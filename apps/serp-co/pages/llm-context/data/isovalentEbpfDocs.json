[
  {
    "owner": "isovalent",
    "repo": "ebpf-docs",
    "content": "TITLE: Defining the bpf_map_lookup_elem Helper Function in C\nDESCRIPTION: This code snippet defines the bpf_map_lookup_elem helper function, which performs a lookup in a map for an entry associated with a given key. It returns the map value associated with the key, or NULL if no entry was found.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_map_lookup_elem.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstatic void *(* const bpf_map_lookup_elem)(void *map, const void *key) = (void *) 1;\n```\n\n----------------------------------------\n\nTITLE: Implementing BPF_PROG_TYPE_CGROUP_SOCKOPT Programs for Socket Option Handling in C\nDESCRIPTION: Example implementation of cgroup sockopt BPF programs that intercept getsockopt and setsockopt syscalls. The getsockopt program can modify returned options, while the setsockopt program can modify or block options before kernel processing. Both programs handle custom socket options, modify kernel options, and deal with large option values.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/program-type/BPF_PROG_TYPE_CGROUP_SOCKOPT.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nSEC(\"cgroup/getsockopt\")\nint getsockopt(struct bpf_sockopt *ctx)\n{\n    /* Custom socket option. */\n    if (ctx->level == MY_SOL && ctx->optname == MY_OPTNAME) {\n        ctx->retval = 0;\n        optval[0] = ...;\n        ctx->optlen = 1;\n        return 1;\n    }\n\n    /* Modify kernel's socket option. */\n    if (ctx->level == SOL_IP && ctx->optname == IP_FREEBIND) {\n        ctx->retval = 0;\n        optval[0] = ...;\n        ctx->optlen = 1;\n        return 1;\n    }\n\n    /* optval larger than PAGE_SIZE use kernel's buffer. */\n    if (ctx->optlen > PAGE_SIZE)\n        ctx->optlen = 0;\n\n    return 1;\n}\n\nSEC(\"cgroup/setsockopt\")\nint setsockopt(struct bpf_sockopt *ctx)\n{\n    /* Custom socket option. */\n    if (ctx->level == MY_SOL && ctx->optname == MY_OPTNAME) {\n        /* do something */\n        ctx->optlen = -1;\n        return 1;\n    }\n\n    /* Modify kernel's socket option. */\n    if (ctx->level == SOL_IP && ctx->optname == IP_FREEBIND) {\n        optval[0] = ...;\n        return 1;\n    }\n\n    /* optval larger than PAGE_SIZE use kernel's buffer. */\n    if (ctx->optlen > PAGE_SIZE)\n        ctx->optlen = 0;\n\n    return 1;\n}\n```\n\n----------------------------------------\n\nTITLE: Unrolling Loops in eBPF with Pragma Directive\nDESCRIPTION: Demonstrates how to use the #pragma unroll directive to unroll loops at compile time in eBPF programs. This technique was the main workaround before Linux v5.3 when bounded loops were not supported.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/concepts/loops.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n#pragma unroll\nfor (int i = 0; i < 10; i++) {\n    // do something\n}\n```\n\n----------------------------------------\n\nTITLE: Using bpf_printk macro in eBPF program\nDESCRIPTION: This example demonstrates how to use the bpf_printk macro in an eBPF program. It shows two cases: one using bpf_trace_printk (with 3 or fewer arguments) and another using bpf_trace_vprintk (with more than 3 arguments).\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/ebpf/bpf_printk.md#2025-04-22_snippet_1\n\nLANGUAGE: c\nCODE:\n```\nSEC(\"tc\")\nint example_prog(struct __sk_buff *ctx)\n{\n    // Will use bpf_trace_printk\n    bpf_printk(\n        \"Got a packet from interface %d, src: %pi4, dst: %pi4\\n\", \n        ctx->ingress_ifindex, \n        ctx->remote_ip4, \n        ctx->local_ip4,\n    );\n\n    // Will use bpf_trace_vprintk\n    bpf_printk(\n        \"Got a packet from interface %d, src: %pi4, dst: %pi4, src port: %d, dst port: %d\\n\", \n        ctx->ingress_ifindex, \n        ctx->remote_ip4, \n        ctx->local_ip4,\n        ctx->remote_port,\n        ctx->local_port,\n    );\n\n    return TC_ACT_OK;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining the bpf_xdp_output eBPF Helper Function Signature in C\nDESCRIPTION: This C code snippet defines the function signature for the `bpf_xdp_output` eBPF helper function. It specifies the return type (`long`), the parameters (`ctx`, `map`, `flags`, `data`, `size`), and assigns it the internal kernel function identifier `121`. This helper is used to write raw data from an eBPF program (specifically `BPF_PROG_TYPE_PERF_EVENT`) to a `BPF_MAP_TYPE_PERF_EVENT_ARRAY` map. It returns 0 on success and a negative error code on failure.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_xdp_output.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n`#!c static long (* const bpf_xdp_output)(void *ctx, void *map, __u64 flags, void *data, __u64 size) = (void *) 121;`\n```\n\n----------------------------------------\n\nTITLE: SKB Dynamic Pointer String Comparison in eBPF\nDESCRIPTION: This code demonstrates how to use dynamic pointers to access SKB data and perform string comparison operations. It shows the usage of bpf_dynptr_from_skb and bpf_dynptr_slice functions, with error handling for NULL cases.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/concepts/dynptrs.md#2025-04-22_snippet_11\n\nLANGUAGE: c\nCODE:\n```\nSEC(\"?cgroup_skb/egress\")\nint test_dynptr_skb_strcmp(struct __sk_buff *skb)\n{\n\tstruct bpf_dynptr ptr;\n\tchar *data;\n\n\tif (bpf_dynptr_from_skb(skb, 0, &ptr)) {\n\t\terr = 1;\n\t\treturn 1;\n\t}\n\n\t/* This may return NULL. SKB may require a buffer */\n\tdata = bpf_dynptr_slice(&ptr, 0, NULL, 10);\n\tif (data) {\n\t\tbpf_strncmp(data, 10, \"foo\");\n\t\treturn 1;\n\t}\n\n\treturn 1;\n}\n```\n\n----------------------------------------\n\nTITLE: Setting NAT Information in Connection Tracking using bpf_ct_set_nat_info kfunc\nDESCRIPTION: This example demonstrates how to use the bpf_ct_set_nat_info kfunc to set source and destination NAT addresses and ports in newly allocated connection tracking entries. The code includes comprehensive error testing and handling scenarios.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/bpf_ct_set_nat_info.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n// SPDX-License-Identifier: GPL-2.0\n#include <vmlinux.h>\n#include <bpf/bpf_helpers.h>\n#include <bpf/bpf_endian.h>\n\n#define EAFNOSUPPORT 97\n#define EPROTO 71\n#define ENONET 64\n#define EINVAL 22\n#define ENOENT 2\n\nextern unsigned long CONFIG_HZ __kconfig;\n\nint test_einval_bpf_tuple = 0;\nint test_einval_reserved = 0;\nint test_einval_netns_id = 0;\nint test_einval_len_opts = 0;\nint test_eproto_l4proto = 0;\nint test_enonet_netns_id = 0;\nint test_enoent_lookup = 0;\nint test_eafnosupport = 0;\nint test_alloc_entry = -EINVAL;\nint test_insert_entry = -EAFNOSUPPORT;\nint test_succ_lookup = -ENOENT;\nu32 test_delta_timeout = 0;\nu32 test_status = 0;\nu32 test_insert_lookup_mark = 0;\nint test_snat_addr = -EINVAL;\nint test_dnat_addr = -EINVAL;\n__be32 saddr = 0;\n__be16 sport = 0;\n__be32 daddr = 0;\n__be16 dport = 0;\nint test_exist_lookup = -ENOENT;\nu32 test_exist_lookup_mark = 0;\n\nenum nf_nat_manip_type___local {\n\tNF_NAT_MANIP_SRC___local,\n\tNF_NAT_MANIP_DST___local\n};\n\nstruct nf_conn;\n\nstruct bpf_ct_opts___local {\n\ts32 netns_id;\n\ts32 error;\n\tu8 l4proto;\n\tu8 reserved[3];\n} __attribute__((preserve_access_index));\n\nstruct nf_conn *bpf_xdp_ct_alloc(struct xdp_md *, struct bpf_sock_tuple *, u32,\n\t\t\t struct bpf_ct_opts___local *, u32) __ksym;\nstruct nf_conn *bpf_xdp_ct_lookup(struct xdp_md *, struct bpf_sock_tuple *, u32,\n\t\t\t  struct bpf_ct_opts___local *, u32) __ksym;\nstruct nf_conn *bpf_skb_ct_alloc(struct __sk_buff *, struct bpf_sock_tuple *, u32,\n\t\t\t struct bpf_ct_opts___local *, u32) __ksym;\nstruct nf_conn *bpf_skb_ct_lookup(struct __sk_buff *, struct bpf_sock_tuple *, u32,\n\t\t\t  struct bpf_ct_opts___local *, u32) __ksym;\nstruct nf_conn *bpf_ct_insert_entry(struct nf_conn *) __ksym;\nvoid bpf_ct_release(struct nf_conn *) __ksym;\nvoid bpf_ct_set_timeout(struct nf_conn *, u32) __ksym;\nint bpf_ct_change_timeout(struct nf_conn *, u32) __ksym;\nint bpf_ct_set_status(struct nf_conn *, u32) __ksym;\nint bpf_ct_change_status(struct nf_conn *, u32) __ksym;\nint bpf_ct_set_nat_info(struct nf_conn *, union nf_inet_addr *,\n\t\t\tint port, enum nf_nat_manip_type___local) __ksym;\n\nstatic __always_inline void\nnf_ct_test(struct nf_conn *(*lookup_fn)(void *, struct bpf_sock_tuple *, u32,\n\t\t\t\t\tstruct bpf_ct_opts___local *, u32),\n\t   struct nf_conn *(*alloc_fn)(void *, struct bpf_sock_tuple *, u32,\n\t\t\t       struct bpf_ct_opts___local *, u32),\n\t   void *ctx)\n{\n\tstruct bpf_ct_opts___local opts_def = { .l4proto = IPPROTO_TCP, .netns_id = -1 };\n\tstruct bpf_sock_tuple bpf_tuple;\n\tstruct nf_conn *ct;\n\n\t__builtin_memset(&bpf_tuple, 0, sizeof(bpf_tuple.ipv4));\n\n\tct = lookup_fn(ctx, NULL, 0, &opts_def, sizeof(opts_def));\n\tif (ct)\n\t\tbpf_ct_release(ct);\n\telse\n\t\ttest_einval_bpf_tuple = opts_def.error;\n\n\topts_def.reserved[0] = 1;\n\tct = lookup_fn(ctx, &bpf_tuple, sizeof(bpf_tuple.ipv4), &opts_def,\n\t\t       sizeof(opts_def));\n\topts_def.reserved[0] = 0;\n\topts_def.l4proto = IPPROTO_TCP;\n\tif (ct)\n\t\tbpf_ct_release(ct);\n\telse\n\t\ttest_einval_reserved = opts_def.error;\n\n\topts_def.netns_id = -2;\n\tct = lookup_fn(ctx, &bpf_tuple, sizeof(bpf_tuple.ipv4), &opts_def,\n\t\t       sizeof(opts_def));\n\topts_def.netns_id = -1;\n\tif (ct)\n\t\tbpf_ct_release(ct);\n\telse\n\t\ttest_einval_netns_id = opts_def.error;\n\n\tct = lookup_fn(ctx, &bpf_tuple, sizeof(bpf_tuple.ipv4), &opts_def,\n\t\t       sizeof(opts_def) - 1);\n\tif (ct)\n\t\tbpf_ct_release(ct);\n\telse\n\t\ttest_einval_len_opts = opts_def.error;\n\n\topts_def.l4proto = IPPROTO_ICMP;\n\tct = lookup_fn(ctx, &bpf_tuple, sizeof(bpf_tuple.ipv4), &opts_def,\n\t\t       sizeof(opts_def));\n\topts_def.l4proto = IPPROTO_TCP;\n\tif (ct)\n\t\tbpf_ct_release(ct);\n\telse\n\t\ttest_eproto_l4proto = opts_def.error;\n\n\topts_def.netns_id = 0xf00f;\n\tct = lookup_fn(ctx, &bpf_tuple, sizeof(bpf_tuple.ipv4), &opts_def,\n\t\t       sizeof(opts_def));\n\topts_def.netns_id = -1;\n\tif (ct)\n\t\tbpf_ct_release(ct);\n\telse\n\t\ttest_enonet_netns_id = opts_def.error;\n\n\tct = lookup_fn(ctx, &bpf_tuple, sizeof(bpf_tuple.ipv4), &opts_def,\n\t\t       sizeof(opts_def));\n\tif (ct)\n\t\tbpf_ct_release(ct);\n\telse\n\t\ttest_enoent_lookup = opts_def.error;\n\n\tct = lookup_fn(ctx, &bpf_tuple, sizeof(bpf_tuple.ipv4) - 1, &opts_def,\n\t\t       sizeof(opts_def));\n\tif (ct)\n\t\tbpf_ct_release(ct);\n\telse\n\t\ttest_eafnosupport = opts_def.error;\n\n\tbpf_tuple.ipv4.saddr = bpf_get_prandom_u32(); /* src IP */\n\tbpf_tuple.ipv4.daddr = bpf_get_prandom_u32(); /* dst IP */\n\tbpf_tuple.ipv4.sport = bpf_get_prandom_u32(); /* src port */\n\tbpf_tuple.ipv4.dport = bpf_get_prandom_u32(); /* dst port */\n\n\tct = alloc_fn(ctx, &bpf_tuple, sizeof(bpf_tuple.ipv4), &opts_def,\n\t\t      sizeof(opts_def));\n\tif (ct) {\n\t\t__u16 sport = bpf_get_prandom_u32();\n\t\t__u16 dport = bpf_get_prandom_u32();\n\t\tunion nf_inet_addr saddr = {};\n\t\tunion nf_inet_addr daddr = {};\n\t\tstruct nf_conn *ct_ins;\n\n\t\tbpf_ct_set_timeout(ct, 10000);\n\t\tct->mark = 77;\n\n\t\t/* snat */\n\t\tsaddr.ip = bpf_get_prandom_u32();\n\t\tbpf_ct_set_nat_info(ct, &saddr, sport, NF_NAT_MANIP_SRC___local);\n\t\t/* dnat */\n\t\tdaddr.ip = bpf_get_prandom_u32();\n\t\tbpf_ct_set_nat_info(ct, &daddr, dport, NF_NAT_MANIP_DST___local);\n\n\t\tct_ins = bpf_ct_insert_entry(ct);\n\t\tif (ct_ins) {\n\t\t\tstruct nf_conn *ct_lk;\n\n\t\t\tct_lk = lookup_fn(ctx, &bpf_tuple, sizeof(bpf_tuple.ipv4),\n\t\t\t\t\t  &opts_def, sizeof(opts_def));\n\t\t\tif (ct_lk) {\n\t\t\t\tstruct nf_conntrack_tuple *tuple;\n\n\t\t\t\t/* check snat and dnat addresses */\n\t\t\t\ttuple = &ct_lk->tuplehash[IP_CT_DIR_REPLY].tuple;\n\t\t\t\tif (tuple->dst.u3.ip == saddr.ip &&\n\t\t\t\t    tuple->dst.u.all == bpf_htons(sport))\n\t\t\t\t\ttest_snat_addr = 0;\n\t\t\t\tif (tuple->src.u3.ip == daddr.ip &&\n\t\t\t\t    tuple->src.u.all == bpf_htons(dport))\n\t\t\t\t\ttest_dnat_addr = 0;\n\n\t\t\t\t/* update ct entry timeout */\n\t\t\t\tbpf_ct_change_timeout(ct_lk, 10000);\n\t\t\t\ttest_delta_timeout = ct_lk->timeout - bpf_jiffies64();\n\t\t\t\ttest_delta_timeout /= CONFIG_HZ;\n\t\t\t\ttest_insert_lookup_mark = ct_lk->mark;\n\t\t\t\tbpf_ct_change_status(ct_lk,\n\t\t\t\t\t\t\t IPS_CONFIRMED | IPS_SEEN_REPLY);\n\t\t\t\ttest_status = ct_lk->status;\n\n\t\t\t\tbpf_ct_release(ct_lk);\n\t\t\t\ttest_succ_lookup = 0;\n\t\t\t}\n\t\t\tbpf_ct_release(ct_ins);\n\t\t\ttest_insert_entry = 0;\n\t\t}\n\t\ttest_alloc_entry = 0;\n\t}\n\n\tbpf_tuple.ipv4.saddr = saddr;\n\tbpf_tuple.ipv4.daddr = daddr;\n\tbpf_tuple.ipv4.sport = sport;\n\tbpf_tuple.ipv4.dport = dport;\n\tct = lookup_fn(ctx, &bpf_tuple, sizeof(bpf_tuple.ipv4), &opts_def,\n\t\t       sizeof(opts_def));\n\tif (ct) {\n\t\ttest_exist_lookup = 0;\n\t\tif (ct->mark == 42) {\n\t\t\tct->mark++;\n\t\t\ttest_exist_lookup_mark = ct->mark;\n\t\t}\n\t\tbpf_ct_release(ct);\n\t} else {\n\t\ttest_exist_lookup = opts_def.error;\n\t}\n}\n\nSEC(\"xdp\")\nint nf_xdp_ct_test(struct xdp_md *ctx)\n{\n\tnf_ct_test((void *)bpf_xdp_ct_lookup, (void *)bpf_xdp_ct_alloc, ctx);\n\treturn 0;\n}\n\nSEC(\"tc\")\nint nf_skb_ct_test(struct __sk_buff *ctx)\n{\n\tnf_ct_test((void *)bpf_skb_ct_lookup, (void *)bpf_skb_ct_alloc, ctx);\n\treturn 0;\n}\n\nchar _license[] SEC(\"license\") = \"GPL\";\n```\n\n----------------------------------------\n\nTITLE: Reading and Writing with Dynamic Pointers in eBPF using C\nDESCRIPTION: This code snippet uses eBPF helper functions to reserve, write to, read from, and submit a dynamic pointer within a ring-buffer. It demonstrates an example of writing a message to the buffer and verifying the read operation matches the written data. Dependencies include importing relevant eBPF functions like bpf_ringbuf_reserve_dynptr and bpf_dynptr_write. The inputs are the data to be reserved and written, and the output is the availability of that data in userspace or its dismissal. A specific constraint is the necessity to use helper functions for reading and writing as direct access is not permitted.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/map-type/BPF_MAP_TYPE_RINGBUF.md#2025-04-22_snippet_3\n\nLANGUAGE: c\nCODE:\n```\n// SPDX-License-Identifier: GPL-2.0\n/* Copyright (c) 2022 Facebook */\n\nSEC(\"?tp/syscalls/sys_enter_nanosleep\")\nint test_read_write(void *ctx)\n{\n    char write_data[64] = \"hello there, world!!\";\n    char read_data[64] = {};\n    struct bpf_dynptr ptr;\n    int i;\n\n    if (bpf_get_current_pid_tgid() >> 32 != pid)\n        return 0;\n\n    bpf_ringbuf_reserve_dynptr(&ringbuf, sizeof(write_data), 0, &ptr);\n\n    /* Write data into the dynptr */\n    err = bpf_dynptr_write(&ptr, 0, write_data, sizeof(write_data), 0);\n\n    /* Read the data that was written into the dynptr */\n    err = err ?: bpf_dynptr_read(read_data, sizeof(read_data), &ptr, 0, 0);\n\n    /* Ensure the data we read matches the data we wrote */\n    for (i = 0; i < sizeof(read_data); i++) {\n        if (read_data[i] != write_data[i]) {\n            err = 1;\n            break;\n        }\n    }\n\n    bpf_ringbuf_submit_dynptr(&ptr, 0);\n    return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining eBPF Map Macros in C\nDESCRIPTION: Defines macros used for easier type definition in BTF-style eBPF maps. These macros help in creating more readable map definitions.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/concepts/maps.md#2025-04-22_snippet_2\n\nLANGUAGE: C\nCODE:\n```\n#define __uint(name, val) int (*name)[val]\n#define __type(name, val) typeof(val) *name\n#define __array(name, val) typeof(val) *name[]\n#define __ulong(name, val) enum { ___bpf_concat(__unique_value, __COUNTER__) = val } name\n```\n\n----------------------------------------\n\nTITLE: Function Definition - bpf_prog_load\nDESCRIPTION: Main function definition for loading BPF programs with parameters for program type, name, license, instructions, and loading options.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_prog_load.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nint bpf_prog_load(enum bpf_prog_type prog_type, const char *prog_name, const char *license, const struct bpf_insn *insns, size_t insn_cnt, struct bpf_prog_load_opts *opts);\n```\n\n----------------------------------------\n\nTITLE: Example Usage of bpf_for_each_map_elem in eBPF Programs\nDESCRIPTION: A complete example showing how to use bpf_for_each_map_elem with a callback function to iterate through map elements and conditionally delete odd-keyed entries while maintaining context between callbacks.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_for_each_map_elem.md#2025-04-22_snippet_2\n\nLANGUAGE: c\nCODE:\n```\nstatic long callback_fn(struct bpf_map *map, const void *key, void *value, void *ctx)\n{\n    bpf_printk(\"context value: %s\\n\", *(char **)ctx);\n    // delete elements with an odd key\n    if (*(__u32 *)key % 2)\n        bpf_map_delete_elem(map, key);\n    return 0;\n}\n\nint program(void *ctx)\n{\n    /*\n        .\n        .\n        .\n    */\n\n    char *context = \"This string will pass to every callback call\";\n    long (*cb_p)(struct bpf_map *, const void *, void *, void *) = &callback_fn;\n    bpf_for_each_map_elem(&my_map, cb_p, &context, 0);\n}\n```\n\n----------------------------------------\n\nTITLE: Using Atomic Operations in eBPF to Count System Calls\nDESCRIPTION: This example demonstrates how to use atomic operations to safely increment a counter in a shared variable. The __sync_fetch_and_add atomic function is used to count the number of times the sys_enter tracepoint is called.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/concepts/concurrency.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nint counter = 0;\n\nSEC(\"tp_btf/sys_enter\")\nint sys_enter_count(void *ctx) {\n\t__sync_fetch_and_add(&counter, 1);\n\treturn 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Using SEC macro with XDP program in C\nDESCRIPTION: This example demonstrates how to use the SEC macro to place an XDP program in the 'xdp' section. The program examines Ethernet headers and passes IPv4 packets while dropping malformed packets that don't have complete headers.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/ebpf/SEC.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nSEC(\"xdp\")\nint example_prog(struct xdp_md *ctx)\n{\n    void *data_end = (void *)(long)ctx->data_end;\n    void *data = (void *)(long)ctx->data;\n\n    if (data + sizeof(struct ethhdr) > data_end)\n        return XDP_DROP;\n\n    struct ethhdr *eth = data;\n    if (eth->h_proto == htons(ETH_P_IP))\n        return XDP_PASS;\n}\n```\n\n----------------------------------------\n\nTITLE: Modifying HID Data with eBPF Fmodify_return Hooks (C)\nDESCRIPTION: This C code demonstrates using 'fmod_ret' (fmodify_return) eBPF programs to modify Human Interface Device (HID) data. It includes three separate BPF programs: 'hid_y_event' and 'hid_x_event' attach to 'hid_bpf_device_event' to negate the Y and X axis values respectively within HID event data retrieved using 'hid_bpf_get_data'. The 'hid_rdesc_fixup' program attaches to 'hid_bpf_rdesc_fixup' to modify the HID report descriptor, swapping the X and Y axis usages. Debug output is generated using 'bpf_printk'. Dependencies include 'vmlinux.h', 'bpf/bpf_helpers.h', 'bpf/bpf_tracing.h', and 'hid_bpf_helpers.h'.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/program-type/BPF_PROG_TYPE_TRACING.md#2025-04-22_snippet_4\n\nLANGUAGE: c\nCODE:\n```\n// SPDX-License-Identifier: GPL-2.0\n\n#include \"vmlinux.h\"\n#include <bpf/bpf_helpers.h>\n#include <bpf/bpf_tracing.h>\n#include \"hid_bpf_helpers.h\"\n\nSEC(\"fmod_ret/hid_bpf_device_event\")\nint BPF_PROG(hid_y_event, struct hid_bpf_ctx *hctx)\n{\n    s16 y;\n    __u8 *data = hid_bpf_get_data(hctx, 0 /* offset */, 9 /* size */);\n\n    if (!data)\n        return 0; /* EPERM check */\n\n    bpf_printk(\"event: size: %d\", hctx->size);\n    bpf_printk(\"incoming event: %02x %02x %02x\",\n        data[0],\n        data[1],\n        data[2]);\n    bpf_printk(\"                %02x %02x %02x\",\n        data[3],\n        data[4],\n        data[5]);\n    bpf_printk(\"                %02x %02x %02x\",\n        data[6],\n        data[7],\n        data[8]);\n\n    y = data[3] | (data[4] << 8);\n\n    y = -y;\n\n    data[3] = y & 0xFF;\n    data[4] = (y >> 8) & 0xFF;\n\n    bpf_printk(\"modified event: %02x %02x %02x\",\n        data[0],\n        data[1],\n        data[2]);\n    bpf_printk(\"                %02x %02x %02x\",\n        data[3],\n        data[4],\n        data[5]);\n    bpf_printk(\"                %02x %02x %02x\",\n        data[6],\n        data[7],\n        data[8]);\n\n    return 0;\n}\n\nSEC(\"fmod_ret/hid_bpf_device_event\")\nint BPF_PROG(hid_x_event, struct hid_bpf_ctx *hctx)\n{\n    s16 x;\n    __u8 *data = hid_bpf_get_data(hctx, 0 /* offset */, 9 /* size */);\n\n    if (!data)\n        return 0; /* EPERM check */\n\nx = data[1] | (data[2] << 8);\n\n    x = -x;\n\n    data[1] = x & 0xFF;\n    data[2] = (x >> 8) & 0xFF;\n    return 0;\n}\n\nSEC(\"fmod_ret/hid_bpf_rdesc_fixup\")\nint BPF_PROG(hid_rdesc_fixup, struct hid_bpf_ctx *hctx)\n{\n    __u8 *data = hid_bpf_get_data(hctx, 0 /* offset */, 4096 /* size */);\n\n    if (!data)\n        return 0; /* EPERM check */\n\n    bpf_printk(\"rdesc: %02x %02x %02x\",\n        data[0],\n        data[1],\n        data[2]);\n    bpf_printk(\"       %02x %02x %02x\",\n        data[3],\n        data[4],\n        data[5]);\n    bpf_printk(\"       %02x %02x %02x ...\",\n        data[6],\n        data[7],\n        data[8]);\n\n    /*\n    * The original report descriptor contains:\n    *\n    * 0x05, 0x01,                    //   Usage Page (Generic Desktop)      30\n    * 0x16, 0x01, 0x80,              //   Logical Minimum (-32767)          32\n    * 0x26, 0xff, 0x7f,              //   Logical Maximum (32767)           35\n    * 0x09, 0x30,                    //   Usage (X)                         38\n    * 0x09, 0x31,                    //   Usage (Y)                         40\n    *\n    * So byte 39 contains Usage X and byte 41 Usage Y.\n    *\n    * We simply swap the axes here.\n    */\n    data[39] = 0x31;\n    data[41] = 0x30;\n\n    return 0;\n}\n\nchar _license[] SEC(\"license\") = \"GPL\";\n```\n\n----------------------------------------\n\nTITLE: Using bpf_ringbuf_reserve in eBPF Programs\nDESCRIPTION: This example demonstrates how to use the 'bpf_ringbuf_reserve' function in an eBPF program. It reserves memory in a ring buffer for a struct, checks if the reservation was successful, and handles the failure case by printing an error message.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_ringbuf_reserve.md#2025-04-22_snippet_1\n\nLANGUAGE: c\nCODE:\n```\nstruct ringbuf_data *rb_data = bpf_ringbuf_reserve(&my_ringbuf, sizeof(struct ringbuf_data), 0);\nif (! rb_data) {\n    // if bpf_ringbuf_reserve fails, print an error message and return\n    bpf_printk(\"bpf_ringbuf_reserve failed\\n\");\n    return 1;\n}\n```\n\n----------------------------------------\n\nTITLE: Redirecting Socket Messages Using eBPF Maps - C\nDESCRIPTION: This C eBPF program demonstrates how to classify and redirect messages within a socket message context. It uses sockmap and sockhash maps for redirection and an array map to count verdicts. Dependencies include the Linux eBPF subsystem, kernel helpers (e.g., bpf_msg_redirect_map/bpf_msg_redirect_hash, bpf_map_lookup_elem), and properly initialized BPF maps. The function receives a sk_msg_md pointer, decides redirect target based on a runtime flag, updates the verdict map, and returns a SK_PASS/SK_DROP verdict.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/program-type/BPF_PROG_TYPE_SK_MSG.md#2025-04-22_snippet_1\n\nLANGUAGE: c\nCODE:\n```\n// Copyright (c) 2020 Cloudflare\n\nstruct {\n\t__uint(type, BPF_MAP_TYPE_SOCKMAP);\n\t__uint(max_entries, 2);\n\t__type(key, __u32);\n\t__type(value, __u64);\n} sock_map SEC(\".maps\");\n\nstruct {\n\t__uint(type, BPF_MAP_TYPE_SOCKHASH);\n\t__uint(max_entries, 2);\n\t__type(key, __u32);\n\t__type(value, __u64);\n} sock_hash SEC(\".maps\");\n\nstruct {\n\t__uint(type, BPF_MAP_TYPE_ARRAY);\n\t__uint(max_entries, 2);\n\t__type(key, int);\n\t__type(value, unsigned int);\n} verdict_map SEC(\".maps\");\n\nSEC(\"sk_msg\")\nint prog_msg_verdict(struct sk_msg_md *msg)\n{\n\tunsigned int *count;\n\t__u32 zero = 0;\n\tint verdict;\n\n\tif (test_sockmap)\n\t\tverdict = bpf_msg_redirect_map(msg, &sock_map, zero, 0);\n\telse\n\t\tverdict = bpf_msg_redirect_hash(msg, &sock_hash, &zero, 0);\n\n\tcount = bpf_map_lookup_elem(&verdict_map, &verdict);\n\tif (count)\n\t\t(*count)++;\n\n\treturn verdict;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Socket Redirection with BPF_PROG_TYPE_SK_LOOKUP in C\nDESCRIPTION: This C eBPF program demonstrates the use of 'BPF_PROG_TYPE_SK_LOOKUP'. It defines a sockmap ('redir_map') to store target sockets. The program intercepts incoming connections/packets, checks if they match a specific destination IP (127.0.0.1) and port (7007) for the AF_INET family. If a match occurs, it retrieves a target socket from the 'redir_map' using a predefined key and uses the 'bpf_sk_assign' helper to redirect the traffic to that socket. It relies on eBPF helpers like 'bpf_map_lookup_elem', 'bpf_sk_assign', and 'bpf_sk_release'.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/program-type/BPF_PROG_TYPE_SK_LOOKUP.md#2025-04-22_snippet_1\n\nLANGUAGE: c\nCODE:\n```\n// Copyright (c) 2020 Cloudflare\nstruct {\n\t__uint(type, BPF_MAP_TYPE_SOCKMAP);\n\t__uint(max_entries, 32);\n\t__type(key, __u32);\n\t__type(value, __u64);\n} redir_map SEC(\".maps\");\n\nstatic const __u16 DST_PORT = 7007; /* Host byte order */\nstatic const __u32 DST_IP4 = IP4(127, 0, 0, 1);\nstatic const __u32 KEY_SERVER_A = 0;\n\n/* Redirect packets destined for DST_IP4 address to socket at redir_map[0]. */\nSEC(\"sk_lookup\")\nint redir_ip4(struct bpf_sk_lookup *ctx)\n{\n\tstruct bpf_sock *sk;\n\tint err;\n\n\tif (ctx->family != AF_INET)\n\t\treturn SK_PASS;\n\tif (ctx->local_port != DST_PORT)\n\t\treturn SK_PASS;\n\tif (ctx->local_ip4 != DST_IP4)\n\t\treturn SK_PASS;\n\n\tsk = bpf_map_lookup_elem(&redir_map, &KEY_SERVER_A);\n\tif (!sk)\n\t\treturn SK_PASS;\n\n\terr = bpf_sk_assign(ctx, sk, 0);\n\tbpf_sk_release(sk);\n\treturn err ? SK_DROP : SK_PASS;\n}\n```\n\n----------------------------------------\n\nTITLE: Simple Static Log Message with bpf_trace_printk (eBPF, C)\nDESCRIPTION: Example of printing a constant log message from within an eBPF program using a statically allocated format string. This ensures compatibility with eBPF's restrictions and writes 'some log' to the kernel trace output. Requires declaration of the helper as previously documented.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_trace_printk.md#2025-04-22_snippet_4\n\nLANGUAGE: c\nCODE:\n```\nstatic const char fmt[] = \"some log\"; \nbpf_trace_printk(fmt, sizeof(fmt));\n```\n\n----------------------------------------\n\nTITLE: Definition of bpf_perf_event_output Helper Function\nDESCRIPTION: Defines the bpf_perf_event_output function prototype that writes data to a perf event array. Takes context, map, flags, data pointer and size as parameters. Returns 0 on success or negative error code on failure.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_perf_event_output.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstatic long (* const bpf_perf_event_output)(void *ctx, void *map, __u64 flags, void *data, __u64 size) = (void *) 25;\n```\n\n----------------------------------------\n\nTITLE: Enumerating TCP Congestion Algorithm State with tcp_ca_state (C)\nDESCRIPTION: This enum documents recognized sender congestion states driving TCP behavior, covering normal, loss, recovery, window reduction, and disorder handling. Each value represents a critical status used by congestion control algorithms to guide their adaptation logic in response to network feedback events. Dependencies: TCP ACK processing loops and congestion logic.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/program-type/BPF_PROG_TYPE_STRUCT_OPS/tcp_congestion_ops.md#2025-04-22_snippet_12\n\nLANGUAGE: c\nCODE:\n```\nenum tcp_ca_state {\n\tTCP_CA_Open     = 0,\n\tTCP_CA_Disorder = 1,\n\tTCP_CA_CWR      = 2,\n\tTCP_CA_Recovery = 3,\n\tTCP_CA_Loss     = 4\n};\n```\n\n----------------------------------------\n\nTITLE: Clamping TCP Connection Window using eBPF sockops in C\nDESCRIPTION: This eBPF C program, attached to the `sockops` hook, modifies TCP socket behavior based on connection parameters and state. It checks if IPv6 endpoints are within the same subnet and adjusts socket options like send/receive buffer sizes (`SO_SNDBUF`, `SO_RCVBUF`) and the TCP send congestion window clamp (`TCP_BPF_SNDCWND_CLAMP`) using the `bpf_setsockopt` helper. The logic triggers differently based on the `bpf_sock_ops` operation type (e.g., `BPF_SOCK_OPS_TCP_CONNECT_CB`, `BPF_SOCK_OPS_ACTIVE_ESTABLISHED_CB`). A port-based check (55601) is included for testing purposes.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/program-type/BPF_PROG_TYPE_SOCK_OPS.md#2025-04-22_snippet_3\n\nLANGUAGE: c\nCODE:\n```\n// Copyright (c) 2017 Facebook\n#define DEBUG 1\n\nSEC(\"sockops\")\nint bpf_clamp(struct bpf_sock_ops *skops)\n{\n    int bufsize = 150000;\n    int to_init = 10;\n    int clamp = 100;\n    int rv = 0;\n    int op;\n\n    /* For testing purposes, only execute rest of BPF program\n    * if neither port numberis 55601\n    */\n    if (bpf_ntohl(skops->remote_port) != 55601 && skops->local_port != 55601) {\n        skops->reply = -1;\n        return 0;\n    }\n\n    op = (int) skops->op;\n\n#ifdef DEBUG\n    bpf_printk(\"BPF command: %d\\n\", op);\n#endif\n\n    /* Check that both hosts are within same datacenter. For this example\n    * it is the case when the first 5.5 bytes of their IPv6 addresses are\n    * the same.\n    */\n    if (skops->family == AF_INET6 &&\n        skops->local_ip6[0] == skops->remote_ip6[0] &&\n        (bpf_ntohl(skops->local_ip6[1]) & 0xfff00000) ==\n        (bpf_ntohl(skops->remote_ip6[1]) & 0xfff00000)) {\n        switch (op) {\n        case BPF_SOCK_OPS_TIMEOUT_INIT:\n            rv = to_init;\n            break;\n        case BPF_SOCK_OPS_TCP_CONNECT_CB:\n            /* Set sndbuf and rcvbuf of active connections */\n            rv = bpf_setsockopt(skops, SOL_SOCKET, SO_SNDBUF,\n                        &bufsize, sizeof(bufsize));\n            rv += bpf_setsockopt(skops, SOL_SOCKET,\n                        SO_RCVBUF, &bufsize,\n                        sizeof(bufsize));\n            break;\n        case BPF_SOCK_OPS_ACTIVE_ESTABLISHED_CB:\n            rv = bpf_setsockopt(skops, SOL_TCP,\n                        TCP_BPF_SNDCWND_CLAMP,\n                        &clamp, sizeof(clamp));\n            break;\n        case BPF_SOCK_OPS_PASSIVE_ESTABLISHED_CB:\n            /* Set sndbuf and rcvbuf of passive connections */\n            rv = bpf_setsockopt(skops, SOL_TCP,\n                        TCP_BPF_SNDCWND_CLAMP,\n                        &clamp, sizeof(clamp));\n            rv += bpf_setsockopt(skops, SOL_SOCKET,\n                        SO_SNDBUF, &bufsize,\n                        sizeof(bufsize));\n            rv += bpf_setsockopt(skops, SOL_SOCKET,\n                        SO_RCVBUF, &bufsize,\n                        sizeof(bufsize));\n            break;\n        default:\n            rv = -1;\n        }\n    } else {\n        rv = -1;\n    }\n#ifdef DEBUG\n    bpf_printk(\"Returning %d\\n\", rv);\n#endif\n    skops->reply = rv;\n    return 1;\n}\n\n```\n\n----------------------------------------\n\nTITLE: Implementing a Memory Protection Security Audit with LSM eBPF Program\nDESCRIPTION: This code snippet demonstrates an LSM eBPF program that attaches to the file_mprotect hook to audit and potentially block memory protection changes. It specifically checks if the memory area is in the heap region and returns an error (-EPERM) to block the operation if true.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/program-type/BPF_PROG_TYPE_LSM.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n// Copyright (C) 2020 Google LLC.\nSEC(\"lsm/file_mprotect\")\nint BPF_PROG(mprotect_audit, struct vm_area_struct *vma,\n            unsigned long reqprot, unsigned long prot, int ret)\n{\n    /* ret is the return value from the previous BPF program\n        * or 0 if it's the first hook.\n        */\n    if (ret != 0)\n        return ret;\n\n    int is_heap;\n\n    is_heap = (vma->vm_start >= vma->vm_mm->start_brk &&\n            vma->vm_end <= vma->vm_mm->brk);\n\n    /* Return an -EPERM or write information to the perf events buffer\n        * for auditing\n        */\n    if (is_heap)\n        return -EPERM;\n}\n```\n\n----------------------------------------\n\nTITLE: Complete LPM Trie Map Implementation Example\nDESCRIPTION: Comprehensive example showing how to define, initialize and use an IPv4 LPM Trie map in eBPF, including the map declaration with BPF_F_NO_PREALLOC flag and a lookup function.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/map-type/BPF_MAP_TYPE_LPM_TRIE.md#2025-04-22_snippet_3\n\nLANGUAGE: c\nCODE:\n```\n#include <linux/bpf.h>\n#include <bpf/bpf_helpers.h>\n\nstruct ipv4_lpm_key {\n        __u32 prefixlen;\n        __u32 data;\n};\n\nstruct {\n        __uint(type, BPF_MAP_TYPE_LPM_TRIE);\n        __type(key, struct ipv4_lpm_key);\n        __type(value, __u32);\n        __uint(map_flags, BPF_F_NO_PREALLOC);\n        __uint(max_entries, 255);\n} ipv4_lpm_map SEC(\".maps\");\n\nvoid *lookup(__u32 ipaddr)\n{\n        struct ipv4_lpm_key key = {\n                .prefixlen = 32,\n                .data = ipaddr\n        };\n\n        return bpf_map_lookup_elem(&ipv4_lpm_map, &key);\n}\n\n```\n\n----------------------------------------\n\nTITLE: Reading and Writing Dynamic Pointers in eBPF\nDESCRIPTION: Demonstrates reserving a ringbuf-backed dynamic pointer, writing data to it, reading data back, and comparing the values to ensure correctness. This showcases the basic dynptr read/write operations.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/concepts/dynptrs.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nSEC(\"?tp/syscalls/sys_enter_nanosleep\")\nint test_read_write(void *ctx)\n{\n\tchar write_data[64] = \"hello there, world!!\";\n\tchar read_data[64] = {};\n\tstruct bpf_dynptr ptr;\n\tint i;\n\n\tif (bpf_get_current_pid_tgid() >> 32 != pid)\n\t\treturn 0;\n\n\tbpf_ringbuf_reserve_dynptr(&ringbuf, sizeof(write_data), 0, &ptr);\n\n\t/* Write data into the dynptr */\n\terr = bpf_dynptr_write(&ptr, 0, write_data, sizeof(write_data), 0);\n\n\t/* Read the data that was written into the dynptr */\n\terr = err ?: bpf_dynptr_read(read_data, sizeof(read_data), &ptr, 0, 0);\n\n\t/* Ensure the data we read matches the data we wrote */\n\tfor (i = 0; i < sizeof(read_data); i++) {\n\t\tif (read_data[i] != write_data[i]) {\n\t\t\terr = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tbpf_ringbuf_discard_dynptr(&ptr, 0);\n\treturn 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Example Structure and Using bpf_core_read\nDESCRIPTION: Demonstrates how to use the bpf_core_read macro with a structure to access nested fields. This snippet explains the proper usage of the macro to read kernel structure members by providing an example input structure and the steps to obtain a specific nested value without manual offset calculations.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/ebpf/bpf_core_read.md#2025-04-22_snippet_1\n\nLANGUAGE: C\nCODE:\n```\nstruct some_value dst;\\nbpf_core_read(&dst, sizeof(dst), a.c.d);\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_sk_storage_get Helper Function in C\nDESCRIPTION: This snippet defines the bpf_sk_storage_get helper function, which retrieves a bpf-local-storage from a socket. It takes a map, socket, value, and flags as parameters and returns a pointer to the storage or NULL if not found or on error.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_sk_storage_get.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstatic void *(* const bpf_sk_storage_get)(void *map, void *sk, void *value, __u64 flags) = (void *) 107;\n```\n\n----------------------------------------\n\nTITLE: Implementing BPF Cgroup Connection and Address Rewriting Hooks in C\nDESCRIPTION: This C code snippet showcases eBPF programs for `cgroup/connect4`, `cgroup/getsockname4`, and `cgroup/getpeername4` hooks, demonstrating service redirection. The `connect4` function forces the local bind address to `127.0.0.1:22222` using `bpf_bind` and redirects connection attempts to `1.2.3.4:60000` towards `127.0.0.1:60123`, storing the original destination in a `BPF_MAP_TYPE_SK_STORAGE` map (`service_mapping`). The `getsockname4` and `getpeername4` functions then use this stored information to rewrite the local and peer addresses respectively, effectively masking the redirection from the application's perspective. Depends on Linux headers, BPF helpers, and potentially a custom `bpf_sockopt_helpers.h`.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/program-type/BPF_PROG_TYPE_CGROUP_SOCK_ADDR.md#2025-04-22_snippet_2\n\nLANGUAGE: c\nCODE:\n```\n// SPDX-License-Identifier: GPL-2.0\n#include <string.h>\n#include <stdbool.h>\n\n#include <linux/bpf.h>\n#include <linux/in.h>\n#include <linux/in6.h>\n#include <sys/socket.h>\n\n#include <bpf/bpf_helpers.h>\n#include <bpf/bpf_endian.h>\n\n#include <bpf_sockopt_helpers.h>\n\nchar _license[] SEC(\"license\") = \"GPL\";\n\nstruct svc_addr {\n    __be32 addr;\n    __be16 port;\n};\n\nstruct {\n    __uint(type, BPF_MAP_TYPE_SK_STORAGE);\n    __uint(map_flags, BPF_F_NO_PREALLOC);\n    __type(key, int);\n    __type(value, struct svc_addr);\n} service_mapping SEC(\".maps\");\n\nSEC(\"cgroup/connect4\")\nint connect4(struct bpf_sock_addr *ctx)\n{\n    struct sockaddr_in sa = {};\n    struct svc_addr *orig;\n\n    /* Force local address to 127.0.0.1:22222. */\n    sa.sin_family = AF_INET;\n    sa.sin_port = bpf_htons(22222);\n    sa.sin_addr.s_addr = bpf_htonl(0x7f000001);\n\n    if (bpf_bind(ctx, (struct sockaddr *)&sa, sizeof(sa)) != 0)\n        return 0;\n\n    /* Rewire service 1.2.3.4:60000 to backend 127.0.0.1:60123. */\n    if (ctx->user_port == bpf_htons(60000)) {\n        orig = bpf_sk_storage_get(&service_mapping, ctx->sk, 0,\n                    BPF_SK_STORAGE_GET_F_CREATE);\n        if (!orig)\n            return 0;\n\n        orig->addr = ctx->user_ip4;\n        orig->port = ctx->user_port;\n\n        ctx->user_ip4 = bpf_htonl(0x7f000001);\n        ctx->user_port = bpf_htons(60123);\n    }\n    return 1;\n}\n\nSEC(\"cgroup/getsockname4\")\nint getsockname4(struct bpf_sock_addr *ctx)\n{\n    if (!get_set_sk_priority(ctx))\n        return 1;\n\n    /* Expose local server as 1.2.3.4:60000 to client. */\n    if (ctx->user_port == bpf_htons(60123)) {\n        ctx->user_ip4 = bpf_htonl(0x01020304);\n        ctx->user_port = bpf_htons(60000);\n    }\n    return 1;\n}\n\nSEC(\"cgroup/getpeername4\")\nint getpeername4(struct bpf_sock_addr *ctx)\n{\n    struct svc_addr *orig;\n\n    if (!get_set_sk_priority(ctx))\n        return 1;\n\n    /* Expose service 1.2.3.4:60000 as peer instead of backend. */\n    if (ctx->user_port == bpf_htons(60123)) {\n        orig = bpf_sk_storage_get(&service_mapping, ctx->sk, 0, 0);\n        if (orig) {\n            ctx->user_ip4 = orig->addr;\n            ctx->user_port = orig->port;\n        }\n    }\n    return 1;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_ktime_get_ns Helper Function in C\nDESCRIPTION: This snippet defines the bpf_ktime_get_ns helper function, which returns the time elapsed since system boot in nanoseconds, excluding time the system was suspended.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_ktime_get_ns.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstatic __u64 (* const bpf_ktime_get_ns)(void) = (void *) 5;\n```\n\n----------------------------------------\n\nTITLE: Implementing Cgroup Egress Bandwidth Limiting with eBPF in C\nDESCRIPTION: This C code defines an eBPF program (`_hbm_out_cg`) attached to the `cgroup_skb/egress` hook using the `SEC` macro. It implements a host bandwidth manager using a virtual queue based on credits and time (Earliest Departure Time - EDT). The program calculates packet departure times based on the configured rate, applies ECN marking or drops packets based on credit thresholds (differentiating large/small packets), and potentially triggers TCP Congestion Window Reduction (CWR). It interacts with eBPF maps (`queue_stats` for configuration/stats, `queue_state` for per-CPU queue state) via helpers like `bpf_map_lookup_elem` and `bpf_get_local_storage`, uses `bpf_spin_lock`/`bpf_spin_unlock` for synchronization, and includes logic to optionally ignore loopback traffic. Dependencies include `hbm_kern.h` and standard eBPF kernel headers/helpers.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/program-type/BPF_PROG_TYPE_CGROUP_SKB.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n/* Copyright (c) 2019 Facebook\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of version 2 of the GNU General Public\n * License as published by the Free Software Foundation.\n *\n * Sample Host Bandwidth Manager (HBM) BPF program.\n *\n * A cgroup skb BPF egress program to limit cgroup output bandwidth.\n * It uses a modified virtual token bucket queue to limit average\n * egress bandwidth. The implementation uses credits instead of tokens.\n * Negative credits imply that queueing would have happened (this is\n * a virtual queue, so no queueing is done by it. However, queueing may\n * occur at the actual qdisc (which is not used for rate limiting).\n *\n * This implementation uses 3 thresholds, one to start marking packets and\n * the other two to drop packets:\n *                                  CREDIT\n *        - <--------------------------|------------------------> +\n *              |    |          |      0\n *              |  Large pkt    |\n *              |  drop thresh  |\n *   Small pkt drop             Mark threshold\n *       thresh\n *\n * The effect of marking depends on the type of packet:\n * a) If the packet is ECN enabled and it is a TCP packet, then the packet\n *    is ECN marked.\n * b) If the packet is a TCP packet, then we probabilistically call tcp_cwr\n *    to reduce the congestion window. The current implementation uses a linear\n *    distribution (0% probability at marking threshold, 100% probability\n *    at drop threshold).\n * c) If the packet is not a TCP packet, then it is dropped.\n *\n * If the credit is below the drop threshold, the packet is dropped. If it\n * is a TCP packet, then it also calls tcp_cwr since packets dropped by\n * a cgroup skb BPF program do not automatically trigger a call to\n * tcp_cwr in the current kernel code.\n *\n * This BPF program actually uses 2 drop thresholds, one threshold\n * for larger packets (>= 120 bytes) and another for smaller packets. This\n * protects smaller packets such as SYNs, ACKs, etc.\n *\n * The default bandwidth limit is set at 1Gbps but this can be changed by\n * a user program through a shared BPF map. In addition, by default this BPF\n * program does not limit connections using loopback. This behavior can be\n * overwritten by the user program. There is also an option to calculate\n * some statistics, such as percent of packets marked or dropped, which\n * a user program, such as hbm, can access.\n */\n\n#include \"hbm_kern.h\"\n\nSEC(\"cgroup_skb/egress\")\nint _hbm_out_cg(struct __sk_buff *skb)\n{\n\tlong long delta = 0, delta_send;\n\tunsigned long long curtime, sendtime;\n\tstruct hbm_queue_stats *qsp = NULL;\n\tunsigned int queue_index = 0;\n\tbool congestion_flag = false;\n\tbool ecn_ce_flag = false;\n\tstruct hbm_pkt_info pkti = {};\n\tstruct hbm_vqueue *qdp;\n\tbool drop_flag = false;\n\tbool cwr_flag = false;\n\tint len = skb->len;\n\tint rv = ALLOW_PKT;\n\n\tqsp = bpf_map_lookup_elem(&queue_stats, &queue_index);\n\n\t// Check if we should ignore loopback traffic\n\tif (qsp != NULL && !qsp->loopback && (skb->ifindex == 1))\n\t\treturn ALLOW_PKT;\n\n\thbm_get_pkt_info(skb, &pkti);\n\n\t// We may want to account for the length of headers in len\n\t// calculation, like ETH header + overhead, specially if it\n\t// is a gso packet. But I am not doing it right now.\n\n\tqdp = bpf_get_local_storage(&queue_state, 0);\n\tif (!qdp)\n\t\treturn ALLOW_PKT;\n\tif (qdp->lasttime == 0)\n\t\thbm_init_edt_vqueue(qdp, 1024);\n\n\tcurtime = bpf_ktime_get_ns();\n\n\t// Begin critical section\n\tbpf_spin_lock(&qdp->lock);\n\tdelta = qdp->lasttime - curtime;\n\t// bound bursts to 100us\n\tif (delta < -BURST_SIZE_NS) {\n\t\t// negative delta is a credit that allows bursts\n\t\tqdp->lasttime = curtime - BURST_SIZE_NS;\n\t\tdelta = -BURST_SIZE_NS;\n\t}\n\tsendtime = qdp->lasttime;\n\tdelta_send = BYTES_TO_NS(len, qdp->rate);\n\t__sync_add_and_fetch(&(qdp->lasttime), delta_send);\n\tbpf_spin_unlock(&qdp->lock);\n\t// End critical section\n\n\t// Set EDT of packet\n\tskb->tstamp = sendtime;\n\n\t// Check if we should update rate\n\tif (qsp != NULL && (qsp->rate * 128) != qdp->rate)\n\t\tqdp->rate = qsp->rate * 128;\n\n\t// Set flags (drop, congestion, cwr)\n\t// last packet will be sent in the future, bound latency\n\tif (delta > DROP_THRESH_NS || (delta > LARGE_PKT_DROP_THRESH_NS &&\n\t\t\t\t       len > LARGE_PKT_THRESH)) {\n\t\tdrop_flag = true;\n\t\tif (pkti.is_tcp && pkti.ecn == 0)\n\t\t\tcwr_flag = true;\n\t} else if (delta > MARK_THRESH_NS) {\n\t\tif (pkti.is_tcp)\n\t\t\tcongestion_flag = true;\n\t\telse\n\t\t\tdrop_flag = true;\n\t}\n\n\tif (congestion_flag) {\n\t\tif (bpf_skb_ecn_set_ce(skb)) {\n\t\t\tecn_ce_flag = true;\n\t\t} else {\n\t\t\tif (pkti.is_tcp) {\n\t\t\t\tunsigned int rand = bpf_get_prandom_u32();\n\n\t\t\t\tif (delta >= MARK_THRESH_NS +\n\t\t\t\t    (rand % MARK_REGION_SIZE_NS)) {\n\t\t\t\t\t// Do congestion control\n\t\t\t\t\tcwr_flag = true;\n\t\t\t\t}\n\t\t\t} else if (len > LARGE_PKT_THRESH) {\n\t\t\t\t// Problem if too many small packets?\n\t\t\t\tdrop_flag = true;\n\t\t\t\tcongestion_flag = false;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (pkti.is_tcp && drop_flag && pkti.packets_out <= 1) {\n\t\tdrop_flag = false;\n\t\tcwr_flag = true;\n\t\tcongestion_flag = false;\n\t}\n\n\tif (qsp != NULL && qsp->no_cn)\n\t\t\tcwr_flag = false;\n\n\thbm_update_stats(qsp, len, curtime, congestion_flag, drop_flag,\n\t\t\t cwr_flag, ecn_ce_flag, &pkti, (int) delta);\n\n\tif (drop_flag) {\n\t\t__sync_add_and_fetch(&(qdp->lasttime), -delta_send);\n\t\trv = DROP_PKT;\n\t}\n\n\tif (cwr_flag)\n\t\trv |= CWR;\n\treturn rv;\n}\nchar _license[] SEC(\"license\") = \"GPL\";\n\n```\n\n----------------------------------------\n\nTITLE: Creating eBPF Hash Map with Custom Flags - C\nDESCRIPTION: This snippet demonstrates how to use the bpf() syscall in C to create a BPF hash map, configuring map type, key and value sizes, maximum entries, and map behavior via the map_flags field. It uses the bpf_attr union to specify these attributes and invokes the BPF_MAP_CREATE command. Dependencies include Linux kernel with eBPF enabled, and knowledge of bpf syscall parameter structures. The inputs are the attributes for the map and the output is a file descriptor representing the new map; errors should be checked after the syscall.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/syscall/BPF_MAP_CREATE.md#2025-04-22_snippet_1\n\nLANGUAGE: c\nCODE:\n```\nunion bpf_attr my_map {\n    .map_type = BPF_MAP_TYPE_HASH,\n    .key_size = sizeof(int),\n    .value_size = sizeof(int),\n    .max_entries = 100,\n    .map_flags = BPF_F_NO_PREALLOC,\n};\nint fd = bpf(BPF_MAP_CREATE, &my_map, sizeof(my_map));\n```\n\n----------------------------------------\n\nTITLE: Defining Pinned Map in C\nDESCRIPTION: Example of defining a BPF array map with automatic pinning enabled using the LIBBPF_PIN_BY_NAME macro.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/concepts/pinning.md#2025-04-22_snippet_1\n\nLANGUAGE: c\nCODE:\n```\nstruct {\n\t__uint(type, BPF_MAP_TYPE_ARRAY);\n\t__uint(max_entries, 1);\n\t__type(key, __u32);\n\t__type(value, __u64);\n\t__uint(pinning, LIBBPF_PIN_BY_NAME);\n} pinmap SEC(\".maps\");\n```\n\n----------------------------------------\n\nTITLE: Defining the perf_event_mmap_page Structure in C\nDESCRIPTION: This C code defines the `struct perf_event_mmap_page`, which represents the metadata header found on the first page of the memory region mapped by `mmap` for a perf event ring buffer. This structure contains crucial fields like `data_head` (kernel writes) and `data_tail` (userspace updates after reading) to manage the ring buffer, along with offset and size information (`data_offset`, `data_size`) and various capability flags and timing details.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/map-type/BPF_MAP_TYPE_PERF_EVENT_ARRAY.md#2025-04-22_snippet_2\n\nLANGUAGE: c\nCODE:\n```\n/*\n* Performance events:\n*\n*    Copyright (C) 2008-2009, Thomas Gleixner <tglx@linutronix.de>\n*    Copyright (C) 2008-2011, Red Hat, Inc., Ingo Molnar\n*    Copyright (C) 2008-2011, Red Hat, Inc., Peter Zijlstra\n*\n* Data type definitions, declarations, prototypes.\n*\n*    Started by: Thomas Gleixner and Ingo Molnar\n*\n* For licencing details see kernel-base/COPYING\n*/\n/*\n* Structure of the page that can be mapped via mmap\n*/\nstruct perf_event_mmap_page {\n    __u32\tversion;\t\t/* version number of this structure */\n    __u32\tcompat_version;\t\t/* lowest version this is compat with */\n\n    /*\n    * Bits needed to read the hw events in user-space.\n    *\n    *   u32 seq, time_mult, time_shift, index, width;\n    *   u64 count, enabled, running;\n    *   u64 cyc, time_offset;\n    *   s64 pmc = 0;\n    *\n    *   do {\n    *     seq = pc->lock;\n    *     barrier()\n    *\n    *     enabled = pc->time_enabled;\n    *     running = pc->time_running;\n    *\n    *     if (pc->cap_usr_time && enabled != running) {\n    *       cyc = rdtsc();\n    *       time_offset = pc->time_offset;\n    *       time_mult   = pc->time_mult;\n    *       time_shift  = pc->time_shift;\n    *     }\n    *\n    *     index = pc->index;\n    *     count = pc->offset;\n    *     if (pc->cap_user_rdpmc && index) {\n    *       width = pc->pmc_width;\n    *       pmc = rdpmc(index - 1);\n    *     }\n    *\n    *     barrier();\n    *   } while (pc->lock != seq);\n    *\n    * NOTE: for obvious reason this only works on self-monitoring\n    *       processes.\n    */\n    __u32\tlock;\t\t\t/* seqlock for synchronization */\n    __u32\tindex;\t\t\t/* hardware event identifier */\n    __s64\toffset;\t\t\t/* add to hardware event value */\n    __u64\ttime_enabled;\t\t/* time event active */\n    __u64\ttime_running;\t\t/* time event on cpu */\n    union {\n        __u64\tcapabilities;\n        struct {\n            __u64\tcap_bit0\t\t: 1, /* Always 0, deprecated, see commit 860f085b74e9 */\n                cap_bit0_is_deprecated\t: 1, /* Always 1, signals that bit 0 is zero */\n\n                cap_user_rdpmc\t\t: 1, /* The RDPMC instruction can be used to read counts */\n                cap_user_time\t\t: 1, /* The time_{shift,mult,offset} fields are used */\n                cap_user_time_zero\t: 1, /* The time_zero field is used */\n                cap_user_time_short\t: 1, /* the time_{cycle,mask} fields are used */\n                cap_____res\t\t: 58;\n        };\n    };\n\n    /*\n    * If cap_user_rdpmc this field provides the bit-width of the value\n    * read using the rdpmc() or equivalent instruction. This can be used\n    * to sign extend the result like:\n    *\n    *   pmc <<= 64 - width;\n    *   pmc >>= 64 - width; // signed shift right\n    *   count += pmc;\n    */\n    __u16\tpmc_width;\n\n    /*\n    * If cap_usr_time the below fields can be used to compute the time\n    * delta since time_enabled (in ns) using rdtsc or similar.\n    *\n    *   u64 quot, rem;\n    *   u64 delta;\n    *\n    *   quot = (cyc >> time_shift);\n    *   rem = cyc & (((u64)1 << time_shift) - 1);\n    *   delta = time_offset + quot * time_mult +\n    *              ((rem * time_mult) >> time_shift);\n    *\n    * Where time_offset,time_mult,time_shift and cyc are read in the\n    * seqcount loop described above. This delta can then be added to\n    * enabled and possible running (if index), improving the scaling:\n    *\n    *   enabled += delta;\n    *   if (index)\n    *     running += delta;\n    *\n    *   quot = count / running;\n    *   rem  = count % running;\n    *   count = quot * enabled + (rem * enabled) / running;\n    */\n    __u16\ttime_shift;\n    __u32\ttime_mult;\n    __u64\ttime_offset;\n    /*\n    * If cap_usr_time_zero, the hardware clock (e.g. TSC) can be calculated\n    * from sample timestamps.\n    *\n    *   time = timestamp - time_zero;\n    *   quot = time / time_mult;\n    *   rem  = time % time_mult;\n    *   cyc = (quot << time_shift) + (rem << time_shift) / time_mult;\n    *\n    * And vice versa:\n    *\n    *   quot = cyc >> time_shift;\n    *   rem  = cyc & (((u64)1 << time_shift) - 1);\n    *   timestamp = time_zero + quot * time_mult +\n    *               ((rem * time_mult) >> time_shift);\n    */\n    __u64\ttime_zero;\n\n    __u32\tsize;\t\t\t/* Header size up to __reserved[] fields. */\n    __u32\t__reserved_1;\n\n    /*\n    * If cap_usr_time_short, the hardware clock is less than 64bit wide\n    * and we must compute the 'cyc' value, as used by cap_usr_time, as:\n    *\n    *   cyc = time_cycles + ((cyc - time_cycles) & time_mask)\n    *\n    * NOTE: this form is explicitly chosen such that cap_usr_time_short\n    *       is a correction on top of cap_usr_time, and code that doesn't\n    *       know about cap_usr_time_short still works under the assumption\n    *       the counter doesn't wrap.\n    */\n    __u64\ttime_cycles;\n    __u64\ttime_mask;\n\n        /*\n        * Hole for extension of the self monitor capabilities\n        */\n\n    __u8\t__reserved[116*8];\t/* align to 1k. */\n\n    /*\n    * Control data for the mmap() data buffer.\n    *\n    * User-space reading the @data_head value should issue an smp_rmb(),\n    * after reading this value.\n    *\n    * When the mapping is PROT_WRITE the @data_tail value should be\n    * written by userspace to reflect the last read data, after issueing\n    * an smp_mb() to separate the data read from the ->data_tail store.\n    * In this case the kernel will not over-write unread data.\n    *\n    * See perf_output_put_handle() for the data ordering.\n    *\n    * data_{offset,size} indicate the location and size of the perf record\n    * buffer within the mmapped area.\n    */\n    __u64   data_head;\t\t/* head in the data section */\n    __u64\tdata_tail;\t\t/* user-space written tail */\n    __u64\tdata_offset;\t\t/* where the buffer starts */\n    __u64\tdata_size;\t\t/* data buffer size */\n\n    /*\n    * AUX area is defined by aux_{offset,size} fields that should be set\n    * by the userspace, so that\n    *\n    *   aux_offset >= data_offset + data_size\n    *\n    * prior to mmap()ing it. Size of the mmap()ed area should be aux_size.\n    *\n    * Ring buffer pointers aux_{head,tail} have the same semantics as\n\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_devmap_val Structure in C\nDESCRIPTION: This snippet defines the C structure bpf_devmap_val used for representing values in the device hash map. It includes fields for device indexing and a union for program file descriptors or IDs, providing the necessary setup for redirecting traffic to different network devices.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/map-type/BPF_MAP_TYPE_DEVMAP_HASH.md#2025-04-22_snippet_0\n\nLANGUAGE: C\nCODE:\n```\nstruct bpf_devmap_val {\n\t__u32 ifindex;   /* device index */\n\tunion {\n\t\tint   fd;  /* prog fd on map write */\n\t\t__u32 id;  /* prog id on map read */\n\t} bpf_prog;\n};\n```\n\n----------------------------------------\n\nTITLE: Comprehensive BPF Socket Management with bpf_sock_destroy Example\nDESCRIPTION: A complete example demonstrating how to use bpf_sock_destroy to terminate TCP and UDP socket connections. The program tracks socket cookies in maps and uses iterators to find and destroy specific sockets based on connection criteria.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/bpf_sock_destroy.md#2025-04-22_snippet_1\n\nLANGUAGE: c\nCODE:\n```\n// SPDX-License-Identifier: GPL-2.0\n\n#include \"vmlinux.h\"\n#include <bpf/bpf_helpers.h>\n#include <bpf/bpf_endian.h>\n\n#include \"bpf_tracing_net.h\"\n\n__be16 serv_port = 0;\n\nint bpf_sock_destroy(struct sock_common *sk) __ksym;\n\nstruct {\n\t__uint(type, BPF_MAP_TYPE_ARRAY);\n\t__uint(max_entries, 1);\n\t__type(key, __u32);\n\t__type(value, __u64);\n} tcp_conn_sockets SEC(\".maps\");\n\nstruct {\n\t__uint(type, BPF_MAP_TYPE_ARRAY);\n\t__uint(max_entries, 1);\n\t__type(key, __u32);\n\t__type(value, __u64);\n} udp_conn_sockets SEC(\".maps\");\n\nSEC(\"cgroup/connect6\")\nint sock_connect(struct bpf_sock_addr *ctx)\n{\n\t__u64 sock_cookie = 0;\n\tint key = 0;\n\t__u32 keyc = 0;\n\n\tif (ctx->family != AF_INET6 || ctx->user_family != AF_INET6)\n\t\treturn 1;\n\n\tsock_cookie = bpf_get_socket_cookie(ctx);\n\tif (ctx->protocol == IPPROTO_TCP)\n\t\tbpf_map_update_elem(&tcp_conn_sockets, &key, &sock_cookie, 0);\n\telse if (ctx->protocol == IPPROTO_UDP)\n\t\tbpf_map_update_elem(&udp_conn_sockets, &keyc, &sock_cookie, 0);\n\telse\n\t\treturn 1;\n\n\treturn 1;\n}\n\nSEC(\"iter/tcp\")\nint iter_tcp6_client(struct bpf_iter__tcp *ctx)\n{\n\tstruct sock_common *sk_common = ctx->sk_common;\n\t__u64 sock_cookie = 0;\n\t__u64 *val;\n\tint key = 0;\n\n\tif (!sk_common)\n\t\treturn 0;\n\n\tif (sk_common->skc_family != AF_INET6)\n\t\treturn 0;\n\n\tsock_cookie  = bpf_get_socket_cookie(sk_common);\n\tval = bpf_map_lookup_elem(&tcp_conn_sockets, &key);\n\tif (!val)\n\t\treturn 0;\n\t/* Destroy connected client sockets. */\n\tif (sock_cookie == *val)\n\t\tbpf_sock_destroy(sk_common);\n\n\treturn 0;\n}\n\nSEC(\"iter/tcp\")\nint iter_tcp6_server(struct bpf_iter__tcp *ctx)\n{\n\tstruct sock_common *sk_common = ctx->sk_common;\n\tconst struct inet_connection_sock *icsk;\n\tconst struct inet_sock *inet;\n\tstruct tcp6_sock *tcp_sk;\n\t__be16 srcp;\n\n\tif (!sk_common)\n\t\treturn 0;\n\n\tif (sk_common->skc_family != AF_INET6)\n\t\treturn 0;\n\n\ttcp_sk = bpf_skc_to_tcp6_sock(sk_common);\n\tif (!tcp_sk)\n\t\treturn 0;\n\n\ticsk = &tcp_sk->tcp.inet_conn;\n\tinet = &icsk->icsk_inet;\n\tsrcp = inet->inet_sport;\n\n\t/* Destroy server sockets. */\n\tif (srcp == serv_port)\n\t\tbpf_sock_destroy(sk_common);\n\n\treturn 0;\n}\n\n\nSEC(\"iter/udp\")\nint iter_udp6_client(struct bpf_iter__udp *ctx)\n{\n\tstruct udp_sock *udp_sk = ctx->udp_sk;\n\tstruct sock *sk = (struct sock *) udp_sk;\n\t__u64 sock_cookie = 0, *val;\n\tint key = 0;\n\n\tif (!sk)\n\t\treturn 0;\n\n\tsock_cookie  = bpf_get_socket_cookie(sk);\n\tval = bpf_map_lookup_elem(&udp_conn_sockets, &key);\n\tif (!val)\n\t\treturn 0;\n\t/* Destroy connected client sockets. */\n\tif (sock_cookie == *val)\n\t\tbpf_sock_destroy((struct sock_common *)sk);\n\n\treturn 0;\n}\n\nSEC(\"iter/udp\")\nint iter_udp6_server(struct bpf_iter__udp *ctx)\n{\n\tstruct udp_sock *udp_sk = ctx->udp_sk;\n\tstruct sock *sk = (struct sock *) udp_sk;\n\tstruct inet_sock *inet;\n\t__be16 srcp;\n\n\tif (!sk)\n\t\treturn 0;\n\n\tinet = &udp_sk->inet;\n\tsrcp = inet->inet_sport;\n\tif (srcp == serv_port)\n\t\tbpf_sock_destroy((struct sock_common *)sk);\n\n\treturn 0;\n}\n\nchar _license[] SEC(\"license\") = \"GPL\";\n```\n\n----------------------------------------\n\nTITLE: Defining the bpf_prog_info Structure for BPF Program Information in C\nDESCRIPTION: This C structure (`bpf_prog_info`) defines the format of information returned by `BPF_OBJ_GET_INFO_BY_FD` when querying a BPF program object. It contains various details about the program, including its type, ID, tag, lengths and pointers to JIT-ed and translated instructions, load time, creator UID, associated map IDs, name, offload information (ifindex, netns_dev, netns_ino), GPL compatibility flag, BTF information, kernel symbol pointers, function lengths, line info, program tags, and runtime statistics (run_time_ns, run_cnt, recursion_misses) if enabled via BPF_ENABLE_STATS.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/syscall/BPF_OBJ_GET_INFO_BY_FD.md#2025-04-22_snippet_1\n\nLANGUAGE: c\nCODE:\n```\n    struct bpf_prog_info {\n        __u32 type;\n        __u32 id;\n        __u8  tag[BPF_TAG_SIZE];\n        __u32 jited_prog_len;\n        __u32 xlated_prog_len;\n        __aligned_u64 jited_prog_insns;\n        __aligned_u64 xlated_prog_insns;\n        __u64 load_time;\t/* ns since boottime */\n        __u32 created_by_uid;\n        __u32 nr_map_ids;\n        __aligned_u64 map_ids;\n        char name[BPF_OBJ_NAME_LEN];\n        __u32 ifindex;\n        __u32 gpl_compatible:1;\n        __u32 :31; /* alignment pad */\n        __u64 netns_dev;\n        __u64 netns_ino;\n        __u32 nr_jited_ksyms;\n        __u32 nr_jited_func_lens;\n        __aligned_u64 jited_ksyms;\n        __aligned_u64 jited_func_lens;\n        __u32 btf_id;\n        __u32 func_info_rec_size;\n        __aligned_u64 func_info;\n        __u32 nr_func_info;\n        __u32 nr_line_info;\n        __aligned_u64 line_info;\n        __aligned_u64 jited_line_info;\n        __u32 nr_jited_line_info;\n        __u32 line_info_rec_size;\n        __u32 jited_line_info_rec_size;\n        __u32 nr_prog_tags;\n        __aligned_u64 prog_tags;\n        __u64 run_time_ns;\n        __u64 run_cnt;\n        __u64 recursion_misses;\n        __u32 verified_insns;\n        __u32 attach_btf_obj_id;\n        __u32 attach_btf_id;\n    } __attribute__((aligned(8)));\n```\n\n----------------------------------------\n\nTITLE: Defining the `bpf_core_cast` Macro in Libbpf eBPF (C)\nDESCRIPTION: This C code snippet shows the preprocessor definition of the `bpf_core_cast` macro. It leverages the `bpf_rdonly_cast` kfunc and `bpf_core_type_id_kernel` to cast a given pointer `ptr` to the specified kernel `type`, ensuring the BPF verifier recognizes the kernel BTF type for direct member access. This definition abstracts away `bpf_probe_read_kernel` calls and handles offset relocation.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/ebpf/bpf_core_cast.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n#define bpf_core_cast(ptr, type)\t\t\t\t\t    \\\n\t((typeof(type) *)bpf_rdonly_cast((ptr), bpf_core_type_id_kernel(type)))\n```\n\n----------------------------------------\n\nTITLE: Advanced UDP Port-Specific XDP Packet Redirection\nDESCRIPTION: Complex XDP program that selectively redirects only UDP traffic on port 9091. Includes IPv4 and IPv6 protocol handling with proper packet header parsing and boundary checks.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/concepts/af_xdp.md#2025-04-22_snippet_8\n\nLANGUAGE: c\nCODE:\n```\nstruct {\n\t__uint(type, BPF_MAP_TYPE_XSKMAP);\n\t__uint(max_entries, 256);\n\t__type(key, __u32);\n\t__type(value, __u32);\n} xsk SEC(\".maps\");\n\nSEC(\"xdp\")\nint rx(struct xdp_md *ctx)\n{\n\tvoid *data, *data_meta, *data_end;\n\tstruct ipv6hdr *ip6h = NULL;\n\tstruct ethhdr *eth = NULL;\n\tstruct udphdr *udp = NULL;\n\tstruct iphdr *iph = NULL;\n\tstruct xdp_meta *meta;\n\tint ret;\n\n\tdata = (void *)(long)ctx->data;\n\tdata_end = (void *)(long)ctx->data_end;\n\teth = data;\n\tif (eth + 1 < data_end) {\n\t\tif (eth->h_proto == bpf_htons(ETH_P_IP)) {\n\t\t\tiph = (void *)(eth + 1);\n\t\t\tif (iph + 1 < data_end && iph->protocol == IPPROTO_UDP)\n\t\t\t\tudp = (void *)(iph + 1);\n\t\t}\n\t\tif (eth->h_proto == bpf_htons(ETH_P_IPV6)) {\n\t\t\tip6h = (void *)(eth + 1);\n\t\t\tif (ip6h + 1 < data_end && ip6h->nexthdr == IPPROTO_UDP)\n\t\t\t\tudp = (void *)(ip6h + 1);\n\t\t}\n\t\tif (udp && udp + 1 > data_end)\n\t\t\tudp = NULL;\n\t}\n\n\tif (!udp)\n\t\treturn XDP_PASS;\n\n\tif (udp->dest != bpf_htons(9091))\n\t\treturn XDP_PASS;\n\n\treturn bpf_redirect_map(&xsk, ctx->rx_queue_index, XDP_PASS);\n}\n```\n\n----------------------------------------\n\nTITLE: Defining struct bpf_sock_ops in C\nDESCRIPTION: This C code defines the structure 'bpf_sock_ops' used in BPF programs to manipulate TCP socket options and gather metrics. It includes fields for network operations, such as IP addresses, ports, and TCP metrics. The structure is central to various BPF operations and provides access to important socket parameters.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/program-type/BPF_PROG_TYPE_SOCK_OPS.md#2025-04-22_snippet_1\n\nLANGUAGE: C\nCODE:\n```\nstruct bpf_sock_ops {\n    __u32 op;\n    union {\n        __u32 args[4];\n        __u32 reply;\n        __u32 replylong[4];\n    };\n    __u32 family;\n    __u32 remote_ip4;\n    __u32 local_ip4;\n    __u32 remote_ip6[4];\n    __u32 local_ip6[4];\n    __u32 remote_port;\n    __u32 local_port;\n    __u32 is_fullsock;\n    __u32 snd_cwnd;\n    __u32 srtt_us;\n    __u32 bpf_sock_ops_cb_flags;\n    __u32 state;\n    __u32 rtt_min;\n    __u32 snd_ssthresh;\n    __u32 rcv_nxt;\n    __u32 snd_nxt;\n    __u32 snd_una;\n    __u32 mss_cache;\n    __u32 ecn_flags;\n    __u32 rate_delivered;\n    __u32 rate_interval_us;\n    __u32 packets_out;\n    __u32 retrans_out;\n    __u32 total_retrans;\n    __u32 segs_in;\n    __u32 data_segs_in;\n    __u32 segs_out;\n    __u32 data_segs_out;\n    __u32 lost_out;\n    __u32 sacked_out;\n    __u32 sk_txhash;\n    __u64 bytes_received;\n    __u64 bytes_acked;\n    __bpf_md_ptr(struct bpf_sock *, sk);\n    __bpf_md_ptr(void *, skb_data);\n    __bpf_md_ptr(void *, skb_data_end);\n    __u32 skb_len;\n    __u32 skb_tcp_flags;\n    __u64 skb_hwtstamp;\n};\n```\n\n----------------------------------------\n\nTITLE: Implementing XDP Flow Table Lookup Program\nDESCRIPTION: Complete XDP program implementation that demonstrates flow table lookup functionality for both IPv4 and IPv6 traffic. Includes packet parsing, header validation, and flow lookup using the bpf_xdp_flow_lookup kfunc.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/bpf_xdp_flow_lookup.md#2025-04-22_snippet_1\n\nLANGUAGE: c\nCODE:\n```\n// SPDX-License-Identifier: GPL-2.0\n#define BPF_NO_KFUNC_PROTOTYPES\n#include <vmlinux.h>\n#include <bpf/bpf_helpers.h>\n#include <bpf/bpf_endian.h>\n\n#define ETH_P_IP\t0x0800\n#define ETH_P_IPV6\t0x86dd\n#define IP_MF\t\t0x2000\t/* \"More Fragments\" */\n#define IP_OFFSET\t0x1fff\t/* \"Fragment Offset\" */\n#define AF_INET\t\t2\n#define AF_INET6\t10\n\nstruct bpf_flowtable_opts___local {\n\ts32 error;\n};\n\nstruct flow_offload_tuple_rhash *\nbpf_xdp_flow_lookup(struct xdp_md *, struct bpf_fib_lookup *,\n\t\t    struct bpf_flowtable_opts___local *, u32) __ksym;\n\nstruct {\n\t__uint(type, BPF_MAP_TYPE_ARRAY);\n\t__type(key, __u32);\n\t__type(value, __u32);\n\t__uint(max_entries, 1);\n} stats SEC(\".maps\");\n\nstatic bool xdp_flowtable_offload_check_iphdr(struct iphdr *iph)\n{\n\t/* ip fragmented traffic */\n\tif (iph->frag_off & bpf_htons(IP_MF | IP_OFFSET))\n\t\treturn false;\n\n\t/* ip options */\n\tif (iph->ihl * 4 != sizeof(*iph))\n\t\treturn false;\n\n\tif (iph->ttl <= 1)\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic bool xdp_flowtable_offload_check_tcp_state(void *ports, void *data_end,\n\t\t\t\t\t\t  u8 proto)\n{\n\tif (proto == IPPROTO_TCP) {\n\t\tstruct tcphdr *tcph = ports;\n\n\t\tif (tcph + 1 > data_end)\n\t\t\treturn false;\n\n\t\tif (tcph->fin || tcph->rst)\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstruct flow_ports___local {\n\t__be16 source, dest;\n} __attribute__((preserve_access_index));\n\nSEC(\"xdp.frags\")\nint xdp_flowtable_do_lookup(struct xdp_md *ctx)\n{\n\tvoid *data_end = (void *)(long)ctx->data_end;\n\tstruct bpf_flowtable_opts___local opts = {};\n\tstruct flow_offload_tuple_rhash *tuplehash;\n\tstruct bpf_fib_lookup tuple = {\n\t\t.ifindex = ctx->ingress_ifindex,\n\t};\n\tvoid *data = (void *)(long)ctx->data;\n\tstruct ethhdr *eth = data;\n\tstruct flow_ports___local *ports;\n\t__u32 *val, key = 0;\n\n\tif (eth + 1 > data_end)\n\t\treturn XDP_DROP;\n\n\tswitch (eth->h_proto) {\n\tcase bpf_htons(ETH_P_IP): {\n\t\tstruct iphdr *iph = data + sizeof(*eth);\n\n\t\tports = (struct flow_ports___local *)(iph + 1);\n\t\tif (ports + 1 > data_end)\n\t\t\treturn XDP_PASS;\n\n\t\t/* sanity check on ip header */\n\t\tif (!xdp_flowtable_offload_check_iphdr(iph))\n\t\t\treturn XDP_PASS;\n\n\t\tif (!xdp_flowtable_offload_check_tcp_state(ports, data_end,\n\t\t\t\t\t\t\t   iph->protocol))\n\t\t\treturn XDP_PASS;\n\n\t\ttuple.family\t\t= AF_INET;\n\t\ttuple.tos\t\t= iph->tos;\n\t\ttuple.l4_protocol\t= iph->protocol;\n\t\ttuple.tot_len\t\t= bpf_ntohs(iph->tot_len);\n\t\ttuple.ipv4_src\t\t= iph->saddr;\n\t\ttuple.ipv4_dst\t\t= iph->daddr;\n\t\ttuple.sport\t\t= ports->source;\n\t\ttuple.dport\t\t= ports->dest;\n\t\tbreak;\n\t}\n\tcase bpf_htons(ETH_P_IPV6): {\n\t\tstruct in6_addr *src = (struct in6_addr *)tuple.ipv6_src;\n\t\tstruct in6_addr *dst = (struct in6_addr *)tuple.ipv6_dst;\n\t\tstruct ipv6hdr *ip6h = data + sizeof(*eth);\n\n\t\tports = (struct flow_ports___local *)(ip6h + 1);\n\t\tif (ports + 1 > data_end)\n\t\t\treturn XDP_PASS;\n\n\t\tif (ip6h->hop_limit <= 1)\n\t\t\treturn XDP_PASS;\n\n\t\tif (!xdp_flowtable_offload_check_tcp_state(ports, data_end,\n\t\t\t\t\t\t\t   ip6h->nexthdr))\n\t\t\treturn XDP_PASS;\n\n\t\ttuple.family\t\t= AF_INET6;\n\t\ttuple.l4_protocol\t= ip6h->nexthdr;\n\t\ttuple.tot_len\t\t= bpf_ntohs(ip6h->payload_len);\n\t\t*src\t\t\t= ip6h->saddr;\n\t\t*dst\t\t\t= ip6h->daddr;\n\t\ttuple.sport\t\t= ports->source;\n\t\ttuple.dport\t\t= ports->dest;\n\t\tbreak;\n\t}\n\tdefault:\n\t\treturn XDP_PASS;\n\t}\n\n\ttuplehash = bpf_xdp_flow_lookup(ctx, &tuple, &opts, sizeof(opts));\n\tif (!tuplehash)\n\t\treturn XDP_PASS;\n\n\tval = bpf_map_lookup_elem(&stats, &key);\n\tif (val)\n\t\t__sync_add_and_fetch(val, 1);\n\n\treturn XDP_PASS;\n}\n\nchar _license[] SEC(\"license\") = \"GPL\";\n```\n\n----------------------------------------\n\nTITLE: Setting Ring Buffer Size for AF_XDP Socket in C\nDESCRIPTION: This code demonstrates how to set the size of ring buffers for an AF_XDP socket using the setsockopt() system call.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/concepts/af_xdp.md#2025-04-22_snippet_3\n\nLANGUAGE: c\nCODE:\n```\nstatic const int ring_size = 512;\nif (!setsockopt(fd, SOL_XDP, {XDP_RX_RING,XDP_TX_RING,XDP_UMEM_FILL_RING,XDP_UMEM_COMPLETION_RING}, &ring_size, sizeof(ring_size)))\n    // handle error\n```\n\n----------------------------------------\n\nTITLE: Reserving, Submitting, and Discarding in Ring-Buffer with eBPF Helpers in C\nDESCRIPTION: This C code snippet showcases reserving space in a ring-buffer using 'bpf_ringbuf_reserve', followed by either submitting the data with 'bpf_ringbuf_submit' or discarding it with 'bpf_ringbuf_discard' in an eBPF program. Dependency includes libbpf for these helper functions. The size for reservation must be known at compile time, and mismanagement could lead to program verification failure.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/map-type/BPF_MAP_TYPE_RINGBUF.md#2025-04-22_snippet_2\n\nLANGUAGE: c\nCODE:\n```\n// Reserve space in the ring buffer\nstruct ringbuf_data *rb_data = bpf_ringbuf_reserve(&my_ringbuf, sizeof(struct ringbuf_data), 0);\nif(!rb_data) {\n    // if bpf_ringbuf_reserve fails, print an error message and return\n    bpf_printk(\"bpf_ringbuf_reserve failed\\n\");\n    return 1;\n}\n\nif(unhappy_flow) {\n    // Discard the reserved data\n    bpf_ringbuf_discard(rb_data, 0);\n    return 1;\n}\n\n// Submit the reserved data\nbpf_ringbuf_submit(rb_data, 0);\n```\n\n----------------------------------------\n\nTITLE: Using bpf_probe_read_user_str in kprobe for sys_open\nDESCRIPTION: This snippet demonstrates how to use bpf_probe_read_user_str in a kprobe for the sys_open system call. It reads a string from user space, which can then be processed or sent to userspace.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_probe_read_user_str.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nSEC(\"kprobe/sys_open\")\nvoid bpf_sys_open(struct pt_regs ctx) {\n    char buf[PATHLEN]; // PATHLEN is defined to 256\n    int res = bpf_probe_read_user_str(buf, sizeof(buf), ctx->di);\n    // Consume buf, for example push it to\n    // userspace via bpf_perf_event_output(); we\n    // can use res (the string length) as event\n    // size, after checking its boundaries.\n}\n```\n\n----------------------------------------\n\nTITLE: Linux Kernel 4.17 eBPF Feature Additions\nDESCRIPTION: New eBPF features added in Linux kernel 4.17, including new program types, attach types, syscall commands, helper functions, flags, and argument constants.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/timeline/index.md#2025-04-22_snippet_1\n\nLANGUAGE: markdown\nCODE:\n```\n* `BPF_PROG_TYPE_SK_MSG`\n* `BPF_PROG_TYPE_RAW_TRACEPOINT`\n* `BPF_PROG_TYPE_CGROUP_SOCK_ADDR`\n* `BPF_SK_MSG_VERDICT`\n* `BPF_CGROUP_INET4_BIND`\n* `BPF_CGROUP_INET6_BIND`\n* `BPF_CGROUP_INET4_CONNECT`\n* `BPF_CGROUP_INET6_CONNECT`\n* `BPF_CGROUP_INET4_POST_BIND`\n* `BPF_CGROUP_INET6_POST_BIND`\n* `BPF_RAW_TRACEPOINT_OPEN`\n* `bpf_get_prandom_u32`\n* `bpf_msg_redirect_map`\n* `bpf_msg_apply_bytes`\n* `bpf_msg_cork_bytes`\n* `bpf_msg_pull_data`\n* `bpf_bind`\n* `BPF_F_STACK_BUILD_ID`\n* `BPF_F_SEQ_NUMBER`\n* `BPF_STACK_BUILD_ID_EMPTY`\n* `BPF_STACK_BUILD_ID_VALID`\n* `BPF_STACK_BUILD_ID_IP`\n```\n\n----------------------------------------\n\nTITLE: Defining eBPF Helper Function: bpf_xdp_adjust_head\nDESCRIPTION: The snippet defines the eBPF helper function 'bpf_xdp_adjust_head', which adjusts the xdp_md->data pointer by a specified delta. This adjustment can be negative and is utility for preparing packets by altering their headers. A proper use of this function requires re-validation of pointers previously checked by the verifier as the packet buffer conceivably alters. Returns 0 on success, otherwise returns a negative error code.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_xdp_adjust_head.md#2025-04-22_snippet_0\n\nLANGUAGE: C\nCODE:\n```\nstatic long (* const bpf_xdp_adjust_head)(struct xdp_md *xdp_md, int delta) = (void *) 44;\n```\n\n----------------------------------------\n\nTITLE: Definition of BPF_CORE_READ_STR_INTO Macro in C\nDESCRIPTION: The C macro definition for BPF_CORE_READ_STR_INTO, which uses ___core_read with bpf_core_read_str and bpf_core_read functions to perform relocatable string reads into user-provided storage.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/ebpf/BPF_CORE_READ_STR_INTO.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n#define BPF_CORE_READ_STR_INTO(dst, src, a, ...) ({\\n\\t___core_read(bpf_core_read_str, bpf_core_read,\\t\\t\\t    \\n\\t\\t     dst, (src), a, ##__VA_ARGS__)\\t\\t\\t    \\n})\n```\n\n----------------------------------------\n\nTITLE: Defining TCP Socket State Enum for BPF Sock Ops Callbacks - C\nDESCRIPTION: This C enum defines the TCP socket connection state constants as used within BPF socket operations programs. This is critical for handlers using the BPF_SOCK_OPS_STATE_CB callback, allowing programs to decode the old_state and new_state context arguments. All constants reflect Linux TCP states, which the BPF program must interpret. No external dependencies beyond the kernel's enumerated connection states are required, and state values are 1-based sequential integers.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/program-type/BPF_PROG_TYPE_SOCK_OPS.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nenum {\n\tBPF_TCP_ESTABLISHED = 1,\n\tBPF_TCP_SYN_SENT,\n\tBPF_TCP_SYN_RECV,\n\tBPF_TCP_FIN_WAIT1,\n\tBPF_TCP_FIN_WAIT2,\n\tBPF_TCP_TIME_WAIT,\n\tBPF_TCP_CLOSE,\n\tBPF_TCP_CLOSE_WAIT,\n\tBPF_TCP_LAST_ACK,\n\tBPF_TCP_LISTEN,\n\tBPF_TCP_CLOSING,\\t/* Now a valid state */\n\tBPF_TCP_NEW_SYN_RECV\n};\n```\n\n----------------------------------------\n\nTITLE: bpf_map_update_elem Function Definition in C\nDESCRIPTION: Core function definition for updating elements in BPF maps. Takes a file descriptor, key pointer, value pointer, and flags as parameters. Returns 0 on success or a negative error code on failure.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_map_update_elem.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nint bpf_map_update_elem(int fd, const void *key, const void *value, __u64 flags);\n```\n\n----------------------------------------\n\nTITLE: Iterating Over Task Files with eBPF Iterator (C)\nDESCRIPTION: This C code snippet shows an eBPF iterator program attached to 'iter/task_file'. It iterates over file descriptors associated with tasks. For each task-file pair, it extracts the task, file, and file descriptor from the context ('ctx'). It prints formatted information (TGID, PID, FD, file operations pointer) to the associated seq_file using 'BPF_SEQ_PRINTF'. The code also includes logic for printing a header on the first call and potentially performing counts based on TGID (requires external variables 'tgid', 'count', 'last_tgid', 'unique_tgid_count'). Dependencies include 'vmlinux.h' and 'bpf/bpf_helpers.h' implicitly.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/program-type/BPF_PROG_TYPE_TRACING.md#2025-04-22_snippet_5\n\nLANGUAGE: c\nCODE:\n```\nSEC(\"iter/task_file\")\nint dump_task_file(struct bpf_iter__task_file *ctx)\n{\n    struct seq_file *seq = ctx->meta->seq;\n    struct task_struct *task = ctx->task;\n    struct file *file = ctx->file;\n    __u32 fd = ctx->fd;\n\n    if (task == NULL || file == NULL)\n        return 0;\n\n    if (ctx->meta->seq_num == 0) {\n        count = 0;\n        BPF_SEQ_PRINTF(seq, \"    tgid      gid       fd      file\\n\");\n    }\n\n    if (tgid == task->tgid && task->tgid != task->pid)\n        count++;\n\n    if (last_tgid != task->tgid) {\n        last_tgid = task->tgid;\n        unique_tgid_count++;\n    }\n\n    BPF_SEQ_PRINTF(seq, \"%8d %8d %8d %lx\\n\", task->tgid, task->pid, fd,\n            (long)file->f_op);\n    return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Using Numeric Iterator in eBPF (Linux v6.4+)\nDESCRIPTION: Shows how to use numeric iterators introduced in Linux v6.4. This approach allows for efficient loops with only two verifier states instead of checking each iteration, avoiding callback functions unlike the loop helper.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/concepts/loops.md#2025-04-22_snippet_3\n\nLANGUAGE: c\nCODE:\n```\nstruct bpf_iter_num it;\nint *v;\n\nbpf_iter_num_new(&it, 2, 5);\nwhile ((v = bpf_iter_num_next(&it))) {\n    bpf_printk(\"X = %d\", *v);\n}\nbpf_iter_num_destroy(&it);\n```\n\n----------------------------------------\n\nTITLE: Implementing cGroup Device Access Control Program in C\nDESCRIPTION: A complete example of a cGroup device BPF program that allows access to specific character devices (/dev/zero and /dev/urandom) while blocking all other device access. The program includes optional debug tracing that prints information about device access attempts.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/program-type/BPF_PROG_TYPE_CGROUP_DEVICE.md#2025-04-22_snippet_1\n\nLANGUAGE: c\nCODE:\n```\n/* Copyright (c) 2017 Facebook\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of version 2 of the GNU General Public\n * License as published by the Free Software Foundation.\n */\n\n#include <linux/bpf.h>\n#include <linux/version.h>\n#include <bpf/bpf_helpers.h>\n\nSEC(\"cgroup/dev\")\nint bpf_prog1(struct bpf_cgroup_dev_ctx *ctx)\n{\n\tshort type = ctx->access_type & 0xFFFF;\n#ifdef DEBUG\n\tshort access = ctx->access_type >> 16;\n\tchar fmt[] = \"  %d:%d    \\n\";\n\n\tswitch (type) {\n\tcase BPF_DEVCG_DEV_BLOCK:\n\t\tfmt[0] = 'b';\n\t\tbreak;\n\tcase BPF_DEVCG_DEV_CHAR:\n\t\tfmt[0] = 'c';\n\t\tbreak;\n\tdefault:\n\t\tfmt[0] = '?';\n\t\tbreak;\n\t}\n\n\tif (access & BPF_DEVCG_ACC_READ)\n\t\tfmt[8] = 'r';\n\n\tif (access & BPF_DEVCG_ACC_WRITE)\n\t\tfmt[9] = 'w';\n\n\tif (access & BPF_DEVCG_ACC_MKNOD)\n\t\tfmt[10] = 'm';\n\n\tbpf_trace_printk(fmt, sizeof(fmt), ctx->major, ctx->minor);\n#endif\n\n\t/* Allow access to /dev/zero and /dev/random.\n\t * Forbid everything else.\n\t */\n\tif (ctx->major != 1 || type != BPF_DEVCG_DEV_CHAR)\n\t\treturn 0;\n\n\tswitch (ctx->minor) {\n\tcase 5: /* 1:5 /dev/zero */\n\tcase 9: /* 1:9 /dev/urandom */\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nchar _license[] SEC(\"license\") = \"GPL\";\n```\n\n----------------------------------------\n\nTITLE: Using BPF_CORE_READ_INTO macro in C\nDESCRIPTION: This example shows how to use the BPF_CORE_READ_INTO macro to achieve the same result as BPF_CORE_READ, but by writing the value into a provided destination variable. This approach can be more performant in certain scenarios.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/ebpf/BPF_CORE_READ_INTO.md#2025-04-22_snippet_2\n\nLANGUAGE: c\nCODE:\n```\nint x;\nBPF_CORE_READ_INTO(&x, s, a.b.c, d.e, f, g);\n```\n\n----------------------------------------\n\nTITLE: Using bpf_ringbuf_output in eBPF Program\nDESCRIPTION: Example of using the bpf_ringbuf_output function to copy data into a ring buffer in an eBPF program.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_ringbuf_output.md#2025-04-22_snippet_1\n\nLANGUAGE: c\nCODE:\n```\n// Copy data into the ring buffer\nbpf_ringbuf_output(&my_ringbuf, &my_data, sizeof(my_data), 0);\n```\n\n----------------------------------------\n\nTITLE: Defining struct tcp_congestion_ops in C\nDESCRIPTION: This C code snippet defines the 'tcp_congestion_ops' struct, which abstracts the implementation of TCP congestion control algorithms within the Linux kernel (v5.6+). Each member corresponds to either an algorithm-specific state, identifier, or a callback invoked by the networking stack during TCP session operations. Required dependencies include the Linux kernel headers for TCP-related structs and enums (e.g., 'struct sock', 'struct ack_sample'). Inputs and outputs depend on callbacks; most use 'struct sock *sk' to reference the relevant socket, with some members returning control values (thresholds, segment numbers, buffer multipliers) or invoking side effects on socket state. Kernel code expects the implementer to fill in mandatory function pointers, such as 'ssthresh', for proper attachment of congestion controls. Provided fields facilitate support for advanced TCP features (ECN, SACK, custom pacing) via relevant ops.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/program-type/BPF_PROG_TYPE_STRUCT_OPS/tcp_congestion_ops.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstruct tcp_congestion_ops {\n    char     [name](#name)[TCP_CA_NAME_MAX];\n\tu32      [key](#key);\n\tu32      [flags](#flags);\n\tu32    (*[ssthresh](#ssthresh))(struct sock *sk);\n\tvoid   (*[cong_avoid](#cong_avoid))(struct sock *sk, u32 ack, u32 acked);\n\tvoid   (*[set_state](#set_state))(struct sock *sk, u8 new_state);\n\tvoid   (*[cwnd_event](#cwnd_event))(struct sock *sk, [enum tcp_ca_event](#enum-tcp_ca_event) ev);\n\tvoid   (*[in_ack_event](#in_ack_event))(struct sock *sk, u32 flags);\n\tvoid   (*[pkts_acked](#pkts_acked))(struct sock *sk, const [struct ack_sample](#struct-ack_sample) *sample);\n\tu32    (*[min_tso_segs](#min_tso_segs))(struct sock *sk);\n\tvoid   (*[cong_control](#cong_control))(struct sock *sk, u32 ack, int flag, const [struct rate_sample](#struct-rate_sample) *rs);\n\tu32    (*[undo_cwnd](#undo_cwnd))(struct sock *sk);\n\tu32    (*[sndbuf_expand](#sndbuf_expand))(struct sock *sk);\n\tsize_t (*[get_info](#get_info))(struct sock *sk, u32 ext, int *attr, [union tcp_cc_info](#union-tcp_cc_info) *info);\n\tvoid   (*[init](#init))(struct sock *sk);\n\tvoid   (*[release](#release))(struct sock *sk);\n};\n```\n\n----------------------------------------\n\nTITLE: Defining and Using bpf_redirect Helper Function in C\nDESCRIPTION: This snippet defines the bpf_redirect helper function and provides an example of its usage in a TC egress program. The function redirects a packet to another network device specified by its interface index.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_redirect.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n#include <linux/bpf.h>\n#include <bpf/bpf_helpers.h>\n\n\nSEC(\"tc/egress\")\nint bpf_clone_redirect_example(struct __sk_buff *skb) {\n\n    __u32 if_index = 2; // interface index to redirect to\n\n    return bpf_redirect(if_index, 0);\n}\n\nchar LICENSE[] SEC(\"license\") = \"Dual BSD/GPL\";\n```\n\n----------------------------------------\n\nTITLE: Dropping Socket Messages Based on PID Validation - C\nDESCRIPTION: This eBPF program in C performs filtering of socket messages based on a process ID and task's thread group ID. It uses sockmap, sockhash, and per-socket storage maps, and relies on helpers like bpf_get_current_task, bpf_get_current_pid_tgid, bpf_sk_storage_get, bpf_probe_read_kernel, and bpf_sk_storage_delete. The program checks that the stored PID matches the task's TGID, dropping the message otherwise, and demonstrates safe access to kernel task structure fields.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/program-type/BPF_PROG_TYPE_SK_MSG.md#2025-04-22_snippet_2\n\nLANGUAGE: c\nCODE:\n```\n// Copyright (c) 2020 Isovalent, Inc.\n\nstruct {\n\t__uint(type, BPF_MAP_TYPE_SOCKMAP);\n\t__uint(max_entries, 2);\n\t__type(key, __u32);\n\t__type(value, __u64);\n} sock_map SEC(\".maps\");\n\nstruct {\n\t__uint(type, BPF_MAP_TYPE_SOCKHASH);\n\t__uint(max_entries, 2);\n\t__type(key, __u32);\n\t__type(value, __u64);\n} sock_hash SEC(\".maps\");\n\nstruct {\n\t__uint(type, BPF_MAP_TYPE_SK_STORAGE);\n\t__uint(map_flags, BPF_F_NO_PREALLOC);\n\t__type(key, __u32);\n\t__type(value, __u64);\n} socket_storage SEC(\".maps\");\n\nSEC(\"sk_msg\")\nint prog_msg_verdict(struct sk_msg_md *msg)\n{\n\tstruct task_struct *task = (struct task_struct *)bpf_get_current_task();\n\tint verdict = SK_PASS;\n\t__u32 pid, tpid;\n\t__u64 *sk_stg;\n\n\tpid = bpf_get_current_pid_tgid() >> 32;\n\tsk_stg = bpf_sk_storage_get(&socket_storage, msg->sk, 0, BPF_SK_STORAGE_GET_F_CREATE);\n\tif (!sk_stg)\n\t\treturn SK_DROP;\n\t*sk_stg = pid;\n\tbpf_probe_read_kernel(&tpid , sizeof(tpid), &task->tgid);\n\tif (pid != tpid)\n\t\tverdict = SK_DROP;\n\tbpf_sk_storage_delete(&socket_storage, (void *)msg->sk);\n\treturn verdict;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing DCTCP Congestion Control with eBPF struct_ops in C\nDESCRIPTION: This C code implements the Data Center TCP (DCTCP) congestion control algorithm using eBPF `struct_ops`. It defines BPF programs that hook into various stages of the TCP congestion control lifecycle, such as initialization (`dctcp_init`), slow start threshold calculation (`dctcp_ssthresh`), alpha value updates (`dctcp_update_alpha`), state changes (`dctcp_state`), and congestion avoidance (`dctcp_cong_avoid`). The implementation utilizes a BPF socket storage map (`sk_stg_map`) for per-connection data and relies on BPF helpers (`bpf_sk_storage_get`, `bpf_tcp_send_ack`) and kernel types related to TCP sockets (`tcp_sock`, `inet_csk`). It defines two `tcp_congestion_ops` structures (`dctcp_nouse` and `dctcp`) to register the BPF functions with the kernel's TCP stack.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/program-type/BPF_PROG_TYPE_STRUCT_OPS.md#2025-04-22_snippet_1\n\nLANGUAGE: c\nCODE:\n```\n// SPDX-License-Identifier: GPL-2.0\n/* Copyright (c) 2019 Facebook */\n\n/* WARNING: This implemenation is not necessarily the same\n* as the tcp_dctcp.c.  The purpose is mainly for testing\n* the kernel BPF logic.\n*/\n\n#include <stddef.h>\n#include <linux/bpf.h>\n#include <linux/types.h>\n#include <linux/stddef.h>\n#include <linux/tcp.h>\n#include <bpf/bpf_helpers.h>\n#include <bpf/bpf_tracing.h>\n#include \"bpf_tcp_helpers.h\"\n\nchar _license[] SEC(\"license\") = \"GPL\";\n\nint stg_result = 0;\n\nstruct {\n\t__uint(type, BPF_MAP_TYPE_SK_STORAGE);\n\t__uint(map_flags, BPF_F_NO_PREALLOC);\n\t__type(key, int);\n\t__type(value, int);\n} sk_stg_map SEC(\".maps\");\n\n#define DCTCP_MAX_ALPHA\t1024U\n\nstruct dctcp {\n\t__u32 old_delivered;\n\t__u32 old_delivered_ce;\n\t__u32 prior_rcv_nxt;\n\t__u32 dctcp_alpha;\n\t__u32 next_seq;\n\t__u32 ce_state;\n\t__u32 loss_cwnd;\n};\n\nstatic unsigned int dctcp_shift_g = 4; /* g = 1/2^4 */\nstatic unsigned int dctcp_alpha_on_init = DCTCP_MAX_ALPHA;\n\nstatic __always_inline void dctcp_reset(const struct tcp_sock *tp,\n\t\t\t\t\tstruct dctcp *ca)\n{\n\tca->next_seq = tp->snd_nxt;\n\n\tca->old_delivered = tp->delivered;\n\tca->old_delivered_ce = tp->delivered_ce;\n}\n\nSEC(\"struct_ops/dctcp_init\")\nvoid BPF_PROG(dctcp_init, struct sock *sk)\n{\n\tconst struct tcp_sock *tp = tcp_sk(sk);\n\tstruct dctcp *ca = inet_csk_ca(sk);\n\tint *stg;\n\n\tca->prior_rcv_nxt = tp->rcv_nxt;\n\tca->dctcp_alpha = min(dctcp_alpha_on_init, DCTCP_MAX_ALPHA);\n\tca->loss_cwnd = 0;\n\tca->ce_state = 0;\n\n\tstg = bpf_sk_storage_get(&sk_stg_map, (void *)tp, NULL, 0);\n\tif (stg) {\n\t\tstg_result = *stg;\n\t\tbpf_sk_storage_delete(&sk_stg_map, (void *)tp);\n\t}\n\tdctcp_reset(tp, ca);\n}\n\nSEC(\"struct_ops/dctcp_ssthresh\")\n__u32 BPF_PROG(dctcp_ssthresh, struct sock *sk)\n{\n\tstruct dctcp *ca = inet_csk_ca(sk);\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\n\tca->loss_cwnd = tp->snd_cwnd;\n\treturn max(tp->snd_cwnd - ((tp->snd_cwnd * ca->dctcp_alpha) >> 11U), 2U);\n}\n\nSEC(\"struct_ops/dctcp_update_alpha\")\nvoid BPF_PROG(dctcp_update_alpha, struct sock *sk, __u32 flags)\n{\n\tconst struct tcp_sock *tp = tcp_sk(sk);\n\tstruct dctcp *ca = inet_csk_ca(sk);\n\n\t/* Expired RTT */\n\tif (!before(tp->snd_una, ca->next_seq)) {\n\t\t__u32 delivered_ce = tp->delivered_ce - ca->old_delivered_ce;\n\t\t__u32 alpha = ca->dctcp_alpha;\n\n\t\t/* alpha = (1 - g) * alpha + g * F */\n\n\t\talpha -= min_not_zero(alpha, alpha >> dctcp_shift_g);\n\t\tif (delivered_ce) {\n\t\t\t__u32 delivered = tp->delivered - ca->old_delivered;\n\n\t\t\t/* If dctcp_shift_g == 1, a 32bit value would overflow\n\t\t\t* after 8 M packets.\n\t\t\t*/\n\t\t\tdelivered_ce <<= (10 - dctcp_shift_g);\n\t\t\tdelivered_ce /= max(1U, delivered);\n\n\t\t\talpha = min(alpha + delivered_ce, DCTCP_MAX_ALPHA);\n\t\t}\n\t\tca->dctcp_alpha = alpha;\n\t\tdctcp_reset(tp, ca);\n\t}\n}\n\nstatic __always_inline void dctcp_react_to_loss(struct sock *sk)\n{\n\tstruct dctcp *ca = inet_csk_ca(sk);\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\n\tca->loss_cwnd = tp->snd_cwnd;\n\ttp->snd_ssthresh = max(tp->snd_cwnd >> 1U, 2U);\n}\n\nSEC(\"struct_ops/dctcp_state\")\nvoid BPF_PROG(dctcp_state, struct sock *sk, __u8 new_state)\n{\n\tif (new_state == TCP_CA_Recovery &&\n\t    new_state != BPF_CORE_READ_BITFIELD(inet_csk(sk), icsk_ca_state))\n\t\tdctcp_react_to_loss(sk);\n\t/* We handle RTO in dctcp_cwnd_event to ensure that we perform only\n\t* one loss-adjustment per RTT.\n\t*/\n}\n\nstatic __always_inline void dctcp_ece_ack_cwr(struct sock *sk, __u32 ce_state)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\n\tif (ce_state == 1)\n\t\ttp->ecn_flags |= TCP_ECN_DEMAND_CWR;\n\telse\n\t\ttp->ecn_flags &= ~TCP_ECN_DEMAND_CWR;\n}\n\n/* Minimal DCTP CE state machine:\n*\n* S:\t0 <- last pkt was non-CE\n*\t1 <- last pkt was CE\n*/\nstatic __always_inline\nvoid dctcp_ece_ack_update(struct sock *sk, enum tcp_ca_event evt,\n\t\t\t__u32 *prior_rcv_nxt, __u32 *ce_state)\n{\n\t__u32 new_ce_state = (evt == CA_EVENT_ECN_IS_CE) ? 1 : 0;\n\n\tif (*ce_state != new_ce_state) {\n\t\t/* CE state has changed, force an immediate ACK to\n\t\t* reflect the new CE state. If an ACK was delayed,\n\t\t* send that first to reflect the prior CE state.\n\t\t*/\n\t\tif (inet_csk(sk)->icsk_ack.pending & ICSK_ACK_TIMER) {\n\t\t\tdctcp_ece_ack_cwr(sk, *ce_state);\n\t\t\tbpf_tcp_send_ack(sk, *prior_rcv_nxt);\n\t\t}\n\t\tinet_csk(sk)->icsk_ack.pending |= ICSK_ACK_NOW;\n\t}\n\t*prior_rcv_nxt = tcp_sk(sk)->rcv_nxt;\n\t*ce_state = new_ce_state;\n\tdctcp_ece_ack_cwr(sk, new_ce_state);\n}\n\nSEC(\"struct_ops/dctcp_cwnd_event\")\nvoid BPF_PROG(dctcp_cwnd_event, struct sock *sk, enum tcp_ca_event ev)\n{\n\tstruct dctcp *ca = inet_csk_ca(sk);\n\n\tswitch (ev) {\n\tcase CA_EVENT_ECN_IS_CE:\n\tcase CA_EVENT_ECN_NO_CE:\n\t\tdctcp_ece_ack_update(sk, ev, &ca->prior_rcv_nxt, &ca->ce_state);\n\t\tbreak;\n\tcase CA_EVENT_LOSS:\n\t\tdctcp_react_to_loss(sk);\n\t\tbreak;\n\tdefault:\n\t\t/* Don't care for the rest. */\n\t\tbreak;\n\t}\n}\n\nSEC(\"struct_ops/dctcp_cwnd_undo\")\n__u32 BPF_PROG(dctcp_cwnd_undo, struct sock *sk)\n{\n\tconst struct dctcp *ca = inet_csk_ca(sk);\n\n\treturn max(tcp_sk(sk)->snd_cwnd, ca->loss_cwnd);\n}\n\nextern void tcp_reno_cong_avoid(struct sock *sk, __u32 ack, __u32 acked) __ksym;\n\nSEC(\"struct_ops/dctcp_reno_cong_avoid\")\nvoid BPF_PROG(dctcp_cong_avoid, struct sock *sk, __u32 ack, __u32 acked)\n{\n\ttcp_reno_cong_avoid(sk, ack, acked);\n}\n\nSEC(\".struct_ops\")\nstruct tcp_congestion_ops dctcp_nouse = {\n\t.init\t\t= (void *)dctcp_init,\n\t.set_state\t= (void *)dctcp_state,\n\t.flags\t\t= TCP_CONG_NEEDS_ECN,\n\t.name\t\t= \"bpf_dctcp_nouse\",\n};\n\nSEC(\".struct_ops\")\nstruct tcp_congestion_ops dctcp = {\n\t.init\t\t= (void *)dctcp_init,\n\t.in_ack_event   = (void *)dctcp_update_alpha,\n\t.cwnd_event\t= (void *)dctcp_cwnd_event,\n\t.ssthresh\t= (void *)dctcp_ssthresh,\n\t.cong_avoid\t= (void *)dctcp_cong_avoid,\n\t.undo_cwnd\t= (void *)dctcp_cwnd_undo,\n\t.set_state\t= (void *)dctcp_state,\n\t.flags\t\t= TCP_CONG_NEEDS_ECN,\n\t.name\t\t= \"bpf_dctcp\",\n};\n```\n\n----------------------------------------\n\nTITLE: Valid CO-RE Read Example with bpf_core_read\nDESCRIPTION: Provides a practical example of using bpf_core_read within an eBPF program to read a task_struct's parent pointer. The snippet highlights error handling and shows how the macro helps achieve a relocation-friendly memory read from kernel structures, ensuring compatibility across diverse kernel versions.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/ebpf/bpf_core_read.md#2025-04-22_snippet_3\n\nLANGUAGE: C\nCODE:\n```\nstruct task_struct *task = (void *)bpf_get_current_task();\\nstruct task_struct *parent_task;\\nint err;\\n\\nerr = bpf_core_read(&parent_task, sizeof(void *), &task->parent);\\nif (err) {\\n    /* handle error */\\n}\\n\\n/* parent_task contains the value of task->parent pointer */\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_core_enum_value_exists Macro in Libbpf - C\nDESCRIPTION: This C macro defines 'bpf_core_enum_value_exists' for eBPF programs using the Libbpf library. It leverages compiler built-ins to determine if an enum value exists in the kernel's BTF type information, branching to use different implementations based on whether the Clang compiler is used. Requires Clang or compatible C compiler, and relies on kernel BTF and loader support. Parameters: 'enum_type' is the C enum type, 'enum_value' is the enumerator; the macro returns 1 if present, 0 otherwise. Proper integration with loader libraries such as libbpf is necessary. Only available for compilers supporting __builtin_preserve_enum_value.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/ebpf/bpf_core_enum_value_exists.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n#ifdef __clang__\\n#define bpf_core_enum_value_exists(enum_type, enum_value)           \\\\\\n    __builtin_preserve_enum_value(*(typeof(enum_type) *)enum_value, BPF_ENUMVAL_EXISTS)\\n#else\\n#define bpf_core_enum_value_exists(enum_type, enum_value)           \\\\\\n    __builtin_preserve_enum_value(___bpf_typeof(enum_type), enum_value, BPF_ENUMVAL_EXISTS)\\n#endif\n```\n\n----------------------------------------\n\nTITLE: New eBPF Map Types in Linux 5.13-5.18\nDESCRIPTION: New map types added for eBPF, including a Bloom filter map type for efficient set membership testing.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/timeline/index.md#2025-04-22_snippet_6\n\nLANGUAGE: C\nCODE:\n```\nBPF_MAP_TYPE_BLOOM_FILTER\n```\n\n----------------------------------------\n\nTITLE: Querying Auto-Attach Status with Libbpf in C\nDESCRIPTION: This C function determines if a given BPF map is set up for auto-attachment during the skeleton attach phase. It requires the 'struct bpf_map' type supplied by the Libbpf library. The single parameter 'map' refers to an instance of a BPF map. The function returns a boolean: 'true' if the map will auto-attach when initializing the skeleton, 'false' otherwise. Libbpf (>= 1.5.0) must be available. Inputs: pointer to a bpf_map object. Output: boolean value. The function is primarily used for introspection inside eBPF loader applications and has no side effects.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_map__autoattach.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n#!c bool bpf_map__autoattach(const struct bpf_map *map);\n```\n\n----------------------------------------\n\nTITLE: Defining a Variadic String Formatting Macro for eBPF (libbpf) in C\nDESCRIPTION: This snippet defines the 'BPF_SNPRINTF' macro, which simplifies in-BPF string formatting by wrapping the 'bpf_snprintf' helper to accept variadic arguments rather than a fixed array of u64. It safely passes format strings as static globals for verifier compatibility and shields conversion warnings with temporary diagnostic suppression. Dependencies include the GCC compiler for pragma support, and the existence of '__bpf_narg', '__bpf_fill', and 'bpf_snprintf' in the build context. Key parameters are the output buffer, buffer size, format string, and variadic arguments. The macro is constrained to usage within BPF programs compiled with libbpf and properly includes required headers.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/ebpf/bpf_snprintf.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n/*\n * BPF_SNPRINTF wraps the bpf_snprintf helper with variadic arguments instead of\n * an array of u64.\n */\n#define BPF_SNPRINTF(out, out_size, fmt, args...)            \\\n({                                                          \\\n    static const char ___fmt[] = fmt;                       \\\n    unsigned long long ___param[___bpf_narg(args)];         \\\n                                                            \\\n    _Pragma(\"GCC diagnostic push\")                         \\\n    _Pragma(\"GCC diagnostic ignored \\\"-Wint-conversion\\\"\")   \\\n    ___bpf_fill(___param, args);                            \\\n    _Pragma(\"GCC diagnostic pop\")                          \\\n                                                            \\\n    bpf_snprintf(out, out_size, ___fmt,                     \\\n                 ___param, sizeof(___param));               \\\n})\n\n```\n\n----------------------------------------\n\nTITLE: Pre-populating eBPF Tail-Call Map in C\nDESCRIPTION: Shows how to pre-populate a tail-call map using the __array macro. This is commonly used to set up program arrays for tail calls.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/concepts/maps.md#2025-04-22_snippet_4\n\nLANGUAGE: C\nCODE:\n```\nstruct {\n\t__uint(type, BPF_MAP_TYPE_PROG_ARRAY);\n\t__uint(max_entries, 2);\n\t__uint(key_size, sizeof(__u32));\n\t__array(values, int (void *));\n} prog_array_init SEC(\".maps\") = {\n\t.values = {\n\t\t[1] = (void *)&tailcall_1,\n\t},\n};\n```\n\n----------------------------------------\n\nTITLE: Profiling Example with perf_event BPF Program in C\nDESCRIPTION: An example BPF program that profiles CPU cycles and records kernel and user stack traces. The program is triggered by the perf_event context. Requires BPF headers and Linux BPF tracing helpers. Inputs include the ctx structure representing the current event state; outputs a stack trace and event reporting.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/program-type/BPF_PROG_TYPE_PERF_EVENT.md#2025-04-22_snippet_3\n\nLANGUAGE: C\nCODE:\n```\n#include <linux/ptrace.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/perf_event.h>\n#include <bpf/bpf_helpers.h>\n#include <bpf/bpf_tracing.h>\n\nstruct key_t {\n    char comm[TASK_COMM_LEN];\n    u32 kernstack;\n    u32 userstack;\n};\n\nstruct {\n    __uint(type, BPF_MAP_TYPE_HASH);\n    __type(key, struct key_t);\n    __type(value, u64);\n    __uint(max_entries, 10000);\n} counts SEC(\".maps\");\n\nstruct {\n    __uint(type, BPF_MAP_TYPE_STACK_TRACE);\n    __uint(key_size, sizeof(u32));\n    __uint(value_size, PERF_MAX_STACK_DEPTH * sizeof(u64));\n    __uint(max_entries, 10000);\n} stackmap SEC(\".maps\");\n\n#define KERN_STACKID_FLAGS (0 | BPF_F_FAST_STACK_CMP)\n#define USER_STACKID_FLAGS (0 | BPF_F_FAST_STACK_CMP | BPF_F_USER_STACK)\n\nSEC(\"perf_event\")\nint bpf_prog1(struct bpf_perf_event_data *ctx)\n{\n    char time_fmt1[] = \"Time Enabled: %llu, Time Running: %llu\";\n    char time_fmt2[] = \"Get Time Failed, ErrCode: %d\";\n    char addr_fmt[] = \"Address recorded on event: %llx\";\n    char fmt[] = \"CPU-%d period %lld ip %llx\";\n    u32 cpu = bpf_get_smp_processor_id();\n    struct bpf_perf_event_value value_buf;\n    struct key_t key;\n    u64 *val, one = 1;\n    int ret;\n\n    if (ctx->sample_period < 10000)\n        /* ignore warmup */\n        return 0;\n    bpf_get_current_comm(&key.comm, sizeof(key.comm));\n    key.kernstack = bpf_get_stackid(ctx, &stackmap, KERN_STACKID_FLAGS);\n    key.userstack = bpf_get_stackid(ctx, &stackmap, USER_STACKID_FLAGS);\n    if ((int)key.kernstack < 0 && (int)key.userstack < 0) {\n        bpf_trace_printk(fmt, sizeof(fmt), cpu, ctx->sample_period,\n                PT_REGS_IP(&ctx->regs));\n        return 0;\n    }\n\n    ret = bpf_perf_prog_read_value(ctx, (void *)&value_buf, sizeof(struct bpf_perf_event_value));\n    if (!ret)\n    bpf_trace_printk(time_fmt1, sizeof(time_fmt1), value_buf.enabled, value_buf.running);\n    else\n    bpf_trace_printk(time_fmt2, sizeof(time_fmt2), ret);\n\n    if (ctx->addr != 0)\n    bpf_trace_printk(addr_fmt, sizeof(addr_fmt), ctx->addr);\n\n    val = bpf_map_lookup_elem(&counts, &key);\n    if (val)\n        (*val)++;\n    else\n        bpf_map_update_elem(&counts, &key, &one, BPF_NOEXIST);\n    return 0;\n}\n\nchar _license[] SEC(\"license\") = \"GPL\";\n```\n\n----------------------------------------\n\nTITLE: Implementing Custom SYN Cookie Validation with bpf_sk_assign_tcp_reqsk in C\nDESCRIPTION: This snippet demonstrates how to use the bpf_sk_assign_tcp_reqsk kernel function to validate an arbitrary SYN cookie on a backend server. It creates a bpf_tcp_req_attrs structure with TCP connection parameters, looks up a TCP socket, and then assigns the attributes to establish a connection.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/bpf_sk_assign_tcp_reqsk.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstruct bpf_tcp_req_attrs attrs = {\n    .mss = mss,\n    .wscale_ok = wscale_ok,\n    .rcv_wscale = rcv_wscale, /* Server's WScale < 15 */\n    .snd_wscale = snd_wscale, /* Client's WScale < 15 */\n    .tstamp_ok = tstamp_ok,\n    .rcv_tsval = tsval,\n    .rcv_tsecr = tsecr, /* Server's Initial TSval */\n    .usec_ts_ok = usec_ts_ok,\n    .sack_ok = sack_ok,\n    .ecn_ok = ecn_ok,\n}\n\nskc = bpf_skc_lookup_tcp(...);\nsk = (struct sock *)bpf_skc_to_tcp_sock(skc);\nbpf_sk_assign_tcp_reqsk(skb, sk, attrs, sizeof(attrs));\nbpf_sk_release(skc);\n```\n\n----------------------------------------\n\nTITLE: Complete eBPF Stack Trace Example\nDESCRIPTION: Example program demonstrating how to use bpf_get_stackid to collect both kernel and user stack traces using a BPF_MAP_TYPE_STACK_TRACE map.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_get_stackid.md#2025-04-22_snippet_2\n\nLANGUAGE: c\nCODE:\n```\n#include <bpf/bpf_helpers.h>\n\nstruct {\n\t__uint(type, BPF_MAP_TYPE_STACK_TRACE);\n\t__uint(key_size, sizeof(u32));\n\t__uint(value_size, PERF_MAX_STACK_DEPTH * sizeof(u64));\n\t__uint(max_entries, 10000);\n} stack_traces SEC(\".maps\");\n\nSEC(\"perf_event\")\nint print_stack_ids(struct bpf_perf_event_data *ctx)\n{\n\tchar fmt[] = \"kern_stack_id=%d user_stack_id=%d\";\n\t\n\tkern_stack_id = bpf_get_stackid(ctx, &stack_traces, 0);\n\tuser_stack_id = bpf_get_stackid(ctx, &stack_traces, 0 | BPF_F_USER_STACK);\n\t\n\tif kern_stack_id >= 0 && user_stack_id >=0 {\n\t\tbpf_trace_printk(fmt, sizeof(fmt), kern_stack_id, user_stack_id);\n\t}\n}\n\nchar _license[] SEC(\"license\") = \"GPL\";\n```\n\n----------------------------------------\n\nTITLE: Incorrect Format String Declaration with bpf_trace_printk (eBPF, C)\nDESCRIPTION: Illustrates a common error where a non-static format string is passed to bpf_trace_printk. Declaring the format string as a local variable can result in ELF section placement incompatible with eBPF, leading to runtime problems. This serves as a caution for eBPF developers. No external dependencies beyond eBPF.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_trace_printk.md#2025-04-22_snippet_1\n\nLANGUAGE: c\nCODE:\n```\nchar *fmt = \"some log\";\nbpf_trace_printk(fmt, 9);\n```\n\n----------------------------------------\n\nTITLE: Implementing a Packet Length Histogram Tracker with BPF_PROG_TYPE_LWT_IN\nDESCRIPTION: This example demonstrates a Light Weight Tunnel Input program that tracks packet length distribution in a histogram. The program logs packet lengths (grouped by powers of 2) in a per-CPU hash map, incrementing counters for each length category. It's designed to be attached to a route for monitoring incoming packet size distribution.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/program-type/BPF_PROG_TYPE_LWT_IN.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n/* Copyright (c) 2016 Thomas Graf <tgraf@tgraf.ch>\n*\n* This program is free software; you can redistribute it and/or\n* modify it under the terms of version 2 of the GNU General Public\n* License as published by the Free Software Foundation.\n*\n* This program is distributed in the hope that it will be useful, but\n* WITHOUT ANY WARRANTY; without even the implied warranty of\n* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n* General Public License for more details.\n*/\n\n#include \"vmlinux.h\"\n#include <bpf/bpf_helpers.h>\n\nstruct {\n    __uint(type, BPF_MAP_TYPE_PERCPU_HASH);\n    __type(key, u64);\n    __type(value, u64);\n    __uint(pinning, LIBBPF_PIN_BY_NAME);\n    __uint(max_entries, 1024);\n} lwt_len_hist_map SEC(\".maps\");\n\nstatic unsigned int log2(unsigned int v)\n{\n    unsigned int r;\n    unsigned int shift;\n\n    r = (v > 0xFFFF) << 4; v >>= r;\n    shift = (v > 0xFF) << 3; v >>= shift; r |= shift;\n    shift = (v > 0xF) << 2; v >>= shift; r |= shift;\n    shift = (v > 0x3) << 1; v >>= shift; r |= shift;\n    r |= (v >> 1);\n    return r;\n}\n\nstatic unsigned int log2l(unsigned long v)\n{\n    unsigned int hi = v >> 32;\n    if (hi)\n        return log2(hi) + 32;\n    else\n        return log2(v);\n}\n\nSEC(\"len_hist\")\nint do_len_hist(struct __sk_buff *skb)\n{\n    __u64 *value, key, init_val = 1;\n\n    key = log2l(skb->len);\n\n    value = bpf_map_lookup_elem(&lwt_len_hist_map, &key);\n    if (value)\n        __sync_fetch_and_add(value, 1);\n    else\n        bpf_map_update_elem(&lwt_len_hist_map, &key, &init_val, BPF_ANY);\n\n    return BPF_OK;\n}\n\nchar _license[] SEC(\"license\") = \"GPL\";\n```\n\n----------------------------------------\n\nTITLE: Defining eBPF Map Update Helper Function in C\nDESCRIPTION: Function definition for the bpf_map_update_elem helper that allows updating map elements. Takes map pointer, key pointer, value pointer, and flags as arguments.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_map_update_elem.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstatic long (* const bpf_map_update_elem)(void *map, const void *key, const void *value, __u64 flags) = (void *) 2;\n```\n\n----------------------------------------\n\nTITLE: Using bpf_sk_assign in Socket Lookup Program\nDESCRIPTION: Example of using bpf_sk_assign in a BPF_PROG_TYPE_SK_LOOKUP program to redirect packets to a specific socket based on IP and port.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_sk_assign.md#2025-04-22_snippet_1\n\nLANGUAGE: c\nCODE:\n```\nstruct {\n\t__uint(type, BPF_MAP_TYPE_SOCKMAP);\n\t__uint(max_entries, 32);\n\t__type(key, __u32);\n\t__type(value, __u64);\n} redir_map SEC(\".maps\");\n\nstatic const __u16 DST_PORT = 7007; /* Host byte order */\nstatic const __u32 DST_IP4 = IP4(127, 0, 0, 1);\nstatic const __u32 KEY_SERVER_A = 0;\n\n/* Redirect packets destined for DST_IP4 address to socket at redir_map[0]. */\nSEC(\"sk_lookup\")\nint redir_ip4(struct bpf_sk_lookup *ctx)\n{\n\tstruct bpf_sock *sk;\n\tint err;\n\n\tif (ctx->family != AF_INET)\n\t\treturn SK_PASS;\n\tif (ctx->local_port != DST_PORT)\n\t\treturn SK_PASS;\n\tif (ctx->local_ip4 != DST_IP4)\n\t\treturn SK_PASS;\n\n\tsk = bpf_map_lookup_elem(&redir_map, &KEY_SERVER_A);\n\tif (!sk)\n\t\treturn SK_PASS;\n\n\terr = bpf_sk_assign(ctx, sk, 0);\n\tbpf_sk_release(sk);\n\treturn err ? SK_DROP : SK_PASS;\n}\n```\n\n----------------------------------------\n\nTITLE: Pre-populating eBPF Map-in-Map in C\nDESCRIPTION: Demonstrates how to pre-populate a map-in-map structure using the __array macro and static values. This is useful for initializing map contents during loading.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/concepts/maps.md#2025-04-22_snippet_3\n\nLANGUAGE: C\nCODE:\n```\nstruct inner_map {\n\t__uint(type, BPF_MAP_TYPE_ARRAY);\n\t__uint(max_entries, INNER_MAX_ENTRIES);\n\t__type(key, __u32);\n\t__type(value, __u32);\n} inner_map SEC(\".maps\");\n\nstruct {\n\t__uint(type, BPF_MAP_TYPE_ARRAY_OF_MAPS);\n\t__uint(max_entries, MAX_ENTRIES);\n\t__type(key, __u32);\n\t__type(value, __u32);\n\t__array(values, struct {\n\t\t__uint(type, BPF_MAP_TYPE_ARRAY);\n\t\t__uint(max_entries, INNER_MAX_ENTRIES);\n\t\t__type(key, __u32);\n\t\t__type(value, __u32);\n\t});\n} m_array_of_maps SEC(\".maps\") = {\n\t.values = { (void *)&inner_map, 0, 0, 0, 0, 0, 0, 0, 0 },\n};\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_msg_cork_bytes Helper Function in C\nDESCRIPTION: This code snippet defines the 'bpf_msg_cork_bytes' helper function for eBPF programs. It prevents the execution of the verdict eBPF program for a message until a specified number of bytes have been accumulated. This is useful for scenarios where a specific amount of data is needed before making a decision, even across multiple send operations.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_msg_cork_bytes.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstatic long (* const bpf_msg_cork_bytes)(struct sk_msg_md *msg, __u32 bytes) = (void *) 62;\n```\n\n----------------------------------------\n\nTITLE: Implementing Packet Redirection with bpf_clone_redirect in eBPF\nDESCRIPTION: This example demonstrates how to use the bpf_clone_redirect helper function to clone and redirect packets to a specific network interface in an eBPF program attached to the TC egress hook. It includes error handling and uses the TC_ACT_OK return value.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_clone_redirect.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n#include <linux/bpf.h>\n#include <bpf/bpf_helpers.h>\n#include <linux/pkt_cls.h>\n\n\nSEC(\"tc/egress\")\nint bpf_clone_redirect_example(struct __sk_buff *skb) {\n\n    __u32 if_index = 2; // interface index to redirect to\n\n    int ret = bpf_clone_redirect(skb, if_index, 0); // redirect to egress path because BPF_F_INGRESS flag is not set\n\n    if (ret) {\n        bpf_printk(\"bpf_clone_redirect error: %d\", ret);\n    }\n\n    return TC_ACT_OK;\n}\n\nchar LICENSE[] SEC(\"license\") = \"Dual BSD/GPL\";\n```\n\n----------------------------------------\n\nTITLE: Defining the 'bpf_core_enum_value' Macro in C\nDESCRIPTION: This C code defines the 'bpf_core_enum_value' macro using preprocessor directives. It utilizes the '__builtin_preserve_enum_value' compiler intrinsic to retrieve the integer value of a specified enum member ('enum_value') within a given enum type ('enum_type') from the target kernel's BTF information at load time. The specific implementation varies slightly depending on whether the Clang compiler ('__clang__') is defined, using either 'typeof' or '___bpf_typeof'. The BPF loader resolves this at load time, returning the 64-bit integer value or 0 if the type or value is not found.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/ebpf/bpf_core_enum_value.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n#ifdef __clang__\n#define bpf_core_enum_value(enum_type, enum_value)\t\t\t    \\\n\t__builtin_preserve_enum_value(*(typeof(enum_type) *)enum_value, BPF_ENUMVAL_VALUE)\n#else\n#define bpf_core_enum_value(enum_type, enum_value)\t\t\t    \\\n\t__builtin_preserve_enum_value(___bpf_typeof(enum_type), enum_value, BPF_ENUMVAL_VALUE)\n#endif\n```\n\n----------------------------------------\n\nTITLE: Implementing Task Iteration in cGroups Using bpf_iter_css_task_new\nDESCRIPTION: This example demonstrates how to use the bpf_for_each iterator with CSS tasks in an LSM program. The code obtains a cgroup by ID, then iterates through processes in that cgroup to count occurrences of a specific PID. The program uses kernel symbols to manage cgroup references properly.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/bpf_iter_css_task_new.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n// SPDX-License-Identifier: GPL-2.0\n/* Copyright (C) 2023 Chuyi Zhou <zhouchuyi@bytedance.com> */\n\n#include \"vmlinux.h\"\n#include <errno.h>\n#include <bpf/bpf_helpers.h>\n#include <bpf/bpf_tracing.h>\n#include \"bpf_misc.h\"\n#include \"bpf_experimental.h\"\n\nchar _license[] SEC(\"license\") = \"GPL\";\n\nstruct cgroup *bpf_cgroup_from_id(u64 cgid) __ksym;\nvoid bpf_cgroup_release(struct cgroup *p) __ksym;\n\npid_t target_pid;\nint css_task_cnt;\nu64 cg_id;\n\nSEC(\"lsm/file_mprotect\")\nint BPF_PROG(iter_css_task_for_each, struct vm_area_struct *vma,\n\t    unsigned long reqprot, unsigned long prot, int ret)\n{\n\tstruct task_struct *cur_task = bpf_get_current_task_btf();\n\tstruct cgroup_subsys_state *css;\n\tstruct task_struct *task;\n\tstruct cgroup *cgrp;\n\n\tif (cur_task->pid != target_pid)\n\t\treturn ret;\n\n\tcgrp = bpf_cgroup_from_id(cg_id);\n\n\tif (!cgrp)\n\t\treturn -EPERM;\n\n\tcss = &cgrp->self;\n\tcss_task_cnt = 0;\n\n\tbpf_for_each(css_task, task, css, CSS_TASK_ITER_PROCS)\n\t\tif (task->pid == target_pid)\n\t\t\tcss_task_cnt++;\n\n\tbpf_cgroup_release(cgrp);\n\n\treturn -EPERM;\n}\n```\n\n----------------------------------------\n\nTITLE: Logging Long Long Value with Formatted Message via bpf_trace_printk (eBPF, C)\nDESCRIPTION: Provides an example of logging a long long integer using the '%lld' specifier in the log message. Demonstrates declaration and use of both the format string and a long long variable as arguments to bpf_trace_printk. The message will include the value of 'abc' (123456789) in the log output. Requires eBPF program compatibility.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_trace_printk.md#2025-04-22_snippet_6\n\nLANGUAGE: c\nCODE:\n```\nstatic const char fmt[] = \"big number: %lld\"; \nlong long abc = 123456789;\nbpf_trace_printk(fmt, sizeof(fmt), abc);\n```\n\n----------------------------------------\n\nTITLE: Disabling VLAN Offloads\nDESCRIPTION: Command to disable VLAN offloads for a network device using ethtool, allowing XDP programs to see VLAN headers.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/program-type/BPF_PROG_TYPE_XDP.md#2025-04-22_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nethtool -K <dev_name> rxvlan off txvlan off\n```\n\n----------------------------------------\n\nTITLE: Defining the BPF_OBJ_GET_INFO_BY_FD Syscall Attributes Structure in C\nDESCRIPTION: This C structure defines the arguments passed to the `BPF_OBJ_GET_INFO_BY_FD` syscall command. It includes the `bpf_fd` (file descriptor of the target BPF object), `info_len` (size of the buffer pointed to by `info`, updated by the kernel with the actual size written), and `info` (a pointer to a buffer where the kernel writes the object information). The actual structure written to the `info` buffer depends on the type of BPF object.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/syscall/BPF_OBJ_GET_INFO_BY_FD.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n\tstruct {\n\t\t__u32\t\tbpf_fd;\n\t\t__u32\t\tinfo_len;\n\t\t__aligned_u64\tinfo;\n\t};\n```\n\n----------------------------------------\n\nTITLE: Example of Tail Call Stack Behavior in eBPF\nDESCRIPTION: This code snippet illustrates how stack sizes can accumulate when combining tail calls with BPF-to-BPF function calls. It demonstrates the potential for stack growth across multiple function and tail call invocations.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/concepts/tail-calls.md#2025-04-22_snippet_0\n\nLANGUAGE: C\nCODE:\n```\nfunc1 -> sub rsp, 128\n subfunc1 -> sub rsp, 256\n tailcall1 -> add rsp, 256\n  func2 -> sub rsp, 192 (total stack size = 128 + 192 = 320)\n  subfunc2 -> sub rsp, 64\n  subfunc22 -> sub rsp, 128\n  tailcall2 -> add rsp, 128\n   func3 -> sub rsp, 32 (total stack size 128 + 192 + 64 + 32 = 416)\n```\n\n----------------------------------------\n\nTITLE: Using bpf_ringbuf_submit in eBPF Program\nDESCRIPTION: This example demonstrates how to use the 'bpf_ringbuf_submit' function in an eBPF program. It shows the process of reserving space in the ring buffer, filling it with data, and then submitting it using bpf_ringbuf_submit.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_ringbuf_submit.md#2025-04-22_snippet_1\n\nLANGUAGE: c\nCODE:\n```\n// Reserve space in the ring buffer\nstruct ringbuf_data *rb_data = bpf_ringbuf_reserve(&my_ringbuf, sizeof(struct ringbuf_data), 0);\nif(!rb_data) {\n    // if bpf_ringbuf_reserve fails, print an error message and return\n    bpf_printk(\"bpf_ringbuf_reserve failed\\n\");\n    return 1;\n}\n\n// Fill the reserved data with some values\nrb_data->data = 42;\nrb_data->timestamp = bpf_ktime_get_ns();\n\n// Submit the reserved data\nbpf_ringbuf_submit(rb_data, 0);\n```\n\n----------------------------------------\n\nTITLE: Defining BTF Map Type Properties with __type Macro in C\nDESCRIPTION: This snippet shows how to use the '__type' macro to define key and value types in a BTF map. The map is defined as a hash map with 1024 max entries, using __u32 as the key type and a custom structure as the value type.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/ebpf/__type.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstruct {\n    __uint(type, BPF_MAP_TYPE_HASH);\n    __uint(max_entries, 1024);\n    __type(key, __u32);\n    __type(value, struct example_struct);\n} SEC(\".maps\") my_map;\n```\n\n----------------------------------------\n\nTITLE: Reconstructing Tracepoint Event Context Struct - C\nDESCRIPTION: Defines the expected context structure for a tracepoint event handler in C, based on information gleaned from the tracefs event format file. This C struct (xdp_exception_ctx) represents the arguments passed to the tracepoint eBPF program. Developers must match the field types and order exactly as emitted by the kernel for stable operation. No external dependencies besides standard kernel headers are required. The fields include common event metadata and specific tracepoint payload.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/program-type/BPF_PROG_TYPE_TRACEPOINT.md#2025-04-22_snippet_1\n\nLANGUAGE: c\nCODE:\n```\nstruct xdp_exception_ctx {\n    __u16 common_type;\n    __u8 flags;\n    __u8 common_preempt_count;\n    __s32 common_pid;\n\n    __s32 prog_int;\n    __u32 act;\n    __s32 ifindex;\n};\n```\n\n----------------------------------------\n\nTITLE: Using bpf_ksym_exists for Weak Symbol Detection in eBPF XDP Programs (C)\nDESCRIPTION: This snippet demonstrates practical usage of the 'bpf_ksym_exists' macro to conditionally utilize a weak symbol function in an eBPF XDP program. It applies the macro to check for the runtime availability of 'bpf_dynptr_from_xdp', ensuring correctness when the symbol may or may not be present. The code distinguishes between cases where the helper is available or requires fallback logic, protecting against errors and improving portability. Dependencies include libbpf, eBPF-compatible kernel, and prior macro definition; key parameters are the 'ctx' context, and the program drops or passes packets based on Ethernet protocol. Inputs are XDP context, and outputs are XDP_DROP or XDP_PASS return codes.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/ebpf/bpf_ksym_exists.md#2025-04-22_snippet_1\n\nLANGUAGE: c\nCODE:\n```\nextern int bpf_dynptr_from_xdp(struct xdp_md *x, u64 flags, struct bpf_dynptr *ptr__uninit) __weak __ksym;\n\nSEC(\"xdp.frags\")\nint example_prog(struct xdp_md *ctx)\n{\n    if (bpf_ksym_exists(bpf_dynptr_from_xdp)) {\n        struct bpf_dynptr ptr;\n        if (bpf_dynptr_from_xdp(ctx, 0, &ptr) < 0)\n            return XDP_DROP;\n\n        __u8 buf[sizeof(struct ethhdr)];\n        struct ethhdr *eth = bpf_dynptr_slice(&ptr, buf, sizeof(buf));\n        if (!eth)\n            return XDP_DROP;\n\n        if (eth->h_proto == htons(ETH_P_IP))\n            return XDP_PASS;\n    } else {\n        void *data_end = (void *)(long)ctx->data_end;\n        void *data = (void *)(long)ctx->data;\n\n        if (data + sizeof(struct ethhdr) > data_end)\n            return XDP_DROP;\n\n        struct ethhdr *eth = data;\n        if (eth->h_proto == htons(ETH_P_IP))\n            return XDP_PASS;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Basic KFunc Implementation in eBPF\nDESCRIPTION: Demonstrates how to implement and use KFuncs in an eBPF program, showing task acquisition and release operations. The example includes proper function declarations with __ksym attributes and necessary includes.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/concepts/kfuncs.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n#include <vmlinux.h>\n#include <bpf/bpf_helpers.h>\n\nextern struct task_struct *bpf_task_acquire(struct task_struct *p) __ksym;\n\nextern void bpf_task_release(struct task_struct *p) __ksym;\n\nSEC(\"tp_btf/task_newtask\")\nint BPF_PROG(task_acquire_release_example, struct task_struct *task, u64 clone_flags)\n{\n    struct task_struct *acquired;\n\n    acquired = bpf_task_acquire(task);\n    if (acquired)\n            /*\n                * In a typical program you'd do something like store\n                * the task in a map, and the map will automatically\n                * release it later. Here, we release it manually.\n                */\n            bpf_task_release(acquired);\n    return 0;\n}\n\nchar _license[] SEC(\"license\") = \"GPL\";\n```\n\n----------------------------------------\n\nTITLE: Using BPF_SNPRINTF for Dynamic Event String Formatting in eBPF (libbpf) with C\nDESCRIPTION: This snippet demonstrates the use of 'BPF_SNPRINTF' within an eBPF program to format packet metadata and log it to a ring buffer, showing realistic integration with BPF maps and helpers. It sets up a ring buffer map, reserves space for output, uses the macro to format network interface and address data into the buffer, and conditionally submits the formatted string. Prerequisites include the libbpf environment, support for ringbuf maps, and that the networking context ('__sk_buff') provides necessary fields. Key parameters involve ringbuf configuration, output size, format string, and packet context. Output is stored in BPF ringbuf; truncation is flagged if output length exceeds buffer size.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/ebpf/bpf_snprintf.md#2025-04-22_snippet_1\n\nLANGUAGE: c\nCODE:\n```\nstruct {\n    __uint(type, BPF_MAP_TYPE_RINGBUF);\n    __uint(max_entries, 4096);\n} ringbuf SEC(\".maps\");\n\nSEC(\"tc\")\nint example_prog(struct __sk_buff *ctx)\n{\n    const int size = 100;\n    char *str_out = bpf_ringbuf_reserve(&ringbuf, size, 0);\n    if (!str_out)\n        return TC_ACT_OK;\n\n    // `len` is the length of the formatted string including NULL-termination char.\n    // if `len` > `size` then the string was truncated.\n    // `len` can also be -EBUSY if the per-CPU memory copy buffer is busy.\n    long len = BPF_SNPRINTF(str_out, size,\n        \"Got a packet from interface %d, src: %pi4, dst: %pi4, src port: %d, dst port: %d\\n\", \n        ctx->ingress_ifindex, \n        ctx->remote_ip4, \n        ctx->local_ip4,\n        ctx->remote_port,\n        ctx->local_port\n    );\n\n    bpf_ringbuf_submit(str_out, 0);\n\n    return TC_ACT_OK;\n}\n\n```\n\n----------------------------------------\n\nTITLE: Creating and Managing an eBPF Sockmap from Userspace in C\nDESCRIPTION: This C function demonstrates the userspace setup for an eBPF sockmap. It creates a map of type `BPF_MAP_TYPE_SOCKMAP` using `bpf_map_create`. It then attaches provided BPF programs (parser and verdict, identified by file descriptors `parse_prog_fd` and `verdict_prog_fd`) to the map using `bpf_prog_attach`. Finally, it inserts a socket file descriptor (`sock`) into the map at index 0 using `bpf_map_update_elem`, ensuring it doesn't overwrite an existing entry (`BPF_NOEXIST`). Error handling is included, and the map file descriptor is closed before returning. This function depends on BPF system calls or a library like libbpf and requires valid file descriptors for the socket and BPF programs.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/program-type/BPF_PROG_TYPE_SK_SKB.md#2025-04-22_snippet_2\n\nLANGUAGE: c\nCODE:\n```\n// Copyright Red Hat\nint create_sample_sockmap(int sock, int parse_prog_fd, int verdict_prog_fd)\n{\n        int index = 0;\n        int map, err;\n\n        map = bpf_map_create(BPF_MAP_TYPE_SOCKMAP, NULL, sizeof(int), sizeof(int), 1, NULL);\n        if (map < 0) {\n                fprintf(stderr, \"Failed to create sockmap: %s\\n\", strerror(errno));\n                return -1;\n        }\n\n        err = bpf_prog_attach(parse_prog_fd, map, BPF_SK_SKB_STREAM_PARSER, 0);\n        if (err){\n                fprintf(stderr, \"Failed to attach_parser_prog_to_map: %s\\n\", strerror(errno));\n                goto out;\n        }\n\n        err = bpf_prog_attach(verdict_prog_fd, map, BPF_SK_SKB_STREAM_VERDICT, 0);\n        if (err){\n                fprintf(stderr, \"Failed to attach_verdict_prog_to_map: %s\\n\", strerror(errno));\n                goto out;\n        }\n\n        err = bpf_map_update_elem(map, &index, &sock, BPF_NOEXIST);\n        if (err) {\n                fprintf(stderr, \"Failed to update sockmap: %s\\n\", strerror(errno));\n                goto out;\n        }\n\nout:\n        close(map);\n        return err;\n}\n```\n\n----------------------------------------\n\nTITLE: BPF Trampoline Assembly Implementation\nDESCRIPTION: Demonstrates how BPF trampolines modify function execution by redirecting to generated_bpf_trampoline.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/concepts/trampolines.md#2025-04-22_snippet_3\n\nLANGUAGE: assembly\nCODE:\n```\n# Symbol where instructions like: CALL some_kernel_func will jump to.\nsome_kernel_func:\n  CALL generated_bpf_trampoline\n  RET\n# actual start of the function\n  PUSH RBP\n  MOV RSP, RBP\n  [...]\n  RET\n```\n\n----------------------------------------\n\nTITLE: Retrieving libbpf version string in C\nDESCRIPTION: Function signature of libbpf_version_string which returns the libbpf version as a NULL-terminated string. This function takes no parameters and was introduced in libbpf version 0.6.0.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/libbpf_version_string.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nconst char *libbpf_version_string(void);\n```\n\n----------------------------------------\n\nTITLE: Example of Using bpf_sock_addr_set_sun_path in a Cgroup Unix Socket Connect Program\nDESCRIPTION: A complete example program showing how to use bpf_sock_addr_set_sun_path to rewrite Unix socket addresses during connection establishment. The program runs in the cgroup/connect_unix context and modifies Unix socket paths.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/bpf_sock_addr_set_sun_path.md#2025-04-22_snippet_1\n\nLANGUAGE: c\nCODE:\n```\n// SPDX-License-Identifier: GPL-2.0\n/* Copyright (c) 2022 Meta Platforms, Inc. and affiliates. */\n\n#include \"vmlinux.h\"\n\n#include <string.h>\n#include <bpf/bpf_helpers.h>\n#include <bpf/bpf_core_read.h>\n#include \"bpf_kfuncs.h\"\n\n__u8 SERVUN_REWRITE_ADDRESS[] = \"\\0bpf_cgroup_unix_test_rewrite\";\n\nSEC(\"cgroup/connect_unix\")\nint connect_unix_prog(struct bpf_sock_addr *ctx)\n{\n\tstruct bpf_sock_addr_kern *sa_kern = bpf_cast_to_kern_ctx(ctx);\n\tstruct sockaddr_un *sa_kern_unaddr;\n\t__u32 unaddrlen = offsetof(struct sockaddr_un, sun_path) +\n\t\t\t  sizeof(SERVUN_REWRITE_ADDRESS) - 1;\n\tint ret;\n\n\t/* Rewrite destination. */\n\tret = bpf_sock_addr_set_sun_path(sa_kern, SERVUN_REWRITE_ADDRESS,\n\t\t\t\t\t sizeof(SERVUN_REWRITE_ADDRESS) - 1);\n\tif (ret)\n\t\treturn 0;\n\n\tif (sa_kern->uaddrlen != unaddrlen)\n\t\treturn 0;\n\n\tsa_kern_unaddr = bpf_rdonly_cast(sa_kern->uaddr,\n\t\t\t\t\t\tbpf_core_type_id_kernel(struct sockaddr_un));\n\tif (memcmp(sa_kern_unaddr->sun_path, SERVUN_REWRITE_ADDRESS,\n\t\t\tsizeof(SERVUN_REWRITE_ADDRESS) - 1) != 0)\n\t\treturn 0;\n\n\treturn 1;\n}\n\nchar _license[] SEC(\"license\") = \"GPL\";\n```\n\n----------------------------------------\n\nTITLE: Using Dynamic Pointers with Ringbuffer and Callbacks\nDESCRIPTION: Demonstrates using dynamic pointers with the ringbuffer map type and passing them to callback functions. This shows how to reserve a dynamic-sized buffer, access fields within it, and modify data through callbacks.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/concepts/dynptrs.md#2025-04-22_snippet_2\n\nLANGUAGE: c\nCODE:\n```\nstatic int ringbuf_callback(__u32 index, void *data)\n{\n\tstruct sample *sample;\n\n\tstruct bpf_dynptr *ptr = (struct bpf_dynptr *)data;\n\n\tsample = bpf_dynptr_data(ptr, 0, sizeof(*sample));\n\tif (!sample)\n\t\terr = 2;\n\telse\n\t\tsample->pid += index;\n\n\treturn 0;\n}\n\nSEC(\"?tp/syscalls/sys_enter_nanosleep\")\nint test_ringbuf(void *ctx)\n{\n\tstruct bpf_dynptr ptr;\n\tstruct sample *sample;\n\n\tif (bpf_get_current_pid_tgid() >> 32 != pid)\n\t\treturn 0;\n\n\tval = 100;\n\n\t/* check that you can reserve a dynamic size reservation */\n\terr = bpf_ringbuf_reserve_dynptr(&ringbuf, val, 0, &ptr);\n\n\tsample = err ? NULL : bpf_dynptr_data(&ptr, 0, sizeof(*sample));\n\tif (!sample) {\n\t\terr = 1;\n\t\tgoto done;\n\t}\n\n\tsample->pid = 10;\n\n\t/* Can pass dynptr to callback functions */\n\tbpf_loop(10, ringbuf_callback, &ptr, 0);\n\n\tif (sample->pid != 55)\n\t\terr = 2;\n\n\tdone:\n\tbpf_ringbuf_discard_dynptr(&ptr, 0);\n\treturn 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Deleting an Element from a BPF Map using libbpf in C\nDESCRIPTION: Defines the 'bpf_map__delete_elem' C function from libbpf, used to delete an element from a specified BPF map using a key. Requires linking against libbpf and having a properly initialized struct bpf_map pointer. Parameters include the map pointer, key memory, key size (matching the BPF map definition), and optional flags (as __u64). Returns 0 on success or a negative error code on failure. Ensures key size compatibility, elevating safety over the lower-level equivalent.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_map__delete_elem.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nint bpf_map__delete_elem(const struct bpf_map *map, const void *key, size_t key_sz, __u64 flags);\n```\n\n----------------------------------------\n\nTITLE: Definition of bpf_dynptr_read eBPF Helper Function\nDESCRIPTION: The C function prototype for the bpf_dynptr_read helper, which allows reading len bytes from src into dst, starting from offset into src. This helper returns 0 on success, -E2BIG if offset+len exceeds source data length, or -EINVAL if src is invalid or flags is not 0.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_dynptr_read.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstatic long (* const bpf_dynptr_read)(void *dst, __u32 len, const struct bpf_dynptr *src, __u32 offset, __u64 flags) = (void *) 201;\n```\n\n----------------------------------------\n\nTITLE: Implementing IPv6 Packet Handling in eBPF XDP\nDESCRIPTION: This snippet handles IPv6 packet processing in an XDP context. It sets up the Ethernet and IPv6 headers, copies address information, and prepares the packet for transmission. The function ends by incrementing a transmission counter and returning XDP_TX to indicate the packet should be transmitted.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/bpf_dynptr_from_xdp.md#2025-04-22_snippet_3\n\nLANGUAGE: C\nCODE:\n```\nset_ethhdr(new_eth, old_eth, tnl, bpf_htons(ETH_P_IPV6));\n\nif (new_eth == eth_buffer)\n    bpf_dynptr_write(&new_xdp_ptr, 0, eth_buffer, sizeof(eth_buffer), 0);\n\nip6h->version = 6;\nip6h->priority = 0;\nmemset(ip6h->flow_lbl, 0, sizeof(ip6h->flow_lbl));\nip6h->payload_len = bpf_htons(bpf_ntohs(payload_len) + ipv6hdr_sz);\nip6h->nexthdr = IPPROTO_IPV6;\nip6h->hop_limit = 8;\nmemcpy(ip6h->saddr.s6_addr32, tnl->saddr.v6, sizeof(tnl->saddr.v6));\nmemcpy(ip6h->daddr.s6_addr32, tnl->daddr.v6, sizeof(tnl->daddr.v6));\n\ncount_tx(vip.protocol);\n\nreturn XDP_TX;\n```\n\n----------------------------------------\n\nTITLE: Mapping Consumer Page with mmap in C\nDESCRIPTION: The snippet demonstrates how to map a 'consumer' page from a ring-buffer using the 'mmap' system call in a userspace program. It is an essential part of accessing data from the ring-buffer in C. Required dependencies include standard C libraries. Key parameters like page size and map file descriptor must be set.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/map-type/BPF_MAP_TYPE_RINGBUF.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nconsumer = mmap(NULL, rb->page_size, PROT_READ | PROT_WRITE, MAP_SHARED, map_fd, 0);\n```\n\n----------------------------------------\n\nTITLE: Generating vmlinux.h Header Using bpftool\nDESCRIPTION: Command to generate a vmlinux.h header file using bpftool by dumping BTF information from the kernel. This eliminates the dependency on kernel headers by extracting type information directly from the running kernel.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/concepts/core.md#2025-04-22_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\nbpftool btf dump file /sys/kernel/btf/vmlinux format c > vmlinux.h\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_ringbuf_output Helper Function in C\nDESCRIPTION: C function definition for the bpf_ringbuf_output eBPF helper. It copies data into a ring buffer with optional notification flags.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_ringbuf_output.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstatic long (* const bpf_ringbuf_output)(void *ringbuf, void *data, __u64 size, __u64 flags) = (void *) 130;\n```\n\n----------------------------------------\n\nTITLE: Allocating UMEM for AF_XDP Socket in C\nDESCRIPTION: This code allocates memory for the UMEM (User Memory) component of an AF_XDP socket, setting up chunk size and count.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/concepts/af_xdp.md#2025-04-22_snippet_1\n\nLANGUAGE: c\nCODE:\n```\nstatic const int chunk_size = 4096;\nstatic const int chunk_count = 4096;\nstatic const int umem_len = chunk_size * chunk_count;\nunsigned char[chunk_count][chunk_size] umem = malloc(umem_len);\n```\n\n----------------------------------------\n\nTITLE: Reading VLAN Metadata from XDP Data in eBPF TC Program (C)\nDESCRIPTION: This eBPF TC C program demonstrates how to read VLAN metadata previously stored by an XDP program in the data_meta region of an sk_buff. The program expects a struct meta_info laid out before the packet, checks validity, and prints the VLAN ID or a suitable message depending on the rx_vlan_tag_status. It assumes cooperation with a corresponding XDP program and proper metadata storage, and is typically attached to the ingress hook with tc. Output is always TC_ACT_OK, and users should ensure meta_info alignment and data region bounds.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/bpf_xdp_metadata_rx_vlan_tag.md#2025-04-22_snippet_1\n\nLANGUAGE: c\nCODE:\n```\n/* A separate tc filter program, that works in collaboration with the XDP code\n * above and uses VLAN information stored by XDP in the skb->data_meta area.\n * bpftool prog loadall test_tc.bpf.o /sys/fs/bpf/prog\n * tc filter add dev eth1 ingress bpf object-pinned /sys/fs/bpf/prog/tc_ingress_test_vlan\n */\n\n#include \"vmlinux.h\"\n\n#include <bpf/bpf_helpers.h>\n#include <bpf/bpf_endian.h>\n#include \"bpf_tracing_net.h\"\n\n#define NO_VLAN_DETECTED 0xffffffff\n\nstruct meta_info {\n\tu16 vlan_proto;\n\tu16 vlan_tci;\n\tint rx_vlan_tag_status;\n};\n\nSEC(\"tc\")\nint tc_ingress_test_vlan(struct __sk_buff *skb)\n{\n\n\tvoid *data = (void *)(unsigned long)skb->data;\n\tvoid *data_meta = (void *)(unsigned long)skb->data_meta;\n\tstruct meta_info *meta = data_meta;\n\n\tif (meta + 1 > data) {\n\t\tbpf_printk(\"No metadata associate with skb.\\n\");\n\t\treturn TC_ACT_OK;\n\t}\n\n\tif (meta->rx_vlan_tag_status == 0)\n\t\tbpf_printk(\"VID=%d\\n\", meta->vlan_tci & 0x0fff);\n\telse if (meta->rx_vlan_tag_status == 0xffffffff)\n\t\tbpf_printk(\"No VLAN tag detected\\n\");\n\telse\n\t\tbpf_printk(\"VLAN was stripped by driver, \"\n\t\t           \"but bpf_xdp_metadata_rx_vlan_tag returned %d\\n\",\n\t\t           meta->rx_vlan_tag_status);\n\n\treturn TC_ACT_OK;\n}\n\nchar _license[] SEC(\"license\") = \"GPL\";\n\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_lwt_seg6_store_bytes Helper Function in C\nDESCRIPTION: This code snippet defines the bpf_lwt_seg6_store_bytes helper function. It stores bytes from a source address into the packet associated with an sk_buff, specifically modifying the IPv6 Segment Routing Header.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_lwt_seg6_store_bytes.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstatic long (* const bpf_lwt_seg6_store_bytes)(struct __sk_buff *skb, __u32 offset, const void *from, __u32 len) = (void *) 74;\n```\n\n----------------------------------------\n\nTITLE: Defining a Spin Lock Structure for eBPF Map Values\nDESCRIPTION: This snippet shows how to define a struct with a bpf_spin_lock field and create a BPF map that uses this structure. The spin lock enables synchronized access to shared map values.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/concepts/concurrency.md#2025-04-22_snippet_1\n\nLANGUAGE: c\nCODE:\n```\nstruct concurrent_element {\n\tstruct bpf_spin_lock semaphore;\n\tint count;\n}\n\nstruct {\n\t__uint(type, BPF_MAP_TYPE_HASH);\n\t__type(key, int);\n\t__type(value, struct concurrent_element);\n\t__uint(max_entries, 100);\n} concurrent_map SEC(\".maps\");\n```\n\n----------------------------------------\n\nTITLE: Inspecting Tracepoint Event Format via tracefs - Bash\nDESCRIPTION: Demonstrates how to read the format definition of a kernel tracepoint event (such as xdp_exception) using the bash shell. This approach requires the tracefs filesystem to be mounted, usually at /sys/kernel/tracing. The file /sys/kernel/tracing/events/xdp/xdp_exception/format contains C struct-like definitions for the event context, which helps developers reconstruct the precise argument layout to be used when attaching eBPF tracepoint programs.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/program-type/BPF_PROG_TYPE_TRACEPOINT.md#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ncat /sys/kernel/tracing/events/xdp/xdp_exception/format\n```\n\n----------------------------------------\n\nTITLE: Extracting VLAN Metadata Using bpf_xdp_metadata_rx_vlan_tag in eBPF XDP Program (C)\nDESCRIPTION: This C eBPF XDP program demonstrates how to use the bpf_xdp_metadata_rx_vlan_tag kfunc to extract VLAN header information, storing the result in a meta_info struct placed prior to packet data with bpf_xdp_adjust_meta. It covers both cases where the VLAN tag is present in the linear packet data and where it is only available via metadata provided by the NIC driver (due to hardware offload). Dependencies include kernel headers (vmlinux.h), bpf_helpers, and bpf_endian, and assumes the program is loaded using bpftool with the XDP meta context. Input is an xdp_md context, and output indicates XDP action (pass/drop/abort) based on success. Users must ensure proper memory bounds checking and handle the absence of VLAN metadata.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/bpf_xdp_metadata_rx_vlan_tag.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n/* XDP program example to show a typical usage of bpf_xdp_metadata_rx_vlan_tag.\n * It could be loaded and attached via following commands:\n * bpftool prog load test_xdp.bpf.o /sys/fs/bpf/prog/xdp_test_vlan type xdp xdpmeta_dev eth1\n * bpftool net attach xdp name xdp_test_vlan dev eth1\n */\n\n#include \"vmlinux.h\"\n\n#include <bpf/bpf_helpers.h>\n#include <bpf/bpf_endian.h>\n#include <linux/errno.h>\n\n#include \"bpf_tracing_net.h\"\n\n#define NO_VLAN_DETECTED 0xffffffff\n\nstruct meta_info {\n\tu16 vlan_proto;\n\tu16 vlan_tci;\n\tint rx_vlan_tag_status;\n};\n\nextern int bpf_xdp_metadata_rx_vlan_tag(const struct xdp_md *ctx,\n\t\t\t\t\t__be16 *vlan_proto,\n\t\t\t\t\t__u16 *vlan_tci) __ksym;\n\nSEC(\"xdp\")\nint xdp_test_vlan(struct xdp_md *xdp) {\n\n\tvoid *data, *data_end, *data_meta;\n\tstruct ethhdr *eth;\n\tstruct vlan_ethhdr *eth_vlan;\n\tstruct meta_info *meta;\n\tu32 eth_proto;\n\n\tif (bpf_xdp_adjust_meta(xdp, -(int)sizeof(*meta)) < 0) {\n\t\tbpf_printk(\"Cannot allocate %ld bytes for metadata\\n\",\n\t\t\t   sizeof(*meta));\n\t\treturn XDP_ABORTED;\n\t}\n\n\tdata = (void *)(unsigned long)xdp->data;\n\tdata_meta = (void *)(unsigned long)xdp->data_meta;\n\tdata_end = (void *)(unsigned long)xdp->data_end;\n\tmeta = data_meta;\n\n\t/* Check that data_meta have room for meta_info struct */\n\tif (meta + 1 > data) {\n\t\treturn XDP_ABORTED;\n\t}\n\tmeta->rx_vlan_tag_status = NO_VLAN_DETECTED;\n\n\teth = (struct ethhdr *)data;\n\tif (eth + 1 > data_end)\n\t\treturn XDP_DROP;\n\n\teth_proto = bpf_ntohs(eth->h_proto);\n\n\tif (eth_proto == ETH_P_8021Q) {\n\t\teth_vlan = (struct vlan_ethhdr *)data;\n\t\tif (eth_vlan + 1 > data_end)\n\t\t\treturn XDP_DROP;\n\n\t\tmeta->vlan_proto = eth_proto;\n\t\tmeta->vlan_tci = bpf_ntohs(eth_vlan->h_vlan_TCI);\n\t\tmeta->rx_vlan_tag_status = 0;\n\t\tbpf_printk(\"VID=%d from XDP linear data\\n\",\n\t\t           meta->vlan_tci & 0x0fff);\n\t\teth_proto = bpf_ntohs(eth_vlan->h_vlan_encapsulated_proto);\n\n\t} else {\n\t\t/* check if VLAN was stripped by driver */\n\t\tmeta->rx_vlan_tag_status = bpf_xdp_metadata_rx_vlan_tag(xdp, &meta->vlan_proto,\n\t\t\t\t\t\t\t\t\t\t&meta->vlan_tci);\n\t\tif (meta->rx_vlan_tag_status == 0)\n\t\t\tbpf_printk(\"VID=%d reported by driver\\n\", meta->vlan_tci & 0x0fff);\n\t\tif (meta->rx_vlan_tag_status == -ENODATA) {\n\t\t\tbpf_printk(\"no VLAN reported by driver\\n\");\n\t\t\tmeta->rx_vlan_tag_status = NO_VLAN_DETECTED;\n\t\t}\n\n\t}\n\n\treturn XDP_PASS;\n}\n\nchar _license[] SEC(\"license\") = \"GPL\";\n\n```\n\n----------------------------------------\n\nTITLE: Using bpf_sk_assign in Traffic Control Classifier\nDESCRIPTION: Example of using bpf_sk_assign in a BPF_PROG_TYPE_SCHED_CLS program to handle TCP and UDP traffic and assign sockets based on packet information.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_sk_assign.md#2025-04-22_snippet_2\n\nLANGUAGE: c\nCODE:\n```\nstruct {\n\t__u32 type;\n\t__u32 size_key;\n\t__u32 size_value;\n\t__u32 max_elem;\n\t__u32 flags;\n\t__u32 id;\n\t__u32 pinning;\n} server_map SEC(\"maps\") = {\n\t.type = BPF_MAP_TYPE_SOCKMAP,\n\t.size_key = sizeof(int),\n\t.size_value  = sizeof(__u64),\n\t.max_elem = 1,\n\t.pinning = PIN_GLOBAL_NS,\n};\n\nstatic inline int\nhandle_udp(struct __sk_buff *skb, struct bpf_sock_tuple *tuple, bool ipv4)\n{\n\tstruct bpf_sock *sk;\n\tconst int zero = 0;\n\tsize_t tuple_len;\n\t__be16 dport;\n\tint ret;\n\n\ttuple_len = ipv4 ? sizeof(tuple->ipv4) : sizeof(tuple->ipv6);\n\tif ((void *)tuple + tuple_len > (void *)(long)skb->data_end)\n\t\treturn TC_ACT_SHOT;\n\n\tsk = bpf_sk_lookup_udp(skb, tuple, tuple_len, BPF_F_CURRENT_NETNS, 0);\n\tif (sk)\n\t\tgoto assign;\n\n\tdport = ipv4 ? tuple->ipv4.dport : tuple->ipv6.dport;\n\tif (dport != bpf_htons(4321))\n\t\treturn TC_ACT_OK;\n\n\tsk = bpf_map_lookup_elem(&server_map, &zero);\n\tif (!sk)\n\t\treturn TC_ACT_SHOT;\n\nassign:\n\tret = bpf_sk_assign(skb, sk, 0);\n\tbpf_sk_release(sk);\n\treturn ret;\n}\n\nstatic inline int\nhandle_tcp(struct __sk_buff *skb, struct bpf_sock_tuple *tuple, bool ipv4)\n{\n\tstruct bpf_sock *sk;\n\tconst int zero = 0;\n\tsize_t tuple_len;\n\t__be16 dport;\n\tint ret;\n\n\ttuple_len = ipv4 ? sizeof(tuple->ipv4) : sizeof(tuple->ipv6);\n\tif ((void *)tuple + tuple_len > (void *)(long)skb->data_end)\n\t\treturn TC_ACT_SHOT;\n\n\tsk = bpf_skc_lookup_tcp(skb, tuple, tuple_len, BPF_F_CURRENT_NETNS, 0);\n\tif (sk) {\n\t\tif (sk->state != BPF_TCP_LISTEN)\n\t\t\tgoto assign;\n\t\tbpf_sk_release(sk);\n\t}\n\n\tdport = ipv4 ? tuple->ipv4.dport : tuple->ipv6.dport;\n\tif (dport != bpf_htons(4321))\n\t\treturn TC_ACT_OK;\n\n\tsk = bpf_map_lookup_elem(&server_map, &zero);\n\tif (!sk)\n\t\treturn TC_ACT_SHOT;\n\n\tif (sk->state != BPF_TCP_LISTEN) {\n\t\tbpf_sk_release(sk);\n\t\treturn TC_ACT_SHOT;\n\t}\n\nassign:\n\tret = bpf_sk_assign(skb, sk, 0);\n\tbpf_sk_release(sk);\n\treturn ret;\n}\n\nSEC(\"tc\")\nint bpf_sk_assign_test(struct __sk_buff *skb)\n{\n\tstruct bpf_sock_tuple *tuple;\n\tbool ipv4 = false;\n\tbool tcp = false;\n\tint tuple_len;\n\tint ret = 0;\n\n\ttuple = get_tuple(skb, &ipv4, &tcp);\n\tif (!tuple)\n\t\treturn TC_ACT_SHOT;\n\n\tif (tcp)\n\t\tret = handle_tcp(skb, tuple, ipv4);\n\telse\n\t\tret = handle_udp(skb, tuple, ipv4);\n\n\treturn ret == 0 ? TC_ACT_OK : TC_ACT_SHOT;\n}\n```\n\n----------------------------------------\n\nTITLE: Function Argument Annotations in eBPF\nDESCRIPTION: Shows the available BTF declaration tags for annotating global function arguments in eBPF programs introduced in v6.8.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/concepts/functions.md#2025-04-22_snippet_1\n\nLANGUAGE: C\nCODE:\n```\n__arg_ctx\n__arg_nonnull\n__arg_nullable\n__arg_trusted\n__arg_arena\n```\n\n----------------------------------------\n\nTITLE: Applying '__arg_ctx' for Reusable eBPF Helper Functions (C)\nDESCRIPTION: This C code demonstrates the usage of the '__arg_ctx' macro. It defines a perf event map ('events') and a reusable helper function 'send_msg' which accepts a generic 'void *ctx' argument tagged with '__arg_ctx'. This tag informs the eBPF verifier that 'ctx' represents a program context, allowing the function to be safely called from different eBPF program types (a kprobe and an fentry in this example) using 'bpf_perf_event_output'. The example shows how 'send_msg' is invoked with the specific context ('ctx' or implicitly 'ctx' via BPF_PROG macro) from each program.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/ebpf/__arg_ctx.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n```c hl_lines=\"7\"\nstruct {\n    __uint(type, BPF_MAP_TYPE_PERF_EVENT_ARRAY);\n    __uint(key_size, sizeof(__u32));\n    __uint(value_size, sizeof(int));\n} events SEC(\".maps\");\n\nint send_msg(void *ctx __arg_ctx)\n{\n    char msg[] = \"Some common message\";\n\treturn bpf_perf_event_output(ctx, &events, 0, msg, sizeof(msg));\n}\n\nSEC(\"kprobe/eth_type_trans\")\nint kprobe__sys_open(struct pt_regs *ctx)\n{\n    send_msg(ctx);\n    return 0;\n}\n\nSEC(\"fentry/eth_type_trans\")\nint BPF_PROG(fentry_eth_type_trans, struct sk_buff *skb,\n\t     struct net_device *dev, unsigned short protocol)\n{\n    // Note: The BPF_PROG does some magic to give us typed arguments, but `ctx` is still preserved as the\n    // context passed into the program.\n\tsend_msg(ctx);\n    return 0;\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Defining BTF-Style eBPF Map in C\nDESCRIPTION: Shows the newer method of defining eBPF maps using BTF (BPF Type Format) style. This approach preserves type information and is located in the .maps section.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/concepts/maps.md#2025-04-22_snippet_1\n\nLANGUAGE: C\nCODE:\n```\nstruct my_value { int x, y, z; };\n\nstruct {\n\t__uint(type, BPF_MAP_TYPE_ARRAY);\n\t__type(key, int);\n\t__type(value, struct my_value);\n\t__uint(max_entries, 16);\n} icmpcnt SEC(\".maps\");\n```\n\n----------------------------------------\n\nTITLE: Defining a kprobe with BPF_KPROBE macro in C\nDESCRIPTION: Example of defining a kprobe program using the BPF_KPROBE macro which allows defining function signatures similar to the functions being traced, with type information and automatic argument casting.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/program-type/BPF_PROG_TYPE_KPROBE.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nSEC(\"kprobe/proc_sys_write\")\nint BPF_KPROBE(my_kprobe_example,\n\t\t   struct file* filp, const char* buf,\n\t\t   size_t count, loff_t* ppos) {\n    ...\n}\n```\n\n----------------------------------------\n\nTITLE: Function Definition - bpf_probe_read_kernel_str\nDESCRIPTION: Core definition of the bpf_probe_read_kernel_str helper function that copies a null-terminated string from an unsafe kernel address to a destination buffer.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_probe_read_kernel_str.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstatic long (* const bpf_probe_read_kernel_str)(void *dst, __u32 size, const void *unsafe_ptr) = (void *) 115;\n```\n\n----------------------------------------\n\nTITLE: Kernel Function Assembly With CONFIG_FUNCTION_TRACER (No Tracing)\nDESCRIPTION: Demonstrates assembly code structure with CONFIG_FUNCTION_TRACER enabled but no active tracing, showing NOP instruction placement.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/concepts/trampolines.md#2025-04-22_snippet_1\n\nLANGUAGE: assembly\nCODE:\n```\n# Symbol where instructions like: CALL some_kernel_func will jump to.\nsome_kernel_func:\n  NOP\n  NOP\n# actual start of the function\n  PUSH RBP\n  MOV RSP, RBP\n  ...\n  RET\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_probe_read_kernel Helper Function in C\nDESCRIPTION: This snippet defines the 'bpf_probe_read_kernel' helper function, which safely reads data from kernel space into a destination buffer. It returns 0 on success or a negative error code on failure.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_probe_read_kernel.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstatic long (* const bpf_probe_read_kernel)(void *dst, __u32 size, const void *unsafe_ptr) = (void *) 113;\n```\n\n----------------------------------------\n\nTITLE: Example Usage of 'bpf_core_field_size' in an eBPF Kprobe (C)\nDESCRIPTION: This C code demonstrates a practical application of 'bpf_core_field_size' within an eBPF kprobe program. It defines a potential kernel struct, then uses the macro within the kprobe function ('kprobe__example') to get the size of 'field1' from the struct pointed to by the function's first argument ('a'). This size is then used with 'bpf_core_read_int' to safely read the field's value, accommodating potential size differences across kernel versions. Requires libbpf for loading and relies on BTF information.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/ebpf/bpf_core_field_size.md#2025-04-22_snippet_2\n\nLANGUAGE: c\nCODE:\n```\nstruct some_kernel_struct {\n    __u16 field1; // This field might be smaller or larger on the target kernel\n}\n\nSEC(\"kprobe\")\nint kprobe__example(struct pt_regs *ctx)\n{\n    struct some_kernel_struct *a = PT_REGS_PARM1(ctx);\n\t__u64 tmp;\n\n\ttmp = 0;\n\tbpf_core_read_int(&tmp, bpf_core_field_size(a->field1), &a->field1);\n\n    // Do something with tmp\n    // ...\n\n    return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining BPF Attributes in C\nDESCRIPTION: This snippet defines the `bpf_attr` structure union in C for the 'BPF_PROG_LOAD' command. It includes various program attributes like `prog_type`, `insn_cnt`, and `license`, which are critical for loading eBPF programs into the kernel. The configuration reflects the dependencies on certain kernel version tags for expanded functionality.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/syscall/BPF_PROG_LOAD.md#2025-04-22_snippet_0\n\nLANGUAGE: C\nCODE:\n```\nunion bpf_attr {\n    struct {\n\t\t__u32           [prog_type](#prog_type);\n\t\t__u32           [insn_cnt](#insn_cnt);\n\t\t__aligned_u64   [insns](#insns);\n\t\t__aligned_u64   [license](#license);\n\t\t__u32           [log_level](#log_level);\n\t\t__u32           [log_size](#log_size);\n\t\t__aligned_u64   [log_buf](#log_buf);\n\t\t__u32           [kern_version](#kern_version);\n\t\t__u32           [prog_flags](#prog_flags);\n\t\tchar            [prog_name](#prog_name)[BPF_OBJ_NAME_LEN];\n\t\t__u32           [prog_ifindex](#prog_ifindex);\n\t\t__u32           [expected_attach_type](#expected_attach_type);\n\t\t__u32           [prog_btf_fd](#prog_btf_fd);\n\t\t__u32           [func_info_rec_size](#func_info_rec_size);\n\t\t__aligned_u64   [func_info](#func_info);\n\t\t__u32           [func_info_cnt](#func_info_cnt);\n\t\t__u32           [line_info_rec_size](#line_info_rec_size);\n\t\t__aligned_u64   [line_info](#line_info);\n\t\t__u32           [line_info_cnt](#line_info_cnt);\n\t\t__u32           [attach_btf_id](#attach_btf_id);\n\t\tunion {\n\t\t\t__u32       [attach_prog_fd](#attach_prog_fd);\n\t\t\t__u32       [attach_btf_obj_fd](#attach_btf_obj_fd);\n\t\t};\n\t\t__u32           [core_relo_cnt](#core_relo_cnt);\n\t\t__aligned_u64   [fd_array](#fd_array);\n\t\t__aligned_u64   [core_relos](#core_relos);\n\t\t__u32           [core_relo_rec_size](#core_relo_rec_size);\n\t\t__u32           [log_true_size](#log_true_size);\n\t\t__s32           [prog_token_fd](#prog_token_fd);\n\t\t__u32           [fd_array_cnt](#fd_array_cnt);\n\t};\n}\n```\n\n----------------------------------------\n\nTITLE: Using BPF_KSYSCALL to Trace 'write' Syscall in C (eBPF)\nDESCRIPTION: This C code demonstrates using the `BPF_KSYSCALL` macro within an eBPF program to trace the `write` syscall. The `SEC(\"ksyscall/write\")` directive attaches the program to the syscall entry. `BPF_KSYSCALL` defines the function `bpf_prog3` and automatically provides the syscall arguments (`fd`, `buf`, `count`) typed correctly, abstracting away the need to manually read registers using `PT_REGS_*` macros. The program calculates a histogram key based on process/user info and the logarithm of the write size, then updates a count in the `my_hist_map` eBPF map. It relies on libbpf helper functions like `bpf_map_lookup_elem`, `bpf_map_update_elem`, and functions to get current process/user context.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/ebpf/BPF_KSYSCALL.md#2025-04-22_snippet_1\n\nLANGUAGE: c\nCODE:\n```\nSEC(\"ksyscall/write\")\nint BPF_KSYSCALL(bpf_prog3, unsigned int fd, const char *buf, size_t count)\n{\n\\tlong init_val = 1;\n\\tlong *value;\n\\tstruct hist_key key;\n\n\\tkey.index = log2l(count);\n\\tkey.pid_tgid = bpf_get_current_pid_tgid();\n\\tkey.uid_gid = bpf_get_current_uid_gid();\n\\tbpf_get_current_comm(&key.comm, sizeof(key.comm));\n\n\\tvalue = bpf_map_lookup_elem(&my_hist_map, &key);\n\\tif (value)\n\\t\\t__sync_fetch_and_add(value, 1);\n\\telse\n\\t\\tbpf_map_update_elem(&my_hist_map, &key, &init_val, BPF_ANY);\n\\treturn 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_program__attach_tracepoint function in C\nDESCRIPTION: This code snippet defines the bpf_program__attach_tracepoint function, which attaches a BPF_PROG_TYPE_TRACEPOINT program. It takes a BPF program, tracepoint category, and tracepoint name as parameters, and returns a reference to the newly created BPF link or NULL on error.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_program__attach_tracepoint.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstruct bpf_link * bpf_program__attach_tracepoint(const struct bpf_program *prog, const char *tp_category, const char *tp_name);\n```\n\n----------------------------------------\n\nTITLE: Using BPF_USDT to Attach to a USDT Probe in C\nDESCRIPTION: Demonstrates attaching an eBPF program to the `urand:read_without_sema` USDT tracepoint located in the `./urandom_read` target using the `BPF_USDT` macro. The macro defines the eBPF program named `urand_read_without_sema` and declares its expected arguments (`iter_num`, `iter_cnt`, `buf_sz`), which are automatically retrieved and cast by the macro's underlying mechanism (using `bpf_usdt_arg`). The program logic filters based on PID and uses BPF helper functions like `bpf_get_current_pid_tgid` and atomic operations. The `SEC` macro specifies the ELF section for USDT attachment.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/ebpf/BPF_USDT.md#2025-04-22_snippet_1\n\nLANGUAGE: c\nCODE:\n```\n```c hl_lines=\"4\"\n// SPDX-License-Identifier: GPL-2.0\n/* Copyright (c) 2022 Meta Platforms, Inc. and affiliates. */\nSEC(\"usdt/./urandom_read:urand:read_without_sema\")\nint BPF_USDT(urand_read_without_sema, int iter_num, int iter_cnt, int buf_sz)\n{\n\tif (urand_pid != (bpf_get_current_pid_tgid() >> 32))\n\t\treturn 0;\n\n\t__sync_fetch_and_add(&urand_read_without_sema_call_cnt, 1);\n\t__sync_fetch_and_add(&urand_read_without_sema_buf_sz_sum, buf_sz);\n\n\treturn 0;\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Defining eBPF Helper Function 'bpf_task_storage_get' in C\nDESCRIPTION: This C code snippet defines the eBPF helper function 'bpf_task_storage_get'. It is used to get a bpf_local_storage from the task, similar to retrieving a value from a map with a task as the key. The map must be of BPF_MAP_TYPE_TASK_STORAGE type. An optional flags parameter, BPF_LOCAL_STORAGE_GET_F_CREATE, can be used to create new storage if none exists. The function returns a bpf_local_storage pointer on success or NULL if not found or if there is an error while adding.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_task_storage_get.md#2025-04-22_snippet_0\n\nLANGUAGE: C\nCODE:\n```\nstatic void *(* const bpf_task_storage_get)(void *map, struct task_struct *task, void *value, __u64 flags) = (void *) 156;\n```\n\n----------------------------------------\n\nTITLE: Defining the 'sched_ext_ops' Struct in C for BPF Scheduler Extensions\nDESCRIPTION: Defines the `sched_ext_ops` structure in C, which holds function pointers and configuration fields for implementing a custom BPF scheduler extension (sched_ext) in the Linux kernel. This structure provides the interface for the kernel to interact with the BPF scheduler logic, enabling custom scheduling policies. Note: The definition shown might be slightly modified from the kernel source for readability.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/program-type/BPF_PROG_TYPE_STRUCT_OPS/sched_ext_ops.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstruct sched_ext_ops {\n    char [name](#name)[SCX_OPS_NAME_LEN];\n    u32  [dispatch_max_batch](#dispatch_max_batch);\n    u64  [flags](#flags);\n    u32  [timeout_ms](#timeout_ms);\n    u32  [exit_dump_len](#exit_dump_len);\n    u64  [hotplug_seq](#hotplug_seq);\n\n    s32  (*[select_cpu](#select_cpu))([struct task_struct](#struct-task_struct) *p, s32 prev_cpu, u64 wake_flags);\n    void (*[enqueue](#enqueue))([struct task_struct](#struct-task_struct) *p, u64 enq_flags);\n    void (*[dequeue](#dequeue))([struct task_struct](#struct-task_struct) *p, u64 deq_flags);\n    void (*[dispatch](#dispatch))(s32 cpu, [struct task_struct](#struct-task_struct) *prev);\n    void (*[tick](#tick))([struct task_struct](#struct-task_struct) *p);\n    void (*[runnable](#runnable))([struct task_struct](#struct-task_struct) *p, u64 enq_flags);\n    void (*[running](#running))([struct task_struct](#struct-task_struct) *p);\n    void (*[stopping](#stopping))([struct task_struct](#struct-task_struct) *p, bool runnable);\n    void (*[quiescent](#quiescent))([struct task_struct](#struct-task_struct) *p, u64 deq_flags);\n    bool (*[yield](#yield))([struct task_struct](#struct-task_struct) *from, [struct task_struct](#struct-task_struct) *to);\n    bool (*[core_sched_before](#core_sched_before))([struct task_struct](#struct-task_struct) *a, [struct task_struct](#struct-task_struct) *b);\n    void (*[set_weight](#set_weight))([struct task_struct](#struct-task_struct) *p, u32 weight);\n    void (*[set_cpumask](#set_cpumask))([struct task_struct](#struct-task_struct) *p, const [struct cpumask](#struct-cpumask) *cpumask);\n    void (*[update_idle](#update_idle))(s32 cpu, bool idle);\n    void (*[cpu_acquire](#cpu_acquire))(s32 cpu, [struct scx_cpu_acquire_args](#struct-scx_cpu_acquire_args) *args);\n    void (*[cpu_release](#cpu_release))(s32 cpu, [struct scx_cpu_release_args](#struct-scx_cpu_release_args) *args);\n    \n    s32  (*[init_task](#init_task))([struct task_struct](#struct-task_struct) *p, [struct scx_init_task_args](#struct-scx_init_task_args) *args);\n    void (*[exit_task](#exit_task))([struct task_struct](#struct-task_struct) *p, [struct scx_exit_task_args](#struct-scx_exit_task_args) *args);\n    \n    void (*[enable](#enable))([struct task_struct](#struct-task_struct) *p);\n    void (*[disable](#disable))([struct task_struct](#struct-task_struct) *p);\n    \n    void (*[dump](#dump))([struct scx_dump_ctx](#struct-scx_dump_ctx) *ctx);\n    void (*[dump_cpu](#dump_cpu))([struct scx_dump_ctx](#struct-scx_dump_ctx) *ctx, s32 cpu, bool idle);\n    void (*[dump_task](#dump_task))([struct scx_dump_ctx](#struct-scx_dump_ctx) *ctx, [struct task_struct](#struct-task_struct) *p);\n\n#ifdef CONFIG_EXT_GROUP_SCHED\n    s32  (*[cgroup_init](#cgroup_init))([struct cgroup](#struct-cgroup) *cgrp, [struct scx_cgroup_init_args](#struct-scx_cgroup_init_args) *args);\n    void (*[cgroup_exit](#cgroup_exit))([struct cgroup](#struct-cgroup) *cgrp);\n    s32  (*[cgroup_prep_move](#cgroup_prep_move))([struct task_struct](#struct-task_struct) *p, [struct cgroup](#struct-cgroup) *from, [struct cgroup](#struct-cgroup) *to);\n    void (*[cgroup_move](#cgroup_move))([struct task_struct](#struct-task_struct) *p, [struct cgroup](#struct-cgroup) *from, [struct cgroup](#struct-cgroup) *to);\n    void (*[cgroup_cancel_move](#cgroup_cancel_move))([struct task_struct](#struct-task_struct) *p, [struct cgroup](#struct-cgroup) *from, [struct cgroup](#struct-cgroup) *to);\n    void (*[cgroup_set_weight](#cgroup_set_weight))([struct cgroup](#struct-cgroup) *cgrp, u32 weight);\n#endif /* CONFIG_EXT_GROUP_SCHED */\n\n    void (*[cpu_online](#cpu_online))(s32 cpu);\n    void (*[cpu_offline](#cpu_offline))(s32 cpu);\n\n    s32  (*[init](#init))(void);\n    void (*[exit](#exit))([struct scx_exit_info](#struct-scx_exit_info) *info);\n};\n```\n\n----------------------------------------\n\nTITLE: Packet Processing Implementation in eBPF/C\nDESCRIPTION: Main packet processing logic that handles both IPv4 and IPv6 traffic, performs protocol parsing (TCP/UDP/ICMP), VIP lookup, and packet redirection. Includes tunnel key setting and statistics collection.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/bpf_dynptr_from_skb.md#2025-04-22_snippet_4\n\nLANGUAGE: c\nCODE:\n```\n        __u64 iph_len;\n        __u32 ifindex;\n        __u8 protocol;\n        __u32 vip_num;\n        int action;\n\n        tkey.tunnel_ttl = 64;\n        if (is_ipv6) {\n            __u8 buffer[sizeof(struct ipv6hdr)] = {};\n\n            ip6h = bpf_dynptr_slice(skb_ptr, off, buffer, sizeof(buffer));\n            if (!ip6h)\n                return TC_ACT_SHOT;\n\n            iph_len = sizeof(struct ipv6hdr);\n            protocol = ip6h->nexthdr;\n            pckt.proto = protocol;\n            pkt_bytes = bpf_ntohs(ip6h->payload_len);\n            off += iph_len;\n            if (protocol == IPPROTO_FRAGMENT) {\n                return TC_ACT_SHOT;\n            } else if (protocol == IPPROTO_ICMPV6) {\n                action = parse_icmpv6(skb_ptr, off, &pckt);\n                if (action >= 0)\n                    return action;\n                off += IPV6_PLUS_ICMP_HDR;\n            } else {\n                memcpy(pckt.srcv6, ip6h->saddr.s6_addr32, 16);\n                memcpy(pckt.dstv6, ip6h->daddr.s6_addr32, 16);\n            }\n        } else {\n            __u8 buffer[sizeof(struct iphdr)] = {};\n\n            iph = bpf_dynptr_slice(skb_ptr, off, buffer, sizeof(buffer));\n            if (!iph || iph->ihl != 5)\n                return TC_ACT_SHOT;\n\n            protocol = iph->protocol;\n            pckt.proto = protocol;\n            pkt_bytes = bpf_ntohs(iph->tot_len);\n            off += IPV4_HDR_LEN_NO_OPT;\n\n            if (iph->frag_off & PCKT_FRAGMENTED)\n                return TC_ACT_SHOT;\n            if (protocol == IPPROTO_ICMP) {\n                action = parse_icmp(skb_ptr, off, &pckt);\n                if (action >= 0)\n                    return action;\n                off += IPV4_PLUS_ICMP_HDR;\n            } else {\n                pckt.src = iph->saddr;\n                pckt.dst = iph->daddr;\n            }\n        }\n        protocol = pckt.proto;\n\n        if (protocol == IPPROTO_TCP) {\n            if (!parse_tcp(skb_ptr, off, &pckt))\n                return TC_ACT_SHOT;\n        } else if (protocol == IPPROTO_UDP) {\n            if (!parse_udp(skb_ptr, off, &pckt))\n                return TC_ACT_SHOT;\n        } else {\n            return TC_ACT_SHOT;\n        }\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_sk_ancestor_cgroup_id Helper Function in C\nDESCRIPTION: This code snippet defines the bpf_sk_ancestor_cgroup_id helper function. It returns the id of a cgroup v2 ancestor of the cgroup associated with the given socket at the specified ancestor level.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_sk_ancestor_cgroup_id.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstatic __u64 (* const bpf_sk_ancestor_cgroup_id)(void *sk, int ancestor_level) = (void *) 129;\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_redirect_map Helper Function in C\nDESCRIPTION: This snippet defines the 'bpf_redirect_map' helper function for eBPF programs. It redirects packets to endpoints referenced by a map at a specific key, supporting net device and CPU redirection.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_redirect_map.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstatic long (* const bpf_redirect_map)(void *map, __u64 key, __u64 flags) = (void *) 51;\n```\n\n----------------------------------------\n\nTITLE: Defining eBPF SYN Cookie Function in C\nDESCRIPTION: This C code snippet defines the eBPF helper function 'bpf_tcp_gen_syncookie'. It is intended to generate a SYN cookie for a packet by accepting a listening socket and IP/TCP headers. On success, it returns the SYN cookie and MSS value; on failure, it returns various error codes. The function can be utilized in specific BPF program types including SCHED_ACT, SCHED_CLS, and XDP.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_tcp_gen_syncookie.md#2025-04-22_snippet_0\n\nLANGUAGE: C\nCODE:\n```\nstatic __s64 (* const bpf_tcp_gen_syncookie)(void *sk, void *iph, __u32 iph_len, struct tcphdr *th, __u32 th_len) = (void *) 110;\n```\n\n----------------------------------------\n\nTITLE: Using bpf_map_delete_elem Helper Function in C\nDESCRIPTION: This example demonstrates how to use the bpf_map_delete_elem helper function to delete an element from an eBPF map. It includes error handling and logging using bpf_printk.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_map_delete_elem.md#2025-04-22_snippet_1\n\nLANGUAGE: c\nCODE:\n```\nint key, result;\nkey = 1;\nresult = bpf_map_delete_element(&my_map, &key);\nif (result == 0)\n\tbpf_printk(\"Element deleted from the map\\n\");\nelse\n\tbpf_printk(\"Failed to delete element from the map: %d\\n\",result);\n```\n\n----------------------------------------\n\nTITLE: Packet Processing Functions for IPv4/IPv6\nDESCRIPTION: Functions to parse and process TCP, UDP, and ICMP packets for both IPv4 and IPv6 protocols. Includes header parsing and packet description structure population.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/bpf_dynptr_from_skb.md#2025-04-22_snippet_2\n\nLANGUAGE: c\nCODE:\n```\nstatic __noinline bool parse_tcp(struct bpf_dynptr *skb_ptr, __u64 off,\n                    struct packet_description *pckt)\n{\n    __u8 buffer[sizeof(struct tcphdr)] = {};\n    struct tcphdr *tcp;\n\n    tcp = bpf_dynptr_slice(skb_ptr, off, buffer, sizeof(buffer));\n    if (!tcp)\n        return false;\n\n    if (tcp->syn)\n        pckt->flags |= F_SYN_SET;\n\n    if (!(pckt->flags & F_ICMP)) {\n        pckt->port16[0] = tcp->source;\n        pckt->port16[1] = tcp->dest;\n    } else {\n        pckt->port16[0] = tcp->dest;\n        pckt->port16[1] = tcp->source;\n    }\n    return true;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_skb_load_bytes Helper Function in C\nDESCRIPTION: This code snippet defines the 'bpf_skb_load_bytes' helper function. It loads 'len' bytes from 'offset' in the packet associated with 'skb' into the buffer pointed to by 'to'. The function returns 0 on success or a negative error code on failure.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_skb_load_bytes.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstatic long (* const bpf_skb_load_bytes)(const void *skb, __u32 offset, void *to, __u32 len) = (void *) 26;\n```\n\n----------------------------------------\n\nTITLE: New eBPF kfuncs in Linux kernel v6.11\nDESCRIPTION: Introduces new kernel functions for eBPF in Linux kernel version 6.11, including bit iteration, XDP flow lookup, HID input handling, and TCP request socket assignment.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/timeline/index.md#2025-04-22_snippet_11\n\nLANGUAGE: C\nCODE:\n```\nbpf_iter_bits_destroy\nbpf_iter_bits_new\nbpf_iter_bits_next\nbpf_xdp_flow_lookup\nhid_bpf_try_input_report\nbpf_sk_assign_tcp_reqsk\n```\n\n----------------------------------------\n\nTITLE: Using bpf_jiffies64 to Measure Elapsed Time\nDESCRIPTION: Example showing how to use bpf_jiffies64 to measure elapsed time between two points in code by calculating the difference between jiffies values.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_jiffies64.md#2025-04-22_snippet_1\n\nLANGUAGE: c\nCODE:\n```\n __u64 start = bpf_jiffies64();\n/* some tasks */\n__u64 end = bpf_jiffies64();\n__u64 elapsed_jiffies = end - start;\n```\n\n----------------------------------------\n\nTITLE: Defining eBPF Tail Call Helper Function in C\nDESCRIPTION: This snippet defines the eBPF helper function 'bpf_tail_call' in C, which allows a program to jump into another eBPF program in the 'prog_array_map'. It accepts a context pointer, a program array map, and an index. It returns 0 on success or a negative error code on failure. It is crucial for extending program capabilities through chaining. Dependencies include a kernel that supports the 'bpf_tail_call' mechanism.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_tail_call.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n#!c static long (* const bpf_tail_call)(void *ctx, void *prog_array_map, __u32 index) = (void *) 12;\n```\n\n----------------------------------------\n\nTITLE: Defining rate_sample Structure for TCP Delivery Measurements (C)\nDESCRIPTION: This struct models a TCP rate sample, used to quantify throughput and related statistics over a measured interval. Each field records precise details about packet delivery, retransmissions, RTT, and loss, with comments mapping them to their role in TCP's internal state or specific algorithm triggers. The struct is actioned by the TCP rate subsystem and is typically read by congestion control algorithms in processing each ACK. Inputs include timestamps, delivery counters, interval lengths, and loss/ack metrics; outputs are struct population for later analysis. Constraints: negative values in 'delivered' or 'interval_us' mark the sample invalid.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/program-type/BPF_PROG_TYPE_STRUCT_OPS/tcp_congestion_ops.md#2025-04-22_snippet_6\n\nLANGUAGE: c\nCODE:\n```\nstruct rate_sample {\n\tu64  prior_mstamp;      // (1)!  \n\tu32  prior_delivered;   // (2)!  \n\tu32  prior_delivered_ce;// (3)!  \n\ts32  delivered;         // (4)!  \n\ts32  delivered_ce;      // (5)!  \n\tlong interval_us;       // (6)!  \n\tu32 snd_interval_us;    // (7)!  \n\tu32 rcv_interval_us;    // (8)!  \n\tlong rtt_us;            // (9)!  \n\tint  losses;            // (10)! \n\tu32  acked_sacked;      // (11)! \n\tu32  prior_in_flight;   // (12)! \n\tu32  last_end_seq;      // (13)! \n\tbool is_app_limited;    // (14)! \n\tbool is_retrans;        // (15)! \n\tbool is_ack_delayed;    // (16)! \n};\n```\n\n----------------------------------------\n\nTITLE: Complete cGroup Socket Program Example for Socket Creation and Release\nDESCRIPTION: Example BPF program implementing cGroup socket handlers for socket creation and release. The program tracks socket usage with socket storage, limits concurrent socket usage, and validates socket types.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/program-type/BPF_PROG_TYPE_CGROUP_SOCK.md#2025-04-22_snippet_2\n\nLANGUAGE: c\nCODE:\n```\n// SPDX-License-Identifier: GPL-2.0-only\n\n#include <sys/socket.h>\n#include <linux/bpf.h>\n#include <bpf/bpf_helpers.h>\n\nint invocations = 0, in_use = 0;\n\nstruct {\n\t__uint(type, BPF_MAP_TYPE_SK_STORAGE);\n\t__uint(map_flags, BPF_F_NO_PREALLOC);\n\t__type(key, int);\n\t__type(value, int);\n} sk_map SEC(\".maps\");\n\nSEC(\"cgroup/sock_create\")\nint sock(struct bpf_sock *ctx)\n{\n\tint *sk_storage;\n\n\tif (ctx->type != SOCK_DGRAM)\n\t\treturn 1;\n\n\tsk_storage = bpf_sk_storage_get(&sk_map, ctx, 0,\n\t\t\t\t\tBPF_SK_STORAGE_GET_F_CREATE);\n\tif (!sk_storage)\n\t\treturn 0;\n\t*sk_storage = 0xdeadbeef;\n\n\t__sync_fetch_and_add(&invocations, 1);\n\n\tif (in_use > 0) {\n\t\t/* BPF_CGROUP_INET_SOCK_RELEASE is _not_ called\n\t\t * when we return an error from the BPF\n\t\t * program!\n\t\t */\n\t\treturn 0;\n\t}\n\n\t__sync_fetch_and_add(&in_use, 1);\n\treturn 1;\n}\n\nSEC(\"cgroup/sock_release\")\nint sock_release(struct bpf_sock *ctx)\n{\n\tint *sk_storage;\n\n\tif (ctx->type != SOCK_DGRAM)\n\t\treturn 1;\n\n\tsk_storage = bpf_sk_storage_get(&sk_map, ctx, 0, 0);\n\tif (!sk_storage || *sk_storage != 0xdeadbeef)\n\t\treturn 0;\n\n\t__sync_fetch_and_add(&invocations, 1);\n\t__sync_fetch_and_add(&in_use, -1);\n\treturn 1;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing HID BPF Ops Driver and Descriptor Fixup Example - Linux Kernel C\nDESCRIPTION: Demonstrates the setup and implementation of a custom HID BPF driver for the HP Elite Presenter Mouse. This example relies on the vmlinux.h, hid_bpf.h, and hid_bpf_helpers.h headers, and uses BPF macros (HID_BPF_CONFIG, SEC, etc.). It shows modifying the HID report descriptor at runtime (hid_rdesc_fixup) and implements a probe syscall hook. Device configuration and license declaration are included, showcasing expected BPF program structure in Linux.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/program-type/BPF_PROG_TYPE_STRUCT_OPS/hid_bpf_ops.md#2025-04-22_snippet_4\n\nLANGUAGE: c\nCODE:\n```\n// SPDX-License-Identifier: GPL-2.0-only\n/* Copyright (c) 2023 Benjamin Tissoires\n */\n\n#include \"vmlinux.h\"\n#include \"hid_bpf.h\"\n#include \"hid_bpf_helpers.h\"\n#include <bpf/bpf_tracing.h>\n\n#define VID_HP 0x03F0\n#define PID_ELITE_PRESENTER 0x464A\n\nHID_BPF_CONFIG(\n\tHID_DEVICE(BUS_BLUETOOTH, HID_GROUP_GENERIC, VID_HP, PID_ELITE_PRESENTER)\n);\n\n/*\n * Already fixed as of commit 0db117359e47 (\"HID: add quirk for 03f0:464a\n * HP Elite Presenter Mouse\") in the kernel, but this is a slightly better\n * fix.\n *\n * The HP Elite Presenter Mouse HID Record Descriptor shows\n * two mice (Report ID 0x1 and 0x2), one keypad (Report ID 0x5),\n * two Consumer Controls (Report IDs 0x6 and 0x3).\n * Prior to these fixes it registers one mouse, one keypad\n * and one Consumer Control, and it was usable only as a\n * digital laser pointer (one of the two mouses).\n * We replace the second mouse collection with a pointer collection,\n * allowing to use the device both as a mouse and a digital laser\n * pointer.\n */\n\nSEC(HID_BPF_RDESC_FIXUP)\nint BPF_PROG(hid_fix_rdesc, struct hid_bpf_ctx *hctx)\n{\n\t__u8 *data = hid_bpf_get_data(hctx, 0 /* offset */, 4096 /* size */);\n\n\tif (!data)\n\t\treturn 0; /* EPERM check */\n\n\t/* replace application mouse by application pointer on the second collection */\n\tif (data[79] == 0x02)\n\t\tdata[79] = 0x01;\n\n\treturn 0;\n}\n\nHID_BPF_OPS(hp_elite_presenter) = {\n\t.hid_rdesc_fixup = (void *)hid_fix_rdesc,\n};\n\nSEC(\"syscall\")\nint probe(struct hid_bpf_probe_args *ctx)\n{\n\tctx->retval = ctx->rdesc_size != 264;\n\tif (ctx->retval)\n\t\tctx->retval = -EINVAL;\n\n\treturn 0;\n}\n\nchar _license[] SEC(\"license\") = \"GPL\";\n```\n\n----------------------------------------\n\nTITLE: Example Usage - Reading Process Name\nDESCRIPTION: Demonstrates using bpf_probe_read_kernel_str to safely read a process name from kernel memory in a tracepoint program. Shows proper error handling and buffer allocation.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_probe_read_kernel_str.md#2025-04-22_snippet_1\n\nLANGUAGE: c\nCODE:\n```\nSEC(\"tracepoint/syscalls/sys_exit_openat\")\nint trace_open(struct trace_event_raw_sys_exit *ctx) {\n    char comm[256];\n    struct task_struct *task = (struct task_struct *)bpf_get_current_task();\n    \n    // Try to read the process name and check for errors\n    int ret = bpf_probe_read_kernel_str(comm, sizeof(comm), task->comm);\n    \n    if (ret < 0) {\n        bpf_printk(\"Failed to read process name, error: %d\\n\", ret);\n        return 0;\n    }\n\n    bpf_printk(\"Process name: %s\\n\", comm);\n    \n    return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: HID-BPF Example Implementation\nDESCRIPTION: Complete example showing usage of hid_bpf_get_data in various BPF program types including device event handling and report descriptor fixup. Demonstrates axis swapping and event modification using the kfunc.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/hid_bpf_get_data.md#2025-04-22_snippet_1\n\nLANGUAGE: c\nCODE:\n```\n// SPDX-License-Identifier: GPL-2.0\n\n#include \"vmlinux.h\"\n#include <bpf/bpf_helpers.h>\n#include <bpf/bpf_tracing.h>\n\n/* following are kfuncs exported by HID for HID-BPF */\nextern int hid_bpf_attach_prog(unsigned int hid_id, int prog_fd, u32 flags) __ksym;\nextern __u8 *hid_bpf_get_data(struct hid_bpf_ctx *ctx,\n\t\t\t      unsigned int offset,\n\t\t\t      const size_t __sz) __ksym;\nextern void hid_bpf_data_release(__u8 *data) __ksym;\nextern int hid_bpf_hw_request(struct hid_bpf_ctx *ctx) __ksym;\n\nstruct attach_prog_args {\n\tint prog_fd;\n\tunsigned int hid;\n\tint retval;\n};\n\nSEC(\"syscall\")\nint attach_prog(struct attach_prog_args *ctx)\n{\n\tctx->retval = hid_bpf_attach_prog(ctx->hid,\n\t\t\t\t\t  ctx->prog_fd,\n\t\t\t\t\t  0);\n\treturn 0;\n}\n\nSEC(\"fmod_ret/hid_bpf_device_event\")\nint BPF_PROG(hid_y_event, struct hid_bpf_ctx *hctx)\n{\n\ts16 y;\n\t__u8 *data = hid_bpf_get_data(hctx, 0 /* offset */, 9 /* size */);\n\n\tif (!data)\n\t\treturn 0; /* EPERM check */\n\n\tbpf_printk(\"event: size: %d\", hctx->size);\n\tbpf_printk(\"incoming event: %02x %02x %02x\",\n\t\t   data[0],\n\t\t   data[1],\n\t\t   data[2]);\n\tbpf_printk(\"                %02x %02x %02x\",\n\t\t   data[3],\n\t\t   data[4],\n\t\t   data[5]);\n\tbpf_printk(\"                %02x %02x %02x\",\n\t\t   data[6],\n\t\t   data[7],\n\t\t   data[8]);\n\n\ty = data[3] | (data[4] << 8);\n\n\ty = -y;\n\n\tdata[3] = y & 0xFF;\n\tdata[4] = (y >> 8) & 0xFF;\n\n\tbpf_printk(\"modified event: %02x %02x %02x\",\n\t\t   data[0],\n\t\t   data[1],\n\t\t   data[2]);\n\tbpf_printk(\"                %02x %02x %02x\",\n\t\t   data[3],\n\t\t   data[4],\n\t\t   data[5]);\n\tbpf_printk(\"                %02x %02x %02x\",\n\t\t   data[6],\n\t\t   data[7],\n\t\t   data[8]);\n\n\treturn 0;\n}\n\nSEC(\"fmod_ret/hid_bpf_device_event\")\nint BPF_PROG(hid_x_event, struct hid_bpf_ctx *hctx)\n{\n\ts16 x;\n\t__u8 *data = hid_bpf_get_data(hctx, 0 /* offset */, 9 /* size */);\n\n\tif (!data)\n\t\treturn 0; /* EPERM check */\n\n\tx = data[1] | (data[2] << 8);\n\n\tx = -x;\n\n\tdata[1] = x & 0xFF;\n\tdata[2] = (x >> 8) & 0xFF;\n\treturn 0;\n}\n\nSEC(\"fmod_ret/hid_bpf_rdesc_fixup\")\nint BPF_PROG(hid_rdesc_fixup, struct hid_bpf_ctx *hctx)\n{\n\t__u8 *data = hid_bpf_get_data(hctx, 0 /* offset */, 4096 /* size */);\n\n\tif (!data)\n\t\treturn 0; /* EPERM check */\n\n\tbpf_printk(\"rdesc: %02x %02x %02x\",\n\t\t   data[0],\n\t\t   data[1],\n\t\t   data[2]);\n\tbpf_printk(\"       %02x %02x %02x\",\n\t\t   data[3],\n\t\t   data[4],\n\t\t   data[5]);\n\tbpf_printk(\"       %02x %02x %02x ...\",\n\t\t   data[6],\n\t\t   data[7],\n\t\t   data[8]);\n\n\t/*\n\t * The original report descriptor contains:\n\t *\n\t * 0x05, 0x01,                    //   Usage Page (Generic Desktop)      30\n\t * 0x16, 0x01, 0x80,              //   Logical Minimum (-32767)          32\n\t * 0x26, 0xff, 0x7f,              //   Logical Maximum (32767)           35\n\t * 0x09, 0x30,                    //   Usage (X)                         38\n\t * 0x09, 0x31,                    //   Usage (Y)                         40\n\t *\n\t * So byte 39 contains Usage X and byte 41 Usage Y.\n\t *\n\t * We simply swap the axes here.\n\t */\n\tdata[39] = 0x31;\n\tdata[41] = 0x30;\n\n\treturn 0;\n}\n\nchar _license[] SEC(\"license\") = \"GPL\";\n```\n\n----------------------------------------\n\nTITLE: Defining and Using bpf_copy_from_user_str in C\nDESCRIPTION: The snippet defines and exemplifies the eBPF function 'bpf_copy_from_user_str', which safely copies a NULL-terminated string from a user space address to a BPF space buffer. It checks edge cases for string copying with different flags. Required dependencies are '#include <bpf/bpf_helpers.h>', '#include <bpf/bpf_tracing.h>', and 'vmlinux.h'. Parameters include the destination buffer, size, source address, and flags. Returns 0 on success or a negative error code. It is used within programs that can sleep, such as the 'handle_uprobe_byname3_sleepable' example showcasing safe string copying with verifications.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/bpf_copy_from_user_str.md#2025-04-22_snippet_0\n\nLANGUAGE: C\nCODE:\n```\n// SPDX-License-Identifier: GPL-2.0\n// Copyright (c) 2017 Facebook\n\n#include \"vmlinux.h\"\n#include <bpf/bpf_helpers.h>\n#include <bpf/bpf_tracing.h>\n#include <bpf/bpf_core_read.h>\n#include <errno.h>\n#include \"bpf_misc.h\"\n\nu32 dynamic_sz = 1;\nint uprobe_byname3_str_sleepable_res = 0;\nvoid *user_ptr = 0;\n\nint bpf_copy_from_user_str(void *dst, u32, const void *, u64) __weak __ksym;\n\nstatic __always_inline bool verify_sleepable_user_copy_str(void)\n{\n\tint ret;\n\tchar data_long[20];\n\tchar data_long_pad[20];\n\tchar data_long_err[20];\n\tchar data_short[4];\n\tchar data_short_pad[4];\n\n\tret = bpf_copy_from_user_str(data_short, sizeof(data_short), user_ptr, 0);\n\n\tif (bpf_strncmp(data_short, 4, \"tes\\0\") != 0 || ret != 4)\n\t\treturn false;\n\n\tret = bpf_copy_from_user_str(data_short_pad, sizeof(data_short_pad), user_ptr, BPF_F_PAD_ZEROS);\n\n\tif (bpf_strncmp(data_short, 4, \"tes\\0\") != 0 || ret != 4)\n\t\treturn false;\n\n\t/* Make sure this passes the verifier */\n\tret = bpf_copy_from_user_str(data_long, dynamic_sz & sizeof(data_long), user_ptr, 0);\n\n\tif (ret != 0)\n\t\treturn false;\n\n\tret = bpf_copy_from_user_str(data_long, sizeof(data_long), user_ptr, 0);\n\n\tif (bpf_strncmp(data_long, 10, \"test_data\\0\") != 0 || ret != 10)\n\t\treturn false;\n\n\tret = bpf_copy_from_user_str(data_long_pad, sizeof(data_long_pad), user_ptr, BPF_F_PAD_ZEROS);\n\n\tif (bpf_strncmp(data_long_pad, 10, \"test_data\\0\") != 0 || ret != 10 || data_long_pad[19] != '\\0')\n\t\treturn false;\n\n\tret = bpf_copy_from_user_str(data_long_err, sizeof(data_long_err), (void *)data_long, BPF_F_PAD_ZEROS);\n\n\tif (ret > 0 || data_long_err[19] != '\\0')\n\t\treturn false;\n\n\tret = bpf_copy_from_user_str(data_long, sizeof(data_long), user_ptr, 2);\n\n\tif (ret != -EINVAL)\n\t\treturn false;\n\n\treturn true;\n}\n\nSEC(\"uprobe.s//proc/self/exe:trigger_func3\")\nint handle_uprobe_byname3_sleepable(struct pt_regs *ctx)\n{\n\tif (verify_sleepable_user_copy_str())\n\t\tuprobe_byname3_str_sleepable_res = 10;\n\treturn 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_skb_change_head Helper Function in C\nDESCRIPTION: This snippet defines the 'bpf_skb_change_head' helper function. It grows the headroom of a packet associated with 'skb' and adjusts the MAC header offset, adding 'len' bytes of space. The function can be used to push a MAC header for layer 2 device redirection.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_skb_change_head.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstatic long (* const bpf_skb_change_head)(struct __sk_buff *skb, __u32 len, __u64 flags) = (void *) 43;\n```\n\n----------------------------------------\n\nTITLE: Basic XDP Packet Redirection with XSK Map\nDESCRIPTION: Simple eBPF XDP program that redirects packets based on queue index using an XSK map. The program looks up the queue index in the map and redirects matching packets using bpf_redirect_map.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/concepts/af_xdp.md#2025-04-22_snippet_7\n\nLANGUAGE: c\nCODE:\n```\nstruct {\n    __uint(type, BPF_MAP_TYPE_XSKMAP);\n    __type(key, __u32);\n    __type(value, __u32);\n    __uint(max_entries, 64);\n} xsks_map SEC(\".maps\");\n\nSEC(\"xdp\")\nint xsk_redir_prog(struct xdp_md *ctx)\n{\n    __u32 index = ctx->rx_queue_index;\n\n    if (bpf_map_lookup_elem(&xsks_map, &index))\n        return bpf_redirect_map(&xsks_map, index, XDP_PASS);\n    return XDP_PASS;\n}\n```\n\n----------------------------------------\n\nTITLE: Using bpf_printk Macro for Logging in eBPF (C, via bpf_helpers.h)\nDESCRIPTION: Invokes the bpf_printk macro, typically provided by libbpf's bpf_helpers.h, to print a message. The macro automatically handles static format allocation, simplifying debug output in eBPF programs and reducing the risk of misallocation errors. Requires that bpf_helpers.h is included and supported in the build environment.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_trace_printk.md#2025-04-22_snippet_3\n\nLANGUAGE: c\nCODE:\n```\n#!c bpf_printk(\"some log\");\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_spin_lock Helper Function in C\nDESCRIPTION: This code snippet defines the bpf_spin_lock helper function as a static function pointer. It takes a pointer to a bpf_spin_lock structure as an argument and is assigned the value 93.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_spin_lock.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstatic long (* const bpf_spin_lock)(struct bpf_spin_lock *lock) = (void *) 93;\n```\n\n----------------------------------------\n\nTITLE: Testing Zero-Size Dynamic Pointers\nDESCRIPTION: Tests behavior with zero-size dynamic pointers, demonstrating that attempting to read or write non-zero bytes from a zero-size dynptr fails, while reading or writing zero bytes succeeds.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/concepts/dynptrs.md#2025-04-22_snippet_7\n\nLANGUAGE: c\nCODE:\n```\nSEC(\"tp/syscalls/sys_enter_nanosleep\")\nint test_zero_size_dynptr(void *ctx)\n{\n\tchar write_data = 'x', read_data;\n\tstruct bpf_dynptr ptr;\n\t__u32 size = 64;\n\n\tif (bpf_get_current_pid_tgid() >> 32 != pid)\n\t\treturn 0;\n\n\tif (bpf_ringbuf_reserve_dynptr(&ringbuf, size, 0, &ptr)) {\n\t\terr = 1;\n\t\tgoto done;\n\t}\n\n\t/* After this, the dynptr has a size of 0 */\n\tif (bpf_dynptr_adjust(&ptr, size, size)) {\n\t\terr = 2;\n\t\tgoto done;\n\t}\n\n\t/* Test that reading + writing non-zero bytes is not ok */\n\tif (bpf_dynptr_read(&read_data, sizeof(read_data), &ptr, 0, 0) != -E2BIG) {\n\t\terr = 3;\n\t\tgoto done;\n\t}\n\n\tif (bpf_dynptr_write(&ptr, 0, &write_data, sizeof(write_data), 0) != -E2BIG) {\n\t\terr = 4;\n\t\tgoto done;\n\t}\n\n\t/* Test that reading + writing 0 bytes from a 0-size dynptr is ok */\n\tif (bpf_dynptr_read(&read_data, 0, &ptr, 0, 0)) {\n\t\terr = 5;\n\t\tgoto done;\n\t}\n\n\tif (bpf_dynptr_write(&ptr, 0, &write_data, 0, 0)) {\n\t\terr = 6;\n\t\tgoto done;\n\t}\n\n\terr = 0;\n\n\tdone:\n\tbpf_ringbuf_discard_dynptr(&ptr, 0);\n\treturn 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Embedding LPM Trie Key in Custom Structure\nDESCRIPTION: Example of embedding the bpf_lpm_trie_key structure within a custom key type for additional functionality.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/map-type/BPF_MAP_TYPE_LPM_TRIE.md#2025-04-22_snippet_1\n\nLANGUAGE: c\nCODE:\n```\nstruct lpm_key {\n\tstruct bpf_lpm_trie_key trie_key;\n\t__u32 data;\n};\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_attr Structure for BPF_MAP_CREATE in C\nDESCRIPTION: This C code snippet defines the 'union bpf_attr' structure, specifically its struct fields used by the 'BPF_MAP_CREATE' ioctl/syscall command for eBPF map creation. This structure specifies various parameters such as map type, key/value size, flags, and advanced attributes for extended map features. To interact with the eBPF subsystem from user space, developers must populate this struct appropriately before issuing syscalls. Dependencies include standard Linux types (like __u32, __u64, __s32) and kernel header definitions. Inputs involve map creation parameters; outputs are used by the kernel to control map properties. Limitations are kernel-version specific and usage must honor field constraints for the chosen map types.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/syscall/BPF_MAP_CREATE.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nunion bpf_attr {\n    struct {\n\t\t__u32\t[map_type](#map_type);\n\t\t__u32\t[key_size](#key_size);\n\t\t__u32\t[value_size](#value_size);\n\t\t__u32\t[max_entries](#max_entries);\n\t\t__u32\t[map_flags](#map_flags);\n\t\t__u32\t[inner_map_fd](#inner_map_fd);\n\t\t__u32\t[numa_node](#numa_node);\n\t\tchar\t[map_name](#map_name)[BPF_OBJ_NAME_LEN];\n\t\t__u32\t[map_ifindex](#map_ifindex);\n\t\t__u32\t[btf_fd](#btf_fd);\n\t\t__u32\t[btf_key_type_id](#btf_key_type_id);\n\t\t__u32\t[btf_value_type_id](#btf_value_type_id);\n\t\t__u32\t[btf_vmlinux_value_type_id](#btf_vmlinux_value_type_id);\n\t\t__u64\t[map_extra](#map_extra);\n\t\t__s32   [value_type_btf_obj_fd](#value_type_btf_obj_fd);\t\n\t\t__s32\t[map_token_fd](#map_token_fd);\n\t};\n};\n```\n\n----------------------------------------\n\nTITLE: Tracing Program Deployment with eBPF in C\nDESCRIPTION: This tracing program, leveraging BPF helpers, monitors task scheduling events by recording enqueue timestamps, calculating wakeup deltas, and outputting performance data. Structured with context reading sections like tp_btf/sched_wakeup, it uses BPF_MAP_TYPE_TASK_STORAGE and checks for specific process IDs. Required headers include vmlinux.h and bpf_helpers.h. Enqueue operations and state tracking are pivotal to this implementation.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/program-type/BPF_PROG_TYPE_RAW_TRACEPOINT.md#2025-04-22_snippet_2\n\nLANGUAGE: c\nCODE:\n```\n// SPDX-License-Identifier: GPL-2.0\n// Copyright (c) 2019 Facebook\n#include \"vmlinux.h\"\n#include <bpf/bpf_helpers.h>\n#include \"runqslower.h\"\n\n#define TASK_RUNNING 0\n#define BPF_F_CURRENT_CPU 0xffffffffULL\n\nconst volatile __u64 min_us = 0;\nconst volatile pid_t targ_pid = 0;\n\nstruct {\n    __uint(type, BPF_MAP_TYPE_TASK_STORAGE);\n    __uint(map_flags, BPF_F_NO_PREALLOC);\n    __type(key, int);\n    __type(value, u64);\n} start SEC(\".maps\");\n\nstruct {\n    __uint(type, BPF_MAP_TYPE_PERF_EVENT_ARRAY);\n    __uint(key_size, sizeof(u32));\n    __uint(value_size, sizeof(u32));\n} events SEC(\".maps\");\n\n/* record enqueue timestamp */\n__always_inline\nstatic int trace_enqueue(struct task_struct *t)\n{\n    u32 pid = t->pid;\n    u64 *ptr;\n\n    if (!pid || (targ_pid && targ_pid != pid))\n        return 0;\n\n    ptr = bpf_task_storage_get(&start, t, 0,\n                BPF_LOCAL_STORAGE_GET_F_CREATE);\n    if (!ptr)\n        return 0;\n\n    *ptr = bpf_ktime_get_ns();\n    return 0;\n}\n\nSEC(\"tp_btf/sched_wakeup\")\nint handle__sched_wakeup(u64 *ctx)\n{\n    /* TP_PROTO(struct task_struct *p) */\n    struct task_struct *p = (void *)ctx[0];\n\n    return trace_enqueue(p);\n}\n\nSEC(\"tp_btf/sched_wakeup_new\")\nint handle__sched_wakeup_new(u64 *ctx)\n{\n    /* TP_PROTO(struct task_struct *p) */\n    struct task_struct *p = (void *)ctx[0];\n\n    return trace_enqueue(p);\n}\n\nSEC(\"tp_btf/sched_switch\")\nint handle__sched_switch(u64 *ctx)\n{\n    /* TP_PROTO(bool preempt, struct task_struct *prev,\n    *        struct task_struct *next)\n    */\n    struct task_struct *prev = (struct task_struct *)ctx[1];\n    struct task_struct *next = (struct task_struct *)ctx[2];\n    struct runq_event event = {};\n    u64 *tsp, delta_us;\n    long state;\n    u32 pid;\n\n    /* ivcsw: treat like an enqueue event and store timestamp */\n    if (prev->__state == TASK_RUNNING)\n        trace_enqueue(prev);\n\n    pid = next->pid;\n\n    /* For pid mismatch, save a bpf_task_storage_get */\n    if (!pid || (targ_pid && targ_pid != pid))\n        return 0;\n\n    /* fetch timestamp and calculate delta */\n    tsp = bpf_task_storage_get(&start, next, 0, 0);\n    if (!tsp)\n        return 0;   /* missed enqueue */\n\n    delta_us = (bpf_ktime_get_ns() - *tsp) / 1000;\n    if (min_us && delta_us <= min_us)\n        return 0;\n\n    event.pid = pid;\n    event.delta_us = delta_us;\n    bpf_get_current_comm(&event.task, sizeof(event.task));\n\n    /* output */\n    bpf_perf_event_output(ctx, &events, BPF_F_CURRENT_CPU,\n                &event, sizeof(event));\n\n    bpf_task_storage_delete(&start, next);\n    return 0;\n}\n\nchar LICENSE[] SEC(\"license\") = \"GPL\";\n```\n\n----------------------------------------\n\nTITLE: Using __ksym Macro to Access Kernel Symbols in eBPF\nDESCRIPTION: Example demonstrating the use of __ksym to access kernel configuration and symbol values. The code reads the value of 'bpf_task_storage_busy' using the __ksym attribute to get its memory address.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/ebpf/__ksym.md#2025-04-22_snippet_1\n\nLANGUAGE: c\nCODE:\n```\n// SPDX-License-Identifier: GPL-2.0\n/* Copyright (C) 2022. Huawei Technologies Co., Ltd */\n#include \"vmlinux.h\"\n#include <bpf/bpf_helpers.h>\n#include <bpf/bpf_tracing.h>\n\nextern bool CONFIG_PREEMPT __kconfig __weak;\nextern const int bpf_task_storage_busy __ksym;\n\nchar _license[] SEC(\"license\") = \"GPL\";\n\nint pid = 0;\nint busy = 0;\n\nstruct {\n\t__uint(type, BPF_MAP_TYPE_TASK_STORAGE);\n\t__uint(map_flags, BPF_F_NO_PREALLOC);\n\t__type(key, int);\n\t__type(value, long);\n} task SEC(\".maps\");\n\nSEC(\"raw_tp/sys_enter\")\nint BPF_PROG(read_bpf_task_storage_busy)\n{\n\tint *value;\n\n\tif (!CONFIG_PREEMPT)\n\t\treturn 0;\n\n\tif (bpf_get_current_pid_tgid() >> 32 != pid)\n\t\treturn 0;\n\n\tvalue = bpf_this_cpu_ptr(&bpf_task_storage_busy);\n\tif (value)\n\t\tbusy = *value;\n\n\treturn 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining SCX Operation Flags Enumeration in C\nDESCRIPTION: Defines the enum scx_ops_flags which contains all the flags that can be set as a bitfield in the flags field. These flags control scheduler behavior such as idle tracking, enqueuing strategies, and cgroup support.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/program-type/BPF_PROG_TYPE_STRUCT_OPS/sched_ext_ops.md#2025-04-22_snippet_39\n\nLANGUAGE: c\nCODE:\n```\nenum scx_ops_flags {\n    SCX_OPS_KEEP_BUILTIN_IDLE   = 1LLU << 0,\n    SCX_OPS_ENQ_LAST            = 1LLU << 1,\n    SCX_OPS_ENQ_EXITING         = 1LLU << 2,\n    SCX_OPS_SWITCH_PARTIAL      = 1LLU << 3,\n    SCX_OPS_HAS_CGROUP_WEIGHT   = 1LLU << 16,\n};\n```\n\n----------------------------------------\n\nTITLE: Defining ack_sample Structure for Per-ACK TCP Metrics (C)\nDESCRIPTION: This struct records the result of processing an individual ACK in TCP, storing metrics for number of packets acknowledged, RTT measured, and congestion 'in flight' amount at the time. Used primarily in per-ACK algorithm logic for congestion control modules, fields are set by kernel TCP during ACK handling. Inputs include per-ACK statistics; output is struct population for use in algorithm decision-making. No auxiliary dependencies.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/program-type/BPF_PROG_TYPE_STRUCT_OPS/tcp_congestion_ops.md#2025-04-22_snippet_7\n\nLANGUAGE: c\nCODE:\n```\nstruct ack_sample {\n\tu32 pkts_acked;\n\ts32 rtt_us;\n\tu32 in_flight;\n};\n```\n\n----------------------------------------\n\nTITLE: Attaching BPF Program Using ioctl Method in C\nDESCRIPTION: Example code demonstrating the attachment of a BPF program to a perf event using ioctl syscalls. It attaches and enables the BPF program, with the ability to disable it. Dependencies include proper initialization of the perf event FD and BPF program FD.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/program-type/BPF_PROG_TYPE_PERF_EVENT.md#2025-04-22_snippet_2\n\nLANGUAGE: C\nCODE:\n```\nioctl(perf_event_fd, PERF_EVENT_IOC_SET_BPF, bpf_prog_fd);\nioctl(perf_event_fd, PERF_EVENT_IOC_ENABLE, 0);\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_skb_under_cgroup Helper Function in C\nDESCRIPTION: This code snippet defines the 'bpf_skb_under_cgroup' helper function for eBPF programs. It checks whether an skb is a descendant of a cgroup2 held by a map of type BPF_MAP_TYPE_CGROUP_ARRAY at a given index.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_skb_under_cgroup.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstatic long (* const bpf_skb_under_cgroup)(struct __sk_buff *skb, void *map, __u32 index) = (void *) 33;\n```\n\n----------------------------------------\n\nTITLE: Defining the BPF_KSYSCALL Macro in C\nDESCRIPTION: This C macro definition (`BPF_KSYSCALL`) simplifies writing eBPF kprobe programs that attach to syscalls. It automatically handles variations in syscall calling conventions across different CPU architectures, particularly the presence of syscall wrappers (`CONFIG_ARCH_HAS_SYSCALL_WRAPPER`). The macro generates the necessary function signature and boilerplate code to extract syscall arguments correctly, making them directly available to the BPF program logic. It depends on BPF CO-RE and virtual `__kconfig` externs.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/ebpf/BPF_KSYSCALL.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n#define BPF_KSYSCALL(name, args...)\\\nname(struct pt_regs *ctx);\\\nextern _Bool LINUX_HAS_SYSCALL_WRAPPER __kconfig;\\\nstatic __always_inline typeof(name(0))\\\n____##name(struct pt_regs *ctx, ##args);\\\ntypeof(name(0)) name(struct pt_regs *ctx)\\\n{\\\n\\tstruct pt_regs *regs = LINUX_HAS_SYSCALL_WRAPPER\\\n\\t\\t\\t       ? (struct pt_regs *)PT_REGS_PARM1(ctx)\\\n\\t\\t\\t       : ctx;\\\n\\t_Pragma(\"GCC diagnostic push\")\\\n\\t_Pragma(\"GCC diagnostic ignored \\\"-Wint-conversion\\\"\")\\\n\\tif (LINUX_HAS_SYSCALL_WRAPPER)\\\n\\t\\treturn ____##name(___bpf_syswrap_args(args));\\\n\\telse\\\n\\t\\treturn ____##name(___bpf_syscall_args(args));\\\n\\t_Pragma(\"GCC diagnostic pop\")\\\n}\\\nstatic __always_inline typeof(name(0))\\\n____##name(struct pt_regs *ctx, ##args)\n```\n\n----------------------------------------\n\nTITLE: Finding BPF Map File Descriptor by Name using libbpf\nDESCRIPTION: Function definition for bpf_object__find_map_fd_by_name that takes a BPF object and map name as parameters. Returns the file descriptor of the BPF map if found, or -1 if not found.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_object__find_map_fd_by_name.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nint bpf_object__find_map_fd_by_name(const struct bpf_object *obj, const char *name);\n```\n\n----------------------------------------\n\nTITLE: Defining the MEMBER_VPTR Macro for eBPF\nDESCRIPTION: The macro definition for MEMBER_VPTR which creates a verifier-friendly pointer to a struct or array member. It calculates the byte offset, checks against size bounds, and returns a NULL pointer if out-of-bounds to help satisfy the eBPF verifier.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/scx/MEMBER_VPTR.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n#define MEMBER_VPTR(base, member) (typeof((base) member) *)             \\\n({                                                                      \\\n    u64 __base = (u64)&(base);                                          \\\n    u64 __addr = (u64)&((base) member) - __base;                        \\\n    _Static_assert(sizeof(base) >= sizeof((base) member),               \\\n               \"@base is smaller than @member, is @base a pointer?\");   \\\n    asm volatile (                                                      \\\n        \"if %0 <= %[max] goto +2\\n\"                                     \\\n        \"%0 = 0\\n\"                                                      \\\n        \"goto +1\\n\"                                                     \\\n        \"%0 += %1\\n\"                                                    \\\n        : \"+r\"(__addr)                                                  \\\n        : \"r\"(__base),                                                  \\\n          [max]\"i\"(sizeof(base) - sizeof((base) member)));              \\\n    __addr;                                                             \\\n})\n```\n\n----------------------------------------\n\nTITLE: New eBPF features in Linux kernel v6.10\nDESCRIPTION: Lists new attach types, kfuncs for work queue management, preemption control, crypto operations, and HID-related functions added in Linux kernel version 6.10.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/timeline/index.md#2025-04-22_snippet_10\n\nLANGUAGE: C\nCODE:\n```\nBPF_TRACE_KPROBE_SESSION\nbpf_wq_init\nbpf_wq_set_callback_impl\nbpf_wq_start\nbpf_preempt_disable\nbpf_preempt_enable\nbpf_crypto_ctx_create\nbpf_crypto_ctx_release\nbpf_crypto_ctx_acquire\nbpf_crypto_decrypt\nbpf_crypto_encrypt\nbpf_session_is_return\nbpf_session_cookie\nhid_bpf_hw_output_report\nhid_bpf_input_report\n```\n\n----------------------------------------\n\nTITLE: Creating AF_XDP Socket in C\nDESCRIPTION: This snippet demonstrates how to create an AF_XDP socket using the socket() system call in C.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/concepts/af_xdp.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nfd = socket(AF_XDP, SOCK_RAW, 0);\n```\n\n----------------------------------------\n\nTITLE: Cloning Dynamic Pointers\nDESCRIPTION: Demonstrates how to clone a dynamic pointer and shows that changes to the original dynptr don't affect the clone. This enables working with the same data through independent pointers.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/concepts/dynptrs.md#2025-04-22_snippet_10\n\nLANGUAGE: c\nCODE:\n```\nSEC(\"cgroup_skb/egress\")\nint test_dynptr_clone(struct __sk_buff *skb)\n{\n\tstruct bpf_dynptr ptr1;\n\tstruct bpf_dynptr ptr2;\n\t__u32 off = 2, size;\n\n\t/* Get a dynptr */\n\tif (bpf_dynptr_from_skb(skb, 0, &ptr1)) {\n\t\terr = 1;\n\t\treturn 0;\n\t}\n\n\tif (bpf_dynptr_adjust(&ptr1, off, bpf_dynptr_size(&ptr1))) {\n\t\terr = 2;\n\t\treturn 0;\n\t}\n\n\t/* Clone the dynptr */\n\tif (bpf_dynptr_clone(&ptr1, &ptr2)) {\n\t\terr = 3;\n\t\treturn 0;\n\t}\n\n\tsize = bpf_dynptr_size(&ptr1);\n\n\t/* Check that the clone has the same size and rd-only */\n\tif (bpf_dynptr_size(&ptr2) != size) {\n\t\terr = 4;\n\t\treturn 0;\n\t}\n\n\tif (bpf_dynptr_is_rdonly(&ptr2) != bpf_dynptr_is_rdonly(&ptr1)) {\n\t\terr = 5;\n\t\treturn 0;\n\t}\n\n\t/* Advance and trim the original dynptr */\n\tbpf_dynptr_adjust(&ptr1, 5, 5);\n\n\t/* Check that only original dynptr was affected, and the clone wasn't */\n\tif (bpf_dynptr_size(&ptr2) != size) {\n\t\terr = 6;\n\t\treturn 0;\n\t}\n\n\treturn 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_perf_event_data Structure in C\nDESCRIPTION: Defines the bpf_perf_event_data structure that contains information about CPU registers, sample periods, and addresses. It is used within BPF programs to access CPU state during a perf event. Dependencies include the appropriate BPF headers. Expected output includes register states during events.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/program-type/BPF_PROG_TYPE_PERF_EVENT.md#2025-04-22_snippet_0\n\nLANGUAGE: C\nCODE:\n```\nstruct bpf_perf_event_data {\n    bpf_user_pt_regs_t regs;\n    __u64 sample_period;\n    __u64 addr;\n};\n```\n\n----------------------------------------\n\nTITLE: Function Definition - bpf_map_lookup_elem\nDESCRIPTION: Core function definition for bpf_map_lookup_elem that performs map element lookups. Takes a file descriptor, key pointer, and value pointer as parameters. Returns 0 on success or negative error code on failure.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_map_lookup_elem.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nint bpf_map_lookup_elem(int fd, const void *key, void *value);\n```\n\n----------------------------------------\n\nTITLE: Instruction Pointer Recording with BPF Program in C\nDESCRIPTION: A sample BPF program that records and counts instruction pointers during a perf_event. Utilizes a hash map to track IP occurrences. Requires BPF headers and tracing helpers from Linux. Inputs include the context event structure; counts IP appearances and propagates updates to the map.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/program-type/BPF_PROG_TYPE_PERF_EVENT.md#2025-04-22_snippet_4\n\nLANGUAGE: C\nCODE:\n```\n#include <linux/ptrace.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <bpf/bpf_helpers.h>\n#include <bpf/bpf_tracing.h>\n\n#define MAX_IPS\t8192\n\nstruct {\n    __uint(type, BPF_MAP_TYPE_HASH);\n    __type(key, u64);\n    __type(value, u32);\n    __uint(max_entries, MAX_IPS);\n} ip_map SEC(\".maps\");\n\nSEC(\"perf_event\")\nint do_sample(struct bpf_perf_event_data *ctx)\n{\n    u64 ip;\n    u32 *value, init_val = 1;\n\n    ip = PT_REGS_IP(&ctx->regs);\n    value = bpf_map_lookup_elem(&ip_map, &ip);\n    if (value)\n        *value += 1;\n    else\n        /* E2BIG not tested for this example only */\n        bpf_map_update_elem(&ip_map, &ip, &init_val, BPF_NOEXIST);\n\n    return 0;\n}\nchar _license[] SEC(\"license\") = \"GPL\";\n```\n\n----------------------------------------\n\nTITLE: Implementing a TCP Memory Sysctl Validator for cGroups\nDESCRIPTION: A complete example of a cGroup sysctl program that validates the net/ipv4/tcp_mem sysctl contents on read operations, ensuring values follow the expected ascending order pattern.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/program-type/BPF_PROG_TYPE_CGROUP_SYSCTL.md#2025-04-22_snippet_1\n\nLANGUAGE: c\nCODE:\n```\n// SPDX-License-Identifier: GPL-2.0\n// Copyright (c) 2019 Facebook\n\n#include <stdint.h>\n#include <string.h>\n\n#include <linux/stddef.h>\n#include <linux/bpf.h>\n\n#include <bpf/bpf_helpers.h>\n\n/* Max supported length of a string with unsigned long in base 10 (pow2 - 1). */\n#define MAX_ULONG_STR_LEN 0xF\n\n/* Max supported length of sysctl value string (pow2). */\n#define MAX_VALUE_STR_LEN 0x40\n\n#ifndef ARRAY_SIZE\n#define ARRAY_SIZE(x) (sizeof(x) / sizeof((x)[0]))\n#endif\n\nconst char tcp_mem_name[] = \"net/ipv4/tcp_mem\";\nstatic __always_inline int is_tcp_mem(struct bpf_sysctl *ctx)\n{\n\tunsigned char i;\n\tchar name[sizeof(tcp_mem_name)];\n\tint ret;\n\n\tmemset(name, 0, sizeof(name));\n\tret = bpf_sysctl_get_name(ctx, name, sizeof(name), 0);\n\tif (ret < 0 || ret != sizeof(tcp_mem_name) - 1)\n\t\treturn 0;\n\n#pragma clang loop unroll(full)\n\tfor (i = 0; i < sizeof(tcp_mem_name); ++i)\n\t\tif (name[i] != tcp_mem_name[i])\n\t\t\treturn 0;\n\n\treturn 1;\n}\n\nSEC(\"cgroup/sysctl\")\nint sysctl_tcp_mem(struct bpf_sysctl *ctx)\n{\n\tunsigned long tcp_mem[3] = {0, 0, 0};\n\tchar value[MAX_VALUE_STR_LEN];\n\tunsigned char i, off = 0;\n\tvolatile int ret;\n\n\tif (ctx->write)\n\t\treturn 0;\n\n\tif (!is_tcp_mem(ctx))\n\t\treturn 0;\n\n\tret = bpf_sysctl_get_current_value(ctx, value, MAX_VALUE_STR_LEN);\n\tif (ret < 0 || ret >= MAX_VALUE_STR_LEN)\n\t\treturn 0;\n\n#pragma clang loop unroll(full)\n\tfor (i = 0; i < ARRAY_SIZE(tcp_mem); ++i) {\n\t\tret = bpf_strtoul(value + off, MAX_ULONG_STR_LEN, 0,\n\t\t\t\t  tcp_mem + i);\n\t\tif (ret <= 0 || ret > MAX_ULONG_STR_LEN)\n\t\t\treturn 0;\n\t\toff += ret & MAX_ULONG_STR_LEN;\n\t}\n\n\n\treturn tcp_mem[0] < tcp_mem[1] && tcp_mem[1] < tcp_mem[2];\n}\n\nchar _license[] SEC(\"license\") = \"GPL\";\n```\n\n----------------------------------------\n\nTITLE: Defining the cubictcp_acked KFunc Signature in C\nDESCRIPTION: This C code snippet defines the signature for the eBPF kfunc `cubictcp_acked`. This function serves as a hook for packet acknowledgment accounting within the TCP Cubic congestion control algorithm. It takes a pointer to the socket structure (`struct sock *sk`) and a constant pointer to the acknowledgment sample (`const struct ack_sample *sample`) as arguments. It does not return any value (`void`). This kfunc can be called from BPF programs of type `BPF_PROG_TYPE_STRUCT_OPS`.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/cubictcp_acked.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nvoid cubictcp_acked(struct sock *sk, const struct ack_sample *sample)\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_skc_to_tcp_timewait_sock Helper Function in C\nDESCRIPTION: This code snippet defines the 'bpf_skc_to_tcp_timewait_sock' helper function, which dynamically casts a sk pointer to a tcp_timewait_sock pointer. It returns the sk if casting is valid, or NULL otherwise.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_skc_to_tcp_timewait_sock.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstatic struct tcp_timewait_sock *(* const bpf_skc_to_tcp_timewait_sock)(void *sk) = (void *) 138;\n```\n\n----------------------------------------\n\nTITLE: Setting Tunnel Parameters with FOU Encapsulation in TC Program\nDESCRIPTION: This example demonstrates using bpf_skb_set_tunnel_key and bpf_skb_set_fou_encap to configure IP-in-IP tunneling with GUE (Generic UDP Encapsulation) settings. It selectively routes ICMP traffic to a specific IP address and sets up UDP encapsulation with a destination port of 5555.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/bpf_skb_get_fou_encap.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n// SPDX-License-Identifier: GPL-2.0\n/* Copyright (c) 2016 VMware\n * Copyright (c) 2016 Facebook\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of version 2 of the GNU General Public\n * License as published by the Free Software Foundation.\n */\n\nSEC(\"tc\")\nint ipip_gue_set_tunnel(struct __sk_buff *skb)\n{\n\tstruct bpf_tunnel_key key = {};\n\tstruct bpf_fou_encap encap = {};\n\tvoid *data = (void *)(long)skb->data;\n\tstruct iphdr *iph = data;\n\tvoid *data_end = (void *)(long)skb->data_end;\n\tint ret;\n\n\tif (data + sizeof(*iph) > data_end) {\n\t\tlog_err(1);\n\t\treturn TC_ACT_SHOT;\n\t}\n\n\tkey.tunnel_ttl = 64;\n\tif (iph->protocol == IPPROTO_ICMP)\n\t\tkey.remote_ipv4 = 0xac100164; /* 172.16.1.100 */\n\n\tret = bpf_skb_set_tunnel_key(skb, &key, sizeof(key), 0);\n\tif (ret < 0) {\n\t\tlog_err(ret);\n\t\treturn TC_ACT_SHOT;\n\t}\n\n\tencap.sport = 0;\n\tencap.dport = bpf_htons(5555);\n\n\tret = bpf_skb_set_fou_encap(skb, &encap, FOU_BPF_ENCAP_GUE);\n\tif (ret < 0) {\n\t\tlog_err(ret);\n\t\treturn TC_ACT_SHOT;\n\t}\n\n\treturn TC_ACT_OK;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining sk_msg_md Context Structure for eBPF Program Type - C\nDESCRIPTION: This C struct defines the execution context ('struct sk_msg_md') for BPF socket message programs. It contains pointers to packet data, address/port metadata for IPv4/IPv6, total message size, and a pointer to the current socket. The struct is entirely read-only within eBPF programs, and correct mapping/alignment must be ensured to avoid access violations. Inputs: provided by kernel for each invocation; Outputs: fields available for inspection within an eBPF sk_msg program.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/program-type/BPF_PROG_TYPE_SK_MSG.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstruct sk_msg_md {\n\t__bpf_md_ptr(void *, data);\n\t__bpf_md_ptr(void *, data_end);\n\n\t__u32 family;\n\t__u32 remote_ip4;\t/* Stored in network byte order */\n\t__u32 local_ip4;\t/* Stored in network byte order */\n\t__u32 remote_ip6[4];\t/* Stored in network byte order */\n\t__u32 local_ip6[4];\t/* Stored in network byte order */\n\t__u32 remote_port;\t/* Stored in network byte order */\n\t__u32 local_port;\t/* stored in host byte order */\n\t__u32 size;\t\t/* Total size of sk_msg */\n\n\t__bpf_md_ptr(struct bpf_sock *, sk); /* current socket */\n};\n```\n\n----------------------------------------\n\nTITLE: Defining the 'bpf_link__update_program' Function in C\nDESCRIPTION: This C code snippet shows the function signature for 'bpf_link__update_program' from the libbpf library. It takes a pointer to a 'bpf_link' struct ('link') and a pointer to a 'bpf_program' struct ('prog') as input. The function updates the BPF program associated with the specified link to the new program. It returns 0 on success and a negative error code otherwise. This allows atomic replacement of the attached program.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_link__update_program.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n`#!c int bpf_link__update_program(struct bpf_link *link, struct bpf_program *prog);`\n```\n\n----------------------------------------\n\nTITLE: Defining eBPF Helper Function bpf_sys_close in C\nDESCRIPTION: Declares the static function pointer 'bpf_sys_close', representing the eBPF helper for closing file descriptors within a kernel context. This function is defined as taking a 32-bit unsigned integer ('fd') representing the file descriptor to close, and returns the syscall result. It requires kernel support for eBPF helper functions (at least Linux v5.14), and can only be invoked from allowed eBPF program types such as 'BPF_PROG_TYPE_SYSCALL'. Key input: an open file descriptor; output: syscall result (typically 0 on success, negative error code otherwise). Not all environments enable this helper, and permissions may apply.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_sys_close.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n#!c static long (* const bpf_sys_close)(__u32 fd) = (void *) 168;\n```\n\n----------------------------------------\n\nTITLE: Adding Sockets to a BPF Map based on Port using eBPF sockops in C\nDESCRIPTION: This eBPF C program, attached via `sockops`, conditionally adds established sockets to a BPF socket map (`sock_map`). The map type (`BPF_MAP_TYPE_SOCKMAP` or `BPF_MAP_TYPE_SOCKHASH`) is determined by the `SOCKMAP` preprocessor macro. For passively established connections (`BPF_SOCK_OPS_PASSIVE_ESTABLISHED_CB`), the socket is added if the local port is 10000. For actively established connections (`BPF_SOCK_OPS_ACTIVE_ESTABLISHED_CB`), the socket is added if the remote port is 10001. It uses either the `bpf_sock_map_update` or `bpf_sock_hash_update` helper function to update the map, depending on the compilation flags.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/program-type/BPF_PROG_TYPE_SOCK_OPS.md#2025-04-22_snippet_5\n\nLANGUAGE: c\nCODE:\n```\n// Copyright (c) 2017-2018 Covalent IO\nSEC(\"sockops\")\nint bpf_sockmap(struct bpf_sock_ops *skops)\n{\n    __u32 lport, rport;\n    int op, err = 0, index, key, ret;\n\n\n    op = (int) skops->op;\n\n    switch (op) {\n    case BPF_SOCK_OPS_PASSIVE_ESTABLISHED_CB:\n        lport = skops->local_port;\n        rport = skops->remote_port;\n\n        if (lport == 10000) {\n            ret = 1;\n#ifdef SOCKMAP\n            err = bpf_sock_map_update(skops, &sock_map, &ret,\n                        BPF_NOEXIST);\n#else\n            err = bpf_sock_hash_update(skops, &sock_map, &ret,\n                        BPF_NOEXIST);\n#endif\n        }\n        break;\n    case BPF_SOCK_OPS_ACTIVE_ESTABLISHED_CB:\n        lport = skops->local_port;\n        rport = skops->remote_port;\n\n        if (bpf_ntohl(rport) == 10001) {\n            ret = 10;\n#ifdef SOCKMAP\n            err = bpf_sock_map_update(skops, &sock_map, &ret,\n                        BPF_NOEXIST);\n#else\n            err = bpf_sock_hash_update(skops, &sock_map, &ret,\n                        BPF_NOEXIST);\n#endif\n        }\n        break;\n    default:\n        break;\n    }\n\n    return 0;\n}\n\n```\n\n----------------------------------------\n\nTITLE: Invoking perf_event_open Syscall for eBPF Data Transfer in C\nDESCRIPTION: This C code snippet demonstrates how to prepare the attributes (`struct perf_event_attr`) and invoke the `perf_event_open` syscall to create a perf event specifically configured for receiving raw data from eBPF programs. Key attributes include `PERF_TYPE_SOFTWARE`, `PERF_COUNT_SW_BPF_OUTPUT`, and `PERF_SAMPLE_RAW`. Placeholders `{watermark}` and `{cpu}` need to be set based on desired buffering behavior and the target CPU.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/map-type/BPF_MAP_TYPE_PERF_EVENT_ARRAY.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstruct perf_event_attr attr = {\n    .type = PERF_TYPE_SOFTWARE,\n    .size = sizeof(struct perf_event_attr),\n    .config = PERF_COUNT_SW_BPF_OUTPUT,\n    .watermark = true,\n    .sample_type = PERF_SAMPLE_RAW,\n    .wakeup_watermark = {watermark},\n};\n\nsyscall(SYS_perf_event_open, \n    &attr,  /* struct perf_event_attr * */\n    -1,     /* pid_t pid */\n    {cpu}   /* int cpu */\n    -1,     /* int group_fd */\n    PERF_FLAG_FD_CLOEXEC /* unsigned long flags */\n);\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_fib_lookup Helper Function in C\nDESCRIPTION: Function definition for the bpf_fib_lookup eBPF helper that performs FIB lookups in kernel tables. The function takes context, parameters struct, parameter length, and flags as inputs. It returns status codes indicating lookup results and sets output parameters for forwarding information.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_fib_lookup.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstatic long (* const bpf_fib_lookup)(void *ctx, struct bpf_fib_lookup *params, int plen, __u32 flags) = (void *) 69;\n```\n\n----------------------------------------\n\nTITLE: Example Usage of bpf_rdonly_cast in TC Program\nDESCRIPTION: Demonstrates practical usage of bpf_rdonly_cast through bpf_core_cast macro in a TC (Traffic Control) program that logs cgroup IDs for UDP packets.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/bpf_rdonly_cast.md#2025-04-22_snippet_1\n\nLANGUAGE: c\nCODE:\n```\n// SPDX-License-Identifier: GPL-2.0\n// Copyright (c) 2018 Facebook\n\n#include <vmlinux.h>\n#include <bpf/bpf_helpers.h>\n#include <bpf/bpf_core_read.h>\n#include \"bpf_tracing_net.h\"\n#define NUM_CGROUP_LEVELS\t4\n\n__u64 cgroup_ids[NUM_CGROUP_LEVELS];\n__u16 dport;\n\nstatic __always_inline void log_nth_level(struct __sk_buff *skb, __u32 level)\n{\n\t/* [1] &level passed to external function that may change it, it's\n\t *     incompatible with loop unroll.\n\t */\n\tcgroup_ids[level] = bpf_skb_ancestor_cgroup_id(skb, level);\n}\n\nSEC(\"tc\")\nint log_cgroup_id(struct __sk_buff *skb)\n{\n\tstruct sock *sk = (void *)skb->sk;\n\n\tif (!sk)\n\t\treturn TC_ACT_OK;\n\n\tsk = bpf_core_cast(sk, struct sock);\n\tif (sk->sk_protocol == IPPROTO_UDP && sk->sk_dport == dport) {\n\t\tlog_nth_level(skb, 0);\n\t\tlog_nth_level(skb, 1);\n\t\tlog_nth_level(skb, 2);\n\t\tlog_nth_level(skb, 3);\n\t}\n\n\treturn TC_ACT_OK;\n}\n\nchar _license[] SEC(\"license\") = \"GPL\";\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_skb_store_bytes Helper Function in C\nDESCRIPTION: Function definition for the bpf_skb_store_bytes eBPF helper. It stores bytes from a source address into a packet buffer, with options for checksum recalculation and hash invalidation.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_skb_store_bytes.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstatic long (* const bpf_skb_store_bytes)(struct __sk_buff *skb, __u32 offset, const void *from, __u32 len, __u64 flags) = (void *) 9;\n```\n\n----------------------------------------\n\nTITLE: Legacy kprobe attachment using perf_event_open\nDESCRIPTION: Code for attaching a kprobe using the legacy method with perf_event_open syscall. This creates a perf event for a previously defined kprobe trace event and attaches a BPF program to it.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/program-type/BPF_PROG_TYPE_KPROBE.md#2025-04-22_snippet_1\n\nLANGUAGE: c\nCODE:\n```\nstruct perf_event_attr attr = {\n    .type = PERF_TYPE_TRACEPOINT,\n    .size = sizeof(struct perf_event_attr),\n    .config = kprobe_id, /* The ID of your kprobe */\n    .sample_period = 1,\n    .sample_type = PERF_SAMPLE_RAW,\n    .wakeup_events = 1,\n};\n\nsyscall(SYS_perf_event_open, \n    &attr,  /* struct perf_event_attr * */\n    -1,     /* pid_t pid */\n    0       /* int cpu */\n    -1,     /* int group_fd */\n    PERF_FLAG_FD_CLOEXEC /* unsigned long flags */\n);\n```\n\n----------------------------------------\n\nTITLE: Definition of bpf_crypto_ctx_acquire KFunc in C\nDESCRIPTION: The function signature for the bpf_crypto_ctx_acquire kfunc that acquires a reference to a BPF crypto context. It takes a BPF crypto context pointer as input and returns the same pointer on success, or NULL if a reference couldn't be acquired.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/bpf_crypto_ctx_acquire.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstruct bpf_crypto_ctx *bpf_crypto_ctx_acquire(struct bpf_crypto_ctx *ctx)\n```\n\n----------------------------------------\n\nTITLE: Implementing Task VMA Iterator Example in eBPF\nDESCRIPTION: This example demonstrates how to use the task VMA iterator functionality to iterate through virtual memory areas of a specific process. It stores the start and end addresses of each VMA into an array.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/bpf_iter_task_vma_new.md#2025-04-22_snippet_1\n\nLANGUAGE: c\nCODE:\n```\n// SPDX-License-Identifier: GPL-2.0\n/* Copyright (c) 2023 Meta Platforms, Inc. and affiliates. */\n\n#include \"vmlinux.h\"\n#include \"bpf_experimental.h\"\n#include <bpf/bpf_helpers.h>\n#include \"bpf_misc.h\"\n\npid_t target_pid = 0;\nunsigned int vmas_seen = 0;\n\nstruct {\n\t__u64 vm_start;\n\t__u64 vm_end;\n} vm_ranges[1000];\n\nSEC(\"raw_tp/sys_enter\")\nint iter_task_vma_for_each(const void *ctx)\n{\n\tstruct task_struct *task = bpf_get_current_task_btf();\n\tstruct vm_area_struct *vma;\n\tunsigned int seen = 0;\n\n\tif (task->pid != target_pid)\n\t\treturn 0;\n\n\tif (vmas_seen)\n\t\treturn 0;\n\n\tbpf_for_each(task_vma, vma, task, 0) {\n\t\tif (seen >= 1000)\n\t\t\tbreak;\n\n\t\tvm_ranges[seen].vm_start = vma->vm_start;\n\t\tvm_ranges[seen].vm_end = vma->vm_end;\n\t\tseen++;\n\t}\n\n\tvmas_seen = seen;\n\treturn 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Using eBPF Field Existence Macro in C\nDESCRIPTION: This snippet demonstrates the practical usage of 'bpf_core_field_exists' within a kprobe program. The code highlights how to conditionally access a struct field based on its presence in the kernel. It showcases an if-else structure where if the field 'b' exists in 'some_kernel_struct', a direct read operation is employed; otherwise, a fallback method is triggered. Parameters include, for example, the ctx parameter representing the function context in eBPF hooks. The evaluation and branching enhance performance by eliminating non-relevant branches.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/ebpf/bpf_core_field_exists.md#2025-04-22_snippet_1\n\nLANGUAGE: C\nCODE:\n```\nstruct some_kernel_struct {\\n    int a;\\n    int b;\\n};\\n\\nSEC(\"kprobe\")\\nint kprobe__example(struct pt_regs *ctx)\\n{\\n    struct some_kernel_struct *a = PT_REGS_PARM1(ctx);\\n    int b;\\n\\n    // Depending on if some_kernel_struct->b exists on the kernel we are running on\\n    // one or the other branch is taken. The verifier will only evaluate the branch\\n    // that is taken, and will optimize the if statement away, so this does not\\n    // impact the program's performance.\\n    if (bpf_core_field_exists(a->b)) {\\n        b = BPF_CORE_READ(a, b);\\n    } else {\\n        b = more_complex_fallback_to_get_b();\\n    }\\n\\n    bpf_printk(\"Value of field 'a' = %d\", b);\\n\\n    return 0;\\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Libbpf eBPF Function\nDESCRIPTION: This snippet defines the 'bpf_tail_call_static' function used for optimized tail calls in eBPF programs. It requires eBPF programs, the eBPF context, and a constant slot index. It generates specific BPF instructions ensuring that the slot is recognized as a constant by the verifier, optimizing tail calls for performance improvements by avoiding slower retpolines.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/ebpf/bpf_tail_call_static.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstatic __always_inline void\nbpf_tail_call_static(void *ctx, const void *map, const __u32 slot)\n{\n\tif (!__builtin_constant_p(slot))\n\t\t__bpf_unreachable();\n\n\tasm volatile(\"r1 = %[ctx]\\n\\t\"\n\t\t     \"r2 = %[map]\\n\\t\"\n\t\t     \"r3 = %[slot]\\n\\t\"\n\t\t     \"call 12\"\n\t\t     :: [ctx]\"r\"(ctx), [map]\"r\"(map), [slot]\"i\"(slot)\n\t\t     : \"r0\", \"r1\", \"r2\", \"r3\", \"r4\", \"r5\");\n}\n\n```\n\n----------------------------------------\n\nTITLE: Defining and Using bpf_map_delete_elem_flags in C\nDESCRIPTION: The snippet provides the C definition of 'bpf_map_delete_elem_flags', a function used to delete elements from a BPF map using specific flags. It requires the 'libbpf' library and expects a file descriptor 'fd', a pointer 'key', and '__u64 flags'. The function returns '0' on success and a negative error code otherwise. This function is generally used when precise control over deletion is necessary.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_map_delete_elem_flags.md#2025-04-22_snippet_0\n\nLANGUAGE: C\nCODE:\n```\n#!c int bpf_map_delete_elem_flags(int fd, const void *key, __u64 flags);\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_loop Helper Function in C\nDESCRIPTION: This code snippet defines the bpf_loop helper function for eBPF programs. It specifies the function signature, parameters, and return value. The function allows for iterative execution of a callback function for a specified number of loops.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_loop.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstatic long (* const bpf_loop)(__u32 nr_loops, void *callback_fn, void *callback_ctx, __u64 flags) = (void *) 181;\n```\n\n----------------------------------------\n\nTITLE: Defining a Map with Timer Fields in eBPF\nDESCRIPTION: This code snippet demonstrates how to define a map structure that includes a bpf_timer field. The timer is stored as part of a structure value in a BPF_MAP_TYPE_HASH map that can hold up to 1000 entries.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/concepts/timers.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstruct map_elem {\n    int counter;\n    struct bpf_timer timer;\n};\n\nstruct {\n    __uint(type, BPF_MAP_TYPE_HASH);\n    __uint(max_entries, 1000);\n    __type(key, int);\n    __type(value, struct map_elem);\n} hmap SEC(\".maps\");\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_program__set_type function in C for libbpf\nDESCRIPTION: Function signature for bpf_program__set_type which sets the program type of a BPF program. It takes a pointer to a bpf_program struct and a bpf_prog_type enum value, returning an integer error code (0 for success).\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_program__set_type.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nint bpf_program__set_type(struct bpf_program *prog, enum bpf_prog_type type);\n```\n\n----------------------------------------\n\nTITLE: Using bpf_ktime_get_ns to Measure Time Intervals in C\nDESCRIPTION: This example demonstrates how to use the bpf_ktime_get_ns function to measure the duration of a task in an eBPF program.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_ktime_get_ns.md#2025-04-22_snippet_1\n\nLANGUAGE: c\nCODE:\n```\n__u64 start_time = bpf_ktime_get_ns();\n/* some tasks */\n__u64 end_time = bpf_ktime_get_ns();\n__u64 duration = end_time - start_time;\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_setsockopt Helper Function in C\nDESCRIPTION: This code snippet defines the bpf_setsockopt helper function for eBPF programs. It emulates a call to setsockopt() on the socket associated with bpf_socket. The function supports various socket options at different levels like SOL_SOCKET, IPPROTO_TCP, IPPROTO_IP, and IPPROTO_IPV6.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_setsockopt.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstatic long (* const bpf_setsockopt)(void *bpf_socket, int level, int optname, void *optval, int optlen) = (void *) 49;\n```\n\n----------------------------------------\n\nTITLE: Defining and Using bpf_usdt_arg Function in C\nDESCRIPTION: This code snippet defines the function 'bpf_usdt_arg' which retrieves a USDT argument from the process and stores it in the given location '*res'. It returns zero on success and a negative error code otherwise. The snippet provides insight into interfacing with USDT arguments, with dependencies on context and a map of specifiers found in 'usdt.bpf.h'. The snippet serves as a foundational element for eBPF developers needing to extract USDT arguments in their probes.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/ebpf/bpf_usdt_arg.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n[__weak](__weak.md) [__hidden](__hidden.md)\nint bpf_usdt_arg(struct pt_regs *ctx, __u64 arg_num, long *res)\n```\n\n----------------------------------------\n\nTITLE: Defining and Using bpf_btf_load Function in C\nDESCRIPTION: The function 'bpf_btf_load' is a low-level userspace function in the libbpf library for loading BPF Type Format (BTF) data. It wraps around the 'BPF_BTF_LOAD' syscall to allow greater control over loading BTF data. The function requires a pointer to BTF data, its size, and a set of options encapsulated in 'bpf_btf_load_opts'. The struct 'bpf_btf_load_opts' includes configurations for kernel logging and other flags.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_btf_load.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nint bpf_btf_load(const void *btf_data, size_t btf_size, struct bpf_btf_load_opts *opts);\n```\n\nLANGUAGE: c\nCODE:\n```\nstruct bpf_btf_load_opts {\n\tsize_t sz; /* size of this struct for forward/backward compatibility */\n\n\t/* kernel log options */\n\tchar *log_buf;\n\t__u32 log_level;\n\t__u32 log_size;\n\t/* output: actual total log contents size (including terminating zero).\n\t * It could be both larger than original log_size (if log was\n\t * truncated), or smaller (if log buffer wasn't filled completely).\n\t * If kernel doesn't support this feature, log_size is left unchanged.\n\t */\n\t__u32 log_true_size;\n\n\t__u32 btf_flags;\n\t__u32 token_fd;\n\tsize_t :0;\n};\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_ringbuf_reserve Helper Function in C\nDESCRIPTION: This snippet defines the 'bpf_ringbuf_reserve' helper function, which reserves a specified number of bytes in a ring buffer. It takes a pointer to the ring buffer, the size to reserve, and flags as arguments, returning a pointer to the reserved memory or NULL if unsuccessful.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_ringbuf_reserve.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstatic void *(* const bpf_ringbuf_reserve)(void *ringbuf, __u64 size, __u64 flags) = (void *) 131;\n```\n\n----------------------------------------\n\nTITLE: Defining and Using bpf_map__get_next_key in C\nDESCRIPTION: The 'bpf_map__get_next_key' function allows for iteration over BPF map keys by obtaining the key following the current key. It is part of the libbpf userspace library and serves as a high-level equivalent to the 'bpf_map_get_next_key' API with additional key size checks. Dependencies include the appropriate BPF headers and linking against the libbpf library. The function requires a BPF map, a current key or NULL for the first key, a pointer for the next key, and the size of the key. The function returns 0 on success, -ENOENT if the current key is the last, or a negative error code otherwise.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_map__get_next_key.md#2025-04-22_snippet_0\n\nLANGUAGE: C\nCODE:\n```\n#!c int bpf_map__get_next_key(const struct bpf_map *map, const void *cur_key, void *next_key, size_t key_sz);\n```\n\n----------------------------------------\n\nTITLE: Initializing Per-CPU Object with __percpu_kptr in eBPF Program\nDESCRIPTION: This eBPF program demonstrates how to initialize a per-CPU object using __percpu_kptr, including lookup, allocation, and exchange operations.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/ebpf/__percpu_kptr.md#2025-04-22_snippet_2\n\nLANGUAGE: c\nCODE:\n```\nSEC(\"?fentry/bpf_fentry_test1\")\nint BPF_PROG(test_array_map_1)\n{\n\tstruct val_t __percpu_kptr *p;\n\tstruct elem *e;\n\tint index = 0;\n\n\te = bpf_map_lookup_elem(&array, &index);\n\tif (!e)\n\t\treturn 0;\n\n\tp = bpf_percpu_obj_new(struct val_t);\n\tif (!p)\n\t\treturn 0;\n\n\tp = bpf_kptr_xchg(&e->pc, p);\n\tif (p)\n\t\tbpf_percpu_obj_drop(p);\n\n\treturn 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Endianness-swapping and Network-to-Host Macros in libbpf (C)\nDESCRIPTION: This code snippet implements macros for converting values between network and host byte orders in C for eBPF programs, supporting both compile-time constants and runtime values. It uses system endianness checks and compiler builtins (such as __builtin_bswap16) when appropriate, ensuring efficient code generation. Dependencies include a C environment targeting eBPF, likely using libbpf; key parameters include the 16-bit number 'x'; outputs are converted values suitable for safe network/host interaction, and the code is limited to platforms whose compilers define __BYTE_ORDER__ macros.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/ebpf/bpf_ntohs.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n#define ___bpf_mvb(x, b, n, m) ((__u##b)(x) << (b-(n+1)*8) >> (b-8) << (m*8))\\n\\n#define ___bpf_swab16(x) ((__u16)(\\t\\t\\t\\t\\\\n\\t\\t\\t  ___bpf_mvb(x, 16, 0, 1) |\\t\\\\n\\t\\t\\t  ___bpf_mvb(x, 16, 1, 0)))\\n\\n#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__\\n# define __bpf_ntohs(x)\\t\\t\\t__builtin_bswap16(x)\\n# define __bpf_constant_ntohs(x)\\t___bpf_swab16(x)\\n#elif __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__\\n# define __bpf_ntohs(x)\\t\\t\\t(x)\\n# define __bpf_constant_ntohs(x)\\t\\t(x)\\n#else\\n# error \"Fix your compiler's __BYTE_ORDER__?!\"\\n#endif\\n\\n#define bpf_ntohs(x)\\t\\t\\t\\t\\t\\\\n\\t(__builtin_constant_p(x) ?\\t\\t\\\\n\\t __bpf_constant_ntohs(x) : __bpf_ntohs(x))\n```\n\n----------------------------------------\n\nTITLE: Logging Integer Value with Formatted Message via bpf_trace_printk (eBPF, C)\nDESCRIPTION: Illustrates logging an integer value using bpf_trace_printk with a format specifier. The format string is declared static const, and an integer argument (123) is provided to be embedded in the message according to the '%d' format. Requires eBPF environment and that the helper pointer is defined.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_trace_printk.md#2025-04-22_snippet_5\n\nLANGUAGE: c\nCODE:\n```\nstatic const char fmt[] = \"some int: %d\"; \nbpf_trace_printk(fmt, sizeof(fmt), 123);\n```\n\n----------------------------------------\n\nTITLE: Defining the BPF_PROBE_READ_USER_STR_INTO Macro in C\nDESCRIPTION: This C macro definition provides a convenient way to read NUL-terminated strings from userspace memory within an eBPF program using the `bpf_probe_read_user_str` helper function. It is a variant of `BPF_PROBE_READ_USER_INTO` specifically designed for strings and utilizes the internal `___core_read` macro. It takes a destination buffer (`dst`), a source userspace pointer (`src`), the size of the destination buffer (`a`), and optional variable arguments for pointer chasing. Unlike some other BPF macros, this one does not emit CO-RE relocations.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/ebpf/BPF_PROBE_READ_USER_STR_INTO.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n#define BPF_PROBE_READ_USER_STR_INTO(dst, src, a, ...) ({ \\\n\t___core_read(bpf_probe_read_user_str, bpf_probe_read_user,\t    \\\n\t\t     dst, (src), a, ##__VA_ARGS__) \\\n})\n```\n\n----------------------------------------\n\nTITLE: Defining tcp_reno_ssthresh in eBPF\nDESCRIPTION: This snippet defines the 'tcp_reno_ssthresh' function signature in eBPF, returning the slow start threshold, which is half of the congestion window but at least 2. It is a kernel function that operates on a given socket structure. Prerequisites include knowledge of eBPF, Linux networking, and the appropriate socket structures. The function takes a socket structure as input and outputs an unsigned 32-bit integer representing the threshold.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/tcp_reno_ssthresh.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n#!c u32 tcp_reno_ssthresh(struct sock *sk)\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_sock_map_update Helper Function in C\nDESCRIPTION: This code snippet defines the 'bpf_sock_map_update' helper function. It takes a bpf_sock_ops pointer, a map pointer, a key pointer, and flags as parameters. The function returns a long integer, typically 0 for success or a negative error code for failure.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_sock_map_update.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstatic long (* const bpf_sock_map_update)(struct bpf_sock_ops *skops, void *map, void *key, __u64 flags) = (void *) 53;\n```\n\n----------------------------------------\n\nTITLE: Filtering Socket Binds by IP and Port in eBPF using libbpf Macros (C)\nDESCRIPTION: This example demonstrates how to use the bpf_ntohs and bpf_ntohl macros in an eBPF program to restrict inbound socket binding to a specific IPv4 address and port. The code defines constants for the allowed IP and port, then checks the socket context fields against these after converting from network to host byte order. Dependencies involve eBPF-capable C toolchains, libbpf, and proper section/macro support; primary parameters are the socket address fields. Outputs are integer return codes: 1 for permitted, 0 for denied; only works with valid IPv4 (AF_INET) sockets.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/ebpf/bpf_ntohs.md#2025-04-22_snippet_1\n\nLANGUAGE: c\nCODE:\n```\n#define SERV4_IP\\t\\t\\t0xc0a801feU /* 192.168.1.254 */\\n#define SERV4_PORT\\t\\t4040\\n\\nSEC(\"cgroup/bind4\")\\nint bind_v4_prog(struct bpf_sock_addr *ctx)\\n{\\n\\tstruct bpf_sock *sk;\\n\\n\\tsk = ctx->sk;\\n\\tif (!sk)\\n\\t\\treturn 0;\\n\\t\\n\\tif (sk->family != AF_INET)\\n\\t\\treturn 0;\\n\\n\\tif (bpf_ntohl(ctx->user_ip4) != SERV4_IP ||\\n\\t    bpf_ntohs(ctx->user_port) != SERV4_PORT)\\n\\t\\treturn 0;\\n    \\n    return 1;\\n}\n```\n\n----------------------------------------\n\nTITLE: Accessing Per-CPU Data in eBPF Fentry Hook (C)\nDESCRIPTION: This C code snippet presents an eBPF fentry program attached to 'security_inode_getattr'. It demonstrates accessing per-CPU data using 'bpf_per_cpu_ptr' with an external kernel symbol 'bpf_prog_active'. The example highlights a potential pitfall by attempting to submit the obtained pointer (which points to regular kernel memory, not necessarily safe for BPF contexts) to a BPF ring buffer map ('ringbuf'). Requires 'vmlinux.h', 'bpf/bpf_helpers.h', and 'bpf/bpf_tracing.h'.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/program-type/BPF_PROG_TYPE_TRACING.md#2025-04-22_snippet_2\n\nLANGUAGE: c\nCODE:\n```\n// SPDX-License-Identifier: GPL-2.0\n\n#include \"vmlinux.h\"\n#include <bpf/bpf_helpers.h>\n#include <bpf/bpf_tracing.h>\n\nextern const int bpf_prog_active __ksym;\n\nstruct {\n    __uint(type, BPF_MAP_TYPE_RINGBUF);\n    __uint(max_entries, 1 << 12);\n} ringbuf SEC(\".maps\");\n\nSEC(\"fentry/security_inode_getattr\")\nint BPF_PROG(d_path_check_rdonly_mem, struct path *path, struct kstat *stat,\n        __u32 request_mask, unsigned int query_flags)\n{\n    void *active;\n    u32 cpu;\n\n    cpu = bpf_get_smp_processor_id();\n    active = (void *)bpf_per_cpu_ptr(&bpf_prog_active, cpu);\n    if (active) {\n        /* FAIL here! 'active' points to 'regular' memory. It\n        * cannot be submitted to ring buffer.\n        */\n        bpf_ringbuf_submit(active, 0);\n    }\n    return 0;\n}\n\nchar _license[] SEC(\"license\") = \"GPL\";\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_get_socket_cookie Helper Function in C\nDESCRIPTION: This code snippet defines the bpf_get_socket_cookie helper function for eBPF programs. It retrieves or generates a unique 8-byte cookie for a socket associated with the given context.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_get_socket_cookie.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstatic __u64 (* const bpf_get_socket_cookie)(void *ctx) = (void *) 46;\n```\n\n----------------------------------------\n\nTITLE: Using bpf_strncmp in an eBPF Program\nDESCRIPTION: This example demonstrates how to use the bpf_strncmp helper function in an eBPF program. It checks if the current task's command name is 'cat' and prints a message if true. The program uses BTF (BPF Type Format) for structure definitions.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_strncmp.md#2025-04-22_snippet_1\n\nLANGUAGE: c\nCODE:\n```\n#include <vmlinux.h>\n#include <bpf/bpf_helpers.h>\n\nSEC(\"tp_btf/sys_enter\")\nint sys_enter_trace(void *ctx) {\n  struct task_struct *task = (struct task_struct *)bpf_get_current_task_btf();\n  if (bpf_strncmp(task->comm, TASK_COMM_LEN, \"cat\") != 0) {\n    return 0;\n  }\n  bpf_printk(\"Hello, I'm a cat!\\n\");\n  return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining user_ring_buffer__reserve_blocking Function in C\nDESCRIPTION: Function signature for user_ring_buffer__reserve_blocking, which reserves space in a user ring buffer with configurable timeout behavior. It takes a ring buffer pointer, size in bytes, and timeout in milliseconds as parameters.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/user_ring_buffer__reserve_blocking.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nvoid *user_ring_buffer__reserve_blocking(struct user_ring_buffer *rb, __u32 size, int timeout_ms);\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_task_release KFunc in C\nDESCRIPTION: Definition of the bpf_task_release kfunc, which releases a reference acquired on a task. It takes a pointer to a task_struct as a parameter and has no return value.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/bpf_task_release.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nvoid bpf_task_release(struct task_struct *p)\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_kallsyms_lookup_name Helper Function in C\nDESCRIPTION: Function definition for the bpf_kallsyms_lookup_name helper that looks up kernel symbol addresses. Takes a symbol name, name size, flags, and result pointer as parameters. Returns 0 on success or negative error codes for various failure conditions.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_kallsyms_lookup_name.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstatic long (* const bpf_kallsyms_lookup_name)(const char *name, int name_sz, int flags, __u64 *res) = (void *) 179;\n```\n\n----------------------------------------\n\nTITLE: Querying cgroup Ancestor Using eBPF KFunc in C\nDESCRIPTION: This C function signature defines 'bpf_cgroup_ancestor', an eBPF kernel function for obtaining a pointer to the specified ancestor (at the given level) of a cgroup object. Usage requires manual reference counting by the developer: the pointer must be released using 'bpf_cgroup_release', or transferred via 'bpf_kptr_xchg', else the BPF verifier will reject the program. The returned pointer may be NULL and must always be checked before use to avoid dereferencing a NULL pointer. The function is accessible from multiple BPF program types, including LSM, PERF_EVENT, SCHED_CLS, STRUCT_OPS, TRACEPOINT, TRACING, and XDP, with additional version constraints on some types.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/bpf_cgroup_ancestor.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n#!c struct cgroup *bpf_cgroup_ancestor(struct cgroup *cgrp, int level)\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_strncmp Helper Function in C\nDESCRIPTION: This snippet defines the bpf_strncmp helper function for eBPF programs. It compares two strings s1 and s2, where s1 is not necessarily null-terminated and has a maximum size of s1_sz. The function returns an integer indicating the comparison result.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_strncmp.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstatic long (* const bpf_strncmp)(const char *s1, __u32 s1_sz, const char *s2) = (void *) 182;\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_skb_adjust_room Helper Function in C\nDESCRIPTION: This code snippet defines the 'bpf_skb_adjust_room' eBPF helper function. It allows growing or shrinking the room for data in a packet associated with an sk_buff, with various modes and flags for customization.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_skb_adjust_room.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstatic long (* const bpf_skb_adjust_room)(struct __sk_buff *skb, __s32 len_diff, __u32 mode, __u64 flags) = (void *) 50;\n```\n\n----------------------------------------\n\nTITLE: Task Struct Definition with RCU Protected Fields\nDESCRIPTION: Structure definition showing RCU-protected fields in the task_struct, demonstrating how certain fields require RCU read lock protection for safe access.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/bpf_rcu_read_lock.md#2025-04-22_snippet_1\n\nLANGUAGE: c\nCODE:\n```\nstruct task_struct {\n    ...\n    struct task_struct              *last_wakee;\n    struct task_struct __rcu        *real_parent;\n    ...\n};\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_sk_lookup_udp Helper Function in C\nDESCRIPTION: Function prototype for the bpf_sk_lookup_udp helper. It looks up a UDP socket matching the given tuple, optionally in a child network namespace. Returns a pointer to struct bpf_sock or NULL on failure.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_sk_lookup_udp.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstatic struct bpf_sock *(* const bpf_sk_lookup_udp)(void *ctx, struct bpf_sock_tuple *tuple, __u32 tuple_size, __u64 netns, __u64 flags) = (void *) 85;\n```\n\n----------------------------------------\n\nTITLE: Normalizing Perf Event Counter in C\nDESCRIPTION: This code snippet demonstrates how to normalize a perf event counter value using the enabled and running times provided by bpf_perf_event_read_value. This normalization is useful when comparing results between different runs, especially when event multiplexing occurs.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_perf_event_read_value.md#2025-04-22_snippet_1\n\nLANGUAGE: c\nCODE:\n```\nnormalized_counter = counter * t_enabled / t_running\n```\n\n----------------------------------------\n\nTITLE: KFunc Parameter Size Annotation Example\nDESCRIPTION: Shows how to use the __sz parameter annotation in KFuncs to indicate memory size requirements. This example demonstrates the bpf_memzero function signature with proper size annotation.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/concepts/kfuncs.md#2025-04-22_snippet_1\n\nLANGUAGE: c\nCODE:\n```\nvoid bpf_memzero(void *mem, int mem__sz)\n```\n\n----------------------------------------\n\nTITLE: Defining the BPF_USDT Macro in C\nDESCRIPTION: Provides the C preprocessor definition for the `BPF_USDT` macro in libbpf. This macro simplifies defining eBPF programs for USDT tracepoints by automatically handling argument retrieval using `bpf_usdt_arg` internally (via `___bpf_usdt_args`), casting them appropriately, and abstracting the complexity of argument location. It depends on the libbpf library and requires the loader (e.g., using `bpf_program__attach_usdt`) to process USDT argument location information (GAS operands).\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/ebpf/BPF_USDT.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n```c\n#define BPF_USDT(name, args...)             \\\nname(struct pt_regs *ctx);              \\\nstatic __always_inline typeof(name(0))          \\\n____##name(struct pt_regs *ctx, ##args);         \\\ntypeof(name(0)) name(struct pt_regs *ctx)         \\\n{                     \\\n        _Pragma(\"GCC diagnostic push\")          \\\n        _Pragma(\"GCC diagnostic ignored \\\"-Wint-conversion\\\"\")       \\\n        return ____##name(___bpf_usdt_args(args));       \\\n        _Pragma(\"GCC diagnostic pop\")           \\\n}                     \\\nstatic __always_inline typeof(name(0))          \\\n____##name(struct pt_regs *ctx, ##args)\n```\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_map_delete_elem Helper Function in C\nDESCRIPTION: This snippet defines the bpf_map_delete_elem helper function for deleting entries from eBPF maps. It specifies the function signature, parameters, and return value.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_map_delete_elem.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstatic long (* const bpf_map_delete_elem)(void *map, const void *key) = (void *) 3;\n```\n\n----------------------------------------\n\nTITLE: Definition of bpf_find_vma Helper Function in C\nDESCRIPTION: The C definition of the bpf_find_vma helper function for eBPF programs. This function finds a virtual memory area (VMA) of a task that contains a specified address and calls a callback function with the task, VMA, and callback context. It returns 0 on success and various error codes in failure scenarios.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_find_vma.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstatic long (* const bpf_find_vma)(struct task_struct *task, __u64 addr, void *callback_fn, void *callback_ctx, __u64 flags) = (void *) 180;\n```\n\n----------------------------------------\n\nTITLE: Using __kptr with bpf_cpumask in eBPF Programs\nDESCRIPTION: This example demonstrates how to use the __kptr macro to properly handle kernel pointers in eBPF programs. It shows defining a map value structure with a tagged kernel pointer, creating functions to manipulate this pointer, and using it in a tracepoint program to track CPU affinity of tasks.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/ebpf/__kptr.md#2025-04-22_snippet_1\n\nLANGUAGE: c\nCODE:\n```\nstruct cpumask_map_value {\n        struct bpf_cpumask __kptr * cpumask;\n};\n\nstruct array_map {\n        __uint(type, BPF_MAP_TYPE_ARRAY);\n        __type(key, int);\n        __type(value, struct cpumask_map_value);\n        __uint(max_entries, 65536);\n} cpumask_map SEC(\".maps\");\n\nstatic int cpumask_map_insert(struct bpf_cpumask *mask, u32 pid)\n{\n        struct cpumask_map_value local, *v;\n        long status;\n        struct bpf_cpumask *old;\n        u32 key = pid;\n\n        local.cpumask = NULL;\n        status = bpf_map_update_elem(&cpumask_map, &key, &local, 0);\n        if (status) {\n                bpf_cpumask_release(mask);\n                return status;\n        }\n\n        v = bpf_map_lookup_elem(&cpumask_map, &key);\n        if (!v) {\n                bpf_cpumask_release(mask);\n                return -ENOENT;\n        }\n\n        old = bpf_kptr_xchg(&v->cpumask, mask);\n        if (old)\n                bpf_cpumask_release(old);\n\n        return 0;\n}\n\n/**\n    * A sample tracepoint showing how a task's cpumask can be queried and\n    * recorded as a kptr.\n    */\nSEC(\"tp_btf/task_newtask\")\nint BPF_PROG(record_task_cpumask, struct task_struct *task, u64 clone_flags)\n{\n        struct bpf_cpumask *cpumask;\n        int ret;\n\n        cpumask = bpf_cpumask_create();\n        if (!cpumask)\n                return -ENOMEM;\n\n        if (!bpf_cpumask_full(task->cpus_ptr))\n                bpf_printk(\"task %s has CPU affinity\", task->comm);\n\n        bpf_cpumask_copy(cpumask, task->cpus_ptr);\n        return cpumask_map_insert(cpumask, task->pid);\n}\n```\n\n----------------------------------------\n\nTITLE: Definition of bpf_bind Helper Function in C\nDESCRIPTION: Function signature for the bpf_bind eBPF helper that binds a socket to a specified address. This function enables outgoing connections from specific IP addresses and works with IPv4/IPv6 and TCP/UDP sockets.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_bind.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstatic long (* const bpf_bind)(struct bpf_sock_addr *ctx, struct sockaddr *addr, int addr_len) = (void *) 64;\n```\n\n----------------------------------------\n\nTITLE: Implementing Raw Tracepoint on_switch Program in eBPF\nDESCRIPTION: This eBPF program example is positioned within a raw_tp/sched_switch section for performance monitoring, leveraging BPF_MAP_TYPE_PERF_EVENT_ARRAY and BPF_MAP_TYPE_PERCPU_ARRAY. It reads performance event data, computes differences from previous readings, and stores updated readings. Dependencies include vmlinux.h, bpf_helpers.h, and bpf_tracing.h, and it utilizes bpf_perf_event_read_value for data retrieval.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/program-type/BPF_PROG_TYPE_RAW_TRACEPOINT.md#2025-04-22_snippet_1\n\nLANGUAGE: c\nCODE:\n```\n// SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)\n// Copyright (c) 2021 Facebook\n#include \"vmlinux.h\"\n#include <bpf/bpf_helpers.h>\n#include <bpf/bpf_tracing.h>\n\nstruct {\n    __uint(type, BPF_MAP_TYPE_PERF_EVENT_ARRAY);\n    __uint(key_size, sizeof(__u32));\n    __uint(value_size, sizeof(int));\n    __uint(map_flags, BPF_F_PRESERVE_ELEMS);\n} events SEC(\".maps\");\n\nstruct {\n    __uint(type, BPF_MAP_TYPE_PERCPU_ARRAY);\n    __uint(key_size, sizeof(__u32));\n    __uint(value_size, sizeof(struct bpf_perf_event_value));\n    __uint(max_entries, 1);\n} prev_readings SEC(\".maps\");\n\nstruct {\n    __uint(type, BPF_MAP_TYPE_PERCPU_ARRAY);\n    __uint(key_size, sizeof(__u32));\n    __uint(value_size, sizeof(struct bpf_perf_event_value));\n    __uint(max_entries, 1);\n} diff_readings SEC(\".maps\");\n\nSEC(\"raw_tp/sched_switch\")\nint BPF_PROG(on_switch)\n{\n    struct bpf_perf_event_value val, *prev_val, *diff_val;\n    __u32 key = bpf_get_smp_processor_id();\n    __u32 zero = 0;\n    long err;\n\n    prev_val = bpf_map_lookup_elem(&prev_readings, &zero);\n    if (!prev_val)\n        return 0;\n\n    diff_val = bpf_map_lookup_elem(&diff_readings, &zero);\n    if (!diff_val)\n        return 0;\n\n    err = bpf_perf_event_read_value(&events, key, &val, sizeof(val));\n    if (err)\n        return 0;\n\n    diff_val->counter = val.counter - prev_val->counter;\n    diff_val->enabled = val.enabled - prev_val->enabled;\n    diff_val->running = val.running - prev_val->running;\n    *prev_val = val;\n    return 0;\n}\n\nchar LICENSE[] SEC(\"license\") = \"Dual BSD/GPL\";\n```\n\n----------------------------------------\n\nTITLE: Defining Conditional eBPF Dispatch Macro\nDESCRIPTION: Defines a macro that conditionally calls either scx_bpf_dsq_insert or scx_bpf_dispatch___compat based on kernel support. The macro takes parameters for process, dispatch queue ID, slice, and enqueue flags, maintaining compatibility across kernel versions that may have different function names for the same functionality.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/scx/scx_bpf_dsq_insert.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n#define scx_bpf_dsq_insert(p, dsq_id, slice, enq_flags)\\\n\t([bpf_ksym_exists](../libbpf/ebpf/bpf_ksym_exists.md)(scx_bpf_dsq_insert) ?\\\n\t [scx_bpf_dsq_insert](../../linux/kfuncs/scx_bpf_dsq_insert.md)((p), (dsq_id), (slice), (enq_flags)) :\\\n\t [scx_bpf_dispatch___compat](../../linux/kfuncs/scx_bpf_dispatch.md)((p), (dsq_id), (slice), (enq_flags)))\n```\n\n----------------------------------------\n\nTITLE: Defining the bpf_ksym_exists Macro in libbpf (C)\nDESCRIPTION: This snippet defines the 'bpf_ksym_exists' macro, which checks at compile-time if a symbol is both marked as __weak and whether it actually exists. It uses the GCC/Clang _Static_assert and __builtin_constant_p for validation. The macro returns a boolean indicating if the symbol was defined, guarding against accidental misuse of non-weak symbols. This macro is intended to improve safety when probing for optional kernel helpers exposed as weak symbols. No external dependencies beyond a C11-compatible compiler are required.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/ebpf/bpf_ksym_exists.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n#define bpf_ksym_exists(sym) ({ \\\n    _Static_assert(!__builtin_constant_p(!!sym), #sym \" should be marked as __weak\"); \\\n    !!sym; \\\n})\n```\n\n----------------------------------------\n\nTITLE: Using KERNEL_VERSION with LINUX_KERNEL_VERSION in eBPF Program\nDESCRIPTION: Example of how to use the KERNEL_VERSION macro in combination with LINUX_KERNEL_VERSION to implement version-dependent behavior in an eBPF program. This allows writing code that adapts to different kernel versions.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/ebpf/KERNEL_VERSION.md#2025-04-22_snippet_1\n\nLANGUAGE: c\nCODE:\n```\nextern int LINUX_KERNEL_VERSION __kconfig;\n\nSEC(\"xdp\")\nint example_prog(struct xdp_md *ctx)\n{\n    if (LINUX_KERNEL_VERSION < KERNEL_VERSION(5, 10, 0)) {\n        // Fall back to old behavior\n    } else {\n        // Use new features\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining 'bpf_tcp_check_syncookie' eBPF Helper Function in C\nDESCRIPTION: The snippet defines the 'bpf_tcp_check_syncookie' function in C, which checks the validity of SYN cookie ACKs for listening sockets. It requires headers pointing to the start of IPv4/IPv6 and TCP headers and their respective lengths, returning 0 for a valid SYN cookie ACK.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_tcp_check_syncookie.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstatic long (* const bpf_tcp_check_syncookie)(void *sk, void *iph, __u32 iph_len, struct tcphdr *th, __u32 th_len) = (void *) 100;\n```\n\n----------------------------------------\n\nTITLE: KFunc Definition for bpf_skb_get_fou_encap\nDESCRIPTION: The kernel function signature for bpf_skb_get_fou_encap, which takes a pointer to the socket buffer context and a pointer to a bpf_fou_encap structure as parameters and returns an integer status code.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/bpf_skb_get_fou_encap.md#2025-04-22_snippet_2\n\nLANGUAGE: c\nCODE:\n```\nint bpf_skb_get_fou_encap(struct __sk_buff *skb_ctx, struct bpf_fou_encap *encap)\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_skb_change_proto Helper Function in C\nDESCRIPTION: This code snippet defines the bpf_skb_change_proto helper function, which changes the protocol of a socket buffer from IPv4 to IPv6 or vice versa. It takes care of resizing the buffer and marks the GSO type as dodgy for header checks and segment recalculations.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_skb_change_proto.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstatic long (* const bpf_skb_change_proto)(struct __sk_buff *skb, __be16 proto, __u64 flags) = (void *) 31;\n```\n\n----------------------------------------\n\nTITLE: Tracing file open operations with bpf_probe_read_user_str\nDESCRIPTION: This example shows how to use bpf_probe_read_user_str in a tracepoint program to capture filenames in openat system calls. It demonstrates error handling and logging of the read filename.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_probe_read_user_str.md#2025-04-22_snippet_1\n\nLANGUAGE: c\nCODE:\n```\nSEC(\"tracepoint/syscalls/sys_enter_openat\")\nint trace_openat(struct trace_event_raw_sys_enter *ctx) {\n    char filename[256];\n    const char *user_filename = (const char *)ctx->args[1];\n\n    int ret = bpf_probe_read_user_str(filename, sizeof(filename), user_filename);\n    if (ret > 0) {\n        bpf_printk(\"Process opened file: %s\\n\", filename);\n    } else {\n        bpf_printk(\"Failed to read filename, error: %d\\n\", ret);\n    }\n\n    return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_get_socket_uid Helper Function in C\nDESCRIPTION: This code snippet defines the 'bpf_get_socket_uid' helper function. It retrieves the owner UID of the socket associated with the given sk_buff structure. The function returns the UID or the overflowuid value if the socket is NULL or not a full socket.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_get_socket_uid.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstatic __u32 (* const bpf_get_socket_uid)(struct __sk_buff *skb) = (void *) 47;\n```\n\n----------------------------------------\n\nTITLE: Defining the bbr_main KFunc Signature (v6.10+)\nDESCRIPTION: Defines the signature of the eBPF kfunc 'bbr_main' as introduced in Linux kernel v6.10. This function notifies the BBR congestion control algorithm of newly delivered packets. It takes the socket structure, ACK details, a flag, and a rate sample structure as parameters. This kfunc is usable within BPF programs of type `BPF_PROG_TYPE_STRUCT_OPS`.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/bbr_main.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n`#!c void bbr_main(struct sock *sk, u32 ack, int flag, const struct rate_sample *rs)`\n```\n\n----------------------------------------\n\nTITLE: Defining eBPF Helper Function bpf_trace_vprintk in C\nDESCRIPTION: This C code snippet defines the eBPF helper function 'bpf_trace_vprintk'. The function operates similarly to 'bpf_trace_printk' but accepts an array of u64 for formatting, allowing for more format arguments. It returns the number of bytes written to the buffer or a negative error on failure. It is essential to include the necessary eBPF header files and compatible Linux kernel version v5.16 or later.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_trace_vprintk.md#2025-04-22_snippet_0\n\nLANGUAGE: C\nCODE:\n```\nstatic long (* const bpf_trace_vprintk)(const char *fmt, __u32 fmt_size, const void *data, __u32 data_len) = (void *) 177;\n```\n\n----------------------------------------\n\nTITLE: Context Structure Definition for Netfilter in C\nDESCRIPTION: Defines the bpf_nf_ctx structure for use in eBPF programs of type BPF_PROG_TYPE_NETFILTER to handle hook state and sk_buff data. Key pointers include the nf_hook_state and sk_buff used to read packet data, accessed using CO-RE for kernel compatibility.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/program-type/BPF_PROG_TYPE_NETFILTER.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstruct bpf_nf_ctx {\n\tconst struct nf_hook_state *state;\n\tstruct sk_buff *skb;\n};\n```\n\n----------------------------------------\n\nTITLE: Function Definition for bpf_object__open in Libbpf\nDESCRIPTION: The C function definition for bpf_object__open which creates a struct bpf_object by loading a BPF ELF object file into memory. It takes a file path as input and returns a pointer to the new object or NULL on error.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_object__open.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstruct bpf_object *bpf_object__open(const char *path);\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_get_current_cgroup_id Helper Function in C\nDESCRIPTION: This code snippet defines the 'bpf_get_current_cgroup_id' helper function. It returns a 64-bit unsigned integer representing the current cgroup id based on the cgroup within which the current task is running.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_get_current_cgroup_id.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstatic __u64 (* const bpf_get_current_cgroup_id)(void) = (void *) 80;\n```\n\n----------------------------------------\n\nTITLE: New eBPF features in Linux kernel v6.9\nDESCRIPTION: Introduces new map types, syscall commands, flags, and kfuncs for eBPF in Linux kernel version 6.9, including arena allocation and management features.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/timeline/index.md#2025-04-22_snippet_9\n\nLANGUAGE: C\nCODE:\n```\nBPF_MAP_TYPE_ARENA\nBPF_TOKEN_CREATE\nBPF_F_VTYPE_BTF_OBJ_FD\nBPF_F_TOKEN_FD\nBPF_F_SEGV_ON_FAULT\nBPF_F_NO_USER_CONV\nbpf_arena_alloc_pages\nbpf_arena_free_pages\n```\n\n----------------------------------------\n\nTITLE: Using bpf_probe_write_user in eBPF Program for Syscall Interception\nDESCRIPTION: This example demonstrates the use of bpf_probe_write_user in an eBPF program attached to the exit of the open syscall. It intercepts the syscall for a specific process and overwrites the filename parameter with a new value.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_probe_write_user.md#2025-04-22_snippet_1\n\nLANGUAGE: c\nCODE:\n```\n#include <vmlinux.h>\n#include <bpf/bpf_helpers.h>\n#include <bpf/bpf_tracing.h>\n#include <bpf/bpf_core_read.h>\n\n// We do it in the exit to not alter the syscall behavior. The userspace program\n// will see the new filename only after the syscall execution.\nSEC(\"fexit/__x64_sys_open\")\nint BPF_PROG(p_open, struct pt_regs *regs, long ret) {\n  // If it is our example program overwrite the open path.\n  struct task_struct *task = (struct task_struct *)bpf_get_current_task_btf();\n  if (bpf_strncmp(task->comm, TASK_COMM_LEN, \"example\") != 0) {\n    return 0;\n  }\n\n  // SYSCALL_DEFINE3(open, const char __user *, filename, int, flags, umode_t, mode)\n  // first param is the pointer to filename.\n  void *filename_ptr = (void *)PT_REGS_PARM1_CORE_SYSCALL(regs);\n  const char filename[16] = \"/tmp/new\";\n  if (bpf_probe_write_user(filename_ptr, filename, 16)) {\n    bpf_printk(\"Failed to write new filename\\n\");\n  }\n  return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining and Explaining libbpf bpf_link_update API - C\nDESCRIPTION: This snippet provides the function prototype for the userspace libbpf function 'bpf_link_update' in C. It shows the full signature, identifying the three parameters ('link_fd', 'new_prog_fd', 'opts') and specifies expected inputs (file descriptors and options) and outputs (0 on success or negative error code). The function serves as a low-level wrapper around the BPF_LINK_UPDATE syscall. Required dependencies are libbpf and appropriate kernel support. The provided usage context and parameter documentation aid in correct integration, though detailed usage examples are pending.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_link_update.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nint bpf_link_update(int link_fd, int new_prog_fd, const struct bpf_link_update_opts *opts);\n```\n\n----------------------------------------\n\nTITLE: Defining the READ_ONCE Macro and Support Functions in C for eBPF\nDESCRIPTION: This snippet defines the READ_ONCE macro and its supporting functions. It creates alias types with the __may_alias__ attribute and implements __read_once_size which handles different memory sizes. The READ_ONCE macro ensures compiler reads values from memory exactly once without caching or reordering.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/scx/READ_ONCE.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\ntypedef __u8  __attribute__((__may_alias__))  __u8_alias_t;\ntypedef __u16 __attribute__((__may_alias__)) __u16_alias_t;\ntypedef __u32 __attribute__((__may_alias__)) __u32_alias_t;\ntypedef __u64 __attribute__((__may_alias__)) __u64_alias_t;\n\nstatic __always_inline void __read_once_size(const volatile void *p, void *res, int size)\n{\n\tswitch (size) {\n\tcase 1: *(__u8_alias_t  *) res = *(volatile __u8_alias_t  *) p; break;\n\tcase 2: *(__u16_alias_t *) res = *(volatile __u16_alias_t *) p; break;\n\tcase 4: *(__u32_alias_t *) res = *(volatile __u32_alias_t *) p; break;\n\tcase 8: *(__u64_alias_t *) res = *(volatile __u64_alias_t *) p; break;\n\tdefault:\n\t\t[barrier](../libbpf/ebpf/barrier.md)();\n\t\t__builtin_memcpy((void *)res, (const void *)p, size);\n\t\t[barrier](../libbpf/ebpf/barrier.md)();\n\t}\n}\n\n#define READ_ONCE(x)                                \\\n({                                                  \\\n\tunion { typeof(x) __val; char __c[1]; } __u =   \\\n\t\t{ .__c = { 0 } };                           \\\n\t__read_once_size(&(x), __u.__c, sizeof(x));     \\\n\t__u.__val;                                      \\\n})\n```\n\n----------------------------------------\n\nTITLE: Mapping Producer Page with mmap in C\nDESCRIPTION: This code snippet shows how to map the 'producer' page and additional data space for a ring-buffer using the 'mmap' syscall. It optimizes data access by virtually mapping twice the physical memory size of the ring-buffer. Dependencies include the definition of 'info.max_entries' and 'rb->page_size'.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/map-type/BPF_MAP_TYPE_RINGBUF.md#2025-04-22_snippet_1\n\nLANGUAGE: c\nCODE:\n```\nmmap_sz = rb->page_size + 2 * (__u64)info.max_entries;\nproducer = mmap(NULL, (size_t)mmap_sz, PROT_READ, MAP_SHARED, map_fd, rb->page_size);\n```\n\n----------------------------------------\n\nTITLE: Documenting BPF_MAP_TYPE_ARRAY_OF_MAPS Usage in Markdown\nDESCRIPTION: Documents the purpose, configuration, and caveats of the 'BPF_MAP_TYPE_ARRAY_OF_MAPS' eBPF map type using Markdown. Dependencies include standard Markdown syntax and referencing conventions used in eBPF project documentation. Inputs are static text and documentation blocks; outputs provide guidance and constraints for eBPF users. Includes embedded hyperlinks, warning and note alerts, and version tags to support a technical audience.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/map-type/BPF_MAP_TYPE_ARRAY_OF_MAPS.md#2025-04-22_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n# Map type `BPF_MAP_TYPE_ARRAY_OF_MAPS`\n\n<!-- [FEATURE_TAG](BPF_MAP_TYPE_ARRAY_OF_MAPS) -->\n[:octicons-tag-24: v4.12](https://github.com/torvalds/linux/commit/56f668dfe00dcf086734f1c42ea999398fad6572)\n<!-- [/FEATURE_TAG] -->\n\nThe array of maps map type contains references to other maps.\n\n## Usage\n\nThis map type is a map-in-map type. The map values contain references to other BPF maps. We will refer to map-in-map as the \"outer map\" and the maps referenced as the \"inner map(s)\". The key advantage of using a map-in-map is that the outer map is directly referenced by any programs that use it, but the inner maps are not.\n\nThere are a couple of use cases for this indirection. First is to implement a form of RCU on the whole map, copying the existing map to a new map, updating multiple fields, then switching out the maps in the outer map. A second use case can be for statistics/metrics accuracy. It takes time for userspace to iterate and read the full contents of a map containing statistics/metrics. If accuracy is required, the outer map can contain multiple inner maps with counters, the program switches the inner map it writes to, giving userspace time to collect the values on the other maps, resulting in very accurate measurements. Lastly, since [:octicons-tag-24: v5.1](https://github.com/torvalds/linux/commit/134fede4eecfcbe7900e789f625fa6f9c3a8cd0e) most inner map types can have varying [`max_entries`](../syscall/BPF_MAP_CREATE.md#max_entries) values from the reference map. This allows for dynamic resizing of a map without having to reload any programs.\n\n!!! warning\n    For inner maps of type `BPF_MAP_TYPE_ARRAY` the [`BPF_F_INNER_MAP`](../syscall/BPF_MAP_CREATE.md#bpf_f_inner_map) flag must be set on the inner map to allow varying [`max_entries`](../syscall/BPF_MAP_CREATE.md#max_entries). And inner maps of type `BPF_MAP_TYPE_XSKMAP` must always have the same amount of [`max_entries`](../syscall/BPF_MAP_CREATE.md#max_entries) as the reference map.\n    \n!!! warning\n    maps of type `BPF_MAP_TYPE_PERF_EVENT_ARRAY` are not allowed as inner maps.\n\nUsers should be aware of the read/write asymmetry of this map type:\n\n* The [`BPF_MAP_UPDATE_ELEM`](../syscall/BPF_MAP_UPDATE_ELEM.md) syscall command takes *file descriptor* of the BPF map you wish to insert into the map.\n* The [`BPF_MAP_LOOKUP_ELEM`](../syscall/BPF_MAP_LOOKUP_ELEM.md) syscall command returns the *ID* of the BPF map, which can be turned into a file descriptor with the [`BPF_MAP_GET_FD_BY_ID`](../syscall/BPF_MAP_GET_FD_BY_ID.md) syscall command.\n* The [bpf_map_lookup_elem](../helper-function/bpf_map_lookup_elem.md) returns a pointer to the inner map or `NULL`. This pointer can be used like any other in helpers that that map pointers.\n\n## Attributes\n\nBoth the [`value_size`](../syscall/BPF_MAP_CREATE.md#value_size) and the [`key_size`](../syscall/BPF_MAP_CREATE.md#key_size) must always be `4` indicating a 32-bit unsigned integer.\n\nThe [`inner_map_fd`](../syscall/BPF_MAP_CREATE.md#inner_map_fd) attribute must be set to the file descriptor of another map. This other map will serve as a template for the inner maps. After loading, during insertion of values, the kernel will verify that the spec of the inner map values you are attempting to insert match the spec of the map provided by this field. The map used to indicate the type is not linked to the map-in-map type in any way, it is just used to transfer type info. A common technique for loaders is to build a temporary map just for the purpose of providing the type info and freeing that map as soon as the outer map has been created.\n\n!!! note\n    If inner maps use the [`BPF_F_INNER_MAP`](../syscall/BPF_MAP_CREATE.md#bpf_f_inner_map) flag, the [`max_entries`](../syscall/BPF_MAP_CREATE.md#max_entries) field of the spec is ignored for the purposes of comparing the map spec.\n\n<!-- TODO link to generic page for attributes which are the same for every map type -->\n\n## Syscall commands\n\nThe following syscall commands work with this map type:\n\n* [`BPF_MAP_LOOKUP_ELEM`](../syscall/BPF_MAP_LOOKUP_ELEM.md)\n* [`BPF_MAP_UPDATE_ELEM`](../syscall/BPF_MAP_UPDATE_ELEM.md)\n* [`BPF_MAP_GET_NEXT_KEY`](../syscall/BPF_MAP_GET_NEXT_KEY.md)\n\n## Helper functions\n\nThe following helper functions work with this map type:\n\n<!-- DO NOT EDIT MANUALLY -->\n<!-- [MAP_HELPER_FUNC_REF] -->\n * [`bpf_map_lookup_elem`](../helper-function/bpf_map_lookup_elem.md)\n<!-- [/MAP_HELPER_FUNC_REF] -->\n\n## Flags\n\nThe following flags are supported by this map type.\n\n### `BPF_F_NUMA_NODE`\n\n[:octicons-tag-24: v4.14](https://github.com/torvalds/linux/commit/96eabe7a40aa17e613cf3db2c742ee8b1fc764d0)\n\nWhen set, the [`numa_node`](../syscall/BPF_MAP_CREATE.md#numa_node) attribute is respected during map creation.\n\n### `BPF_F_RDONLY`\n\n[:octicons-tag-24: v4.15](https://github.com/torvalds/linux/commit/6e71b04a82248ccf13a94b85cbc674a9fefe53f5)\n\nSetting this flag will make it so the map can only be read via the [syscall](../syscall/index.md) interface, but not written to.\n\nFor details please check the [generic description](../syscall/BPF_MAP_CREATE.md#bpf_f_rdonly).\n\n### `BPF_F_WRONLY`\n\n[:octicons-tag-24: v4.15](https://github.com/torvalds/linux/commit/6e71b04a82248ccf13a94b85cbc674a9fefe53f5)\n\nSetting this flag will make it so the map can only be written to via the [syscall](../syscall/index.md) interface, but not read from.\n\n### `BPF_F_RDONLY_PROG`\n\n[:octicons-tag-24: v5.2](https://github.com/torvalds/linux/commit/591fe9888d7809d9ee5c828020b6c6ae27c37229)\n\nSetting this flag will make it so the map can only be read via [helper functions](../helper-function/index.md), but not written to.\n\nFor details please check the [generic description](../syscall/BPF_MAP_CREATE.md#bpf_f_rdonly_prog).\n\n### `BPF_F_WRONLY_PROG`\n\n[:octicons-tag-24: v5.2](https://github.com/torvalds/linux/commit/591fe9888d7809d9ee5c828020b6c6ae27c37229)\n\nSetting this flag will make it so the map can only be written to via [helper functions](../helper-function/index.md), but not read from.\n\nFor details please check the [generic description](../syscall/BPF_MAP_CREATE.md#bpf_f_wronly_prog).\n\n```\n\n----------------------------------------\n\nTITLE: BPF Program Iterator Function Definition\nDESCRIPTION: Function definition for bpf_object__next_program that iterates over programs in a BPF object. Takes a BPF object pointer and current program pointer as parameters, returns pointer to the next program or NULL if no more programs exist.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_object__next_program.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstruct bpf_program * bpf_object__next_program(const struct bpf_object *obj, struct bpf_program *prog);\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_sk_lookup_tcp Helper Function in C\nDESCRIPTION: This snippet defines the bpf_sk_lookup_tcp helper function, which looks for a TCP socket matching a given tuple. It can optionally search in a child network namespace.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_sk_lookup_tcp.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstatic struct bpf_sock *(* const bpf_sk_lookup_tcp)(void *ctx, struct bpf_sock_tuple *tuple, __u32 tuple_size, __u64 netns, __u64 flags) = (void *) 84;\n```\n\n----------------------------------------\n\nTITLE: Creating multiple kprobes with BPF_TRACE_KPROBE_MULTI\nDESCRIPTION: Using BPF_LINK_CREATE with BPF_TRACE_KPROBE_MULTI to create and link multiple kprobes in one operation. This uses Fprobes under the hood for better performance.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/program-type/BPF_PROG_TYPE_KPROBE.md#2025-04-22_snippet_5\n\nLANGUAGE: c\nCODE:\n```\nunion bpf_attr attr = {\n    .link_create.prog_fd = prog_fd;\n    .link_create.attach_type = BPF_TRACE_KPROBE_MULTI;\n    .link_create.kprobe_multi.cnt = sym_count; \n    .link_create.kprobe_multi.cookies = 0;\n    .link_create.kprobe_multi.flags = BPF_F_KPROBE_MULTI_RETURN;\n    .link_create.kprobe_multi.syms = ((uint64_t)sym_name); /* char array of symbol names */\n);\n\nsyscall(SYS_bpf,\n    BPF_LINK_CREATE,\n    &attr,\n    sizeof(attr)\n);\n```\n\n----------------------------------------\n\nTITLE: Defining the bpf_task_pt_regs eBPF Helper Function Pointer in C\nDESCRIPTION: This C code snippet defines a constant function pointer `bpf_task_pt_regs`. This pointer represents the eBPF helper function used within eBPF programs to obtain the `pt_regs` structure (containing processor registers) associated with a specified kernel task (`struct task_struct *task`). The pointer is initialized with the address `(void *) 175`, where 175 is the unique identifier for this specific helper function within the Linux kernel's eBPF subsystem (available since kernel v5.15). The function takes a pointer to a `task_struct` as input and returns a pointer (`long`, interpreted as `struct pt_regs *`) to the corresponding register set.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_task_pt_regs.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n#!c static long (* const bpf_task_pt_regs)(struct task_struct *task) = (void *) 175;\n```\n\n----------------------------------------\n\nTITLE: Defining the bpf_sk_lookup Context Structure in C\nDESCRIPTION: This C code defines the 'bpf_sk_lookup' structure, which serves as the context for eBPF programs of type 'BPF_PROG_TYPE_SK_LOOKUP'. It contains fields providing details about the incoming connection or packet, such as protocol family, transport protocol, local and remote IP addresses and ports, and the ingress interface index. The 'sk' field is a pointer used to assign a target socket via the 'bpf_sk_assign' helper, while 'cookie' is used during test runs.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/program-type/BPF_PROG_TYPE_SK_LOOKUP.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nunion {\n    __bpf_md_ptr(struct bpf_sock *, sk); /* Selected socket */\n    __u64 cookie; /* Non-zero if socket was selected in PROG_TEST_RUN */\n};\n\n__u32 family;\t\t    /* Protocol family (AF_INET, AF_INET6) */\n__u32 protocol;\t\t    /* IP protocol (IPPROTO_TCP, IPPROTO_UDP) */\n__u32 remote_ip4;\t    /* Network byte order */\n__u32 remote_ip6[4];    /* Network byte order */\n__be16 remote_port;\t    /* Network byte order */\n__u16 :16;\t\t        /* Zero padding */\n__u32 local_ip4;\t    /* Network byte order */\n__u32 local_ip6[4];\t    /* Network byte order */\n__u32 local_port;\t    /* Host byte order */\n__u32 ingress_ifindex;  /* The arriving interface. Determined by inet_iif. */\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_getsockopt Helper Function in C\nDESCRIPTION: C function definition for the bpf_getsockopt helper that enables retrieving socket options from eBPF programs. Takes socket pointer, level, option name, value buffer and length as parameters. Returns 0 on success or negative error code on failure.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_getsockopt.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstatic long (* const bpf_getsockopt)(void *bpf_socket, int level, int optname, void *optval, int optlen) = (void *) 57;\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_core_read_str Macro with libbpf (C)\nDESCRIPTION: Defines the bpf_core_read_str C macro in libbpf, which simplifies reading NUL-terminated strings from kernel memory in eBPF programs. It wraps bpf_probe_read_kernel_str and uses __builtin_preserve_access_index to handle field offset relocations for compatibility with different kernel versions. Inputs include destination pointer (dst), buffer size (sz), and source pointer (src), with output being number of bytes read or negative error. Requires libbpf v0.0.6 or later and sufficient kernel support for bpf_probe_read_kernel_str.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/ebpf/bpf_core_read_str.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n#define bpf_core_read_str(dst, sz, src)\\\n\tbpf_probe_read_kernel_str(dst, sz, (const void *)__builtin_preserve_access_index(src))\n```\n\n----------------------------------------\n\nTITLE: Using `bpf_core_cast` to Access Socket Members in an eBPF TC Program (C)\nDESCRIPTION: This C code snippet provides an example eBPF program attached to the TC (Traffic Control) hook. It demonstrates using the `bpf_core_cast` macro (line 29) to cast the raw `skb->sk` pointer to a `struct sock *`, enabling safe and verified access to kernel socket structure members like `sk_protocol` and `sk_dport` without needing `BPF_CORE_READ`. The program logs ancestor cgroup IDs for specific UDP traffic based on the destination port.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/ebpf/bpf_core_cast.md#2025-04-22_snippet_1\n\nLANGUAGE: c\nCODE:\n```\n// SPDX-License-Identifier: GPL-2.0\n// Copyright (c) 2018 Facebook\n\n#include <vmlinux.h>\n#include <bpf/bpf_helpers.h>\n#include <bpf/bpf_core_read.h>\n#include \"bpf_tracing_net.h\"\n#define NUM_CGROUP_LEVELS\t4\n\n__u64 cgroup_ids[NUM_CGROUP_LEVELS];\n__u16 dport;\n\nstatic __always_inline void log_nth_level(struct __sk_buff *skb, __u32 level)\n{\n\t/* [1] &level passed to external function that may change it, it's\n\t *     incompatible with loop unroll.\n\t */\n\tcgroup_ids[level] = bpf_skb_ancestor_cgroup_id(skb, level);\n}\n\nSEC(\"tc\")\nint log_cgroup_id(struct __sk_buff *skb)\n{\n\tstruct sock *sk = (void *)skb->sk;\n\n\tif (!sk)\n\t\treturn TC_ACT_OK;\n\n\tsk = bpf_core_cast(sk, struct sock);\n\tif (sk->sk_protocol == IPPROTO_UDP && sk->sk_dport == dport) {\n\t\tlog_nth_level(skb, 0);\n\t\tlog_nth_level(skb, 1);\n\t\tlog_nth_level(skb, 2);\n\t\tlog_nth_level(skb, 3);\n\t}\n\n\treturn TC_ACT_OK;\n}\n\nchar _license[] SEC(\"license\") = \"GPL\";\n```\n\n----------------------------------------\n\nTITLE: Definition of bpf_get_current_task_btf Helper Function\nDESCRIPTION: Function definition that returns a BTF pointer to the current task structure. This pointer can be used in helpers that accept an ARG_PTR_TO_BTF_ID of type task_struct.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_get_current_task_btf.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstatic struct task_struct *(* const bpf_get_current_task_btf)(void) = (void *) 158;\n```\n\n----------------------------------------\n\nTITLE: Defining scx_bpf_cpuperf_set eBPF KFunc in C\nDESCRIPTION: This code snippet provides the function signature for the 'scx_bpf_cpuperf_set' kernel function in C, used with eBPF to adjust a CPU's relative performance target. It requires inclusion in an eBPF-enabled Linux kernel environment (v6.12 or later) and is compatible with multiple BPF program types such as LSM, PERF_EVENT, STRUCT_OPS, SYSCALL, TRACEPOINT, and TRACING. The function accepts two integer arguments: 'cpu' (the target CPU) and 'perf' (the desired relative performance level, an unsigned 32-bit integer in the range [0, SCX_CPUPERF_ONE]). No value is returned; side effects are determined by the kernel's cpufreq driver. Limitations include dependency on underlying hardware and appropriate kernel version.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/scx_bpf_cpuperf_set.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n#!c void scx_bpf_cpuperf_set(s32 cpu, u32 perf)\n```\n\n----------------------------------------\n\nTITLE: Defining struct bpf_map_create_opts with Extended Map Options in C\nDESCRIPTION: Defines the struct bpf_map_create_opts, used as an options parameter for advanced map creation with bpf_map_create in libbpf. This struct provides fields for BTF (BPF Type Format) IDs, inner map file descriptors, flags, NUMA node awareness, network interface index, and more, allowing forward/backward compatibility and fine-tuned map attributes. Users must include correct types (__u32, __u64, size_t, etc.) and ensure field values match the kernel and libbpf expectations.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_map_create.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstruct bpf_map_create_opts {\n\tsize_t sz; /* size of this struct for forward/backward compatibility */\n\n\t__u32 btf_fd;\n\t__u32 btf_key_type_id;\n\t__u32 btf_value_type_id;\n\t__u32 btf_vmlinux_value_type_id;\n\n\t__u32 inner_map_fd;\n\t__u32 map_flags;\n\t__u64 map_extra;\n\n\t__u32 numa_node;\n\t__u32 map_ifindex;\n\t__s32 value_type_btf_obj_fd;\n\n\t__u32 token_fd;\n\tsize_t :0;\n};\n```\n\n----------------------------------------\n\nTITLE: Accessing and Manipulating Dynamic Pointer Data\nDESCRIPTION: Shows how to create a dynptr from memory, access data slices with bounds checking, and modify the underlying data. This example demonstrates various data access scenarios including out-of-bounds handling.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/concepts/dynptrs.md#2025-04-22_snippet_1\n\nLANGUAGE: c\nCODE:\n```\nSEC(\"?tp/syscalls/sys_enter_nanosleep\")\nint test_dynptr_data(void *ctx)\n{\n\t__u32 key = 0, val = 235, *map_val;\n\tstruct bpf_dynptr ptr;\n\t__u32 map_val_size;\n\tvoid *data;\n\n\tmap_val_size = sizeof(*map_val);\n\n\tif (bpf_get_current_pid_tgid() >> 32 != pid)\n\t\treturn 0;\n\n\tbpf_map_update_elem(&array_map, &key, &val, 0);\n\n\tmap_val = bpf_map_lookup_elem(&array_map, &key);\n\tif (!map_val) {\n\t\terr = 1;\n\t\treturn 0;\n\t}\n\n\tbpf_dynptr_from_mem(map_val, map_val_size, 0, &ptr);\n\n\t/* Try getting a data slice that is out of range */\n\tdata = bpf_dynptr_data(&ptr, map_val_size + 1, 1);\n\tif (data) {\n\t\terr = 2;\n\t\treturn 0;\n\t}\n\n\t/* Try getting more bytes than available */\n\tdata = bpf_dynptr_data(&ptr, 0, map_val_size + 1);\n\tif (data) {\n\t\terr = 3;\n\t\treturn 0;\n\t}\n\n\tdata = bpf_dynptr_data(&ptr, 0, sizeof(__u32));\n\tif (!data) {\n\t\terr = 4;\n\t\treturn 0;\n\t}\n\n\t*(__u32 *)data = 999;\n\n\terr = bpf_probe_read_kernel(&val, sizeof(val), data);\n\tif (err)\n\t\treturn 0;\n\n\tif (val != *(int *)data)\n\t\terr = 5;\n\n\treturn 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_perf_prog_read_value Helper Function in C\nDESCRIPTION: Function definition for the bpf_perf_prog_read_value helper that reads perf event counter values. Takes a perf event data context, a buffer for the value, and buffer size as parameters. Returns 0 on success or negative error code on failure.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_perf_prog_read_value.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstatic long (* const bpf_perf_prog_read_value)(struct bpf_perf_event_data *ctx, struct bpf_perf_event_value *buf, __u32 buf_size) = (void *) 56;\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_cpumask_clear KFunc in C\nDESCRIPTION: Specifies the signature for the 'bpf_cpumask_clear' kernel function, allowing eBPF programs to clear all processors from a given cpumask. The function takes a single argument, a pointer to a struct bpf_cpumask, and returns void. Dependencies include an eBPF-capable Linux kernel (version 6.3+) and definitions for struct bpf_cpumask. Inputs: pointer to the cpumask to clear. Outputs: none (side effect is the cleared mask). Intended for use in BPF programs, limited to eligible program types (LSM, perf_event, struct_ops, tracepoint, and tracing).\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/bpf_cpumask_clear.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nvoid bpf_cpumask_clear(struct bpf_cpumask *cpumask)\n```\n\n----------------------------------------\n\nTITLE: Defining the bpf_dynptr_slice KFunc in C\nDESCRIPTION: Signature definition for the bpf_dynptr_slice kfunc that retrieves a read-only pointer to dynptr data. It takes a dynptr pointer, offset, buffer pointer, and buffer size as parameters. The function returns NULL if continuous data isn't available.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/bpf_dynptr_slice.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nvoid *bpf_dynptr_slice(const struct bpf_dynptr *p, u32 offset, void *buffer__opt, u32 buffer__szk)\n```\n\n----------------------------------------\n\nTITLE: Initializing DCTCP Congestion Control in BPF\nDESCRIPTION: This function initializes the DCTCP congestion control algorithm. It sets up initial values for the algorithm's parameters and handles fallback scenarios if ECN is not supported.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/program-type/BPF_PROG_TYPE_STRUCT_OPS/tcp_congestion_ops.md#2025-04-22_snippet_15\n\nLANGUAGE: C\nCODE:\n```\nSEC(\"struct_ops\")\nvoid BPF_PROG(bpf_dctcp_init, struct sock *sk)\n{\n\tconst struct tcp_sock *tp = tcp_sk(sk);\n\tstruct bpf_dctcp *ca = inet_csk_ca(sk);\n\tint *stg;\n\n\tif (!(tp->ecn_flags & TCP_ECN_OK) && fallback_cc[0]) {\n\t\t/* Switch to fallback */\n\t\tif (bpf_setsockopt(sk, SOL_TCP, TCP_CONGESTION,\n\t\t\t\t   (void *)fallback_cc, sizeof(fallback_cc)) == -EBUSY)\n\t\t\tebusy_cnt++;\n\n\t\t/* Switch back to myself and the recurred bpf_dctcp_init()\n\t\t * will get -EBUSY for all bpf_setsockopt(TCP_CONGESTION),\n\t\t * except the last \"cdg\" one.\n\t\t */\n\t\tif (bpf_setsockopt(sk, SOL_TCP, TCP_CONGESTION,\n\t\t\t\t   (void *)bpf_dctcp, sizeof(bpf_dctcp)) == -EBUSY)\n\t\t\tebusy_cnt++;\n\n\t\t/* Switch back to fallback */\n\t\tif (bpf_setsockopt(sk, SOL_TCP, TCP_CONGESTION,\n\t\t\t\t   (void *)fallback_cc, sizeof(fallback_cc)) == -EBUSY)\n\t\t\tebusy_cnt++;\n\n\t\t/* Expecting -ENOTSUPP for tcp_cdg_res */\n\t\ttcp_cdg_res = bpf_setsockopt(sk, SOL_TCP, TCP_CONGESTION,\n\t\t\t\t\t     (void *)tcp_cdg, sizeof(tcp_cdg));\n\t\tbpf_getsockopt(sk, SOL_TCP, TCP_CONGESTION,\n\t\t\t       (void *)cc_res, sizeof(cc_res));\n\t\treturn;\n\t}\n\n\tca->prior_rcv_nxt = tp->rcv_nxt;\n\tca->dctcp_alpha = min(dctcp_alpha_on_init, DCTCP_MAX_ALPHA);\n\tca->loss_cwnd = 0;\n\tca->ce_state = 0;\n\n\tstg = bpf_sk_storage_get(&sk_stg_map, (void *)tp, NULL, 0);\n\tif (stg) {\n\t\tstg_result = *stg;\n\t\tbpf_sk_storage_delete(&sk_stg_map, (void *)tp);\n\t}\n\tdctcp_reset(tp, ca);\n}\n```\n\n----------------------------------------\n\nTITLE: Using bpf_map_lookup_elem to Read Values from a Map in C\nDESCRIPTION: This example demonstrates how to use the bpf_map_lookup_elem helper function to read a value from a map. It looks up a key in 'my_map' and prints the value if found, or an error message if not found.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_map_lookup_elem.md#2025-04-22_snippet_1\n\nLANGUAGE: c\nCODE:\n```\nint key, *value;\nkey = 1;\nvalue = bpf_map_lookup_elem(&my_map, &key);\nif (value)\n\tbpf_printk(\"Value read from the map: '%d'\\n\", *value);\nelse\n\tbpf_printk(\"Failed to read value from the map\\n\");\n```\n\n----------------------------------------\n\nTITLE: Example Usage of bpf_map_update_elem Function\nDESCRIPTION: Example showing how to use bpf_map_update_elem to update a map with a new key-value pair using the BPF_NOEXIST flag. Includes error handling and status reporting via bpf_printk.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_map_update_elem.md#2025-04-22_snippet_1\n\nLANGUAGE: c\nCODE:\n```\nint key, value, result;\n\nkey = 1, value = 5678;\n\nresult = bpf_map_update_elem(&my_map, &key, &value, BPF_NOEXIST);\nif (result == 0)\n\tbpf_printk(\"Map updated with new element\\n\");\nelse\n\tbpf_printk(\"Failed to update map with new value: %d\\n\", result);\n```\n\n----------------------------------------\n\nTITLE: Defining eBPF Helper Function bpf_user_ringbuf_drain\nDESCRIPTION: This C code snippet defines the 'bpf_user_ringbuf_drain' function, which is used to drain samples from a user ring buffer and invoke a callback for each sample processed. The function returns the number of samples drained or error codes like -EBUSY, -EINVAL, or -E2BIG under specific conditions. Dependencies include the proper setup of a user ring buffer and alignment conditions.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_user_ringbuf_drain.md#2025-04-22_snippet_0\n\nLANGUAGE: C\nCODE:\n```\nstatic long (* const bpf_user_ringbuf_drain)(void *map, void *callback_fn, void *ctx, __u64 flags) = (void *) 209;\n```\n\n----------------------------------------\n\nTITLE: Getting Congestion Control State via get_info API in Linux Kernel (C)\nDESCRIPTION: This C function pointer type defines the 'get_info' callback, invoked to retrieve information about the congestion control state for a given socket. It requires the socket pointer, a bitmask selecting which state extensions are requested, a pointer to an attribute, and a pointer to a union carrying the specific state info. The function is central to congestion control module introspection and is extended via related enum values determining interpretation of the union info parameter. Inputs are: 'sk' (socket), 'ext' (extension bitmask), 'attr' (attribute pointer), 'info' (output union). The implementation expects proper enum value use and filled structs matching requested attributes.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/program-type/BPF_PROG_TYPE_STRUCT_OPS/tcp_congestion_ops.md#2025-04-22_snippet_2\n\nLANGUAGE: c\nCODE:\n```\nsize_t (*get_info)(struct sock *sk, u32 ext, int *attr, union tcp_cc_info *info)\n```\n\n----------------------------------------\n\nTITLE: Defining the bpf_link_get_fd_by_id Function in C\nDESCRIPTION: Defines the C function signature for `bpf_link_get_fd_by_id`. This libbpf function is a low-level wrapper for the `BPF_LINK_GET_FD_BY_ID` syscall. It takes a BPF link ID (`id` of type `__u32`) as input and returns a file descriptor (positive integer) for the corresponding BPF link if successful, or a negative error code otherwise. Obtaining this file descriptor takes a reference on the link, preventing the kernel from unloading it; the descriptor must be closed using `close(2)` when no longer needed.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_link_get_fd_by_id.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n#!c int bpf_link_get_fd_by_id(__u32 id);\n```\n\n----------------------------------------\n\nTITLE: Implementing BPF Cgroup Bind Hooks in C\nDESCRIPTION: This C code snippet demonstrates eBPF programs attached to `cgroup/bind4` and `cgroup/bind6` hooks. The `bind_prog` function checks if the socket is TCP (SOCK_STREAM) and belongs to the correct address family (AF_INET or AF_INET6). If the user attempts to bind to port 111, the program returns `(1 | 2)` to allow the bind and bypass the `CAP_NET_BIND_SERVICE` capability check. Otherwise, it returns 1 to allow the bind. Requires Linux kernel headers and BPF helper libraries.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/program-type/BPF_PROG_TYPE_CGROUP_SOCK_ADDR.md#2025-04-22_snippet_1\n\nLANGUAGE: c\nCODE:\n```\n// SPDX-License-Identifier: GPL-2.0\n\n#include <linux/stddef.h>\n#include <linux/bpf.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <bpf/bpf_helpers.h>\n#include <bpf/bpf_endian.h>\n\nstatic __always_inline int bind_prog(struct bpf_sock_addr *ctx, int family)\n{\n    struct bpf_sock *sk;\n\n    sk = ctx->sk;\n    if (!sk)\n        return 0;\n\n    if (sk->family != family)\n        return 0;\n\n    if (ctx->type != SOCK_STREAM)\n        return 0;\n\n    /* Return 1 OR'ed with the first bit set to indicate\n    * that CAP_NET_BIND_SERVICE should be bypassed.\n    */\n    if (ctx->user_port == bpf_htons(111))\n        return (1 | 2);\n\n    return 1;\n}\n\nSEC(\"cgroup/bind4\")\nint bind_v4_prog(struct bpf_sock_addr *ctx)\n{\n    return bind_prog(ctx, AF_INET);\n}\n\nSEC(\"cgroup/bind6\")\nint bind_v6_prog(struct bpf_sock_addr *ctx)\n{\n    return bind_prog(ctx, AF_INET6);\n}\n\nchar _license[] SEC(\"license\") = \"GPL\";\n```\n\n----------------------------------------\n\nTITLE: Declaring bpf_map_lookup_elem Helper in bpf_helper_defs.h (C)\nDESCRIPTION: Demonstrates the special declaration mechanism for eBPF helper functions within `bpf_helper_defs.h`. This snippet shows how the `bpf_map_lookup_elem` function is declared by casting the integer literal `1` to a constant static function pointer. This technique causes the compiler to generate a specific `call 1` instruction, which the kernel interprets as a call to the corresponding eBPF helper.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/ebpf/index.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstatic void *(* const bpf_map_lookup_elem)(void *map, const void *key) = (void *) 1;\n```\n\n----------------------------------------\n\nTITLE: Definition of bpf_object__close Function in C\nDESCRIPTION: The bpf_object__close function is used to close a BPF object and release all associated resources. It takes a pointer to a valid BPF object as its only parameter.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_object__close.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nvoid bpf_object__close(struct bpf_object *obj);\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_probe_read Helper Function in C\nDESCRIPTION: Function signature for the bpf_probe_read helper, which allows tracing programs to safely read data from kernel space into a destination buffer. It returns 0 on success or a negative error code on failure.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_probe_read.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstatic long (* const bpf_probe_read)(void *dst, __u32 size, const void *unsafe_ptr) = (void *) 4;\n```\n\n----------------------------------------\n\nTITLE: New eBPF kfuncs in Linux kernel v6.8\nDESCRIPTION: Lists new kernel functions (kfuncs) added for eBPF in Linux kernel version 6.8, including file attribute, CPU mask, cgroup, fs verity, and XDP-related functions.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/timeline/index.md#2025-04-22_snippet_8\n\nLANGUAGE: C\nCODE:\n```\nbpf_get_file_xattr\nbpf_cpumask_weight\nbpf_task_get_cgroup1\nbpf_get_fsverity_digest\nbpf_xdp_metadata_rx_vlan_tag\nbpf_xdp_get_xfrm_state\nbpf_xdp_xfrm_state_release\n```\n\n----------------------------------------\n\nTITLE: HID Descriptor Fixup in C\nDESCRIPTION: eBPF program that modifies HID device descriptors to change input mappings and configurations. Converts touch input to button and modifies coordinate system properties.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/hid_bpf_allocate_context.md#2025-04-22_snippet_2\n\nLANGUAGE: c\nCODE:\n```\nSEC(\"fmod_ret/hid_bpf_rdesc_fixup\")\nint BPF_PROG(hid_rdesc_fixup, struct hid_bpf_ctx *hctx)\n{\n\t__u8 *data = hid_bpf_get_data(hctx, 0 /* offset */, 4096 /* size */);\n\t__u16 *res, *phys;\n\n\tif (!data)\n\t\treturn 0; /* EPERM check */\n\n\t/* Convert TOUCH into a button */\n\tdata[31] = HID_UP_BUTTON;\n\tdata[33] = 2;\n\n\t/* Convert REL_DIAL into REL_WHEEL */\n\tdata[45] = HID_GD_WHEEL;\n\n\t/* Change Resolution Multiplier */\n\tphys = (__u16 *)&data[61];\n\t*phys = physical;\n\tres = (__u16 *)&data[66];\n\t*res = resolution;\n\n\t/* Convert X,Y from Abs to Rel */\n\tdata[88] = 0x06;\n\tdata[98] = 0x06;\n\n\treturn 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining cubictcp_init for eBPF\nDESCRIPTION: Defines the signature of the 'cubictcp_init' function in C for initializing TCP Cubic congestion control on a socket. This function can be used in BPF_PROG_TYPE_STRUCT_OPS program types, with 'sk' as a parameter representing the socket structure.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/cubictcp_init.md#2025-04-22_snippet_0\n\nLANGUAGE: C\nCODE:\n```\n#!c void cubictcp_init(struct sock *sk)\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_ringbuf_submit Helper Function in C\nDESCRIPTION: This snippet defines the 'bpf_ringbuf_submit' helper function, which submits a reserved ring buffer sample. It specifies the function signature, parameters, and return value.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_ringbuf_submit.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstatic void (* const bpf_ringbuf_submit)(void *data, __u64 flags) = (void *) 132;\n```\n\n----------------------------------------\n\nTITLE: Definition of bpf_skb_ct_lookup KFunc in C\nDESCRIPTION: Function signature for the bpf_skb_ct_lookup kfunc which looks up a conntrack entry for a given tuple and returns a pointer to the nf_conn structure. The function takes parameters for the skb context, tuple information, and options for the lookup operation.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/bpf_skb_ct_lookup.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstruct nf_conn *bpf_skb_ct_lookup(struct __sk_buff *skb_ctx, struct bpf_sock_tuple *bpf_tuple, u32 tuple__sz, struct bpf_ct_opts *opts, u32 opts__sz)\n```\n\n----------------------------------------\n\nTITLE: Defining the ring_buffer__new Function in C\nDESCRIPTION: Function signature and parameter definition for creating a new ring buffer manager in libbpf. This function creates a manager that can handle multiple ring buffers with a callback function that processes incoming data.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/ring_buffer__new.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\ntypedef int (*ring_buffer_sample_fn)(void *ctx, void *data, size_t size); \n\nstruct ring_buffer * ring_buffer__new(int map_fd, ring_buffer_sample_fn sample_cb, void *ctx, const struct ring_buffer_opts *opts);\n```\n\n----------------------------------------\n\nTITLE: Defining the bpf_xdp_adjust_meta Helper Function Pointer in C\nDESCRIPTION: This C code snippet declares a constant function pointer `bpf_xdp_adjust_meta`. This pointer represents the eBPF helper function used to adjust the metadata buffer (`data_meta`) associated with an XDP packet context (`struct xdp_md`). It accepts the XDP context (`xdp_md`) and an integer `delta` (which can be positive or negative) specifying the adjustment size. The helper returns 0 on success and a negative error code on failure. It is initialized with the address `(void *) 54`, representing the kernel's internal ID for this helper function.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_xdp_adjust_meta.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n`#!c static long (* const bpf_xdp_adjust_meta)(struct xdp_md *xdp_md, int delta) = (void *) 54;`\n```\n\n----------------------------------------\n\nTITLE: Defining and Using bpf_cpumask_create in eBPF (C)\nDESCRIPTION: Defines the C-language signature for the 'bpf_cpumask_create' kfunc used in eBPF programs. This function allocates a new mutable CPU-mask object, returning a pointer that must either be released with bpf_cpumask_release() or embedded as a referenced kptr in a map. Users must check for NULL and manage reference lifetimes as enforced by the verifier. No arguments are required and the only output is the pointer (possibly NULL); the function is non-blocking and uses the BPF memory allocator. Requires a recent Linux kernel (v6.3+), and must be used in conjunction with appropriate BPF program and memory safety practices.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/bpf_cpumask_create.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n#!c struct bpf_cpumask *bpf_cpumask_create()\n```\n\n----------------------------------------\n\nTITLE: Pinning a BPF Map by Name Using libbpf Pinning Enum in C\nDESCRIPTION: Demonstrates usage of the enum libbpf_pin_type to configure a BPF hash map with a maximum of 1024 entries, specifying pinning via LIBBPF_PIN_BY_NAME. This ensures the map is pinned by its name in /sys/fs/bpf. Dependencies: libbpf, BPF type definitions, and relevant C headers. Key parameters set map type, entry limits, key/value sizes, and enable pinning; snippet is intended for inclusion in larger eBPF programs.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/ebpf/enum-libbpf_pin_type.md#2025-04-22_snippet_1\n\nLANGUAGE: c\nCODE:\n```\nstruct {\n    __uint(type, BPF_MAP_TYPE_HASH);\n    __uint(max_entries, 1024);\n    __uint(key_size, sizeof(int));\n    __uint(value_size, sizeof(long));\n    __uint(pinning, LIBBPF_PIN_BY_NAME);\n} SEC(\".maps\") my_map;\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_program__attach_uprobe function in C\nDESCRIPTION: This snippet defines the bpf_program__attach_uprobe function from the libbpf library. It attaches a BPF program to a userspace function, allowing for optional process specification and attachment to function exit.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_program__attach_uprobe.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstruct bpf_link * bpf_program__attach_uprobe(const struct bpf_program *prog, bool retprobe, pid_t pid, const char *binary_path, size_t func_offset);\n```\n\n----------------------------------------\n\nTITLE: Using bpf_skb_set_tunnel_key in eBPF Program (C)\nDESCRIPTION: This code snippet demonstrates a typical usage of the 'bpf_skb_set_tunnel_key' function on the transmit path. It shows how to populate a tunnel key structure and use it to set the tunnel metadata for a packet.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_skb_set_tunnel_key.md#2025-04-22_snippet_1\n\nLANGUAGE: c\nCODE:\n```\nstruct bpf_tunnel_key key;      populate key ... bpf_skb_set_tunnel_key(skb, &key, sizeof(key), 0); bpf_clone_redirect(skb, vxlan_dev_ifindex, 0);\n```\n\n----------------------------------------\n\nTITLE: Implementing a No-Op Stream Parser in C for BPF_PROG_TYPE_SK_SKB\nDESCRIPTION: This C code defines a minimal eBPF program intended to be attached as a BPF_SK_SKB_STREAM_PARSER. The program, named `noop_parser`, takes a `struct __sk_buff *skb` context and simply returns its length (`skb->len`). This effectively tells the kernel that the message size is the size of the current TCP packet, preserving default behavior. This pattern was particularly useful on Linux kernels before v5.10, where a stream parser was mandatory even if only stream verdict functionality was desired.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/program-type/BPF_PROG_TYPE_SK_SKB.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nSEC(\"sk_skb/stream_parser\")\nint noop_parser(struct __sk_buff *skb)\n{\n    return skb->len;\n}\n```\n\n----------------------------------------\n\nTITLE: Complete Red-Black Tree Implementation Example in C\nDESCRIPTION: A comprehensive example showing the definition of red-black tree structures and using the __contains macro to inform the verifier about the relationship between tree root and nodes.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/scx/__contains.md#2025-04-22_snippet_3\n\nLANGUAGE: c\nCODE:\n```\n/* SPDX-License-Identifier: GPL-2.0 */\n/* Copyright (c) 2022 Tejun Heo <tj@kernel.org> */\n\nstruct bpf_rb_root {\n\t__u64 __opaque[2];\n} __attribute__((aligned(8)));\n\nstruct bpf_rb_node {\n\t__u64 __opaque[4];\n} __attribute__((aligned(8)));\n\nstruct cgv_node {\n\tstruct bpf_rb_node  rb_node;\n\t__u64               cvtime;\n\t__u64               cgid;\n};\n\n[private](private.md)(CGV_TREE) struct bpf_rb_root cgv_tree __contains(cgv_node, rb_node);\n```\n\n----------------------------------------\n\nTITLE: Signature Definition for bpf_skb_ct_alloc Kernel Function\nDESCRIPTION: The C function signature for the bpf_skb_ct_alloc kernel function that allocates a new connection tracking entry. This function returns a pointer to a refcounted nf_conn___init object and requires several parameters including the socket buffer context, tuple information, and options.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/bpf_skb_ct_alloc.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstruct nf_conn___init *bpf_skb_ct_alloc(struct __sk_buff *skb_ctx, struct bpf_sock_tuple *bpf_tuple, u32 tuple__sz, struct bpf_ct_opts *opts, u32 opts__sz)\n```\n\n----------------------------------------\n\nTITLE: Implementing HID BPF Program in C\nDESCRIPTION: This example demonstrates how to implement a HID BPF program using the hid_bpf_attach_prog kfunc. It includes license declaration, external function declarations, and two BPF program sections for handling HID events and attaching the program.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/hid_bpf_attach_prog.md#2025-04-22_snippet_1\n\nLANGUAGE: c\nCODE:\n```\n// SPDX-License-Identifier: GPL-2.0\n/* Copyright (c) 2022 Red hat */\n#include \"vmlinux.h\"\n#include <bpf/bpf_helpers.h>\n#include <bpf/bpf_tracing.h>\n\nchar _license[] SEC(\"license\") = \"GPL\";\n\nextern __u8 *hid_bpf_get_data(struct hid_bpf_ctx *ctx,\n\t\t\t      unsigned int offset,\n\t\t\t      const size_t __sz) __ksym;\nextern int hid_bpf_attach_prog(unsigned int hid_id, int prog_fd, u32 flags) __ksym;\n\nstruct attach_prog_args {\n\tint prog_fd;\n\tunsigned int hid;\n\tint retval;\n};\n\n__u64 callback_check = 52;\n__u64 callback2_check = 52;\n\nSEC(\"?fmod_ret/hid_bpf_device_event\")\nint BPF_PROG(hid_first_event, struct hid_bpf_ctx *hid_ctx)\n{\n\t__u8 *rw_data = hid_bpf_get_data(hid_ctx, 0 /* offset */, 3 /* size */);\n\n\tif (!rw_data)\n\t\treturn 0; /* EPERM check */\n\n\tcallback_check = rw_data[1];\n\n\trw_data[2] = rw_data[1] + 5;\n\n\treturn 0;\n}\n\nSEC(\"syscall\")\nint attach_prog(struct attach_prog_args *ctx)\n{\n\tctx->retval = hid_bpf_attach_prog(ctx->hid,\n\t\t\t\t\t  ctx->prog_fd,\n\t\t\t\t\t  0);\n\treturn 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_seq_printf Helper Function in C\nDESCRIPTION: This code snippet defines the bpf_seq_printf helper function for eBPF programs. It specifies the function signature, including parameters for the seq_file, format string, and data array. The function is assigned the constant value 126.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_seq_printf.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstatic long (* const bpf_seq_printf)(struct seq_file *m, const char *fmt, __u32 fmt_size, const void *data, __u32 data_len) = (void *) 126;\n```\n\n----------------------------------------\n\nTITLE: Defining eBPF 'bpf_cpumask_and' Function\nDESCRIPTION: This C function performs a logical AND operation on two CPU-mask structures and stores the result in a destination CPU-mask. It returns a boolean indicating if the destination has any bits set. The function relies on the definition of 'struct bpf_cpumask' and correctly handles the passed arguments 'src1' and 'src2'.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/bpf_cpumask_and.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nbool bpf_cpumask_and(struct bpf_cpumask *dst, const struct cpumask *src1, const struct cpumask *src2)\n```\n\n----------------------------------------\n\nTITLE: Defining USDT Argument Count Function in Libbpf eBPF (C)\nDESCRIPTION: Defines the eBPF helper function 'bpf_usdt_arg_cnt' which returns the number of arguments defined for a currently traced USDT (User Statically Defined Tracing) probe. This function requires a pointer to a 'pt_regs' context structure and is used to query argument metadata populated by the loader via specifiers in a USDT map, such as found in 'usdt.bpf.h'. The function returns an integer count, with dependencies including a supported eBPF/libbpf environment and proper loader-side population of USDT information.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/ebpf/bpf_usdt_arg_cnt.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n[__weak](__weak.md) [__hidden](__hidden.md)\nint bpf_usdt_arg_cnt(struct pt_regs *ctx)\n```\n\n----------------------------------------\n\nTITLE: DCTCP Congestion Avoidance in BPF\nDESCRIPTION: This function implements the congestion avoidance algorithm for DCTCP. It uses the standard TCP Reno congestion avoidance mechanism.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/program-type/BPF_PROG_TYPE_STRUCT_OPS/tcp_congestion_ops.md#2025-04-22_snippet_21\n\nLANGUAGE: C\nCODE:\n```\nSEC(\"struct_ops\")\nvoid BPF_PROG(bpf_dctcp_cong_avoid, struct sock *sk, __u32 ack, __u32 acked)\n{\n\ttcp_reno_cong_avoid(sk, ack, acked);\n}\n```\n\n----------------------------------------\n\nTITLE: Using libbpf_num_possible_cpus with per-CPU maps in C\nDESCRIPTION: This snippet demonstrates how to use the libbpf_num_possible_cpus function to determine the number of CPUs for allocating an appropriately sized array when working with per-CPU maps. It includes error handling and shows how to use the allocated array with bpf_map_lookup_elem.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/libbpf_num_possible_cpus.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nint ncpus = libbpf_num_possible_cpus();\nif (ncpus < 0) {\n        // error handling\n}\nlong values[ncpus];\nbpf_map_lookup_elem(per_cpu_map_fd, key, values);\n```\n\n----------------------------------------\n\nTITLE: Using bpf_skb_get_xfrm_info in TC BPF Programs\nDESCRIPTION: Example showing how to use the bpf_skb_get_xfrm_info and bpf_skb_set_xfrm_info kfuncs in TC (Traffic Control) BPF programs. The example demonstrates setting XFRM info with a requested interface ID and retrieving XFRM info from a packet.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/bpf_skb_get_xfrm_info.md#2025-04-22_snippet_1\n\nLANGUAGE: c\nCODE:\n```\n// SPDX-License-Identifier: GPL-2.0\n#include \"vmlinux.h\"\n#include \"bpf_tracing_net.h\"\n#include <bpf/bpf_helpers.h>\n\n__u32 req_if_id;\n__u32 resp_if_id;\n\nint bpf_skb_set_xfrm_info(struct __sk_buff *skb_ctx,\n\t\t\t  const struct bpf_xfrm_info *from) __ksym;\nint bpf_skb_get_xfrm_info(struct __sk_buff *skb_ctx,\n\t\t\t  struct bpf_xfrm_info *to) __ksym;\n\nSEC(\"tc\")\nint set_xfrm_info(struct __sk_buff *skb)\n{\n\tstruct bpf_xfrm_info info = { .if_id = req_if_id };\n\n\treturn bpf_skb_set_xfrm_info(skb, &info) ? TC_ACT_SHOT : TC_ACT_UNSPEC;\n}\n\nSEC(\"tc\")\nint get_xfrm_info(struct __sk_buff *skb)\n{\n\tstruct bpf_xfrm_info info = {};\n\n\tif (bpf_skb_get_xfrm_info(skb, &info) < 0)\n\t\treturn TC_ACT_SHOT;\n\n\tresp_if_id = info.if_id;\n\n\treturn TC_ACT_UNSPEC;\n}\n\nchar _license[] SEC(\"license\") = \"GPL\";\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_raw_tracepoint_args Structure in C\nDESCRIPTION: Defines the structure bpf_raw_tracepoint_args which is essential for handling raw arguments in raw tracepoint programs. The args array holds the arguments received directly from the tracepoint. The structure is integral to ensuring the raw data is available for processing by the eBPF program, depending on the tracepoint's specification.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/program-type/BPF_PROG_TYPE_RAW_TRACEPOINT.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstruct bpf_raw_tracepoint_args {\n       __u64 args[0];\n};\n```\n\n----------------------------------------\n\nTITLE: Defining Value Structure for BPF_MAP_TYPE_DEVMAP - C\nDESCRIPTION: This C code snippet defines the value structure used in the BPF_MAP_TYPE_DEVMAP eBPF map type. The struct bpf_devmap_val contains an interface index and an optional union for either a program file descriptor (fd) or program id, supporting secondary XDP program attachment post-redirection. To use this structure, the Linux kernel must be built with eBPF support and the specific map and program types must be enabled in userspace code interacting with eBPF. Inputs include an integer network interface index (ifindex) and optional fd or id in the bpf_prog union; the expected output is a correctly structured value for updating or reading from a DEVMAP entry. There are kernel-version related constraints (value size may vary, extended fields available after kernel v5.8); correct userspace interaction is required for attaching programs.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/map-type/BPF_MAP_TYPE_DEVMAP.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstruct bpf_devmap_val {\n\t__u32 ifindex;   /* device index */\n\tunion {\n\t\tint   fd;  /* prog fd on map write */\n\t\t__u32 id;  /* prog id on map read */\n\t} bpf_prog;\n};\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_ringbuf_submit_dynptr Helper Function in C\nDESCRIPTION: This code snippet defines the 'bpf_ringbuf_submit_dynptr' helper function for eBPF programs. It submits a reserved ring buffer sample pointed to by a dynptr and takes flags as a parameter. The function always succeeds and returns nothing.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_ringbuf_submit_dynptr.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstatic void (* const bpf_ringbuf_submit_dynptr)(struct bpf_dynptr *ptr, __u64 flags) = (void *) 199;\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_skc_lookup_tcp Helper Function in C\nDESCRIPTION: This code snippet defines the 'bpf_skc_lookup_tcp' helper function. It looks for a TCP socket matching a given tuple, optionally in a child network namespace. The function returns a pointer to struct bpf_sock or NULL on failure.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_skc_lookup_tcp.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstatic struct bpf_sock *(* const bpf_skc_lookup_tcp)(void *ctx, struct bpf_sock_tuple *tuple, __u32 tuple_size, __u64 netns, __u64 flags) = (void *) 99;\n```\n\n----------------------------------------\n\nTITLE: Defining eBPF Raw Tracepoint Writable Program\nDESCRIPTION: This C code snippet defines an eBPF program that deals with writable raw tracepoints. It demonstrates how to manipulate the tracepoint context by reading and writing variable values within a BPF program. The program utilizes specific macros such as [SEC] and [BPF_PROG] to correctly identify and structure the BPF logic. It requires the inclusion of certain headers like struct bpf_testmod_test_writable_ctx, specific to the context being manipulated.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/program-type/BPF_PROG_TYPE_RAW_TRACEPOINT_WRITABLE.md#2025-04-22_snippet_0\n\nLANGUAGE: C\nCODE:\n```\n// SPDX-License-Identifier: GPL-2.0\n/* Copyright (c) 2020 Facebook */\n\n[SEC](../../ebpf-library/libbpf/ebpf/SEC.md)(\"raw_tp.w/bpf_testmod_test_writable_bare\")\nint [BPF_PROG](../../ebpf-library/libbpf/ebpf/BPF_PROG.md)(handle_raw_tp_writable_bare,\n\t     struct bpf_testmod_test_writable_ctx *writable)\n{\n\traw_tp_writable_bare_in_val = writable->val;\n\twritable->early_ret = raw_tp_writable_bare_early_ret;\n\twritable->val = raw_tp_writable_bare_out_val;\n\treturn 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Definition of btf__load_into_kernel Function in C\nDESCRIPTION: Function signature for btf__load_into_kernel which loads a BTF object into the kernel. It takes a pointer to a struct btf object and returns the file descriptor of the loaded BTF object on success or a negative error code on failure.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/btf__load_into_kernel.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nint btf__load_into_kernel(struct btf *btf);\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_skb_ancestor_cgroup_id Helper Function in C\nDESCRIPTION: This snippet defines the bpf_skb_ancestor_cgroup_id helper function for eBPF programs. It returns the id of a cgroup v2 ancestor of the cgroup associated with the given skb at the specified ancestor level.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_skb_ancestor_cgroup_id.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstatic __u64 (* const bpf_skb_ancestor_cgroup_id)(struct __sk_buff *skb, int ancestor_level) = (void *) 83;\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_set_retval Helper Function in C\nDESCRIPTION: This code snippet defines the 'bpf_set_retval' helper function for eBPF programs. It sets the BPF program's return value that will be returned to the upper layers. The function takes an integer parameter 'retval' and returns 0 on success or a negative error code on failure.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_set_retval.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstatic int (* const bpf_set_retval)(int retval) = (void *) 187;\n```\n\n----------------------------------------\n\nTITLE: Applying 'container_of' within an eBPF Iterator Program in C\nDESCRIPTION: Demonstrates the usage of `container_of` within an eBPF iterator program (`dump_netlink`) designed to inspect netlink sockets. The helper function `SOCK_INODE` uses `container_of` to derive the address of the containing `struct socket_alloc` from a given `struct socket *socket` pointer, allowing access to the `vfs_inode` member. The main iterator function then uses this helper (indirectly via `bpf_probe_read_kernel` due to verifier limitations noted in comments) to retrieve the inode number (`ino`) for display.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/ebpf/container_of.md#2025-04-22_snippet_2\n\nLANGUAGE: c\nCODE:\n```\n// SPDX-License-Identifier: GPL-2.0\n/* Copyright (c) 2020 Facebook */\n#include \"bpf_iter.h\"\n#include \"bpf_tracing_net.h\"\n#include <bpf/bpf_helpers.h>\n\nchar _license[] SEC(\"license\") = \"GPL\";\n\nstatic __attribute__((noinline)) struct inode *SOCK_INODE(struct socket *socket)\n{\n\treturn &container_of(socket, struct socket_alloc, socket)->vfs_inode;\n}\n\nSEC(\"iter/netlink\")\nint dump_netlink(struct bpf_iter__netlink *ctx)\n{\n\tstruct seq_file *seq = ctx->meta->seq;\n\tstruct netlink_sock *nlk = ctx->sk;\n\tunsigned long group, ino;\n\tstruct inode *inode;\n\tstruct socket *sk;\n\tstruct sock *s;\n\n\tif (nlk == (void *)0)\n\t\treturn 0;\n\n\tif (ctx->meta->seq_num == 0)\n\t\tBPF_SEQ_PRINTF(seq, \"sk               Eth Pid        Groups   \"\n\t\t\t    \"Rmem     Wmem     Dump  Locks    Drops    \"\n\t\t\t    \"Inode\\n\");\n\n\ts = &nlk->sk;\n\tBPF_SEQ_PRINTF(seq, \"%pK %-3d \", s, s->sk_protocol);\n\n\tif (!nlk->groups)  {\n\t\tgroup = 0;\n\t} else {\n\t\t/* FIXME: temporary use bpf_probe_read_kernel here, needs\n\t\t * verifier support to do direct access.\n\t\t */\n\t\tbpf_probe_read_kernel(&group, sizeof(group), &nlk->groups[0]);\n\t}\n\tBPF_SEQ_PRINTF(seq, \"%-10u %08x %-8d %-8d %-5d %-8d \",\n\t\t       nlk->portid, (u32)group,\n\t\t       s->sk_rmem_alloc.counter,\n\t\t       s->sk_wmem_alloc.refs.counter - 1,\n\t\t       nlk->cb_running, s->sk_refcnt.refs.counter);\n\n\tsk = s->sk_socket;\n\tif (!sk) {\n\t\tino = 0;\n\t} else {\n\t\t/* FIXME: container_of inside SOCK_INODE has a forced\n\t\t * type conversion, and direct access cannot be used\n\t\t * with current verifier.\n\t\t */\n\t\tinode = SOCK_INODE(sk);\n\t\tbpf_probe_read_kernel(&ino, sizeof(ino), &inode->i_ino);\n\t}\n\tBPF_SEQ_PRINTF(seq, \"%-8u %-8lu\\n\", s->sk_drops.counter, ino);\n\n\treturn 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining tcp_reno_cong_avoid in C\nDESCRIPTION: The 'tcp_reno_cong_avoid' function calculates a new congestion window using Jacobson's slow start and congestion avoidance algorithm. It requires a socket structure 'sk' and two 32-bit unsigned integers 'ack' and 'acked'. This function is utilized in conjunction with eBPF, specifically in program types like 'BPF_PROG_TYPE_STRUCT_OPS'.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/tcp_reno_cong_avoid.md#2025-04-22_snippet_0\n\nLANGUAGE: C\nCODE:\n```\nvoid tcp_reno_cong_avoid(struct sock *sk, u32 ack, u32 acked)\n```\n\n----------------------------------------\n\nTITLE: Implementing a Loadable Kernel Module in C\nDESCRIPTION: This code snippet demonstrates a simple loadable kernel module that defines a global variable 'test_kmod_var'. It includes initialization and cleanup functions, and module metadata.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_probe_read_kernel.md#2025-04-22_snippet_1\n\nLANGUAGE: c\nCODE:\n```\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nconst int test_kmod_var = 666;\n\nstatic int __init test_kmod_init(void)\n{\n    printk(KERN_INFO \"Hello, world, test_var=%d\\n\", test_kmod_var);\n\n    return 0;\n}\n\nstatic void __exit test_kmod_exit(void)\n{\n    printk(KERN_INFO \"Goodbye, world!\\n\");\n}\n\nmodule_init(test_kmod_init);\nmodule_exit(test_kmod_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Your Name\");\nMODULE_DESCRIPTION(\"A simple module\");\nMODULE_VERSION(\"1.0\");\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_get_func_ret Helper Function in C\nDESCRIPTION: Definition of the bpf_get_func_ret helper function for eBPF programs. This function retrieves the return value of a traced function for tracing programs.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_get_func_ret.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstatic long (* const bpf_get_func_ret)(void *ctx, __u64 *value) = (void *) 184;\n```\n\n----------------------------------------\n\nTITLE: Defining struct btf_dedup_opts for BTF Type Deduplication in C\nDESCRIPTION: The struct btf_dedup_opts defines options for the BTF deduplication process, including optional BTF extension information and testing parameters.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/btf__dedup.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstruct btf_dedup_opts {\n\tsize_t sz;\n\tstruct btf_ext *btf_ext;\n\tbool force_collisions;\n\tsize_t :0;\n};\n```\n\n----------------------------------------\n\nTITLE: Defining the bpf_dynptr_from_mem helper function in C\nDESCRIPTION: Declaration of the bpf_dynptr_from_mem helper function that creates a dynamic pointer to local memory. The function takes a pointer to data, size, flags, and a destination dynptr structure. It returns 0 on success, -E2BIG if size exceeds DYNPTR_MAX_SIZE, or -EINVAL if flags is not 0.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_dynptr_from_mem.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstatic long (* const bpf_dynptr_from_mem)(void *data, __u32 size, __u64 flags, struct bpf_dynptr *ptr) = (void *) 197;\n```\n\n----------------------------------------\n\nTITLE: Using a Weak Symbol for Safe Fallback in eBPF (libbpf, C)\nDESCRIPTION: This C code demonstrates marking an extern function 'bpf_dynptr_from_xdp' as a weak symbol for eBPF, and shows conditional runtime handling if the symbol is not found. It uses 'bpf_ksym_exists' to check symbol availability and provides a fallback code path if unavailable. Dependencies include libbpf, kernel headers for eBPF, and bpf helper definitions. The key parameters are pointers to packet data regardless of which path is taken; the output is XDP_PASS or XDP_DROP, controlling packet forwarding. Limitations: expects all helper functions are either present or safely handled as NULL.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/ebpf/__weak.md#2025-04-22_snippet_1\n\nLANGUAGE: c\nCODE:\n```\nextern int bpf_dynptr_from_xdp(struct xdp_md *x, u64 flags, struct bpf_dynptr *ptr__uninit) __weak __ksym;\n\nSEC(\"xdp.frags\")\nint example_prog(struct xdp_md *ctx)\n{\n    if (bpf_ksym_exists(bpf_dynptr_from_xdp)) {\n        struct bpf_dynptr ptr;\n        if (bpf_dynptr_from_xdp(ctx, 0, &ptr) < 0)\n            return XDP_DROP;\n\n        __u8 buf[sizeof(struct ethhdr)];\n        struct ethhdr *eth = bpf_dynptr_slice(&ptr, buf, sizeof(buf));\n        if (!eth)\n            return XDP_DROP;\n\n        if (eth->h_proto == htons(ETH_P_IP))\n            return XDP_PASS;\n    } else {\n        void *data_end = (void *)(long)ctx->data_end;\n        void *data = (void *)(long)ctx->data;\n\n        if (data + sizeof(struct ethhdr) > data_end)\n            return XDP_DROP;\n\n        struct ethhdr *eth = data;\n        if (eth->h_proto == htons(ETH_P_IP))\n            return XDP_PASS;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Using bpf_core_type_matches for Conditional Kernel Structure Access in C (eBPF)\nDESCRIPTION: This C code demonstrates using 'bpf_core_type_matches' within an eBPF helper function ('get_lock_owner') to check if specific structure definitions ('rw_semaphore___old' or 'rw_semaphore___new') match the target kernel's BTF. Based on the match result (evaluated at load time by the loader), the code conditionally accesses the appropriate structure members (using 'BPF_CORE_READ') to retrieve the lock owner, ensuring the eBPF program works correctly across different kernel versions with varying structure layouts. The return value (1 for match, 0 for no match) determines which code path is taken.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/ebpf/bpf_core_type_matches.md#2025-04-22_snippet_1\n\nLANGUAGE: c\nCODE:\n```\nstruct rw_semaphore___old {\n\tstruct task_struct *owner;\n} __attribute__((preserve_access_index));\n\nstruct rw_semaphore___new {\n\tatomic_long_t owner;\n} __attribute__((preserve_access_index));\n\nstatic inline struct task_struct *get_lock_owner(__u64 lock, __u32 flags)\n{\n\tstruct task_struct *task;\n\t__u64 owner = 0;\n\n\tif (flags & LCB_F_MUTEX) {\n\t\tstruct mutex *mutex = (void *)lock;\n\t\towner = BPF_CORE_READ(mutex, owner.counter);\n\t} else if (flags == LCB_F_READ || flags == LCB_F_WRITE) {\n        if (bpf_core_type_matches(struct rw_semaphore___old)) {\n            struct rw_semaphore___old *rwsem = (void *)lock;\n            owner = (unsigned long)BPF_CORE_READ(rwsem, owner);\n        } else if (bpf_core_type_matches(struct rw_semaphore___new)) {\n            struct rw_semaphore___new *rwsem = (void *)lock;\n            owner = BPF_CORE_READ(rwsem, owner.counter);\n        }\n\t}\n\n\tif (!owner)\n\t\treturn NULL;\n\n\ttask = (void *)(owner & ~7UL);\n\treturn task;\n}\n\n```\n\n----------------------------------------\n\nTITLE: Function Signature for btf__add_type in Libbpf (C)\nDESCRIPTION: Definition of the btf__add_type function which adds a BTF type from a source BTF object to another BTF object. It takes pointers to the destination BTF object, source BTF object, and the specific BTF type to be added. Returns 0 on success or a negative value on error.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/btf__add_type.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nint btf__add_type(struct btf *btf, const struct btf *src_btf, const struct btf_type *src_type);\n```\n\n----------------------------------------\n\nTITLE: Using READ_ONCE in a Loop for Shared Data Access in C\nDESCRIPTION: This example demonstrates how to use the READ_ONCE macro in a practical scenario. It shows a loop that checks a flag in shared data, using READ_ONCE to force the compiler to read the value from memory on each iteration rather than caching it.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/scx/READ_ONCE.md#2025-04-22_snippet_1\n\nLANGUAGE: c\nCODE:\n```\nfor (int i = 0; i < 10; i++) {\n    if (READ_ONCE(shared_data->flag) == 1) {\n        // Do something\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Function signature for bpf_program__attach_raw_tracepoint in C\nDESCRIPTION: The function declaration for bpf_program__attach_raw_tracepoint which attaches a BPF_PROG_TYPE_RAW_TRACEPOINT program to a tracepoint. It takes a BPF program pointer and a tracepoint name, returning a bpf_link pointer on success or NULL on failure.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_program__attach_raw_tracepoint.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstruct bpf_link * bpf_program__attach_raw_tracepoint(const struct bpf_program *prog, const char *tp_name);\n```\n\n----------------------------------------\n\nTITLE: Implementing Basic IR Decoder with BPF_PROG_TYPE_LIRC_MODE2\nDESCRIPTION: Example eBPF program that demonstrates how to decode IR signals by implementing a simple decoder that detects pulse durations and triggers keydown or pointer movement actions based on the signal properties. This program attaches to a LIRC device and processes IR signals in real-time.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/program-type/BPF_PROG_TYPE_LIRC_MODE2.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n// SPDX-License-Identifier: GPL-2.0\n// test ir decoder\n//\n// Copyright (C) 2018 Sean Young <sean@mess.org>\n\n#include <linux/bpf.h>\n#include <linux/lirc.h>\n#include <bpf/bpf_helpers.h>\n\nSEC(\"lirc_mode2\")\nint bpf_decoder(unsigned int *sample)\n{\n    if (LIRC_IS_PULSE(*sample)) {\n        unsigned int duration = LIRC_VALUE(*sample);\n\n        if (duration & 0x10000)\n            bpf_rc_keydown(sample, 0x40, duration & 0xffff, 0);\n        if (duration & 0x20000)\n            bpf_rc_pointer_rel(sample, (duration >> 8) & 0xff,\n                       duration & 0xff);\n    }\n\n    return 0;\n}\n\nchar _license[] SEC(\"license\") = \"GPL\";\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_strtol Helper Function in C\nDESCRIPTION: This code snippet defines the bpf_strtol helper function for eBPF. It converts a string to a long integer with a specified base, handling whitespace and negative signs. The function returns the number of characters consumed or error codes.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_strtol.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstatic long (* const bpf_strtol)(const char *buf, unsigned long buf_len, __u64 flags, long *res) = (void *) 105;\n```\n\n----------------------------------------\n\nTITLE: Defining and Using bpf_map__lookup_and_delete_elem in C\nDESCRIPTION: The function 'bpf_map__lookup_and_delete_elem' is used to lookup and atomically delete an element in a BPF map specified by the given key. This function requires a pointer to the BPF map and a key for the element. It also takes the size of the key and value, and a location to store the value. The function returns 0 on success or a negative error code on failure. Dependencies include the libbpf library and correct memory allocation for key and value parameters.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_map__lookup_and_delete_elem.md#2025-04-22_snippet_0\n\nLANGUAGE: C\nCODE:\n```\nint bpf_map__lookup_and_delete_elem(const struct bpf_map *map, const void *key, size_t key_sz, void *value, size_t value_sz, __u64 flags);\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_probe_read_user Helper Function in C\nDESCRIPTION: Function definition for bpf_probe_read_user helper that safely reads bytes from user space address to a destination buffer. Returns 0 on success or negative error code on failure.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_probe_read_user.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstatic long (* const bpf_probe_read_user)(void *dst, __u32 size, const void *unsafe_ptr) = (void *) 112;\n```\n\n----------------------------------------\n\nTITLE: HID Event Handling Program in C\nDESCRIPTION: eBPF program to handle HID device events by modifying input data for touch and coordinate information. Uses hid_bpf_get_data to access device data.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/hid_bpf_allocate_context.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nSEC(\"fmod_ret/hid_bpf_device_event\")\nint BPF_PROG(hid_event, struct hid_bpf_ctx *hctx)\n{\n\t__u8 *data = hid_bpf_get_data(hctx, 0 /* offset */, 9 /* size */);\n\n\tif (!data)\n\t\treturn 0; /* EPERM check */\n\n\t/* Touch */\n\tdata[1] &= 0xfd;\n\n\t/* X */\n\tdata[4] = 0;\n\tdata[5] = 0;\n\n\t/* Y */\n\tdata[6] = 0;\n\tdata[7] = 0;\n\n\treturn 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Declaring the bpf_link__disconnect Function in libbpf (C)\nDESCRIPTION: This C code snippet shows the function signature for `bpf_link__disconnect` from the libbpf library. The function takes a pointer to a `struct bpf_link` (`link`) and returns `void`. It is used to disconnect a BPF link, meaning the link object will no longer manage the lifetime (detachment/unregistration) of the underlying BPF resource when `bpf_link__destroy` is called.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_link__disconnect.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n#!c void bpf_link__disconnect(struct bpf_link *link);\n```\n\n----------------------------------------\n\nTITLE: Defining the bpf_trace_printk Helper Function (eBPF, C)\nDESCRIPTION: Defines the bpf_trace_printk helper as a static constant function pointer in eBPF C. This assignment is required to enable calls to the helper from eBPF programs, with the function pointer address (number 6) specific to the Linux eBPF helper table. The function accepts a format string, its size, and up to three additional arguments. Suitable for BPF program source files targeting the supported program types. This needs to appear in C code targeting eBPF, with no external dependencies other than the kernel BPF infrastructure.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_trace_printk.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n#!c static long (* const bpf_trace_printk)(const char *fmt, __u32 fmt_size, ...) = (void *) 6;\n```\n\n----------------------------------------\n\nTITLE: Defining Perf Event Header Structure in C\nDESCRIPTION: This structure defines the header for each entry in the perf event ring buffer, including the event type, miscellaneous data, and size.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/map-type/BPF_MAP_TYPE_PERF_EVENT_ARRAY.md#2025-04-22_snippet_4\n\nLANGUAGE: c\nCODE:\n```\nstruct perf_event_header {\n        __u32   type;\n        __u16   misc;\n        __u16   size;\n};\n```\n\n----------------------------------------\n\nTITLE: Defining 'bpf_cpumask_full' eBPF KFunc in C\nDESCRIPTION: Defines the 'bpf_cpumask_full' function that checks if all bits in a CPU-mask are set to true. It returns true if all the bits are set, otherwise false. This kfunc can be utilized in various BPF program types, such as LSM and PERF_EVENT. It requires a 'struct bpf_cpumask' as input.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/bpf_cpumask_full.md#2025-04-22_snippet_0\n\nLANGUAGE: C\nCODE:\n```\n#!c bool bpf_cpumask_full(const struct cpumask *cpumask)\n```\n\n----------------------------------------\n\nTITLE: Attaching an eBPF Program to a HID Device using BPF_PROG_TYPE_SYSCALL in C\nDESCRIPTION: This C code defines an eBPF program of type BPF_PROG_TYPE_SYSCALL. Its purpose is to attach another eBPF program (specified by `prog_fd`) to a particular HID device (identified by `hid`) using the `hid_bpf_attach_prog` function (likely a wrapper for a kfunc). The program takes a `struct attach_prog_args` as context, containing the program file descriptor and HID identifier, and stores the return value of the attach operation back into the context structure. This snippet is part of the HID-BPF use case where syscall programs facilitate attaching tracing programs to specific devices.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/program-type/BPF_PROG_TYPE_SYSCALL.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n```c\n// SPDX-License-Identifier: GPL-2.0-only\n/* Copyright (c) 2022 Benjamin Tissoires\n*/\n\n#include \"vmlinux.h\"\n#include <bpf/bpf_helpers.h>\n#include <bpf/bpf_tracing.h>\n#include \"hid_bpf_helpers.h\"\n\nstruct attach_prog_args {\n    int prog_fd;\n    unsigned int hid;\n    int retval;\n};\n\nSEC(\"syscall\")\nint attach_prog(struct attach_prog_args *ctx)\n{\n    ctx->retval = hid_bpf_attach_prog(ctx->hid,\n                    ctx->prog_fd,\n                    0);\n    return 0;\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Linking a BPF program to a perf event using BPF_LINK_CREATE\nDESCRIPTION: Using the BPF syscall with BPF_LINK_CREATE command to create a link between a BPF program and a perf event. This is part of the modern attachment method for single probes.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/program-type/BPF_PROG_TYPE_KPROBE.md#2025-04-22_snippet_4\n\nLANGUAGE: c\nCODE:\n```\nunion bpf_attr attr = {\n    .link_create.prog_fd = prog_fd; /* valid fd to bpf program of type KPROBE */\n    .link_create.target_fd = perf_fd; /* valid fd to PMU event */\n    .link_create.attach_type = BPF_PERF_EVENT;\n    .link_create.flags = 0;\n    .link_create.perf_event.bpf_cookie = 0;\n};\n\nsyscall(SYS_bpf,\n    BPF_LINK_CREATE,\n    &attr,\n    sizeof(attr)\n);\n```\n\n----------------------------------------\n\nTITLE: Testing Read-Only Status Detection for Dynamic Pointers\nDESCRIPTION: Tests the bpf_dynptr_is_rdonly helper with various dynptr types, showing that SKB-based dynptrs are read-only while ringbuffer-based dynptrs are read-write.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/concepts/dynptrs.md#2025-04-22_snippet_9\n\nLANGUAGE: c\nCODE:\n```\nSEC(\"cgroup_skb/egress\")\nint test_dynptr_is_rdonly(struct __sk_buff *skb)\n{\n\tstruct bpf_dynptr ptr1;\n\tstruct bpf_dynptr ptr2;\n\tstruct bpf_dynptr ptr3;\n\n\t/* Pass in invalid flags, get back an invalid dynptr */\n\tif (bpf_dynptr_from_skb(skb, 123, &ptr1) != -EINVAL) {\n\t\terr = 1;\n\t\treturn 0;\n\t}\n\n\t/* Test that an invalid dynptr is_rdonly returns false */\n\tif (bpf_dynptr_is_rdonly(&ptr1)) {\n\t\terr = 2;\n\t\treturn 0;\n\t}\n\n\t/* Get a read-only dynptr */\n\tif (bpf_dynptr_from_skb(skb, 0, &ptr2)) {\n\t\terr = 3;\n\t\treturn 0;\n\t}\n\n\t/* Test that the dynptr is read-only */\n\tif (!bpf_dynptr_is_rdonly(&ptr2)) {\n\t\terr = 4;\n\t\treturn 0;\n\t}\n\n\t/* Get a read-writeable dynptr */\n\tif (bpf_ringbuf_reserve_dynptr(&ringbuf, 64, 0, &ptr3)) {\n\t\terr = 5;\n\t\tgoto done;\n\t}\n\n\t/* Test that the dynptr is read-only */\n\tif (bpf_dynptr_is_rdonly(&ptr3)) {\n\t\terr = 6;\n\t\tgoto done;\n\t}\n\n\tdone:\n\tbpf_ringbuf_discard_dynptr(&ptr3, 0);\n\treturn 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_send_signal Helper Function in C\nDESCRIPTION: This snippet defines the 'bpf_send_signal' helper function prototype in C. It sends a signal to the process of the current task, with the signal potentially being delivered to any of the process's threads.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_send_signal.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstatic long (* const bpf_send_signal)(__u32 sig) = (void *) 109;\n```\n\n----------------------------------------\n\nTITLE: Defining Scheduler Extension Entity Structure (C)\nDESCRIPTION: Defines the sched_ext_entity struct which is embedded in task_struct and contains all fields necessary for a task to be scheduled by the SCX framework, including dispatch queues, flags, weights, and timing information.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/program-type/BPF_PROG_TYPE_STRUCT_OPS/sched_ext_ops.md#2025-04-22_snippet_51\n\nLANGUAGE: c\nCODE:\n```\nstruct sched_ext_entity {\n    struct scx_dispatch_q      *dsq;\n    struct scx_dsq_list_node    dsq_list; \n    struct rb_node              dsq_priq; \n\n    u32 dsq_seq;\n    u32 dsq_flags;\n    u32 flags; \n    u32 weight;\n    s32 sticky_cpu;\n    s32 holding_cpu;\n    u32 kf_mask; \n    \n    struct task_struct  *kf_tasks[2];\n    atomic_long_t        ops_state;\n    struct list_head     runnable_node;\n    unsigned long        runnable_at;\n\n#ifdef CONFIG_SCHED_CORE\n    u64 core_sched_at;\n#endif\n    \n    u64  ddsp_dsq_id;\n    u64  ddsp_enq_flags;\n    u64  slice;\n    u64  dsq_vtime;\n    bool disallow;\n\n#ifdef CONFIG_EXT_GROUP_SCHED\n    struct cgroup       *cgrp_moving_from;\n#endif\n    struct list_head    tasks_node;\n};\n```\n\n----------------------------------------\n\nTITLE: Defining scx_bpf_dispatch KFunc in C\nDESCRIPTION: This code snippet defines the signature of the 'scx_bpf_dispatch' kfunc. It takes a task_struct pointer, dispatch queue ID, slice value, and enqueue flags as parameters.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/scx_bpf_dispatch.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nvoid scx_bpf_dispatch(struct task_struct *p, u64 dsq_id, u64 slice, u64 enq_flags)\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_get_task_stack Helper Function in C\nDESCRIPTION: Function definition for the bpf_get_task_stack helper that retrieves stack traces. Takes task_struct pointer, buffer, size and flags as parameters. Returns the length of copied buffer or negative error code.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_get_task_stack.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstatic long (* const bpf_get_task_stack)(struct task_struct *task, void *buf, __u32 size, __u64 flags) = (void *) 141;\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_sk_storage_delete Helper Function in C\nDESCRIPTION: This code snippet defines the bpf_sk_storage_delete helper function for eBPF programs. It deletes a bpf-local-storage from a socket (sk). The function returns 0 on success, -ENOENT if the storage is not found, and -EINVAL if the socket is not a full socket.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_sk_storage_delete.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstatic long (* const bpf_sk_storage_delete)(void *map, void *sk) = (void *) 108;\n```\n\n----------------------------------------\n\nTITLE: Defining Legacy eBPF Map in C\nDESCRIPTION: Demonstrates the legacy method of defining an eBPF map using the struct bpf_map_def type. This method is less preferred as it loses key and value type information.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/concepts/maps.md#2025-04-22_snippet_0\n\nLANGUAGE: C\nCODE:\n```\nstruct bpf_map_def my_map = {\n\t.type = BPF_MAP_TYPE_HASH,\n\t.key_size = sizeof(int),\n\t.value_size = sizeof(int),\n\t.max_entries = 100,\n\t.map_flags = BPF_F_NO_PREALLOC,\n} SEC(\"maps\");\n```\n\n----------------------------------------\n\nTITLE: eBPF Program Type and ELF Section Name Index (Markdown)\nDESCRIPTION: A Markdown table detailing the relationship between various eBPF program types (like `BPF_PROG_TYPE_CGROUP_SKB`, `BPF_PROG_TYPE_KPROBE`, `BPF_PROG_TYPE_XDP`), attach types (like `BPF_CGROUP_INET_EGRESS`, `BPF_TRACE_FENTRY`), and the expected ELF section names (like `cgroup_skb/egress`, `fentry/<function>`, `xdp`) used by libbpf. Footnotes clarify the meaning of placeholders such as `<function>`, `<syscall>`, `<path>`, `<tracepoint>`, etc.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/program-type/index.md#2025-04-22_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n## Index of section names\n\n| Program Type | Attach Type | ELF Section Name |\n| --- | --- | --- |\n| `BPF_PROG_TYPE_CGROUP_DEVICE` | `BPF_CGROUP_DEVICE` | `cgroup/dev` |\n| `BPF_PROG_TYPE_CGROUP_SKB` || `cgroup/skb` |\n| `BPF_PROG_TYPE_CGROUP_SKB` | `BPF_CGROUP_INET_EGRESS` | `cgroup_skb/egress` |\n| `BPF_PROG_TYPE_CGROUP_SKB` | `BPF_CGROUP_INET_INGRESS` | `cgroup_skb/ingress` |\n| `BPF_PROG_TYPE_CGROUP_SOCKOPT` | `BPF_CGROUP_GETSOCKOPT` | `cgroup/getsockopt` |\n| `BPF_PROG_TYPE_CGROUP_SOCKOPT` | `BPF_CGROUP_SETSOCKOPT` | `cgroup/setsockopt` |\n| `BPF_PROG_TYPE_CGROUP_SOCK_ADDR` | `BPF_CGROUP_INET4_BIND` | `cgroup/bind4` |\n| `BPF_PROG_TYPE_CGROUP_SOCK_ADDR` | `BPF_CGROUP_INET4_CONNECT` | `cgroup/connect4` |\n| `BPF_PROG_TYPE_CGROUP_SOCK_ADDR` | `BPF_CGROUP_INET4_GETPEERNAME` | `cgroup/getpeername4` |\n| `BPF_PROG_TYPE_CGROUP_SOCK_ADDR` | `BPF_CGROUP_INET4_GETSOCKNAME` | `cgroup/getsockname4` |\n| `BPF_PROG_TYPE_CGROUP_SOCK_ADDR` | `BPF_CGROUP_INET6_BIND` | `cgroup/bind6` |\n| `BPF_PROG_TYPE_CGROUP_SOCK_ADDR` | `BPF_CGROUP_INET6_CONNECT` | `cgroup/connect6` |\n| `BPF_PROG_TYPE_CGROUP_SOCK_ADDR` | `BPF_CGROUP_INET6_GETPEERNAME` | `cgroup/getpeername6` |\n| `BPF_PROG_TYPE_CGROUP_SOCK_ADDR` | `BPF_CGROUP_INET6_GETSOCKNAME` | `cgroup/getsockname6` |\n| `BPF_PROG_TYPE_CGROUP_SOCK_ADDR` | `BPF_CGROUP_UDP4_RECVMSG` | `cgroup/recvmsg4` |\n| `BPF_PROG_TYPE_CGROUP_SOCK_ADDR` | `BPF_CGROUP_UDP4_SENDMSG` | `cgroup/sendmsg4` |\n| `BPF_PROG_TYPE_CGROUP_SOCK_ADDR` | `BPF_CGROUP_UDP6_RECVMSG` | `cgroup/recvmsg6` |\n| `BPF_PROG_TYPE_CGROUP_SOCK_ADDR` | `BPF_CGROUP_UDP6_SENDMSG` | `cgroup/sendmsg6` |\n| `BPF_PROG_TYPE_CGROUP_SOCK_ADDR` | `BPF_CGROUP_UNIX_CONNECT` | `cgroup/connect_unix` |\n| `BPF_PROG_TYPE_CGROUP_SOCK_ADDR` | `BPF_CGROUP_UNIX_SENDMSG` | `cgroup/sendmsg_unix` |\n| `BPF_PROG_TYPE_CGROUP_SOCK_ADDR` | `BPF_CGROUP_UNIX_RECVMSG` | `cgroup/recvmsg_unix` |\n| `BPF_PROG_TYPE_CGROUP_SOCK_ADDR` | `BPF_CGROUP_UNIX_GETPEERNAME` | `cgroup/getpeername_unix` |\n| `BPF_PROG_TYPE_CGROUP_SOCK_ADDR` | `BPF_CGROUP_UNIX_GETSOCKNAME` | `cgroup/getsockname_unix` |\n| `BPF_PROG_TYPE_CGROUP_SOCK` | `BPF_CGROUP_INET4_POST_BIND` | `cgroup/post_bind4` |\n| `BPF_PROG_TYPE_CGROUP_SOCK` | `BPF_CGROUP_INET6_POST_BIND` | `cgroup/post_bind6` |\n| `BPF_PROG_TYPE_CGROUP_SOCK` | `BPF_CGROUP_INET_SOCK_CREATE` | `cgroup/sock_create` |\n| `BPF_PROG_TYPE_CGROUP_SOCK` | `BPF_CGROUP_INET_SOCK_CREATE` | `cgroup/sock` |\n| `BPF_PROG_TYPE_CGROUP_SOCK` | `BPF_CGROUP_INET_SOCK_RELEASE` | `cgroup/sock_release` |\n| `BPF_PROG_TYPE_CGROUP_SYSCTL` | `BPF_CGROUP_SYSCTL` | `cgroup/sysctl` |\n| `BPF_PROG_TYPE_EXT` || `freplace`  or `freplace/<function>`  [^1]|\n| `BPF_PROG_TYPE_FLOW_DISSECTOR` | `BPF_FLOW_DISSECTOR` | `flow_dissector` |\n| `BPF_PROG_TYPE_KPROBE` || `kprobe`  or `kprobe/<function>` or `kprobe/<function>+<offset>`  [^2]|\n| `BPF_PROG_TYPE_KPROBE` || `kretprobe`  or `kprobe/<function>` or `kprobe/<function>+<offset>`  [^2]|\n| `BPF_PROG_TYPE_KPROBE` || `ksyscall`  or `ksyscall/<syscall>`  [^3]|\n| `BPF_PROG_TYPE_KPROBE` || `kretsyscall`  or `ksyscall/<syscall>`  [^3]|\n| `BPF_PROG_TYPE_KPROBE` || `uprobe`  or `uprobe/<path>:<function>` or `uprobe:/<path>:<function>+<offset>`  [^4]|\n| `BPF_PROG_TYPE_KPROBE` || `uprobe.s`  or `uprobe.s/<path>:<function>` or `uprobe.s:/<path>:<function>+<offset>`  [^4]|\n| `BPF_PROG_TYPE_KPROBE` || `uretprobe`  or `uretprobe/<path>:<function>` or `uretprobe:/<path>:<function>+<offset>`  [^4]|\n| `BPF_PROG_TYPE_KPROBE` || `uretprobe.s`  or `uretprobe.s/<path>:<function>` or `uretprobe.s:/<path>:<function>+<offset>`  [^4]|\n| `BPF_PROG_TYPE_KPROBE` || `usdt`  or `usdt/<path>:<provider>:<name>`  [^5]|\n| `BPF_PROG_TYPE_KPROBE` | `BPF_TRACE_KPROBE_MULTI` | `kprobe.multi`  or `kprobe.multi/<pattern>`  [^6]|\n| `BPF_PROG_TYPE_KPROBE` | `BPF_TRACE_KPROBE_MULTI` | `kretprobe.multi`  or  `kretprobe.multi/<pattern>`  [^6]|\n| `BPF_PROG_TYPE_LIRC_MODE2` | `BPF_LIRC_MODE2` | `lirc_mode2` |\n| `BPF_PROG_TYPE_LSM` | `BPF_LSM_CGROUP` | `lsm_cgroup` |     |\n| `BPF_PROG_TYPE_LSM` | `BPF_LSM_MAC` | `lsm`  or `lsm/<hook>`  [^7]|\n| `BPF_PROG_TYPE_LSM` | `BPF_LSM_MAC` | `lsm.s`  or `lsm.s/<hook>`  [^7]|\n| `BPF_PROG_TYPE_LWT_IN` || `lwt_in` |\n| `BPF_PROG_TYPE_LWT_OUT` || `lwt_out` |\n| `BPF_PROG_TYPE_LWT_SEG6LOCAL` || `lwt_seg6local` |\n| `BPF_PROG_TYPE_LWT_XMIT` || `lwt_xmit` |\n| `BPF_PROG_TYPE_NETFILTER` || `netfilter` |\n| `BPF_PROG_TYPE_PERF_EVENT` || `perf_event` |\n| `BPF_PROG_TYPE_RAW_TRACEPOINT_WRITABLE` || `raw_tp.w`  or `raw_tp.w/<tracepoint>`  [^8]|\n| `BPF_PROG_TYPE_RAW_TRACEPOINT_WRITABLE` || `raw_tracepoint.w` or `raw_tracepoint.w/<tracepoint>` |\n| `BPF_PROG_TYPE_RAW_TRACEPOINT` || `raw_tp`  or `raw_tp.w/<tracepoint>`  [^8]|\n| `BPF_PROG_TYPE_RAW_TRACEPOINT` || `raw_tracepoint` or `raw_tracepoint/<tracepoint>` |\n| `BPF_PROG_TYPE_SCHED_ACT` || `action`   [^9]|\n| `BPF_PROG_TYPE_SCHED_CLS` || `classifier`   [^9]|\n| `BPF_PROG_TYPE_SCHED_CLS` || `tc`   [^9]|\n| `BPF_PROG_TYPE_SCHED_CLS` | `BPF_NETKIT_PRIMARY` | `netkit/primary` |\n| `BPF_PROG_TYPE_SCHED_CLS` | `BPF_NETKIT_PEER` | `netkit/peer` |\n| `BPF_PROG_TYPE_SCHED_CLS` | `BPF_TCX_INGRESS` | `tc/ingress` |\n| `BPF_PROG_TYPE_SCHED_CLS` | `BPF_TCX_EGRESS` | `tc/egress` |\n| `BPF_PROG_TYPE_SCHED_CLS` | `BPF_TCX_INGRESS` | `tcx/ingress` |\n| `BPF_PROG_TYPE_SCHED_CLS` | `BPF_TCX_EGRESS` | `tcx/egress` |\n| `BPF_PROG_TYPE_SK_LOOKUP` | `BPF_SK_LOOKUP` | `sk_lookup` |\n| `BPF_PROG_TYPE_SK_MSG` | `BPF_SK_MSG_VERDICT` | `sk_msg` |\n| `BPF_PROG_TYPE_SK_REUSEPORT` | `BPF_SK_REUSEPORT_SELECT_OR_MIGRATE` | `sk_reuseport/migrate` |\n| `BPF_PROG_TYPE_SK_REUSEPORT` | `BPF_SK_REUSEPORT_SELECT` | `sk_reuseport` |\n| `BPF_PROG_TYPE_SK_SKB` || `sk_skb` |\n| `BPF_PROG_TYPE_SK_SKB` | `BPF_SK_SKB_STREAM_PARSER` | `sk_skb/stream_parser` |\n| `BPF_PROG_TYPE_SK_SKB` | `BPF_SK_SKB_STREAM_VERDICT` | `sk_skb/stream_verdict` |\n| `BPF_PROG_TYPE_SOCKET_FILTER` || `socket` |\n| `BPF_PROG_TYPE_SOCK_OPS` | `BPF_CGROUP_SOCK_OPS` | `sockops` |\n| `BPF_PROG_TYPE_STRUCT_OPS` || `struct_ops`  or `struct_ops/<name>`  [^10]|\n| `BPF_PROG_TYPE_STRUCT_OPS` || `struct_ops.s`  or `struct_ops.s/<name>`  [^10]|\n| `BPF_PROG_TYPE_SYSCALL` || `syscall` |\n| `BPF_PROG_TYPE_TRACEPOINT` || `tp`  or `tp/<category>/<name>`  [^11]|\n| `BPF_PROG_TYPE_TRACEPOINT` || `tracepoint`  or `tracepoint/<category>/<name>`  [^11]|\n| `BPF_PROG_TYPE_TRACING` | `BPF_MODIFY_RETURN` | `fmod_ret`  or `fmod_ret/<function>`  [^1]|\n| `BPF_PROG_TYPE_TRACING` | `BPF_MODIFY_RETURN` | `fmod_ret.s`  or `fmod_ret.s/<function>`  [^1]|\n| `BPF_PROG_TYPE_TRACING` | `BPF_TRACE_FENTRY` | `fentry`  or `fentry/<function>`  [^1]|\n| `BPF_PROG_TYPE_TRACING` | `BPF_TRACE_FENTRY` | `fentry.s`  or `fentry.s/<function>`  [^1]|\n| `BPF_PROG_TYPE_TRACING` | `BPF_TRACE_FEXIT` | `fexit`  or `fexit/<function>`  [^1]|\n| `BPF_PROG_TYPE_TRACING` | `BPF_TRACE_FEXIT` | `fexit.s`  or `fexit.s/<function>`  [^1]|\n| `BPF_PROG_TYPE_TRACING` | `BPF_TRACE_ITER` | `iter`  or ` iter/<struct-name>`  [^12]|\n| `BPF_PROG_TYPE_TRACING` | `BPF_TRACE_ITER` | `iter.s`  or ` iter.s/<struct-name>`  [^12]|\n| `BPF_PROG_TYPE_TRACING` | `BPF_TRACE_RAW_TP` | `tp_btf`  or `tp_btf/<function>`  [^1]|\n| `BPF_PROG_TYPE_XDP` | `BPF_XDP_CPUMAP` | `xdp.frags/cpumap` |\n| `BPF_PROG_TYPE_XDP` | `BPF_XDP_CPUMAP` | `xdp/cpumap` |\n| `BPF_PROG_TYPE_XDP` | `BPF_XDP_DEVMAP` | `xdp.frags/devmap` |\n| `BPF_PROG_TYPE_XDP` | `BPF_XDP_DEVMAP` | `xdp/devmap` |\n| `BPF_PROG_TYPE_XDP` | `BPF_XDP` | `xdp.frags` |\n| `BPF_PROG_TYPE_XDP` | `BPF_XDP` | `xdp` |\n\nThe table above was sourced from the [Program Types and ELF Sections](https://docs.kernel.org/bpf/libbpf/program_types.html) page (`Copyright (c) 2022 Donald Hunter . All rights reserved.`) in the [Linux Kernel documentation](https://docs.kernel.org/index.html).\n\n[^1]: `<function>` is the symbol name of a function. This may be architecture-specific, such as `__x64_sys_getpid` for the `getpid` syscall on the x86_64 architecture. Valid characters for `<function>` are `a-zA-Z0-9_`.\n[^2]: `<offset>` is an address offset from the symbol name. It must be a valid non-negative integer.\n[^3]: `<syscall>` is the name of a system call, such as `getpid`. It is not architecture-specific.\n[^4]:  `<path>` is a path to an executable or library.\n[^5]:  `<path>` is a path to an executable or library that provides the USDT probe, `<provider>` is the USDT provider, and `<name>` is the USDT probe name.\n[^6]:  `<pattern>` is used to match kernel function names, which may be architecture-specific. `<pattern>` supports `*` and `?` wildcards. Valid characters for `<pattern>` are `a-zA-Z0-9_.*?`.\n[^7]:  `<hook>` is the name of an LSM (Linux Security Module) hook. See [Program type BPF_PROG_TYPE_LSM](./BPF_PROG_TYPE_LSM.md) for details.\n[^8]:  `<tracepoint>` is the name of a trace event. See [Program type BPF_PROG_TYPE_TRACEPOINT](./BPF_PROG_TYPE_TRACEPOINT.md) and [Program Type BPF_PROG_TYPE_RAW_TRACEPOINT](./BPF_PROG_TYPE_RAW_TRACEPOINT.md) for details.\n[^9]: The `tc`, `classifier` and `action` attach types are deprecated, use `tcx/*` instead.\n[^10]: `<name>` is the value of the `.name` member of a struct defined in the `.struct_ops` section. See [Program type BPF_PROG_TYPE_STRUCT_OPS](./BPF_PROG_TYPE_STRUCT_OPS.md) for details.\n[^11]: `<category>` is the name of a subsystem, and `<name>` is the name of an event as per [event tracing](https://docs.kernel.org/trace/events.html) convention.\n[^12]: `<struct_name>` is the name of a _tracing program iterator_. See [Iterator in Program type BPF_PROG_TYPE_TRACING](./BPF_PROG_TYPE_TRACING.md#iterator) for details.\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_set_hash_invalid Helper Function in C\nDESCRIPTION: This code snippet defines the bpf_set_hash_invalid helper function. It invalidates the current skb->hash and triggers recalculation when the kernel accesses the hash or when bpf_get_hash_recalc() is called. The function takes a struct __sk_buff pointer as an argument and returns void.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_set_hash_invalid.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstatic void (* const bpf_set_hash_invalid)(struct __sk_buff *skb) = (void *) 41;\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_kptr_xchg Helper Function in C\nDESCRIPTION: Function definition for the bpf_kptr_xchg helper that exchanges a kptr at a given destination with a new pointer value. The function returns the old pointer value and handles pointer reference management.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_kptr_xchg.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstatic void *(* const bpf_kptr_xchg)(void *dst, void *ptr) = (void *) 194;\n```\n\n----------------------------------------\n\nTITLE: IP Tunnel Encapsulation with eBPF Dynamic Pointers\nDESCRIPTION: This example demonstrates IP-in-IP tunnel encapsulation using eBPF dynamic pointers (dynptrs). It processes both IPv4 and IPv6 packets, performs encapsulation based on a map lookup, and handles packet modification for tunneling. The code includes packet header inspection and modification.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/bpf_dynptr_from_xdp.md#2025-04-22_snippet_2\n\nLANGUAGE: c\nCODE:\n```\n// SPDX-License-Identifier: GPL-2.0\n/* Copyright (c) 2022 Meta */\n#include <stddef.h>\n#include <string.h>\n#include <linux/bpf.h>\n#include <linux/if_ether.h>\n#include <linux/if_packet.h>\n#include <linux/ip.h>\n#include <linux/ipv6.h>\n#include <linux/in.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/pkt_cls.h>\n#include <sys/socket.h>\n#include <bpf/bpf_helpers.h>\n#include <bpf/bpf_endian.h>\n#include \"test_iptunnel_common.h\"\n#include \"bpf_kfuncs.h\"\n\nconst size_t tcphdr_sz = sizeof(struct tcphdr);\nconst size_t udphdr_sz = sizeof(struct udphdr);\nconst size_t ethhdr_sz = sizeof(struct ethhdr);\nconst size_t iphdr_sz = sizeof(struct iphdr);\nconst size_t ipv6hdr_sz = sizeof(struct ipv6hdr);\n\nstruct {\n    __uint(type, BPF_MAP_TYPE_PERCPU_ARRAY);\n    __uint(max_entries, 256);\n    __type(key, __u32);\n    __type(value, __u64);\n} rxcnt SEC(\".maps\");\n\nstruct {\n    __uint(type, BPF_MAP_TYPE_HASH);\n    __uint(max_entries, MAX_IPTNL_ENTRIES);\n    __type(key, struct vip);\n    __type(value, struct iptnl_info);\n} vip2tnl SEC(\".maps\");\n\nstatic __always_inline void count_tx(__u32 protocol)\n{\n    __u64 *rxcnt_count;\n\n    rxcnt_count = bpf_map_lookup_elem(&rxcnt, &protocol);\n    if (rxcnt_count)\n        *rxcnt_count += 1;\n}\n\nstatic __always_inline int get_dport(void *trans_data, __u8 protocol)\n{\n    struct tcphdr *th;\n    struct udphdr *uh;\n\n    switch (protocol) {\n    case IPPROTO_TCP:\n        th = (struct tcphdr *)trans_data;\n        return th->dest;\n    case IPPROTO_UDP:\n        uh = (struct udphdr *)trans_data;\n        return uh->dest;\n    default:\n        return 0;\n    }\n}\n\nstatic __always_inline void set_ethhdr(struct ethhdr *new_eth,\n                    const struct ethhdr *old_eth,\n                    const struct iptnl_info *tnl,\n                    __be16 h_proto)\n{\n    memcpy(new_eth->h_source, old_eth->h_dest, sizeof(new_eth->h_source));\n    memcpy(new_eth->h_dest, tnl->dmac, sizeof(new_eth->h_dest));\n    new_eth->h_proto = h_proto;\n}\n\nstatic __always_inline int handle_ipv4(struct xdp_md *xdp, struct bpf_dynptr *xdp_ptr)\n{\n    __u8 eth_buffer[ethhdr_sz + iphdr_sz + ethhdr_sz];\n    __u8 iph_buffer_tcp[iphdr_sz + tcphdr_sz];\n    __u8 iph_buffer_udp[iphdr_sz + udphdr_sz];\n    struct bpf_dynptr new_xdp_ptr;\n    struct iptnl_info *tnl;\n    struct ethhdr *new_eth;\n    struct ethhdr *old_eth;\n    __u32 transport_hdr_sz;\n    struct iphdr *iph;\n    __u16 *next_iph;\n    __u16 payload_len;\n    struct vip vip = {};\n    int dport;\n    __u32 csum = 0;\n    int i;\n\n    __builtin_memset(eth_buffer, 0, sizeof(eth_buffer));\n    __builtin_memset(iph_buffer_tcp, 0, sizeof(iph_buffer_tcp));\n    __builtin_memset(iph_buffer_udp, 0, sizeof(iph_buffer_udp));\n\n    if (ethhdr_sz + iphdr_sz + tcphdr_sz > xdp->data_end - xdp->data)\n        iph = bpf_dynptr_slice(xdp_ptr, ethhdr_sz, iph_buffer_udp, sizeof(iph_buffer_udp));\n    else\n        iph = bpf_dynptr_slice(xdp_ptr, ethhdr_sz, iph_buffer_tcp, sizeof(iph_buffer_tcp));\n\n    if (!iph)\n        return XDP_DROP;\n\n    dport = get_dport(iph + 1, iph->protocol);\n    if (dport == -1)\n        return XDP_DROP;\n\n    vip.protocol = iph->protocol;\n    vip.family = AF_INET;\n    vip.daddr.v4 = iph->daddr;\n    vip.dport = dport;\n    payload_len = bpf_ntohs(iph->tot_len);\n\n    tnl = bpf_map_lookup_elem(&vip2tnl, &vip);\n    /* It only does v4-in-v4 */\n    if (!tnl || tnl->family != AF_INET)\n        return XDP_PASS;\n\n    if (bpf_xdp_adjust_head(xdp, 0 - (int)iphdr_sz))\n        return XDP_DROP;\n\n    bpf_dynptr_from_xdp(xdp, 0, &new_xdp_ptr);\n    new_eth = bpf_dynptr_slice_rdwr(&new_xdp_ptr, 0, eth_buffer, sizeof(eth_buffer));\n    if (!new_eth)\n        return XDP_DROP;\n\n    iph = (struct iphdr *)(new_eth + 1);\n    old_eth = (struct ethhdr *)(iph + 1);\n\n    set_ethhdr(new_eth, old_eth, tnl, bpf_htons(ETH_P_IP));\n\n    if (new_eth == eth_buffer)\n        bpf_dynptr_write(&new_xdp_ptr, 0, eth_buffer, sizeof(eth_buffer), 0);\n\n    iph->version = 4;\n    iph->ihl = iphdr_sz >> 2;\n    iph->frag_off =\t0;\n    iph->protocol = IPPROTO_IPIP;\n    iph->check = 0;\n    iph->tos = 0;\n    iph->tot_len = bpf_htons(payload_len + iphdr_sz);\n    iph->daddr = tnl->daddr.v4;\n    iph->saddr = tnl->saddr.v4;\n    iph->ttl = 8;\n\n    next_iph = (__u16 *)iph;\n    for (i = 0; i < iphdr_sz >> 1; i++)\n        csum += *next_iph++;\n\n    iph->check = ~((csum & 0xffff) + (csum >> 16));\n\n    count_tx(vip.protocol);\n\n    return XDP_TX;\n}\n\nstatic __always_inline int handle_ipv6(struct xdp_md *xdp, struct bpf_dynptr *xdp_ptr)\n{\n    __u8 eth_buffer[ethhdr_sz + ipv6hdr_sz + ethhdr_sz];\n    __u8 ip6h_buffer_tcp[ipv6hdr_sz + tcphdr_sz];\n    __u8 ip6h_buffer_udp[ipv6hdr_sz + udphdr_sz];\n    struct bpf_dynptr new_xdp_ptr;\n    struct iptnl_info *tnl;\n    struct ethhdr *new_eth;\n    struct ethhdr *old_eth;\n    __u32 transport_hdr_sz;\n    struct ipv6hdr *ip6h;\n    __u16 payload_len;\n    struct vip vip = {};\n    int dport;\n\n    __builtin_memset(eth_buffer, 0, sizeof(eth_buffer));\n    __builtin_memset(ip6h_buffer_tcp, 0, sizeof(ip6h_buffer_tcp));\n    __builtin_memset(ip6h_buffer_udp, 0, sizeof(ip6h_buffer_udp));\n\n    if (ethhdr_sz + iphdr_sz + tcphdr_sz > xdp->data_end - xdp->data)\n        ip6h = bpf_dynptr_slice(xdp_ptr, ethhdr_sz, ip6h_buffer_udp, sizeof(ip6h_buffer_udp));\n    else\n        ip6h = bpf_dynptr_slice(xdp_ptr, ethhdr_sz, ip6h_buffer_tcp, sizeof(ip6h_buffer_tcp));\n\n    if (!ip6h)\n        return XDP_DROP;\n\n    dport = get_dport(ip6h + 1, ip6h->nexthdr);\n    if (dport == -1)\n        return XDP_DROP;\n\n    vip.protocol = ip6h->nexthdr;\n    vip.family = AF_INET6;\n    memcpy(vip.daddr.v6, ip6h->daddr.s6_addr32, sizeof(vip.daddr));\n    vip.dport = dport;\n    payload_len = ip6h->payload_len;\n\n    tnl = bpf_map_lookup_elem(&vip2tnl, &vip);\n    /* It only does v6-in-v6 */\n    if (!tnl || tnl->family != AF_INET6)\n        return XDP_PASS;\n\n    if (bpf_xdp_adjust_head(xdp, 0 - (int)ipv6hdr_sz))\n        return XDP_DROP;\n\n    bpf_dynptr_from_xdp(xdp, 0, &new_xdp_ptr);\n    new_eth = bpf_dynptr_slice_rdwr(&new_xdp_ptr, 0, eth_buffer, sizeof(eth_buffer));\n    if (!new_eth)\n        return XDP_DROP;\n\n    ip6h = (struct ipv6hdr *)(new_eth + 1);\n    old_eth = (struct ethhdr *)(ip6h + 1);\n\n\n```\n\n----------------------------------------\n\nTITLE: Defining the bpf_core_type_matches Macro in C\nDESCRIPTION: This snippet shows the C macro definition for 'bpf_core_type_matches'. It utilizes the '__builtin_preserve_type_info' compiler builtin with the 'BPF_TYPE_MATCHES' flag to embed type information. This information is later used by the eBPF loader (like libbpf) to compare the type against the target kernel's BTF information at load time.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/ebpf/bpf_core_type_matches.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n#define bpf_core_type_matches(type)\t\t\t\t\t    \\\n\t__builtin_preserve_type_info(*___bpf_typeof(type), BPF_TYPE_MATCHES)\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_get_branch_snapshot Helper Function in C\nDESCRIPTION: Function definition for bpf_get_branch_snapshot helper that gets branch trace from hardware engines. The function takes entries buffer, size, and flags as parameters and returns the number of bytes written or error code.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_get_branch_snapshot.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstatic long (* const bpf_get_branch_snapshot)(void *entries, __u32 size, __u64 flags) = (void *) 176;\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_copy_from_user_task Helper Function in C\nDESCRIPTION: This code snippet defines the 'bpf_copy_from_user_task' helper function for eBPF programs. It reads data from user space of a specified task into a destination buffer.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_copy_from_user_task.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstatic long (* const bpf_copy_from_user_task)(void *dst, __u32 size, const void *user_ptr, struct task_struct *tsk, __u64 flags) = (void *) 191;\n```\n\n----------------------------------------\n\nTITLE: Creating an Umem Area with xsk_umem__create Function in C\nDESCRIPTION: Function signature for xsk_umem__create which creates an umem area. It takes parameters for the umem structure, memory area, size, ring buffers for fill and completion, and configuration. Returns 0 on success or negative error codes on failure.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libxdp/functions/xsk_umem__create.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nint xsk_umem__create(struct xsk_umem **umem, void *umem_area, __u64 size,\n\t\t     struct xsk_ring_prod *fill,\n\t\t     struct xsk_ring_cons *comp,\n\t\t     const struct xsk_umem_config *config);\n```\n\n----------------------------------------\n\nTITLE: Load Balancer Map Definitions\nDESCRIPTION: eBPF map definitions for storing VIP configurations, consistent hash rings, real server definitions, and statistics. Includes map type specifications and maximum entry limits.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/bpf_dynptr_from_skb.md#2025-04-22_snippet_3\n\nLANGUAGE: c\nCODE:\n```\nstruct {\n    __uint(type, BPF_MAP_TYPE_HASH);\n    __uint(max_entries, MAX_VIPS);\n    __type(key, struct vip);\n    __type(value, struct vip_meta);\n} vip_map SEC(\".maps\");\n\nstruct {\n    __uint(type, BPF_MAP_TYPE_ARRAY);\n    __uint(max_entries, CH_RINGS_SIZE);\n    __type(key, __u32);\n    __type(value, __u32);\n} ch_rings SEC(\".maps\");\n```\n\n----------------------------------------\n\nTITLE: Querying Ring Buffer Characteristics in eBPF\nDESCRIPTION: This code snippet demonstrates how to use the bpf_ringbuf_query helper function to query different characteristics of a ring buffer. It retrieves the amount of available data, ring buffer size, consumer position, and producer position.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_ringbuf_query.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nlong avail_data = 0;\nlong ring_size = 0;\nlong cons_pos = 0;\nlong prod_pos = 0;\n\navail_data = bpf_ringbuf_query(&my_ringbuf, BPF_RB_AVAIL_DATA);\nring_size = bpf_ringbuf_query(&my_ringbuf, BPF_RB_RING_SIZE);\ncons_pos = bpf_ringbuf_query(&my_ringbuf, BPF_RB_CONS_POS);\nprod_pos = bpf_ringbuf_query(&my_ringbuf, BPF_RB_PROD_POS);\n```\n\n----------------------------------------\n\nTITLE: Configuring XDP Program Metadata in C\nDESCRIPTION: Demonstrates how to configure metadata for XDP programs including priority and chain call actions using BTF format. The configuration allows setting program priority and defining which actions enable chain calling to subsequent programs.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libxdp/libxdp.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n#include <bpf/bpf_helpers.h>\n#include <xdp/xdp_helpers.h>\n\nstruct {\n\t__uint(priority, 10);  // priority\n\t__uint(XDP_PASS, 1);   // chain call action\n\t__uint(XDP_DROP, 1);   // chain call action\n} XDP_RUN_CONFIG(my_xdp_func);\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_skb_load_bytes_relative Helper Function in C\nDESCRIPTION: This snippet defines the 'bpf_skb_load_bytes_relative' helper function for eBPF programs. It loads bytes from a packet buffer (skb) at a specified offset relative to a chosen start header.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_skb_load_bytes_relative.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstatic long (* const bpf_skb_load_bytes_relative)(const void *skb, __u32 offset, void *to, __u32 len, __u32 start_header) = (void *) 68;\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_perf_event_read_value Helper Function in C\nDESCRIPTION: This code snippet defines the bpf_perf_event_read_value helper function, which reads the value of a perf event counter and stores it in a buffer. It returns 0 on success or a negative error code on failure.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_perf_event_read_value.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstatic long (* const bpf_perf_event_read_value)(void *map, __u64 flags, struct bpf_perf_event_value *buf, __u32 buf_size) = (void *) 55;\n```\n\n----------------------------------------\n\nTITLE: Defining the bpf_linker__add_buf Libbpf Function in C\nDESCRIPTION: This C code snippet shows the function signature for `bpf_linker__add_buf` from the libbpf library. It takes a pointer to a `bpf_linker` object, a pointer to a buffer containing the ELF file data (`buf`), the size of the buffer (`buf_sz`), and optional linker file options (`opts`). It returns 0 on success or a negative error code on failure, setting `errno` accordingly.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_linker__add_buf.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nint bpf_linker__add_buf(struct bpf_linker *linker, void *buf, size_t buf_sz, const struct bpf_linker_file_opts *opts);\n```\n\n----------------------------------------\n\nTITLE: Implementing Queue Map Dump Function with BPF_STRUCT_OPS\nDESCRIPTION: Example implementation of a queue map dump function using BPF_STRUCT_OPS macro. The function iterates through a queue array and dumps the contents of each FIFO queue, demonstrating practical usage of the macro with various BPF helper functions.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/scx/BPF_STRUCT_OPS.md#2025-04-22_snippet_1\n\nLANGUAGE: c\nCODE:\n```\nvoid BPF_STRUCT_OPS(qmap_dump, struct scx_dump_ctx *dctx)\n{\n\ts32 i, pid;\n\n\tif (suppress_dump)\n\t\treturn;\n\n\tbpf_for(i, 0, 5) {\n\t\tvoid *fifo;\n\n\t\tif (!(fifo = bpf_map_lookup_elem(&queue_arr, &i)))\n\t\t\treturn;\n\n\t\tscx_bpf_dump(\"QMAP FIFO[%d]:\", i);\n\t\tbpf_repeat(4096) {\n\t\t\tif (bpf_map_pop_elem(fifo, &pid))\n\t\t\t\tbreak;\n\t\t\tscx_bpf_dump(\" %d\", pid);\n\t\t}\n\t\tscx_bpf_dump(\"\\n\");\n\t}\n}\n```\n\n----------------------------------------\n\nTITLE: Updating DCTCP Alpha in BPF\nDESCRIPTION: This function updates the DCTCP alpha value based on the number of ECN-marked packets received. It's called when an ACK is received and adjusts the congestion response accordingly.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/program-type/BPF_PROG_TYPE_STRUCT_OPS/tcp_congestion_ops.md#2025-04-22_snippet_17\n\nLANGUAGE: C\nCODE:\n```\nSEC(\"struct_ops\")\nvoid BPF_PROG(bpf_dctcp_update_alpha, struct sock *sk, __u32 flags)\n{\n\tconst struct tcp_sock *tp = tcp_sk(sk);\n\tstruct bpf_dctcp *ca = inet_csk_ca(sk);\n\n\t/* Expired RTT */\n\tif (!before(tp->snd_una, ca->next_seq)) {\n\t\t__u32 delivered_ce = tp->delivered_ce - ca->old_delivered_ce;\n\t\t__u32 alpha = ca->dctcp_alpha;\n\n\t\t/* alpha = (1 - g) * alpha + g * F */\n\n\t\talpha -= min_not_zero(alpha, alpha >> dctcp_shift_g);\n\t\tif (delivered_ce) {\n\t\t\t__u32 delivered = tp->delivered - ca->old_delivered;\n\n\t\t\t/* If dctcp_shift_g == 1, a 32bit value would overflow\n\t\t\t * after 8 M packets.\n\t\t\t */\n\t\t\tdelivered_ce <<= (10 - dctcp_shift_g);\n\t\t\tdelivered_ce /= max(1U, delivered);\n\n\t\t\talpha = min(alpha + delivered_ce, DCTCP_MAX_ALPHA);\n\t\t}\n\t\tca->dctcp_alpha = alpha;\n\t\tdctcp_reset(tp, ca);\n\t}\n}\n```\n\n----------------------------------------\n\nTITLE: Definition of bpf_send_signal_task KFunc in C\nDESCRIPTION: Function signature of the bpf_send_signal_task kfunc that can send signals to threads and processes with optional cookies.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/bpf_send_signal_task.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nint bpf_send_signal_task(struct task_struct *task, int sig, pid_type type, u64 value)\n```\n\n----------------------------------------\n\nTITLE: Acquiring/Releasing task_struct in eBPF Tracepoint (C)\nDESCRIPTION: This C code snippet demonstrates a simple eBPF program attached to the 'task_newtask' raw tracepoint (using BTF). It shows how to acquire a reference to a 'struct task_struct' using 'bpf_task_acquire' and subsequently release it using 'bpf_task_release'. This is typically done when storing task pointers in maps for later use, although this example releases it immediately.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/program-type/BPF_PROG_TYPE_TRACING.md#2025-04-22_snippet_1\n\nLANGUAGE: c\nCODE:\n```\n/**\n* A trivial example tracepoint program that shows how to\n* acquire and release a struct task_struct * pointer.\n*/\nSEC(\"tp_btf/task_newtask\")\nint BPF_PROG(task_acquire_release_example, struct task_struct *task, u64 clone_flags)\n{\n    struct task_struct *acquired;\n\n    acquired = bpf_task_acquire(task);\n    if (acquired)\n        /*\n            * In a typical program you'd do something like store\n            * the task in a map, and the map will automatically\n            * release it later. Here, we release it manually.\n            */\n        bpf_task_release(acquired);\n    return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Triggering TX Buffer Packet Sending with XDP_USE_NEED_WAKEUP in C\nDESCRIPTION: This code snippet shows how to trigger the sending of packets queued in the TX buffer when the XDP_USE_NEED_WAKEUP flag is set. It uses the sendto syscall with specific parameters to signal the kernel to process the TX ring.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/concepts/af_xdp.md#2025-04-22_snippet_10\n\nLANGUAGE: c\nCODE:\n```\nsendto(fd, NULL, 0, MSG_DONTWAIT, NULL, 0);\n```\n\n----------------------------------------\n\nTITLE: Hash Function Implementation in eBPF\nDESCRIPTION: Implementation of Jenkins hash function adapted for eBPF, including helper functions for 32-bit word rotation and mixing operations. Used for load balancing packet distribution.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/bpf_dynptr_from_skb.md#2025-04-22_snippet_1\n\nLANGUAGE: c\nCODE:\n```\nstatic __always_inline __u32 rol32(__u32 word, unsigned int shift)\n{\n    return (word << shift) | (word >> ((-shift) & 31));\n}\n\n#define __jhash_mix(a, b, c) \\\n{\\\n    a -= c;  a ^= rol32(c, 4);  c += b;\\\n    b -= a;  b ^= rol32(a, 6);  a += c;\\\n    c -= b;  c ^= rol32(b, 8);  b += a;\\\n    a -= c;  a ^= rol32(c, 16); c += b;\\\n    b -= a;  b ^= rol32(a, 19); a += c;\\\n    c -= b;  c ^= rol32(b, 4);  b += a;\\\n}\n```\n\n----------------------------------------\n\nTITLE: Defining the bpf_task_acquire KFunc in C\nDESCRIPTION: Function signature for the bpf_task_acquire kernel function that acquires a reference to a task. The function takes a task_struct pointer as input and returns a pointer to the referenced task_struct.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/bpf_task_acquire.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstruct task_struct *bpf_task_acquire(struct task_struct *p)\n```\n\n----------------------------------------\n\nTITLE: Defining the bpf_tcp_sock eBPF Helper Function in C\nDESCRIPTION: This code snippet statically defines the 'bpf_tcp_sock' helper function, which takes a pointer to a 'struct bpf_sock' and returns a pointer to a 'struct bpf_tcp_sock' on success or NULL on failure. There are no external dependencies beyond kernel support for eBPF helper calls. The input parameter 'sk' is a pointer to a socket structure, and the function is cast to a constant pointer at a specific helper ID address (96). The output is either a valid TCP socket structure or NULL if the conversion isn't possible.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_tcp_sock.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstatic struct bpf_tcp_sock *(* const bpf_tcp_sock)(struct bpf_sock *sk) = (void *) 96;\n```\n\n----------------------------------------\n\nTITLE: Modern kprobe attachment using perf_event_open\nDESCRIPTION: Using perf_event_open syscall with different attribute configuration for the modern approach to kprobe attachment. This creates a PMU event for a kernel symbol.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/program-type/BPF_PROG_TYPE_KPROBE.md#2025-04-22_snippet_3\n\nLANGUAGE: c\nCODE:\n```\nstruct perf_event_attr attr = {\n    .type = 8; /* read type from /sys/bus/event_source/devices/kprobe/type or uprobe/type */\n    .sample_type = PERF_SAMPLE_RAW;\n    .sample_period = 1;\n    .wakeup_events = 1;\n    .size = sizeof(attr);\n    .config |= 1 << 0;\n    .kprobe_func = ((uint64_t)\"symbol_name\");  /* symbol name in string, valid names can be found in /proc/kallsyms */\n    .config1 = ((uint64_t)\"symbol_name\"); \n    .config2 = 0x0;\n    .probe_offset = 0x0; /* offset must be a valid instruction, here it is just the start of the kernel symbol*/\n};\n\nsyscall(SYS_perf_event_open, \n    &attr,  /* struct perf_event_attr * */\n    -1,     /* pid_t pid */\n    0       /* int cpu */\n    -1,     /* int group_fd */\n    PERF_FLAG_FD_CLOEXEC /* unsigned long flags */\n);\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_cgroup_storage_key Structure in C\nDESCRIPTION: Defines the structure 'bpf_cgroup_storage_key' used as the key for the BPF_MAP_TYPE_PERCPU_CGROUP_STORAGE map. This structure contains the cgroup inode ID and the attach type, typically requiring a key_size of 12 bytes. Since Linux kernel v5.9, an 8-byte key_size is also permitted, representing only the cgroup_inode_id.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/map-type/BPF_MAP_TYPE_PERCPU_CGROUP_STORAGE.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstruct bpf_cgroup_storage_key {\n        __u64 cgroup_inode_id;\n        __u32 attach_type;\n};\n```\n\n----------------------------------------\n\nTITLE: Enumerating TCP ACK Event Flags with tcp_ca_ack_event_flags (C)\nDESCRIPTION: This enum defines bitmaskable flags for specially handling inbound ACK packets in TCP, signaling slow path processing, window update detection, or the presence of ECN-CE marks. Used mainly as arguments to specialized introspection or callback interfaces in modular congestion control code. Each value enables targeted conditional logic in per-ACK event handlers.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/program-type/BPF_PROG_TYPE_STRUCT_OPS/tcp_congestion_ops.md#2025-04-22_snippet_14\n\nLANGUAGE: c\nCODE:\n```\nenum tcp_ca_ack_event_flags {\n\tCA_ACK_SLOWPATH     = (1 << 0), // (1)!\n\tCA_ACK_WIN_UPDATE   = (1 << 1), // (1)!\n\tCA_ACK_ECE          = (1 << 2), // (1)!\n};\n```\n\n----------------------------------------\n\nTITLE: Defining the bpf_tcp_send_ack Helper Function Pointer in C\nDESCRIPTION: This C code defines a constant function pointer `bpf_tcp_send_ack` for use in eBPF programs. It points to the kernel implementation (ID 116) responsible for sending a TCP acknowledgment (ACK). The function takes a pointer `tp` to the kernel's `tcp_sock` structure and the sequence number to acknowledge (`rcv_nxt`) as input. It returns 0 on success or a negative error code on failure. This definition allows eBPF programs to call the helper function.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_tcp_send_ack.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstatic long (* const bpf_tcp_send_ack)(void *tp, __u32 rcv_nxt) = (void *) 116;\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_program__attach_raw_tracepoint_opts function in C\nDESCRIPTION: Function definition for attaching a BPF_PROG_TYPE_RAW_TRACEPOINT program with additional options. It takes the BPF program, tracepoint name, and options as parameters, returning a reference to the newly created BPF link or NULL on error.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_program__attach_raw_tracepoint_opts.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstruct bpf_link * bpf_program__attach_raw_tracepoint_opts(const struct bpf_program *prog, const char *tp_name, struct bpf_raw_tracepoint_opts *opts);\n```\n\n----------------------------------------\n\nTITLE: Using bpf_obj_new in cgroup initialization in C\nDESCRIPTION: Example of using bpf_obj_new to allocate a cgv_node object in kernel memory during cgroup initialization. The code demonstrates object allocation, initialization, error handling, and cleanup.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/scx/bpf_obj_new.md#2025-04-22_snippet_1\n\nLANGUAGE: c\nCODE:\n```\n/* SPDX-License-Identifier: GPL-2.0 */\n/* Copyright (c) 2022 Tejun Heo <tj@kernel.org> */\n\nint [BPF_STRUCT_OPS_SLEEPABLE](BPF_STRUCT_OPS_SLEEPABLE.md)(fcg_cgroup_init, struct cgroup *cgrp,\n\t\t\t     struct scx_cgroup_init_args *args)\n{\n\tstruct fcg_cgrp_ctx *cgc;\n\tstruct cgv_node *cgv_node;\n\tstruct cgv_node_stash empty_stash = {}, *stash;\n\tu64 cgid = cgrp->kn->id;\n\tint ret;\n\n\t/*\n\t * Technically incorrect as cgroup ID is full 64bit while dsq ID is\n\t * 63bit. Should not be a problem in practice and easy to spot in the\n\t * unlikely case that it breaks.\n\t */\n\tret = [scx_bpf_create_dsq](../../linux/kfuncs/scx_bpf_create_dsq.md)(cgid, -1);\n\tif (ret)\n\t\treturn ret;\n\n\tcgc = [bpf_cgrp_storage_get](../../linux/helper-function/bpf_cgrp_storage_get.md)(&cgrp_ctx, cgrp, 0,\n\t\t\t\t   BPF_LOCAL_STORAGE_GET_F_CREATE);\n\tif (!cgc) {\n\t\tret = -ENOMEM;\n\t\tgoto err_destroy_dsq;\n\t}\n\n\tcgc->weight = args->weight;\n\tcgc->hweight = FCG_HWEIGHT_ONE;\n\n\tret = [bpf_map_update_elem](../../linux/helper-function/bpf_map_update_elem.md)(&cgv_node_stash, &cgid, &empty_stash,\n\t\t\t\t  BPF_NOEXIST);\n\tif (ret) {\n\t\tif (ret != -ENOMEM)\n\t\t\t[scx_bpf_error](scx_bpf_error.md)(\"unexpected stash creation error (%d)\",\n\t\t\t\t      ret);\n\t\tgoto err_destroy_dsq;\n\t}\n\n\tstash = [bpf_map_lookup_elem](../../linux/helper-function/bpf_map_lookup_elem.md)(&cgv_node_stash, &cgid);\n\tif (!stash) {\n\t\t[scx_bpf_error](scx_bpf_error.md)(\"unexpected cgv_node stash lookup failure\");\n\t\tret = -ENOENT;\n\t\tgoto err_destroy_dsq;\n\t}\n\n\tcgv_node = bpf_obj_new(struct cgv_node);\n\tif (!cgv_node) {\n\t\tret = -ENOMEM;\n\t\tgoto err_del_cgv_node;\n\t}\n\n\tcgv_node->cgid = cgid;\n\tcgv_node->cvtime = cvtime_now;\n\n\tcgv_node = [bpf_kptr_xchg](../../linux/helper-function/bpf_kptr_xchg.md)(&stash->node, cgv_node);\n\tif (cgv_node) {\n\t\t[scx_bpf_error](scx_bpf_error.md)(\"unexpected !NULL cgv_node stash\");\n\t\tret = -EBUSY;\n\t\tgoto err_drop;\n\t}\n\n\treturn 0;\n\nerr_drop:\n\t[bpf_obj_drop](bpf_obj_drop.md)(cgv_node);\nerr_del_cgv_node:\n\t[bpf_map_delete_elem](../../linux/helper-function/bpf_map_delete_elem.md)(&cgv_node_stash, &cgid);\nerr_destroy_dsq:\n\t[scx_bpf_destroy_dsq](../../linux/kfuncs/scx_bpf_destroy_dsq.md)(cgid);\n\treturn ret;\n}\n```\n\n----------------------------------------\n\nTITLE: Definition of perf_buffer__poll Function in Libbpf (C)\nDESCRIPTION: The perf_buffer__poll function polls for available data on a perf buffer, waiting for a specified timeout if no data is immediately available. It returns the number of records consumed or a negative error value.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/perf_buffer__poll.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nint perf_buffer__poll(struct perf_buffer *pb, int timeout_ms);\n```\n\n----------------------------------------\n\nTITLE: Defining a Compatibility Macro for SCX Scheduler kfuncs in C\nDESCRIPTION: This macro provides compatibility between the renamed kfuncs scx_bpf_dispatch_from_dsq_set_vtime and scx_bpf_dsq_move_set_vtime. It uses bpf_ksym_exists to detect available functions at runtime and falls back gracefully if neither is available, ensuring compatibility across different kernel versions.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/scx/__COMPAT_scx_bpf_dsq_move_set_vtime.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n#define __COMPAT_scx_bpf_dsq_move_set_vtime(it__iter, vtime)\\n\\t([bpf_ksym_exists](../libbpf/ebpf/bpf_ksym_exists.md)(scx_bpf_dsq_move_set_vtime) ?\\n\\t [scx_bpf_dsq_move_set_vtime](../../linux/kfuncs/scx_bpf_dsq_move_set_vtime.md)((it__iter), (vtime)) :\\n\\t ([bpf_ksym_exists](../libbpf/ebpf/bpf_ksym_exists.md)(scx_bpf_dispatch_from_dsq_set_vtime___compat) ?\\n\\t  [scx_bpf_dispatch_from_dsq_set_vtime___compat](../../linux/kfuncs/scx_bpf_dispatch_from_dsq_set_vtime.md)((it__iter), (vtime)) :\\n\\t  (void)0))\n```\n\n----------------------------------------\n\nTITLE: Defining the bpf_rbtree_add_impl Kernel Function Signature in C\nDESCRIPTION: Defines the function signature for the bpf_rbtree_add_impl kernel function. This function adds a node to a red-black tree with a specified root and comparator. The meta and off parameters are rewritten by the verifier and don't need to be set by BPF programs.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/bpf_rbtree_add_impl.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nint bpf_rbtree_add_impl(struct bpf_rb_root *root, struct bpf_rb_node *node, bool (less)(struct bpf_rb_node * , const struct bpf_rb_node * ), void *meta__ign, u64 off)\n```\n\n----------------------------------------\n\nTITLE: Defining BPF_CORE_READ_BITFIELD macro for CO-RE bitfield extraction in C\nDESCRIPTION: This macro extracts a bitfield from a given structure in a CO-RE (Compile Once - Run Everywhere) relocatable way. It handles different byte sizes and applies appropriate shifts based on the field's characteristics.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/ebpf/BPF_CORE_READ_BITFIELD.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n#define BPF_CORE_READ_BITFIELD(s, field) ({\n\tconst void *p = (const void *)s + __CORE_RELO(s, field, BYTE_OFFSET); \n\tunsigned long long val;\n\n\t/* This is a so-called barrier_var() operation that makes specified   \n\t * variable \"a black box\" for optimizing compiler.\t\t      \n\t * It forces compiler to perform BYTE_OFFSET relocation on p and use  \n\t * its calculated value in the switch below, instead of applying      \n\t * the same relocation 4 times for each individual memory load.       \n\t */\t\t\t\t\t\t\t\t      \n\tasm volatile(\"\" : \"=r\"(p) : \"0\"(p));\n\n\tswitch (__CORE_RELO(s, field, BYTE_SIZE)) {\t\t\t      \n\tcase 1: val = *(const unsigned char *)p; break;\t\t\t      \n\tcase 2: val = *(const unsigned short *)p; break;\t\t      \n\tcase 4: val = *(const unsigned int *)p; break;\t\t\t      \n\tcase 8: val = *(const unsigned long long *)p; break;\t\t      \n\tdefault: val = 0; break;\t\t\t\t\t      \n\t}\t\t\t\t\t\t\t\t      \n\tval <<= __CORE_RELO(s, field, LSHIFT_U64);\t\t\t      \n\tif (__CORE_RELO(s, field, SIGNED))\t\t\t\t      \n\t\tval = ((long long)val) >> __CORE_RELO(s, field, RSHIFT_U64);  \n\telse\t\t\t\t\t\t\t\t      \n\t\tval = val >> __CORE_RELO(s, field, RSHIFT_U64);\t\t      \n\tval;\t\t\t\t\t\t\t\t      \n})\n```\n\n----------------------------------------\n\nTITLE: Netfilter Attachment Structure in C\nDESCRIPTION: Defines the attributes used to attach netfilter programs using the link API, specifying protocol family, hook number, priority, and flags for the attachment process.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/program-type/BPF_PROG_TYPE_NETFILTER.md#2025-04-22_snippet_2\n\nLANGUAGE: c\nCODE:\n```\nstruct {\n    __u32\t\tpf;\n    __u32\t\thooknum;\n    __s32\t\tpriority;\n    __u32\t\tflags;\n} netfilter;\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_program__attach function in C\nDESCRIPTION: Function signature for bpf_program__attach, which attaches a BPF program and returns a bpf_link struct pointer. It takes a const struct bpf_program pointer as input and returns NULL on error, with the error code stored in errno.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_program__attach.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstruct bpf_link * bpf_program__attach(const struct bpf_program *prog);\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_prog_bind_map function in C\nDESCRIPTION: This snippet defines the bpf_prog_bind_map function, which is a low-level wrapper for the BPF_PROG_BIND_MAP syscall command. It takes program and map file descriptors, along with options for configuring the binding.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_prog_bind_map.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nint bpf_prog_bind_map(int prog_fd, int map_fd, const struct bpf_prog_bind_opts *opts);\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_l4_csum_replace Helper Function in C\nDESCRIPTION: This code snippet defines the bpf_l4_csum_replace helper function for eBPF programs. It recomputes the layer 4 checksum for a packet, allowing incremental updates to header fields.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_l4_csum_replace.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstatic long (* const bpf_l4_csum_replace)(struct __sk_buff *skb, __u32 offset, __u64 from, __u64 to, __u64 flags) = (void *) 11;\n```\n\n----------------------------------------\n\nTITLE: Defining Perf Buffer Raw Options Structure in C\nDESCRIPTION: Structure definition for perf_buffer_raw_opts which provides configuration options for raw perf buffer creation, including CPU count, CPU array specification, and map key settings.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/perf_buffer__new_raw.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstruct perf_buffer_raw_opts {\n\tsize_t sz;\n\tlong :0;\n\tlong :0;\n\t/* if cpu_cnt == 0, open all on all possible CPUs (up to the number of\n\t * max_entries of given PERF_EVENT_ARRAY map)\n\t */\n\tint cpu_cnt;\n\t/* if cpu_cnt > 0, cpus is an array of CPUs to open ring buffers on */\n\tint *cpus;\n\t/* if cpu_cnt > 0, map_keys specify map keys to set per-CPU FDs for */\n\tint *map_keys;\n};\n```\n\n----------------------------------------\n\nTITLE: Querying BPF Map Interface Index using libbpf in C\nDESCRIPTION: This code snippet shows the C function declaration for bpf_map__ifindex, a helper from libbpf that allows retrieval of the interface index associated with a BPF map. Dependencies include the libbpf library and the definition of struct bpf_map and __u32 types. The function takes a pointer to a bpf_map and returns a 32-bit unsigned integer representing the interface index, or 0 if no index is available. This is used primarily when working with XDP program and BPF map hardware offloads.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_map__ifindex.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n#!c __u32 bpf_map__ifindex(const struct bpf_map *map);\n```\n\n----------------------------------------\n\nTITLE: Implementing Custom Round-Robin Packet Distribution in XDP\nDESCRIPTION: This XDP program demonstrates how to implement a simple round-robin packet distribution across multiple AF_XDP sockets sharing the same UMEM. It uses a BPF map to store socket references and a static counter for round-robin selection.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/concepts/af_xdp.md#2025-04-22_snippet_11\n\nLANGUAGE: c\nCODE:\n```\n#include <linux/bpf.h>\n#include \"bpf_helpers.h\"\n\n#define MAX_SOCKS 16\n\nstruct {\n    __uint(type, BPF_MAP_TYPE_XSKMAP);\n    __uint(max_entries, MAX_SOCKS);\n    __uint(key_size, sizeof(int));\n    __uint(value_size, sizeof(int));\n} xsks_map SEC(\".maps\");\n\nstatic unsigned int rr;\n\nSEC(\"xdp_sock\") int xdp_sock_prog(struct xdp_md *ctx)\n{\n    rr = (rr + 1) & (MAX_SOCKS - 1);\n\n    return bpf_redirect_map(&xsks_map, rr, XDP_DROP);\n}\n```\n\n----------------------------------------\n\nTITLE: Defining and Using bpf_xdp_get_xfrm_state KFunc in XDP Program\nDESCRIPTION: This code snippet demonstrates the usage of the bpf_xdp_get_xfrm_state kfunc in an XDP program. It retrieves the XFRM state for an ESP packet and accesses the replay window.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/bpf_xdp_get_xfrm_state.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nvolatile int xfrm_replay_window = 0;\n\nSEC(\"xdp\")\nint xfrm_get_state_xdp(struct xdp_md *xdp)\n{\n\tstruct bpf_xfrm_state_opts opts = {};\n\tstruct xfrm_state *x = NULL;\n\tstruct ip_esp_hdr *esph;\n\tstruct bpf_dynptr ptr;\n\tu8 esph_buf[8] = {};\n\tu8 iph_buf[20] = {};\n\tstruct iphdr *iph;\n\tu32 off;\n\n\tif (bpf_dynptr_from_xdp(xdp, 0, &ptr))\n\t\tgoto out;\n\n\toff = sizeof(struct ethhdr);\n\tiph = bpf_dynptr_slice(&ptr, off, iph_buf, sizeof(iph_buf));\n\tif (!iph || iph->protocol != IPPROTO_ESP)\n\t\tgoto out;\n\n\toff += sizeof(struct iphdr);\n\tesph = bpf_dynptr_slice(&ptr, off, esph_buf, sizeof(esph_buf));\n\tif (!esph)\n\t\tgoto out;\n\n\topts.netns_id = BPF_F_CURRENT_NETNS;\n\topts.daddr.a4 = iph->daddr;\n\topts.spi = esph->spi;\n\topts.proto = IPPROTO_ESP;\n\topts.family = AF_INET;\n\n\tx = bpf_xdp_get_xfrm_state(xdp, &opts, sizeof(opts));\n\tif (!x)\n\t\tgoto out;\n\n\tif (!x->replay_esn)\n\t\tgoto out;\n\n\txfrm_replay_window = x->replay_esn->replay_window;\nout:\n\tif (x)\n\t\tbpf_xdp_xfrm_state_release(x);\n\treturn XDP_PASS;\n}\n\nchar _license[] SEC(\"license\") = \"GPL\";\n```\n\n----------------------------------------\n\nTITLE: Definition of bpf_get_func_ip Helper Function in C\nDESCRIPTION: C function definition for the bpf_get_func_ip helper that returns the address of a traced function. Returns 0 for kprobes placed within functions and probe address for uprobes.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_get_func_ip.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstatic __u64 (* const bpf_get_func_ip)(void *ctx) = (void *) 173;\n```\n\n----------------------------------------\n\nTITLE: Attaching BPF Program to Tracepoint Using ioctl - C\nDESCRIPTION: Shows how to attach a loaded BPF program to a perf event representing a kernel tracepoint using the ioctl syscall in C. It invokes PERF_EVENT_IOC_SET_BPF to bind the eBPF program (given by its file descriptor) and PERF_EVENT_IOC_ENABLE to activate the trace event. This is the traditional, but less recommended, way to attach tracepoint programs. Inputs include perf event and BPF program file descriptors; the result is an active connection until the FDs are closed.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/program-type/BPF_PROG_TYPE_TRACEPOINT.md#2025-04-22_snippet_3\n\nLANGUAGE: c\nCODE:\n```\nioctl(perf_event_fd, PERF_EVENT_IOC_SET_BPF, bpf_prog_fd);\n```\n\nLANGUAGE: c\nCODE:\n```\nioctl(perf_event_fd, PERF_EVENT_IOC_ENABLE, 0);\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_skb_get_xfrm_state Helper Function in C\nDESCRIPTION: This code snippet defines the 'bpf_skb_get_xfrm_state' helper function for eBPF programs. It retrieves the XFRM state at a specified index in the XFRM security path for a given network packet (skb). The function stores the retrieved state in a provided bpf_xfrm_state structure.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_skb_get_xfrm_state.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstatic long (* const bpf_skb_get_xfrm_state)(struct __sk_buff *skb, __u32 index, struct bpf_xfrm_state *xfrm_state, __u32 size, __u64 flags) = (void *) 66;\n```\n\n----------------------------------------\n\nTITLE: TC Program Example Using bpf_crypto_decrypt in C\nDESCRIPTION: A complete example demonstrating how to use bpf_crypto_decrypt in a TC (Traffic Control) program. The example shows creating a crypto context map, looking up the context, and using the function to decrypt packet data.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/bpf_crypto_decrypt.md#2025-04-22_snippet_1\n\nLANGUAGE: c\nCODE:\n```\n/* SPDX-License-Identifier: GPL-2.0 */\n/* Copyright (c) 2024 Meta Platforms, Inc. and affiliates. */\n\n#include \"vmlinux.h\"\n#include \"bpf_tracing_net.h\"\n#include <bpf/bpf_helpers.h>\n#include <bpf/bpf_endian.h>\n#include <bpf/bpf_tracing.h>\n#include \"bpf_misc.h\"\n#include \"bpf_kfuncs.h\"\n#include \"errno.h\"\n#include <stdbool.h>\n\nint bpf_crypto_decrypt(struct bpf_crypto_ctx *ctx, const struct bpf_dynptr *src,\n            const struct bpf_dynptr *dst, const struct bpf_dynptr *iv) __ksym;\n\nstruct __crypto_ctx_value {\n    struct bpf_crypto_ctx __kptr * ctx;\n};\n\nstruct array_map {\n    __uint(type, BPF_MAP_TYPE_ARRAY);\n    __type(key, int);\n    __type(value, struct __crypto_ctx_value);\n    __uint(max_entries, 1);\n} __crypto_ctx_map SEC(\".maps\");\n\nstatic inline struct __crypto_ctx_value *crypto_ctx_value_lookup(void)\n{\n    u32 key = 0;\n\n    return bpf_map_lookup_elem(&__crypto_ctx_map, &key);\n}\n\nconst volatile unsigned int len = 16;\nchar dst[256] = {};\nlong hits = 0;\n\nSEC(\"tc\")\nint crypto_decrypt(struct __sk_buff *skb)\n{\n    struct bpf_dynptr psrc, pdst, iv;\n    struct __crypto_ctx_value *v;\n    struct bpf_crypto_ctx *ctx;\n\n    v = crypto_ctx_value_lookup();\n    if (!v)\n        return -ENOENT;\n\n    ctx = v->ctx;\n    if (!ctx)\n        return -ENOENT;\n\n    bpf_dynptr_from_skb(skb, 0, &psrc);\n    bpf_dynptr_from_mem(dst, len, 0, &pdst);\n    bpf_dynptr_from_mem(dst, 0, 0, &iv);\n\n    status = bpf_crypto_decrypt(ctx, &psrc, &pdst, &iv);\n    __sync_add_and_fetch(&hits, 1);\n\n    return 0;\n}\n\nchar __license[] SEC(\"license\") = \"GPL\";\n```\n\n----------------------------------------\n\nTITLE: XDP IP Tunneling Main Handler Function in eBPF\nDESCRIPTION: This function is the main entry point for XDP IP tunneling. It reads the Ethernet header, determines the protocol (IPv4 or IPv6), and calls the appropriate handler function. If the protocol is neither IPv4 nor IPv6, the packet is dropped.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/bpf_dynptr_from_xdp.md#2025-04-22_snippet_4\n\nLANGUAGE: C\nCODE:\n```\nSEC(\"xdp\")\nint _xdp_tx_iptunnel(struct xdp_md *xdp)\n{\n    __u8 buffer[ethhdr_sz];\n    struct bpf_dynptr ptr;\n    struct ethhdr *eth;\n    __u16 h_proto;\n\n    __builtin_memset(buffer, 0, sizeof(buffer));\n\n    bpf_dynptr_from_xdp(xdp, 0, &ptr);\n    eth = bpf_dynptr_slice(&ptr, 0, buffer, sizeof(buffer));\n    if (!eth)\n        return XDP_DROP;\n\n    h_proto = eth->h_proto;\n\n    if (h_proto == bpf_htons(ETH_P_IP))\n        return handle_ipv4(xdp, &ptr);\n    else if (h_proto == bpf_htons(ETH_P_IPV6))\n        return handle_ipv6(xdp, &ptr);\n    else\n        return XDP_DROP;\n}\n```\n\n----------------------------------------\n\nTITLE: Haptic Feedback Control System in C\nDESCRIPTION: Syscall program that configures haptic feedback settings for HID devices. Uses hid_bpf_allocate_context and hid_bpf_hw_request to communicate with the device.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/hid_bpf_allocate_context.md#2025-04-22_snippet_1\n\nLANGUAGE: c\nCODE:\n```\nSEC(\"syscall\")\nint set_haptic(struct haptic_syscall_args *args)\n{\n\tstruct hid_bpf_ctx *ctx;\n\tconst size_t size = sizeof(haptic_data);\n\tu16 *res;\n\tint ret;\n\n\tif (size > sizeof(haptic_data))\n\t\treturn -7; /* -E2BIG */\n\n\tctx = hid_bpf_allocate_context(args->hid);\n\tif (!ctx)\n\t\treturn -1; /* EPERM check */\n\n\thaptic_data[0] = 1;  /* report ID */\n\n\tret = hid_bpf_hw_request(ctx, haptic_data, size, HID_FEATURE_REPORT, HID_REQ_GET_REPORT);\n\n\tbpf_printk(\"probed/remove event ret value: %d\", ret);\n\tbpf_printk(\"buf: %02x %02x %02x\",\n\t\t   haptic_data[0],\n\t\t   haptic_data[1],\n\t\t   haptic_data[2]);\n\tbpf_printk(\"     %02x %02x %02x\",\n\t\t   haptic_data[3],\n\t\t   haptic_data[4],\n\t\t   haptic_data[5]);\n\tbpf_printk(\"     %02x %02x\",\n\t\t   haptic_data[6],\n\t\t   haptic_data[7]);\n\n\tres = (u16 *)&haptic_data[1];\n\tif (*res != 3600) {\n\t\thaptic_data[4] = 3;  /* haptic Auto Trigger */\n\t} else {\n\t\thaptic_data[4] = 0;\n\t}\n\n\tret = hid_bpf_hw_request(ctx, haptic_data, size, HID_FEATURE_REPORT, HID_REQ_SET_REPORT);\n\n\tbpf_printk(\"set haptic ret value: %d -> %d\", ret, haptic_data[4]);\n\n\targs->retval = ret;\n\n\thid_bpf_release_context(ctx);\n\n\treturn 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining eBPF Helper 'bpf_tcp_raw_check_syncookie_ipv4' Function Pointer in C\nDESCRIPTION: This C code snippet defines a constant function pointer `bpf_tcp_raw_check_syncookie_ipv4`. It represents the eBPF helper function used to validate IPv4 SYN cookie ACKs. The function takes pointers to `struct iphdr` (IPv4 header) and `struct tcphdr` (TCP header) as input and returns 0 on success or -EACCES if the cookie is invalid. It's assigned the internal kernel helper function ID 206. This definition allows eBPF programs compiled with libbpf or similar tools to call the kernel helper.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_tcp_raw_check_syncookie_ipv4.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n`#!c static long (* const bpf_tcp_raw_check_syncookie_ipv4)(struct iphdr *iph, struct tcphdr *th) = (void *) 206;`\n```\n\n----------------------------------------\n\nTITLE: Setting FOU Encapsulation Parameters with bpf_skb_set_fou_encap in TC Program\nDESCRIPTION: This example demonstrates how to use the bpf_skb_set_fou_encap kfunc in a TC (Traffic Control) program. The code first sets up tunnel parameters with bpf_skb_set_tunnel_key and then configures FOU encapsulation with specific UDP port parameters. The example shows proper error handling for both operations.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/bpf_skb_set_fou_encap.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n// SPDX-License-Identifier: GPL-2.0\n/* Copyright (c) 2016 VMware\n * Copyright (c) 2016 Facebook\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of version 2 of the GNU General Public\n * License as published by the Free Software Foundation.\n */\n\nSEC(\"tc\")\nint ipip_fou_set_tunnel(struct __sk_buff *skb)\n{\n\tstruct bpf_tunnel_key key = {};\n\tstruct bpf_fou_encap encap = {};\n\tvoid *data = (void *)(long)skb->data;\n\tstruct iphdr *iph = data;\n\tvoid *data_end = (void *)(long)skb->data_end;\n\tint ret;\n\n\tif (data + sizeof(*iph) > data_end) {\n\t\tlog_err(1);\n\t\treturn TC_ACT_SHOT;\n\t}\n\n\tkey.tunnel_ttl = 64;\n\tif (iph->protocol == IPPROTO_ICMP)\n\t\tkey.remote_ipv4 = 0xac100164; /* 172.16.1.100 */\n\n\tret = bpf_skb_set_tunnel_key(skb, &key, sizeof(key), 0);\n\tif (ret < 0) {\n\t\tlog_err(ret);\n\t\treturn TC_ACT_SHOT;\n\t}\n\n\tencap.sport = 0;\n\tencap.dport = bpf_htons(5555);\n\n\tret = bpf_skb_set_fou_encap(skb, &encap, FOU_BPF_ENCAP_FOU);\n\tif (ret < 0) {\n\t\tlog_err(ret);\n\t\treturn TC_ACT_SHOT;\n\t}\n\n\treturn TC_ACT_OK;\n}\n```\n\n----------------------------------------\n\nTITLE: DCTCP Congestion Control Operations Structure\nDESCRIPTION: This structure defines the operations for the DCTCP congestion control algorithm. It includes function pointers to various DCTCP-specific operations implemented in BPF.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/program-type/BPF_PROG_TYPE_STRUCT_OPS/tcp_congestion_ops.md#2025-04-22_snippet_22\n\nLANGUAGE: C\nCODE:\n```\nSEC(\".struct_ops\")\nstruct tcp_congestion_ops dctcp = {\n\t.init\t\t= (void *)bpf_dctcp_init,\n\t.in_ack_event   = (void *)bpf_dctcp_update_alpha,\n\t.cwnd_event\t= (void *)bpf_dctcp_cwnd_event,\n\t.ssthresh\t= (void *)bpf_dctcp_ssthresh,\n\t.cong_avoid\t= (void *)bpf_dctcp_cong_avoid,\n\t.undo_cwnd\t= (void *)bpf_dctcp_cwnd_undo,\n\t.set_state\t= (void *)bpf_dctcp_state,\n\t.flags\t\t= TCP_CONG_NEEDS_ECN,\n\t.name\t\t= \"bpf_dctcp\",\n};\n```\n\n----------------------------------------\n\nTITLE: Defining scx_bpf_nr_cpu_ids KFunc in C\nDESCRIPTION: This code snippet defines the signature of the 'scx_bpf_nr_cpu_ids' kfunc. It returns a 32-bit unsigned integer representing the number of possible CPU IDs in the system. All valid CPU IDs are guaranteed to be smaller than this returned value.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/scx_bpf_nr_cpu_ids.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nu32 scx_bpf_nr_cpu_ids()\n```\n\n----------------------------------------\n\nTITLE: Creating a kprobe session with BPF_TRACE_KPROBE_SESSION\nDESCRIPTION: Using BPF_LINK_CREATE with BPF_TRACE_KPROBE_SESSION to attach a BPF program to both function entry and return probes in a single session, which simplifies code structure and improves performance.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/program-type/BPF_PROG_TYPE_KPROBE.md#2025-04-22_snippet_6\n\nLANGUAGE: c\nCODE:\n```\nunion bpf_attr attr = {\n    .link_create.prog_fd = prog_fd;\n    .link_create.attach_type = BPF_TRACE_KPROBE_SESSION;\n};\n\nsyscall(SYS_bpf,\n    BPF_LINK_CREATE,\n    &attr,\n    sizeof(attr)\n);\n```\n\n----------------------------------------\n\nTITLE: Defining and Using bpf_map__lookup_elem Libbpf Function in C\nDESCRIPTION: The 'bpf_map__lookup_elem' function is defined in the libbpf library and allows users to look up values in a BPF map using a specified key. It requires the BPF map, the key and its size, a memory pointer for the value, the value's size, and flags. The function checks key and value sizes and returns 0 on success or a negative error otherwise.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_map__lookup_elem.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nint bpf_map__lookup_elem(const struct bpf_map *map, const void *key, size_t key_sz, void *value, size_t value_sz, __u64 flags);\n```\n\n----------------------------------------\n\nTITLE: Using '__hidden' macro with spinlock in eBPF C program\nDESCRIPTION: This example demonstrates the use of the '__hidden' macro to hide a spinlock from userspace in an eBPF program. It's applied to a global variable to make it eBPF-only, though this specific usage is not recommended in practice.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/ebpf/__hidden.md#2025-04-22_snippet_1\n\nLANGUAGE: c\nCODE:\n```\nstruct bpf_spin_lock lockA __hidden SEC(\".data.A\");\nint counter = 0;\n\nSEC(\"xdp\")\nint example_prog(struct xdp_md *ctx)\n{\n    bpf_spin_lock(&lockA);\n    counter++;\n    bpf_spin_unlock(&lockA);\n\treturn XDP_PASS;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_map_lookup_percpu_elem Helper Function in C\nDESCRIPTION: This code snippet defines the 'bpf_map_lookup_percpu_elem' helper function for eBPF programs. It performs a lookup in a per-CPU map for an entry associated with a key on a specific CPU. The function returns the map value or NULL if no entry is found or the CPU is invalid.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_map_lookup_percpu_elem.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstatic void *(* const bpf_map_lookup_percpu_elem)(void *map, const void *key, __u32 cpu) = (void *) 195;\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_probe_read_str Helper Function in C\nDESCRIPTION: Function definition for bpf_probe_read_str helper that copies a NULL-terminated string from an unsafe kernel address to a destination buffer. Returns positive length of string on success or negative value on error.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_probe_read_str.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstatic long (* const bpf_probe_read_str)(void *dst, __u32 size, const void *unsafe_ptr) = (void *) 45;\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_get_route_realm Helper Function in C\nDESCRIPTION: This code snippet defines the bpf_get_route_realm helper function, which retrieves the realm or route of a packet. It returns the tclassid field of the destination for the given skb (socket buffer).\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_get_route_realm.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstatic __u32 (* const bpf_get_route_realm)(struct __sk_buff *skb) = (void *) 24;\n```\n\n----------------------------------------\n\nTITLE: Defining the bpf_get_dentry_xattr Kernel Function in C\nDESCRIPTION: Function signature for bpf_get_dentry_xattr which retrieves extended attributes from a directory entry. The function takes a dentry pointer, the name of the attribute to retrieve, and a pointer to store the output value. This function may sleep and therefore can only be used from sleepable programs.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/bpf_get_dentry_xattr.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nint bpf_get_dentry_xattr(struct dentry *dentry, const char *name__str, struct bpf_dynptr *value_p)\n```\n\n----------------------------------------\n\nTITLE: Defining the 'bpf_map__update_elem' Function Signature in C\nDESCRIPTION: This C code snippet presents the function prototype for `bpf_map__update_elem` provided by the libbpf library. This function allows userspace applications to insert a new element or update an existing element in a specified BPF map. It takes the map object, pointers to the key and value data, their respective sizes, and optional flags as arguments. The function returns 0 upon successful update or insertion, and a negative error code otherwise. Special handling is required for calculating `value_sz` for per-CPU maps.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_map__update_elem.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n#!c int bpf_map__update_elem(const struct bpf_map *map, const void *key, size_t key_sz, const void *value, size_t value_sz, __u64 flags);\n```\n\n----------------------------------------\n\nTITLE: Using BPF_PROBE_READ_INTO Macro in eBPF Programs - C\nDESCRIPTION: Demonstrates a typical usage of the 'BPF_PROBE_READ_INTO' macro to assign results directly into the provided storage. Here, 's' is the destination, and 'a.b.c', 'd.e', 'f', 'g' are the source and subsequent fields to access. This illustrates the convenience of the macro for multiple pointer dereferences. The values assigned depend on properly declared variables/structures in scope.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/ebpf/BPF_PROBE_READ_INTO.md#2025-04-22_snippet_1\n\nLANGUAGE: c\nCODE:\n```\nint x = BPF_PROBE_READ_INTO(s, a.b.c, d.e, f, g);\n```\n\n----------------------------------------\n\nTITLE: New eBPF kfuncs in Linux 5.13-5.18\nDESCRIPTION: New kernel functions (kfuncs) made available for use in eBPF programs, including TCP congestion control algorithms and connection tracking operations.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/timeline/index.md#2025-04-22_snippet_7\n\nLANGUAGE: C\nCODE:\n```\nbbr_init\nbbr_main\nbbr_sndbuf_expand\nbbr_undo_cwnd\nbbr_cwnd_event\nbbr_ssthresh\nbbr_min_tso_segs\nbbr_set_state\ncubictcp_init\ncubictcp_recalc_ssthresh\ncubictcp_cong_avoid\ncubictcp_state\ncubictcp_cwnd_event\ncubictcp_acked\ndctcp_init\ndctcp_update_alpha\ndctcp_cwnd_event\ndctcp_ssthresh\ndctcp_cwnd_undo\ndctcp_state\ntcp_reno_ssthresh\ntcp_reno_cong_avoid\ntcp_reno_undo_cwnd\ntcp_slow_start\ntcp_cong_avoid_ai\nbpf_xdp_ct_lookup\nbpf_skb_ct_lookup\nbpf_ct_release\n```\n\n----------------------------------------\n\nTITLE: Function Definition for user_ring_buffer__submit in C\nDESCRIPTION: Core function definition for submitting a previously reserved sample into the user ring buffer. Takes a ring buffer pointer and sample pointer as parameters. This function is thread-safe for multiple producers.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/user_ring_buffer__submit.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nvoid user_ring_buffer__submit(struct user_ring_buffer *rb, void *sample);\n```\n\n----------------------------------------\n\nTITLE: Using BPF_FOR_EACH_ITER in a bpf_for_each loop in C\nDESCRIPTION: This example demonstrates how to use the BPF_FOR_EACH_ITER macro within a bpf_for_each loop. It iterates over all tasks in a shared DSQ and moves them to a BPF scheduler-defined DSQ using scx_bpf_dsq_move_vtime.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/scx/BPF_FOR_EACH_ITER.md#2025-04-22_snippet_1\n\nLANGUAGE: c\nCODE:\n```\nstruct task_struct *p;\nbpf_for_each(scx_dsq, p, SHARED_DSQ, 0) {\n    scx_bpf_dsq_move_vtime(BPF_FOR_EACH_ITER, p, SOME_DSQ, 0);\n}\n```\n\n----------------------------------------\n\nTITLE: Defining BPF Link Type String Conversion Function in C\nDESCRIPTION: Function definition for libbpf_bpf_link_type_str that takes a bpf_link_type enum parameter and returns a const char pointer to the string representation. Returns NULL for unknown link types.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/libbpf_bpf_link_type_str.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nconst char *libbpf_bpf_link_type_str(enum bpf_link_type t);\n```\n\n----------------------------------------\n\nTITLE: Defining BPF_CORE_READ_USER Macro in C\nDESCRIPTION: The C macro definition of BPF_CORE_READ_USER which enables reading from userspace memory through the bpf_probe_read_user helper function. This macro creates a temporary variable to store the read result and returns it after reading from userspace memory.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/ebpf/BPF_CORE_READ_USER.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n#define BPF_CORE_READ_USER(src, a, ...) ({\\n\\t___type((src), a, ##__VA_ARGS__) __r;\\n\\tBPF_CORE_READ_USER_INTO(&__r, (src), a, ##__VA_ARGS__);\\n\\t__r;\\n})\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_msg_redirect_map Helper Function in C\nDESCRIPTION: Function definition for the bpf_msg_redirect_map helper that redirects messages to sockets referenced in a map. Returns SK_PASS on success or SK_DROP on error. Takes parameters for message metadata, map reference, key, and flags.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_msg_redirect_map.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstatic long (* const bpf_msg_redirect_map)(struct sk_msg_md *msg, void *map, __u32 key, __u64 flags) = (void *) 60;\n```\n\n----------------------------------------\n\nTITLE: Defining the 'bpf_core_field_size' eBPF Macro in C\nDESCRIPTION: This C code snippet defines the 'bpf_core_field_size' macro using the '__builtin_preserve_field_info' built-in function. It is used within eBPF programs compiled with libbpf to query the size (in bytes) of a specified structure field on the target kernel.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/ebpf/bpf_core_field_size.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n#define bpf_core_field_size(field...) \\\n\t__builtin_preserve_field_info(___bpf_field_ref(field), BPF_FIELD_BYTE_SIZE)\n```\n\n----------------------------------------\n\nTITLE: Definition of btf__type_by_id function in C\nDESCRIPTION: Function prototype for btf__type_by_id which takes a pointer to a BTF object and a type ID, returning a pointer to the corresponding struct btf_type or NULL on failure.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/btf__type_by_id.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nconst struct btf_type *btf__type_by_id(const struct btf *btf, __u32 id);\n```\n\n----------------------------------------\n\nTITLE: Attaching eBPF Programs via TC CLI Tool - Bash\nDESCRIPTION: This snippet demonstrates how to attach eBPF programs to Traffic Control (TC) using the tc command-line interface. It requires iproute2 utilities and a compiled eBPF ELF file. The example shows adding a clsact qdisc to an interface and attaching a specific program section to it. The input needed is the network device name and the ELF file with the compiled eBPF program. It modifies the network device's queuing discipline by binding an eBPF program section, allowing for Traffic Control actions.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/program-type/BPF_PROG_TYPE_SCHED_ACT.md#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n# Add a qdisc of type `clsact` to device `eth1`\n$ tc qdisc add dev eth1 clsact\n# Load the `program.o` ELF file, and attach the `my_func` section to the qdisc of eth1 on the egress side.\n$ tc filter add dev eth1 egress matchall action bpf object-file program.o sec my_func\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_get_prandom_u32 Helper Function in C\nDESCRIPTION: This code snippet defines the 'bpf_get_prandom_u32' helper function in C. It returns a random 32-bit unsigned value and is not cryptographically secure.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_get_prandom_u32.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstatic __u32 (* const bpf_get_prandom_u32)(void) = (void *) 7;\n```\n\n----------------------------------------\n\nTITLE: Using bpf_ktime_get_boot_ns to Measure Time in eBPF Programs\nDESCRIPTION: This example demonstrates how to use the 'bpf_ktime_get_boot_ns' function to measure the duration of a task in an eBPF program. It captures start and end times, then calculates the duration.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_ktime_get_boot_ns.md#2025-04-22_snippet_1\n\nLANGUAGE: c\nCODE:\n```\n__u64 start_time = bpf_ktime_get_boot_ns();\n/* some tasks */\n__u64 end_time = bpf_ktime_get_boot_ns();\n__u64 duration = end_time - start_time;\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_skb_ecn_set_ce Helper Function in C\nDESCRIPTION: This snippet defines the 'bpf_skb_ecn_set_ce' helper function, which sets the ECN field of IP header to CE if current value is ECT. It works with both IPv6 and IPv4. The function returns 1 if the CE flag is set, 0 otherwise.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_skb_ecn_set_ce.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstatic long (* const bpf_skb_ecn_set_ce)(struct __sk_buff *skb) = (void *) 97;\n```\n\n----------------------------------------\n\nTITLE: Defining the bpf_timer_start Helper Function Pointer (C)\nDESCRIPTION: This code defines the function pointer for the `bpf_timer_start` eBPF helper. It takes a pointer to a `bpf_timer` struct, the expiration time in nanoseconds (`nsecs`), and flags (`flags`) as input. The function sets the timer to expire `nsecs` nanoseconds from the current time (or at an absolute time if `BPF_F_TIMER_ABS` flag is used) and schedules its callback. It returns 0 on success and -EINVAL if the timer wasn't initialized with `bpf_timer_init` or if invalid flags are provided. The flags `BPF_F_TIMER_ABS` and `BPF_F_TIMER_CPU_PIN` control the timer's behavior.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_timer_start.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n`#!c static long (* const bpf_timer_start)(struct bpf_timer *timer, __u64 nsecs, __u64 flags) = (void *) 171;`\n```\n\n----------------------------------------\n\nTITLE: Querying Map Key Size with libbpf in C\nDESCRIPTION: Declares the 'bpf_map__key_size' function from the libbpf library in C, which returns the key size for a given BPF map. The function takes a pointer to a struct bpf_map and returns the size as an unsigned 32-bit integer. This interface requires libbpf to be linked and included, with the input parameter expected to be an initialized pointer to an existing BPF map instance; it outputs a __u32 key size or possibly an error if the map pointer is invalid. No code example is supplied for usage.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_map__key_size.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n#!c __u32 bpf_map__key_size(const struct bpf_map *map);\n```\n\n----------------------------------------\n\nTITLE: Using BPF_CORE_READ macro in C\nDESCRIPTION: This example demonstrates the usage of the BPF_CORE_READ macro to read nested struct fields into a variable. It showcases the typical syntax for accessing multiple levels of struct members.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/ebpf/BPF_CORE_READ_INTO.md#2025-04-22_snippet_1\n\nLANGUAGE: c\nCODE:\n```\nint x = BPF_CORE_READ(s, a.b.c, d.e, f, g);\n```\n\n----------------------------------------\n\nTITLE: Declaring the 'name' Field in 'sched_ext_ops' Struct (C)\nDESCRIPTION: Declares the 'name' field within the 'sched_ext_ops' struct as a character array of size SCX_OPS_NAME_LEN (128). This field stores the BPF scheduler's name for observability purposes via the `kernel.sched_ext_ops` sysctl. The name must be a valid BPF object name containing only alphanumeric characters, underscores (_), or periods (.).\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/program-type/BPF_PROG_TYPE_STRUCT_OPS/sched_ext_ops.md#2025-04-22_snippet_1\n\nLANGUAGE: c\nCODE:\n```\nname[SCX_OPS_NAME_LEN]\n```\n\n----------------------------------------\n\nTITLE: Defining scx_bpf_get_idle_cpumask KFunc\nDESCRIPTION: C function signature for the scx_bpf_get_idle_cpumask kernel function. This function returns a pointer to the idle-tracking per-CPU cpumask, with NULL returned if idle tracking is disabled or on UP kernels. The returned pointer is refcounted and must be properly released.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/scx_bpf_get_idle_cpumask.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nconst struct cpumask *scx_bpf_get_idle_cpumask()\n```\n\n----------------------------------------\n\nTITLE: Listing INET_DIAG_* Enumeration for TCP State Extensions (C)\nDESCRIPTION: This C enum lists all symbolic values representing supported TCP diagnostic and state information extensions for use in the 'get_info' interface and elsewhere in congestion control introspection. Members control which struct within tcp_cc_info union should be accessed, or what kind of auxiliary TCP information to retrieve. Each value gates a particular flavor of TCP or host-level metadata, with some requiring elevated privileges (e.g. CAP_NET_ADMIN).\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/program-type/BPF_PROG_TYPE_STRUCT_OPS/tcp_congestion_ops.md#2025-04-22_snippet_3\n\nLANGUAGE: c\nCODE:\n```\nenum {\n\tINET_DIAG_NONE,\n\tINET_DIAG_MEMINFO,\n\tINET_DIAG_INFO,\n\tINET_DIAG_VEGASINFO,\n\tINET_DIAG_CONG,\n\tINET_DIAG_TOS,\n\tINET_DIAG_TCLASS,\n\tINET_DIAG_SKMEMINFO,\n\tINET_DIAG_SHUTDOWN,\n\tINET_DIAG_DCTCPINFO, // (1)!\n\tINET_DIAG_PROTOCOL,  // (2)!\n\tINET_DIAG_SKV6ONLY,\n\tINET_DIAG_LOCALS,\n\tINET_DIAG_PEERS,\n\tINET_DIAG_PAD,\n\tINET_DIAG_MARK,     // (3)!\n\tINET_DIAG_BBRINFO,    // (4)!\n\tINET_DIAG_CLASS_ID,   // (5)!\n\tINET_DIAG_MD5SIG,\n\tINET_DIAG_ULP_INFO,\n\tINET_DIAG_SK_BPF_STORAGES,\n\tINET_DIAG_CGROUP_ID,\n\tINET_DIAG_SOCKOPT,\n};\n```\n\n----------------------------------------\n\nTITLE: Unpinning a BPF Map Using Libbpf in C\nDESCRIPTION: Defines the bpf_map__unpin function for unpinning (removing the pin file) from a BPF map object using the libbpf C API. This function requires libbpf to be available and takes a pointer to a bpf_map structure and a file path as arguments: the 'map' parameter specifies the BPF map object to unpin, and the 'path' parameter is the file path of the pin to remove (can be NULL to use the pin_path in the map struct). Returns 0 on success or a negative error code otherwise. The signature must be included in a C file linked against libbpf with libbpf headers available.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_map__unpin.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nint bpf_map__unpin(struct bpf_map *map, const char *path);\n```\n\n----------------------------------------\n\nTITLE: Implementing __arg_trusted for Trusted Kernel Pointers in eBPF\nDESCRIPTION: Example demonstrating how to use the __arg_trusted macro to tag a function argument as a trusted pointer to kernel memory. The example shows a subprogram that expects a non-null task pointer and its caller.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/ebpf/__arg_trusted.md#2025-04-22_snippet_1\n\nLANGUAGE: c\nCODE:\n```\n__weak int subprog_nonnull_task_flavor(struct task_struct___local *task __arg_trusted)\n{\n    char buf[16];\n\n    return bpf_copy_from_user_task(&buf, sizeof(buf), NULL, (void *)task, 0);\n}\n\nSEC(\"?uprobe.s\")\nint flavor_ptr_nonnull(void *ctx)\n{\n    struct task_struct *t = bpf_get_current_task_btf();\n\n    return subprog_nonnull_task_flavor((void *)t);\n}\n```\n\n----------------------------------------\n\nTITLE: Definition of bpf_crypto_encrypt KFunc in C\nDESCRIPTION: The kfunc signature and definition for bpf_crypto_encrypt, which encrypts a buffer using a configured crypto context and initialization vector.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/bpf_crypto_encrypt.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nint bpf_crypto_encrypt(struct bpf_crypto_ctx *ctx, const struct bpf_dynptr *src, const struct bpf_dynptr *dst, const struct bpf_dynptr *siv__nullable)\n```\n\n----------------------------------------\n\nTITLE: eBPF Traffic Control Ingress Handler\nDESCRIPTION: TC ingress hook implementation that processes incoming packets, determines ethernet protocol type, and calls appropriate packet processing function for IPv4 or IPv6 traffic.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/bpf_dynptr_from_skb.md#2025-04-22_snippet_5\n\nLANGUAGE: c\nCODE:\n```\n    SEC(\"tc\")\n    int balancer_ingress(struct __sk_buff *ctx)\n    {\n        __u8 buffer[sizeof(struct eth_hdr)] = {};\n        struct bpf_dynptr ptr;\n        struct eth_hdr *eth;\n        __u32 eth_proto;\n        __u32 nh_off;\n        int err;\n\n        nh_off = sizeof(struct eth_hdr);\n\n        bpf_dynptr_from_skb(ctx, 0, &ptr);\n        eth = bpf_dynptr_slice_rdwr(&ptr, 0, buffer, sizeof(buffer));\n        if (!eth)\n            return TC_ACT_SHOT;\n        eth_proto = eth->eth_proto;\n        if (eth_proto == bpf_htons(ETH_P_IP))\n            err = process_packet(&ptr, eth, nh_off, false, ctx);\n        else if (eth_proto == bpf_htons(ETH_P_IPV6))\n            err = process_packet(&ptr, eth, nh_off, true, ctx);\n        else\n            return TC_ACT_SHOT;\n\n        if (eth == buffer)\n            bpf_dynptr_write(&ptr, 0, buffer, sizeof(buffer), 0);\n\n        return err;\n    }\n\n    char _license[] SEC(\"license\") = \"GPL\";\n```\n\n----------------------------------------\n\nTITLE: Defining struct scx_cpu_release_args in C\nDESCRIPTION: Definition of the scx_cpu_release_args structure, which is an argument container for the cpu_release function. It contains the reason for CPU preemption and a pointer to the task structure.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/program-type/BPF_PROG_TYPE_STRUCT_OPS/sched_ext_ops.md#2025-04-22_snippet_54\n\nLANGUAGE: c\nCODE:\n```\nstruct scx_cpu_release_args {\n\t[enum scx_cpu_preempt_reason](#enum-scx_cpu_preempt_reason) reason;\n\t[struct task_struct](#struct-task_struct)         *task;\n};\n```\n\n----------------------------------------\n\nTITLE: Discarding a Sample with user_ring_buffer__discard in C\nDESCRIPTION: Defines the user_ring_buffer__discard function which is used to discard a previously reserved sample from a user ring buffer. The function takes two parameters: the user ring buffer and the sample to discard.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/user_ring_buffer__discard.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nvoid user_ring_buffer__discard(struct user_ring_buffer *rb, void *sample);\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_sysctl_get_current_value Helper in eBPF C\nDESCRIPTION: This C snippet defines the prototype for the eBPF helper function 'bpf_sysctl_get_current_value', which retrieves the current sysctl value from /proc/sys and copies it into a user-provided buffer. The function requires a pointer to a bpf_sysctl context, a buffer to write the value, and the buffer's length, and returns the number of characters copied or a negative error code on failure. Dependencies include proper eBPF program context setup and applicable use in BPF_CGROUP_SYSCTL program types; buffer must be adequately sized to avoid truncation, and the return value must be checked by the caller for error handling.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_sysctl_get_current_value.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n#!c static long (* const bpf_sysctl_get_current_value)(struct bpf_sysctl *ctx, char *buf, unsigned long buf_len) = (void *) 102;\n```\n\n----------------------------------------\n\nTITLE: Defining scx_bpf_cpu_rq KFunc in C\nDESCRIPTION: This code snippet defines the signature of the 'scx_bpf_cpu_rq' kfunc. It takes a CPU number as input and returns a pointer to the corresponding run queue structure.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/scx_bpf_cpu_rq.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstruct rq *scx_bpf_cpu_rq(s32 cpu)\n```\n\n----------------------------------------\n\nTITLE: Defining SCX Dispatch Queue ID Flags Enumeration in C\nDESCRIPTION: Defines the enum scx_dsq_id_flags which specifies flags and constants for dispatch queue IDs. These IDs follow a 64-bit format with specific bit patterns for built-in DSQs and user-created DSQs.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/program-type/BPF_PROG_TYPE_STRUCT_OPS/sched_ext_ops.md#2025-04-22_snippet_42\n\nLANGUAGE: c\nCODE:\n```\nenum scx_dsq_id_flags {\n    SCX_DSQ_FLAG_BUILTIN    = 1LLU << 63,\n    SCX_DSQ_FLAG_LOCAL_ON   = 1LLU << 62,\n\n    SCX_DSQ_INVALID         = SCX_DSQ_FLAG_BUILTIN | 0,\n    SCX_DSQ_GLOBAL          = SCX_DSQ_FLAG_BUILTIN | 1,\n    SCX_DSQ_LOCAL           = SCX_DSQ_FLAG_BUILTIN | 2,\n    SCX_DSQ_LOCAL_ON        = SCX_DSQ_FLAG_BUILTIN | SCX_DSQ_FLAG_LOCAL_ON,\n};\n```\n\n----------------------------------------\n\nTITLE: Defining the bpf_tcp_raw_gen_syncookie_ipv6 Helper Function in C\nDESCRIPTION: Defines the eBPF helper function pointer 'bpf_tcp_raw_gen_syncookie_ipv6' as a static symbol in C, referencing the kernel helper ID 205. Offers the ability to generate a SYN cookie for an IPv6 packet using only IPv6 and TCP header pointers, bypassing socket state, and returns a 64-bit value encoding both the SYN cookie and the MSS, or error codes on failure. Requires inclusion of struct definitions for 'ipv6hdr' and 'tcphdr', and is only available in contexts where CONFIG_IPV6 is enabled and the program type is SCHED_CLS or XDP. Inputs are pointers to IPv6 and TCP headers, as well as the TCP header length; output is an __s64 encoded as documented. Not invokable outside eBPF kernel space.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_tcp_raw_gen_syncookie_ipv6.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n#!c static __s64 (* const bpf_tcp_raw_gen_syncookie_ipv6)(struct ipv6hdr *iph, struct tcphdr *th, __u32 th_len) = (void *) 205;\n```\n\n----------------------------------------\n\nTITLE: BPF_F_XDP_DEV_BOUND_ONLY Flag Documentation\nDESCRIPTION: Documents the BPF_F_XDP_DEV_BOUND_ONLY flag (introduced in v6.3) which makes the loaded XDP program device-bound while allowing access to XDP metadata.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/syscall/BPF_PROG_LOAD.md#2025-04-22_snippet_8\n\nLANGUAGE: markdown\nCODE:\n```\n### `BPF_F_XDP_DEV_BOUND_ONLY`\n\n[:octicons-tag-24: v6.3](https://github.com/torvalds/linux/commit/2b3486bc2d237ec345b3942b7be5deabf8c8fed1)\n\nIf `BPF_F_XDP_DEV_BOUND_ONLY` is used in `BPF_PROG_LOAD` command, the loaded program becomes device-bound but can access XDP metadata.\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_token_create_opts struct in C\nDESCRIPTION: Structure definition for bpf_token_create_opts, which represents optional BPF token creation options. It includes fields for struct size, flags, and a zero-sized array for potential future extensions.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_token_create.md#2025-04-22_snippet_1\n\nLANGUAGE: c\nCODE:\n```\nstruct bpf_token_create_opts {\n\tsize_t sz; /* size of this struct for forward/backward compatibility */\n\t__u32 flags;\n\tsize_t :0;\n};\n```\n\n----------------------------------------\n\nTITLE: Defining eBPF KFunc 'cgroup_rstat_updated' in C\nDESCRIPTION: This code snippet shows the signature for the kfunc 'cgroup_rstat_updated' in an eBPF context. It is designed to track updates to `rstat_cpu` on a given CPU, and link it with the matching parent's `rstat_cpu->updated_children` list. The function requires a target cgroup and CPU as parameters. This kfunc can be used in conjunction with types like BPF_PROG_TYPE_LSM, BPF_PROG_TYPE_PERF_EVENT, BPF_PROG_TYPE_TRACEPOINT, and BPF_PROG_TYPE_TRACING.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/cgroup_rstat_updated.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n#!c void cgroup_rstat_updated(struct cgroup *cgrp, int cpu)\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_spin_unlock helper function in C\nDESCRIPTION: This code defines the bpf_spin_unlock helper function for eBPF programs. It takes a pointer to a bpf_spin_lock structure as an argument and is assigned the function ID 94.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_spin_unlock.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstatic long (* const bpf_spin_unlock)(struct bpf_spin_lock *lock) = (void *) 94;\n```\n\n----------------------------------------\n\nTITLE: Defining BPF_CORE_READ_BITFIELD_PROBED Macro in C\nDESCRIPTION: Definition of the BPF_CORE_READ_BITFIELD_PROBED macro that handles bitfield extraction. The macro uses bpf_probe_read_kernel to read the underlying integer storage and handles various bitfield attributes like signedness, bit size, and offset changes automatically. Returns 0 on success, <0 on error.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/ebpf/BPF_CORE_READ_BITFIELD_PROBED.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n#define BPF_CORE_READ_BITFIELD_PROBED(s, field) ({\\n\\tunsigned long long val = 0;\\n\\t\\n\\t__CORE_BITFIELD_PROBE_READ(&val, s, field);\\n\\tval <<= __CORE_RELO(s, field, LSHIFT_U64);\\n\\tif (__CORE_RELO(s, field, SIGNED))\\n\\t\\tval = ((long long)val) >> __CORE_RELO(s, field, RSHIFT_U64);\\n\\telse\\n\\t\\tval = val >> __CORE_RELO(s, field, RSHIFT_U64);\\n\\tval;\\n})\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_seq_printf_btf Helper Function in C\nDESCRIPTION: This snippet defines the 'bpf_seq_printf_btf' helper function. It uses BTF to write a string representation of _ptr_->ptr to seq_write, using _ptr_->type_id. The function returns 0 on success or a negative error on failure.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_seq_printf_btf.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstatic long (* const bpf_seq_printf_btf)(struct seq_file *m, struct btf_ptr *ptr, __u32 ptr_size, __u64 flags) = (void *) 150;\n```\n\n----------------------------------------\n\nTITLE: Defining btf__parse_elf_split Function Signature in C\nDESCRIPTION: Function signature for btf__parse_elf_split, which parses BTF data from an ELF file using a base BTF object. It takes a file path and a base BTF pointer as parameters and returns a struct btf pointer that must be freed with btf__free.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/btf__parse_elf_split.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstruct btf *btf__parse_elf_split(const char *path, struct btf *base_btf);\n```\n\n----------------------------------------\n\nTITLE: Definition of bpf_current_task_under_cgroup Helper Function in C\nDESCRIPTION: The C function prototype for the bpf_current_task_under_cgroup eBPF helper. It takes a pointer to a cgroup array map and an index as parameters, returning whether the current task belongs to the specified cgroup.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_current_task_under_cgroup.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstatic long (* const bpf_current_task_under_cgroup)(void *map, __u32 index) = (void *) 37;\n```\n\n----------------------------------------\n\nTITLE: eBPF Timer Callback Function Signature\nDESCRIPTION: The required signature for an eBPF timer callback function. The callback receives pointers to the map, key, and value associated with the timer. It must always return 0 to pass verification.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/concepts/timers.md#2025-04-22_snippet_2\n\nLANGUAGE: c\nCODE:\n```\nstatic int callback_fn(void *map, {map key type} *key, {map value type} *value)\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_program__unload function in C\nDESCRIPTION: This snippet shows the C function definition for bpf_program__unload. It takes a pointer to a bpf_program struct as an argument and returns void. The function is used to unload a BPF program by closing its file descriptor.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_program__unload.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nvoid bpf_program__unload(struct bpf_program *prog);\n```\n\n----------------------------------------\n\nTITLE: Adjusting Packet Tail and Adding Trailer in XDP eBPF Program in C\nDESCRIPTION: This C snippet defines an XDP eBPF program that parses Ethernet, IP, and UDP headers, and then uses the 'bpf_xdp_adjust_tail' helper to add a 4-byte trailer at the end of certain UDP packets. The program includes careful boundary and protocol checks to ensure packet safety, uses helpers like bpf_ntohs for endianness, and handles queue-specific trailer data. This requires the eBPF kernel environment, the declared helper, and properly initialized xdp_md input; output is an eBPF XDP verdict (XDP_PASS, XDP_DROP, or XDP_ABORTED). Limitations are that invalid packets or lengths will be dropped, and only packets destined for a specific port are modified.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_xdp_adjust_tail.md#2025-04-22_snippet_2\n\nLANGUAGE: C\nCODE:\n```\nSEC(\"xdp\")\nint xdp_test_adjust_tail(struct xdp_md *xdp)\n{\n\tvoid *data, *data_end;\n\tu16 init_pkt_size;\n\tstruct ethhdr *eth;\n\tstruct iphdr *ip = NULL;\n\tstruct udphdr *udp;\n\tu16 eth_proto;\n\n\tdata = (void *)(unsigned long)xdp->data;\n\tdata_end = (void *)(unsigned long)xdp->data_end;\n\teth = (struct ethhdr *)data;\n\tinit_pkt_size = data_end - data;\n\n\tif (eth + 1 > data_end)\n\t\treturn XDP_DROP;\n\n\teth_proto = bpf_ntohs(eth->h_proto);\n\tif (eth_proto == ETH_P_IP) {\n\t\tip = (struct iphdr *)(eth + 1);\n\t} else\n\t\treturn XDP_PASS;\n\n\tif (((ip + 1) > data_end) || (ip->ihl < 5) || (ip->ihl > 15)) {\n\t\treturn XDP_DROP;\n\t}\n\n\tif (ip->protocol == IPPROTO_UDP) {\n\t\tudp = (struct udphdr *)(ip + 1);\n\t\tif (udp + 1 > data_end)\n\t\t\treturn XDP_DROP;\n\n\t\tif (udp->len < sizeof(*udp))\n\t\t\treturn XDP_DROP;\n\n\t\tif (bpf_ntohs(udp->dest) == TARGET_PORT) {\n\t\t\tu16 len, offset;\n\t\t\tu32 *trailer_start;\n\n\t\t\t/* 4-byte pattern to add at the end of a packet, that is\n\t\t\t * destined to TARGET_PORT\n\t\t\t */\n\t\t\ttrailer |= xdp->rx_queue_index;\n\n\t\t\tif (bpf_xdp_adjust_tail(xdp, init_pkt_size + sizeof(trailer)) < 0) {\n\t\t\t\treturn XDP_ABORTED;\n\t\t\t}\n\t\t\tdata = (void *)(unsigned long)xdp->data;\n\t\t\tdata_end = (void *)(unsigned long)xdp->data_end;\n\n\t\t\t/* write trailer */\n\t\t\tlen = data_end - data;\n\t\t\tif ((data + len) > data_end) {\n\t\t\t\treturn XDP_ABORTED;\n\t\t\t}\n\n\t\t\t/*  0x3fff - largest value for a packet size that allows 9K jumbo */\n\t\t\toffset = (len - sizeof(trailer)) & 0x3fff;\n\n\t\t\ttrailer_start = (u32 *)(data + offset);\n\t\t\tif ((trailer_start + 1) > (u32 *)data_end) {\n\t\t\t\treturn XDP_ABORTED;\n\t\t\t}\n\n\t\t\t*trailer_start = trailer;\n\n\t\t\treturn XDP_PASS;\n\t\t}\n\t}\n\treturn XDP_PASS;\n}\n```\n\n----------------------------------------\n\nTITLE: DCTCP Congestion Window Event Handling in BPF\nDESCRIPTION: This function handles various congestion window events for DCTCP, including ECN marking and packet loss. It updates the congestion state and triggers appropriate responses.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/program-type/BPF_PROG_TYPE_STRUCT_OPS/tcp_congestion_ops.md#2025-04-22_snippet_19\n\nLANGUAGE: C\nCODE:\n```\nSEC(\"struct_ops\")\nvoid BPF_PROG(bpf_dctcp_cwnd_event, struct sock *sk, enum tcp_ca_event ev)\n{\n\tstruct bpf_dctcp *ca = inet_csk_ca(sk);\n\n\tswitch (ev) {\n\tcase CA_EVENT_ECN_IS_CE:\n\tcase CA_EVENT_ECN_NO_CE:\n\t\tdctcp_ece_ack_update(sk, ev, &ca->prior_rcv_nxt, &ca->ce_state);\n\t\tbreak;\n\tcase CA_EVENT_LOSS:\n\t\tdctcp_react_to_loss(sk);\n\t\tbreak;\n\tdefault:\n\t\t/* Don't care for the rest. */\n\t\tbreak;\n\t}\n}\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_program__attach_sockmap function in C\nDESCRIPTION: This snippet defines the bpf_program__attach_sockmap function, which attaches a BPF program to a sockmap or sockhash map. It takes a BPF program and a map file descriptor as parameters and returns a pointer to a bpf_link structure or NULL on error.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_program__attach_sockmap.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstruct bpf_link * bpf_program__attach_sockmap(const struct bpf_program *prog, int map_fd);\n```\n\n----------------------------------------\n\nTITLE: Retrieving Tunnel and FOU Encapsulation Information in TC Program\nDESCRIPTION: This example shows how to use bpf_skb_get_tunnel_key and bpf_skb_get_fou_encap to retrieve IP-in-IP tunnel information and FOU encapsulation parameters. It filters traffic based on the UDP destination port (5555) and logs relevant encapsulation details.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/bpf_skb_get_fou_encap.md#2025-04-22_snippet_1\n\nLANGUAGE: c\nCODE:\n```\n// SPDX-License-Identifier: GPL-2.0\n/* Copyright (c) 2016 VMware\n * Copyright (c) 2016 Facebook\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of version 2 of the GNU General Public\n * License as published by the Free Software Foundation.\n */\n\nSEC(\"tc\")\nint ipip_encap_get_tunnel(struct __sk_buff *skb)\n{\n\tint ret;\n\tstruct bpf_tunnel_key key = {};\n\tstruct bpf_fou_encap encap = {};\n\n\tret = bpf_skb_get_tunnel_key(skb, &key, sizeof(key), 0);\n\tif (ret < 0) {\n\t\tlog_err(ret);\n\t\treturn TC_ACT_SHOT;\n\t}\n\n\tret = bpf_skb_get_fou_encap(skb, &encap);\n\tif (ret < 0) {\n\t\tlog_err(ret);\n\t\treturn TC_ACT_SHOT;\n\t}\n\n\tif (bpf_ntohs(encap.dport) != 5555)\n\t\treturn TC_ACT_SHOT;\n\n\tbpf_printk(\"%d remote ip 0x%x, sport %d, dport %d\\n\", ret,\n\t\t   key.remote_ipv4, bpf_ntohs(encap.sport),\n\t\t   bpf_ntohs(encap.dport));\n\treturn TC_ACT_OK;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining BPF Attributes for netkit\nDESCRIPTION: This C code snippet defines a structure for the netkit attribute in eBPF, with components like `relative_fd` and `expected_revision`. These elements ensure correct program attachment and revision tracking, preventing conflicts when multiple connections are established simultaneously, as marked for kernel version 6.7.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/syscall/BPF_LINK_CREATE.md#2025-04-22_snippet_5\n\nLANGUAGE: C\nCODE:\n```\nunion bpf_attr {\n\tstruct {\n\t\t[...]\n\t\tunion {\n\t\t\tstruct {\n\t\t\t\tunion {\n\t\t\t\t\t__u32\t[relative_fd](#netkit-relative_fd);\n\t\t\t\t\t__u32\t[relative_id](#netkit-relative_id);\n\t\t\t\t};\n\t\t\t\t__u64\t\t[expected_revision](#netkit-expected_revision);\n\t\t\t} netkit;\n\t\t}\n\t}\n}\n```\n\n----------------------------------------\n\nTITLE: Defining scx_bpf_cpuperf_cap KFunc Signature in C\nDESCRIPTION: Function signature for the scx_bpf_cpuperf_cap kernel function that returns the maximum relative capacity of a specified CPU compared to the most performant CPU in the system. The function takes a CPU ID as input and returns a u32 value representing the relative capacity.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/scx_bpf_cpuperf_cap.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nu32 scx_bpf_cpuperf_cap(s32 cpu)\n```\n\n----------------------------------------\n\nTITLE: Static Function Declaration in eBPF C\nDESCRIPTION: The snippet declares a static eBPF helper function 'bpf_xdp_store_bytes' that stores a specified number of bytes from a buffer into the XDP (Express Data Path) frame associated with 'xdp_md' at a given offset. It returns 0 on success or a negative error code if it fails. The function is intended for use in specific program types, namely 'BPF_PROG_TYPE_XDP'.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_xdp_store_bytes.md#2025-04-22_snippet_0\n\nLANGUAGE: C\nCODE:\n```\nstatic long (* const bpf_xdp_store_bytes)(struct xdp_md *xdp_md, __u32 offset, void *buf, __u32 len) = (void *) 190;\n```\n\n----------------------------------------\n\nTITLE: Using 'offsetof' in an eBPF TC Program (C)\nDESCRIPTION: This C code snippet shows an example eBPF program attached to the Traffic Control (TC) hook. It uses the `offsetof` macro to calculate the offset of the destination address field (`daddr`) within the IP header (`struct iphdr`). This calculated offset, added to the Ethernet header length (`ETH_HLEN`), is then used with the `bpf_skb_store_bytes` helper function to modify the destination IP address of the packet in the `skb` buffer to `10.0.0.1`.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/ebpf/offsetof.md#2025-04-22_snippet_1\n\nLANGUAGE: c\nCODE:\n```\n#define ETH_HLEN 14\n\nSEC(\"tc\")\nint example_prog(struct __sk_buff *ctx)\n{\n    __u32 assigned_ip = 0x0a000001; // 10.0.0.1\n    bpf_skb_store_bytes(skb, ETH_HLEN + offsetof(struct iphdr, daddr), &assigned_ip, sizeof(__u32), 0) < 0)\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Operation States in SCX Framework (C)\nDESCRIPTION: Defines the enum scx_ops_state which represents the states a scheduler operation can be in, including ownership by SCX core, in transit to BPF scheduler, owned by BPF scheduler, or in transit back to SCX core.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/program-type/BPF_PROG_TYPE_STRUCT_OPS/sched_ext_ops.md#2025-04-22_snippet_46\n\nLANGUAGE: c\nCODE:\n```\nenum scx_ops_state {\n\tSCX_OPSS_NONE,          // (1)!\n\tSCX_OPSS_QUEUEING,      // (2)!\n\tSCX_OPSS_QUEUED,        // (3)!\n\tSCX_OPSS_DISPATCHING,   // (4)!\n};\n```\n\n----------------------------------------\n\nTITLE: BPF Map Info Structure Definition\nDESCRIPTION: C structure definition for bpf_map_info that contains map attributes like type, size, flags and BTF information. Used to store and retrieve information about BPF maps.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/syscall/BPF_OBJ_GET_INFO_BY_FD.md#2025-04-22_snippet_2\n\nLANGUAGE: c\nCODE:\n```\nstruct bpf_map_info {\n    __u32 type;\n    __u32 id;\n    __u32 key_size;\n    __u32 value_size;\n    __u32 max_entries;\n    __u32 map_flags;\n    char  name[BPF_OBJ_NAME_LEN];\n    __u32 ifindex;\n    __u32 btf_vmlinux_value_type_id;\n    __u64 netns_dev;\n    __u64 netns_ino;\n    __u32 btf_id;\n    __u32 btf_key_type_id;\n    __u32 btf_value_type_id;\n    __u32 :32;\t/* alignment pad */\n    __u64 map_extra;\n} __attribute__((aligned(8)));\n```\n\n----------------------------------------\n\nTITLE: Task Stopping State Operation\nDESCRIPTION: Callback when a task stops execution, with indication if it remains runnable.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/program-type/BPF_PROG_TYPE_STRUCT_OPS/sched_ext_ops.md#2025-04-22_snippet_14\n\nLANGUAGE: c\nCODE:\n```\nvoid (*stopping)(struct task_struct *p, bool runnable);\n```\n\n----------------------------------------\n\nTITLE: Defining the bbr_undo_cwnd kfunc Signature in C\nDESCRIPTION: This C code snippet shows the function signature for the eBPF kfunc 'bbr_undo_cwnd'. This function is part of the BBR congestion control implementation in the Linux kernel and can be called from specific eBPF programs. It takes a pointer to a socket structure ('struct sock *sk') as input and returns a 'u32' value, theoretically representing the new congestion window size after a loss event, although BBR's behavior on loss might differ.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/bbr_undo_cwnd.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nu32 bbr_undo_cwnd(struct sock *sk)\n```\n\n----------------------------------------\n\nTITLE: Defining HID BPF Struct Operations - Linux Kernel C\nDESCRIPTION: Defines the 'hid_bpf_ops' struct with function pointers for custom HID device logic using BPF programs. Dependencies include Linux kernel headers and double-pointer callback syntax. The struct enables device event filtering, descriptor fixup, and hardware request interception. All fields, argument types, and function pointer signatures are essential for users creating HID BPF drivers. Proper initialization and attachment to devices are required for these ops to be effective.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/program-type/BPF_PROG_TYPE_STRUCT_OPS/hid_bpf_ops.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstruct hid_bpf_ops {\n\tint   [hid_id](#hid_id);\n\tu32   [flags](#flags);\n\tint (*[hid_device_event](#hid_device_event))(\n\t\t[struct hid_bpf_ctx](#struct-hid_bpf_ctx)  *ctx, \n\t\t[enum hid_report_type](#enum-hid_report_type) report_type, \n\t\tu64                  source\n\t);\n\tint (*[hid_rdesc_fixup](#hid_rdesc_fixup))([struct hid_bpf_ctx](#struct-hid_bpf_ctx) *ctx);\n\tint (*[hid_hw_request](#hid_hw_request))(\n        [struct hid_bpf_ctx](#struct-hid_bpf_ctx)     *ctx, \n        unsigned char           reportnum, \n        [enum hid_report_type](#enum-hid_report_type)    rtype,\n        [enum hid_class_request](#enum-hid_class_request)  reqtype,\n        u64                     source\n    );\n\tint (*[hid_hw_output_report](#hid_hw_output_report))([struct hid_bpf_ctx](#struct-hid_bpf_ctx) *ctx, u64 source);\n};\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_link_create Function Signature (Libbpf, C)\nDESCRIPTION: Declares the bpf_link_create function in libbpf, which is used to create a new BPF link by directly invoking the BPF_LINK_CREATE syscall. The parameters include file descriptors for the program and target object, the type of attachment, and optional configuration via a struct pointer. Returns a new file descriptor on success or a negative error code otherwise. Requires libbpf and relevant kernel support.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_link_create.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n#!c int bpf_link_create(int prog_fd, int target_fd, enum bpf_attach_type attach_type, const struct bpf_link_create_opts *opts);\n```\n\n----------------------------------------\n\nTITLE: Defining the bpf_xdp_get_buff_len Helper Function in eBPF (C)\nDESCRIPTION: This code snippet defines the bpf_xdp_get_buff_len helper as a function pointer for use in eBPF programs written in C. The function retrieves the total size of an XDP buffer, including both linear and paged regions, and is primarily used in tracing or XDP program types. It requires inclusion of the struct xdp_md and linking against the eBPF kernel headers. The only parameter is a pointer to xdp_md, representing packet metadata, and the function returns a 64-bit unsigned integer indicating the buffer length. This helper is only available from Linux kernel version 5.18 onwards.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_xdp_get_buff_len.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n#!c static __u64 (* const bpf_xdp_get_buff_len)(struct xdp_md *xdp_md) = (void *) 188;\n```\n\n----------------------------------------\n\nTITLE: Defining scx_bpf_pick_any_cpu KFunc in C\nDESCRIPTION: Function signature for the scx_bpf_pick_any_cpu kfunc. It takes a cpumask and flags as parameters and returns an s32 value representing the picked CPU number or an error code.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/scx_bpf_pick_any_cpu.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\ns32 scx_bpf_pick_any_cpu(const struct cpumask *cpus_allowed, u64 flags)\n```\n\n----------------------------------------\n\nTITLE: Using bpf_dynptr_from_skb Function in eBPF\nDESCRIPTION: Function signature for creating a dynamic pointer from an sk_buff object, allowing for variable-sized data operations on SKB data without needing manual bounds checking.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/bpf_dynptr_from_skb.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nint bpf_dynptr_from_skb(struct __sk_buff *s, u64 flags, struct bpf_dynptr *ptr__uninit)\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_verify_pkcs7_signature KFunc in C\nDESCRIPTION: Function signature for the bpf_verify_pkcs7_signature kernel function that verifies PKCS#7 signatures against provided data using a trusted keyring. This function is sleepable and returns an integer status code.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/bpf_verify_pkcs7_signature.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nint bpf_verify_pkcs7_signature(struct bpf_dynptr *data_p, struct bpf_dynptr *sig_p, struct bpf_key *trusted_keyring)\n```\n\n----------------------------------------\n\nTITLE: Initializing BBR with eBPF KFunc Definition in C\nDESCRIPTION: Defines the eBPF kfunc 'bbr_init' which initializes the BBR congestion control algorithm on a socket. The function requires a single parameter of type 'struct sock *'. It is used primarily with 'BPF_PROG_TYPE_STRUCT_OPS' program types in the eBPF ecosystem.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/bbr_init.md#2025-04-22_snippet_0\n\nLANGUAGE: C\nCODE:\n```\nvoid bbr_init(struct sock *sk)\n```\n\n----------------------------------------\n\nTITLE: Defining the bpf_path_d_path KFunc in C\nDESCRIPTION: Function signature for the bpf_path_d_path kernel function that resolves path names. It takes a path pointer, a buffer to store the result, and the buffer size. Returns the length of the resolved path name or a negative value on error.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/bpf_path_d_path.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nint bpf_path_d_path(struct path *path, char *buf, size_t buf__sz)\n```\n\n----------------------------------------\n\nTITLE: Defining SCX Dequeue Flags Enumeration in C\nDESCRIPTION: Defines the enum scx_deq_flags which specifies flags used during task dequeuing operations. These flags indicate whether a task is sleeping or if it was executed by the core scheduler.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/program-type/BPF_PROG_TYPE_STRUCT_OPS/sched_ext_ops.md#2025-04-22_snippet_41\n\nLANGUAGE: c\nCODE:\n```\nenum scx_deq_flags {\n    SCX_DEQ_SLEEP           = 1LLU << 0,\n    SCX_DEQ_CORE_SCHED_EXEC = 1LLU << 32,\n};\n```\n\n----------------------------------------\n\nTITLE: Setting NUMA Node for BPF Map using libbpf in C\nDESCRIPTION: This snippet defines the userspace C function 'bpf_map__set_numa_node', which allows a user to set the NUMA node for a BPF map before its creation using the libbpf library. Dependencies include the 'libbpf' library and appropriate BPF map structures. Inputs are the pointer to the map ('map') and the NUMA node identifier ('numa_node'), with valid output being 0 on success or negative error code on failure. This operation must occur before the map is loaded, thus is constrained to pre-creation configuration only.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_map__set_numa_node.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n#!c int bpf_map__set_numa_node(struct bpf_map *map, __u32 numa_node);\n```\n\n----------------------------------------\n\nTITLE: Retrieving Tunnel Metadata with bpf_skb_get_tunnel_key in C\nDESCRIPTION: This code snippet demonstrates how to use the bpf_skb_get_tunnel_key helper function to retrieve tunnel metadata from a network packet. It filters packets based on the remote IPv4 address.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_skb_get_tunnel_key.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nint ret; struct bpf_tunnel_key key = {};\n\nret = bpf_skb_get_tunnel_key(skb, &key, sizeof(key), 0);\nif (ret < 0)\n    return TC_ACT_SHOT;  // drop packet\n\nif (key.remote_ipv4 != 0x0a000001)\n    return TC_ACT_SHOT;  // drop packet\n\nreturn TC_ACT_OK;  // accept packet\n```\n\n----------------------------------------\n\nTITLE: Using 'unlikely' macro in conditional statements in C\nDESCRIPTION: This example demonstrates how to use the 'unlikely' macro in an if statement. It's applied to a pointer check where the null case is expected to be rare, potentially improving instruction cache locality for the likely code path.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/scx/unlikely.md#2025-04-22_snippet_1\n\nLANGUAGE: c\nCODE:\n```\nif (unlikely(ptr == NULL)) {\n    // Unlikely code path\n    return -EINVAL;\n}\n// Likely code path\n```\n\n----------------------------------------\n\nTITLE: Defining the bpf_dynptr_clone KFunc in C\nDESCRIPTION: Function signature for the bpf_dynptr_clone kernel function that creates a clone of a dynamic pointer. The cloned dynptr will point to the same data as its parent with identical type, offset, size and read-only properties.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/bpf_dynptr_clone.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nint bpf_dynptr_clone(const struct bpf_dynptr *p, struct bpf_dynptr *clone__uninit)\n```\n\n----------------------------------------\n\nTITLE: Context Structure for BPF_PROG_TYPE_CGROUP_SOCK_ADDR Program Type\nDESCRIPTION: C structure definition for bpf_sock_addr context that provides access to syscall arguments and socket information. The structure includes fields for IP addresses, port numbers, socket family, type, and protocol, each with specific read/write permissions.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/program-type/BPF_PROG_TYPE_CGROUP_SOCK_ADDR.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstruct bpf_sock_addr {\n    __u32 user_family;\t/* Allows 4-byte read, but no write. */\n    __u32 user_ip4;\t\t/* Allows 1,2,4-byte read and 4-byte write.\n                * Stored in network byte order.\n                */\n    __u32 user_ip6[4];\t/* Allows 1,2,4,8-byte read and 4,8-byte write.\n                * Stored in network byte order.\n                */\n    __u32 user_port;\t/* Allows 1,2,4-byte read and 4-byte write.\n                * Stored in network byte order\n                */\n    __u32 family;\t\t/* Allows 4-byte read, but no write */\n    __u32 type;\t\t/* Allows 4-byte read, but no write */\n    __u32 protocol;\t\t/* Allows 4-byte read, but no write */\n    __u32 msg_src_ip4;\t/* Allows 1,2,4-byte read and 4-byte write.\n                * Stored in network byte order.\n                */\n    __u32 msg_src_ip6[4];\t/* Allows 1,2,4,8-byte read and 4,8-byte write.\n                * Stored in network byte order.\n                */\n    __bpf_md_ptr(struct bpf_sock *, sk);\n};\n```\n\n----------------------------------------\n\nTITLE: Using perf_event_open syscall in C\nDESCRIPTION: Opens a new perf event using the perf_event_open syscall, initializing a perf_event_attr structure to set up event configurations like frequency and type. Input parameters include a filled perf_event_attr structure and the syscall function. Successful execution returns a file descriptor for the event.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/program-type/BPF_PROG_TYPE_PERF_EVENT.md#2025-04-22_snippet_1\n\nLANGUAGE: C\nCODE:\n```\nstruct perf_event_attr attr = {\n    .sample_freq = SAMPLE_FREQ,\n    .freq = 1,\n    .type = PERF_TYPE_HARDWARE,\n    .config = PERF_COUNT_HW_CPU_CYCLES,\n};\n\nsyscall(SYS_perf_event_open, \n    &attr,  /* struct perf_event_attr * */\n    -1,     /* pid_t pid */\n    0       /* int cpu */\n    -1,     /* int group_fd */\n    PERF_FLAG_FD_CLOEXEC /* unsigned long flags */\n);\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_map__map_flags in Libbpf (C)\nDESCRIPTION: This code snippet defines the `bpf_map__map_flags` function in C using libbpf. It retrieves the flags associated with a BPF map, which are used when a map is loaded. The function takes a pointer to a BPF map as an input parameter and returns a 32-bit unsigned integer representing the flags. No additional dependencies are specified beyond standard libbpf usage.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_map__map_flags.md#2025-04-22_snippet_0\n\nLANGUAGE: C\nCODE:\n```\n__u32 bpf_map__map_flags(const struct bpf_map *map);\n```\n\n----------------------------------------\n\nTITLE: Using bpf_get_kmem_cache to Identify Task Struct in eBPF Program\nDESCRIPTION: Example eBPF program that uses bpf_get_kmem_cache to retrieve and check the slab cache name for the current task structure. It demonstrates how to identify objects based on their slab allocation.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/bpf_get_kmem_cache.md#2025-04-22_snippet_1\n\nLANGUAGE: c\nCODE:\n```\n// SPDX-License-Identifier: GPL-2.0\n/* Copyright (c) 2024 Google */\n#include <vmlinux.h>\n#include <bpf/bpf_helpers.h>\n#include <bpf/bpf_tracing.h>\n#include \"bpf_experimental.h\"\n\nchar _license[] SEC(\"license\") = \"GPL\";\n\n#define SLAB_NAME_MAX  32\n\nstruct {\n\t__uint(type, BPF_MAP_TYPE_HASH);\n\t__uint(key_size, sizeof(void *));\n\t__uint(value_size, SLAB_NAME_MAX);\n\t__uint(max_entries, 1);\n} slab_hash SEC(\".maps\");\n\nextern struct kmem_cache *bpf_get_kmem_cache(u64 addr) __ksym;\n\n/* Result, will be checked by userspace */\nint task_struct_found;\n\nSEC(\"raw_tp/bpf_test_finish\")\nint BPF_PROG(check_task_struct)\n{\n\tu64 curr = bpf_get_current_task();\n\tstruct kmem_cache *s;\n\tchar *name;\n\n\ts = bpf_get_kmem_cache(curr);\n\tif (s == NULL) {\n\t\ttask_struct_found = -1;\n\t\treturn 0;\n\t}\n\tname = bpf_map_lookup_elem(&slab_hash, &s);\n\tif (name && !bpf_strncmp(name, 11, \"task_struct\"))\n\t\ttask_struct_found = 1;\n\telse\n\t\ttask_struct_found = -2;\n\treturn 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_ima_file_hash Helper Function in C\nDESCRIPTION: This code snippet defines the bpf_ima_file_hash helper function. It calculates the IMA hash of a file and copies it to a destination buffer. The function returns the hash algorithm used on success, or error codes for failures.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_ima_file_hash.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstatic long (* const bpf_ima_file_hash)(struct file *file, void *dst, __u32 size) = (void *) 193;\n```\n\n----------------------------------------\n\nTITLE: Implementing bpf_xdp_xfrm_state_release in an XDP Program (C)\nDESCRIPTION: This C code provides an example XDP program demonstrating the usage of `bpf_xdp_xfrm_state_release`. The program parses packet headers, retrieves an IPsec transform state using `bpf_xdp_get_xfrm_state`, potentially reads a value from the state, and crucially calls `bpf_xdp_xfrm_state_release` in an `if (x)` block to release the state reference before returning `XDP_PASS`. This ensures proper resource management as required by the eBPF verifier.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/bpf_xdp_xfrm_state_release.md#2025-04-22_snippet_1\n\nLANGUAGE: c\nCODE:\n```\n// SPDX-License-Identifier: GPL-2.0\n/* Copyright (c) 2016 VMware\n * Copyright (c) 2016 Facebook\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of version 2 of the GNU General Public\n * License as published by the Free Software Foundation.\n */\n\nvolatile int xfrm_replay_window = 0;\n\nSEC(\"xdp\")\nint xfrm_get_state_xdp(struct xdp_md *xdp)\n{\n\tstruct bpf_xfrm_state_opts opts = {};\n\tstruct xfrm_state *x = NULL;\n\tstruct ip_esp_hdr *esph;\n\tstruct bpf_dynptr ptr;\n\tu8 esph_buf[8] = {};\n\tu8 iph_buf[20] = {};\n\tstruct iphdr *iph;\n\tu32 off;\n\n\tif (bpf_dynptr_from_xdp(xdp, 0, &ptr))\n\t\tgoto out;\n\n\toff = sizeof(struct ethhdr);\n\tiph = bpf_dynptr_slice(&ptr, off, iph_buf, sizeof(iph_buf));\n\tif (!iph || iph->protocol != IPPROTO_ESP)\n\t\tgoto out;\n\n\toff += sizeof(struct iphdr);\n\tesph = bpf_dynptr_slice(&ptr, off, esph_buf, sizeof(esph_buf));\n\tif (!esph)\n\t\tgoto out;\n\n\topts.netns_id = BPF_F_CURRENT_NETNS;\n\topts.daddr.a4 = iph->daddr;\n\topts.spi = esph->spi;\n\topts.proto = IPPROTO_ESP;\n\topts.family = AF_INET;\n\n\tx = bpf_xdp_get_xfrm_state(xdp, &opts, sizeof(opts));\n\tif (!x)\n\t\tgoto out;\n\n\tif (!x->replay_esn)\n\t\tgoto out;\n\n\txfrm_replay_window = x->replay_esn->replay_window;\nout:\n\tif (x)\n\t\tbpf_xdp_xfrm_state_release(x);\n\treturn XDP_PASS;\n}\n\nchar _license[] SEC(\"license\") = \"GPL\";\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_map__reuse_fd in Libbpf\nDESCRIPTION: The 'bpf_map__reuse_fd' function in C allows a bpf_map to reuse an existing file descriptor. It facilitates sharing of the file descriptor across different programs using the map, enhancing efficiency by avoiding the creation of new file descriptors. The function returns 0 on success and a negative error code on failure. Prerequisites include having a valid bpf_map object and a file descriptor ready to be reused.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_map__reuse_fd.md#2025-04-22_snippet_0\n\nLANGUAGE: C\nCODE:\n```\n#!c\nint bpf_map__reuse_fd(struct bpf_map *map, int fd);\n```\n\n----------------------------------------\n\nTITLE: Updating Per-CPU Data with __percpu_kptr in eBPF Program\nDESCRIPTION: This eBPF program shows how to update per-CPU data using __percpu_kptr, including lookup and modification of specific CPU's data.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/ebpf/__percpu_kptr.md#2025-04-22_snippet_3\n\nLANGUAGE: c\nCODE:\n```\nSEC(\"?fentry/bpf_fentry_test2\")\nint BPF_PROG(test_array_map_2)\n{\n\tstruct val_t __percpu_kptr *p;\n\tstruct val_t *v;\n\tstruct elem *e;\n\tint index = 0;\n\n\te = bpf_map_lookup_elem(&array, &index);\n\tif (!e)\n\t\treturn 0;\n\n\tp = e->pc;\n\tif (!p)\n\t\treturn 0;\n\n\tv = bpf_per_cpu_ptr(p, 0);\n\tif (!v)\n\t\treturn 0;\n\tv->c = 1;\n\tv->d = 2;\n\n\treturn 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_program__attach_lsm Function Signature in C\nDESCRIPTION: Function signature for attaching a BPF_PROG_TYPE_LSM program. The function takes a BPF program pointer as input and returns a pointer to the newly created BPF link structure. Returns NULL on error with errno set.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_program__attach_lsm.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstruct bpf_link * bpf_program__attach_lsm(const struct bpf_program *prog);\n```\n\n----------------------------------------\n\nTITLE: Defining BPF Linker Options Structure (C)\nDESCRIPTION: Defines the 'bpf_linker_opts' structure, which specifies configuration for the BPF linker. This struct currently contains a single field, 'sz', representing its own size for versioning and compatibility. It must be initialized by the caller and passed to BPF linking functions. The only parameter is 'sz', a 'size_t' storing the struct's size, ensuring safe extension in future Libbpf releases.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_linker__new.md#2025-04-22_snippet_1\n\nLANGUAGE: c\nCODE:\n```\nstruct bpf_linker_opts {\n\t/* size of this struct, for forward/backward compatibility */\n\tsize_t sz;\n};\n```\n\n----------------------------------------\n\nTITLE: Defining Dispatch Queue Flags for Task Entities (C)\nDESCRIPTION: Defines the enum scx_ent_dsq_flags which contains flags that can be set on a task's dispatch queue entry, such as indicating whether a task is queued on the priority queue of a DSQ.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/program-type/BPF_PROG_TYPE_STRUCT_OPS/sched_ext_ops.md#2025-04-22_snippet_47\n\nLANGUAGE: c\nCODE:\n```\nenum scx_ent_dsq_flags {\n\tSCX_TASK_DSQ_ON_PRIQ = 1 << 0, // (1)!\n};\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_cgroup_dev_ctx Structure and Related Enums in C\nDESCRIPTION: This structure defines the context passed to cGroup device BPF programs, including the access type (mknod/read/write) and device information (type, major and minor numbers). The enums define constants for access types and device types.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/program-type/BPF_PROG_TYPE_CGROUP_DEVICE.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstruct bpf_cgroup_dev_ctx {\n\t/* access_type encoded as (BPF_DEVCG_ACC_* << 16) | BPF_DEVCG_DEV_* */\n\t__u32 access_type;\n\t__u32 major;\n\t__u32 minor;\n};\n\nenum {\n\tBPF_DEVCG_ACC_MKNOD\t= (1ULL << 0),\n\tBPF_DEVCG_ACC_READ\t= (1ULL << 1),\n\tBPF_DEVCG_ACC_WRITE\t= (1ULL << 2),\n};\n\nenum {\n\tBPF_DEVCG_DEV_BLOCK\t= (1ULL << 0),\n\tBPF_DEVCG_DEV_CHAR\t= (1ULL << 1),\n};\n```\n\n----------------------------------------\n\nTITLE: Defining struct scx_cpu_acquire_args in C\nDESCRIPTION: Definition of the scx_cpu_acquire_args structure, which is an argument container for the cpu_acquire function. Currently empty but may be expanded in the future.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/program-type/BPF_PROG_TYPE_STRUCT_OPS/sched_ext_ops.md#2025-04-22_snippet_53\n\nLANGUAGE: c\nCODE:\n```\nstruct scx_cpu_acquire_args {};\n```\n\n----------------------------------------\n\nTITLE: KFunc Definition for bpf_xdp_ct_alloc in C\nDESCRIPTION: Function signature and return type definition for the bpf_xdp_ct_alloc kernel function. Returns a pointer to a refcounted nf_conn___init object that must be properly released.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/bpf_xdp_ct_alloc.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstruct nf_conn___init *bpf_xdp_ct_alloc(struct xdp_md *xdp_ctx, struct bpf_sock_tuple *bpf_tuple, u32 tuple__sz, struct bpf_ct_opts *opts, u32 opts__sz)\n```\n\n----------------------------------------\n\nTITLE: TCP Connection States Enumeration for cGroup Socket Programs\nDESCRIPTION: Enumeration of TCP connection states used in the state field of bpf_sock structure. These values represent different states a TCP connection can be in.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/program-type/BPF_PROG_TYPE_CGROUP_SOCK.md#2025-04-22_snippet_1\n\nLANGUAGE: c\nCODE:\n```\nenum {\n\tBPF_TCP_ESTABLISHED = 1,\n\tBPF_TCP_SYN_SENT,\n\tBPF_TCP_SYN_RECV,\n\tBPF_TCP_FIN_WAIT1,\n\tBPF_TCP_FIN_WAIT2,\n\tBPF_TCP_TIME_WAIT,\n\tBPF_TCP_CLOSE,\n\tBPF_TCP_CLOSE_WAIT,\n\tBPF_TCP_LAST_ACK,\n\tBPF_TCP_LISTEN,\n\tBPF_TCP_CLOSING,\t/* Now a valid state */\n\tBPF_TCP_NEW_SYN_RECV\n};\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_timer_set_callback Helper in eBPF C\nDESCRIPTION: Declares the static function pointer for 'bpf_timer_set_callback', which configures an eBPF timer to invoke a user-defined callback function. To use this helper, the timer must first be initialized with bpf_timer_init(); otherwise, the function fails with -EINVAL. The timer must reside in a map with an active user reference (map pinned or file descriptor open), else -EPERM is returned. On success, returns 0. The definition is a C language function pointer, mapping to helper ID 170. Inputs are 'struct bpf_timer *timer' and a callback function pointer. Output is an integer status code.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_timer_set_callback.md#2025-04-22_snippet_0\n\nLANGUAGE: C\nCODE:\n```\nstatic long (* const bpf_timer_set_callback)(struct bpf_timer *timer, void *callback_fn) = (void *) 170;\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_tcp_raw_gen_syncookie_ipv4 eBPF Helper Function in C\nDESCRIPTION: Declares the eBPF helper function 'bpf_tcp_raw_gen_syncookie_ipv4', which can be used in eBPF programs to generate SYN cookies for IPv4/TCP packets without a listening socket. The function receives pointers to IPv4 and TCP headers and the length of the TCP header and returns a status code with the SYN cookie and MSS encoded on success or error codes on failure. This declaration is for C-based eBPF programs using appropriate kernel versions (v6.0+), with dependencies on kernel eBPF loader and the presence of the 'struct iphdr' and 'struct tcphdr' types. Inputs: pointers to IP and TCP header structs, and header length. Outputs: __s64 status encoding SYN cookie and MSS or error. Use is restricted to BPF_PROG_TYPE_SCHED_CLS and BPF_PROG_TYPE_XDP programs.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_tcp_raw_gen_syncookie_ipv4.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstatic __s64 (* const bpf_tcp_raw_gen_syncookie_ipv4)(struct iphdr *iph, struct tcphdr *th, __u32 th_len) = (void *) 204;\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_wq_start KFunc in C\nDESCRIPTION: Function signature for the bpf_wq_start kfunc. It takes a pointer to a struct bpf_wq and flags as parameters, and returns an integer status code.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/bpf_wq_start.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nint bpf_wq_start(struct bpf_wq *wq, unsigned int flags)\n```\n\n----------------------------------------\n\nTITLE: Defining struct bpf_get_fd_by_id_opts in Libbpf (C)\nDESCRIPTION: This snippet defines 'struct bpf_get_fd_by_id_opts', a configuration struct used when retrieving a BPF link file descriptor using 'bpf_link_get_fd_by_id_opts'. The struct provides forward/backward compatibility ('sz'), the ability to specify open flags for permission control ('open_flags'), and is compatible with libbpf version 1.1.0. Proper size and flag values must be specified by the user. The struct must be initialized with relevant fields before being passed to the function.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_link_get_fd_by_id_opts.md#2025-04-22_snippet_1\n\nLANGUAGE: c\nCODE:\n```\nstruct bpf_get_fd_by_id_opts {\n\tsize_t sz; /* size of this struct for forward/backward compatibility */\n\t__u32 open_flags; /* permissions requested for the operation on fd */\n\tsize_t :0;\n};\n```\n\n----------------------------------------\n\nTITLE: Definition of bpf_cgrp_storage_delete Helper Function in C\nDESCRIPTION: Function signature for the bpf_cgrp_storage_delete eBPF helper that deletes local storage from a cgroup. It takes a map pointer and a cgroup pointer as parameters and returns 0 on success or -ENOENT if the storage cannot be found.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_cgrp_storage_delete.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstatic long (* const bpf_cgrp_storage_delete)(void *map, struct cgroup *cgroup) = (void *) 211;\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_ktime_get_tai_ns eBPF Helper Function in C\nDESCRIPTION: This code snippet defines the 'bpf_ktime_get_tai_ns' eBPF helper function. It returns the current ktime as a 64-bit unsigned integer, representing a nonsettable system-wide clock derived from wall-clock time but ignoring leap seconds.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_ktime_get_tai_ns.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstatic __u64 (* const bpf_ktime_get_tai_ns)(void) = (void *) 208;\n```\n\n----------------------------------------\n\nTITLE: Definition of bpf_ct_release kFunc in C\nDESCRIPTION: Function signature for the bpf_ct_release kFunc which releases a referenced nf_conn object. This must be called for any referenced PTR_TO_BTF_ID objects to avoid verifier rejection.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/bpf_ct_release.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nvoid bpf_ct_release(struct nf_conn *nfct)\n```\n\n----------------------------------------\n\nTITLE: Retrieving Inner Map Using libbpf (C)\nDESCRIPTION: Defines the 'bpf_map__inner_map' function signature in C, which retrieves the inner map from a given BPF map structure. It requires including the libbpf library, and the only parameter is a pointer to a struct bpf_map. The function returns a pointer to the inner map if successful, or NULL on failure. Suitable for userspace programs leveraging map-in-map BPF functionality; error handling for a NULL return is necessary.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_map__inner_map.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n#!c struct bpf_map *bpf_map__inner_map(struct bpf_map *map);\n```\n\n----------------------------------------\n\nTITLE: Defining the perf_buffer_opts structure in C\nDESCRIPTION: This snippet defines the options structure used with perf_buffer__new. It contains fields for size, sample period, and includes a zero-width field for binary compatibility.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/perf_buffer__new.md#2025-04-22_snippet_1\n\nLANGUAGE: c\nCODE:\n```\nstruct perf_buffer_opts {\n\tsize_t sz;\n\t__u32 sample_period;\n\tsize_t :0;\n};\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_sk_fullsock Helper Function in C\nDESCRIPTION: This code snippet defines the 'bpf_sk_fullsock' helper function. It retrieves a struct bpf_sock pointer, allowing access to all fields in the bpf_sock structure. The function returns a struct bpf_sock pointer on success, or NULL on failure.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_sk_fullsock.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstatic struct bpf_sock *(* const bpf_sk_fullsock)(struct bpf_sock *sk) = (void *) 95;\n```\n\n----------------------------------------\n\nTITLE: Freeing Per-CPU Data with __percpu_kptr in eBPF Program\nDESCRIPTION: This eBPF program shows how to explicitly free allocated per-CPU data using __percpu_kptr, including exchange and drop operations.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/ebpf/__percpu_kptr.md#2025-04-22_snippet_5\n\nLANGUAGE: c\nCODE:\n```\nSEC(\"?fentry/bpf_fentry_test4\")\nint BPF_PROG(test_array_map_4)\n{\n\tstruct val_t __percpu_kptr *p;\n\tstruct elem *e;\n\tint index = 0;\n\n\te = bpf_map_lookup_elem(&array, &index);\n\tif (!e)\n\t\treturn 0;\n\n\t/* delete */\n\tp = bpf_kptr_xchg(&e->pc, NULL);\n\tif (p) {\n\t\tbpf_percpu_obj_drop(p);\n\t}\n\n\treturn 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_get_retval Helper Function in C\nDESCRIPTION: This snippet defines the 'bpf_get_retval' helper function for eBPF programs. It retrieves the BPF program's return value that will be returned to upper layers, currently supported by specific cgroup programs.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_get_retval.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstatic int (* const bpf_get_retval)(void) = (void *) 186;\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_load_hdr_opt Helper Function in C\nDESCRIPTION: This snippet defines the bpf_load_hdr_opt helper function for eBPF programs. It is used to load TCP header options, particularly in BPF_PROG_TYPE_SOCK_OPS programs. The function takes parameters for the socket operations structure, result buffer, length, and flags.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_load_hdr_opt.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstatic long (* const bpf_load_hdr_opt)(struct bpf_sock_ops *skops, void *searchby_res, __u32 len, __u64 flags) = (void *) 142;\n```\n\n----------------------------------------\n\nTITLE: Definition of bpf_lookup_system_key KFunc in C\nDESCRIPTION: Signature of the bpf_lookup_system_key kernel function that obtains a bpf_key structure with a key pointer set to the passed key ID. The function returns a pointer to a refcounted object that must be properly managed.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/bpf_lookup_system_key.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstruct bpf_key *bpf_lookup_system_key(u64 id)\n```\n\n----------------------------------------\n\nTITLE: Defining the bpf_btf_get_info_by_fd Function in C\nDESCRIPTION: This C code defines the `bpf_btf_get_info_by_fd` function from the libbpf library. It retrieves information about a BTF object associated with the given file descriptor `btf_fd`. The information is stored in the provided `info` struct, and the size of the written information is updated in `info_len`. The function requires the `btf_fd` (an integer file descriptor), `info` (a pointer to `struct bpf_btf_info`), and `info_len` (a pointer to a `__u32` holding the buffer size). It returns 0 on success and a negative error code on failure, setting `errno` accordingly.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_btf_get_info_by_fd.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n#!c int bpf_btf_get_info_by_fd(int btf_fd, struct bpf_btf_info *info, __u32 *info_len);\n```\n\n----------------------------------------\n\nTITLE: Redirecting Traffic with BPF_MAP_TYPE_XSKMAP in eBPF/XDP - C\nDESCRIPTION: This example demonstrates how to declare and use a BPF_MAP_TYPE_XSKMAP map within an XDP (eXpress Data Path) program in C. The xsks_map is defined as an array map storing file descriptors for XDP Sockets, with both key and value types set to 32-bit unsigned integers. The program uses the rx_queue_index from xdp_md as the key to look up entries in the map, and if present, redirects packets to userspace using bpf_redirect_map; otherwise, packets are passed on. Dependencies include Linux eBPF infrastructure, appropriate BPF helper functions, and a userspace-prepared set of AF_XDP sockets. Inputs are packets received on a network device, and the output is either packet redirection to userspace or allowing the packet to pass, depending on the map lookup result. Proper attributes and section macros are required for BPF map and program definitions.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/map-type/BPF_MAP_TYPE_XSKMAP.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstruct {\n    __uint(type, BPF_MAP_TYPE_XSKMAP);\n    __type(key, __u32);\n    __type(value, __u32);\n    __uint(max_entries, 64);\n} xsks_map SEC(\".maps\");\n\n\nSEC(\"xdp\")\nint xsk_redir_prog(struct xdp_md *ctx)\n{\n    __u32 index = ctx->rx_queue_index;\n\n    if (bpf_map_lookup_elem(&xsks_map, &index))\n            return bpf_redirect_map(&xsks_map, index, 0);\n    return XDP_PASS;\n}\n\n```\n\n----------------------------------------\n\nTITLE: Listing Supported eBPF KFuncs in Markdown\nDESCRIPTION: This code snippet uses Markdown syntax to create a collapsible section listing all supported eBPF kernel functions (KFuncs). Each function is linked to its corresponding documentation page.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/program-type/BPF_PROG_TYPE_CGROUP_SKB.md#2025-04-22_snippet_2\n\nLANGUAGE: markdown\nCODE:\n```\n??? abstract \"Supported kfuncs\"\n    - [`bpf_arena_alloc_pages`](../kfuncs/bpf_arena_alloc_pages.md)\n    - [`bpf_arena_free_pages`](../kfuncs/bpf_arena_free_pages.md)\n    - [`bpf_cast_to_kern_ctx`](../kfuncs/bpf_cast_to_kern_ctx.md)\n    - [`bpf_copy_from_user_str`](../kfuncs/bpf_copy_from_user_str.md)\n    - [`bpf_dynptr_adjust`](../kfuncs/bpf_dynptr_adjust.md)\n    - [`bpf_dynptr_clone`](../kfuncs/bpf_dynptr_clone.md)\n    - [`bpf_dynptr_from_skb`](../kfuncs/bpf_dynptr_from_skb.md)\n    - [`bpf_dynptr_is_null`](../kfuncs/bpf_dynptr_is_null.md)\n    - [`bpf_dynptr_is_rdonly`](../kfuncs/bpf_dynptr_is_rdonly.md)\n    - [`bpf_dynptr_size`](../kfuncs/bpf_dynptr_size.md)\n    - [`bpf_dynptr_slice`](../kfuncs/bpf_dynptr_slice.md)\n    - [`bpf_dynptr_slice_rdwr`](../kfuncs/bpf_dynptr_slice_rdwr.md)\n    - [`bpf_get_kmem_cache`](../kfuncs/bpf_get_kmem_cache.md)\n    - [`bpf_iter_bits_destroy`](../kfuncs/bpf_iter_bits_destroy.md)\n    - [`bpf_iter_bits_new`](../kfuncs/bpf_iter_bits_new.md)\n    - [`bpf_iter_bits_next`](../kfuncs/bpf_iter_bits_next.md)\n    - [`bpf_iter_css_destroy`](../kfuncs/bpf_iter_css_destroy.md)\n    - [`bpf_iter_css_new`](../kfuncs/bpf_iter_css_new.md)\n    - [`bpf_iter_css_next`](../kfuncs/bpf_iter_css_next.md)\n    - [`bpf_iter_css_task_destroy`](../kfuncs/bpf_iter_css_task_destroy.md)\n    - [`bpf_iter_css_task_new`](../kfuncs/bpf_iter_css_task_new.md)\n    - [`bpf_iter_css_task_next`](../kfuncs/bpf_iter_css_task_next.md)\n    - [`bpf_iter_kmem_cache_destroy`](../kfuncs/bpf_iter_kmem_cache_destroy.md)\n    - [`bpf_iter_kmem_cache_new`](../kfuncs/bpf_iter_kmem_cache_new.md)\n    - [`bpf_iter_kmem_cache_next`](../kfuncs/bpf_iter_kmem_cache_next.md)\n    - [`bpf_iter_num_destroy`](../kfuncs/bpf_iter_num_destroy.md)\n    - [`bpf_iter_num_new`](../kfuncs/bpf_iter_num_new.md)\n    - [`bpf_iter_num_next`](../kfuncs/bpf_iter_num_next.md)\n    - [`bpf_iter_task_destroy`](../kfuncs/bpf_iter_task_destroy.md)\n    - [`bpf_iter_task_new`](../kfuncs/bpf_iter_task_new.md)\n    - [`bpf_iter_task_next`](../kfuncs/bpf_iter_task_next.md)\n    - [`bpf_iter_task_vma_destroy`](../kfuncs/bpf_iter_task_vma_destroy.md)\n    - [`bpf_iter_task_vma_new`](../kfuncs/bpf_iter_task_vma_new.md)\n    - [`bpf_iter_task_vma_next`](../kfuncs/bpf_iter_task_vma_next.md)\n    - [`bpf_local_irq_restore`](../kfuncs/bpf_local_irq_restore.md)\n    - [`bpf_local_irq_save`](../kfuncs/bpf_local_irq_save.md)\n    - [`bpf_map_sum_elem_count`](../kfuncs/bpf_map_sum_elem_count.md)\n    - [`bpf_preempt_disable`](../kfuncs/bpf_preempt_disable.md)\n    - [`bpf_preempt_enable`](../kfuncs/bpf_preempt_enable.md)\n    - [`bpf_rcu_read_lock`](../kfuncs/bpf_rcu_read_lock.md)\n    - [`bpf_rcu_read_unlock`](../kfuncs/bpf_rcu_read_unlock.md)\n    - [`bpf_rdonly_cast`](../kfuncs/bpf_rdonly_cast.md)\n    - [`bpf_sock_addr_set_sun_path`](../kfuncs/bpf_sock_addr_set_sun_path.md)\n    - [`bpf_wq_init`](../kfuncs/bpf_wq_init.md)\n    - [`bpf_wq_set_callback_impl`](../kfuncs/bpf_wq_set_callback_impl.md)\n    - [`bpf_wq_start`](../kfuncs/bpf_wq_start.md)\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_tracepoint_opts struct in C\nDESCRIPTION: This snippet defines the bpf_tracepoint_opts struct used in the bpf_program__attach_tracepoint_opts function. It includes fields for the struct size and a custom user-provided value (bpf_cookie) that can be fetched through bpf_get_attach_cookie().\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_program__attach_tracepoint_opts.md#2025-04-22_snippet_1\n\nLANGUAGE: c\nCODE:\n```\nstruct bpf_tracepoint_opts {\n\t/* size of this struct, for forward/backward compatibility */\n\tsize_t sz;\n\t/* custom user-provided value fetchable through bpf_get_attach_cookie() */\n\t__u64 bpf_cookie;\n};\n```\n\n----------------------------------------\n\nTITLE: Definition of ring_buffer__epoll_fd Function in Libbpf\nDESCRIPTION: The function definition for ring_buffer__epoll_fd, which retrieves an epoll file descriptor from a ring buffer manager. This file descriptor can be used to sleep until data is available in any of the managed ring buffers.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/ring_buffer__epoll_fd.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nint ring_buffer__epoll_fd(const struct ring_buffer *rb);\n```\n\n----------------------------------------\n\nTITLE: Defining an eBPF Program for Socket Redirection in C\nDESCRIPTION: This C code defines an eBPF program attached to the `sk_skb/stream_verdict` hook. It inspects the local port (`skb->local_port`). If the port is 10000, it uses the `bpf_sk_redirect_map` helper to redirect the socket via the `sock_map_rx` map at index 0. Otherwise, it allows the packet to pass through normally (`SK_PASS`). This program requires a userspace loader to create and manage the `sock_map_rx`.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/program-type/BPF_PROG_TYPE_SK_SKB.md#2025-04-22_snippet_1\n\nLANGUAGE: c\nCODE:\n```\n// Copyright Red Hat\nSEC(\"sk_skb/stream_verdict\")\nint bpf_prog_verdict(struct __sk_buff *skb)\n{\n        __u32 lport = skb->local_port;\n        __u32 idx = 0;\n\n        if (lport == 10000)\n                return bpf_sk_redirect_map(skb, &sock_map_rx, idx, 0);\n\n        return SK_PASS;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_program__attach_usdt function in C\nDESCRIPTION: This snippet shows the function signature for bpf_program__attach_usdt, which is used to attach a BPF program to a USDT probe. It includes parameters for specifying the BPF program, target process, binary path, USDT provider, probe name, and attachment options.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_program__attach_usdt.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstruct bpf_link * bpf_program__attach_usdt(const struct bpf_program *prog, pid_t pid, const char *binary_path, const char *usdt_provider, const char *usdt_name, const struct bpf_usdt_opts *opts);\n```\n\n----------------------------------------\n\nTITLE: Updating BPF Link Map Functionality in C\nDESCRIPTION: The function `bpf_link__update_map` is used to swap out a `BPF_MAP_TYPE_STRUCT_OPS` map that is associated with a kernel BPF link. This function requires a pointer to the BPF link and a pointer to the BPF map, allowing users to update the map for dynamic operations within the kernel. The dependency for this snippet is the libbpf library, version 1.2.0 or higher.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_link__update_map.md#2025-04-22_snippet_0\n\nLANGUAGE: C\nCODE:\n```\n#!c int bpf_link__update_map(struct bpf_link *link, const struct bpf_map *map);\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_copy_from_user Helper Function in C\nDESCRIPTION: This code snippet defines the 'bpf_copy_from_user' helper function for eBPF programs. It reads bytes from user space and stores them in a destination buffer.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_copy_from_user.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstatic long (* const bpf_copy_from_user)(void *dst, __u32 size, const void *user_ptr) = (void *) 148;\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_tc_attach_point enum in C for TC hook attachment points\nDESCRIPTION: Definition of the bpf_tc_attach_point enum used to specify where to attach the TC hook. Options include ingress (incoming traffic), egress (outgoing traffic), or custom attachment points.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_tc_hook_create.md#2025-04-22_snippet_1\n\nLANGUAGE: c\nCODE:\n```\nenum bpf_tc_attach_point {\n\tBPF_TC_INGRESS = 1 << 0,\n\tBPF_TC_EGRESS  = 1 << 1,\n\tBPF_TC_CUSTOM  = 1 << 2,\n};\n```\n\n----------------------------------------\n\nTITLE: Defining tcp_dctcp_info Structure for DCTCP Congestion Control (C)\nDESCRIPTION: This struct records the current DCTCP algorithm state in TCP, including enablement, congestion experience state, running alpha estimate, and accumulated ECN/loss counters. Inputs: live statistics from DCTCP-enabled TCP sockets; outputs: fields for diagnostic tools or get_info queries. All types are unsigned integer variants.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/program-type/BPF_PROG_TYPE_STRUCT_OPS/tcp_congestion_ops.md#2025-04-22_snippet_10\n\nLANGUAGE: c\nCODE:\n```\nstruct tcp_dctcp_info {\n\t__u16\tdctcp_enabled;\n\t__u16\tdctcp_ce_state;\n\t__u32\tdctcp_alpha;\n\t__u32\tdctcp_ab_ecn;\n\t__u32\tdctcp_ab_tot;\n};\n```\n\n----------------------------------------\n\nTITLE: Defining the bpf_map__numa_node Function Signature in C\nDESCRIPTION: This C code snippet presents the function signature for `bpf_map__numa_node` from the libbpf library. It declares a function that accepts a constant pointer to a `bpf_map` structure as input and returns a `__u32` representing the NUMA node ID. This function is used to query the preferred or actual NUMA node for a given BPF map.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_map__numa_node.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n__u32 bpf_map__numa_node(const struct bpf_map *map);\n```\n\n----------------------------------------\n\nTITLE: Defining a USDT Tracepoint in C\nDESCRIPTION: Example of defining a USDT tracepoint in C using the SystemTap header. This snippet demonstrates creating a tracepoint with a provider name, tracepoint name, and two arguments that will be passed to tracers.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/concepts/usdt.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n#include <sys/sdt.h>\n\n// Some function called at some point in our program\nint somefunction(int8_t a, uint32_t b) {\n    DTRACE_PROBE2(\"my_provider\", \"somefunction-enter\", a, b);\n    // [...]\n}\n```\n\n----------------------------------------\n\nTITLE: Defining tcpvegas_info Structure for Vegas TCP Congestion Control (C)\nDESCRIPTION: This struct holds key monitored parameters of the Vegas congestion control implementation in TCP, intended for use in diagnostic or introspection interfaces. Each field is a 32-bit unsigned integer recording enablement, RTT count, last RTT sample, and minimum RTT. Input: measured Vegas algorithm state; output: struct fields populated as per connection state.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/program-type/BPF_PROG_TYPE_STRUCT_OPS/tcp_congestion_ops.md#2025-04-22_snippet_9\n\nLANGUAGE: c\nCODE:\n```\nstruct tcpvegas_info {\n\t__u32\ttcpv_enabled;\n\t__u32\ttcpv_rttcnt;\n\t__u32\ttcpv_rtt;\n\t__u32\ttcpv_minrtt;\n};\n```\n\n----------------------------------------\n\nTITLE: Defining BPF_PROBE_READ_STR_INTO Macro in C for eBPF Programs\nDESCRIPTION: The definition of the BPF_PROBE_READ_STR_INTO macro, introduced in libbpf v0.4.0. This macro is designed for string reading from kernel memory into user-provided storage using bpf_probe_read_kernel_str helper function. It's particularly useful for reading NUL-terminated strings.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/ebpf/BPF_PROBE_READ_STR_INTO.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n#define BPF_PROBE_READ_STR_INTO(dst, src, a, ...) ({\\n\\t___core_read(bpf_probe_read_kernel_str, bpf_probe_read_kernel,\\t    \\n\\t\\t     dst, (src), a, ##__VA_ARGS__)\\t\\t\\t    \\n})\n```\n\n----------------------------------------\n\nTITLE: Definition of bpf_dynptr_from_xdp KFunc in C\nDESCRIPTION: C function signature for the 'bpf_dynptr_from_xdp' kernel function that creates a dynamic pointer from an XDP buffer. The function takes an XDP metadata pointer, flags, and an uninitialized dynamic pointer structure.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/bpf_dynptr_from_xdp.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nint bpf_dynptr_from_xdp(struct xdp_md *x, u64 flags, struct bpf_dynptr *ptr__uninit)\n```\n\n----------------------------------------\n\nTITLE: Defining the bpf_iter_css_new kfunc in C\nDESCRIPTION: Function signature for the bpf_iter_css_new kfunc which initializes a cGroup iterator. It takes a pointer to the iterator struct, the starting cgroup subsystem state, and flags that control iteration behavior.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/bpf_iter_css_new.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nint bpf_iter_css_new(struct bpf_iter_css *it, struct cgroup_subsys_state *start, unsigned int flags)\n```\n\n----------------------------------------\n\nTITLE: Defining the sk_reuseport_md Context Structure in C\nDESCRIPTION: Defines the C structure 'struct sk_reuseport_md', which serves as the context argument for eBPF programs of type BPF_PROG_TYPE_SK_REUSEPORT. This structure provides read-only access to packet metadata, including data pointers (`data`, `data_end`), total packet length (`len`), protocol identifiers (`eth_protocol`, `ip_protocol`), binding status (`bind_inany`), a packet hash (`hash`), and pointers to relevant sockets for selection (`sk`) or migration (`migrating_sk`).\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/program-type/BPF_PROG_TYPE_SK_REUSEPORT.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstruct sk_reuseport_md {\n    /*\n    * Start of directly accessible data. It begins from\n    * the tcp/udp header.\n    */\n    __bpf_md_ptr(void *, data);\n    /* End of directly accessible data */\n    __bpf_md_ptr(void *, data_end);\n    /*\n    * Total length of packet (starting from the tcp/udp header).\n    * Note that the directly accessible bytes (data_end - data)\n    * could be less than this \"len\".  Those bytes could be\n    * indirectly read by a helper \"bpf_skb_load_bytes()\".\n    */\n    __u32 len;\n    /*\n    * Eth protocol in the mac header (network byte order). e.g.\n    * ETH_P_IP(0x0800) and ETH_P_IPV6(0x86DD)\n    */\n    __u32 eth_protocol;\n    __u32 ip_protocol;\t/* IP protocol. e.g. IPPROTO_TCP, IPPROTO_UDP */\n    __u32 bind_inany;\t/* Is sock bound to an INANY address? */\n    __u32 hash;\t\t/* A hash of the packet 4 tuples */\n    /* When reuse->migrating_sk is NULL, it is selecting a sk for the\n    * new incoming connection request (e.g. selecting a listen sk for\n    * the received SYN in the TCP case).  reuse->sk is one of the sk\n    * in the reuseport group. The bpf prog can use reuse->sk to learn\n    * the local listening ip/port without looking into the skb.\n    *\n    * When reuse->migrating_sk is not NULL, reuse->sk is closed and\n    * reuse->migrating_sk is the socket that needs to be migrated\n    * to another listening socket.  migrating_sk could be a fullsock\n    * sk that is fully established or a reqsk that is in-the-middle\n    * of 3-way handshake.\n    */\n    __bpf_md_ptr(struct bpf_sock *, sk);\n    __bpf_md_ptr(struct bpf_sock *, migrating_sk);\n};\n```\n\n----------------------------------------\n\nTITLE: Summarizing Per-CPU Data with __percpu_kptr in eBPF Program\nDESCRIPTION: This eBPF program demonstrates how to summarize per-CPU data using __percpu_kptr, including iterating over all CPUs and accumulating values.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/ebpf/__percpu_kptr.md#2025-04-22_snippet_4\n\nLANGUAGE: c\nCODE:\n```\nSEC(\"?fentry/bpf_fentry_test3\")\nint BPF_PROG(test_array_map_3)\n{\n\tstruct val_t __percpu_kptr *p;\n\tint i, index = 0;\n\tstruct val_t *v;\n\tstruct elem *e;\n\n\tif ((bpf_get_current_pid_tgid() >> 32) != my_pid)\n\t\treturn 0;\n\n\te = bpf_map_lookup_elem(&array, &index);\n\tif (!e)\n\t\treturn 0;\n\n\tp = e->pc;\n\tif (!p)\n\t\treturn 0;\n\n\tbpf_for(i, 0, nr_cpus) {\n\t\tv = bpf_per_cpu_ptr(p, i);\n\t\tif (v) {\n\t\t\tif (i == 0)\n\t\t\t\tcpu0_field_d = v->d;\n\t\t\tsum_field_c += v->c;\n\t\t}\n\t}\n\n\treturn 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_skb_set_tstamp Helper Function in C\nDESCRIPTION: This code snippet defines the bpf_skb_set_tstamp helper function for eBPF programs. It allows changing the timestamp type and value for network packets. The function takes a pointer to __sk_buff, a 64-bit timestamp value, and a 32-bit timestamp type as parameters.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_skb_set_tstamp.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstatic long (* const bpf_skb_set_tstamp)(struct __sk_buff *skb, __u64 tstamp, __u32 tstamp_type) = (void *) 192;\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_get_func_arg Helper Function in C\nDESCRIPTION: Function prototype for the bpf_get_func_arg helper that retrieves the n-th argument register of a traced function. Returns 0 on success or -EINVAL if n is invalid.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_get_func_arg.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstatic long (* const bpf_get_func_arg)(void *ctx, __u32 n, __u64 *value) = (void *) 183;\n```\n\n----------------------------------------\n\nTITLE: Function Definition - bpf_iter_task_vma_next\nDESCRIPTION: Kernel function definition for bpf_iter_task_vma_next that returns a pointer to the next virtual memory area structure from the iterator. The returned pointer may be NULL and requires validation before use.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/bpf_iter_task_vma_next.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstruct vm_area_struct *bpf_iter_task_vma_next(struct bpf_iter_task_vma *it)\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_seq_write Helper Function in C\nDESCRIPTION: This code snippet defines the bpf_seq_write helper function for eBPF. It uses seq_file seq_write() to write data. The function takes a seq_file pointer, data pointer, and length as parameters. It returns 0 on success or a negative error code on failure.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_seq_write.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstatic long (* const bpf_seq_write)(struct seq_file *m, const void *data, __u32 len) = (void *) 127;\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_iter_link_info for iter_info\nDESCRIPTION: A C structure union bpf_iter_link_info used within the iter_info field of the bpf_attr structure. It holds parameters essential for iterating over various kernel objects in eBPF programs, specifying fields necessary to attach BPF programs to iterables like maps, cgroups, and tasks. Dependencies include the Linux kernel headers and a working knowledge of eBPF iterators.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/syscall/BPF_LINK_CREATE.md#2025-04-22_snippet_1\n\nLANGUAGE: c\nCODE:\n```\nunion bpf_iter_link_info {\n\tstruct {\n\t\t__u32\tmap_fd;\n\t} map;\n\tstruct {\n\t\tenum bpf_cgroup_iter_order order;\n\n\t\t/* At most one of cgroup_fd and cgroup_id can be non-zero. If\n\t\t * both are zero, the walk starts from the default cgroup v2\n\t\t * root. For walking v1 hierarchy, one should always explicitly\n\t\t * specify cgroup_fd.\n\t\t */\n\t\t__u32\tcgroup_fd;\n\t\t__u64\tcgroup_id;\n\t} cgroup;\n\t/* Parameters of task iterators. */\n\tstruct {\n\t\t__u32\ttid;\n\t\t__u32\tpid;\n\t\t__u32\tpid_fd;\n\t} task;\n};\n```\n\n----------------------------------------\n\nTITLE: Defining the bbr_main KFunc Signature (Prior to v6.10)\nDESCRIPTION: Defines the previous signature of the eBPF kfunc 'bbr_main' used before Linux kernel v6.10 (introduced in v5.13). This version notified the BBR algorithm taking only the socket structure and rate sample as parameters. The documentation notes that weak ELF symbols can be used to support both this older signature and the newer one introduced in v6.10.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/bbr_main.md#2025-04-22_snippet_1\n\nLANGUAGE: c\nCODE:\n```\n`#!c void bbr_main(struct sock *sk, const struct rate_sample *rs)`\n```\n\n----------------------------------------\n\nTITLE: Definition of bpf_program__insn_cnt Function in Libbpf\nDESCRIPTION: The C function signature for bpf_program__insn_cnt which returns the number of struct bpf_insn instructions that make up a BPF program. It takes a const pointer to a bpf_program struct as its parameter and returns a size_t value.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_program__insn_cnt.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nsize_t bpf_program__insn_cnt(const struct bpf_program *prog);\n```\n\n----------------------------------------\n\nTITLE: Detaching BPF Link using Libbpf in C\nDESCRIPTION: This C snippet demonstrates the function signature for detaching a BPF link in userspace using the Libbpf library. The function 'bpf_link__detach' receives a pointer to a 'struct bpf_link' and requests the kernel to detach it. The function does not delete any BPF object pins or free associated user resources. Dependency: Libbpf library should be available and initialized. The key parameter is 'link', representing the link to be detached. Returns an integer status, typically zero on success. Limitations: Resource and pin management are left to the caller.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_link__detach.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nint bpf_link__detach(struct bpf_link *link);\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_map_lookup_batch Function Signature in C\nDESCRIPTION: Function signature for bpf_map_lookup_batch that enables batch lookup of BPF map elements. Takes parameters for map file descriptor, batch control pointers, key/value arrays, count, and options.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_map_lookup_batch.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nint bpf_map_lookup_batch(int fd, void *in_batch, void *out_batch, void *keys, void *values, __u32 *count, const struct bpf_map_batch_opts *opts);\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_task_from_pid KFunc in C\nDESCRIPTION: Function signature for the bpf_task_from_pid kernel function that returns a pointer to task_struct for a given PID. The function returns a refcounted object that must be either stored in a map or released using bpf_task_release().\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/bpf_task_from_pid.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstruct task_struct *bpf_task_from_pid(s32 pid)\n```\n\n----------------------------------------\n\nTITLE: BPF_F_TOKEN_FD Flag Documentation\nDESCRIPTION: Documents the BPF_F_TOKEN_FD flag (introduced in v6.9) which uses a BPF token in prog_token_fd to authorize the creation of a map instead of checking the capabilities of the current user.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/syscall/BPF_PROG_LOAD.md#2025-04-22_snippet_10\n\nLANGUAGE: markdown\nCODE:\n```\n### `BPF_F_TOKEN_FD`\n\n<!-- [FEATURE_TAG](BPF_F_TOKEN_FD) -->\n[:octicons-tag-24: v6.9](https://github.com/torvalds/linux/commit/a177fc2bf6fd83704854feaf7aae926b1df4f0b9)\n<!-- [/FEATURE_TAG] -->\n\nWhen set, the kernel will use the BPF token in [`prog_token_fd`](#prog_token_fd) to authorize the creation of the map instead of checking the capabilities of the current user.\n```\n\n----------------------------------------\n\nTITLE: Definition of bpf_list_pop_front KFunc in C\nDESCRIPTION: The signature for the bpf_list_pop_front kernel function that removes the entry at the beginning of a BPF linked list. It returns a pointer to the removed node's bpf_list_node or NULL if the list is empty.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/bpf_list_pop_front.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstruct bpf_list_node *bpf_list_pop_front(struct bpf_list_head *head)\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_list_pop_back KFunc in C\nDESCRIPTION: Function signature and definition for the bpf_list_pop_back kernel function. Returns a pointer to the bpf_list_node of the deleted entry from the end of the list, or NULL if the list is empty. The returned pointer is refcounted and must be properly released.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/bpf_list_pop_back.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstruct bpf_list_node *bpf_list_pop_back(struct bpf_list_head *head)\n```\n\n----------------------------------------\n\nTITLE: Check CPU Mask Overlap with eBPF in C\nDESCRIPTION: The 'bpf_cpumask_intersects' function determines if two CPU mask structures have any overlapping bits, returning true if they do. It requires two 'cpumask' structure pointers as inputs and outputs a boolean value. This function can be used in BPF program types like LSM, PERF_EVENT, STRUCT_OPS, TRACEPOINT, and TRACING.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/bpf_cpumask_intersects.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n#!c bool bpf_cpumask_intersects(const struct cpumask *src1, const struct cpumask *src2)\n```\n\n----------------------------------------\n\nTITLE: Documenting libbpf Function 'bpf_map__set_max_entries' in C\nDESCRIPTION: The purpose of this function is to set the maximum number of entries that a BPF map can hold. It requires a pointer to the BPF map and the maximum entries as parameters. It returns 0 on success or a negative value on failure. This setting must be applied before the map is loaded; otherwise, it cannot be modified.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_map__set_max_entries.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nint bpf_map__set_max_entries(struct bpf_map *map, __u32 max_entries);\n```\n\n----------------------------------------\n\nTITLE: Defining and Using __kptr_untrusted Macro in BPF Programs\nDESCRIPTION: This example demonstrates how to use the __kptr_untrusted macro to tag a pointer in a map value structure. The program uses BPF maps, task structure access, and kernel function hooking to demonstrate the proper tagging of untrusted kernel pointers. It includes two BPF programs attached to fentry hooks that interact with a LRU hash map.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/ebpf/__kptr_untrusted.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n// SPDX-License-Identifier: GPL-2.0\n#include <vmlinux.h>\n#include <bpf/bpf_tracing.h>\n#include <bpf/bpf_helpers.h>\n\nstruct map_value {\n\tstruct task_struct __kptr_untrusted *ptr;\n};\n\nstruct {\n\t__uint(type, BPF_MAP_TYPE_LRU_HASH);\n\t__uint(max_entries, 1);\n\t__type(key, int);\n\t__type(value, struct map_value);\n} lru_map SEC(\".maps\");\n\nint pid = 0;\nint result = 1;\n\nSEC(\"fentry/bpf_ktime_get_ns\")\nint printk(void *ctx)\n{\n\tstruct map_value v = {};\n\n\tif (pid == bpf_get_current_task_btf()->pid)\n\t\tbpf_map_update_elem(&lru_map, &(int){0}, &v, 0);\n\treturn 0;\n}\n\nSEC(\"fentry/do_nanosleep\")\nint nanosleep(void *ctx)\n{\n\tstruct map_value val = {}, *v;\n\tstruct task_struct *current;\n\n\tbpf_map_update_elem(&lru_map, &(int){0}, &val, 0);\n\tv = bpf_map_lookup_elem(&lru_map, &(int){0});\n\tif (!v)\n\t\treturn 0;\n\tbpf_map_delete_elem(&lru_map, &(int){0});\n\tcurrent = bpf_get_current_task_btf();\n\tv->ptr = current;\n\tpid = current->pid;\n\tbpf_ktime_get_ns();\n\tresult = !v->ptr;\n\treturn 0;\n}\n\nchar _license[] SEC(\"license\") = \"GPL\";\n\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_inode_storage_delete Helper Function in C\nDESCRIPTION: Function definition for the bpf_inode_storage_delete helper that deletes bpf_local_storage from an inode. Returns 0 on success and -ENOENT if the storage cannot be found.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_inode_storage_delete.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstatic int (* const bpf_inode_storage_delete)(void *map, void *inode) = (void *) 146;\n```\n\n----------------------------------------\n\nTITLE: Defining the bpf_uprobe_multi_opts Structure in C\nDESCRIPTION: Structure definition for bpf_uprobe_multi_opts which specifies options for the bpf_program__attach_uprobe_multi function. It includes fields for function symbols, offsets, reference counter offsets, cookies, and flags for controlling the behavior of uprobes.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_program__attach_uprobe_multi.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstruct bpf_uprobe_multi_opts {\n\t/* size of this struct, for forward/backward compatibility */\n\tsize_t sz;\n\t/* array of function symbols to attach to */\n\tconst char **syms;\n\t/* array of function addresses to attach to */\n\tconst unsigned long *offsets;\n\t/* optional, array of associated ref counter offsets */\n\tconst unsigned long *ref_ctr_offsets;\n\t/* optional, array of associated BPF cookies */\n\tconst __u64 *cookies;\n\t/* number of elements in syms/addrs/cookies arrays */\n\tsize_t cnt;\n\t/* create return uprobes */\n\tbool retprobe;\n\t/* create session kprobes */\n\tbool session;\n\tsize_t :0;\n};\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_sock Structure in C for cGroup Socket Programs\nDESCRIPTION: C structure definition for the bpf_sock context used in cGroup socket programs. This structure contains fields for socket attributes like bound device, family, type, protocol, mark, priority, and IP addresses.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/program-type/BPF_PROG_TYPE_CGROUP_SOCK.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstruct bpf_sock {\n    __u32 bound_dev_if;\n    __u32 family;\n    __u32 type;\n    __u32 protocol;\n    __u32 mark;\n    __u32 priority;\n    /* IP address also allows 1 and 2 bytes access */\n    __u32 src_ip4;\n    __u32 src_ip6[4];\n    __u32 src_port;\t\t/* host byte order */\n    __be16 dst_port;\t/* network byte order */\n    __u16 :16;\t\t/* zero padding */\n    __u32 dst_ip4;\n    __u32 dst_ip6[4];\n    __u32 state;\n    __s32 rx_queue_mapping;\n};\n```\n\n----------------------------------------\n\nTITLE: Defining the bpf_prog_query_opts struct in C\nDESCRIPTION: This structure defines the configuration options for querying BPF programs and links. It includes fields for flags, program IDs, counts, link IDs, and attachment flags. The struct is passed as a parameter to the bpf_prog_query_opts function.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_prog_query_opts.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstruct bpf_prog_query_opts {\n\tsize_t sz; /* size of this struct for forward/backward compatibility */\n\t__u32 query_flags;\n\t__u32 attach_flags; /* output argument */\n\t__u32 *prog_ids;\n\tunion {\n\t\t/* input+output argument */\n\t\t__u32 prog_cnt;\n\t\t__u32 count;\n\t};\n\t__u32 *prog_attach_flags;\n\t__u32 *link_ids;\n\t__u32 *link_attach_flags;\n\t__u64 revision;\n\tsize_t :0;\n};\n```\n\n----------------------------------------\n\nTITLE: Using Repeat Macro in eBPF\nDESCRIPTION: Demonstrates the bpf_repeat macro for simple repeated iterations, incrementing and printing a counter 5 times.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/bpf_iter_num_new.md#2025-04-22_snippet_2\n\nLANGUAGE: c\nCODE:\n```\nint i = 0;\nbpf_repeat(5) {\n    bpf_printk(\"X = %d\", i);\n    i++;\n}\n```\n\n----------------------------------------\n\nTITLE: Disabling RTO Callback Using bpf_sock_ops_cb_flags_set in C\nDESCRIPTION: This code snippet demonstrates how to use the bpf_sock_ops_cb_flags_set function to disable the RTO (Retransmission Timeout) callback by clearing the appropriate flag.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_sock_ops_cb_flags_set.md#2025-04-22_snippet_1\n\nLANGUAGE: c\nCODE:\n```\nbpf_sock_ops_cb_flags_set(bpf_sock,\n    bpf_sock->bpf_sock_ops_cb_flags & ~BPF_SOCK_OPS_RTO_CB_FLAG)\n```\n\n----------------------------------------\n\nTITLE: Defining tcp_cc_info Union for Transporting Algorithm-Specific TCP Info (C)\nDESCRIPTION: This union groups structs carrying congestion algorithm-specific state information, selected by the diagnostic enum parameter in the get_info function. Fields are per-algorithm, with the appropriate struct to be populated determined by the INET_DIAG_* code in the request. Dependencies: tcpvegas_info, tcp_dctcp_info, tcp_bbr_info. Used by introspection tools and other kernel components referencing detailed algorithm state.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/program-type/BPF_PROG_TYPE_STRUCT_OPS/tcp_congestion_ops.md#2025-04-22_snippet_8\n\nLANGUAGE: c\nCODE:\n```\nunion tcp_cc_info {\n\tstruct tcpvegas_info\tvegas;\n\tstruct tcp_dctcp_info\tdctcp;\n\tstruct tcp_bbr_info\t\tbbr;\n};\n```\n\n----------------------------------------\n\nTITLE: Function Signature for bpf_local_irq_save in C\nDESCRIPTION: The C function signature for the bpf_local_irq_save kfunc. It takes a pointer to a 64-bit unsigned integer where the current IRQ state will be saved.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/bpf_local_irq_save.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nvoid bpf_local_irq_save(long unsigned int *flags__irq_flag)\n```\n\n----------------------------------------\n\nTITLE: Definition of bpf_iter_css_next KFunc in C\nDESCRIPTION: C function signature for the bpf_iter_css_next kernel function that returns the next cgroup_subsys_state in an iteration. The function takes a bpf_iter_css pointer and returns a potentially NULL pointer that must be checked before use.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/bpf_iter_css_next.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstruct cgroup_subsys_state *bpf_iter_css_next(struct bpf_iter_css *it)\n```\n\n----------------------------------------\n\nTITLE: Netfilter Packet Fragmentation Handling Example in C\nDESCRIPTION: Demonstrates an eBPF program using BPF_PROG_TYPE_NETFILTER to check and drop fragmented packets for both IPv4 and IPv6. Utilizes the bpf_dynptr_from_skb function to access packet data and employ helper functions to determine packet fragmentation, thereby deciding whether to accept or drop the packet.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/program-type/BPF_PROG_TYPE_NETFILTER.md#2025-04-22_snippet_3\n\nLANGUAGE: c\nCODE:\n```\n// SPDX-License-Identifier: GPL-2.0-only\n#include \"vmlinux.h\"\n#include <bpf/bpf_helpers.h>\n#include <bpf/bpf_endian.h>\n#include \"bpf_tracing_net.h\"\n\n#define NF_DROP\t\t0\n#define NF_ACCEPT\t\t1\n#define ETH_P_IP\t\t0x0800\n#define ETH_P_IPV6\t\t0x86DD\n#define IP_MF\t\t0x2000\n#define IP_OFFSET\t\t0x1FFF\n#define NEXTHDR_FRAGMENT\t44\n\nextern int bpf_dynptr_from_skb(struct __sk_buff *skb, __u64 flags,\n\t\t\t      struct bpf_dynptr *ptr__uninit) __ksym;\nextern void *bpf_dynptr_slice(const struct bpf_dynptr *ptr, uint32_t offset,\n\t\t\t      void *buffer, uint32_t buffer__sz) __ksym;\n\nvolatile int shootdowns = 0;\n\nstatic bool is_frag_v4(struct iphdr *iph)\n{\n\tint offset;\n\tint flags;\n\n\toffset = bpf_ntohs(iph->frag_off);\n\tflags = offset & ~IP_OFFSET;\n\toffset &= IP_OFFSET;\n\toffset <<= 3;\n\n\treturn (flags & IP_MF) || offset;\n}\n\nstatic bool is_frag_v6(struct ipv6hdr *ip6h)\n{\n\t/* Simplifying assumption that there are no extension headers\n\t * between fixed header and fragmentation header. This assumption\n\t * is only valid in this test case. It saves us the hassle of\n\t * searching all potential extension headers.\n\t */\n\treturn ip6h->nexthdr == NEXTHDR_FRAGMENT;\n}\n\nstatic int handle_v4(struct __sk_buff *skb)\n{\n\tstruct bpf_dynptr ptr;\n\tu8 iph_buf[20] = {};\n\tstruct iphdr *iph;\n\n\tif (bpf_dynptr_from_skb(skb, 0, &ptr))\n\t\treturn NF_DROP;\n\n\tiph = bpf_dynptr_slice(&ptr, 0, iph_buf, sizeof(iph_buf));\n\tif (!iph)\n\t\treturn NF_DROP;\n\n\t/* Shootdown any frags */\n\tif (is_frag_v4(iph)) {\n\t\tshootdowns++;\n\t\treturn NF_DROP;\n\t}\n\n\treturn NF_ACCEPT;\n}\n\nstatic int handle_v6(struct __sk_buff *skb)\n{\n\tstruct bpf_dynptr ptr;\n\tstruct ipv6hdr *ip6h;\n\tu8 ip6h_buf[40] = {};\n\n\tif (bpf_dynptr_from_skb(skb, 0, &ptr))\n\t\treturn NF_DROP;\n\n\tip6h = bpf_dynptr_slice(&ptr, 0, ip6h_buf, sizeof(ip6h_buf));\n\tif (!ip6h)\n\t\treturn NF_DROP;\n\n\t/* Shootdown any frags */\n\tif (is_frag_v6(ip6h)) {\n\t\tshootdowns++;\n\t\treturn NF_DROP;\n\t}\n\n\treturn NF_ACCEPT;\n}\n\nSEC(\"netfilter\")\nint defrag(struct bpf_nf_ctx *ctx)\n{\n\tstruct __sk_buff *skb = (struct __sk_buff *)ctx->skb;\n\n\tswitch (bpf_ntohs(ctx->skb->protocol)) {\n\tcase ETH_P_IP:\n\t\treturn handle_v4(skb);\n\tcase ETH_P_IPV6:\n\t\treturn handle_v6(skb);\n\tdefault:\n\t\treturn NF_ACCEPT;\n\t}\n}\n\nchar _license[] SEC(\"license\") = \"GPL\";\n```\n\n----------------------------------------\n\nTITLE: Querying BPF Map Type via Libbpf in C\nDESCRIPTION: Defines the signature for the 'bpf_map__type' function, which returns the type of a specified BPF map using the libbpf library. It requires the inclusion of libbpf and Linux BPF headers, and the function accepts a pointer to a BPF map structure as an argument. The function returns an enum value representing the map's type, enabling callers to determine the nature of the map (such as hash, array, etc.). 'map' must be a valid pointer to a previously created or loaded BPF map. Proper error handling depends on usage context.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_map__type.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nenum bpf_map_type bpf_map__type(const struct bpf_map *map);\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_skb_vlan_push Helper Function in C\nDESCRIPTION: This code snippet defines the 'bpf_skb_vlan_push' helper function for eBPF. It takes a socket buffer, VLAN protocol, and VLAN tag control information as parameters. The function pushes VLAN information to the packet and updates the checksum.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_skb_vlan_push.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstatic long (* const bpf_skb_vlan_push)(struct __sk_buff *skb, __be16 vlan_proto, __u16 vlan_tci) = (void *) 18;\n```\n\n----------------------------------------\n\nTITLE: Defining the eBPF KFunc in C\nDESCRIPTION: The 'bpf_cpumask_clear_cpu' function clears a bit corresponding to a CPU in a BPF CPU-mask. The function accepts a CPU identifier and a pointer to a BPF CPU-mask structure as parameters. No direct outputs are produced, but the function modifies the provided CPU-mask. Requires familiarity with eBPF and BPF CPU-masks.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/bpf_cpumask_clear_cpu.md#2025-04-22_snippet_0\n\nLANGUAGE: C\nCODE:\n```\n#!c void bpf_cpumask_clear_cpu(u32 cpu, struct bpf_cpumask *cpumask)\n```\n\n----------------------------------------\n\nTITLE: Defining the bpf_map__set_type Function Signature in C\nDESCRIPTION: This C code snippet shows the function signature for `bpf_map__set_type` from the libbpf library. It is used to set the intended type for a BPF map represented by the `struct bpf_map` pointer before the map is created in the kernel. The `type` parameter specifies the desired map type using the `enum bpf_map_type`. The function returns 0 on success and a negative error code upon failure. Requires `libbpf` headers.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_map__set_type.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nint bpf_map__set_type(struct bpf_map *map, enum bpf_map_type type);\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_lwt_seg6_action helper function in C\nDESCRIPTION: This code snippet defines the bpf_lwt_seg6_action helper function for eBPF programs. It takes a packet buffer, an action type, a parameter, and the parameter length as inputs. The function applies IPv6 Segment Routing actions to the packet.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_lwt_seg6_action.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstatic long (* const bpf_lwt_seg6_action)(struct __sk_buff *skb, __u32 action, void *param, __u32 param_len) = (void *) 76;\n```\n\n----------------------------------------\n\nTITLE: Defining SCX Dump Context in C\nDESCRIPTION: Structure that provides informational context for dump operations in the scheduler extension. Contains details about the exit reason, code, timestamp, and descriptive text.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/program-type/BPF_PROG_TYPE_STRUCT_OPS/sched_ext_ops.md#2025-04-22_snippet_57\n\nLANGUAGE: c\nCODE:\n```\nstruct scx_dump_ctx {\n\t[enum scx_exit_kind](#enum-scx_exit_kind)  kind;\n\ts64                 exit_code;\n\tconst char         *reason;\n\tu64                 at_ns;\n\tu64                 at_jiffies;\n};\n```\n\n----------------------------------------\n\nTITLE: Declaring bbr_ssthresh eBPF KFunc in C\nDESCRIPTION: This snippet defines the C function signature for the eBPF kernel function 'bbr_ssthresh'. It takes a pointer to struct sock as input and returns a 32-bit unsigned integer representing the slow start threshold (ssthresh). The function is invoked when entering loss recovery to save the congestion window for later restoration. Dependency includes struct sock (defined in kernel networking headers) and an appropriate eBPF program type such as BPF_PROG_TYPE_STRUCT_OPS. Intended for use within eBPF programs that implement transport behavior, with expected output as the ssthresh value in recovery phase.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/bbr_ssthresh.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nu32 bbr_ssthresh(struct sock *sk)\n```\n\n----------------------------------------\n\nTITLE: Defining the bpf_link__pin Function in C\nDESCRIPTION: This C code snippet presents the function signature for `bpf_link__pin` from the libbpf library. It takes a pointer to a `bpf_link` structure (`link`), which must already be loaded, and a constant character pointer representing the file path (`path`) within a BPF file system (BPFFS). The function's purpose is to pin the specified BPF link to the given path, which increments the link's reference count. It returns 0 on successful pinning and a negative error code otherwise.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_link__pin.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nint bpf_link__pin(struct bpf_link *link, const char *path);\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_map_delete_batch Function in C\nDESCRIPTION: This C function allows the batch deletion of multiple elements from a BPF map. It requires the map file descriptor, a pointer to keys, a count of elements, and optional batch operation settings. The function returns 0 on success or a negative error code. Errors can update the 'errno'.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_map_delete_batch.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n#int bpf_map_delete_batch(int fd, const void *keys, __u32 *count, const struct bpf_map_batch_opts *opts);\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_object__find_map_by_name Function Signature in C\nDESCRIPTION: Function signature for bpf_object__find_map_by_name that takes a BPF object pointer and map name as parameters and returns a pointer to the found BPF map structure. Returns NULL if the map is not found.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_object__find_map_by_name.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstruct bpf_map * bpf_object__find_map_by_name(const struct bpf_object *obj, const char *name);\n```\n\n----------------------------------------\n\nTITLE: Defining scx_bpf_dsq_move_to_local KFunc Signature in C\nDESCRIPTION: Function signature for the scx_bpf_dsq_move_to_local kernel function. Takes a DSQ ID as parameter and returns a boolean indicating if a task was moved successfully.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/scx_bpf_dsq_move_to_local.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nbool scx_bpf_dsq_move_to_local(u64 dsq_id)\n```\n\n----------------------------------------\n\nTITLE: CGroup Move Commit Callback Definition in C\nDESCRIPTION: Callback function signature for committing task movement between cgroups. Takes task struct and source/destination cgroups as parameters.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/program-type/BPF_PROG_TYPE_STRUCT_OPS/sched_ext_ops.md#2025-04-22_snippet_33\n\nLANGUAGE: c\nCODE:\n```\nvoid (*cgroup_move)(struct task_struct *p, struct cgroup *from, struct cgroup *to);\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_object__prev_program function in C\nDESCRIPTION: This code snippet defines the 'bpf_object__prev_program' function from the libbpf library. It takes a BPF object and a current program as parameters, and returns the previous program in the object or NULL if there are no more programs.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_object__prev_program.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstruct bpf_program * bpf_object__prev_program(const struct bpf_object *obj, struct bpf_program *prog);\n```\n\n----------------------------------------\n\nTITLE: Defining scx_bpf_get_online_cpumask KFunc in C\nDESCRIPTION: This code snippet defines the signature of the scx_bpf_get_online_cpumask kfunc. It returns a pointer to the cpumask structure representing online CPUs. The function is designed to work with refcounted objects, requiring proper release or transfer of the returned pointer.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/scx_bpf_get_online_cpumask.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nconst struct cpumask *scx_bpf_get_online_cpumask()\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_dynptr_data eBPF Helper Function in C\nDESCRIPTION: This code snippet defines the 'bpf_dynptr_data' eBPF helper function. It returns a pointer to the underlying dynptr data, with specific conditions for validity and usage.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_dynptr_data.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstatic void *(* const bpf_dynptr_data)(const struct bpf_dynptr *ptr, __u32 offset, __u32 len) = (void *) 203;\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_msg_pop_data Helper Function in C\nDESCRIPTION: This code snippet defines the 'bpf_msg_pop_data' eBPF helper function. It removes a specified number of bytes from a message starting at a given position. The function may return ENOMEM errors in certain situations and can fail if input parameters are invalid.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_msg_pop_data.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstatic long (* const bpf_msg_pop_data)(struct sk_msg_md *msg, __u32 start, __u32 len, __u64 flags) = (void *) 91;\n```\n\n----------------------------------------\n\nTITLE: Defining a struct_ops Implementation in C for eBPF\nDESCRIPTION: This C code snippet demonstrates how a user defines an instance of a kernel `struct_ops` (specifically `tcp_congestion_ops`) within a special ELF section named `.struct_ops`. Function pointer fields like `.init` and `.set_state` are assigned to eBPF programs (represented here by C function names like `dctcp_init`). This struct definition is processed by the eBPF loader to attach the BPF programs to kernel hooks, enabling functionalities like custom TCP congestion control.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/program-type/BPF_PROG_TYPE_STRUCT_OPS.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n/* Copyright (c) 2019 Facebook */\n\nSEC(\".struct_ops\")\nstruct tcp_congestion_ops dctcp_nouse = {\n\t.init\t\t= (void *)dctcp_init,\n\t.set_state\t= (void *)dctcp_state,\n\t.flags\t\t= TCP_CONG_NEEDS_ECN,\n\t.name\t\t= \"bpf_dctcp_nouse\",\n};\n```\n\n----------------------------------------\n\nTITLE: Definition of bpf_put_file KFunc in C\nDESCRIPTION: The signature of the bpf_put_file kernel function that puts a reference on the supplied file. This function accepts a file pointer and has no return value. It releases the pointer passed to it, invalidating all copies of the pointer.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/bpf_put_file.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nvoid bpf_put_file(struct file *file)\n```\n\n----------------------------------------\n\nTITLE: Definition of bpf_get_task_exe_file kernel function in C\nDESCRIPTION: Function signature for the bpf_get_task_exe_file kfunc that returns a referenced struct file pointer to the exe_file member of a task's mm_struct. The function requires proper resource management, with references needing to be released using bpf_put_file.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/bpf_get_task_exe_file.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstruct file *bpf_get_task_exe_file(struct task_struct *task)\n```\n\n----------------------------------------\n\nTITLE: Defining SCX Enqueue Flags Enumeration in C\nDESCRIPTION: Defines the enum scx_enq_flags which specifies flags used during task enqueuing operations. These flags control wakeup behavior, queue position, preemption, and other enqueue-related behaviors.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/program-type/BPF_PROG_TYPE_STRUCT_OPS/sched_ext_ops.md#2025-04-22_snippet_40\n\nLANGUAGE: c\nCODE:\n```\nenum scx_enq_flags {\n    SCX_ENQ_WAKEUP          = 1LLU << 0,\n    SCX_ENQ_HEAD            = 1LLU << 4,\n    SCX_ENQ_CPU_SELECTED    = 1LLU << 10,\n    SCX_ENQ_PREEMPT         = 1LLU << 32,\n    SCX_ENQ_REENQ           = 1LLU << 40,\n    SCX_ENQ_LAST            = 1LLU << 41,\n    SCX_ENQ_CLEAR_OPSS      = 1LLU << 56,\n    SCX_ENQ_DSQ_PRIQ        = 1LLU << 57,\n};\n```\n\n----------------------------------------\n\nTITLE: Dumping TCP Socket Statistics Periodically using eBPF sockops in C\nDESCRIPTION: This eBPF C program uses the `sockops` hook to periodically dump TCP statistics for connections. It leverages a BPF map of type `BPF_MAP_TYPE_SK_STORAGE` (`bpf_next_dump`) to maintain per-socket state (the next dump timestamp). The program enables RTT callbacks (`BPF_SOCK_OPS_RTT_CB_FLAG`) during connection setup. On RTT callbacks, it checks if the specified interval has elapsed using `bpf_ktime_get_ns`, retrieves TCP socket details with `bpf_tcp_sock`, prints statistics like `dsack_dups` and `delivered` via `bpf_printk`, and updates the timestamp in the socket storage map.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/program-type/BPF_PROG_TYPE_SOCK_OPS.md#2025-04-22_snippet_4\n\nLANGUAGE: c\nCODE:\n```\n#define INTERVAL\t\t\t1000000000ULL\n\nint _version SEC(\"version\") = 1;\nchar _license[] SEC(\"license\") = \"GPL\";\n\nstruct {\n    __u32 type;\n    __u32 map_flags;\n    int *key;\n    __u64 *value;\n} bpf_next_dump SEC(\".maps\") = {\n    .type = BPF_MAP_TYPE_SK_STORAGE,\n    .map_flags = BPF_F_NO_PREALLOC,\n};\n\nSEC(\"sockops\")\nint _sockops(struct bpf_sock_ops *ctx)\n{\n    struct bpf_tcp_sock *tcp_sk;\n    struct bpf_sock *sk;\n    __u64 *next_dump;\n    __u64 now;\n\n    switch (ctx->op) {\n    case BPF_SOCK_OPS_TCP_CONNECT_CB:\n        bpf_sock_ops_cb_flags_set(ctx, BPF_SOCK_OPS_RTT_CB_FLAG);\n        return 1;\n    case BPF_SOCK_OPS_RTT_CB:\n        break;\n    default:\n        return 1;\n    }\n\n    sk = ctx->sk;\n    if (!sk)\n        return 1;\n\n    next_dump = bpf_sk_storage_get(&bpf_next_dump, sk, 0,\n                    BPF_SK_STORAGE_GET_F_CREATE);\n    if (!next_dump)\n        return 1;\n\n    now = bpf_ktime_get_ns();\n    if (now < *next_dump)\n        return 1;\n\n    tcp_sk = bpf_tcp_sock(sk);\n    if (!tcp_sk)\n        return 1;\n\n    *next_dump = now + INTERVAL;\n\n    bpf_printk(\"dsack_dups=%u delivered=%u\\n\",\n        tcp_sk->dsack_dups, tcp_sk->delivered);\n    bpf_printk(\"delivered_ce=%u icsk_retransmits=%u\\n\",\n        tcp_sk->delivered_ce, tcp_sk->icsk_retransmits);\n\n    return 1;\n}\n\n```\n\n----------------------------------------\n\nTITLE: Definition of bpf_program__attach_perf_event_opts Function in C\nDESCRIPTION: The function signature for bpf_program__attach_perf_event_opts which attaches a BPF_PROG_TYPE_PERF_EVENT program to a perf event. It takes a BPF program pointer, a perf event file descriptor, and additional options as parameters.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_program__attach_perf_event_opts.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstruct bpf_link * bpf_program__attach_perf_event_opts(const struct bpf_program *prog, int pfd, const struct bpf_perf_event_opts *opts);\n```\n\n----------------------------------------\n\nTITLE: Defining Syscall Attributes for BPF_BTF_LOAD using C Structs\nDESCRIPTION: This C code snippet defines the bpf_attr union structure used by the BPF_BTF_LOAD syscall command in the Linux kernel. It lays out the struct fields relevant to BTF object loading, such as pointers to BTF information, log buffers, sizes, flags, and an optional token file descriptor. Proper alignment and type annotations (e.g., __aligned_u64, __u32) are used to ensure correct interaction with kernel memory. Dependencies include Linux kernel headers for fixed-size types (such as __aligned_u64 and __u32), and all fields must be set appropriately before invoking the syscall. Expected inputs are filled struct fields; output is a file descriptor or error code. This struct is a foundational component for userspace programs making BPF_BTF_LOAD calls via bpf() syscall.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/syscall/BPF_BTF_LOAD.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nunion bpf_attr {\n    struct {\n\t\t__aligned_u64   [btf](#btf);\n\t\t__aligned_u64   [btf_log_buf](#btf_log_buf);\n\t\t__u32           [btf_size](#btf_size);\n\t\t__u32           [btf_log_size](#btf_log_size);\n\t\t__u32           [btf_log_level](#btf_log_level);\n\t\t__u32           [btf_log_true_size](#btf_log_true_size);\n\t\t__u32           [btf_flags](#btf_flags);\n\t\t__s32           [btf_token_fd](#btf_token_fd);\n\t};\n};\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_test_run_opts struct in C\nDESCRIPTION: Structure definition for configuring BPF program test runs. Contains fields for input/output data buffers, context information, performance metrics, and execution parameters. Used as parameter for bpf_prog_test_run_opts function.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_prog_test_run_opts.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstruct bpf_test_run_opts {\n\tsize_t sz; /* size of this struct for forward/backward compatibility */\n\tconst void *data_in; /* optional */\n\tvoid *data_out;      /* optional */\n\t__u32 data_size_in;\n\t__u32 data_size_out; /* in: max length of data_out\n\t\t\t      * out: length of data_out\n\t\t\t      */\n\tconst void *ctx_in; /* optional */\n\tvoid *ctx_out;      /* optional */\n\t__u32 ctx_size_in;\n\t__u32 ctx_size_out; /* in: max length of ctx_out\n\t\t\t     * out: length of cxt_out\n\t\t\t     */\n\t__u32 retval;        /* out: return code of the BPF program */\n\tint repeat;\n\t__u32 duration;      /* out: average per repetition in ns */\n\t__u32 flags;\n\t__u32 cpu;\n\t__u32 batch_size;\n};\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_sock_ops_cb_flags_set Helper Function in C\nDESCRIPTION: This code snippet defines the bpf_sock_ops_cb_flags_set helper function for eBPF programs. It attempts to set the value of the bpf_sock_ops_cb_flags field for the full TCP socket associated with bpf_sock_ops.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_sock_ops_cb_flags_set.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstatic long (* const bpf_sock_ops_cb_flags_set)(struct bpf_sock_ops *bpf_sock, int argval) = (void *) 59;\n```\n\n----------------------------------------\n\nTITLE: Declaring the 'enqueue' Function Pointer in 'sched_ext_ops' (C)\nDESCRIPTION: Declares the 'enqueue' function pointer within the 'sched_ext_ops' struct. This BPF scheduler function is invoked when a task (`p`) becomes ready to run and needs to be added to the scheduler's run queue or internal data structures. It receives the task and enqueue flags (`enq_flags`) and is responsible for managing the task until dispatch, unless it was already inserted into a Dispatch Queue (DSQ) via `select_cpu`.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/program-type/BPF_PROG_TYPE_STRUCT_OPS/sched_ext_ops.md#2025-04-22_snippet_8\n\nLANGUAGE: c\nCODE:\n```\nvoid (*enqueue)(struct task_struct *p, u64 enq_flags);\n```\n\n----------------------------------------\n\nTITLE: Implementing eBPF Virtual Time Dispatch Compatibility Macro in C\nDESCRIPTION: A compatibility macro that handles the transition between scx_bpf_dispatch_vtime_from_dsq and scx_bpf_dsq_move_vtime kfuncs. It provides runtime checking of available kfuncs and falls back to returning false if neither function is available.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/scx/__COMPAT_scx_bpf_dsq_move_vtime.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n#define __COMPAT_scx_bpf_dsq_move_vtime(it__iter, p, dsq_id, enq_flags)\t\t\\\n\t(bpf_ksym_exists(scx_bpf_dsq_move_vtime) ?\t\t\t\t\t\\\n\t scx_bpf_dsq_move_vtime((it__iter), (p), (dsq_id), (enq_flags)) :\t\t\\\n\t (bpf_ksym_exists(scx_bpf_dispatch_vtime_from_dsq___compat) ?\t\t\t\\\n\t  scx_bpf_dispatch_vtime_from_dsq___compat((it__iter), (p), (dsq_id), (enq_flags)) : \\\n\t  false))\n```\n\n----------------------------------------\n\nTITLE: Calculating DCTCP Slow Start Threshold in BPF\nDESCRIPTION: This function calculates the slow start threshold for DCTCP. It uses the current congestion window and the DCTCP alpha value to determine the new threshold.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/program-type/BPF_PROG_TYPE_STRUCT_OPS/tcp_congestion_ops.md#2025-04-22_snippet_16\n\nLANGUAGE: C\nCODE:\n```\nSEC(\"struct_ops\")\n__u32 BPF_PROG(bpf_dctcp_ssthresh, struct sock *sk)\n{\n\tstruct bpf_dctcp *ca = inet_csk_ca(sk);\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\n\tca->loss_cwnd = tp->snd_cwnd;\n\treturn max(tp->snd_cwnd - ((tp->snd_cwnd * ca->dctcp_alpha) >> 11U), 2U);\n}\n```\n\n----------------------------------------\n\nTITLE: Defining struct bpf_kprobe_multi_opts in C\nDESCRIPTION: Definition of the bpf_kprobe_multi_opts structure used to configure options when attaching a BPF program to multiple kernel functions simultaneously. The structure contains fields for specifying target functions, addresses, cookies, and behavior options.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_program__attach_kprobe_multi_opts.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstruct bpf_kprobe_multi_opts {\n\t/* size of this struct, for forward/backward compatibility */\n\tsize_t sz;\n\tconst char **syms;\n\tconst unsigned long *addrs;\n\tconst __u64 *cookies;\n\t/* number of elements in syms/addrs/cookies arrays */\n\tsize_t cnt;\n\tbool retprobe;\n\tbool session;\n\tbool unique_match;\n\tsize_t :0;\n};\n```\n\n----------------------------------------\n\nTITLE: Defining the bpf_cpumask_equal KFunc Signature in C\nDESCRIPTION: This C code snippet presents the function signature for the eBPF kfunc `bpf_cpumask_equal`. It accepts two constant pointers, `src1` and `src2`, referencing `struct cpumask` (or compatible `struct bpf_cpumask`). The function's purpose is to compare these two CPU masks, returning `true` if they are identical (all bits match) and `false` if they differ in any bit. This kfunc is available since Linux kernel v6.3.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/bpf_cpumask_equal.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n#!c bool bpf_cpumask_equal(const struct cpumask *src1, const struct cpumask *src2)\n```\n\n----------------------------------------\n\nTITLE: Definition of bpf_iter_bits_destroy KFunc in C\nDESCRIPTION: The function signature for the bpf_iter_bits_destroy kernel function that takes a pointer to a bpf_iter_bits structure and destroys the resources associated with it.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/bpf_iter_bits_destroy.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nvoid bpf_iter_bits_destroy(struct bpf_iter_bits *it)\n```\n\n----------------------------------------\n\nTITLE: Defining the bpf_iter_meta Structure for BPF Iterator Context in C\nDESCRIPTION: This C code defines the `bpf_iter_meta` struct, which is the first field of the context provided to BPF iterator programs (`BPF_TRACE_ITER`). It contains a pointer to the `seq_file` for outputting data, a `session_id` identifying the current iteration session, and a `seq_num` indicating the iteration number within the session. Helper functions like `bpf_seq_printf` use the `seq_file` pointer to write data.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/program-type/BPF_PROG_TYPE_TRACING.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstruct bpf_iter_meta {\n\tstruct seq_file *seq;\n\t__u64 session_id;\n\t__u64 seq_num;\n};\n```\n\n----------------------------------------\n\nTITLE: Task Runnable State Operation\nDESCRIPTION: Callback when a task becomes runnable on its associated CPU due to wakeup, CPU migration or queue restoration.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/program-type/BPF_PROG_TYPE_STRUCT_OPS/sched_ext_ops.md#2025-04-22_snippet_12\n\nLANGUAGE: c\nCODE:\n```\nvoid (*runnable)(struct task_struct *p, u64 enq_flags);\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_get_listener_sock Helper Function in C\nDESCRIPTION: Function definition for the bpf_get_listener_sock helper that returns a struct bpf_sock pointer in TCP_LISTEN state. The function takes a bpf_sock pointer as input and returns NULL on failure. Note that bpf_sk_release() is not allowed on the returned pointer.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_get_listener_sock.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstatic struct bpf_sock *(* const bpf_get_listener_sock)(struct bpf_sock *sk) = (void *) 98;\n```\n\n----------------------------------------\n\nTITLE: Retrieving Pin Path with Libbpf in C\nDESCRIPTION: Defines the prototype for the userspace function 'bpf_link__pin_path' in the libbpf C library, which retrieves the filesystem pin path associated with a given BPF link pointer. Requires libbpf headers and an initialized BPF link object as input. The function returns a pointer to a string representing the path or NULL if an error occurs; callers should check for NULL when handling errors.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_link__pin_path.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n#!c const char *bpf_link__pin_path(const struct bpf_link *link);\n```\n\n----------------------------------------\n\nTITLE: Definition of bpf_get_fsverity_digest Kernel Function in C\nDESCRIPTION: Function signature for the bpf_get_fsverity_digest kernel function that retrieves the fs-verity digest of a file. It takes a file pointer and a bpf_dynptr to store the digest.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/bpf_get_fsverity_digest.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nint bpf_get_fsverity_digest(struct file *file, struct bpf_dynptr *digest_p)\n```\n\n----------------------------------------\n\nTITLE: CGroup Exit Callback Definition in C\nDESCRIPTION: Callback function signature for cleaning up a cgroup during exit. Takes cgroup struct as parameter.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/program-type/BPF_PROG_TYPE_STRUCT_OPS/sched_ext_ops.md#2025-04-22_snippet_31\n\nLANGUAGE: c\nCODE:\n```\nvoid (*cgroup_exit)(struct cgroup *cgrp);\n```\n\n----------------------------------------\n\nTITLE: Definition of bpf_cpumask_weight KFunc in C\nDESCRIPTION: Signature for the bpf_cpumask_weight kernel function that counts the number of set bits in a given CPU-mask. It takes a pointer to a cpumask structure and returns the count as an unsigned 32-bit integer.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/bpf_cpumask_weight.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nu32 bpf_cpumask_weight(const struct cpumask *cpumask)\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_object__set_kversion Function in C\nDESCRIPTION: Function definition for setting kernel version on a BPF object. Takes a BPF object pointer and kernel version as parameters. Returns 0 on success or negative error code on failure.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_object__set_kversion.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nint bpf_object__set_kversion(struct bpf_object *obj, __u32 kern_version);\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_program__insns function in C\nDESCRIPTION: Function definition for bpf_program__insns, which returns a pointer to an array of BPF instructions for a given BPF program.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_program__insns.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nconst struct bpf_insn *bpf_program__insns(const struct bpf_program *prog);\n```\n\n----------------------------------------\n\nTITLE: Definition of bpf_program__attach_netns Function in C\nDESCRIPTION: Function signature for bpf_program__attach_netns which attaches BPF_PROG_TYPE_SK_LOOKUP or BPF_PROG_TYPE_FLOW_DISSECTOR programs to a network namespace. Takes a BPF program pointer and network namespace file descriptor as parameters and returns a BPF link struct pointer.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_program__attach_netns.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstruct bpf_link * bpf_program__attach_netns(const struct bpf_program *prog, int netns_fd);\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_program__set_log_level Function in Libbpf C API\nDESCRIPTION: Function signature for bpf_program__set_log_level, which allows setting the log level for a BPF program. The function takes a pointer to a bpf_program structure and a 32-bit unsigned integer representing the log level.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_program__set_log_level.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nint bpf_program__set_log_level(struct bpf_program *prog, __u32 log_level);\n```\n\n----------------------------------------\n\nTITLE: Task Initialization Callback Definition in C\nDESCRIPTION: Callback function signature for initializing a task for BPF scheduling. Takes task struct and init arguments as parameters. Returns 0 for success or error code.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/program-type/BPF_PROG_TYPE_STRUCT_OPS/sched_ext_ops.md#2025-04-22_snippet_23\n\nLANGUAGE: c\nCODE:\n```\ns32 (*init_task)(struct task_struct *p, struct scx_init_task_args *args);\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_token_create function in C\nDESCRIPTION: Function signature for bpf_token_create, which creates a new BPF token instance. It takes a file descriptor for a BPF filesystem instance and optional creation options as parameters, returning a BPF token file descriptor or an error code.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_token_create.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nint bpf_token_create(int bpffs_fd, struct bpf_token_create_opts *opts);\n```\n\n----------------------------------------\n\nTITLE: Example Implementation of XFRM Metadata Manipulation in TC Programs\nDESCRIPTION: Complete example showing how to use bpf_skb_set_xfrm_info and bpf_skb_get_xfrm_info functions in TC (Traffic Control) eBPF programs. The example demonstrates setting XFRM metadata with a specific interface ID and retrieving it in another program.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/bpf_skb_set_xfrm_info.md#2025-04-22_snippet_1\n\nLANGUAGE: c\nCODE:\n```\n// SPDX-License-Identifier: GPL-2.0\n#include \"vmlinux.h\"\n#include \"bpf_tracing_net.h\"\n#include <bpf/bpf_helpers.h>\n\n__u32 req_if_id;\n__u32 resp_if_id;\n\nint bpf_skb_set_xfrm_info(struct __sk_buff *skb_ctx,\n\t\t\t  const struct bpf_xfrm_info *from) __ksym;\nint bpf_skb_get_xfrm_info(struct __sk_buff *skb_ctx,\n\t\t\t  struct bpf_xfrm_info *to) __ksym;\n\nSEC(\"tc\")\nint set_xfrm_info(struct __sk_buff *skb)\n{\n\tstruct bpf_xfrm_info info = { .if_id = req_if_id };\n\n\treturn bpf_skb_set_xfrm_info(skb, &info) ? TC_ACT_SHOT : TC_ACT_UNSPEC;\n}\n\nSEC(\"tc\")\nint get_xfrm_info(struct __sk_buff *skb)\n{\n\tstruct bpf_xfrm_info info = {};\n\n\tif (bpf_skb_get_xfrm_info(skb, &info) < 0)\n\t\treturn TC_ACT_SHOT;\n\n\tresp_if_id = info.if_id;\n\n\treturn TC_ACT_UNSPEC;\n}\n\nchar _license[] SEC(\"license\") = \"GPL\";\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_sk_select_reuseport Helper Function in C\nDESCRIPTION: This code snippet defines the bpf_sk_select_reuseport helper function, which is used to select a socket for incoming requests when multiple sockets are bound to the same port. It returns 0 on success or a negative error code on failure.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_sk_select_reuseport.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstatic long (* const bpf_sk_select_reuseport)(struct sk_reuseport_md *reuse, void *map, void *key, __u64 flags) = (void *) 82;\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_sock_hash_update Helper Function in C\nDESCRIPTION: This code snippet defines the 'bpf_sock_hash_update' helper function for eBPF. It takes parameters for socket operations, a map, a key, and flags. The function returns 0 on success or a negative error code on failure.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_sock_hash_update.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstatic long (* const bpf_sock_hash_update)(struct bpf_sock_ops *skops, void *map, void *key, __u64 flags) = (void *) 70;\n```\n\n----------------------------------------\n\nTITLE: Function Definition - scx_bpf_dump_bstr KFunc\nDESCRIPTION: Core function signature showing the scx_bpf_dump_bstr kernel function definition. Takes a format string, data buffer pointer, and size parameter for generating BPF scheduler debug dumps.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/scx_bpf_dump_bstr.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nvoid scx_bpf_dump_bstr(char *fmt, long long unsigned int *data, u32 data__sz)\n```\n\n----------------------------------------\n\nTITLE: Defining struct cpumask in C\nDESCRIPTION: Definition of the cpumask structure, which represents a bitmap with one bit for every CPU in the system.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/program-type/BPF_PROG_TYPE_STRUCT_OPS/sched_ext_ops.md#2025-04-22_snippet_52\n\nLANGUAGE: c\nCODE:\n```\nstruct cpumask { \n    [DECLARE_BITMAP](https://elixir.bootlin.com/linux/v6.13.4/source/include/linux/types.h#L10)(bits, NR_CPUS); \n};\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_program__set_autoattach function in C\nDESCRIPTION: This snippet shows the function signature for the bpf_program__set_autoattach function from the libbpf library. It takes a pointer to a bpf_program struct and a boolean flag for autoattach.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_program__set_autoattach.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nvoid bpf_program__set_autoattach(struct bpf_program *prog, bool autoattach);\n```\n\n----------------------------------------\n\nTITLE: Problematic Bounded Loop with Large Range in eBPF\nDESCRIPTION: Shows an example of a bounded loop with a variable upper bound (ip->tot_len) that can create verifier complexity issues. Since tot_len is a 16-bit integer, the verifier would check up to 65535 iterations.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/concepts/loops.md#2025-04-22_snippet_1\n\nLANGUAGE: c\nCODE:\n```\nvoid *data = ctx->data;\nvoid *data_end = ctx->data_end;\nstruct iphdr *ip = data + sizeof(struct ethhdr);\nif (ip + sizeof(struct iphdr) > data_end)\n    return XDP_DROP;\n\nif (ip + sizeof(struct iphdr) > data_end)\n    return XDP_DROP;\n\nfor (int i = 0; i < ip->tot_len; i++) {\n    // scan IP body for something\n}\n```\n\n----------------------------------------\n\nTITLE: Enum Definition for probe_attach_mode in C\nDESCRIPTION: Enumeration defining different modes for attaching uprobes, including default, legacy, perf and link modes. Used to specify how the uprobe should be attached to the system.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_program__attach_uprobe_opts.md#2025-04-22_snippet_1\n\nLANGUAGE: c\nCODE:\n```\nenum probe_attach_mode {\n\t/* attach probe in latest supported mode by kernel */\n\tPROBE_ATTACH_MODE_DEFAULT = 0,\n\t/* attach probe in legacy mode, using debugfs/tracefs */\n\tPROBE_ATTACH_MODE_LEGACY,\n\t/* create perf event with perf_event_open() syscall */\n\tPROBE_ATTACH_MODE_PERF,\n\t/* attach probe with BPF link */\n\tPROBE_ATTACH_MODE_LINK,\n};\n```\n\n----------------------------------------\n\nTITLE: Defining eBPF kfunc bpf_cpumask_empty in C\nDESCRIPTION: This C function 'bpf_cpumask_empty' checks if a CPU mask has any bits set. It takes a pointer to a cpumask structure and returns true if none of the bits are set and false if at least one is set. This kfunc can be used in various BPF program types such as LSM, PERF_EVENT, STRUCT_OPS, TRACEPOINT, and TRACING. The function prototype requires including appropriate headers for BPF programming.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/bpf_cpumask_empty.md#2025-04-22_snippet_0\n\nLANGUAGE: C\nCODE:\n```\n#!c bool bpf_cpumask_empty(const struct cpumask *cpumask)\n```\n\n----------------------------------------\n\nTITLE: Definition of bpf_iter_kmem_cache_next kfunc in C\nDESCRIPTION: Function signature for the 'bpf_iter_kmem_cache_next' kfunc which takes a pointer to an iterator and returns a pointer to the next kmem_cache or NULL if there are no more caches to iterate over.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/bpf_iter_kmem_cache_next.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstruct kmem_cache *bpf_iter_kmem_cache_next(struct bpf_iter_kmem_cache *it)\n```\n\n----------------------------------------\n\nTITLE: Defining eBPF KFunc 'bpf_cpumask_any_distribute' in C\nDESCRIPTION: The code defines an eBPF kernel function 'bpf_cpumask_any_distribute' which returns a random CPU ID from a given CPU mask. The function signature indicates the use of a constant struct cpumask pointer as input. It returns a random set bit within the range [0, num_cpus) if any bits are set or ans 'out of range' value if no bits are set in the mask.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/bpf_cpumask_any_distribute.md#2025-04-22_snippet_0\n\nLANGUAGE: C\nCODE:\n```\nu32 bpf_cpumask_any_distribute(const struct cpumask *cpumask)\n```\n\n----------------------------------------\n\nTITLE: Defining ARRAY_ELEM_PTR Macro for Verified Array Element Access in C\nDESCRIPTION: This macro creates a verified pointer to an array element, particularly useful for arrays that will be resized before BPF program loading. It safely handles bounds checking to prevent verifier rejection.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/scx/ARRAY_ELEM_PTR.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n#define ARRAY_ELEM_PTR(arr, i, n) (typeof(arr[i]) *)    \\\n({                                                      \\\n    u64 __base = (u64)arr;                              \\\n    u64 __addr = (u64)&(arr[i]) - __base;               \\\n    asm volatile (                                      \\\n        \"if %0 <= %[max] goto +2\\n\"                     \\\n        \"%0 = 0\\n\"                                      \\\n        \"goto +1\\n\"                                     \\\n        \"%0 += %1\\n\"                                    \\\n        : \"+r\"(__addr)                                  \\\n        : \"r\"(__base),                                  \\\n          [max]\"r\"(sizeof(arr[0]) * ((n) - 1)));        \\\n    __addr;                                             \\\n})\n```\n\n----------------------------------------\n\nTITLE: Definition of bpf_ct_set_status KFunc in C\nDESCRIPTION: Function signature for the bpf_ct_set_status kernel function. It takes a pointer to a referenced nf_conn object and a status value as parameters, returning an integer status code.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/bpf_ct_set_status.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nint bpf_ct_set_status(const struct nf_conn___init *nfct, u32 status)\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_iter_task_new KFunc Interface in C\nDESCRIPTION: Function signature for bpf_iter_task_new kfunc that initializes a task iterator. The function parameters include a pointer to the iterator structure, an optional task pointer, and flags that control iteration behavior.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/bpf_iter_task_new.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nint bpf_iter_task_new(struct bpf_iter_task *it, struct task_struct *task__nullable, unsigned int flags)\n```\n\n----------------------------------------\n\nTITLE: Function Definition for bpf_prog_detach2\nDESCRIPTION: C function declaration for bpf_prog_detach2 that detaches a BPF program from an attachable object. Takes program file descriptor, attachable file descriptor, and attachment type as parameters. Returns 0 on success or negative error code on failure.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_prog_detach2.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nint bpf_prog_detach2(int prog_fd, int attachable_fd, enum bpf_attach_type type);\n```\n\n----------------------------------------\n\nTITLE: Initializing TCP Congestion Control Algorithm via init Callback (C)\nDESCRIPTION: This function pointer type defines the 'init' callback used to initialize a congestion control algorithm instance for a given socket. Called on algorithm setup, it receives only the socket pointer. Implementers use this to allocate or set up any per-socket state before active transmission. No output values or return value are expected.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/program-type/BPF_PROG_TYPE_STRUCT_OPS/tcp_congestion_ops.md#2025-04-22_snippet_4\n\nLANGUAGE: c\nCODE:\n```\nvoid (*init)(struct sock *sk)\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_get_current_pid_tgid Helper Function in C\nDESCRIPTION: This code snippet defines the bpf_get_current_pid_tgid helper function. It returns a 64-bit integer containing the current task group ID (tgid) in the upper 32 bits and the process ID (pid) in the lower 32 bits.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_get_current_pid_tgid.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstatic __u64 (* const bpf_get_current_pid_tgid)(void) = (void *) 14;\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_msg_redirect_hash Helper Function in C\nDESCRIPTION: This code snippet defines the 'bpf_msg_redirect_hash' helper function for eBPF. It takes a message, a map, a key, and flags as parameters. The function returns SK_PASS on success or SK_DROP on error.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_msg_redirect_hash.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstatic long (* const bpf_msg_redirect_hash)(struct sk_msg_md *msg, void *map, void *key, __u64 flags) = (void *) 71;\n```\n\n----------------------------------------\n\nTITLE: Definition of bpf_program__attach_xdp function in C\nDESCRIPTION: Function definition for attaching a BPF_PROG_TYPE_XDP program to a network interface. Takes the BPF program and interface index as parameters and returns a struct bpf_link pointer on success or NULL with errno set on failure.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_program__attach_xdp.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstruct bpf_link * bpf_program__attach_xdp(const struct bpf_program *prog, int ifindex);\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_rbtree_remove KFunc in C\nDESCRIPTION: Function signature for the bpf_rbtree_remove kernel function that removes a node from a red-black tree. Returns a pointer to the removed node or NULL if the node wasn't found in the tree. The returned pointer is refcounted and must be properly released.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/bpf_rbtree_remove.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstruct bpf_rb_node *bpf_rbtree_remove(struct bpf_rb_root *root, struct bpf_rb_node *node)\n```\n\n----------------------------------------\n\nTITLE: Defining '__hidden' macro for symbol visibility in C\nDESCRIPTION: This snippet defines the '__hidden' macro using the visibility attribute to mark symbols as hidden. It's used to control symbol visibility and affect BPF-to-BPF function verification.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/ebpf/__hidden.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n#define __hidden __attribute__((visibility(\"hidden\")))\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_override_return Helper Function in C\nDESCRIPTION: Function prototype for the bpf_override_return helper, used for error injection in eBPF programs. It overrides the return value of a probed function using kprobes.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_override_return.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstatic long (* const bpf_override_return)(struct pt_regs *regs, __u64 rc) = (void *) 58;\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_xdp_attach function in C\nDESCRIPTION: This snippet defines the bpf_xdp_attach function, which is used to attach a BPF_PROG_TYPE_XDP program to a network interface. It takes parameters for the interface index, program file descriptor, flags, and options.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_xdp_attach.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nint bpf_xdp_attach(int ifindex, int prog_fd, __u32 flags, const struct bpf_xdp_attach_opts *opts);\n```\n\n----------------------------------------\n\nTITLE: Basic Numeric Iterator Usage in eBPF\nDESCRIPTION: Demonstrates basic usage of the numeric iterator to loop from 2 to 4, printing each value using bpf_printk. Shows initialization, iteration, and cleanup of the iterator.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/bpf_iter_num_new.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstruct bpf_iter_num it;\nint *v;\n\nbpf_iter_num_new(&it, 2, 5);\nwhile ((v = bpf_iter_num_next(&it))) {\n    bpf_printk(\"X = %d\", *v);\n}\nbpf_iter_num_destroy(&it);\n```\n\n----------------------------------------\n\nTITLE: Opening a BPF Link with libbpf in C\nDESCRIPTION: This snippet defines the prototype for the 'bpf_link__open' function from the libbpf C library. Its purpose is to open a BPF link object that has been previously pinned to a filesystem path. The only parameter is a string representing the pin path to the BPF link. On success, it returns a pointer to a 'struct bpf_link'; otherwise, it returns NULL to indicate failure. Requires libbpf installed and the relevant BPF link to be already pinned.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_link__open.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n#!c struct bpf_link *bpf_link__open(const char *path);\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_program__set_insns Function in C\nDESCRIPTION: Function signature and definition for bpf_program__set_insns which allows setting BPF program instructions. Takes a BPF program pointer, array of new instructions, and instruction count as parameters. Returns 0 on success or negative error code on failure.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_program__set_insns.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nint bpf_program__set_insns(struct bpf_program *prog, struct bpf_insn *new_insns, size_t new_insn_cnt);\n```\n\n----------------------------------------\n\nTITLE: Periodic Tick Operation in BPF Scheduler\nDESCRIPTION: Callback executed every 1/HZ seconds on CPUs running an SCX task to handle periodic scheduling updates.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/program-type/BPF_PROG_TYPE_STRUCT_OPS/sched_ext_ops.md#2025-04-22_snippet_11\n\nLANGUAGE: c\nCODE:\n```\nvoid (*tick)(struct task_struct *p);\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_map_lookup_elem_flags Function in C\nDESCRIPTION: Function prototype for the bpf_map_lookup_elem_flags libbpf userspace function. Takes a file descriptor, key pointer, value pointer, and flags as parameters. Returns 0 on success or negative error code on failure.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_map_lookup_elem_flags.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nint bpf_map_lookup_elem_flags(int fd, const void *key, void *value, __u64 flags);\n```\n\n----------------------------------------\n\nTITLE: Implementing a Red-Black Tree Node Structure in C\nDESCRIPTION: Example structure for a red-black tree node that embeds the bpf_rb_node known type along with user data.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/scx/__contains.md#2025-04-22_snippet_2\n\nLANGUAGE: c\nCODE:\n```\nstruct my_rb_tree_node {\n    struct bpf_rb_node rb_node;\n    __u64 data;\n}\n```\n\n----------------------------------------\n\nTITLE: Retrieving BPF Object Name Function Definition in C\nDESCRIPTION: Function definition for bpf_object__name that returns the name of a BPF object. Takes a const struct bpf_object pointer as parameter and returns a const char pointer to the object name.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_object__name.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nconst char *bpf_object__name(const struct bpf_object *obj);\n```\n\n----------------------------------------\n\nTITLE: Defining scx_bpf_select_cpu_dfl KFunc in C\nDESCRIPTION: Function signature for the scx_bpf_select_cpu_dfl kfunc. It selects a CPU for a given task, considering previous CPU, wake flags, and idle status.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/scx_bpf_select_cpu_dfl.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\ns32 scx_bpf_select_cpu_dfl(struct task_struct *p, s32 prev_cpu, u64 wake_flags, bool *is_idle)\n```\n\n----------------------------------------\n\nTITLE: Defining scx_bpf_dispatch_nr_slots KFunc in C\nDESCRIPTION: Function signature for the scx_bpf_dispatch_nr_slots kfunc. It takes no parameters and returns a u32 value representing the number of remaining dispatch slots.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/scx_bpf_dispatch_nr_slots.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nu32 scx_bpf_dispatch_nr_slots()\n```\n\n----------------------------------------\n\nTITLE: Documenting eBPF Map Type Features and Metadata - Markdown\nDESCRIPTION: This snippet defines the metadata headers for the Markdown documentation page, including title and description. It uses YAML front matter to establish identifiers for static site generators or documentation tools. These declarations are essential prerequisites for building rich documentation pages, and they constrain the document to the 'BPF_MAP_TYPE_LRU_PERCPU_HASH' subject.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/map-type/BPF_MAP_TYPE_LRU_PERCPU_HASH.md#2025-04-22_snippet_0\n\nLANGUAGE: Markdown\nCODE:\n```\n---\ntitle: \"Map Type 'BPF_MAP_TYPE_LRU_PERCPU_HASH'\"\ndescription: \"This page documents the 'BPF_MAP_TYPE_LRU_PERCPU_HASH' eBPF map type, including its definition, usage, program types that can use it, and examples.\"\n---\n```\n\n----------------------------------------\n\nTITLE: Defining the `bpf_link_detach` Function Signature in C\nDESCRIPTION: This C code snippet provides the function signature for `bpf_link_detach` from the libbpf library. It accepts a file descriptor (`link_fd`) representing the BPF link to detach. The function returns 0 upon successful detachment or a negative errno value if an error occurs. It's a low-level function, and higher-level alternatives like `bpf_link__detach` or `bpf_link__destroy` are generally recommended.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_link_detach.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n`#!c int bpf_link_detach(int link_fd);`\n```\n\n----------------------------------------\n\nTITLE: Setting Target Architecture for PT_REGS_IP Macro\nDESCRIPTION: Example showing how to set the target architecture when compiling eBPF programs using PT_REGS_IP macro. The architecture is specified using compiler flags like __TARGET_ARCH_{arch}.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/ebpf/PT_REGS_IP.md#2025-04-22_snippet_0\n\nLANGUAGE: C\nCODE:\n```\n-D__TARGET_ARCH_x86\n```\n\n----------------------------------------\n\nTITLE: Implementing a USDT eBPF Program in C\nDESCRIPTION: Example of defining an eBPF program that attaches to a USDT tracepoint. The program uses the SEC macro to specify the path to the binary, provider name, and tracepoint name. It demonstrates how to receive and process arguments from the tracepoint.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/concepts/usdt.md#2025-04-22_snippet_1\n\nLANGUAGE: c\nCODE:\n```\n// SPDX-License-Identifier: GPL-2.0\n/* Copyright (c) 2022 Meta Platforms, Inc. and affiliates. */\nSEC(\"usdt/./urandom_read:urand:read_without_sema\")\nint BPF_USDT(urand_read_without_sema, int iter_num, int iter_cnt, int buf_sz)\n{\n\tif (urand_pid != (bpf_get_current_pid_tgid() >> 32))\n\t\treturn 0;\n\n\t__sync_fetch_and_add(&urand_read_without_sema_call_cnt, 1);\n\t__sync_fetch_and_add(&urand_read_without_sema_buf_sz_sum, buf_sz);\n\n\treturn 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining ring_buffer__consume_n Function in C\nDESCRIPTION: Function signature for ring_buffer__consume_n, which consumes up to 'n' records from available ring buffer(s) data without event polling. It takes a ring buffer manager and the number of records to consume as parameters, returning the number of records consumed or a negative value on error.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/ring_buffer__consume_n.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nint ring_buffer__consume_n(struct ring_buffer *rb, size_t n);\n```\n\n----------------------------------------\n\nTITLE: Testing bpf_dynptr_data with SKB Dynamic Pointers\nDESCRIPTION: Demonstrates that direct access to SKB data via bpf_dynptr_data is not allowed, requiring the use of the bpf_dynptr_slice API instead. This enforces proper API usage for network buffer access.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/concepts/dynptrs.md#2025-04-22_snippet_4\n\nLANGUAGE: c\nCODE:\n```\nSEC(\"?cgroup_skb/egress\")\nint test_dynptr_skb_data(struct __sk_buff *skb)\n{\n\tstruct bpf_dynptr ptr;\n\t__u64 *data;\n\n\tif (bpf_dynptr_from_skb(skb, 0, &ptr)) {\n\t\terr = 1;\n\t\treturn 1;\n\t}\n\n\t/* This should return NULL. Must use bpf_dynptr_slice API */\n\tdata = bpf_dynptr_data(&ptr, 0, 1);\n\tif (data) {\n\t\terr = 2;\n\t\treturn 1;\n\t}\n\n\treturn 1;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_ringbuf_reserve_dynptr Helper Function in C\nDESCRIPTION: C definition of the bpf_ringbuf_reserve_dynptr eBPF helper function. It reserves size bytes of payload in a ring buffer ringbuf through the dynptr interface. The flags parameter must be 0. Returns 0 on success, or a negative error in case of failure.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_ringbuf_reserve_dynptr.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstatic long (* const bpf_ringbuf_reserve_dynptr)(void *ringbuf, __u32 size, __u64 flags, struct bpf_dynptr *ptr) = (void *) 198;\n```\n\n----------------------------------------\n\nTITLE: Defining the bpf_cpumask_test_and_clear_cpu KFunc in C\nDESCRIPTION: Function signature for the bpf_cpumask_test_and_clear_cpu kernel function which atomically tests and clears a CPU in a BPF CPU-mask. It takes a CPU number and a CPU mask as parameters and returns a boolean indicating whether the CPU was set in the mask.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/bpf_cpumask_test_and_clear_cpu.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nbool bpf_cpumask_test_and_clear_cpu(u32 cpu, struct bpf_cpumask *cpumask)\n```\n\n----------------------------------------\n\nTITLE: Defining the BPF_SEQ_PRINTF Macro in C\nDESCRIPTION: This C code defines the `BPF_SEQ_PRINTF` preprocessor macro. It serves as a wrapper around the `bpf_seq_printf` helper function, designed to simplify printing to bpf iterator sequence files. The macro stores the format string (`fmt`) in a static constant character array (`___fmt`) and prepares the arguments (`args`) in an array (`___param`) before calling `bpf_seq_printf`. This approach helps meet the eBPF verifier's requirements. It uses pragmas to temporarily ignore potential integer conversion warnings during argument filling.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/ebpf/bpf_seq_printf.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n/*\n * BPF_SEQ_PRINTF to wrap bpf_seq_printf to-be-printed values\n * in a structure.\n */\n#define BPF_SEQ_PRINTF(seq, fmt, args...)      \\\n({\t\t\t\t\t\t\t\\\n\tstatic const char ___fmt[] = fmt;\t\t\t\\\n\tunsigned long long ___param[___bpf_narg(args)];\t\\\n\t\t\t\t\t\t\t\\\n\t_Pragma(\"GCC diagnostic push\")\t\t\t\\\n\t_Pragma(\"GCC diagnostic ignored \\\"-Wint-conversion\\\"\")\t\\\n\t___bpf_fill(___param, args);\t\t\t\\\n\t_Pragma(\"GCC diagnostic pop\")\t\t\t\\\n\t\t\t\t\t\t\t\\\n\tbpf_seq_printf(seq, ___fmt, sizeof(___fmt),\t\t\\\n\t\t       ___param, sizeof(___param));\t\t\\\n})\n```\n\n----------------------------------------\n\nTITLE: Using BPF_PROBE_READ_USER macro in C\nDESCRIPTION: This snippet demonstrates the usage of BPF_PROBE_READ_USER macro, which returns the read value directly. It's provided for comparison with BPF_PROBE_READ_USER_INTO.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/ebpf/BPF_PROBE_READ_USER_INTO.md#2025-04-22_snippet_1\n\nLANGUAGE: c\nCODE:\n```\nint x = BPF_PROBE_READ_USER(s, a.b.c, d.e, f, g);\n```\n\n----------------------------------------\n\nTITLE: Defining the C Signature for eBPF Helper 'bpf_tcp_raw_check_syncookie_ipv6'\nDESCRIPTION: This C code defines the function pointer signature for the `bpf_tcp_raw_check_syncookie_ipv6` eBPF helper. It takes pointers to IPv6 (`struct ipv6hdr *iph`) and TCP (`struct tcphdr *th`) headers as input. The helper checks if these headers constitute a valid SYN cookie ACK for IPv6, returning 0 on success or a negative error code (`-EACCES`, `-EPROTONOSUPPORT`) otherwise. It's assigned the kernel helper ID 207 and requires kernel v6.0+ and `CONFIG_IPV6` enabled.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_tcp_raw_check_syncookie_ipv6.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n`#!c static long (* const bpf_tcp_raw_check_syncookie_ipv6)(struct ipv6hdr *iph, struct tcphdr *th) = (void *) 207;`\n```\n\n----------------------------------------\n\nTITLE: Enabling kprobe using ioctl\nDESCRIPTION: ioctl commands for attaching a BPF program to a kprobe event and enabling the kprobe. This is part of the legacy attachment method.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/program-type/BPF_PROG_TYPE_KPROBE.md#2025-04-22_snippet_2\n\nLANGUAGE: c\nCODE:\n```\nioctl(perf_event_fd, PERF_EVENT_IOC_SET_BPF, bpf_prog_fd);\n```\n\nLANGUAGE: c\nCODE:\n```\nioctl(perf_event_fd, PERF_EVENT_IOC_ENABLE, 0);\n```\n\n----------------------------------------\n\nTITLE: CPU Yield Operation\nDESCRIPTION: Handles CPU yield requests, either to any other task or to a specific target task.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/program-type/BPF_PROG_TYPE_STRUCT_OPS/sched_ext_ops.md#2025-04-22_snippet_16\n\nLANGUAGE: c\nCODE:\n```\nbool (*yield)(struct task_struct *from, struct task_struct *to);\n```\n\n----------------------------------------\n\nTITLE: Definition of bpf_task_from_vpid KFunc in C\nDESCRIPTION: Function signature for the bpf_task_from_vpid kernel function. This kfunc takes a vpid parameter (s32) and returns a pointer to a task_struct or NULL. The returned task must either be stored in a map or released with bpf_task_release.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/bpf_task_from_vpid.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstruct task_struct *bpf_task_from_vpid(s32 vpid)\n```\n\n----------------------------------------\n\nTITLE: Definition of bpf_list_push_back_impl Kernel Function in C\nDESCRIPTION: Function signature for the bpf_list_push_back_impl kernel function. This function adds a new entry to the end of a BPF linked list. The meta and off parameters are rewritten by the verifier and don't need to be set by BPF programs.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/bpf_list_push_back_impl.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nint bpf_list_push_back_impl(struct bpf_list_head *head, struct bpf_list_node *node, void *meta__ign, u64 off)\n```\n\n----------------------------------------\n\nTITLE: Defining the bpf_map__btf_key_type_id Function (C)\nDESCRIPTION: This C function signature defines `bpf_map__btf_key_type_id`. It takes a constant pointer to a `bpf_map` structure as input and returns the BTF type ID (`__u32`) associated with the map's key. If no BTF type ID is available for the key, the function returns 0.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_map__btf_key_type_id.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n__u32 bpf_map__btf_key_type_id(const struct bpf_map *map);\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_map_push_elem Helper Function in C\nDESCRIPTION: This code snippet defines the bpf_map_push_elem helper function, which is used to push an element into a map. It takes a pointer to the map, a pointer to the value to be pushed, and flags as parameters. The function returns 0 on success or a negative error code on failure.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_map_push_elem.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstatic long (* const bpf_map_push_elem)(void *map, const void *value, __u64 flags) = (void *) 87;\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_get_current_comm Helper Function in C\nDESCRIPTION: Function definition for the bpf_get_current_comm helper that copies the current task's comm attribute (executable name) into a provided buffer.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_get_current_comm.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstatic long (* const bpf_get_current_comm)(void *buf, __u32 size_of_buf) = (void *) 16;\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_xdp_query_id function in C\nDESCRIPTION: This snippet defines the 'bpf_xdp_query_id' function, which queries the program ID of an XDP program attached to a network interface. It takes the interface index, flags, and a pointer to store the program ID as parameters.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_xdp_query_id.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nint bpf_xdp_query_id(int ifindex, int flags, __u32 *prog_id);\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_get_func_arg_cnt Helper Function in C\nDESCRIPTION: Definition of the bpf_get_func_arg_cnt helper function, which retrieves the number of argument registers for a traced function in eBPF tracing programs.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_get_func_arg_cnt.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstatic long (* const bpf_get_func_arg_cnt)(void *ctx) = (void *) 185;\n```\n\n----------------------------------------\n\nTITLE: Defining SCX Task Initialization Arguments in C\nDESCRIPTION: Structure for passing arguments to the init_task callback when initializing a task in the scheduler extension. Contains a fork flag and optionally a cgroup reference when extended group scheduling is configured.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/program-type/BPF_PROG_TYPE_STRUCT_OPS/sched_ext_ops.md#2025-04-22_snippet_55\n\nLANGUAGE: c\nCODE:\n```\nstruct scx_init_task_args {\n\tbool fork;\n#ifdef CONFIG_EXT_GROUP_SCHED\n\tstruct cgroup *cgroup;\n#endif\n};\n```\n\n----------------------------------------\n\nTITLE: KFunc Definition - bpf_task_get_cgroup1\nDESCRIPTION: Function signature for bpf_task_get_cgroup1 that takes a task_struct pointer and hierarchy ID as parameters. Returns a pointer to a cgroup structure that must be properly released or transferred using bpf_kptr_xchg. The returned pointer may be NULL and requires validation before use.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/bpf_task_get_cgroup1.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstruct cgroup *bpf_task_get_cgroup1(struct task_struct *task, int hierarchy_id)\n```\n\n----------------------------------------\n\nTITLE: Defining struct bpf_get_fd_by_id_opts in C\nDESCRIPTION: Definition of the bpf_get_fd_by_id_opts structure used by the bpf_prog_get_fd_by_id_opts function. This structure contains fields for size, open flags, and a zero-sized field for compatibility.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_prog_get_fd_by_id_opts.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstruct bpf_get_fd_by_id_opts {\n\tsize_t sz; /* size of this struct for forward/backward compatibility */\n\t__u32 open_flags; /* permissions requested for the operation on fd */\n\tsize_t :0;\n};\n```\n\n----------------------------------------\n\nTITLE: Defining the 'dctcp_state' KFunc Signature in C\nDESCRIPTION: This C code snippet defines the signature for the eBPF kernel function 'dctcp_state'. The function takes a pointer to a 'struct sock' (representing a socket) and a 'u8' (unsigned 8-bit integer) representing the new state as input. It returns 'void', indicating it does not return a value. This function is intended to be called before modifying the congestion algorithm state ('ca_state') of the socket.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/dctcp_state.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n`#!c void dctcp_state(struct sock *sk, u8 new_state)`\n```\n\n----------------------------------------\n\nTITLE: Definition of bpf_program__attach_iter Function in Libbpf C API\nDESCRIPTION: This snippet shows the function signature of bpf_program__attach_iter which attaches an iterator program. It takes a BPF program and attachment options as parameters and returns a bpf_link pointer or NULL on failure.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_program__attach_iter.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstruct bpf_link * bpf_program__attach_iter(const struct bpf_program *prog, const struct bpf_iter_attach_opts *opts);\n```\n\n----------------------------------------\n\nTITLE: BPF Program Type Function Definition in C\nDESCRIPTION: Function definition for bpf_program__type that returns the type of a BPF program. Takes a const struct bpf_program pointer as input and returns an enum bpf_prog_type.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_program__type.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nenum bpf_prog_type bpf_program__type(const struct bpf_program *prog);\n```\n\n----------------------------------------\n\nTITLE: Defining BPF Map File Descriptor Options Structure in C\nDESCRIPTION: Structure definition for bpf_get_fd_by_id_opts that specifies options for retrieving a BPF map file descriptor. Contains fields for structure size and operation permissions flags.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_map_get_fd_by_id_opts.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstruct bpf_get_fd_by_id_opts {\n\tsize_t sz; /* size of this struct for forward/backward compatibility */\n\t__u32 open_flags; /* permissions requested for the operation on fd */\n\tsize_t :0;\n};\n```\n\n----------------------------------------\n\nTITLE: Setting Initial Value in BPF Map with Libbpf in C\nDESCRIPTION: The `bpf_map__set_initial_value` function sets the initial value for BPF maps in libbpf. Requires a pointer to the map, the initial data, and the size of the data. The function returns 0 on success or a negative error code on failure. It should be called post map creation and pre program loading.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_map__set_initial_value.md#2025-04-22_snippet_0\n\nLANGUAGE: C\nCODE:\n```\n#!c int bpf_map__set_initial_value(struct bpf_map *map, const void *data, size_t size);\n```\n\n----------------------------------------\n\nTITLE: Definition of bpf_cpumask_test_cpu Kernel Function in C\nDESCRIPTION: Function signature for the bpf_cpumask_test_cpu kfunc that tests whether a CPU is set in a CPU-mask. It takes a CPU number and a CPU-mask pointer as parameters and returns a boolean result.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/bpf_cpumask_test_cpu.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nbool bpf_cpumask_test_cpu(u32 cpu, const struct cpumask *cpumask)\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_dynptr_write Helper Function in C\nDESCRIPTION: Function definition for the bpf_dynptr_write eBPF helper that writes len bytes from src into dst starting at offset. The function handles special cases for skb-type dynptrs and includes flags parameter for additional control.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_dynptr_write.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstatic long (* const bpf_dynptr_write)(const struct bpf_dynptr *dst, __u32 offset, void *src, __u32 len, __u64 flags) = (void *) 202;\n```\n\n----------------------------------------\n\nTITLE: Defining tcp_bbr_info Structure for BBR TCP Congestion Control (C)\nDESCRIPTION: This struct models the major state variables tracked by BBR congestion control in TCP, including bandwidth estimate split into upper/lower segments, minimum RTT observed, and pacing/cwnd gain factors (each shifted for fixed-point representation). Inputs: BBR measurement and algorithm results; output: populated struct for management or diagnostics. Only unsigned fields are used.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/program-type/BPF_PROG_TYPE_STRUCT_OPS/tcp_congestion_ops.md#2025-04-22_snippet_11\n\nLANGUAGE: c\nCODE:\n```\nstruct tcp_bbr_info {\n\t/* u64 bw: max-filtered BW (app throughput) estimate in Byte per sec: */\n\t__u32\tbbr_bw_lo;\t\t/* lower 32 bits of bw */\n\t__u32\tbbr_bw_hi;\t\t/* upper 32 bits of bw */\n\t__u32\tbbr_min_rtt;\t\t/* min-filtered RTT in uSec */\n\t__u32\tbbr_pacing_gain;\t/* pacing gain shifted left 8 bits */\n\t__u32\tbbr_cwnd_gain;\t\t/* cwnd gain shifted left 8 bits */\n};\n```\n\n----------------------------------------\n\nTITLE: Defining WRITE_ONCE macro for atomic memory writes in C\nDESCRIPTION: This code snippet defines the WRITE_ONCE macro and its supporting functions. It provides type-safe atomic writes for various data sizes, preventing compiler optimizations like caching, redoing, or reordering writes.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/scx/WRITE_ONCE.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\ntypedef __u8  __attribute__((__may_alias__))  __u8_alias_t;\ntypedef __u16 __attribute__((__may_alias__)) __u16_alias_t;\ntypedef __u32 __attribute__((__may_alias__)) __u32_alias_t;\ntypedef __u64 __attribute__((__may_alias__)) __u64_alias_t;\n\nstatic __always_inline void __write_once_size(volatile void *p, void *res, int size)\n{\n\tswitch (size) {\n\tcase 1: *(volatile  __u8_alias_t *) p = *(__u8_alias_t  *) res; break;\n\tcase 2: *(volatile __u16_alias_t *) p = *(__u16_alias_t *) res; break;\n\tcase 4: *(volatile __u32_alias_t *) p = *(__u32_alias_t *) res; break;\n\tcase 8: *(volatile __u64_alias_t *) p = *(__u64_alias_t *) res; break;\n\tdefault:\n\t\t[barrier]();\n\t\t__builtin_memcpy((void *)p, (const void *)res, size);\n\t\t[barrier]();\n\t}\n}\n\n#define WRITE_ONCE(x, val)                          \\\n({                                                  \\\n\tunion { typeof(x) __val; char __c[1]; } __u =   \\\n\t\t{ .__val = (val) };                         \\\n\t__write_once_size(&(x), __u.__c, sizeof(x));    \\\n\t__u.__val;                                      \\\n})\n```\n\n----------------------------------------\n\nTITLE: Defining the bpf_iter_bits_new KFunc in C\nDESCRIPTION: Function signature for the bpf_iter_bits_new kfunc that initializes a bits iterator. It takes a bpf_iter_bits structure, a pointer to memory area, and the size in 8-byte units (limited to 512).\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/bpf_iter_bits_new.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nint bpf_iter_bits_new(struct bpf_iter_bits *it, const u64 *unsafe_ptr__ign, u32 nr_words)\n```\n\n----------------------------------------\n\nTITLE: Definition of perf_buffer__epoll_fd in C\nDESCRIPTION: Function signature for perf_buffer__epoll_fd which returns an epoll file descriptor for a perf buffer. The function takes a perf buffer pointer as input and returns an integer file descriptor.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/perf_buffer__epoll_fd.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nint perf_buffer__epoll_fd(const struct perf_buffer *pb);\n```\n\n----------------------------------------\n\nTITLE: BTF Distillation Function Definition in C\nDESCRIPTION: Function definition for btf__distill_base that creates new versions of split BTF and base BTF. Takes a source BTF and populates pointers to new base and split BTF versions. Returns 0 on success or negative value on error.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/btf__distill_base.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nint btf__distill_base(const struct btf *src_btf, struct btf **new_base_btf, struct btf **new_split_btf);\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_get_attach_cookie Helper Function in C\nDESCRIPTION: C function definition for the bpf_get_attach_cookie helper that retrieves the cookie value provided during program attachment. Takes a context pointer as argument and returns a 64-bit unsigned integer.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_get_attach_cookie.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstatic __u64 (* const bpf_get_attach_cookie)(void *ctx) = (void *) 174;\n```\n\n----------------------------------------\n\nTITLE: Defining cgroup_rstat_flush KFunc in C\nDESCRIPTION: This snippet defines the signature of the cgroup_rstat_flush kfunc. It takes a pointer to a cgroup struct as a parameter and returns void. The function flushes stats in the cgroup's subtree and may block.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/cgroup_rstat_flush.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nvoid cgroup_rstat_flush(struct cgroup *cgrp)\n```\n\n----------------------------------------\n\nTITLE: Task Running State Operation\nDESCRIPTION: Notification callback when a task starts running on its associated CPU.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/program-type/BPF_PROG_TYPE_STRUCT_OPS/sched_ext_ops.md#2025-04-22_snippet_13\n\nLANGUAGE: c\nCODE:\n```\nvoid (*running)(struct task_struct *p);\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_rc_keydown Helper Function in C\nDESCRIPTION: This snippet defines the bpf_rc_keydown helper function for use in eBPF programs. It is used for reporting decoded key presses in IR decoding implementations.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_rc_keydown.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstatic long (* const bpf_rc_keydown)(void *ctx, __u32 protocol, __u64 scancode, __u32 toggle) = (void *) 78;\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_map_pop_elem Helper Function in C\nDESCRIPTION: This code snippet defines the bpf_map_pop_elem helper function, which pops an element from a map. It returns 0 on success or a negative error code on failure.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_map_pop_elem.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstatic long (* const bpf_map_pop_elem)(void *map, void *value) = (void *) 88;\n```\n\n----------------------------------------\n\nTITLE: Defining scx_bpf_dsq_nr_queued KFunc in C\nDESCRIPTION: Function signature for the scx_bpf_dsq_nr_queued kernel function. Takes a DSQ ID as input and returns the number of queued tasks or -ENOENT if not found.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/scx_bpf_dsq_nr_queued.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\ns32 scx_bpf_dsq_nr_queued(u64 dsq_id)\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_skc_to_mptcp_sock Helper Function in C\nDESCRIPTION: Definition of the bpf_skc_to_mptcp_sock helper function, which dynamically casts a sk pointer to a mptcp_sock pointer. It returns the sk if casting is valid, or NULL otherwise.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_skc_to_mptcp_sock.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstatic struct mptcp_sock *(* const bpf_skc_to_mptcp_sock)(void *sk) = (void *) 196;\n```\n\n----------------------------------------\n\nTITLE: Defining the bpf_object__open_file function in C\nDESCRIPTION: Function signature for bpf_object__open_file which creates a struct bpf_object by opening the BPF ELF object file from a specified path. It takes a file path and optional loading options as parameters and returns a pointer to the new bpf_object or NULL on error.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_object__open_file.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstruct bpf_object * bpf_object__open_file(const char *path, const struct bpf_object_open_opts *opts);\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_skb_pull_data Helper Function in C\nDESCRIPTION: This code snippet defines the bpf_skb_pull_data helper function for eBPF programs. It takes an __sk_buff pointer and a length as parameters, and returns a long integer indicating success or failure.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_skb_pull_data.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstatic long (* const bpf_skb_pull_data)(struct __sk_buff *skb, __u32 len) = (void *) 39;\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_timer_cancel Function in C\nDESCRIPTION: Defines the eBPF helper function 'bpf_timer_cancel' which cancels a pending timer and waits for the callback_fn to finish if it was running. It returns 0 if the timer was not active, 1 if it was active, -EINVAL if the timer was not initialized, and -EDEADLK if there's a deadlock risk. Requires dependencies on eBPF and struct bpf_timer. The key parameter is the 'timer' of type 'struct bpf_timer'. The output varies as explained based on the timer's state.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_timer_cancel.md#2025-04-22_snippet_0\n\nLANGUAGE: C\nCODE:\n```\nstatic long (* const bpf_timer_cancel)(struct bpf_timer *timer) = (void *) 172;\n```\n\n----------------------------------------\n\nTITLE: Defining btf__add_enum64 Function in C\nDESCRIPTION: This snippet shows the C function signature for btf__add_enum64. It takes a pointer to a struct btf object, the enum name, size in bytes, and a boolean indicating if it's signed. The function returns a positive type ID on success or a negative value on error.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/btf__add_enum64.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nint btf__add_enum64(struct btf *btf, const char *name, __u32 bytes_sz, bool is_signed);\n```\n\n----------------------------------------\n\nTITLE: CGroup Move Preparation Callback Definition in C\nDESCRIPTION: Callback function signature for preparing task movement between cgroups. Takes task struct and source/destination cgroups as parameters.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/program-type/BPF_PROG_TYPE_STRUCT_OPS/sched_ext_ops.md#2025-04-22_snippet_32\n\nLANGUAGE: c\nCODE:\n```\ns32 (*cgroup_prep_move)(struct task_struct *p, struct cgroup *from, struct cgroup *to);\n```\n\n----------------------------------------\n\nTITLE: Testing Read-Only Restrictions with SKB Dynamic Pointers\nDESCRIPTION: Verifies that SKB-based dynamic pointers from cgroup_skb/egress are read-only and cannot be written to. This demonstrates the safety features of dynptrs with network buffers.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/concepts/dynptrs.md#2025-04-22_snippet_3\n\nLANGUAGE: c\nCODE:\n```\nSEC(\"?cgroup_skb/egress\")\nint test_skb_readonly(struct __sk_buff *skb)\n{\n\t__u8 write_data[2] = {1, 2};\n\tstruct bpf_dynptr ptr;\n\tint ret;\n\n\tif (bpf_dynptr_from_skb(skb, 0, &ptr)) {\n\t\terr = 1;\n\t\treturn 1;\n\t}\n\n\t/* since cgroup skbs are read only, writes should fail */\n\tret = bpf_dynptr_write(&ptr, 0, write_data, sizeof(write_data), 0);\n\tif (ret != -EINVAL) {\n\t\terr = 2;\n\t\treturn 1;\n\t}\n\n\treturn 1;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining hid_bpf_attach_prog KFunc in C\nDESCRIPTION: This snippet shows the C function signature for the hid_bpf_attach_prog kfunc. It takes a HID device identifier, a program file descriptor, and flags as parameters, returning a file descriptor or error code.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/hid_bpf_attach_prog.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nint hid_bpf_attach_prog(unsigned int hid_id, int prog_fd, __u32 flags)\n```\n\n----------------------------------------\n\nTITLE: Definition of btf__free function in libbpf\nDESCRIPTION: The function signature for btf__free, which frees all data associated with a BTF object. It takes a pointer to a struct btf as its only parameter and returns void.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/btf__free.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nvoid btf__free(struct btf *btf);\n```\n\n----------------------------------------\n\nTITLE: Checking if a Libbpf Map is Pinned in C\nDESCRIPTION: This C function signature defines `bpf_map__is_pinned` from the libbpf library. It takes a constant pointer to a `bpf_map` struct (`map`) as input and returns a boolean value indicating whether the map has been pinned to the BPF filesystem (`true` if pinned, `false` otherwise). This function is part of the libbpf userspace API.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_map__is_pinned.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nbool bpf_map__is_pinned(const struct bpf_map *map);\n```\n\n----------------------------------------\n\nTITLE: Definition of bpf_ct_change_timeout KFunc in C\nDESCRIPTION: Function signature for the bpf_ct_change_timeout kfunc that takes a pointer to an nf_conn object and a timeout value in milliseconds. This function allows changing the timeout associated with an inserted or looked up nf_conn object.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/bpf_ct_change_timeout.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nint bpf_ct_change_timeout(struct nf_conn *nfct, u32 timeout)\n```\n\n----------------------------------------\n\nTITLE: Definition of btf__parse_elf function in libbpf\nDESCRIPTION: Function prototype for btf__parse_elf which parses BTF data from an ELF file. It takes a path to the ELF file and a double pointer to store BTF extension data if present. Returns a struct btf pointer on success or NULL on failure.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/btf__parse_elf.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstruct btf *btf__parse_elf(const char *path, struct btf_ext **btf_ext);\n```\n\n----------------------------------------\n\nTITLE: BTF Endianness Enumeration Definition\nDESCRIPTION: Enum definition specifying possible endianness values for BTF extension objects. Defines little endian (0) and big endian (1) options.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/btf_ext__set_endianness.md#2025-04-22_snippet_1\n\nLANGUAGE: c\nCODE:\n```\nenum btf_endianness {\n\tBTF_LITTLE_ENDIAN = 0,\n\tBTF_BIG_ENDIAN = 1,\n};\n```\n\n----------------------------------------\n\nTITLE: Defining the 'bpf_enable_stats' Function Signature in C\nDESCRIPTION: This C code snippet shows the function signature for 'bpf_enable_stats'. It takes an 'enum bpf_stats_type' as input to specify the type of statistics to enable system-wide and returns an integer (0 on success, negative error code otherwise). This function is part of the libbpf library and requires linking against it.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_enable_stats.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n`#!c int bpf_enable_stats(enum bpf_stats_type type);`\n```\n\n----------------------------------------\n\nTITLE: Function Definition for bpf_map_lookup_and_delete_elem_flags\nDESCRIPTION: Low-level C function definition that provides a wrapper around the BPF_MAP_LOOKUP_AND_DELETE_ELEM syscall. The function takes a file descriptor, key pointer, value pointer, and flags as parameters, returning 0 on success or a negative error code on failure.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_map_lookup_and_delete_elem_flags.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nint bpf_map_lookup_and_delete_elem_flags(int fd, const void *key, void *value, __u64 flags);\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_strtoul Helper Function in C\nDESCRIPTION: This snippet defines the 'bpf_strtoul' helper function for eBPF programs. It converts a string to an unsigned long integer based on a specified base. The function handles whitespace, supports bases 8, 10, 16, or auto-detection, and returns the number of characters consumed or error codes.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_strtoul.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstatic long (* const bpf_strtoul)(const char *buf, unsigned long buf_len, __u64 flags, unsigned long *res) = (void *) 106;\n```\n\n----------------------------------------\n\nTITLE: Defining __kptr Macro in eBPF\nDESCRIPTION: This snippet shows the definition of the __kptr macro using the btf_type_tag attribute to mark a pointer as a kernel pointer. This allows the eBPF verifier to properly track kernel memory references.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/ebpf/__kptr.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n#define __kptr __attribute__((btf_type_tag(\"kptr\")))\n```\n\n----------------------------------------\n\nTITLE: KFunc Definition - scx_bpf_dsq_insert_vtime\nDESCRIPTION: Function signature and parameters for the scx_bpf_dsq_insert_vtime kernel function that inserts a task into a DSQ's vtime priority queue. Takes parameters for task struct, DSQ ID, execution slice duration, vtime value, and enqueue flags.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/scx_bpf_dsq_insert_vtime.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nvoid scx_bpf_dsq_insert_vtime(struct task_struct *p, u64 dsq_id, u64 slice, u64 vtime, u64 enq_flags)\n```\n\n----------------------------------------\n\nTITLE: Definition of libbpf_major_version function in C\nDESCRIPTION: Function signature for libbpf_major_version which returns the major version of the libbpf library as an unsigned 32-bit integer. This function takes no parameters and is available since libbpf version 0.6.0.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/libbpf_major_version.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n__u32 libbpf_major_version(void)\n```\n\n----------------------------------------\n\nTITLE: Defining libbpf_prog_setup_fn_t callback in C\nDESCRIPTION: Definition of the function pointer type for the BPF program initialization callback. This callback is called during bpf_object__open for each recognized BPF program.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/struct-libbpf_prog_handler_opts.md#2025-04-22_snippet_1\n\nLANGUAGE: c\nCODE:\n```\ntypedef int (*libbpf_prog_setup_fn_t)(struct bpf_program *prog, long cookie);\n```\n\n----------------------------------------\n\nTITLE: Defining the bpf_iter_scx_dsq_destroy KFunc in C\nDESCRIPTION: Signature of the bpf_iter_scx_dsq_destroy kernel function which destroys a DSQ iterator. It takes a pointer to a bpf_iter_scx_dsq structure as its parameter.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/bpf_iter_scx_dsq_destroy.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nvoid bpf_iter_scx_dsq_destroy(struct bpf_iter_scx_dsq *it)\n```\n\n----------------------------------------\n\nTITLE: Implementing a Packet Length Histogram with LWT_OUT BPF Program\nDESCRIPTION: This example demonstrates a BPF_PROG_TYPE_LWT_OUT program that creates a histogram of packet lengths. It uses a PERCPU_HASH map to store the distribution of packet sizes encountered in the egress path, classifying packets by the log2 of their length.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/program-type/BPF_PROG_TYPE_LWT_OUT.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n/* Copyright (c) 2016 Thomas Graf <tgraf@tgraf.ch>\n*\n* This program is free software; you can redistribute it and/or\n* modify it under the terms of version 2 of the GNU General Public\n* License as published by the Free Software Foundation.\n*\n* This program is distributed in the hope that it will be useful, but\n* WITHOUT ANY WARRANTY; without even the implied warranty of\n* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n* General Public License for more details.\n*/\n\n#include \"vmlinux.h\"\n#include <bpf/bpf_helpers.h>\n\nstruct {\n    __uint(type, BPF_MAP_TYPE_PERCPU_HASH);\n    __type(key, u64);\n    __type(value, u64);\n    __uint(pinning, LIBBPF_PIN_BY_NAME);\n    __uint(max_entries, 1024);\n} lwt_len_hist_map SEC(\".maps\");\n\nstatic unsigned int log2(unsigned int v)\n{\n    unsigned int r;\n    unsigned int shift;\n\n    r = (v > 0xFFFF) << 4; v >>= r;\n    shift = (v > 0xFF) << 3; v >>= shift; r |= shift;\n    shift = (v > 0xF) << 2; v >>= shift; r |= shift;\n    shift = (v > 0x3) << 1; v >>= shift; r |= shift;\n    r |= (v >> 1);\n    return r;\n}\n\nstatic unsigned int log2l(unsigned long v)\n{\n    unsigned int hi = v >> 32;\n    if (hi)\n        return log2(hi) + 32;\n    else\n        return log2(v);\n}\n\nSEC(\"len_hist\")\nint do_len_hist(struct __sk_buff *skb)\n{\n    __u64 *value, key, init_val = 1;\n\n    key = log2l(skb->len);\n\n    value = bpf_map_lookup_elem(&lwt_len_hist_map, &key);\n    if (value)\n        __sync_fetch_and_add(value, 1);\n    else\n        bpf_map_update_elem(&lwt_len_hist_map, &key, &init_val, BPF_ANY);\n\n    return BPF_OK;\n}\n```\n\n----------------------------------------\n\nTITLE: Definition of ring__consumer_pos function in C\nDESCRIPTION: Function signature for the ring__consumer_pos function which returns the current consumer position in a given ring buffer. It takes a constant pointer to a ring buffer structure and returns an unsigned long value representing the position.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/ring__consumer_pos.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nunsigned long ring__consumer_pos(const struct ring *r);\n```\n\n----------------------------------------\n\nTITLE: Defining btf__resolve_type function in C\nDESCRIPTION: Function definition for btf__resolve_type, which takes a pointer to a struct btf object and a type_id as parameters. It returns the type ID that the given type points to, or a negative error code on failure.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/btf__resolve_type.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nint btf__resolve_type(const struct btf *btf, __u32 type_id);\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_xdp_ct_lookup KFunc in C\nDESCRIPTION: Function signature for the bpf_xdp_ct_lookup kfunc, which looks up a CT entry for a given tuple in XDP programs. It returns a pointer to a refcounted nf_conn object.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/bpf_xdp_ct_lookup.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstruct nf_conn *bpf_xdp_ct_lookup(struct xdp_md *xdp_ctx, struct bpf_sock_tuple *bpf_tuple, u32 tuple__sz, struct bpf_ct_opts *opts, u32 opts__sz)\n```\n\n----------------------------------------\n\nTITLE: Definition of btf__add_func_param Function in C\nDESCRIPTION: Function signature for btf__add_func_param that adds a new parameter to a FUNC_PROTO type. Takes a btf struct pointer, parameter name, and type ID as arguments. Returns 0 on success and negative value on error.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/btf__add_func_param.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nint btf__add_func_param(struct btf *btf, const char *name, int type_id);\n```\n\n----------------------------------------\n\nTITLE: Defining BPF Attributes for uprobe_multi\nDESCRIPTION: This snippet provides the structure for the uprobe_multi attribute in eBPF, defining paths, offsets, and flags for uprobe operations. It includes various elements like `path`, `offsets`, `cookies`, and `pid` with comments suggesting that documentation could be improved, indicative of elements' roles in multi-probe setups.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/syscall/BPF_LINK_CREATE.md#2025-04-22_snippet_4\n\nLANGUAGE: C\nCODE:\n```\nunion bpf_attr {\n\tstruct {\n\t\t[...]\n\t\tunion {\n\t\t\tstruct {\n\t\t\t\t__aligned_u64\t[path](#uprobe_multi-path);\n\t\t\t\t__aligned_u64\t[offsets](#uprobe_multi-offsets);\n\t\t\t\t__aligned_u64\t[ref_ctr_offsets](#uprobe_multi-ref_ctr_offsets);\n\t\t\t\t__aligned_u64\t[cookies](#uprobe_multi-cookies);\n\t\t\t\t__u32\t\t\t[cnt](#uprobe_multi-cnt);\n\t\t\t\t__u32\t\t\t[flags](#uprobe_multi-flags);\n\t\t\t\t__u32\t\t\t[pid](#uprobe_multi-pid);\n\t\t\t} uprobe_multi;\n\t\t}\n\t}\n}\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_get_smp_processor_id Helper Function in C\nDESCRIPTION: Function definition for the bpf_get_smp_processor_id helper that returns the SMP processor ID. This helper runs with migration disabled to ensure stable processor ID during program execution.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_get_smp_processor_id.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstatic __bpf_fastcall __u32 (* const bpf_get_smp_processor_id)(void) = (void *) 8;\n```\n\n----------------------------------------\n\nTITLE: Defining eBPF Field Existence Macro in C\nDESCRIPTION: This code snippet defines the 'bpf_core_field_exists' macro used in eBPF programs to check for the existence of a particular struct field in the kernel. It relies on the '__builtin_preserve_field_info' function, marking a field reference and specifying 'BPF_FIELD_EXISTS'. The macro is crucial for adaptive eBPF programs that need to adjust if certain fields are unavailable in the kernel version they are being executed upon.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/ebpf/bpf_core_field_exists.md#2025-04-22_snippet_0\n\nLANGUAGE: C\nCODE:\n```\n#define bpf_core_field_exists(field...) \\n\\t__builtin_preserve_field_info(___bpf_field_ref(field), BPF_FIELD_EXISTS)\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_read_branch_records Helper Function in C\nDESCRIPTION: This snippet defines the bpf_read_branch_records helper function for eBPF programs. It retrieves branch records associated with a perf event context and stores them in a buffer. The function returns the number of bytes written or an error code.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_read_branch_records.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstatic long (* const bpf_read_branch_records)(struct bpf_perf_event_data *ctx, void *buf, __u32 size, __u64 flags) = (void *) 119;\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_snprintf_btf Helper Function in C\nDESCRIPTION: This code snippet defines the bpf_snprintf_btf helper function for eBPF programs. It uses BTF to store a string representation of a pointer in a specified buffer, with various flags for formatting options.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_snprintf_btf.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstatic long (* const bpf_snprintf_btf)(char *str, __u32 str_size, struct btf_ptr *ptr, __u32 btf_ptr_size, __u64 flags) = (void *) 149;\n```\n\n----------------------------------------\n\nTITLE: Callback Function Signature for bpf_timer_set_callback in eBPF C\nDESCRIPTION: Specifies the required signature for callback functions to be registered with 'bpf_timer_set_callback' in eBPF C. The callback must be a static function, accepting arguments for the BPF map, a pointer to the map's key type, and a pointer to the map's value type. The function returns an integer status code. Implementers must ensure the types match the eBPF map's expected key/value types. This function will be called when the associated timer expires.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_timer_set_callback.md#2025-04-22_snippet_1\n\nLANGUAGE: C\nCODE:\n```\nstatic int callback_fn(void *map, {map key type} *key, {map value type} *value)\n```\n\n----------------------------------------\n\nTITLE: KF_ITER_DESTROY Flag Documentation\nDESCRIPTION: Flag indicating that a KFunc destroys an iterator.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/concepts/kfuncs.md#2025-04-22_snippet_9\n\nLANGUAGE: markdown\nCODE:\n```\nKF_ITER_DESTROY\n```\n\n----------------------------------------\n\nTITLE: Struct Definition - bpf_prog_load_opts\nDESCRIPTION: Structure definition containing various options and parameters for BPF program loading, including retry attempts, attach types, BTF information, and logging options.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_prog_load.md#2025-04-22_snippet_1\n\nLANGUAGE: c\nCODE:\n```\nstruct bpf_prog_load_opts {\n\tsize_t sz;\n\tint attempts;\n\tenum bpf_attach_type expected_attach_type;\n\t__u32 prog_btf_fd;\n\t__u32 prog_flags;\n\t__u32 prog_ifindex;\n\t__u32 kern_version;\n\t__u32 attach_btf_id;\n\t__u32 attach_prog_fd;\n\t__u32 attach_btf_obj_fd;\n\tconst int *fd_array;\n\tconst void *func_info;\n\t__u32 func_info_cnt;\n\t__u32 func_info_rec_size;\n\tconst void *line_info;\n\t__u32 line_info_cnt;\n\t__u32 line_info_rec_size;\n\t__u32 log_level;\n\t__u32 log_size;\n\tchar *log_buf;\n\t__u32 log_true_size;\n\t__u32 token_fd;\n\t__u32 fd_array_cnt;\n\tsize_t :0;\n};\n```\n\n----------------------------------------\n\nTITLE: Getting BPF Map File Descriptor using libbpf (C)\nDESCRIPTION: This C function signature defines `bpf_map__fd` from the `libbpf` library. It takes a pointer to a `bpf_map` structure (`map`) as input and is intended to return the integer file descriptor associated with that BPF map. A negative value, specifically `-EINVAL`, indicates an error occurred during the operation.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_map__fd.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nint bpf_map__fd(const struct bpf_map *map);\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_msg_push_data Helper Function in C\nDESCRIPTION: This code snippet defines the 'bpf_msg_push_data' helper function for eBPF programs. It allows inserting data into a message at a specified offset, primarily used in socket policies.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_msg_push_data.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstatic long (* const bpf_msg_push_data)(struct sk_msg_md *msg, __u32 start, __u32 len, __u64 flags) = (void *) 90;\n```\n\n----------------------------------------\n\nTITLE: Defining btf__parse_split Function in C\nDESCRIPTION: This snippet shows the function signature for btf__parse_split. It takes a file path and a base BTF object as parameters, and returns a pointer to a struct btf object. The function is used to parse BTF data from a file, which can contain either raw BTF data or BTF data embedded in an ELF file.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/btf__parse_split.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstruct btf *btf__parse_split(const char *path, struct btf *base_btf);\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_sk_redirect_map Helper Function in C\nDESCRIPTION: This code snippet defines the 'bpf_sk_redirect_map' helper function used for redirecting a message to a socket referenced by a map. It specifies the function signature, return values, and its internal representation.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_sk_redirect_map.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstatic long (* const bpf_sk_redirect_map)(struct __sk_buff *skb, void *map, __u32 key, __u64 flags) = (void *) 52;\n```\n\n----------------------------------------\n\nTITLE: Defining scx_bpf_now KFunc in C\nDESCRIPTION: Function signature for the scx_bpf_now kfunc, which returns a u64 representing the current time in nanoseconds.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/scx_bpf_now.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nu64 scx_bpf_now()\n```\n\n----------------------------------------\n\nTITLE: Definition of bpf_dynptr_adjust KFunc\nDESCRIPTION: Function signature for the bpf_dynptr_adjust kernel function that adjusts the dynptr's interval by advancing the offset by 'start' bytes and optionally trimming it based on 'end'.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/bpf_dynptr_adjust.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nint bpf_dynptr_adjust(const struct bpf_dynptr *p, u32 start, u32 end)\n```\n\n----------------------------------------\n\nTITLE: Defining libbpf_prog_attach_fn_t callback in C\nDESCRIPTION: Definition of the function pointer type for the BPF program attach callback. This callback is called during skeleton attach or through bpf_program__attach.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/struct-libbpf_prog_handler_opts.md#2025-04-22_snippet_3\n\nLANGUAGE: c\nCODE:\n```\ntypedef int (*libbpf_prog_attach_fn_t)(const struct bpf_program *prog, long cookie,\n\t\t\t\t       struct bpf_link **link);\n```\n\n----------------------------------------\n\nTITLE: Using xsk_ring_prod__fill_addr in C to Access Fill Ring Slots\nDESCRIPTION: This function signature shows how to use xsk_ring_prod__fill_addr to get a pointer to a slot in the fill ring for setting packet buffer addresses. It returns a pointer to a 64-bit address of the packet.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libxdp/functions/xsk_ring_prod__fill_addr.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n__u64 *xsk_ring_prod__fill_addr(struct xsk_ring_prod *fill, __u32 idx);\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_xdp_metadata_rx_timestamp KFunc in C\nDESCRIPTION: Function signature for the bpf_xdp_metadata_rx_timestamp kfunc. It takes a const pointer to xdp_md struct and a pointer to u64 for timestamp as parameters, and returns an int.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/bpf_xdp_metadata_rx_timestamp.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nint bpf_xdp_metadata_rx_timestamp(const struct xdp_md *ctx, u64 *timestamp)\n```\n\n----------------------------------------\n\nTITLE: Defining BTF String Search Function in C\nDESCRIPTION: Function definition for btf__find_str that searches for a string in the BTF string section. Takes a BTF structure pointer and target string as parameters. Returns positive offset if found, -ENOENT if not found, or negative error code for other errors.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/btf__find_str.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nint btf__find_str(struct btf *btf, const char *s);\n```\n\n----------------------------------------\n\nTITLE: Definition of KERNEL_VERSION Macro in C\nDESCRIPTION: The KERNEL_VERSION macro converts a three-part version number (major.minor.patch) to a single integer representation by shifting each component into specific bit positions.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/ebpf/KERNEL_VERSION.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n#define KERNEL_VERSION(a, b, c) (((a) << 16) + ((b) << 8) + ((c) > 255 ? 255 : (c)))\n```\n\n----------------------------------------\n\nTITLE: Defining XDP Flow Table Lookup Function\nDESCRIPTION: Kernel function definition for bpf_xdp_flow_lookup that performs flow table entry lookups based on FIB tuples. The function takes XDP metadata, FIB lookup parameters, flow table options, and returns a flow offload tuple.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/bpf_xdp_flow_lookup.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstruct flow_offload_tuple_rhash *bpf_xdp_flow_lookup(struct xdp_md *ctx, struct bpf_fib_lookup *fib_tuple, struct bpf_flowtable_opts *opts, u32 opts_len)\n```\n\n----------------------------------------\n\nTITLE: Defining btf__add_union Function in C for BTF Object Manipulation\nDESCRIPTION: This function appends a new BTF_KIND_UNION type to a BTF object. It takes a pointer to a struct btf object, the name of the union (which can be NULL or empty for anonymous unions), and the size of the union in bytes. It returns the type ID of the newly added BTF type on success, or a negative value on error.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/btf__add_union.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nint btf__add_union(struct btf *btf, const char *name, __u32 sz);\n```\n\n----------------------------------------\n\nTITLE: Defining libbpf strict mode options in C\nDESCRIPTION: This enum defines the various strict mode options that can be passed to libbpf_set_strict_mode(). It includes options like LIBBPF_STRICT_ALL, LIBBPF_STRICT_NONE, and several specific flags that control different aspects of libbpf's behavior. Note that as of libbpf 1.0, this enum and the associated function have no effect.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/libbpf_set_strict_mode.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n/* As of libbpf 1.0 libbpf_set_strict_mode() and enum libbpf_struct_mode have\n * no effect. But they are left in libbpf_legacy.h so that applications that\n * prepared for libbpf 1.0 before final release by using\n * libbpf_set_strict_mode() still work with libbpf 1.0+ without any changes.\n */\nenum libbpf_strict_mode {\n\t/* Turn on all supported strict features of libbpf to simulate libbpf\n\t * v1.0 behavior.\n\t * This will be the default behavior in libbpf v1.0.\n\t */\n\tLIBBPF_STRICT_ALL = 0xffffffff,\n\n\t/*\n\t * Disable any libbpf 1.0 behaviors. This is the default before libbpf\n\t * v1.0. It won't be supported anymore in v1.0, please update your\n\t * code so that it handles LIBBPF_STRICT_ALL mode before libbpf v1.0.\n\t */\n\tLIBBPF_STRICT_NONE = 0x00,\n\t/*\n\t * Return NULL pointers on error, not ERR_PTR(err).\n\t * Additionally, libbpf also always sets errno to corresponding Exx\n\t * (positive) error code.\n\t */\n\tLIBBPF_STRICT_CLEAN_PTRS = 0x01,\n\t/*\n\t * Return actual error codes from low-level APIs directly, not just -1.\n\t * Additionally, libbpf also always sets errno to corresponding Exx\n\t * (positive) error code.\n\t */\n\tLIBBPF_STRICT_DIRECT_ERRS = 0x02,\n\t/*\n\t * Enforce strict BPF program section (SEC()) names.\n\t * E.g., while prefiously SEC(\"xdp_whatever\") or SEC(\"perf_event_blah\") were\n\t * allowed, with LIBBPF_STRICT_SEC_PREFIX this will become\n\t * unrecognized by libbpf and would have to be just SEC(\"xdp\") and\n\t * SEC(\"xdp\") and SEC(\"perf_event\").\n\t *\n\t * Note, in this mode the program pin path will be based on the\n\t * function name instead of section name.\n\t *\n\t * Additionally, routines in the .text section are always considered\n\t * sub-programs. Legacy behavior allows for a single routine in .text\n\t * to be a program.\n\t */\n\tLIBBPF_STRICT_SEC_NAME = 0x04,\n\t/*\n\t * Disable the global 'bpf_objects_list'. Maintaining this list adds\n\t * a race condition to bpf_object__open() and bpf_object__close().\n\t * Clients can maintain it on their own if it is valuable for them.\n\t */\n\tLIBBPF_STRICT_NO_OBJECT_LIST = 0x08,\n\t/*\n\t * Automatically bump RLIMIT_MEMLOCK using setrlimit() before the\n\t * first BPF program or map creation operation. This is done only if\n\t * kernel is too old to support memcg-based memory accounting for BPF\n\t * subsystem. By default, RLIMIT_MEMLOCK limit is set to RLIM_INFINITY,\n\t * but it can be overridden with libbpf_set_memlock_rlim() API.\n\t * Note that libbpf_set_memlock_rlim() needs to be called before\n\t * the very first bpf_prog_load(), bpf_map_create() or bpf_object__load()\n\t * operation.\n\t */\n\tLIBBPF_STRICT_AUTO_RLIMIT_MEMLOCK = 0x10,\n\t/*\n\t * Error out on any SEC(\"maps\") map definition, which are deprecated\n\t * in favor of BTF-defined map definitions in SEC(\".maps\").\n\t */\n\tLIBBPF_STRICT_MAP_DEFINITIONS = 0x20,\n\n\t__LIBBPF_STRICT_LAST,\n};\n```\n\n----------------------------------------\n\nTITLE: Defining the bpf_map__map_extra Function in C\nDESCRIPTION: This C code snippet shows the function signature for 'bpf_map__map_extra'. It takes a constant pointer to a 'bpf_map' struct ('map') as input and returns a '__u64' representing the map's extra flags ('map_extra'), which are associated with the map during its creation.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_map__map_extra.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n__u64 bpf_map__map_extra(const struct bpf_map *map);\n```\n\n----------------------------------------\n\nTITLE: Defining scx_bpf_dsq_insert KFunc in C\nDESCRIPTION: Function signature for the scx_bpf_dsq_insert kfunc, which inserts a task into a Dispatch Queue's FIFO queue. It takes parameters for the task, DSQ ID, execution slice duration, and enqueue flags.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/scx_bpf_dsq_insert.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nvoid scx_bpf_dsq_insert(struct task_struct *p, u64 dsq_id, u64 slice, u64 enq_flags)\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_prog_bind_opts struct in C\nDESCRIPTION: This struct definition is used for configuring options when binding a BPF program to a map. It includes fields for the struct size and flags.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_prog_bind_map.md#2025-04-22_snippet_1\n\nLANGUAGE: c\nCODE:\n```\nstruct bpf_prog_bind_opts {\n\tsize_t sz; /* size of this struct for forward/backward compatibility */\n\t__u32 flags;\n};\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_probe_write_user Helper Function in C\nDESCRIPTION: This code snippet defines the bpf_probe_write_user helper function, which attempts to safely write data from a source buffer to a user space destination address. It's intended for debugging and manipulation of semi-cooperative processes, but comes with risks and limitations.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_probe_write_user.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstatic long (* const bpf_probe_write_user)(void *dst, const void *src, __u32 len) = (void *) 36;\n```\n\n----------------------------------------\n\nTITLE: Defining BTF Type Name Lookup Function in C\nDESCRIPTION: Function definition for btf__find_by_name that takes a BTF object pointer and type name as parameters, returning the type ID or a negative error code.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/btf__find_by_name.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n__s32 btf__find_by_name(const struct btf *btf, const char *type_name);\n```\n\n----------------------------------------\n\nTITLE: Destroying BPF Link in Libbpf C\nDESCRIPTION: The function 'bpf_link__destroy' is used to detach a BPF link from the kernel and deallocate any resources associated with it. It requires a valid pointer to a BPF link as input and returns '0' on success or '-1' on error. Users should ensure the link is valid before calling this function.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_link__destroy.md#2025-04-22_snippet_0\n\nLANGUAGE: C\nCODE:\n```\n#!c int bpf_link__destroy(struct bpf_link *link);\n```\n\n----------------------------------------\n\nTITLE: Libbpf btf__relocate Function Definition\nDESCRIPTION: C function definition for btf__relocate that takes two BTF structure pointers as parameters. The function verifies BTF references and adjusts type IDs and strings to accommodate re-parenting of BTF objects.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/btf__relocate.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nint btf__relocate(struct btf *btf, const struct btf *base_btf);\n```\n\n----------------------------------------\n\nTITLE: CPU Acquisition Operation\nDESCRIPTION: Handles when a CPU becomes available to the BPF scheduler after being previously released.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/program-type/BPF_PROG_TYPE_STRUCT_OPS/sched_ext_ops.md#2025-04-22_snippet_21\n\nLANGUAGE: c\nCODE:\n```\nvoid (*cpu_acquire)(s32 cpu, struct scx_cpu_acquire_args *args);\n```\n\n----------------------------------------\n\nTITLE: Defining scx_bpf_dsq_move KFunc in C\nDESCRIPTION: Function signature for the scx_bpf_dsq_move kfunc. It takes a DSQ iterator, task struct, DSQ ID, and enqueue flags as parameters, and returns a boolean indicating success.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/scx_bpf_dsq_move.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nbool scx_bpf_dsq_move(struct bpf_iter_scx_dsq *it__iter, struct task_struct *p, u64 dsq_id, u64 enq_flags)\n```\n\n----------------------------------------\n\nTITLE: Definition of bpf_get_current_uid_gid Helper Function\nDESCRIPTION: C function definition for the bpf_get_current_uid_gid helper that returns a 64-bit integer containing the current GID in the upper 32 bits and current UID in the lower 32 bits.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_get_current_uid_gid.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstatic __u64 (* const bpf_get_current_uid_gid)(void) = (void *) 15;\n```\n\n----------------------------------------\n\nTITLE: BPF fd_array_cnt Attribute Documentation\nDESCRIPTION: Documents the fd_array_cnt attribute (introduced in v6.14) which requires the fd_array to contain contiguous elements with valid file descriptors. The program takes refcounts on all file descriptors in the array.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/syscall/BPF_PROG_LOAD.md#2025-04-22_snippet_1\n\nLANGUAGE: markdown\nCODE:\n```\n### `fd_array_cnt`\n\n[:octicons-tag-24: v6.14](https://github.com/torvalds/linux/commit/4d3ae294f900fb7232fb6c890dbd3176b8a5f121)\n\nIf set, the [`fd_array`](#fd_array) must be contiguous of `fd_array_cnt` elements and all file descriptors must be valid. The array may contain file descriptors of maps and BTF objects. The program will take a refcount on all file descriptors in the array, not just the ones referenced by instructions.\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_program__fd function in C for libbpf\nDESCRIPTION: This snippet defines the bpf_program__fd function, which returns the file descriptor of a BPF program. It takes a const struct bpf_program pointer as an argument and returns an integer representing the file descriptor or a negative error code on failure.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_program__fd.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nint bpf_program__fd(const struct bpf_program *prog);\n```\n\n----------------------------------------\n\nTITLE: Retrieving BPF Program Name with bpf_program__name in C\nDESCRIPTION: Function definition for bpf_program__name that returns the name of a BPF program. It takes a pointer to a bpf_program structure as input and returns a const char pointer to the program name.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_program__name.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nconst char *bpf_program__name(const struct bpf_program *prog);\n```\n\n----------------------------------------\n\nTITLE: Defining eBPF Helper Function in C\nDESCRIPTION: This snippet defines the 'bpf_sysctl_get_new_value' eBPF helper function. It retrieves a new value written from user space to sysctl and copies it as a string into a buffer provided by the eBPF program. ‘bpf_sysctl_get_new_value’ must be assigned with a specific buffer and is terminated with a NUL unless the buffer size is zero. The function returns the number of characters copied, excluding the trailing NUL, and different error codes if the buffer is insufficient or if sysctl is being read instead.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_sysctl_get_new_value.md#2025-04-22_snippet_0\n\nLANGUAGE: C\nCODE:\n```\n#!c static long (* const bpf_sysctl_get_new_value)(struct bpf_sysctl *ctx, char *buf, unsigned long buf_len) = (void *) 103;\n```\n\n----------------------------------------\n\nTITLE: Defining the bpf_key_put KFunc in C\nDESCRIPTION: Function definition for the bpf_key_put kfunc that decrements the reference count of a key inside a bkey structure and frees the bkey. This function releases the pointer passed to it, invalidating all copies of that pointer.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/bpf_key_put.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nvoid bpf_key_put(struct bpf_key *bkey)\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_usdt_opts structure in C\nDESCRIPTION: This snippet defines the bpf_usdt_opts structure used in the bpf_program__attach_usdt function. It includes fields for specifying the structure size and a custom user-provided cookie value that can be retrieved using bpf_get_attach_cookie.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_program__attach_usdt.md#2025-04-22_snippet_1\n\nLANGUAGE: c\nCODE:\n```\nstruct bpf_usdt_opts {\n\t/* size of this struct, for forward/backward compatibility */\n\tsize_t sz;\n\t__u64 usdt_cookie;\n\tsize_t :0;\n};\n```\n\n----------------------------------------\n\nTITLE: Defining the cubictcp_cong_avoid KFunc Signature in C\nDESCRIPTION: This snippet provides the C function signature for the 'cubictcp_cong_avoid' eBPF kfunc. It takes a pointer to a socket structure ('struct sock *sk'), an acknowledgment number ('u32 ack'), and the count of acknowledged packets ('u32 acked') as arguments. The function returns void and is intended to be called from eBPF programs of type BPF_PROG_TYPE_STRUCT_OPS to perform CUBIC TCP congestion window calculations.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/cubictcp_cong_avoid.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nvoid cubictcp_cong_avoid(struct sock *sk, u32 ack, u32 acked)\n```\n\n----------------------------------------\n\nTITLE: Defining Return Codes for TCX Programs in C\nDESCRIPTION: Defines a simple enumeration for user return codes in tcx programs. Each return code maps to specific actions essential for the behavior compatibility of tcx programs. This C snippet requires inclusion in kernel source files and assists in defining program behavior based on user-defined actions such as passing, dropping, or redirecting packets.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/program-type/BPF_PROG_TYPE_SCHED_CLS.md#2025-04-22_snippet_2\n\nLANGUAGE: C\nCODE:\n```\n\"enum tcx_action_base {\\n\\tTCX_NEXT\\t= -1,\\n\\tTCX_PASS\\t= 0,\\n\\tTCX_DROP\\t= 2,\\n\\tTCX_REDIRECT\\t= 7,\\n};\"\n```\n\n----------------------------------------\n\nTITLE: Using BPF_SEQ_PRINTF in an eBPF Iterator Program in C\nDESCRIPTION: This C code demonstrates the usage of the `BPF_SEQ_PRINTF` macro within an eBPF iterator program attached to `iter/task_file`. The function `dump_task_file` receives context via `bpf_iter__task_file`, including the sequence file (`seq`), task structure (`task`), and file descriptor (`fd`). It first prints a header line using `BPF_SEQ_PRINTF` only on the first call (`ctx->meta->seq_num == 0`). Subsequently, for each relevant task, it formats and prints the task's tgid, pid, file descriptor, and file operations address to the sequence file using `BPF_SEQ_PRINTF`. The `hl_lines` comment indicates the specific lines (14, 25, 26) where the macro is invoked.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/ebpf/bpf_seq_printf.md#2025-04-22_snippet_1\n\nLANGUAGE: c\nCODE:\n```\nSEC(\"iter/task_file\")\nint dump_task_file(struct bpf_iter__task_file *ctx)\n{\n    struct seq_file *seq = ctx->meta->seq;\n    struct task_struct *task = ctx->task;\n    struct file *file = ctx->file;\n    __u32 fd = ctx->fd;\n\n    if (task == NULL || file == NULL)\n        return 0;\n\n    if (ctx->meta->seq_num == 0) {\n        count = 0;\n        BPF_SEQ_PRINTF(seq, \"    tgid      gid       fd      file\\n\");\n    }\n\n    if (tgid == task->tgid && task->tgid != task->pid)\n        count++;\n\n    if (last_tgid != task->tgid) {\n        last_tgid = task->tgid;\n        unique_tgid_count++;\n    }\n\n    BPF_SEQ_PRINTF(seq, \"%8d %8d %8d %lx\\n\", task->tgid, task->pid, fd,\n            (long)file->f_op);\n    return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining the bpf_dynptr_size kernel function in C\nDESCRIPTION: Function signature for bpf_dynptr_size which returns the number of usable bytes in a dynptr. It takes a const struct bpf_dynptr pointer as input and returns an unsigned 32-bit integer.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/bpf_dynptr_size.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n__u32 bpf_dynptr_size(const struct bpf_dynptr *p)\n```\n\n----------------------------------------\n\nTITLE: Defining scx_bpf_bstr_preamble Macro in C\nDESCRIPTION: This code snippet defines the scx_bpf_bstr_preamble macro. It initializes the fmt and variadic argument inputs for bstr kfuncs. The macro uses GCC pragmas to ignore int-conversion warnings and calls the ___bpf_fill function to populate the parameter array.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/scx/scx_bpf_bstr_preamble.md#2025-04-22_snippet_0\n\nLANGUAGE: C\nCODE:\n```\n#define scx_bpf_bstr_preamble(fmt, args...)                         \\\n\tstatic char ___fmt[] = fmt;                                     \\\n\tunsigned long long ___param[___bpf_narg(args) ?: 1] = {};       \\\n                                                                    \\\n\t_Pragma(\"GCC diagnostic push\")                                  \\\n\t_Pragma(\"GCC diagnostic ignored \\\"-Wint-conversion\\\"\")          \\\n\t[___bpf_fill](../libbpf/ebpf/___bpf_fill.md)(___param, args);                                    \\\n\t_Pragma(\"GCC diagnostic pop\")\n```\n\n----------------------------------------\n\nTITLE: Definition of bpf_ct_insert_entry KFunc in C\nDESCRIPTION: The kfunc definition for bpf_ct_insert_entry that takes a pointer to an nf_conn___init object and returns a pointer to an nf_conn structure. This function adds the provided entry into a CT map.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/bpf_ct_insert_entry.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstruct nf_conn *bpf_ct_insert_entry(struct nf_conn___init *nfct_i)\n```\n\n----------------------------------------\n\nTITLE: Defining scx_bpf_consume KFunc in C\nDESCRIPTION: Function signature for the scx_bpf_consume kfunc, which takes a dsq_id parameter and returns a boolean value.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/scx_bpf_consume.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nbool scx_bpf_consume(u64 dsq_id)\n```\n\n----------------------------------------\n\nTITLE: Defining btf_var_linkage enum in C\nDESCRIPTION: This enum defines the possible linkage types for BTF variables. It includes static, global allocated, and global extern linkage types. This enum is likely used in conjunction with the btf__add_var function to specify the variable's linkage.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/btf__add_var.md#2025-04-22_snippet_1\n\nLANGUAGE: c\nCODE:\n```\nenum {\n\tBTF_VAR_STATIC = 0,\n\tBTF_VAR_GLOBAL_ALLOCATED = 1,\n\tBTF_VAR_GLOBAL_EXTERN = 2,\n};\n```\n\n----------------------------------------\n\nTITLE: Function Definition - scx_bpf_dispatch_vtime_from_dsq\nDESCRIPTION: The kernel function signature that defines the dispatch virtual time operation from a dispatch queue. Takes iterator, task struct, queue ID and flags as parameters and returns a boolean value.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/scx_bpf_dispatch_vtime_from_dsq.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nbool scx_bpf_dispatch_vtime_from_dsq(struct bpf_iter_scx_dsq *it__iter, struct task_struct *p, u64 dsq_id, u64 enq_flags)\n```\n\n----------------------------------------\n\nTITLE: Defining the bpf_prog_detach Function in C\nDESCRIPTION: The definition of the bpf_prog_detach function that takes an attachable file descriptor and attachment type as parameters. It returns 0 on success or a negative error code on failure.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_prog_detach.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nint bpf_prog_detach(int attachable_fd, enum bpf_attach_type type);\n```\n\n----------------------------------------\n\nTITLE: Definition of bpf_object__open_subskeleton function in C\nDESCRIPTION: The C function definition for bpf_object__open_subskeleton, which takes a pointer to a bpf_object_subskeleton structure and returns an integer status code. This function is used to open a BPF sub-skeleton.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_object__open_subskeleton.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nint bpf_object__open_subskeleton(struct bpf_object_subskeleton *s);\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_raw_tracepoint_open Function in C\nDESCRIPTION: Function signature for bpf_raw_tracepoint_open which is a low-level wrapper around the BPF_RAW_TRACEPOINT_OPEN syscall command. It takes a tracepoint name and program file descriptor as parameters and returns a file descriptor or negative error code.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_raw_tracepoint_open.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nint bpf_raw_tracepoint_open(const char *name, int prog_fd);\n```\n\n----------------------------------------\n\nTITLE: Using xdp_multiprog__next_prog Function in C\nDESCRIPTION: Function declaration for retrieving the next loaded program in an XDP dispatcher. Returns a pointer to the next XDP program if successful, or a negative error code on failure.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libxdp/functions/xdp_multiprog__next_prog.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstruct xdp_program *xdp_multiprog__next_prog(const struct xdp_program *prog, const struct xdp_multiprog *mp);\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_obj_pin_opts Structure in C\nDESCRIPTION: Structure definition for bpf_obj_pin_opts used by the bpf_obj_pin_opts function. Contains fields for size tracking (sz), file flags (file_flags), and path file descriptor (path_fd).\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_obj_pin_opts.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstruct bpf_obj_pin_opts {\n\tsize_t sz; /* size of this struct for forward/backward compatibility */\n\n\t__u32 file_flags;\n\tint path_fd;\n\n\tsize_t :0;\n};\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_session_cookie KFunc in C\nDESCRIPTION: Function signature for the bpf_session_cookie kernel function that returns a pointer to a 64-bit session cookie value. This function is available since Linux kernel v6.10 and can be used to store and load values between entry and return callbacks.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/bpf_session_cookie.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n__u64 *bpf_session_cookie()\n```\n\n----------------------------------------\n\nTITLE: Definition of btf__name_by_offset Function in C\nDESCRIPTION: This function retrieves the name of a BTF (BPF Type Format) type based on its offset within the BTF object. It takes a BTF object pointer and an offset as parameters, and returns a const pointer to the name string.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/btf__name_by_offset.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nconst char *btf__name_by_offset(const struct btf *btf, __u32 offset);\n```\n\n----------------------------------------\n\nTITLE: Using PT_REGS_SP Macro with Target Architecture Specification\nDESCRIPTION: The PT_REGS_SP macro extracts the stack pointer from struct pt_regs contexts in an architecture-independent way. Architecture targeting is achieved by setting __TARGET_ARCH_{arch} macros through compiler flags like -D__TARGET_ARCH_x86 for x86 architectures.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/ebpf/PT_REGS_SP.md#2025-04-22_snippet_0\n\nLANGUAGE: C\nCODE:\n```\n-D__TARGET_ARCH_x86\n```\n\n----------------------------------------\n\nTITLE: Using bpf_ntohl in socket binding eBPF program in C\nDESCRIPTION: This code snippet demonstrates the usage of bpf_ntohl in an eBPF program that filters socket bind operations. It allows binding only to a specific IP address (192.168.1.254) and port (4040) by converting network byte order values to host byte order for comparison.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/ebpf/bpf_ntohl.md#2025-04-22_snippet_1\n\nLANGUAGE: c\nCODE:\n```\n#define SERV4_IP  0xc0a801feU /* 192.168.1.254 */\n#define SERV4_PORT  4040\n\nSEC(\"cgroup/bind4\")\nint bind_v4_prog(struct bpf_sock_addr *ctx)\n{\n struct bpf_sock *sk;\n\n sk = ctx->sk;\n if (!sk)\n  return 0;\n\n if (sk->family != AF_INET)\n  return 0;\n\n if (bpf_ntohl(ctx->user_ip4) != SERV4_IP ||\n    bpf_ntohs(ctx->user_port) != SERV4_PORT)\n  return 0;\n    \n    return 1;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_send_signal_thread Helper Function in C\nDESCRIPTION: C function definition for the bpf_send_signal_thread eBPF helper. This function sends a signal to the thread of the current task. It returns 0 on success or when successfully queued, and various error codes for different failure scenarios.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_send_signal_thread.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstatic long (* const bpf_send_signal_thread)(__u32 sig) = (void *) 117;\n```\n\n----------------------------------------\n\nTITLE: Definition of btf__str_by_offset Function in C\nDESCRIPTION: The function signature for btf__str_by_offset, which takes a BTF object and an offset as parameters and returns a const pointer to the name of the type.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/btf__str_by_offset.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nconst char *btf__str_by_offset(const struct btf *btf, __u32 offset);\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_map__set_map_flags in Libbpf - C\nDESCRIPTION: The function 'bpf_map__set_map_flags' is used in Libbpf applications to assign flags to a BPF map during its creation. It requires a pointer to a BPF map object and a 32-bit unsigned integer for the flags. The function modifies flags before loading the map and returns 0 on success, or a negative value if it fails.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_map__set_map_flags.md#2025-04-22_snippet_0\n\nLANGUAGE: C\nCODE:\n```\n#!c int bpf_map__set_map_flags(struct bpf_map *map, __u32 flags);\n```\n\n----------------------------------------\n\nTITLE: Function Definition of bpf_program__log_level in C\nDESCRIPTION: Defines the bpf_program__log_level function that returns the verifier log level for a BPF program. The function takes a BPF program pointer as input and returns a 32-bit unsigned integer representing the log level.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_program__log_level.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n__u32 bpf_program__log_level(const struct bpf_program *prog);\n```\n\n----------------------------------------\n\nTITLE: Using 'container_of' in a Simple C Example\nDESCRIPTION: Illustrates a basic use case for `container_of`. Given a pointer `b_ptr` to a `struct b` which is itself a member (`b`) of `struct a`, it retrieves a pointer to the containing `struct a` using `container_of(b_ptr, struct a, b)`. This allows accessing other members of the parent structure, such as `a->y`, from the member pointer.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/ebpf/container_of.md#2025-04-22_snippet_1\n\nLANGUAGE: c\nCODE:\n```\nstruct a {\n    int x;\n    int y;\n    struct b b;\n}\n\nstruct b {\n    int z;\n}\n\nint some_func(struct b *b) {\n    struct a *a = container_of(b, struct a, b);\n    return a->y;\n}\n```\n\n----------------------------------------\n\nTITLE: Deleting Umem Area Using xsk_umem__delete\nDESCRIPTION: Function signature for deleting an umem area. Returns 0 on success, -EINVAL for invalid arguments, or -EBUSY if the umem is busy.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libxdp/functions/xsk_umem__delete.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nint xsk_umem__delete(struct xsk_umem *umem);\n```\n\n----------------------------------------\n\nTITLE: Defining Task States Enum in SCX Framework (C)\nDESCRIPTION: Defines the enum scx_task_state which represents the various states a task can be in within the SCX framework, from uninitialized (NONE) to fully initialized and managed by sched_ext (ENABLED).\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/program-type/BPF_PROG_TYPE_STRUCT_OPS/sched_ext_ops.md#2025-04-22_snippet_44\n\nLANGUAGE: c\nCODE:\n```\nenum scx_task_state {\n\tSCX_TASK_NONE,\n\tSCX_TASK_INIT,\n\tSCX_TASK_READY,\n\tSCX_TASK_ENABLED,\n};\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_ntohl macro for network to host byte order conversion in C\nDESCRIPTION: This code snippet defines the bpf_ntohl macro, which converts a 32-bit number from network byte order to host byte order. It accounts for different system endianness and optimizes for compile-time constants.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/ebpf/bpf_ntohl.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n#define ___bpf_mvb(x, b, n, m) ((__u##b)(x) << (b-(n+1)*8) >> (b-8) << (m*8))\n\n#define ___bpf_swab32(x) ((__u32)(   \n   ___bpf_mvb(x, 32, 0, 3) | \n   ___bpf_mvb(x, 32, 1, 2) | \n   ___bpf_mvb(x, 32, 2, 1) | \n   ___bpf_mvb(x, 32, 3, 0)))\n\n#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__\n# define __bpf_ntohl(x)   __builtin_bswap32(x)\n# define __bpf_constant_ntohl(x) ___bpf_swab32(x)\n#elif __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__\n# define __bpf_ntohl(x)   (x)\n# define __bpf_constant_ntohl(x) (x)\n#else\n# error \"Fix your compiler's __BYTE_ORDER__?!\"\n#endif\n\n#define bpf_ntohl(x)    \n (__builtin_constant_p(x) ?  \n __bpf_constant_ntohl(x) : __bpf_ntohl(x))\n```\n\n----------------------------------------\n\nTITLE: Defining the bpf_cgrp_storage_get eBPF Helper Function in C\nDESCRIPTION: C function prototype for the bpf_cgrp_storage_get helper that retrieves or creates a bpf_local_storage from a cgroup. The function takes a map pointer, cgroup pointer, optional initial value, and flags as parameters.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_cgrp_storage_get.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstatic void *(* const bpf_cgrp_storage_get)(void *map, struct cgroup *cgroup, void *value, __u64 flags) = (void *) 210;\n```\n\n----------------------------------------\n\nTITLE: BPF_F_TEST_STATE_FREQ Flag Documentation\nDESCRIPTION: Documents the BPF_F_TEST_STATE_FREQ internal testing flag (introduced in v5.4) used for stress testing state pruning in the BPF verifier, with undefined behavior in normal usage.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/syscall/BPF_PROG_LOAD.md#2025-04-22_snippet_5\n\nLANGUAGE: markdown\nCODE:\n```\n### `BPF_F_TEST_STATE_FREQ`\n\n<!-- [FEATURE_TAG](BPF_F_TEST_STATE_FREQ) -->\n[:octicons-tag-24: v5.4](https://github.com/torvalds/linux/commit/10d274e880eb208ec6a76261a9f8f8155020f771)\n<!-- [/FEATURE_TAG] -->\n\nThe verifier internal test flag used for stress testing state pruning. \n\n!!! warning\n    Behavior is undefined \n```\n\n----------------------------------------\n\nTITLE: Setting Interface Index for BPF Program Function Definition\nDESCRIPTION: Function definition for bpf_program__set_ifindex that sets the interface index for a BPF program. This is specifically used for BPF_PROG_TYPE_XDP programs that are offloaded to hardware, allowing the kernel to identify the target network device during program loading.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_program__set_ifindex.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nvoid bpf_program__set_ifindex(struct bpf_program *prog, __u32 ifindex);\n```\n\n----------------------------------------\n\nTITLE: Function Definition for bpf_program__attach_cgroup\nDESCRIPTION: C function definition for attaching a BPF program to a cgroup. Takes a BPF program pointer and cgroup file descriptor as parameters. Returns a pointer to the created BPF link or NULL on error.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_program__attach_cgroup.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstruct bpf_link * bpf_program__attach_cgroup(const struct bpf_program *prog, int cgroup_fd);\n```\n\n----------------------------------------\n\nTITLE: Defining the bpf_prog_get_info_by_fd function in C\nDESCRIPTION: Function signature for bpf_prog_get_info_by_fd which obtains information about a BPF program using its file descriptor. It takes a program file descriptor, a pointer to a bpf_prog_info structure, and a pointer to the size of the info structure.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_prog_get_info_by_fd.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nint bpf_prog_get_info_by_fd(int prog_fd, struct bpf_prog_info *info, __u32 *info_len);\n```\n\n----------------------------------------\n\nTITLE: Definition of bpf_get_file_xattr KFunc in C\nDESCRIPTION: The C function signature for the bpf_get_file_xattr kernel function which retrieves extended attributes from a file. It requires a file pointer, attribute name string (only those with \"user.\" prefix are allowed), and a dynamic pointer to store the result value.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/bpf_get_file_xattr.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nint bpf_get_file_xattr(struct file *file, const char *name__str, struct bpf_dynptr *value_p)\n```\n\n----------------------------------------\n\nTITLE: BTF Integer Encoding Flags\nDESCRIPTION: Macro definitions for BTF integer type encoding flags. Includes flags for signed integers, character types, and boolean values.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/btf__add_int.md#2025-04-22_snippet_1\n\nLANGUAGE: c\nCODE:\n```\n/* Attributes stored in the BTF_INT_ENCODING */\n#define BTF_INT_SIGNED\t(1 << 0)\n#define BTF_INT_CHAR\t(1 << 1)\n#define BTF_INT_BOOL\t(1 << 2)\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_map__max_entries in C\nDESCRIPTION: This snippet documents the 'bpf_map__max_entries' function in C, which retrieves the maximum number of entries in a BPF map. The function takes a pointer to a 'bpf_map' structure and returns a 32-bit unsigned integer representing the maximum entries allowed. It relies on the libbpf library to operate and expects a valid 'bpf_map' pointer as input.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_map__max_entries.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n__u32 bpf_map__max_entries(const struct bpf_map *map);\n```\n\n----------------------------------------\n\nTITLE: Getting Ring Buffer Offsets for AF_XDP Socket in C\nDESCRIPTION: This snippet shows how to retrieve the offsets for ring buffers of an AF_XDP socket using the getsockopt() system call.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/concepts/af_xdp.md#2025-04-22_snippet_4\n\nLANGUAGE: c\nCODE:\n```\nstruct xdp_ring_offset {\n\t__u64 producer;\n\t__u64 consumer;\n\t__u64 desc;\n\t__u64 flags;\n};\n\nstruct xdp_mmap_offsets {\n\tstruct xdp_ring_offset rx;\n\tstruct xdp_ring_offset tx;\n\tstruct xdp_ring_offset fr; /* Fill */\n\tstruct xdp_ring_offset cr; /* Completion */\n};\n\nstruct xdp_ring_offset offsets = {0};\n\nif (!getsockopt(fd, SOL_XDP, XDP_MMAP_OFFSETS, &offsets, sizeof(offsets)))\n    // handle error\n```\n\n----------------------------------------\n\nTITLE: Defining the 'tcp_slow_start' eBPF KFunc Signature in C\nDESCRIPTION: This C code snippet defines the function signature for the eBPF kfunc `tcp_slow_start`. It takes a pointer to the `tcp_sock` structure (`tp`) representing the TCP socket state and the number of acknowledged bytes (`acked`) as parameters. It returns a `u32` value, which represents the outcome of the slow start algorithm execution, potentially the number of leftover acknowledged bytes to be processed in congestion avoidance mode. This kfunc allows eBPF programs, specifically `BPF_PROG_TYPE_STRUCT_OPS`, to invoke the kernel's TCP slow start logic.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/tcp_slow_start.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n`#!c u32 tcp_slow_start(struct tcp_sock *tp, u32 acked)`\n```\n\n----------------------------------------\n\nTITLE: Using BPF_CORE_READ_BITFIELD in TCP socket congestion window check in C\nDESCRIPTION: This example demonstrates the use of BPF_CORE_READ_BITFIELD macro to extract the 'is_cwnd_limited' bitfield from a TCP socket structure. It's part of a function that checks if the congestion window is limited.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/ebpf/BPF_CORE_READ_BITFIELD.md#2025-04-22_snippet_1\n\nLANGUAGE: c\nCODE:\n```\nstruct tcp_sock {\n    u32\tsnd_cwnd;\t/* Sending congestion window\t\t*/\n    /* [...] */\n    u8\tchrono_type : 2,\t/* current chronograph type */\n\t\trepair      : 1,\n\t\ttcp_usec_ts : 1, /* TSval values in usec */\n\t\tis_sack_reneg:1,    /* in recovery from loss with SACK reneg? */\n\t\tis_cwnd_limited:1;/* forward progress limited by snd_cwnd? */\n    /* [...] */\n    u32\tmax_packets_out;  /* max packets_out in last window */\n}\n\nstatic inline bool tcp_is_cwnd_limited(const struct sock *sk)\n{\n\tconst struct tcp_sock *tp = tcp_sk(sk);\n\n\t/* If in slow start, ensure cwnd grows to twice what was ACKed. */\n\tif (tcp_in_slow_start(tp))\n\t\treturn tp->snd_cwnd < 2 * tp->max_packets_out;\n\n\treturn !!BPF_CORE_READ_BITFIELD(tp, is_cwnd_limited);\n}\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_sk_assign Helper Function in C\nDESCRIPTION: C definition of the bpf_sk_assign helper function, which assigns a socket to a context.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_sk_assign.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstatic long (* const bpf_sk_assign)(void *ctx, void *sk, __u64 flags) = (void *) 124;\n```\n\n----------------------------------------\n\nTITLE: Defining cubictcp_cwnd_event KFunc in C\nDESCRIPTION: This snippet provides the function signature for the `cubictcp_cwnd_event` kfunc, which is invoked during a congestion window event in the CUBIC TCP congestion control algorithm. The function accepts a pointer to a `sock` struct (representing the socket) and a `tcp_ca_event` enum value (indicating the specific congestion event). This function is designed to be used by eBPF program types that implement TCP congestion algorithms via `BPF_PROG_TYPE_STRUCT_OPS`. No external dependencies beyond appropriate kernel headers are needed. The function expects kernel-space types for its arguments and should be integrated into struct_ops-based eBPF programs.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/cubictcp_cwnd_event.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n#!c void cubictcp_cwnd_event(struct sock *sk, tcp_ca_event event)\n```\n\n----------------------------------------\n\nTITLE: Structure Definition for bpf_tc_opts in C\nDESCRIPTION: Defines the structure containing options for TC qdisc creation and program attachment. Includes fields for program file descriptor, flags, handle, and priority.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_tc_attach.md#2025-04-22_snippet_2\n\nLANGUAGE: c\nCODE:\n```\nstruct bpf_tc_opts {\n\tsize_t sz;\n\tint prog_fd;\n\t__u32 flags;\n\t__u32 prog_id;\n\t__u32 handle;\n\t__u32 priority;\n\tsize_t :0;\n};\n```\n\n----------------------------------------\n\nTITLE: Defining scx_bpf_dispatch_cancel KFunc in C\nDESCRIPTION: Function signature for the scx_bpf_dispatch_cancel kfunc. This function cancels the latest dispatch and can be called multiple times to cancel further dispatches. It can only be called from the sched_ext_ops.dispatch context.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/scx_bpf_dispatch_cancel.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nvoid scx_bpf_dispatch_cancel()\n```\n\n----------------------------------------\n\nTITLE: Function signature for bpf_object__load_skeleton in C\nDESCRIPTION: The C function signature for bpf_object__load_skeleton which takes a bpf_object_skeleton pointer as input and returns an integer status code. This function is responsible for loading a BPF object skeleton into the kernel.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_object__load_skeleton.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nint bpf_object__load_skeleton(struct bpf_object_skeleton *s);\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_ktime_get_coarse_ns Helper Function in C\nDESCRIPTION: Function definition for the bpf_ktime_get_coarse_ns helper that returns a coarse-grained timestamp in nanoseconds since system boot.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_ktime_get_coarse_ns.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstatic __u64 (* const bpf_ktime_get_coarse_ns)(void) = (void *) 160;\n```\n\n----------------------------------------\n\nTITLE: Using __kconfig macro to access kernel configuration in C\nDESCRIPTION: Example showing how to use the __kconfig macro to access the CONFIG_HZ kernel configuration value for implementing a jiffies_to_clock_t conversion function that adapts to the system's configuration.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/ebpf/__kconfig.md#2025-04-22_snippet_2\n\nLANGUAGE: c\nCODE:\n```\nextern unsigned CONFIG_HZ __kconfig;\n\n#define USER_HZ\t\t100\n#define NSEC_PER_SEC\t1000000000ULL\nstatic clock_t jiffies_to_clock_t(unsigned long x)\n{\n\t/* The implementation here tailored to a particular\n\t * setting of USER_HZ.\n\t */\n\tu64 tick_nsec = (NSEC_PER_SEC + CONFIG_HZ/2) / CONFIG_HZ;\n\tu64 user_hz_nsec = NSEC_PER_SEC / USER_HZ;\n\n\tif ((tick_nsec % user_hz_nsec) == 0) {\n\t\tif (CONFIG_HZ < USER_HZ)\n\t\t\treturn x * (USER_HZ / CONFIG_HZ);\n\t\telse\n\t\t\treturn x / (CONFIG_HZ / USER_HZ);\n\t}\n\treturn x * tick_nsec/user_hz_nsec;\n}\n```\n\n----------------------------------------\n\nTITLE: Definition of bpf_program__autoattach Function in C\nDESCRIPTION: The C function signature for bpf_program__autoattach, which takes a const pointer to a bpf_program structure and returns a boolean value. This function is part of the libbpf API introduced in version 1.0.0.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_program__autoattach.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nbool bpf_program__autoattach(const struct bpf_program *prog);\n```\n\n----------------------------------------\n\nTITLE: Defining __COMPAT_ENUM_OR_ZERO Macro in C\nDESCRIPTION: Macro that returns an enum member value if it exists, or zero if undefined. Uses bpf_core_enum_value_exists for runtime checking of enum member existence.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/scx/__COMPAT_ENUM_OR_ZERO.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n#define __COMPAT_ENUM_OR_ZERO(__type, __ent)        \\\n({                                                  \\\n\t__type __ret = 0;                               \\\n\tif ([bpf_core_enum_value_exists](../libbpf/ebpf/bpf_core_enum_value_exists.md)(__type, __ent))  \\\n\t\t__ret = __ent;                              \\\n\t__ret;                                          \\\n})\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_prog_query function in C\nDESCRIPTION: This snippet defines the 'bpf_prog_query' function from the libbpf library. It queries BPF programs and links attached to a target, which can be a file descriptor or netdevice ifindex.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_prog_query.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nint bpf_prog_query(int target_fd, enum bpf_attach_type type, __u32 query_flags, __u32 *attach_flags, __u32 *prog_ids, __u32 *prog_cnt);\n```\n\n----------------------------------------\n\nTITLE: Defining BTF Type Finder Helper Function in C\nDESCRIPTION: Function definition for bpf_btf_find_by_name_kind helper that finds BTF type with given name and kind in vmlinux BTF or module BTFs. Returns btf_id and btf_obj_fd in lower and upper 32 bits.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_btf_find_by_name_kind.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstatic long (* const bpf_btf_find_by_name_kind)(char *name, int name_sz, __u32 kind, int flags) = (void *) 167;\n```\n\n----------------------------------------\n\nTITLE: Definition of btf__add_datasec_var_info Function in C\nDESCRIPTION: Function definition for btf__add_datasec_var_info which appends new data section variable information entry for current DATASEC type. It takes parameters for the BTF object, variable type ID, offset, and byte size, returning 0 on success or a negative value on error.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/btf__add_datasec_var_info.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nint btf__add_datasec_var_info(struct btf *btf, int var_type_id, __u32 offset, __u32 byte_sz);\n```\n\n----------------------------------------\n\nTITLE: eBPF Helper Function Definition - bpf_get_netns_cookie\nDESCRIPTION: Function definition for bpf_get_netns_cookie helper that retrieves an 8-byte opaque number representing the network namespace cookie. The function takes a context pointer as input and returns a unique identifier for the associated network namespace.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_get_netns_cookie.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstatic __u64 (* const bpf_get_netns_cookie)(void *ctx) = (void *) 122;\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_program__autoload function in C\nDESCRIPTION: This code snippet shows the function signature for the bpf_program__autoload function. It takes a const pointer to a bpf_program struct and returns a boolean value indicating whether the program will be automatically loaded.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_program__autoload.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nbool bpf_program__autoload(const struct bpf_program *prog);\n```\n\n----------------------------------------\n\nTITLE: Defining __percpu_kptr Macro in C\nDESCRIPTION: This snippet defines the __percpu_kptr macro using the btf_type_tag attribute to indicate a per-CPU kernel pointer.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/ebpf/__percpu_kptr.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n#define __percpu_kptr __attribute__((btf_type_tag(\"percpu_kptr\")))\n```\n\n----------------------------------------\n\nTITLE: Enum Definition of probe_attach_mode in C\nDESCRIPTION: Defines the possible attachment modes for kprobes and uprobes, specifying how the probes should be attached to the kernel. Options include default mode, legacy mode using debugfs/tracefs, perf event mode, and BPF link mode.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_program__attach_kprobe_opts.md#2025-04-22_snippet_2\n\nLANGUAGE: c\nCODE:\n```\nenum probe_attach_mode {\n\t/* attach probe in latest supported mode by kernel */\n\tPROBE_ATTACH_MODE_DEFAULT = 0,\n\t/* attach probe in legacy mode, using debugfs/tracefs */\n\tPROBE_ATTACH_MODE_LEGACY,\n\t/* create perf event with [perf_event_open](https://man7.org/linux/man-pages/man2/perf_event_open.2.html) syscall */\n\tPROBE_ATTACH_MODE_PERF,\n\t/* attach probe with BPF link */\n\tPROBE_ATTACH_MODE_LINK,\n};\n```\n\n----------------------------------------\n\nTITLE: Enum Definition for bpf_tc_attach_point in C\nDESCRIPTION: Defines the possible TC attach points that can be used with bpf_tc_attach. Options include ingress, egress, and custom attachment points.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_tc_attach.md#2025-04-22_snippet_1\n\nLANGUAGE: c\nCODE:\n```\nenum bpf_tc_attach_point {\n\tBPF_TC_INGRESS = 1 << 0,\n\tBPF_TC_EGRESS  = 1 << 1,\n\tBPF_TC_CUSTOM  = 1 << 2,\n};\n```\n\n----------------------------------------\n\nTITLE: Triggering FILL Ring Buffer Consumption with XDP_USE_NEED_WAKEUP in C\nDESCRIPTION: This code snippet demonstrates how to trigger the consumption of the FILL ring buffer when the XDP_USE_NEED_WAKEUP flag is set. It uses the recvfrom syscall with specific parameters to signal the kernel to process the FILL ring.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/concepts/af_xdp.md#2025-04-22_snippet_9\n\nLANGUAGE: c\nCODE:\n```\nrecvfrom(fd, NULL, 0, MSG_DONTWAIT, NULL, NULL);\n```\n\n----------------------------------------\n\nTITLE: Using perf_buffer__buffer_fd Function in C\nDESCRIPTION: The function returns the file descriptor for a specific buffer index in a perf buffer manager. This FD can be used with select/poll/epoll for event notification. The function takes a perf buffer pointer and buffer index as parameters and returns the corresponding file descriptor or a negative error code.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/perf_buffer__buffer_fd.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nint perf_buffer__buffer_fd(const struct perf_buffer *pb, size_t buf_idx);\n```\n\n----------------------------------------\n\nTITLE: Function Definition of bpf_object__pin_programs in C\nDESCRIPTION: C function definition for bpf_object__pin_programs that takes a BPF object pointer and directory path as parameters. The function pins each program in the BPF object to the specified directory and returns 0 on success or a negative error code on failure.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_object__pin_programs.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nint bpf_object__pin_programs(struct bpf_object *obj, const char *path);\n```\n\n----------------------------------------\n\nTITLE: Setting BPF Map Key Size with Libbpf in C\nDESCRIPTION: The function 'bpf_map__set_key_size' sets the size of a key in a BPF map using the Libbpf library. It requires a pointer to a BPF map and the desired key size in bytes. This setting must be adjusted prior to loading the map, and the function returns 0 on success or a negative number if it fails.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_map__set_key_size.md#2025-04-22_snippet_0\n\nLANGUAGE: C\nCODE:\n```\n#!c int bpf_map__set_key_size(struct bpf_map *map, __u32 size);\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_cpumask_setall in C\nDESCRIPTION: The function definition sets all bits in a BPF CPU-mask, allowing it to be used in various eBPF program types. It requires the cpumask struct as an input. The function is used primarily in Linux kernel versions from v6.3 onwards.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/bpf_cpumask_setall.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nvoid bpf_cpumask_setall(struct bpf_cpumask *cpumask)\n```\n\n----------------------------------------\n\nTITLE: Defining the 'tcp_cong_avoid_ai' KFunc Signature in C\nDESCRIPTION: This C code snippet defines the function signature for the eBPF kernel function `tcp_cong_avoid_ai`. It is intended for use within specific eBPF program types, notably `BPF_PROG_TYPE_STRUCT_OPS`, to implement TCP congestion avoidance algorithms. The function takes a pointer to a `tcp_sock` structure (`tp`), and two `u32` parameters (`w` and `acked`) related to the congestion window adjustment based on acknowledged packets.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/tcp_cong_avoid_ai.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n`#!c void tcp_cong_avoid_ai(struct tcp_sock *tp, u32 w, u32 acked)`\n```\n\n----------------------------------------\n\nTITLE: Incorrect Usage of bpf_core_read\nDESCRIPTION: Illustrates an incorrect pattern of using bpf_core_read by pre-evaluating the field access outside the macro, which prevents proper offset relocation. It serves as a cautionary example of erroneous macro usage, emphasizing that field accesses should be done within the macro call.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/ebpf/bpf_core_read.md#2025-04-22_snippet_2\n\nLANGUAGE: C\nCODE:\n```\nstruct some_value dst;\\nstruct some_value *ptr = a.c.d;\\nbpf_core_read(&dst, sizeof(dst), ptr);\n```\n\n----------------------------------------\n\nTITLE: Defining BPF Line Info Structure and Macros in C\nDESCRIPTION: This code defines the structure for individual line information records and macros to extract line numbers and column information from combined values. The structure contains instruction offsets and file position information.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_prog_linfo__new.md#2025-04-22_snippet_1\n\nLANGUAGE: c\nCODE:\n```\n#define BPF_LINE_INFO_LINE_NUM(line_col)\t((line_col) >> 10)\n#define BPF_LINE_INFO_LINE_COL(line_col)\t((line_col) & 0x3ff)\n\nstruct bpf_line_info {\n\t__u32\tinsn_off;\n\t__u32\tfile_name_off;\n\t__u32\tline_off;\n\t__u32\tline_col;\n};\n```\n\n----------------------------------------\n\nTITLE: Defining and Using bpf_crypto_ctx_create KFunc in eBPF\nDESCRIPTION: This example demonstrates creating a BPF crypto context using bpf_crypto_ctx_create, storing it in a map, and handling potential errors. The created context can be used for encryption and decryption operations in network packets. This code is designed to run in a sleepable syscall program.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/bpf_crypto_ctx_create.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n/* Copyright (c) 2024 Meta Platforms, Inc. and affiliates. */\n\n#include \"vmlinux.h\"\n#include \"bpf_tracing_net.h\"\n#include <bpf/bpf_helpers.h>\n#include <bpf/bpf_endian.h>\n#include <bpf/bpf_tracing.h>\n#include \"bpf_misc.h\"\n#include \"bpf_kfuncs.h\"\n\nstruct bpf_crypto_ctx *bpf_crypto_ctx_create(const struct bpf_crypto_params *params,\n\t\t\t\t\t\tu32 params__sz, int *err) __ksym;\nstruct bpf_crypto_ctx *bpf_crypto_ctx_acquire(struct bpf_crypto_ctx *ctx) __ksym;\nvoid bpf_crypto_ctx_release(struct bpf_crypto_ctx *ctx) __ksym;\n\nstruct __crypto_ctx_value {\n\tstruct bpf_crypto_ctx __kptr * ctx;\n};\n\nstruct array_map {\n\t__uint(type, BPF_MAP_TYPE_ARRAY);\n\t__type(key, int);\n\t__type(value, struct __crypto_ctx_value);\n\t__uint(max_entries, 1);\n} __crypto_ctx_map SEC(\".maps\");\n\nstatic inline int crypto_ctx_insert(struct bpf_crypto_ctx *ctx)\n{\n\tstruct __crypto_ctx_value local, *v;\n\tstruct bpf_crypto_ctx *old;\n\tu32 key = 0;\n\tint err;\n\n\tlocal.ctx = NULL;\n\terr = bpf_map_update_elem(&__crypto_ctx_map, &key, &local, 0);\n\tif (err) {\n\t\tbpf_crypto_ctx_release(ctx);\n\t\treturn err;\n\t}\n\n\tv = bpf_map_lookup_elem(&__crypto_ctx_map, &key);\n\tif (!v) {\n\t\tbpf_crypto_ctx_release(ctx);\n\t\treturn -ENOENT;\n\t}\n\n\told = bpf_kptr_xchg(&v->ctx, ctx);\n\tif (old) {\n\t\tbpf_crypto_ctx_release(old);\n\t\treturn -EEXIST;\n\t}\n\n\treturn 0;\n}\n\nchar cipher[128] = {};\nu32 key_len, authsize;\nu8 key[256] = {};\nint status;\n\nSEC(\"syscall\")\nint crypto_setup(void *args)\n{\n\tstruct bpf_crypto_ctx *cctx;\n\tstruct bpf_crypto_params params = {\n\t\t.type = \"skcipher\",\n\t\t.key_len = key_len,\n\t\t.authsize = authsize,\n\t};\n\tint err = 0;\n\n\tstatus = 0;\n\n\tif (!cipher[0] || !key_len || key_len > 256) {\n\t\tstatus = -EINVAL;\n\t\treturn 0;\n\t}\n\n\t__builtin_memcpy(&params.algo, cipher, sizeof(cipher));\n\t__builtin_memcpy(&params.key, key, sizeof(key));\n\tcctx = bpf_crypto_ctx_create(&params, sizeof(params), &err);\n\n\tif (!cctx) {\n\t\tstatus = err;\n\t\treturn 0;\n\t}\n\n\terr = crypto_ctx_insert(cctx);\n\tif (err && err != -EEXIST)\n\t\tstatus = err;\n\n\treturn 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_skb_get_tunnel_opt Helper Function in C\nDESCRIPTION: This code snippet defines the bpf_skb_get_tunnel_opt helper function for eBPF programs. It retrieves tunnel options metadata for a packet and stores raw tunnel option data in a buffer.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_skb_get_tunnel_opt.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstatic long (* const bpf_skb_get_tunnel_opt)(struct __sk_buff *skb, void *opt, __u32 size) = (void *) 29;\n```\n\n----------------------------------------\n\nTITLE: Listing BPF Token Delegation Options in Markdown\nDESCRIPTION: This code snippet enumerates the available options for delegating privileges using BPF Tokens through the fsconfig(2) system call. It includes options for delegating specific BPF commands, map types, program types, and attach types.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/concepts/token.md#2025-04-22_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n- `delegate_cmds`: Allows performing specific BPF system call commands\n- `delegate_maps`: Allows creating specific types of maps\n- `delegate_progs`: Allows loading specific types of programs\n- `delegate_attachs`: Allows specific attach types\n```\n\n----------------------------------------\n\nTITLE: Correct Format String Declaration with Static Const (eBPF, C)\nDESCRIPTION: Demonstrates the correct technique for defining a static, stack-allocated format string suitable for use with bpf_trace_printk in eBPF programs. The static const ensures that the format string resides in an accessible section, avoiding issues common with local or non-const declarations. No external dependencies required beyond the eBPF environment.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_trace_printk.md#2025-04-22_snippet_2\n\nLANGUAGE: c\nCODE:\n```\nstatic const char fmt[] = \"some log\"; \nbpf_trace_printk(fmt, sizeof(fmt))\n```\n\n----------------------------------------\n\nTITLE: Defining hid_bpf_input_report KFunc in C\nDESCRIPTION: Function signature for the hid_bpf_input_report kfunc. It takes a HID-BPF context, report type, buffer, and buffer size as parameters. Returns 0 on success or a negative error code on failure. This function may sleep and can only be used from sleepable programs.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/hid_bpf_input_report.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nint hid_bpf_input_report(struct hid_bpf_ctx *ctx, hid_report_type type, u8 *buf, const size_t buf__sz)\n```\n\n----------------------------------------\n\nTITLE: Function Declaration for bpf_program__attach_tcx\nDESCRIPTION: Function signature for attaching a BPF_PROG_TYPE_SCHED_CLS program to a network interface, taking the program, interface index, and options as parameters.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_program__attach_tcx.md#2025-04-22_snippet_1\n\nLANGUAGE: c\nCODE:\n```\nstruct bpf_link * bpf_program__attach_tcx(const struct bpf_program *prog, int ifindex, const struct bpf_tcx_opts *opts);\n```\n\n----------------------------------------\n\nTITLE: Defining scx_bpf_create_dsq KFunc in C\nDESCRIPTION: Function signature for the scx_bpf_create_dsq kfunc. It takes a DSQ ID and NUMA node as parameters and returns an integer status code.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/scx_bpf_create_dsq.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\ns32 scx_bpf_create_dsq(u64 dsq_id, s32 node)\n```\n\n----------------------------------------\n\nTITLE: Definition of bpf_object__unpin_programs function in C\nDESCRIPTION: Function signature for bpf_object__unpin_programs which unpins all programs in a BPF object from a specified directory path. It takes a pointer to a BPF object and a directory path as parameters and returns 0 on success or a negative error code on failure.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_object__unpin_programs.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nint bpf_object__unpin_programs(struct bpf_object *obj, const char *path);\n```\n\n----------------------------------------\n\nTITLE: Declaring the 'timeout_ms' Field in 'sched_ext_ops' Struct (C)\nDESCRIPTION: Declares the 'timeout_ms' field within the 'sched_ext_ops' struct as an unsigned 32-bit integer. It defines the maximum time (in milliseconds) a runnable task should wait before being scheduled by the BPF scheduler. This value cannot exceed the default kernel timeout of 30 seconds and defaults to 30 seconds if not explicitly set.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/program-type/BPF_PROG_TYPE_STRUCT_OPS/sched_ext_ops.md#2025-04-22_snippet_4\n\nLANGUAGE: c\nCODE:\n```\nu32 timeout_ms\n```\n\n----------------------------------------\n\nTITLE: Defining eBPF KFunc 'bpf_cast_to_kern_ctx' in C\nDESCRIPTION: Defines the eBPF kernel function 'bpf_cast_to_kern_ctx', which is used to convert UAPI context into a kernel type pointer. The function takes a single void pointer as an argument and returns a void pointer that points to a kernel-accessible type. This functionality is crucial for eBPF programs to interact with kernel objects within supported program types.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/bpf_cast_to_kern_ctx.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n#!c\nvoid *bpf_cast_to_kern_ctx(void *obj)\n```\n\n----------------------------------------\n\nTITLE: Defining eBPF Helper Function in C\nDESCRIPTION: This code snippet defines the 'bpf_xdp_load_bytes' eBPF helper function in C. It loads data from an XDP buffer and can be used to load a specified number of bytes from an offset into a buffer. It returns 0 on success or a negative error code on failure.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_xdp_load_bytes.md#2025-04-22_snippet_0\n\nLANGUAGE: C\nCODE:\n```\nstatic long (* const bpf_xdp_load_bytes)(struct xdp_md *xdp_md, __u32 offset, void *buf, __u32 len) = (void *) 189;\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_skb_cgroup_classid Helper Function in C\nDESCRIPTION: This code snippet defines the bpf_skb_cgroup_classid helper function. It retrieves the cgroup v1 net_cls class from the skb's associated socket and returns the id or 0 if it couldn't be retrieved.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_skb_cgroup_classid.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstatic __u64 (* const bpf_skb_cgroup_classid)(struct __sk_buff *skb) = (void *) 151;\n```\n\n----------------------------------------\n\nTITLE: Implementing Hash Table Operations with __arg_arena in C\nDESCRIPTION: This code snippet demonstrates the usage of the '__arg_arena' macro in a hash table implementation. It includes functions for looking up and updating elements in the hash table, with the 'htab' parameter tagged using '__arg_arena'.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/ebpf/__arg_arena.md#2025-04-22_snippet_1\n\nLANGUAGE: c\nCODE:\n```\n/* SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause) */\n/* Copyright (c) 2024 Meta Platforms, Inc. and affiliates. */\n#pragma once\n#include <errno.h>\n#include \"bpf_arena_alloc.h\"\n#include \"bpf_arena_list.h\"\n\nstruct htab_bucket {\n\tstruct arena_list_head head;\n};\ntypedef struct htab_bucket __arena htab_bucket_t;\n\nstruct htab {\n\thtab_bucket_t *buckets;\n\tint n_buckets;\n};\ntypedef struct htab __arena htab_t;\n\nstatic inline htab_bucket_t *__select_bucket(htab_t *htab, __u32 hash)\n{\n\thtab_bucket_t *b = htab->buckets;\n\n\tcast_kern(b);\n\treturn &b[hash & (htab->n_buckets - 1)];\n}\n\nstatic inline arena_list_head_t *select_bucket(htab_t *htab, __u32 hash)\n{\n\treturn &__select_bucket(htab, hash)->head;\n}\n\nstruct hashtab_elem {\n\tint hash;\n\tint key;\n\tint value;\n\tstruct arena_list_node hash_node;\n};\ntypedef struct hashtab_elem __arena hashtab_elem_t;\n\nstatic hashtab_elem_t *lookup_elem_raw(arena_list_head_t *head, __u32 hash, int key)\n{\n\thashtab_elem_t *l;\n\n\tlist_for_each_entry(l, head, hash_node)\n\t\tif (l->hash == hash && l->key == key)\n\t\t\treturn l;\n\n\treturn NULL;\n}\n\nstatic int htab_hash(int key)\n{\n\treturn key;\n}\n\n__weak int htab_lookup_elem(htab_t *htab __arg_arena, int key)\n{\n\thashtab_elem_t *l_old;\n\tarena_list_head_t *head;\n\n\tcast_kern(htab);\n\thead = select_bucket(htab, key);\n\tl_old = lookup_elem_raw(head, htab_hash(key), key);\n\tif (l_old)\n\t\treturn l_old->value;\n\treturn 0;\n}\n\n__weak int htab_update_elem(htab_t *htab __arg_arena, int key, int value)\n{\n\thashtab_elem_t *l_new = NULL, *l_old;\n\tarena_list_head_t *head;\n\n\tcast_kern(htab);\n\thead = select_bucket(htab, key);\n\tl_old = lookup_elem_raw(head, htab_hash(key), key);\n\n\tl_new = bpf_alloc(sizeof(*l_new));\n\tif (!l_new)\n\t\treturn -ENOMEM;\n\tl_new->key = key;\n\tl_new->hash = htab_hash(key);\n\tl_new->value = value;\n\n\tlist_add_head(&l_new->hash_node, head);\n\tif (l_old) {\n\t\tlist_del(&l_old->hash_node);\n\t\tbpf_free(l_old);\n\t}\n\treturn 0;\n}\n\nvoid htab_init(htab_t *htab)\n{\n\tvoid __arena *buckets = bpf_arena_alloc_pages(&arena, NULL, 2, NUMA_NO_NODE, 0);\n\n\tcast_user(buckets);\n\thtab->buckets = buckets;\n\thtab->n_buckets = 2 * PAGE_SIZE / sizeof(struct htab_bucket);\n}\n```\n\n----------------------------------------\n\nTITLE: Example Implementation Using bpf_send_signal_task KFunc in C\nDESCRIPTION: A detailed example showing how to use the bpf_send_signal_task function to send signals to processes or threads. The example demonstrates loading task structures, specifying signal types, and handling return values.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/bpf_send_signal_task.md#2025-04-22_snippet_1\n\nLANGUAGE: c\nCODE:\n```\n// SPDX-License-Identifier: GPL-2.0\n// Copyright (c) 2019 Facebook\n#include <vmlinux.h>\n#include <linux/version.h>\n#include <bpf/bpf_helpers.h>\n\nstruct task_struct *bpf_task_from_pid(int pid) __ksym;\nvoid bpf_task_release(struct task_struct *p) __ksym;\nint bpf_send_signal_task(struct task_struct *task, int sig, enum pid_type type, u64 value) __ksym;\n\n__u32 sig = 0, pid = 0, status = 0, signal_thread = 0, target_pid = 0;\n\nstatic __always_inline int bpf_send_signal_test(void *ctx)\n{\n\tstruct task_struct *target_task = NULL;\n\tint ret;\n\tu64 value;\n\n\tif (status != 0 || pid == 0)\n\t\treturn 0;\n\n\tif ((bpf_get_current_pid_tgid() >> 32) == pid) {\n\t\tif (target_pid) {\n\t\t\ttarget_task = bpf_task_from_pid(target_pid);\n\t\t\tif (!target_task)\n\t\t\t\treturn 0;\n\t\t\tvalue = 8;\n\t\t}\n\n\t\tif (signal_thread) {\n\t\t\tif (target_pid)\n\t\t\t\tret = bpf_send_signal_task(target_task, sig, PIDTYPE_PID, value);\n\t\t\telse\n\t\t\t\tret = bpf_send_signal_thread(sig);\n\t\t} else {\n\t\t\tif (target_pid)\n\t\t\t\tret = bpf_send_signal_task(target_task, sig, PIDTYPE_TGID, value);\n\t\t\telse\n\t\t\t\tret = bpf_send_signal(sig);\n\t\t}\n\t\tif (ret == 0)\n\t\t\tstatus = 1;\n\t}\n\n\tif (target_task)\n\t\tbpf_task_release(target_task);\n\n\treturn 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining the 'container_of' Macro in C\nDESCRIPTION: Provides the C preprocessor definition of the `container_of` macro. It calculates the address of the containing structure (`type`) by taking a pointer to a member (`ptr`), casting it to `void *`, and then subtracting the byte offset of that `member` within the `type` structure using the `offsetof` macro. The result is cast to a pointer of the containing structure's `type`.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/ebpf/container_of.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n#define container_of(ptr, type, member)                 \\\n    ({                                                  \\\n        void *__mptr = (void *)(ptr);                   \\\n        ((type *)(__mptr - offsetof(type, member)));    \\\n    })\n```\n\n----------------------------------------\n\nTITLE: Defining struct bpf_link_create_opts for Link Configuration (Libbpf, C)\nDESCRIPTION: Defines the bpf_link_create_opts C struct, which captures configuration options and extra data for the bpf_link_create function in libbpf. This struct supports forward and backward compatibility and contains unions for various link types such as perf event, kprobe_multi, uprobe_multi, tracing, netfilter, tcx, and netkit. Dependencies include Linux headers and libbpf definitions. Used as the opts parameter in bpf_link_create to specify advanced link settings.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_link_create.md#2025-04-22_snippet_1\n\nLANGUAGE: c\nCODE:\n```\nstruct bpf_link_create_opts {\n\tsize_t sz; /* size of this struct for forward/backward compatibility */\n\t__u32 flags;\n\tunion bpf_iter_link_info *iter_info;\n\t__u32 iter_info_len;\n\t__u32 target_btf_id;\n\tunion {\n\t\tstruct {\n\t\t\t__u64 bpf_cookie;\n\t\t} perf_event;\n\t\tstruct {\n\t\t\t__u32 flags;\n\t\t\t__u32 cnt;\n\t\t\tconst char **syms;\n\t\t\tconst unsigned long *addrs;\n\t\t\tconst __u64 *cookies;\n\t\t} kprobe_multi;\n\t\tstruct {\n\t\t\t__u32 flags;\n\t\t\t__u32 cnt;\n\t\t\tconst char *path;\n\t\t\tconst unsigned long *offsets;\n\t\t\tconst unsigned long *ref_ctr_offsets;\n\t\t\tconst __u64 *cookies;\n\t\t\t__u32 pid;\n\t\t} uprobe_multi;\n\t\tstruct {\n\t\t\t__u64 cookie;\n\t\t} tracing;\n\t\tstruct {\n\t\t\t__u32 pf;\n\t\t\t__u32 hooknum;\n\t\t\t__s32 priority;\n\t\t\t__u32 flags;\n\t\t} netfilter;\n\t\tstruct {\n\t\t\t__u32 relative_fd;\n\t\t\t__u32 relative_id;\n\t\t\t__u64 expected_revision;\n\t\t} tcx;\n\t\tstruct {\n\t\t\t__u32 relative_fd;\n\t\t\t__u32 relative_id;\n\t\t\t__u64 expected_revision;\n\t\t} netkit;\n\t};\n\tsize_t :0;\n};\n```\n\n----------------------------------------\n\nTITLE: Definition of ring_buffer__free function in libbpf\nDESCRIPTION: C function declaration for ring_buffer__free which frees a ring buffer manager. It takes a pointer to a ring_buffer structure as its only parameter.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/ring_buffer__free.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nvoid ring_buffer__free(struct ring_buffer *rb);\n```\n\n----------------------------------------\n\nTITLE: Definition of struct btf_dump_type_data_opts in C\nDESCRIPTION: Defines the configuration structure for btf_dump__dump_type_data function. This struct includes parameters for controlling indentation, formatting options like compact display, name skipping, and zero value emission.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/btf_dump__dump_type_data.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstruct btf_dump_type_data_opts {\n\t/* size of this struct, for forward/backward compatibility */\n\tsize_t sz;\n\tconst char *indent_str;\n\tint indent_level;\n\t/* below match \"show\" flags for bpf_show_snprintf() */\n\tbool compact;\n\tbool skip_names;\n\tbool emit_zeroes;\n\tsize_t :0;\n};\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_skb_set_tunnel_opt Helper Function in C\nDESCRIPTION: This code snippet defines the bpf_skb_set_tunnel_opt helper function. It sets tunnel options metadata for a packet associated with an sk_buff to the option data contained in a raw buffer.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_skb_set_tunnel_opt.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstatic long (* const bpf_skb_set_tunnel_opt)(struct __sk_buff *skb, void *opt, __u32 size) = (void *) 30;\n```\n\n----------------------------------------\n\nTITLE: Defining perf_buffer__consume function in C\nDESCRIPTION: Function signature for perf_buffer__consume, which consumes available perf buffer data without event polling. It takes a perf buffer manager pointer as an argument and returns the number of records consumed or a negative number on error.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/perf_buffer__consume.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nint perf_buffer__consume(struct perf_buffer *pb);\n```\n\n----------------------------------------\n\nTITLE: Placeholder for Socket Filter Attachment Examples (Markdown Comment)\nDESCRIPTION: This is a Markdown comment serving as a placeholder to add examples showing how to attach eBPF socket filter programs using different user-space libraries like libbpf, cilium/ebpf, and Aya. It signifies planned documentation content.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/program-type/BPF_PROG_TYPE_SOCKET_FILTER.md#2025-04-22_snippet_3\n\nLANGUAGE: markdown\nCODE:\n```\n<!-- TODO: show attaching via libbpf, cilium/ebpf, and aya -->\n```\n\n----------------------------------------\n\nTITLE: Definition of ring__size function in libbpf C API\nDESCRIPTION: Function prototype for the ring__size function that returns the total size of the ring buffer's map data area (excluding special producer/consumer pages). The function takes a ring buffer object as input and returns the size in bytes.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/ring__size.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nsize_t ring__size(const struct ring *r);\n```\n\n----------------------------------------\n\nTITLE: NF Hook State Structure for eBPF in C\nDESCRIPTION: Defines the nf_hook_state structure containing details about the current netfilter hook environment, such as incoming/outgoing network devices and references to the socket and network state, for eBPF program type netfilter.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/program-type/BPF_PROG_TYPE_NETFILTER.md#2025-04-22_snippet_1\n\nLANGUAGE: c\nCODE:\n```\nstruct nf_hook_state {\n\tu8 hook;\n\tu8 pf;\n\tstruct net_device *in;\n\tstruct net_device *out;\n\tstruct sock *sk;\n\tstruct net *net;\n\tint (*okfn)(struct net *, struct sock *, struct sk_buff *);\n};\n```\n\n----------------------------------------\n\nTITLE: Structure Definition of bpf_kprobe_opts in C\nDESCRIPTION: Defines the structure of options available when attaching kprobes using bpf_program__attach_kprobe_opts. It includes fields for size tracking, custom cookie values, offset configuration, return probe flag, and attachment mode selection.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_program__attach_kprobe_opts.md#2025-04-22_snippet_1\n\nLANGUAGE: c\nCODE:\n```\nstruct bpf_kprobe_opts {\n\t/* size of this struct, for forward/backward compatibility */\n\tsize_t sz;\n\t__u64 bpf_cookie;\n\tsize_t offset;\n\tbool retprobe;\n\t/* kprobe attach mode */\n\tenum probe_attach_mode attach_mode;\n\tsize_t :0;\n};\n```\n\n----------------------------------------\n\nTITLE: List of Supported eBPF Kfuncs (v6.12) in Markdown\nDESCRIPTION: A Markdown list enumerating supported eBPF kernel functions (kfuncs) introduced in Linux kernel v6.12. Each list item includes the kfunc name, a link to its dedicated documentation page (relative path), and a link indicating the kernel version and the specific commit on GitHub where it was introduced.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/program-type/BPF_PROG_TYPE_CGROUP_SOCKOPT.md#2025-04-22_snippet_1\n\nLANGUAGE: markdown\nCODE:\n```\n<!-- [PROG_KFUNC_REF] -->\n??? abstract \"Supported kfuncs\"\n    - [`bpf_arena_alloc_pages`](../kfuncs/bpf_arena_alloc_pages.md) [:octicons-tag-24: v6.12](https://github.com/torvalds/linux/commit/67666479edf1e2b732f4d0ac797885e859a78de4) - \n    - [`bpf_arena_free_pages`](../kfuncs/bpf_arena_free_pages.md) [:octicons-tag-24: v6.12](https://github.com/torvalds/linux/commit/67666479edf1e2b732f4d0ac797885e859a78de4) - \n    - [`bpf_cast_to_kern_ctx`](../kfuncs/bpf_cast_to_kern_ctx.md) [:octicons-tag-24: v6.12](https://github.com/torvalds/linux/commit/67666479edf1e2b732f4d0ac797885e859a78de4) - \n    - [`bpf_copy_from_user_str`](../kfuncs/bpf_copy_from_user_str.md) [:octicons-tag-24: v6.12](https://github.com/torvalds/linux/commit/67666479edf1e2b732f4d0ac797885e859a78de4) - \n    - [`bpf_dynptr_adjust`](../kfuncs/bpf_dynptr_adjust.md) [:octicons-tag-24: v6.12](https://github.com/torvalds/linux/commit/67666479edf1e2b732f4d0ac797885e859a78de4) - \n    - [`bpf_dynptr_clone`](../kfuncs/bpf_dynptr_clone.md) [:octicons-tag-24: v6.12](https://github.com/torvalds/linux/commit/67666479edf1e2b732f4d0ac797885e859a78de4) - \n    - [`bpf_dynptr_from_skb`](../kfuncs/bpf_dynptr_from_skb.md) [:octicons-tag-24: v6.12](https://github.com/torvalds/linux/commit/67666479edf1e2b732f4d0ac797885e859a78de4) - \n    - [`bpf_dynptr_is_null`](../kfuncs/bpf_dynptr_is_null.md) [:octicons-tag-24: v6.12](https://github.com/torvalds/linux/commit/67666479edf1e2b732f4d0ac797885e859a78de4) - \n    - [`bpf_dynptr_is_rdonly`](../kfuncs/bpf_dynptr_is_rdonly.md) [:octicons-tag-24: v6.12](https://github.com/torvalds/linux/commit/67666479edf1e2b732f4d0ac797885e859a78de4) - \n    - [`bpf_dynptr_size`](../kfuncs/bpf_dynptr_size.md) [:octicons-tag-24: v6.12](https://github.com/torvalds/linux/commit/67666479edf1e2b732f4d0ac797885e859a78de4) - \n    - [`bpf_dynptr_slice`](../kfuncs/bpf_dynptr_slice.md) [:octicons-tag-24: v6.12](https://github.com/torvalds/linux/commit/67666479edf1e2b732f4d0ac797885e859a78de4) - \n    - [`bpf_dynptr_slice_rdwr`](../kfuncs/bpf_dynptr_slice_rdwr.md) [:octicons-tag-24: v6.12](https://github.com/torvalds/linux/commit/67666479edf1e2b732f4d0ac797885e859a78de4) - \n    - [`bpf_get_kmem_cache`](../kfuncs/bpf_get_kmem_cache.md) [:octicons-tag-24: v6.12](https://github.com/torvalds/linux/commit/67666479edf1e2b732f4d0ac797885e859a78de4) - \n    - [`bpf_iter_bits_destroy`](../kfuncs/bpf_iter_bits_destroy.md) [:octicons-tag-24: v6.12](https://github.com/torvalds/linux/commit/67666479edf1e2b732f4d0ac797885e859a78de4) - \n    - [`bpf_iter_bits_new`](../kfuncs/bpf_iter_bits_new.md) [:octicons-tag-24: v6.12](https://github.com/torvalds/linux/commit/67666479edf1e2b732f4d0ac797885e859a78de4) - \n    - [`bpf_iter_bits_next`](../kfuncs/bpf_iter_bits_next.md) [:octicons-tag-24: v6.12](https://github.com/torvalds/linux/commit/67666479edf1e2b732f4d0ac797885e859a78de4) - \n    - [`bpf_iter_css_destroy`](../kfuncs/bpf_iter_css_destroy.md) [:octicons-tag-24: v6.12](https://github.com/torvalds/linux/commit/67666479edf1e2b732f4d0ac797885e859a78de4) - \n    - [`bpf_iter_css_new`](../kfuncs/bpf_iter_css_new.md) [:octicons-tag-24: v6.12](https://github.com/torvalds/linux/commit/67666479edf1e2b732f4d0ac797885e859a78de4) - \n    - [`bpf_iter_css_next`](../kfuncs/bpf_iter_css_next.md) [:octicons-tag-24: v6.12](https://github.com/torvalds/linux/commit/67666479edf1e2b732f4d0ac797885e859a78de4) - \n    - [`bpf_iter_css_task_destroy`](../kfuncs/bpf_iter_css_task_destroy.md) [:octicons-tag-24: v6.12](https://github.com/torvalds/linux/commit/67666479edf1e2b732f4d0ac797885e859a78de4) - \n    - [`bpf_iter_css_task_new`](../kfuncs/bpf_iter_css_task_new.md) [:octicons-tag-24: v6.12](https://github.com/torvalds/linux/commit/67666479edf1e2b732f4d0ac797885e859a78de4) - \n    - [`bpf_iter_css_task_next`](../kfuncs/bpf_iter_css_task_next.md) [:octicons-tag-24: v6.12](https://github.com/torvalds/linux/commit/67666479edf1e2b732f4d0ac797885e859a78de4) - \n    - [`bpf_iter_kmem_cache_destroy`](../kfuncs/bpf_iter_kmem_cache_destroy.md) [:octicons-tag-24: v6.12](https://github.com/torvalds/linux/commit/67666479edf1e2b732f4d0ac797885e859a78de4) - \n    - [`bpf_iter_kmem_cache_new`](../kfuncs/bpf_iter_kmem_cache_new.md) [:octicons-tag-24: v6.12](https://github.com/torvalds/linux/commit/67666479edf1e2b732f4d0ac797885e859a78de4) - \n    - [`bpf_iter_kmem_cache_next`](../kfuncs/bpf_iter_kmem_cache_next.md) [:octicons-tag-24: v6.12](https://github.com/torvalds/linux/commit/67666479edf1e2b732f4d0ac797885e859a78de4) - \n    - [`bpf_iter_num_destroy`](../kfuncs/bpf_iter_num_destroy.md) [:octicons-tag-24: v6.12](https://github.com/torvalds/linux/commit/67666479edf1e2b732f4d0ac797885e859a78de4) - \n    - [`bpf_iter_num_new`](../kfuncs/bpf_iter_num_new.md) [:octicons-tag-24: v6.12](https://github.com/torvalds/linux/commit/67666479edf1e2b732f4d0ac797885e859a78de4) - \n    - [`bpf_iter_num_next`](../kfuncs/bpf_iter_num_next.md) [:octicons-tag-24: v6.12](https://github.com/torvalds/linux/commit/67666479edf1e2b732f4d0ac797885e859a78de4) - \n    - [`bpf_iter_task_destroy`](../kfuncs/bpf_iter_task_destroy.md) [:octicons-tag-24: v6.12](https://github.com/torvalds/linux/commit/67666479edf1e2b732f4d0ac797885e859a78de4) - \n    - [`bpf_iter_task_new`](../kfuncs/bpf_iter_task_new.md) [:octicons-tag-24: v6.12](https://github.com/torvalds/linux/commit/67666479edf1e2b732f4d0ac797885e859a78de4) - \n    - [`bpf_iter_task_next`](../kfuncs/bpf_iter_task_next.md) [:octicons-tag-24: v6.12](https://github.com/torvalds/linux/commit/67666479edf1e2b732f4d0ac797885e859a78de4) - \n    - [`bpf_iter_task_vma_destroy`](../kfuncs/bpf_iter_task_vma_destroy.md) [:octicons-tag-24: v6.12](https://github.com/torvalds/linux/commit/67666479edf1e2b732f4d0ac797885e859a78de4) - \n    - [`bpf_iter_task_vma_new`](../kfuncs/bpf_iter_task_vma_new.md) [:octicons-tag-24: v6.12](https://github.com/torvalds/linux/commit/67666479edf1e2b732f4d0ac797885e859a78de4) - \n    - [`bpf_iter_task_vma_next`](../kfuncs/bpf_iter_task_vma_next.md) [:octicons-tag-24: v6.12](https://github.com/torvalds/linux/commit/67666479edf1e2b732f4d0ac797885e859a78de4) - \n    - [`bpf_local_irq_restore`](../kfuncs/bpf_local_irq_restore.md) [:octicons-tag-24: v6.12](https://github.com/torvalds/linux/commit/67666479edf1e2b732f4d0ac797885e859a78de4) - \n    - [`bpf_local_irq_save`](../kfuncs/bpf_local_irq_save.md) [:octicons-tag-24: v6.12](https://github.com/torvalds/linux/commit/67666479edf1e2b732f4d0ac797885e859a78de4) - \n    - [`bpf_map_sum_elem_count`](../kfuncs/bpf_map_sum_elem_count.md) [:octicons-tag-24: v6.12](https://github.com/torvalds/linux/commit/67666479edf1e2b732f4d0ac797885e859a78de4) - \n    - [`bpf_preempt_disable`](../kfuncs/bpf_preempt_disable.md) [:octicons-tag-24: v6.12](https://github.com/torvalds/linux/commit/67666479edf1e2b732f4d0ac797885e859a78de4) - \n    - [`bpf_preempt_enable`](../kfuncs/bpf_preempt_enable.md) [:octicons-tag-24: v6.12](https://github.com/torvalds/linux/commit/67666479edf1e2b732f4d0ac797885e859a78de4) - \n    - [`bpf_rcu_read_lock`](../kfuncs/bpf_rcu_read_lock.md) [:octicons-tag-24: v6.12](https://github.com/torvalds/linux/commit/67666479edf1e2b732f4d0ac797885e859a78de4) - \n    - [`bpf_rcu_read_unlock`](../kfuncs/bpf_rcu_read_unlock.md) [:octicons-tag-24: v6.12](https://github.com/torvalds/linux/commit/67666479edf1e2b732f4d0ac797885e859a78de4) - \n    - [`bpf_rdonly_cast`](../kfuncs/bpf_rdonly_cast.md) [:octicons-tag-24: v6.12](https://github.com/torvalds/linux/commit/67666479edf1e2b732f4d0ac797885e859a78de4) - \n    - [`bpf_sock_addr_set_sun_path`](../kfuncs/bpf_sock_addr_set_sun_path.md) [:octicons-tag-24: v6.12](https://github.com/torvalds/linux/commit/67666479edf1e2b732f4d0ac797885e859a78de4) - \n    - [`bpf_wq_init`](../kfuncs/bpf_wq_init.md) [:octicons-tag-24: v6.12](https://github.com/torvalds/linux/commit/67666479edf1e2b732f4d0ac797885e859a78de4) - \n    - [`bpf_wq_set_callback_impl`](../kfuncs/bpf_wq_set_callback_impl.md) [:octicons-tag-24: v6.12](https://github.com/torvalds/linux/commit/67666479edf1e2b732f4d0ac797885e859a78de4) - \n    - [`bpf_wq_start`](../kfuncs/bpf_wq_start.md) [:octicons-tag-24: v6.12](https://github.com/torvalds/linux/commit/67666479edf1e2b732f4d0ac797885e859a78de4) - \n<!-- [/PROG_KFUNC_REF] -->\n```\n\n----------------------------------------\n\nTITLE: Definition of bpf_obj_pin function in C\nDESCRIPTION: The bpf_obj_pin function is a low-level wrapper for the BPF_OBJ_PIN syscall command, taking a file descriptor and pathname as parameters and returning 0 on success or a negative error code on failure.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_obj_pin.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nint bpf_obj_pin(int fd, const char *pathname);\n```\n\n----------------------------------------\n\nTITLE: Enum Definition for bpf_tc_flags in C\nDESCRIPTION: Defines flags that can be used with bpf_tc_opts. Currently includes only BPF_TC_F_REPLACE which replaces an existing program and fails if no program is attached.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_tc_attach.md#2025-04-22_snippet_3\n\nLANGUAGE: c\nCODE:\n```\nenum bpf_tc_flags {\n\tBPF_TC_F_REPLACE = 1 << 0, // Replace existing program, fail if no program is attached\n};\n```\n\n----------------------------------------\n\nTITLE: Defining the BTF Dump Callback Function Type and Constructor in libbpf\nDESCRIPTION: This code snippet defines the signature for the 'btf_dump__new' function that creates a new BTF dumper object, along with the callback function type used for printing BTF data.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/btf_dump__new.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\ntypedef void (*btf_dump_printf_fn_t)(void *ctx, const char *fmt, va_list args);\n\nstruct btf_dump *btf_dump__new(const struct btf *btf, btf_dump_printf_fn_t printf_fn, void *ctx, const struct btf_dump_opts *opts);\n```\n\n----------------------------------------\n\nTITLE: Defining the bpf_map__set_value_size function in C\nDESCRIPTION: This C code defines the signature for the 'bpf_map__set_value_size' function. It takes a pointer to a 'bpf_map' structure ('map') and a '__u32' size ('size') as input. The function returns 0 on success and a negative error code otherwise. It is used to set the size of values stored within the specified BPF map, with special behavior for memory-mapped regions.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_map__set_value_size.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nint bpf_map__set_value_size(struct bpf_map *map, __u32 size);\n```\n\n----------------------------------------\n\nTITLE: Defining the 'bpf_cpumask_set_cpu' KFunc Signature in C\nDESCRIPTION: This C code snippet defines the function signature for the eBPF kernel function 'bpf_cpumask_set_cpu'. It takes an unsigned 32-bit integer 'cpu' (representing the CPU index to set) and a pointer to a 'bpf_cpumask' struct 'cpumask' (the target CPU mask) as input. The function modifies the provided cpumask in place to set the specified CPU bit and returns void.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/bpf_cpumask_set_cpu.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n#!c void bpf_cpumask_set_cpu(u32 cpu, struct bpf_cpumask *cpumask)\n```\n\n----------------------------------------\n\nTITLE: Defining BPF Attributes for netfilter\nDESCRIPTION: This C code snippet defines a union, `bpf_attr`, for the netfilter attribute in eBPF. It includes elements like `pf`, `hooknum`, `priority`, and `flags`, each with a specific purpose such as indicating protocol family or hook ordering. This structure requires understanding of network protocols and priorities for proper configuration. Kernel version 6.4 is required.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/syscall/BPF_LINK_CREATE.md#2025-04-22_snippet_2\n\nLANGUAGE: C\nCODE:\n```\nunion bpf_attr {\n\tstruct {\n\t\t[...]\n\t\tunion {\n\t\t\tstruct {\n\t\t\t\t__u32\t\t[pf](#pf);\n\t\t\t\t__u32\t\t[hooknum](#hooknum);\n\t\t\t\t__s32\t\t[priority](#priority);\n\t\t\t\t__u32\t\t[flags](#netfilter-flags);\n\t\t\t} netfilter;\n\t\t}\n\t}\n}\n```\n\n----------------------------------------\n\nTITLE: Declaring the 'select_cpu' Function Pointer in 'sched_ext_ops' (C)\nDESCRIPTION: Declares the 'select_cpu' function pointer within the 'sched_ext_ops' struct. This function is implemented by the BPF scheduler and called by the kernel when a task (`p`) is woken up. Its purpose is to select a target CPU for the task, considering its previous CPU (`prev_cpu`) and wake flags (`wake_flags`). Returning an idle CPU can trigger it to start dispatching.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/program-type/BPF_PROG_TYPE_STRUCT_OPS/sched_ext_ops.md#2025-04-22_snippet_7\n\nLANGUAGE: c\nCODE:\n```\ns32 (*select_cpu)(struct task_struct *p, s32 prev_cpu, u64 wake_flags);\n```\n\n----------------------------------------\n\nTITLE: Declaring the bpf_map__set_map_extra function (C)\nDESCRIPTION: This C code snippet shows the function signature for 'bpf_map__set_map_extra'. It takes a pointer to a 'bpf_map' struct and a '__u64' value for 'map_extra' as input. The function is intended to set extra map options before the map is created via libbpf. It returns 0 on success and a negative error code on failure. This must be called before the map is created.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_map__set_map_extra.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nint bpf_map__set_map_extra(struct bpf_map *map, __u64 map_extra);\n```\n\n----------------------------------------\n\nTITLE: Defining scx_bpf_reenqueue_local KFunc in C\nDESCRIPTION: Function signature for the scx_bpf_reenqueue_local kfunc. It returns the number of processed tasks and can only be called from sched_ext_ops.cpu_release.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/scx_bpf_reenqueue_local.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nu32 scx_bpf_reenqueue_local()\n```\n\n----------------------------------------\n\nTITLE: BPF_F_SLEEPABLE Flag Documentation\nDESCRIPTION: Documents the BPF_F_SLEEPABLE flag (introduced in v5.10) which allows BPF programs to use sleeping functionality and helpers like bpf_copy_from_user, but limits where such programs can be attached.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/syscall/BPF_PROG_LOAD.md#2025-04-22_snippet_6\n\nLANGUAGE: markdown\nCODE:\n```\n### `BPF_F_SLEEPABLE`\n\n<!-- [FEATURE_TAG](BPF_F_SLEEPABLE) -->\n[:octicons-tag-24: v5.10](https://github.com/torvalds/linux/commit/1e6c62a8821557720a9b2ea9617359b264f2f67c)\n<!-- [/FEATURE_TAG] -->\n\nIf `BPF_F_SLEEPABLE` is used in `BPF_PROG_LOAD` command, the verifier will restrict map and helper usage for such programs. Sleepable BPF programs can only be attached to hooks where kernel execution context allows sleeping. Such programs are allowed to use helpers that may sleep like [`bpf_copy_from_user`](../helper-function/bpf_copy_from_user.md).\n```\n\n----------------------------------------\n\nTITLE: Definition of perf_buffer__buffer Function in Libbpf C API\nDESCRIPTION: Function signature for perf_buffer__buffer which retrieves the raw mmap'ed memory region of a perf buffer. It takes a perf buffer structure, buffer index, and provides output parameters for the buffer pointer and size.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/perf_buffer__buffer.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nint perf_buffer__buffer(struct perf_buffer *pb, int buf_idx, void **buf, size_t *buf_size);\n```\n\n----------------------------------------\n\nTITLE: Defining scx_bpf_task_cgroup KFunc in C\nDESCRIPTION: This snippet defines the KFunc 'scx_bpf_task_cgroup' that returns a sched cGroup for a given task. It ensures atomicity through rq lock for rq-locked operations. The function takes a task struct pointer 'p' as a parameter and returns a pointer to a refcounted struct cgroup object. Proper management of this pointer through release kfunc or map transfer is necessary to pass BPF verifier checks.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/scx_bpf_task_cgroup.md#2025-04-22_snippet_0\n\nLANGUAGE: C\nCODE:\n```\n#!c struct cgroup *scx_bpf_task_cgroup(struct task_struct *p)\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_tc_flags enum in C\nDESCRIPTION: This enum defines the flags for TC qdisc operations, currently only including the replace flag.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_tc_detach.md#2025-04-22_snippet_4\n\nLANGUAGE: c\nCODE:\n```\nenum bpf_tc_flags {\n\tBPF_TC_F_REPLACE = 1 << 0, // Replace existing program, fail if no program is attached\n};\n```\n\n----------------------------------------\n\nTITLE: Defining eBPF kfunc bpf_cpumask_first in C\nDESCRIPTION: This C code snippet provides the function signature for the 'bpf_cpumask_first' kfunc. It requires a 'struct cpumask' pointer as input and returns a u32 integer representing the index of the first nonzero bit in the CPU mask. This function is commonly utilized in various BPF program types, ensuring compatibility with applicable kernel versions.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/bpf_cpumask_first.md#2025-04-22_snippet_0\n\nLANGUAGE: C\nCODE:\n```\nu32 bpf_cpumask_first(const struct cpumask *cpumask)\n```\n\n----------------------------------------\n\nTITLE: Defining btf__add_const Function Signature in C\nDESCRIPTION: Function signature for btf__add_const that appends a new BTF_KIND_CONST type to a BTF object. Takes a BTF struct pointer and reference type ID as parameters. Returns the new type ID on success or negative value on error.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/btf__add_const.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nint btf__add_const(struct btf *btf, int ref_type_id);\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_rcu_read_unlock KFunc in C\nDESCRIPTION: Function definition for the bpf_rcu_read_unlock kernel function that releases an RCU read lock region in BPF programs. This function takes no parameters and returns void.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/bpf_rcu_read_unlock.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nvoid bpf_rcu_read_unlock()\n```\n\n----------------------------------------\n\nTITLE: Declaring eBPF KFunc scx_bpf_test_and_clear_cpu_idle in C\nDESCRIPTION: This code snippet presents the C function signature for the eBPF kernel function 'scx_bpf_test_and_clear_cpu_idle', which allows programs to test and clear the idle state for a given CPU. Dependencies include access to BPF kfuncs in a Linux kernel supporting this API (v6.12+). The function takes an s32 'cpu' identifying the target CPU and returns a boolean indicating whether the idle state was cleared. This function is applicable across several eBPF program types (e.g., LSM, PERF_EVENT, STRUCT_OPS, SYSCALL, TRACEPOINT, and TRACING) and requires that sched_ext_ops.update_idle is not implemented unless SCX_OPS_KEEP_BUILTIN_IDLE is set.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/scx_bpf_test_and_clear_cpu_idle.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nbool scx_bpf_test_and_clear_cpu_idle(s32 cpu)\n```\n\n----------------------------------------\n\nTITLE: Defining Perf Event Sample Structure in C\nDESCRIPTION: This structure defines a sample event in the perf event ring buffer, including the header, timestamp, size, and data payload.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/map-type/BPF_MAP_TYPE_PERF_EVENT_ARRAY.md#2025-04-22_snippet_5\n\nLANGUAGE: c\nCODE:\n```\nstruct perf_event_sample {\n\tstruct perf_event_header header;\n\t__u64 time;\n\t__u32 size;\n\tunsigned char data[];\n};\n```\n\n----------------------------------------\n\nTITLE: Defining the bbr_cwnd_event KFunc Signature in C\nDESCRIPTION: This C code snippet presents the function signature for the `bbr_cwnd_event` eBPF kfunc. It takes a pointer to a socket (`struct sock *sk`) and a TCP congestion avoidance event (`tcp_ca_event event`) as input. This function is designed to be called from `BPF_PROG_TYPE_STRUCT_OPS` eBPF programs when a congestion window event happens in the TCP BBR implementation.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/bbr_cwnd_event.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n`#!c void bbr_cwnd_event(struct sock *sk, tcp_ca_event event)`\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_get_cgroup_classid Helper Function in C\nDESCRIPTION: Function prototype for the bpf_get_cgroup_classid eBPF helper. It takes a struct __sk_buff pointer as an argument and returns a __u32 classid.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_get_cgroup_classid.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstatic __u32 (* const bpf_get_cgroup_classid)(struct __sk_buff *skb) = (void *) 17;\n```\n\n----------------------------------------\n\nTITLE: Function Definition for bpf_obj_get_info_by_fd\nDESCRIPTION: Function signature for retrieving information about a BPF object using its file descriptor. Takes a BPF file descriptor, an info buffer, and buffer length pointer as parameters. Returns the amount of information written or a negative error code.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_obj_get_info_by_fd.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nint bpf_obj_get_info_by_fd(int bpf_fd, void *info, __u32 *info_len);\n```\n\n----------------------------------------\n\nTITLE: BPF BTF Info Structure Definition\nDESCRIPTION: C structure definition for bpf_btf_info that stores BTF (BPF Type Format) related information including serialized BTF data, size, and kernel BTF details.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/syscall/BPF_OBJ_GET_INFO_BY_FD.md#2025-04-22_snippet_3\n\nLANGUAGE: c\nCODE:\n```\nstruct bpf_btf_info {\n    __aligned_u64 btf;\n    __u32 btf_size;\n    __u32 id;\n    __aligned_u64 name;\n    __u32 name_len;\n    __u32 kernel_btf;\n} __attribute__((aligned(8)));\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_skb_vlan_pop Helper Function in C\nDESCRIPTION: This code snippet defines the bpf_skb_vlan_pop helper function for eBPF programs. It takes a pointer to an __sk_buff structure as an argument and returns a long integer. The function is used to pop a VLAN header from the packet associated with the given sk_buff.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_skb_vlan_pop.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstatic long (* const bpf_skb_vlan_pop)(struct __sk_buff *skb) = (void *) 19;\n```\n\n----------------------------------------\n\nTITLE: Using __percpu_kptr in Struct Definition in C\nDESCRIPTION: This code demonstrates how to use the __percpu_kptr macro in a struct definition to tag a pointer as a per-CPU kernel pointer.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/ebpf/__percpu_kptr.md#2025-04-22_snippet_1\n\nLANGUAGE: c\nCODE:\n```\nstruct elem {\n\tlong sum;\n\tstruct val_t __percpu_kptr *pc;\n};\n```\n\n----------------------------------------\n\nTITLE: Defining the bpf_ct_set_timeout KFunc in C\nDESCRIPTION: Function signature for the bpf_ct_set_timeout kfunc which takes a pointer to an nf_conn___init object and a timeout value in milliseconds. This kfunc must be used with a refcounted pointer to nf_conn___init.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/bpf_ct_set_timeout.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nvoid bpf_ct_set_timeout(struct nf_conn___init *nfct, u32 timeout)\n```\n\n----------------------------------------\n\nTITLE: Freeing BTF Dumper Object in C\nDESCRIPTION: Function definition for btf_dump__free that takes a pointer to a struct btf_dump object and frees it. This function is used to clean up BTF dumper objects when they are no longer needed.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/btf_dump__free.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nvoid btf_dump__free(struct btf_dump *d);\n```\n\n----------------------------------------\n\nTITLE: Definition of struct bpf_prog_detach_opts in C\nDESCRIPTION: This struct defines the options for the bpf_prog_detach_opts function, allowing configuration of the BPF program detachment process. It includes fields for size tracking, flags, relative file descriptors, IDs, and expected revision numbers for compatibility.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_prog_detach_opts.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstruct bpf_prog_detach_opts {\n\tsize_t sz; /* size of this struct for forward/backward compatibility */\n\t__u32 flags;\n\tint relative_fd;\n\t__u32 relative_id;\n\t__u64 expected_revision;\n\tsize_t :0;\n};\n```\n\n----------------------------------------\n\nTITLE: Defining the `bpf_map_delete_elem` Function in C\nDESCRIPTION: Defines the C function `bpf_map_delete_elem` from the libbpf library. This function acts as a low-level wrapper around the `BPF_MAP_DELETE_ELEM` syscall command. It takes the file descriptor (`fd`) of the target eBPF map and a pointer to the key (`key`) of the element to be deleted. It returns 0 on successful deletion and a negative error code otherwise.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_map_delete_elem.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n#!c int bpf_map_delete_elem(int fd, const void *key);\n```\n\n----------------------------------------\n\nTITLE: Structure Definition for bpf_tc_hook in C\nDESCRIPTION: Defines the structure used to specify hook information for TC qdisc attachment. Contains fields for interface index, attach point, and parent qdisc ID.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_tc_attach.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstruct bpf_tc_hook {\n\tsize_t sz;\n\tint ifindex;\n\tenum bpf_tc_attach_point attach_point;\n\t__u32 parent;\n\tsize_t :0;\n};\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_object__pin_maps function in C\nDESCRIPTION: Function signature for bpf_object__pin_maps which pins each map contained within a BPF object at the specified directory. It takes a pointer to a BPF object and a path string, returning 0 on success or a negative error code on failure.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_object__pin_maps.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nint bpf_object__pin_maps(struct bpf_object *obj, const char *path);\n```\n\n----------------------------------------\n\nTITLE: Defining SCX CGroup Initialization Arguments in C\nDESCRIPTION: Structure for passing arguments to the cgroup_init callback when initializing a cgroup in the scheduler extension. Contains a weight field ranging from 1 to 10000.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/program-type/BPF_PROG_TYPE_STRUCT_OPS/sched_ext_ops.md#2025-04-22_snippet_58\n\nLANGUAGE: c\nCODE:\n```\nstruct scx_cgroup_init_args {\n\tu32 weight;\n};\n```\n\n----------------------------------------\n\nTITLE: Defining and Implementing bpf_cgroup_acquire in C\nDESCRIPTION: The 'bpf_cgroup_acquire' function acquires a reference to a cGroup. If the cGroup reference is not stored as a kptr in a map, it needs to be explicitly released via 'bpf_cgroup_release()' to avoid resource leaks. This snippet requires eBPF and kernel headers. It returns NULL if the allocation fails, necessitating a NULL check before use.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/bpf_cgroup_acquire.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstruct cgroup *bpf_cgroup_acquire(struct cgroup *cgrp)\n```\n\n----------------------------------------\n\nTITLE: Defining SCX Entity Flags Enumeration in C\nDESCRIPTION: Defines the enum scx_ent_flags which specifies flags for scheduler entities. These flags track the state of tasks in the scheduler, such as whether they are queued or sleeping.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/program-type/BPF_PROG_TYPE_STRUCT_OPS/sched_ext_ops.md#2025-04-22_snippet_43\n\nLANGUAGE: c\nCODE:\n```\nenum scx_ent_flags {\n    SCX_TASK_QUEUED             = 1 << 0,\n\tSCX_TASK_RESET_RUNNABLE_AT  = 1 << 2,\n\tSCX_TASK_DEQD_FOR_SLEEP     = 1 << 3,\n\tSCX_TASK_CURSOR             = 1 << 31,\n};\n```\n\n----------------------------------------\n\nTITLE: Using xsk_ring_prod__reserve Function in C\nDESCRIPTION: Function definition for reserving slots in a producer ring. Returns the number of successfully reserved slots as a __u32 value, or 0 on failure. The number of reserved slots may be less than or equal to the requested number.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libxdp/functions/xsk_ring_prod__reserve.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n__u32 xsk_ring_prod__reserve(struct xsk_ring_prod *prod, __u32 nb, __u32 *idx);\n```\n\n----------------------------------------\n\nTITLE: Using bpf_for macro in eBPF program\nDESCRIPTION: This example demonstrates how to use the bpf_for macro in an eBPF program. It iterates over a range of numbers (2 to 4) and prints each value using bpf_printk.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/ebpf/bpf_for.md#2025-04-22_snippet_1\n\nLANGUAGE: c\nCODE:\n```\nSEC(\"raw_tp/sys_enter\")\nint iter_next_rcu(const void *ctx)\n{\n\tint v;\n\n    // Will print 2, 3, 4\n    bpf_for(v, 2, 5) {\n        bpf_printk(\"X = %d\", v);\n    }\n\n\treturn 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining KFunc 'scx_bpf_destroy_dsq' in C\nDESCRIPTION: This code snippet declares the 'scx_bpf_destroy_dsq' kfunc, which is responsible for destroying custom DSQs identified by their ID. It presupposes that the DSQ was previously created using 'scx_bpf_create_dsq', and is ensured empty before destruction. The function is used within various BPF program types and can be invoked from any available 'sched_ext_ops'.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/scx_bpf_destroy_dsq.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n#!c void scx_bpf_destroy_dsq(u64 dsq_id)\n```\n\n----------------------------------------\n\nTITLE: CGroup Weight Set Callback Definition in C\nDESCRIPTION: Callback function signature for updating cgroup weight. Takes cgroup struct and new weight value as parameters.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/program-type/BPF_PROG_TYPE_STRUCT_OPS/sched_ext_ops.md#2025-04-22_snippet_35\n\nLANGUAGE: c\nCODE:\n```\nvoid (*cgroup_set_weight)(struct cgroup *cgrp, u32 weight);\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_sock_from_file Helper Function in C\nDESCRIPTION: Definition of the bpf_sock_from_file helper function, which returns a pointer to a struct socket if the given file represents a socket, or NULL otherwise.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_sock_from_file.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstatic struct socket *(* const bpf_sock_from_file)(struct file *file) = (void *) 162;\n```\n\n----------------------------------------\n\nTITLE: Defining the bpf_cpumask_first_zero KFunc Signature in C\nDESCRIPTION: Defines the C function signature for the eBPF kernel function (kfunc) `bpf_cpumask_first_zero`. This function takes a constant pointer to a `struct cpumask` as input and returns a `u32` representing the index of the first unset (zero) bit within that mask. A pointer to `struct bpf_cpumask` can also be safely passed.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/bpf_cpumask_first_zero.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nu32 bpf_cpumask_first_zero(const struct cpumask *cpumask)\n```\n\n----------------------------------------\n\nTITLE: Defining the 'bpf_cpumask_first_and' KFunc Signature in C\nDESCRIPTION: This C code snippet presents the function signature for the eBPF kfunc `bpf_cpumask_first_and`. It takes two constant pointers to `struct cpumask` (src1 and src2) as input and returns a `u32` representing the index of the first set bit in the logical AND of the two input CPU masks. The function requires pointers to valid `struct cpumask` or `struct bpf_cpumask` objects.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/bpf_cpumask_first_and.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n`#!c u32 bpf_cpumask_first_and(const struct cpumask *src1, const struct cpumask *src2)`\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_task_under_cgroup KFunc in C\nDESCRIPTION: Defines the signature of the 'bpf_task_under_cgroup' kfunc. This function tests whether a task's default cgroup hierarchy is a descendant of a given ancestor cgroup.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/bpf_task_under_cgroup.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nlong int bpf_task_under_cgroup(struct task_struct *task, struct cgroup *ancestor)\n```\n\n----------------------------------------\n\nTITLE: Defining BTF Enum Creation Function in C\nDESCRIPTION: Function definition for btf__add_enum which creates a new BTF enum type. Takes a BTF object pointer, enum name, and size in bytes as parameters. Returns the new type ID on success or negative value on error.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/btf__add_enum.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nint btf__add_enum(struct btf *btf, const char *name, __u32 bytes_sz);\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_set_hash Helper Function in C\nDESCRIPTION: This snippet defines the 'bpf_set_hash' helper function prototype. It sets the full hash for a socket buffer (skb) to a specified value.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_set_hash.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstatic long (* const bpf_set_hash)(struct __sk_buff *skb, __u32 hash) = (void *) 48;\n```\n\n----------------------------------------\n\nTITLE: Defining BPF_MAP_TYPE_CPUMAP Value Structure in C\nDESCRIPTION: This struct defines the value structure for CPU map entries after Linux v5.9. It includes a queue size field and a union containing either a file descriptor or program ID for the secondary XDP program to execute on the redirected packet.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/map-type/BPF_MAP_TYPE_CPUMAP.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstruct bpf_cpumap_val {\n\t__u32 qsize;\t/* queue size to remote target CPU */\n\tunion {\n\t\tint   fd;\t/* prog fd on map write */\n\t\t__u32 id;\t/* prog id on map read */\n\t} bpf_prog;\n};\n```\n\n----------------------------------------\n\nTITLE: Definition of btf__endianness function in C\nDESCRIPTION: Function signature for btf__endianness that retrieves the endianness of a BTF object. It takes a pointer to a struct btf object as input and returns an enum btf_endianness value.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/btf__endianness.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nenum btf_endianness btf__endianness(const struct btf *btf);\n```\n\n----------------------------------------\n\nTITLE: Defining Libbpf Map Creation Function in C\nDESCRIPTION: Defines the bpf_map_create function and associated struct from libbpf, used for manual creation of eBPF maps during runtime.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/concepts/maps.md#2025-04-22_snippet_5\n\nLANGUAGE: C\nCODE:\n```\nLIBBPF_API int bpf_map_create(enum bpf_map_type map_type,\n\t\t\t      const char *map_name,\n\t\t\t      __u32 key_size,\n\t\t\t      __u32 value_size,\n\t\t\t      __u32 max_entries,\n\t\t\t      const struct bpf_map_create_opts *opts);\n\nstruct bpf_map_create_opts {\n\tsize_t sz; /* size of this struct for forward/backward compatibility */\n\n\t__u32 btf_fd;\n\t__u32 btf_key_type_id;\n\t__u32 btf_value_type_id;\n\t__u32 btf_vmlinux_value_type_id;\n\n\t__u32 inner_map_fd;\n\t__u32 map_flags;\n\t__u64 map_extra;\n\n\t__u32 numa_node;\n\t__u32 map_ifindex;\n};\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_object__destroy_skeleton Function in C\nDESCRIPTION: Function signature for bpf_object__destroy_skeleton which detaches all loaded BPF programs of a skeleton and frees any associated resources. The function takes a pointer to a bpf_object_skeleton structure as its only parameter.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_object__destroy_skeleton.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nvoid bpf_object__destroy_skeleton(struct bpf_object_skeleton *s);\n```\n\n----------------------------------------\n\nTITLE: Declaring the bpf_sys_bpf Helper Function Pointer in eBPF (C)\nDESCRIPTION: Defines a static function pointer to the kernel's 'bpf_sys_bpf' helper for executing the eBPF syscall with specific arguments. Dependencies include kernel headers providing '__u32' and appropriate privilege to use helper functions. Parameters: 'cmd' (operation code), 'attr' (pointer to attributes structure), and 'attr_size' (length of attributes), all passed to the kernel syscall handler. Returns a long integer with the syscall result or error code. Intended for use within BPF programs allowed to perform syscalls via 'BPF_PROG_TYPE_SYSCALL'.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_sys_bpf.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n#!c static long (* const bpf_sys_bpf)(__u32 cmd, void *attr, __u32 attr_size) = (void *) 166;\n```\n\n----------------------------------------\n\nTITLE: Using bpf_get_current_comm in eBPF Program\nDESCRIPTION: Example showing how to use bpf_get_current_comm in an eBPF program attached to the sys_enter_open tracepoint. It retrieves and prints the current task's executable name.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_get_current_comm.md#2025-04-22_snippet_1\n\nLANGUAGE: c\nCODE:\n```\n#include <vmlinux.h>\n#include <bpf/bpf_helpers.h>\n\nSEC(\"tp/syscalls/sys_enter_open\")\nint sys_open_trace(void *ctx) {\n  // TASK_COMM_LEN is defined in vmlinux.h\n  char comm[TASK_COMM_LEN];\n  if (bpf_get_current_comm(comm, TASK_COMM_LEN)) {\n    bpf_printk(\"Failed to get comm\\n\");\n    return 0;\n  }\n  bpf_printk(\"Hello from %s\\n\", comm);\n  return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Opening a Perf Event for Tracepoint Attachment - C\nDESCRIPTION: Illustrates how to open a perf event file descriptor to represent a kernel tracepoint, using the perf_event_open syscall in C. The code initializes struct perf_event_attr with parameters required for tracepoint use (e.g., type set to PERF_TYPE_TRACEPOINT, config to the trace event ID retrieved from tracefs). The syscall returns a file descriptor that is used for subsequent eBPF attachment. Requires kernel headers and proper user privileges. Inputs include the event ID; outputs a file descriptor on success.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/program-type/BPF_PROG_TYPE_TRACEPOINT.md#2025-04-22_snippet_2\n\nLANGUAGE: c\nCODE:\n```\nstruct perf_event_attr attr = {\n    .type = PERF_TYPE_TRACEPOINT,\n    .size = sizeof(struct perf_event_attr),\n    .config = event_id, /* The ID of your trace event */\n    .sample_period = 1,\n    .sample_type = PERF_SAMPLE_RAW,\n    .wakeup_events = 1,\n};\n\nsyscall(SYS_perf_event_open, \n    &attr,  /* struct perf_event_attr * */\n    -1,     /* pid_t pid */\n    0       /* int cpu */\n    -1,     /* int group_fd */\n    PERF_FLAG_FD_CLOEXEC /* unsigned long flags */\n);\n```\n\n----------------------------------------\n\nTITLE: Definition of libbpf_bpf_prog_type_str Function in C\nDESCRIPTION: Function signature for libbpf_bpf_prog_type_str which takes a bpf_prog_type enum parameter and returns a const char pointer to a string representation of the program type. Returns NULL for unknown program types.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/libbpf_bpf_prog_type_str.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nconst char *libbpf_bpf_prog_type_str(enum bpf_prog_type t);\n```\n\n----------------------------------------\n\nTITLE: Defining the '__weak' Macro in C (libbpf)\nDESCRIPTION: This code snippet defines the '__weak' macro using GCC-style attributes for the C language. The macro allows functions or variables to be marked as weak symbols, which can be overridden by strong symbols during linking. In eBPF, the '__weak' attribute indicates to loaders to make a best effort to locate the symbol but tolerate its absence, so the program must check availability at runtime.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/ebpf/__weak.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n#define __weak __attribute__((weak))\n```\n\n----------------------------------------\n\nTITLE: Defining btf__add_decl_tag function in C\nDESCRIPTION: Function signature for btf__add_decl_tag which adds a declaration tag to a BTF object. It takes a BTF object pointer, tag value, reference type ID, and component index as parameters. Returns a positive type ID on success or a negative value on failure.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/btf__add_decl_tag.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nint btf__add_decl_tag(struct btf *btf, const char *value, int ref_type_id, int component_idx);\n```\n\n----------------------------------------\n\nTITLE: Using PT_REGS_PARM1 in eBPF Network Packet Processing\nDESCRIPTION: Example demonstrates using PT_REGS_PARM1 macro to access network packet data from a kprobe context. The program attaches to __netif_receive_skb_core, extracts the sk_buff pointer using PT_REGS_PARM1, and processes packets on the loopback device.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/ebpf/PT_REGS_PARM.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nSEC(\"kprobe.multi/__netif_receive_skb_core*\")\nint bpf_prog1(struct pt_regs *ctx)\n{\n\tchar devname[IFNAMSIZ];\n\tstruct net_device *dev;\n\tstruct sk_buff *skb;\n\tint len;\n\n\tbpf_core_read(&skb, sizeof(skb), (void *)PT_REGS_PARM1(ctx));\n\tdev = BPF_CORE_READ(skb, dev);\n\tlen = BPF_CORE_READ(skb, len);\n\n\tBPF_CORE_READ_STR_INTO(&devname, dev, name);\n\n\tif (devname[0] == 'l' && devname[1] == 'o') {\n\t\tchar fmt[] = \"skb %p len %d\\n\";\n\t\t/* using bpf_trace_printk() for DEBUG ONLY */\n\t\tbpf_trace_printk(fmt, sizeof(fmt), skb, len);\n\t}\n\n\treturn 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_sk_release Helper Function in C\nDESCRIPTION: C definition of the bpf_sk_release eBPF helper function. It takes a void pointer to a socket and returns a long integer status code.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_sk_release.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstatic long (* const bpf_sk_release)(void *sock) = (void *) 86;\n```\n\n----------------------------------------\n\nTITLE: Task State Dump Callback Definition in C\nDESCRIPTION: Callback function signature for dumping task-specific scheduler state during errors. Takes dump context and task struct as parameters.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/program-type/BPF_PROG_TYPE_STRUCT_OPS/sched_ext_ops.md#2025-04-22_snippet_29\n\nLANGUAGE: c\nCODE:\n```\nvoid (*dump_task)(struct scx_dump_ctx *ctx, struct task_struct *p);\n```\n\n----------------------------------------\n\nTITLE: Releasing HID-BPF Context Using hid_bpf_release_context in C\nDESCRIPTION: Declares the hid_bpf_release_context function for use by eBPF programs to release a previously allocated hid_bpf_ctx pointer. The function requires that only a single referenced pointer is passed in, and after its invocation all copies of that pointer are invalidated. This kfunc may sleep, therefore it can be called only from sleepable programs unless used in BPF_PROG_TYPE_SYSCALL, per kernel constraints. The function expects a non-null pointer to struct hid_bpf_ctx as argument and does not return a value.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/hid_bpf_release_context.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n#!c void hid_bpf_release_context(struct hid_bpf_ctx *ctx)\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_netkit_opts Structure in C\nDESCRIPTION: This struct defines the options available when attaching a netkit program. It includes fields for size, flags for controlling attachment behavior, relative file descriptors and IDs, and expected revision numbers.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_program__attach_netkit.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstruct bpf_netkit_opts {\n\t/* size of this struct, for forward/backward compatibility */\n\tsize_t sz;\n\t__u32 flags;\n\t__u32 relative_fd;\n\t__u32 relative_id;\n\t__u64 expected_revision;\n\tsize_t :0;\n};\n```\n\n----------------------------------------\n\nTITLE: Defining the bpf_cpumask_acquire KFunc Signature in C\nDESCRIPTION: Provides the C function signature for the eBPF kfunc 'bpf_cpumask_acquire'. This function takes a pointer to an existing BPF CPU-mask ('cpumask') and returns a pointer to the same structure after incrementing its reference count. The returned pointer represents an acquired reference that must be explicitly released using 'bpf_cpumask_release' or transferred to a map via 'bpf_kptr_xchg' to avoid resource leaks, as enforced by the eBPF verifier.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/bpf_cpumask_acquire.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n#!c struct bpf_cpumask *bpf_cpumask_acquire(struct bpf_cpumask *cpumask)\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_map_get_next_key Function in C\nDESCRIPTION: Function definition for bpf_map_get_next_key, a low-level wrapper around the BPF_MAP_GET_NEXT_KEY syscall. The function takes a map file descriptor, current key pointer, and next key pointer as parameters, returning 0 on success or a negative error code on failure.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_map_get_next_key.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nint bpf_map_get_next_key(int fd, const void *key, void *next_key);\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_program__set_attach_target Function in C\nDESCRIPTION: Function signature for the bpf_program__set_attach_target function. This function sets BTF-based attach targets for supported BPF program types, taking parameters for the BPF program, attach program file descriptor, and attach function name.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_program__set_attach_target.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nint bpf_program__set_attach_target(struct bpf_program *prog, int attach_prog_fd, const char *attach_func_name);\n```\n\n----------------------------------------\n\nTITLE: Pinning BPF Map using libbpf C Function\nDESCRIPTION: The function `bpf_map__pin` from Libbpf library is used to create a filesystem pin for a BPF map, which increases its reference count. It requires the map object and a file path for the operation, successfully returning `0` on success and a negative error code on failure. If both the `path` and map's `pin_path` are `NULL`, an error occurs.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_map__pin.md#2025-04-22_snippet_0\n\nLANGUAGE: C\nCODE:\n```\nint bpf_map__pin(struct bpf_map *map, const char *path);\n```\n\n----------------------------------------\n\nTITLE: Defining Exit Conditions for SCX Scheduler (C)\nDESCRIPTION: Defines the enum scx_exit_kind which represents the various exit conditions for the SCX scheduler, including normal completion, unregistration, and error conditions.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/program-type/BPF_PROG_TYPE_STRUCT_OPS/sched_ext_ops.md#2025-04-22_snippet_48\n\nLANGUAGE: c\nCODE:\n```\nenum scx_exit_kind {\n    SCX_EXIT_NONE,\n    SCX_EXIT_DONE,          // (1)!\n\n    SCX_EXIT_UNREG = 64,    // (2)!\n    SCX_EXIT_UNREG_BPF,     // (3)!\n    SCX_EXIT_UNREG_KERN,    // (4)!\n    SCX_EXIT_SYSRQ,         // (5)!\n\n    SCX_EXIT_ERROR = 1024,  // (6)!\n    SCX_EXIT_ERROR_BPF,     // (7)!\n    SCX_EXIT_ERROR_STALL,   // (8)!\n};\n```\n\n----------------------------------------\n\nTITLE: Defining the 'bbr_min_tso_segs' KFunc Signature in C\nDESCRIPTION: This C code snippet defines the signature for the eBPF kernel function (kfunc) 'bbr_min_tso_segs'. It takes a pointer to a 'struct sock' as input and returns a 'u32' value. This function is used within eBPF programs (specifically BPF_PROG_TYPE_STRUCT_OPS) to override the system's 'sysctl_tcp_min_tso_segs' setting for a specific socket, allowing control over the minimum number of TCP segments for TSO (TCP Segmentation Offload). It requires Linux kernel version 5.13 or later.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/bbr_min_tso_segs.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n#!c u32 bbr_min_tso_segs(struct sock *sk)\n```\n\n----------------------------------------\n\nTITLE: CGroup Move Cancel Callback Definition in C\nDESCRIPTION: Callback function signature for canceling a prepared cgroup move. Takes task struct and source/destination cgroups as parameters.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/program-type/BPF_PROG_TYPE_STRUCT_OPS/sched_ext_ops.md#2025-04-22_snippet_34\n\nLANGUAGE: c\nCODE:\n```\nvoid (*cgroup_cancel_move)(struct task_struct *p, struct cgroup *from, struct cgroup *to);\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_bprm_opts_set Helper Function in C\nDESCRIPTION: Function definition for the bpf_bprm_opts_set helper that allows setting options on linux_binprm structs. It takes a bprm pointer and flags as parameters, returning -EINVAL for invalid flags or zero on success.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_bprm_opts_set.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstatic long (* const bpf_bprm_opts_set)(struct linux_binprm *bprm, __u64 flags) = (void *) 159;\n```\n\n----------------------------------------\n\nTITLE: Indicating No Supported KFuncs in Markdown\nDESCRIPTION: This code snippet is a Markdown comment indicating that there are currently no supported KFuncs for this program type.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/program-type/BPF_PROG_TYPE_SOCK_OPS.md#2025-04-22_snippet_7\n\nLANGUAGE: markdown\nCODE:\n```\nThere are currently no kfuncs supported for this program type\n```\n\n----------------------------------------\n\nTITLE: Defining scx_bpf_put_cpumask KFunc in C\nDESCRIPTION: This code snippet defines the signature of the 'scx_bpf_put_cpumask' kfunc. It takes a pointer to a cpumask struct as a parameter and releases it. The function has no return value.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/scx_bpf_put_cpumask.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nvoid scx_bpf_put_cpumask(const struct cpumask *cpumask)\n```\n\n----------------------------------------\n\nTITLE: Defining eBPF KFunc in C\nDESCRIPTION: Defines the 'cubictcp_recalc_ssthresh' function, which returns the slow start threshold as an unsigned 32-bit integer. This function takes a pointer to a socket structure. It is essential for use in BPF programs of type 'BPF_PROG_TYPE_STRUCT_OPS'.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/cubictcp_recalc_ssthresh.md#2025-04-22_snippet_0\n\nLANGUAGE: C\nCODE:\n```\n#!c u32 cubictcp_recalc_ssthresh(struct sock *sk)\n```\n\n----------------------------------------\n\nTITLE: Defining and Using bpf_cpumask_or in C\nDESCRIPTION: The 'bpf_cpumask_or' function performs a logical OR on two CPU-masks and stores the result in the destination mask. The function takes three parameters: the destination CPU-mask and two source CPU-masks. It is aimed at BPF programs that perform operations on cpumasks. This snippet requires that the 'bpf_cpumask' structure is defined in the environment.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/bpf_cpumask_or.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nvoid bpf_cpumask_or(struct bpf_cpumask *dst, const struct cpumask *src1, const struct cpumask *src2)\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_skb_change_tail Helper Function in C\nDESCRIPTION: Function prototype for the bpf_skb_change_tail helper, which resizes the packet associated with an skb. It takes parameters for the skb, new length, and flags.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_skb_change_tail.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstatic long (* const bpf_skb_change_tail)(struct __sk_buff *skb, __u32 len, __u64 flags) = (void *) 38;\n```\n\n----------------------------------------\n\nTITLE: Defining hid_bpf_try_input_report KFunc in C\nDESCRIPTION: Function signature for the hid_bpf_try_input_report kfunc. It takes a HID-BPF context, report type, buffer, and buffer size as parameters. Returns 0 on success or a negative error code on failure.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/hid_bpf_try_input_report.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nint hid_bpf_try_input_report(struct hid_bpf_ctx *ctx, hid_report_type type, u8 *buf, const size_t buf__sz)\n```\n\n----------------------------------------\n\nTITLE: Enumeration of BTF Function Linkage Types in C\nDESCRIPTION: The btf_func_linkage enum defines the possible linkage types for BTF functions, including static (0), global (1), and extern (2).\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/btf__add_func.md#2025-04-22_snippet_1\n\nLANGUAGE: c\nCODE:\n```\nenum btf_func_linkage {\n\tBTF_FUNC_STATIC = 0,\n\tBTF_FUNC_GLOBAL = 1,\n\tBTF_FUNC_EXTERN = 2,\n};\n```\n\n----------------------------------------\n\nTITLE: KFunc Definition - bpf_percpu_obj_new_impl\nDESCRIPTION: Function signature for the bpf_percpu_obj_new_impl kfunc. Takes a local_type_id parameter representing the BTF type and a meta parameter that is rewritten by the verifier. Returns a pointer to a per-CPU object or NULL on failure.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/bpf_percpu_obj_new_impl.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nvoid *bpf_percpu_obj_new_impl(u64 local_type_id__k, void *meta__ign)\n```\n\n----------------------------------------\n\nTITLE: Setting Chain Call Actions in XDP Programs\nDESCRIPTION: Function signature for configuring which XDP actions should enable program chaining. Takes an XDP program pointer, action number, and boolean enable flag as parameters. Returns 0 on success or -EINVAL for invalid arguments. Must be called before program loading.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libxdp/functions/xdp_program__set_chain_call_enabled.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nint xdp_program__set_chain_call_enabled(struct xdp_program *prog, unsigned int action, bool enabled);\n```\n\n----------------------------------------\n\nTITLE: Definition of bpf_sock_addr_set_sun_path KFunc\nDESCRIPTION: Function signature for the bpf_sock_addr_set_sun_path kernel function that allows modifying the path of a Unix socket address.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/bpf_sock_addr_set_sun_path.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nint bpf_sock_addr_set_sun_path(struct bpf_sock_addr_kern *sa_kern, const u8 *sun_path, u32 sun_path__sz)\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_map__set_inner_map_fd with Parameters in Libbpf (C)\nDESCRIPTION: This snippet provides the function signature for 'bpf_map__set_inner_map_fd', which is used in userspace to specify the file descriptor of an inner map to an outer eBPF map, enabling map-in-map constructs (such as arrays or hashes of maps). The function requires the outer map pointer and the file descriptor of the preloaded inner map as arguments and returns 0 on success or a negative error code on failure. There are no direct dependencies except for libbpf and eBPF-enabled Linux, with inputs being a valid struct bpf_map pointer and an integer file descriptor.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_map__set_inner_map_fd.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nint bpf_map__set_inner_map_fd(struct bpf_map *map, int fd);\n```\n\n----------------------------------------\n\nTITLE: Defining struct btf_dump_emit_type_decl_opts in C\nDESCRIPTION: Definition of the structure that provides options for the btf_dump__emit_type_decl function, including fields for customizing the output format of type declarations.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/btf_dump__emit_type_decl.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstruct btf_dump_emit_type_decl_opts {\n\t/* size of this struct, for forward/backward compatibility */\n\tsize_t sz;\n\tconst char *field_name;\n\tint indent_level;\n\tbool strip_mods;\n\tsize_t :0;\n};\n```\n\n----------------------------------------\n\nTITLE: Definition of libbpf_strerror function in C\nDESCRIPTION: This is the function signature for libbpf_strerror which converts an error code into a human-readable string. It takes an error code, a buffer to store the resulting string, and the size of that buffer as parameters.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/libbpf_strerror.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nint libbpf_strerror(int err, char *buf, size_t size)\n```\n\n----------------------------------------\n\nTITLE: Definition of __noinline Macro in C\nDESCRIPTION: The basic definition of the __noinline macro which uses the GCC/Clang noinline attribute to prevent function inlining.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/ebpf/__noinline.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n#define __noinline __attribute__((noinline))\n```\n\n----------------------------------------\n\nTITLE: Defining btf__add_float function in C\nDESCRIPTION: Function definition for btf__add_float, which appends a new BTF_KIND_FLOAT type to a BTF object. It takes a BTF object pointer, type name, and byte size as parameters, returning the new type ID or an error code.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/btf__add_float.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nint btf__add_float(struct btf *btf, const char *name, size_t byte_sz);\n```\n\n----------------------------------------\n\nTITLE: Bounded Loop with Limited Range in eBPF\nDESCRIPTION: Demonstrates a fix for the verifier complexity issue by limiting the loop range to a manageable size. This approach reduces the number of states the verifier must check while preserving functionality.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/concepts/loops.md#2025-04-22_snippet_2\n\nLANGUAGE: c\nCODE:\n```\nvoid *data = ctx->data;\nvoid *data_end = ctx->data_end;\nstruct iphdr *ip = data + sizeof(struct ethhdr);\nif (ip + sizeof(struct iphdr) > data_end)\n    return XDP_DROP;\n\nif (ip + sizeof(struct iphdr) > data_end)\n    return XDP_DROP;\n\nint max = ip->tot_len;\nif (max > 100)\n    max = 100;\n\nfor (int i = 0; i < max; i++) {\n    // scan IP body for something\n}\n```\n\n----------------------------------------\n\nTITLE: Definition of btf__add_volatile function in libbpf\nDESCRIPTION: Function signature for btf__add_volatile which appends a new BTF_KIND_VOLATILE type to a BTF object. It takes a pointer to a struct btf object and a reference type ID, returning the new type ID on success or a negative value on error.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/btf__add_volatile.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nint btf__add_volatile(struct btf *btf, int ref_type_id);\n```\n\n----------------------------------------\n\nTITLE: BTF Parse Raw Split Function Definition\nDESCRIPTION: C function declaration for btf__parse_raw_split that takes a file path and base BTF object as parameters and returns a pointer to a new BTF structure. The function parses raw BTF data from a file using a base BTF object as reference.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/btf__parse_raw_split.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstruct btf *btf__parse_raw_split(const char *path, struct btf *base_btf);\n```\n\n----------------------------------------\n\nTITLE: Defining scx_bpf_task_running Kernel Function in C\nDESCRIPTION: This snippet declares the scx_bpf_task_running function in C, which checks if a specific task is currently running in the kernel context. The function accepts a pointer to a task_struct and returns a boolean indicating the running state of that task. To use this function, the environment must support the specified program types (such as BPF_PROG_TYPE_LSM, TRACEPOINT, etc.) and be running Linux kernel version v6.12 or later; this is intended for use within eBPF-enabled code and relies on kernel-provided types and build context.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/scx_bpf_task_running.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n#!c bool scx_bpf_task_running(const struct task_struct *p)\n```\n\n----------------------------------------\n\nTITLE: Function Definition for bpf_map_update_batch in C\nDESCRIPTION: Defines the function signature for bpf_map_update_batch, which updates multiple elements in a BPF map. Takes file descriptor, key array, value array, count pointer, and options structure as parameters. Returns 0 on success or negative error code on failure.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_map_update_batch.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nint bpf_map_update_batch(int fd, const void *keys, const void *values, __u32 *count, const struct bpf_map_batch_opts *opts);\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_task_fd_query function in C\nDESCRIPTION: This code snippet defines the bpf_task_fd_query function, which is a low-level wrapper for the BPF_TASK_FD_QUERY syscall command. It takes multiple parameters including pid, fd, flags, and pointers for various output values.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_task_fd_query.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nint bpf_task_fd_query(int pid, int fd, __u32 flags, char *buf, __u32 *buf_len, __u32 *prog_id, __u32 *fd_type, __u64 *probe_offset, __u64 *probe_addr);\n```\n\n----------------------------------------\n\nTITLE: Definition of ring__map_fd function in C\nDESCRIPTION: This C function definition shows the signature of the ring__map_fd function, which takes a ring buffer object as input and returns the underlying file descriptor as an integer.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/ring__map_fd.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nint ring__map_fd(const struct ring *r);\n```\n\n----------------------------------------\n\nTITLE: Task Exit Callback Definition in C\nDESCRIPTION: Callback function signature for cleaning up a task that is exiting BPF scheduling. Takes task struct and exit arguments as parameters.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/program-type/BPF_PROG_TYPE_STRUCT_OPS/sched_ext_ops.md#2025-04-22_snippet_24\n\nLANGUAGE: c\nCODE:\n```\nvoid (*exit_task)(struct task_struct *p, struct scx_exit_task_args *args);\n```\n\n----------------------------------------\n\nTITLE: KFunc Definition for bpf_rdonly_cast in C\nDESCRIPTION: Function signature for the bpf_rdonly_cast kernel function that allows casting objects to specified BTF types.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/bpf_rdonly_cast.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nvoid *bpf_rdonly_cast(const void *obj__ign, u32 btf_id__k)\n```\n\n----------------------------------------\n\nTITLE: Function Definition - scx_bpf_dispatch_from_dsq_set_vtime\nDESCRIPTION: Kernel function definition that takes a struct bpf_iter_scx_dsq pointer and a u64 vtime parameter. This function was introduced in kernel v6.12 and renamed in v6.13, but remains aliased until v6.15.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/scx_bpf_dispatch_from_dsq_set_vtime.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nvoid scx_bpf_dispatch_from_dsq_set_vtime(struct bpf_iter_scx_dsq *it__iter, u64 vtime)\n```\n\n----------------------------------------\n\nTITLE: Using xdp_program__open_file function in C for loading XDP programs\nDESCRIPTION: This function opens an XDP program from a file at the specified section name. It returns a pointer to the xdp_program structure on success or a negative error code on failure. Optional BPF object open options can be provided.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libxdp/functions/xdp_program__open_file.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstruct xdp_program *xdp_program__open_file(const char *filename, const char *section_name, struct bpf_object_open_opts *opts);\n```\n\n----------------------------------------\n\nTITLE: Setting Autocreate for BPF Map in Libbpf C\nDESCRIPTION: The snippet demonstrates the usage of the 'bpf_map__set_autocreate' function in C, which enables or disables the auto-creation of BPF maps during the object loading phase in the Libbpf library. Dependencies include the Libbpf library. The function takes two parameters: a 'struct bpf_map *map', representing the BPF map instance, and a 'bool autocreate', indicating whether the map should be auto-created. It returns 0 on success or '-EBUSY' if the BPF object was already loaded. This function is useful when the user wants to manually manage map creation, particularly in cases where the kernel does not support certain map types.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_map__set_autocreate.md#2025-04-22_snippet_0\n\nLANGUAGE: C\nCODE:\n```\n#!c int bpf_map__set_autocreate(struct bpf_map *map, bool autocreate);\n```\n\n----------------------------------------\n\nTITLE: Definition of bpf_get_kmem_cache KFunc in C\nDESCRIPTION: The function signature for the bpf_get_kmem_cache kernel function, which returns slab cache information from a virtual address.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/bpf_get_kmem_cache.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstruct kmem_cache *bpf_get_kmem_cache(u64 addr)\n```\n\n----------------------------------------\n\nTITLE: Loading BTF Object from Kernel by ID with Base BTF in C\nDESCRIPTION: Definition of the btf__load_from_kernel_by_id_split function that loads a BTF object from the kernel by its ID using a base BTF object. It returns a pointer to a struct btf object on success or NULL on failure.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/btf__load_from_kernel_by_id_split.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstruct btf *btf__load_from_kernel_by_id_split(__u32 id, struct btf *base_btf);\n```\n\n----------------------------------------\n\nTITLE: Defining the bpf_cpumask_release kfunc signature in C\nDESCRIPTION: This C code snippet presents the function signature for the `bpf_cpumask_release` eBPF kfunc. It takes a single argument, `cpumask`, which is a pointer to a `struct bpf_cpumask`. The function returns `void`. Its purpose is to release the reference associated with the provided `cpumask` pointer. When the final reference is released, the underlying memory is freed using an RCU callback. Importantly, the pointer passed to this function is invalidated upon its execution.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/bpf_cpumask_release.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n`#!c void bpf_cpumask_release(struct bpf_cpumask *cpumask)`\n```\n\n----------------------------------------\n\nTITLE: Defining 'unlikely' macro for eBPF optimization in C\nDESCRIPTION: This snippet defines the 'unlikely' macro using the __builtin_expect function. It's used to hint to the compiler that an expression is unlikely to be true, potentially optimizing the generated code.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/scx/unlikely.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n#define unlikely(x) __builtin_expect(!!(x), 0)\n```\n\n----------------------------------------\n\nTITLE: Declaring bpf_arena_alloc_pages kfunc in eBPF C\nDESCRIPTION: This snippet declares the 'bpf_arena_alloc_pages' kernel function available to eBPF programs, allowing allocation of one or more pages in a BPF ARENA map. Dependencies include a recent Linux kernel supporting this kfunc, an appropriate BPF MAP_TYPE_ARENA map, and usage in a sleepable BPF program. Parameters: 'p__map' - pointer to the arena map, 'addr__ign' - target (must be page-aligned), 'page_cnt' - number of pages, 'node_id' - NUMA node, 'flags' - reserved. On success, returns a pointer to the allocated memory; otherwise returns NULL. Only callable from specific, sleepable eBPF program types, as listed in the documentation.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/bpf_arena_alloc_pages.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n#!c void *bpf_arena_alloc_pages(void *p__map, void *addr__ign, u32 page_cnt, int node_id, u64 flags)\n```\n\n----------------------------------------\n\nTITLE: Defining BTF Extension Endianness Function\nDESCRIPTION: Function definition for setting endianness of BTF extension objects. Takes a btf_ext pointer and endianness enum as parameters, returns 0 on success or negative error code on failure.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/btf_ext__set_endianness.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nint btf_ext__set_endianness(struct btf_ext *btf_ext, enum btf_endianness endian);\n```\n\n----------------------------------------\n\nTITLE: Defining the __arg_trusted Macro in C for eBPF Programs\nDESCRIPTION: The definition of the __arg_trusted macro which uses the btf_decl_tag attribute to mark arguments as trusted pointers to kernel memory.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/ebpf/__arg_trusted.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n#define __arg_trusted __attribute((btf_decl_tag(\"arg:trusted\")))\n```\n\n----------------------------------------\n\nTITLE: Defining scx_bpf_dispatch_vtime KFunc in C\nDESCRIPTION: Function signature for the scx_bpf_dispatch_vtime eBPF kfunc. It takes a task_struct pointer, dispatch queue ID, time slice, virtual time, and enqueue flags as parameters.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/scx_bpf_dispatch_vtime.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nvoid scx_bpf_dispatch_vtime(struct task_struct *p, u64 dsq_id, u64 slice, u64 vtime, u64 enq_flags)\n```\n\n----------------------------------------\n\nTITLE: Using the bpf_repeat Macro in eBPF\nDESCRIPTION: Shows how to use the bpf_repeat macro for simple repetition of a block of code a specific number of times. This provides a clean syntax for fixed-count iteration.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/concepts/loops.md#2025-04-22_snippet_5\n\nLANGUAGE: c\nCODE:\n```\nint i = 0;\nbpf_repeat(5) {\n    bpf_printk(\"X = %d\", i);\n    i++;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining dctcp_cwnd_event KFunc in C\nDESCRIPTION: Function signature for the dctcp_cwnd_event kernel function that handles TCP congestion window events. Takes a sock structure pointer and tcp_ca_event as parameters.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/dctcp_cwnd_event.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nvoid dctcp_cwnd_event(struct sock *sk, tcp_ca_event ev)\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_map_peek_elem Helper Function in C\nDESCRIPTION: Function definition for the bpf_map_peek_elem helper that retrieves an element from a map without removing it. Takes a map pointer and value pointer as parameters and returns a long integer status code.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_map_peek_elem.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstatic long (* const bpf_map_peek_elem)(void *map, void *value) = (void *) 89;\n```\n\n----------------------------------------\n\nTITLE: Retrieving XDP Program from File Descriptor in C\nDESCRIPTION: Function declaration showing how to retrieve an XDP program structure from a file descriptor. Returns a struct xdp_program on success or negative error code on failure. Error code -ENOENT indicates file not found.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libxdp/functions/xdp_program__from_fd.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstruct xdp_program *xdp_program__from_fd(int fd);\n```\n\n----------------------------------------\n\nTITLE: Processing and Parsing Packet Trailers in TC eBPF Program in C\nDESCRIPTION: This snippet implements a TC (traffic control) eBPF program for parsing packets and extracting a trailer field from UDP packets destined to a target port. It demonstrates packet data boundary checks, calculation of trailer offset, and optionally logging trailer values via bpf_printk. It depends on kernel headers and eBPF helpers; expected parameters are a struct __sk_buff pointer (skb). Outputs are TC action codes signalling whether the packet is OK or should be dropped. Limitations include omitted UDP parsing for brevity and assumed correct buffer offsets.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_xdp_adjust_tail.md#2025-04-22_snippet_1\n\nLANGUAGE: C\nCODE:\n```\nSEC(\"tc\")\nint tc_test_adjust_tail(struct __sk_buff *skb)\n{\n\tvoid *data;\n\tvoid *data_end;\n\n\tif (bpf_skb_pull_data(skb, skb->len) < 0) {\n\t\treturn TC_ACT_SHOT;\n\t}\n\n\tdata = (void *)(unsigned long)skb->data;\n\tdata_end = (void *)(unsigned long)skb->data_end;\n\n\t/* packet parsing to check if this is a valid UDP packet for the\n\t * TARGET_PORT is omitted for brevity\n\t */\n\n\t/* get trailer from packet destined to TARGET_PORT */\n\tu16 len = data_end - data;\n\tif ((data + len) > data_end)\n\t\treturn TC_ACT_SHOT;\n\n\t/*  0x3fff - largest value for a packet size that allows 9K jumbo */\n\tu16 offset = (len - sizeof(trailer)) & 0x3fff;\n\n\tu32 *trailer_start = (u32 *)(data + offset);\n\tif ((trailer_start + 1) > (u32 *)data_end)\n\t\treturn TC_ACT_SHOT;\n\n\tif (*trailer_start & 0xffffff00)\n\t\tbpf_printk(\"Packet was received on XDP RX queue %d\\n\",\n\t\t   (*trailer_start) & 0x000000ff);\n\n\treturn TC_ACT_OK;\n}\n```\n\n----------------------------------------\n\nTITLE: Testing Dynamic Pointer Adjustment Error Handling\nDESCRIPTION: Tests error conditions when adjusting dynamic pointers, including invalid range parameters and writing beyond available size. Also verifies that an adjusted dynptr can still be properly submitted or discarded.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/concepts/dynptrs.md#2025-04-22_snippet_6\n\nLANGUAGE: c\nCODE:\n```\nSEC(\"tp/syscalls/sys_enter_nanosleep\")\nint test_adjust_err(void *ctx)\n{\n\tchar write_data[45] = \"hello there, world!!\";\n\tstruct bpf_dynptr ptr;\n\t__u32 size = 64;\n\t__u32 off = 20;\n\n\tif (bpf_get_current_pid_tgid() >> 32 != pid)\n\t\treturn 0;\n\n\tif (bpf_ringbuf_reserve_dynptr(&ringbuf, size, 0, &ptr)) {\n\t\terr = 1;\n\t\tgoto done;\n\t}\n\n\t/* Check that start can't be greater than end */\n\tif (bpf_dynptr_adjust(&ptr, 5, 1) != -EINVAL) {\n\t\terr = 2;\n\t\tgoto done;\n\t}\n\n\t/* Check that start can't be greater than size */\n\tif (bpf_dynptr_adjust(&ptr, size + 1, size + 1) != -ERANGE) {\n\t\terr = 3;\n\t\tgoto done;\n\t}\n\n\t/* Check that end can't be greater than size */\n\tif (bpf_dynptr_adjust(&ptr, 0, size + 1) != -ERANGE) {\n\t\terr = 4;\n\t\tgoto done;\n\t}\n\n\tif (bpf_dynptr_adjust(&ptr, off, size)) {\n\t\terr = 5;\n\t\tgoto done;\n\t}\n\n\t/* Check that you can't write more bytes than available into the dynptr\n\t * after you've adjusted it\n\t */\n\tif (bpf_dynptr_write(&ptr, 0, &write_data, sizeof(write_data), 0) != -E2BIG) {\n\t\terr = 6;\n\t\tgoto done;\n\t}\n\n\t/* Check that even after adjusting, submitting/discarding\n\t * a ringbuf dynptr works\n\t */\n\tbpf_ringbuf_submit_dynptr(&ptr, 0);\n\treturn 0;\n\n\tdone:\n\tbpf_ringbuf_discard_dynptr(&ptr, 0);\n\treturn 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Using PT_REGS_RC macro in eBPF programs\nDESCRIPTION: The PT_REGS_RC macro is used to extract return values from struct pt_regs in an architecture-independent way. It is typically used with kretprobes where the architecture is determined by compiler flags like -D__TARGET_ARCH_x86.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/ebpf/PT_REGS_RC.md#2025-04-22_snippet_0\n\nLANGUAGE: C\nCODE:\n```\nPT_REGS_RC\n```\n\n----------------------------------------\n\nTITLE: Defining Array Properties with __array Macro in eBPF Maps\nDESCRIPTION: This example demonstrates how to use the __array macro to define array properties in BTF map definitions. The code creates inner maps and an outer hash map that references them, showcasing the map-in-map functionality. The highlighted lines show the __array declaration and the initialization of the values array with references to the inner maps.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/ebpf/__array.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstruct inner_map {\n        __uint(type, BPF_MAP_TYPE_ARRAY);\n        __uint(max_entries, 1);\n        __type(key, int);\n        __type(value, int);\n} inner_map1 SEC(\".maps\"),\ninner_map2 SEC(\".maps\");\n\nstruct outer_hash {\n        __uint(type, BPF_MAP_TYPE_HASH_OF_MAPS);\n        __uint(max_entries, 5);\n        __uint(key_size, sizeof(int));\n        __array(values, struct inner_map);\n} outer_hash SEC(\".maps\") = {\n        .values = {\n                [0] = &inner_map2,\n                [4] = &inner_map1,\n        },\n};\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_program__flags function in C\nDESCRIPTION: This snippet shows the C function definition for bpf_program__flags. It takes a const struct bpf_program pointer as input and returns a 32-bit unsigned integer representing the program flags.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_program__flags.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n__u32 bpf_program__flags(const struct bpf_program *prog);\n```\n\n----------------------------------------\n\nTITLE: Defining LPM Trie Key Structure in C\nDESCRIPTION: Example structure definition for an LPM Trie key from the bpf.h header file, showing the required prefixlen field and variable-sized data array.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/map-type/BPF_MAP_TYPE_LPM_TRIE.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstruct bpf_lpm_trie_key {\n\t__u32\tprefixlen;\t/* up to 32 for AF_INET, 128 for AF_INET6 */\n\t__u8\tdata[0];\t/* Arbitrary size */\n};\n```\n\n----------------------------------------\n\nTITLE: Defining scx_bpf_pick_idle_cpu KFunc in C\nDESCRIPTION: Function signature for the scx_bpf_pick_idle_cpu kfunc. It takes a cpumask pointer and flags as parameters, and returns an s32 value representing the picked idle CPU number or an error code.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/scx_bpf_pick_idle_cpu.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\ns32 scx_bpf_pick_idle_cpu(const struct cpumask *cpus_allowed, u64 flags)\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_obj_get Function in C\nDESCRIPTION: Function definition for bpf_obj_get that takes a pathname parameter and returns a file descriptor or negative error code. This is a low-level wrapper around the BPF_OBJ_GET syscall command and should only be used when precise control over object retrieval is needed.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_obj_get.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nint bpf_obj_get(const char *pathname);\n```\n\n----------------------------------------\n\nTITLE: Defining KFunc 'tcp_reno_undo_cwnd' Signature in C\nDESCRIPTION: This C code snippet defines the function signature for the eBPF kfunc 'tcp_reno_undo_cwnd'. It shows that the function takes a pointer to a 'struct sock' (representing a socket) as input and returns a 'u32' (unsigned 32-bit integer), which is the new congestion window value after a loss event according to the Reno algorithm. This function is intended to be called from eBPF programs of type BPF_PROG_TYPE_STRUCT_OPS.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/tcp_reno_undo_cwnd.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n`#!c u32 tcp_reno_undo_cwnd(struct sock *sk)`\n```\n\n----------------------------------------\n\nTITLE: Creating Empty Split BTF Object in C\nDESCRIPTION: Function signature for creating an unpopulated BTF object based on a base BTF. The function returns a new BTF object instance that must be freed with btf__free() when no longer needed.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/btf__new_empty_split.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstruct btf *btf__new_empty_split(struct btf *base_btf);\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_jiffies64 Helper Function in C\nDESCRIPTION: Function definition for the bpf_jiffies64 helper that retrieves the current jiffies count as a 64-bit value.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_jiffies64.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstatic __u64 (* const bpf_jiffies64)(void) = (void *) 118;\n```\n\n----------------------------------------\n\nTITLE: Defining btf__new_empty function in C\nDESCRIPTION: Function signature for btf__new_empty, which creates an empty BTF object. It returns a pointer to the new BTF object or an error code encoded as a pointer. The returned object must be freed using btf__free() when no longer needed.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/btf__new_empty.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstruct btf *btf__new_empty(void);\n```\n\n----------------------------------------\n\nTITLE: Defining libbpf_prog_prepare_load_fn_t callback in C\nDESCRIPTION: Definition of the function pointer type for the BPF program loading callback. This callback is called right before libbpf performs bpf_prog_load to load the BPF program into the kernel.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/struct-libbpf_prog_handler_opts.md#2025-04-22_snippet_2\n\nLANGUAGE: c\nCODE:\n```\ntypedef int (*libbpf_prog_prepare_load_fn_t)(struct bpf_program *prog,\n\t\t\t\t\t     struct bpf_prog_load_opts *opts, long cookie);\n```\n\n----------------------------------------\n\nTITLE: Finalizing BPF Linker Output with Libbpf (C)\nDESCRIPTION: This snippet presents the prototype for the bpf_linker__finalize function used in Libbpf, a userspace library for working with BPF programs. Its purpose is to complete the BPF object linking process and write the resulting ELF file, as previously specified when constructing the linker object. The only parameter is a pointer to a bpf_linker structure. On success, it returns 0; on failure, it returns a negative error code and sets errno. Requires linking against libbpf and definition of struct bpf_linker.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_linker__finalize.md#2025-04-22_snippet_0\n\nLANGUAGE: C\nCODE:\n```\nint bpf_linker__finalize(struct bpf_linker *linker);\n```\n\n----------------------------------------\n\nTITLE: Defining scx_bpf_put_idle_cpumask KFunc in C\nDESCRIPTION: This code snippet defines the signature of the scx_bpf_put_idle_cpumask kfunc. It takes a const struct cpumask pointer as an argument and returns void. The function releases the pointer passed to it, invalidating all copies of the pointer.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/scx_bpf_put_idle_cpumask.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nvoid scx_bpf_put_idle_cpumask(const struct cpumask *idle_mask)\n```\n\n----------------------------------------\n\nTITLE: Function Definition - bpf_iter_task_destroy\nDESCRIPTION: The kernel function signature for bpf_iter_task_destroy which takes a task iterator pointer as input and destroys it. This function has void return type.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/bpf_iter_task_destroy.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nvoid bpf_iter_task_destroy(struct bpf_iter_task *it)\n```\n\n----------------------------------------\n\nTITLE: Listing Supported eBPF KFuncs for LWT Programs\nDESCRIPTION: This Markdown snippet lists the eBPF kfuncs (kernel functions callable from eBPF) available for use within Lightweight Tunnel (LWT) programs. Each kfunc name links to its specific documentation page. The list is structured within an expandable 'abstract' block for conciseness.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/program-type/BPF_PROG_TYPE_LWT_IN.md#2025-04-22_snippet_2\n\nLANGUAGE: markdown\nCODE:\n```\n<!-- [PROG_KFUNC_REF] -->\n??? abstract \"Supported kfuncs\"\n    - [`bpf_arena_alloc_pages`](../kfuncs/bpf_arena_alloc_pages.md)\n    - [`bpf_arena_free_pages`](../kfuncs/bpf_arena_free_pages.md)\n    - [`bpf_cast_to_kern_ctx`](../kfuncs/bpf_cast_to_kern_ctx.md)\n    - [`bpf_copy_from_user_str`](../kfuncs/bpf_copy_from_user_str.md)\n    - [`bpf_dynptr_adjust`](../kfuncs/bpf_dynptr_adjust.md)\n    - [`bpf_dynptr_clone`](../kfuncs/bpf_dynptr_clone.md)\n    - [`bpf_dynptr_from_skb`](../kfuncs/bpf_dynptr_from_skb.md)\n    - [`bpf_dynptr_is_null`](../kfuncs/bpf_dynptr_is_null.md)\n    - [`bpf_dynptr_is_rdonly`](../kfuncs/bpf_dynptr_is_rdonly.md)\n    - [`bpf_dynptr_size`](../kfuncs/bpf_dynptr_size.md)\n    - [`bpf_dynptr_slice`](../kfuncs/bpf_dynptr_slice.md)\n    - [`bpf_dynptr_slice_rdwr`](../kfuncs/bpf_dynptr_slice_rdwr.md)\n    - [`bpf_get_kmem_cache`](../kfuncs/bpf_get_kmem_cache.md)\n    - [`bpf_iter_bits_destroy`](../kfuncs/bpf_iter_bits_destroy.md)\n    - [`bpf_iter_bits_new`](../kfuncs/bpf_iter_bits_new.md)\n    - [`bpf_iter_bits_next`](../kfuncs/bpf_iter_bits_next.md)\n    - [`bpf_iter_css_destroy`](../kfuncs/bpf_iter_css_destroy.md)\n    - [`bpf_iter_css_new`](../kfuncs/bpf_iter_css_new.md)\n    - [`bpf_iter_css_next`](../kfuncs/bpf_iter_css_next.md)\n    - [`bpf_iter_css_task_destroy`](../kfuncs/bpf_iter_css_task_destroy.md)\n    - [`bpf_iter_css_task_new`](../kfuncs/bpf_iter_css_task_new.md)\n    - [`bpf_iter_css_task_next`](../kfuncs/bpf_iter_css_task_next.md)\n    - [`bpf_iter_kmem_cache_destroy`](../kfuncs/bpf_iter_kmem_cache_destroy.md)\n    - [`bpf_iter_kmem_cache_new`](../kfuncs/bpf_iter_kmem_cache_new.md)\n    - [`bpf_iter_kmem_cache_next`](../kfuncs/bpf_iter_kmem_cache_next.md)\n    - [`bpf_iter_num_destroy`](../kfuncs/bpf_iter_num_destroy.md)\n    - [`bpf_iter_num_new`](../kfuncs/bpf_iter_num_new.md)\n    - [`bpf_iter_num_next`](../kfuncs/bpf_iter_num_next.md)\n    - [`bpf_iter_task_destroy`](../kfuncs/bpf_iter_task_destroy.md)\n    - [`bpf_iter_task_new`](../kfuncs/bpf_iter_task_new.md)\n    - [`bpf_iter_task_next`](../kfuncs/bpf_iter_task_next.md)\n    - [`bpf_iter_task_vma_destroy`](../kfuncs/bpf_iter_task_vma_destroy.md)\n    - [`bpf_iter_task_vma_new`](../kfuncs/bpf_iter_task_vma_new.md)\n    - [`bpf_iter_task_vma_next`](../kfuncs/bpf_iter_task_vma_next.md)\n    - [`bpf_local_irq_restore`](../kfuncs/bpf_local_irq_restore.md)\n    - [`bpf_local_irq_save`](../kfuncs/bpf_local_irq_save.md)\n    - [`bpf_map_sum_elem_count`](../kfuncs/bpf_map_sum_elem_count.md)\n    - [`bpf_preempt_disable`](../kfuncs/bpf_preempt_disable.md)\n    - [`bpf_preempt_enable`](../kfuncs/bpf_preempt_enable.md)\n    - [`bpf_rcu_read_lock`](../kfuncs/bpf_rcu_read_lock.md)\n    - [`bpf_rcu_read_unlock`](../kfuncs/bpf_rcu_read_unlock.md)\n    - [`bpf_rdonly_cast`](../kfuncs/bpf_rdonly_cast.md)\n    - [`bpf_wq_init`](../kfuncs/bpf_wq_init.md)\n    - [`bpf_wq_set_callback_impl`](../kfuncs/bpf_wq_set_callback_impl.md)\n    - [`bpf_wq_start`](../kfuncs/bpf_wq_start.md)\n<!-- [/PROG_KFUNC_REF] -->\n```\n\n----------------------------------------\n\nTITLE: Defining btf_endianness enum in C\nDESCRIPTION: Enum definition for specifying endianness options in BTF. It defines constants for little endian (0) and big endian (1).\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/btf__set_endianness.md#2025-04-22_snippet_1\n\nLANGUAGE: c\nCODE:\n```\nenum btf_endianness {\n\tBTF_LITTLE_ENDIAN = 0,\n\tBTF_BIG_ENDIAN = 1,\n};\n```\n\n----------------------------------------\n\nTITLE: Mapping Perf Event Ring Buffer with mmap in C\nDESCRIPTION: This inline C comment shows the syntax for calling the `mmap` system call to map the shared memory region associated with a perf event ring buffer into the userspace process's address space. It requires the file descriptor (`fd`) obtained from `perf_event_open`. The `length` parameter must be `1+2^n` pages (where n > 0), and the memory must be mapped with read and write permissions (`PROT_READ|PROT_WRITE`) and shared (`MAP_SHARED`).\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/map-type/BPF_MAP_TYPE_PERF_EVENT_ARRAY.md#2025-04-22_snippet_1\n\nLANGUAGE: c\nCODE:\n```\nmmap(nil, length, PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0)\n```\n\n----------------------------------------\n\nTITLE: Usage Example of MEMBER_VPTR Macro\nDESCRIPTION: A basic usage example of the MEMBER_VPTR macro in eBPF programs. This demonstrates the pattern of checking for NULL and immediately dereferencing to satisfy the eBPF verifier.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/scx/MEMBER_VPTR.md#2025-04-22_snippet_1\n\nLANGUAGE: c\nCODE:\n```\nvptr = MEMBER_VPTR(my_array, [i][j]);\nif (!vptr)\n    return error;\n*vptr = new_value;\n```\n\n----------------------------------------\n\nTITLE: Defining the bpf_core_type_id_kernel Macro in C\nDESCRIPTION: This C code defines the 'bpf_core_type_id_kernel' macro using the '__builtin_btf_type_id' compiler builtin. It takes a local type as input ('type') and resolves its corresponding target kernel BTF type ID using 'BPF_TYPE_ID_TARGET'. The result is determined by the loader library (like libbpf) at load time and treated as a constant by the verifier.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/ebpf/bpf_core_type_id_kernel.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n#define bpf_core_type_id_kernel(type)\t\t\t\t\t    \\\n\t__builtin_btf_type_id(*___bpf_typeof(type), BPF_TYPE_ID_TARGET)\n```\n\n----------------------------------------\n\nTITLE: Defining scx_bpf_kick_cpu KFunc in C\nDESCRIPTION: Function signature for the scx_bpf_kick_cpu kfunc, which triggers reschedule on a specified CPU with given flags.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/scx_bpf_kick_cpu.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nvoid scx_bpf_kick_cpu(s32 cpu, u64 flags)\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_arena_free_pages Kernel Helper in C\nDESCRIPTION: Declares the C function signature for the bpf_arena_free_pages kernel function, enabling developers to release one or more pages of memory from a BPF_ARENA map. Requires eBPF program support in the kernel (v6.9 or later) and is intended for use exclusively in sleepable BPF programs. Parameters include a pointer to a BPF_ARENA map (p__map), a page-aligned address to free (ptr__ign), and the number of pages to release (page_cnt, u32). The function may sleep, so it must be used in appropriate program types as documented. Input is a pointer to the map, the start address, and page count; there is no return value. Improper use outside of sleepable contexts or misaligned addresses may cause undefined behavior.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/bpf_arena_free_pages.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n#!c void bpf_arena_free_pages(void *p__map, void *ptr__ign, u32 page_cnt)\n```\n\n----------------------------------------\n\nTITLE: Defining libbpf_set_print function in C\nDESCRIPTION: This code snippet shows the definition of the libbpf_set_print function and its associated type definition. The function allows setting a custom print callback function for libbpf logging, and returns a pointer to the previous print function.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/libbpf_set_print.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\ntypedef int (*libbpf_print_fn_t)(enum libbpf_print_level level, const char *, va_list ap);\n\nlibbpf_print_fn_t libbpf_set_print(libbpf_print_fn_t fn);\n```\n\n----------------------------------------\n\nTITLE: Definition of bpf_preempt_disable KFunc in C\nDESCRIPTION: Function signature for the bpf_preempt_disable kernel function that disables preemption in eBPF programs. This function takes no parameters and returns no value.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/bpf_preempt_disable.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nvoid bpf_preempt_disable()\n```\n\n----------------------------------------\n\nTITLE: KFunc Definition - bpf_xdp_metadata_rx_hash\nDESCRIPTION: Function signature for the bpf_xdp_metadata_rx_hash kernel function. Takes XDP metadata context, hash pointer, and RSS hash type pointer as parameters. Returns an integer status code.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/bpf_xdp_metadata_rx_hash.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nint bpf_xdp_metadata_rx_hash(const struct xdp_md *ctx, u32 *hash, xdp_rss_hash_type *rss_type)\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_percpu_obj_drop_impl KFunc in C\nDESCRIPTION: Function signature for the bpf_percpu_obj_drop_impl kfunc. This function frees an allocated per-CPU object and handles destruction of object fields. The meta parameter is automatically handled by the verifier.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/bpf_percpu_obj_drop_impl.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nvoid bpf_percpu_obj_drop_impl(void *p__alloc, void *meta__ign)\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_lwt_push_encap Helper Function in C\nDESCRIPTION: This code snippet defines the bpf_lwt_push_encap helper function, which is used to encapsulate packets within Layer 3 protocol headers. It specifies the function signature, including parameters for the skb (socket buffer), encapsulation type, header, and length.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_lwt_push_encap.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstatic long (* const bpf_lwt_push_encap)(struct __sk_buff *skb, __u32 type, void *hdr, __u32 len) = (void *) 73;\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_prog_attach_opts function in C\nDESCRIPTION: Function signature for bpf_prog_attach_opts, which attaches a BPF program to a target. It takes parameters for program file descriptor, target, attach type, and options.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_prog_attach_opts.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nint bpf_prog_attach_opts(int prog_fd, int target, enum bpf_attach_type type, const struct bpf_prog_attach_opts *opts);\n```\n\n----------------------------------------\n\nTITLE: Defining the bpf_obj_new macro in C\nDESCRIPTION: Definition of the bpf_obj_new macro that wraps bpf_obj_new_impl to provide a more ergonomic interface for allocating objects of a custom type in kernel memory.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/scx/bpf_obj_new.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n#define bpf_obj_new(type) ((type *)[bpf_obj_new_impl](../../linux/kfuncs/bpf_obj_new_impl.md)([bpf_core_type_id_local](../libbpf/ebpf/bpf_core_type_id_local.md)(type), NULL))\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_printk macro in C\nDESCRIPTION: This snippet shows the short version of the bpf_printk macro definition. It uses the ___bpf_pick_printk helper to select the appropriate printing function based on the number of arguments.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/ebpf/bpf_printk.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n/* Helper macro to print out debug messages */\n#define bpf_printk(fmt, args...) ___bpf_pick_printk(args)(fmt, ##args)\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_program__attach_trace_opts Function in C\nDESCRIPTION: Function signature for attaching a BPF_PROG_TYPE_TRACING program with additional options. It takes a BPF program and trace options as parameters and returns a reference to the newly created BPF link.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_program__attach_trace_opts.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstruct bpf_link * bpf_program__attach_trace_opts(const struct bpf_program *prog, const struct bpf_trace_opts *opts);\n```\n\n----------------------------------------\n\nTITLE: Binding AF_XDP Socket to Network Device in C\nDESCRIPTION: This snippet shows how to associate an AF_XDP socket with a specific network device and queue using the bind() system call.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/concepts/af_xdp.md#2025-04-22_snippet_6\n\nLANGUAGE: c\nCODE:\n```\nstruct sockaddr_xdp {\n\t__u16 sxdp_family;\n\t__u16 sxdp_flags;\n\t__u32 sxdp_ifindex;\n\t__u32 sxdp_queue_id;\n\t__u32 sxdp_shared_umem_fd;\n};\n\nstruct sockaddr_xdp sockaddr = {\n    .sxdp_family = AF_XDP,\n    .sxdp_flags = 0, // see Options, variations, and exceptions\n    .sxdp_ifindex = some_ifindex, // The actual ifindex is dynamically determined, picking is up to the user.\n    .sxdp_queue_id = 0,\n    .sxdp_shared_umem_fd = fd, // see Options, variations, and exceptions\n};\n\nif(!bind(fd, &sockaddr, sizeof(struct sockaddr_xdp)))\n    // handle error\n```\n\n----------------------------------------\n\nTITLE: CPU Online Callback Definition in C\nDESCRIPTION: Callback function signature for handling CPU online events. Takes CPU ID as parameter.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/program-type/BPF_PROG_TYPE_STRUCT_OPS/sched_ext_ops.md#2025-04-22_snippet_36\n\nLANGUAGE: c\nCODE:\n```\nvoid (*cpu_online)(s32 cpu);\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_tc_opts structure in C\nDESCRIPTION: This struct defines the options for the TC qdisc, including program file descriptor, flags, program ID, handle, and priority.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_tc_query.md#2025-04-22_snippet_3\n\nLANGUAGE: c\nCODE:\n```\nstruct bpf_tc_opts {\n\tsize_t sz;\n\tint prog_fd;\n\t__u32 flags;\n\t__u32 prog_id;\n\t__u32 handle;\n\t__u32 priority;\n\tsize_t :0;\n};\n```\n\n----------------------------------------\n\nTITLE: Defining hid_bpf_get_data Kernel Function\nDESCRIPTION: C function definition for the hid_bpf_get_data kfunc that retrieves kernel memory pointer from HID-BPF context at a specified offset. Returns NULL on error or a pointer to __u8 memory on success.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/hid_bpf_get_data.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n__u8 *hid_bpf_get_data(struct hid_bpf_ctx *ctx, unsigned int offset, const size_t rdwr_buf_size)\n```\n\n----------------------------------------\n\nTITLE: Retrieving Raw BTF Extension Data in C using btf_ext__raw_data\nDESCRIPTION: Function signature for btf_ext__raw_data which retrieves the raw data from a BTF extension object. It takes a BTF extension object and a size parameter that will be written to, and returns a const pointer to the raw serialized BTF extension data.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/btf_ext__raw_data.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nconst void *btf_ext__raw_data(const struct btf_ext *btf_ext, __u32 *size);\n```\n\n----------------------------------------\n\nTITLE: Defining struct libbpf_prog_handler_opts in C\nDESCRIPTION: Definition of the libbpf_prog_handler_opts structure, which contains fields for size, cookie, and function pointers for program setup, preparation for loading, and attachment.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/struct-libbpf_prog_handler_opts.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstruct libbpf_prog_handler_opts {\n\tsize_t  sz;\n\tlong    cookie;\n    \n\tlibbpf_prog_setup_fn_t          prog_setup_fn;\n\tlibbpf_prog_prepare_load_fn_t   prog_prepare_load_fn;\n\tlibbpf_prog_attach_fn_t         prog_attach_fn;\n};\n```\n\n----------------------------------------\n\nTITLE: Defining BPF Linker Initialization with Libbpf (C)\nDESCRIPTION: Defines the signature of the bpf_linker__new_fd function in Libbpf, which is used to instantiate a new BPF linker object. Requires linking against the Libbpf library, with parameters for a file descriptor to the object file and an options structure. Returns a pointer to struct bpf_linker on success, or NULL and sets errno on error.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_linker__new_fd.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstruct bpf_linker *bpf_linker__new_fd(int fd, struct bpf_linker_opts *opts);\n```\n\n----------------------------------------\n\nTITLE: KFunc Definition for scx_bpf_dsq_move_set_vtime\nDESCRIPTION: C function signature for the scx_bpf_dsq_move_set_vtime kernel function. Takes a DSQ iterator and vtime value as parameters to override the vtime of the next task being moved.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/scx_bpf_dsq_move_set_vtime.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nvoid scx_bpf_dsq_move_set_vtime(struct bpf_iter_scx_dsq *it__iter, u64 vtime)\n```\n\n----------------------------------------\n\nTITLE: Defining scx_bpf_exit_bstr KFunc in C\nDESCRIPTION: Function signature for the scx_bpf_exit_bstr kernel function. Takes an exit code, format string, data pointer, and data size as parameters to gracefully exit a BPF scheduler with custom error messages.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/scx_bpf_exit_bstr.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nvoid scx_bpf_exit_bstr(s64 exit_code, char *fmt, long long unsigned int *data, u32 data__sz)\n```\n\n----------------------------------------\n\nTITLE: Defining perf_buffer__free function in libbpf\nDESCRIPTION: Function signature for perf_buffer__free that frees all resources associated with a perf buffer. It takes a pointer to a struct perf_buffer object as its only parameter.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/perf_buffer__free.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nvoid perf_buffer__free(struct perf_buffer *pb);\n```\n\n----------------------------------------\n\nTITLE: Implementing MEMBER_VPTR in a CPU Monitoring eBPF Program\nDESCRIPTION: A practical example showing MEMBER_VPTR usage within a larger eBPF program that monitors CPU states. The macro is used to safely access array elements in a buffer used for printing CPU state information.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/scx/MEMBER_VPTR.md#2025-04-22_snippet_2\n\nLANGUAGE: c\nCODE:\n```\n/* SPDX-License-Identifier: GPL-2.0 */\n/* Copyright (c) 2022 Meta Platforms, Inc. and affiliates.\n * Copyright (c) 2022 Tejun Heo <tj@kernel.org>\n * Copyright (c) 2022 David Vernet <dvernet@meta.com>\n */\n\n/*\n * Print out the online and possible CPU map using bpf_printk() as a\n * demonstration of using the cpumask kfuncs and ops.cpu_on/offline().\n */\nstatic void print_cpus(void)\n{\n\tconst struct cpumask *possible, *online;\n\ts32 cpu;\n\tchar buf[128] = \"\", *p;\n\tint idx;\n\n\tpossible = scx_bpf_get_possible_cpumask();\n\tonline = scx_bpf_get_online_cpumask();\n\n\tidx = 0;\n\tbpf_for(cpu, 0, scx_bpf_nr_cpu_ids()) {\n\t\tif (!(p = MEMBER_VPTR(buf, [idx++])))\n\t\t\tbreak;\n\t\tif (bpf_cpumask_test_cpu(cpu, online))\n\t\t\t*p++ = 'O';\n\t\telse if (bpf_cpumask_test_cpu(cpu, possible))\n\t\t\t*p++ = 'X';\n\t\telse\n\t\t\t*p++ = ' ';\n\n\t\tif ((cpu & 7) == 7) {\n\t\t\tif (!(p = MEMBER_VPTR(buf, [idx++])))\n\t\t\t\tbreak;\n\t\t\t*p++ = '|';\n\t\t}\n\t}\n\tbuf[sizeof(buf) - 1] = '\\0';\n\n\tscx_bpf_put_cpumask(online);\n\tscx_bpf_put_cpumask(possible);\n\n\tbpf_printk(\"CPUS: |%s\", buf);\n}\n\nvoid BPF_STRUCT_OPS(qmap_cpu_online, s32 cpu)\n{\n\tbpf_printk(\"CPU %d coming online\", cpu);\n\t/* @cpu is already online at this point */\n\tprint_cpus();\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Perf Event Lost Record Structure in C\nDESCRIPTION: This structure defines a lost record event in the perf event ring buffer, indicating how many samples were lost due to buffer overflow.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/map-type/BPF_MAP_TYPE_PERF_EVENT_ARRAY.md#2025-04-22_snippet_6\n\nLANGUAGE: c\nCODE:\n```\nstruct {\n    struct perf_event_header header;\n    u64    id;\n    u64    lost;\n    struct sample_id sample_id;\n};\n```\n\n----------------------------------------\n\nTITLE: BTF kind constants definition in C\nDESCRIPTION: A list of constant definitions for the different BTF (BPF Type Format) kinds that can be specified when using the function. These constants represent different data types and structures in the BPF type system.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/btf__find_by_name_kind.md#2025-04-22_snippet_1\n\nLANGUAGE: c\nCODE:\n```\n#define BTF_KIND_INT            1       /* Integer      */\n#define BTF_KIND_PTR            2       /* Pointer      */\n#define BTF_KIND_ARRAY          3       /* Array        */\n#define BTF_KIND_STRUCT         4       /* Struct       */\n#define BTF_KIND_UNION          5       /* Union        */\n#define BTF_KIND_ENUM           6       /* Enumeration up to 32-bit values */\n#define BTF_KIND_FWD            7       /* Forward      */\n#define BTF_KIND_TYPEDEF        8       /* Typedef      */\n#define BTF_KIND_VOLATILE       9       /* Volatile     */\n#define BTF_KIND_CONST          10      /* Const        */\n#define BTF_KIND_RESTRICT       11      /* Restrict     */\n#define BTF_KIND_FUNC           12      /* Function     */\n#define BTF_KIND_FUNC_PROTO     13      /* Function Proto       */\n#define BTF_KIND_VAR            14      /* Variable     */\n#define BTF_KIND_DATASEC        15      /* Section      */\n#define BTF_KIND_FLOAT          16      /* Floating point       */\n#define BTF_KIND_DECL_TAG       17      /* Decl Tag     */\n#define BTF_KIND_TYPE_TAG       18      /* Type Tag     */\n#define BTF_KIND_ENUM64         19      /* Enumeration up to 64-bit values */\n```\n\n----------------------------------------\n\nTITLE: Defining the bpf_core_type_exists Macro in C for libbpf\nDESCRIPTION: This snippet shows the C preprocessor definition of the `bpf_core_type_exists` macro. It utilizes the `__builtin_preserve_type_info` compiler builtin along with `___bpf_typeof` to mark the type information for preservation in the eBPF object file, specifically indicating an existence check (`BPF_TYPE_EXISTS`). This allows libbpf at load time to determine if the specified type exists in the target kernel's BTF.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/ebpf/bpf_core_type_exists.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n#define bpf_core_type_exists(type)\\\n\t__builtin_preserve_type_info(*___bpf_typeof(type), BPF_TYPE_EXISTS)\n```\n\n----------------------------------------\n\nTITLE: Definition of btf__add_ptr Function in C\nDESCRIPTION: Function signature for btf__add_ptr which appends a new BTF_KIND_PTR type to a BTF object. It takes a pointer to a struct btf object and a reference type ID. Returns a positive type ID on success or a negative value on error.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/btf__add_ptr.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nint btf__add_ptr(struct btf *btf, int ref_type_id);\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_csum_diff Helper Function in C\nDESCRIPTION: Function prototype for the bpf_csum_diff helper that computes checksum differences between raw buffers. It takes source and destination buffers with their sizes and an optional seed value for cascaded operations.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_csum_diff.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstatic __s64 (* const bpf_csum_diff)(__be32 *from, __u32 from_size, __be32 *to, __u32 to_size, __wsum seed) = (void *) 28;\n```\n\n----------------------------------------\n\nTITLE: Defining the BPF_CORE_WRITE_BITFIELD Macro in C\nDESCRIPTION: This C macro definition implements 'BPF_CORE_WRITE_BITFIELD'. It takes a pointer to a structure 's', a field name 'field' (which must be a bitfield), and the 'new_val' to write. It uses internal libbpf CO-RE relocation helpers ('__CORE_RELO') to determine the byte offset, size, and bit shifts (lshift, rshift) of the bitfield at runtime. It reads the existing value from memory, calculates a mask, clears the old bitfield value, sets the new value shifted appropriately, and writes the result back to memory. The macro supports bitfields spanning 1, 2, 4, or 8 bytes. It requires BPF program types that permit direct memory access.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/ebpf/BPF_CORE_WRITE_BITFIELD.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n#define BPF_CORE_WRITE_BITFIELD(s, field, new_val) ({      \\\n\tvoid *p = (void *)s + __CORE_RELO(s, field, BYTE_OFFSET);\t\\\n\tunsigned int byte_size = __CORE_RELO(s, field, BYTE_SIZE);\t\\\n\tunsigned int lshift = __CORE_RELO(s, field, LSHIFT_U64);\t\\\n\tunsigned int rshift = __CORE_RELO(s, field, RSHIFT_U64);\t\\\n\tunsigned long long mask, val, nval = new_val;\t\t\t\\\n\tunsigned int rpad = rshift - lshift;\t\t\t\t\\\n\t\t\t\t\t\t\t\t\\\n\tasm volatile(\"\" : \"+r\"(p));\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\\\n\tswitch (byte_size) {\t\t\t\t\t\\\n\tcase 1: val = *(unsigned char *)p; break;\t\t\t\\\n\tcase 2: val = *(unsigned short *)p; break;\t\t\t\\\n\tcase 4: val = *(unsigned int *)p; break;\t\t\t\\\n\tcase 8: val = *(unsigned long long *)p; break;\t\t\t\\\n\t}\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\\\n\tmask = (~0ULL << rshift) >> lshift;\t\t\t\t\\\n\tval = (val & ~mask) | ((nval << rpad) & mask);\t\t\t\\\n\t\t\t\t\t\t\t\t\\\n\tswitch (byte_size) {\t\t\t\t\t\\\n\tcase 1: *(unsigned char *)p      = val; break;\t\t\t\\\n\tcase 2: *(unsigned short *)p     = val; break;\t\t\t\\\n\tcase 4: *(unsigned int *)p       = val; break;\t\t\t\\\n\tcase 8: *(unsigned long long *)p = val; break;\t\t\t\\\n\t}\t\t\t\t\t\t\t\\\n})\n```\n\n----------------------------------------\n\nTITLE: Definition of libbpf_minor_version Function in C\nDESCRIPTION: The function signature for libbpf_minor_version which returns an unsigned 32-bit integer representing the minor version of the libbpf library. This function takes no parameters and was introduced in libbpf version 0.6.0.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/libbpf_minor_version.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n__u32 libbpf_minor_version(void)\n```\n\n----------------------------------------\n\nTITLE: Setting BTF File Descriptor in Libbpf (C)\nDESCRIPTION: Function signature for setting the file descriptor of a BTF object. It takes a BTF object pointer and the file descriptor of a loaded BTF object as parameters.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/btf__set_fd.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nvoid btf__set_fd(struct btf *btf, int fd);\n```\n\n----------------------------------------\n\nTITLE: New eBPF Helper Functions in Linux 5.13-5.18\nDESCRIPTION: New helper functions added for eBPF programs, including functions for timers, branch snapshots, string operations, and more.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/timeline/index.md#2025-04-22_snippet_4\n\nLANGUAGE: C\nCODE:\n```\nbpf_for_each_map_elem\nbpf_snprintf\nbpf_sys_bpf\nbpf_btf_find_by_name_kind\nbpf_sys_close\nbpf_timer_init\nbpf_timer_set_callback\nbpf_timer_start\nbpf_timer_cancel\nbpf_get_func_ip\nbpf_get_attach_cookie\nbpf_task_pt_regs\nbpf_get_branch_snapshot\nbpf_trace_vprintk\nbpf_skc_to_unix_sock\nbpf_kallsyms_lookup_name\nbpf_find_vma\nbpf_loop\nbpf_strncmp\nbpf_get_func_arg\nbpf_get_func_ret\nbpf_get_func_arg_cnt\nbpf_get_retval\nbpf_set_retval\nbpf_xdp_get_buff_len\nbpf_xdp_load_bytes\nbpf_xdp_store_bytes\nbpf_copy_from_user_task\nbpf_skb_set_tstamp\nbpf_ima_file_hash\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_sk_redirect_hash Helper Function in C\nDESCRIPTION: C definition of the bpf_sk_redirect_hash helper function. It takes a socket buffer, a map pointer, a key, and flags as parameters. Returns SK_PASS on success or SK_DROP on error.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_sk_redirect_hash.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstatic long (* const bpf_sk_redirect_hash)(struct __sk_buff *skb, void *map, void *key, __u64 flags) = (void *) 72;\n```\n\n----------------------------------------\n\nTITLE: Helper Function Definition in C\nDESCRIPTION: Core definition of the bpf_get_stackid helper function showing its type signature.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_get_stackid.md#2025-04-22_snippet_1\n\nLANGUAGE: c\nCODE:\n```\nstatic long (* const bpf_get_stackid)(void *ctx, void *map, __u64 flags) = (void *) 27;\n```\n\n----------------------------------------\n\nTITLE: RCU Read Lock Function Definition in C\nDESCRIPTION: Function signature for the bpf_rcu_read_lock kernel function that defines an RCU read lock region.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/bpf_rcu_read_lock.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nvoid bpf_rcu_read_lock()\n```\n\n----------------------------------------\n\nTITLE: Using the 'likely' Macro in Conditional Statements\nDESCRIPTION: Example demonstrating how to use the 'likely' macro in an if statement to optimize for the expected code path. This helps with instruction cache locality by placing the likely code path closer to the conditional jump.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/scx/likely.md#2025-04-22_snippet_1\n\nLANGUAGE: c\nCODE:\n```\nif (likely(x > 0)) {\n    // Likely code path\n} else {\n    // Unlikely code path\n}\n```\n\n----------------------------------------\n\nTITLE: Using bpf_core_type_exists for Conditional Logic in C eBPF Programs\nDESCRIPTION: This C code demonstrates using the `bpf_core_type_exists` macro (mistakenly written as `bpf_core_field_exists` in the example's `if` condition, but the surrounding text clarifies the intent is type existence) within a kprobe eBPF program. It checks if `struct some_kernel_struct` exists in the target kernel. If it does, it reads a field (`b`) from it using `BPF_CORE_READ`; otherwise, it executes fallback logic. This conditional check is resolved at load time by libbpf, and the eBPF verifier only processes the branch taken, ensuring no runtime performance overhead.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/ebpf/bpf_core_type_exists.md#2025-04-22_snippet_1\n\nLANGUAGE: c\nCODE:\n```\nstruct some_kernel_struct {\n    int a;\n    int b;\n};\n\nSEC(\"kprobe\")\nint kprobe__example(struct pt_regs *ctx)\n{\n    int b;\n\n    // Depending on if some_kernel_struct exists on the kernel we are running on\n    // one or the other branch is taken. The verifier will only evaluate the branch\n    // that is taken, and will optimize the if statement away, so this does not\n    // impact the program's performance.\n    if (bpf_core_field_exists(struct some_kernel_struct)) { // Note: The surrounding text suggests this should be bpf_core_type_exists\n        struct some_kernel_struct *a = PT_REGS_PARM1(ctx);\n        int b = BPF_CORE_READ(a, b);\n    } else {\n        int b = more_complex_fallback_to_get_b();\n    }\n\n    bpf_printk(\"Value of field 'a' = %d\", b);\n\n    return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining the cast_mask Macro for BPF cpumask Conversion in C\nDESCRIPTION: This macro casts a BPF cpumask (struct bpf_cpumask) to a regular cpumask (struct cpumask). It's an inline function that performs a simple typecast and was introduced in Linux kernel v6.12.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/scx/cast_mask.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstatic __always_inline const struct cpumask *cast_mask(struct bpf_cpumask *mask)\n{\n\treturn (const struct cpumask *)mask;\n}\n```\n\n----------------------------------------\n\nTITLE: Using xdp_multiprog__hw_prog Function in C\nDESCRIPTION: Function signature for xdp_multiprog__hw_prog which returns a struct xdp_program pointer representing the program loaded in the interface. Returns a reference on success or a negative error code on failure.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libxdp/functions/xdp_multiprog__hw_prog.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstruct xdp_program *xdp_multiprog__hw_prog(const struct xdp_multiprog *mp);\n```\n\n----------------------------------------\n\nTITLE: Defining libbpf_register_prog_handler function in C\nDESCRIPTION: Function signature for libbpf_register_prog_handler, which registers a custom BPF program SEC handler. It takes section prefix, program type, attach type, and optional settings as parameters, returning a handler ID or error code.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/libbpf_register_prog_handler.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nint libbpf_register_prog_handler(const char *sec, enum bpf_prog_type prog_type, enum bpf_attach_type exp_attach_type, const struct libbpf_prog_handler_opts *opts);\n```\n\n----------------------------------------\n\nTITLE: Mounting BPF Filesystem in Bash\nDESCRIPTION: Command to manually mount the BPF filesystem at the standard location /sys/fs/bpf.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/concepts/pinning.md#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nmount -t bpf bpffs /sys/fs/bpf\n```\n\n----------------------------------------\n\nTITLE: Defining scx_bpf_dispatch_from_dsq KFunc in C\nDESCRIPTION: Function signature for the scx_bpf_dispatch_from_dsq kernel function that handles task dispatch from a dispatch queue. Takes iterator, task struct, queue ID and flags as parameters and returns a boolean.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/scx_bpf_dispatch_from_dsq.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nbool scx_bpf_dispatch_from_dsq(struct bpf_iter_scx_dsq *it__iter, struct task_struct *p, u64 dsq_id, u64 enq_flags)\n```\n\n----------------------------------------\n\nTITLE: Defining the bpf_map__set_autoattach Function in libbpf\nDESCRIPTION: This C snippet defines the 'bpf_map__set_autoattach' function, allowing users to set whether libbpf should auto-attach a map during the BPF skeleton attach phase. Dependencies include the libbpf library. The main parameters are 'map', a BPF map instance, and 'autoattach', a boolean to indicate auto-attachment. The function returns 0 on success, or a negative error code if an error occurs. This implementation may have limitations if the documentation is incomplete.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_map__set_autoattach.md#2025-04-22_snippet_0\n\nLANGUAGE: C\nCODE:\n```\nint bpf_map__set_autoattach(struct bpf_map *map, bool autoattach);\n```\n\n----------------------------------------\n\nTITLE: Defining the bpf_for_each_map_elem Helper Function in C\nDESCRIPTION: The C definition of the bpf_for_each_map_elem helper function, showing its parameters and declaration as helper function number 164.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_for_each_map_elem.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstatic long (* const bpf_for_each_map_elem)(void *map, void *callback_fn, void *callback_ctx, __u64 flags) = (void *) 164;\n```\n\n----------------------------------------\n\nTITLE: Defining BPF Program Line Info Structure in C\nDESCRIPTION: This structure holds line information for a BPF program, containing fields for raw line info before and after JIT compilation, along with various counters and indexes to track line information records.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_prog_linfo__new.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstruct bpf_prog_linfo {\n\tvoid *raw_linfo;\n\tvoid *raw_jited_linfo;\n\t__u32 *nr_jited_linfo_per_func;\n\t__u32 *jited_linfo_func_idx;\n\t__u32 nr_linfo;\n\t__u32 nr_jited_func;\n\t__u32 rec_size;\n\t__u32 jited_rec_size;\n};\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_rc_pointer_rel Helper Function in C\nDESCRIPTION: This code snippet defines the 'bpf_rc_pointer_rel' helper function used in eBPF programs for IR decoding to report decoded pointer movements. It takes a context pointer and relative x and y coordinates as parameters, returning 0 on completion.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_rc_pointer_rel.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstatic long (* const bpf_rc_pointer_rel)(void *ctx, __s32 rel_x, __s32 rel_y) = (void *) 92;\n```\n\n----------------------------------------\n\nTITLE: Defining btf__add_type_tag function in C\nDESCRIPTION: This snippet shows the function signature for btf__add_type_tag. It takes a pointer to a struct btf object, a tag value string, and a reference type ID. The function returns a positive integer for the new type ID on success, or a negative value on error.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/btf__add_type_tag.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nint btf__add_type_tag(struct btf *btf, const char *value, int ref_type_id);\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_tc_detach function in C\nDESCRIPTION: This snippet defines the bpf_tc_detach function, which is used to detach a BPF_PROG_TYPE_SCHED_CLS program from a TC qdisc. It takes pointers to bpf_tc_hook and bpf_tc_opts structures as parameters.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_tc_detach.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nint bpf_tc_detach(const struct bpf_tc_hook *hook, const struct bpf_tc_opts *opts);\n```\n\n----------------------------------------\n\nTITLE: Defining libbpf_probe_bpf_map_type Function in C\nDESCRIPTION: Function declaration for libbpf_probe_bpf_map_type which detects if the host kernel supports BPF maps of a given type. It takes a map_type parameter and an opts parameter reserved for future extensibility.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/libbpf_probe_bpf_map_type.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nint libbpf_probe_bpf_map_type(enum bpf_map_type map_type, const void *opts);\n```\n\n----------------------------------------\n\nTITLE: Definition of bpf_iter_num_destroy KFunc in C\nDESCRIPTION: Function signature for the bpf_iter_num_destroy kernel function that destroys an iterator. The iterator can be reused after destruction but must be re-initialized with bpf_iter_num_new first.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/bpf_iter_num_destroy.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nvoid bpf_iter_num_destroy(struct bpf_iter_num *it)\n```\n\n----------------------------------------\n\nTITLE: Function Definition for bpf_object__btf in C\nDESCRIPTION: Function signature for bpf_object__btf that takes a const bpf_object pointer and returns a BTF struct pointer. Returns NULL if the BPF object has no BTF information.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_object__btf.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstruct btf *bpf_object__btf(const struct bpf_object *obj);\n```\n\n----------------------------------------\n\nTITLE: Defining a Basic Multi-line Code Block in Markdown\nDESCRIPTION: Shows the basic Markdown syntax using triple backticks (```) to define a multi-line code block. This snippet simply contains the text 'Code example'.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/meta.md#2025-04-22_snippet_1\n\nLANGUAGE: markdown\nCODE:\n```\n```\nCode example\n```\n```\n\n----------------------------------------\n\nTITLE: Serving eBPF Docs with Docker\nDESCRIPTION: Simple command to serve the documentation using Docker through a makefile.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/README.md#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n$ make serve\n```\n\n----------------------------------------\n\nTITLE: Struct Definition for HID BPF Context - Linux Kernel C\nDESCRIPTION: Defines 'struct hid_bpf_ctx', holding context for BPF HID programs including pointers to the HID device and bookkeeping fields for size and return value management. This context struct is required by all BPF callback functions and allows safe, limited access to device data via helper calls (see hid_bpf_get_data). All members are carefully typed for kernel data structures.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/program-type/BPF_PROG_TYPE_STRUCT_OPS/hid_bpf_ops.md#2025-04-22_snippet_1\n\nLANGUAGE: c\nCODE:\n```\nstruct hid_bpf_ctx {\n\tstruct hid_device *hid;\n\t__u32 allocated_size;\n\tunion {\n\t\t__s32 retval;\n\t\t__s32 size;\n\t};\n};\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_object__prev_map function in libbpf\nDESCRIPTION: Function definition for bpf_object__prev_map which iterates over maps in a BPF object in reverse order. It takes a BPF object pointer and a current map pointer (or NULL to start iteration) and returns the previous map or NULL if there are no more maps.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_object__prev_map.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstruct bpf_map * bpf_object__prev_map(const struct bpf_object *obj, const struct bpf_map *map);\n```\n\n----------------------------------------\n\nTITLE: Defining BPF_CORE_READ_USER_INTO Macro in C for eBPF CO-RE String Reading\nDESCRIPTION: The C macro definition for BPF_CORE_READ_USER_INTO which uses the ___core_read internal function with bpf_core_read_user to perform relocatable reads from user memory. This forms the basis for the BPF_CORE_READ_USER_STR_INTO functionality.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/ebpf/BPF_CORE_READ_USER_STR_INTO.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n#define BPF_CORE_READ_USER_INTO(dst, src, a, ...) ({\\n\\t___core_read(bpf_core_read_user, bpf_core_read_user,\\t\\t    \\n\\t\\t     dst, (src), a, ##__VA_ARGS__)\\t\\t\\t    \\n})\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_skc_to_tcp6_sock Helper Function in C\nDESCRIPTION: This code snippet defines the 'bpf_skc_to_tcp6_sock' helper function. It dynamically casts a 'sk' pointer to a 'tcp6_sock' pointer, returning the cast pointer if valid or NULL otherwise.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_skc_to_tcp6_sock.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstatic struct tcp6_sock *(* const bpf_skc_to_tcp6_sock)(void *sk) = (void *) 136;\n```\n\n----------------------------------------\n\nTITLE: Declaring bpf_xdp_adjust_tail Helper Function Reference in C\nDESCRIPTION: This C snippet declares a static function pointer 'bpf_xdp_adjust_tail' for use within eBPF programs, mapping it as a helper with handler ID 65. It allows calling the kernel helper to adjust the tail of an XDP packet buffer. The dependency is the eBPF environment (including struct xdp_md); the function accepts a pointer to xdp_md and an integer delta, returning 0 on success or a negative error code.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_xdp_adjust_tail.md#2025-04-22_snippet_0\n\nLANGUAGE: C\nCODE:\n```\nstatic long (* const bpf_xdp_adjust_tail)(struct xdp_md *xdp_md, int delta) = (void *) 65;\n```\n\n----------------------------------------\n\nTITLE: Defining 64-bit Host-to-Network Byte Order Conversion Macro with Libbpf in C\nDESCRIPTION: Declares a set of C macros culminating in 'bpf_cpu_to_be64', used within eBPF and libbpf C code to ensure a 64-bit integer is in network (big-endian) byte order. This set of macros detects system endianness at compile time with preprocessor logic, leverages compiler built-ins when available, and manually performs byte swapping on compile-time constants. Prerequisites: libbpf development headers and a C99-compliant compiler. Input must be a 64-bit value, output is the value in big-endian order. The macro supports constant expressions and non-constant runtime values, and will error at compile time if system byte order is unsupported.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/ebpf/bpf_cpu_to_be64.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n#define ___bpf_mvb(x, b, n, m) ((__u##b)(x) << (b-(n+1)*8) >> (b-8) << (m*8))\\n\\n#define ___bpf_swab64(x) ((__u64)(\\t\\t\\t\\t\\t\\\\n\\t\\t\\t  ___bpf_mvb(x, 64, 0, 7) |\\t\\t\\\\n\\t\\t\\t  ___bpf_mvb(x, 64, 1, 6) |\\t\\t\\\\n\\t\\t\\t  ___bpf_mvb(x, 64, 2, 5) |\\t\\t\\\\n\\t\\t\\t  ___bpf_mvb(x, 64, 3, 4) |\\t\\t\\\\n\\t\\t\\t  ___bpf_mvb(x, 64, 4, 3) |\\t\\t\\\\n\\t\\t\\t  ___bpf_mvb(x, 64, 5, 2) |\\t\\t\\\\n\\t\\t\\t  ___bpf_mvb(x, 64, 6, 1) |\\t\\t\\\\n\\t\\t\\t  ___bpf_mvb(x, 64, 7, 0)))\\n\\n#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__\\n# define __bpf_cpu_to_be64(x)\\t\\t__builtin_bswap64(x)\\n# define __bpf_constant_cpu_to_be64(x)\\t___bpf_swab64(x)\\n#elif __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__\\n# define __bpf_cpu_to_be64(x)\\t\\t(x)\\n# define __bpf_constant_cpu_to_be64(x)  (x)\\n#else\\n# error \"Fix your compiler's __BYTE_ORDER__?!\"\\n#endif\\n\\n#define bpf_cpu_to_be64(x)\\t\\t\\t\\t\\\\n\\t(__builtin_constant_p(x) ?\\t\\t\\\\n\\t __bpf_constant_cpu_to_be64(x) : __bpf_cpu_to_be64(x))\n```\n\n----------------------------------------\n\nTITLE: Definition of bpf_cpumask_test_and_set_cpu kfunc in C\nDESCRIPTION: Function signature for the bpf_cpumask_test_and_set_cpu kfunc that takes a CPU number and a CPU-mask pointer as arguments. It returns a boolean indicating whether the CPU was already set in the mask.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/bpf_cpumask_test_and_set_cpu.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nbool bpf_cpumask_test_and_set_cpu(u32 cpu, struct bpf_cpumask *cpumask)\n```\n\n----------------------------------------\n\nTITLE: BTF Type Count Function Definition\nDESCRIPTION: C function definition for btf__type_cnt that takes a BTF object pointer and returns the count of types as an unsigned 32-bit integer.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/btf__type_cnt.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n__u32 btf__type_cnt(const struct btf *btf);\n```\n\n----------------------------------------\n\nTITLE: Declaring bpf_linker_opts Structure for BPF Linking (C)\nDESCRIPTION: Declares the bpf_linker_opts struct, which serves as an options container for BPF linker creation. The only member, sz, should be set to the size of the struct for compatibility across different Libbpf versions. This struct is passed as a parameter when initializing a new BPF linker object.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_linker__new_fd.md#2025-04-22_snippet_1\n\nLANGUAGE: c\nCODE:\n```\nstruct bpf_linker_opts {\n    /* size of this struct, for forward/backward compatibility */\n    size_t sz;\n};\n```\n\n----------------------------------------\n\nTITLE: Example Usage of 'bpf_tail_call_static' Function\nDESCRIPTION: An example demonstrates the usage of 'bpf_tail_call_static' for optimized tail calls in BPF programs. It includes a map definition and sample XDP programs that demonstrate how to switch between functions based on packet data size, achieving optimized routing within eBPF using static slot indices.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/ebpf/bpf_tail_call_static.md#2025-04-22_snippet_1\n\nLANGUAGE: c\nCODE:\n```\n#define TAIL_CALL_ZERO 0\n#define TAIL_CALL_ONE 1\n\nstruct {\n\t__uint(type, BPF_MAP_TYPE_PROG_ARRAY);\n\t__uint(max_entries, 2);\n\t__uint(key_size, sizeof(__u32));\n\t__array(values, int (void *));\n} prog_array_map SEC(\".maps\") = {\n\t.values = {\n        [TAIL_CALL_ZERO] = (void *)&tailcall_0,\n\t\t[TAIL_CALL_ONE] = (void *)&tailcall_1,\n\t},\n};\n\nSEC(\"xdp\")\nint tailcall_0(struct xdp_md *ctx)\n{\n    return XDP_PASS;\n}\n\nSEC(\"xdp\")\nint tailcall_1(struct xdp_md *ctx)\n{\n    return XDP_DROP;\n}\n\nSEC(\"xdp\")\nint xdp_prog(struct xdp_md *ctx)\n{\n    void *data_end = (void *)(long)ctx->data_end;\n    void *data = (void *)(long)ctx->data;\n\n    if (data + sizeof(struct ethhdr) > data_end)\n        return bpf_tail_call_static(skb, &prog_array_map, TAIL_CALL_ONE);\n\n    return bpf_tail_call_static(skb, &prog_array_map, TAIL_CALL_ZERO);\n}\n\n```\n\n----------------------------------------\n\nTITLE: Definition of bpf_program__set_flags function in C\nDESCRIPTION: Function signature for bpf_program__set_flags which sets flags for BPF program loading. Takes a pointer to a bpf_program struct and a 32-bit unsigned integer for flags. Returns an integer error code (0 if successful).\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_program__set_flags.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nint bpf_program__set_flags(struct bpf_program *prog, __u32 flags);\n```\n\n----------------------------------------\n\nTITLE: Defining the 'offsetof' Macro in C\nDESCRIPTION: This C preprocessor macro `offsetof` calculates the byte offset of a specified `member` within a given struct `type`. It achieves this by casting the null pointer (0) to the struct type, accessing the member, taking its address, and converting it to an `unsigned long`. This macro is part of libbpf version 0.0.9 and later.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/ebpf/offsetof.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n#define offsetof(type, member)\t((unsigned long)&((type *)0)->member)\n```\n\n----------------------------------------\n\nTITLE: Accessing TX Descriptor in Libxdp\nDESCRIPTION: Function signature showing how to access a specific transmit descriptor in the TX ring. The function takes a pointer to xsk_ring_prod structure and an index, returning a pointer to xdp_desc containing packet transmission information.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libxdp/functions/xsk_ring_prod__tx_desc.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstruct xdp_desc *xsk_ring_prod__tx_desc(struct xsk_ring_prod *tx, __u32 idx);\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_linker__add_fd API Function in Libbpf (C)\nDESCRIPTION: Declares the 'bpf_linker__add_fd' function, used to add a file descriptor to a Libbpf bpf_linker instance in userspace C programs. This function takes a pointer to a bpf_linker struct, a file descriptor, and a pointer to a bpf_linker_file_opts struct providing additional options. On success, it returns 0; on failure, it returns a negative error code and sets errno. Requires Libbpf 1.6.0 or newer and properly initialized structs.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_linker__add_fd.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nint bpf_linker__add_fd(struct bpf_linker *linker, int fd, const struct bpf_linker_file_opts *opts);\n```\n\n----------------------------------------\n\nTITLE: Unpinning BPF Links with Libbpf in C\nDESCRIPTION: The 'bpf_link__unpin' function is used to unpin a BPF link specified by a path in the BPF file system (BPFFS). The function takes a 'struct bpf_link *link' parameter and returns 0 on successful execution, or a negative error code if an error occurs. It requires that a BPFFS path be specified correctly and anticipates potential unlinking by other processes.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_link__unpin.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nint bpf_link__unpin(struct bpf_link *link);\n```\n\n----------------------------------------\n\nTITLE: Enumeration of HID Report Types - Linux Kernel C\nDESCRIPTION: Provides an enumeration, 'enum hid_report_type', for BPF programs to identify the type of HID report being processed. Each value maps to a specific HID report channel. Used in struct_ops callbacks and by kernel HID APIs.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/program-type/BPF_PROG_TYPE_STRUCT_OPS/hid_bpf_ops.md#2025-04-22_snippet_2\n\nLANGUAGE: c\nCODE:\n```\nenum hid_report_type {\n\tHID_INPUT_REPORT    = 0,\n\tHID_OUTPUT_REPORT   = 1,\n\tHID_FEATURE_REPORT  = 2,\n};\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_tc_opts structure in C\nDESCRIPTION: This struct defines the options for TC qdisc operations. It includes fields for program file descriptor, flags, program ID, handle, and priority.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_tc_detach.md#2025-04-22_snippet_3\n\nLANGUAGE: c\nCODE:\n```\nstruct bpf_tc_opts {\n\tsize_t sz;\n\tint prog_fd;\n\t__u32 flags;\n\t__u32 prog_id;\n\t__u32 handle;\n\t__u32 priority;\n\tsize_t :0;\n};\n```\n\n----------------------------------------\n\nTITLE: Using xdp_program__run_prio Function in C\nDESCRIPTION: This function retrieves the priority value of an XDP program. It returns the unsigned integer priority value on success, or a negative error code (-EINVAL) in case of failure with invalid arguments.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libxdp/functions/xdp_program__run_prio.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nunsigned int xdp_program__run_prio(const struct xdp_program *xdp_prog);\n```\n\n----------------------------------------\n\nTITLE: Defining btf__set_endianness function in C\nDESCRIPTION: Function signature for setting the endianness of a BTF object. It takes a pointer to a struct btf and an enum btf_endianness as parameters, returning an integer status code.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/btf__set_endianness.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nint btf__set_endianness(struct btf *btf, enum btf_endianness endian);\n```\n\n----------------------------------------\n\nTITLE: Declaring the 'bpf_map__set_pin_path' Function in C\nDESCRIPTION: This C code snippet shows the function signature for `bpf_map__set_pin_path`. It is part of the libbpf library and is used to set the intended filesystem pin path for a given BPF map (`map`) using a specified `path` string. The function returns 0 on success or a negative error code on failure. It requires the libbpf headers.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_map__set_pin_path.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n`#!c int bpf_map__set_pin_path(struct bpf_map *map, const char *path);`\n```\n\n----------------------------------------\n\nTITLE: Get Path Attribute with Libbpf 'bpf_map__pin_path' Function\nDESCRIPTION: The 'bpf_map__pin_path' function retrieves the path where a BPF map is intended to be pinned. It is part of the libbpf library and requires a 'bpf_map' structure as input. The function returns a path string or 'NULL' if the path is not set or an error occurs.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_map__pin_path.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nconst char *bpf_map__pin_path(const struct bpf_map *map);\n```\n\n----------------------------------------\n\nTITLE: Definition of bpf_iter_css_task_destroy KFunc in C\nDESCRIPTION: Function signature for the bpf_iter_css_task_destroy kernel function which takes a pointer to a bpf_iter_css_task struct and returns void. This function is used to clean up CSS task iterators.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/bpf_iter_css_task_destroy.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nvoid bpf_iter_css_task_destroy(struct bpf_iter_css_task *it)\n```\n\n----------------------------------------\n\nTITLE: Function Signature for bpf_map__is_internal in C\nDESCRIPTION: This snippet shows the C function signature for `bpf_map__is_internal`. The function takes a constant pointer to a `bpf_map` structure (`map`) as input and returns a boolean value indicating whether the map is an internal map created by libbpf (`true`) or not (`false`). It depends on the `libbpf` library and the `bpf_map` structure definition.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_map__is_internal.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n#!c bool bpf_map__is_internal(const struct bpf_map *map);\n```\n\n----------------------------------------\n\nTITLE: Inserting Program Type Helper Function References in Markdown\nDESCRIPTION: Shows the markers used to insert generated program type helper function references into markdown files. The tool looks for these markers to place the generated markdown content.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/meta.md#2025-04-22_snippet_7\n\nLANGUAGE: markdown\nCODE:\n```\n<!-- [PROG_HELPER_FUNC_REF] -->\n<!-- [/PROG_HELPER_FUNC_REF] -->\n```\n\n----------------------------------------\n\nTITLE: Function Definition for bpf_map_lookup_and_delete_elem in C\nDESCRIPTION: Function signature and parameters for looking up and deleting elements from a BPF map. Takes a file descriptor, key pointer, and value pointer as parameters. Returns 0 on success or negative error code on failure.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_map_lookup_and_delete_elem.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nint bpf_map_lookup_and_delete_elem(int fd, const void *key, void *value);\n```\n\n----------------------------------------\n\nTITLE: Definition of btf__resolve_size function in C\nDESCRIPTION: Function signature for btf__resolve_size which resolves the size of a BTF type. It takes a pointer to a struct btf object and a type ID as parameters, returning the size in bytes or a negative error code on failure.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/btf__resolve_size.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n__s64 btf__resolve_size(const struct btf *btf, __u32 type_id);\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_tc_attach_point enum in C\nDESCRIPTION: This enum defines the possible TC attach points for BPF programs, including ingress, egress, and custom.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_tc_detach.md#2025-04-22_snippet_2\n\nLANGUAGE: c\nCODE:\n```\nenum bpf_tc_attach_point {\n\tBPF_TC_INGRESS = 1 << 0,\n\tBPF_TC_EGRESS  = 1 << 1,\n\tBPF_TC_CUSTOM  = 1 << 2,\n};\n```\n\n----------------------------------------\n\nTITLE: Defining the __kconfig macro in C\nDESCRIPTION: The definition of the __kconfig macro using the section attribute to place variables in the .kconfig section of the eBPF object file.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/ebpf/__kconfig.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n#define __kconfig __attribute__((section(\".kconfig\")))\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_cpumask_copy KFunc - C\nDESCRIPTION: This snippet provides the C function signature for the eBPF kfunc `bpf_cpumask_copy`, used to copy the contents of a CPU-mask into a BPF CPU-mask. It requires kernel support for eBPF kfuncs and the presence of the `struct bpf_cpumask` and `struct cpumask` types. Expected parameters are pointers to the destination and source CPU masks; it does not return a value. Used in eBPF programs for CPU mask manipulation, particularly in supported program types.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/bpf_cpumask_copy.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n#!c void bpf_cpumask_copy(struct bpf_cpumask *dst, const struct cpumask *src)\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_redirect_peer Helper Function in C\nDESCRIPTION: This code snippet defines the 'bpf_redirect_peer' eBPF helper function. It redirects a packet to another net device's peer in a different network namespace, similar to bpf_redirect() but with specific behavior differences.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_redirect_peer.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstatic long (* const bpf_redirect_peer)(__u32 ifindex, __u64 flags) = (void *) 155;\n```\n\n----------------------------------------\n\nTITLE: Using __noinline with eBPF Functions in C\nDESCRIPTION: Example demonstrating how to use the __noinline attribute with a function in an eBPF program. The function 'add' is marked as non-inlineable, forcing a BPF-to-BPF function call which can help with stack space constraints.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/ebpf/__noinline.md#2025-04-22_snippet_1\n\nLANGUAGE: c\nCODE:\n```\nstatic int __noinline add(int a, int b)\n{\n    return a + b;\n}\n\nSEC(\"xdp\")\nint example_prog(struct xdp_md *ctx)\n{\n    if (add(1, 2) == 3)\n        return XDP_PASS;\n    else\n        return XDP_DROP;\n}\n```\n\n----------------------------------------\n\nTITLE: Using __arg_nullable in eBPF Functions\nDESCRIPTION: This example demonstrates the usage of __arg_nullable in eBPF functions. It shows how to tag a function argument as nullable and how to handle null checks in the function body.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/ebpf/__arg_nullable.md#2025-04-22_snippet_1\n\nLANGUAGE: C\nCODE:\n```\n__weak int subprog_nullable_task_flavor(\n\tstruct task_struct___local *task __arg_trusted __arg_nullable)\n{\n\tchar buf[16];\n\n\tif (!task)\n\t\treturn 0;\n\n\treturn bpf_copy_from_user_task(&buf, sizeof(buf), NULL, (void *)task, 0);\n}\n\nSEC(\"?uprobe.s\")\nint flavor_ptr_nullable(void *ctx)\n{\n\tstruct task_struct___local *t = (void *)bpf_get_current_task_btf();\n\n\treturn subprog_nullable_task_flavor(t);\n}\n\n__weak int subprog_nonnull_task_flavor(struct task_struct___local *task __arg_trusted)\n{\n\tchar buf[16];\n\n\treturn bpf_copy_from_user_task(&buf, sizeof(buf), NULL, (void *)task, 0);\n}\n\nSEC(\"?uprobe.s\")\nint flavor_ptr_nonnull(void *ctx)\n{\n\tstruct task_struct *t = bpf_get_current_task_btf();\n\n\treturn subprog_nonnull_task_flavor((void *)t);\n}\n```\n\n----------------------------------------\n\nTITLE: Function Definition: bpf_prog_linfo__lfind in C\nDESCRIPTION: Definition of the bpf_prog_linfo__lfind function that searches for line info records based on instruction offset. It takes a line info object, instruction offset, and skip count as parameters, returning a pointer to the matching line info record or NULL if not found.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_prog_linfo__lfind.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nconst struct bpf_line_info * bpf_prog_linfo__lfind(const struct bpf_prog_linfo *prog_linfo, __u32 insn_off, __u32 nr_skip);\n```\n\n----------------------------------------\n\nTITLE: Defining ring_buffer_opts Structure in C\nDESCRIPTION: Definition of the options structure used when creating a new ring buffer. Currently contains only a size field for forward/backward compatibility.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/ring_buffer__new.md#2025-04-22_snippet_1\n\nLANGUAGE: c\nCODE:\n```\nstruct ring_buffer_opts {\n\tsize_t sz; /* size of this struct, for forward/backward compatibility */\n};\n```\n\n----------------------------------------\n\nTITLE: Defining the bpf_rbtree_add macro in C\nDESCRIPTION: This C macro wraps the bpf_rbtree_add_impl kfunc, providing a simplified interface by handling the NULL fourth argument and setting the fifth argument to 0.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/scx/bpf_rbtree_add.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n#define bpf_rbtree_add(head, node, less) [bpf_rbtree_add_impl](../../linux/kfuncs/bpf_rbtree_add_impl.md)(head, node, less, NULL, 0)\n```\n\n----------------------------------------\n\nTITLE: Definition of the bpf_program__attach_kprobe_opts function in C\nDESCRIPTION: Function signature for attaching a BPF_PROG_TYPE_KPROBE program with custom options. It takes a program pointer, kernel function name, and options structure, returning a bpf_link pointer.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_program__attach_kprobe_opts.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstruct bpf_link * bpf_program__attach_kprobe_opts(const struct bpf_program *prog, const char *func_name, const struct bpf_kprobe_opts *opts);\n```\n\n----------------------------------------\n\nTITLE: Using Markdown Links within Code Blocks (Syntax Example)\nDESCRIPTION: Demonstrates the Markdown syntax for embedding a link within a C code block. This functionality is enabled by a custom MkDocs hook (`hooks/links_in_code.py`) specific to this project, allowing parts of code examples to link to other documentation sections or definitions.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/meta.md#2025-04-22_snippet_4\n\nLANGUAGE: markdown\nCODE:\n```\n````\n```c\nstruct abc {\n    uint_t [some_field](#codeblocks);\n};\n```\n````\n```\n\n----------------------------------------\n\nTITLE: Defining the bpf_core_read_user Macro in C\nDESCRIPTION: The 'bpf_core_read_user' macro defines a wrapper around the 'bpf_probe_read_user' function, facilitating userspace access with offset relocation. This relies on '__builtin_preserve_access_index' to ensure the correct memory access. No external dependencies aside from what is available in the eBPF environment are needed.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/ebpf/bpf_core_read_user.md#2025-04-22_snippet_0\n\nLANGUAGE: C\nCODE:\n```\n#define bpf_core_read_user(dst, sz, src)\\n\\tbpf_probe_read_user(dst, sz, (const void *)__builtin_preserve_access_index(src))\n```\n\n----------------------------------------\n\nTITLE: Defining __arg_nullable Macro in C\nDESCRIPTION: This snippet shows the definition of the __arg_nullable macro using a C attribute. It tags a function argument to indicate that its value may be null.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/ebpf/__arg_nullable.md#2025-04-22_snippet_0\n\nLANGUAGE: C\nCODE:\n```\n#define __arg_nullable __attribute((btf_decl_tag(\"arg:nullable\")))\n```\n\n----------------------------------------\n\nTITLE: Definition of bpf_local_irq_restore KFunc in C\nDESCRIPTION: Function signature for the bpf_local_irq_restore kernel function, which restores IRQ state from the stack and re-enables IRQs.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/bpf_local_irq_restore.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nvoid bpf_local_irq_restore(long unsigned int *flags__irq_flag)\n```\n\n----------------------------------------\n\nTITLE: Defining the bpf_linker_file_opts Struct in C\nDESCRIPTION: This C code snippet defines the `bpf_linker_file_opts` structure, used as an optional parameter for the `bpf_linker__add_buf` function in libbpf. It contains a `sz` field which must be initialized to the size of the structure (`sizeof(struct bpf_linker_file_opts)`) to ensure forward and backward compatibility.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_linker__add_buf.md#2025-04-22_snippet_1\n\nLANGUAGE: c\nCODE:\n```\nstruct bpf_linker_file_opts {\n    /* size of this struct, for forward/backward compatibility */\n    size_t sz;\n};\n```\n\n----------------------------------------\n\nTITLE: Definition of the 'private' Macro in C\nDESCRIPTION: The 'private' macro definition which places a global variable in a section named '.data.<name>' and marks it as hidden. It uses the SEC macro and __hidden attribute with 8-byte alignment.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/scx/private.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n#define private(name) [SEC](../libbpf/ebpf/SEC.md)(\".data.\" #name) [__hidden](../libbpf/ebpf/__hidden.md) __attribute__((aligned(8)))\n```\n\n----------------------------------------\n\nTITLE: Defining eBPF Helper Function bpf_get_ns_current_pid_tgid\nDESCRIPTION: Function definition for bpf_get_ns_current_pid_tgid helper that retrieves PID and TGID from current namespace. Returns 0 on success or error codes -EINVAL/-ENOENT on failure. Takes device ID, inode number, namespace data struct and size as parameters.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_get_ns_current_pid_tgid.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstatic long (* const bpf_get_ns_current_pid_tgid)(__u64 dev, __u64 ino, struct bpf_pidns_info *nsdata, __u32 size) = (void *) 120;\n```\n\n----------------------------------------\n\nTITLE: Declaring eBPF KFunc 'scx_bpf_dsq_move_vtime' in C\nDESCRIPTION: This snippet provides the signature for the 'scx_bpf_dsq_move_vtime' kfunc in C, which facilitates the transfer of a task from a DSQ iterator to a priority queue of another DSQ. It maintains 'p'\\'s slice and vtime by default, and operates under specific conditions outlined in the parameters.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/scx_bpf_dsq_move_vtime.md#2025-04-22_snippet_0\n\nLANGUAGE: C\nCODE:\n```\n#!c bool scx_bpf_dsq_move_vtime(struct bpf_iter_scx_dsq *it__iter, struct task_struct *p, u64 dsq_id, u64 enq_flags)\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_reserve_hdr_opt Helper Function in C\nDESCRIPTION: This code snippet defines the bpf_reserve_hdr_opt helper function for eBPF programs. It reserves space for header options to be used later in BPF_SOCK_OPS_WRITE_HDR_OPT_CB. The function takes a bpf_sock_ops pointer, length, and flags as parameters, and returns a long integer indicating success or failure.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_reserve_hdr_opt.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstatic long (* const bpf_reserve_hdr_opt)(struct bpf_sock_ops *skops, __u32 len, __u64 flags) = (void *) 144;\n```\n\n----------------------------------------\n\nTITLE: Defining btf__add_type_attr function in C\nDESCRIPTION: This snippet shows the function signature for the btf__add_type_attr function from the libbpf library. It takes a btf structure pointer, a string value, and an integer reference type ID as parameters, and returns an integer result.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/btf__add_type_attr.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nint btf__add_type_attr(struct btf *btf, const char *value, int ref_type_id);\n```\n\n----------------------------------------\n\nTITLE: Definition of btf__add_func Function in C\nDESCRIPTION: The function signature for btf__add_func which appends a new BTF_KIND_FUNC type to a BTF object. It takes parameters for the BTF object, function name, linkage type, and prototype type ID.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/btf__add_func.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nint btf__add_func(struct btf *btf, const char *name, enum btf_func_linkage linkage, int proto_type_id);\n```\n\n----------------------------------------\n\nTITLE: Defining ring__avail_data_size Function in C\nDESCRIPTION: Function signature for ring__avail_data_size, which takes a const struct ring pointer and returns a size_t representing the number of unconsumed bytes in the ring buffer.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/ring__avail_data_size.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nsize_t ring__avail_data_size(const struct ring *r);\n```\n\n----------------------------------------\n\nTITLE: Defining btf__new function in C for creating BTF object from raw data\nDESCRIPTION: This function creates a new BTF object instance from raw bytes of an ELF's BTF section. It takes a pointer to the raw data and its size as parameters, returning a new BTF object that must be freed with btf__free when no longer needed.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/btf__new.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstruct btf *btf__new(const void *data, __u32 size);\n```\n\n----------------------------------------\n\nTITLE: Defining btf__new_split function in C\nDESCRIPTION: Function signature for btf__new_split, which creates a new BTF object instance from raw data bytes and a base BTF object. It returns a new BTF object or an error code encoded as a pointer.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/btf__new_split.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstruct btf *btf__new_split(const void *data, __u32 size, struct btf *base_btf);\n```\n\n----------------------------------------\n\nTITLE: KFunc Definition for DSQ Iterator Progression in C\nDESCRIPTION: Function signature for bpf_iter_scx_dsq_next kfunc that takes a DSQ iterator pointer and returns the next task struct pointer. The returned pointer requires NULL checking before use.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/bpf_iter_scx_dsq_next.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstruct task_struct *bpf_iter_scx_dsq_next(struct bpf_iter_scx_dsq *it)\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_object__unpin function in C\nDESCRIPTION: This code snippet defines the 'bpf_object__unpin' function from the libbpf library. It takes a pointer to a BPF object and a path string as parameters, and returns an integer status code.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_object__unpin.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nint bpf_object__unpin(struct bpf_object *object, const char *path);\n```\n\n----------------------------------------\n\nTITLE: Merged and Resolved Type Information Example in C\nDESCRIPTION: This code shows the result of BTF deduplication, where partial type information from different compilation units is merged into complete type definitions for all structures.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/btf__dedup.md#2025-04-22_snippet_2\n\nLANGUAGE: c\nCODE:\n```\nstruct A {\n\tint a;\n\tstruct A* self;\n\tstruct S* parent;\n};\nstruct B {\n\tint b;\n\tstruct B* self;\n\tstruct S* parent;\n};\nstruct S {\n\tstruct A* a_ptr;\n\tstruct B* b_ptr;\n};\n```\n\n----------------------------------------\n\nTITLE: Defining btf__add_var function in C\nDESCRIPTION: This snippet defines the btf__add_var function, which appends a new BTF_KIND_VAR type to a BTF object. It takes parameters for the BTF object, variable name, linkage type, and type ID. The function returns a positive type ID on success or a negative value on error.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/btf__add_var.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nint btf__add_var(struct btf *btf, const char *name, int linkage, int type_id);\n```\n\n----------------------------------------\n\nTITLE: Definition of ring_buffer__consume function in libbpf\nDESCRIPTION: Specifies the C function signature for ring_buffer__consume, which takes a ring buffer manager pointer and returns the number of records consumed or an error code.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/ring_buffer__consume.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nint ring_buffer__consume(struct ring_buffer *rb);\n```\n\n----------------------------------------\n\nTITLE: Defining the 'likely' Macro in C for eBPF Optimization\nDESCRIPTION: The 'likely' macro definition that wraps the __builtin_expect compiler hint. It tells the compiler that the expression will most probably evaluate to true, allowing optimization of instruction placement.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/scx/likely.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n#define likely(x) __builtin_expect(!!(x), 1)\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_attr Structure for BPF_LINK_CREATE\nDESCRIPTION: Defines the union bpf_attr structure used in the BPF_LINK_CREATE syscall command in C. It specifies fields such as prog_fd, map_fd, target_fd, target_ifindex, attach_type, flags, and several context-dependent sub-structures. Essential for users seeking to attach eBPF programs using the BPF_LINK_CREATE command, this code requires familiarity with C programming and Linux kernel concepts.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/syscall/BPF_LINK_CREATE.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n#pragma once\nunion bpf_attr {\n\tstruct {\n\t\tunion {\n\t\t\t__u32\tprog_fd;\n\t\t\t__u32\tmap_fd;\n\t\t};\n\t\tunion {\n\t\t\t__u32\ttarget_fd;\n\t\t\t__u32\ttarget_ifindex;\n\t\t};\n\t\t__u32\t\tattach_type;\n\t\t__u32\t\tflags;\n\t\tunion {\n\t\t\t__u32\ttarget_btf_id;\n\t\t\tstruct {\n\t\t\t\t__aligned_u64\titer_info;\n\t\t\t\t__u32\t\titer_info_len;\n\t\t\t};\n\t\t\tstruct {\n\t\t\t\t[...]\n\t\t\t} perf_event;\n\t\t\tstruct {\n\t\t\t\t[...]\n\t\t\t} kprobe_multi;\n\t\t\tstruct {\n\t\t\t\t// Additional structs\n\t\t\t} tracing;\n\t\t\tstruct {\n\t\t\t\t[...]\n\t\t\t} netfilter;\n\t\t\tstruct {\n\t\t\t\t[...]\n\t\t\t} tcx;\n\t\t\tstruct {\n\t\t\t\t[...]\n\t\t\t} uprobe_multi;\n\t\t\tstruct {\n\t\t\t\t[...]\n\t\t\t} netkit;\n\t\t};\n\t} link_create;\n};\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_rc_repeat Helper Function in C\nDESCRIPTION: This code snippet defines the bpf_rc_repeat helper function for use in eBPF programs. It takes a void pointer ctx as an argument and returns a long integer. The function is specifically used for IR decoding in programs implementing the BPF_PROG_TYPE_LIRC_MODE2 program type.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_rc_repeat.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstatic long (* const bpf_rc_repeat)(void *ctx) = (void *) 77;\n```\n\n----------------------------------------\n\nTITLE: Using bpf_ringbuf_discard in eBPF Program\nDESCRIPTION: Example of using bpf_ringbuf_discard in an eBPF program. It demonstrates reserving space in the ring buffer, discarding the reserved data if certain conditions are met, and submitting the data otherwise.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_ringbuf_discard.md#2025-04-22_snippet_1\n\nLANGUAGE: c\nCODE:\n```\n// Reserve space in the ring buffer\nstruct ringbuf_data *rb_data = bpf_ringbuf_reserve(&my_ringbuf, sizeof(struct ringbuf_data), 0);\nif(!rb_data) {\n    // if bpf_ringbuf_reserve fails, print an error message and return\n    bpf_printk(\"bpf_ringbuf_reserve failed\\n\");\n    return 1;\n}\n\nif(unhappy_flow) {\n    // Discard the reserved data\n    bpf_ringbuf_discard(rb_data, 0);\n    return 1;\n}\n\n// Submit the reserved data\nbpf_ringbuf_submit(rb_data, 0);\n```\n\n----------------------------------------\n\nTITLE: Defining the bpf_map__btf_value_type_id libbpf Function (C)\nDESCRIPTION: This C code snippet shows the function definition for `bpf_map__btf_value_type_id`. This libbpf function takes a constant pointer to a `bpf_map` struct as input (`map`) and returns the BTF type ID (`__u32`) associated with the map's value type. If no BTF type ID is available for the map's value, it returns 0. This function requires the libbpf library headers.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_map__btf_value_type_id.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n__u32 bpf_map__btf_value_type_id(const struct bpf_map *map);\n```\n\n----------------------------------------\n\nTITLE: Function Definition of bpf_object__destroy_subskeleton in C\nDESCRIPTION: The C function signature for bpf_object__destroy_subskeleton, which takes a pointer to a bpf_object_subskeleton structure and destroys the resources associated with it. This function doesn't return a value.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_object__destroy_subskeleton.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nvoid bpf_object__destroy_subskeleton(struct bpf_object_subskeleton *s);\n```\n\n----------------------------------------\n\nTITLE: System Control Stack Depth Configuration\nDESCRIPTION: Command to modify the maximum stack depth for performance events using sysctl.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_get_stackid.md#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n# sysctl kernel.perf_event_max_stack=<new value>\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_core_read Macro in C\nDESCRIPTION: Defines the bpf_core_read macro, which simplifies kernel memory reads in eBPF programs by wrapping bpf_probe_read_kernel with offset relocation capabilities. The macro expects a destination, size, and a source expression as parameters, facilitating safer and more adaptable memory reads across different kernel versions.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/ebpf/bpf_core_read.md#2025-04-22_snippet_0\n\nLANGUAGE: C\nCODE:\n```\n#define bpf_core_read(dst, sz, src)\\n\\tbpf_probe_read_kernel(dst, sz, (const void *)__builtin_preserve_access_index(src))\n```\n\n----------------------------------------\n\nTITLE: Definition of bpf_rbtree_first KFunc in C\nDESCRIPTION: The C function signature for the bpf_rbtree_first kernel function that returns the leftmost node in a red-black tree. It takes a pointer to a bpf_rb_root structure and returns a pointer to a bpf_rb_node which may be NULL if the tree is empty.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/bpf_rbtree_first.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstruct bpf_rb_node *bpf_rbtree_first(struct bpf_rb_root *root)\n```\n\n----------------------------------------\n\nTITLE: Defining the bpf_iter_bits_next KFunc in C\nDESCRIPTION: Function signature for the 'bpf_iter_bits_next' eBPF kernel function that returns a pointer to the next bit in a bpf_iter_bits structure. It returns NULL if no further bits are available, requiring a NULL check before usage.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/bpf_iter_bits_next.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nint *bpf_iter_bits_next(struct bpf_iter_bits *it)\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_cpumask_subset KFunc in C\nDESCRIPTION: The function definition for the bpf_cpumask_subset kernel function. It takes two cpumask pointers and returns a boolean indicating whether all bits in the first mask are also set in the second mask.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/bpf_cpumask_subset.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nbool bpf_cpumask_subset(const struct cpumask *src1, const struct cpumask *src2)\n```\n\n----------------------------------------\n\nTITLE: Initializing BPF Linker with Libbpf (C)\nDESCRIPTION: Declares the API function for creating a new BPF linker object using Libbpf. This function, 'bpf_linker__new', takes a filename for the ELF file and a pointer to an options struct, returning a pointer to a BPF linker instance. Dependencies include Libbpf headers and the structure definition for 'bpf_linker_opts'. The function facilitates static linking of BPF objects into a single output file. Inputs are the destination filename and an optional options structure; output is a pointer to a BPF linker object or NULL on failure.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_linker__new.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstruct bpf_linker *bpf_linker__new(const char *filename, struct bpf_linker_opts *opts);\n```\n\n----------------------------------------\n\nTITLE: Definition of bpf_perf_event_opts Structure in C\nDESCRIPTION: The structure definition for bpf_perf_event_opts which provides additional options when attaching a BPF program to a perf event. It includes fields for struct size, a BPF cookie value, and a flag to force ioctl attach method.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_program__attach_perf_event_opts.md#2025-04-22_snippet_1\n\nLANGUAGE: c\nCODE:\n```\nstruct bpf_perf_event_opts {\n\t/* size of this struct, for forward/backward compatibility */\n\tsize_t sz;\n\t__u64 bpf_cookie;\n\tbool force_ioctl_attach;\n\tsize_t :0;\n};\n```\n\n----------------------------------------\n\nTITLE: KF_RCU_PROTECTED Flag Documentation\nDESCRIPTION: Flag indicating that a KFunc can only be used within an RCU critical section.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/concepts/kfuncs.md#2025-04-22_snippet_10\n\nLANGUAGE: markdown\nCODE:\n```\nKF_RCU_PROTECTED\n```\n\n----------------------------------------\n\nTITLE: Definition of bpf_obj_new_impl KFunc in C\nDESCRIPTION: Function signature for the bpf_obj_new_impl kernel function that allocates an object of a specified type. The function takes a local_type_id parameter which must be a constant and a meta parameter that's handled by the verifier.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/bpf_obj_new_impl.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nvoid *bpf_obj_new_impl(u64 local_type_id__k, void *meta__ign)\n```\n\n----------------------------------------\n\nTITLE: Definition of bpf_iter_kmem_cache_new KFunc in C\nDESCRIPTION: Function signature for the bpf_iter_kmem_cache_new kfunc that initializes an iterator for slab caches. Takes a pointer to a stack allocated struct bpf_iter_kmem_cache and returns an integer status code.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/bpf_iter_kmem_cache_new.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nint bpf_iter_kmem_cache_new(struct bpf_iter_kmem_cache *it)\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_object__detach_skeleton Function in C\nDESCRIPTION: Function definition for bpf_object__detach_skeleton that takes a bpf_object_skeleton pointer as parameter and detaches the skeleton's programs from the kernel. This function was introduced in libbpf version 0.0.7.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_object__detach_skeleton.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nvoid bpf_object__detach_skeleton(struct bpf_object_skeleton *s);\n```\n\n----------------------------------------\n\nTITLE: Function Signature for perf_buffer__consume_buffer in C\nDESCRIPTION: The function signature for perf_buffer__consume_buffer, which consumes data from a specific slot in a perf buffer without waiting. It takes a perf buffer manager pointer and a buffer index, returning 0 on success or a negative value on failure.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/perf_buffer__consume_buffer.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nint perf_buffer__consume_buffer(struct perf_buffer *pb, size_t buf_idx);\n```\n\n----------------------------------------\n\nTITLE: Defining btf_ext__endianness function in C\nDESCRIPTION: Function definition for btf_ext__endianness, which returns the endianness of a BTF extension object. It takes a const struct btf_ext pointer as input and returns an enum btf_endianness value.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/btf_ext__endianness.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nenum btf_endianness btf_ext__endianness(const struct btf_ext *btf_ext);\n```\n\n----------------------------------------\n\nTITLE: Defining user_ring_buffer__reserve function in C\nDESCRIPTION: This snippet shows the function signature for user_ring_buffer__reserve. It takes a pointer to a user ring buffer and a size parameter, returning a void pointer to the reserved space or NULL on failure.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/user_ring_buffer__reserve.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nvoid *user_ring_buffer__reserve(struct user_ring_buffer *rb, __u32 size);\n```\n\n----------------------------------------\n\nTITLE: Defining btf__load_from_kernel_by_id Function in C\nDESCRIPTION: Function signature for btf__load_from_kernel_by_id. It takes a 32-bit unsigned integer as the BTF object ID and returns a pointer to a struct btf object. The function loads a BTF object from the kernel based on the provided ID.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/btf__load_from_kernel_by_id.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstruct btf *btf__load_from_kernel_by_id(__u32 id);\n```\n\n----------------------------------------\n\nTITLE: Example of Compilation Units with Incomplete Type Information in C\nDESCRIPTION: This code demonstrates how different compilation units can have incomplete but overlapping type information that the BTF deduplication algorithm handles. It shows two units with partial information about structs S, A, and B.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/btf__dedup.md#2025-04-22_snippet_1\n\nLANGUAGE: c\nCODE:\n```\n// CU #1:\nstruct S;\nstruct A {\n\tint a;\n\tstruct A* self;\n\tstruct S* parent;\n};\nstruct B;\nstruct S {\n\tstruct A* a_ptr;\n\tstruct B* b_ptr;\n};\n\n// CU #2:\nstruct S;\nstruct A;\nstruct B {\n\tint b;\n\tstruct B* self;\n\tstruct S* parent;\n};\nstruct S {\n\tstruct A* a_ptr;\n\tstruct B* b_ptr;\n};\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_prog_attach_opts struct in C\nDESCRIPTION: Structure definition for bpf_prog_attach_opts, which contains options for configuring the BPF program attachment. It includes fields for flags, replacement program file descriptor, and relative positioning.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_prog_attach_opts.md#2025-04-22_snippet_1\n\nLANGUAGE: c\nCODE:\n```\nstruct bpf_prog_attach_opts {\n\tsize_t sz; /* size of this struct for forward/backward compatibility */\n\t__u32 flags;\n\tunion {\n\t\tint replace_prog_fd;\n\t\tint replace_fd;\n\t};\n\tint relative_fd;\n\t__u32 relative_id;\n\t__u64 expected_revision;\n\tsize_t :0;\n};\n```\n\n----------------------------------------\n\nTITLE: Defining TCP State Enums in Linux BPF\nDESCRIPTION: Defines various TCP states used in BPF programs as an enumeration. This includes states like ESTABLISHED, SYN_SENT, and more. These states are essential for managing socket operations in BPF, being sourced from kernel version 4.16.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/program-type/BPF_PROG_TYPE_SOCK_OPS.md#2025-04-22_snippet_2\n\nLANGUAGE: C\nCODE:\n```\nenum {\n\tBPF_TCP_ESTABLISHED = 1,\n\tBPF_TCP_SYN_SENT,\n\tBPF_TCP_SYN_RECV,\n\tBPF_TCP_FIN_WAIT1,\n\tBPF_TCP_FIN_WAIT2,\n\tBPF_TCP_TIME_WAIT,\n\tBPF_TCP_CLOSE,\n\tBPF_TCP_CLOSE_WAIT,\n\tBPF_TCP_LAST_ACK,\n\tBPF_TCP_LISTEN,\n\tBPF_TCP_CLOSING,    /* Now a valid state */\n\tBPF_TCP_NEW_SYN_RECV\n};\n```\n\n----------------------------------------\n\nTITLE: Defining btf__fd function in C for libbpf\nDESCRIPTION: This snippet defines the btf__fd function, which retrieves the file descriptor of a BTF object. It takes a pointer to a struct btf object as a parameter and returns an integer representing the file descriptor or a negative error code.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/btf__fd.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nint btf__fd(const struct btf *btf);\n```\n\n----------------------------------------\n\nTITLE: Defining btf__add_datasec Function in C\nDESCRIPTION: Function signature for btf__add_datasec which appends a new BTF_KIND_DATASEC type to a BTF object. It takes a BTF object pointer, section name, and byte size as parameters and returns a type ID on success or a negative value on error.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/btf__add_datasec.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nint btf__add_datasec(struct btf *btf, const char *name, __u32 byte_sz);\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_d_path Helper Function in C\nDESCRIPTION: Function definition for bpf_d_path helper that returns full path for a struct path object. Takes path object, buffer and size as parameters. Returns positive length on success or negative value on error.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_d_path.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstatic long (* const bpf_d_path)(struct path *path, char *buf, __u32 sz) = (void *) 147;\n```\n\n----------------------------------------\n\nTITLE: Using bpf_probe_read_kernel in an XDP eBPF Program\nDESCRIPTION: This eBPF program demonstrates the usage of 'bpf_probe_read_kernel' to access global kernel variables and variables from a loadable kernel module. It reads 'jiffies' and 'test_kmod_var' and prints their values.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_probe_read_kernel.md#2025-04-22_snippet_2\n\nLANGUAGE: c\nCODE:\n```\n#include \"vmlinux.h\"\n#include <bpf/bpf_helpers.h>\n#include \"bpf_tracing_net.h\"\n\nextern const void test_kmod_var __ksym;\nextern const void jiffies __ksym;\n\nSEC(\"xdp\")\nint xdp_test(struct xdp_md *xdp) {\n\n\tu64 kernel_jiffies;\n\tu32 loadable_kmod_var;\n\n\tbpf_probe_read_kernel(&kernel_jiffies, 8, &jiffies);\n\n\tbpf_printk(\">>> %s: Can access jiffies=%lu\\n\", __func__, kernel_jiffies);\n\n\tbpf_probe_read_kernel(&loadable_kmod_var, 4, &test_kmod_var);\n\n\tbpf_printk(\">>> %s: Can also access test_kmod_var=%lu\\n\", __func__, loadable_kmod_var);\n\n\treturn XDP_PASS;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_object__attach_skeleton Function in C\nDESCRIPTION: Function definition for bpf_object__attach_skeleton which takes a bpf_object_skeleton pointer as parameter and returns an integer status code. This function automatically attaches programs in the skeleton to appropriate kernel hooks based on their sections.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_object__attach_skeleton.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nint bpf_object__attach_skeleton(struct bpf_object_skeleton *s);\n```\n\n----------------------------------------\n\nTITLE: Defining '__uint' Macro for Unsigned Integer Properties in C\nDESCRIPTION: This snippet shows the definition of the '__uint' macro used in libbpf eBPF. It defines unsigned integer properties as pointers to arrays, where the array size represents the actual integer value.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/ebpf/__uint.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n#define __uint(name, val) int (*name)[val]\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_msg_pull_data Helper Function in C\nDESCRIPTION: This code snippet defines the 'bpf_msg_pull_data' eBPF helper function. It takes a pointer to sk_msg_md, start and end offsets, and flags as parameters. The function pulls non-linear data from user space for socket policies and returns 0 on success or a negative error code on failure.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_msg_pull_data.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstatic long (* const bpf_msg_pull_data)(struct sk_msg_md *msg, __u32 start, __u32 end, __u64 flags) = (void *) 63;\n```\n\n----------------------------------------\n\nTITLE: Defining the bpf_cgroup_from_id KFunc Signature in C\nDESCRIPTION: This C code defines the signature for the eBPF kfunc `bpf_cgroup_from_id`. It takes a 64-bit unsigned integer `cgid` (cgroup ID) as input and returns a pointer to a `struct cgroup`. The returned pointer represents the cgroup associated with the given ID. Important considerations include that the returned pointer is reference-counted and must be explicitly released using `bpf_cgroup_release` or transferred to a map via `bpf_kptr_xchg`, and it might be NULL, requiring a check before use.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/bpf_cgroup_from_id.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n`#!c struct cgroup *bpf_cgroup_from_id(u64 cgid)`\n```\n\n----------------------------------------\n\nTITLE: Function Definition for bpf_map_get_fd_by_id in C\nDESCRIPTION: Function prototype for bpf_map_get_fd_by_id that takes a 32-bit unsigned integer map ID and returns an integer file descriptor. The function returns a negative error code on failure.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_map_get_fd_by_id.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nint bpf_map_get_fd_by_id(__u32 id);\n```\n\n----------------------------------------\n\nTITLE: Defining the 'bpf_usdt_arg_size' eBPF Helper Function in C\nDESCRIPTION: This snippet shows the C definition of the static inline eBPF helper function 'bpf_usdt_arg_size'. It takes the register context 'ctx' and a zero-indexed argument number 'arg_num' as input. The function returns the size in bytes of the specified USDT argument or a negative error code if the argument is not found or 'arg_num' is invalid. Its functionality depends on maps populated by the loader, typically using 'bpf_program__attach_usdt'.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/ebpf/bpf_usdt_arg_size.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstatic [__always_inline](__always_inline.md)\nint bpf_usdt_arg_size(struct pt_regs *ctx, __u64 arg_num)\n```\n\n----------------------------------------\n\nTITLE: Using ARRAY_ELEM_PTR in a BPF Program for CPU Tracking\nDESCRIPTION: This example demonstrates how to use the ARRAY_ELEM_PTR macro in a BPF program to safely access an element in a resizable array. The macro verifies the pointer is valid before allowing access to the array element.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/scx/ARRAY_ELEM_PTR.md#2025-04-22_snippet_1\n\nLANGUAGE: c\nCODE:\n```\n/* SPDX-License-Identifier: GPL-2.0 */\n/* Copyright (c) 2022 Meta Platforms, Inc. and affiliates.\n * Copyright (c) 2022 Tejun Heo <tj@kernel.org>\n * Copyright (c) 2022 David Vernet <dvernet@meta.com>\n */\n\nu64 [RESIZABLE_ARRAY](RESIZABLE_ARRAY.md)(data, cpu_started_at);\n\nvoid [BPF_STRUCT_OPS](BPF_STRUCT_OPS.md)(central_running, struct task_struct *p)\n{\n    s32 cpu = [scx_bpf_task_cpu](../../linux/kfuncs/scx_bpf_task_cpu.md)(p);\n    u64 *started_at = ARRAY_ELEM_PTR(cpu_started_at, cpu, nr_cpu_ids);\n    if (started_at)\n        *started_at = [scx_bpf_now](../../linux/kfuncs/scx_bpf_now.md)() ?: 1;\t/* 0 indicates idle */\n}\n```\n\n----------------------------------------\n\nTITLE: Defining scx_bpf_error_bstr KFunc in C\nDESCRIPTION: Function signature for the scx_bpf_error_bstr kernel function that handles fatal errors in BPF scheduler. Takes a format string, data buffer pointer, and size parameter for error reporting.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/scx_bpf_error_bstr.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nvoid scx_bpf_error_bstr(char *fmt, long long unsigned int *data, u32 data__sz)\n```\n\n----------------------------------------\n\nTITLE: Definition of bpf_map_sum_elem_count Kernel Function in C\nDESCRIPTION: The function signature for the bpf_map_sum_elem_count kernel function that returns the sum of a map's per-CPU element counters as a signed 64-bit integer. The function takes a constant pointer to a bpf_map structure as its only parameter.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/bpf_map_sum_elem_count.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\ns64 bpf_map_sum_elem_count(const struct bpf_map *map)\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_msg_apply_bytes Helper Function in C\nDESCRIPTION: Function prototype for the bpf_msg_apply_bytes eBPF helper. It applies the verdict of the eBPF program to a specified number of bytes of a message.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_msg_apply_bytes.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstatic long (* const bpf_msg_apply_bytes)(struct sk_msg_md *msg, __u32 bytes) = (void *) 61;\n```\n\n----------------------------------------\n\nTITLE: Definition of libbpf_bpf_map_type_str Function in C\nDESCRIPTION: This function takes a bpf_map_type enum value and returns a pointer to a static string representing the map type. It returns NULL for unknown map type values.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/libbpf_bpf_map_type_str.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nconst char *libbpf_bpf_map_type_str(enum bpf_map_type t);\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_cgroup_release in C\nDESCRIPTION: Defines the signature for `bpf_cgroup_release`, a kernel function used within eBPF programs to release a reference on a cGroup. It ensures safe release by delaying freeing until the end of a grace period when used in an RCU read region. The function takes a `struct cgroup *cgrp` as its parameter and invalidates all copies of the pointer upon release.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/bpf_cgroup_release.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n#!c void bpf_cgroup_release(struct cgroup *cgrp)\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_ima_inode_hash Helper Function in C\nDESCRIPTION: This code snippet defines the 'bpf_ima_inode_hash' eBPF helper function. It retrieves the stored IMA hash of an inode if available, with size limitations for the copied data. The function returns the hash algorithm on success, or error codes for specific failure conditions.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_ima_inode_hash.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstatic long (* const bpf_ima_inode_hash)(struct inode *inode, void *dst, __u32 size) = (void *) 161;\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_ringbuf_discard_dynptr Helper Function in C\nDESCRIPTION: This code snippet defines the 'bpf_ringbuf_discard_dynptr' helper function for eBPF. It discards a reserved ring buffer sample through the dynptr interface, with no effect if the dynptr is invalid or null. The function takes a pointer to a bpf_dynptr structure and a flags parameter.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_ringbuf_discard_dynptr.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstatic void (* const bpf_ringbuf_discard_dynptr)(struct bpf_dynptr *ptr, __u64 flags) = (void *) 200;\n```\n\n----------------------------------------\n\nTITLE: Defining scx_bpf_get_idle_smtmask KFunc in C\nDESCRIPTION: This code snippet defines the signature of the scx_bpf_get_idle_smtmask kfunc. It returns a pointer to a const struct cpumask, which is used for idle tracking of physical cores.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/scx_bpf_get_idle_smtmask.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nconst struct cpumask *scx_bpf_get_idle_smtmask()\n```\n\n----------------------------------------\n\nTITLE: Implementing Work Queue Initialization Example\nDESCRIPTION: Complete example demonstrating how to initialize and use work queues in eBPF programs, including map definitions, callback handling, and queue initialization logic.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/bpf_wq_init.md#2025-04-22_snippet_1\n\nLANGUAGE: c\nCODE:\n```\n/* Copyright (c) 2024 Benjamin Tissoires */\n\n#include <bpf/bpf_helpers.h>\n\nchar _license[] SEC(\"license\") = \"GPL\";\n\nstruct elem {\n    struct bpf_wq w;\n};\n\nstruct {\n    __uint(type, BPF_MAP_TYPE_ARRAY);\n    __uint(max_entries, 2);\n    __type(key, int);\n    __type(value, struct elem);\n} array SEC(\".maps\");\n\n__u32 ok;\n__u32 ok_sleepable;\nvoid bpf_kfunc_common_test(void) __ksym;\n\nstatic int test_elem_callback(void *map, int *key,\n        int (callback_fn)(void *map, int *key, struct bpf_wq *wq))\n{\n    struct elem init = {}, *val;\n    struct bpf_wq *wq;\n\n    if ((ok & (1 << *key) ||\n        (ok_sleepable & (1 << *key))))\n        return -22;\n\n    if (map == &lru &&\n        bpf_map_update_elem(map, key, &init, 0))\n        return -1;\n\n    val = bpf_map_lookup_elem(map, key);\n    if (!val)\n        return -2;\n\n    wq = &val->w;\n    if (bpf_wq_init(wq, map, 0) != 0)\n        return -3;\n\n    if (bpf_wq_set_callback(wq, callback_fn, 0))\n        return -4;\n\n    if (bpf_wq_start(wq, 0))\n        return -5;\n\n    return 0;\n}\n\n/* callback for non sleepable workqueue */\nstatic int wq_callback(void *map, int *key, struct bpf_wq *work)\n{\n    bpf_kfunc_common_test();\n    ok |= (1 << *key);\n    return 0;\n}\n\nSEC(\"tc\")\nlong test_call_array_sleepable(void *ctx)\n{\n    int key = 0;\n\n    return test_elem_callback(&array, &key, wq_cb_sleepable);\n}\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_program__attach_tracepoint_opts function in C\nDESCRIPTION: This snippet defines the bpf_program__attach_tracepoint_opts function, which attaches a BPF_PROG_TYPE_TRACEPOINT program with additional options. It takes parameters for the BPF program, tracepoint category, name, and options, returning a reference to the newly created BPF link or NULL on error.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_program__attach_tracepoint_opts.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstruct bpf_link * bpf_program__attach_tracepoint_opts(const struct bpf_program *prog, const char *tp_category, const char *tp_name, const struct bpf_tracepoint_opts *opts);\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_tc_attach_point enum in C\nDESCRIPTION: This enum defines the possible TC attach points, including ingress, egress, and custom.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_tc_query.md#2025-04-22_snippet_2\n\nLANGUAGE: c\nCODE:\n```\nenum bpf_tc_attach_point {\n\tBPF_TC_INGRESS = 1 << 0,\n\tBPF_TC_EGRESS  = 1 << 1,\n\tBPF_TC_CUSTOM  = 1 << 2,\n};\n```\n\n----------------------------------------\n\nTITLE: Defining struct bpf_xdp_attach_opts in C\nDESCRIPTION: Definition of a structure used to specify options when detaching XDP programs. Contains fields for size tracking (sz), file descriptor of old program (old_prog_fd), and padding.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_xdp_detach.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstruct bpf_xdp_attach_opts {\n\tsize_t sz;\n\tint old_prog_fd;\n\tsize_t :0;\n};\n```\n\n----------------------------------------\n\nTITLE: Function Definition for bpf_prog_get_next_id in C\nDESCRIPTION: C function definition for bpf_prog_get_next_id that takes a starting program ID and returns the next program ID. The function returns 0 on success or a negative error code on failure.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_prog_get_next_id.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nint bpf_prog_get_next_id(__u32 start_id, __u32 *next_id);\n```\n\n----------------------------------------\n\nTITLE: Function Definition for btf__add_enum64_value in C\nDESCRIPTION: The C function definition for btf__add_enum64_value which is used to append new enum values to ENUM64 types. It takes parameters for the BTF object, the enum value name, and the integer value for the enumerator.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/btf__add_enum64_value.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nint btf__add_enum64_value(struct btf *btf, const char *name, __u64 value);\n```\n\n----------------------------------------\n\nTITLE: Listing Supported eBPF KFuncs for Socket Filters (Markdown)\nDESCRIPTION: This Markdown snippet displays a list of eBPF KFuncs available for use within socket filter programs. Each KFunc name is linked to its detailed documentation page. The list is presented within an expandable `??? abstract` block and includes comments indicating potential auto-generation (`<!-- [PROG_KFUNC_REF] -->`).\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/program-type/BPF_PROG_TYPE_SOCKET_FILTER.md#2025-04-22_snippet_1\n\nLANGUAGE: markdown\nCODE:\n```\n<!-- [PROG_KFUNC_REF] -->\n??? abstract \"Supported kfuncs\"\n    - [`bpf_arena_alloc_pages`](../kfuncs/bpf_arena_alloc_pages.md)\n    - [`bpf_arena_free_pages`](../kfuncs/bpf_arena_free_pages.md)\n    - [`bpf_cast_to_kern_ctx`](../kfuncs/bpf_cast_to_kern_ctx.md)\n    - [`bpf_copy_from_user_str`](../kfuncs/bpf_copy_from_user_str.md)\n    - [`bpf_dynptr_adjust`](../kfuncs/bpf_dynptr_adjust.md)\n    - [`bpf_dynptr_clone`](../kfuncs/bpf_dynptr_clone.md)\n    - [`bpf_dynptr_from_skb`](../kfuncs/bpf_dynptr_from_skb.md)\n    - [`bpf_dynptr_is_null`](../kfuncs/bpf_dynptr_is_null.md)\n    - [`bpf_dynptr_is_rdonly`](../kfuncs/bpf_dynptr_is_rdonly.md)\n    - [`bpf_dynptr_size`](../kfuncs/bpf_dynptr_size.md)\n    - [`bpf_dynptr_slice`](../kfuncs/bpf_dynptr_slice.md)\n    - [`bpf_dynptr_slice_rdwr`](../kfuncs/bpf_dynptr_slice_rdwr.md)\n    - [`bpf_get_kmem_cache`](../kfuncs/bpf_get_kmem_cache.md)\n    - [`bpf_iter_bits_destroy`](../kfuncs/bpf_iter_bits_destroy.md)\n    - [`bpf_iter_bits_new`](../kfuncs/bpf_iter_bits_new.md)\n    - [`bpf_iter_bits_next`](../kfuncs/bpf_iter_bits_next.md)\n    - [`bpf_iter_css_destroy`](../kfuncs/bpf_iter_css_destroy.md)\n    - [`bpf_iter_css_new`](../kfuncs/bpf_iter_css_new.md)\n    - [`bpf_iter_css_next`](../kfuncs/bpf_iter_css_next.md)\n    - [`bpf_iter_css_task_destroy`](../kfuncs/bpf_iter_css_task_destroy.md)\n    - [`bpf_iter_css_task_new`](../kfuncs/bpf_iter_css_task_new.md)\n    - [`bpf_iter_css_task_next`](../kfuncs/bpf_iter_css_task_next.md)\n    - [`bpf_iter_kmem_cache_destroy`](../kfuncs/bpf_iter_kmem_cache_destroy.md)\n    - [`bpf_iter_kmem_cache_new`](../kfuncs/bpf_iter_kmem_cache_new.md)\n    - [`bpf_iter_kmem_cache_next`](../kfuncs/bpf_iter_kmem_cache_next.md)\n    - [`bpf_iter_num_destroy`](../kfuncs/bpf_iter_num_destroy.md)\n    - [`bpf_iter_num_new`](../kfuncs/bpf_iter_num_new.md)\n    - [`bpf_iter_num_next`](../kfuncs/bpf_iter_num_next.md)\n    - [`bpf_iter_task_destroy`](../kfuncs/bpf_iter_task_destroy.md)\n    - [`bpf_iter_task_new`](../kfuncs/bpf_iter_task_new.md)\n    - [`bpf_iter_task_next`](../kfuncs/bpf_iter_task_next.md)\n    - [`bpf_iter_task_vma_destroy`](../kfuncs/bpf_iter_task_vma_destroy.md)\n    - [`bpf_iter_task_vma_new`](../kfuncs/bpf_iter_task_vma_new.md)\n    - [`bpf_iter_task_vma_next`](../kfuncs/bpf_iter_task_vma_next.md)\n    - [`bpf_local_irq_restore`](../kfuncs/bpf_local_irq_restore.md)\n    - [`bpf_local_irq_save`](../kfuncs/bpf_local_irq_save.md)\n    - [`bpf_map_sum_elem_count`](../kfuncs/bpf_map_sum_elem_count.md)\n    - [`bpf_preempt_disable`](../kfuncs/bpf_preempt_disable.md)\n    - [`bpf_preempt_enable`](../kfuncs/bpf_preempt_enable.md)\n    - [`bpf_rcu_read_lock`](../kfuncs/bpf_rcu_read_lock.md)\n    - [`bpf_rcu_read_unlock`](../kfuncs/bpf_rcu_read_unlock.md)\n    - [`bpf_rdonly_cast`](../kfuncs/bpf_rdonly_cast.md)\n    - [`bpf_wq_init`](../kfuncs/bpf_wq_init.md)\n    - [`bpf_wq_set_callback_impl`](../kfuncs/bpf_wq_set_callback_impl.md)\n    - [`bpf_wq_start`](../kfuncs/bpf_wq_start.md)\n<!-- [/PROG_KFUNC_REF] -->\n```\n\n----------------------------------------\n\nTITLE: Defining BPF_PROBE_READ_USER_INTO macro in C\nDESCRIPTION: This snippet shows the definition of the BPF_PROBE_READ_USER_INTO macro. It uses the ___core_read function with bpf_probe_read_user to read user space memory into a provided destination.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/ebpf/BPF_PROBE_READ_USER_INTO.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n#define BPF_PROBE_READ_USER_INTO(dst, src, a, ...) ({\\n\\t___core_read(bpf_probe_read_user, bpf_probe_read_user,\\t\\t    \\n\\t\\t     dst, (src), a, ##__VA_ARGS__)\\t\\t\\t    \\n})\n```\n\n----------------------------------------\n\nTITLE: C Function Definition - bpf_perf_event_read Helper\nDESCRIPTION: Definition of the bpf_perf_event_read helper function that reads perf event counter values. The function takes a map pointer and flags as parameters and returns the counter value or a negative error code.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_perf_event_read.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstatic __u64 (* const bpf_perf_event_read)(void *map, __u64 flags) = (void *) 22;\n```\n\n----------------------------------------\n\nTITLE: Definition of btf__parse_raw function in libbpf\nDESCRIPTION: Function signature for btf__parse_raw which parses BTF data from a raw file. It takes a file path as input and returns a pointer to a struct btf object that must be freed with btf__free when no longer needed.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/btf__parse_raw.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstruct btf *btf__parse_raw(const char *path);\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_program__attach_perf_event function in C\nDESCRIPTION: This snippet defines the 'bpf_program__attach_perf_event' function from the libbpf library. It takes a BPF program and a perf event file descriptor as parameters and returns a bpf_link structure pointer.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_program__attach_perf_event.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstruct bpf_link * bpf_program__attach_perf_event(const struct bpf_program *prog, int pfd);\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_skc_to_unix_sock Helper Function in C\nDESCRIPTION: This code defines the 'bpf_skc_to_unix_sock' helper function, which dynamically casts a sk pointer to a unix_sock pointer. It returns the casted pointer if valid, or NULL otherwise.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_skc_to_unix_sock.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstatic struct unix_sock *(* const bpf_skc_to_unix_sock)(void *sk) = (void *) 178;\n```\n\n----------------------------------------\n\nTITLE: KF_ITER_NEW Flag Documentation\nDESCRIPTION: Flag indicating that a KFunc initializes an iterator to iterate over objects.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/concepts/kfuncs.md#2025-04-22_snippet_7\n\nLANGUAGE: markdown\nCODE:\n```\nKF_ITER_NEW\n```\n\n----------------------------------------\n\nTITLE: Retrieving Kernel Version from BPF Object in C\nDESCRIPTION: Function prototype for bpf_object__kversion which returns the kernel version associated with a BPF object as an unsigned integer. The version is retrieved from the object's ELF 'version' section or probed at load time.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_object__kversion.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nunsigned int bpf_object__kversion(const struct bpf_object *obj);\n```\n\n----------------------------------------\n\nTITLE: Defining __ksym Macro in C\nDESCRIPTION: The definition of the __ksym macro which creates an attribute that places the variable in the .ksyms section of the eBPF object file.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/ebpf/__ksym.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n#define __ksym __attribute__((section(\".ksyms\")))\n```\n\n----------------------------------------\n\nTITLE: Defining the Key Structure for BPF_MAP_TYPE_CGROUP_STORAGE in C\nDESCRIPTION: This C struct `bpf_cgroup_storage_key` defines the standard 12-byte key format required for the `BPF_MAP_TYPE_CGROUP_STORAGE` eBPF map prior to Linux kernel v5.9. It consists of the cGroup inode ID (`cgroup_inode_id`, 64 bits) and the attachment type (`attach_type`, 32 bits). As mentioned in the surrounding text, kernel v5.9 and later also permit an 8-byte key size, interpreted as just the `cgroup_inode_id`.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/map-type/BPF_MAP_TYPE_CGROUP_STORAGE.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstruct bpf_cgroup_storage_key {\n        __u64 cgroup_inode_id;\n        __u32 attach_type;\n};\n```\n\n----------------------------------------\n\nTITLE: Defining xsk_setup_xdp_prog Function in C\nDESCRIPTION: This snippet shows the function signature for xsk_setup_xdp_prog. It takes an interface index and a pointer to an XSKs map file descriptor as parameters, and returns an integer status code.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libxdp/functions/xsk_setup_xdp_prog.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nint xsk_setup_xdp_prog(int ifindex, int *xsks_map_fd);\n```\n\n----------------------------------------\n\nTITLE: Simplified LPM Key Structure with __u32 Prefix Length\nDESCRIPTION: Alternative approach to defining an LPM key structure without embedding the trie_key struct, demonstrating the essential requirement of having a __u32 prefixlen as the first field.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/map-type/BPF_MAP_TYPE_LPM_TRIE.md#2025-04-22_snippet_2\n\nLANGUAGE: c\nCODE:\n```\nstruct lpm_key {\n\t__u32 prefixlen;\n\t__be32 addr;\n};\n```\n\n----------------------------------------\n\nTITLE: Defining struct bpf_tc_hook in C for TC hook creation\nDESCRIPTION: Definition of the bpf_tc_hook structure used with bpf_tc_hook_create. This structure contains fields for specifying the interface index, attach point, and parent qdisc ID when creating a TC hook.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_tc_hook_create.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstruct bpf_tc_hook {\n\tsize_t sz;\n\tint ifindex;\n\tenum bpf_tc_attach_point attach_point;\n\t__u32 parent;\n\tsize_t :0;\n};\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_iter_task_next KFunc in C\nDESCRIPTION: Function signature for the bpf_iter_task_next kernel function that returns a pointer to task_struct. The function takes a bpf_iter_task pointer as input and returns a possibly NULL pointer that requires validation before use.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/bpf_iter_task_next.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstruct task_struct *bpf_iter_task_next(struct bpf_iter_task *it)\n```\n\n----------------------------------------\n\nTITLE: Defining BPF Attributes for tcx\nDESCRIPTION: The tcx attribute in eBPF is defined in this snippet using a union. It encompasses elements like `relative_fd` and `expected_revision`, which determine how a program is attached relative to others. This structure emphasizes correct ordering, revision management, and kernel version considerations, with dependencies on previous kernel behaviors.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/syscall/BPF_LINK_CREATE.md#2025-04-22_snippet_3\n\nLANGUAGE: C\nCODE:\n```\nunion bpf_attr {\n\tstruct {\n\t\t[...]\n\t\tunion {\n\t\t\tstruct {\n\t\t\t\tunion {\n\t\t\t\t\t__u32\t[relative_fd](#tcx-relative_fd);\n\t\t\t\t\t__u32\t[relative_id](#tcx-relative_id);\n\t\t\t\t};\n\t\t\t\t__u64\t\t[expected_revision](#tcx-expected_revision);\n\t\t\t} tcx;\n\t\t}\n\t}\n}\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_store_hdr_opt Helper Function in C\nDESCRIPTION: This code snippet defines the bpf_store_hdr_opt helper function, which is used to store header options in TCP headers. It takes parameters for the sock operations, buffer to copy from, length, and flags.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_store_hdr_opt.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstatic long (* const bpf_store_hdr_opt)(struct bpf_sock_ops *skops, const void *from, __u32 len, __u64 flags) = (void *) 143;\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_crypto_ctx_release KFunc in C\nDESCRIPTION: Function signature for the bpf_crypto_ctx_release kernel function which releases a previously acquired reference to a BPF crypto context. When the final reference is released, the memory is freed.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/bpf_crypto_ctx_release.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nvoid bpf_crypto_ctx_release(struct bpf_crypto_ctx *ctx)\n```\n\n----------------------------------------\n\nTITLE: Defining and Using bpf_iter_task_vma_new KFunc in C\nDESCRIPTION: This code snippet demonstrates the signature of the bpf_iter_task_vma_new kfunc which is used to create a new task virtual memory area iterator.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/bpf_iter_task_vma_new.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nint bpf_iter_task_vma_new(struct bpf_iter_task_vma *it, struct task_struct *task, u64 addr)\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_raw_tracepoint_opts struct in C\nDESCRIPTION: Structure definition for bpf_raw_tracepoint_opts, which includes fields for struct size, cookie value, and a zero-sized array for compatibility. The cookie field allows attaching the same program to multiple perf events with different values.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_program__attach_raw_tracepoint_opts.md#2025-04-22_snippet_1\n\nLANGUAGE: c\nCODE:\n```\nstruct bpf_raw_tracepoint_opts {\n\tsize_t sz; /* size of this struct for forward/backward compatibility */\n\t__u64 cookie;\n\tsize_t :0;\n};\n```\n\n----------------------------------------\n\nTITLE: Defining BPF Syscall Attachment Options Structure in C\nDESCRIPTION: The structure definition for bpf_ksyscall_opts which allows configuring BPF cookie values and whether to attach as a return probe. The structure includes size information for compatibility and padding.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_program__attach_ksyscall.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstruct bpf_ksyscall_opts {\n\t/* size of this struct, for forward/backward compatibility */\n\tsize_t sz;\n\t__u64 bpf_cookie;\n\tbool retprobe;\n\tsize_t :0;\n};\n```\n\n----------------------------------------\n\nTITLE: Definition of bpf_tc_hook_destroy function in C\nDESCRIPTION: The C function signature for bpf_tc_hook_destroy which takes a pointer to a bpf_tc_hook structure and returns an integer status code. This function destroys a TC hook previously created with bpf_tc_hook_create.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_tc_hook_destroy.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nint bpf_tc_hook_destroy(struct bpf_tc_hook *hook);\n```\n\n----------------------------------------\n\nTITLE: Finding XDP Program by Filename in C\nDESCRIPTION: Function signature for locating an XDP program using filename and section name. The function searches in LIBXDP_OBJECT_PATH (default: /usr/lib/bpf) and returns a struct xdp_program pointer on success or negative error on failure.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libxdp/functions/xdp_program__find_file.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstruct xdp_program *xdp_program__find_file(const char *filename, const char *section_name, struct bpf_object_open_opts *opts);\n```\n\n----------------------------------------\n\nTITLE: Defining btf__add_struct function in C\nDESCRIPTION: Function signature for btf__add_struct, which adds a new struct type to a BTF object. It takes a pointer to a struct btf object, the name of the struct (can be NULL for anonymous structs), and the size of the struct in bytes. Returns the type ID of the newly added BTF type on success, or a negative value on error.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/btf__add_struct.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nint btf__add_struct(struct btf *btf, const char *name, __u32 sz);\n```\n\n----------------------------------------\n\nTITLE: Defining btf__add_str Function in C for BTF String Section Management\nDESCRIPTION: Function signature for btf__add_str which adds a string to the BTF string section. It takes a pointer to a struct btf object and the string to add, returning the offset into the string section on success or a negative value on error.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/btf__add_str.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nint btf__add_str(struct btf *btf, const char *s);\n```\n\n----------------------------------------\n\nTITLE: Using the bpf_for Macro for Numeric Iteration in eBPF\nDESCRIPTION: Demonstrates the simplified bpf_for macro provided by libbpf to create more natural-feeling loops with numeric iterators. This is a wrapper around the numeric iterator functions.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/concepts/loops.md#2025-04-22_snippet_4\n\nLANGUAGE: c\nCODE:\n```\nint v;\n\nbpf_for(v, start, end) {\n    bpf_printk(\"X = %d\", v);\n}\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_xdp_query_opts Structure - C\nDESCRIPTION: Structure definition for bpf_xdp_query_opts used to store XDP program query results. Contains fields for program IDs, attachment mode, feature flags and zero-copy segment information.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_xdp_query.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstruct bpf_xdp_query_opts {\n\tsize_t sz;\n\t__u32 prog_id;\t\t/* output */\n\t__u32 drv_prog_id;\t/* output */\n\t__u32 hw_prog_id;\t/* output */\n\t__u32 skb_prog_id;\t/* output */\n\t__u8 attach_mode;\t/* output */\n\t__u64 feature_flags;\t/* output */\n\t__u32 xdp_zc_max_segs;\t/* output */\n\tsize_t :0;\n};\n```\n\n----------------------------------------\n\nTITLE: C Function Definition for btf__add_field\nDESCRIPTION: Function definition for adding a new field to a STRUCT/UNION type in a BTF object. Takes parameters for the BTF object pointer, field name, type ID, bit offset, and bit size for bitfields.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/btf__add_field.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nint btf__add_field(struct btf *btf, const char *name, int field_type_id, __u32 bit_offset, __u32 bit_size);\n```\n\n----------------------------------------\n\nTITLE: Using xdp_multiprog__close Function in C\nDESCRIPTION: Function signature and usage example for closing XDP multiprog programs. Takes a pointer to xdp_multiprog structure as input and returns void. Used to clean up and close all programs inside a dispatcher program linked to an interface. Returns 0 on success or -EINVAL if arguments are invalid.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libxdp/functions/xdp_multiprog__close.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nvoid xdp_multiprog__close(struct xdp_multiprog *mp);\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_ktime_get_boot_ns Helper Function in C\nDESCRIPTION: This snippet defines the 'bpf_ktime_get_boot_ns' helper function for eBPF programs. It returns the time elapsed since system boot in nanoseconds, including suspended time.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_ktime_get_boot_ns.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstatic __u64 (* const bpf_ktime_get_boot_ns)(void) = (void *) 125;\n```\n\n----------------------------------------\n\nTITLE: Defining SCX_KICK_PREEMPT Flag in C\nDESCRIPTION: Definition of the SCX_KICK_PREEMPT flag used with scx_bpf_kick_cpu to preempt the current task and execute the dispatch path.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/scx_bpf_kick_cpu.md#2025-04-22_snippet_1\n\nLANGUAGE: c\nCODE:\n```\nSCX_KICK_PREEMPT\n```\n\n----------------------------------------\n\nTITLE: Function Definition for btf_ext__get_raw_data in C\nDESCRIPTION: Function prototype for retrieving raw data from a BTF extension object. Takes a btf_ext pointer and size pointer as parameters, returns a void pointer to the raw data.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/btf_ext__get_raw_data.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nconst void *btf_ext__get_raw_data(const struct btf_ext *btf_ext, __u32 *size);\n```\n\n----------------------------------------\n\nTITLE: Defining a Compiler Memory Barrier Macro in C\nDESCRIPTION: Defines the 'barrier' macro to insert a full memory barrier via an empty volatile assembly statement, thereby preventing the compiler from reordering memory operations across the barrier. This macro should be used in C programs, particularly within kernel or eBPF development using libbpf, when explicit instruction ordering is required. No external dependencies are required, but support for inline assembly (via GCC or Clang) is necessary. The macro takes no parameters and does not produce a direct output; it solely affects compiler behavior.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/ebpf/barrier.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n#define barrier() asm volatile(\"\" ::: \"memory\")\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_get_current_task Helper Function in C\nDESCRIPTION: This code snippet defines the 'bpf_get_current_task' helper function, which retrieves a pointer to the current task struct. It is available since Linux kernel version 4.8.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_get_current_task.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstatic __u64 (* const bpf_get_current_task)(void) = (void *) 35;\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_inode_storage_get Helper Function in C\nDESCRIPTION: Function definition for the bpf_inode_storage_get helper that retrieves or creates bpf_local_storage from an inode. The function takes a map pointer, inode pointer, optional initial value pointer, and flags as parameters. Returns a pointer to bpf_local_storage on success or NULL on failure.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_inode_storage_get.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstatic void *(* const bpf_inode_storage_get)(void *map, void *inode, void *value, __u64 flags) = (void *) 145;\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_skb_change_type Helper Function in C\nDESCRIPTION: This code snippet defines the 'bpf_skb_change_type' helper function for eBPF programs. It allows changing the packet type for the packet associated with an sk_buff structure.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_skb_change_type.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstatic long (* const bpf_skb_change_type)(struct __sk_buff *skb, __u32 type) = (void *) 32;\n```\n\n----------------------------------------\n\nTITLE: Defining the bpf_crypto_decrypt KFunc Signature in C\nDESCRIPTION: The formal definition of the bpf_crypto_decrypt kernel function, showing its parameters and return type. It takes a crypto context, source and destination dynptrs, and an optional IV dynptr.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/bpf_crypto_decrypt.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nint bpf_crypto_decrypt(struct bpf_crypto_ctx *ctx, const struct bpf_dynptr *src, const struct bpf_dynptr *dst, const struct bpf_dynptr *siv__nullable)\n```\n\n----------------------------------------\n\nTITLE: BTF Integer Type Function Definition\nDESCRIPTION: Function signature and parameters for btf__add_int, which adds integer type definitions to a BTF object. Takes BTF object pointer, type name, byte size, and encoding flags as parameters.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/btf__add_int.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nint btf__add_int(struct btf *btf, const char *name, size_t byte_sz, int encoding);\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_obj_drop_impl KFunc in C\nDESCRIPTION: Function signature for the bpf_obj_drop_impl kernel function. It takes two parameters: a pointer to the allocated object to be freed and a meta parameter that is rewritten by the verifier. The function frees the storage and destructs any fields requiring destruction.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/bpf_obj_drop_impl.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nvoid bpf_obj_drop_impl(void *p__alloc, void *meta__ign)\n```\n\n----------------------------------------\n\nTITLE: Defining eBPF Helper Function in C\nDESCRIPTION: The snippet defines an eBPF helper function 'bpf_task_storage_delete', which deletes a bpf_local_storage from a task. It returns 0 on success or -ENOENT if the storage cannot be found. The function is statically allocated with a specific address pointer in the kernel space. This function is typically used in multiple eBPF program types.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_task_storage_delete.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstatic long (* const bpf_task_storage_delete)(void *map, struct task_struct *task) = (void *) 157;\n```\n\n----------------------------------------\n\nTITLE: Definition of bpf_prog_linfo__free function in C\nDESCRIPTION: Function signature for bpf_prog_linfo__free which frees a line info object previously allocated by bpf_prog_linfo__new. It takes a pointer to a bpf_prog_linfo struct as its only parameter.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_prog_linfo__free.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nvoid bpf_prog_linfo__free(struct bpf_prog_linfo *prog_linfo);\n```\n\n----------------------------------------\n\nTITLE: Defining the bpf_cpumask_xor KFunc in C\nDESCRIPTION: Function signature for the bpf_cpumask_xor kernel function that performs XOR operations on two CPU-masks. The function takes three parameters: a destination CPU-mask where the result is stored, and two source CPU-masks that are XORed together.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/bpf_cpumask_xor.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nvoid bpf_cpumask_xor(struct bpf_cpumask *dst, const struct cpumask *src1, const struct cpumask *src2)\n```\n\n----------------------------------------\n\nTITLE: Defining eBPF KFunc 'scx_bpf_task_cpu' in C\nDESCRIPTION: This C function returns the CPU associated with a given task. It requires the task as a parameter 'p'. The function signature explains the input and resultant output, and highlights dependencies on the task_struct structure from Linux kernel internals.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/scx_bpf_task_cpu.md#2025-04-22_snippet_0\n\nLANGUAGE: C\nCODE:\n```\ns32 scx_bpf_task_cpu(const struct task_struct *p)\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_get_local_storage Helper Function in C\nDESCRIPTION: This snippet defines the 'bpf_get_local_storage' helper function. It returns a pointer to the local storage area, which is defined by the map argument. The flags parameter is specific to each map type and should be 0 for cgroup local storage.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_get_local_storage.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstatic void *(* const bpf_get_local_storage)(void *map, __u64 flags) = (void *) 81;\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_skc_to_udp6_sock Helper Function in C\nDESCRIPTION: This code snippet defines the 'bpf_skc_to_udp6_sock' eBPF helper function. It dynamically casts a 'sk' pointer to a 'udp6_sock' pointer, returning the cast pointer if valid or NULL otherwise.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_skc_to_udp6_sock.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstatic struct udp6_sock *(* const bpf_skc_to_udp6_sock)(void *sk) = (void *) 140;\n```\n\n----------------------------------------\n\nTITLE: Definition of bpf_object__unpin_maps Function in C\nDESCRIPTION: This C function signature defines bpf_object__unpin_maps, which unpins each map contained within a BPF object found in the passed directory. It takes a pointer to a BPF object and a path string as parameters, and returns 0 on success or a negative error code on failure.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_object__unpin_maps.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nint bpf_object__unpin_maps(struct bpf_object *obj, const char *path);\n```\n\n----------------------------------------\n\nTITLE: Declaring bpf_link_get_fd_by_id_opts in Libbpf (C)\nDESCRIPTION: This code snippet provides the C function prototype for 'bpf_link_get_fd_by_id_opts' as implemented in libbpf. It allows retrieving a file descriptor for a given BPF link ID with configurable options via a pointer to 'struct bpf_get_fd_by_id_opts'. Dependencies include libbpf headers and Linux syscall support for BPF_LINK_GET_FD_BY_ID. The first parameter 'id' specifies the BPF link identifier, while 'opts' points to an options struct. On success, the function returns a non-negative file descriptor; on failure, a negative error code is returned. Requires compatible Linux kernel and libbpf version 1.1.0 or higher.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_link_get_fd_by_id_opts.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n#!c int bpf_link_get_fd_by_id_opts(__u32 id, const struct bpf_get_fd_by_id_opts *opts);\n```\n\n----------------------------------------\n\nTITLE: Function Definition - bpf_program__get_type in C\nDESCRIPTION: Function signature for bpf_program__get_type that returns the type of a BPF program. Takes a const pointer to a bpf_program struct as input and returns an enum bpf_prog_type.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_program__get_type.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nenum bpf_prog_type bpf_program__get_type(const struct bpf_program *prog);\n```\n\n----------------------------------------\n\nTITLE: Using xsk_ring_cons__peek Function in C\nDESCRIPTION: Function signature for checking new packets in a consumer ring. Returns the number of available packets in the ring, which may be less than or equal to the requested number to peek.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libxdp/functions/xsk_ring_cons__peek.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n__u32 xsk_ring_cons__peek(struct xsk_ring_cons *cons, __u32 nb, __u32 *idx);\n```\n\n----------------------------------------\n\nTITLE: Defining btf__set_pointer_size function in C for libbpf\nDESCRIPTION: Function definition for btf__set_pointer_size which allows overriding or setting the pointer size in bytes for a BTF object. The function accepts a BTF structure pointer and the desired pointer size, returning an integer status code. Only pointer sizes of 4 and 8 bytes are supported.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/btf__set_pointer_size.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nint btf__set_pointer_size(struct btf *btf, size_t ptr_sz);\n```\n\n----------------------------------------\n\nTITLE: Defining btf__add_array Function in C\nDESCRIPTION: Function signature for btf__add_array, which appends a new BTF_KIND_ARRAY type to a BTF object. It takes parameters for the BTF object, index type ID, element type ID, and number of elements. Returns the new type ID on success or a negative value on error.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/btf__add_array.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nint btf__add_array(struct btf *btf, int index_type_id, int elem_type_id, __u32 nr_elems);\n```\n\n----------------------------------------\n\nTITLE: Defining the ring__consume_n Function in C for Libbpf Ring Buffer Consumption\nDESCRIPTION: The function signature for ring__consume_n which consumes up to a specified number of items from a ring buffer without event polling. It takes a ring buffer object and the maximum number of items to consume, returning the actual number of items consumed or a negative error code.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/ring__consume_n.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nint ring__consume_n(struct ring *r, size_t n);\n```\n\n----------------------------------------\n\nTITLE: CPU Affinity Setting Operation\nDESCRIPTION: Updates the CPU affinity mask for a task to control which CPUs it can run on.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/program-type/BPF_PROG_TYPE_STRUCT_OPS/sched_ext_ops.md#2025-04-22_snippet_19\n\nLANGUAGE: c\nCODE:\n```\nvoid (*set_cpumask)(struct task_struct *p, const struct cpumask *cpumask);\n```\n\n----------------------------------------\n\nTITLE: Defining btf__add_enum_value Function in C\nDESCRIPTION: Function signature for btf__add_enum_value which appends a new enum value to the current ENUM type. It takes a BTF object, name of the enumerator, and the integer value as parameters. Returns 0 on success or a negative value on error.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/btf__add_enum_value.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nint btf__add_enum_value(struct btf *btf, const char *name, __s64 value);\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_sk_cgroup_id Helper Function in C\nDESCRIPTION: This snippet defines the bpf_sk_cgroup_id helper function, which returns the cgroup v2 id of a given socket. It requires a non-NULL pointer to a socket as input and returns the id or 0 if retrieval fails.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_sk_cgroup_id.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstatic __u64 (* const bpf_sk_cgroup_id)(void *sk) = (void *) 128;\n```\n\n----------------------------------------\n\nTITLE: Task Quiescent State Operation\nDESCRIPTION: Callback when a task becomes not runnable on its CPU due to sleeping, migration or queue removal.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/program-type/BPF_PROG_TYPE_STRUCT_OPS/sched_ext_ops.md#2025-04-22_snippet_15\n\nLANGUAGE: c\nCODE:\n```\nvoid (*quiescent)(struct task_struct *p, u64 deq_flags);\n```\n\n----------------------------------------\n\nTITLE: Task Disable Callback Definition in C\nDESCRIPTION: Callback function signature for disabling BPF scheduling for a task. Takes task struct as parameter.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/program-type/BPF_PROG_TYPE_STRUCT_OPS/sched_ext_ops.md#2025-04-22_snippet_26\n\nLANGUAGE: c\nCODE:\n```\nvoid (*disable)(struct task_struct *p);\n```\n\n----------------------------------------\n\nTITLE: Equivalent BPF_PROBE_READ Usage in eBPF Programs - C\nDESCRIPTION: Shows the alternative way of achieving the same effect as 'BPF_PROBE_READ_INTO' by using 'BPF_PROBE_READ' directly with an explicit destination pointer. It highlights functional equivalence and reinforces the underlying pointer-based nature of both macros. Requires that 'x' and 's' are variables declared and in scope prior to this usage.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/ebpf/BPF_PROBE_READ_INTO.md#2025-04-22_snippet_2\n\nLANGUAGE: c\nCODE:\n```\nint x;\nBPF_PROBE_READ(&x, s, a.b.c, d.e, f, g);\n```\n\n----------------------------------------\n\nTITLE: Implementing a sleepable struct ops program using BPF_STRUCT_OPS_SLEEPABLE\nDESCRIPTION: This example demonstrates the use of the BPF_STRUCT_OPS_SLEEPABLE macro to define a sleepable struct ops program named 'hotplug_cpu_online'. It shows how the macro simplifies the program definition and allows for invoking blocking kfuncs.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/scx/BPF_STRUCT_OPS_SLEEPABLE.md#2025-04-22_snippet_1\n\nLANGUAGE: c\nCODE:\n```\nstatic void exit_from_hotplug(s32 cpu, bool onlining)\n{\n\t/*\n\t * Ignored, just used to verify that we can invoke blocking kfuncs\n\t * from the hotplug path.\n\t */\n\t[scx_bpf_create_dsq](../../linux/kfuncs/scx_bpf_create_dsq.md)(0, -1);\n\n\ts64 code = SCX_ECODE_ACT_RESTART | HOTPLUG_EXIT_RSN;\n\n\tif (onlining)\n\t\tcode |= HOTPLUG_ONLINING;\n\n\t[scx_bpf_exit](scx_bpf_exit.md)(code, \"hotplug event detected (%d going %s)\", cpu,\n\t\t     onlining ? \"online\" : \"offline\");\n}\n\nvoid BPF_STRUCT_OPS_SLEEPABLE(hotplug_cpu_online, s32 cpu)\n{\n\texit_from_hotplug(cpu, true);\n}\n```\n\n----------------------------------------\n\nTITLE: Defining barrier_var Compiler Barrier Macro in C\nDESCRIPTION: This macro defines a variable-specific compiler barrier that prevents optimization and reordering of memory operations for a specific variable. It uses inline assembly to create a volatile instruction that forces the compiler to treat the variable as potentially modified.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/ebpf/barrier_var.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n#define barrier_var(var) asm volatile(\"\" : \"+r\"(var))\n```\n\n----------------------------------------\n\nTITLE: Defining __arg_arena Macro in C\nDESCRIPTION: This snippet defines the '__arg_arena' macro using the 'btf_decl_tag' attribute to tag function arguments.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/ebpf/__arg_arena.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n#define __arg_arena __attribute((btf_decl_tag(\"arg:arena\")))\n```\n\n----------------------------------------\n\nTITLE: Definition of libbpf_prog_type_by_name Function in C\nDESCRIPTION: Function signature for libbpf_prog_type_by_name that resolves BPF program type and attach type from an ELF section name. It takes three parameters: the section name, a pointer to store the program type, and a pointer to store the expected attach type.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/libbpf_prog_type_by_name.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nint libbpf_prog_type_by_name(const char *name, enum bpf_prog_type *prog_type, enum bpf_attach_type *expected_attach_type);\n```\n\n----------------------------------------\n\nTITLE: KFunc Definition for scx_bpf_dsq_move_set_slice\nDESCRIPTION: Function signature showing the declaration of scx_bpf_dsq_move_set_slice kfunc. Takes a DSQ iterator pointer and slice duration in nanoseconds as parameters.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/scx_bpf_dsq_move_set_slice.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nvoid scx_bpf_dsq_move_set_slice(struct bpf_iter_scx_dsq *it__iter, u64 slice)\n```\n\n----------------------------------------\n\nTITLE: Using xsk_umem__get_data in C to retrieve packet data pointers\nDESCRIPTION: Function prototype for xsk_umem__get_data which returns a void pointer to packet data. It takes a memory area pointer and an address as parameters. This function is specifically used in aligned mode for XDP socket operations.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libxdp/functions/xsk_umem__get_data.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nvoid *xsk_umem__get_data(void *umem_area, __u64 addr);\n```\n\n----------------------------------------\n\nTITLE: Definition of bpf_iter_css_destroy KFunc in C\nDESCRIPTION: Function signature for the bpf_iter_css_destroy kfunc that is used to destroy a cGroup iterator object created with bpf_iter_css_new.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/bpf_iter_css_destroy.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nvoid bpf_iter_css_destroy(struct bpf_iter_css *it)\n```\n\n----------------------------------------\n\nTITLE: Definition of btf__base_btf function in Libbpf (C)\nDESCRIPTION: Function signature that retrieves the base BTF object of a BTF object. It takes a pointer to a struct btf object as a parameter and returns a pointer to a struct btf object on success, or NULL if the BTF object has no base.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/btf__base_btf.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nconst struct btf *btf__base_btf(const struct btf *btf);\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_program__set_log_buf Function in C\nDESCRIPTION: Function signature for setting a log buffer for a BPF program. Takes a BPF program pointer, a log buffer, and the size of the buffer as parameters. Returns an error code or 0 on success.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_program__set_log_buf.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nint bpf_program__set_log_buf(struct bpf_program *prog, char *log_buf, size_t log_size);\n```\n\n----------------------------------------\n\nTITLE: Defining dctcp_ssthresh KFunc in C\nDESCRIPTION: Function signature for the dctcp_ssthresh kfunc. It takes a struct sock pointer as an argument and returns a u32 value representing the slow start threshold.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/dctcp_ssthresh.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nu32 dctcp_ssthresh(struct sock *sk)\n```\n\n----------------------------------------\n\nTITLE: Declaring struct bpf_linker_file_opts Options Struct (C)\nDESCRIPTION: This structure defines file options for use with 'bpf_linker__add_file'. The struct currently contains a single field, 'sz', which stores the size of the struct, enabling backward and forward compatibility. Intended as an extension point for additional options in future libbpf versions. All fields should be properly initialized before use.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_linker__add_file.md#2025-04-22_snippet_1\n\nLANGUAGE: c\nCODE:\n```\nstruct bpf_linker_file_opts {\n\t/* size of this struct, for forward/backward compatibility */\n\tsize_t sz;\n};\n```\n\n----------------------------------------\n\nTITLE: Retrieving XDP Program from ID using xdp_program__from_id in C\nDESCRIPTION: This function retrieves the xdp_program associated with a given program ID. It returns a pointer to the xdp_program structure on success, or negative error codes on failure. Possible errors include -ENOENT for non-existent files/directories and -EINVAL for invalid arguments.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libxdp/functions/xdp_program__from_id.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstruct xdp_program *xdp_program__from_id(__u32 prog_id);\n```\n\n----------------------------------------\n\nTITLE: Creating a Shared AF_XDP Socket with xsk_socket__create_shared in C\nDESCRIPTION: Function signature for creating an AF_XDP socket that shares umem ownership among multiple sockets. The function accepts parameters for socket configuration, interface name, queue ID, umem, and various ring buffer pointers (rx, tx, fill, and completion).\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libxdp/functions/xsk_socket__create_shared.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nint xsk_socket__create_shared(struct xsk_socket **xsk_ptr,\n\t\t\t      const char *ifname,\n\t\t\t      __u32 queue_id, struct xsk_umem *umem,\n\t\t\t      struct xsk_ring_cons *rx,\n\t\t\t      struct xsk_ring_prod *tx,\n\t\t\t      struct xsk_ring_prod *fill,\n\t\t\t      struct xsk_ring_cons *comp,\n\t\t\t      const struct xsk_socket_config *config);\n```\n\n----------------------------------------\n\nTITLE: Creating a new BTF extension object with btf_ext__new in C\nDESCRIPTION: Function definition for btf_ext__new which creates a new BTF extension object from raw data. It takes raw BTF extension data and its size as parameters and returns a pointer to the newly created BTF extension object or NULL on failure.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/btf_ext__new.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstruct btf_ext *btf_ext__new(const __u8 *data, __u32 size);\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_tcx_opts Struct in C\nDESCRIPTION: Structure definition for bpf_tcx_opts used to specify options when attaching TC programs. Contains fields for flags, relative file descriptors/IDs, and expected revision numbers.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_program__attach_tcx.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstruct bpf_tcx_opts {\n    /* size of this struct, for forward/backward compatibility */\n    size_t sz;\n    __u32 flags;\n    __u32 relative_fd;\n    __u32 relative_id;\n    __u64 expected_revision;\n    size_t :0;\n};\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_l3_csum_replace Helper Function in C\nDESCRIPTION: This code snippet defines the bpf_l3_csum_replace helper function for eBPF programs. It is used to recompute layer 3 checksums for packets, such as IP checksums. The function takes parameters for the packet buffer, offset, old and new values, and size of the modified field.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_l3_csum_replace.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstatic long (* const bpf_l3_csum_replace)(struct __sk_buff *skb, __u32 offset, __u64 from, __u64 to, __u64 size) = (void *) 10;\n```\n\n----------------------------------------\n\nTITLE: Task Weight Setting Operation\nDESCRIPTION: Updates the scheduling weight of a task within the valid range of 1 to 10000.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/program-type/BPF_PROG_TYPE_STRUCT_OPS/sched_ext_ops.md#2025-04-22_snippet_18\n\nLANGUAGE: c\nCODE:\n```\nvoid (*set_weight)(struct task_struct *p, u32 weight);\n```\n\n----------------------------------------\n\nTITLE: Defining scx_bpf_get_possible_cpumask KFunc in C\nDESCRIPTION: Function signature for the scx_bpf_get_possible_cpumask kernel function that returns a pointer to the CPU possible mask. The returned pointer is reference-counted and must be properly released or transferred to avoid memory leaks.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/scx_bpf_get_possible_cpumask.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nconst struct cpumask *scx_bpf_get_possible_cpumask()\n```\n\n----------------------------------------\n\nTITLE: Defining and Using bpf_iter_create in Libbpf (C)\nDESCRIPTION: Declares the 'bpf_iter_create' function for manually creating an iterator in user space via libbpf. The function requires a valid file descriptor 'link_fd' as input and returns 0 on success or a negative error code on failure. Usage generally assumes prior setup of link objects and file descriptors, with dependency on libbpf and the associated Linux BPF subsystem. Typical invocation is only necessary when precise control is needed, defaulting otherwise to higher-level helpers.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_iter_create.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n#!c int bpf_iter_create(int link_fd);\n```\n\n----------------------------------------\n\nTITLE: Task Enable Callback Definition in C\nDESCRIPTION: Callback function signature for enabling BPF scheduling for a task. Takes task struct as parameter.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/program-type/BPF_PROG_TYPE_STRUCT_OPS/sched_ext_ops.md#2025-04-22_snippet_25\n\nLANGUAGE: c\nCODE:\n```\nvoid (*enable)(struct task_struct *p);\n```\n\n----------------------------------------\n\nTITLE: Specifying Language for Syntax Highlighting in Markdown\nDESCRIPTION: Illustrates how to specify the programming language (in this case, 'c') following the opening triple backticks in a Markdown code block. This enables language-specific syntax highlighting using Pygments via the Material for MkDocs theme.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/meta.md#2025-04-22_snippet_2\n\nLANGUAGE: markdown\nCODE:\n```\n````\n```c\nstruct abc {\n    uint_t some_field;\n};\n```\n````\n```\n\n----------------------------------------\n\nTITLE: Handling DCTCP State Changes in BPF\nDESCRIPTION: This function manages state changes for DCTCP, particularly handling the transition to recovery state after packet loss. It adjusts the congestion window and slow start threshold accordingly.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/program-type/BPF_PROG_TYPE_STRUCT_OPS/tcp_congestion_ops.md#2025-04-22_snippet_18\n\nLANGUAGE: C\nCODE:\n```\nSEC(\"struct_ops\")\nvoid BPF_PROG(bpf_dctcp_state, struct sock *sk, __u8 new_state)\n{\n\tif (new_state == TCP_CA_Recovery &&\n\t    new_state != BPF_CORE_READ_BITFIELD(inet_csk(sk), icsk_ca_state))\n\t\tdctcp_react_to_loss(sk);\n\t/* We handle RTO in bpf_dctcp_cwnd_event to ensure that we perform only\n\t * one loss-adjustment per RTT.\n\t */\n}\n```\n\n----------------------------------------\n\nTITLE: Using xdp_program__print_chain_call_actions Function in C\nDESCRIPTION: This function returns the chain call actions associated with an xdp_program to a provided buffer. It returns 0 on success or a negative error code on failure, such as -EINVAL for invalid arguments.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libxdp/functions/xdp_program__print_chain_call_actions.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nint xdp_program__print_chain_call_actions(const struct xdp_program *prog, char *buf, size_t buf_len);\n```\n\n----------------------------------------\n\nTITLE: Defining the bpf_sysctl_get_name eBPF Helper Function Pointer in C\nDESCRIPTION: This C code snippet defines the function pointer for the eBPF helper function 'bpf_sysctl_get_name'. It specifies the function signature, including parameters like the sysctl context ('ctx'), the output buffer ('buf') and its length ('buf_len'), and flags ('flags'). The helper function is assigned the ID 101, making it callable from eBPF programs. Its purpose is to retrieve the name of a sysctl variable.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_sysctl_get_name.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n#!c static long (* const bpf_sysctl_get_name)(struct bpf_sysctl *ctx, char *buf, unsigned long buf_len, __u64 flags) = (void *) 101;\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_get_hash_recalc Helper Function in C\nDESCRIPTION: Function definition for the bpf_get_hash_recalc helper that retrieves or recomputes a packet's hash value. Returns a 32-bit hash and takes a pointer to __sk_buff structure as input.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_get_hash_recalc.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstatic __u32 (* const bpf_get_hash_recalc)(struct __sk_buff *skb) = (void *) 34;\n```\n\n----------------------------------------\n\nTITLE: Documenting eBPF KFunc Signature in C\nDESCRIPTION: This C code snippet defines the signature of the 'bpf_cpumask_any_and_distribute' function, which returns a random set CPU from the AND of two CPU-masks. It requires two parameters: 'src1' and 'src2', which are pointers to 'struct cpumask'. The function returns a random set bit within the range 0 to 'num_cpus', or a value greater than or equal to 'num_cpus' if no bit is set.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/bpf_cpumask_any_and_distribute.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nu32 bpf_cpumask_any_and_distribute(const struct cpumask *src1, const struct cpumask *src2)\n```\n\n----------------------------------------\n\nTITLE: Using xsk_socket__fd Function in C\nDESCRIPTION: This function retrieves the file descriptor of an XSK socket. It returns 0 on success or a negative error code on failure, with -EINVAL indicating invalid arguments.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libxdp/functions/xsk_socket__fd.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nint xsk_socket__fd(const struct xsk_socket *xsk);\n```\n\n----------------------------------------\n\nTITLE: Defining eBPF KFunction in C\nDESCRIPTION: The snippet defines an eBPF kfunc `bbr_sndbuf_expand` which returns the multiplier used by `tcp_sndbuf_expand`. It accepts a TCP socket structure as its parameter. The function is expected to interact with certain TCP congestion control mechanisms.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/bbr_sndbuf_expand.md#2025-04-22_snippet_0\n\nLANGUAGE: C\nCODE:\n```\n#!c u32 bbr_sndbuf_expand(struct sock *sk)\n```\n\n----------------------------------------\n\nTITLE: Defining Perf Buffer New Raw Function Signature in C\nDESCRIPTION: Function signature for perf_buffer__new_raw that creates a new perf buffer with raw configuration options. Returns a perf_buffer struct pointer on success or NULL on failure.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/perf_buffer__new_raw.md#2025-04-22_snippet_1\n\nLANGUAGE: c\nCODE:\n```\nstruct perf_buffer * perf_buffer__new_raw(int map_fd, size_t page_cnt, struct perf_event_attr *attr, perf_buffer_event_fn event_cb, void *ctx, const struct perf_buffer_raw_opts *opts);\n```\n\n----------------------------------------\n\nTITLE: Using xsk_socket__update_xskmap Function in C\nDESCRIPTION: This code snippet shows the function signature for updating an XSK map with a new AF_XDP socket. It takes a pointer to an xsk_socket structure and the file descriptor of an XSK map as parameters, returning 0 on success or a negative error code on failure.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libxdp/functions/xsk_socket__update_xskmap.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nint xsk_socket__update_xskmap(struct xsk_socket *xsk, int xsks_map_fd);\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_lwt_seg6_adjust_srh Helper Function in C\nDESCRIPTION: This code snippet defines the bpf_lwt_seg6_adjust_srh helper function for adjusting the size allocated to TLVs in the outermost IPv6 Segment Routing Header. It takes a struct __sk_buff pointer, an offset, and a delta value as parameters, and returns a long integer.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_lwt_seg6_adjust_srh.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstatic long (* const bpf_lwt_seg6_adjust_srh)(struct __sk_buff *skb, __u32 offset, __s32 delta) = (void *) 75;\n```\n\n----------------------------------------\n\nTITLE: Using bpf_ktime_get_coarse_ns for Duration Measurement\nDESCRIPTION: Example showing how to measure time duration using bpf_ktime_get_coarse_ns by capturing start and end timestamps.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_ktime_get_coarse_ns.md#2025-04-22_snippet_1\n\nLANGUAGE: c\nCODE:\n```\n__u64 start_time = bpf_ktime_get_coarse_ns();\n/* some tasks */\n__u64 end_time = bpf_ktime_get_coarse_ns();\n__u64 duration = end_time - start_time;\n```\n\n----------------------------------------\n\nTITLE: Definition of bpf_skb_get_tunnel_key Helper Function in C\nDESCRIPTION: This code snippet shows the C definition of the bpf_skb_get_tunnel_key helper function. It takes a pointer to an sk_buff, a pointer to a bpf_tunnel_key struct, the size of the struct, and flags as parameters.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_skb_get_tunnel_key.md#2025-04-22_snippet_1\n\nLANGUAGE: c\nCODE:\n```\nstatic long (* const bpf_skb_get_tunnel_key)(struct __sk_buff *skb, struct bpf_tunnel_key *key, __u32 size, __u64 flags) = (void *) 20;\n```\n\n----------------------------------------\n\nTITLE: Implementing base 2 logarithm calculation for 32-bit values in C\nDESCRIPTION: This function computes the base 2 logarithm of a 32-bit exponential value. It uses bitwise operations and shifts to efficiently calculate the result without using floating-point arithmetic.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/scx/log2_u32.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstatic inline u32 log2_u32(u32 v)\n{\n    u32 r;\n    u32 shift;\n\n    r = (v > 0xFFFF) << 4; v >>= r;\n    shift = (v > 0xFF) << 3; v >>= shift; r |= shift;\n    shift = (v > 0xF) << 2; v >>= shift; r |= shift;\n    shift = (v > 0x3) << 1; v >>= shift; r |= shift;\n    r |= (v >> 1);\n    return r;\n}\n```\n\n----------------------------------------\n\nTITLE: Definition of libbpf_find_kernel_btf Function in C\nDESCRIPTION: Function prototype for libbpf_find_kernel_btf which returns a pointer to a struct btf. This function has been aliased to btf__load_vmlinux_btf as of libbpf v0.5.0.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/libbpf_find_kernel_btf.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstruct btf *libbpf_find_kernel_btf(void);\n```\n\n----------------------------------------\n\nTITLE: Defining BPF_CORE_READ_INTO macro in C\nDESCRIPTION: This snippet shows the definition of the BPF_CORE_READ_INTO macro. It uses the ___core_read function with bpf_core_read as arguments, allowing for variadic macro expansion.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/ebpf/BPF_CORE_READ_INTO.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n#define BPF_CORE_READ_INTO(dst, src, a, ...) ({\\n\\t___core_read(bpf_core_read, bpf_core_read,\\t\\t\\t    \\n\\t\\t     dst, (src), a, ##__VA_ARGS__)\\t\\t\\t    \\n})\n```\n\n----------------------------------------\n\nTITLE: Setting XDP Program Priority in C\nDESCRIPTION: Function signature for setting the execution priority of an XDP program. The priority value determines the order of program execution, with higher values causing later execution. Default priority is 50 if unspecified. Must be called before loading the program into the dispatcher.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libxdp/functions/xdp_program__set_run_prio.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nint xdp_program__set_run_prio(struct xdp_program *xdp_prog, unsigned int run_prio);\n```\n\n----------------------------------------\n\nTITLE: Implementing cGroup Iteration with bpf_iter_css_new in C\nDESCRIPTION: A complete example of using bpf_iter_css_new to iterate over cgroups in different orders. The program demonstrates pre-order, post-order, and ancestor iteration using the BPF_CGROUP_ITER flags. It counts nodes and tracks hierarchy information.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/bpf_iter_css_new.md#2025-04-22_snippet_1\n\nLANGUAGE: c\nCODE:\n```\n// SPDX-License-Identifier: GPL-2.0\n/* Copyright (C) 2023 Chuyi Zhou <zhouchuyi@bytedance.com> */\n\n#include \"vmlinux.h\"\n#include <bpf/bpf_helpers.h>\n#include <bpf/bpf_tracing.h>\n#include \"bpf_misc.h\"\n#include \"bpf_experimental.h\"\n\nchar _license[] SEC(\"license\") = \"GPL\";\n\npid_t target_pid;\nu64 root_cg_id, leaf_cg_id;\nu64 first_cg_id, last_cg_id;\n\nint pre_order_cnt, post_order_cnt, tree_high;\n\nstruct cgroup *bpf_cgroup_from_id(u64 cgid) __ksym;\nvoid bpf_cgroup_release(struct cgroup *p) __ksym;\nvoid bpf_rcu_read_lock(void) __ksym;\nvoid bpf_rcu_read_unlock(void) __ksym;\n\nSEC(\"fentry.s/\" SYS_PREFIX \"sys_getpgid\")\nint iter_css_for_each(const void *ctx)\n{\n\tstruct task_struct *cur_task = bpf_get_current_task_btf();\n\tstruct cgroup_subsys_state *root_css, *leaf_css, *pos;\n\tstruct cgroup *root_cgrp, *leaf_cgrp, *cur_cgrp;\n\n\tif (cur_task->pid != target_pid)\n\t\treturn 0;\n\n\troot_cgrp = bpf_cgroup_from_id(root_cg_id);\n\n\tif (!root_cgrp)\n\t\treturn 0;\n\n\tleaf_cgrp = bpf_cgroup_from_id(leaf_cg_id);\n\n\tif (!leaf_cgrp) {\n\t\tbpf_cgroup_release(root_cgrp);\n\t\treturn 0;\n\t}\n\troot_css = &root_cgrp->self;\n\tleaf_css = &leaf_cgrp->self;\n\tpre_order_cnt = post_order_cnt = tree_high = 0;\n\tfirst_cg_id = last_cg_id = 0;\n\n\tbpf_rcu_read_lock();\n\tbpf_for_each(css, pos, root_css, BPF_CGROUP_ITER_DESCENDANTS_POST) {\n\t\tcur_cgrp = pos->cgroup;\n\t\tpost_order_cnt++;\n\t\tlast_cg_id = cur_cgrp->kn->id;\n\t}\n\n\tbpf_for_each(css, pos, root_css, BPF_CGROUP_ITER_DESCENDANTS_PRE) {\n\t\tcur_cgrp = pos->cgroup;\n\t\tpre_order_cnt++;\n\t\tif (!first_cg_id)\n\t\t\tfirst_cg_id = cur_cgrp->kn->id;\n\t}\n\n\tbpf_for_each(css, pos, leaf_css, BPF_CGROUP_ITER_ANCESTORS_UP)\n\t\ttree_high++;\n\n\tbpf_for_each(css, pos, root_css, BPF_CGROUP_ITER_ANCESTORS_UP)\n\t\ttree_high--;\n\tbpf_rcu_read_unlock();\n\tbpf_cgroup_release(root_cgrp);\n\tbpf_cgroup_release(leaf_cgrp);\n\treturn 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining the __always_inline Macro in C for eBPF Programs\nDESCRIPTION: The macro definition combines the C inline keyword with the GCC/Clang always_inline attribute to strongly hint to the compiler that a function should be inlined.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/ebpf/__always_inline.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n#define __always_inline inline __attribute__((always_inline))\n```\n\n----------------------------------------\n\nTITLE: Definition of bpf_netfilter_opts Structure in C\nDESCRIPTION: Defines the structure used to configure netfilter hook options when attaching a BPF program to a netfilter hook. The structure includes fields for protocol family, hook number, priority, and flags.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_program__attach_netfilter.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstruct bpf_netfilter_opts {\n\t/* size of this struct, for forward/backward compatibility */\n\tsize_t sz;\n\n\t__u32 pf;\n\t__u32 hooknum;\n\t__s32 priority;\n\t__u32 flags;\n};\n```\n\n----------------------------------------\n\nTITLE: Definition of bpf_object__pin function in C\nDESCRIPTION: The function signature for bpf_object__pin which takes a pointer to a BPF object and a directory path where programs should be pinned. It returns 0 on success or a negative error code on failure.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_object__pin.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nint bpf_object__pin(struct bpf_object *object, const char *path);\n```\n\n----------------------------------------\n\nTITLE: Task Dequeue Operation in BPF Scheduler\nDESCRIPTION: Function callback to remove a task from the BPF scheduler. Used when isolating a task for updating scheduling properties.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/program-type/BPF_PROG_TYPE_STRUCT_OPS/sched_ext_ops.md#2025-04-22_snippet_9\n\nLANGUAGE: c\nCODE:\n```\nvoid (*dequeue)(struct task_struct *p, u64 deq_flags);\n```\n\n----------------------------------------\n\nTITLE: KF_TRUSTED_ARGS Flag Documentation\nDESCRIPTION: Flag indicating that pointers passed to KFunc must be valid kernel objects or unmodified BTF objects.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/concepts/kfuncs.md#2025-04-22_snippet_3\n\nLANGUAGE: markdown\nCODE:\n```\nKF_TRUSTED_ARGS\n```\n\n----------------------------------------\n\nTITLE: Adding Forward Declarations with btf__add_fwd Function Definition\nDESCRIPTION: C function definition for btf__add_fwd that adds forward declarations to BTF objects. Takes a BTF object pointer, declaration name, and forward kind as parameters. Returns the new type ID on success or negative value on error.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/btf__add_fwd.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nint btf__add_fwd(struct btf *btf, const char *name, enum btf_fwd_kind fwd_kind);\n```\n\n----------------------------------------\n\nTITLE: CPU Offline Callback Definition in C\nDESCRIPTION: Callback function signature for handling CPU offline events. Takes CPU ID as parameter.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/program-type/BPF_PROG_TYPE_STRUCT_OPS/sched_ext_ops.md#2025-04-22_snippet_37\n\nLANGUAGE: c\nCODE:\n```\nvoid (*cpu_offline)(s32 cpu);\n```\n\n----------------------------------------\n\nTITLE: Accessing BPF Token File Descriptor in C\nDESCRIPTION: Function definition for retrieving a BPF token file descriptor from a BPF object. Takes a pointer to a bpf_object as input and returns either the associated token file descriptor or -1 if not set.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_object__token_fd.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nint bpf_object__token_fd(const struct bpf_object *obj);\n```\n\n----------------------------------------\n\nTITLE: Task Dispatch Operation in BPF Scheduler\nDESCRIPTION: Callback for dispatching tasks from BPF scheduler and/or user DSQs when a CPU's local DSQ is empty.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/program-type/BPF_PROG_TYPE_STRUCT_OPS/sched_ext_ops.md#2025-04-22_snippet_10\n\nLANGUAGE: c\nCODE:\n```\nvoid (*dispatch)(s32 cpu, struct task_struct *prev);\n```\n\n----------------------------------------\n\nTITLE: Example of Using bpf_crypto_encrypt in TC Program\nDESCRIPTION: A complete example showing how to use bpf_crypto_encrypt in a TC (Traffic Control) program to encrypt network packet data using dynamic pointers and a crypto context stored in a map.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/bpf_crypto_encrypt.md#2025-04-22_snippet_1\n\nLANGUAGE: c\nCODE:\n```\n/* Copyright (c) 2024 Meta Platforms, Inc. and affiliates. */\n\n#include \"vmlinux.h\"\n#include \"bpf_tracing_net.h\"\n#include <bpf/bpf_helpers.h>\n#include <bpf/bpf_endian.h>\n#include <bpf/bpf_tracing.h>\n#include \"bpf_misc.h\"\n#include \"bpf_kfuncs.h\"\n\nint bpf_crypto_encrypt(struct bpf_crypto_ctx *ctx, const struct bpf_dynptr *src,\n            const struct bpf_dynptr *dst, const struct bpf_dynptr *iv) __ksym;\n\nstruct __crypto_ctx_value {\n    struct bpf_crypto_ctx __kptr * ctx;\n};\n\nstruct array_map {\n    __uint(type, BPF_MAP_TYPE_ARRAY);\n    __type(key, int);\n    __type(value, struct __crypto_ctx_value);\n    __uint(max_entries, 1);\n} __crypto_ctx_map SEC(\".maps\");\n\nstatic inline struct __crypto_ctx_value *crypto_ctx_value_lookup(void)\n{\n    u32 key = 0;\n\n    return bpf_map_lookup_elem(&__crypto_ctx_map, &key);\n}\n\nconst volatile unsigned int len = 16;\nchar dst[256] = {};\n\nSEC(\"tc\")\nint crypto_encrypt(struct __sk_buff *skb)\n{\n    struct __crypto_ctx_value *v;\n    struct bpf_crypto_ctx *ctx;\n    struct bpf_dynptr psrc, pdst, iv;\n\n    v = crypto_ctx_value_lookup();\n    if (!v) {\n        status = -ENOENT;\n        return 0;\n    }\n\n    ctx = v->ctx;\n    if (!ctx) {\n        status = -ENOENT;\n        return 0;\n    }\n\n    bpf_dynptr_from_skb(skb, 0, &psrc);\n    bpf_dynptr_from_mem(dst, len, 0, &pdst);\n    bpf_dynptr_from_mem(dst, 0, 0, &iv);\n\n    status = bpf_crypto_encrypt(ctx, &psrc, &pdst, &iv);\n    __sync_add_and_fetch(&hits, 1);\n\n    return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Definition of struct btf_type in C\nDESCRIPTION: Structure definition for btf_type which represents BPF Type Format information. It includes name offset, info bits for storing metadata, and a union for size or type reference depending on the kind of type.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/btf__type_by_id.md#2025-04-22_snippet_1\n\nLANGUAGE: c\nCODE:\n```\nstruct btf_type {\n    __u32 name_off;\n    /* \"info\" bits arrangement\n     * bits  0-15: vlen (e.g. # of struct's members)\n     * bits 16-23: unused\n     * bits 24-28: kind (e.g. int, ptr, array...etc)\n     * bits 29-30: unused\n     * bit     31: kind_flag, currently used by\n     *             struct, union, fwd, enum and enum64.\n     */\n    __u32 info;\n    /* \"size\" is used by INT, ENUM, STRUCT, UNION and ENUM64.\n     * \"size\" tells the size of the type it is describing.\n     *\n     * \"type\" is used by PTR, TYPEDEF, VOLATILE, CONST, RESTRICT,\n     * FUNC, FUNC_PROTO, DECL_TAG and TYPE_TAG.\n     * \"type\" is a type_id referring to another type.\n     */\n    union {\n            __u32 size;\n            __u32 type;\n    };\n};\n```\n\n----------------------------------------\n\nTITLE: Enumerating TCP Congestion Algorithm Events with tcp_ca_event (C)\nDESCRIPTION: This enum lists significant kernel-generated network events affecting congestion control implementation state, such as new transmissions, window restarts, completion of recovery, and loss or ECN triggers. Implementers of congestion algorithms use this enum to react to both regular and exceptional packet processing scenarios. Used in callback/event handler APIs.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/program-type/BPF_PROG_TYPE_STRUCT_OPS/tcp_congestion_ops.md#2025-04-22_snippet_13\n\nLANGUAGE: c\nCODE:\n```\nenum tcp_ca_event {\n\tCA_EVENT_TX_START,      // (1)!\n\tCA_EVENT_CWND_RESTART,  // (2)!\n\tCA_EVENT_COMPLETE_CWR,  // (3)!\n\tCA_EVENT_LOSS,          // (4)!\n\tCA_EVENT_ECN_NO_CE,     // (5)!\n\tCA_EVENT_ECN_IS_CE,     // (6)!\n};\n```\n\n----------------------------------------\n\nTITLE: Function Definition for bpf_object__open_mem in C\nDESCRIPTION: The C function signature for bpf_object__open_mem which creates a struct bpf_object by reading BPF objects from a memory buffer containing a valid BPF ELF object file.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_object__open_mem.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstruct bpf_object * bpf_object__open_mem(const void *obj_buf, size_t obj_buf_sz, const struct bpf_object_open_opts *opts);\n```\n\n----------------------------------------\n\nTITLE: Using xsk_ring_prod__submit Function in C\nDESCRIPTION: This snippet shows the function signature for xsk_ring_prod__submit. It submits filled slots to the kernel for processing. The function takes a pointer to xsk_ring_prod structure and the number of slots to submit.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libxdp/functions/xsk_ring_prod__submit.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nvoid xsk_ring_prod__submit(struct xsk_ring_prod *prod, __u32 nb);\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_refcount_acquire macro in C\nDESCRIPTION: This snippet defines the 'bpf_refcount_acquire' macro, which wraps the 'bpf_refcount_acquire_impl' function. It simplifies usage by automatically passing NULL as the second argument.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/scx/bpf_refcount_acquire.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n#define bpf_refcount_acquire(kptr) bpf_refcount_acquire_impl(kptr, NULL)\n```\n\n----------------------------------------\n\nTITLE: Core Scheduling Task Ordering\nDESCRIPTION: Determines execution ordering between two tasks for core scheduling implementation.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/program-type/BPF_PROG_TYPE_STRUCT_OPS/sched_ext_ops.md#2025-04-22_snippet_17\n\nLANGUAGE: c\nCODE:\n```\nbool (*core_sched_before)(struct task_struct *a, struct task_struct *b);\n```\n\n----------------------------------------\n\nTITLE: Loading and Attaching BPF Program using TC in Shell\nDESCRIPTION: This command uses 'tc' to load an ELF file ('program.o') and attach a BPF program ('my_func' section) to the ingress qdisc of the network device 'eth1'. This requires tc and proper privileges to execute. Outputs any errors or confirmations via shell response.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/program-type/BPF_PROG_TYPE_SCHED_CLS.md#2025-04-22_snippet_1\n\nLANGUAGE: Shell\nCODE:\n```\n\"$ tc filter add dev eth1 ingress bpf obj program.o sec my_func\"\n```\n\n----------------------------------------\n\nTITLE: Defining the BTF Dump Options Structure in libbpf\nDESCRIPTION: This code snippet defines the 'btf_dump_opts' structure which is used to configure BTF dumping operations. Currently, it only contains a size field, suggesting it may be extended in future versions while maintaining backward compatibility.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/btf_dump__new.md#2025-04-22_snippet_1\n\nLANGUAGE: c\nCODE:\n```\nstruct btf_dump_opts {\n\tsize_t sz;\n};\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_ringbuf_discard Helper Function in C\nDESCRIPTION: C function definition for the bpf_ringbuf_discard eBPF helper. It takes a void pointer to the data and a 64-bit unsigned integer for flags.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_ringbuf_discard.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstatic void (* const bpf_ringbuf_discard)(void *data, __u64 flags) = (void *) 133;\n```\n\n----------------------------------------\n\nTITLE: Defining the bpf_map__set_ifindex Function Signature (C)\nDESCRIPTION: This C code snippet provides the function definition for `bpf_map__set_ifindex` from the libbpf library. It specifies the function's return type (`int`) and its parameters: a pointer to the BPF map (`struct bpf_map *map`) and the interface index to associate (`__u32 ifindex`). This function is used to link a BPF map to a specific network interface before the map is loaded, which is necessary for features like hardware offloading.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_map__set_ifindex.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n#!c int bpf_map__set_ifindex(struct bpf_map *map, __u32 ifindex);\n```\n\n----------------------------------------\n\nTITLE: Defining BPF_STRUCT_OPS_SLEEPABLE macro for eBPF struct ops programs\nDESCRIPTION: This snippet defines the BPF_STRUCT_OPS_SLEEPABLE macro used for creating sleepable struct ops programs in eBPF. It combines the SEC and BPF_PROG macros to properly place and name the program.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/scx/BPF_STRUCT_OPS_SLEEPABLE.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n#define BPF_STRUCT_OPS_SLEEPABLE(name, args...)   \\\n    [SEC](../libbpf/ebpf/SEC.md)(\"struct_ops.s/\"#name)             \\\n    [BPF_PROG](../libbpf/ebpf/BPF_PROG.md)(name, ##args)\n```\n\n----------------------------------------\n\nTITLE: Detaching XDP Programs from Dispatcher using xdp_multiprog__detach in C\nDESCRIPTION: Function signature for xdp_multiprog__detach which detaches programs inside an XDP dispatcher without closing them. Returns 0 on success or a negative error code on failure.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libxdp/functions/xdp_multiprog__detach.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nint xdp_multiprog__detach(struct xdp_multiprog *mp, int ifindex);\n```\n\n----------------------------------------\n\nTITLE: BPF Link Info Structure Definition in C\nDESCRIPTION: Defines the bpf_link_info structure that contains information about BPF links. The structure includes general link information and union fields specific to different link types like tracepoints, cgroups, iterators, network namespaces, and XDP.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/syscall/BPF_OBJ_GET_INFO_BY_FD.md#2025-04-22_snippet_4\n\nLANGUAGE: c\nCODE:\n```\nstruct bpf_link_info {\n    __u32 type;\n    __u32 id;\n    __u32 prog_id;\n    union {\n        struct {\n            __aligned_u64 tp_name; /* in/out: tp_name buffer ptr */\n            __u32 tp_name_len;     /* in/out: tp_name buffer len */\n        } raw_tracepoint;\n        struct {\n            __u32 attach_type;\n            __u32 target_obj_id; /* prog_id for PROG_EXT, otherwise btf object id */\n            __u32 target_btf_id; /* BTF type id inside the object */\n        } tracing;\n        struct {\n            __u64 cgroup_id;\n            __u32 attach_type;\n        } cgroup;\n        struct {\n            __aligned_u64 target_name; /* in/out: target_name buffer ptr */\n            __u32 target_name_len;     /* in/out: target_name buffer len */\n\n            /* If the iter specific field is 32 bits, it can be put\n            * in the first or second union. Otherwise it should be\n            * put in the second union.\n            */\n            union {\n                struct {\n                    __u32 map_id;\n                } map;\n            };\n            union {\n                struct {\n                    __u64 cgroup_id;\n                    __u32 order;\n                } cgroup;\n                struct {\n                    __u32 tid;\n                    __u32 pid;\n                } task;\n            };\n        } iter;\n        struct  {\n            __u32 netns_ino;\n            __u32 attach_type;\n        } netns;\n        struct {\n            __u32 ifindex;\n        } xdp;\n    };\n} __attribute__((aligned(8)));\n```\n\n----------------------------------------\n\nTITLE: Using __always_inline with a Function in an eBPF Program\nDESCRIPTION: This example demonstrates applying the __always_inline attribute to a simple addition function used within an XDP program. The function will be inlined at the call site by the compiler.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/ebpf/__always_inline.md#2025-04-22_snippet_1\n\nLANGUAGE: c\nCODE:\n```\nstatic int __always_inline add(int a, int b)\n{\n    return a + b;\n}\n\nSEC(\"xdp\")\nint example_prog(struct xdp_md *ctx)\n{\n    if (add(1, 2) == 3)\n        return XDP_PASS;\n    else\n        return XDP_DROP;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_tc_hook structure in C\nDESCRIPTION: This struct defines the hook information for the TC qdisc, including interface index, attach point, and parent ID.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_tc_query.md#2025-04-22_snippet_1\n\nLANGUAGE: c\nCODE:\n```\nstruct bpf_tc_hook {\n\tsize_t sz;\n\tint ifindex;\n\tenum bpf_tc_attach_point attach_point;\n\t__u32 parent;\n\tsize_t :0;\n};\n```\n\n----------------------------------------\n\nTITLE: Defining the bpf_skb_cgroup_id Helper Function - C\nDESCRIPTION: Declares the prototype for the bpf_skb_cgroup_id eBPF helper, which returns the cgroup v2 ID for the socket associated with a given struct __sk_buff (skb). This allows eBPF programs to reference cgroup identifiers for enforcing policies or tracking traffic. Required dependencies include kernel support with CONFIG_SOCK_CGROUP_DATA enabled. The main parameter is skb (pointer to network buffer), and the helper returns a 64-bit cgroup v2 ID or 0 on failure. It is only available on allowed BPF program types, and limited to TC egress path in relevant configurations.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_skb_cgroup_id.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n#!c static __u64 (* const bpf_skb_cgroup_id)(struct __sk_buff *skb) = (void *) 79;\n```\n\n----------------------------------------\n\nTITLE: Attaching LWT XMIT Program via Netlink\nDESCRIPTION: This command shows how to attach a BPF_PROG_TYPE_LWT_XMIT program to a route using the ip command with netlink. The program will be invoked during packet transmission to the specified route.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/program-type/BPF_PROG_TYPE_LWT_XMIT.md#2025-04-22_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nip route add 192.168.253.2/32 encap bpf xmit obj {elf file}.o section {prog section} dev veth0\n```\n\n----------------------------------------\n\nTITLE: Definition of scx_bpf_dsq_insert_vtime Macro in C\nDESCRIPTION: This macro provides backward compatibility between the renamed functions. It checks if scx_bpf_dsq_insert_vtime exists at runtime using bpf_ksym_exists, and calls it if available, otherwise falls back to the older scx_bpf_dispatch_vtime___compat function. Both functions are functionally equivalent but were renamed to avoid confusion with the overloaded 'dispatch' term.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/scx/scx_bpf_dsq_insert_vtime.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n#define scx_bpf_dsq_insert_vtime(p, dsq_id, slice, vtime, enq_flags)\\t\\t\\\n\t([bpf_ksym_exists](../libbpf/ebpf/bpf_ksym_exists.md)(scx_bpf_dsq_insert_vtime) ?\\\t\\\t\\\t\\\n\t [scx_bpf_dsq_insert_vtime](../../linux/kfuncs/scx_bpf_dsq_insert_vtime.md)((p), (dsq_id), (slice), (vtime), (enq_flags)) : \\\n\t [scx_bpf_dispatch_vtime___compat](../../linux/kfuncs/scx_bpf_dispatch_vtime.md)((p), (dsq_id), (slice), (vtime), (enq_flags)))\n```\n\n----------------------------------------\n\nTITLE: Defining libbpf_probe_bpf_prog_type function in C\nDESCRIPTION: This snippet shows the function signature for libbpf_probe_bpf_prog_type. It takes an enum bpf_prog_type and a void pointer as parameters, and returns an integer indicating support status or an error code.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/libbpf_probe_bpf_prog_type.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nint libbpf_probe_bpf_prog_type(enum bpf_prog_type prog_type, const void *opts);\n```\n\n----------------------------------------\n\nTITLE: Defining CPU Preemption Reasons in SCX (C)\nDESCRIPTION: Defines the enum scx_cpu_preempt_reason which represents the various reasons why a CPU might be preempted in the SCX framework, such as real-time, deadline, or stop scheduling classes.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/program-type/BPF_PROG_TYPE_STRUCT_OPS/sched_ext_ops.md#2025-04-22_snippet_49\n\nLANGUAGE: c\nCODE:\n```\nenum scx_cpu_preempt_reason {\n\tSCX_CPU_PREEMPT_RT,      // (1)!\n\tSCX_CPU_PREEMPT_DL,      // (2)!\n\tSCX_CPU_PREEMPT_STOP,    // (3)!\n\tSCX_CPU_PREEMPT_UNKNOWN, // (4)!\n};\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_program__unpin function in C\nDESCRIPTION: This snippet defines the bpf_program__unpin function from the libbpf library. It takes a pointer to a bpf_program struct and a file path as parameters, and returns an integer indicating success or failure.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_program__unpin.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nint bpf_program__unpin(struct bpf_program *prog, const char *path);\n```\n\n----------------------------------------\n\nTITLE: Declaring the 'hotplug_seq' Field in 'sched_ext_ops' Struct (C)\nDESCRIPTION: Declares the 'hotplug_seq' field within the 'sched_ext_ops' struct as an unsigned 64-bit integer. This sequence number allows the BPF scheduler to detect CPU hot-plug events that occur during its loading process. If non-zero, the scheduler load will fail if this value doesn't match the kernel's `scx_hotplug_seq` at the time of enabling.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/program-type/BPF_PROG_TYPE_STRUCT_OPS/sched_ext_ops.md#2025-04-22_snippet_6\n\nLANGUAGE: c\nCODE:\n```\nu64 hotplug_seq\n```\n\n----------------------------------------\n\nTITLE: Initializing bpf_timer_init in C\nDESCRIPTION: The C code snippet initializes a timer using the 'bpf_timer_init' helper function. It outlines the limitations of the 'flags' parameter, specifying acceptable clock IDs and reserved bits. The function checks that the timer is from the correct map. Success and error return codes (-EBUSY, -EINVAL, -EPERM) are documented.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_timer_init.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n#!c static long (* const bpf_timer_init)(struct bpf_timer *timer, void *map, __u64 flags) = (void *) 169;\n```\n\n----------------------------------------\n\nTITLE: Creating AF_XDP Socket with 'xsk_socket__create' in C\nDESCRIPTION: This function creates an AF_XDP socket with exclusive ownership of a umem. It returns 0 on success or a negative error code on failure. Error codes include -EINVAL (invalid arguments), -EFAULT (invalid memory address), -ENOMEM (no data space available), and -ENOPROTOOPT (option not supported by protocol).\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libxdp/functions/xsk_socket__create.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nint xsk_socket__create(struct xsk_socket **xsk,\n\t\t       const char *ifname, __u32 queue_id,\n\t\t       struct xsk_umem *umem,\n\t\t       struct xsk_ring_cons *rx,\n\t\t       struct xsk_ring_prod *tx,\n\t\t       const struct xsk_socket_config *config);\n```\n\n----------------------------------------\n\nTITLE: Defining the bpf_map__attach_struct_ops Function (C)\nDESCRIPTION: This C code snippet shows the function signature for `bpf_map__attach_struct_ops`. It takes a pointer to a `bpf_map` structure (`map`) as input, representing the BPF map to attach. The function returns a pointer to a `bpf_link` structure representing the attachment upon success, or `NULL` if an error occurs (in which case `errno` is set). This function is specifically designed for attaching BPF maps of type `BPF_MAP_TYPE_STRUCT_OPS`.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_map__attach_struct_ops.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstruct bpf_link *bpf_map__attach_struct_ops(const struct bpf_map *map);\n```\n\n----------------------------------------\n\nTITLE: BPF_F_XDP_HAS_FRAGS Flag Documentation\nDESCRIPTION: Documents the BPF_F_XDP_HAS_FRAGS flag (introduced in v5.18) which indicates that an XDP program supports processing packets split across multiple fragments, rather than requiring linear buffer representation.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/syscall/BPF_PROG_LOAD.md#2025-04-22_snippet_7\n\nLANGUAGE: markdown\nCODE:\n```\n### `BPF_F_XDP_HAS_FRAGS`\n\n<!-- [FEATURE_TAG](BPF_F_XDP_HAS_FRAGS) -->\n[:octicons-tag-24: v5.18](https://github.com/torvalds/linux/commit/c2f2cdbeffda7b153c19e0f3d73149c41026c0db)\n<!-- [/FEATURE_TAG] -->\n\nThis flag notifies the kernel that the XDP program supports XDP fragments. If set, the XDP program may be called with a context that doesn't include the full packet in a single linear piece of memory, which breaks assumptions most XDP programs have, hence the flag.\n\nFor more details, check out the [XDP program type page](../program-type/BPF_PROG_TYPE_XDP.md#xdp-fragments)\n```\n\n----------------------------------------\n\nTITLE: Flag Bitmask Definitions for CONG_CONTROL Callback in C\nDESCRIPTION: This C snippet defines named bitmask constants used as the 'flag' bitfield parameter for the 'cong_control' callback within 'tcp_congestion_ops'. The constants enable the callback to interpret the nature of TCP ACK events (e.g., data acknowledged, window update, ECN seen). Each define facilitates readable, maintainable implementations of custom congestion control logic. Expected input is a valid combination of these flags, and output is specific to the callback's logic. All values are unsigned integer flags suitable for bitwise operations and must be consistent with upstream Linux kernel sources.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/program-type/BPF_PROG_TYPE_STRUCT_OPS/tcp_congestion_ops.md#2025-04-22_snippet_1\n\nLANGUAGE: c\nCODE:\n```\n#define FLAG_DATA               0x01    // (1)!\n#define FLAG_WIN_UPDATE         0x02    // (2)!\n#define FLAG_DATA_ACKED         0x04    // (3)!\n#define FLAG_RETRANS_DATA_ACKED\\t0x08    // (4)!\n#define FLAG_SYN_ACKED          0x10    // (5)!\n#define FLAG_DATA_SACKED        0x20    // (6)!\n#define FLAG_ECE                0x40    // (7)!\n#define FLAG_LOST_RETRANS       0x80    // (8)!\n#define FLAG_SLOWPATH           0x100   // (9)!\n#define FLAG_ORIG_SACK_ACKED    0x200   // (10)!\n#define FLAG_SND_UNA_ADVANCED   0x400   // (11)!\n#define FLAG_DSACKING_ACK       0x800   // (12)!\n#define FLAG_SET_XMIT_TIMER     0x1000  // (13)!\n#define FLAG_SACK_RENEGING      0x2000  // (14)!\n#define FLAG_UPDATE_TS_RECENT   0x4000  // (15)!\n#define FLAG_NO_CHALLENGE_ACK   0x8000  // (16)!\n#define FLAG_ACK_MAYBE_DELAYED  0x10000 // (17)!\n#define FLAG_DSACK_TLP          0x20000 // (18)!\n```\n\n----------------------------------------\n\nTITLE: Registering UMEM with AF_XDP Socket in C\nDESCRIPTION: This snippet shows how to register the allocated UMEM with the AF_XDP socket using the setsockopt() system call.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/concepts/af_xdp.md#2025-04-22_snippet_2\n\nLANGUAGE: c\nCODE:\n```\nstruct xdp_umem_reg {\n\t__u64 addr; /* Start of packet data area */\n\t__u64 len; /* Length of packet data area */\n\t__u32 chunk_size;\n\t__u32 headroom;\n\t__u32 flags;\n};\n\nstruct xdp_umem_reg umem_reg = {\n    .addr = (__u64)(void *)umem,\n    .len = umem_len,\n    .chunk_size = chunk_size,\n    .headroom = 0, // see Options, variations, and exceptions\n    .flags = 0, // see Options, variations, and exceptions\n};\nif (!setsockopt(fd, SOL_XDP, XDP_UMEM_REG, &umem_reg, sizeof(umem_reg)))\n    // handle error\n```\n\n----------------------------------------\n\nTITLE: Enumeration of HID Class Requests - Linux Kernel C\nDESCRIPTION: Declares 'enum hid_class_request' mapping constants to USB HID class requests as specified in the protocol. BPF programs may use these to inspect or override low-level HID control messages during hid_hw_request hooks.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/program-type/BPF_PROG_TYPE_STRUCT_OPS/hid_bpf_ops.md#2025-04-22_snippet_3\n\nLANGUAGE: c\nCODE:\n```\nenum hid_class_request {\n\tHID_REQ_GET_REPORT      = 0x01,\n\tHID_REQ_GET_IDLE        = 0x02,\n\tHID_REQ_GET_PROTOCOL    = 0x03,\n\tHID_REQ_SET_REPORT      = 0x09,\n\tHID_REQ_SET_IDLE        = 0x0A,\n\tHID_REQ_SET_PROTOCOL    = 0x0B,\n};\n```\n\n----------------------------------------\n\nTITLE: Displaying Supported KFuncs in Markdown\nDESCRIPTION: This snippet uses a collapsible Markdown section to list all supported kfuncs for eBPF programming. Each kfunc is presented as a link to its detailed documentation page.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/program-type/BPF_PROG_TYPE_XDP.md#2025-04-22_snippet_2\n\nLANGUAGE: markdown\nCODE:\n```\n??? abstract \"Supported kfuncs\"\n    - [`bpf_arena_alloc_pages`](../kfuncs/bpf_arena_alloc_pages.md)\n    - [`bpf_arena_free_pages`](../kfuncs/bpf_arena_free_pages.md)\n    - [`bpf_cast_to_kern_ctx`](../kfuncs/bpf_cast_to_kern_ctx.md)\n    - [`bpf_cgroup_acquire`](../kfuncs/bpf_cgroup_acquire.md)\n    - [`bpf_cgroup_ancestor`](../kfuncs/bpf_cgroup_ancestor.md)\n    - [`bpf_cgroup_from_id`](../kfuncs/bpf_cgroup_from_id.md)\n    - [`bpf_cgroup_release`](../kfuncs/bpf_cgroup_release.md)\n    - [`bpf_copy_from_user_str`](../kfuncs/bpf_copy_from_user_str.md)\n    - [`bpf_crypto_decrypt`](../kfuncs/bpf_crypto_decrypt.md)\n    - [`bpf_crypto_encrypt`](../kfuncs/bpf_crypto_encrypt.md)\n    - [`bpf_ct_change_status`](../kfuncs/bpf_ct_change_status.md)\n    - [`bpf_ct_change_timeout`](../kfuncs/bpf_ct_change_timeout.md)\n    - [`bpf_ct_insert_entry`](../kfuncs/bpf_ct_insert_entry.md)\n    - [`bpf_ct_release`](../kfuncs/bpf_ct_release.md)\n    - [`bpf_ct_set_nat_info`](../kfuncs/bpf_ct_set_nat_info.md)\n    - [`bpf_ct_set_status`](../kfuncs/bpf_ct_set_status.md)\n    - [`bpf_ct_set_timeout`](../kfuncs/bpf_ct_set_timeout.md)\n    - [`bpf_dynptr_adjust`](../kfuncs/bpf_dynptr_adjust.md)\n    - [`bpf_dynptr_clone`](../kfuncs/bpf_dynptr_clone.md)\n    - [`bpf_dynptr_from_xdp`](../kfuncs/bpf_dynptr_from_xdp.md)\n    - [`bpf_dynptr_is_null`](../kfuncs/bpf_dynptr_is_null.md)\n    - [`bpf_dynptr_is_rdonly`](../kfuncs/bpf_dynptr_is_rdonly.md)\n    - [`bpf_dynptr_size`](../kfuncs/bpf_dynptr_size.md)\n    - [`bpf_dynptr_slice`](../kfuncs/bpf_dynptr_slice.md)\n    - [`bpf_dynptr_slice_rdwr`](../kfuncs/bpf_dynptr_slice_rdwr.md)\n    - [`bpf_get_kmem_cache`](../kfuncs/bpf_get_kmem_cache.md)\n    - [`bpf_iter_bits_destroy`](../kfuncs/bpf_iter_bits_destroy.md)\n    - [`bpf_iter_bits_new`](../kfuncs/bpf_iter_bits_new.md)\n    - [`bpf_iter_bits_next`](../kfuncs/bpf_iter_bits_next.md)\n    - [`bpf_iter_css_destroy`](../kfuncs/bpf_iter_css_destroy.md)\n    - [`bpf_iter_css_new`](../kfuncs/bpf_iter_css_new.md)\n    - [`bpf_iter_css_next`](../kfuncs/bpf_iter_css_next.md)\n    - [`bpf_iter_css_task_destroy`](../kfuncs/bpf_iter_css_task_destroy.md)\n    - [`bpf_iter_css_task_new`](../kfuncs/bpf_iter_css_task_new.md)\n    - [`bpf_iter_css_task_next`](../kfuncs/bpf_iter_css_task_next.md)\n    - [`bpf_iter_kmem_cache_destroy`](../kfuncs/bpf_iter_kmem_cache_destroy.md)\n    - [`bpf_iter_kmem_cache_new`](../kfuncs/bpf_iter_kmem_cache_new.md)\n    - [`bpf_iter_kmem_cache_next`](../kfuncs/bpf_iter_kmem_cache_next.md)\n    - [`bpf_iter_num_destroy`](../kfuncs/bpf_iter_num_destroy.md)\n    - [`bpf_iter_num_new`](../kfuncs/bpf_iter_num_new.md)\n    - [`bpf_iter_num_next`](../kfuncs/bpf_iter_num_next.md)\n    - [`bpf_iter_task_destroy`](../kfuncs/bpf_iter_task_destroy.md)\n    - [`bpf_iter_task_new`](../kfuncs/bpf_iter_task_new.md)\n    - [`bpf_iter_task_next`](../kfuncs/bpf_iter_task_next.md)\n    - [`bpf_iter_task_vma_destroy`](../kfuncs/bpf_iter_task_vma_destroy.md)\n    - [`bpf_iter_task_vma_new`](../kfuncs/bpf_iter_task_vma_new.md)\n    - [`bpf_iter_task_vma_next`](../kfuncs/bpf_iter_task_vma_next.md)\n    - [`bpf_list_pop_back`](../kfuncs/bpf_list_pop_back.md)\n    - [`bpf_list_pop_front`](../kfuncs/bpf_list_pop_front.md)\n    - [`bpf_list_push_back_impl`](../kfuncs/bpf_list_push_back_impl.md)\n    - [`bpf_list_push_front_impl`](../kfuncs/bpf_list_push_front_impl.md)\n    - [`bpf_local_irq_restore`](../kfuncs/bpf_local_irq_restore.md)\n    - [`bpf_local_irq_save`](../kfuncs/bpf_local_irq_save.md)\n    - [`bpf_map_sum_elem_count`](../kfuncs/bpf_map_sum_elem_count.md)\n    - [`bpf_obj_drop_impl`](../kfuncs/bpf_obj_drop_impl.md)\n    - [`bpf_obj_new_impl`](../kfuncs/bpf_obj_new_impl.md)\n    - [`bpf_percpu_obj_drop_impl`](../kfuncs/bpf_percpu_obj_drop_impl.md)\n    - [`bpf_percpu_obj_new_impl`](../kfuncs/bpf_percpu_obj_new_impl.md)\n    - [`bpf_preempt_disable`](../kfuncs/bpf_preempt_disable.md)\n    - [`bpf_preempt_enable`](../kfuncs/bpf_preempt_enable.md)\n    - [`bpf_rbtree_add_impl`](../kfuncs/bpf_rbtree_add_impl.md)\n    - [`bpf_rbtree_first`](../kfuncs/bpf_rbtree_first.md)\n    - [`bpf_rbtree_remove`](../kfuncs/bpf_rbtree_remove.md)\n    - [`bpf_rcu_read_lock`](../kfuncs/bpf_rcu_read_lock.md)\n    - [`bpf_rcu_read_unlock`](../kfuncs/bpf_rcu_read_unlock.md)\n    - [`bpf_rdonly_cast`](../kfuncs/bpf_rdonly_cast.md)\n    - [`bpf_refcount_acquire_impl`](../kfuncs/bpf_refcount_acquire_impl.md)\n    - [`bpf_send_signal_task`](../kfuncs/bpf_send_signal_task.md)\n    - [`bpf_skb_ct_alloc`](../kfuncs/bpf_skb_ct_alloc.md)\n    - [`bpf_skb_ct_lookup`](../kfuncs/bpf_skb_ct_lookup.md)\n    - [`bpf_task_acquire`](../kfuncs/bpf_task_acquire.md)\n    - [`bpf_task_from_pid`](../kfuncs/bpf_task_from_pid.md)\n    - [`bpf_task_from_vpid`](../kfuncs/bpf_task_from_vpid.md)\n    - [`bpf_task_get_cgroup1`](../kfuncs/bpf_task_get_cgroup1.md)\n    - [`bpf_task_release`](../kfuncs/bpf_task_release.md)\n    - [`bpf_task_under_cgroup`](../kfuncs/bpf_task_under_cgroup.md)\n    - [`bpf_throw`](../kfuncs/bpf_throw.md)\n    - [`bpf_wq_init`](../kfuncs/bpf_wq_init.md)\n    - [`bpf_wq_set_callback_impl`](../kfuncs/bpf_wq_set_callback_impl.md)\n    - [`bpf_wq_start`](../kfuncs/bpf_wq_start.md)\n    - [`bpf_xdp_ct_alloc`](../kfuncs/bpf_xdp_ct_alloc.md)\n    - [`bpf_xdp_ct_lookup`](../kfuncs/bpf_xdp_ct_lookup.md)\n    - [`bpf_xdp_flow_lookup`](../kfuncs/bpf_xdp_flow_lookup.md)\n    - [`bpf_xdp_get_xfrm_state`](../kfuncs/bpf_xdp_get_xfrm_state.md)\n    - [`bpf_xdp_metadata_rx_hash`](../kfuncs/bpf_xdp_metadata_rx_hash.md)\n    - [`bpf_xdp_metadata_rx_timestamp`](../kfuncs/bpf_xdp_metadata_rx_timestamp.md)\n    - [`bpf_xdp_metadata_rx_vlan_tag`](../kfuncs/bpf_xdp_metadata_rx_vlan_tag.md)\n    - [`bpf_xdp_xfrm_state_release`](../kfuncs/bpf_xdp_xfrm_state_release.md)\n    - [`crash_kexec`](../kfuncs/crash_kexec.md)\n```\n\n----------------------------------------\n\nTITLE: Definition of bpf_skb_set_xfrm_info KFunc for XFRM Metadata Manipulation\nDESCRIPTION: Function signature for the bpf_skb_set_xfrm_info kernel function that sets XFRM metadata for a socket buffer. It takes the socket buffer context and a pointer to the XFRM info structure as parameters.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/bpf_skb_set_xfrm_info.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nint bpf_skb_set_xfrm_info(struct __sk_buff *skb_ctx, const struct bpf_xfrm_info *from)\n```\n\n----------------------------------------\n\nTITLE: Definition of libbpf_attach_type_by_name function in C\nDESCRIPTION: Function signature for libbpf_attach_type_by_name which takes an ELF section name and a pointer to store the resolved attach type. Returns 0 on success or a negative error code on failure.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/libbpf_attach_type_by_name.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nint libbpf_attach_type_by_name(const char *name, enum bpf_attach_type *attach_type);\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_csum_level Helper Function in C\nDESCRIPTION: C function definition for the bpf_csum_level eBPF helper. This function allows changing the skb's checksum level by one layer up or down, or resetting it entirely.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_csum_level.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstatic long (* const bpf_csum_level)(struct __sk_buff *skb, __u64 level) = (void *) 135;\n```\n\n----------------------------------------\n\nTITLE: Defining ring_buffer__poll function in C for libbpf\nDESCRIPTION: This snippet defines the 'ring_buffer__poll' function, which polls for available data and consumes records from a ring buffer. It takes a ring buffer manager and timeout as parameters, returning the number of records consumed or an error code.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/ring_buffer__poll.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nint ring_buffer__poll(struct ring_buffer *rb, int timeout_ms);\n```\n\n----------------------------------------\n\nTITLE: Defining the 'bpf_btf_get_fd_by_id_opts' function signature in C\nDESCRIPTION: This snippet shows the C function signature for `bpf_btf_get_fd_by_id_opts`. This libbpf function acts as a low-level wrapper around the BPF_BTF_GET_FD_BY_ID syscall command. It takes a BTF object ID (`id`) and a pointer to an options structure (`opts`) as input. On success, it returns a positive integer representing the file descriptor for the BTF object; otherwise, it returns a negative error code. Requires libbpf v1.1.0 or later.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_btf_get_fd_by_id_opts.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n#!c int bpf_btf_get_fd_by_id_opts(__u32 id, const struct bpf_get_fd_by_id_opts *opts);\n```\n\n----------------------------------------\n\nTITLE: Listing Supported Helper Functions for Raw Tracepoint Programs\nDESCRIPTION: This code snippet uses a markdown-formatted list to enumerate all the helper functions available for raw tracepoint programs in eBPF. Each function is linked to its respective documentation page, and some entries include version tags indicating when the function was introduced.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/program-type/BPF_PROG_TYPE_TRACING.md#2025-04-22_snippet_6\n\nLANGUAGE: markdown\nCODE:\n```\n??? abstract \"Supported helper functions\"\n    * [`bpf_cgrp_storage_delete`](../helper-function/bpf_cgrp_storage_delete.md)\n    * [`bpf_cgrp_storage_get`](../helper-function/bpf_cgrp_storage_get.md)\n    * [`bpf_copy_from_user`](../helper-function/bpf_copy_from_user.md)\n    * [`bpf_copy_from_user_task`](../helper-function/bpf_copy_from_user_task.md)\n    * [`bpf_current_task_under_cgroup`](../helper-function/bpf_current_task_under_cgroup.md)\n    * [`bpf_d_path`](../helper-function/bpf_d_path.md)\n    * [`bpf_dynptr_data`](../helper-function/bpf_dynptr_data.md)\n    * [`bpf_dynptr_from_mem`](../helper-function/bpf_dynptr_from_mem.md)\n    * [`bpf_dynptr_read`](../helper-function/bpf_dynptr_read.md)\n    * [`bpf_dynptr_write`](../helper-function/bpf_dynptr_write.md)\n    * [`bpf_find_vma`](../helper-function/bpf_find_vma.md)\n    * [`bpf_for_each_map_elem`](../helper-function/bpf_for_each_map_elem.md)\n    * [`bpf_get_attach_cookie`](../helper-function/bpf_get_attach_cookie.md) [:octicons-tag-24: v5.19](https://github.com/torvalds/linux/commit/2fcc82411e74e5e6aba336561cf56fb899bfae4e)\n    * [`bpf_get_branch_snapshot`](../helper-function/bpf_get_branch_snapshot.md)\n    * [`bpf_get_current_ancestor_cgroup_id`](../helper-function/bpf_get_current_ancestor_cgroup_id.md)\n    * [`bpf_get_current_cgroup_id`](../helper-function/bpf_get_current_cgroup_id.md)\n    * [`bpf_get_current_comm`](../helper-function/bpf_get_current_comm.md)\n    * [`bpf_get_current_pid_tgid`](../helper-function/bpf_get_current_pid_tgid.md)\n    * [`bpf_get_current_task`](../helper-function/bpf_get_current_task.md)\n    * [`bpf_get_current_task_btf`](../helper-function/bpf_get_current_task_btf.md)\n    * [`bpf_get_current_uid_gid`](../helper-function/bpf_get_current_uid_gid.md)\n    * [`bpf_get_func_arg`](../helper-function/bpf_get_func_arg.md)\n    * [`bpf_get_func_arg_cnt`](../helper-function/bpf_get_func_arg_cnt.md)\n    * [`bpf_get_func_ip`](../helper-function/bpf_get_func_ip.md)\n    * [`bpf_get_func_ret`](../helper-function/bpf_get_func_ret.md)\n    * [`bpf_get_ns_current_pid_tgid`](../helper-function/bpf_get_ns_current_pid_tgid.md)\n    * [`bpf_get_numa_node_id`](../helper-function/bpf_get_numa_node_id.md)\n    * [`bpf_get_prandom_u32`](../helper-function/bpf_get_prandom_u32.md)\n    * [`bpf_get_smp_processor_id`](../helper-function/bpf_get_smp_processor_id.md)\n    * [`bpf_get_socket_cookie`](../helper-function/bpf_get_socket_cookie.md)\n    * [`bpf_get_stack`](../helper-function/bpf_get_stack.md)\n    * [`bpf_get_stackid`](../helper-function/bpf_get_stackid.md)\n    * [`bpf_get_task_stack`](../helper-function/bpf_get_task_stack.md)\n    * [`bpf_jiffies64`](../helper-function/bpf_jiffies64.md)\n    * [`bpf_kptr_xchg`](../helper-function/bpf_kptr_xchg.md)\n    * [`bpf_ktime_get_boot_ns`](../helper-function/bpf_ktime_get_boot_ns.md)\n    * [`bpf_ktime_get_ns`](../helper-function/bpf_ktime_get_ns.md)\n    * [`bpf_ktime_get_tai_ns`](../helper-function/bpf_ktime_get_tai_ns.md)\n    * [`bpf_loop`](../helper-function/bpf_loop.md)\n    * [`bpf_map_delete_elem`](../helper-function/bpf_map_delete_elem.md)\n    * [`bpf_map_lookup_elem`](../helper-function/bpf_map_lookup_elem.md)\n    * [`bpf_map_lookup_percpu_elem`](../helper-function/bpf_map_lookup_percpu_elem.md)\n    * [`bpf_map_peek_elem`](../helper-function/bpf_map_peek_elem.md)\n    * [`bpf_map_pop_elem`](../helper-function/bpf_map_pop_elem.md)\n    * [`bpf_map_push_elem`](../helper-function/bpf_map_push_elem.md)\n    * [`bpf_map_update_elem`](../helper-function/bpf_map_update_elem.md)\n    * [`bpf_per_cpu_ptr`](../helper-function/bpf_per_cpu_ptr.md)\n    * [`bpf_perf_event_output`](../helper-function/bpf_perf_event_output.md)\n    * [`bpf_perf_event_read`](../helper-function/bpf_perf_event_read.md)\n    * [`bpf_perf_event_read_value`](../helper-function/bpf_perf_event_read_value.md)\n    * [`bpf_probe_read`](../helper-function/bpf_probe_read.md)\n    * [`bpf_probe_read_kernel`](../helper-function/bpf_probe_read_kernel.md)\n    * [`bpf_probe_read_kernel_str`](../helper-function/bpf_probe_read_kernel_str.md)\n    * [`bpf_probe_read_str`](../helper-function/bpf_probe_read_str.md)\n    * [`bpf_probe_read_user`](../helper-function/bpf_probe_read_user.md)\n    * [`bpf_probe_read_user_str`](../helper-function/bpf_probe_read_user_str.md)\n    * [`bpf_probe_write_user`](../helper-function/bpf_probe_write_user.md)\n    * [`bpf_ringbuf_discard`](../helper-function/bpf_ringbuf_discard.md)\n    * [`bpf_ringbuf_discard_dynptr`](../helper-function/bpf_ringbuf_discard_dynptr.md)\n    * [`bpf_ringbuf_output`](../helper-function/bpf_ringbuf_output.md)\n    * [`bpf_ringbuf_query`](../helper-function/bpf_ringbuf_query.md)\n    * [`bpf_ringbuf_reserve`](../helper-function/bpf_ringbuf_reserve.md)\n    * [`bpf_ringbuf_reserve_dynptr`](../helper-function/bpf_ringbuf_reserve_dynptr.md)\n    * [`bpf_ringbuf_submit`](../helper-function/bpf_ringbuf_submit.md)\n    * [`bpf_ringbuf_submit_dynptr`](../helper-function/bpf_ringbuf_submit_dynptr.md)\n    * [`bpf_send_signal`](../helper-function/bpf_send_signal.md)\n    * [`bpf_send_signal_thread`](../helper-function/bpf_send_signal_thread.md)\n    * [`bpf_seq_printf`](../helper-function/bpf_seq_printf.md)\n    * [`bpf_seq_printf_btf`](../helper-function/bpf_seq_printf_btf.md)\n    * [`bpf_seq_write`](../helper-function/bpf_seq_write.md)\n    * [`bpf_sk_storage_delete`](../helper-function/bpf_sk_storage_delete.md) [:octicons-tag-24: v5.11](https://github.com/torvalds/linux/commit/8e4597c627fb48f361e2a5b012202cb1b6cbcd5e)\n    * [`bpf_sk_storage_get`](../helper-function/bpf_sk_storage_get.md) [:octicons-tag-24: v5.11](https://github.com/torvalds/linux/commit/8e4597c627fb48f361e2a5b012202cb1b6cbcd5e)\n    * [`bpf_skb_output`](../helper-function/bpf_skb_output.md)\n    * [`bpf_skc_to_mptcp_sock`](../helper-function/bpf_skc_to_mptcp_sock.md)\n    * [`bpf_skc_to_tcp6_sock`](../helper-function/bpf_skc_to_tcp6_sock.md)\n    * [`bpf_skc_to_tcp_request_sock`](../helper-function/bpf_skc_to_tcp_request_sock.md)\n    * [`bpf_skc_to_tcp_sock`](../helper-function/bpf_skc_to_tcp_sock.md)\n    * [`bpf_skc_to_tcp_timewait_sock`](../helper-function/bpf_skc_to_tcp_timewait_sock.md)\n    * [`bpf_skc_to_udp6_sock`](../helper-function/bpf_skc_to_udp6_sock.md)\n    * [`bpf_skc_to_unix_sock`](../helper-function/bpf_skc_to_unix_sock.md)\n    * [`bpf_snprintf`](../helper-function/bpf_snprintf.md)\n    * [`bpf_snprintf_btf`](../helper-function/bpf_snprintf_btf.md)\n    * [`bpf_sock_from_file`](../helper-function/bpf_sock_from_file.md)\n    * [`bpf_spin_lock`](../helper-function/bpf_spin_lock.md)\n    * [`bpf_spin_unlock`](../helper-function/bpf_spin_unlock.md)\n    * [`bpf_strncmp`](../helper-function/bpf_strncmp.md)\n    * [`bpf_tail_call`](../helper-function/bpf_tail_call.md)\n    * [`bpf_task_pt_regs`](../helper-function/bpf_task_pt_regs.md)\n    * [`bpf_task_storage_delete`](../helper-function/bpf_task_storage_delete.md)\n    * [`bpf_task_storage_get`](../helper-function/bpf_task_storage_get.md)\n    * [`bpf_this_cpu_ptr`](../helper-function/bpf_this_cpu_ptr.md)\n    * [`bpf_timer_cancel`](../helper-function/bpf_timer_cancel.md)\n    * [`bpf_timer_init`](../helper-function/bpf_timer_init.md)\n    * [`bpf_timer_set_callback`](../helper-function/bpf_timer_set_callback.md)\n    * [`bpf_timer_start`](../helper-function/bpf_timer_start.md)\n    * [`bpf_trace_printk`](../helper-function/bpf_trace_printk.md)\n    * [`bpf_trace_vprintk`](../helper-function/bpf_trace_vprintk.md)\n    * [`bpf_user_ringbuf_drain`](../helper-function/bpf_user_ringbuf_drain.md)\n    * [`bpf_xdp_get_buff_len`](../helper-function/bpf_xdp_get_buff_len.md)\n    * [`bpf_xdp_output`](../helper-function/bpf_xdp_output.md)\n```\n\n----------------------------------------\n\nTITLE: Retrieving XDP Attachment Mode in C using xdp_multiprog__attach_mode\nDESCRIPTION: Function signature for retrieving the attachment mode of an XDP multiprog. It takes a const struct xdp_multiprog pointer as input and returns an enum xdp_attach_mode value. If the multiprog is not found, it returns XDP_MODE_UNSPEC.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libxdp/functions/xdp_multiprog__attach_mode.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nenum xdp_attach_mode xdp_multiprog__attach_mode(const struct xdp_multiprog *mp);\n```\n\n----------------------------------------\n\nTITLE: Using Spin Locks in eBPF to Safely Update Map Values\nDESCRIPTION: This example demonstrates how to use bpf_spin_lock and bpf_spin_unlock helpers to safely increment a counter in a shared map value. The code initializes a map element if needed, then acquires the lock before modifying the value.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/concepts/concurrency.md#2025-04-22_snippet_2\n\nLANGUAGE: c\nCODE:\n```\nSEC(\"tp_btf/sys_enter\")\nint sys_enter_count(void *ctx) {\n\tint key = 0;\n\tstruct concurrent_element init_value = {};\n\tstruct concurrent_element *read_value;\n\tbpf_map_update_elem(&concurrent_map, &key, &init_value, BPF_NOEXIST);\n\n\tread_value = bpf_map_lookup_elem(&concurrent_map, &key);\n\tif(!read_value)\n\t{\n\t\treturn 0;\n\t}\n\n\tbpf_spin_lock(&read_value->semaphore);\n\tread_value->count += 1;\n\tbpf_spin_unlock(&read_value->semaphore);\n\treturn 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Using '__uint' Macro for BTF Map Definition in C\nDESCRIPTION: This example demonstrates how to use the '__uint' macro to define properties of a BTF map. It sets the map type, maximum entries, key size, and value size using the macro.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/ebpf/__uint.md#2025-04-22_snippet_1\n\nLANGUAGE: c\nCODE:\n```\nstruct {\n    __uint(type, BPF_MAP_TYPE_HASH);\n    __uint(max_entries, 1024);\n    __uint(key_size, sizeof(int));\n    __uint(value_size, sizeof(long));\n} SEC(\".maps\") my_map;\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_tc_hook structure in C\nDESCRIPTION: This struct defines the hook information for TC qdisc operations. It includes fields for interface index, attach point, and parent qdisc ID.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_tc_detach.md#2025-04-22_snippet_1\n\nLANGUAGE: c\nCODE:\n```\nstruct bpf_tc_hook {\n\tsize_t sz;\n\tint ifindex;\n\tenum bpf_tc_attach_point attach_point;\n\t__u32 parent;\n\tsize_t :0;\n};\n```\n\n----------------------------------------\n\nTITLE: Listing Supported eBPF Helper Functions for Socket Filters (Markdown)\nDESCRIPTION: Provides a comprehensive list of eBPF helper functions available within socket filter programs. Each function links to its detailed documentation, and some include version tags indicating when they were introduced (e.g., v6.10). This list is enclosed within comment markers often used for auto-generating documentation sections.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/program-type/BPF_PROG_TYPE_FLOW_DISSECTOR.md#2025-04-22_snippet_1\n\nLANGUAGE: markdown\nCODE:\n```\n<!-- DO NOT EDIT MANUALLY -->\n<!-- [PROG_HELPER_FUNC_REF] -->\n??? abstract \"Supported helper functions\"\n    * [`bpf_cgrp_storage_delete`](../helper-function/bpf_cgrp_storage_delete.md)\n    * [`bpf_cgrp_storage_get`](../helper-function/bpf_cgrp_storage_get.md)\n    * [`bpf_dynptr_data`](../helper-function/bpf_dynptr_data.md)\n    * [`bpf_dynptr_from_mem`](../helper-function/bpf_dynptr_from_mem.md)\n    * [`bpf_dynptr_read`](../helper-function/bpf_dynptr_read.md)\n    * [`bpf_dynptr_write`](../helper-function/bpf_dynptr_write.md)\n    * [`bpf_for_each_map_elem`](../helper-function/bpf_for_each_map_elem.md)\n    * [`bpf_get_current_pid_tgid`](../helper-function/bpf_get_current_pid_tgid.md) [:octicons-tag-24: v6.10](https://github.com/torvalds/linux/commit/eb166e522c77699fc19bfa705652327a1e51a117)\n    * [`bpf_get_current_task`](../helper-function/bpf_get_current_task.md)\n    * [`bpf_get_current_task_btf`](../helper-function/bpf_get_current_task_btf.md)\n    * [`bpf_get_ns_current_pid_tgid`](../helper-function/bpf_get_ns_current_pid_tgid.md) [:octicons-tag-24: v6.10](https://github.com/torvalds/linux/commit/eb166e522c77699fc19bfa705652327a1e51a117)\n    * [`bpf_get_numa_node_id`](../helper-function/bpf_get_numa_node_id.md)\n    * [`bpf_get_prandom_u32`](../helper-function/bpf_get_prandom_u32.md)\n    * [`bpf_get_smp_processor_id`](../helper-function/bpf_get_smp_processor_id.md)\n    * [`bpf_jiffies64`](../helper-function/bpf_jiffies64.md)\n    * [`bpf_kptr_xchg`](../helper-function/bpf_kptr_xchg.md)\n    * [`bpf_ktime_get_boot_ns`](../helper-function/bpf_ktime_get_boot_ns.md)\n    * [`bpf_ktime_get_coarse_ns`](../helper-function/bpf_ktime_get_coarse_ns.md)\n    * [`bpf_ktime_get_ns`](../helper-function/bpf_ktime_get_ns.md)\n    * [`bpf_ktime_get_tai_ns`](../helper-function/bpf_ktime_get_tai_ns.md)\n    * [`bpf_loop`](../helper-function/bpf_loop.md)\n    * [`bpf_map_delete_elem`](../helper-function/bpf_map_delete_elem.md)\n    * [`bpf_map_lookup_elem`](../helper-function/bpf_map_lookup_elem.md)\n    * [`bpf_map_lookup_percpu_elem`](../helper-function/bpf_map_lookup_percpu_elem.md)\n    * [`bpf_map_peek_elem`](../helper-function/bpf_map_peek_elem.md)\n    * [`bpf_map_pop_elem`](../helper-function/bpf_map_pop_elem.md)\n    * [`bpf_map_push_elem`](../helper-function/bpf_map_push_elem.md)\n    * [`bpf_map_update_elem`](../helper-function/bpf_map_update_elem.md)\n    * [`bpf_per_cpu_ptr`](../helper-function/bpf_per_cpu_ptr.md)\n    * [`bpf_probe_read_kernel`](../helper-function/bpf_probe_read_kernel.md)\n    * [`bpf_probe_read_kernel_str`](../helper-function/bpf_probe_read_kernel_str.md)\n    * [`bpf_probe_read_user`](../helper-function/bpf_probe_read_user.md)\n    * [`bpf_probe_read_user_str`](../helper-function/bpf_probe_read_user_str.md)\n    * [`bpf_ringbuf_discard`](../helper-function/bpf_ringbuf_discard.md)\n    * [`bpf_ringbuf_discard_dynptr`](../helper-function/bpf_ringbuf_discard_dynptr.md)\n    * [`bpf_ringbuf_output`](../helper-function/bpf_ringbuf_output.md)\n    * [`bpf_ringbuf_query`](../helper-function/bpf_ringbuf_query.md)\n    * [`bpf_ringbuf_reserve`](../helper-function/bpf_ringbuf_reserve.md)\n    * [`bpf_ringbuf_reserve_dynptr`](../helper-function/bpf_ringbuf_reserve_dynptr.md)\n    * [`bpf_ringbuf_submit`](../helper-function/bpf_ringbuf_submit.md)\n    * [`bpf_ringbuf_submit_dynptr`](../helper-function/bpf_ringbuf_submit_dynptr.md)\n    * [`bpf_skb_load_bytes`](../helper-function/bpf_skb_load_bytes.md)\n    * [`bpf_skc_to_tcp6_sock`](../helper-function/bpf_skc_to_tcp6_sock.md)\n    * [`bpf_skc_to_tcp_request_sock`](../helper-function/bpf_skc_to_tcp_request_sock.md)\n    * [`bpf_skc_to_tcp_sock`](../helper-function/bpf_skc_to_tcp_sock.md)\n    * [`bpf_skc_to_tcp_timewait_sock`](../helper-function/bpf_skc_to_tcp_timewait_sock.md)\n    * [`bpf_skc_to_udp6_sock`](../helper-function/bpf_skc_to_udp6_sock.md)\n    * [`bpf_skc_to_unix_sock`](../helper-function/bpf_skc_to_unix_sock.md)\n    * [`bpf_snprintf`](../helper-function/bpf_snprintf.md)\n    * [`bpf_snprintf_btf`](../helper-function/bpf_snprintf_btf.md)\n    * [`bpf_spin_lock`](../helper-function/bpf_spin_lock.md)\n    * [`bpf_spin_unlock`](../helper-function/bpf_spin_unlock.md)\n    * [`bpf_strncmp`](../helper-function/bpf_strncmp.md)\n    * [`bpf_tail_call`](../helper-function/bpf_tail_call.md)\n    * [`bpf_task_pt_regs`](../helper-function/bpf_task_pt_regs.md)\n    * [`bpf_this_cpu_ptr`](../helper-function/bpf_this_cpu_ptr.md)\n    * [`bpf_timer_cancel`](../helper-function/bpf_timer_cancel.md)\n    * [`bpf_timer_init`](../helper-function/bpf_timer_init.md)\n    * [`bpf_timer_set_callback`](../helper-function/bpf_timer_set_callback.md)\n    * [`bpf_timer_start`](../helper-function/bpf_timer_start.md)\n    * [`bpf_trace_printk`](../helper-function/bpf_trace_printk.md)\n    * [`bpf_trace_vprintk`](../helper-function/bpf_trace_vprintk.md)\n    * [`bpf_user_ringbuf_drain`](../helper-function/bpf_user_ringbuf_drain.md)\n<!-- [/PROG_HELPER_FUNC_REF] -->\n```\n\n----------------------------------------\n\nTITLE: Defining the bpf_refcount_acquire_impl KFunc in C\nDESCRIPTION: The signature for the bpf_refcount_acquire_impl kfunc that increments refcount on a refcounted local kptr. It takes a pointer to a refcounted kernel pointer and a metadata parameter which is rewritten by the verifier. The function returns an owning reference to the object.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/bpf_refcount_acquire_impl.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nvoid *bpf_refcount_acquire_impl(void *p__refcounted_kptr, void *meta__ign)\n```\n\n----------------------------------------\n\nTITLE: Defining btf__add_btf function in C\nDESCRIPTION: Function definition for btf__add_btf, which appends all BTF types from src_btf into btf. It takes two parameters: btf and src_btf, both of type struct btf*. The function returns an integer representing the BTF type ID of the first appended BTF type or a negative error code.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/btf__add_btf.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nint btf__add_btf(struct btf *btf, const struct btf *src_btf);\n```\n\n----------------------------------------\n\nTITLE: Defining Task Structure with SCX Support (C)\nDESCRIPTION: Defines a simplified version of the Linux task_struct with focus on the SCX-specific field that contains scheduling information used by the Scheduler Extension framework.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/program-type/BPF_PROG_TYPE_STRUCT_OPS/sched_ext_ops.md#2025-04-22_snippet_50\n\nLANGUAGE: c\nCODE:\n```\nstruct task_struct {\n#ifdef CONFIG_SCHED_CLASS_EXT\n\tstruct sched_ext_entity scx;\n#endif\n};\n```\n\n----------------------------------------\n\nTITLE: Defining SCX Task Exit Arguments in C\nDESCRIPTION: Structure for passing arguments to the exit_task callback when a task is exiting from the scheduler extension. The cancelled field indicates whether the task exited before running on sched_ext.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/program-type/BPF_PROG_TYPE_STRUCT_OPS/sched_ext_ops.md#2025-04-22_snippet_56\n\nLANGUAGE: c\nCODE:\n```\nstruct scx_exit_task_args {\n\tbool cancelled;\n};\n```\n\n----------------------------------------\n\nTITLE: Declaring the 'dispatch_max_batch' Field in 'sched_ext_ops' Struct (C)\nDESCRIPTION: Declares the 'dispatch_max_batch' field within the 'sched_ext_ops' struct as an unsigned 32-bit integer. This field specifies the maximum number of tasks that the associated `dispatch` operation can handle in a single batch when selecting tasks to run.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/program-type/BPF_PROG_TYPE_STRUCT_OPS/sched_ext_ops.md#2025-04-22_snippet_2\n\nLANGUAGE: c\nCODE:\n```\nu32 dispatch_max_batch\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_map__value_size in Libbpf C\nDESCRIPTION: The function `bpf_map__value_size` returns the size of the value associated with a BPF map in bytes. It requires a pointer to the struct bpf_map as a parameter. The function is part of libbpf, which is used for interacting with BPF programs from user space.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_map__value_size.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n#!c __u32 bpf_map__value_size(const struct bpf_map *map);\n```\n\n----------------------------------------\n\nTITLE: Defining ring_buffer__add function in C\nDESCRIPTION: This snippet defines the 'ring_buffer__add' function and its callback type. It adds a new ring buffer to a ring buffer manager, taking parameters for the manager, map file descriptor, sample callback function, and context.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/ring_buffer__add.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\ntypedef int (*ring_buffer_sample_fn)(void *ctx, void *data, size_t size);\n\nint ring_buffer__add(struct ring_buffer *rb, int map_fd, ring_buffer_sample_fn sample_cb, void *ctx);\n```\n\n----------------------------------------\n\nTITLE: Function Definition: bpf_map_lookup_and_delete_batch\nDESCRIPTION: Function signature for batch lookup and deletion of BPF map elements. It allows retrieving multiple elements from a BPF map while simultaneously deleting them, supporting various map types including HASH, PERCPU_HASH, LRU_HASH, and LRU_PERCPU_HASH.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_map_lookup_and_delete_batch.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nint bpf_map_lookup_and_delete_batch(int fd, void *in_batch, void *out_batch, void *keys, void *values, __u32 *count, const struct bpf_map_batch_opts *opts);\n```\n\n----------------------------------------\n\nTITLE: CGroup Initialization Callback Definition in C\nDESCRIPTION: Callback function signature for initializing a cgroup for BPF scheduling. Takes cgroup struct and init arguments as parameters.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/program-type/BPF_PROG_TYPE_STRUCT_OPS/sched_ext_ops.md#2025-04-22_snippet_30\n\nLANGUAGE: c\nCODE:\n```\ns32 (*cgroup_init)(struct cgroup *cgrp, struct scx_cgroup_init_args *args);\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_xdp_attach_opts struct in C\nDESCRIPTION: This struct defines the options for the bpf_xdp_attach function. It includes fields for the size of the struct, the file descriptor of the old program, and a zero-sized bitfield for future expansion.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_xdp_attach.md#2025-04-22_snippet_1\n\nLANGUAGE: c\nCODE:\n```\nstruct bpf_xdp_attach_opts {\n\tsize_t sz;\n\tint old_prog_fd;\n\tsize_t :0;\n};\n```\n\n----------------------------------------\n\nTITLE: Declaring bpf_iter_kmem_cache_destroy KFunc in C\nDESCRIPTION: Function signature for the bpf_iter_kmem_cache_destroy kernel function which takes a pointer to a stack allocated struct bpf_iter_kmem_cache and destroys the iterator for slab caches. This function may sleep and can only be used from sleepable programs.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/bpf_iter_kmem_cache_destroy.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nvoid bpf_iter_kmem_cache_destroy(struct bpf_iter_kmem_cache *it)\n```\n\n----------------------------------------\n\nTITLE: Freeing a bpf_linker Object with Libbpf in C\nDESCRIPTION: Defines the 'bpf_linker__free' function in C, provided by the libbpf library, which frees the memory and resources associated with a pointer to a 'struct bpf_linker' object. The function requires libbpf to be installed and the definition of 'struct bpf_linker' to be available. The sole parameter, 'linker', is a pointer to the bpf_linker that should be released. Typically, this function returns no value and should be called when the linker is no longer needed to avoid resource leaks.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_linker__free.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nvoid bpf_linker__free(struct bpf_linker *linker);\n```\n\n----------------------------------------\n\nTITLE: Definition of bpf_lookup_user_key KFunc in C\nDESCRIPTION: The function signature for bpf_lookup_user_key which takes a serial number and flags as parameters and returns a bpf_key pointer. It looks up a key with the given serial and flags, incrementing the reference count if found.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/bpf_lookup_user_key.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstruct bpf_key *bpf_lookup_user_key(u32 serial, u64 flags)\n```\n\n----------------------------------------\n\nTITLE: Using xdp_multiprog__main_prog to Get XDP Dispatcher Program Reference in C\nDESCRIPTION: This function returns a reference to the dispatcher program from an XDP multiprog structure. It returns a struct xdp_program pointer on success, or a negative error value in case of failure.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libxdp/functions/xdp_multiprog__main_prog.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstruct xdp_program *xdp_multiprog__main_prog(const struct xdp_multiprog *mp);\n```\n\n----------------------------------------\n\nTITLE: Defining the libbpf_probe_bpf_helper function in C\nDESCRIPTION: Function signature for libbpf_probe_bpf_helper which allows checking if a specific BPF helper function is supported for a given program type. It takes parameters for program type, helper ID, and options (reserved for future use).\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/libbpf_probe_bpf_helper.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nint libbpf_probe_bpf_helper(enum bpf_prog_type prog_type, enum bpf_func_id helper_id, const void *opts);\n```\n\n----------------------------------------\n\nTITLE: Listing Supported eBPF Helper Functions in Markdown\nDESCRIPTION: This code snippet is a Markdown-formatted list of supported eBPF helper functions. Each function is linked to its respective documentation page. Some functions are tagged with version information.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/program-type/BPF_PROG_TYPE_SOCK_OPS.md#2025-04-22_snippet_6\n\nLANGUAGE: markdown\nCODE:\n```\n??? abstract \"Supported helper functions\"\n    * [`bpf_cgrp_storage_delete`](../helper-function/bpf_cgrp_storage_delete.md)\n    * [`bpf_cgrp_storage_get`](../helper-function/bpf_cgrp_storage_get.md)\n    * [`bpf_dynptr_data`](../helper-function/bpf_dynptr_data.md)\n    * [`bpf_dynptr_from_mem`](../helper-function/bpf_dynptr_from_mem.md)\n    * [`bpf_dynptr_read`](../helper-function/bpf_dynptr_read.md)\n    * [`bpf_dynptr_write`](../helper-function/bpf_dynptr_write.md)\n    * [`bpf_for_each_map_elem`](../helper-function/bpf_for_each_map_elem.md)\n    * [`bpf_get_current_pid_tgid`](../helper-function/bpf_get_current_pid_tgid.md) [:octicons-tag-24: v6.10](https://github.com/torvalds/linux/commit/eb166e522c77699fc19bfa705652327a1e51a117)\n    * [`bpf_get_current_task`](../helper-function/bpf_get_current_task.md)\n    * [`bpf_get_current_task_btf`](../helper-function/bpf_get_current_task_btf.md)\n    * [`bpf_get_local_storage`](../helper-function/bpf_get_local_storage.md)\n    * [`bpf_get_netns_cookie`](../helper-function/bpf_get_netns_cookie.md)\n    * [`bpf_get_ns_current_pid_tgid`](../helper-function/bpf_get_ns_current_pid_tgid.md) [:octicons-tag-24: v6.10](https://github.com/torvalds/linux/commit/eb166e522c77699fc19bfa705652327a1e51a117)\n    * [`bpf_get_numa_node_id`](../helper-function/bpf_get_numa_node_id.md)\n    * [`bpf_get_prandom_u32`](../helper-function/bpf_get_prandom_u32.md)\n    * [`bpf_get_smp_processor_id`](../helper-function/bpf_get_smp_processor_id.md)\n    * [`bpf_get_socket_cookie`](../helper-function/bpf_get_socket_cookie.md)\n    * [`bpf_getsockopt`](../helper-function/bpf_getsockopt.md)\n    * [`bpf_jiffies64`](../helper-function/bpf_jiffies64.md)\n    * [`bpf_kptr_xchg`](../helper-function/bpf_kptr_xchg.md)\n    * [`bpf_ktime_get_boot_ns`](../helper-function/bpf_ktime_get_boot_ns.md)\n    * [`bpf_ktime_get_coarse_ns`](../helper-function/bpf_ktime_get_coarse_ns.md)\n    * [`bpf_ktime_get_ns`](../helper-function/bpf_ktime_get_ns.md)\n    * [`bpf_ktime_get_tai_ns`](../helper-function/bpf_ktime_get_tai_ns.md)\n    * [`bpf_load_hdr_opt`](../helper-function/bpf_load_hdr_opt.md)\n    * [`bpf_loop`](../helper-function/bpf_loop.md)\n    * [`bpf_map_delete_elem`](../helper-function/bpf_map_delete_elem.md)\n    * [`bpf_map_lookup_elem`](../helper-function/bpf_map_lookup_elem.md)\n    * [`bpf_map_lookup_percpu_elem`](../helper-function/bpf_map_lookup_percpu_elem.md)\n    * [`bpf_map_peek_elem`](../helper-function/bpf_map_peek_elem.md)\n    * [`bpf_map_pop_elem`](../helper-function/bpf_map_pop_elem.md)\n    * [`bpf_map_push_elem`](../helper-function/bpf_map_push_elem.md)\n    * [`bpf_map_update_elem`](../helper-function/bpf_map_update_elem.md)\n    * [`bpf_per_cpu_ptr`](../helper-function/bpf_per_cpu_ptr.md)\n    * [`bpf_perf_event_output`](../helper-function/bpf_perf_event_output.md)\n    * [`bpf_probe_read_kernel`](../helper-function/bpf_probe_read_kernel.md)\n    * [`bpf_probe_read_kernel_str`](../helper-function/bpf_probe_read_kernel_str.md)\n    * [`bpf_probe_read_user`](../helper-function/bpf_probe_read_user.md)\n    * [`bpf_probe_read_user_str`](../helper-function/bpf_probe_read_user_str.md)\n    * [`bpf_reserve_hdr_opt`](../helper-function/bpf_reserve_hdr_opt.md)\n    * [`bpf_ringbuf_discard`](../helper-function/bpf_ringbuf_discard.md)\n    * [`bpf_ringbuf_discard_dynptr`](../helper-function/bpf_ringbuf_discard_dynptr.md)\n    * [`bpf_ringbuf_output`](../helper-function/bpf_ringbuf_output.md)\n    * [`bpf_ringbuf_query`](../helper-function/bpf_ringbuf_query.md)\n    * [`bpf_ringbuf_reserve`](../helper-function/bpf_ringbuf_reserve.md)\n    * [`bpf_ringbuf_reserve_dynptr`](../helper-function/bpf_ringbuf_reserve_dynptr.md)\n    * [`bpf_ringbuf_submit`](../helper-function/bpf_ringbuf_submit.md)\n    * [`bpf_ringbuf_submit_dynptr`](../helper-function/bpf_ringbuf_submit_dynptr.md)\n    * [`bpf_setsockopt`](../helper-function/bpf_setsockopt.md)\n    * [`bpf_sk_storage_delete`](../helper-function/bpf_sk_storage_delete.md)\n    * [`bpf_sk_storage_get`](../helper-function/bpf_sk_storage_get.md)\n    * [`bpf_skc_to_tcp6_sock`](../helper-function/bpf_skc_to_tcp6_sock.md)\n    * [`bpf_skc_to_tcp_request_sock`](../helper-function/bpf_skc_to_tcp_request_sock.md)\n    * [`bpf_skc_to_tcp_sock`](../helper-function/bpf_skc_to_tcp_sock.md)\n    * [`bpf_skc_to_tcp_timewait_sock`](../helper-function/bpf_skc_to_tcp_timewait_sock.md)\n    * [`bpf_skc_to_udp6_sock`](../helper-function/bpf_skc_to_udp6_sock.md)\n    * [`bpf_skc_to_unix_sock`](../helper-function/bpf_skc_to_unix_sock.md)\n    * [`bpf_snprintf`](../helper-function/bpf_snprintf.md)\n    * [`bpf_snprintf_btf`](../helper-function/bpf_snprintf_btf.md)\n    * [`bpf_sock_hash_update`](../helper-function/bpf_sock_hash_update.md)\n    * [`bpf_sock_map_update`](../helper-function/bpf_sock_map_update.md)\n    * [`bpf_sock_ops_cb_flags_set`](../helper-function/bpf_sock_ops_cb_flags_set.md)\n    * [`bpf_spin_lock`](../helper-function/bpf_spin_lock.md)\n    * [`bpf_spin_unlock`](../helper-function/bpf_spin_unlock.md)\n    * [`bpf_store_hdr_opt`](../helper-function/bpf_store_hdr_opt.md)\n    * [`bpf_strncmp`](../helper-function/bpf_strncmp.md)\n    * [`bpf_tail_call`](../helper-function/bpf_tail_call.md)\n    * [`bpf_task_pt_regs`](../helper-function/bpf_task_pt_regs.md)\n    * [`bpf_tcp_sock`](../helper-function/bpf_tcp_sock.md)\n    * [`bpf_this_cpu_ptr`](../helper-function/bpf_this_cpu_ptr.md)\n    * [`bpf_timer_cancel`](../helper-function/bpf_timer_cancel.md)\n    * [`bpf_timer_init`](../helper-function/bpf_timer_init.md)\n    * [`bpf_timer_set_callback`](../helper-function/bpf_timer_set_callback.md)\n    * [`bpf_timer_start`](../helper-function/bpf_timer_start.md)\n    * [`bpf_trace_printk`](../helper-function/bpf_trace_printk.md)\n    * [`bpf_trace_vprintk`](../helper-function/bpf_trace_vprintk.md)\n    * [`bpf_user_ringbuf_drain`](../helper-function/bpf_user_ringbuf_drain.md)\n```\n\n----------------------------------------\n\nTITLE: Using xsk_umem__extract_addr Function in C\nDESCRIPTION: A function signature example showing how to use xsk_umem__extract_addr to extract memory address in unaligned mode. It returns a __u64 representation of the address.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libxdp/functions/xsk_umem__extract_addr.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n__u64 xsk_umem__extract_addr(__u64 addr);\n```\n\n----------------------------------------\n\nTITLE: Using BPF_PROBE_READ_USER_INTO macro in C\nDESCRIPTION: This snippet shows how to use the BPF_PROBE_READ_USER_INTO macro. It reads the value into a provided destination variable, which is equivalent to the BPF_PROBE_READ_USER example above.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/ebpf/BPF_PROBE_READ_USER_INTO.md#2025-04-22_snippet_2\n\nLANGUAGE: c\nCODE:\n```\nint x;\nBPF_PROBE_READ_USER_INTO(&x, s, a.b.c, d.e, f, g);\n```\n\n----------------------------------------\n\nTITLE: Using WRITE_ONCE macro for ordered memory writes in C\nDESCRIPTION: This example demonstrates the use of the WRITE_ONCE macro to ensure writes to memory occur in a specific order, preventing compiler optimizations that might reorder writes for cache locality improvements.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/scx/WRITE_ONCE.md#2025-04-22_snippet_1\n\nLANGUAGE: c\nCODE:\n```\nWRITE_ONCE(shared_data->field1, 1);\nWRITE_ONCE(some_other_var, true);\nWRITE_ONCE(shared_data->field2, 2);\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_obj_drop Macro in C\nDESCRIPTION: This macro wraps the bpf_obj_drop_impl kfunc to provide a more ergonomic interface by automatically passing NULL as the second parameter, abstracting away this implementation quirk.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/scx/bpf_obj_drop.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n#define bpf_obj_drop(kptr) bpf_obj_drop_impl(kptr, NULL)\n```\n\n----------------------------------------\n\nTITLE: Listing Supported eBPF Helper Functions for Socket Filters (Markdown)\nDESCRIPTION: This Markdown snippet displays a list of eBPF helper functions available for use within socket filter programs. Each function name is linked to its detailed documentation page, with some indicating the kernel version they were introduced in. The list is presented within an expandable `??? abstract` block for better organization and includes comments indicating potential auto-generation (`<!-- [PROG_HELPER_FUNC_REF] -->`).\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/program-type/BPF_PROG_TYPE_SOCKET_FILTER.md#2025-04-22_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n<!-- DO NOT EDIT MANUALLY -->\n<!-- [PROG_HELPER_FUNC_REF] -->\n??? abstract \"Supported helper functions\"\n    * [`bpf_cgrp_storage_delete`](../helper-function/bpf_cgrp_storage_delete.md)\n    * [`bpf_cgrp_storage_get`](../helper-function/bpf_cgrp_storage_get.md)\n    * [`bpf_dynptr_data`](../helper-function/bpf_dynptr_data.md)\n    * [`bpf_dynptr_from_mem`](../helper-function/bpf_dynptr_from_mem.md)\n    * [`bpf_dynptr_read`](../helper-function/bpf_dynptr_read.md)\n    * [`bpf_dynptr_write`](../helper-function/bpf_dynptr_write.md)\n    * [`bpf_for_each_map_elem`](../helper-function/bpf_for_each_map_elem.md)\n    * [`bpf_get_current_pid_tgid`](../helper-function/bpf_get_current_pid_tgid.md) [:octicons-tag-24: v6.10](https://github.com/torvalds/linux/commit/eb166e522c77699fc19bfa705652327a1e51a117)\n    * [`bpf_get_current_task`](../helper-function/bpf_get_current_task.md)\n    * [`bpf_get_current_task_btf`](../helper-function/bpf_get_current_task_btf.md)\n    * [`bpf_get_ns_current_pid_tgid`](../helper-function/bpf_get_ns_current_pid_tgid.md) [:octicons-tag-24: v6.10](https://github.com/torvalds/linux/commit/eb166e522c77699fc19bfa705652327a1e51a117)\n    * [`bpf_get_numa_node_id`](../helper-function/bpf_get_numa_node_id.md)\n    * [`bpf_get_prandom_u32`](../helper-function/bpf_get_prandom_u32.md)\n    * [`bpf_get_smp_processor_id`](../helper-function/bpf_get_smp_processor_id.md)\n    * [`bpf_get_socket_cookie`](../helper-function/bpf_get_socket_cookie.md)\n    * [`bpf_get_socket_uid`](../helper-function/bpf_get_socket_uid.md)\n    * [`bpf_jiffies64`](../helper-function/bpf_jiffies64.md)\n    * [`bpf_kptr_xchg`](../helper-function/bpf_kptr_xchg.md)\n    * [`bpf_ktime_get_boot_ns`](../helper-function/bpf_ktime_get_boot_ns.md)\n    * [`bpf_ktime_get_ns`](../helper-function/bpf_ktime_get_ns.md)\n    * [`bpf_ktime_get_tai_ns`](../helper-function/bpf_ktime_get_tai_ns.md)\n    * [`bpf_loop`](../helper-function/bpf_loop.md)\n    * [`bpf_map_delete_elem`](../helper-function/bpf_map_delete_elem.md)\n    * [`bpf_map_lookup_elem`](../helper-function/bpf_map_lookup_elem.md)\n    * [`bpf_map_lookup_percpu_elem`](../helper-function/bpf_map_lookup_percpu_elem.md)\n    * [`bpf_map_peek_elem`](../helper-function/bpf_map_peek_elem.md)\n    * [`bpf_map_pop_elem`](../helper-function/bpf_map_pop_elem.md)\n    * [`bpf_map_push_elem`](../helper-function/bpf_map_push_elem.md)\n    * [`bpf_map_update_elem`](../helper-function/bpf_map_update_elem.md)\n    * [`bpf_per_cpu_ptr`](../helper-function/bpf_per_cpu_ptr.md)\n    * [`bpf_perf_event_output`](../helper-function/bpf_perf_event_output.md)\n    * [`bpf_probe_read_kernel`](../helper-function/bpf_probe_read_kernel.md)\n    * [`bpf_probe_read_kernel_str`](../helper-function/bpf_probe_read_kernel_str.md)\n    * [`bpf_probe_read_user`](../helper-function/bpf_probe_read_user.md)\n    * [`bpf_probe_read_user_str`](../helper-function/bpf_probe_read_user_str.md)\n    * [`bpf_ringbuf_discard`](../helper-function/bpf_ringbuf_discard.md)\n    * [`bpf_ringbuf_discard_dynptr`](../helper-function/bpf_ringbuf_discard_dynptr.md)\n    * [`bpf_ringbuf_output`](../helper-function/bpf_ringbuf_output.md)\n    * [`bpf_ringbuf_query`](../helper-function/bpf_ringbuf_query.md)\n    * [`bpf_ringbuf_reserve`](../helper-function/bpf_ringbuf_reserve.md)\n    * [`bpf_ringbuf_reserve_dynptr`](../helper-function/bpf_ringbuf_reserve_dynptr.md)\n    * [`bpf_ringbuf_submit`](../helper-function/bpf_ringbuf_submit.md)\n    * [`bpf_ringbuf_submit_dynptr`](../helper-function/bpf_ringbuf_submit_dynptr.md)\n    * [`bpf_skb_load_bytes`](../helper-function/bpf_skb_load_bytes.md)\n    * [`bpf_skb_load_bytes_relative`](../helper-function/bpf_skb_load_bytes_relative.md)\n    * [`bpf_snprintf`](../helper-function/bpf_snprintf.md)\n    * [`bpf_snprintf_btf`](../helper-function/bpf_snprintf_btf.md)\n    * [`bpf_spin_lock`](../helper-function/bpf_spin_lock.md)\n    * [`bpf_spin_unlock`](../helper-function/bpf_spin_unlock.md)\n    * [`bpf_strncmp`](../helper-function/bpf_strncmp.md)\n    * [`bpf_tail_call`](../helper-function/bpf_tail_call.md)\n    * [`bpf_task_pt_regs`](../helper-function/bpf_task_pt_regs.md)\n    * [`bpf_this_cpu_ptr`](../helper-function/bpf_this_cpu_ptr.md)\n    * [`bpf_timer_cancel`](../helper-function/bpf_timer_cancel.md)\n    * [`bpf_timer_init`](../helper-function/bpf_timer_init.md)\n    * [`bpf_timer_set_callback`](../helper-function/bpf_timer_set_callback.md)\n    * [`bpf_timer_start`](../helper-function/bpf_timer_start.md)\n    * [`bpf_trace_printk`](../helper-function/bpf_trace_printk.md)\n    * [`bpf_trace_vprintk`](../helper-function/bpf_trace_vprintk.md)\n    * [`bpf_user_ringbuf_drain`](../helper-function/bpf_user_ringbuf_drain.md)\n<!-- [/PROG_HELPER_FUNC_REF] -->\n```\n\n----------------------------------------\n\nTITLE: Defining the dctcp_cwnd_undo KFunc Signature in C\nDESCRIPTION: This C snippet defines the signature for the Linux kernel function 'dctcp_cwnd_undo', callable from eBPF programs. It accepts a pointer to a socket structure ('struct sock *sk') and returns the calculated congestion window ('u32') after a loss event, implementing part of the DCTCP logic. This function is intended for use within BPF programs of type BPF_PROG_TYPE_STRUCT_OPS, available since Linux kernel v5.13.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/dctcp_cwnd_undo.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n`#!c u32 dctcp_cwnd_undo(struct sock *sk)`\n```\n\n----------------------------------------\n\nTITLE: Freeing BTF Extension Object Definition\nDESCRIPTION: Function definition for btf_ext__free that takes a BTF extension object pointer and frees its associated resources.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/btf_ext__free.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nvoid btf_ext__free(struct btf_ext *btf_ext);\n```\n\n----------------------------------------\n\nTITLE: Listing Supported eBPF Helper Functions in Markdown\nDESCRIPTION: This code snippet uses Markdown syntax to create a collapsible section listing all supported eBPF helper functions. Each function is linked to its corresponding documentation page, and some functions are tagged with version information.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/program-type/BPF_PROG_TYPE_CGROUP_SKB.md#2025-04-22_snippet_1\n\nLANGUAGE: markdown\nCODE:\n```\n??? abstract \"Supported helper functions\"\n    * [`bpf_cgrp_storage_delete`](../helper-function/bpf_cgrp_storage_delete.md)\n    * [`bpf_cgrp_storage_get`](../helper-function/bpf_cgrp_storage_get.md)\n    * [`bpf_dynptr_data`](../helper-function/bpf_dynptr_data.md)\n    * [`bpf_dynptr_from_mem`](../helper-function/bpf_dynptr_from_mem.md)\n    * [`bpf_dynptr_read`](../helper-function/bpf_dynptr_read.md)\n    * [`bpf_dynptr_write`](../helper-function/bpf_dynptr_write.md)\n    * [`bpf_for_each_map_elem`](../helper-function/bpf_for_each_map_elem.md)\n    * [`bpf_get_current_pid_tgid`](../helper-function/bpf_get_current_pid_tgid.md) [:octicons-tag-24: v6.10](https://github.com/torvalds/linux/commit/eb166e522c77699fc19bfa705652327a1e51a117)\n    * [`bpf_get_current_task`](../helper-function/bpf_get_current_task.md)\n    * [`bpf_get_current_task_btf`](../helper-function/bpf_get_current_task_btf.md)\n    * [`bpf_get_listener_sock`](../helper-function/bpf_get_listener_sock.md)\n    * [`bpf_get_local_storage`](../helper-function/bpf_get_local_storage.md)\n    * [`bpf_get_ns_current_pid_tgid`](../helper-function/bpf_get_ns_current_pid_tgid.md) [:octicons-tag-24: v6.10](https://github.com/torvalds/linux/commit/eb166e522c77699fc19bfa705652327a1e51a117)\n    * [`bpf_get_numa_node_id`](../helper-function/bpf_get_numa_node_id.md)\n    * [`bpf_get_prandom_u32`](../helper-function/bpf_get_prandom_u32.md)\n    * [`bpf_get_smp_processor_id`](../helper-function/bpf_get_smp_processor_id.md)\n    * [`bpf_get_socket_cookie`](../helper-function/bpf_get_socket_cookie.md)\n    * [`bpf_get_socket_uid`](../helper-function/bpf_get_socket_uid.md)\n    * [`bpf_jiffies64`](../helper-function/bpf_jiffies64.md)\n    * [`bpf_kptr_xchg`](../helper-function/bpf_kptr_xchg.md)\n    * [`bpf_ktime_get_boot_ns`](../helper-function/bpf_ktime_get_boot_ns.md)\n    * [`bpf_ktime_get_ns`](../helper-function/bpf_ktime_get_ns.md)\n    * [`bpf_ktime_get_tai_ns`](../helper-function/bpf_ktime_get_tai_ns.md)\n    * [`bpf_loop`](../helper-function/bpf_loop.md)\n    * [`bpf_map_delete_elem`](../helper-function/bpf_map_delete_elem.md)\n    * [`bpf_map_lookup_elem`](../helper-function/bpf_map_lookup_elem.md)\n    * [`bpf_map_lookup_percpu_elem`](../helper-function/bpf_map_lookup_percpu_elem.md)\n    * [`bpf_map_peek_elem`](../helper-function/bpf_map_peek_elem.md)\n    * [`bpf_map_pop_elem`](../helper-function/bpf_map_pop_elem.md)\n    * [`bpf_map_push_elem`](../helper-function/bpf_map_push_elem.md)\n    * [`bpf_map_update_elem`](../helper-function/bpf_map_update_elem.md)\n    * [`bpf_per_cpu_ptr`](../helper-function/bpf_per_cpu_ptr.md)\n    * [`bpf_perf_event_output`](../helper-function/bpf_perf_event_output.md)\n    * [`bpf_probe_read_kernel`](../helper-function/bpf_probe_read_kernel.md)\n    * [`bpf_probe_read_kernel_str`](../helper-function/bpf_probe_read_kernel_str.md)\n    * [`bpf_probe_read_user`](../helper-function/bpf_probe_read_user.md)\n    * [`bpf_probe_read_user_str`](../helper-function/bpf_probe_read_user_str.md)\n    * [`bpf_ringbuf_discard`](../helper-function/bpf_ringbuf_discard.md)\n    * [`bpf_ringbuf_discard_dynptr`](../helper-function/bpf_ringbuf_discard_dynptr.md)\n    * [`bpf_ringbuf_output`](../helper-function/bpf_ringbuf_output.md)\n    * [`bpf_ringbuf_query`](../helper-function/bpf_ringbuf_query.md)\n    * [`bpf_ringbuf_reserve`](../helper-function/bpf_ringbuf_reserve.md)\n    * [`bpf_ringbuf_reserve_dynptr`](../helper-function/bpf_ringbuf_reserve_dynptr.md)\n    * [`bpf_ringbuf_submit`](../helper-function/bpf_ringbuf_submit.md)\n    * [`bpf_ringbuf_submit_dynptr`](../helper-function/bpf_ringbuf_submit_dynptr.md)\n    * [`bpf_sk_ancestor_cgroup_id`](../helper-function/bpf_sk_ancestor_cgroup_id.md)\n    * [`bpf_sk_cgroup_id`](../helper-function/bpf_sk_cgroup_id.md)\n    * [`bpf_sk_fullsock`](../helper-function/bpf_sk_fullsock.md)\n    * [`bpf_sk_lookup_tcp`](../helper-function/bpf_sk_lookup_tcp.md)\n    * [`bpf_sk_lookup_udp`](../helper-function/bpf_sk_lookup_udp.md)\n    * [`bpf_sk_release`](../helper-function/bpf_sk_release.md)\n    * [`bpf_sk_storage_delete`](../helper-function/bpf_sk_storage_delete.md)\n    * [`bpf_sk_storage_get`](../helper-function/bpf_sk_storage_get.md)\n    * [`bpf_skb_ancestor_cgroup_id`](../helper-function/bpf_skb_ancestor_cgroup_id.md)\n    * [`bpf_skb_cgroup_id`](../helper-function/bpf_skb_cgroup_id.md)\n    * [`bpf_skb_ecn_set_ce`](../helper-function/bpf_skb_ecn_set_ce.md)\n    * [`bpf_skb_load_bytes`](../helper-function/bpf_skb_load_bytes.md)\n    * [`bpf_skb_load_bytes_relative`](../helper-function/bpf_skb_load_bytes_relative.md)\n    * [`bpf_skc_lookup_tcp`](../helper-function/bpf_skc_lookup_tcp.md)\n    * [`bpf_snprintf`](../helper-function/bpf_snprintf.md)\n    * [`bpf_snprintf_btf`](../helper-function/bpf_snprintf_btf.md)\n    * [`bpf_spin_lock`](../helper-function/bpf_spin_lock.md)\n    * [`bpf_spin_unlock`](../helper-function/bpf_spin_unlock.md)\n    * [`bpf_strncmp`](../helper-function/bpf_strncmp.md)\n    * [`bpf_tail_call`](../helper-function/bpf_tail_call.md)\n    * [`bpf_task_pt_regs`](../helper-function/bpf_task_pt_regs.md)\n    * [`bpf_tcp_sock`](../helper-function/bpf_tcp_sock.md)\n    * [`bpf_this_cpu_ptr`](../helper-function/bpf_this_cpu_ptr.md)\n    * [`bpf_timer_cancel`](../helper-function/bpf_timer_cancel.md)\n    * [`bpf_timer_init`](../helper-function/bpf_timer_init.md)\n    * [`bpf_timer_set_callback`](../helper-function/bpf_timer_set_callback.md)\n    * [`bpf_timer_start`](../helper-function/bpf_timer_start.md)\n    * [`bpf_trace_printk`](../helper-function/bpf_trace_printk.md)\n    * [`bpf_trace_vprintk`](../helper-function/bpf_trace_vprintk.md)\n    * [`bpf_user_ringbuf_drain`](../helper-function/bpf_user_ringbuf_drain.md)\n```\n\n----------------------------------------\n\nTITLE: Defining btf__parse Function in C\nDESCRIPTION: Function signature for btf__parse, which parses BTF data from a file. It takes a file path and a double pointer for BTF extension data as parameters. Returns a pointer to a struct btf object on success, or NULL on failure.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/btf__parse.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstruct btf *btf__parse(const char *path, struct btf_ext **btf_ext);\n```\n\n----------------------------------------\n\nTITLE: Listing Supported eBPF Kernel Functions\nDESCRIPTION: Markdown list of all supported kernel functions that can be called from eBPF programs, including links to their detailed documentation. The functions are grouped into categories like memory management, dynamic pointers, iterators, and synchronization primitives.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/program-type/BPF_PROG_TYPE_SK_SKB.md#2025-04-22_snippet_3\n\nLANGUAGE: markdown\nCODE:\n```\n??? abstract \"Supported kfuncs\"\n    - [`bpf_arena_alloc_pages`](../kfuncs/bpf_arena_alloc_pages.md)\n    - [`bpf_arena_free_pages`](../kfuncs/bpf_arena_free_pages.md)\n    - [`bpf_cast_to_kern_ctx`](../kfuncs/bpf_cast_to_kern_ctx.md)\n    - [`bpf_copy_from_user_str`](../kfuncs/bpf_copy_from_user_str.md)\n    - [`bpf_dynptr_adjust`](../kfuncs/bpf_dynptr_adjust.md)\n    - [`bpf_dynptr_clone`](../kfuncs/bpf_dynptr_clone.md)\n    - [`bpf_dynptr_from_skb`](../kfuncs/bpf_dynptr_from_skb.md)\n    - [`bpf_dynptr_is_null`](../kfuncs/bpf_dynptr_is_null.md)\n    - [`bpf_dynptr_is_rdonly`](../kfuncs/bpf_dynptr_is_rdonly.md)\n    - [`bpf_dynptr_size`](../kfuncs/bpf_dynptr_size.md)\n    - [`bpf_dynptr_slice`](../kfuncs/bpf_dynptr_slice.md)\n    - [`bpf_dynptr_slice_rdwr`](../kfuncs/bpf_dynptr_slice_rdwr.md)\n    - [`bpf_get_kmem_cache`](../kfuncs/bpf_get_kmem_cache.md)\n    - [`bpf_iter_bits_destroy`](../kfuncs/bpf_iter_bits_destroy.md)\n    - [`bpf_iter_bits_new`](../kfuncs/bpf_iter_bits_new.md)\n    - [`bpf_iter_bits_next`](../kfuncs/bpf_iter_bits_next.md)\n    - [`bpf_iter_css_destroy`](../kfuncs/bpf_iter_css_destroy.md)\n    - [`bpf_iter_css_new`](../kfuncs/bpf_iter_css_new.md)\n    - [`bpf_iter_css_next`](../kfuncs/bpf_iter_css_next.md)\n    - [`bpf_iter_css_task_destroy`](../kfuncs/bpf_iter_css_task_destroy.md)\n    - [`bpf_iter_css_task_new`](../kfuncs/bpf_iter_css_task_new.md)\n    - [`bpf_iter_css_task_next`](../kfuncs/bpf_iter_css_task_next.md)\n    - [`bpf_iter_kmem_cache_destroy`](../kfuncs/bpf_iter_kmem_cache_destroy.md)\n    - [`bpf_iter_kmem_cache_new`](../kfuncs/bpf_iter_kmem_cache_new.md)\n    - [`bpf_iter_kmem_cache_next`](../kfuncs/bpf_iter_kmem_cache_next.md)\n    - [`bpf_iter_num_destroy`](../kfuncs/bpf_iter_num_destroy.md)\n    - [`bpf_iter_num_new`](../kfuncs/bpf_iter_num_new.md)\n    - [`bpf_iter_num_next`](../kfuncs/bpf_iter_num_next.md)\n    - [`bpf_iter_task_destroy`](../kfuncs/bpf_iter_task_destroy.md)\n    - [`bpf_iter_task_new`](../kfuncs/bpf_iter_task_new.md)\n    - [`bpf_iter_task_next`](../kfuncs/bpf_iter_task_next.md)\n    - [`bpf_iter_task_vma_destroy`](../kfuncs/bpf_iter_task_vma_destroy.md)\n    - [`bpf_iter_task_vma_new`](../kfuncs/bpf_iter_task_vma_new.md)\n    - [`bpf_iter_task_vma_next`](../kfuncs/bpf_iter_task_vma_next.md)\n    - [`bpf_local_irq_restore`](../kfuncs/bpf_local_irq_restore.md)\n    - [`bpf_local_irq_save`](../kfuncs/bpf_local_irq_save.md)\n    - [`bpf_map_sum_elem_count`](../kfuncs/bpf_map_sum_elem_count.md)\n    - [`bpf_preempt_disable`](../kfuncs/bpf_preempt_disable.md)\n    - [`bpf_preempt_enable`](../kfuncs/bpf_preempt_enable.md)\n    - [`bpf_rcu_read_lock`](../kfuncs/bpf_rcu_read_lock.md)\n    - [`bpf_rcu_read_unlock`](../kfuncs/bpf_rcu_read_unlock.md)\n    - [`bpf_rdonly_cast`](../kfuncs/bpf_rdonly_cast.md)\n    - [`bpf_wq_init`](../kfuncs/bpf_wq_init.md)\n    - [`bpf_wq_set_callback_impl`](../kfuncs/bpf_wq_set_callback_impl.md)\n    - [`bpf_wq_start`](../kfuncs/bpf_wq_start.md)\n```\n\n----------------------------------------\n\nTITLE: Definition of bpf_object__open_skeleton function in C\nDESCRIPTION: The function signature for bpf_object__open_skeleton which takes a skeleton structure to populate and options for opening the BPF object. It returns an integer value, likely indicating success or failure.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_object__open_skeleton.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nint bpf_object__open_skeleton(struct bpf_object_skeleton *s, const struct bpf_object_open_opts *opts);\n```\n\n----------------------------------------\n\nTITLE: Defining scx_bpf_cpuperf_cur KFunc in C\nDESCRIPTION: Function signature for the scx_bpf_cpuperf_cur kfunc. It takes a CPU number as input and returns the current relative performance of that CPU.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/scx_bpf_cpuperf_cur.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nu32 scx_bpf_cpuperf_cur(s32 cpu)\n```\n\n----------------------------------------\n\nTITLE: BPF_F_STRICT_ALIGNMENT Flag Documentation\nDESCRIPTION: Documents the BPF_F_STRICT_ALIGNMENT flag (introduced in v4.12) which enforces strict alignment checking during verification as if CONFIG_EFFICIENT_UNALIGNED_ACCESS is not set and NET_IP_ALIGN is defined as 2.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/syscall/BPF_PROG_LOAD.md#2025-04-22_snippet_2\n\nLANGUAGE: markdown\nCODE:\n```\n### `BPF_F_STRICT_ALIGNMENT`\n\n<!-- [FEATURE_TAG](BPF_F_STRICT_ALIGNMENT) -->\n[:octicons-tag-24: v4.12](https://github.com/torvalds/linux/commit/e07b98d9bffe410019dfcf62c3428d4a96c56a2c)\n<!-- [/FEATURE_TAG] -->\n\nIf `BPF_F_STRICT_ALIGNMENT` is used in `BPF_PROG_LOAD` command, the verifier will perform strict alignment checking as if the kernel has been built with `CONFIG_EFFICIENT_UNALIGNED_ACCESS` not set, and `NET_IP_ALIGN` defined to 2.\n```\n\n----------------------------------------\n\nTITLE: Using Libbpf Macro for Numeric Iteration\nDESCRIPTION: Shows a more concise way to perform numeric iteration using the bpf_for macro provided by libbpf, which handles iterator setup and cleanup automatically.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/bpf_iter_num_new.md#2025-04-22_snippet_1\n\nLANGUAGE: c\nCODE:\n```\nint *v;\n\nbpf_for(v, start, end) {\n    bpf_printk(\"X = %d\", *v);\n}\n```\n\n----------------------------------------\n\nTITLE: Listing Supported eBPF Helper Functions for LWT Programs\nDESCRIPTION: This Markdown snippet lists the eBPF helper functions available for use within Lightweight Tunnel (LWT) programs. Each function name links to its corresponding detailed documentation page. The list is presented within an expandable 'abstract' block.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/program-type/BPF_PROG_TYPE_LWT_IN.md#2025-04-22_snippet_1\n\nLANGUAGE: markdown\nCODE:\n```\n<!-- DO NOT EDIT MANUALLY -->\n<!-- [PROG_HELPER_FUNC_REF] -->\n??? abstract \"Supported helper functions\"\n    * [`bpf_cgrp_storage_delete`](../helper-function/bpf_cgrp_storage_delete.md)\n    * [`bpf_cgrp_storage_get`](../helper-function/bpf_cgrp_storage_get.md)\n    * [`bpf_csum_diff`](../helper-function/bpf_csum_diff.md)\n    * [`bpf_dynptr_data`](../helper-function/bpf_dynptr_data.md)\n    * [`bpf_dynptr_from_mem`](../helper-function/bpf_dynptr_from_mem.md)\n    * [`bpf_dynptr_read`](../helper-function/bpf_dynptr_read.md)\n    * [`bpf_dynptr_write`](../helper-function/bpf_dynptr_write.md)\n    * [`bpf_for_each_map_elem`](../helper-function/bpf_for_each_map_elem.md)\n    * [`bpf_get_cgroup_classid`](../helper-function/bpf_get_cgroup_classid.md)\n    * [`bpf_get_current_pid_tgid`](../helper-function/bpf_get_current_pid_tgid.md) [:octicons-tag-24: v6.10](https://github.com/torvalds/linux/commit/eb166e522c77699fc19bfa705652327a1e51a117)\n    * [`bpf_get_current_task`](../helper-function/bpf_get_current_task.md)\n    * [`bpf_get_current_task_btf`](../helper-function/bpf_get_current_task_btf.md)\n    * [`bpf_get_hash_recalc`](../helper-function/bpf_get_hash_recalc.md)\n    * [`bpf_get_ns_current_pid_tgid`](../helper-function/bpf_get_ns_current_pid_tgid.md) [:octicons-tag-24: v6.10](https://github.com/torvalds/linux/commit/eb166e522c77699fc19bfa705652327a1e51a117)\n    * [`bpf_get_numa_node_id`](../helper-function/bpf_get_numa_node_id.md)\n    * [`bpf_get_prandom_u32`](../helper-function/bpf_get_prandom_u32.md)\n    * [`bpf_get_route_realm`](../helper-function/bpf_get_route_realm.md)\n    * [`bpf_get_smp_processor_id`](../helper-function/bpf_get_smp_processor_id.md)\n    * [`bpf_jiffies64`](../helper-function/bpf_jiffies64.md)\n    * [`bpf_kptr_xchg`](../helper-function/bpf_kptr_xchg.md)\n    * [`bpf_ktime_get_boot_ns`](../helper-function/bpf_ktime_get_boot_ns.md)\n    * [`bpf_ktime_get_ns`](../helper-function/bpf_ktime_get_ns.md)\n    * [`bpf_ktime_get_tai_ns`](../helper-function/bpf_ktime_get_tai_ns.md)\n    * [`bpf_loop`](../helper-function/bpf_loop.md)\n    * [`bpf_lwt_push_encap`](../helper-function/bpf_lwt_push_encap.md)\n    * [`bpf_map_delete_elem`](../helper-function/bpf_map_delete_elem.md)\n    * [`bpf_map_lookup_elem`](../helper-function/bpf_map_lookup_elem.md)\n    * [`bpf_map_lookup_percpu_elem`](../helper-function/bpf_map_lookup_percpu_elem.md)\n    * [`bpf_map_peek_elem`](../helper-function/bpf_map_peek_elem.md)\n    * [`bpf_map_pop_elem`](../helper-function/bpf_map_pop_elem.md)\n    * [`bpf_map_push_elem`](../helper-function/bpf_map_push_elem.md)\n    * [`bpf_map_update_elem`](../helper-function/bpf_map_update_elem.md)\n    * [`bpf_per_cpu_ptr`](../helper-function/bpf_per_cpu_ptr.md)\n    * [`bpf_perf_event_output`](../helper-function/bpf_perf_event_output.md)\n    * [`bpf_probe_read_kernel`](../helper-function/bpf_probe_read_kernel.md)\n    * [`bpf_probe_read_kernel_str`](../helper-function/bpf_probe_read_kernel_str.md)\n    * [`bpf_probe_read_user`](../helper-function/bpf_probe_read_user.md)\n    * [`bpf_probe_read_user_str`](../helper-function/bpf_probe_read_user_str.md)\n    * [`bpf_ringbuf_discard`](../helper-function/bpf_ringbuf_discard.md)\n    * [`bpf_ringbuf_discard_dynptr`](../helper-function/bpf_ringbuf_discard_dynptr.md)\n    * [`bpf_ringbuf_output`](../helper-function/bpf_ringbuf_output.md)\n    * [`bpf_ringbuf_query`](../helper-function/bpf_ringbuf_query.md)\n    * [`bpf_ringbuf_reserve`](../helper-function/bpf_ringbuf_reserve.md)\n    * [`bpf_ringbuf_reserve_dynptr`](../helper-function/bpf_ringbuf_reserve_dynptr.md)\n    * [`bpf_ringbuf_submit`](../helper-function/bpf_ringbuf_submit.md)\n    * [`bpf_ringbuf_submit_dynptr`](../helper-function/bpf_ringbuf_submit_dynptr.md)\n    * [`bpf_skb_load_bytes`](../helper-function/bpf_skb_load_bytes.md)\n    * [`bpf_skb_pull_data`](../helper-function/bpf_skb_pull_data.md)\n    * [`bpf_skb_under_cgroup`](../helper-function/bpf_skb_under_cgroup.md)\n    * [`bpf_snprintf`](../helper-function/bpf_snprintf.md)\n    * [`bpf_snprintf_btf`](../helper-function/bpf_snprintf_btf.md)\n    * [`bpf_spin_lock`](../helper-function/bpf_spin_lock.md)\n    * [`bpf_spin_unlock`](../helper-function/bpf_spin_unlock.md)\n    * [`bpf_strncmp`](../helper-function/bpf_strncmp.md)\n    * [`bpf_tail_call`](../helper-function/bpf_tail_call.md)\n    * [`bpf_task_pt_regs`](../helper-function/bpf_task_pt_regs.md)\n    * [`bpf_this_cpu_ptr`](../helper-function/bpf_this_cpu_ptr.md)\n    * [`bpf_timer_cancel`](../helper-function/bpf_timer_cancel.md)\n    * [`bpf_timer_init`](../helper-function/bpf_timer_init.md)\n    * [`bpf_timer_set_callback`](../helper-function/bpf_timer_set_callback.md)\n    * [`bpf_timer_start`](../helper-function/bpf_timer_start.md)\n    * [`bpf_trace_printk`](../helper-function/bpf_trace_printk.md)\n    * [`bpf_trace_vprintk`](../helper-function/bpf_trace_vprintk.md)\n    * [`bpf_user_ringbuf_drain`](../helper-function/bpf_user_ringbuf_drain.md)\n<!-- [/PROG_HELPER_FUNC_REF] -->\n```\n\n----------------------------------------\n\nTITLE: Definition of bpf_iter_attach_opts Structure in C\nDESCRIPTION: This structure defines the options for attaching an iterator program. It includes the structure size for compatibility, a pointer to link_info, and the length of link_info.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_program__attach_iter.md#2025-04-22_snippet_1\n\nLANGUAGE: c\nCODE:\n```\nstruct bpf_iter_attach_opts {\n\tsize_t sz; /* size of this struct for forward/backward compatibility */\n\tunion bpf_iter_link_info *link_info;\n\t__u32 link_info_len;\n};\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_skc_to_tcp_request_sock Helper Function in C\nDESCRIPTION: This code snippet defines the bpf_skc_to_tcp_request_sock helper function, which casts a sk pointer to a tcp_request_sock pointer. It returns the casted pointer if valid, or NULL otherwise.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_skc_to_tcp_request_sock.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstatic struct tcp_request_sock *(* const bpf_skc_to_tcp_request_sock)(void *sk) = (void *) 139;\n```\n\n----------------------------------------\n\nTITLE: Function Definition for bpf_program__section_name in C\nDESCRIPTION: This function prototype retrieves the ELF section name of a BPF program. It takes a const pointer to a bpf_program structure and returns a const char pointer to the section name. The function was introduced in libbpf version 0.2.0.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_program__section_name.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nconst char *bpf_program__section_name(const struct bpf_program *prog);\n```\n\n----------------------------------------\n\nTITLE: Scheduler State Dump Callback Definition in C\nDESCRIPTION: Callback function signature for dumping BPF scheduler state during errors. Takes dump context as parameter.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/program-type/BPF_PROG_TYPE_STRUCT_OPS/sched_ext_ops.md#2025-04-22_snippet_27\n\nLANGUAGE: c\nCODE:\n```\nvoid (*dump)(struct scx_dump_ctx *ctx);\n```\n\n----------------------------------------\n\nTITLE: bpf_get_numa_node_id Function Definition in C\nDESCRIPTION: eBPF helper function definition that returns the ID of the current NUMA node. Used for NUMA-aware socket operations and available to multiple eBPF program types.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_get_numa_node_id.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstatic long (* const bpf_get_numa_node_id)(void) = (void *) 42;\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_redirect_neigh Helper Function in C\nDESCRIPTION: C function definition for the bpf_redirect_neigh eBPF helper. This function redirects a packet to another network device, populating L2 addresses from the neighboring subsystem.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_redirect_neigh.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstatic long (* const bpf_redirect_neigh)(__u32 ifindex, struct bpf_redir_neigh *params, int plen, __u64 flags) = (void *) 152;\n```\n\n----------------------------------------\n\nTITLE: Defining Libbpf bpf_map__get_pin_path Function in C\nDESCRIPTION: Declares the bpf_map__get_pin_path function, which takes a pointer to a const struct bpf_map and returns a constant character pointer representing the pin path of a libbpf map object. This function relies on libbpf data structures and is typically used for retrieving the path where an eBPF map is pinned in the filesystem. The function requires libbpf 0.0.6 or later, but as of v0.7.0, it is an alias to bpf_map__pin_path. Input is a pointer to a bpf_map, and output is a C string (const char*) with the pin path or NULL. The function depends on correct initialization of the underlying bpf_map object.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_map__get_pin_path.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nconst char *bpf_map__get_pin_path(const struct bpf_map *map);\n```\n\n----------------------------------------\n\nTITLE: Listing New eBPF Kernel Functions for Linux 6.12-6.14\nDESCRIPTION: This Markdown snippet lists new eBPF kernel functions (kfuncs) introduced in Linux kernel versions 6.12, 6.13, and 6.14. Each function is presented with its name, the commit hash where it was introduced, and grouped by kernel version.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/timeline/index.md#2025-04-22_snippet_12\n\nLANGUAGE: Markdown\nCODE:\n```\n## :octicons-tag-24: v6.12\n\n* `bpf_copy_from_user_str` [65ab5ac](https://github.com/torvalds/linux/commit/65ab5ac4df012388481d0414fcac1d5ac1721fb3) (kfuncs)\n* `scx_bpf_select_cpu_dfl` [f0e1a06](https://github.com/torvalds/linux/commit/f0e1a0643a59bf1f922fa209cec86a170b784f3f) (kfuncs)\n* `scx_bpf_dispatch` [f0e1a06](https://github.com/torvalds/linux/commit/f0e1a0643a59bf1f922fa209cec86a170b784f3f) (kfuncs)\n* `scx_bpf_dispatch_vtime` [06e51be](https://github.com/torvalds/linux/commit/06e51be3d5e7a07aea5c9012773df8d5de01db6c) (kfuncs)\n* `scx_bpf_dispatch_nr_slots` [f0e1a06](https://github.com/torvalds/linux/commit/f0e1a0643a59bf1f922fa209cec86a170b784f3f) (kfuncs)\n* `scx_bpf_dispatch_cancel` [f0e1a06](https://github.com/torvalds/linux/commit/f0e1a0643a59bf1f922fa209cec86a170b784f3f) (kfuncs)\n* `scx_bpf_consume` [f0e1a06](https://github.com/torvalds/linux/commit/f0e1a0643a59bf1f922fa209cec86a170b784f3f) (kfuncs)\n* `scx_bpf_dispatch_from_dsq_set_slice` [4c30f5c](https://github.com/torvalds/linux/commit/4c30f5ce4f7af4f639af99e0bdeada8b268b7361) (kfuncs)\n* `scx_bpf_dispatch_from_dsq_set_vtime` [4c30f5c](https://github.com/torvalds/linux/commit/4c30f5ce4f7af4f639af99e0bdeada8b268b7361) (kfuncs)\n* `scx_bpf_dispatch_from_dsq` [4c30f5c](https://github.com/torvalds/linux/commit/4c30f5ce4f7af4f639af99e0bdeada8b268b7361) (kfuncs)\n* `scx_bpf_dispatch_vtime_from_dsq` [4c30f5c](https://github.com/torvalds/linux/commit/4c30f5ce4f7af4f639af99e0bdeada8b268b7361) (kfuncs)\n* `scx_bpf_reenqueue_local` [245254f](https://github.com/torvalds/linux/commit/245254f7081dbe1c8da54675d0e4ddbe74cee61b) (kfuncs)\n* `scx_bpf_dispatch_from_dsq_set_slice` [4c30f5c](https://github.com/torvalds/linux/commit/4c30f5ce4f7af4f639af99e0bdeada8b268b7361) (kfuncs)\n* `scx_bpf_dispatch_from_dsq_set_vtime` [4c30f5c](https://github.com/torvalds/linux/commit/4c30f5ce4f7af4f639af99e0bdeada8b268b7361) (kfuncs)\n* `scx_bpf_create_dsq` [f0e1a06](https://github.com/torvalds/linux/commit/f0e1a0643a59bf1f922fa209cec86a170b784f3f) (kfuncs)\n* `scx_bpf_dispatch_from_dsq` [4c30f5c](https://github.com/torvalds/linux/commit/4c30f5ce4f7af4f639af99e0bdeada8b268b7361) (kfuncs)\n* `scx_bpf_dispatch_vtime_from_dsq` [4c30f5c](https://github.com/torvalds/linux/commit/4c30f5ce4f7af4f639af99e0bdeada8b268b7361) (kfuncs)\n* `scx_bpf_kick_cpu` [f0e1a06](https://github.com/torvalds/linux/commit/f0e1a0643a59bf1f922fa209cec86a170b784f3f) (kfuncs)\n* `scx_bpf_dsq_nr_queued` [f0e1a06](https://github.com/torvalds/linux/commit/f0e1a0643a59bf1f922fa209cec86a170b784f3f) (kfuncs)\n* `scx_bpf_destroy_dsq` [f0e1a06](https://github.com/torvalds/linux/commit/f0e1a0643a59bf1f922fa209cec86a170b784f3f) (kfuncs)\n* `bpf_iter_scx_dsq_new` [650ba21](https://github.com/torvalds/linux/commit/650ba21b131ed1f8ee57826b2c6295a3be221132) (kfuncs)\n* `bpf_iter_scx_dsq_next` [650ba21](https://github.com/torvalds/linux/commit/650ba21b131ed1f8ee57826b2c6295a3be221132) (kfuncs)\n* `bpf_iter_scx_dsq_destroy` [650ba21](https://github.com/torvalds/linux/commit/650ba21b131ed1f8ee57826b2c6295a3be221132) (kfuncs)\n* `scx_bpf_exit_bstr` [f0e1a06](https://github.com/torvalds/linux/commit/f0e1a0643a59bf1f922fa209cec86a170b784f3f) (kfuncs)\n* `scx_bpf_error_bstr` [f0e1a06](https://github.com/torvalds/linux/commit/f0e1a0643a59bf1f922fa209cec86a170b784f3f) (kfuncs)\n* `scx_bpf_dump_bstr` [07814a9](https://github.com/torvalds/linux/commit/07814a9439a3b03d79a1001614b5bc1cab69bcec) (kfuncs)\n* `scx_bpf_cpuperf_cap` [d86adb4](https://github.com/torvalds/linux/commit/d86adb4fc0655a0867da811d000df75d2a325ef6) (kfuncs)\n* `scx_bpf_cpuperf_cur` [d86adb4](https://github.com/torvalds/linux/commit/d86adb4fc0655a0867da811d000df75d2a325ef6) (kfuncs)\n* `scx_bpf_cpuperf_set` [d86adb4](https://github.com/torvalds/linux/commit/d86adb4fc0655a0867da811d000df75d2a325ef6) (kfuncs)\n* `scx_bpf_nr_cpu_ids` [f0e1a06](https://github.com/torvalds/linux/commit/f0e1a0643a59bf1f922fa209cec86a170b784f3f) (kfuncs)\n* `scx_bpf_get_possible_cpumask` [f0e1a06](https://github.com/torvalds/linux/commit/f0e1a0643a59bf1f922fa209cec86a170b784f3f) (kfuncs)\n* `scx_bpf_get_online_cpumask` [f0e1a06](https://github.com/torvalds/linux/commit/f0e1a0643a59bf1f922fa209cec86a170b784f3f) (kfuncs)\n* `scx_bpf_put_cpumask` [f0e1a06](https://github.com/torvalds/linux/commit/f0e1a0643a59bf1f922fa209cec86a170b784f3f) (kfuncs)\n* `scx_bpf_get_idle_cpumask` [f0e1a06](https://github.com/torvalds/linux/commit/f0e1a0643a59bf1f922fa209cec86a170b784f3f) (kfuncs)\n* `scx_bpf_get_idle_smtmask` [f0e1a06](https://github.com/torvalds/linux/commit/f0e1a0643a59bf1f922fa209cec86a170b784f3f) (kfuncs)\n* `scx_bpf_put_idle_cpumask` [f0e1a06](https://github.com/torvalds/linux/commit/f0e1a0643a59bf1f922fa209cec86a170b784f3f) (kfuncs)\n* `scx_bpf_test_and_clear_cpu_idle` [f0e1a06](https://github.com/torvalds/linux/commit/f0e1a0643a59bf1f922fa209cec86a170b784f3f) (kfuncs)\n* `scx_bpf_pick_idle_cpu` [f0e1a06](https://github.com/torvalds/linux/commit/f0e1a0643a59bf1f922fa209cec86a170b784f3f) (kfuncs)\n* `scx_bpf_pick_any_cpu` [f0e1a06](https://github.com/torvalds/linux/commit/f0e1a0643a59bf1f922fa209cec86a170b784f3f) (kfuncs)\n* `scx_bpf_task_running` [f0e1a06](https://github.com/torvalds/linux/commit/f0e1a0643a59bf1f922fa209cec86a170b784f3f) (kfuncs)\n* `scx_bpf_task_cpu` [f0e1a06](https://github.com/torvalds/linux/commit/f0e1a0643a59bf1f922fa209cec86a170b784f3f) (kfuncs)\n* `scx_bpf_cpu_rq` [6203ef7](https://github.com/torvalds/linux/commit/6203ef73fa5c0358f7960b038628259be1448724) (kfuncs)\n* `scx_bpf_task_cgroup` [8195136](https://github.com/torvalds/linux/commit/8195136669661fdfe54e9a8923c33b31c92fc1da) (kfuncs)\n* `bpf_get_task_exe_file` [d08e204](https://github.com/torvalds/linux/commit/d08e2045ebf0f5f2a97ad22cc7dae398b35354ba) (kfuncs)\n* `bpf_put_file` [d08e204](https://github.com/torvalds/linux/commit/d08e2045ebf0f5f2a97ad22cc7dae398b35354ba) (kfuncs)\n* `bpf_path_d_path` [d08e204](https://github.com/torvalds/linux/commit/d08e2045ebf0f5f2a97ad22cc7dae398b35354ba) (kfuncs)\n* `bpf_get_dentry_xattr` [ac13a42](https://github.com/torvalds/linux/commit/ac13a4261afe81ca423eddd8e6571078fe2a7cea) (kfuncs)\n\n## :octicons-tag-24: v6.13\n\n* `bpf_task_from_vpid` [675c359](https://github.com/torvalds/linux/commit/675c3596ff32c040d1dd2e28dd57e83e634b9f60) (kfuncs)\n* `bpf_send_signal_task` [6280cf7](https://github.com/torvalds/linux/commit/6280cf718db0c557b5fe44e2d2e8ad8e832696a7) (kfuncs)\n* `bpf_get_kmem_cache` [a992d7a](https://github.com/torvalds/linux/commit/a992d7a3979120fbd7c13435d27b3da8d9ed095a) (kfuncs)\n* `bpf_iter_kmem_cache_new` [2e9a548](https://github.com/torvalds/linux/commit/2e9a548009c2d804e55cdd5b0e9903756cf7d9b3) (kfuncs)\n* `bpf_iter_kmem_cache_next` [2e9a548](https://github.com/torvalds/linux/commit/2e9a548009c2d804e55cdd5b0e9903756cf7d9b3) (kfuncs)\n* `bpf_iter_kmem_cache_destroy` [2e9a548](https://github.com/torvalds/linux/commit/2e9a548009c2d804e55cdd5b0e9903756cf7d9b3) (kfuncs)\n* `scx_bpf_dsq_insert` [cc26abb](https://github.com/torvalds/linux/commit/cc26abb1a19adbb91b79d25a2e74976633ece429) (kfuncs)\n* `scx_bpf_dsq_insert_vtime` [cc26abb](https://github.com/torvalds/linux/commit/cc26abb1a19adbb91b79d25a2e74976633ece429) (kfuncs)\n* `scx_bpf_dsq_move_to_local` [5209c03](https://github.com/torvalds/linux/commit/5209c03c8ed215357a4827496a71fd32167d83ef) (kfuncs)\n* `scx_bpf_dsq_move_set_slice` [5cbb302](https://github.com/torvalds/linux/commit/5cbb302880f50f3edf35f8c6a1d38b6948bf4d11) (kfuncs)\n* `scx_bpf_dsq_move_set_vtime` [5cbb302](https://github.com/torvalds/linux/commit/5cbb302880f50f3edf35f8c6a1d38b6948bf4d11) (kfuncs)\n* `scx_bpf_dsq_move` [5cbb302](https://github.com/torvalds/linux/commit/5cbb302880f50f3edf35f8c6a1d38b6948bf4d11) (kfuncs)\n* `scx_bpf_dsq_move_vtime` [5cbb302](https://github.com/torvalds/linux/commit/5cbb302880f50f3edf35f8c6a1d38b6948bf4d11) (kfuncs)\n* `scx_bpf_dsq_move_set_slice` [5cbb302](https://github.com/torvalds/linux/commit/5cbb302880f50f3edf35f8c6a1d38b6948bf4d11) (kfuncs)\n* `scx_bpf_dsq_move_set_vtime` [5cbb302](https://github.com/torvalds/linux/commit/5cbb302880f50f3edf35f8c6a1d38b6948bf4d11) (kfuncs)\n* `scx_bpf_dsq_move` [5cbb302](https://github.com/torvalds/linux/commit/5cbb302880f50f3edf35f8c6a1d38b6948bf4d11) (kfuncs)\n* `scx_bpf_dsq_move_vtime` [5cbb302](https://github.com/torvalds/linux/commit/5cbb302880f50f3edf35f8c6a1d38b6948bf4d11) (kfuncs)\n\n## :octicons-tag-24: v6.14\n\n* `bpf_local_irq_save` [c8e2ee1](https://github.com/torvalds/linux/commit/c8e2ee1f3df05dc4caa746c062c6b5791c745c79) (kfuncs)\n* `bpf_local_irq_restore` [c8e2ee1](https://github.com/torvalds/linux/commit/c8e2ee1f3df05dc4caa746c062c6b5791c745c79) (kfuncs)\n* `scx_bpf_now` [3a9910b](https://github.com/torvalds/linux/commit/3a9910b5904d29c566e3ff9290990b519827ba75) (kfuncs)\n```\n\n----------------------------------------\n\nTITLE: Defining BPF_FOR_EACH_ITER macro in C\nDESCRIPTION: This snippet shows the definition of the BPF_FOR_EACH_ITER macro. It takes the address of an implicitly defined iterator '___it'.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/scx/BPF_FOR_EACH_ITER.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n#define BPF_FOR_EACH_ITER\t(&___it)\n```\n\n----------------------------------------\n\nTITLE: Implementing log2_u64 function in C for SCX eBPF\nDESCRIPTION: This function computes the base 2 logarithm of a 64-bit value. It splits the input into high and low 32-bit parts, and uses the log2_u32 function for computation. The function handles both cases where the high 32 bits are set or not.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/scx/log2_u64.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstatic inline u32 log2_u64(u64 v)\n{\n        u32 hi = v >> 32;\n        if (hi)\n                return log2_u32(hi) + 32 + 1;\n        else\n                return log2_u32(v) + 1;\n}\n```\n\n----------------------------------------\n\nTITLE: Using xsk_umem__extract_offset in C\nDESCRIPTION: This function extracts the offset from an address in unaligned mode. It should be used in conjunction with xsk_umem__extract_addr and xsk_umem__add_offset_to_addr. For aligned mode, xsk_umem__get_data should be used instead.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libxdp/functions/xsk_umem__extract_offset.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n__u64 xsk_umem__extract_offset(__u64 addr);\n```\n\n----------------------------------------\n\nTITLE: BPF_F_ANY_ALIGNMENT Flag Documentation\nDESCRIPTION: Documents the BPF_F_ANY_ALIGNMENT flag (introduced in v5.0) which allows any memory alignment, turning off the alignment checking and enforcement especially useful for platforms with strict alignment requirements.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/syscall/BPF_PROG_LOAD.md#2025-04-22_snippet_3\n\nLANGUAGE: markdown\nCODE:\n```\n### `BPF_F_ANY_ALIGNMENT`\n\n<!-- [FEATURE_TAG](BPF_F_ANY_ALIGNMENT) -->\n[:octicons-tag-24: v5.0](https://github.com/torvalds/linux/commit/e9ee9efc0d176512cdce9d27ff8549d7ffa2bfcd)\n<!-- [/FEATURE_TAG] -->\n\nIf `BPF_F_ANY_ALIGNMENT` is used in `BPF_PROF_LOAD` command, the verifier will allow any alignment whatsoever.  On platforms with strict alignment requirements for loads ands stores (such as sparc and mips) the verifier validates that all loads and stores provably follow this requirement.  This flag turns that checking and enforcement off.\n\nIt is mostly used for testing when we want to validate the context and memory access aspects of the verifier, but because of an unaligned access the alignment check would trigger before the one we are interested in.\n```\n\n----------------------------------------\n\nTITLE: Struct Definition for bpf_uprobe_opts in C\nDESCRIPTION: Definition of the bpf_uprobe_opts structure used for configuring uprobe attachment options. Contains fields for controlling reference counting, cookies, return probes, function names and attachment modes.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_program__attach_uprobe_opts.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstruct bpf_uprobe_opts {\n\t/* size of this struct, for forward/backward compatibility */\n\tsize_t sz;\n\tsize_t ref_ctr_offset;\n\t__u64 bpf_cookie;\n\tbool retprobe;\n\tconst char *func_name;\n\tenum probe_attach_mode attach_mode;\n\tsize_t :0;\n};\n```\n\n----------------------------------------\n\nTITLE: Retrieving Map Name from BPF Map with Libbpf - C\nDESCRIPTION: Defines the userspace function 'bpf_map__name' in the libbpf library, which returns the name of a given BPF map as a null-terminated string. The function takes a pointer to a 'bpf_map' struct and returns the associated map name or NULL on error. Required dependency is libbpf and it expects the 'bpf_map' to be properly allocated. Input is a pointer to a map, output is a const char pointer or NULL; improper or NULL pointers could yield failure.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_map__name.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nconst char *bpf_map__name(const struct bpf_map *map);\n```\n\n----------------------------------------\n\nTITLE: Using bpf_obj_drop in cgroup initialization function in C\nDESCRIPTION: This example demonstrates the usage of bpf_obj_drop in an error handling path of a cgroup initialization function. The function creates resources and uses bpf_obj_drop to clean up a cgv_node object when an error occurs.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/scx/bpf_obj_drop.md#2025-04-22_snippet_1\n\nLANGUAGE: c\nCODE:\n```\n/* SPDX-License-Identifier: GPL-2.0 */\n/* Copyright (c) 2022 Tejun Heo <tj@kernel.org> */\n\nint BPF_STRUCT_OPS_SLEEPABLE(fcg_cgroup_init, struct cgroup *cgrp,\n\t\t\t     struct scx_cgroup_init_args *args)\n{\n\tstruct fcg_cgrp_ctx *cgc;\n\tstruct cgv_node *cgv_node;\n\tstruct cgv_node_stash empty_stash = {}, *stash;\n\tu64 cgid = cgrp->kn->id;\n\tint ret;\n\n\t/*\n\t * Technically incorrect as cgroup ID is full 64bit while dsq ID is\n\t * 63bit. Should not be a problem in practice and easy to spot in the\n\t * unlikely case that it breaks.\n\t */\n\tret = scx_bpf_create_dsq(cgid, -1);\n\tif (ret)\n\t\treturn ret;\n\n\tcgc = bpf_cgrp_storage_get(&cgrp_ctx, cgrp, 0,\n\t\t\t\t   BPF_LOCAL_STORAGE_GET_F_CREATE);\n\tif (!cgc) {\n\t\tret = -ENOMEM;\n\t\tgoto err_destroy_dsq;\n\t}\n\n\tcgc->weight = args->weight;\n\tcgc->hweight = FCG_HWEIGHT_ONE;\n\n\tret = bpf_map_update_elem(&cgv_node_stash, &cgid, &empty_stash,\n\t\t\t\t  BPF_NOEXIST);\n\tif (ret) {\n\t\tif (ret != -ENOMEM)\n\t\t\tscx_bpf_error(\"unexpected stash creation error (%d)\",\n\t\t\t      ret);\n\t\tgoto err_destroy_dsq;\n\t}\n\n\tstash = bpf_map_lookup_elem(&cgv_node_stash, &cgid);\n\tif (!stash) {\n\t\tscx_bpf_error(\"unexpected cgv_node stash lookup failure\");\n\t\tret = -ENOENT;\n\t\tgoto err_destroy_dsq;\n\t}\n\n\tcgv_node = bpf_obj_new(struct cgv_node);\n\tif (!cgv_node) {\n\t\tret = -ENOMEM;\n\t\tgoto err_del_cgv_node;\n\t}\n\n\tcgv_node->cgid = cgid;\n\tcgv_node->cvtime = cvtime_now;\n\n\tcgv_node = bpf_kptr_xchg(&stash->node, cgv_node);\n\tif (cgv_node) {\n\t\tscx_bpf_error(\"unexpected !NULL cgv_node stash\");\n\t\tret = -EBUSY;\n\t\tgoto err_drop;\n\t}\n\n\treturn 0;\n\nerr_drop:\n\tbpf_obj_drop(cgv_node);\nerr_del_cgv_node:\n\tbpf_map_delete_elem(&cgv_node_stash, &cgid);\nerr_destroy_dsq:\n\tscx_bpf_destroy_dsq(cgid);\n\treturn ret;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining BPF_STRUCT_OPS Macro in C\nDESCRIPTION: Macro definition that combines SEC and BPF_PROG directives to create struct ops programs. It places the program in an ELF section starting with struct_ops/ and handles program context unpacking.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/scx/BPF_STRUCT_OPS.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n#define BPF_STRUCT_OPS(name, args...)   \\\n    SEC(\"struct_ops/\"#name)             \\\n    BPF_PROG(name, ##args)\n```\n\n----------------------------------------\n\nTITLE: Placeholder for Socket Filter Program Examples (Markdown Comment)\nDESCRIPTION: This is a Markdown comment serving as a placeholder to add C and Rust code examples demonstrating the implementation of an eBPF socket filter program. It indicates that this content is planned but not yet present.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/program-type/BPF_PROG_TYPE_SOCKET_FILTER.md#2025-04-22_snippet_2\n\nLANGUAGE: markdown\nCODE:\n```\n<!-- TODO(dylandreimerink): show example program in C and Rust -->\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_wq_init Kernel Function Signature\nDESCRIPTION: Function signature showing the parameters and return type of the bpf_wq_init kernel function used to initialize work queues.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/bpf_wq_init.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nint bpf_wq_init(struct bpf_wq *wq, void *p__map, unsigned int flags)\n```\n\n----------------------------------------\n\nTITLE: Defining Perf Event MMAP Page Structure in C\nDESCRIPTION: This structure defines the memory-mapped page for perf events, containing metadata for the ring buffer including data offsets, head, and tail pointers.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/map-type/BPF_MAP_TYPE_PERF_EVENT_ARRAY.md#2025-04-22_snippet_3\n\nLANGUAGE: c\nCODE:\n```\n__u64\taux_head;\n__u64\taux_tail;\n__u64\taux_offset;\n__u64\taux_size;\n```\n\n----------------------------------------\n\nTITLE: Definition of bpf_csum_update Helper Function in C\nDESCRIPTION: Function signature for the bpf_csum_update helper, which adds a checksum into an sk_buff's csum field. This helper is available since Linux kernel v4.9 and returns the checksum on success or a negative error code on failure.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_csum_update.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstatic __s64 (* const bpf_csum_update)(struct __sk_buff *skb, __wsum csum) = (void *) 40;\n```\n\n----------------------------------------\n\nTITLE: Defining bbr_set_state kfunc in eBPF (C)\nDESCRIPTION: This code snippet shows the function signature for the bbr_set_state kfunc, which sets a new congestion control state for a TCP socket in eBPF. It accepts a pointer to a 'struct sock' (representing a kernel socket) and a new state value as an unsigned 8-bit integer. This function is intended to be called before changing the ca_state in TCP congestion control logic and is usable from BPF_PROG_TYPE_STRUCT_OPS eBPF program types. Required dependencies include kernel headers defining struct sock and eBPF kfunc registration. Inputs are a valid kernel socket pointer and a new congestion state; no output is returned.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/bbr_set_state.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n#!c void bbr_set_state(struct sock *sk, u8 new_state)\n```\n\n----------------------------------------\n\nTITLE: Attaching a TC Classifier using iproute2 tc CLI - Bash\nDESCRIPTION: Demonstrates the basic method of attaching a traffic control classifier (qdisc of type clsact) to a specific network device using the tc command-line tool. This command requires iproute2 and proper permissions, and it does not require direct programming of eBPF bytecode. The device name (here, eth1) is the main parameter, and the action creates a qdisc as a prerequisite for classifier attachment.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/program-type/BPF_PROG_TYPE_SCHED_CLS.md#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n# Add a qdisc of type `clsact` to device `eth1`\n$ tc qdisc add dev eth1 clsact\n```\n\n----------------------------------------\n\nTITLE: Updating Cgroup Storage in eBPF Fexit Hook (C)\nDESCRIPTION: This C snippet shows an eBPF fexit program attached to 'inet_stream_connect'. It intercepts the return of the function, checks if the connection is IPv6, retrieves cgroup-local storage associated with the socket's cgroup using 'bpf_cgrp_storage_get' (requires a map named 'socket_cookies'), verifies a socket cookie using 'bpf_get_socket_cookie', and updates a value ('cookie_value') in the cgroup storage if the conditions match. Requires 'vmlinux.h' and 'bpf/bpf_helpers.h' implicitly.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/program-type/BPF_PROG_TYPE_TRACING.md#2025-04-22_snippet_3\n\nLANGUAGE: c\nCODE:\n```\nSEC(\"fexit/inet_stream_connect\")\nint BPF_PROG(update_cookie_tracing, struct socket *sock,\n        struct sockaddr *uaddr, int addr_len, int flags, int ret)\n{\n    struct socket_cookie *p;\n\n    if (uaddr->sa_family != AF_INET6)\n        return 0;\n\n    p = bpf_cgrp_storage_get(&socket_cookies, sock->sk->sk_cgrp_data.cgroup, 0, 0);\n    if (!p)\n        return 0;\n\n    if (p->cookie_key != bpf_get_socket_cookie(sock->sk))\n        return 0;\n\n    p->cookie_value |= 0xF0;\n    return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_obj_get_opts struct in C\nDESCRIPTION: Definition of the bpf_obj_get_opts structure used by the bpf_obj_get_opts function. The structure contains fields for size tracking, file flags and path file descriptor.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_obj_get_opts.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstruct bpf_obj_get_opts {\n    size_t sz; /* size of this struct for forward/backward compatibility */\n\n    __u32 file_flags;\n    int path_fd;\n\n    size_t :0;\n};\n```\n\n----------------------------------------\n\nTITLE: Defining Netdev XDP Action Features - C\nDESCRIPTION: Enumeration of XDP features supported by network devices, including basic actions, redirects, hardware offload capabilities, and zero-copy modes.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_xdp_query.md#2025-04-22_snippet_2\n\nLANGUAGE: c\nCODE:\n```\nenum netdev_xdp_act {\n\tNETDEV_XDP_ACT_BASIC = 1,\n\tNETDEV_XDP_ACT_REDIRECT = 2,\n\tNETDEV_XDP_ACT_NDO_XMIT = 4,\n\tNETDEV_XDP_ACT_XSK_ZEROCOPY = 8,\n\tNETDEV_XDP_ACT_HW_OFFLOAD = 16,\n\tNETDEV_XDP_ACT_RX_SG = 32,\n\tNETDEV_XDP_ACT_NDO_XMIT_SG = 64,\n};\n```\n\n----------------------------------------\n\nTITLE: CPU Idle State Update Operation\nDESCRIPTION: Handles updates to CPU idle state transitions, with optional built-in idle tracking override.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/program-type/BPF_PROG_TYPE_STRUCT_OPS/sched_ext_ops.md#2025-04-22_snippet_20\n\nLANGUAGE: c\nCODE:\n```\nvoid (*update_idle)(s32 cpu, bool idle);\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_get_stack Helper Function in C\nDESCRIPTION: Function definition for the bpf_get_stack helper that returns user or kernel stack traces. The function takes a context pointer, buffer pointer, size, and flags as parameters.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_get_stack.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstatic long (* const bpf_get_stack)(void *ctx, void *buf, __u32 size, __u64 flags) = (void *) 67;\n```\n\n----------------------------------------\n\nTITLE: Defining xsk_ring_cons__comp_addr Function in C\nDESCRIPTION: This code snippet shows the function signature for the xsk_ring_cons__comp_addr function. It takes a pointer to a xsk_ring_cons structure and an index as parameters, and returns a pointer to a 64-bit unsigned integer representing an address entry.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libxdp/functions/xsk_ring_cons__comp_addr.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nconst __u64 *xsk_ring_cons__comp_addr(const struct xsk_ring_cons *comp, __u32 idx);\n```\n\n----------------------------------------\n\nTITLE: Inserting Kfunc to Program Type References in Markdown\nDESCRIPTION: Shows the markers used to insert generated kfunc to program type reference lists into markdown files. The tool looks for these markers to place the rendered markdown content.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/meta.md#2025-04-22_snippet_9\n\nLANGUAGE: markdown\nCODE:\n```\n<!-- [KFUNC_PROG_REF] -->\n<!-- [/KFUNC_PROG_REF] -->\n```\n\n----------------------------------------\n\nTITLE: CPU Release Callback Definition in C\nDESCRIPTION: Callback function signature for when a CPU is taken away from BPF scheduler control. Takes CPU ID and release arguments as parameters.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/program-type/BPF_PROG_TYPE_STRUCT_OPS/sched_ext_ops.md#2025-04-22_snippet_22\n\nLANGUAGE: c\nCODE:\n```\nvoid (*cpu_release)(s32 cpu, struct scx_cpu_release_args *args);\n```\n\n----------------------------------------\n\nTITLE: Testing Null Dynamic Pointer Detection\nDESCRIPTION: Demonstrates how to check if a dynamic pointer is null, testing both valid and invalid dynptrs. Shows that a dynptr created with invalid flags is considered null.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/concepts/dynptrs.md#2025-04-22_snippet_8\n\nLANGUAGE: c\nCODE:\n```\nSEC(\"tp/syscalls/sys_enter_nanosleep\")\nint test_dynptr_is_null(void *ctx)\n{\n\tstruct bpf_dynptr ptr1;\n\tstruct bpf_dynptr ptr2;\n\t__u64 size = 4;\n\n\tif (bpf_get_current_pid_tgid() >> 32 != pid)\n\t\treturn 0;\n\n\t/* Pass in invalid flags, get back an invalid dynptr */\n\tif (bpf_ringbuf_reserve_dynptr(&ringbuf, size, 123, &ptr1) != -EINVAL) {\n\t\terr = 1;\n\t\tgoto exit_early;\n\t}\n\n\t/* Test that the invalid dynptr is null */\n\tif (!bpf_dynptr_is_null(&ptr1)) {\n\t\terr = 2;\n\t\tgoto exit_early;\n\t}\n\n\t/* Get a valid dynptr */\n\tif (bpf_ringbuf_reserve_dynptr(&ringbuf, size, 0, &ptr2)) {\n\t\terr = 3;\n\t\tgoto exit;\n\t}\n\n\t/* Test that the valid dynptr is not null */\n\tif (bpf_dynptr_is_null(&ptr2)) {\n\t\terr = 4;\n\t\tgoto exit;\n\t}\n\n\texit:\n\tbpf_ringbuf_discard_dynptr(&ptr2, 0);\n\texit_early:\n\tbpf_ringbuf_discard_dynptr(&ptr1, 0);\n\treturn 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Enum definition for kernel configuration values in C\nDESCRIPTION: The enum type used to represent kernel configuration values (y, m, n) as integer constants that the loader can use when initializing __kconfig variables.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/ebpf/__kconfig.md#2025-04-22_snippet_1\n\nLANGUAGE: c\nCODE:\n```\nenum libbpf_tristate {\n\tTRI_NO = 0,\n\tTRI_YES = 1,\n\tTRI_MODULE = 2,\n};\n```\n\n----------------------------------------\n\nTITLE: Declaring bpf_linker__add_file in Libbpf (C)\nDESCRIPTION: This C function declaration introduces 'bpf_linker__add_file', which adds a specified file to a BPF linker context for static linking. It requires a pointer to a 'struct bpf_linker', the filename as a string, and an optional pointer to a 'struct bpf_linker_file_opts' that controls file-specific options. Returns 0 on success, or a negative error code with 'errno' set on failure. Requires inclusion of libbpf headers and linking against the libbpf library. Inputs are the linker, target filename, and options; output is success or error status.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_linker__add_file.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nint bpf_linker__add_file(struct bpf_linker *linker, const char *filename, const struct bpf_linker_file_opts *opts);\n```\n\n----------------------------------------\n\nTITLE: BPF_F_TEST_RND_HI32 Flag Documentation\nDESCRIPTION: Documents the BPF_F_TEST_RND_HI32 testing flag (introduced in v5.3) which randomizes high 32-bit values for instructions identified as safe to ignore them, useful for verifying JIT optimizations.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/syscall/BPF_PROG_LOAD.md#2025-04-22_snippet_4\n\nLANGUAGE: markdown\nCODE:\n```\n### `BPF_F_TEST_RND_HI32`\n\n<!-- [FEATURE_TAG](BPF_F_TEST_RND_HI32) -->\n[:octicons-tag-24: v5.3](https://github.com/torvalds/linux/commit/c240eff63a1cf1c4edc768e0cfc374811c02f069)\n<!-- [/FEATURE_TAG] -->\n\n!!! warning\n    `BPF_F_TEST_RND_HI32` is used for testing purpose, not meant for production usage.\n\nVerifier does sub-register def/use analysis and identifies instructions whose def only matters for low 32-bit, high 32-bit is never referenced later through implicit zero extension. Therefore verifier notifies JIT back-ends that it is safe to ignore clearing high 32-bit for these instructions. This saves some back-ends a lot of code-gen. However such optimization is not necessary on some arches, for example x86_64, arm64 etc, whose JIT back-ends hence hasn't used verifier's analysis result. But, we really want to have a way to be able to verify the correctness of the described optimization on x86_64 on which test suites are frequently exercised.\n\nSo, this flag is introduced. Once it is set, verifier will randomize high 32-bit for those instructions who has been identified as safe to ignore them. Then, if verifier is not doing correct analysis, such randomization will regress tests to expose bugs.\n```\n\n----------------------------------------\n\nTITLE: BPF_F_TEST_REG_INVARIANTS Flag Documentation\nDESCRIPTION: Documents the BPF_F_TEST_REG_INVARIANTS internal testing flag (introduced in v6.8) with undefined behavior, used only for BPF verifier testing purposes.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/syscall/BPF_PROG_LOAD.md#2025-04-22_snippet_9\n\nLANGUAGE: markdown\nCODE:\n```\n### `BPF_F_TEST_REG_INVARIANTS`\n\n[:octicons-tag-24: v6.8](https://github.com/torvalds/linux/commit/ff8867af01daa7ea770bebf5f91199b7434b74e5)\n\nThe verifier internal test flag. Behavior is undefined \n```\n\n----------------------------------------\n\nTITLE: Iterating BPF Links Using Libbpf Function in C\nDESCRIPTION: The 'bpf_link_get_next_id' function is designed to iterate over BPF links by returning the next link ID after a specified 'start_id'. It is dependent on the BPF_LINK_GET_NEXT_ID syscall command and is used in C programming to facilitate interactions with the BPF subsystem. The function requires two parameters: 'start_id', which specifies the starting point for iteration, and 'next_id', which is a pointer to the next link ID. On success, it returns '0', and on failure, it returns a negative error code.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_link_get_next_id.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nint bpf_link_get_next_id(__u32 start_id, __u32 *next_id);\n```\n\n----------------------------------------\n\nTITLE: Common Header Macros for eBPF Schedulers\nDESCRIPTION: Lists of macro definitions from common.bpf.h that provide utility functions and forward declarations for scheduler development. Includes iterators, error handling, struct operations, array manipulation, and common utility macros.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/scx/index.md#2025-04-22_snippet_0\n\nLANGUAGE: C\nCODE:\n```\nBPF_FOR_EACH_ITER\nscx_bpf_bstr_preamble\nscx_bpf_exit\nscx_bpf_error\nscx_bpf_dump\nBPF_STRUCT_OPS\nBPF_STRUCT_OPS_SLEEPABLE\nRESIZABLE_ARRAY\nARRAY_ELEM_PTR\nMEMBER_VPTR\n__contains\nprivate\nbpf_obj_new\nbpf_obj_drop\nbpf_rbtree_add\nbpf_refcount_acquire\ncast_mask\nlikely\nunlikely\nREAD_ONCE\nWRITE_ONCE\nlog2_u32\nlog2_u64\n```\n\n----------------------------------------\n\nTITLE: Defining __ulong Macro for Unsigned Long Properties in BTF Maps\nDESCRIPTION: This snippet shows the definition of the __ulong macro used to encode unsigned long properties in BTF map definitions. It creates an enum with a unique name and the specified value.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/ebpf/__ulong.md#2025-04-22_snippet_0\n\nLANGUAGE: C\nCODE:\n```\n#define __ulong(name, val) enum { ___bpf_concat(__unique_value, __COUNTER__) = val } name\n```\n\n----------------------------------------\n\nTITLE: Example Implementation of 'private' Macro in C\nDESCRIPTION: Example showing how to use the 'private' macro to create a global variable 'cgv_tree' that won't be used from userspace. The example includes structure definitions and the highlighted line demonstrates the macro usage.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/scx/private.md#2025-04-22_snippet_1\n\nLANGUAGE: c\nCODE:\n```\n/* SPDX-License-Identifier: GPL-2.0 */\n/* Copyright (c) 2022 Tejun Heo <tj@kernel.org> */\n\nstruct bpf_rb_root {\n\t__u64 __opaque[2];\n} __attribute__((aligned(8)));\n\nstruct bpf_rb_node {\n\t__u64 __opaque[4];\n} __attribute__((aligned(8)));\n\nstruct cgv_node {\n\tstruct bpf_rb_node  rb_node;\n\t__u64               cvtime;\n\t__u64               cgid;\n};\n\nprivate.md(CGV_TREE) struct bpf_rb_root cgv_tree [__contains](__contains.md)(cgv_node, rb_node);\n```\n\n----------------------------------------\n\nTITLE: Defining ring__producer_pos Function in C\nDESCRIPTION: Function signature for the ring__producer_pos libbpf userspace function. It takes a const pointer to a ring buffer object and returns an unsigned long representing the current producer position.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/ring__producer_pos.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nunsigned long ring__producer_pos(const struct ring *r);\n```\n\n----------------------------------------\n\nTITLE: Mapping Ring Buffers for AF_XDP Socket in C\nDESCRIPTION: This code demonstrates how to map the ring buffers into process memory for an AF_XDP socket using the mmap() system call.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/concepts/af_xdp.md#2025-04-22_snippet_5\n\nLANGUAGE: c\nCODE:\n```\nstruct xdp_desc {\n\t__u64 addr;\n\t__u32 len;\n\t__u32 options;\n};\n\nvoid *{rx,tx,fill,completion}_ring_mmap = mmap(\n    fd, \n    {XDP_PGOFF_RX_RING,XDP_PGOFF_TX_RING,XDP_UMEM_PGOFF_FILL_RING,XDP_UMEM_PGOFF_COMPLETION_RING},\n    offsets.{rx,tx,fr,cr}.desc + ring_size * sizeof(struct xdp_desc),\n    PROT_READ|PROT_WRITE,\n    MAP_SHARED|MAP_POPULATE);\nif (!{rx,tx,fill,completion}_ring_mmap)\n    // handle error\n\n__u32 *{rx,tx,fill,completion}_ring_consumer = {rx,tx,fill,completion}_ring_mmap + offsets.{rx,tx,fr,cr}.consumer;\n__u32 *{rx,tx,fill,completion}_ring_producer = {rx,tx,fill,completion}_ring_mmap + offsets.{rx,tx,fr,cr}.producer;\nstruct xdp_desc[ring_size] {rx,tx,fill,completion}_ring = {rx,tx,fill,completion}_ring_mmap + offsets.{rx,tx,fr,cr}.desc;\n```\n\n----------------------------------------\n\nTITLE: Defining __bpf_unreachable macro in C for eBPF\nDESCRIPTION: This snippet shows the definition of the __bpf_unreachable macro using the __builtin_trap() function. It's used to generate a compile-time error if the code path is reached in eBPF programs.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/ebpf/__bpf_unreachable.md#2025-04-22_snippet_0\n\nLANGUAGE: C\nCODE:\n```\n#define __bpf_unreachable() __builtin_trap()\n```\n\n----------------------------------------\n\nTITLE: Defining KFunc 'scx_bpf_dispatch_from_dsq_set_slice' in C\nDESCRIPTION: This C code snippet shows the function signature for the eBPF kfunc `scx_bpf_dispatch_from_dsq_set_slice`. It takes a pointer to a `bpf_iter_scx_dsq` struct and a `u64` slice value as parameters. This function is intended for use within BPF programs of type STRUCT_OPS or SYSCALL, although it has been renamed in newer kernel versions.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/scx_bpf_dispatch_from_dsq_set_slice.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n`#!c void scx_bpf_dispatch_from_dsq_set_slice(struct bpf_iter_scx_dsq *it__iter, u64 slice)`\n```\n\n----------------------------------------\n\nTITLE: Callback Function Signature for bpf_for_each_map_elem in C\nDESCRIPTION: The required signature for the callback function that will be invoked for each map element during iteration.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_for_each_map_elem.md#2025-04-22_snippet_1\n\nLANGUAGE: c\nCODE:\n```\nlong (*callback_fn)(struct bpf_map *map, const void *key, void *value, void *ctx);\n```\n\n----------------------------------------\n\nTITLE: Declaring the 'exit_dump_len' Field in 'sched_ext_ops' Struct (C)\nDESCRIPTION: Declares the 'exit_dump_len' field within the 'sched_ext_ops' struct as an unsigned 32-bit integer. This field specifies the buffer length allocated for the `scx_exit_info.dump` field, which can be used for dumping scheduler state upon exit. If set to 0, a default buffer size of 32768 bytes is used.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/program-type/BPF_PROG_TYPE_STRUCT_OPS/sched_ext_ops.md#2025-04-22_snippet_5\n\nLANGUAGE: c\nCODE:\n```\nu32 exit_dump_len\n```\n\n----------------------------------------\n\nTITLE: Basic Kernel Function Assembly Without CONFIG_FUNCTION_TRACER\nDESCRIPTION: Shows the basic assembly structure of a kernel function without tracing enabled.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/concepts/trampolines.md#2025-04-22_snippet_0\n\nLANGUAGE: assembly\nCODE:\n```\nsome_kernel_func:\n  PUSH RBP\n  MOV RSP, RBP\n  ...\n  RET\n```\n\n----------------------------------------\n\nTITLE: KF_ITER_NEXT Flag Documentation\nDESCRIPTION: Flag indicating that a KFunc advances an iterator to the next object.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/concepts/kfuncs.md#2025-04-22_snippet_8\n\nLANGUAGE: markdown\nCODE:\n```\nKF_ITER_NEXT\n```\n\n----------------------------------------\n\nTITLE: Definition of bpf_program__log_buf function in C\nDESCRIPTION: The function signature for bpf_program__log_buf which returns a pointer to the log buffer of a BPF program. It takes a BPF program pointer and a size_t pointer to store the log size, and returns a pointer to the null-terminated log buffer string.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_program__log_buf.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nconst char *bpf_program__log_buf(const struct bpf_program *prog, size_t *log_size);\n```\n\n----------------------------------------\n\nTITLE: Defining scx_bpf_dsq_move_to_local Macro in C\nDESCRIPTION: Macro definition that provides backwards compatibility between scx_bpf_dsq_move_to_local and scx_bpf_consume___compat kernel functions. It uses bpf_ksym_exists to check for the availability of the newer function at runtime.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/scx/scx_bpf_dsq_move_to_local.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n#define scx_bpf_dsq_move_to_local(dsq_id)\\n\\t([bpf_ksym_exists](../libbpf/ebpf/bpf_ksym_exists.md)(scx_bpf_dsq_move_to_local) ?\\n\\t [scx_bpf_dsq_move_to_local](../../linux/kfuncs/scx_bpf_dsq_move_to_local.md)((dsq_id)) :\\n\\t [scx_bpf_consume___compat](../../linux/kfuncs/scx_bpf_consume.md)((dsq_id)))\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_get_current_ancestor_cgroup_id Helper Function in C\nDESCRIPTION: Function definition for the bpf_get_current_ancestor_cgroup_id helper that returns the cgroup ID of an ancestor cgroup at the specified level. Returns 0 if the ID cannot be retrieved. Helper number is 123.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_get_current_ancestor_cgroup_id.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstatic __u64 (* const bpf_get_current_ancestor_cgroup_id)(int ancestor_level) = (void *) 123;\n```\n\n----------------------------------------\n\nTITLE: Defining Libbpf eBPF Function bpf_usdt_cookie in C\nDESCRIPTION: This code snippet presents the definition of 'bpf_usdt_cookie', an eBPF function used in the libbpf framework. The function retrieves the user-specified cookie value provided during the attach process, utilizing BPF cookies internally. The necessary dependencies include 'pt_regs' as an input parameter, associating with tracepoint specifiers maintained in 'usdt.bpf.h'.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/ebpf/bpf_usdt_cookie.md#2025-04-22_snippet_0\n\nLANGUAGE: C\nCODE:\n```\n[__weak](__weak.md) [__hidden](__hidden.md)\\nlong bpf_usdt_cookie(struct pt_regs *ctx)\n```\n\n----------------------------------------\n\nTITLE: Retrieving XDP User Memory File Descriptor in C\nDESCRIPTION: Function signature for obtaining the file descriptor of an XDP user memory object. Returns the file descriptor on success or -EINVAL if arguments are invalid.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libxdp/functions/xsk_umem__fd.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nint xsk_umem__fd(const struct xsk_umem *umem);\n```\n\n----------------------------------------\n\nTITLE: Defining SCX Exit Information in C\nDESCRIPTION: Structure that provides detailed information about why the BPF scheduler is being disabled. Contains fields for the exit kind, code, reason, backtrace, and debug information.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/program-type/BPF_PROG_TYPE_STRUCT_OPS/sched_ext_ops.md#2025-04-22_snippet_59\n\nLANGUAGE: c\nCODE:\n```\nstruct scx_exit_info {\n    enum scx_exit_kind  kind;\n    s64                 exit_code;\n    const char          *reason;\n    unsigned long       *bt;\n    u32                 bt_len;\n    char                *msg;\n    char                *dump;\n};\n```\n\n----------------------------------------\n\nTITLE: Linux Kernel 4.16 eBPF Feature Additions\nDESCRIPTION: New eBPF features added in Linux kernel 4.16, including helper functions for socket operations and various sock_ops callback flags.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/timeline/index.md#2025-04-22_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n* `bpf_override_return`\n* `bpf_sock_ops_cb_flags_set`\n* `BPF_SOCK_OPS_RTO_CB_FLAG`\n* `BPF_SOCK_OPS_RETRANS_CB_FLAG`\n* `BPF_SOCK_OPS_STATE_CB_FLAG`\n* `BPF_SOCK_OPS_ALL_CB_FLAGS`\n* `BPF_SOCK_OPS_RTO_CB`\n* `BPF_SOCK_OPS_RETRANS_CB`\n* `BPF_SOCK_OPS_STATE_CB`\n```\n\n----------------------------------------\n\nTITLE: Defining eBPF KFunc 'dctcp_update_alpha' in C\nDESCRIPTION: This C code snippet defines the signature for 'dctcp_update_alpha', an eBPF kfunc. It is called when an acknowledgment arrives in the network stack. This kfunc can be used within BPF_PROG_TYPE_STRUCT_OPS program types. The function takes as parameters a structure of type 'sock' and a 32-bit unsigned integer representing flags, although the documentation lacks specific details about their purposes.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/dctcp_update_alpha.md#2025-04-22_snippet_0\n\nLANGUAGE: C\nCODE:\n```\n#!c void dctcp_update_alpha(struct sock *sk, u32 flags)\n```\n\n----------------------------------------\n\nTITLE: Fetching Initial Value of BPF Map with Libbpf in C\nDESCRIPTION: The function 'bpf_map__initial_value' retrieves the initial value from a specified BPF map. Users need to pass a pointer to the BPF map and a pointer to the size of the initial value. On success, it returns the pointer to the initial value, otherwise, it returns NULL. It is particularly useful when working with array maps created automatically for ELF sections containing global variables or with arena maps.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_map__initial_value.md#2025-04-22_snippet_0\n\nLANGUAGE: C\nCODE:\n```\n#!c void *bpf_map__initial_value(const struct bpf_map *map, size_t *psize);\n```\n\n----------------------------------------\n\nTITLE: Compatibility Wrappers for eBPF Schedulers\nDESCRIPTION: Lists of compatibility definitions from compat.bpf.h that provide version-specific implementations for different kernel versions. Includes task management, dispatch queue operations, and scheduler operations definitions.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/scx/index.md#2025-04-22_snippet_1\n\nLANGUAGE: C\nCODE:\n```\n__COMPAT_ENUM_OR_ZERO\n__COMPAT_scx_bpf_task_cgroup\nscx_bpf_dsq_insert\nscx_bpf_dsq_insert_vtime\nscx_bpf_dsq_move_to_local\n__COMPAT_scx_bpf_dsq_move_set_slice\n__COMPAT_scx_bpf_dsq_move_set_vtime\n__COMPAT_scx_bpf_dsq_move\n__COMPAT_scx_bpf_dsq_move_vtime\nSCX_OPS_DEFINE\n```\n\n----------------------------------------\n\nTITLE: Inserting Program Type to Kfunc References in Markdown\nDESCRIPTION: Demonstrates the markers used to insert generated program type to kfunc reference lists into markdown files. The tool searches for these markers to place the rendered markdown content.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/meta.md#2025-04-22_snippet_10\n\nLANGUAGE: markdown\nCODE:\n```\n<!-- [PROG_KFUNC_REF] -->\n<!-- [/PROG_KFUNC_REF] -->\n```\n\n----------------------------------------\n\nTITLE: Example of a C Code Block with Syntax Highlighting\nDESCRIPTION: Provides an example of a C struct definition within a code block. When rendered using MkDocs with the specified language ('c'), this code will be syntax highlighted by Pygments.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/meta.md#2025-04-22_snippet_3\n\nLANGUAGE: c\nCODE:\n```\n```c\nstruct abc {\n    uint_t some_field;\n};\n```\n```\n\n----------------------------------------\n\nTITLE: Defining the bpf_iter_task_vma_destroy KFunc in C\nDESCRIPTION: Function signature for the bpf_iter_task_vma_destroy kernel function that destroys a task virtual memory area iterator.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/bpf_iter_task_vma_destroy.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nvoid bpf_iter_task_vma_destroy(struct bpf_iter_task_vma *it)\n```\n\n----------------------------------------\n\nTITLE: Definition of libbpf_unregister_prog_handler function in C\nDESCRIPTION: The function signature for unregistering a previously registered custom BPF program SEC handler. It takes a handler_id parameter and returns an integer indicating success or failure.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/libbpf_unregister_prog_handler.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nint libbpf_unregister_prog_handler(int handler_id);\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_tc_flags enum in C\nDESCRIPTION: This enum defines the flags for the TC qdisc, currently only including the replace flag.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_tc_query.md#2025-04-22_snippet_4\n\nLANGUAGE: c\nCODE:\n```\nenum bpf_tc_flags {\n\tBPF_TC_F_REPLACE = 1 << 0, // Replace existing program, fail if no program is attached\n};\n```\n\n----------------------------------------\n\nTITLE: Releasing TCP Congestion Control Algorithm via release Callback (C)\nDESCRIPTION: This function pointer type defines the 'release' callback, executed when the congestion control algorithm instance for a socket is being released. It receives the relevant socket pointer as a parameter. Implementers are expected to free any algorithm-specific resources or perform teardown actions here. This callback has no return value or additional parameters.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/program-type/BPF_PROG_TYPE_STRUCT_OPS/tcp_congestion_ops.md#2025-04-22_snippet_5\n\nLANGUAGE: c\nCODE:\n```\nvoid (*release)(struct sock *sk)\n```\n\n----------------------------------------\n\nTITLE: Defining the bpf_skb_get_xfrm_info KFunc Signature in C\nDESCRIPTION: This snippet defines the function signature for the bpf_skb_get_xfrm_info kernel function that retrieves XFRM metadata from a socket buffer.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/bpf_skb_get_xfrm_info.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nint bpf_skb_get_xfrm_info(struct __sk_buff *skb_ctx, struct bpf_xfrm_info *to)\n```\n\n----------------------------------------\n\nTITLE: New eBPF Flags in Linux 5.13-5.18\nDESCRIPTION: New flags introduced for various eBPF operations, including flags for adjusting room, broadcasting, and XDP functionality.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/timeline/index.md#2025-04-22_snippet_5\n\nLANGUAGE: C\nCODE:\n```\nBPF_F_ADJ_ROOM_ENCAP_L2_ETH\nBPF_F_BROADCAST\nBPF_F_EXCLUDE_INGRESS\nBPF_F_XDP_HAS_FRAGS\nBPF_F_KPROBE_MULTI_RETURN\nBPF_F_TEST_XDP_LIVE_FRAMES\n```\n\n----------------------------------------\n\nTITLE: Defining the bpf_dynptr_slice_rdwr KFunc in C\nDESCRIPTION: Function signature for bpf_dynptr_slice_rdwr which returns a pointer to dynptr data for read-write access. It accepts a dynptr, offset, buffer pointer, and buffer size parameters.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/bpf_dynptr_slice_rdwr.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nvoid *bpf_dynptr_slice_rdwr(const struct bpf_dynptr *p, u32 offset, void *buffer__opt, u32 buffer__szk)\n```\n\n----------------------------------------\n\nTITLE: Defining the eBPF Helper Function bpf_this_cpu_ptr in C\nDESCRIPTION: This snippet defines the 'bpf_this_cpu_ptr' eBPF helper as a function pointer in C, mapping it to a kernel helper function with a specific function ID (154). It is to be used within eBPF programs for accessing the percpu kernel variable for the current CPU from a given percpu pointer, and unlike 'bpf_per_cpu_ptr', it never returns NULL. There are no input/output buffer size limitations, but passing an invalid percpu pointer yields undefined behavior. Requires a Linux kernel version supporting eBPF helper 154 and an eBPF program operating in a permitted program type.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_this_cpu_ptr.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n#!c static void *(* const bpf_this_cpu_ptr)(const void *percpu_ptr) = (void *) 154;\n```\n\n----------------------------------------\n\nTITLE: Using xdp_program__chain_call_enabled Function in C\nDESCRIPTION: This function checks whether a specified XDP action is configured as a call chain action. It takes an XDP program structure pointer and an action enum as parameters, and returns a boolean value indicating whether the action is set for call chaining.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libxdp/functions/xdp_program__chain_call_enabled.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nbool xdp_program__chain_call_enabled(const struct xdp_program *xdp_prog, enum xdp_action action);\n```\n\n----------------------------------------\n\nTITLE: Defining btf__add_restrict Function in C\nDESCRIPTION: Function signature for btf__add_restrict, which appends a new BTF_KIND_RESTRICT type to a BTF object. It takes a pointer to a struct btf object and a referenced type ID as parameters. Returns the type ID of the newly added BTF type on success, or a negative value on error.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/btf__add_restrict.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nint btf__add_restrict(struct btf *btf, int ref_type_id);\n```\n\n----------------------------------------\n\nTITLE: Defining BPF_PROBE_READ_INTO Macro using libbpf - C\nDESCRIPTION: Defines the 'BPF_PROBE_READ_INTO' macro, which enables efficiently copying data from kernel memory into a user-provided destination in eBPF programs. It wraps the internal helper '__core_read' with the 'bpf_probe_read_kernel' helper function and provides variable argument support. This macro is intended for pointer-chasing use cases and does not emit CO-RE relocations. Requires libbpf v0.4.0+ and proper header inclusion; the destination storage must be prepared by the user.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/ebpf/BPF_PROBE_READ_INTO.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n#define BPF_PROBE_READ_INTO(dst, src, a, ...) ({\\\n\t___core_read(bpf_probe_read_kernel, bpf_probe_read_kernel,    \\\n\t\t     dst, (src), a, ##__VA_ARGS__)                \\\n})\n```\n\n----------------------------------------\n\nTITLE: Function Definition for bpf_program__get_expected_attach_type in C\nDESCRIPTION: Definition of the deprecated libbpf userspace function that returns the expected attach type for a BPF program. This function was introduced in libbpf v0.0.6 and has been renamed to bpf_program__expected_attach_type.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_program__get_expected_attach_type.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nenum bpf_attach_type bpf_program__get_expected_attach_type(const struct bpf_program *prog);\n```\n\n----------------------------------------\n\nTITLE: Defining libbpf_bpf_attach_type_str function in C\nDESCRIPTION: This snippet defines the libbpf_bpf_attach_type_str function, which takes a bpf_attach_type enum as input and returns a const char pointer to a static string identifying the attach type. It returns NULL for unknown bpf_attach_type values.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/libbpf_bpf_attach_type_str.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nconst char *libbpf_bpf_attach_type_str(enum bpf_attach_type t);\n```\n\n----------------------------------------\n\nTITLE: Using scx_bpf_exit in BPF scheduler error handling\nDESCRIPTION: This example demonstrates the usage of scx_bpf_exit macro in an error path of a BPF scheduler. It's used within a function that creates and destroys DSQs in a loop, specifically in the create_dsq_init_task function.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/scx/scx_bpf_exit.md#2025-04-22_snippet_1\n\nLANGUAGE: C\nCODE:\n```\ns32 [BPF_STRUCT_OPS_SLEEPABLE](BPF_STRUCT_OPS_SLEEPABLE.md)(create_dsq_init_task, struct task_struct *p,\n\t\t\t     struct scx_init_task_args *args)\n{\n\ts32 err;\n\n\terr = [scx_bpf_create_dsq](../../linux/kfuncs/scx_bpf_create_dsq.md)(p->pid, -1);\n\tif (err)\n\t\tscx_bpf_error(\"Failed to create DSQ for %s[%d]\",\n\t\t\t      p->comm, p->pid);\n\n\treturn err;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining the perf_buffer__new function and callback types in C\nDESCRIPTION: This snippet shows the function signature of perf_buffer__new along with the callback function types it requires for handling sample data and reporting lost events.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/perf_buffer__new.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\ntypedef void (*perf_buffer_sample_fn)(void *ctx, int cpu, void *data, __u32 size);\ntypedef void (*perf_buffer_lost_fn)(void *ctx, int cpu, __u64 cnt);\n\nstruct perf_buffer * perf_buffer__new(int map_fd, size_t page_cnt, perf_buffer_sample_fn sample_cb, perf_buffer_lost_fn lost_cb, void *ctx, const struct perf_buffer_opts *opts);\n```\n\n----------------------------------------\n\nTITLE: Defining an Admonition Note in Markdown\nDESCRIPTION: Demonstrates the Markdown syntax using '!!! note' to create a styled note block. This feature is provided by the Material for MkDocs theme's admonition extension, allowing for visually distinct inline messages like notes, warnings, tips, etc.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/meta.md#2025-04-22_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n```\n!!! note\n    This is a note\n```\n```\n\n----------------------------------------\n\nTITLE: Defining cubictcp_state KFunc in C\nDESCRIPTION: Function signature definition for the cubictcp_state kernel function. Takes a sock structure pointer and new state value as parameters. Must be called before changing ca_state.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/cubictcp_state.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nvoid cubictcp_state(struct sock *sk, u8 new_state)\n```\n\n----------------------------------------\n\nTITLE: Configuring Stack Depth with sysctl\nDESCRIPTION: Bash command to configure the maximum stack depth that can be collected using the sysctl interface. Allows adjusting kernel.perf_event_max_stack parameter for profiling longer stacks.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_get_task_stack.md#2025-04-22_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n# sysctl kernel.perf_event_max_stack=<new value>\n```\n\n----------------------------------------\n\nTITLE: Defining the PT_REGS_SYSCALL_REGS Macro in C for Libbpf\nDESCRIPTION: This C code defines the PT_REGS_SYSCALL_REGS macro. It takes a context pointer `ctx` and uses the PT_REGS_PARM1 macro to retrieve the first parameter passed to the kprobe, casting it to a `struct pt_regs *`. This abstraction allows eBPF programs to consistently access syscall registers via `struct pt_regs` regardless of whether the underlying architecture uses a syscall wrapper, by relying on target architecture flags set during compilation.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/ebpf/PT_REGS_SYSCALL_REGS.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n#define PT_REGS_SYSCALL_REGS(ctx) ((struct pt_regs *)PT_REGS_PARM1(ctx))\n```\n\n----------------------------------------\n\nTITLE: Deleting AF_XDP Socket Using xsk_socket__delete\nDESCRIPTION: Function signature for deleting an AF_XDP socket. The function takes a pointer to an xsk_socket structure and has no return value.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libxdp/functions/xsk_socket__delete.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nvoid xsk_socket__delete(struct xsk_socket *xsk);\n```\n\n----------------------------------------\n\nTITLE: Attaching LWT XMIT Program to a Route with iproute2\nDESCRIPTION: This command demonstrates how to attach a BPF_PROG_TYPE_LWT_XMIT program to a specific route using the iproute2 utility. The program will be executed when transmitting packets to the specified route.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/program-type/BPF_PROG_TYPE_LWT_XMIT.md#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nip route add 192.168.253.2/32 encap bpf out obj {elf file}.o section {prog section} dev veth0\n```\n\n----------------------------------------\n\nTITLE: Parsing TCP Header Options with eBPF Dynamic Pointers\nDESCRIPTION: This example demonstrates how to parse TCP header options using eBPF dynamic pointers to extract server IDs from packets. The code is adapted from the Katran L4 load balancer. It includes functions to parse TCP header options and an XDP program that processes IPv6 packets.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/bpf_dynptr_from_xdp.md#2025-04-22_snippet_1\n\nLANGUAGE: c\nCODE:\n```\n// SPDX-License-Identifier: GPL-2.0\n\n/* This logic is lifted from a real-world use case of packet parsing, used in\n * the open source library katran, a layer 4 load balancer.\n *\n * This test demonstrates how to parse packet contents using dynptrs. The\n * original code (parsing without dynptrs) can be found in test_parse_tcp_hdr_opt.c\n */\n\n#include <linux/bpf.h>\n#include <bpf/bpf_helpers.h>\n#include <linux/tcp.h>\n#include <stdbool.h>\n#include <linux/ipv6.h>\n#include <linux/if_ether.h>\n#include \"test_tcp_hdr_options.h\"\n#include \"bpf_kfuncs.h\"\n\nchar _license[] SEC(\"license\") = \"GPL\";\n\n/* Kind number used for experiments */\nconst __u32 tcp_hdr_opt_kind_tpr = 0xFD;\n/* Length of the tcp header option */\nconst __u32 tcp_hdr_opt_len_tpr = 6;\n/* maximum number of header options to check to lookup server_id */\nconst __u32 tcp_hdr_opt_max_opt_checks = 15;\n\n__u32 server_id;\n\nstatic int parse_hdr_opt(struct bpf_dynptr *ptr, __u32 *off, __u8 *hdr_bytes_remaining,\n\t\t\t __u32 *server_id)\n{\n\t__u8 *tcp_opt, kind, hdr_len;\n\t__u8 buffer[sizeof(kind) + sizeof(hdr_len) + sizeof(*server_id)];\n\t__u8 *data;\n\n\t__builtin_memset(buffer, 0, sizeof(buffer));\n\n\tdata = bpf_dynptr_slice(ptr, *off, buffer, sizeof(buffer));\n\tif (!data)\n\t\treturn -1;\n\n\tkind = data[0];\n\n\tif (kind == TCPOPT_EOL)\n\t\treturn -1;\n\n\tif (kind == TCPOPT_NOP) {\n\t\t*off += 1;\n\t\t*hdr_bytes_remaining -= 1;\n\t\treturn 0;\n\t}\n\n\tif (*hdr_bytes_remaining < 2)\n\t\treturn -1;\n\n\thdr_len = data[1];\n\tif (hdr_len > *hdr_bytes_remaining)\n\t\treturn -1;\n\n\tif (kind == tcp_hdr_opt_kind_tpr) {\n\t\tif (hdr_len != tcp_hdr_opt_len_tpr)\n\t\t\treturn -1;\n\n\t\t__builtin_memcpy(server_id, (__u32 *)(data + 2), sizeof(*server_id));\n\t\treturn 1;\n\t}\n\n\t*off += hdr_len;\n\t*hdr_bytes_remaining -= hdr_len;\n\treturn 0;\n}\n\nSEC(\"xdp\")\nint xdp_ingress_v6(struct xdp_md *xdp)\n{\n\t__u8 buffer[sizeof(struct tcphdr)] = {};\n\t__u8 hdr_bytes_remaining;\n\tstruct tcphdr *tcp_hdr;\n\t__u8 tcp_hdr_opt_len;\n\tint err = 0;\n\t__u32 off;\n\n\tstruct bpf_dynptr ptr;\n\n\tbpf_dynptr_from_xdp(xdp, 0, &ptr);\n\n\toff = sizeof(struct ethhdr) + sizeof(struct ipv6hdr);\n\n\ttcp_hdr = bpf_dynptr_slice(&ptr, off, buffer, sizeof(buffer));\n\tif (!tcp_hdr)\n\t\treturn XDP_DROP;\n\n\ttcp_hdr_opt_len = (tcp_hdr->doff * 4) - sizeof(struct tcphdr);\n\tif (tcp_hdr_opt_len < tcp_hdr_opt_len_tpr)\n\t\treturn XDP_DROP;\n\n\thdr_bytes_remaining = tcp_hdr_opt_len;\n\n\toff += sizeof(struct tcphdr);\n\n\t/* max number of bytes of options in tcp header is 40 bytes */\n\tfor (int i = 0; i < tcp_hdr_opt_max_opt_checks; i++) {\n\t\terr = parse_hdr_opt(&ptr, &off, &hdr_bytes_remaining, &server_id);\n\n\t\tif (err || !hdr_bytes_remaining)\n\t\t\tbreak;\n\t}\n\n\tif (!server_id)\n\t\treturn XDP_DROP;\n\n\treturn XDP_PASS;\n}\n```\n\n----------------------------------------\n\nTITLE: Using __ulong Macro in BTF Map Definition\nDESCRIPTION: This example demonstrates the usage of the __ulong macro in a BTF map definition for an arena map. It shows how to set map properties, including using __ulong for 64-bit values like map_extra.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/ebpf/__ulong.md#2025-04-22_snippet_1\n\nLANGUAGE: C\nCODE:\n```\nstruct {\n\t__uint(type, BPF_MAP_TYPE_ARENA);\n\t__uint(map_flags, BPF_F_MMAPABLE);\n\t__uint(max_entries, 10); /* number of pages */\n#ifdef __TARGET_ARCH_arm64\n\t__ulong(map_extra, 0x1ull << 32); /* start of mmap() region */\n#else\n\t__ulong(map_extra, 0x1ull << 44); /* start of mmap() region */\n#endif\n} arena SEC(\".maps\");\n```\n\n----------------------------------------\n\nTITLE: Using 'bpf_core_field_size' Macro in C\nDESCRIPTION: This snippet shows two ways to use the 'bpf_core_field_size' macro in C eBPF programs. The first form uses a variable access (p->my_field), while the second uses type and field names (struct my_type, my_field). Both methods allow querying the size of a kernel struct field at load time.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/ebpf/bpf_core_field_size.md#2025-04-22_snippet_1\n\nLANGUAGE: c\nCODE:\n```\nbpf_core_field_size(p->my_field)\n```\n\nLANGUAGE: c\nCODE:\n```\nbpf_core_field_size(struct my_type, my_field)\n```\n\n----------------------------------------\n\nTITLE: Defining dctcp_init KFunc in C\nDESCRIPTION: This code snippet defines the signature of the 'dctcp_init' kfunc. It takes a pointer to a struct sock as its parameter and returns void.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/dctcp_init.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nvoid dctcp_init(struct sock *sk)\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_map_get_info_by_fd Function in C\nDESCRIPTION: Function declaration for bpf_map_get_info_by_fd that retrieves information about a BPF map using its file descriptor. Takes a map file descriptor, info struct pointer, and info length pointer as parameters. Returns 0 on success or negative error code on failure.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_map_get_info_by_fd.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nint bpf_map_get_info_by_fd(int map_fd, struct bpf_map_info *info, __u32 *info_len);\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_wq_set_callback_impl kfunc in C\nDESCRIPTION: This snippet shows the C function signature for the bpf_wq_set_callback_impl kfunc. It sets a callback function for a work-queue, taking a pointer to a bpf_wq struct, a callback function, flags, and an auxiliary parameter.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/bpf_wq_set_callback_impl.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nint bpf_wq_set_callback_impl(struct bpf_wq *wq, int (callback_fn)(void * , int * , void * ), unsigned int flags, void *aux__ign)\n```\n\n----------------------------------------\n\nTITLE: Scheduler Initialization Callback Definition in C\nDESCRIPTION: Callback function signature for initializing the BPF scheduler. Returns 0 for success or error code.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/program-type/BPF_PROG_TYPE_STRUCT_OPS/sched_ext_ops.md#2025-04-22_snippet_38\n\nLANGUAGE: c\nCODE:\n```\ns32 (*init)(void);\n```\n\n----------------------------------------\n\nTITLE: Definition of bpf_dynptr_is_null Kernel Function in C\nDESCRIPTION: This code snippet shows the function signature of the bpf_dynptr_is_null kfunc. It takes a const pointer to a bpf_dynptr structure and returns a boolean value indicating whether the dynptr is null or invalid.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/bpf_dynptr_is_null.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nbool bpf_dynptr_is_null(const struct bpf_dynptr *p)\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_trace_opts Structure in C\nDESCRIPTION: Structure definition for bpf_trace_opts, which includes the size of the struct and a custom user-provided cookie value. The cookie can be retrieved using bpf_get_attach_cookie() in the BPF program.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_program__attach_trace_opts.md#2025-04-22_snippet_1\n\nLANGUAGE: c\nCODE:\n```\nstruct bpf_trace_opts {\n\tsize_t sz;\n\t__u64 cookie;\n};\n```\n\n----------------------------------------\n\nTITLE: Using xdp_program__from_bpf_obj Function in C\nDESCRIPTION: Function signature for retrieving an XDP program from a BPF object using a specific section name. This function returns a struct xdp_program pointer on success or a negative error code on failure.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libxdp/functions/xdp_program__from_bpf_obj.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstruct xdp_program *xdp_program__from_bpf_obj(struct bpf_object *obj, const char *section_name);\n```\n\n----------------------------------------\n\nTITLE: Example Markdown Admonition for Incomplete Documentation\nDESCRIPTION: A markdown admonition block indicating that the documentation about eBPF loaders is incomplete and that contributions are welcome.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/concepts/loader.md#2025-04-22_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n!!! example \"Docs could be improved\"\n    This part of the docs is incomplete, contributions are very welcome\n```\n\n----------------------------------------\n\nTITLE: KF_DESTRUCTIVE Flag Documentation\nDESCRIPTION: Flag indicating that a KFunc can be destructive to the system, requiring CAP_SYS_BOOT capability.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/concepts/kfuncs.md#2025-04-22_snippet_5\n\nLANGUAGE: markdown\nCODE:\n```\nKF_DESTRUCTIVE\n```\n\n----------------------------------------\n\nTITLE: KF_RCU Flag Documentation\nDESCRIPTION: Flag indicating that KFunc arguments must be RCU protected.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/concepts/kfuncs.md#2025-04-22_snippet_6\n\nLANGUAGE: markdown\nCODE:\n```\nKF_RCU\n```\n\n----------------------------------------\n\nTITLE: Function Definition for bpf_program__attach_freplace in C\nDESCRIPTION: Function signature for bpf_program__attach_freplace which is used to attach and replace a global eBPF function. It takes the BPF program to attach, the file descriptor of the target program, and the name of the function to replace.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_program__attach_freplace.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstruct bpf_link * bpf_program__attach_freplace(const struct bpf_program *prog, int target_fd, const char *attach_func_name);\n```\n\n----------------------------------------\n\nTITLE: Enum Definition of bpf_attach_type in C\nDESCRIPTION: Complete enumeration of all possible BPF program attach types that can be returned by bpf_program__expected_attach_type function. This defines all the locations where BPF programs can be attached in the kernel.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_program__expected_attach_type.md#2025-04-22_snippet_1\n\nLANGUAGE: c\nCODE:\n```\nenum bpf_attach_type {\n\tBPF_CGROUP_INET_INGRESS,\n\tBPF_CGROUP_INET_EGRESS,\n\tBPF_CGROUP_INET_SOCK_CREATE,\n\tBPF_CGROUP_SOCK_OPS,\n\tBPF_SK_SKB_STREAM_PARSER,\n\tBPF_SK_SKB_STREAM_VERDICT,\n\tBPF_CGROUP_DEVICE,\n\tBPF_SK_MSG_VERDICT,\n\tBPF_CGROUP_INET4_BIND,\n\tBPF_CGROUP_INET6_BIND,\n\tBPF_CGROUP_INET4_CONNECT,\n\tBPF_CGROUP_INET6_CONNECT,\n\tBPF_CGROUP_INET4_POST_BIND,\n\tBPF_CGROUP_INET6_POST_BIND,\n\tBPF_CGROUP_UDP4_SENDMSG,\n\tBPF_CGROUP_UDP6_SENDMSG,\n\tBPF_LIRC_MODE2,\n\tBPF_FLOW_DISSECTOR,\n\tBPF_CGROUP_SYSCTL,\n\tBPF_CGROUP_UDP4_RECVMSG,\n\tBPF_CGROUP_UDP6_RECVMSG,\n\tBPF_CGROUP_GETSOCKOPT,\n\tBPF_CGROUP_SETSOCKOPT,\n\tBPF_TRACE_RAW_TP,\n\tBPF_TRACE_FENTRY,\n\tBPF_TRACE_FEXIT,\n\tBPF_MODIFY_RETURN,\n\tBPF_LSM_MAC,\n\tBPF_TRACE_ITER,\n\tBPF_CGROUP_INET4_GETPEERNAME,\n\tBPF_CGROUP_INET6_GETPEERNAME,\n\tBPF_CGROUP_INET4_GETSOCKNAME,\n\tBPF_CGROUP_INET6_GETSOCKNAME,\n\tBPF_XDP_DEVMAP,\n\tBPF_CGROUP_INET_SOCK_RELEASE,\n\tBPF_XDP_CPUMAP,\n\tBPF_SK_LOOKUP,\n\tBPF_XDP,\n\tBPF_SK_SKB_VERDICT,\n\tBPF_SK_REUSEPORT_SELECT,\n\tBPF_SK_REUSEPORT_SELECT_OR_MIGRATE,\n\tBPF_PERF_EVENT,\n\t__MAX_BPF_ATTACH_TYPE\n};\n```\n\n----------------------------------------\n\nTITLE: Configuring Stack Depth with sysctl\nDESCRIPTION: Shell command to modify the maximum stack depth that can be collected by bpf_get_stack using sysctl.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_get_stack.md#2025-04-22_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n# sysctl kernel.perf_event_max_stack=<new value>\n```\n\n----------------------------------------\n\nTITLE: Defining btf__pointer_size Function in C\nDESCRIPTION: Function definition for btf__pointer_size, which returns the pointer size assumed by a BTF instance. It takes a pointer to a struct btf object as a parameter and returns the size of the pointer in bytes.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/btf__pointer_size.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nsize_t btf__pointer_size(const struct btf *btf);\n```\n\n----------------------------------------\n\nTITLE: KF_SLEEPABLE Flag Documentation\nDESCRIPTION: Flag indicating that a KFunc can sleep and must be called from sleepable programs.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/concepts/kfuncs.md#2025-04-22_snippet_4\n\nLANGUAGE: markdown\nCODE:\n```\nKF_SLEEPABLE\n```\n\n----------------------------------------\n\nTITLE: Querying BPF Link Information via libbpf in C\nDESCRIPTION: This C function provides a userspace API for retrieving information about a given BPF link by its file descriptor. It requires the 'libbpf' library and expects the caller to provide a pointer to a zero-initialized struct bpf_link_info and a pointer to its length in bytes. The function fills out this structure, updating 'info_len' with the number of bytes written. On success, it returns 0; on failure, a negative errno code is returned. Proper initialization of the info structure is required for reliable operation.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_link_get_info_by_fd.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n#!c int bpf_link_get_info_by_fd(int link_fd, struct bpf_link_info *info, __u32 *info_len);\n```\n\n----------------------------------------\n\nTITLE: Updating Kernel Configuration for VMLinux Blob Creation - Configuration\nDESCRIPTION: This snippet lists the specific kernel configuration options required to ensure all relevant Kfuncs and features are included in the VMLinux blob. These configuration settings must be applied to the Linux kernel's configuration file before building the kernel image, ensuring the produced blob supports desired eBPF functionality. Dependencies: access to the Linux kernel source and build environment. Inputs are lines to be added to the config, outputs are a kernel configured for VMLinux extraction.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/tools/kfunc-gen/vmlinux-update.md#2025-04-22_snippet_0\n\nLANGUAGE: configuration\nCODE:\n```\nCONFIG_HID=y\\nCONFIG_HID_BPF=y\\nCONFIG_TCP_CONG_BBR=y\\nCONFIG_TCP_CONG_DCTCP=y\\nCONFIG_XFRM=y\\nCONFIG_XFRM_INTERFACE=y\\nCONFIG_FS_VERITY=y\\nCONFIG_MODULE_SIG=y\\nCONFIG_MODULE_SIG_FORMAT=y\\nCONFIG_SYSTEM_DATA_VERIFICATION=y\\nCONFIG_CRYPTO=y\\nCONFIG_NF_TABLES=y\\nCONFIG_NF_FLOW_TABLE=y\\nCONFIG_MMU=y\\nCONFIG_64BIT=y\\nCONFIG_CGROUP_SCHED=y\\nCONFIG_SCHED_CLASS_EXT=y\n```\n\n----------------------------------------\n\nTITLE: Using xdp_multiprog__get_from_ifindex to retrieve XDP multiprog dispatcher in C\nDESCRIPTION: Function signature for retrieving an XDP multiprog (dispatcher program) from an interface index. Returns the multiprog structure on success or NULL on failure with a negative error code that can be -EBUSY if the dispatcher can't be reached or -ENOENT if the interface index doesn't exist.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libxdp/functions/xdp_multiprog__get_from_ifindex.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstruct xdp_multiprog *xdp_multiprog__get_from_ifindex(int ifindex);\n```\n\n----------------------------------------\n\nTITLE: Referencing Feature Introduction and Markdown Comments - Markdown\nDESCRIPTION: This snippet introduces the specific eBPF map type in a Markdown header and utilizes HTML comments as custom tags for feature metadata. It also includes a markdown-style badge linking to a Linux kernel commit, helping document when the feature was introduced. The approach provides contextual metadata for readers and toolchains, but introduces no logic or dynamic processing.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/map-type/BPF_MAP_TYPE_LRU_PERCPU_HASH.md#2025-04-22_snippet_1\n\nLANGUAGE: Markdown\nCODE:\n```\n# Map type `BPF_MAP_TYPE_LRU_PERCPU_HASH`\n\n<!-- [FEATURE_TAG](BPF_MAP_TYPE_LRU_PERCPU_HASH) -->\n[:octicons-tag-24: v4.10](https://github.com/torvalds/linux/commit/8f8449384ec364ba2a654f11f94e754e4ff719e0)\n<!-- [/FEATURE_TAG] -->\n```\n\n----------------------------------------\n\nTITLE: Retrieving Rx Descriptor from Rx Ring using xsk_ring_cons__rx_desc in C\nDESCRIPTION: This function retrieves the receive descriptor at a specific index in the Rx ring. It returns a struct xdp_desc representing the receive descriptor on success, or a negative error value on failure. The function takes a pointer to the xsk_ring_cons structure and an index as parameters.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libxdp/functions/xsk_ring_cons__rx_desc.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nconst struct xdp_desc *xsk_ring_cons__rx_desc(const struct xsk_ring_cons *rx, __u32 idx);\n```\n\n----------------------------------------\n\nTITLE: Inserting Helper Function References in Markdown\nDESCRIPTION: Demonstrates the markers used to insert generated helper function references into markdown files. The tool searches for these markers and places the generated content between them.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/meta.md#2025-04-22_snippet_6\n\nLANGUAGE: markdown\nCODE:\n```\n<!-- [HELPER_FUNC_PROG_REF] -->\n<!-- [/HELPER_FUNC_PROG_REF] -->\n```\n\n----------------------------------------\n\nTITLE: Documenting bpf_map_freeze in Libbpf C\nDESCRIPTION: This code snippet provides the function definition for 'bpf_map_freeze', which is a Libbpf function used to freeze BPF maps, preventing any further modifications. Its parameter is a file descriptor of the map to be frozen. It returns 0 on success or -errno on error, and it requires users to have a clear understanding of its implications.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_map_freeze.md#2025-04-22_snippet_0\n\nLANGUAGE: C\nCODE:\n```\n#!c int bpf_map_freeze(int fd);\n```\n\n----------------------------------------\n\nTITLE: Complex Per-CPU Operations with __percpu_kptr in eBPF Program\nDESCRIPTION: This eBPF program demonstrates complex operations with __percpu_kptr, including RCU-protected access, allocation, update, and deletion of per-CPU data.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/ebpf/__percpu_kptr.md#2025-04-22_snippet_6\n\nLANGUAGE: c\nCODE:\n```\nSEC(\"?fentry.s/bpf_fentry_test1\")\nint BPF_PROG(test_array_map_10)\n{\n\tstruct val_t __percpu_kptr *p, *p1;\n\tint i, index = 0;\n\tstruct val_t *v;\n\tstruct elem *e;\n\n\tif ((bpf_get_current_pid_tgid() >> 32) != my_pid)\n\t\treturn 0;\n\n\te = bpf_map_lookup_elem(&array, &index);\n\tif (!e)\n\t\treturn 0;\n\n\tbpf_rcu_read_lock();\n\tp = e->pc;\n\tif (!p) {\n\t\tp = bpf_percpu_obj_new(struct val_t);\n\t\tif (!p)\n\t\t\tgoto out;\n\n\t\tp1 = bpf_kptr_xchg(&e->pc, p);\n\t\tif (p1) {\n\t\t\t/* race condition */\n\t\t\tbpf_percpu_obj_drop(p1);\n\t\t}\n\t}\n\n\tv = bpf_this_cpu_ptr(p);\n\tv->c = 3;\n\tv = bpf_this_cpu_ptr(p);\n\tv->c = 0;\n\n\tv = bpf_per_cpu_ptr(p, 0);\n\tif (!v)\n\t\tgoto out;\n\tv->c = 1;\n\tv->d = 2;\n\n\t/* delete */\n\tp1 = bpf_kptr_xchg(&e->pc, NULL);\n\tif (!p1)\n\t\tgoto out;\n\n\tbpf_for(i, 0, nr_cpus) {\n\t\tv = bpf_per_cpu_ptr(p, i);\n\t\tif (v) {\n\t\t\tif (i == 0)\n\t\t\t\tcpu0_field_d = v->d;\n\t\t\tsum_field_c += v->c;\n\t\t}\n\t}\n\n\t/* finally release p */\n\tbpf_percpu_obj_drop(p1);\nout:\n\tbpf_rcu_read_unlock();\n\treturn 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining BTF Type Dump Function in C\nDESCRIPTION: Function prototype for btf_dump__dump_type that dumps BTF type in compilable C syntax. Takes a btf_dump struct pointer and BTF type ID as parameters, returns 0 on success and negative value on failure.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/btf_dump__dump_type.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nint btf_dump__dump_type(struct btf_dump *d, __u32 id);\n```\n\n----------------------------------------\n\nTITLE: Defining the bpf_xdp_xfrm_state_release KFunc Signature in C\nDESCRIPTION: This snippet shows the C function signature for the eBPF kfunc `bpf_xdp_xfrm_state_release`. It takes one parameter, `x`, which is a pointer to the `xfrm_state` object previously acquired via `bpf_xdp_get_xfrm_state`. The function releases this pointer, invalidating all other copies, and must be called for every acquired reference to avoid verifier errors.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/bpf_xdp_xfrm_state_release.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n`#!c void bpf_xdp_xfrm_state_release(struct xfrm_state *x)`\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_iter_scx_dsq_new KFunc in C\nDESCRIPTION: This code snippet defines the signature of the bpf_iter_scx_dsq_new kfunc which initializes a BPF iterator for walking tasks in a DSQ. The function takes an iterator, DSQ ID, and flags as parameters, returning 0 on success or a negative error code on failure.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/bpf_iter_scx_dsq_new.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nint bpf_iter_scx_dsq_new(struct bpf_iter_scx_dsq *it, u64 dsq_id, u64 flags)\n```\n\n----------------------------------------\n\nTITLE: Defining XDP Attachment Mode Enums - C\nDESCRIPTION: Enumeration defining possible XDP program attachment modes including none, driver, SKB, hardware, and multi-mode attachments.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_xdp_query.md#2025-04-22_snippet_1\n\nLANGUAGE: c\nCODE:\n```\nenum {\n\tXDP_ATTACHED_NONE = 0,\n\tXDP_ATTACHED_DRV,\n\tXDP_ATTACHED_SKB,\n\tXDP_ATTACHED_HW,\n\tXDP_ATTACHED_MULTI,\n};\n```\n\n----------------------------------------\n\nTITLE: Using xsk_ring_prod__needs_wakeup Function in C\nDESCRIPTION: Function declaration for checking if kernel needs wakeup for producer ring processing. Returns non-zero if kernel needs wake up, 0 otherwise. Should be used with XDP_USE_NEED_WAKEUP flag enabled in xdp_bind_flags.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libxdp/functions/xsk_ring_prod__needs_wakeup.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nint xsk_ring_prod__needs_wakeup(const struct xsk_ring_prod *r);\n```\n\n----------------------------------------\n\nTITLE: Declaring the 'flags' Field in 'sched_ext_ops' Struct (C)\nDESCRIPTION: Declares the 'flags' field within the 'sched_ext_ops' struct as an unsigned 64-bit integer. This bitfield is used to control the behavior of the custom BPF scheduler, allowing customization of its core operations. Possible values and their meanings are defined by the 'enum scx_ops_flags'.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/program-type/BPF_PROG_TYPE_STRUCT_OPS/sched_ext_ops.md#2025-04-22_snippet_3\n\nLANGUAGE: c\nCODE:\n```\nu64 flags\n```\n\n----------------------------------------\n\nTITLE: Building VMLinux Docker Image and Extracting BTF - Shell Script\nDESCRIPTION: This set of shell commands sequentially builds a VMLinux Docker image using a specified kernel tag, then extracts the VMLinux ELF and its BTF section for use with eBPF tools. Prerequisites: Docker, objcopy, a kernel build environment, and access to the 'ci-kernels' repo. Key parameters include the latest tag for the kernel, output directories, and image names. Inputs are the kernel config and sources; outputs are the ELF and BTF files named 'vmlinux' for use in further tooling.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/tools/kfunc-gen/vmlinux-update.md#2025-04-22_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\n./buildx.sh {latest tag} amd64 vmlinux --tag foo:vmlinux\n```\n\nLANGUAGE: shell\nCODE:\n```\necho \\\"FROM foo:vmlinux\\\" | \\\"$docker\\\" buildx build --quiet --output=\\\"$tmp\\\" - &> /dev/null\n```\n\nLANGUAGE: shell\nCODE:\n```\n\"/lib/modules/$(uname -r)/build/scripts/extract-vmlinux\" \"$tmp/boot/vmlinuz\" > \"$tmp/vmlinux.elf\"\n```\n\nLANGUAGE: shell\nCODE:\n```\nobjcopy --dump-section .BTF=/dev/stdout \"$tmp/vmlinux.elf\" /dev/null > vmlinux\n```\n\n----------------------------------------\n\nTITLE: Definition of bpf_check_mtu Helper Function in C\nDESCRIPTION: The C function prototype for the bpf_check_mtu eBPF helper, which allows checking if packet size would exceed the MTU of a network device. It's particularly useful when adjusting packet sizes in eBPF programs.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_check_mtu.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstatic long (* const bpf_check_mtu)(void *ctx, __u32 ifindex, __u32 *mtu_len, __s32 len_diff, __u64 flags) = (void *) 163;\n```\n\n----------------------------------------\n\nTITLE: Setting eBPF Program License\nDESCRIPTION: This line sets the license for the eBPF program to GPL (GNU General Public License). This is required for certain eBPF program types and affects which kernel functions the program can call.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/bpf_dynptr_from_xdp.md#2025-04-22_snippet_5\n\nLANGUAGE: C\nCODE:\n```\nchar _license[] SEC(\"license\") = \"GPL\";\n```\n\n----------------------------------------\n\nTITLE: Defining KFunction Masks for Scheduler Operations (C)\nDESCRIPTION: Defines the enum scx_kf_mask which contains mask bits for tracking which kernel functions (kfuncs) are allowed for the current task in different scheduler contexts.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/program-type/BPF_PROG_TYPE_STRUCT_OPS/sched_ext_ops.md#2025-04-22_snippet_45\n\nLANGUAGE: c\nCODE:\n```\nenum scx_kf_mask {\n    SCX_KF_UNLOCKED     = 0,\n    SCX_KF_CPU_RELEASE  = 1 << 0,\n    SCX_KF_DISPATCH     = 1 << 1,\n    SCX_KF_ENQUEUE      = 1 << 2,\n    SCX_KF_SELECT_CPU   = 1 << 3,\n    SCX_KF_REST         = 1 << 4,\n};\n```\n\n----------------------------------------\n\nTITLE: Using xsk_umem__add_offset_to_addr Function in C\nDESCRIPTION: This snippet shows the function signature for xsk_umem__add_offset_to_addr, which adds an offset to the address in unaligned mode. The function returns a __u64 containing the new address. Note that this should be used with xsk_umem__extract_addr and xsk_umem__extract_offset functions.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libxdp/functions/xsk_umem__add_offset_to_addr.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n__u64 xsk_umem__add_offset_to_addr(__u64 addr);\n```\n\n----------------------------------------\n\nTITLE: Definition of libbpf_get_error function in C\nDESCRIPTION: Function signature for libbpf_get_error that extracts error codes from pointers returned by libbpf API functions. It takes a pointer parameter and returns a long representing the error code or 0 if no error occurred.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/libbpf_get_error.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nlong libbpf_get_error(const void *ptr);\n```\n\n----------------------------------------\n\nTITLE: Definition of bpf_dynptr_is_rdonly eBPF KFunc\nDESCRIPTION: The function signature for the 'bpf_dynptr_is_rdonly' kernel function. It takes a constant bpf_dynptr struct pointer as input and returns a boolean indicating whether the dynptr is read-only.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/bpf_dynptr_is_rdonly.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nbool bpf_dynptr_is_rdonly(const struct bpf_dynptr *p)\n```\n\n----------------------------------------\n\nTITLE: Inserting MTU Calculation Table in Markdown\nDESCRIPTION: Shows the markers used to insert the generated MTU calculation table into the XDP program type markdown file. The tool looks for these markers to place the rendered table.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/meta.md#2025-04-22_snippet_11\n\nLANGUAGE: markdown\nCODE:\n```\n<!-- [MTU_TABLE] -->\n<!-- [/MTU_TABLE] -->\n```\n\n----------------------------------------\n\nTITLE: Inserting Libbpf Version Tags in Markdown\nDESCRIPTION: Illustrates the markers used to insert generated Libbpf version tags into markdown files. The tool searches for these markers and places the version number tag and link between them.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/meta.md#2025-04-22_snippet_12\n\nLANGUAGE: markdown\nCODE:\n```\n<!-- [LIBBPF_TAG] -->\n<!-- [/LIBBPF_TAG] -->\n```\n\n----------------------------------------\n\nTITLE: New eBPF Program Types in Linux 5.13-5.18\nDESCRIPTION: New program types added for eBPF, including BPF_PROG_TYPE_SYSCALL for system call interception.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/timeline/index.md#2025-04-22_snippet_3\n\nLANGUAGE: C\nCODE:\n```\nBPF_PROG_TYPE_SYSCALL\n```\n\n----------------------------------------\n\nTITLE: Retrieving XDP Program from Pinned Path in C\nDESCRIPTION: This function retrieves an XDP program from a specified pinned path. It returns a pointer to an xdp_program structure on success, or a negative error code on failure. The function takes a single parameter 'pin_path' which is the path where the XDP program is pinned.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libxdp/functions/xdp_program__from_pin.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstruct xdp_program *xdp_program__from_pin(const char *pin_path);\n```\n\n----------------------------------------\n\nTITLE: Definition of btf__load_vmlinux_btf Function in Libbpf\nDESCRIPTION: Function signature for btf__load_vmlinux_btf that loads the BTF object of the current running kernel. It returns a pointer to a struct btf object on success, or NULL on failure. The caller must free the returned object with btf__free.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/btf__load_vmlinux_btf.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstruct btf *btf__load_vmlinux_btf(void);\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_preempt_enable KFunc in C\nDESCRIPTION: Function signature for the bpf_preempt_enable kernel function that enables preemption in BPF programs. This function allows nesting and works in conjunction with bpf_preempt_disable.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/bpf_preempt_enable.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nvoid bpf_preempt_enable()\n```\n\n----------------------------------------\n\nTITLE: Defining Pinning Types with enum in libbpf (C)\nDESCRIPTION: Defines the enum libbpf_pin_type, enumerating valid values for the 'pinning' property of BPF maps in C. This enum includes LIBBPF_PIN_NONE for no pinning and LIBBPF_PIN_BY_NAME for pinning by map name under /sys/fs/bpf. Required dependency: libbpf headers. Outputs the available pinning options for map configuration; not intended to stand alone but used as part of eBPF program definitions.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/ebpf/enum-libbpf_pin_type.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nenum libbpf_pin_type {\n\tLIBBPF_PIN_NONE,\n\t/* PIN_BY_NAME: pin maps by name (in /sys/fs/bpf by default) */\n\tLIBBPF_PIN_BY_NAME,\n};\n```\n\n----------------------------------------\n\nTITLE: Definition of bpf_program__set_autoload Function in Libbpf (C)\nDESCRIPTION: Function prototype for bpf_program__set_autoload which changes the auto-load status of a BPF program. It takes a BPF program pointer and a boolean parameter to control whether the program should be automatically loaded when the object is loaded.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_program__set_autoload.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nint bpf_program__set_autoload(struct bpf_program *prog, bool autoload);\n```\n\n----------------------------------------\n\nTITLE: DCTCP Congestion Window Undo in BPF\nDESCRIPTION: This function handles undoing changes to the congestion window in DCTCP. It ensures that the congestion window doesn't fall below a certain threshold after a loss event.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/program-type/BPF_PROG_TYPE_STRUCT_OPS/tcp_congestion_ops.md#2025-04-22_snippet_20\n\nLANGUAGE: C\nCODE:\n```\nSEC(\"struct_ops\")\n__u32 BPF_PROG(bpf_dctcp_cwnd_undo, struct sock *sk)\n{\n\tconst struct bpf_dctcp *ca = inet_csk_ca(sk);\n\n\treturn max(tcp_sk(sk)->snd_cwnd, ca->loss_cwnd);\n}\n```\n\n----------------------------------------\n\nTITLE: Using xsk_ring_cons__cancel Function in C\nDESCRIPTION: Function signature for canceling the reservation of slots in a consumer ring. It takes a pointer to a consumer ring structure and the number of slots to cancel. The function doesn't return any value.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libxdp/functions/xsk_ring_cons__cancel.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nvoid xsk_ring_cons__cancel(struct xsk_ring_cons *cons, __u32 nb);\n```\n\n----------------------------------------\n\nTITLE: Defining the bpf_core_type_id_local Macro in C (libbpf)\nDESCRIPTION: Defines the C macro `bpf_core_type_id_local` used in libbpf-based eBPF programs. This macro leverages the `__builtin_btf_type_id` compiler built-in with the `BPF_TYPE_ID_LOCAL` flag to retrieve the BTF (BPF Type Format) type ID of the specified `type` from the program's local BTF information. This ID is determined at load time by the loader (e.g., libbpf) and is treated as a constant by the eBPF verifier.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/ebpf/bpf_core_type_id_local.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n#define bpf_core_type_id_local(type)\t\t\t\t\t    \\\n\t__builtin_btf_type_id(*___bpf_typeof(type), BPF_TYPE_ID_LOCAL)\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_program__set_expected_attach_type Function in C\nDESCRIPTION: Function definition for setting the expected attach type of a BPF program. It takes a pointer to a bpf_program struct and an enum bpf_attach_type as parameters. Returns an integer error code, with 0 indicating success.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_program__set_expected_attach_type.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nint bpf_program__set_expected_attach_type(struct bpf_program *prog, enum bpf_attach_type type);\n```\n\n----------------------------------------\n\nTITLE: CPU State Dump Callback Definition in C\nDESCRIPTION: Callback function signature for dumping CPU-specific scheduler state during errors. Takes dump context, CPU ID and idle flag as parameters.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/program-type/BPF_PROG_TYPE_STRUCT_OPS/sched_ext_ops.md#2025-04-22_snippet_28\n\nLANGUAGE: c\nCODE:\n```\nvoid (*dump_cpu)(struct scx_dump_ctx *ctx, s32 cpu, bool idle);\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_program__attach_trace Function in C\nDESCRIPTION: The function signature for bpf_program__attach_trace which attaches a BPF_PROG_TYPE_TRACING program. It takes a pointer to a bpf_program structure and returns a pointer to the created bpf_link structure, or NULL on error.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_program__attach_trace.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstruct bpf_link * bpf_program__attach_trace(const struct bpf_program *prog);\n```\n\n----------------------------------------\n\nTITLE: Stating Absence of Supported eBPF KFuncs for Socket Filters (Text)\nDESCRIPTION: A simple textual statement indicating that, at the time of writing, there are no supported Kernel Functions (KFuncs) available for use within eBPF socket filter programs. This information is located within comment markers often used for auto-generated documentation sections related to KFunc availability.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/program-type/BPF_PROG_TYPE_FLOW_DISSECTOR.md#2025-04-22_snippet_2\n\nLANGUAGE: text\nCODE:\n```\n<!-- [PROG_KFUNC_REF] -->\nThere are currently no kfuncs supported for this program type\n<!-- [/PROG_KFUNC_REF] -->\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_flow_keys Structure in C\nDESCRIPTION: C structure definition of bpf_flow_keys which contains flow dissector input and output arguments. This structure stores metadata extracted from packets, including protocol information, ports, and IP addresses.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/program-type/BPF_PROG_TYPE_FLOW_DISSECTOR.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstruct bpf_flow_keys {\n    __u16\tnhoff;\n    __u16\tthoff;\n    __u16\taddr_proto;\t\t\t/* ETH_P_* of valid addrs */\n    __u8\tis_frag;\n    __u8\tis_first_frag;\n    __u8\tis_encap;\n    __u8\tip_proto;\n    __be16\tn_proto;\n    __be16\tsport;\n    __be16\tdport;\n    union {\n        struct {\n            __be32\tipv4_src;\n            __be32\tipv4_dst;\n        };\n        struct {\n            __u32\tipv6_src[4];\t/* in6_addr; network order */\n            __u32\tipv6_dst[4];\t/* in6_addr; network order */\n        };\n    };\n    __u32\tflags;\n    __be32\tflow_label;\n};\n```\n\n----------------------------------------\n\nTITLE: Definition of bpf_iter_link_info Union in C\nDESCRIPTION: This union defines the link information for iterator program attachment. Currently it only contains a map structure with a map_fd field that specifies the file descriptor of the map to iterate over.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_program__attach_iter.md#2025-04-22_snippet_2\n\nLANGUAGE: c\nCODE:\n```\nunion bpf_iter_link_info {\n\tstruct {\n\t\t__u32\tmap_fd;\n\t} map;\n};\n```\n\n----------------------------------------\n\nTITLE: Defining the 'bpf_get_fd_by_id_opts' structure in C\nDESCRIPTION: This snippet defines the C structure `bpf_get_fd_by_id_opts`, which is used to pass options to the `bpf_btf_get_fd_by_id_opts` function. It includes `sz` for structure size (ensuring forward/backward compatibility) and `open_flags` (available since libbpf 1.1.0) to specify the permissions requested for operations on the obtained file descriptor. This structure allows configuring how the BTF object's file descriptor is retrieved.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_btf_get_fd_by_id_opts.md#2025-04-22_snippet_1\n\nLANGUAGE: c\nCODE:\n```\nstruct bpf_get_fd_by_id_opts {\n\tsize_t sz; /* size of this struct for forward/backward compatibility */\n\t__u32 open_flags; /* permissions requested for the operation on fd */\n\tsize_t :0;\n};\n```\n\n----------------------------------------\n\nTITLE: Defining eBPF KFunc Hid Output Report in C\nDESCRIPTION: The function 'hid_bpf_hw_output_report' sends an output report to a HID device. It requires a previously allocated HID-BPF context and a memory buffer. It returns the number of bytes transferred, or a negative error code if the transfer fails. This function may sleep and must be used within sleepable programs, not in 'BPF_PROG_TYPE_SYSCALL'.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/hid_bpf_hw_output_report.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nint hid_bpf_hw_output_report(struct hid_bpf_ctx *ctx, __u8 *buf, size_t buf__sz)\n```\n\n----------------------------------------\n\nTITLE: Prompting for Documentation Improvement - Markdown\nDESCRIPTION: This snippet uses a Markdown callout block to notify readers that the documentation is incomplete and invites community contributions. It demonstrates the use of callout syntax (compatible with various Markdown renderers) and highlights collaborative documentation practices. The block does not accept input and outputs only a styled message.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/map-type/BPF_MAP_TYPE_LRU_PERCPU_HASH.md#2025-04-22_snippet_2\n\nLANGUAGE: Markdown\nCODE:\n```\n!!! example \"Docs could be improved\"\n    This part of the docs is incomplete, contributions are very welcome\n```\n\n----------------------------------------\n\nTITLE: Definition of perf_buffer__buffer_cnt function in C\nDESCRIPTION: Function signature for perf_buffer__buffer_cnt which returns the number of BPF_MAP_TYPE_PERF_EVENT_ARRAY map slots configured in a perf buffer. The function takes a perf buffer manager as input and returns the slot count as a size_t value.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/perf_buffer__buffer_cnt.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nsize_t perf_buffer__buffer_cnt(const struct perf_buffer *pb);\n```\n\n----------------------------------------\n\nTITLE: Defining Compatibility Macro for scx_bpf_dsq_move in C\nDESCRIPTION: This macro provides compatibility between the renamed kernel functions scx_bpf_dsq_move and scx_bpf_dispatch_from_dsq. It uses bpf_ksym_exists to check which function is available at runtime and calls the appropriate one, returning false if neither is available.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/scx/__COMPAT_scx_bpf_dsq_move.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n#define __COMPAT_scx_bpf_dsq_move(it__iter, p, dsq_id, enq_flags)\\t\\t\\\n\\t([bpf_ksym_exists](../libbpf/ebpf/bpf_ksym_exists.md)(scx_bpf_dsq_move) ?\\t\\t\\t\\t\\t\\\n\\t [scx_bpf_dsq_move](../../linux/kfuncs/scx_bpf_dsq_move.md)((it__iter), (p), (dsq_id), (enq_flags)) :\\t\\t\\\n\\t ([bpf_ksym_exists](../libbpf/ebpf/bpf_ksym_exists.md)(scx_bpf_dispatch_from_dsq___compat) ?\\t\\t\\t\\\n\\t  [scx_bpf_dispatch_from_dsq___compat](../../linux/kfuncs/scx_bpf_dispatch_from_dsq.md)((it__iter), (p), (dsq_id), (enq_flags)) : \\\n\\t  false))\n```\n\n----------------------------------------\n\nTITLE: Defining the btf__find_by_name_kind function in C\nDESCRIPTION: The function signature for btf__find_by_name_kind, which takes a BTF object pointer, type name string, and kind identifier as parameters and returns the type ID on success or a negative error code on failure.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/btf__find_by_name_kind.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n__s32 btf__find_by_name_kind(const struct btf *btf, const char *type_name, __u32 kind);\n```\n\n----------------------------------------\n\nTITLE: Defining btf__add_decl_attr function in C\nDESCRIPTION: Function definition for btf__add_decl_attr, which appends a new BTF_KIND_DECL_TAG type to a BTF object. It takes parameters for the BTF object, tag value, referenced type ID, and component index. Returns the type ID of the newly added BTF type or a negative value on error.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/btf__add_decl_attr.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nint btf__add_decl_attr(struct btf *btf, const char *value, int ref_type_id, int component_idx);\n```\n\n----------------------------------------\n\nTITLE: eBPF Timer Structure Definition\nDESCRIPTION: The definition of the bpf_timer structure which consists of two 64-bit fields. This structure is used as a field within map values to enable timer functionality.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/concepts/timers.md#2025-04-22_snippet_1\n\nLANGUAGE: c\nCODE:\n```\nstruct bpf_timer { __u64 :64; __u64 :64; };\n```\n\n----------------------------------------\n\nTITLE: Definition of btf__get_raw_data Function in C\nDESCRIPTION: The function signature for btf__get_raw_data, which retrieves raw BTF data and its size. This function takes a pointer to a BTF structure and a pointer to store the size, returning a pointer to the raw data.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/btf__get_raw_data.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nconst void *btf__get_raw_data(const struct btf *btf, __u32 *size);\n```\n\n----------------------------------------\n\nTITLE: Using __bpf_unreachable in an eBPF switch statement\nDESCRIPTION: This example demonstrates the use of __bpf_unreachable in a switch statement. It ensures that my_func is always called with one of the handled enum values, causing a compile-time error if an unhandled case is reached.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/ebpf/__bpf_unreachable.md#2025-04-22_snippet_1\n\nLANGUAGE: C\nCODE:\n```\nenum my_enum {\n    MY_ENUM_A,\n    MY_ENUM_B,\n};\n\nstatic void __always_inline my_func(enum my_enum e) {\n    switch (e) {\n    case MY_ENUM_A:\n        // Do something\n        break;\n    case MY_ENUM_B:\n        // Do something\n        break;\n    default:\n        __bpf_unreachable();\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Function Definition for bpf_object__load in C\nDESCRIPTION: Function prototype for bpf_object__load that takes a pointer to a bpf_object structure and returns an integer status code. The function loads a BPF object into the kernel and returns 0 on success or a negative error code on failure.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_object__load.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nint bpf_object__load(struct bpf_object *obj);\n```\n\n----------------------------------------\n\nTITLE: Defining libbpf_set_memlock_rlim function in C\nDESCRIPTION: This snippet defines the libbpf_set_memlock_rlim function, which sets the memlock resource limit for the current process. It takes a size_t parameter for the number of bytes and returns an integer indicating success or failure.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/libbpf_set_memlock_rlim.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nint libbpf_set_memlock_rlim(size_t memlock_bytes);\n```\n\n----------------------------------------\n\nTITLE: Defining btf__load_module_btf function in C\nDESCRIPTION: This snippet defines the btf__load_module_btf function, which loads the BTF object of a kernel module. It takes the module name and a pointer to the vmlinux BTF object as parameters and returns a pointer to a struct btf object.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/btf__load_module_btf.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstruct btf *btf__load_module_btf(const char *module_name, struct btf *vmlinux_btf);\n```\n\n----------------------------------------\n\nTITLE: Placeholder for Socket Filter Change Log (Markdown Comment)\nDESCRIPTION: This is a Markdown comment serving as a placeholder to add information about how the eBPF socket filter program type has changed or evolved over different kernel versions. It indicates where a detailed change history should be documented.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/program-type/BPF_PROG_TYPE_SOCKET_FILTER.md#2025-04-22_snippet_5\n\nLANGUAGE: markdown\nCODE:\n```\n<!-- TODO: Did this change over time, how? -->\n```\n\n----------------------------------------\n\nTITLE: Example of C Code with an Embedded Markdown Link\nDESCRIPTION: Shows a C struct definition where the field name 'some_field' is hyperlinked using Markdown syntax. This relies on a custom project hook (`hooks/links_in_code.py`) to process and render the link correctly within the highlighted code block.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/meta.md#2025-04-22_snippet_5\n\nLANGUAGE: c\nCODE:\n```\n```c\nstruct abc {\n    uint_t [some_field](#codeblocks);\n};\n```\n```\n\n----------------------------------------\n\nTITLE: BPF Log Level Constants in C\nDESCRIPTION: Defines the constants for different BPF verifier log levels and flags. Includes basic log levels (LEVEL1, LEVEL2) and additional flags (STATS, FIXED) that can be combined with the log levels to control verbosity and behavior of the verifier output.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_program__log_level.md#2025-04-22_snippet_1\n\nLANGUAGE: c\nCODE:\n```\n#define BPF_LOG_LEVEL1\t1\n#define BPF_LOG_LEVEL2\t2\n#define BPF_LOG_STATS\t4\n#define BPF_LOG_FIXED\t8\n```\n\n----------------------------------------\n\nTITLE: Function Definition for bpf_object__btf_fd in C\nDESCRIPTION: Function signature for retrieving the BTF file descriptor from a BPF object. Takes a const pointer to a bpf_object and returns an integer file descriptor. Returns -1 if the object has no BTF or if BTF is not yet loaded into kernel.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_object__btf_fd.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nint bpf_object__btf_fd(const struct bpf_object *obj);\n```\n\n----------------------------------------\n\nTITLE: Kernel Function Assembly With Active Tracing\nDESCRIPTION: Shows how the assembly code looks when tracing is enabled, with trace_call implementation.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/concepts/trampolines.md#2025-04-22_snippet_2\n\nLANGUAGE: assembly\nCODE:\n```\n# Symbol where instructions like: CALL some_kernel_func will jump to.\nsome_kernel_func:\n  CALL trace_call\n  NOP\n# actual start of the function\n  PUSH RBP\n  MOV RSP, RBP\n  [...]\n  RET\n```\n\n----------------------------------------\n\nTITLE: Defining btf__raw_data function in C\nDESCRIPTION: This snippet defines the 'btf__raw_data' function from the libbpf library. It takes a BTF object and a pointer to store the size, returning a const pointer to the raw serialized BTF data.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/btf__raw_data.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nconst void *btf__raw_data(const struct btf *btf, __u32 *size);\n```\n\n----------------------------------------\n\nTITLE: Serving eBPF Docs Locally with Python\nDESCRIPTION: Steps to set up a Python virtual environment, install dependencies, and serve the documentation locally using mkdocs. The documentation will be served on localhost port 8000 with live reload functionality.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/README.md#2025-04-22_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\n$ python3 -m venv .venv\n$ source .venv/bin/activate\n$ pip install -r requirements.txt\n$ mkdocs serve -a 127.0.0.1:8000 --watch ./docs\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_raw_tp_opts struct for Raw Tracepoint Options in C\nDESCRIPTION: This code defines the structure bpf_raw_tp_opts which contains the configuration options for raw tracepoints, including the struct size for compatibility, tracepoint name, cookie value, and a size field for alignment.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_raw_tracepoint_open_opts.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstruct bpf_raw_tp_opts {\n\tsize_t sz; /* size of this struct for forward/backward compatibility */\n\tconst char *tp_name;\n\t__u64 cookie;\n\tsize_t :0;\n};\n```\n\n----------------------------------------\n\nTITLE: Definition of bpf_iter_css_task_next KFunc in C\nDESCRIPTION: Function signature for the bpf_iter_css_task_next kernel function that advances a cgroup subsystem task iterator to the next task. The function returns a pointer to struct task_struct which may be NULL, requiring NULL checking before use.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/bpf_iter_css_task_next.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstruct task_struct *bpf_iter_css_task_next(struct bpf_iter_css_task *it)\n```\n\n----------------------------------------\n\nTITLE: Defining btf__align_of function in C\nDESCRIPTION: Function definition for btf__align_of, which takes a pointer to a struct btf object and a BTF type ID as parameters. It returns the alignment of the type on success or a negative error code on failure.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/btf__align_of.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nint btf__align_of(const struct btf *btf, __u32 id);\n```\n\n----------------------------------------\n\nTITLE: Function Definition for bpf_object__find_program_by_name in Libbpf\nDESCRIPTION: This function allows querying a BPF object for a program by name. It takes a pointer to a valid BPF object and the name of the program to find. Returns a pointer to the program with the given name, or NULL if no program with that name is found.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_object__find_program_by_name.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstruct bpf_program * bpf_object__find_program_by_name(const struct bpf_object *obj, const char *name);\n```\n\n----------------------------------------\n\nTITLE: Standard Forward Declaration of bpf_map_lookup_elem (C)\nDESCRIPTION: Illustrates the standard C forward declaration for the `bpf_map_lookup_elem` function. This is provided for contrast with the specialized declaration used in `bpf_helper_defs.h`. The standard declaration is not the one used by libbpf to invoke the kernel helper function.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/ebpf/index.md#2025-04-22_snippet_1\n\nLANGUAGE: c\nCODE:\n```\nvoid *bpf_map_lookup_elem(void *map, const void *key);\n```\n\n----------------------------------------\n\nTITLE: BTF Typedef Function Definition in C\nDESCRIPTION: Function signature for btf__add_typedef which adds a new typedef entry to a BTF object. Takes a BTF struct pointer, typedef name, and reference type ID as parameters. Returns the new type ID on success or negative value on error.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/btf__add_typedef.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nint btf__add_typedef(struct btf *btf, const char *name, int ref_type_id);\n```\n\n----------------------------------------\n\nTITLE: Defining crash_kexec KFunc in C\nDESCRIPTION: Function signature for the crash_kexec kernel function that triggers a kernel panic. Takes a pointer to pt_regs structure as parameter. Requires CAP_SYS_BOOT capability and can cause system reboots or panics.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/crash_kexec.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nvoid crash_kexec(struct pt_regs *regs)\n```\n\n----------------------------------------\n\nTITLE: Defining and Describing bpf_map__autocreate in C\nDESCRIPTION: The 'bpf_map__autocreate' function determines if a BPF map should be auto-created by libbpf during the BPF object load phase. It accepts a pointer to a BPF map as its parameter and returns a boolean. The dependency is libbpf version 0.8.0 or higher. The implementation focuses on BPF map management and integration with BPF object lifecycle.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_map__autocreate.md#2025-04-22_snippet_0\n\nLANGUAGE: C\nCODE:\n```\n#!c bool bpf_map__autocreate(const struct bpf_map *map);\n```\n\n----------------------------------------\n\nTITLE: Function Definition: bpf_map_get_next_id\nDESCRIPTION: C function definition for bpf_map_get_next_id that wraps the BPF_MAP_GET_NEXT_ID syscall. Takes a starting map ID and returns the next available map ID. Returns 0 on success or a negative error code on failure.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_map_get_next_id.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nint bpf_map_get_next_id(__u32 start_id, __u32 *next_id);\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_skc_to_tcp_sock Helper Function in C\nDESCRIPTION: This snippet defines the 'bpf_skc_to_tcp_sock' helper function, which dynamically casts a 'sk' pointer to a 'tcp_sock' pointer. It returns the 'sk' pointer if casting is valid, or NULL otherwise.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_skc_to_tcp_sock.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstatic struct tcp_sock *(* const bpf_skc_to_tcp_sock)(void *sk) = (void *) 137;\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_per_cpu_ptr Helper Function in C\nDESCRIPTION: Function definition for the bpf_per_cpu_ptr helper that takes a pointer to a percpu ksym and returns a pointer to the percpu kernel variable on the specified CPU. Returns NULL if the CPU ID is invalid.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_per_cpu_ptr.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstatic void *(* const bpf_per_cpu_ptr)(const void *percpu_ptr, __u32 cpu) = (void *) 153;\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_skb_output Helper Function in C\nDESCRIPTION: C function definition for the bpf_skb_output eBPF helper. It takes context, map, flags, data, and size parameters, returning a long integer status code.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_skb_output.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstatic long (* const bpf_skb_output)(void *ctx, void *map, __u64 flags, void *data, __u64 size) = (void *) 111;\n```\n\n----------------------------------------\n\nTITLE: Defining btf__add_func_proto function in C\nDESCRIPTION: This snippet shows the function signature for btf__add_func_proto. It takes a pointer to a struct btf object and an integer representing the return type ID. The function returns an integer type ID for the newly added BTF type, or a negative value on error.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/btf__add_func_proto.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nint btf__add_func_proto(struct btf *btf, int ret_type_id);\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_btf_get_next_id Function in C\nDESCRIPTION: This C function serves as a low-level wrapper around the 'BPF_BTF_GET_NEXT_ID' syscall. It allows iteration over loaded BTF objects by returning the next BTF object ID after the specified 'start_id'. If 'start_id' is '0', the first BTF object ID is returned. It takes two parameters: 'start_id' and a pointer 'next_id'. It returns '0' on success or a negative error code if it fails.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_btf_get_next_id.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nint bpf_btf_get_next_id(__u32 start_id, __u32 *next_id);\n```\n\n----------------------------------------\n\nTITLE: Function Signature for bpf_object__next_map in Libbpf C API\nDESCRIPTION: This function signature defines the bpf_object__next_map function that iterates over maps in a BPF object. It takes a BPF object pointer and the current map pointer (or NULL to start iteration) and returns the next map or NULL if there are no more maps.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_object__next_map.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstruct bpf_map * bpf_object__next_map(const struct bpf_object *obj, const struct bpf_map *map);\n```\n\n----------------------------------------\n\nTITLE: Defining btf_endianness enum in C\nDESCRIPTION: Enum definition for btf_endianness, which represents the possible endianness values (little endian and big endian) for BTF extension objects.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/btf_ext__endianness.md#2025-04-22_snippet_1\n\nLANGUAGE: c\nCODE:\n```\nenum btf_endianness {\n\tBTF_LITTLE_ENDIAN = 0,\n\tBTF_BIG_ENDIAN = 1,\n};\n```\n\n----------------------------------------\n\nTITLE: Definition of bpf_object__gen_loader function in C\nDESCRIPTION: The C function signature for bpf_object__gen_loader, which takes a BPF object pointer and generation options as parameters and returns an integer status code.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_object__gen_loader.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nint bpf_object__gen_loader(struct bpf_object *obj, struct gen_loader_opts *opts);\n```\n\n----------------------------------------\n\nTITLE: Function Definition for bpf_prog_linfo__lfind_addr_func\nDESCRIPTION: C function declaration for finding a line info record based on instruction offset and function index. Takes prog_linfo object, address, function index and skip count as parameters. Returns a pointer to the matching line info record or NULL if not found.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_prog_linfo__lfind_addr_func.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nconst struct bpf_line_info * bpf_prog_linfo__lfind_addr_func(const struct bpf_prog_linfo *prog_linfo, __u64 addr, __u32 func_idx, __u32 nr_skip);\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_skb_set_tunnel_key eBPF Helper Function in C\nDESCRIPTION: This code snippet defines the 'bpf_skb_set_tunnel_key' eBPF helper function, which is used to populate tunnel metadata for a packet associated with an sk_buff. It specifies the function signature, parameters, and return type.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_skb_set_tunnel_key.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstatic long (* const bpf_skb_set_tunnel_key)(struct __sk_buff *skb, struct bpf_tunnel_key *key, __u32 size, __u64 flags) = (void *) 21;\n```\n\n----------------------------------------\n\nTITLE: Function Definition for bpf_program__expected_attach_type in C\nDESCRIPTION: The function signature for bpf_program__expected_attach_type which takes a BPF program structure pointer and returns the expected attach type as an enum bpf_attach_type value.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_program__expected_attach_type.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nenum bpf_attach_type bpf_program__expected_attach_type(const struct bpf_program *prog);\n```\n\n----------------------------------------\n\nTITLE: Implementing a Linked List Node Structure in C\nDESCRIPTION: Example structure for a linked list node that embeds the bpf_list_node known type along with user data.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/scx/__contains.md#2025-04-22_snippet_1\n\nLANGUAGE: c\nCODE:\n```\nstruct my_linked_list_node {\n    struct bpf_list_node list_node;\n    __u64 data;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining hid_bpf_hw_request KFunc in C\nDESCRIPTION: Function signature for the hid_bpf_hw_request kfunc, used to communicate with a HID device. It takes a HID-BPF context, a buffer, buffer size, report type, and request type as parameters.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/hid_bpf_hw_request.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nint hid_bpf_hw_request(struct hid_bpf_ctx *ctx, __u8 *buf, size_t buf__sz, hid_report_type rtype, hid_class_request reqtype)\n```\n\n----------------------------------------\n\nTITLE: Definition of btf_endianness enum in C\nDESCRIPTION: Enumeration defining the possible endianness values for BTF objects. It defines two constants: BTF_LITTLE_ENDIAN (0) for little-endian and BTF_BIG_ENDIAN (1) for big-endian representations.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/btf__endianness.md#2025-04-22_snippet_1\n\nLANGUAGE: c\nCODE:\n```\nenum btf_endianness {\n\tBTF_LITTLE_ENDIAN = 0,\n\tBTF_BIG_ENDIAN = 1,\n};\n```\n\n----------------------------------------\n\nTITLE: Defining the bpf_link__fd Function Signature in C\nDESCRIPTION: This C code snippet defines the function signature for `bpf_link__fd` from the libbpf library. It takes a constant pointer to a `bpf_link` structure as input (`link`) and is intended to return the associated file descriptor as an integer. A return value of -1 indicates an error. This function requires the libbpf headers.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_link__fd.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nint bpf_link__fd(const struct bpf_link *link);\n```\n\n----------------------------------------\n\nTITLE: Definition of bpf_session_is_return KFunc in C\nDESCRIPTION: The C function signature for the bpf_session_is_return eBPF kernel function. This function returns a boolean value indicating whether the BPF program is executed from the exit probe of a kprobe multi link in wrapper mode.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/bpf_session_is_return.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nbool bpf_session_is_return()\n```\n\n----------------------------------------\n\nTITLE: Definition of bpf_list_push_front_impl kfunc\nDESCRIPTION: Defines the function signature for the bpf_list_push_front_impl kernel function which adds a new entry to the beginning of a BPF linked list. The meta and off parameters are handled by the verifier.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/bpf_list_push_front_impl.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nint bpf_list_push_front_impl(struct bpf_list_head *head, struct bpf_list_node *node, void *meta__ign, u64 off)\n```\n\n----------------------------------------\n\nTITLE: Defining ring__consume function in C for libbpf\nDESCRIPTION: This snippet shows the C function signature for the ring__consume function in libbpf. It takes a ring buffer object as a parameter and returns the number of records consumed or an error code.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/ring__consume.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nint ring__consume(struct ring *r);\n```\n\n----------------------------------------\n\nTITLE: Function Inline Attribute Example in C\nDESCRIPTION: Demonstrates the use of compiler attributes for controlling function inlining behavior in eBPF programs.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/concepts/functions.md#2025-04-22_snippet_0\n\nLANGUAGE: C\nCODE:\n```\n__attribute__((always_inline))\n__attribute__((noinline))\n```\n\n----------------------------------------\n\nTITLE: Definition of bpf_ct_change_status eBPF Kernel Function in C\nDESCRIPTION: Function signature for the bpf_ct_change_status kernel function that changes the status field of a referenced connection tracking entry. It takes a pointer to an nf_conn object and a new status value as parameters.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/bpf_ct_change_status.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nint bpf_ct_change_status(struct nf_conn *nfct, u32 status)\n```\n\n----------------------------------------\n\nTITLE: Defining struct user_ring_buffer_opts in libbpf for user ring buffer configuration\nDESCRIPTION: This structure defines configuration options for user ring buffer creation. It contains a size field (sz) that tracks the structure size to maintain compatibility across different versions.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/user_ring_buffer__new.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstruct user_ring_buffer_opts {\n\tsize_t sz; /* size of this struct, for forward/backward compatibility */\n};\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_prog_attach Function in C\nDESCRIPTION: Function declaration for bpf_prog_attach, which is a low-level wrapper around the BPF_PROG_ATTACH syscall command. It takes parameters for program file descriptor, attachable object file descriptor, attachment type, and flags.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_prog_attach.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nint bpf_prog_attach(int prog_fd, int attachable_fd, enum bpf_attach_type type, unsigned int flags);\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_throw KFunc in C\nDESCRIPTION: Function signature for the bpf_throw kfunc, which throws a BPF exception with a specified cookie value. The function never returns and terminates program execution immediately.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/bpf_throw.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nvoid bpf_throw(u64 cookie)\n```\n\n----------------------------------------\n\nTITLE: Using xsk_ring_cons__release in libxdp to release processed packets\nDESCRIPTION: This function releases a specified number of packets from the consumer ring back to the kernel. It informs the kernel that these packets have been consumed and their buffers can be reused for new incoming packets.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libxdp/functions/xsk_ring_cons__release.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nvoid xsk_ring_cons__release(struct xsk_ring_cons *cons, __u32 nb);\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_program__pin function in C\nDESCRIPTION: This snippet shows the function definition for bpf_program__pin. It takes a pointer to a bpf_program struct and a const char pointer for the path. The function returns an integer, with 0 indicating success and a negative value indicating an error.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_program__pin.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nint bpf_program__pin(struct bpf_program *prog, const char *path);\n```\n\n----------------------------------------\n\nTITLE: KFunc Definition for bpf_iter_num_next\nDESCRIPTION: Function signature for the bpf_iter_num_next kernel function that returns a pointer to the next integer from the iterator. The returned pointer may be NULL if the iterator is exhausted.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/bpf_iter_num_next.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nint *bpf_iter_num_next(struct bpf_iter_num *it)\n```\n\n----------------------------------------\n\nTITLE: Defining the 'bpf_sysctl_set_new_value' Helper Function Pointer (C)\nDESCRIPTION: This C code defines a constant function pointer `bpf_sysctl_set_new_value` for the corresponding eBPF helper function. It takes a `bpf_sysctl` context pointer (`ctx`), a character buffer (`buf`) containing the new value string, and the buffer length (`buf_len`). The function pointer is assigned the kernel-internal helper ID 104. It's used within eBPF programs of type `BPF_PROG_TYPE_CGROUP_SYSCTL` to intercept and modify sysctl writes from user space. It returns 0 on success, -E2BIG if `buf_len` exceeds the maximum allowed size, or -EINVAL if the operation is attempted during a sysctl read.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_sysctl_set_new_value.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n`#!c static long (* const bpf_sysctl_set_new_value)(struct bpf_sysctl *ctx, const char *buf, unsigned long buf_len) = (void *) 104;`\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_program__attach_kprobe Function in C\nDESCRIPTION: This snippet defines the bpf_program__attach_kprobe function, which attaches a BPF_PROG_TYPE_KPROBE program. It takes parameters for the BPF program, whether it's a return probe, and the name of the kernel function to attach to.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_program__attach_kprobe.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstruct bpf_link * bpf_program__attach_kprobe(const struct bpf_program *prog, bool retprobe, const char *func_name);\n```\n\n----------------------------------------\n\nTITLE: Defining the bpf_sock_destroy KFunc in C\nDESCRIPTION: The C function signature for the bpf_sock_destroy kernel function. It takes a pointer to a sock_common structure and returns an integer status code.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/kfuncs/bpf_sock_destroy.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nint bpf_sock_destroy(struct sock_common *sock)\n```\n\n----------------------------------------\n\nTITLE: Creating UMEM Area with File Descriptor in C using libxdp\nDESCRIPTION: This function creates an umem area using a file descriptor. It takes pointers to the umem structure, file descriptor, memory area, size, fill and completion rings, and configuration. It returns 0 on success or negative error codes for various failure scenarios.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libxdp/functions/xsk_umem__create_with_fd.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nint xsk_umem__create_with_fd(struct xsk_umem **umem,\n\t\t\t     int fd, void *umem_area, __u64 size,\n\t\t\t     struct xsk_ring_prod *fill,\n\t\t\t     struct xsk_ring_cons *comp,\n\t\t\t     const struct xsk_umem_config *config);\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_prog_get_fd_by_id function in C\nDESCRIPTION: Function signature for bpf_prog_get_fd_by_id, which retrieves a file descriptor for a BPF program given its ID. The function returns a positive integer (file descriptor) on success or a negative error code on failure.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_prog_get_fd_by_id.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nint bpf_prog_get_fd_by_id(__u32 id);\n```\n\n----------------------------------------\n\nTITLE: KF_RET_NULL Flag Documentation\nDESCRIPTION: Flag indicating that a KFunc can return NULL, requiring verifier checks before using the return value.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/concepts/kfuncs.md#2025-04-22_snippet_2\n\nLANGUAGE: markdown\nCODE:\n```\nKF_RET_NULL\n```\n\n----------------------------------------\n\nTITLE: Defining struct bpf_linker_file_opts for File Options in Libbpf (C)\nDESCRIPTION: Defines the 'struct bpf_linker_file_opts', providing options for file addition in the Libbpf linker API. The structure currently contains a single member 'sz', indicating the size of the struct for forward and backward compatibility. Proper initialization and correct size assignment are required when using this struct with related API functions. This struct must be used as an argument to 'bpf_linker__add_fd'.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_linker__add_fd.md#2025-04-22_snippet_1\n\nLANGUAGE: c\nCODE:\n```\nstruct bpf_linker_file_opts {\n    /* size of this struct, for forward/backward compatibility */\n    size_t sz;\n};\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_tc_query function in C\nDESCRIPTION: This snippet shows the function signature for the bpf_tc_query function, which takes pointers to bpf_tc_hook and bpf_tc_opts structures as parameters and returns an integer.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_tc_query.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nint bpf_tc_query(const struct bpf_tc_hook *hook, struct bpf_tc_opts *opts);\n```\n\n----------------------------------------\n\nTITLE: Defining bpf_snprintf Helper Function in C\nDESCRIPTION: This code snippet defines the bpf_snprintf helper function for eBPF programs. It outputs a formatted string to a buffer based on a format string and data array.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/helper-function/bpf_snprintf.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstatic long (* const bpf_snprintf)(char *str, __u32 str_size, const char *fmt, __u64 *data, __u32 data_len) = (void *) 165;\n```\n\n----------------------------------------\n\nTITLE: New eBPF Attach Types in Linux 5.13-5.18\nDESCRIPTION: New attach types introduced for eBPF programs, including BPF_SK_SKB_VERDICT, BPF_SK_REUSEPORT_SELECT, BPF_PERF_EVENT, and BPF_TRACE_KPROBE_MULTI.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/timeline/index.md#2025-04-22_snippet_2\n\nLANGUAGE: C\nCODE:\n```\nBPF_SK_SKB_VERDICT\nBPF_SK_REUSEPORT_SELECT\nBPF_SK_REUSEPORT_SELECT_OR_MIGRATE\nBPF_PERF_EVENT\nBPF_TRACE_KPROBE_MULTI\n```\n\n----------------------------------------\n\nTITLE: Defining ring_buffer__ring Function in C\nDESCRIPTION: Function definition for ring_buffer__ring, which returns a ring buffer object from a ring buffer manager. It takes a ring buffer manager and an index as parameters, returning a struct ring pointer or NULL on failure.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/ring_buffer__ring.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstruct ring *ring_buffer__ring(struct ring_buffer *rb, unsigned int idx);\n```\n\n----------------------------------------\n\nTITLE: Defining the __contains Macro in C\nDESCRIPTION: The basic definition of the __contains macro which uses the btf_decl_tag attribute to inform the verifier about graph structure relationships.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/scx/__contains.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n#define __contains(name, node) __attribute__((btf_decl_tag(\"contains:\" #name \":\" #node)))\n```\n\n----------------------------------------\n\nTITLE: Defining the 'bpf_stats_type' Enum in C\nDESCRIPTION: This C code snippet defines the 'bpf_stats_type' enumeration, which specifies the types of eBPF statistics that can be enabled via the 'bpf_enable_stats' function. Currently, it only includes 'BPF_STATS_RUN_TIME' for enabling run time (run_time_ns) and run count (run_cnt) statistics. This enum is used as the parameter for the 'bpf_enable_stats' function.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/bpf_enable_stats.md#2025-04-22_snippet_1\n\nLANGUAGE: c\nCODE:\n```\n```c\nenum bpf_stats_type {\n\t/* enabled run_time_ns and run_cnt */\n\tBPF_STATS_RUN_TIME = 0,\n};\n```\n```\n\n----------------------------------------\n\nTITLE: Defining user_ring_buffer__free function in C\nDESCRIPTION: This snippet shows the function signature for the user_ring_buffer__free function. It takes a pointer to a user_ring_buffer struct as its parameter and frees the associated resources.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/user_ring_buffer__free.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nvoid user_ring_buffer__free(struct user_ring_buffer *rb);\n```\n\n----------------------------------------\n\nTITLE: Defining the bpf_for macro for eBPF programs in C\nDESCRIPTION: This snippet defines the bpf_for macro, which simplifies writing for loops with open coded iterators in eBPF programs. It initializes a numeric iterator, sets up cleanup, and handles iteration and bounds checking.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/ebpf/bpf_for.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n#define bpf_for(i, start, end) for (\\n\\tstruct bpf_iter_num ___it __attribute__((aligned(8), /* enforce, just in case */\\n\\t\\t\\t\\t\\t cleanup(bpf_iter_num_destroy))),\\n\\t/* ___p pointer is necessary to call bpf_iter_num_new() *once* to init ___it */\\n\\t\\t\\t    *___p __attribute__((unused)) = (\\n\\t\\t\\t\\tbpf_iter_num_new(&___it, (start), (end)),\\n\\t/* this is a workaround for Clang bug: it currently doesn't emit BTF */\\n\\t/* for bpf_iter_num_destroy() when used from cleanup() attribute */\\n\\t\\t\\t\\t(void)bpf_iter_num_destroy, (void *)0);\\n\\t({\\n\\t\\t/* iteration step */\\n\\t\\tint *___t = bpf_iter_num_next(&___it);\\n\\t\\t/* termination and bounds check */\\n\\t\\t(___t && ((i) = *___t, (i) >= (start) && (i) < (end)));\\n\\t});\\n)\n```\n\n----------------------------------------\n\nTITLE: Inserting Kfunc Definitions in Markdown\nDESCRIPTION: Illustrates the markers used to insert generated kfunc definitions into markdown files. The tool searches for these markers and places the rendered markdown with function signatures and notes between them.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/meta.md#2025-04-22_snippet_8\n\nLANGUAGE: markdown\nCODE:\n```\n<!-- [KFUNC_DEF] -->\n<!-- [/KFUNC_DEF] -->\n```\n\n----------------------------------------\n\nTITLE: Defining scx_bpf_exit macro in C\nDESCRIPTION: This snippet defines the scx_bpf_exit macro, which wraps the scx_bpf_exit_bstr kfunc. It uses variadic arguments and includes necessary preamble and format checking.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/scx/scx_bpf_exit.md#2025-04-22_snippet_0\n\nLANGUAGE: C\nCODE:\n```\n#define scx_bpf_exit(code, fmt, args...)                            \\\n({                                                                  \\\n\t[scx_bpf_bstr_preamble](scx_bpf_bstr_preamble.md)(fmt, args)                                \\\n\t[scx_bpf_exit_bstr](../../linux/kfuncs/scx_bpf_exit_bstr.md)(code, ___fmt, ___param, sizeof(___param));    \\\n\t___scx_bpf_bstr_format_checker(fmt, ##args);                    \\\n})\n```\n\n----------------------------------------\n\nTITLE: Placeholder for Socket Filter History Details (Markdown Comment)\nDESCRIPTION: This is a Markdown comment serving as a placeholder to add specific details about the commit and kernel version in which eBPF socket filter support was introduced or significantly modified. It marks an area for future historical data insertion.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/program-type/BPF_PROG_TYPE_SOCKET_FILTER.md#2025-04-22_snippet_4\n\nLANGUAGE: markdown\nCODE:\n```\n<!-- TODO: Added in commit X, in kernel version Y -->\n```\n\n----------------------------------------\n\nTITLE: Context Structure Definition for BPF_PROG_TYPE_CGROUP_SYSCTL\nDESCRIPTION: Defines the context structure passed to cGroup sysctl programs. Contains fields for operation type (read/write) and file position.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/program-type/BPF_PROG_TYPE_CGROUP_SYSCTL.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstruct bpf_sysctl {\n    __u32 write;\n    __u32 file_pos;\n};\n```\n\n----------------------------------------\n\nTITLE: Using xdp_multiprog__is_legacy Function in C\nDESCRIPTION: This function determines if an XDP dispatcher program is legacy, unrecognized, or not a dispatcher program. It returns true if the dispatcher is legacy, unrecognized, or another program that is not the dispatcher is loaded, and false if the dispatcher is properly identified.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libxdp/functions/xdp_multiprog__is_legacy.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nbool xdp_multiprog__is_legacy(const struct xdp_multiprog *mp);\n```\n\n----------------------------------------\n\nTITLE: Adjusting Dynamic Pointer Size and Offset\nDESCRIPTION: Shows how to adjust a dynamic pointer by advancing its offset and trimming its size. This demonstrates the ability to work with subranges of data within a dynamic pointer.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/concepts/dynptrs.md#2025-04-22_snippet_5\n\nLANGUAGE: c\nCODE:\n```\nSEC(\"tp/syscalls/sys_enter_nanosleep\")\nint test_adjust(void *ctx)\n{\n\tstruct bpf_dynptr ptr;\n\t__u32 bytes = 64;\n\t__u32 off = 10;\n\t__u32 trim = 15;\n\n\tif (bpf_get_current_pid_tgid() >> 32 != pid)\n\t\treturn 0;\n\n\terr = bpf_ringbuf_reserve_dynptr(&ringbuf, bytes, 0, &ptr);\n\tif (err) {\n\t\terr = 1;\n\t\tgoto done;\n\t}\n\n\tif (bpf_dynptr_size(&ptr) != bytes) {\n\t\terr = 2;\n\t\tgoto done;\n\t}\n\n\t/* Advance the dynptr by off */\n\terr = bpf_dynptr_adjust(&ptr, off, bpf_dynptr_size(&ptr));\n\tif (err) {\n\t\terr = 3;\n\t\tgoto done;\n\t}\n\n\tif (bpf_dynptr_size(&ptr) != bytes - off) {\n\t\terr = 4;\n\t\tgoto done;\n\t}\n\n\t/* Trim the dynptr */\n\terr = bpf_dynptr_adjust(&ptr, off, 15);\n\tif (err) {\n\t\terr = 5;\n\t\tgoto done;\n\t}\n\n\t/* Check that the size was adjusted correctly */\n\tif (bpf_dynptr_size(&ptr) != trim - off) {\n\t\terr = 6;\n\t\tgoto done;\n\t}\n\n\tdone:\n\tbpf_ringbuf_discard_dynptr(&ptr, 0);\n\treturn 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Checking VLAN Offload Status\nDESCRIPTION: Command to check VLAN offload status for a network device using ethtool.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/linux/program-type/BPF_PROG_TYPE_XDP.md#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nethtool -k <dev_name> | grep vlan-offload\n```\n\n----------------------------------------\n\nTITLE: Defining libbpf_find_vmlinux_btf_id Function in C\nDESCRIPTION: Function definition for finding the BTF ID of a kernel symbol. Takes a kernel symbol name and attach type as parameters and returns the BTF ID or a negative error code.\nSOURCE: https://github.com/isovalent/ebpf-docs/blob/master/docs/ebpf-library/libbpf/userspace/libbpf_find_vmlinux_btf_id.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nint libbpf_find_vmlinux_btf_id(const char *name, enum bpf_attach_type attach_type);\n```"
  }
]