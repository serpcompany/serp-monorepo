[
  {
    "owner": "mergesort",
    "repo": "boutique",
    "content": "TITLE: Creating and Using a Boutique Store in Swift\nDESCRIPTION: Demonstrates how to create a Store object and use its core methods (insert, remove, removeAll) to manage persisted data. The Store handles data persistence automatically and ensures uniqueness of items based on an identifier.\nSOURCE: https://github.com/mergesort/Boutique/blob/main/README.md#2025-04-11_snippet_0\n\nLANGUAGE: Swift\nCODE:\n```\n// Create a Store ¹\nlet store = Store<Animal>(\n    storage: SQLiteStorageEngine.default(appendingPath: \"Animals\"),\n    cacheIdentifier: \\.id\n)\n\n// Insert an item into the Store ²\nlet redPanda = Animal(id: \"red_panda\")\ntry await store.insert(redPanda)\n\n// Remove an animal from the Store\ntry await store.remove(redPanda)\n\n// Insert two more animals to the Store\nlet dog = Animal(id: \"dog\")\nlet cat = Animal(id: \"cat\")\ntry await store.insert([dog, cat])\n\n// You can read items directly\nprint(store.items) // Prints [dog, cat]\n\n// You also don't have to worry about maintaining uniqueness, the Store handles uniqueness for you\nlet secondDog = Animal(id: \"dog\")\ntry await store.insert(secondDog)\nprint(store.items) // Prints [dog, cat]\n\n// Clear your store by removing all the items at once.\nstore.removeAll()\n\nprint(store.items) // Prints []\n\n// You can even chain commands together\ntry await store\n    .insert(dog)\n    .insert(cat)\n    .run()\n\nprint(store.items) // Prints [dog, cat]\n\n// This is a good way to clear stale cached data\ntry await store\n    .removeAll()\n    .insert(redPanda)\n    .run()\n\nprint(store.items) // Prints [redPanda]\n```\n\n----------------------------------------\n\nTITLE: Creating and Using a Boutique Store in Swift\nDESCRIPTION: This snippet demonstrates how to create a Store, insert and remove items, read directly from the store, and chain commands. The Store handles uniqueness automatically and provides real-time updates through @Published properties.\nSOURCE: https://github.com/mergesort/Boutique/blob/main/llms.txt#2025-04-11_snippet_0\n\nLANGUAGE: swift\nCODE:\n```\n// Create a Store ¹\nlet store = Store<Animal>(\n    storage: SQLiteStorageEngine.default(appendingPath: \"Animals\"),\n    cacheIdentifier: \\.id\n)\n\n// Insert an item into the Store ²\nlet redPanda = Animal(id: \"red_panda\")\ntry await store.insert(redPanda)\n\n// Remove an animal from the Store\ntry await store.remove(redPanda)\n\n// Insert two more animals to the Store\nlet dog = Animal(id: \"dog\")\nlet cat = Animal(id: \"cat\")\ntry await store.insert([dog, cat])\n\n// You can read items directly\nprint(store.items) // Prints [dog, cat]\n\n// You also don't have to worry about maintaining uniqueness, the Store handles uniqueness for you\nlet secondDog = Animal(id: \"dog\")\ntry await store.insert(secondDog)\nprint(store.items) // Prints [dog, cat]\n\n// Clear your store by removing all the items at once.\nstore.removeAll()\n\nprint(store.items) // Prints []\n\n// You can even chain commands together\ntry await store\n    .insert(dog)\n    .insert(cat)\n    .run()\n\nprint(store.items) // Prints [dog, cat]\n\n// This is a good way to clear stale cached data\ntry await store\n    .removeAll()\n    .insert(redPanda)\n    .run()\n\nprint(store.items) // Prints [redPanda]\n```\n\n----------------------------------------\n\nTITLE: Initializing Store in Swift for Boutique Library\nDESCRIPTION: Demonstrates the usage of Store in Boutique for persisting data automatically and exposing it as a Swift array. This snippet shows how to use the Store concept, which is central to Boutique's functionality.\nSOURCE: https://github.com/mergesort/Boutique/blob/main/llms.txt#2025-04-11_snippet_1\n\nLANGUAGE: swift\nCODE:\n```\nStore\n```\n\n----------------------------------------\n\nTITLE: Implementing Note Storage and Management with @Stored in Swift\nDESCRIPTION: Demonstrates how to use the @Stored property wrapper to cache notes in memory and on disk. Shows initialization of a Store, fetching notes from an API, and performing CRUD operations on the stored notes.\nSOURCE: https://github.com/mergesort/Boutique/blob/main/README.md#2025-04-11_snippet_3\n\nLANGUAGE: swift\nCODE:\n```\nextension Store where Item == Note {\n    // Initialize a Store to save our notes into\n    static let notesStore = Store<Note>(\n        storage: SQLiteStorageEngine.default(appendingPath: \"Notes\")\n    )\n\n}\n\n@Observable\nfinal class NotesController {\n    /// Creates an @Stored property to handle an in-memory and on-disk cache of notes. ³\n    @Stored(in: .notesStore) var notes\n\n    /// Fetches `Notes` from the API, providing the user with a red panda note if the request succeeds.\n    func fetchNotes() async throws -> Note {\n        // Hit the API that provides you a random image's metadata\n        let noteURL = URL(string: \"https://notes.redpanda.club/random/json\")!\n        let randomNoteRequest = URLRequest(url: noteURL)\n        let (noteResponse, _) = try await URLSession.shared.data(for: randomNoteRequest)\n\n        return Note(createdAt: .now, url: noteResponse.url, text: noteResponse.text)\n    }\n\n    /// Saves an note to the `Store` in memory and on disk.\n    func saveNote(note: Note) async throws {\n        try await self.$notes.insert(note)\n    }\n\n    /// Removes one note from the `Store` in memory and on disk.\n    func removeNote(note: Note) async throws {\n        try await self.$notes.remove(note)\n    }\n\n    /// Removes all of the notes from the `Store` in memory and on disk.\n    func clearAllNotes() async throws {\n        try await self.$notes.removeAll()\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Data Controller with @Stored Property Wrapper in Swift\nDESCRIPTION: Example of a NotesController class using @Stored property wrapper to manage an array of Notes with CRUD operations and API synchronization.\nSOURCE: https://github.com/mergesort/Boutique/blob/main/Sources/Boutique/Documentation.docc/Articles/The @Stored Family Of Property Wrappers.md#2025-04-11_snippet_0\n\nLANGUAGE: swift\nCODE:\n```\n@Observable\nfinal class NotesController {\n    @ObservationIgnored\n    @Stored var notes: [Note]\n\n    init(store: Store<Note>) {\n        self._notes = Stored(in: store)\n    }\n\n    func fetchNotesFromAPI() async throws -> [Note] {\n        // This would be an API call we make to our server\n        try await self.fetchAllNotesFromServer()\n \n        // Insert all of the notes we fetched into the local Store once the request succeeds, to keep the state in sync\n        try await self.$notes.insert(notes)\n    }\n\n    func addNote(note: Note) async throws {\n        // This would be an API call we make to our server\n        try await self.insertNoteOnServer(note)\n \n        // Insert our note into the local Store once the request succeeds, to keep the state in sync\n        try await self.$notes.insert(note)\n    }\n\n    func removeNote(note: Note) async throws {\n        // This would be an API call we make to our server\n        try await self.removeRemoteNoteFromServer(note)\n\n        // Remove our note from the local Store once the request succeeds, to keep the state in sync\n        try await self.$notes.remove(note)\n    }\n\n    func clearAllNotes() async throws {\n        // This would be an API call we make to our server\n        try await self.removeAllNotesOnServer()\n\n        // Remove all notes from the local Store once the request succeeds, to keep the state in sync\n        try await self.$notes.removeAll()\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Integrating Boutique Store with SwiftUI for Reactive Updates\nDESCRIPTION: This snippet shows how to use Boutique's @Published property with SwiftUI for reactive updates. It demonstrates using sink for subscribing to changes and onReceive for updating UI when the store changes.\nSOURCE: https://github.com/mergesort/Boutique/blob/main/llms.txt#2025-04-11_snippet_2\n\nLANGUAGE: swift\nCODE:\n```\n// Since items is a @Published property\n// you can subscribe to any changes in realtime.\nstore.$items.sink({ items in\n    print(\"Items was updated\", items)\n})\n\n// Works great with SwiftUI out the box for more complex pipelines.\n.onReceive(store.$items, perform: {\n    self.allItems = $0.filter({ $0.id > 100 })\n})\n```\n\n----------------------------------------\n\nTITLE: Implementing @Stored Property Wrapper for Cache Management in Swift\nDESCRIPTION: This snippet shows how to use the @Stored property wrapper to create an in-memory and on-disk cache with minimal code. It includes creating a static store extension and implementing methods to fetch, save, and remove images.\nSOURCE: https://github.com/mergesort/Boutique/blob/main/llms.txt#2025-04-11_snippet_3\n\nLANGUAGE: swift\nCODE:\n```\nextension Store where Item == RemoteImage {\n    // Initialize a Store to save our images into\n    static let imagesStore = Store<RemoteImage>(\n        storage: SQLiteStorageEngine.default(appendingPath: \"Images\")\n    )\n\n}\n\nfinal class ImagesController: ObservableObject {\n    /// Creates a @Stored property to handle an in-memory and on-disk cache of images. ⁴\n    @Stored(in: .imagesStore) var images\n\n    /// Fetches `RemoteImage` from the API, providing the user with a red panda if the request succeeds.\n    func fetchImage() async throws -> RemoteImage {\n        // Hit the API that provides you a random image's metadata\n        let imageURL = URL(string: \"https://image.redpanda.club/random/json\")!\n        let randomImageRequest = URLRequest(url: imageURL)\n        let (imageResponse, _) = try await URLSession.shared.data(for: randomImageRequest)\n\n        return RemoteImage(createdAt: .now, url: imageResponse.url, width: imageResponse.width, height: imageResponse.height, imageData: imageResponse.imageData)\n    }\n\n    /// Saves an image to the `Store` in memory and on disk.\n    func saveImage(image: RemoteImage) async throws {\n        try await self.$images.insert(image)\n    }\n\n    /// Removes one image from the `Store` in memory and on disk.\n    func removeImage(image: RemoteImage) async throws {\n        try await self.$images.remove(image)\n    }\n\n    /// Removes all of the images from the `Store` in memory and on disk.\n    func clearAllImages() async throws {\n        try await self.$images.removeAll()\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Using @StoredValue for Persistent Storage in Swift\nDESCRIPTION: Demonstrates the usage of @StoredValue property wrapper for storing individual values in UserDefaults. Shows examples of storing various types including booleans, dates, enums, and complex objects.\nSOURCE: https://github.com/mergesort/Boutique/blob/main/README.md#2025-04-11_snippet_5\n\nLANGUAGE: swift\nCODE:\n```\n// Setup a `@StoredValue has the same API.\n@StoredValue(key: \"hasHapticsEnabled\")\nvar hasHapticsEnabled = false\n\n// You can also store nil values\n@StoredValue(key: \"lastOpenedDate\")\nvar lastOpenedDate: Date? = nil\n\n// Enums work as well, as long as it conforms to `Codable` and `Equatable`.\n@StoredValue(key: \"currentTheme\")\nvar currentlySelectedTheme = .light\n\n// Complex objects work as well\nstruct UserPreferences: Codable, Equatable {\n    var hasHapticsEnabled: Bool\n    var prefersDarkMode: Bool\n    var prefersWideScreen: Bool\n    var spatialAudioEnabled: Bool\n}\n\n@StoredValue(key: \"userPreferences\")\nvar preferences = UserPreferences()\n\n// Set the lastOpenedDate to now\n$lastOpenedDate.set(.now)\n\n// currentlySelected is now .dark\n$currentlySelectedTheme.set(.dark)\n\n// StoredValues that are backed by a boolean also have a toggle() function\n$hasHapticsEnabled.toggle()\n```\n\n----------------------------------------\n\nTITLE: Using StoredValue and SecurelyStoredValue Property Wrappers in Swift\nDESCRIPTION: Demonstrates how to use @StoredValue to persist various types of data in UserDefaults with a publisher for change notifications. Shows storing booleans, optional values, enums, and complex objects, along with methods to modify the stored values.\nSOURCE: https://github.com/mergesort/Boutique/blob/main/llms.txt#2025-04-11_snippet_4\n\nLANGUAGE: swift\nCODE:\n```\n// Setup a `@StoredValue has the same API.\n@StoredValue(key: \"hasHapticsEnabled\")\nvar hasHapticsEnabled = false\n\n// You can also store nil values\n@StoredValue(key: \"lastOpenedDate\")\nvar lastOpenedDate: Date? = nil\n\n// Enums work as well, as long as it conforms to `Codable` and `Equatable`.\n@StoredValue(key: \"currentTheme\")\nvar currentlySelectedTheme = .light\n\n// Complex objects work as well\nstruct UserPreferences: Codable, Equatable {\n    var hasHapticsEnabled: Bool\n    var prefersDarkMode: Bool\n    var prefersWideScreen: Bool\n    var spatialAudioEnabled: Bool\n}\n\n@StoredValue(key: \"userPreferences\")\nvar preferences = UserPreferences()\n\n// Set the lastOpenedDate to now\n$lastOpenedDate.set(.now)\n\n// currentlySelected is now .dark\n$currentlySelectedTheme.set(.dark)\n\n// StoredValues that are backed by a boolean also have a toggle() function\n$hasHapticsEnabled.toggle()\n```\n\n----------------------------------------\n\nTITLE: Implementing Notes Controller with @Stored Property Wrapper in Swift\nDESCRIPTION: Example implementation of a NotesController class using @Stored property wrapper to manage a collection of notes with persistence and API synchronization.\nSOURCE: https://github.com/mergesort/Boutique/blob/main/llms.txt#2025-04-11_snippet_5\n\nLANGUAGE: swift\nCODE:\n```\n@Observable\nfinal class NotesController {\n    @ObservationIgnored\n    @Stored var notes: [Note]\n\n    init(store: Store<Note>) {\n        self._notes = Stored(in: store)\n    }\n\n    func fetchNotesFromAPI() async throws -> [Note] {\n        // This would be an API call we make to our server\n        try await self.fetchAllNotesFromServer()\n\n        // Insert all of the notes we fetched into the local Store once the request succeeds, to keep the state in sync\n        try await self.$notes.insert(notes)\n    }\n\n    func addNote(note: Note) async throws {\n        // This would be an API call we make to our server\n        try await self.insertNoteOnServer(note)\n\n        // Insert our note into the local Store once the request succeeds, to keep the state in sync\n        try await self.$notes.insert(note)\n    }\n\n    func removeNote(note: Note) async throws {\n        // This would be an API call we make to our server\n        try await self.removeRemoteNoteFromServer(note)\n\n        // Remove our note from the local Store once the request succeeds, to keep the state in sync\n        try await self.$notes.remove(note)\n    }\n\n    func clearAllNotes() async throws {\n        // This would be an API call we make to our server\n        try await self.removeAllNotesOnServer()\n\n        // Remove all notes from the local Store once the request succeeds, to keep the state in sync\n        try await self.$notes.removeAll()\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing @StoredValue in an Observable Class\nDESCRIPTION: Example of setting up @StoredValue property wrappers in an @Observable class to persist user preferences. This requires the @ObservationIgnored attribute to properly work with the observation system.\nSOURCE: https://github.com/mergesort/Boutique/blob/main/Sources/Boutique/Documentation.docc/Articles/The @Stored Family Of Property Wrappers.md#2025-04-11_snippet_4\n\nLANGUAGE: swift\nCODE:\n```\n@Observable\nfinal class Preferences {\n    @ObservationIgnored\n    @StoredValue(key: \"hasHapticsEnabled\")\n    var hasHapticsEnabled = false\n    \n    @ObservationIgnored\n    @StoredValue(key: \"lastOpenedDate\")\n    var lastOpenedDate: Date? = nil\n    \n    @ObservationIgnored\n    @StoredValue(key: \"currentTheme\")\n    var currentlySelectedTheme = .light\n}\n```\n\n----------------------------------------\n\nTITLE: Observing Store Changes with SwiftUI's onChange Modifier\nDESCRIPTION: Shows how to subscribe to changes in a Boutique Store using SwiftUI's onChange modifier. This enables reactive UI updates when store data changes.\nSOURCE: https://github.com/mergesort/Boutique/blob/main/README.md#2025-04-11_snippet_1\n\nLANGUAGE: Swift\nCODE:\n```\n// Since @Store, @StoredValue, and @SecurelyStoredValue are `@Observable`, you can subscribe\n// to changes in realtime using any of Swift's built-in observability mechanisms.\n.onChange(of: store.items) {\n    self.items = self.items.sorted(by: { $0.createdAt > $1.createdAt})\n})\n```\n\n----------------------------------------\n\nTITLE: Implementing SwiftUI View with Store Observation\nDESCRIPTION: Example of a SwiftUI view that observes changes to a Store using onChange modifier and handles user interactions. This pattern helps keep the UI in sync with the data store.\nSOURCE: https://github.com/mergesort/Boutique/blob/main/llms.txt#2025-04-11_snippet_17\n\nLANGUAGE: swift\nCODE:\n```\nstruct NotesListView: View {\n    @State var notesController: NotesController\n    @State private var notes: [Note] = []\n\n    var body: some View {\n        VStack {\n            ForEach(self.notes) { note in\n                Text(note.text)\n                    .onTapGesture {\n                        Task {\n                            try await notesController.removeNote(note)\n                        }\n                    }\n            }\n        }\n        .onChange(of: notesController.notes, initial: true) { _, newValue in\n            // We can even create complex pipelines, for example filtering all notes smaller than a tweet\n            self.notes = newValue.filter { $0.length < 280 }\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Observing Store Changes with SwiftUI's onChange Modifier in Boutique\nDESCRIPTION: Demonstrates how to observe changes to a Store's items using SwiftUI's .onChange modifier. The example shows a NotesListView that displays filtered notes and updates the view whenever the notes collection changes. The 'initial: true' parameter ensures the handler is called when the view first appears.\nSOURCE: https://github.com/mergesort/Boutique/blob/main/Sources/Boutique/Documentation.docc/Articles/Using Stores.md#2025-04-11_snippet_9\n\nLANGUAGE: swift\nCODE:\n```\nstruct NotesListView: View {\n    @State var notesController: NotesController\n    @State private var notes: [Note] = []\n\n    var body: some View {\n        VStack {\n            ForEach(self.notes) { note in\n                Text(note.text)\n                    .onTapGesture {\n                        Task {\n                            try await notesController.removeNote(note)\n                        }\n                    }\n            }\n        }\n        .onChange(of: notesController.notes, initial: true) { _, newValue in\n            // We can even create complex pipelines, for example filtering all notes smaller than a tweet\n            self.notes = newValue.filter { $0.length < 280 }\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Observing Store Changes in SwiftUI with onChange Modifier\nDESCRIPTION: Shows how to observe changes to a Store's items using SwiftUI's .onChange modifier. This example demonstrates filtering the results to only include notes shorter than 280 characters.\nSOURCE: https://github.com/mergesort/Boutique/blob/main/llms.txt#2025-04-11_snippet_11\n\nLANGUAGE: swift\nCODE:\n```\nstruct NotesListView: View {\n    @State var notesController: NotesController\n    @State private var notes: [Note] = []\n\n    var body: some View {\n        VStack {\n            ForEach(self.notes) { note in\n                Text(note.text)\n                    .onTapGesture {\n                        Task {\n                            try await notesController.removeNote(note)\n                        }\n                    }\n            }\n        }\n        .onChange(of: notesController.notes, initial: true) { _, newValue in\n            // We can even create complex pipelines, for example filtering all notes smaller than a tweet\n            self.notes = newValue.filter { $0.length < 280 }\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Chaining Store Operations in Swift\nDESCRIPTION: Demonstrates how to chain multiple Store operations using the run() function. This approach allows for executing multiple operations in a single transaction.\nSOURCE: https://github.com/mergesort/Boutique/blob/main/llms.txt#2025-04-11_snippet_16\n\nLANGUAGE: swift\nCODE:\n```\ntry await store\n    .removeAll()\n    .insert(coat)\n    .run()\n```\n\n----------------------------------------\n\nTITLE: Using Boutique's Granular Events Tracking API\nDESCRIPTION: Demonstrates how to monitor specific events in a Boutique Store using the Granular Events Tracking API. This allows for detailed tracking of store operations like initialization, loading, insertion, and removal.\nSOURCE: https://github.com/mergesort/Boutique/blob/main/README.md#2025-04-11_snippet_2\n\nLANGUAGE: Swift\nCODE:\n```\n// You can also use Boutique's Granular Events Tracking API to be notified of individual changes.\nfunc monitorNotesStoreEvents() async {\n    for await event in self.notesController.$notes.events {\n        switch event.operation {\n\n        case .initialized:\n            print(\"[Store Event: initial] Our Notes Store has initialized\")\n\n        case .loaded:\n            print(\"[Store Event: loaded] Our Notes Store has loaded with notes\", event.notes.map(\\.text))\n\n        case .insert:\n            print(\"[Store Event: insert] Our Notes Store inserted notes\", event.notes.map(\\.text))\n\n        case .remove:\n            print(\"[Store Event: remove] Our Notes Store removed notes\", event.notes.map(\\.text))\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Using StoredValue Property Wrapper in Swift\nDESCRIPTION: Illustrates the use of the @StoredValue property wrapper in Boutique for persisting individual Swift values. This property wrapper simplifies saving single values using Boutique's storage mechanism.\nSOURCE: https://github.com/mergesort/Boutique/blob/main/llms.txt#2025-04-11_snippet_30\n\nLANGUAGE: swift\nCODE:\n```\n@StoredValue\n```\n\n----------------------------------------\n\nTITLE: Monitoring Granular Events in Boutique Store for Swift\nDESCRIPTION: This code snippet demonstrates how to use the Granular Events API in Boutique to monitor detailed events in a Notes Store. It showcases handling different operations like initialization, loading, insertion, and removal of notes.\nSOURCE: https://github.com/mergesort/Boutique/blob/main/llms.txt#2025-04-11_snippet_7\n\nLANGUAGE: swift\nCODE:\n```\nfunc monitorNotesEvents() async {\n    for await event in notesController.$notes.events {\n        switch event.operation {\n        case .initialized:\n            print(\"Notes Store has initialized\")\n        case .loaded:\n            print(\"Notes Store has loaded with notes\", event.items)\n        case .insert:\n            print(\"Notes Store inserted notes\", event.items)\n        case .remove:\n            print(\"Notes Store removed notes\", event.items)\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Monitoring Granular Store Events in Boutique\nDESCRIPTION: Shows how to use the Granular Events API to observe specific operations on a Store. This approach provides detailed information about what type of event occurred (initialization, loading, insertion, removal) and which specific items were affected by the change.\nSOURCE: https://github.com/mergesort/Boutique/blob/main/Sources/Boutique/Documentation.docc/Articles/Using Stores.md#2025-04-11_snippet_10\n\nLANGUAGE: swift\nCODE:\n```\nfunc monitorNotesEvents() async {\n    for await event in notesController.$notes.events {\n        switch event.operation {\n        case .initialized:\n            print(\"Notes Store has initialized\")\n        case .loaded:\n            print(\"Notes Store has loaded with notes\", event.items)\n        case .insert:\n            print(\"Notes Store inserted notes\", event.items)\n        case .remove:\n            print(\"Notes Store removed notes\", event.items)\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Using SecurelyStoredValue Property Wrapper in Swift with Boutique\nDESCRIPTION: Shows the usage of the @SecurelyStoredValue property wrapper for securely persisting individual Swift values with added security measures.\nSOURCE: https://github.com/mergesort/Boutique/blob/main/llms.txt#2025-04-11_snippet_31\n\nLANGUAGE: swift\nCODE:\n```\n@SecurelyStoredValue\n```\n\n----------------------------------------\n\nTITLE: Granular Store Event Monitoring\nDESCRIPTION: Example of monitoring granular Store events using AsyncStream to track different operations like initialization, loading, insertion, and removal.\nSOURCE: https://github.com/mergesort/Boutique/blob/main/Sources/Boutique/Documentation.docc/Articles/The @Stored Family Of Property Wrappers.md#2025-04-11_snippet_3\n\nLANGUAGE: swift\nCODE:\n```\nfunc monitorNotesEvents() async {\n    for await event in notesController.$notes.events {\n        switch event.operation {\n        case .initialized:\n            print(\"Notes Store has initialized\")\n        case .loaded:\n            print(\"Notes Store has loaded with notes\", event.items)\n        case .insert:\n            print(\"Notes Store inserted notes\", event.items)\n        case .remove:\n            print(\"Notes Store removed notes\", event.items)\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing Store with SQLiteStorageEngine\nDESCRIPTION: Creates a Store instance with SQLite persistence using a custom cache identifier. The store is configured with a storage directory and unique identifier path.\nSOURCE: https://github.com/mergesort/Boutique/blob/main/Sources/Boutique/Documentation.docc/Articles/Using Stores.md#2025-04-11_snippet_0\n\nLANGUAGE: swift\nCODE:\n```\nlet store = Store<Item>(\n    storage: SQLiteStorageEngine(directory: .defaultStorageDirectory(appendingPath: \"Items\")),\n    cacheIdentifier: \\.id\n)\n```\n\n----------------------------------------\n\nTITLE: Monitoring Granular Store Events with AsyncStream in Swift\nDESCRIPTION: Example showing how to monitor granular events from a Store using AsyncStream<StoreEvent>. This allows tracking specific operations like initialization, loading, insertion, and removal of items.\nSOURCE: https://github.com/mergesort/Boutique/blob/main/llms.txt#2025-04-11_snippet_18\n\nLANGUAGE: swift\nCODE:\n```\nfunc monitorNotesEvents() async {\n    for await event in notesController.$notes.events {\n        switch event.operation {\n        case .initialized:\n            print(\"Notes Store has initialized\")\n        case .loaded:\n            print(\"Notes Store has loaded with notes\", event.items)\n        case .insert:\n            print(\"Notes Store inserted notes\", event.items)\n        case .remove:\n            print(\"Notes Store removed notes\", event.items)\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Asynchronous Store Initialization\nDESCRIPTION: Example of initializing a Store asynchronously to ensure items are loaded before access.\nSOURCE: https://github.com/mergesort/Boutique/blob/main/Sources/Boutique/Documentation.docc/Articles/Using Stores.md#2025-04-11_snippet_7\n\nLANGUAGE: swift\nCODE:\n```\nlet store: Store<Item>\n\ninit() async throws {\n    store = try await Store(...)\n    // Now the store will have `items` already loaded.\n    let items = await store.items\n}\n```\n\n----------------------------------------\n\nTITLE: Waiting for Store Items to Load in Swift\nDESCRIPTION: Demonstrates how to wait for items to load after synchronous Store initialization. The itemsHaveLoaded() method ensures all items are loaded before they are accessed.\nSOURCE: https://github.com/mergesort/Boutique/blob/main/llms.txt#2025-04-11_snippet_15\n\nLANGUAGE: swift\nCODE:\n```\nlet store: Store<Item> = Store(...)\n\nfunc getItems() async -> [Item] {\n    try await store.itemsHaveLoaded()\n    return await store.items\n}\n```\n\n----------------------------------------\n\nTITLE: Synchronous Store Initialization with Async Loading\nDESCRIPTION: Shows how to initialize a Store synchronously while waiting for items to load before access.\nSOURCE: https://github.com/mergesort/Boutique/blob/main/Sources/Boutique/Documentation.docc/Articles/Using Stores.md#2025-04-11_snippet_8\n\nLANGUAGE: swift\nCODE:\n```\nlet store: Store<Item> = Store(...)\n\nfunc getItems() async -> [Item] {\n    try await store.itemsHaveLoaded() \n    return await store.items\n}\n```\n\n----------------------------------------\n\nTITLE: Inserting an Item into a Store in Swift\nDESCRIPTION: Shows how to insert an item into a Store using the insert method. This asynchronous operation adds a new item to the persistent storage.\nSOURCE: https://github.com/mergesort/Boutique/blob/main/llms.txt#2025-04-11_snippet_23\n\nLANGUAGE: swift\nCODE:\n```\nlet coat = Item(name: \"coat\")\ntry await store.insert(coat)\n```\n\n----------------------------------------\n\nTITLE: Observing @StoredValue Changes with AsyncStream\nDESCRIPTION: Shows how to monitor changes to a @StoredValue using the values property, which returns an AsyncStream. This allows for reactive programming with stored values using Swift's structured concurrency.\nSOURCE: https://github.com/mergesort/Boutique/blob/main/Sources/Boutique/Documentation.docc/Articles/The @Stored Family Of Property Wrappers.md#2025-04-11_snippet_10\n\nLANGUAGE: swift\nCODE:\n```\nfunc monitorThemeChanges() async {\n    for await theme in preferences.$currentlySelectedTheme.values {\n        print(\"Theme changed to\", theme)\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Storing Complex Types with @StoredValue\nDESCRIPTION: Example of storing a custom Codable struct using @StoredValue. This demonstrates how Boutique can persist more complex data structures beyond simple value types.\nSOURCE: https://github.com/mergesort/Boutique/blob/main/Sources/Boutique/Documentation.docc/Articles/The @Stored Family Of Property Wrappers.md#2025-04-11_snippet_6\n\nLANGUAGE: swift\nCODE:\n```\nstruct UserPreferences: Codable, Sendable, Equatable {\n    var hasHapticsEnabled: Bool\n    var prefersDarkMode: Bool\n    var prefersWideScreen: Bool\n    var spatialAudioEnabled: Bool\n}\n\n@Observable\nfinal class PreferencesManager {\n    @ObservationIgnored\n    @StoredValue(key: \"userPreferences\")\n    var preferences = UserPreferences()\n}\n```\n\n----------------------------------------\n\nTITLE: Removing an Item from a Store in Swift\nDESCRIPTION: Demonstrates how to remove a specific item from a Store. This asynchronous operation deletes the item from the persistent storage.\nSOURCE: https://github.com/mergesort/Boutique/blob/main/llms.txt#2025-04-11_snippet_24\n\nLANGUAGE: swift\nCODE:\n```\ntry await store.remove(coat)\n```\n\n----------------------------------------\n\nTITLE: Injecting Store into NotesController with @Stored in Swift\nDESCRIPTION: Shows how to decouple the store from the view model, controller, or manager object by injecting stores into the object using @Stored property wrapper.\nSOURCE: https://github.com/mergesort/Boutique/blob/main/README.md#2025-04-11_snippet_4\n\nLANGUAGE: swift\nCODE:\n```\n@Observable\nfinal class NotesController {\n    @ObservationIgnored\n    @Stored var notes: [Note]\n\n    init(store: Store<Note>) {\n        self._notes = Stored(in: store)\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Chaining Store Operations\nDESCRIPTION: Shows how to chain multiple Store operations using the run() function for atomic execution.\nSOURCE: https://github.com/mergesort/Boutique/blob/main/Sources/Boutique/Documentation.docc/Articles/Using Stores.md#2025-04-11_snippet_6\n\nLANGUAGE: swift\nCODE:\n```\ntry await store\n    .removeAll()\n    .insert(coat)\n    .run()\n```\n\n----------------------------------------\n\nTITLE: Injecting Boutique Store into Controller for Dependency Injection\nDESCRIPTION: This snippet demonstrates how to decouple a store from the controller by injecting it via initialization. This approach enables better testability and dependency management.\nSOURCE: https://github.com/mergesort/Boutique/blob/main/llms.txt#2025-04-11_snippet_8\n\nLANGUAGE: swift\nCODE:\n```\nfinal class ImagesController: ObservableObject {\n    @Stored var images: [RemoteImage]\n\n    init(store: Store<RemoteImage>) {\n        self._images = Stored(in: store)\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Asynchronous Store Initialization in Swift\nDESCRIPTION: Shows how to initialize a Store asynchronously to ensure items are loaded before access. This approach guarantees that the items are available when the store is first accessed.\nSOURCE: https://github.com/mergesort/Boutique/blob/main/llms.txt#2025-04-11_snippet_14\n\nLANGUAGE: swift\nCODE:\n```\nlet store: Store<Item>\n\ninit() async throws {\n    store = try await Store(...)\n    // Now the store will have `items` already loaded.\n    let items = await store.items\n}\n```\n\n----------------------------------------\n\nTITLE: Observing @SecurelyStoredValue Changes\nDESCRIPTION: Shows how to monitor changes to a @SecurelyStoredValue using the values property. This works similar to @StoredValue observation but with securely stored keychain values.\nSOURCE: https://github.com/mergesort/Boutique/blob/main/Sources/Boutique/Documentation.docc/Articles/The @Stored Family Of Property Wrappers.md#2025-04-11_snippet_13\n\nLANGUAGE: swift\nCODE:\n```\nfunc monitorPasswordChanges() async {\n    for await password in securityManager.$storedPassword.values {\n        if let password {\n            print(\"Password was set\")\n        } else {\n            print(\"Password was removed\")\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Observing StoredValue Changes Asynchronously in Swift\nDESCRIPTION: This example shows how to observe changes to a StoredValue using the values property in an asynchronous context. The for-await loop processes each change to the theme as it occurs.\nSOURCE: https://github.com/mergesort/Boutique/blob/main/llms.txt#2025-04-11_snippet_21\n\nLANGUAGE: swift\nCODE:\n```\nfunc monitorThemeChanges() async {\n    for await theme in preferences.$currentlySelectedTheme.values {\n        print(\"Theme changed to\", theme)\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing @SecurelyStoredValue for Keychain Storage\nDESCRIPTION: Example of setting up the @SecurelyStoredValue property wrapper to store sensitive data in the system Keychain. This requires the @ObservationIgnored attribute in @Observable classes.\nSOURCE: https://github.com/mergesort/Boutique/blob/main/Sources/Boutique/Documentation.docc/Articles/The @Stored Family Of Property Wrappers.md#2025-04-11_snippet_11\n\nLANGUAGE: swift\nCODE:\n```\n@Observable\nfinal class SecurityManager {\n    @ObservationIgnored\n    @SecurelyStoredValue<RedPanda>(key: \"redPanda\")\n    private var redPanda\n}\n```\n\n----------------------------------------\n\nTITLE: Observing SecurelyStoredValue Changes Asynchronously in Swift\nDESCRIPTION: This snippet demonstrates how to observe changes to a SecurelyStoredValue using the values property in an asynchronous context. It handles both when a password is set and when it's removed.\nSOURCE: https://github.com/mergesort/Boutique/blob/main/llms.txt#2025-04-11_snippet_22\n\nLANGUAGE: swift\nCODE:\n```\nfunc monitorPasswordChanges() async {\n    for await password in securityManager.$storedPassword.values {\n        if let password {\n            print(\"Password was set\")\n        } else {\n            print(\"Password was removed\")\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing SecurelyStoredValue in Swift\nDESCRIPTION: This snippet demonstrates how to create a SecurelyStoredValue property in an @Observable class for storing sensitive data in the system Keychain. SecurelyStoredValue provides enhanced security for sensitive information.\nSOURCE: https://github.com/mergesort/Boutique/blob/main/llms.txt#2025-04-11_snippet_28\n\nLANGUAGE: swift\nCODE:\n```\n@Observable\nfinal class SecurityManager {\n    @ObservationIgnored\n    @SecurelyStoredValue<RedPanda>(key: \"redPanda\")\n    private var redPanda\n}\n```\n\n----------------------------------------\n\nTITLE: Simplified Store Initialization for Identifiable Items in Swift\nDESCRIPTION: Shows a simplified Store initialization when the model conforms to Identifiable. This allows omitting the cacheIdentifier parameter as it uses the id property from Identifiable.\nSOURCE: https://github.com/mergesort/Boutique/blob/main/llms.txt#2025-04-11_snippet_19\n\nLANGUAGE: swift\nCODE:\n```\nlet store = Store<Item>(\n    storage: SQLiteStorageEngine(directory: .defaultStorageDirectory(appendingPath: \"Items\"))\n)\n```\n\n----------------------------------------\n\nTITLE: Organizing Multiple @StoredValue Properties with Observable Classes\nDESCRIPTION: Demonstrates how to organize large applications by breaking down objects with many @StoredValue properties into smaller, more focused observable classes while maintaining reactivity.\nSOURCE: https://github.com/mergesort/Boutique/blob/main/Sources/Boutique/Documentation.docc/Articles/The @Stored Family Of Property Wrappers.md#2025-04-11_snippet_14\n\nLANGUAGE: swift\nCODE:\n```\n@Observable\nfinal class Preferences {\n    var userExperiencePreferences = UserExperiencePreferences()\n    var redPandaPreferences = RedPandaPreferences()\n}\n\n@MainActor\n@Observable\nfinal class UserExperiencePreferences {\n    @ObservationIgnored\n    @StoredValue(key: \"hasSoundEffectsEnabled\")\n    public var hasSoundEffectsEnabled = false\n\n    @ObservationIgnored\n    @StoredValue(key: \"hasHapticsEnabled\")\n    public var hasHapticsEnabled = true\n}\n\n@MainActor\n@Observable\nfinal class RedPandaPreferences {\n    @ObservationIgnored\n    @StoredValue(key: \"isRedPandaFan\")\n    public var isRedPandaFan = true\n}\n```\n\n----------------------------------------\n\nTITLE: Inserting Items into Store\nDESCRIPTION: Demonstrates how to insert a new item into the Store asynchronously.\nSOURCE: https://github.com/mergesort/Boutique/blob/main/Sources/Boutique/Documentation.docc/Articles/Using Stores.md#2025-04-11_snippet_3\n\nLANGUAGE: swift\nCODE:\n```\nlet coat = Item(name: \"coat\")\ntry await store.insert(coat)\n```\n\n----------------------------------------\n\nTITLE: Initializing Store with SQLiteStorageEngine in Swift\nDESCRIPTION: Demonstrates how to initialize a Store using SQLiteStorageEngine with a custom storage directory and cache identifier.\nSOURCE: https://github.com/mergesort/Boutique/blob/main/llms.txt#2025-04-11_snippet_6\n\nLANGUAGE: swift\nCODE:\n```\nlet store = Store<Item>(\n    storage: SQLiteStorageEngine(directory: .defaultStorageDirectory(appendingPath: \"Items\")),\n    cacheIdentifier: \\.id\n)\n```\n\n----------------------------------------\n\nTITLE: Removing Items from Store\nDESCRIPTION: Shows how to remove a specific item from the Store asynchronously.\nSOURCE: https://github.com/mergesort/Boutique/blob/main/Sources/Boutique/Documentation.docc/Articles/Using Stores.md#2025-04-11_snippet_4\n\nLANGUAGE: swift\nCODE:\n```\ntry await store.remove(coat)\n```\n\n----------------------------------------\n\nTITLE: Removing All Items from a Store in Swift\nDESCRIPTION: Shows how to remove all items from a Store at once. This asynchronous operation clears the entire store's contents.\nSOURCE: https://github.com/mergesort/Boutique/blob/main/llms.txt#2025-04-11_snippet_25\n\nLANGUAGE: swift\nCODE:\n```\ntry await store.removeAll()\n```\n\n----------------------------------------\n\nTITLE: Structuring Complex Preferences with Multiple StoredValues in Swift\nDESCRIPTION: This example shows how to break down large objects with many @StoredValues into smaller, more focused Observable classes. Each class handles a specific aspect of the preferences while maintaining reactivity.\nSOURCE: https://github.com/mergesort/Boutique/blob/main/llms.txt#2025-04-11_snippet_13\n\nLANGUAGE: swift\nCODE:\n```\n@Observable\nfinal class Preferences {\n    var userExperiencePreferences = UserExperiencePreferences()\n    var redPandaPreferences = RedPandaPreferences()\n}\n\n@MainActor\n@Observable\nfinal class UserExperiencePreferences {\n    @ObservationIgnored\n    @StoredValue(key: \"hasSoundEffectsEnabled\")\n    public var hasSoundEffectsEnabled = false\n\n    @ObservationIgnored\n    @StoredValue(key: \"hasHapticsEnabled\")\n    public var hasHapticsEnabled = true\n}\n\n@MainActor\n@Observable\nfinal class RedPandaPreferences {\n    @ObservationIgnored\n    @StoredValue(key: \"isRedPandaFan\")\n    public var isRedPandaFan = true\n}\n```\n\n----------------------------------------\n\nTITLE: Removing All Items from Store\nDESCRIPTION: Demonstrates how to clear all items from the Store asynchronously.\nSOURCE: https://github.com/mergesort/Boutique/blob/main/Sources/Boutique/Documentation.docc/Articles/Using Stores.md#2025-04-11_snippet_5\n\nLANGUAGE: swift\nCODE:\n```\ntry await store.removeAll()\n```\n\n----------------------------------------\n\nTITLE: Resetting @StoredValue to Default Values\nDESCRIPTION: Shows how to reset @StoredValue properties to their default values using the reset() method. This restores the original default value specified when the property was initialized.\nSOURCE: https://github.com/mergesort/Boutique/blob/main/Sources/Boutique/Documentation.docc/Articles/The @Stored Family Of Property Wrappers.md#2025-04-11_snippet_8\n\nLANGUAGE: swift\nCODE:\n```\n$lastOpenedDate.reset() // lastOpenedDate has been reset to it's initial value of nil again\n$currentlySelectedTheme.reset() // currentlySelected has been reset to it's initial value of .light\n```\n\n----------------------------------------\n\nTITLE: Storing Custom User Preferences with StoredValue in Swift\nDESCRIPTION: This snippet demonstrates storing a custom UserPreferences struct using the StoredValue property wrapper in an Observable class. The UserPreferences struct includes user settings for a video player app.\nSOURCE: https://github.com/mergesort/Boutique/blob/main/llms.txt#2025-04-11_snippet_10\n\nLANGUAGE: swift\nCODE:\n```\nstruct UserPreferences: Codable, Sendable, Equatable {\n    var hasHapticsEnabled: Bool\n    var prefersDarkMode: Bool\n    var prefersWideScreen: Bool\n    var spatialAudioEnabled: Bool\n}\n\n@Observable\nfinal class PreferencesManager {\n    @ObservationIgnored\n    @StoredValue(key: \"userPreferences\")\n    var preferences = UserPreferences()\n}\n```\n\n----------------------------------------\n\nTITLE: Toggling Boolean @StoredValue Properties\nDESCRIPTION: Demonstrates the special toggle() method available for Boolean @StoredValue properties. This provides a convenient way to flip Boolean values without manual negation.\nSOURCE: https://github.com/mergesort/Boutique/blob/main/Sources/Boutique/Documentation.docc/Articles/The @Stored Family Of Property Wrappers.md#2025-04-11_snippet_9\n\nLANGUAGE: swift\nCODE:\n```\n$hasHapticsEnabled.toggle()\n\n// Equivalent to but cleaner than\n$hasHapticsEnabled.set(!hasHapticsEnabled)\n```\n\n----------------------------------------\n\nTITLE: Setting and Resetting StoredValue Properties in Swift\nDESCRIPTION: These snippets show how to set new values and reset StoredValue properties using the projectedValue ($ prefix). The reset operation returns the property to its initial value.\nSOURCE: https://github.com/mergesort/Boutique/blob/main/llms.txt#2025-04-11_snippet_26\n\nLANGUAGE: swift\nCODE:\n```\n$lastOpenedDate.set(.now) // Set the lastOpenedDate to now\n$currentlySelectedTheme.set(.dark) // currentlySelected is now .dark\n```\n\nLANGUAGE: swift\nCODE:\n```\n$lastOpenedDate.reset() // lastOpenedDate has been reset to it's initial value of nil again\n$currentlySelectedTheme.reset() // currentlySelected has been reset to it's initial value of .light\n```\n\n----------------------------------------\n\nTITLE: Setting and Removing SecurelyStoredValue in Swift\nDESCRIPTION: These examples show how to set and remove values from a SecurelyStoredValue property. The operations are marked with try since SecurelyStoredValue operations can throw errors if Keychain access fails.\nSOURCE: https://github.com/mergesort/Boutique/blob/main/llms.txt#2025-04-11_snippet_29\n\nLANGUAGE: swift\nCODE:\n```\ntry self.$storedPassword.set(\"p@ssw0rd\") // self.storedPassword is now set to \"p@assw0rd\"\ntry self.$storedPassword.remove() // self.storedPassword is now nil\n```\n\n----------------------------------------\n\nTITLE: Setting Values with @StoredValue\nDESCRIPTION: Demonstrates how to set new values using the projectedValue (accessed with $ prefix) of a @StoredValue property wrapper. The set() method updates the stored value in UserDefaults.\nSOURCE: https://github.com/mergesort/Boutique/blob/main/Sources/Boutique/Documentation.docc/Articles/The @Stored Family Of Property Wrappers.md#2025-04-11_snippet_7\n\nLANGUAGE: swift\nCODE:\n```\n$lastOpenedDate.set(.now) // Set the lastOpenedDate to now\n$currentlySelectedTheme.set(.dark) // currentlySelected is now .dark\n```\n\n----------------------------------------\n\nTITLE: Setting StoredValue in Swift using Boutique\nDESCRIPTION: Demonstrates how to set a value using the StoredValue property wrapper in Boutique. This code snippet shows the syntax for saving a single Swift value using the set method.\nSOURCE: https://github.com/mergesort/Boutique/blob/main/llms.txt#2025-04-11_snippet_32\n\nLANGUAGE: swift\nCODE:\n```\n$storedValue.set(value)\n```\n\n----------------------------------------\n\nTITLE: Setting and Removing @SecurelyStoredValue Data\nDESCRIPTION: Demonstrates how to set and remove securely stored values using the set() and remove() methods. Unlike @StoredValue which uses reset(), @SecurelyStoredValue uses remove() to clear data.\nSOURCE: https://github.com/mergesort/Boutique/blob/main/Sources/Boutique/Documentation.docc/Articles/The @Stored Family Of Property Wrappers.md#2025-04-11_snippet_12\n\nLANGUAGE: swift\nCODE:\n```\ntry self.$storedPassword.set(\"p@ssw0rd\") // self.storedPassword is now set to \"p@assw0rd\" \ntry self.$storedPassword.remove() // self.storedPassword is now nil\n```\n\n----------------------------------------\n\nTITLE: Toggling Boolean StoredValue in Swift\nDESCRIPTION: This snippet demonstrates how to toggle a boolean StoredValue using the .toggle() function. This is a convenient shorthand for inverting a boolean value.\nSOURCE: https://github.com/mergesort/Boutique/blob/main/llms.txt#2025-04-11_snippet_27\n\nLANGUAGE: swift\nCODE:\n```\n$hasHapticsEnabled.toggle()\n\n// Equivalent to but cleaner than\n$hasHapticsEnabled.set(!hasHapticsEnabled)\n```\n\n----------------------------------------\n\nTITLE: Initializing Preferences with @StoredValue in Swift\nDESCRIPTION: This snippet demonstrates how to set up a Preferences class using @StoredValue property wrapper in an @Observable class. It shows how to store boolean, date, and enum values with default values.\nSOURCE: https://github.com/mergesort/Boutique/blob/main/llms.txt#2025-04-11_snippet_9\n\nLANGUAGE: swift\nCODE:\n```\n@Observable\nfinal class Preferences {\n    @ObservationIgnored\n    @StoredValue(key: \"hasHapticsEnabled\")\n    var hasHapticsEnabled = false\n\n    @ObservationIgnored\n    @StoredValue(key: \"lastOpenedDate\")\n    var lastOpenedDate: Date? = nil\n\n    @ObservationIgnored\n    @StoredValue(key: \"currentTheme\")\n    var currentlySelectedTheme = .light\n}\n```\n\n----------------------------------------\n\nTITLE: Creating StoredValue Without Property Wrapper\nDESCRIPTION: Direct initialization of a StoredValue instance without using the property wrapper syntax. This approach is useful in non-@Observable contexts where property wrappers cannot be applied.\nSOURCE: https://github.com/mergesort/Boutique/blob/main/Sources/Boutique/Documentation.docc/Articles/The @Stored Family Of Property Wrappers.md#2025-04-11_snippet_5\n\nLANGUAGE: swift\nCODE:\n```\nlet hasHapticsEnabled = StoredValue(key: \"hasHapticsEnabled\", default: false)\n```\n\n----------------------------------------\n\nTITLE: Creating StoredValue without Property Wrapper in Swift\nDESCRIPTION: This example shows how to create a StoredValue directly without using a property wrapper, which is useful in non-@Observable contexts.\nSOURCE: https://github.com/mergesort/Boutique/blob/main/llms.txt#2025-04-11_snippet_33\n\nLANGUAGE: swift\nCODE:\n```\nlet hasHapticsEnabled = StoredValue(key: \"hasHapticsEnabled\", default: false)\n```\n\n----------------------------------------\n\nTITLE: Initializing Store with Default SQLite Storage\nDESCRIPTION: Concise Store initialization using the default SQLite storage engine configuration with a custom path.\nSOURCE: https://github.com/mergesort/Boutique/blob/main/Sources/Boutique/Documentation.docc/Articles/Using Stores.md#2025-04-11_snippet_2\n\nLANGUAGE: swift\nCODE:\n```\nstatic let store = Store<Item>(\n    storage: SQLiteStorageEngine.default(appendingPath: \"Items\")\n)\n```\n\n----------------------------------------\n\nTITLE: Concise Store Initialization with Default SQLiteStorageEngine in Swift\nDESCRIPTION: Demonstrates the most concise way to initialize a Store using the default SQLiteStorageEngine provided by Bodega. This shorthand approach simplifies the setup process.\nSOURCE: https://github.com/mergesort/Boutique/blob/main/llms.txt#2025-04-11_snippet_20\n\nLANGUAGE: swift\nCODE:\n```\nstatic let store = Store<Item>(\n    storage: SQLiteStorageEngine.default(appendingPath: \"Items\")\n)\n```\n\n----------------------------------------\n\nTITLE: Adding Boutique as a Dependency with Swift Package Manager\nDESCRIPTION: Shows how to integrate the Boutique library into a Swift project using Swift Package Manager by adding it to the dependencies in Package.swift.\nSOURCE: https://github.com/mergesort/Boutique/blob/main/llms.txt#2025-04-11_snippet_34\n\nLANGUAGE: swift\nCODE:\n```\ndependencies: [\n    .package(url: \"https://github.com/mergesort/Boutique.git\", .upToNextMajor(from: \"1.0.0\"))\n]\n```\n\n----------------------------------------\n\nTITLE: Initializing Store with Identifiable Model\nDESCRIPTION: Simplified Store initialization for models that conform to Identifiable protocol, omitting the explicit cache identifier.\nSOURCE: https://github.com/mergesort/Boutique/blob/main/Sources/Boutique/Documentation.docc/Articles/Using Stores.md#2025-04-11_snippet_1\n\nLANGUAGE: swift\nCODE:\n```\nlet store = Store<Item>(\n    storage: SQLiteStorageEngine(directory: .defaultStorageDirectory(appendingPath: \"Items\"))\n)\n```\n\n----------------------------------------\n\nTITLE: SwiftUI View with Store Change Observation\nDESCRIPTION: Implementation of a SwiftUI view that observes changes to a Store using onChange modifier and handles user interactions.\nSOURCE: https://github.com/mergesort/Boutique/blob/main/Sources/Boutique/Documentation.docc/Articles/The @Stored Family Of Property Wrappers.md#2025-04-11_snippet_2\n\nLANGUAGE: swift\nCODE:\n```\nstruct NotesListView: View {\n    @State var notesController: NotesController\n    @State private var notes: [Note] = []\n\n    var body: some View {\n        VStack {\n            ForEach(self.notes) { note in\n                Text(note.text)\n                    .onTapGesture {\n                        Task {\n                            try await notesController.removeNote(note)\n                        }\n                    }\n            }\n        }\n        .onChange(of: notesController.notes, initial: true) { _, newValue in\n            // We can even create complex pipelines, for example filtering all notes smaller than a tweet\n            self.notes = newValue.filter { $0.length < 280 }\n        }\n    }\n```\n\n----------------------------------------\n\nTITLE: Stored Property Wrapper Value vs Projected Value Example\nDESCRIPTION: Demonstrates the difference between wrapped value and projected value when using the @Stored property wrapper.\nSOURCE: https://github.com/mergesort/Boutique/blob/main/Sources/Boutique/Documentation.docc/Articles/The @Stored Family Of Property Wrappers.md#2025-04-11_snippet_1\n\nLANGUAGE: swift\nCODE:\n```\n@Stored var notes: [Note]\nself.notes // The type of the `wrappedValue` is [Note]\nself.$notes // The type of the `projectedValue` is Store<Note>\n```\n\n----------------------------------------\n\nTITLE: Accessing Stored Property Wrapper Values in Swift\nDESCRIPTION: Example showing the difference between wrappedValue and projectedValue when using the @Stored property wrapper. The wrappedValue accesses the stored data, while the projectedValue provides access to the Store object.\nSOURCE: https://github.com/mergesort/Boutique/blob/main/llms.txt#2025-04-11_snippet_12\n\nLANGUAGE: swift\nCODE:\n```\n@Stored var notes: [Note]\nself.notes // The type of the `wrappedValue` is [Note]\nself.$notes // The type of the `projectedValue` is Store<Note>\n```\n\n----------------------------------------\n\nTITLE: Adding Boutique Dependency in Swift Package Manager\nDESCRIPTION: This code snippet shows how to add Boutique as a dependency in a Swift package's Package.swift file. It specifies the GitHub repository URL and version constraint for the package.\nSOURCE: https://github.com/mergesort/Boutique/blob/main/README.md#2025-04-11_snippet_6\n\nLANGUAGE: swift\nCODE:\n```\ndependencies: [\n    .package(url: \"https://github.com/mergesort/Boutique.git\", .upToNextMajor(from: \"1.0.0\"))\n]\n```\n\n----------------------------------------\n\nTITLE: Using Store Property Reference\nDESCRIPTION: Example of how to reference the Store property wrapper in Swift code documentation.\nSOURCE: https://github.com/mergesort/Boutique/blob/main/Sources/Boutique/Documentation.docc/Articles/Boutique.md#2025-04-11_snippet_0\n\nLANGUAGE: Swift\nCODE:\n```\n``Store``\n```\n\n----------------------------------------\n\nTITLE: Using StoredValue Property Wrapper Reference\nDESCRIPTION: Example of how to reference the StoredValue property wrapper in Swift code documentation.\nSOURCE: https://github.com/mergesort/Boutique/blob/main/Sources/Boutique/Documentation.docc/Articles/Boutique.md#2025-04-11_snippet_1\n\nLANGUAGE: Swift\nCODE:\n```\n``StoredValue``\n```\n\n----------------------------------------\n\nTITLE: Using SecurelyStoredValue Property Wrapper Reference\nDESCRIPTION: Example of how to reference the SecurelyStoredValue property wrapper in Swift code documentation.\nSOURCE: https://github.com/mergesort/Boutique/blob/main/Sources/Boutique/Documentation.docc/Articles/Boutique.md#2025-04-11_snippet_2\n\nLANGUAGE: Swift\nCODE:\n```\n``SecurelyStoredValue``\n```"
  }
]