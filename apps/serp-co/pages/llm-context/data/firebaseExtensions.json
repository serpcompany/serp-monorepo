[
  {
    "owner": "firebase",
    "repo": "extensions",
    "content": "TITLE: Generating a Google OAuth2 Refresh Token with Google Auth Library - JavaScript\nDESCRIPTION: This JavaScript snippet demonstrates how to use the official google-auth-library to generate an OAuth2 refresh token for authenticating with Gmail. This is relevant for Node.js environments where npm packages can be installed. Key dependencies: 'google-auth-library'. The sample covers OAuth2 client initialization, URL generation for consent, and token exchange upon user callback. Inputs: OAuth credentials, user authorization code. Outputs: tokens (including refresh_token).\nSOURCE: https://github.com/firebase/extensions/blob/next/firestore-send-email/README.md#_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nimport { OAuth2Client } from \"google-auth-library\";\n\n// Initialize OAuth client\nconst oAuth2Client = new OAuth2Client(CLIENT_ID, CLIENT_SECRET, REDIRECT_URI);\n\n// Generate authorization URL\nconst authorizeUrl = oAuth2Client.generateAuthUrl({\n  access_type: \"offline\",\n  prompt: \"consent\",\n  scope: [\"https://mail.google.com/\"],  // Full Gmail access\n});\n\n// After receiving the code from the callback:\nconst { tokens } = await oAuth2Client.getToken(code);\nconst refreshToken = tokens.refresh_token;\n```\n\n----------------------------------------\n\nTITLE: Generating OAuth2 Refresh Token with google-auth-library (Node.js, JavaScript/ESModules)\nDESCRIPTION: This JavaScript snippet utilizes the google-auth-library package to carry out the OAuth2 flow for Gmail SMTP. It shows importing OAuth2Client, initializing with OAuth credentials, generating an authorization URL (scoped for Gmail), and exchanging an authorization code for tokens. Prerequisite is 'npm install google-auth-library'; key parameters are CLIENT_ID, CLIENT_SECRET, REDIRECT_URI, and received code. The output is a refresh token suitable for further use in Firebase extension SMTP settings.\nSOURCE: https://github.com/firebase/extensions/blob/next/firestore-send-email/PREINSTALL.md#_snippet_3\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { OAuth2Client } from \"google-auth-library\";\n\n// Initialize OAuth client\nconst oAuth2Client = new OAuth2Client(CLIENT_ID, CLIENT_SECRET, REDIRECT_URI);\n\n// Generate authorization URL\nconst authorizeUrl = oAuth2Client.generateAuthUrl({\n  access_type: \"offline\",\n  prompt: \"consent\",\n  scope: [\"https://mail.google.com/\"],  // Full Gmail access\n});\n\n// After receiving the code from the callback:\nconst { tokens } = await oAuth2Client.getToken(code);\nconst refreshToken = tokens.refresh_token;\n```\n\n----------------------------------------\n\nTITLE: Implementing Firestore Sharded Counter in Web Apps (Firebase SDK v9+)\nDESCRIPTION: Provides an example using Firebase SDK v9+ modular syntax. It initializes Firebase and Firestore, gets a document reference, creates a `sharded.Counter` instance for a potentially nested field (`stats.views`), increments the counter, and sets up listeners for both local (`views.onSnapshot`) and eventual consistency (`onSnapshot` on the document). Requires importing necessary Firebase v9 functions and including the `sharded-counter.js` client library.\nSOURCE: https://github.com/firebase/extensions/blob/next/firestore-counter/POSTINSTALL.md#_snippet_2\n\nLANGUAGE: html\nCODE:\n```\n<html>\n  <head> </head>\n  <body>\n    <script src=\"clients/web/dist/sharded-counter.js\"></script>\n\n    <script type=\"module\">\n      import { initializeApp } from \"https://www.gstatic.com/firebasejs/9.6.1/firebase-app.js\";\n\n      // Add Firebase products that you want to use\n      import { getAuth } from \"https://www.gstatic.com/firebasejs/9.6.1/firebase-auth.js\";\n      import {\n        getFirestore,\n        getDoc,\n        doc,\n        onSnapshot,\n      } from \"https://www.gstatic.com/firebasejs/9.6.1/firebase-firestore.js\";\n\n      // Initialize Firebase\n      const firebaseApp = initializeApp({ projectId: \"extensions-testing\" });\n\n      // initializeApp(firebaseConfig);\n      const db = getFirestore(firebaseApp);\n\n\n      const docRef = doc(db, \"pages\", \"hello-world\");\n\n\n      // Initialize the sharded counter.\n      var views = new sharded.Counter(docRef, \"stats.views\");\n\n      // // This will increment a field \"stats.views\" of the \"pages/hello-world\" document by 3.\n      views.incrementBy(4).then($ => console.log(\"returning document >>>>\", $));\n\n      // // Listen to locally consistent values\n      views.onSnapshot(snap => {\n        console.log(\"Locally consistent view of visits: \" + snap.data());\n      });\n\n      //Alternatively if you don't mind counter delays, you can listen to the document directly.\n      onSnapshot(doc(db, \"pages\", \"hello-world\"), snap => {\n        console.log(\n          \"Eventually consistent view of visits: \" + snap.get(\"stats.views\")\n        );\n      });\n    </script>\n  </body>\n</html>\n```\n\n----------------------------------------\n\nTITLE: Using Firestore Sharded Counter in Android Applications (Java)\nDESCRIPTION: Demonstrates initializing Firestore, creating a `DocumentReference`, instantiating the `FirestoreShardedCounter` (using provided sample code `FirestoreShardedCounter.java`), incrementing the counter (`visits`), listening for real-time updates using `onSnapshot`, cleaning up the listener, and fetching the current value once with `get()`. Also shows listening directly to the document for eventually consistent values. Requires the Firebase Firestore Android SDK and the provided sample code.\nSOURCE: https://github.com/firebase/extensions/blob/next/firestore-counter/POSTINSTALL.md#_snippet_3\n\nLANGUAGE: java\nCODE:\n```\nimport com.google.firebase.firestore.DocumentReference;\nimport com.google.firebase.firestore.DocumentSnapshot;\nimport com.google.firebase.firestore.EventListener;\nimport com.google.firebase.firestore.FirebaseFirestore;\nimport com.google.firebase.firestore.FirebaseFirestoreException;\nimport com.google.firebase.firestore.ListenerRegistration;\n\n\n// somewhere in your app code initialize Firestore instance\nFirebaseFirestore db = admin.firestore.getInstance();\n// create reference to the collection and the document you wish to use \nDocumentReference doc = db.collection(\"pages\").document(\"hello-world\");\n// initialize FirestoreShardedCounter with the document and the property which will hold the counter value\nFirestoreShardedCounter visits = new FirestoreShardedCounter(doc, \"visits\");\n\n// to increment counter\nvisits.incrementBy(1);\n\n// listen for updates\nEventListener<Double> snapshotListener = new EventListener<Double>(){\n  @Override\n  public void onEvent(@Nullable Double value, @Nullable FirebaseFirestoreException error) {\n    // 'value' param is total amount of pages visits\n  }\n};\nListenerRegistration registration = visits.onSnapshot(snapshotListener);\n// clean up event listeners once finished\nregistration.remove();\n\n// make one time call to query total amount of visits\ndouble totalVisits = visits.get();\n\n// if you don't mind counter delays, you can listen to the document directly.\ndb.document(\"pages/hello-world\").addSnapshotListener(new EventListener<DocumentSnapshot>() {\n  @Override\n  public void onEvent(@Nullable DocumentSnapshot value, @Nullable FirebaseFirestoreException error) {\n    // total page visits\n    double pageVisits = (double) value.get(\"visits\");\n  }\n});\n```\n\n----------------------------------------\n\nTITLE: Handling Firebase Storage Image Resize Events with Eventarc (TypeScript)\nDESCRIPTION: This TypeScript snippet defines a Firebase Cloud Function that listens for custom events published by the 'storage-resize-images' extension upon successful image resizing. It leverages 'firebase-functions' and 'firebase-functions/v2/eventarc' dependencies to register an event handler, logging details about the successful image resize operation. The function takes an event payload, logs it for monitoring, and allows for additional processing. Input is a custom event of type 'firebase.extensions.storage-resize-images.v1.onSuccess', and the function returns a resolved Promise. Ensure that the project has Eventarc enabled and correct Pub/Sub permissions.\nSOURCE: https://github.com/firebase/extensions/blob/next/storage-resize-images/PREINSTALL.md#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport * as functions from 'firebase-functions';\\nimport { onCustomEventPublished } from 'firebase-functions/v2/eventarc';\\n\\nexport const onImageResized = onCustomEventPublished(\\n    \\\"firebase.extensions.storage-resize-images.v1.onSuccess\\\",\\n    (event) => {\\n        functions.logger.info(\\\"Resize Image is successful\\\", event);\\n        // Additional operations based on the event data can be performed here\\n        return Promise.resolve();\\n    }\\n);\n```\n\n----------------------------------------\n\nTITLE: Adding a Mail Document to Firestore to Trigger Email - Firebase JavaScript\nDESCRIPTION: This JavaScript snippet demonstrates how to add a document to the 'mail' collection in Firestore, triggering the Firestore-send-email extension to send an email. It uses the Firebase Admin SDK to add a document with recipient, subject, and HTML body fields. The main dependencies are the Firebase Admin SDK and a properly configured Firestore-send-email extension; ensure your Firebase project is initialized and the extension is installed. The method requires valid recipient information; missing required fields may lead to email not being sent.\nSOURCE: https://github.com/firebase/extensions/blob/next/docs/firestore-send-email/get-started.md#_snippet_0\n\nLANGUAGE: js\nCODE:\n```\nadmin\n  .firestore()\n  .collection(\"mail\")\n  .add({\n    to: \"someone@example.com\",\n    message: {\n      subject: \"Hello from Firebase!\",\n      html: \"This is an <code>HTML</code> email body.\",\n    },\n  });\n```\n\n----------------------------------------\n\nTITLE: Sending Categorized Email via Firestore Document - SendGrid - JSON\nDESCRIPTION: This JSON code sample illustrates how to add a Firestore document to trigger a categorized email using SendGrid via the extension. The 'categories' array is used by SendGrid for email tagging and analytics. Required fields are 'to' (recipient array), 'categories' (array of categories), and 'message' (with subject, text, and HTML body). Requires SendGrid SMTP setup and extension configuration for category support.\nSOURCE: https://github.com/firebase/extensions/blob/next/firestore-send-email/README.md#_snippet_1\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"to\": [\"example@example.com\"],\n  \"categories\": [\"Example_Category\"],\n  \"message\": {\n    \"subject\": \"Test Email with Categories\",\n    \"text\": \"This is a test email to see if categories work.\",\n    \"html\": \"<strong>This is a test email to see if categories work.</strong>\"\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Example Format for Sending Email via Firestore Document - Firebase JavaScript\nDESCRIPTION: This JavaScript example illustrates the structure of a Firestore document needed to trigger the extension to send an email. The object contains the 'to' field (an array of recipient addresses) and a 'message' field with subject, plaintext, and HTML content. This object should be written to the configured messages collection. The document shape must match the Firestore-send-email extension's expected format; required fields include recipients and 'message' content.\nSOURCE: https://github.com/firebase/extensions/blob/next/docs/firestore-send-email/get-started.md#_snippet_1\n\nLANGUAGE: js\nCODE:\n```\nto: ['someone@example.com'],\nmessage: {\n  subject: 'Hello from Firebase!',\n  text: 'This is the plaintext section of the email body.',\n  html: 'This is the <code>HTML</code> section of the email body.',\n}\n```\n\n----------------------------------------\n\nTITLE: Fetching and Loading Firestore Bundles in JavaScript\nDESCRIPTION: This JavaScript snippet demonstrates how to fetch a Firestore data bundle from the extension's endpoint and load it using the Firestore SDK. It shows fetching from a Firebase Hosting CDN URL (preferred) or directly from the Cloud Function URL. The fetched bundle response is then passed to the `loadBundle` function from the `firebase/firestore` module to populate the SDK's cache.\nSOURCE: https://github.com/firebase/extensions/blob/next/docs/firestore-bundle-builder/get-started.md#_snippet_1\n\nLANGUAGE: js\nCODE:\n```\nimport { loadBundle } from \"firebase/firestore\";\n\n// Download the bundle from the Firebase Hosting CDN:\nconst bundle = await fetch(\"/bundles/:bundleId\");\n\n// If not using a CDN, download the bundle directly:\n// const bundle = await fetch('https://<location>-<project-id>.cloudfunctions.net/ext-firestore-bundle-builder-serve/:bundleId');\n\nawait loadBundle(bundle);\n```\n\n----------------------------------------\n\nTITLE: Executing Named Queries from a Loaded Bundle Cache (JavaScript)\nDESCRIPTION: This JavaScript snippet demonstrates how to execute a named query defined within a Firestore bundle after the bundle has been loaded. It uses `namedQuery` from the `firebase/firestore` module, passing the Firestore instance and the specific `queryId` (defined in the bundle specification), to retrieve the query object. Then, `getDocsFromCache` is used with this query object to fetch the query results from the local cache populated by `loadBundle`.\nSOURCE: https://github.com/firebase/extensions/blob/next/docs/firestore-bundle-builder/get-started.md#_snippet_3\n\nLANGUAGE: js\nCODE:\n```\nimport { getFirestore, namedQuery } from \"firebase/firestore\";\nconst query = await namedQuery(getFirestore(), \"queryId\");\nconst snapshot = await getDocsFromCache(query);\n```\n\n----------------------------------------\n\nTITLE: Accessing Specific Documents from a Loaded Bundle Cache (JavaScript)\nDESCRIPTION: This JavaScript snippet shows how to retrieve a specific document's data from the Firestore cache after a bundle containing that document has been loaded via `loadBundle`. It uses `getFirestore` to get the Firestore instance, `doc` to create a reference to the specific document path (e.g., 'users/92x1NgSWYKUC4AG4s2nHGMR2ikZ2'), and `getDocFromCache` to retrieve the document snapshot from the cache.\nSOURCE: https://github.com/firebase/extensions/blob/next/docs/firestore-bundle-builder/get-started.md#_snippet_2\n\nLANGUAGE: js\nCODE:\n```\nimport { getFirestore, doc, getDocFromCache } from \"firebase/firestore\";\n// Bundle Document IDs: ['users/92x1NgSWYKUC4AG4s2nHGMR2ikZ2']\n\nconst ref = doc(getFirestore(), \"users/92x1NgSWYKUC4AG4s2nHGMR2ikZ2\");\nconst snapshot = await getDocFromCache(ref);\n```\n\n----------------------------------------\n\nTITLE: Creating a Firestore Email Document - JavaScript\nDESCRIPTION: This snippet provides the structure for an email document that should be inserted into the specified mail collection within Firestore to trigger the Firestore Send-Email extension. The document includes a 'to' array listing recipient addresses and a 'message' object specifying subject, plaintext, and HTML body. No external dependencies are required for this Firestore UI usage, but the extension should be installed and configured. Inputs are the recipient(s) and message, outputs are processing actions by the extension, and required parameters are the 'to' and 'message' fields.\nSOURCE: https://github.com/firebase/extensions/blob/next/firestore-send-email/POSTINSTALL.md#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nto: ['someone@example.com'],\nmessage: {\n  subject: 'Hello from Firebase!',\n  text: 'This is the plaintext section of the email body.',\n  html: 'This is the <code>HTML</code> section of the email body.',\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Non-incremental Materialized View in BigQuery - SQL\nDESCRIPTION: Demonstrates the SQL statement generated by the extension to create a non-incremental materialized view in BigQuery. This view captures the latest state of documents by aggregating change history, supports refresh intervals and staleness configuration, and uses advanced SQL functions such as MAX_BY. Input table and parameters must reflect your extension setup. Neither clustering nor partitioning are supported on these views.\nSOURCE: https://github.com/firebase/extensions/blob/next/firestore-bigquery-export/README.md#_snippet_1\n\nLANGUAGE: sql\nCODE:\n```\nCREATE MATERIALIZED VIEW `my_project.my_dataset.my_table_raw_changelog`\\n  OPTIONS (\\n    allow_non_incremental_definition = true,\\n    enable_refresh = true,\\n    refresh_interval_minutes = 60,\\n    max_staleness = INTERVAL \"4:0:0\" HOUR TO SECOND\\n  )\\n  AS (\\n    WITH latests AS (\\n      SELECT\\n        document_name,\\n        MAX_BY(document_id, timestamp) AS document_id,\\n        MAX(timestamp) AS timestamp,\\n        MAX_BY(event_id, timestamp) AS event_id,\\n        MAX_BY(operation, timestamp) AS operation,\\n        MAX_BY(data, timestamp) AS data,\\n        MAX_BY(old_data, timestamp) AS old_data,\\n        MAX_BY(extra_field, timestamp) AS extra_field\\n      FROM `my_project.my_dataset.my_table_raw_changelog`\\n      GROUP BY document_name\\n    )\\n    SELECT *\\n    FROM latests\\n    WHERE operation != \"DELETE\"\\n  )\\n\n```\n\n----------------------------------------\n\nTITLE: Creating Incremental Materialized View in BigQuery - SQL\nDESCRIPTION: Presents an SQL command for defining an incremental materialized view in BigQuery, as designed by the extension. The view efficiently updates only new or modified records and is subject to certain BigQuery query restrictions. Supports configurable refresh intervals and staleness policies. No support for clustering or partitioning. Intended as a template for extension-generated view creation.\nSOURCE: https://github.com/firebase/extensions/blob/next/firestore-bigquery-export/README.md#_snippet_2\n\nLANGUAGE: sql\nCODE:\n```\nCREATE MATERIALIZED VIEW `my_project.my_dataset.my_table_raw_changelog`\\n  OPTIONS (\\n    enable_refresh = true,\\n    refresh_interval_minutes = 60,\\n    max_staleness = INTERVAL \"4:0:0\" HOUR TO SECOND\\n  )\\nAS (\\n      SELECT\\n        document_name,\\n        MAX_BY(document_id, timestamp) AS document_id,\\n        MAX(timestamp) AS timestamp,\\n        MAX_BY(event_id, timestamp) AS event_id,\\n        MAX_BY(operation, timestamp) AS operation,\\n        MAX_BY(data, timestamp) AS data,\\n        MAX_BY(old_data, timestamp) AS old_data,\\n        MAX_BY(extra_field, timestamp) AS extra_field\\n      FROM\\n        `my_project.my_dataset.my_table_raw_changelog`\\n      GROUP BY\\n        document_name\\n    )\\n\n```\n\n----------------------------------------\n\nTITLE: Granting BigQuery CMEK Permissions via gcloud CLI - Bash\nDESCRIPTION: Contains a bash script command for granting the BigQuery encryption service account necessary permissions to use a Cloud KMS key for customer managed encryption keys (CMEK). The gcloud command binds the Encrypter/Decrypter IAM role to the service account and must be customized with your project, key, and location details. This is a prerequisite when configuring BigQuery datasets to use CMEK with the extension.\nSOURCE: https://github.com/firebase/extensions/blob/next/firestore-bigquery-export/README.md#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\ngcloud kms keys add-iam-policy-binding \\\\n--project=KMS_PROJECT_ID \\\\n--member serviceAccount:bq-PROJECT_NUMBER@bigquery-encryption.iam.gserviceaccount.com \\\\n--role roles/cloudkms.cryptoKeyEncrypterDecrypter \\\\n--location=KMS_KEY_LOCATION \\\\n--keyring=KMS_KEY_RING \\\\nKMS_KEY\\n\n```\n\n----------------------------------------\n\nTITLE: Sending an Email Using Template Data with Firestore Admin SDK - JavaScript (JSX)\nDESCRIPTION: This JavaScript (JSX) snippet demonstrates how to submit a new email sending request to Firestore by adding a document to the mail collection. It uses the Firebase Admin SDK to specify the recipient UIDs and template details, referencing the 'following' template and providing merge data for the placeholders in that template. Dependencies include the Firebase Admin SDK and an initialized Firestore. Inputs are recipient identifiers and template merge data, output is a queued email document for processing by the extension. Ensure the collection path and template names match those defined in the extension configuration and templates collection. Used for automated, data-driven email messaging.\nSOURCE: https://github.com/firebase/extensions/blob/next/docs/firestore-send-email/use-handlebars-template.md#_snippet_1\n\nLANGUAGE: jsx\nCODE:\n```\nadmin\\n  .firestore()\\n  .collection(\\\"MAIL_COLLECTION\\\")\\n  .add({\\n    toUids: [\\\"abc123\\\"],\\n    template: {\\n      name: \\\"following\\\",\\n      data: {\\n        username: \\\"ada\\\",\\n        name: \\\"Ada Lovelace\\\",\\n        imagePath: \\\"https://example.com/path/to/file/image-name.jpg\\\",\\n      },\\n    },\\n  });\n```\n\n----------------------------------------\n\nTITLE: Specifying a Cloud KMS Resource for CMEK - Plaintext Example\nDESCRIPTION: Illustrates the format for specifying a Cloud KMS resource name when configuring BigQuery datasets to use CMEK within the extension. Users must replace tokens with their actual project, region, key ring, and key names. No computation or CLI invocation is performed; this value is for configuration fields during extension installation.\nSOURCE: https://github.com/firebase/extensions/blob/next/firestore-bigquery-export/README.md#_snippet_4\n\nLANGUAGE: plaintext\nCODE:\n```\nprojects/<YOUR PROJECT ID>/locations/<YOUR REGION>/keyRings/<YOUR KEY RING NAME>/cryptoKeys/<YOUR KEY NAME>\\n\n```\n\n----------------------------------------\n\nTITLE: Running OAuth2 Refresh Token Helper Script (Node.js via Bash)\nDESCRIPTION: This Bash snippet demonstrates how to execute the OAuth2 refresh token helper script using Node.js, supporting both direct and environment variable-based CLI parameter passing. Supported options include port, Google Client ID, secret, output filename, and help. The script launches a local OAuth flow to obtain a refresh token which can then be used for authenticating SMTP mailing services such as Gmail when configuring the Firebase Send Email extension.\nSOURCE: https://github.com/firebase/extensions/blob/next/firestore-send-email/PREINSTALL.md#_snippet_4\n\nLANGUAGE: Bash\nCODE:\n```\nnode oauth2-refresh-token-helper.js\n```\n\nLANGUAGE: Bash\nCODE:\n```\n# Using environment variables\nexport CLIENT_ID=your_client_id\nexport CLIENT_SECRET=your_client_secret\nnode oauth2-refresh-token-helper.js\n\n# Using command-line arguments\nnode oauth2-refresh-token-helper.js --id=your_client_id --secret=your_client_secret\n```\n\n----------------------------------------\n\nTITLE: Running the Schema-Views Script via npx for BigQuery Schema Generation (Bash)\nDESCRIPTION: This Bash snippet demonstrates running the fs-bq-schema-views script using npx to generate BigQuery schema views for Firestore data. Required dependencies include Node.js, npm, and (optionally) npx for npm versions <5.2. Parameters such as --project, --dataset, --table-name-prefix, and --schema-files must be specified. Inputs are the Firebase project ID, BigQuery dataset ID, target table prefix, and path(s) to the schema JSON file(s). The script outputs BigQuery views matching the provided schema definitions. Incorrect parameters or missing dependencies will result in script failure.\nSOURCE: https://github.com/firebase/extensions/blob/next/docs/firestore-bigquery-export/generating-schemas.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n$ npx @firebaseextensions/fs-bq-schema-views \\\\\\n  --non-interactive \\\\\\n  --project=${param:PROJECT_ID} \\\\\\n  --dataset=${param:DATASET_ID} \\\\\\n  --table-name-prefix=${param:TABLE_ID} \\\\\\n  --schema-files=./test_schema.json\\n\n```\n\n----------------------------------------\n\nTITLE: Running the OAuth2 Refresh Token Helper Script - Node.js Bash\nDESCRIPTION: This Bash code shows how to run the OAuth2 refresh token helper script with Node.js, either using default environment or command-line arguments. Prerequisites: Node.js installed, helper script present. Input: environment variables or command-line parameters for CLIENT_ID and CLIENT_SECRET. Output: Launches local webserver, returns refresh token in browser and/or on disk.\nSOURCE: https://github.com/firebase/extensions/blob/next/firestore-send-email/README.md#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nnode oauth2-refresh-token-helper.js\n```\n\n----------------------------------------\n\nTITLE: Uploading Images with Correct Content-Type using Node.js Admin SDK\nDESCRIPTION: This Node.js snippet demonstrates uploading raw image data to a Firebase Storage bucket using the Admin SDK. It specifically shows how to set the `Content-Type` metadata (`image/jpeg` in this example) during the upload process, which is essential for triggering the image resizing extension. Requires the `firebase-admin` package and a service account key for initialization.\nSOURCE: https://github.com/firebase/extensions/blob/next/storage-resize-images/POSTINSTALL.md#_snippet_0\n\nLANGUAGE: js\nCODE:\n```\nconst admin = require(\"firebase-admin\");\nconst serviceAccount = require(\"../path-to-service-account.json\");\n\nadmin.initializeApp({\n  credential: admin.credential.cert(serviceAccount),\n});\n\nconst storage = admin.storage();\n\n// rawImage param is the binary data read from the file system or downloaded from URL\nfunction uploadImageToStorage(rawImage){\n  const bucket = storage.bucket(\"YOUR FIREBASE STORAGE BUCKET URL\");\n  const file = bucket.file(\"filename.jpeg\");\n\n  file.save(\n    rawImage,\n    {\n      // set the content type to ensure the extension triggers the image resize(s)\n      metadata: { contentType: \"image/jpeg\" },\n    },\n    (error) => {\n      if (error) {\n        throw error;\n      }\n      console.log(\"Successfully uploaded image\");\n    }\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Providing OAuth2 Credentials to the Helper Script - Bash\nDESCRIPTION: This snippet presents two Bash approaches for providing OAuth2 credentials to the helper script: via environment variables or command-line arguments. Necessary parameters are CLIENT_ID and CLIENT_SECRET. Result: upon execution, script uses provided credentials to initiate OAuth2 flow.\nSOURCE: https://github.com/firebase/extensions/blob/next/firestore-send-email/README.md#_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\n# Using environment variables\nexport CLIENT_ID=your_client_id\nexport CLIENT_SECRET=your_client_secret\nnode oauth2-refresh-token-helper.js\n\n# Using command-line arguments\nnode oauth2-refresh-token-helper.js --id=your_client_id --secret=your_client_secret\n```\n\n----------------------------------------\n\nTITLE: Example SMTP URI with Query Parameters\nDESCRIPTION: Illustrates how to append query parameters to an SMTP(S) connection URI to configure additional connection options. This generic example shows adding a `pool=true` parameter after the main connection details (protocol, username, hostname, port). The specific parameters and their usage depend on the SMTP provider.\nSOURCE: https://github.com/firebase/extensions/blob/next/docs/firestore-send-email/smtp-connection-url.md#_snippet_2\n\nLANGUAGE: text\nCODE:\n```\nsmtp(s)://username@hostname:port/?pool=true\n```\n\n----------------------------------------\n\nTITLE: Querying Specific Document Changelog in BigQuery SQL\nDESCRIPTION: Executes a SQL query to select the complete history of changes for a specific document ('bigquery-mirror-test') from the raw changelog table, ordered by timestamp. This is useful for auditing or tracking the lifecycle of a single Firestore document within BigQuery. Requires the `BIGQUERY_PROJECT_ID`, `DATASET_ID`, and `TABLE_ID` parameters.\nSOURCE: https://github.com/firebase/extensions/blob/next/firestore-bigquery-export/POSTINSTALL.md#_snippet_2\n\nLANGUAGE: sql\nCODE:\n```\nSELECT *\nFROM `${param:BIGQUERY_PROJECT_ID}.${param:DATASET_ID}.${param:TABLE_ID}_raw_changelog`\nWHERE document_name = \"bigquery-mirror-test\"\nORDER BY TIMESTAMP ASC\n```\n\n----------------------------------------\n\nTITLE: Implementing Firestore Sharded Counter with Node.js Admin SDK\nDESCRIPTION: Shows how to initialize the Firebase Admin SDK in a Node.js environment, require the provided Node.js counter sample (`distributed_counter`), instantiate the `Counter` class for a specific document and field (`visits`), increment the counter, and listen for both locally consistent (`visits.onSnapshot`) and eventually consistent (`db...onSnapshot`) updates. Requires the `firebase-admin` package and the counter sample code (`distributed_counter.js`).\nSOURCE: https://github.com/firebase/extensions/blob/next/firestore-counter/POSTINSTALL.md#_snippet_5\n\nLANGUAGE: js\nCODE:\n```\n  // Initialize Firebase.\n  const admin = require('firebase-admin');\n  admin.initializeApp();\n  const db = admin.firestore();\n\n  const Counter = require(\"./distributed_counter\")\n\n  const visits = new Counter(db.collection(\"pages\").doc(\"hello-world\"), \"visits\")\n\n  // Increment the field \"visits\" of the document \"pages/hello-world\".\n  visits.incrementBy(1);\n\n  // Listen to locally consistent values.\n  visits.onSnapshot((snap) => {\n    console.log(\"Locally consistent view of visits: \" + snap.data());\n  });\n\n  // Alternatively, if you don't mind counter delays, you can listen to the document directly.\n  db.collection(\"pages\").doc(\"hello-world\").onSnapshot((snap) => {\n    console.log(\"Eventually consistent view of visits: \" + snap.get(\"visits\"));\n  });\n```\n\n----------------------------------------\n\nTITLE: Authenticating Application Default Credentials with gcloud CLI - Shell\nDESCRIPTION: This shell snippet demonstrates setting up Application Default Credentials for the import script using the gcloud CLI. This authentication is required for the script to access BigQuery and execute import operations. Before running the import script, this command should be executed on the system where you will invoke the script.\nSOURCE: https://github.com/firebase/extensions/blob/next/firestore-bigquery-export/guides/IMPORT_EXISTING_DOCUMENTS.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\ngcloud auth application-default login\n```\n\n----------------------------------------\n\nTITLE: Counting Imported Firestore Documents in BigQuery - SQL\nDESCRIPTION: This SQL snippet demonstrates how to count the number of documents imported by querying the raw changelog table in BigQuery. The query selects all records with the operation 'IMPORT', helping verify the total imported documents. Replace the placeholders with your project, dataset, and collection path values.\nSOURCE: https://github.com/firebase/extensions/blob/next/firestore-bigquery-export/guides/IMPORT_EXISTING_DOCUMENTS.md#_snippet_2\n\nLANGUAGE: sql\nCODE:\n```\nSELECT COUNT(*) FROM\n  `${PROJECT_ID}.${COLLECTION_PATH}.${COLLECTION_PATH}_raw_changelog`\n  WHERE operation = \"IMPORT\"\n```\n\n----------------------------------------\n\nTITLE: Running fs-bq-schema-views Non-Interactively with Gemini AI (Bash)\nDESCRIPTION: Executes the `fs-bq-schema-views` script non-interactively using `npx`, providing all configuration via command-line arguments. It uses Gemini AI (`--use-gemini`) to generate a schema based on the specified Firestore collection (`users_collection`) and saves it (`--gemini-schema-file-name`) in the specified directory (`--schema-directory`). Requires project IDs, dataset, table prefix, and a Google AI API key (`$GOOGLE_API_KEY`).\nSOURCE: https://github.com/firebase/extensions/blob/next/firestore-bigquery-export/guides/GENERATE_SCHEMA_VIEWS.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nnpx @firebaseextensions/fs-bq-schema-views \\\n  --non-interactive \\\n  --project=my-firebase-project \\\n  --big-query-project=my-bq-project \\\n  --dataset=firestore_changelog \\\n  --table-name-prefix=user_profiles \\\n  --use-gemini=users_collection \\\n  --google-ai-key=$GOOGLE_API_KEY \\\n  --schema-directory=./schemas \\\n  --gemini-schema-file-name=user_schema\n```\n\n----------------------------------------\n\nTITLE: Querying the Generated BigQuery Changelog View (SQL)\nDESCRIPTION: Example BigQuery SQL query to retrieve data from a generated changelog view, demonstrating how to test the schema application. It selects the `document_name`, `name`, and `age` columns from the view named `YOUR_TABLE_PREFIX_schema_test_schema_changelog` (assuming a schema file named `test_schema.json` was used). The query filters for a specific document (`test-schema-document`). Requires replacing placeholders with actual project, dataset, and table prefix values.\nSOURCE: https://github.com/firebase/extensions/blob/next/firestore-bigquery-export/guides/GENERATE_SCHEMA_VIEWS.md#_snippet_5\n\nLANGUAGE: sql\nCODE:\n```\nSELECT document_name, name, age\nFROM YOUR_PROJECT_ID.YOUR_DATASET_ID.YOUR_TABLE_PREFIX_schema_test_schema_changelog\nWHERE document_name = \"test-schema-document\"\n```\n\n----------------------------------------\n\nTITLE: Using the Firestore Counter Web SDK to Increment and Observe Counters\nDESCRIPTION: This HTML and JavaScript snippet demonstrates initializing Firebase, including the sharded-counter Web SDK, and using it to manage a counter. It creates a 'sharded.Counter' instance linked to the 'stats.views' field within the 'pages/hello-world' Firestore document. The 'incrementBy(3)' method increases the counter, and two 'onSnapshot' listeners show how to observe both locally consistent (via the counter object) and eventually consistent (directly from the document) counter values. Requires a Firebase configuration object.\nSOURCE: https://github.com/firebase/extensions/blob/next/firestore-counter/CONTRIBUTING.md#_snippet_1\n\nLANGUAGE: html\nCODE:\n```\n<html>\n    <head>\n        <script src=\"https://www.gstatic.com/firebasejs/6.2.0/firebase-app.js\"></script>\n        <script src=\"https://www.gstatic.com/firebasejs/6.2.0/firebase-firestore.js\"></script>\n        <script src=\"clients/web/dist/sharded-counter.js\"></script>\n    </head>\n    <body>\n        <script>\n            // Initialize Firebase.\n            var config = {};\n            firebase.initializeApp(config);\n            var db = firebase.firestore();\n\n            // Initialize the sharded counter.\n            var views = new sharded.Counter(db.doc(\"pages/hello-world\"), \"stats.views\");\n\n            // This will increment a field \"stats.views\" of the \"pages/hello-world\" document by 3.\n            views.incrementBy(3);\n\n            // Listen to locally consistent values\n            views.onSnapshot((snap) => {\n                console.log(\"Locally consistent view of visits: \" + snap.data());\n            });\n\n            // Alternatively if you don't mind counter delays, you can listen to the document directly.\n            db.doc(\"pages/hello-world\").onSnapshot((snap) => {\n                console.log(\"Eventually consistent view of visits: \" + snap.get(\"stats.views\"));\n            })\n        </script>\n    </body>\n</html>\n```\n\n----------------------------------------\n\nTITLE: Handling Resize Image Completion Events with Firebase Functions in Node.js\nDESCRIPTION: Defines a cloud function handler named \\\\\"onimageresized\\\\\" that responds to image resize completion events published by the Resize Image Extension. The handler logs the received event and writes the resized image data into a Firestore document, transforming the event subject (file path) into a valid document ID and storing metadata provided in the event's data property. This function expects a properly initialized Firestore and requires the custom event name to be enabled; it is invoked upon relevant resize completion events via Eventarc. Input is the event object; on success, data is persisted in Firestore under the 'images' collection.\nSOURCE: https://github.com/firebase/extensions/blob/next/docs/storage-resize-images/handle-resize-image-extension-events.md#_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nexports.onimageresized = onCustomEventPublished(\n  \"firebase.extensions.storage-resize-images.v1.complete\",\n  (event) => {\n    logger.info(\"Received image resize completed event\", event);\n    // For example, write resized image details into Firestore.\n    return getFirestore()\n      .collection(\"images\")\n      .doc(event.subject.replace(\"/\", \"_\")) // original file path\n      .set(event.data); // resized images paths and sizes\n  }\n);\n```\n\n----------------------------------------\n\nTITLE: Running fs-bq-schema-views Non-Interactively with Manual Schema (Bash)\nDESCRIPTION: Executes the `fs-bq-schema-views` script non-interactively using `npx`, applying one or more manually created schema files (e.g., `./test_schema.json` specified via `--schema-files`). Requires placeholder values for Firebase Project ID, BigQuery Project ID, BigQuery Dataset ID, and the Table Prefix used by the Firestore to BigQuery extension to be replaced with actual values. Multiple schema files can be provided separated by commas.\nSOURCE: https://github.com/firebase/extensions/blob/next/firestore-bigquery-export/guides/GENERATE_SCHEMA_VIEWS.md#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nnpx @firebaseextensions/fs-bq-schema-views \\\n  --non-interactive \\\n  --project=YOUR_PROJECT_ID \\\n  --big-query-project=YOUR_BIGQUERY_PROJECT_ID \\\n  --dataset=YOUR_DATASET_ID \\\n  --table-name-prefix=YOUR_TABLE_PREFIX \\\n  --schema-files=./test_schema.json\n```\n\n----------------------------------------\n\nTITLE: Granting Cross-Project BigQuery Access via PowerShell Script\nDESCRIPTION: Provides PowerShell commands for Windows users to download and execute a script that grants the necessary BigQuery permissions to the extension's service account on a target project different from the Firebase project. Requires specifying the source Firebase project ID (`-FirebaseProject`) and the target BigQuery project ID (`-BigQueryProject`), with optional parameters for the extension instance ID (`-ExtensionInstanceId`) and service account email (`-ServiceAccount`). Prerequisites include having the gcloud CLI installed and permissions to grant IAM roles on the target project.\nSOURCE: https://github.com/firebase/extensions/blob/next/firestore-bigquery-export/POSTINSTALL.md#_snippet_4\n\nLANGUAGE: powershell\nCODE:\n```\nInvoke-WebRequest -Uri \"https://raw.githubusercontent.com/firebase/extensions/master/firestore-bigquery-export/scripts/grant-crossproject-access.ps1\" -OutFile \"grant-crossproject-access.ps1\"\n.\\grant-crossproject-access.ps1 -FirebaseProject SOURCE_FIREBASE_PROJECT -BigQueryProject TARGET_BIGQUERY_PROJECT [-ExtensionInstanceId EXTENSION_INSTANCE_ID] [-ServiceAccount SERVICE_ACCOUNT]\n```\n\n----------------------------------------\n\nTITLE: Defining a Complex Manual Schema with Various Data Types (JSON)\nDESCRIPTION: Illustrates a more complex manual schema definition in JSON format for `fs-bq-schema-views`, showcasing various supported field types. It includes definitions for `string`, `array` (`favorite_numbers`), `timestamp` (`last_login`), `geopoint` (`last_location`), `stringified_map` (`geo_point` - converts a map to a JSON string), and a nested `map` (`friends`) which itself contains fields like `name` (string). This structure guides the script on how to create corresponding typed columns or structures in the BigQuery view.\nSOURCE: https://github.com/firebase/extensions/blob/next/firestore-bigquery-export/guides/GENERATE_SCHEMA_VIEWS.md#_snippet_6\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"fields\": [\n    {\n      \"name\": \"name\",\n      \"type\": \"string\"\n    },\n    {\n      \"name\": \"favorite_numbers\",\n      \"type\": \"array\"\n    },\n    {\n      \"name\": \"last_login\",\n      \"type\": \"timestamp\"\n    },\n    {\n      \"name\": \"last_location\",\n      \"type\": \"geopoint\"\n    },\n    {\n      \"name\": \"geo_point\",\n      \"type\": \"stringified_map\"\n    },\n    {\n      \"name\": \"friends\",\n      \"type\": \"map\",\n      \"fields\": [\n        {\n          \"name\": \"name\",\n          \"type\": \"string\"\n        }\n      ]\n    }\n  ]\n}\n```\n\n----------------------------------------\n\nTITLE: Including a Handlebars Partial in an Email Template - HTML\nDESCRIPTION: This HTML snippet shows how to incorporate a Handlebars partial (such as a common footer) within the main template content using the partial syntax '{{> footer }}'. It demonstrates template composition and reuse within email bodies. There are no external dependencies beyond a functioning Handlebars environment. Input is the outer template, output is rendered HTML with the referenced partial included. This promotes DRY patterns and easier template maintenance.\nSOURCE: https://github.com/firebase/extensions/blob/next/docs/firestore-send-email/use-handlebars-template.md#_snippet_3\n\nLANGUAGE: html\nCODE:\n```\n<p>This is my main template content, but it will use a common footer.</p>\\n\\n{{> footer }}\n```\n\n----------------------------------------\n\nTITLE: Translating a Single String with Firebase Extension in Firestore (JavaScript)\nDESCRIPTION: Demonstrates the resulting Firestore document structure when the Firebase Translate Text extension processes a document where the `${param:INPUT_FIELD_NAME}` field contains a single string ('My name is Bob'). The extension adds an `${param:OUTPUT_FIELD_NAME}` field containing a map of target language codes (de, en, es, fr) to their respective translations. This occurs automatically when the input field is created or updated in the `${param:COLLECTION_PATH}` collection.\nSOURCE: https://github.com/firebase/extensions/blob/next/firestore-translate-text/POSTINSTALL.md#_snippet_0\n\nLANGUAGE: js\nCODE:\n```\n{\n  ${param:INPUT_FIELD_NAME}: 'My name is Bob',\n  ${param:OUTPUT_FIELD_NAME}: {\n    de: 'Ich heiße Bob',\n    en: 'My name is Bob',\n    es: 'Mi nombre es Bob',\n    fr: 'Je m\\'appelle Bob',\n  },\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Firestore Security Rules for Sharded Counter Access\nDESCRIPTION: Sets Firestore security rules for a specific collection (`pages`) to allow authenticated users to read shard documents (`_counter_shards_`) and write updates, specifically incrementing the `visits` field by exactly 1. This ensures controlled access to the counter mechanism and prevents arbitrary writes to the counter shards.\nSOURCE: https://github.com/firebase/extensions/blob/next/firestore-counter/POSTINSTALL.md#_snippet_0\n\nLANGUAGE: firestore-rules\nCODE:\n```\nmatch /databases/{database}/documents/pages/{page} {\n  // Allow to increment only the 'visits' field and only by 1.\n  match /_counter_shards_/{shardId} {\n    allow get;\n    allow write: if request.resource.data.keys() == [\"visits\"]\n                   && (resource == null || request.resource.data.visits ==\n                   resource.data.visits + 1);\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Installing the Firestore Counter Firebase Mod via CLI\nDESCRIPTION: This command uses the Firebase CLI to install the 'firestore-counter' mod, assumed to be located in the current directory (.), into the specified Firebase project. It requires the Firebase CLI to be installed and configured. The user is prompted to check the post-installation message for further setup instructions.\nSOURCE: https://github.com/firebase/extensions/blob/next/firestore-counter/CONTRIBUTING.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nfirebase mods:install . --project=<my-project-id>\n\nPlease check the post-install message for the final step to set up your mod.\n```\n\n----------------------------------------\n\nTITLE: Building the Firestore Counter Cloud Functions from Source\nDESCRIPTION: These shell commands provide instructions for building the Cloud Functions component of the 'firestore-counter' mod from its source code. It involves navigating into the 'functions' directory, installing Node.js dependencies using 'npm install', and executing the build script defined in 'package.json' via 'npm run build'. Requires Node.js and npm to be installed.\nSOURCE: https://github.com/firebase/extensions/blob/next/firestore-counter/CONTRIBUTING.md#_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\n    cd functions/\n    npm install\n    npm run build\n```\n\n----------------------------------------\n\nTITLE: Translating a Map of Strings with Firebase Extension in Firestore (JavaScript)\nDESCRIPTION: Illustrates the resulting Firestore document structure when the Firebase Translate Text extension processes a document where `${param:INPUT_FIELD_NAME}` is a map of strings ({ first: \"My name is Bob\", second: \"Hello, friend\" }). The extension adds an `${param:OUTPUT_FIELD_NAME}` field containing a map where each key corresponds to the input map's keys ('first', 'second'), and the value is another map of target language codes (de, en, es, fr) to translations for that specific input string. This is triggered by creating or updating the document in the `${param:COLLECTION_PATH}` collection.\nSOURCE: https://github.com/firebase/extensions/blob/next/firestore-translate-text/POSTINSTALL.md#_snippet_1\n\nLANGUAGE: js\nCODE:\n```\n{\n  first: \"My name is Bob\",\n  second: \"Hello, friend\"\n}\n```\n\nLANGUAGE: js\nCODE:\n```\n{\n  ${param:INPUT_FIELD_NAME}: {\n    first: \"My name is Bob\",\n    second: \"Hello, friend\"\n  },\n  \n  ${param:OUTPUT_FIELD_NAME}: {\n    first:{\n      de: \"Ich heiße Bob\",\n      en: \"My name is Bob\",\n      es: \"Mi nombre es Bob\",\n      fr: \"Je m'appelle Bob\",\n    },\n    second:{\n      de: \"Hallo Freund\",\n      en: \"Hello, friend\",\n      es: \"Hola amigo\",\n      fr: \"Salut l'ami\",\n    },   \n  },\n}\n```\n\n----------------------------------------\n\nTITLE: Handling Successful Image Resize Events in Firebase Functions (TypeScript)\nDESCRIPTION: This TypeScript code defines a Google Cloud Function using the Firebase Functions v2 SDK. It triggers on custom events published by the 'storage-resize-images' Firebase extension via Eventarc, specifically listening for the 'firebase.extensions.storage-resize-images.v1.onSuccess' event type. When a successful image resize occurs and events are enabled in the extension, this function logs the event details and can be extended to perform additional actions based on the successful resize.\nSOURCE: https://github.com/firebase/extensions/blob/next/storage-resize-images/README.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as functions from 'firebase-functions';\nimport { onCustomEventPublished } from 'firebase-functions/v2/eventarc';\n\nexport const onImageResized = onCustomEventPublished(\n    \"firebase.extensions.storage-resize-images.v1.onSuccess\",\n    (event) => {\n        functions.logger.info(\"Resize Image is successful\", event);\n        // Additional operations based on the event data can be performed here\n        return Promise.resolve();\n    }\n);\n```\n\n----------------------------------------\n\nTITLE: Configuring Sharp Resize Options (JSON)\nDESCRIPTION: Example JSON configuration string for the 'Sharp constructor options for resizing images' parameter. It shows how to customize image resizing behavior using Sharp options like 'fastShrinkOnLoad', 'position', and 'fit', allowing control over how images are scaled and positioned within the target dimensions.\nSOURCE: https://github.com/firebase/extensions/blob/next/storage-resize-images/README.md#_snippet_2\n\nLANGUAGE: json\nCODE:\n```\n`{ \"fastShrinkOnLoad\": false, \"position\": “centre”, \"fit\": \"inside\" }`\n```\n\n----------------------------------------\n\nTITLE: Configuring Multiple Image Formats with OUTPUT_OPTIONS in JSON\nDESCRIPTION: This JSON snippet provides a comprehensive example of the `OUTPUT_OPTIONS` parameter for a Firebase image processing extension. It demonstrates how to define specific output settings for multiple image formats within a single JSON object: JPEG quality is set to 5 and chroma subsampling to '4:4:4', while PNG palette is enabled. Image formats or options not specified in this object will use the default Sharp library settings.\nSOURCE: https://github.com/firebase/extensions/blob/next/docs/storage-resize-images/customize-output-options.md#_snippet_1\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"jpeg\": { \"quality\": 5, \"chromaSubsampling\": \"4:4:4\" },\n  \"png\": { \"pallete\": true }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring PNG Output Quality with OUTPUT_OPTIONS in JSON\nDESCRIPTION: This JSON snippet exemplifies configuring the `OUTPUT_OPTIONS` parameter for a Firebase image processing extension. It specifically sets the 'quality' option for 'png' images to 50, overriding the default value (80). This configuration map is parsed by the extension using `JSON.parse()` and applied during image processing via the Sharp library.\nSOURCE: https://github.com/firebase/extensions/blob/next/docs/storage-resize-images/customize-output-options.md#_snippet_0\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"png\": { \"quality\": 50 }\n}\n```\n\n----------------------------------------\n\nTITLE: Using Firestore Sharded Counter in iOS Applications (Swift)\nDESCRIPTION: Illustrates initializing Firestore, getting a `DocumentReference`, creating a `FirestoreShardCounter` instance (using provided sample code `FirestoreShardedCounter.swift`), setting up an `onSnapshot` listener for real-time updates, fetching the current count with `get()`, and incrementing the counter (`visits`) within a `UIViewController`. Requires the Firebase Firestore iOS SDK and the provided sample code.\nSOURCE: https://github.com/firebase/extensions/blob/next/firestore-counter/POSTINSTALL.md#_snippet_4\n\nLANGUAGE: swift\nCODE:\n```\nimport UIKit\nimport FirestoreCounter\nimport FirebaseFirestore\n\nclass ViewController: UIViewController {\n  // somewhere in your app code initialize Firestore instance\n  var db = Firestore.firestore()\n  // create reference to the collection and the document you wish to use \n  var doc = db.collection(\"pages\").document(\"hello-world\")\n  // initialize FirestoreShardedCounter with the document and the property which will hold the counter value\n  var controller = FirestoreShardCounter(docRef: doc, field: \"visits\")\n\n  override func viewDidLoad() {\n    super.viewDidLoad()\n    // event listener which returns total amount\n    controller.onSnapshot { (value, error) in\n      if let error = error {\n        // handle error\n      } else if let value = value {\n        // 'value' param is total amount of pages visits\n      }\n    }\n  }\n\n  @IBAction func getLatest(_ sender: Any) {\n    // get current total\n    controller.get() { (value, error) in\n      if let error = error {\n        // handle error\n      } else if let value = value {\n        // 'value' param is total amount of pages visits\n      }\n    }\n  }\n\n  @IBAction func incrementer(_ sender: Any) {\n    // to increment counter\n    controller.incrementBy(val: Double(1))\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Firebase Storage Resize Images Extension via CLI - Bash\nDESCRIPTION: This snippet demonstrates how to install the Firebase Storage Resize Images extension using the Firebase CLI. It requires the Firebase CLI to be installed and authenticated. Substitute 'projectId-or-alias' with the ID or alias of your Firebase project. The command installs the specified extension into the intended Firebase project, enabling image resizing functionality for Cloud Storage buckets configured in the extension.\nSOURCE: https://github.com/firebase/extensions/blob/next/docs/storage-resize-images/get-started.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nfirebase ext:install firebase/storage-resize-images --project=projectId-or-alias\n```\n\n----------------------------------------\n\nTITLE: Creating Incremental Materialized View in BigQuery (SQL)\nDESCRIPTION: Example SQL generated by the Firebase extension to create an incremental materialized view in BigQuery. This view efficiently updates by processing only new or changed records, using aggregation functions like MAX_BY grouped by document_name to represent the latest state. It includes options for refresh intervals and maximum staleness but has limitations on query complexity compared to non-incremental views.\nSOURCE: https://github.com/firebase/extensions/blob/next/firestore-bigquery-export/PREINSTALL.md#_snippet_2\n\nLANGUAGE: sql\nCODE:\n```\nCREATE MATERIALIZED VIEW `my_project.my_dataset.my_table_raw_changelog`\n  OPTIONS (\n    enable_refresh = true,\n    refresh_interval_minutes = 60,\n    max_staleness = INTERVAL \"4:0:0\" HOUR TO SECOND\n  )\nAS (\n      SELECT\n        document_name,\n        MAX_BY(document_id, timestamp) AS document_id,\n        MAX(timestamp) AS timestamp,\n        MAX_BY(event_id, timestamp) AS event_id,\n        MAX_BY(operation, timestamp) AS operation,\n        MAX_BY(data, timestamp) AS data,\n        MAX_BY(old_data, timestamp) AS old_data,\n        MAX_BY(extra_field, timestamp) AS extra_field\n      FROM\n        `my_project.my_dataset.my_table_raw_changelog`\n      GROUP BY\n        document_name\n    )\n```\n\n----------------------------------------\n\nTITLE: Creating Non-Incremental Materialized View in BigQuery (SQL)\nDESCRIPTION: Example SQL generated by the Firebase extension to create a non-incremental materialized view in BigQuery. This view represents the latest state of documents by selecting the most recent record for each document based on the timestamp, excluding records marked with the 'DELETE' operation. It includes options for refresh intervals and maximum staleness, and allows potentially complex query definitions.\nSOURCE: https://github.com/firebase/extensions/blob/next/firestore-bigquery-export/PREINSTALL.md#_snippet_1\n\nLANGUAGE: sql\nCODE:\n```\nCREATE MATERIALIZED VIEW `my_project.my_dataset.my_table_raw_changelog`\n  OPTIONS (\n    allow_non_incremental_definition = true,\n    enable_refresh = true,\n    refresh_interval_minutes = 60,\n    max_staleness = INTERVAL \"4:0:0\" HOUR TO SECOND\n  )\n  AS (\n    WITH latests AS (\n      SELECT\n        document_name,\n        MAX_BY(document_id, timestamp) AS document_id,\n        MAX(timestamp) AS timestamp,\n        MAX_BY(event_id, timestamp) AS event_id,\n        MAX_BY(operation, timestamp) AS operation,\n        MAX_BY(data, timestamp) AS data,\n        MAX_BY(old_data, timestamp) AS old_data,\n        MAX_BY(extra_field, timestamp) AS extra_field\n      FROM `my_project.my_dataset.my_table_raw_changelog`\n      GROUP BY document_name\n    )\n    SELECT *\n    FROM latests\n    WHERE operation != \"DELETE\"\n  )\n```\n\n----------------------------------------\n\nTITLE: Triggering Email Delivery via Firestore Document Insertion (Firebase Admin SDK, JavaScript)\nDESCRIPTION: This snippet inserts a document containing email recipient and message details into a Firestore collection, triggering the Firebase Send Email extension to send the email. It demonstrates how to structure the Firestore document, setting fields like 'to', 'subject', and HTML body. The admin.firestore() dependency must be initialized; input fields are key-value pairs representing standard email properties, and successful execution sends an email matching the provided fields via the extension's configured SMTP provider.\nSOURCE: https://github.com/firebase/extensions/blob/next/firestore-send-email/PREINSTALL.md#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nadmin.firestore().collection('mail').add({\n  to: 'someone@example.com',\n  message: {\n    subject: 'Hello from Firebase!',\n    html: 'This is an <code>HTML</code> email body.',\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Granting Cross-Project BigQuery Access Using PowerShell Script for Firebase Extension (PowerShell)\nDESCRIPTION: This PowerShell snippet streamlines assigning necessary BigQuery permissions to a Firebase extension's service account for cross-project exports. It's intended for Windows environments with the gcloud CLI installed, and it uses named parameters: -FirebaseProject for the source Firebase project ID, -BigQueryProject for the target BigQuery project ID, and an optional -ExtensionInstanceId. The code uses Invoke-WebRequest to fetch the script and executes it to configure the required BigQuery IAM roles, supporting automated permissions management during setup.\nSOURCE: https://github.com/firebase/extensions/blob/next/firestore-bigquery-export/PREINSTALL.md#_snippet_6\n\nLANGUAGE: powershell\nCODE:\n```\nInvoke-WebRequest -Uri \\\"https://raw.githubusercontent.com/firebase/extensions/master/firestore-bigquery-export/scripts/grant-crossproject-access.ps1\\\" -OutFile \\\"grant-crossproject-access.ps1\\\"\\n.\\grant-crossproject-access.ps1 -FirebaseProject SOURCE_FIREBASE_PROJECT -BigQueryProject TARGET_BIGQUERY_PROJECT [-ExtensionInstanceId EXTENSION_INSTANCE_ID]\n```\n\n----------------------------------------\n\nTITLE: Filtering Logs for OnWrite Trigger using Logs Explorer - plaintext\nDESCRIPTION: Demonstrates how to filter Cloud Logging entries for the fsexportbigquery (onWrite) function using the Logs Explorer in Google Cloud. This query targets logs from both Cloud Functions and Cloud Run deployments for a given extension instance ID, searching for Firestore events handled by the onWrite trigger. Replace 'firestore-bigquery-export' with the appropriate extension instance ID. Key parameters are 'function_name', 'service_name', 'region', and the search term within log messages. Expected output is a filtered logs list matching these criteria.\nSOURCE: https://github.com/firebase/extensions/blob/next/firestore-bigquery-export/guides/OBSERVABILITY.md#_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\n(resource.type=\\\"cloud_function\\\" resource.labels.function_name=(\\\"ext-firestore-bigquery-export-fsexportbigquery\\\") resource.labels.region=\\\"us-central1\\\") OR (resource.type=\\\"cloud_run_revision\\\" resource.labels.service_name=(\\\"ext-firestore-bigquery-export-fsexportbigquery\\\") resource.labels.location=\\\"us-central1\\\") SEARCH(\\\"Firestore event received by onWrite trigger\\\")\n```\n\n----------------------------------------\n\nTITLE: Example Log Entry for Firestore onWrite Trigger - JSON\nDESCRIPTION: Provides a sample structured JSON log entry generated when the fsexportbigquery function handles a Firestore onWrite event. Useful for understanding the fields present in logs (such as insertId, jsonPayload with document_name, event_id, message, operation, severity, trace) and for constructing log filters. No additional dependencies required; this format is output natively by Google Cloud Logging for the extension.\nSOURCE: https://github.com/firebase/extensions/blob/next/firestore-bigquery-export/guides/OBSERVABILITY.md#_snippet_6\n\nLANGUAGE: json\nCODE:\n```\n{\\n  \\\"insertId\\\": \\\"672ca19d0008f1be9873dda5\\\",\\n  \\\"jsonPayload\\\": {\\n    \\\"document_name\\\": \\\"projects/dev-extensions-testing/databases/(default)/documents/posts/x0F2QodvO09MJGX3DUfm\\\",\\n    \\\"event_id\\\": \\\"1b8f5ae5-983a-40f6-b921-560118e5e321-1\\\",\\n    \\\"message\\\": \\\"Firestore event received by onWrite trigger\\\",\\n    \\\"operation\\\": 0\\n  },\\n  \\\"labels\\\": {},\\n  \\\"logName\\\": \\\"projects/dev-extensions-testing/logs/cloudfunctions.googleapis.com%2Fcloud-functions\\\",\\n  \\\"receiveTimestamp\\\": \\\"2024-11-07T11:16:45.817442537Z\\\",\\n  \\\"resource\\\": {},\\n  \\\"severity\\\": \\\"INFO\\\",\\n  \\\"timestamp\\\": \\\"2024-11-07T11:16:45.586174Z\\\",\\n  \\\"trace\\\": \\\"projects/dev-extensions-testing/traces/6b1e13de24821178b8937f6ed72cc113\\\"\\n}\n```\n\n----------------------------------------\n\nTITLE: Filtering Logs by Operation Type in Logs Explorer - plaintext\nDESCRIPTION: Filters Cloud Logging entries to show events with a specific operation code, such as UPDATE (operation value 2). This is useful for analyzing only certain types of Firestore changes being exported. Key parameter is 'jsonPayload.operation'. Expected output is logs related to the selected operation type.\nSOURCE: https://github.com/firebase/extensions/blob/next/firestore-bigquery-export/guides/OBSERVABILITY.md#_snippet_3\n\nLANGUAGE: plaintext\nCODE:\n```\njsonPayload.operation=2\n```\n\n----------------------------------------\n\nTITLE: Combining Filters in Logs Explorer - plaintext\nDESCRIPTION: Demonstrates how to combine multiple filter conditions in Logs Explorer using the AND operator. This example narrows logs to those from the syncBigQuery function where a Firestore event was received by the onDispatch trigger. Replace <EXTENSION_INSTANCE_ID> for your instance. Both 'resource.labels.function_name' and 'jsonPayload.message' are required parameters. Output is logs matching all filter conditions.\nSOURCE: https://github.com/firebase/extensions/blob/next/firestore-bigquery-export/guides/OBSERVABILITY.md#_snippet_5\n\nLANGUAGE: plaintext\nCODE:\n```\nresource.labels.function_name=\\\"ext-<EXTENSION_INSTANCE_ID>-syncBigQuery\\\"\\nAND jsonPayload.message=\\\"Firestore event received by onDispatch trigger\\\"\n```\n\n----------------------------------------\n\nTITLE: Configuring Firebase Hosting Rewrites for Bundle Serving (JSON)\nDESCRIPTION: This JSON configuration snippet is for the `firebase.json` file. It sets up a rewrite rule for Firebase Hosting, directing requests made to `/bundles/*` to the Cloud Function deployed by the Firestore Bundle Builder extension (`ext-firestore-bundle-builder-serve`). This enables caching of the data bundles via Firebase Hosting's CDN for improved performance.\nSOURCE: https://github.com/firebase/extensions/blob/next/docs/firestore-bundle-builder/get-started.md#_snippet_0\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"hosting\": {\n    \"ignore\": [\"firebase.json\", \"**/.*\", \"**/node_modules/**\"],\n    \"rewrites\": [\n      {\n        \"source\": \"/bundles/*\",\n        \"function\": \"ext-firestore-bundle-builder-serve\"\n      }\n    ]\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Adding a Document to Firestore to Trigger Email - Firebase Admin SDK - JavaScript\nDESCRIPTION: This JavaScript snippet demonstrates how to use the Firebase Admin SDK to add a document to the 'mail' collection in Firestore, which triggers the extension to send an email. The document defines the recipient, as well as subject and HTML body for the message. Requires Firebase Admin SDK to be properly initialized. The key parameters are 'to' (email recipient) and 'message' (email content). Expected input: email fields as shown, output: triggers email delivery if the extension is installed and configured.\nSOURCE: https://github.com/firebase/extensions/blob/next/firestore-send-email/README.md#_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nadmin.firestore().collection('mail').add({\n  to: 'someone@example.com',\n  message: {\n    subject: 'Hello from Firebase!',\n    html: 'This is an <code>HTML</code> email body.',\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Cleaning Local Build Artifacts using Shell\nDESCRIPTION: This shell script iterates through specified package directories (`firestore-bigquery-change-tracker`, `scripts/gen-schema-view`, `scripts/import`, `functions`, and the root directory `.`) within the `firestore-bigquery-export` extension project. For each directory, it executes `npm run clean` to remove build artifacts and then deletes the `node_modules` folder to ensure a clean state before building. It uses `pushd` and `popd` to manage directory changes.\nSOURCE: https://github.com/firebase/extensions/blob/next/firestore-bigquery-export/CONTRIBUTING.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nexport PKGS=\"firestore-bigquery-change-tracker scripts/gen-schema-view scripts/import functions .\"\n\nfor pkg in $PKGS;\ndo\n  pushd . && cd $pkg && npm run clean && rm -rf node_modules\n  popd\ndone;\n```\n\n----------------------------------------\n\nTITLE: Building Extension Packages Sequentially using Shell and npm\nDESCRIPTION: This shell script defines the build order for the extension's packages (`firestore-bigquery-change-tracker`, `scripts/import`, the root package `.`, `scripts/gen-schema-view`). It iterates through these package directories, changes into each directory using `pushd`, runs `npm install` to install dependencies (including the locally linked ones if the previous step was performed), and then executes `npm run build` to compile the package. `popd` returns to the original directory after each package build. Requires `npm` and Node.js to be installed.\nSOURCE: https://github.com/firebase/extensions/blob/next/firestore-bigquery-export/CONTRIBUTING.md#_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\nexport PKGS=\"firestore-bigquery-change-tracker scripts/import . scripts/gen-schema-view\"\n\nfor pkg in $PKGS;\ndo\n pushd . && cd $pkg && npm install && npm run build\n popd\ndone;\n```\n\n----------------------------------------\n\nTITLE: Inserting Mail Document Using Firebase Admin SDK - JavaScript\nDESCRIPTION: This JavaScript snippet demonstrates how to programmatically add an email document to the Firestore mail collection using the Firebase Admin SDK. It requires the Admin SDK to be initialized and the extension configured. The function sends an email by specifying recipient(s) in the 'to' field and message details, and logs a confirmation once queued. Expected input is a properly structured object, and output is a newly added Firestore document for extension processing. Constraints include requiring the Admin SDK and proper permissions.\nSOURCE: https://github.com/firebase/extensions/blob/next/firestore-send-email/POSTINSTALL.md#_snippet_1\n\nLANGUAGE: JavaScript\nCODE:\n```\nadmin\n  .firestore()\n  .collection(\"${param:MAIL_COLLECTION}\")\n  .add({\n    to: \"someone@example.com\",\n    message: {\n      subject: \"Hello from Firebase!\",\n      text: \"This is the plaintext section of the email body.\",\n      html: \"This is the <code>HTML</code> section of the email body.\",\n    },\n  })\n  .then(() => console.log(\"Queued email for delivery!\"));\n```\n\n----------------------------------------\n\nTITLE: Adding Data to Firebase Realtime Database using Push (JavaScript)\nDESCRIPTION: This snippet shows the recommended method for adding data to the Firebase Realtime Database using the `push()` function from the Firebase Web SDK. Using `push()` generates a unique, chronologically ordered key for the new data node, which is useful for lists like messages processed by the extension.\nSOURCE: https://github.com/firebase/extensions/blob/next/samples/rtdb-uppercase-messages/POSTINSTALL.md#_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfirebase.database().ref().push()\n```\n\n----------------------------------------\n\nTITLE: Querying BigQuery Timestamps from Schema View (SQL)\nDESCRIPTION: Example BigQuery SQL query to retrieve user names and their last login timestamps from a schema view generated by the 'fs-bq-schema-views' script. It queries the '_latest' view corresponding to a specific schema file and orders the results by the login timestamp in descending order. Requires substituting `${param:PROJECT_ID}`, `${param:DATASET_ID}`, `${param:TABLE_ID}`, and `${SCHEMA_FILE_NAME}` with actual values.\nSOURCE: https://github.com/firebase/extensions/blob/next/firestore-bigquery-export/guides/EXAMPLE_QUERIES.md#_snippet_1\n\nLANGUAGE: sql\nCODE:\n```\nSELECT name, last_login\nFROM ${param:PROJECT_ID}.${param:DATASET_ID}.${param:TABLE_ID}_schema_${SCHEMA_FILE_NAME}_latest\nORDER BY last_login DESC\n```\n\n----------------------------------------\n\nTITLE: Querying Partitioned Tables in BigQuery - SQL\nDESCRIPTION: This SQL snippet demonstrates how to query all records from a partitioned BigQuery table where the partitioning field 'created' matches a specific date (here, \\\"2022-04-18\\\"). The partitioned table must exist, and 'created' must be defined as the partition column of type DATETIME. The query pulls up to 1000 records, optimizing performance by leveraging partition pruning on the 'created' field. Prerequisites: a partitioned BigQuery table with the specified schema and date partitioning enforced. Input is the target partition value, output is a result set limited to 1000 rows.\nSOURCE: https://github.com/firebase/extensions/blob/next/docs/firestore-bigquery-export/Partitioning.md#_snippet_0\n\nLANGUAGE: sql\nCODE:\n```\nSELECT * FROM `example_dataset.table_raw_changelog`\\nWHERE created = \"2022-04-18\"\\nLIMIT 1000\n```\n\n----------------------------------------\n\nTITLE: Deleting Stale Data from BigQuery Changelog Table (SQL)\nDESCRIPTION: BigQuery SQL query to delete historical data from the raw changelog table created by the 'Stream Firestore to BigQuery' extension. It removes all document versions except the latest one, provided they are older than a specified interval (e.g., 1 month). Requires substituting `[PROJECT ID]`, `[DATASET ID]`, and `[CHANGELOG TABLE ID]` with actual values.\nSOURCE: https://github.com/firebase/extensions/blob/next/firestore-bigquery-export/guides/EXAMPLE_QUERIES.md#_snippet_5\n\nLANGUAGE: sql\nCODE:\n```\n/* The query below deletes any rows below that are over one month old. */\nDELETE FROM `[PROJECT ID].[DATASET ID].[CHANGELOG TABLE ID]`\nWHERE (document_name, timestamp) IN\n(\n  WITH latest AS (\n    SELECT MAX(timestamp) as timestamp, document_name\n    FROM `[PROJECT ID].[DATASET ID].[CHANGELOG TABLE ID]`\n    GROUP BY document_name\n  )\n  SELECT (t.document_name, t.timestamp)\n  FROM `[PROJECT ID].[DATASET ID].[CHANGELOG TABLE ID]` AS t\n  JOIN latest  ON (t.document_name = latest.document_name )\n  WHERE t.timestamp != latest.timestamp\n  AND DATETIME(t.timestamp) < DATE_ADD(CURRENT_DATETIME(), INTERVAL -1 MONTH)\n)\n```\n\n----------------------------------------\n\nTITLE: Example Query Definition in JavaScript\nDESCRIPTION: This JavaScript snippet illustrates how to define a named query called 'products' using the `QueryDefinition` and `QueryCondition` structures. The query targets the 'products' collection, applies a `where` filter to find documents where 'type' equals 'featured', and limits the results to 10 documents.\nSOURCE: https://github.com/firebase/extensions/blob/next/docs/firestore-bundle-builder/api-reference.md#_snippet_5\n\nLANGUAGE: javascript\nCODE:\n```\n```js\nqueries: {\n  products: {\n    collection: ‘products’,\n    conditions: [\n      { where: [‘type’, ‘==’, ‘featured’] },\n      { limit: 10 },\n    ],\n  }\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Installing Firebase Extension via CLI (Bash)\nDESCRIPTION: This command uses the Firebase CLI to install a Firebase extension into a specified project. Although the surrounding text discusses the 'Limit Child Nodes' extension, this specific command installs the 'storage-resize-images' extension. Replace `projectId-or-alias` with your actual Firebase project ID or alias.\nSOURCE: https://github.com/firebase/extensions/blob/next/docs/rtdb-limit-child-nodes/get-started.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nfirebase ext:install firebase/storage-resize-images --project=projectId-or-alias\n```\n\n----------------------------------------\n\nTITLE: Querying Path Parameters in BigQuery - SQL\nDESCRIPTION: This SQL snippet demonstrates how to query the JSON-encoded wildcard column (e.g., 'path_params') using JSON_VALUE to extract specific path variables such as 'regionId'. It assumes a BigQuery table (here 'dataset.countries_raw_changelog') that contains a 'path_params' column with serialized JSON objects mapping wildcard variables. The snippet filters records where the 'regionId' is 'South America' and returns corresponding 'document_id' values. This query requires BigQuery SQL syntax and expects the 'path_params' column in each row.\nSOURCE: https://github.com/firebase/extensions/blob/next/docs/firestore-bigquery-export/Wildcards.md#_snippet_1\n\nLANGUAGE: SQL\nCODE:\n```\nSELECT document_id FROM `dataset.countries_raw_changelog` c\nWHERE JSON_VALUE(c.path_params, \"$.regionId\") = \"South America\"\n```\n\n----------------------------------------\n\nTITLE: Defining a Handlebars Email Template Document in Firestore - JavaScript (JSX)\nDESCRIPTION: This snippet represents a Firestore document structure defining a Handlebars email template, including dynamic subject, HTML content, and an attachments array. The example demonstrates how to use handlebars placeholders such as {{username}}, {{name}}, and {{imagePath}} throughout the template. Required dependencies are a properly configured Firestore collection and the Trigger Email from Firestore extension. The key parameters are 'subject', 'html', and 'attachments', each utilizing Handlebars expressions. Inputs are template data for merging, outputs are the rendered email content when the extension processes a matching template.\nSOURCE: https://github.com/firebase/extensions/blob/next/docs/firestore-send-email/use-handlebars-template.md#_snippet_0\n\nLANGUAGE: jsx\nCODE:\n```\n{\\n\\u00a0 subject: \\\"@{{username}} is now following you!\\\",\\n\\u00a0 html: \\\"Just writing to let you know that <code>@{{username}}</code> ({{name}}) is now following you.\\\",\\n\\u00a0 attachments: [\\n\\u00a0\\u00a0\\u00a0{\\n\\u00a0\\u00a0\\u00a0 filename: \\\"{{username}}.jpg\\\",\\n\\u00a0\\u00a0\\u00a0 path: \\\"{{imagePath}}\\\"\\n\\u00a0\\u00a0\\u00a0}\\n\\u00a0 ]\\n}\n```\n\n----------------------------------------\n\nTITLE: Querying Specific Array Elements in BigQuery Schema View (SQL)\nDESCRIPTION: Example BigQuery SQL query to retrieve the first element (index 0) of an array field (`favorite_numbers`) for each document in a specific schema view. It filters the results based on the array index. Assumes the schema view table name follows the pattern `${param:PROJECT_ID}.users.users_schema_user_full_schema_latest`.\nSOURCE: https://github.com/firebase/extensions/blob/next/firestore-bigquery-export/guides/EXAMPLE_QUERIES.md#_snippet_3\n\nLANGUAGE: sql\nCODE:\n```\nSELECT document_name, favorite_numbers_member\nFROM ${param:PROJECT_ID}.users.users_schema_user_full_schema_latest\nWHERE favorite_numbers_index = 0\n```\n\n----------------------------------------\n\nTITLE: Querying Raw Changelog Table in BigQuery SQL\nDESCRIPTION: Executes a SQL query to select all records from the raw changelog table in BigQuery. This table logs every change (create, update, delete) to documents in the specified Firestore collection as individual rows. Requires the `BIGQUERY_PROJECT_ID`, `DATASET_ID`, and `TABLE_ID` parameters defined during extension setup.\nSOURCE: https://github.com/firebase/extensions/blob/next/firestore-bigquery-export/POSTINSTALL.md#_snippet_0\n\nLANGUAGE: sql\nCODE:\n```\nSELECT *\nFROM `${param:BIGQUERY_PROJECT_ID}.${param:DATASET_ID}.${param:TABLE_ID}_raw_changelog`\n```\n\n----------------------------------------\n\nTITLE: Counting Array Elements in BigQuery Schema View (SQL)\nDESCRIPTION: Example BigQuery SQL query to count the number of elements in an array field (`favorite_numbers`) for each document in a specific schema view. It groups results by document name and uses `MAX(array_index)` to determine the count. Assumes the schema view table name follows the pattern `${param:PROJECT_ID}.users.users_schema_user_full_schema_latest`.\nSOURCE: https://github.com/firebase/extensions/blob/next/firestore-bigquery-export/guides/EXAMPLE_QUERIES.md#_snippet_2\n\nLANGUAGE: sql\nCODE:\n```\nSELECT document_name, MAX(favorite_numbers_index)\nFROM ${param:PROJECT_ID}.users.users_schema_user_full_schema_latest\nGROUP BY document_name\n```\n\n----------------------------------------\n\nTITLE: Importing Firebase Eventarc and Admin SDK Modules in Node.js\nDESCRIPTION: Imports the Eventarc event handler, the logger utility, and initializes Firebase Admin SDK modules for app setup and Firestore usage. These imports are required for handling custom events and interacting with Firestore within your cloud function. Ensure all modules are installed and configured before using them in exported handlers.\nSOURCE: https://github.com/firebase/extensions/blob/next/docs/storage-resize-images/handle-resize-image-extension-events.md#_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nconst { onCustomEventPublished } = require(\"firebase-functions/v2/eventarc\");\nconst logger = require(\"firebase-functions/logger\");\nconst { initializeApp } = require(\"firebase-admin/app\");\nconst { getFirestore } = require(\"firebase-admin/firestore\");\n```\n\n----------------------------------------\n\nTITLE: Querying Firestore-to-BigQuery Changelog View for Schema Verification (SQL)\nDESCRIPTION: These SQL snippets query the generated BigQuery schema views to verify data ingestion and schema conformity from Firestore. Each query selects fields (document_name, name, age) from the appropriate changelog or latest views, filtering for a test document. Inputs are the specific project, dataset, and table/view names interpolated from environment variables or user parameters. The results demonstrate the mapping (or loss) of type-mismatched/removed fields as NULLs, aligning with the validated schema. If the document does not exist or field types do not match, columns return NULL or no results.\nSOURCE: https://github.com/firebase/extensions/blob/next/docs/firestore-bigquery-export/generating-schemas.md#_snippet_3\n\nLANGUAGE: sql\nCODE:\n```\nSELECT document_name, name, age\\nFROM ${param:PROJECT_ID}.${param:DATASET_ID}.${param:TABLE_ID}_schema_test_schema_changelog\\nWHERE document_name = \\\"test-schema-document\\\"\\n\n```\n\nLANGUAGE: sql\nCODE:\n```\nSELECT document_name, name, age\\nFROM ${param:PROJECT_ID}.${param:DATASET_ID}.${param:TABLE_ID}_schema_test_schema_changelog\\nWHERE document_name = \\\"test-schema-document\\\"\\n\n```\n\nLANGUAGE: sql\nCODE:\n```\nSELECT document_name, name, age\\nFROM ${param:PROJECT_ID}.${param:DATASET_ID}.${param:TABLE_ID}_schema_test_schema_latest\\nWHERE document_name = \\\"test-schema-document\\\"\\n\n```\n\n----------------------------------------\n\nTITLE: Defining the BundleDocument Interface in TypeScript\nDESCRIPTION: This TypeScript interface defines the structure for a single document within the configured Firestore collection used by the Bundle Builder API. It specifies properties for including specific document IDs (`docs`), defining named queries (`queries`), setting up parameters (`params`), and configuring client-side, server-side (Firebase Hosting CDN), and file caching (`clientCache`, `serverCache`, `fileCache`). The `notBefore` timestamp applies specifically to file caching.\nSOURCE: https://github.com/firebase/extensions/blob/next/docs/firestore-bundle-builder/api-reference.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\ntype BundleDocument = {\n  // A list of document IDs to serve in the bundle.\n  docs?: Array<string>;\n  // A map containing individual named queries and their definitions.\n  queries?: Map<string, QueryDefinition[]>;\n  // A map of parameters and their definitions, which can be provided to a query definition.\n  params?: Map<string, ParamDefinition>;\n  // Specifies how long to keep the bundle in the client's cache, in seconds. If not defined, client-side cache is disabled.\n  clientCache?: string;\n  // Only used in combination with Firebase Hosting. Specifies how long to keep the bundle in Firebase Hosting CDN cache, in seconds.\n  serverCache: string;\n  // Specifies how long (in seconds) to keep the bundle in a Cloud Storage bucket, in seconds. If not defined, Cloud Storage bucket is not accessed.\n  fileCache?: string;\n  // If a 'File Cache' is specified, bundles created before this timestamp will not be file cached.\n  notBefore?: Timestamp;\n};\n```\n```\n\n----------------------------------------\n\nTITLE: Defining the QueryCondition Interface in TypeScript\nDESCRIPTION: This TypeScript interface defines the structure for a single condition within the `conditions` array of a `QueryDefinition`. Each `QueryCondition` object should represent only one type of Firestore query operation, such as filtering (`where`), ordering (`orderBy`), limiting results (`limit`, `limitToLast`), offsetting (`offset`), or specifying cursor points (`startAt`, `startAfter`, `endAt`, `endBefore`).\nSOURCE: https://github.com/firebase/extensions/blob/next/docs/firestore-bundle-builder/api-reference.md#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\ntype QueryCondition = {\n  // Performs a `where` filter on the collection on a given FieldPath, operator and value.\n  where?: [\n    string,\n    (\n      | \"<\"\n      | \"<=\"\n      | \"==\"\n      | \">=\"\n      | \">\"\n      | \"!=\"\n      | \"array-contains\"\n      | \"in\"\n      | \"not-in\"\n      | \"array-contains-any\"\n    ),\n    any\n  ];\n  orderBy?: [string, (\"asc\" | \"desc\")?];\n  limit?: number;\n  limitToLast?: number;\n  offset?: number;\n  startAt?: string;\n  startAfter?: string;\n  endAt?: string;\n  endBefore?: string;\n};\n```\n```\n\n----------------------------------------\n\nTITLE: Defining a Template Partial for Handlebars Email Templates - JavaScript (JSX)\nDESCRIPTION: This JSX code snippet provides the structure of a Firestore document representing a reusable Handlebars template partial, such as a footer for emails. The 'partial: true' flag indicates to the Firebase extension that this document is to be registered as a partial. 'html' and 'text' fields can be referenced in other templates via the partial syntax. Inputs include the partial's body for both HTML and plaintext; outputs are dynamically included fragments in emails. Dependencies are the Firestore extension and Handlebars' partials support as orchestrated by Firebase.\nSOURCE: https://github.com/firebase/extensions/blob/next/docs/firestore-send-email/use-handlebars-template.md#_snippet_2\n\nLANGUAGE: jsx\nCODE:\n```\n{\\n\\u00a0 partial: true,\\n\\u00a0 html: \\\"<p>This mail was sent by ExampleApp, Inc. <a href='https://example.com/unsubscribe'>Unsubscribe</a></p>\\\",\\n\\u00a0 text: \\\"This mail was sent by ExampleApp, Inc. Unsubscribe here: https://example.com/unsubscribe\\\"\\n}\n```\n\n----------------------------------------\n\nTITLE: Setting up Google Cloud Authentication for Script (Bash)\nDESCRIPTION: Authenticates the local environment using Google Cloud Application Default Credentials (ADC). This command opens a browser window for login and grants the necessary permissions (like `bigquery.datasets.create`) for the import script to interact with BigQuery. This is a prerequisite for running the `fs-bq-import-collection` script.\nSOURCE: https://github.com/firebase/extensions/blob/next/docs/firestore-bigquery-export/importing-data.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngcloud auth application-default login\n```\n\n----------------------------------------\n\nTITLE: Defining Firestore-to-BigQuery Event Payload Structure in JSON\nDESCRIPTION: This JSON snippet defines the structure of the payload sent to a custom transform function URL by the Firestore to BigQuery Firebase Extension. It includes an array `data` containing objects with event metadata (`timestamp`, `event_id`, `document_name`, `document_id`, `operation`) and the Firestore document `data` itself (as a string). The transform function receives this payload, modifies it as needed, and the returned data is then saved into the BigQuery table.\nSOURCE: https://github.com/firebase/extensions/blob/next/docs/firestore-bigquery-export/transforming-data.md#_snippet_0\n\nLANGUAGE: json\nCODE:\n```\n```json\n{\n  data: [{\n    insertId: int;\n    json: {\n      timestamp: int;\n      event_id: int;\n      document_name: string;\n      document_id: int;\n      operation: ChangeType;\n      data: string;\n    },\n  }]\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Authenticating gcloud Credentials for BigQuery Jobs (Bash)\nDESCRIPTION: This Bash snippet uses the gcloud CLI to authenticate and set Application Default Credentials required by the schema-views script for BigQuery access. Prerequisite: Google Cloud SDK installed and gcloud authenticated. The command initiates a browser-based login and stores credentials. After execution, the environment is able to submit BigQuery jobs via the schema-views tool or compatible SDKs. If no credentials are present, BigQuery operations will fail due to missing authentication.\nSOURCE: https://github.com/firebase/extensions/blob/next/docs/firestore-bigquery-export/generating-schemas.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ngcloud auth application-default login\\n\n```\n\n----------------------------------------\n\nTITLE: Defining Payload Structure for Transform Functions - JSON\nDESCRIPTION: Specifies the expected data structure passed to (and returned from) a transform function used by the Firestore to BigQuery import process. The transform service receives an array of data objects, each representing a Firestore document change event, and expects a response with the same structure. Key fields include 'insertId', 'json' property details (such as 'timestamp', 'event_id', 'document_name', 'operation', and the 'data' payload as a string). This informs providers on how to shape their transform function input/output.\nSOURCE: https://github.com/firebase/extensions/blob/next/firestore-bigquery-export/guides/IMPORT_EXISTING_DOCUMENTS.md#_snippet_6\n\nLANGUAGE: json\nCODE:\n```\n{\n  data: [{\n    insertId: int;\n    json: {\n      timestamp: int;\n      event_id: int;\n      document_name: string;\n      document_id: int;\n      operation: ChangeType;\n      data: string;\n    },\n  }]\n}\n```\n\n----------------------------------------\n\nTITLE: Running the Firestore to BigQuery Import Script Interactively (Bash)\nDESCRIPTION: Executes the `fs-bq-import-collection` script using `npx`. This command initiates an interactive session prompting the user for necessary parameters like Firebase Project ID, Firestore Collection Path, and BigQuery Dataset ID. The script reads documents from the specified Firestore collection and inserts them into the BigQuery raw changelog table. Requires Node.js, npm, and gcloud authentication to be set up.\nSOURCE: https://github.com/firebase/extensions/blob/next/docs/firestore-bigquery-export/importing-data.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nnpx @firebaseextensions/fs-bq-import-collection\n\n```\n\n----------------------------------------\n\nTITLE: Transform Function Payload Structure - Plaintext Example\nDESCRIPTION: Defines the expected data structure for the HTTP transform function used before exporting changes to BigQuery. The payload contains an array of data objects with fields such as timestamp, event_id, document_name, document_id, operation, and data. The function should return an identical structure. Serves as a contract for custom HTTP handlers integrating with the extension.\nSOURCE: https://github.com/firebase/extensions/blob/next/firestore-bigquery-export/README.md#_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\n{ \\n  data: [{\\n    insertId: int;\\n    json: {\\n      timestamp: int;\\n      event_id: int;\\n      document_name: string;\\n      document_id: int;\\n      operation: ChangeType;\\n      data: string;\\n    },\\n  }]\\n}\\n\n```\n\n----------------------------------------\n\nTITLE: Defining Payload Structure for Firestore BigQuery Transform Function (JSON)\nDESCRIPTION: This JSON structure represents the payload sent to an optional HTTP function when the Firestore to BigQuery extension processes a document change. The function can transform the data before it's sent to BigQuery. The payload contains an array 'data' with objects detailing the change, including timestamp, event ID, document details, operation type, and the document data itself.\nSOURCE: https://github.com/firebase/extensions/blob/next/firestore-bigquery-export/PREINSTALL.md#_snippet_0\n\nLANGUAGE: json\nCODE:\n```\n{\n  data: [{\n    insertId: int;\n    json: {\n      timestamp: int;\n      event_id: int;\n      document_name: string;\n      document_id: int;\n      operation: ChangeType;\n      data: string;\n    },\n  }]\n}\n```\n\n----------------------------------------\n\nTITLE: Running Firestore-to-BigQuery Import Script Interactively - Shell\nDESCRIPTION: This shell snippet shows how to run the Firestore import script using npx, which allows execution of the package without installing it globally. The script prompts the user for necessary inputs and facilitates batch import of Firestore data into BigQuery. Ensure dependencies like Node.js and Application Default Credentials are properly set before running.\nSOURCE: https://github.com/firebase/extensions/blob/next/firestore-bigquery-export/guides/IMPORT_EXISTING_DOCUMENTS.md#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\nnpx @firebaseextensions/fs-bq-import-collection\n```\n\n----------------------------------------\n\nTITLE: Running fs-bq-schema-views Script Interactively (Bash)\nDESCRIPTION: Runs the `fs-bq-schema-views` script using `npx` in interactive mode. This mode prompts the user for configuration details like Firebase Project ID, BigQuery Project ID, dataset ID, table prefix, Firestore collection path, Google AI API key, and schema output directory/filename to generate a schema using Gemini AI based on Firestore data.\nSOURCE: https://github.com/firebase/extensions/blob/next/firestore-bigquery-export/guides/GENERATE_SCHEMA_VIEWS.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpx @firebaseextensions/fs-bq-schema-views\n```\n\n----------------------------------------\n\nTITLE: Adding Multiple Fields for Translation in Firestore (JavaScript)\nDESCRIPTION: Demonstrates adding a document to a Firestore collection named 'translations' using the Firebase Admin SDK in JavaScript. The document contains a map with multiple string fields ('first' and 'second') intended for translation by the extension when configured to handle map inputs.\nSOURCE: https://github.com/firebase/extensions/blob/next/firestore-translate-text/PREINSTALL.md#_snippet_0\n\nLANGUAGE: js\nCODE:\n```\nadmin.firestore().collection('translations').add({\n  first: \"My name is Bob\",\n  second: \"Hello, friend\"\n})\n```\n\n----------------------------------------\n\nTITLE: Adding Multiple Fields for Translation in Firestore using JavaScript\nDESCRIPTION: This JavaScript snippet demonstrates adding a new document to the 'translations' Firestore collection using the Firebase Admin SDK. It includes multiple fields ('first', 'second'), each containing a string intended for translation by the Firebase Translate Text extension. This structure allows the extension to process and translate multiple strings within a single document write when configured for multiple field translations. Requires the Firebase Admin SDK to be initialized.\nSOURCE: https://github.com/firebase/extensions/blob/next/firestore-translate-text/README.md#_snippet_0\n\nLANGUAGE: js\nCODE:\n```\nadmin.firestore().collection('translations').add({\n  first: \"My name is Bob\",\n  second: \"Hello, friend\"\n})\n```\n\n----------------------------------------\n\nTITLE: Granting Cross-Project BigQuery Access via Bash Script\nDESCRIPTION: Downloads and executes a Bash script to grant the Firebase extension's service account the necessary BigQuery permissions on a target Google Cloud project different from the Firebase project. This enables cross-project data streaming. Requires the gcloud CLI to be installed and configured, along with appropriate IAM permissions on the target project. The script takes the source Firebase project ID, target BigQuery project ID, and an optional extension instance ID as arguments.\nSOURCE: https://github.com/firebase/extensions/blob/next/firestore-bigquery-export/README.md#_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\ncurl -O https://raw.githubusercontent.com/firebase/extensions/master/firestore-bigquery-export/scripts/grant-crossproject-access.sh\nchmod +x grant-crossproject-access.sh\n./grant-crossproject-access.sh -f SOURCE_FIREBASE_PROJECT -b TARGET_BIGQUERY_PROJECT [-i EXTENSION_INSTANCE_ID]\n```\n\n----------------------------------------\n\nTITLE: Querying Latest View in BigQuery SQL\nDESCRIPTION: Executes a SQL query to select all records from the latest view in BigQuery. This view represents the current state of each document in the mirrored Firestore collection, showing only the most recent change event per document. Requires the `BIGQUERY_PROJECT_ID`, `DATASET_ID`, and `TABLE_ID` parameters defined during extension setup.\nSOURCE: https://github.com/firebase/extensions/blob/next/firestore-bigquery-export/POSTINSTALL.md#_snippet_1\n\nLANGUAGE: sql\nCODE:\n```\nSELECT *\nFROM `${param:BIGQUERY_PROJECT_ID}.${param:DATASET_ID}.${param:TABLE_ID}_raw_latest`\n```\n\n----------------------------------------\n\nTITLE: Granting Cross-Project BigQuery Access via PowerShell Script\nDESCRIPTION: Downloads and executes a PowerShell script for Windows environments to grant the Firebase extension's service account the necessary BigQuery permissions on a target Google Cloud project different from the Firebase project. This facilitates cross-project data streaming. Prerequisites include having the gcloud CLI installed and configured, and sufficient IAM permissions on the target BigQuery project. The script accepts the source Firebase project ID, target BigQuery project ID, and an optional extension instance ID as parameters.\nSOURCE: https://github.com/firebase/extensions/blob/next/firestore-bigquery-export/README.md#_snippet_6\n\nLANGUAGE: powershell\nCODE:\n```\nInvoke-WebRequest -Uri \"https://raw.githubusercontent.com/firebase/extensions/master/firestore-bigquery-export/scripts/grant-crossproject-access.ps1\" -OutFile \"grant-crossproject-access.ps1\"\n.\\grant-crossproject-access.ps1 -FirebaseProject SOURCE_FIREBASE_PROJECT -BigQueryProject TARGET_BIGQUERY_PROJECT [-ExtensionInstanceId EXTENSION_INSTANCE_ID]\n```\n\n----------------------------------------\n\nTITLE: Firestore Email Document with SendGrid Categories - JSON\nDESCRIPTION: This JSON example shows the required format for Firestore Send-Email extension documents when using SendGrid and email categories. Dependencies are the SendGrid-compatible SMTP connection and extension configuration. The 'categories' field enables categorization, while 'to' and 'message' fields specify recipients and content. Expected input is a document matching this structure, and the output is categorized emails sent through SendGrid. Limitations include requiring SendGrid as the underlying provider and correct setup of the extension.\nSOURCE: https://github.com/firebase/extensions/blob/next/firestore-send-email/POSTINSTALL.md#_snippet_2\n\nLANGUAGE: JSON\nCODE:\n```\n{\n  \"to\": [\"example@example.com\"],\n  \"categories\": [\"Example_Category\"],\n  \"message\": {\n    \"subject\": \"Test Email with Categories\",\n    \"text\": \"This is a test email to see if categories work.\",\n    \"html\": \"<strong>This is a test email to see if categories work.</strong>\"\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Running Firestore BigQuery Import with a Transform Function - Shell\nDESCRIPTION: Provides a shell command using 'npx' to execute the Firebase Extensions script for bulk-importing Firestore collections into BigQuery, including applying an external transform function. The command uses several options: '--non-interactive' for headless execution, project ID, collection path, dataset ID, and the URL to the transform function. Users must substitute these placeholders with their actual project-specific values. This approach requires the '@firebaseextensions/fs-bq-import-collection' npm package and that the transform function endpoint is live and properly formatted.\nSOURCE: https://github.com/firebase/extensions/blob/next/firestore-bigquery-export/guides/IMPORT_EXISTING_DOCUMENTS.md#_snippet_7\n\nLANGUAGE: shell\nCODE:\n```\nnpx @firebaseextensions/fs-bq-import-collection --non-interactive \\\n -P <PROJECT_ID> \\\n -s <COLLECTION_PATH> \\\n -d <DATASET_ID> \\\n -f https://us-west1-my-project.cloudfunctions.net/transformFunction\n```\n\n----------------------------------------\n\nTITLE: Configuring Sharp Output Options for Image Resizing Extension\nDESCRIPTION: This JSON example illustrates the format for the 'Output options for selected formats' parameter in the Firebase image resizing extension. It allows specifying advanced output settings from the Sharp library for different image formats (like JPEG quality or PNG palette). The value should be provided as a stringified JSON object without outer quotes or indentation in the extension configuration.\nSOURCE: https://github.com/firebase/extensions/blob/next/storage-resize-images/POSTINSTALL.md#_snippet_1\n\nLANGUAGE: js\nCODE:\n```\n{\"jpeg\": {\"quality\": 5,\"chromaSubsampling\": '4:4:4'}, \"png\": { \"pallete\": true}}\n```\n\n----------------------------------------\n\nTITLE: Defining Firestore Schema for BigQuery Views (JSON)\nDESCRIPTION: A JSON configuration file defining the schema of Firestore documents. This schema is used by the 'fs-bq-schema-views' script to generate corresponding BigQuery views over the raw changelog data exported by the 'Stream Firestore to BigQuery' extension. It specifies field names and their data types (string, array, timestamp, geopoint, map).\nSOURCE: https://github.com/firebase/extensions/blob/next/firestore-bigquery-export/guides/EXAMPLE_QUERIES.md#_snippet_0\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"fields\": [\n    {\n      \"name\": \"name\",\n      \"type\": \"string\"\n    },\n    {\n      \"name\":\"favorite_numbers\",\n      \"type\": \"array\"\n    },\n    {\n      \"name\": \"last_login\",\n      \"type\": \"timestamp\"\n    },\n    {\n      \"name\": \"last_location\",\n      \"type\": \"geopoint\"\n    },\n    {\n      \"fields\": [\n        {\n          \"name\": \"name\",\n          \"type\": \"string\"\n        }\n      ],\n      \"name\": \"friends\",\n      \"type\": \"map\"\n    }\n  ]\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Schema Files for BigQuery View Generation (JSON)\nDESCRIPTION: These JSON snippets define schema files to specify field names and types for Firestore-to-BigQuery schema view generation. Each schema file requires a 'fields' array representing each top-level field, with possible subfields for 'map' types. Supported field types must align with Firestore data types, and 'column_name' can be used to resolve reserved word conflicts. The schema files are consumed as input by the fs-bq-schema-views script. The expected output is a correctly structured JSON file, with at least one supported type per 'fields' array. Improper structure, missing required fields, or unsupported types will result in errors.\nSOURCE: https://github.com/firebase/extensions/blob/next/docs/firestore-bigquery-export/generating-schemas.md#_snippet_0\n\nLANGUAGE: json\nCODE:\n```\n{\\n  \\\"fields\\\": [\\n    {\\n      \\\"name\\\": \\\"name\\\",\\n      \\\"type\\\": \\\"string\\\"\\n    },\\n    {\\n      \\\"name\\\": \\\"age\\\",\\n      \\\"type\\\": \\\"number\\\"\\n    }\\n  ]\\n}\n```\n\nLANGUAGE: json\nCODE:\n```\n{\\n  \\\"fields\\\": [\\n    {\\n      \\\"name\\\": \\\"name\\\",\\n      \\\"type\\\": \\\"string\\\"\\n    },\\n    {\\n      \\\"name\\\": \\\"age\\\",\\n      \\\"type\\\": \\\"number\\\",\\n      \\\"column_name\\\": \\\"new_column_name\\\"\\n    }\\n  ]\\n}\n```\n\nLANGUAGE: json\nCODE:\n```\n{\\n  \\\"fields\\\": [\\n    {\\n      \\\"name\\\": \\\"name\\\",\\n      \\\"type\\\": \\\"string\\\"\\n    },\\n    {\\n      \\\"name\\\": \\\"favorite_numbers\\\",\\n      \\\"type\\\": \\\"array\\\"\\n    },\\n    {\\n      \\\"name\\\": \\\"last_login\\\",\\n      \\\"type\\\": \\\"timestamp\\\"\\n    },\\n    {\\n      \\\"name\\\": \\\"last_location\\\",\\n      \\\"type\\\": \\\"geopoint\\\"\\n    },\\n    {\\n      \\\"name\\\": \\\"geo_point\\\",\\n      \\\"type\\\": \\\"stringified_map\\\"\\n    },\\n    {\\n      \\\"fields\\\": [\\n        {\\n          \\\"name\\\": \\\"name\\\",\\n          \\\"type\\\": \\\"string\\\"\\n        }\\n      ],\\n      \\\"name\\\": \\\"friends\\\",\\n      \\\"type\\\": \\\"map\\\"\\n    }\\n  ]\\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Sharp Output Options for Image Conversion (JSON)\nDESCRIPTION: Example JSON configuration string for the 'Output options for selected formats' parameter. It demonstrates setting specific Sharp output options like quality and chroma subsampling for JPEG, and palette usage or compression level for PNG conversions. This allows fine-grained control over the output of converted images.\nSOURCE: https://github.com/firebase/extensions/blob/next/storage-resize-images/README.md#_snippet_1\n\nLANGUAGE: json\nCODE:\n```\n`{\"jpeg\": { \"quality\": 5, \"chromaSubsampling\": \"4:4:4\" }, \"png\": { \"palette\": true }}`\n```\n\nLANGUAGE: json\nCODE:\n```\n`{\"png\":{\"compressionLevel\":9}}`\n```\n\n----------------------------------------\n\nTITLE: Handling SQL Reserved Keywords in Manual Schema (JSON)\nDESCRIPTION: Demonstrates how to handle potential SQL reserved keyword conflicts within a manual JSON schema definition for `fs-bq-schema-views`. The `column_name` property provides an alternative, safe name (`event_timestamp`) for the resulting BigQuery column, while the original Firestore field name (`timestamp`), which is a reserved keyword, is still used for data extraction. This ensures the generated view doesn't cause SQL syntax errors.\nSOURCE: https://github.com/firebase/extensions/blob/next/firestore-bigquery-export/guides/GENERATE_SCHEMA_VIEWS.md#_snippet_3\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"fields\": [\n    {\n      \"name\": \"timestamp\", // SQL reserved keyword\n      \"type\": \"timestamp\",\n      \"column_name\": \"event_timestamp\" // Safe alternative name\n    }\n  ]\n}\n```\n\n----------------------------------------\n\nTITLE: Example BigQuery Clustering Column Configuration\nDESCRIPTION: An example demonstrating the comma-separated format for specifying column names in the 'Clustering' parameter of the Firebase BigQuery Export extension. This list defines the order in which BigQuery should cluster the table data to optimize queries. Note that BigQuery allows a maximum of four clustering fields; any extra fields listed beyond the fourth might be ignored or cause an error depending on the specific implementation.\nSOURCE: https://github.com/firebase/extensions/blob/next/docs/firestore-bigquery-export/Clustering.md#_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\ndocument_id, document_name, timestamp, event_id, data\n```\n\n----------------------------------------\n\nTITLE: Verifying Imported Documents in BigQuery Raw Changelog (SQL)\nDESCRIPTION: Counts the number of rows in the BigQuery raw changelog table that were added by the import script. This query filters records by the 'IMPORT' operation type. The result should match the number of documents in the source Firestore collection. Replace `${PROJECT_ID}`, `${COLLECTION_PATH}` with your specific values.\nSOURCE: https://github.com/firebase/extensions/blob/next/docs/firestore-bigquery-export/importing-data.md#_snippet_2\n\nLANGUAGE: sql\nCODE:\n```\nSELECT COUNT(*) FROM\n  `${PROJECT_ID}.${COLLECTION_PATH}.${COLLECTION_PATH}_raw_changelog`\n  WHERE operation = \"IMPORT\"\n\n```\n\n----------------------------------------\n\nTITLE: Installing the Firebase Delete User Data Extension via CLI - Bash\nDESCRIPTION: This Bash command installs the Firebase Delete User Data extension using the Firebase CLI. To run it, you must have the Firebase CLI installed and be authenticated. The '--project' parameter specifies the target Firebase project by ID or alias, and 'firebase/storage-resize-images' is the extension identifier. Replace 'projectId-or-alias' with your actual project identifier. The output of the command is interactive and may prompt for additional configuration options during installation.\nSOURCE: https://github.com/firebase/extensions/blob/next/docs/delete-user-data/get-started.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nfirebase ext:install firebase/storage-resize-images --project=projectId-or-alias\n\n```\n\n----------------------------------------\n\nTITLE: Installing Firestore-send-email Extension via Firebase CLI - Bash\nDESCRIPTION: This Bash command installs the 'firebase/firestore-send-email' extension using the Firebase CLI. Replace 'projectId-or-alias' with your actual Firebase project ID or alias. You must have the Firebase CLI installed and authenticated before running this command. Upon execution, the CLI will prompt for SMTP connection and Firestore collection details as required by the extension.\nSOURCE: https://github.com/firebase/extensions/blob/next/docs/firestore-send-email/get-started.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nfirebase ext:install firebase/firestore-send-email --project=projectId-or-alias\n```\n\n----------------------------------------\n\nTITLE: Installing Firebase BigQuery Extension via Firebase CLI (JavaScript)\nDESCRIPTION: This JavaScript code snippet provides the Firebase CLI command for installing the Firestore BigQuery Export extension, allowing users to automatically mirror Cloud Firestore collections into BigQuery tables and views. The command requires the Firebase CLI to be installed and a valid Firebase project ID or alias specified using the --project flag. Running this command will initiate the installation process, prompting the user for necessary configuration parameters such as dataset location, table ID, and BigQuery settings.\nSOURCE: https://github.com/firebase/extensions/blob/next/docs/firestore-bigquery-export/get-started.md#_snippet_0\n\nLANGUAGE: js\nCODE:\n```\nfirebase ext:install firebase/firestore-bigquery-export --project=projectId-or-alias\n```\n\n----------------------------------------\n\nTITLE: Filtering Logs for OnDispatch Trigger using Logs Explorer - plaintext\nDESCRIPTION: Shows how to filter logs related to the syncBigQuery (onDispatch) function via the Logs Explorer in Google Cloud. This filter targets logs from both Cloud Functions and Cloud Run services for a specific extension instance ID, isolating entries where the onDispatch trigger was used. Update the extension instance ID as needed. Main parameters include 'function_name', 'service_name', 'location', and a search string within log messages. The result is a filtered list of log entries for onDispatch-triggered Firestore events.\nSOURCE: https://github.com/firebase/extensions/blob/next/firestore-bigquery-export/guides/OBSERVABILITY.md#_snippet_1\n\nLANGUAGE: plaintext\nCODE:\n```\n(resource.type=\\\"cloud_function\\\" resource.labels.function_name=(\\\"ext-firestore-bigquery-export-syncBigQuery\\\") resource.labels.region=\\\"us-central1\\\") OR (resource.type=\\\"cloud_run_revision\\\" resource.labels.service_name=(\\\"ext-firestore-bigquery-export-syncBigQuery\\\") resource.labels.location=\\\"us-central1\\\") SEARCH(\\\"Firestore event received by onDispatch trigger\\\")\n```\n\n----------------------------------------\n\nTITLE: Defining Wildcard Path Parameters - JavaScript\nDESCRIPTION: This JavaScript snippet provides an example of a path parameters object generated when exporting Firestore data using a wildcard path such as 'regions/{regionId}/countries'. The object maps wildcard variable names to their values, which are serialized as a JSON string and stored in a BigQuery column. There are no external dependencies or required imports for this structure; its purpose is illustrative, showing the format and access method for these parameters within the data pipeline.\nSOURCE: https://github.com/firebase/extensions/blob/next/docs/firestore-bigquery-export/Wildcards.md#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\n{\n  regionId: \"Central America\";\n}\n```\n\n----------------------------------------\n\nTITLE: Filtering Logs by Log Message in Logs Explorer - plaintext\nDESCRIPTION: Shows how to filter log entries for those containing a specific message, in this case, indicating that an event was received by the onDispatch trigger. Useful for tracking which events were processed by the syncBigQuery function. The parameter 'jsonPayload.message' should match the corresponding log message string. Output will be event logs with the specified message.\nSOURCE: https://github.com/firebase/extensions/blob/next/firestore-bigquery-export/guides/OBSERVABILITY.md#_snippet_4\n\nLANGUAGE: plaintext\nCODE:\n```\njsonPayload.message=\\\"Firestore event received by onDispatch trigger\\\"\n```\n\n----------------------------------------\n\nTITLE: Querying Distinct Array Elements with Multiple Arrays (SQL)\nDESCRIPTION: Example BigQuery SQL query demonstrating how to retrieve distinct documents and a specific array element (first favorite number) when the schema contains multiple arrays. Using `DISTINCT` avoids duplicate rows that can result from the `CROSS JOIN` operations performed by the schema view generation script. Assumes the schema view table name follows the pattern `${param:PROJECT_ID}.users.users_schema_user_full_schema_latest`.\nSOURCE: https://github.com/firebase/extensions/blob/next/firestore-bigquery-export/guides/EXAMPLE_QUERIES.md#_snippet_4\n\nLANGUAGE: sql\nCODE:\n```\nSELECT DISTINCT document_name, favorite_numbers_member\nFROM ${param:PROJECT_ID}.users.users_schema_user_full_schema_latest\nWHERE favorite_numbers_index = 0\n```\n\n----------------------------------------\n\nTITLE: Example Where Condition with 'in' Operator in JavaScript\nDESCRIPTION: This JavaScript snippet shows how to structure a `where` condition using the `in` operator. Since nested arrays are not supported by Firestore for these operators (`in`, `not-in`, `array-contains-any`), array values must be provided as a single comma-separated string. The example demonstrates filtering documents where the 'category' field is either 'womens' or 'shorts'.\nSOURCE: https://github.com/firebase/extensions/blob/next/docs/firestore-bundle-builder/api-reference.md#_snippet_6\n\nLANGUAGE: javascript\nCODE:\n```\n```js\n{ where: [‘category’, ‘in’, ‘womens,shorts’] }, // [‘womens’, ‘shorts’]\n```\n```\n\n----------------------------------------\n\nTITLE: Running the Import Script with Failed Batch Output Option - Shell\nDESCRIPTION: This shell snippet shows how to run the import script with the optional -f flag to specify an output file for failed import batch document paths. This enables tracking of failed documents for troubleshooting or retrying imports. The specified file is cleared before writing new failed paths.\nSOURCE: https://github.com/firebase/extensions/blob/next/firestore-bigquery-export/guides/IMPORT_EXISTING_DOCUMENTS.md#_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\nnpx @firebaseextensions/fs-bq-import-collection -f failed_batches.txt\n```\n\n----------------------------------------\n\nTITLE: Structuring Categorized SendGrid Emails in Firestore (JSON)\nDESCRIPTION: This JSON snippet illustrates how to specify additional metadata, such as 'categories', when sending emails via SendGrid through the Firestore Send Email extension. Categories enable better email organization and analytics on SendGrid. The snippet expects an array for 'to' and 'categories'; the 'message' object contains typical email fields including both 'text' and 'html' variants. This document should be added to the Firestore mail collection.\nSOURCE: https://github.com/firebase/extensions/blob/next/firestore-send-email/PREINSTALL.md#_snippet_1\n\nLANGUAGE: JSON\nCODE:\n```\n{\n  \"to\": [\"example@example.com\"],\n  \"categories\": [\"Example_Category\"],\n  \"message\": {\n    \"subject\": \"Test Email with Categories\",\n    \"text\": \"This is a test email to see if categories work.\",\n    \"html\": \"<strong>This is a test email to see if categories work.</strong>\"\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Granting Cross-Project BigQuery Access via Bash Script\nDESCRIPTION: Provides Bash commands for Linux/Mac users to download, make executable, and run a script that grants the necessary BigQuery permissions to the extension's service account on a target project different from the Firebase project. Requires specifying the source Firebase project ID (`-f`) and the target BigQuery project ID (`-b`), with optional parameters for the extension instance ID (`-i`) and service account email (`-s`). Prerequisites include having the gcloud CLI installed and permissions to grant IAM roles on the target project.\nSOURCE: https://github.com/firebase/extensions/blob/next/firestore-bigquery-export/POSTINSTALL.md#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\ncurl -O https://raw.githubusercontent.com/firebase/extensions/master/firestore-bigquery-export/scripts/grant-crossproject-access.sh\nchmod +x grant-crossproject-access.sh\n./grant-crossproject-access.sh -f SOURCE_FIREBASE_PROJECT -b TARGET_BIGQUERY_PROJECT [-i EXTENSION_INSTANCE_ID] [-s SERVICE_ACCOUNT]\n```\n\n----------------------------------------\n\nTITLE: Granting Cross-Project BigQuery Access Using Bash Script for Firebase Extension (Bash)\nDESCRIPTION: This Bash code snippet automates the granting of BigQuery permissions to the Firebase extension's service account, enabling cross-project data export from Firestore to BigQuery. It requires the gcloud CLI to be installed and configured and sufficient IAM privileges on the target BigQuery project. Main parameters include -f for the source Firebase project ID, -b for the target BigQuery project ID, and an optional -i for the extension instance ID. The script is downloaded, made executable, and executed, facilitating seamless permissions setup on Linux or Mac systems.\nSOURCE: https://github.com/firebase/extensions/blob/next/firestore-bigquery-export/PREINSTALL.md#_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\ncurl -O https://raw.githubusercontent.com/firebase/extensions/master/firestore-bigquery-export/scripts/grant-crossproject-access.sh\\nchmod +x grant-crossproject-access.sh\\n./grant-crossproject-access.sh -f SOURCE_FIREBASE_PROJECT -b TARGET_BIGQUERY_PROJECT [-i EXTENSION_INSTANCE_ID]\n```\n\n----------------------------------------\n\nTITLE: Defining the ParamDefinition Interface in TypeScript\nDESCRIPTION: This TypeScript interface specifies the structure for defining a single parameter within the `params` map of a `BundleDocument`. It includes whether the parameter is mandatory (`required`) and its expected data type (`type`), which defaults to 'string' if not specified. Supported types include various primitives and arrays.\nSOURCE: https://github.com/firebase/extensions/blob/next/docs/firestore-bundle-builder/api-reference.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\ntype ParamDefinition = {\n  // Whether this parameter is required. If not provided as a query string, an error will be thrown.\n  required: boolean;\n  // The type of value which will be parsed, defaults to ‘string’.\n  type?:\n    | \"string\"\n    | \"integer\"\n    | \"float\"\n    | \"boolean\"\n    | \"string-array\"\n    | \"integer-array\"\n    | \"float-array\";\n};\n```\n```\n\n----------------------------------------\n\nTITLE: Running the Test Data Population Script using npm\nDESCRIPTION: Executes the 'populate' script defined in the project's package.json file using npm. This script is intended to populate test data for Firebase extensions like 'delete-user-data', requiring a Firebase project ID and service account key as prerequisites mentioned in the surrounding text. The command will likely prompt the user for necessary inputs.\nSOURCE: https://github.com/firebase/extensions/blob/next/delete-user-data/test-data/README.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nnpm run populate\n```\n\n----------------------------------------\n\nTITLE: Example Where Condition Using Dynamic Parameter in JavaScript\nDESCRIPTION: This JavaScript snippet illustrates how to use a parameter (defined in the `params` section of the `BundleDocument`) within a query condition. By prefixing the parameter name with '$' (e.g., '$type'), its value, provided via a query string in the request (e.g., `?type=featured`), will be substituted into the condition, enabling dynamic bundle generation.\nSOURCE: https://github.com/firebase/extensions/blob/next/docs/firestore-bundle-builder/api-reference.md#_snippet_8\n\nLANGUAGE: javascript\nCODE:\n```\n```js\n// ?type=featured\n\n\n    conditions: [\n      { where: [‘type’, ‘==’, ‘$type’] },\n```\n```\n\n----------------------------------------\n\nTITLE: Example Where Conditions for Number Parsing in JavaScript\nDESCRIPTION: These JavaScript snippets demonstrate how numeric values are handled within query conditions. Standard number values (like '1,2.5') are automatically parsed as numbers. If a string representation of a number is required, it must be explicitly wrapped in quotes within the comma-separated string (e.g., '“1”,”2.5”').\nSOURCE: https://github.com/firebase/extensions/blob/next/docs/firestore-bundle-builder/api-reference.md#_snippet_7\n\nLANGUAGE: javascript\nCODE:\n```\n```js\n{ where: [‘price’, ‘in’, ‘1,2.5’] }, // [1, 2.5]\n{ where: [‘price’, ‘in’, ‘“1”,”2.5”’] }, // [‘1’, ‘2.5’]\n```\n```\n\n----------------------------------------\n\nTITLE: Downloading OAuth2 Refresh Token Generation Script - Bash\nDESCRIPTION: This Bash snippet shows two alternative commands for downloading a Node.js OAuth2 refresh token helper script with 'curl' or 'wget'. The script is used to generate and obtain a refresh token for authenticating Gmail/SMTP via OAuth2 in the extension setup process. Dependencies: 'curl' or 'wget', internet access. The downloaded file is 'oauth2-refresh-token-helper.js'. Input: the command, Output: the script saved locally.\nSOURCE: https://github.com/firebase/extensions/blob/next/firestore-send-email/README.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n# Using curl\ncurl -o oauth2-refresh-token-helper.js https://raw.githubusercontent.com/firebase/extensions/refs/heads/master/firestore-send-email/scripts/oauth2-refresh-token-helper.js\n\n# Using wget\nwget https://raw.githubusercontent.com/firebase/extensions/refs/heads/master/firestore-send-email/scripts/oauth2-refresh-token-helper.js\n```\n\n----------------------------------------\n\nTITLE: Downloading OAuth2 Refresh Token Helper Script (Bash)\nDESCRIPTION: This Bash snippet provides two alternative commands to download a Node.js helper script for generating OAuth2 refresh tokens without requiring npm installation. It uses either curl or wget to fetch 'oauth2-refresh-token-helper.js' from the Firebase Extensions GitHub repository. The script assists with interactive OAuth2 flows; dependencies are minimal (only Node.js). Output is the script file, which can be executed in subsequent steps.\nSOURCE: https://github.com/firebase/extensions/blob/next/firestore-send-email/PREINSTALL.md#_snippet_2\n\nLANGUAGE: Bash\nCODE:\n```\n# Using curl\ncurl -o oauth2-refresh-token-helper.js https://raw.githubusercontent.com/firebase/extensions/refs/heads/master/firestore-send-email/scripts/oauth2-refresh-token-helper.js\n\n# Using wget\nwget https://raw.githubusercontent.com/firebase/extensions/refs/heads/master/firestore-send-email/scripts/oauth2-refresh-token-helper.js\n```\n\n----------------------------------------\n\nTITLE: Example Parameter Definition in JavaScript\nDESCRIPTION: This JavaScript code snippet demonstrates how to define a parameter named 'name' within the `params` object of a `BundleDocument`. It implements the `ParamDefinition` interface, specifying that the 'name' parameter is required and its type is 'string'. This parameter can then be supplied via a query string (e.g., `?name=david`) in the bundle request.\nSOURCE: https://github.com/firebase/extensions/blob/next/docs/firestore-bundle-builder/api-reference.md#_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\n```js\nparams: {\n  name: {\n    required: true,\n    type: ‘string’,\n  }\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Granting BigQuery CMEK Permissions using gcloud (Bash)\nDESCRIPTION: This gcloud command grants the necessary IAM permissions (Cloud KMS CryptoKey Encrypter/Decrypter role) to the BigQuery service account, allowing it to use a specified Customer-Managed Encryption Key (CMEK) from Cloud KMS for encrypting BigQuery data. Replace placeholders like KMS_PROJECT_ID, PROJECT_NUMBER, KMS_KEY_LOCATION, KMS_KEY_RING, and KMS_KEY with actual values.\nSOURCE: https://github.com/firebase/extensions/blob/next/firestore-bigquery-export/PREINSTALL.md#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\ngcloud kms keys add-iam-policy-binding \\\n--project=KMS_PROJECT_ID \\\n--member serviceAccount:bq-PROJECT_NUMBER@bigquery-encryption.iam.gserviceaccount.com \\\n--role roles/cloudkms.cryptoKeyEncrypterDecrypter \\\n--location=KMS_KEY_LOCATION \\\n--keyring=KMS_KEY_RING \\\nKMS_KEY\n```\n\n----------------------------------------\n\nTITLE: Defining the QueryDefinition Interface in TypeScript\nDESCRIPTION: This TypeScript interface defines the structure for a single named query within the `queries` map of a `BundleDocument`. Each query definition must specify the target Firestore `collection` and can optionally include an array of `conditions` (defined by `QueryCondition`) to filter or modify the query results.\nSOURCE: https://github.com/firebase/extensions/blob/next/docs/firestore-bundle-builder/api-reference.md#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\ntype QueryDefinition = {\n  // The collection to perform the query on.\n  collection: string;\n  // An optional list of conditions to perform on the specified collection.\n  conditions?: QueryCondition[];\n};\n```\n```\n\n----------------------------------------\n\nTITLE: Installing Firebase BigQuery Export Extension via CLI\nDESCRIPTION: This bash command utilizes the Firebase CLI (`firebase`) to install the `firestore-bigquery-export` Firebase extension into a specified project. The `--project` flag is used to designate the target Firebase project by its ID or alias. Note that while the surrounding documentation discusses the `firestore-shorten-urls-bitly` extension, this command specifically installs `firestore-bigquery-export`.\nSOURCE: https://github.com/firebase/extensions/blob/next/docs/firestore-shorten-urls-bitly/get-started.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nfirebase ext:install firebase/firestore-bigquery-export --project=projectId-or-alias\n```\n\n----------------------------------------\n\nTITLE: Defining a Basic Manual Schema for fs-bq-schema-views (JSON)\nDESCRIPTION: Provides a basic example of a manual schema definition in JSON format for the `fs-bq-schema-views` script, intended to be saved in a file (e.g., `test_schema.json`). This schema defines two fields for Firestore documents: `name` of type `string` and `age` of type `number`. This file would be passed to the script via the `--schema-files` argument.\nSOURCE: https://github.com/firebase/extensions/blob/next/firestore-bigquery-export/guides/GENERATE_SCHEMA_VIEWS.md#_snippet_2\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"fields\": [\n    {\n      \"name\": \"name\",\n      \"type\": \"string\"\n    },\n    {\n      \"name\": \"age\",\n      \"type\": \"number\"\n    }\n  ]\n}\n```\n\n----------------------------------------\n\nTITLE: Identifying Extension Service Account for IAM\nDESCRIPTION: This template represents the format of the service account identifier created for a Firebase Extension instance. This specific account needs to be granted the 'BigQuery Data Editor' role in the target BigQuery project (`BIGQUERY_PROJECT_ID`) to enable cross-project data synchronization. `${param:EXT_INSTANCE_ID}` is the unique ID of the extension instance, and `${param:PROJECT_ID}` is the ID of the Firebase project where the extension is installed.\nSOURCE: https://github.com/firebase/extensions/blob/next/docs/firestore-bigquery-export/cross-project-support.md#_snippet_0\n\nLANGUAGE: text\nCODE:\n```\next-${param:EXT_INSTANCE_ID}@${param:PROJECT_ID}.iam.gserviceaccount.com\n```\n\n----------------------------------------\n\nTITLE: Installing a Firebase Extension via CLI (Bash)\nDESCRIPTION: This Bash command uses the Firebase CLI to install the `firebase/storage-resize-images` extension into the specified Firebase project. Replace `projectId-or-alias` with your actual project ID or alias. This command requires the Firebase CLI to be installed and authenticated.\nSOURCE: https://github.com/firebase/extensions/blob/next/docs/firestore-counter/get-started.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nfirebase ext:install firebase/storage-resize-images --project=projectId-or-alias\n```\n\n----------------------------------------\n\nTITLE: Example Log Entry for Firestore onDispatch Trigger - JSON\nDESCRIPTION: Shows a structured JSON log entry produced when the syncBigQuery function processes a Firestore event via the onDispatch trigger. This example aids in understanding log schema fields and crafting targeted log queries. The jsonPayload includes the document path, event ID, trigger message, and operation code. No external dependencies are required; such logs are natively emitted by the extension in Google Cloud Logging.\nSOURCE: https://github.com/firebase/extensions/blob/next/firestore-bigquery-export/guides/OBSERVABILITY.md#_snippet_7\n\nLANGUAGE: json\nCODE:\n```\n{\\n  \\\"insertId\\\": \\\"672ca19d0008f1be9873dda6\\\",\\n  \\\"jsonPayload\\\": {\\n    \\\"document_name\\\": \\\"projects/dev-extensions-testing/databases/(default)/documents/posts/x0F2QodvO09MJGX3DUfm\\\",\\n    \\\"event_id\\\": \\\"1b8f5ae5-983a-40f6-b921-560118e5e321-2\\\",\\n    \\\"message\\\": \\\"Firestore event received by onDispatch trigger\\\",\\n    \\\"operation\\\": 0\\n  },\\n  \\\"labels\\\": {},\\n  \\\"logName\\\": \\\"projects/dev-extensions-testing/logs/cloudfunctions.googleapis.com%2Fcloud-functions\\\",\\n  \\\"receiveTimestamp\\\": \\\"2024-11-07T11:17:45.817442537Z\\\",\\n  \\\"resource\\\": {},\\n  \\\"severity\\\": \\\"INFO\\\",\\n  \\\"timestamp\\\": \\\"2024-11-07T11:17:45.586174Z\\\",\\n  \\\"trace\\\": \\\"projects/dev-extensions-testing/traces/6b1e13de24821178b8937f6ed72cc113\\\"\\n}\n```\n\n----------------------------------------\n\nTITLE: Example SMTP URI for Google Secret Manager Integration\nDESCRIPTION: This example shows the format for an SMTP connection URI when intending to store the password securely in Google Secret Manager. It includes the protocol (`smtps`), username (`username@gmail.com`), host (`smtp.gmail.com`), and port (`465`). The password is omitted from the URI itself. Port 465 is recommended for SMTPS as port 25 is blocked by Google Cloud Platform.\nSOURCE: https://github.com/firebase/extensions/blob/next/docs/firestore-send-email/smtp-connection-url.md#_snippet_0\n\nLANGUAGE: text\nCODE:\n```\nsmtps://username@gmail.com@smtp.gmail.com:465\n```\n\n----------------------------------------\n\nTITLE: Resulting Realtime Database Output Structure (JSON)\nDESCRIPTION: Shows the data structure in Firebase Realtime Database for a specific record after the extension runs. For a given message ID, a new field 'upper' is added alongside the 'original' field, containing the uppercase version of the text originally stored in 'original'.\nSOURCE: https://github.com/firebase/extensions/blob/next/samples/rtdb-uppercase-messages/PREINSTALL.md#_snippet_1\n\nLANGUAGE: json\nCODE:\n```\nMESSAGE_ID: {\n    \"original\": MESSAGE_TEXT,\n    \"upper\": UPPERCASE_MESSAGE_TEXT,\n}\n```\n\n----------------------------------------\n\nTITLE: Expected Realtime Database Input Structure (JSON)\nDESCRIPTION: Illustrates the expected data structure in Firebase Realtime Database before the extension processes it. New messages should be added under the 'messages' path (or the configured path), with each unique ID containing an 'original' field holding the string to be converted.\nSOURCE: https://github.com/firebase/extensions/blob/next/samples/rtdb-uppercase-messages/PREINSTALL.md#_snippet_0\n\nLANGUAGE: json\nCODE:\n```\n\"messages\": {\n    MESSAGE_ID: {\n        \"original\": MESSAGE_TEXT\n    },\n    MESSAGE_ID: {\n        \"original\": MESSAGE_TEXT\n    },\n}\n```\n\n----------------------------------------\n\nTITLE: Example Firestore Document After URL Shortening (JSON)\nDESCRIPTION: This JSON object illustrates the structure of a Cloud Firestore document after the URL Shortener extension has processed it. When a URL is added to the field defined by `${param:URL_FIELD_NAME}`, the extension generates a short URL and saves it in the field defined by `${param:SHORT_URL_FIELD_NAME}` within the same document.\nSOURCE: https://github.com/firebase/extensions/blob/next/firestore-shorten-urls-bitly/POSTINSTALL.md#_snippet_0\n\nLANGUAGE: json\nCODE:\n```\n{\n  ${param:URL_FIELD_NAME}: 'https://my.super.long-link.example.com/api/user/profile/-jEHitne10395-k3593085',\n  ${param:SHORT_URL_FIELD_NAME}: 'https://bit.ly/EKDdza',\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Firebase Functions Dependency with NPM in JSON\nDESCRIPTION: Defines the required Firebase Functions package version in a package.json dependencies block. This ensures that the onCustomEventPublished handler and the latest Firestore integration features are available. Install this dependency before proceeding with event handling code; run \\\\\"npm install\\\\\" to ensure all modules are available.\nSOURCE: https://github.com/firebase/extensions/blob/next/docs/storage-resize-images/handle-resize-image-extension-events.md#_snippet_0\n\nLANGUAGE: json\nCODE:\n```\n{\n \"firebase-functions\": \"^3.21.1\"\n}\n```\n\n----------------------------------------\n\nTITLE: Console Output: Logging Failed Batch during Import - Text\nDESCRIPTION: This snippet shows the typical console output when the import script encounters a failed batch. It displays failed document paths to aid quick identification and further action. The actual content will list the affected Firestore document paths encountered in that batch.\nSOURCE: https://github.com/firebase/extensions/blob/next/firestore-bigquery-export/guides/IMPORT_EXISTING_DOCUMENTS.md#_snippet_5\n\nLANGUAGE: text\nCODE:\n```\nFailed batch: <paths of failed documents in batch>\n```\n\n----------------------------------------\n\nTITLE: Packing and Publishing npm Packages using Shell\nDESCRIPTION: These shell commands demonstrate how to package and publish an npm package from within its directory. `npm pack` creates a `.tgz` archive of the package, useful for testing or local distribution. `npm publish` uploads the package to the configured npm registry, making it available according to registry settings. These are standard npm commands for package management.\nSOURCE: https://github.com/firebase/extensions/blob/next/firestore-bigquery-export/CONTRIBUTING.md#_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\nnpm pack\nnpm publish\n```\n\n----------------------------------------\n\nTITLE: Representing Firestore Path Depths for User Data Deletion - JavaScript\nDESCRIPTION: This code snippet illustrates how path depths in a Firestore database are assigned integer values for the purpose of configuring data deletion traversal within the Delete User Data extension. For each path, a depth is specified that influences how deeply the extension will search for and delete user-associated documents or collections. This serves as a reference for users configuring the 'search depth' parameter, clarifying how document and collection hierarchies are traversed. No dependencies are needed; this code is for documentation and conceptual reference only.\nSOURCE: https://github.com/firebase/extensions/blob/next/docs/delete-user-data/get-started.md#_snippet_1\n\nLANGUAGE: js\nCODE:\n```\n/users = 1\n/users/<document-id> = 1\n/users/<document-id>/comments = 2\n/users/<document-id>/comments/<document-id> = 2\n\n```\n\n----------------------------------------\n\nTITLE: Specifying Cloud KMS Key Resource Name Format (Text)\nDESCRIPTION: Illustrates the standard format for a Cloud KMS key resource name. This format is required when configuring the Firestore to BigQuery extension to use Customer-Managed Encryption Keys (CMEK). It includes the project ID, location (region), key ring name, and the key name itself.\nSOURCE: https://github.com/firebase/extensions/blob/next/firestore-bigquery-export/PREINSTALL.md#_snippet_4\n\nLANGUAGE: text\nCODE:\n```\nprojects/<YOUR PROJECT ID>/locations/<YOUR REGION>/keyRings/<YOUR KEY RING NAME>/cryptoKeys/<YOUR KEY NAME>\n```\n\n----------------------------------------\n\nTITLE: Implementing Firestore Sharded Counter in Web Apps (Firebase SDK <v9)\nDESCRIPTION: Shows the HTML structure and JavaScript code required to initialize Firebase SDK v8 or earlier, instantiate the sharded counter client (`sharded-counter.js`), increment a counter (`visits` on `pages/hello-world`), and listen for both locally consistent and eventually consistent updates. Requires including the Firebase App and Firestore JS SDKs (specific versions) and the compiled client sample JS file (`sharded-counter.js`).\nSOURCE: https://github.com/firebase/extensions/blob/next/firestore-counter/POSTINSTALL.md#_snippet_1\n\nLANGUAGE: html\nCODE:\n```\n<html>\n  <head>\n    <script src=\"https://www.gstatic.com/firebasejs/[version]/firebase-app.js\"></script>\n    <script src=\"https://www.gstatic.com/firebasejs/[version]/firebase-firestore.js\"></script>\n    <script src=\"sharded-counter.js\"></script>\n  </head>\n  <body>\n    <script>\n      // Initialize Firebase.\n      var firebaseConfig = { projectId: \"${param:PROJECT_ID}\" };\n      firebase.initializeApp(firebaseConfig);\n      var db = firebase.firestore();\n\n      // Initialize the sharded counter.\n      var visits = new sharded.Counter(db.doc(\"pages/hello-world\"), \"visits\");\n\n      // Increment the field \"visits\" of the document \"pages/hello-world\".\n      visits.incrementBy(1);\n\n      // Listen to locally consistent values.\n      visits.onSnapshot((snap) => {\n        console.log(\"Locally consistent view of visits: \" + snap.data());\n      });\n\n      // Alternatively, if you don't mind counter delays, you can listen to the document directly.\n      db.doc(\"pages/hello-world\").onSnapshot((snap) => {\n        console.log(\"Eventually consistent view of visits: \" + snap.get(\"visits\"));\n      });\n    </script>\n  </body>\n</html>\n```\n\n----------------------------------------\n\nTITLE: Mapping Cloud Firestore Types to BigQuery Types (HTML)\nDESCRIPTION: This HTML table illustrates the data type conversion scheme used by the schema-views script when generating BigQuery views from Cloud Firestore data. It lists basic Cloud Firestore types (string, boolean, number, timestamp, geopoint, reference, null) and their corresponding BigQuery types (STRING, BOOLEAN, NUMERIC, TIMESTAMP, GEOGRAPHY, STRING, NULL). It notes that map and array types are handled differently.\nSOURCE: https://github.com/firebase/extensions/blob/next/docs/firestore-bigquery-export/generating-schemas.md#_snippet_5\n\nLANGUAGE: html\nCODE:\n```\n<table>\n  <thead>\n    <tr>\n      <th><strong>Cloud Firestore type</strong></th>\n      <th><strong>BigQuery type</strong></th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>string</td>\n      <td>STRING</td>\n    </tr>\n    <tr>\n      <td>boolean</td>\n      <td>BOOLEAN</td>\n    </tr>\n    <tr>\n      <td>number</td>\n      <td>NUMERIC</td>\n    </tr>\n    <tr>\n      <td>timestamp</td>\n      <td>TIMESTAMP</td>\n    </tr>\n    <tr>\n      <td>geopoint</td>\n      <td>GEOGRAPHY</td>\n    </tr>\n    <tr>\n      <td>reference</td>\n      <td>STRING<br />(containing the path to the referenced document)</td>\n    </tr>\n    <tr>\n      <td>null</td>\n      <td>NULL</td>\n    </tr>\n  </tbody>\n</table>\n```\n\n----------------------------------------\n\nTITLE: Filtering Logs by Severity in Logs Explorer - plaintext\nDESCRIPTION: Filters log entries in Logs Explorer by severity, specifically showing only ERROR level logs across all components. This is useful for quickly surfacing error events and troubleshooting extension issues. Key parameter is 'severity' set to 'ERROR'. Expected output is a list of error logs.\nSOURCE: https://github.com/firebase/extensions/blob/next/firestore-bigquery-export/guides/OBSERVABILITY.md#_snippet_2\n\nLANGUAGE: plaintext\nCODE:\n```\nseverity=\\\"ERROR\\\"\n```\n\n----------------------------------------\n\nTITLE: Displaying Common Schema Configuration Mistakes (HTML)\nDESCRIPTION: This HTML snippet renders a table outlining common errors encountered when configuring a schema file for the Firebase Firestore-to-BigQuery extension. It lists mistakes like omitting fields, using incorrect types, specifying non-existent fields, or writing invalid JSON, and details the consequences of each mistake on the generated BigQuery view.\nSOURCE: https://github.com/firebase/extensions/blob/next/docs/firestore-bigquery-export/generating-schemas.md#_snippet_4\n\nLANGUAGE: html\nCODE:\n```\n<table>\n  <thead>\n    <tr>\n      <th><strong>Mistake in schema file config</strong></th>\n      <th><strong>Outcome of mistake</strong></th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>Omitting a relevant field</td>\n      <td>The generated view will not contain a column for that field.</td>\n    </tr>\n    <tr>\n      <td>Specifying the wrong type for a relevant field</td>\n      <td>\n        Type conversion (see previous section) will fail and the resulting\n        column will contain a BigQuery <code>null</code> value in lieu of the\n        desired value.\n      </td>\n    </tr>\n    <tr>\n      <td>\n        Specifying a schema field that doesn't exist in the underlying raw\n        changelog\n      </td>\n      <td>\n        Querying the column for that field will return a BigQuery\n        <code>null</code> value instead of the desired value.\n      </td>\n    </tr>\n    <tr>\n      <td>Writing invalid JSON</td>\n      <td>The schema-views script cannot generate a view</td>\n    </tr>\n  </tbody>\n</table>\n```\n\n----------------------------------------\n\nTITLE: Example Output: Paths to Failed Imported Firestore Documents - Text\nDESCRIPTION: This code block provides an example of the output format for failed Firestore document imports. Each line specifies the Firestore document path not successfully imported, as recorded in the output file when using the -f option. This output helps in identifying and reprocessing problematic documents.\nSOURCE: https://github.com/firebase/extensions/blob/next/firestore-bigquery-export/guides/IMPORT_EXISTING_DOCUMENTS.md#_snippet_4\n\nLANGUAGE: text\nCODE:\n```\nprojects/my-project/databases/(default)/documents/users/user123\nprojects/my-project/databases/(default)/documents/orders/order456\nprojects/my-project/databases/(default)/documents/posts/post789\n```\n\n----------------------------------------\n\nTITLE: Example SMTP URI with Inline Password\nDESCRIPTION: This example demonstrates an SMTP connection URI that includes the password directly within the string. It specifies the protocol (`smtps`), username (`username@gmail.com`), password (`password`), host (`smtp.gmail.com`), and port (`465`). This method is presented as easier but less secure compared to using Google Secret Manager.\nSOURCE: https://github.com/firebase/extensions/blob/next/docs/firestore-send-email/smtp-connection-url.md#_snippet_1\n\nLANGUAGE: text\nCODE:\n```\nsmtps://username@gmail.com:password@smtp.gmail.com:465\n```\n\n----------------------------------------\n\nTITLE: Updating package.json for Local Dependencies using jq and Shell\nDESCRIPTION: This shell script uses the `jq` command-line JSON processor to modify `package.json` files. It updates the dependency `@firebaseextensions/firestore-bigquery-change-tracker` to point to the local file path (`file:./firestore-bigquery-change-tracker` or `file:../../firestore-bigquery-change-tracker`) in the root `package.json` and `scripts/import/package.json`. Backup copies of the original files are created (`.bak` and `.remote.json.bak`) before overwriting them with the modified versions (`package.local.json`). This setup facilitates local development by using local package versions instead of published ones. Requires `jq` to be installed.\nSOURCE: https://github.com/firebase/extensions/blob/next/firestore-bigquery-export/CONTRIBUTING.md#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\njq '.dependencies.\"@firebaseextensions/firestore-bigquery-change-tracker\" = \"file:./firestore-bigquery-change-tracker\"' package.json > package.local.json\njq '.dependencies.\"@firebaseextensions/firestore-bigquery-change-tracker\" = \"file:../../firestore-bigquery-change-tracker\"' scripts/import/package.json > scripts/import/package.local.json\n\nmv package.json package.json.bak\nmv scripts/import/package.json scripts/import/package.remote.json.bak\n\nmv package.local.json package.json\nmv scripts/import/package.local.json scripts/import/package.json\n```\n\n----------------------------------------\n\nTITLE: Empty Object Structure\nDESCRIPTION: The file contains an empty object structure `{}`. This could represent an empty JSON object, an empty code block in various languages, or placeholder content. Without further context, its specific purpose cannot be determined.\nSOURCE: https://github.com/firebase/extensions/blob/next/firestore-bigquery-export/scripts/gen-schema-view/src/__tests__/fixtures/schema-files/full-directory/schema-4.txt#_snippet_0\n\nLANGUAGE: json\nCODE:\n```\n{}\n```"
  }
]