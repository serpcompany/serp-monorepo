[
  {
    "owner": "matthiasvalvekens",
    "repo": "pyhanko",
    "content": "TITLE: Signing a PDF Document with pyHanko in Python\nDESCRIPTION: This snippet demonstrates how to sign a PDF document using pyHanko's SimpleSigner and PdfSignatureMetadata. It loads a signer certificate and key, creates an IncrementalPdfFileWriter, and uses the sign_pdf function to apply the signature.\nSOURCE: https://github.com/matthiasvalvekens/pyhanko/blob/master/docs/lib-guide/signing.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom pyhanko.sign import signers\nfrom pyhanko.pdf_utils.incremental_writer import IncrementalPdfFileWriter\n\n\ncms_signer = signers.SimpleSigner.load(\n    'path/to/signer/key.pem', 'path/to/signer/cert.pem',\n    ca_chain_files=('path/to/relevant/certs.pem',),\n    key_passphrase=b'secret'\n)\n\nwith open('document.pdf', 'rb') as doc:\n    w = IncrementalPdfFileWriter(doc)\n    out = signers.sign_pdf(\n        w, signers.PdfSignatureMetadata(field_name='Signature1'),\n        signer=cms_signer,\n    )\n\n    # do stuff with 'out'\n    # ...\n```\n\n----------------------------------------\n\nTITLE: Validating a PAdES B-LTA Long-Term Signature in Python\nDESCRIPTION: This code shows how to perform long-term validation (LTV) on a PDF signature using the PAdES B-LTA profile. It validates the signature at the current time and then constructs a validation context at the point of signing to verify that the signature was valid when it was created.\nSOURCE: https://github.com/matthiasvalvekens/pyhanko/blob/master/docs/lib-guide/validation.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom pyhanko.keys import load_cert_from_pemder\nfrom pyhanko.pdf_utils.reader import PdfFileReader\nfrom pyhanko.sign.validation import (\n    validate_pdf_ltv_signature, RevocationInfoValidationType\n)\n\nroot_cert = load_cert_from_pemder('path/to/certfile')\n\nwith open('document.pdf', 'rb') as doc:\n    r = PdfFileReader(doc)\n    sig = r.embedded_signatures[0]\n    status = validate_pdf_ltv_signature(\n        sig, RevocationInfoValidationType.PADES_LTA,\n        validation_context_kwargs={'trust_roots': [root_cert]}\n    )\n    print(status.pretty_print_details())\n```\n\n----------------------------------------\n\nTITLE: Validating a PDF Signature Against a Trust Root in Python\nDESCRIPTION: This code demonstrates how to validate a PDF signature against a specific trust root certificate. It loads a certificate, creates a ValidationContext with it as a trust root, opens a PDF document, retrieves the first embedded signature, and validates it.\nSOURCE: https://github.com/matthiasvalvekens/pyhanko/blob/master/docs/lib-guide/validation.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom pyhanko.keys import load_cert_from_pemder\nfrom pyhanko_certvalidator import ValidationContext\nfrom pyhanko.pdf_utils.reader import PdfFileReader\nfrom pyhanko.sign.validation import validate_pdf_signature\n\nroot_cert = load_cert_from_pemder('path/to/certfile')\nvc = ValidationContext(trust_roots=[root_cert])\n\nwith open('document.pdf', 'rb') as doc:\n    r = PdfFileReader(doc)\n    sig = r.embedded_signatures[0]\n    status = validate_pdf_signature(sig, vc)\n    print(status.pretty_print_details())\n```\n\n----------------------------------------\n\nTITLE: Creating PAdES B-LTA Compliant Signatures with PyHanko\nDESCRIPTION: This code demonstrates creating a PAdES B-LTA signature, which is the most advanced PAdES baseline profile. It shows how to set up the validation context for fetching revocation information and configure the proper metadata for PAdES compliance.\nSOURCE: https://github.com/matthiasvalvekens/pyhanko/blob/master/docs/lib-guide/signing.rst#2025-04-22_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nfrom pyhanko.pdf_utils.incremental_writer import IncrementalPdfFileWriter\nfrom pyhanko.sign import signers, timestamps\nfrom pyhanko.sign.fields import SigSeedSubFilter\nfrom pyhanko_certvalidator import ValidationContext\n\n# Load signer key material from PKCS#12 file\n# This assumes that any relevant intermediate certs are also included\n# in the PKCS#12 file.\nsigner = signers.SimpleSigner.load_pkcs12(\n    pfx_file='signer.pfx', passphrase=b'secret'\n)\n\n# Set up a timestamping client to fetch timestamps tokens\ntimestamper = timestamps.HTTPTimeStamper(\n    url='http://tsa.example.com/timestampService'\n)\n\n# Settings for PAdES-LTA\nsignature_meta = signers.PdfSignatureMetadata(\n    field_name='Signature', md_algorithm='sha256',\n    # Mark the signature as a PAdES signature\n    subfilter=SigSeedSubFilter.PADES,\n    # We'll also need a validation context\n    # to fetch & embed revocation info.\n    validation_context=ValidationContext(allow_fetching=True),\n    # Embed relevant OCSP responses / CRLs (PAdES-LT)\n    embed_validation_info=True,\n    # Tell pyHanko to put in an extra DocumentTimeStamp\n    # to kick off the PAdES-LTA timestamp chain.\n    use_pades_lta=True\n)\n\nwith open('input.pdf', 'rb') as inf:\n    w = IncrementalPdfFileWriter(inf)\n    with open('output.pdf', 'wb') as outf:\n        signers.sign_pdf(\n```\n\n----------------------------------------\n\nTITLE: Validating PDF Signature without Diff Analysis in Python\nDESCRIPTION: This code snippet shows how to validate a PDF signature while skipping the difference analysis. It loads a root certificate, creates a validation context, reads a PDF file, and validates the first embedded signature with the 'skip_diff' parameter set to True.\nSOURCE: https://github.com/matthiasvalvekens/pyhanko/blob/master/docs/lib-guide/validation.rst#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom pyhanko.keys import load_cert_from_pemder\nfrom pyhanko_certvalidator import ValidationContext\nfrom pyhanko.pdf_utils.reader import PdfFileReader\nfrom pyhanko.sign.validation import validate_pdf_signature\n\nroot_cert = load_cert_from_pemder('path/to/certfile')\nvc = ValidationContext(trust_roots=[root_cert])\n\nwith open('document.pdf', 'rb') as doc:\n    r = PdfFileReader(doc)\n    sig = r.embedded_signatures[0]\n    status = validate_pdf_signature(sig, vc, skip_diff=True)\n    print(status.pretty_print_details())\n```\n\n----------------------------------------\n\nTITLE: Validating PDF Signature with Custom Diff Policy in Python\nDESCRIPTION: This snippet demonstrates how to validate a PDF signature using a custom diff policy. It loads a root certificate, creates a validation context, reads a PDF file, and validates the first embedded signature using a custom diff policy.\nSOURCE: https://github.com/matthiasvalvekens/pyhanko/blob/master/docs/lib-guide/validation.rst#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom pyhanko.keys import load_cert_from_pemder\nfrom pyhanko_certvalidator import ValidationContext\nfrom pyhanko.pdf_utils.reader import PdfFileReader\nfrom pyhanko.sign.validation import validate_pdf_signature\n\nfrom my_awesome_module import CustomDiffPolicy\n\nroot_cert = load_cert_from_pemder('path/to/certfile')\nvc = ValidationContext(trust_roots=[root_cert])\n\nwith open('document.pdf', 'rb') as doc:\n    r = PdfFileReader(doc)\n    sig = r.embedded_signatures[0]\n    status = validate_pdf_signature(sig, vc, diff_policy=CustomDiffPolicy())\n    print(status.pretty_print_details())\n```\n\n----------------------------------------\n\nTITLE: Creating PAdES B-LT Compliant Signature with pyHanko\nDESCRIPTION: This command demonstrates how to create a PAdES B-LT compliant signature using pyHanko. It embeds validation information and uses PAdES extensions.\nSOURCE: https://github.com/matthiasvalvekens/pyhanko/blob/master/docs/cli-guide/signing.rst#2025-04-22_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\npyhanko sign addsig --field Sig1 --timestamp-url http://tsa.example.com \\\n    --with-validation-info --use-pades pemder \\\n    --key key.pem --cert cert.pem input.pdf output.pdf\n```\n\n----------------------------------------\n\nTITLE: Implementing Async PDF Signing with aiohttp in Python\nDESCRIPTION: Example demonstrating how to use aiohttp-based networking in pyHanko to create a PAdES-B-LTA signature. Shows configuration of validation context, timestamp service, and async signing process.\nSOURCE: https://github.com/matthiasvalvekens/pyhanko/blob/master/docs/lib-guide/signing.rst#2025-04-22_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nimport aiohttp\nfrom pyhanko.pdf_utils.incremental_writer import IncrementalPdfFileWriter\nfrom pyhanko.sign import signers\nfrom pyhanko.sign.fields import SigSeedSubFilter\nfrom pyhanko.sign.timestamps.aiohttp_client import AIOHttpTimeStamper\nfrom pyhanko_certvalidator import ValidationContext\nfrom pyhanko_certvalidator.fetchers.aiohttp_fetchers \\\n    import AIOHttpFetcherBackend\n\n# Load signer key material from PKCS#12 file\n# (see earlier examples)\nsigner = signers.SimpleSigner.load_pkcs12(\n    pfx_file='signer.pfx', passphrase=b'secret'\n)\n\n# This demo async function takes an aiohttp session, an input\n# file name and an output file name.\nasync def sign_doc_demo(session, input_file, output_file):\n    # Use the aiohttp fetcher backend provided by pyhanko-certvalidator,\n    # and tell it to use our client session.\n    validation_context = ValidationContext(\n        fetcher_backend=AIOHttpFetcherBackend(session),\n        allow_fetching=True\n    )\n\n    # Similarly, we choose an RFC 3161 client implementation\n    # that uses AIOHttp under the hood\n    timestamper = AIOHttpTimeStamper(\n        'http://tsa.example.com/timestampService',\n        session=session\n    )\n\n    # The signing config is otherwise the same\n    settings = signers.PdfSignatureMetadata(\n        field_name='AsyncSignatureExample',\n        validation_context=validation_context,\n        subfilter=SigSeedSubFilter.PADES,\n        embed_validation_info=True\n    )\n\n    with open(input_file, 'rb') as inf:\n        w = IncrementalPdfFileWriter(inf)\n        with open(output_file, 'wb') as outf:\n            await signers.async_sign_pdf(\n                w, settings, signer=signer, timestamper=timestamper,\n                output=outf\n            )\n\nasync def demo():\n   # Set up our aiohttp session\n   async with aiohttp.ClientSession() as session:\n       await sign_doc_demo(session, 'input.pdf', 'output.pdf')\n```\n\n----------------------------------------\n\nTITLE: Using PdfSigner Directly for PDF Signing in Python\nDESCRIPTION: This example shows how to use the PdfSigner class directly to sign a PDF document. It's equivalent to the previous example but offers more control over the signing process.\nSOURCE: https://github.com/matthiasvalvekens/pyhanko/blob/master/docs/lib-guide/signing.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom pyhanko.sign import signers\nfrom pyhanko.pdf_utils.incremental_writer import IncrementalPdfFileWriter\n\n\ncms_signer = signers.SimpleSigner.load(\n    'path/to/signer/key.pem', 'path/to/signer/cert.pem',\n    ca_chain_files=('path/to/relevant/certs.pem',),\n    key_passphrase=b'secret'\n)\n\nwith open('document.pdf', 'rb') as doc:\n    w = IncrementalPdfFileWriter(doc)\n    out = signers.PdfSigner(\n        signers.PdfSignatureMetadata(field_name='Signature1'),\n        signer=cms_signer,\n    ).sign_pdf(w)\n\n    # do stuff with 'out'\n    # ...\n```\n\n----------------------------------------\n\nTITLE: Adding Timestamp Tokens to PDF Signatures with PyHanko\nDESCRIPTION: This example shows how to include a trusted timestamp in a PDF signature using a timestamp authority (TSA). It demonstrates setting up the HTTP client for the TSA and incorporating it into the signing process.\nSOURCE: https://github.com/matthiasvalvekens/pyhanko/blob/master/docs/lib-guide/signing.rst#2025-04-22_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nfrom pyhanko.sign import signers, timestamps\nfrom pyhanko.pdf_utils.incremental_writer import IncrementalPdfFileWriter\n\n\ncms_signer = signers.SimpleSigner.load(\n    'path/to/signer/key.pem', 'path/to/signer/cert.pem',\n    ca_chain_files=('path/to/relevant/certs.pem',),\n    key_passphrase=b'secret'\n)\n\ntst_client = timestamps.HTTPTimeStamper('http://example.com/tsa')\n\nwith open('document.pdf', 'rb') as doc:\n    w = IncrementalPdfFileWriter(doc)\n    out = signers.sign_pdf(\n        w, signers.PdfSignatureMetadata(field_name='Signature1'),\n        signer=cms_signer, timestamper=tst_client\n    )\n\n    # do stuff with 'out'\n    # ...\n```\n\n----------------------------------------\n\nTITLE: Asynchronous PDF Signing with pyHanko in Python\nDESCRIPTION: This snippet demonstrates how to use pyHanko's asynchronous API for PDF signing. It defines an async function that signs a PDF document and shows how to run it using asyncio.\nSOURCE: https://github.com/matthiasvalvekens/pyhanko/blob/master/docs/lib-guide/signing.rst#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nimport asyncio\nfrom pyhanko.sign import signers\nfrom pyhanko.pdf_utils.incremental_writer import IncrementalPdfFileWriter\n\n\nasync def async_demo(signer, fname):\n    with open(fname, 'rb') as doc:\n        w = IncrementalPdfFileWriter(doc)\n        out = await signers.async_sign_pdf(\n            w, signers.PdfSignatureMetadata(field_name='Signature1'),\n            signer=signer,\n        )\n\n        return out\n\ncms_signer = signers.SimpleSigner.load(\n    'path/to/signer/key.pem', 'path/to/signer/cert.pem',\n    ca_chain_files=('path/to/relevant/certs.pem',),\n    key_passphrase=b'secret'\n)\nasyncio.run(async_demo(cms_signer, 'document.pdf'))\n```\n\n----------------------------------------\n\nTITLE: Adding Timestamp to PDF Signature with pyHanko\nDESCRIPTION: This command shows how to add a timestamp to a PDF signature using pyHanko. It includes the timestamp URL and uses a PEM-encoded key and certificate.\nSOURCE: https://github.com/matthiasvalvekens/pyhanko/blob/master/docs/cli-guide/signing.rst#2025-04-22_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\npyhanko sign addsig --field Sig1 --timestamp-url http://tsa.example.com \\\n    pemder --key key.pem --cert cert.pem input.pdf output.pdf\n```\n\n----------------------------------------\n\nTITLE: Interrupted Signing Without Prior Knowledge of Signer's Certificate\nDESCRIPTION: This example demonstrates how to implement an interrupted signing workflow when the signer's certificate is not known at the start of the process, which is useful when integrating with remote signing services that provide short-lived certificates upon receiving the document hash.\nSOURCE: https://github.com/matthiasvalvekens/pyhanko/blob/master/docs/lib-guide/signing.rst#2025-04-22_snippet_13\n\nLANGUAGE: python\nCODE:\n```\nw = IncrementalPdfFileWriter(pdf_file_handle)\npdf_signer = signers.PdfSigner(\n    # Specifying a digest algorithm (or signature mechanism)\n    # is necessary if the signing cert is not available\n    signers.PdfSignatureMetadata(\n        field_name='Signature',\n        md_algorithm='sha256',\n    ),\n    signer=ExternalSigner(\n        # note the 'None's\n        signing_cert=None, cert_registry=None,\n        signature_value=256,\n    )\n)\n\n# Since estimation is disabled without a certificate\n# available, bytes_reserved becomes mandatory.\nprep_digest, tbs_document, output = await pdf_signer\\\n    .async_digest_doc_for_signing(w, bytes_reserved=8192)\n\n# Call the external service\n# note: the signing certificate is in the returned payload,\n# but we don't (necessarily) need to do anything with it.\nsignature_container = \\\n    await call_external_service(prep_digest.document_digest)\n\n# Note: in the meantime, we could've serialised and deserialised\n# the contents of 'output', of course\nawait PdfTBSDocument.async_finish_signing(output, prep_digest)\n\n# If you want, you can now proceed to tack on additional revisions\n# with revocation information, document timestamps and the like.\n```\n\n----------------------------------------\n\nTITLE: Adding Validation Data to Existing PDF Signature\nDESCRIPTION: This command uses pyHanko's 'ltvfix' subcommand to fetch and append current validation information to an existing signature in a PDF document. It targets a specific signature field named 'Sig1'.\nSOURCE: https://github.com/matthiasvalvekens/pyhanko/blob/master/docs/cli-guide/validation.rst#2025-04-22_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\npyhanko sign ltvfix --field Sig1 document.pdf\n```\n\n----------------------------------------\n\nTITLE: Signing PDF with PEM/DER Key Files using pyHanko\nDESCRIPTION: Command for signing a PDF using key material from PEM or DER-encoded files. It specifies a signature field, private key file, and certificate file.\nSOURCE: https://github.com/matthiasvalvekens/pyhanko/blob/master/docs/cli-guide/signing.rst#2025-04-22_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\npyhanko sign addsig --field Sig1 pemder \\\n    --key key.pem --cert cert.pem input.pdf output.pdf\n```\n\n----------------------------------------\n\nTITLE: Installing PyHanko with Optional Dependencies\nDESCRIPTION: Command to install PyHanko using pip with optional dependencies for PKCS#11, image handling, OpenType/TrueType support, and XMP metadata handling. Requires Python 3.8 or later.\nSOURCE: https://github.com/matthiasvalvekens/pyhanko/blob/master/README.md#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\npip install 'pyHanko[pkcs11,image-support,opentype,xmp]'\n```\n\nLANGUAGE: bash\nCODE:\n```\npip install pyHanko[pkcs11,image-support,opentype,xmp]\n```\n\n----------------------------------------\n\nTITLE: Customizing PDF Signature Appearance with TextStampStyle in Python\nDESCRIPTION: This example shows how to customize the appearance of a PDF signature using TextStampStyle. It demonstrates creating a signature field, setting up a PdfSigner with custom stamp style, and applying the signature.\nSOURCE: https://github.com/matthiasvalvekens/pyhanko/blob/master/docs/lib-guide/signing.rst#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom pyhanko import stamp\nfrom pyhanko.pdf_utils import text, images\nfrom pyhanko.pdf_utils.font import opentype\nfrom pyhanko.pdf_utils.incremental_writer import IncrementalPdfFileWriter\nfrom pyhanko.sign import fields, signers\n\n\nsigner = signers.SimpleSigner.load(...)\nwith open('document.pdf', 'rb') as inf:\n    w = IncrementalPdfFileWriter(inf)\n    fields.append_signature_field(\n        w, sig_field_spec=fields.SigFieldSpec(\n            'Signature', box=(200, 600, 400, 660)\n        )\n    )\n\n    meta = signers.PdfSignatureMetadata(field_name='Signature')\n    pdf_signer = signers.PdfSigner(\n        meta, signer=signer, stamp_style=stamp.TextStampStyle(\n            # the 'signer' and 'ts' parameters will be interpolated by pyHanko, if present\n```\n\n----------------------------------------\n\nTITLE: Implementing Interrupted PDF Signing Workflow in pyHanko\nDESCRIPTION: This code demonstrates how to implement an interrupted signing workflow where pyHanko prepares a document for signing, computes the digest, sends it elsewhere for signing, and later completes the signing process when the response is received. It uses ExternalSigner to format the CMS object.\nSOURCE: https://github.com/matthiasvalvekens/pyhanko/blob/master/docs/lib-guide/signing.rst#2025-04-22_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nfrom pyhanko.sign import signers, fields, timestamps\nfrom pyhanko.sign.signers.pdf_signer import PdfTBSDocument\nfrom pyhanko_certvalidator import ValidationContext\nfrom pyhanko.pdf_utils.writer import BasePdfFileWriter\n\n# Skeleton code for an interrupted PAdES signature\n\n\nasync def prep_document(w: BasePdfFileWriter):\n    vc = ValidationContext(...)\n    pdf_signer = signers.PdfSigner(\n        signers.PdfSignatureMetadata(\n            field_name='SigNew', embed_validation_info=True, use_pades_lta=True,\n            subfilter=fields.SigSeedSubFilter.PADES,\n            validation_context=vc,\n            md_algorithm='sha256'\n        ),\n        # note: this signer will not perform any cryptographic operations,\n        # it's just there to bundle certificates with the generated CMS\n        # object and to provide size estimates\n        signer=signers.ExternalSigner(\n            signing_cert=..., ...,\n            # placeholder value, appropriate for a 2048-bit RSA key\n            # (for example's sake)\n            signature_value=bytes(256),\n        ),\n        timestamper=timestamps.HTTPTimeStamper('http://tsa.example.com')\n    )\n    prep_digest, tbs_document, output_handle = \\\n        await pdf_signer.async_digest_doc_for_signing(w)\n    md_algorithm = tbs_document.md_algorithm\n    psi = tbs_document.post_sign_instructions\n\n    signed_attrs = await ext_signer.signed_attrs(\n        prep_digest.document_digest, 'sha256', use_pades=True\n    )\n    return prep_digest, signed_attrs, psi, output_handle\n\n# After prep_document finishes, you can serialise the contents\n# of prep_digest, signed_attrs and psi somewhere.\n# The output stream can also be stored in a temporary file, for example.\n# You could now call the remote signing service, and once the response\n# comes back, proceed with finish_signing() after deserialising\n# all the intermediate outputs from the previous step.\n\nasync def finish_signing(sig_value: bytes, prep_digest, signed_attrs,\n                         psi, output_handle):\n    # Here, assume sig_value is the signed digest of the signed_attrs\n    # bytes, obtained from some remote signing service\n\n    # use ExternalSigner to format the CMS given the signed value\n    # we obtained from the remote signing service\n    ext_signer = instantiate_external_signer(sig_value)\n    sig_cms = await ext_signer.async_sign_prescribed_attributes(\n        'sha256', signed_attrs=signed_attrs,\n        timestamper=DUMMY_HTTP_TS\n    )\n\n    validation_context = ValidationContext(...)\n    await PdfTBSDocument.async_finish_signing(\n        output_handle, prepared_digest=prep_digest,\n        signature_cms=sig_cms,\n        post_sign_instr=psi,\n        validation_context=validation_context\n    )\n```\n\n----------------------------------------\n\nTITLE: Using Google Cloud KMS via PKCS#11 in Python\nDESCRIPTION: This example shows how to use Google Cloud KMS for PDF signing using the PKCS#11 library provided by Google. It sets up a PKCS11SigningContext and uses it with pyHanko's sign_pdf function.\nSOURCE: https://github.com/matthiasvalvekens/pyhanko/blob/master/docs/lib-guide/adv-examples.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom asn1crypto import algos\n\nfrom pyhanko.config.pkcs11 import PKCS11SignatureConfig\nfrom pyhanko.keys import load_cert_from_pemder, load_certs_from_pemder\nfrom pyhanko.pdf_utils.incremental_writer import IncrementalPdfFileWriter\nfrom pyhanko.sign import pkcs11, sign_pdf, PdfSignatureMetadata\n\nMODULE=\"/path/to/libkmsp11.so\"\n\n\ndef run_test(input_file, output_file, key_name, signer_cert_file, ca_certs_file):\n    cert_obj = load_cert_from_pemder(signer_cert_file)\n\n    config = PKCS11SignatureConfig(\n        module_path=MODULE,\n        slot_no=0,\n        key_label=key_name,\n        signing_certificate=cert_obj,\n        other_certs_to_pull=None,\n        other_certs = list(load_certs_from_pemder(ca_certs_file)),\n    )\n\n    with pkcs11.PKCS11SigningContext(config) as signer:\n        with open(input_file, 'rb') as inf:\n            w = IncrementalPdfFileWriter(inf)\n            meta = PdfSignatureMetadata(field_name='Sig1')\n            with open(output_file, 'wb') as outf:\n                sign_pdf(w, meta, signer, output=outf)\n\n\nrun_test(\n    'input.pdf',\n    'output.pdf',\n    'my-test-key',\n    'signer.cert.pem',\n    'ca-certs.cert.pem'\n)\n```\n\n----------------------------------------\n\nTITLE: Generic Data Signing and Embedding Signed Content in PDF\nDESCRIPTION: This example demonstrates how to use pyHanko's generic data signing capabilities to sign arbitrary data and embed it as a signed attachment in a PDF file. This showcases the flexibility of the CMS signing API outside of traditional PDF signatures.\nSOURCE: https://github.com/matthiasvalvekens/pyhanko/blob/master/docs/lib-guide/signing.rst#2025-04-22_snippet_14\n\nLANGUAGE: python\nCODE:\n```\nfrom pyhanko.sign.signers.pdf_cms import SimpleSigner\nfrom pyhanko.sign.signers.functions import embed_payload_with_cms\nfrom pyhanko.pdf_utils import embed, writer\n\nasync def demo():\n    data = b'Hello world!'\n    # instantiate a SimpleSigner\n    sgn = SimpleSigner(...)\n    # Sign some data\n    signature = \\\n        await sign.async_sign_general_data(data, 'sha256', detached=False)\n\n    # Embed the payload into a PDF file, with the signature\n    # object as a related file.\n    w = writer.PdfFileWriter()  # fresh writer, for demonstration's sake\n    embed_payload_with_cms(\n        w, file_spec_string='attachment.txt',\n        file_name='attachment.txt',\n        payload=embed.EmbeddedFileObject.from_file_data(\n            w, data=data, mime_type='text/plain',\n        ),\n        cms_obj=signature,\n        file_spec_kwargs={'description': \"Signed attachment test\"}\n    )\n```\n\n----------------------------------------\n\nTITLE: Running PDF Signing Test with GCP KMS Integration in Python\nDESCRIPTION: A test function that demonstrates how to sign a PDF using GCP KMS. It loads certificates, creates a signer object with GCP KMS credentials, and signs an input PDF file using pyHanko's async signing functionality.\nSOURCE: https://github.com/matthiasvalvekens/pyhanko/blob/master/docs/lib-guide/adv-examples.rst#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\ndef run_test(input_file, output_file, key_name, signer_cert_file, ca_certs_file):\n    cert_obj = load_cert_from_pemder(signer_cert_file)\n\n    registry = SimpleCertificateStore.from_certs(load_certs_from_pemder(ca_certs_file))\n    signer = GCPKMSSigner(\n        kms_key=GCPKMSKey(KEYRING, key_name, \"1\"),\n        signing_cert=cert_obj,\n        cert_registry=registry,\n    )\n\n    with open(input_file, 'rb') as inf:\n        w = IncrementalPdfFileWriter(inf)\n        meta = PdfSignatureMetadata(field_name='Sig1')\n        with open(output_file, 'wb') as outf:\n            await async_sign_pdf(w, meta, signer, output=outf)\n```\n\n----------------------------------------\n\nTITLE: Creating QR Code Signature Stamps with PyHanko\nDESCRIPTION: This snippet shows how to create a PDF signature with a QR code embedded in the appearance. It demonstrates configuring the stamp text alongside the QR code and setting the URL that will be encoded in the QR code.\nSOURCE: https://github.com/matthiasvalvekens/pyhanko/blob/master/docs/lib-guide/signing.rst#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom pyhanko import stamp\nfrom pyhanko.pdf_utils import text\nfrom pyhanko.pdf_utils.font import opentype\nfrom pyhanko.pdf_utils.incremental_writer import IncrementalPdfFileWriter\nfrom pyhanko.sign import fields, signers\n\n\nsigner = signers.SimpleSigner.load(...)\nwith open('document.pdf', 'rb') as inf:\n    w = IncrementalPdfFileWriter(inf)\n    fields.append_signature_field(\n        w, sig_field_spec=fields.SigFieldSpec(\n            'Signature', box=(200, 600, 400, 660)\n        )\n    )\n\n    meta = signers.PdfSignatureMetadata(field_name='Signature')\n    pdf_signer = signers.PdfSigner(\n        meta, signer=signer, stamp_style=stamp.QRStampStyle(\n            # Let's include the URL in the stamp text as well\n            stamp_text='Signed by: %(signer)s\\nTime: %(ts)s\\nURL: %(url)s',\n            text_box_style=text.TextBoxStyle(\n                font=opentype.GlyphAccumulatorFactory('path/to/NotoSans-Regular.ttf')\n            ),\n        ),\n    )\n    with open('document-signed.pdf', 'wb') as outf:\n        # with QR stamps, the 'url' text parameter is special-cased and mandatory, even if it\n        # doesn't occur in the stamp text: this is because the value of the 'url' parameter is\n        # also used to render the QR code.\n        pdf_signer.sign_pdf(\n            w, output=outf,\n            appearance_text_params={'url': 'https://example.com'}\n        )\n```\n\n----------------------------------------\n\nTITLE: Validating PDF Signatures using pyHanko CLI\nDESCRIPTION: This command uses pyHanko's 'validate' subcommand to check the validity of signatures in a PDF document. It prints a human-readable overview of the signature status.\nSOURCE: https://github.com/matthiasvalvekens/pyhanko/blob/master/docs/cli-guide/validation.rst#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\npyhanko sign validate --pretty-print document.pdf\n```\n\n----------------------------------------\n\nTITLE: Creating Text-Based Signature Stamps with PyHanko\nDESCRIPTION: This snippet demonstrates how to create a PDF signature with a customized text stamp appearance. It includes defining the stamp text with placeholders, setting a custom font, and adding an image background to the signature appearance.\nSOURCE: https://github.com/matthiasvalvekens/pyhanko/blob/master/docs/lib-guide/signing.rst#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nstamp_text='This is custom text!\\nSigned by: %(signer)s\\nTime: %(ts)s',\ntext_box_style=text.TextBoxStyle(\n    font=opentype.GlyphAccumulatorFactory('path/to/NotoSans-Regular.ttf')\n),\nbackground=images.PdfImage('stamp.png')\n),\n)\nwith open('document-signed.pdf', 'wb') as outf:\n    pdf_signer.sign_pdf(w, output=outf)\n```\n\n----------------------------------------\n\nTITLE: Signing PDF with PKCS#11 Token in pyHanko\nDESCRIPTION: This command demonstrates how to sign a PDF document using a PKCS#11 token with pyHanko. It specifies the PKCS#11 library path, token label, and certificate label.\nSOURCE: https://github.com/matthiasvalvekens/pyhanko/blob/master/docs/cli-guide/signing.rst#2025-04-22_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\npyhanko sign addsig pkcs11 --lib /path/to/module.so \\\n    --token-label testrsa --cert-label signer document.pdf output.pdf\n```\n\n----------------------------------------\n\nTITLE: Creating a Signature Field with MDP Settings in PyHanko\nDESCRIPTION: This snippet demonstrates how to create a signature field specification with field modification detection policies. It configures a field to lock 'SomeTextField' and sets the DocMDP value to permit only form filling after signing.\nSOURCE: https://github.com/matthiasvalvekens/pyhanko/blob/master/docs/lib-guide/sig-fields.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom pyhanko.sign import fields\n\nfields.SigFieldSpec(\n    'Sig1', box=(10, 74, 140, 134),\n    field_mdp_spec=fields.FieldMDPSpec(\n        fields.FieldMDPAction.INCLUDE, fields=['SomeTextField']\n    ),\n    doc_mdp_update_value=fields.MDPPerm.FORM_FILLING\n)\n```\n\n----------------------------------------\n\nTITLE: Signing PDF with PKCS#12 File using pyHanko\nDESCRIPTION: Command for signing a PDF using a PKCS#12 file (.pfx or .p12) which contains both the private key and certificate.\nSOURCE: https://github.com/matthiasvalvekens/pyhanko/blob/master/docs/cli-guide/signing.rst#2025-04-22_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\npyhanko sign addsig --field Sig1 pkcs12 \\\n    input.pdf output.pdf secrets.pfx\n```\n\n----------------------------------------\n\nTITLE: Low-level PDF CMS Signature Implementation with PdfCMSEmbedder\nDESCRIPTION: Example showing low-level implementation of PDF CMS signatures using PdfCMSEmbedder, demonstrating the complete signing process including form field setup, placeholder creation, and CMS object construction.\nSOURCE: https://github.com/matthiasvalvekens/pyhanko/blob/master/docs/lib-guide/signing.rst#2025-04-22_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nfrom datetime import datetime\nfrom pyhanko.sign import signers\nfrom pyhanko.sign.signers import cms_embedder\nfrom pyhanko.pdf_utils.incremental_writer import IncrementalPdfFileWriter\n\nfrom io import BytesIO\n\ninput_buf = BytesIO(b'<input file goes here>')\nw = IncrementalPdfFileWriter(input_buf)\n\n# Phase 1: coroutine sets up the form field, and returns a reference\ncms_writer = cms_embedder.PdfCMSEmbedder().write_cms(\n    field_name='Signature', writer=w\n)\nsig_field_ref = next(cms_writer)\n\n# just for kicks, let's check\nassert sig_field_ref.get_object()['/T'] == 'Signature'\n\n# Phase 2: make a placeholder signature object,\n# wrap it up together with the MDP config we want, and send that\n# on to cms_writer\ntimestamp = datetime.now(tz=tzlocal.get_localzone())\nsig_obj = signers.SignatureObject(timestamp=timestamp, bytes_reserved=8192)\n\nmd_algorithm = 'sha256'\n# for demonstration purposes, let's do a certification signature instead\n# of a plain old approval signature here\ncms_writer.send(\n    cms_embedder.SigObjSetup(\n        sig_placeholder=sig_obj,\n        mdp_setup=cms_embedder.SigMDPSetup(\n            md_algorithm=md_algorithm, certify=True,\n            docmdp_perms=fields.MDPPerm.NO_CHANGES\n        )\n    )\n)\n\n# Phase 3: write & hash the document (with placeholder)\nprep_digest, output = cms_writer.send(\n    cms_embedder.SigIOSetup(md_algorithm=md_algorithm, in_place=True)\n)\n\n# Phase 4: construct the CMS object, and pass it on to cms_writer\nsigner: signers.SimpleSigner = FROM_CA\n# let's supply the CMS object as a raw bytestring\ncms_bytes = signer.sign(\n    data_digest=prep_digest.document_digest,\n    digest_algorithm=md_algorithm, timestamp=timestamp\n).dump()\nsig_contents = cms_writer.send(cms_bytes)\n```\n\n----------------------------------------\n\nTITLE: Updating Long-Term Archival (LTA) Signature with pyHanko\nDESCRIPTION: This command shows how to update a long-term archival (LTA) signature using pyHanko. It adds a new document timestamp to extend the validity of the signature.\nSOURCE: https://github.com/matthiasvalvekens/pyhanko/blob/master/docs/cli-guide/signing.rst#2025-04-22_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\npyhanko sign ltaupdate --timestamp-url http://tsa.example.com input.pdf\n```\n\n----------------------------------------\n\nTITLE: Advanced PKCS#11 Setup Configuration in PyHanko YAML\nDESCRIPTION: This snippet shows an advanced PKCS#11 setup configuration using token serial number and object IDs for certificate and key selection.\nSOURCE: https://github.com/matthiasvalvekens/pyhanko/blob/master/docs/cli-guide/config.rst#2025-04-22_snippet_7\n\nLANGUAGE: yaml\nCODE:\n```\npkcs11-setups:\n   test-setup:\n       module-path: /path/to/module.so\n       token-criteria:\n           serial: 17aa21784b9f\n       cert-id: 1382391af78ac390\n       key-id: 1382391af78ac390\n```\n\n----------------------------------------\n\nTITLE: Creating Visible Signature Field On-the-fly with pyHanko\nDESCRIPTION: Command that creates a visible signature field while signing the document, specifying the page number, coordinates, and field name.\nSOURCE: https://github.com/matthiasvalvekens/pyhanko/blob/master/docs/cli-guide/signing.rst#2025-04-22_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\npyhanko sign addsig --field PAGE/X1,Y1,X2,Y2/NAME pkcs12 \\\n    input.pdf output.pdf secrets.pfx\n```\n\n----------------------------------------\n\nTITLE: Configuring PKCS#11 Setups with PIN in PyHanko YAML\nDESCRIPTION: This snippet demonstrates how to include a user PIN in a PKCS#11 setup configuration for PyHanko.\nSOURCE: https://github.com/matthiasvalvekens/pyhanko/blob/master/docs/cli-guide/config.rst#2025-04-22_snippet_6\n\nLANGUAGE: yaml\nCODE:\n```\npkcs11-setups:\n    test-setup:\n        module-path: /usr/lib/libsofthsm2.so\n        token-criteria:\n            label: testrsa\n        cert-label: signer\n        user-pin: 1234\n```\n\n----------------------------------------\n\nTITLE: Implementing Asynchronous Raw Signing with Google Cloud KMS in Python\nDESCRIPTION: An asynchronous method that signs data using Google Cloud KMS. It computes a digest of the input data, sends a signing request to the GCP KMS API, and verifies the integrity of the response using CRC32C checksums before returning the signature.\nSOURCE: https://github.com/matthiasvalvekens/pyhanko/blob/master/docs/lib-guide/adv-examples.rst#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nasync def async_sign_raw(self, data: bytes, digest_algorithm: str, dry_run=False) -> bytes:\n    if dry_run:\n        return bytes(256)\n\n    # Note: this method makes no effort to check whether the digest\n    # algorithm matches the expectation of the upstream API\n    md_spec = get_pyca_cryptography_hash(digest_algorithm)\n    md = hashes.Hash(md_spec)\n    md.update(data)\n    digest = md.finalize()\n    name = self.kms_key.path\n    crc32c = crcmod.predefined.mkPredefinedCrcFun(\"crc-32c\")\n\n    request = kms.AsymmetricSignRequest(\n        {\n            \"name\": name,\n            \"digest\": {digest_algorithm: digest},\n            \"digest_crc32c\": crc32c(digest),\n        }\n    )\n    response = await self.client.asymmetric_sign(request=request)\n\n    # From https://cloud.google.com/kms/docs/create-validate-signatures#kms-sign-asymmetric-python\n    if (\n        not response.verified_digest_crc32c\n        or response.name != name\n        or response.signature_crc32c != crc32c(response.signature)\n    ):\n        raise SigningError(\n            \"The request sent to the server was corrupted in-transit.\"\n        )\n\n    return response.signature\n```\n\n----------------------------------------\n\nTITLE: Customizing Signature Appearance with pyHanko\nDESCRIPTION: This command demonstrates how to customize the appearance of a visible signature using a named style in pyHanko. The style must be defined in the configuration file.\nSOURCE: https://github.com/matthiasvalvekens/pyhanko/blob/master/docs/cli-guide/signing.rst#2025-04-22_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\npyhanko sign addsig --field Sig1 --style-name mystyle pemder \\\n    --key key.pem --cert cert.pem input.pdf output.pdf\n```\n\n----------------------------------------\n\nTITLE: Defining Validation Contexts in PyHanko YAML\nDESCRIPTION: This snippet shows how to define named validation contexts in the PyHanko configuration file. It includes examples of setting trust anchors, other certificates, and trust replacement options.\nSOURCE: https://github.com/matthiasvalvekens/pyhanko/blob/master/docs/cli-guide/config.rst#2025-04-22_snippet_1\n\nLANGUAGE: yaml\nCODE:\n```\nvalidation-contexts:\n    default:\n        other-certs: some-cert.pem.cert\n    special-setup:\n        trust: customca.pem.cert\n        trust-replace: true\n        other-certs: some-cert.pem.cert\n```\n\n----------------------------------------\n\nTITLE: Configuring On-Disk Key Material with Passphrases in PyHanko YAML\nDESCRIPTION: This snippet shows how to include passphrases in the configuration for PKCS#12 and PEM/DER key material setups.\nSOURCE: https://github.com/matthiasvalvekens/pyhanko/blob/master/docs/cli-guide/config.rst#2025-04-22_snippet_9\n\nLANGUAGE: yaml\nCODE:\n```\npkcs12-setups:\n    foo:\n        pfx-file: path/to/signer.pfx\n        other-certs: path/to/more/certs.chain.pem\n        pfx-passphrase: secret\npemder-setups:\n    bar:\n        key-file: path/to/signer.key.pem\n        cert-file: path/to/signer.cert.pem\n        other-certs: path/to/more/certs.chain.pem\n        key-passphrase: secret\n```\n\n----------------------------------------\n\nTITLE: Applying a Stamp to a PDF Using pyHanko CLI\nDESCRIPTION: Basic command for applying a named style stamp to a specific position on a page in a PDF document. The command specifies the style name, target page, input file, output file, and x/y coordinates for stamp placement.\nSOURCE: https://github.com/matthiasvalvekens/pyhanko/blob/master/docs/cli-guide/stamping.rst#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\npyhanko stamp --style-name some-style --page 2 input.pdf output.pdf 50 100\n```\n\n----------------------------------------\n\nTITLE: Creating Static Content Stamps from External PDFs with PyHanko\nDESCRIPTION: This example demonstrates how to import an entire page from an external PDF file to use as a signature appearance. This approach allows for more advanced signature appearances designed in other tools to be used with PyHanko's signing capabilities.\nSOURCE: https://github.com/matthiasvalvekens/pyhanko/blob/master/docs/lib-guide/signing.rst#2025-04-22_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nfrom pyhanko import stamp\nfrom pyhanko.pdf_utils.incremental_writer import IncrementalPdfFileWriter\nfrom pyhanko.sign import fields, signers\n\n\nsigner = signers.SimpleSigner.load(...)\nwith open('document.pdf', 'rb') as inf:\n    w = IncrementalPdfFileWriter(inf)\n    fields.append_signature_field(\n        w, sig_field_spec=fields.SigFieldSpec(\n            'Signature', box=(200, 600, 400, 660)\n        )\n    )\n\n    meta = signers.PdfSignatureMetadata(field_name='Signature')\n    pdf_signer = signers.PdfSigner(\n        meta, signer=signer,\n        stamp_style=stamp.StaticStampStyle.from_pdf_file('my-fancy-appearance.pdf')\n    )\n    with open('document-signed.pdf', 'wb') as outf:\n        pdf_signer.sign_pdf(w, output=outf)\n```\n\n----------------------------------------\n\nTITLE: Creating Signature Fields with pyHanko CLI\nDESCRIPTION: Command syntax for adding empty signature fields to a PDF document. The command specifies page number, coordinates for the bounding box, and field name.\nSOURCE: https://github.com/matthiasvalvekens/pyhanko/blob/master/docs/cli-guide/signing.rst#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\npyhanko sign addfields --field  PAGE/X1,Y1,X2,Y2/NAME input.pdf output.pdf\n```\n\n----------------------------------------\n\nTITLE: Implementing Asynchronous Google Cloud KMS Signer in Python\nDESCRIPTION: This snippet shows the beginning of a custom Signer implementation for Google Cloud KMS using the Google Cloud client library. It defines data classes for GCP key rings and keys, and the start of the GCPKMSSigner class.\nSOURCE: https://github.com/matthiasvalvekens/pyhanko/blob/master/docs/lib-guide/adv-examples.rst#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n@dataclass(frozen=True)\nclass GCPKeyRing:\n    project_id: str\n    location_id: str\n    key_ring_id: str\n\n\n@dataclass(frozen=True)\nclass GCPKMSKey:\n    key_ring: GCPKeyRing\n    key_id: str\n    version_id: str\n\n    @property\n    def path(self) -> str:\n        return kms.KeyManagementServiceAsyncClient.crypto_key_version_path(\n            self.key_ring.project_id,\n            self.key_ring.location_id,\n            self.key_ring.key_ring_id,\n            self.key_id,\n            self.version_id,\n        )\n\nclass GCPKMSSigner(Signer):\n\n    def __init__(\n        self, *, signing_cert: x509.Certificate, kms_key: GCPKMSKey, **kwargs\n    ):\n        self.kms_key = kms_key\n        self.client = kms.KeyManagementServiceAsyncClient()\n```\n\n----------------------------------------\n\nTITLE: Configuring PKCS#11 Setups in PyHanko YAML\nDESCRIPTION: This snippet shows how to define named PKCS#11 setups in the PyHanko configuration file, including module path, token criteria, and certificate label.\nSOURCE: https://github.com/matthiasvalvekens/pyhanko/blob/master/docs/cli-guide/config.rst#2025-04-22_snippet_5\n\nLANGUAGE: yaml\nCODE:\n```\npkcs11-setups:\n    test-setup:\n        module-path: /usr/lib/libsofthsm2.so\n        token-criteria:\n            label: testrsa\n        cert-label: signer\n```\n\n----------------------------------------\n\nTITLE: Simplified Completion of Non-PAdES Interrupted PDF Signing\nDESCRIPTION: A simplified way to complete an interrupted signing process for non-PAdES signatures where post-signature processing is not required. This is a one-line alternative to the more complex async_finish_signing method.\nSOURCE: https://github.com/matthiasvalvekens/pyhanko/blob/master/docs/lib-guide/signing.rst#2025-04-22_snippet_12\n\nLANGUAGE: python\nCODE:\n```\nprep_digest.fill_with_cms(output_handle, sig_cms)\n```\n\n----------------------------------------\n\nTITLE: Configuring On-Disk Key Material Setups in PyHanko YAML\nDESCRIPTION: This snippet demonstrates how to configure named setups for on-disk key material, including PKCS#12 and PEM/DER formats.\nSOURCE: https://github.com/matthiasvalvekens/pyhanko/blob/master/docs/cli-guide/config.rst#2025-04-22_snippet_8\n\nLANGUAGE: yaml\nCODE:\n```\npkcs12-setups:\n    foo:\n        pfx-file: path/to/signer.pfx\n        other-certs: path/to/more/certs.chain.pem\npemder-setups:\n    bar:\n        key-file: path/to/signer.key.pem\n        cert-file: path/to/signer.cert.pem\n        other-certs: path/to/more/certs.chain.pem\n```\n\n----------------------------------------\n\nTITLE: Modifying PDF Files with IncrementalPdfFileWriter\nDESCRIPTION: Demonstrates how to modify a PDF file using IncrementalPdfFileWriter with in-place writing. Opens the file in binary read-write mode to allow appending updates.\nSOURCE: https://github.com/matthiasvalvekens/pyhanko/blob/master/docs/lib-guide/reading-writing.rst#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom pyhanko.pdf_utils.incremental_writer import IncrementalPdfFileWriter\n\nwith open('document.pdf', 'rb+') as doc:\n    w = IncrementalPdfFileWriter(doc)\n    # ... do stuff ...\n    w.write_in_place()\n```\n\n----------------------------------------\n\nTITLE: Reading PDF Files with PdfFileReader\nDESCRIPTION: Demonstrates how to read a PDF file from disk using PdfFileReader. Opens the file in binary read mode and creates a reader instance.\nSOURCE: https://github.com/matthiasvalvekens/pyhanko/blob/master/docs/lib-guide/reading-writing.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom pyhanko.pdf_utils.reader import PdfFileReader\n\nwith open('document.pdf', 'rb') as doc:\n    r = PdfFileReader(doc)\n    # ... do stuff ...\n```\n\n----------------------------------------\n\nTITLE: Setting Default Validation Context in PyHanko YAML\nDESCRIPTION: This snippet demonstrates how to set a default validation context and define multiple validation setups in the PyHanko configuration file.\nSOURCE: https://github.com/matthiasvalvekens/pyhanko/blob/master/docs/cli-guide/config.rst#2025-04-22_snippet_2\n\nLANGUAGE: yaml\nCODE:\n```\ndefault-validation-context: setup-a\nvalidation-contexts:\n    setup-a:\n        trust: customca.pem.cert\n        trust-replace: true\n        other-certs: some-cert.pem.cert\n    setup-b:\n        trust: customca.pem.cert\n        trust-replace: false\n```\n\n----------------------------------------\n\nTITLE: Defining Stamp Styles in YAML for pyHanko\nDESCRIPTION: YAML configuration demonstrating how to define two stamp styles for PDF signatures: a default text-based style and a QR code style with custom font settings.\nSOURCE: https://github.com/matthiasvalvekens/pyhanko/blob/master/docs/cli-guide/config.rst#2025-04-22_snippet_11\n\nLANGUAGE: yaml\nCODE:\n```\nstamp-styles:\n    default:\n        type: text\n        background: __stamp__\n        stamp-text: \"Signed by %(signer)s\\nTimestamp: %(ts)s\"\n        text-box-style:\n            font: NotoSerif-Regular.otf\n    noto-qr:\n        type: qr\n        background: background.png\n        stamp-text: \"Signed by %(signer)s\\nTimestamp: %(ts)s\\n%(url)s\"\n        text-box-style:\n            font: NotoSerif-Regular.otf\n            leading: 13\n```\n\n----------------------------------------\n\nTITLE: Advanced Stamp Layout Configuration in YAML for pyHanko\nDESCRIPTION: YAML configuration for a more complex stamp style with custom background image positioning, opacity settings, and text box alignment with custom margins.\nSOURCE: https://github.com/matthiasvalvekens/pyhanko/blob/master/docs/cli-guide/config.rst#2025-04-22_snippet_12\n\nLANGUAGE: yaml\nCODE:\n```\nstamp-styles:\n    more-complex-demo:\n        type: text\n        stamp-text: \"Test Test Test\\n%(ts)s\"\n        background: image.png\n        background-opacity: 1\n        background-layout:\n          x-align: left\n          margins:\n            left: 10\n            top: 10\n            bottom: 10\n        inner-content-layout:\n          x-align: right\n          margins:\n            right: 10\n```\n\n----------------------------------------\n\nTITLE: Configuring Key Usage Settings in YAML for pyHanko\nDESCRIPTION: Example YAML configuration for a validation context named 'setup-a', demonstrating how to set certificate key usage and extended key usage requirements for signature validation.\nSOURCE: https://github.com/matthiasvalvekens/pyhanko/blob/master/docs/cli-guide/config.rst#2025-04-22_snippet_10\n\nLANGUAGE: yaml\nCODE:\n```\nvalidation-contexts:\n    setup-a:\n        trust: customca.pem.cert\n        trust-replace: true\n        other-certs: some-cert.pem.cert\n        signer-key-usage: [\"digital_signature\", \"non_repudiation\"]\n        signer-extd-key-usage: [\"code_signing\", \"2.999\"]\n```\n\n----------------------------------------\n\nTITLE: Implementing SigningCommandPlugin in Python\nDESCRIPTION: Skeleton code for implementing the SigningCommandPlugin interface to create a custom signing command for pyHanko's CLI.\nSOURCE: https://github.com/matthiasvalvekens/pyhanko/blob/master/docs/lib-guide/cli-plugins.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nclass MySigningCommand(SigningCommandPlugin):\n    subcommand_name = 'mysigner'\n    help_summary = 'a short line about the plugin'\n\n    def click_options(self) -> List[click.Option]:\n        ...\n\n    def create_signer(\n        self, context: CLIContext, **kwargs\n    ) -> ContextManager[Signer]:\n        ...\n```\n\n----------------------------------------\n\nTITLE: Configuring Logging in PyHanko YAML\nDESCRIPTION: This snippet demonstrates how to set up logging configuration in PyHanko's YAML file. It shows how to set root-level logging and module-specific logging levels and outputs.\nSOURCE: https://github.com/matthiasvalvekens/pyhanko/blob/master/docs/cli-guide/config.rst#2025-04-22_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\nlogging:\n    root-level: ERROR\n    root-output: stderr\n    by-module:\n        pyhanko_certvalidator:\n            level: DEBUG\n            output: pyhanko_certvalidator.log\n        pyhanko.sign:\n            level: DEBUG\n```\n\n----------------------------------------\n\nTITLE: Invoking pyHanko CLI with help flag\nDESCRIPTION: Shows how to invoke the pyHanko command-line interface with the help flag to access built-in documentation.\nSOURCE: https://github.com/matthiasvalvekens/pyhanko/blob/master/docs/cli-guide/index.rst#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\npyhanko --help\n```\n\n----------------------------------------\n\nTITLE: Reading In-Memory PDF Data\nDESCRIPTION: Shows how to read PDF data from an in-memory bytes buffer using BytesIO and PdfFileReader.\nSOURCE: https://github.com/matthiasvalvekens/pyhanko/blob/master/docs/lib-guide/reading-writing.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom pyhanko.pdf_utils.reader import PdfFileReader\nfrom io import BytesIO\n\nbuf = b'<PDF file data goes here>'\ndoc = BytesIO(buf)\nr = PdfFileReader(doc)\n# ... do stuff ...\n```\n\n----------------------------------------\n\nTITLE: Alternative Python module invocation of pyHanko CLI\nDESCRIPTION: Demonstrates how to run pyHanko CLI through the Python module syntax when the pyHanko executable is not on the PATH but the package is installed.\nSOURCE: https://github.com/matthiasvalvekens/pyhanko/blob/master/docs/cli-guide/index.rst#2025-04-22_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\npython -m pyhanko --help\n```\n\n----------------------------------------\n\nTITLE: Setting Retroactive Revocation Info in PyHanko YAML\nDESCRIPTION: This snippet demonstrates how to configure retroactive revocation information globally and for specific validation contexts in the PyHanko configuration file.\nSOURCE: https://github.com/matthiasvalvekens/pyhanko/blob/master/docs/cli-guide/config.rst#2025-04-22_snippet_4\n\nLANGUAGE: yaml\nCODE:\n```\nretroactive-revinfo: true\nvalidation-contexts:\n    setup-a:\n        retroactive-revinfo: false\n        trust: customca.pem.cert\n        trust-replace: true\n        other-certs: some-cert.pem.cert\n    setup-b:\n        trust: customca.pem.cert\n        trust-replace: false\n```\n\n----------------------------------------\n\nTITLE: Verifying Sigstore Signatures for PyHanko Releases Using GitHub Actions OIDC\nDESCRIPTION: This script verifies Sigstore signatures of PyHanko release artifacts. It sets environment variables for the expected version and repository, then uses the sigstore CLI tool to verify GitHub signatures against the specified identity and repository references.\nSOURCE: https://github.com/matthiasvalvekens/pyhanko/blob/master/docs/artifact-authenticity.rst#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n#!/bin/bash\n\nexport EXPECTED_VERSION=<version number goes here>\nexport REPO=MatthiasValvekens/pyHanko\nsigstore verify github \\\n    --cert-identity \"https://github.com/$REPO/.github/workflows/release.yml@refs/tags/v$EXPECTED_VERSION\" \\\n    --ref \"refs/tags/v$EXPECTED_VERSION\" \\\n    --repo \"$REPO\" \\\n    pyHanko-$EXPECTED_VERSION-*.whl pyHanko-$EXPECTED_VERSION.tar.gz\n```\n\n----------------------------------------\n\nTITLE: Importing AdES Validation Module in Python\nDESCRIPTION: This code snippet demonstrates how to import the AdES validation module in pyHanko. The module provides an experimental implementation of AdES validation according to ETSI EN 319 102-1.\nSOURCE: https://github.com/matthiasvalvekens/pyhanko/blob/master/docs/known-issues.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom pyhanko.sign.validation.ades import *\n```\n\n----------------------------------------\n\nTITLE: Configuring Time Tolerance in PyHanko YAML\nDESCRIPTION: This snippet shows how to configure global and context-specific time drift tolerance in the PyHanko configuration file.\nSOURCE: https://github.com/matthiasvalvekens/pyhanko/blob/master/docs/cli-guide/config.rst#2025-04-22_snippet_3\n\nLANGUAGE: yaml\nCODE:\n```\ntime-tolerance: 30\nvalidation-contexts:\n    setup-a:\n        time-tolerance: 180\n        trust: customca.pem.cert\n        trust-replace: true\n        other-certs: some-cert.pem.cert\n    setup-b:\n        trust: customca.pem.cert\n        trust-replace: false\n```\n\n----------------------------------------\n\nTITLE: Running pyHanko in verbose mode\nDESCRIPTION: Shows the syntax for running pyHanko with verbose output by placing the --verbose flag before the subcommand.\nSOURCE: https://github.com/matthiasvalvekens/pyhanko/blob/master/docs/cli-guide/index.rst#2025-04-22_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\npyhanko --verbose <subcommand>\n```\n\n----------------------------------------\n\nTITLE: Importing PDF Utils Module Reference Example\nDESCRIPTION: Sample module reference for importing the main pdf_utils package from pyHanko. This is the foundational package that provides PDF manipulation capabilities.\nSOURCE: https://github.com/matthiasvalvekens/pyhanko/blob/master/docs/lib-guide/pdf-utils.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom pyhanko.pdf_utils import generic, content, images, text, font\n```\n\n----------------------------------------\n\nTITLE: Verifying SLSA Provenance Data for PyHanko Release Artifacts\nDESCRIPTION: This script verifies SLSA provenance data for PyHanko release artifacts. It uses the slsa-verifier tool to validate that artifacts were built using expected parameters on the GitHub Actions platform, confirming their authenticity based on the specified version and repository.\nSOURCE: https://github.com/matthiasvalvekens/pyhanko/blob/master/docs/artifact-authenticity.rst#2025-04-22_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nexport EXPECTED_VERSION=<version number goes here>\nexport REPO=MatthiasValvekens/pyHanko\nslsa-verifier verify-artifact \\\n    --source-tag \"v$EXPECTED_VERSION\" \\\n    --provenance-path ./multiple.intoto.jsonl \\\n    --source-uri \"github.com/$REPO\" \\\n    pyHanko-$EXPECTED_VERSION-*.whl pyHanko-$EXPECTED_VERSION.tar.gz\n```\n\n----------------------------------------\n\nTITLE: Defining Click Options for PKCS#11 Subcommand in Python\nDESCRIPTION: Example of defining Click options for a simplified version of the PKCS#11 subcommand in pyHanko's CLI.\nSOURCE: https://github.com/matthiasvalvekens/pyhanko/blob/master/docs/lib-guide/cli-plugins.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ndef click_options(self) -> List[click.Option]:\n    return [\n        click.Option(\n            ('--lib',),\n            help='path to PKCS#11 module',\n            type=readable_file,\n            required=False,\n        ),\n        click.Option(\n            ('--token-label',),\n            help='PKCS#11 token label',\n            type=str,\n            required=False,\n        ),\n        click.Option(\n            ('--cert-label',),\n            help='certificate label',\n            type=str,\n            required=False,\n        ),\n        click.Option(\n            ('--key-label',), help='key label', type=str, required=False\n        ),\n    ]\n```\n\n----------------------------------------\n\nTITLE: Refactoring Signer Class in pyHanko (After Change - Option 2)\nDESCRIPTION: Second option for refactoring Signer class initialization after the breaking changes in version 0.18.0. This approach passes the values to the parent constructor through keyword arguments.\nSOURCE: https://github.com/matthiasvalvekens/pyhanko/blob/master/docs/changelog.rst#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nclass MySigner(Signer):\n    def __init__(\n        self,\n        signing_cert: x509.Certificate,\n        cert_registry: CertificateStore,\n        *args, **kwargs\n    ):\n        super().__init__(\n            signing_cert=signing_cert,\n            cert_registry=cert_registry,\n            signature_mechanism=signature_mechanism\n        )\n```\n\n----------------------------------------\n\nTITLE: Configuring GCP KMS Keyring in Python\nDESCRIPTION: Defines a GCP KMS keyring configuration with project ID, region, and keyring name for use with pyHanko's PDF signing functionality.\nSOURCE: https://github.com/matthiasvalvekens/pyhanko/blob/master/docs/lib-guide/adv-examples.rst#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nKEYRING = GCPKeyRing(\"my-project-id\", \"europe-west1\", \"pyhanko-test\")\n```\n\n----------------------------------------\n\nTITLE: Executing PDF Signing Test Function with asyncio in Python\nDESCRIPTION: Code that runs the PDF signing test function using asyncio, providing specific file paths and key information as parameters.\nSOURCE: https://github.com/matthiasvalvekens/pyhanko/blob/master/docs/lib-guide/adv-examples.rst#2025-04-22_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nasyncio.run(\n    run_test(\n        'input.pdf',\n        'output.pdf',\n        'my-test-key',\n        'signer.cert.pem',\n        'ca-certs.cert.pem'\n    )\n)\n```\n\n----------------------------------------\n\nTITLE: Checking for Whitespace Errors in Git\nDESCRIPTION: This Git command checks for whitespace errors in the staged changes, helping to maintain clean and consistent code formatting.\nSOURCE: https://github.com/matthiasvalvekens/pyhanko/blob/master/CONTRIBUTING.md#2025-04-22_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ngit diff-index --check --cached HEAD\n```\n\n----------------------------------------\n\nTITLE: Running Black for Code Formatting in Python\nDESCRIPTION: This command runs the Black code formatter to check Python code style conformance. It sets the line length to 80 characters and disables string literal standardization.\nSOURCE: https://github.com/matthiasvalvekens/pyhanko/blob/master/CONTRIBUTING.md#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nblack -S --line-length 80 --check\n```\n\n----------------------------------------\n\nTITLE: Implementing Asynchronous AWS KMS Signer in Python\nDESCRIPTION: This snippet demonstrates how to create a custom Signer class that uses AWS KMS asynchronously with aioboto3. It includes the AsyncKMSSigner class implementation and a run function to use the signer for PDF signing.\nSOURCE: https://github.com/matthiasvalvekens/pyhanko/blob/master/docs/lib-guide/adv-examples.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport asyncio\n\nimport aioboto3\n\nfrom asn1crypto import x509, algos\nfrom cryptography.hazmat.primitives import hashes\n\nfrom pyhanko.pdf_utils.incremental_writer import IncrementalPdfFileWriter\nfrom pyhanko.sign import Signer, signers\nfrom pyhanko.sign.general import (\n    get_pyca_cryptography_hash,\n    load_cert_from_pemder,\n)\nfrom pyhanko_certvalidator.registry import SimpleCertificateStore\n\n\nclass AsyncKMSSigner(Signer):\n    def __init__(\n        self,\n        session: aioboto3.session,\n        key_id: str,\n        signing_cert: x509.Certificate,\n        signature_mechanism: algos.SignedDigestAlgorithm,\n        # this can be derived from the above, obviously\n        signature_mechanism_aws_id: str,\n        other_certs=(),\n    ):\n        self.session = session\n        self.key_id = key_id\n        self.signature_mechanism = signature_mechanism\n        self.signature_mechanism_aws_id = signature_mechanism_aws_id\n        cr = SimpleCertificateStore()\n        cr.register_multiple(other_certs)\n        super().__init__(\n            signing_cert=signing_cert,\n            cert_registry=cr,\n        )\n\n    async def async_sign_raw(\n        self, data: bytes, digest_algorithm: str, dry_run=False\n    ) -> bytes:\n        if dry_run:\n            return bytes(256)\n\n        # Send hash to server instead of raw data\n        hash_spec = get_pyca_cryptography_hash(\n            self.signature_mechanism.hash_algo\n        )\n        md = hashes.Hash(hash_spec)\n        md.update(data)\n\n        async with self.session.client('kms') as kms_client:\n            result = await kms_client.sign(\n                KeyId=self.key_id,\n                Message=md.finalize(),\n                MessageType='DIGEST',\n                SigningAlgorithm=self.signature_mechanism_aws_id,\n            )\n            signature = result['Signature']\n            assert isinstance(signature, bytes)\n            return signature\n\n\nasync def run():\n    # Load relevant certificates\n    # Note: the AWS KMS does not provide certificates by itself,\n    # so the details of how certificates are provisioned are beyond\n    # the scope of this example.\n    cert = load_cert_from_pemder('path/to/your/signing-cert.pem')\n    chain = list(load_certs_from_pemder('path/to/chain.pem'))\n\n    # AWS credentials\n    kms_key_id = \"KEY_ID_GOES_HERE\"\n\n    # Set up aioboto3 session with ambient credentials & region\n    session = aioboto3.Session()\n\n    # Set up our signer\n    signer = AsyncKMSSigner(\n        session=session,\n        key_id=kms_key_id,\n        signing_cert=cert,\n        other_certs=chain,\n        # change the signature mechanism according to your key type\n        # I'm using an ECDSA key over the NIST-P384 (secp384r1) curve here.\n        signature_mechanism=algos.SignedDigestAlgorithm(\n            {'algorithm': 'sha384_ecdsa'}\n        ),\n        signature_mechanism_aws_id='ECDSA_SHA_384',\n    )\n\n    with open('input.pdf', 'rb') as inf:\n        w = IncrementalPdfFileWriter(inf)\n        meta = signers.PdfSignatureMetadata(field_name='AWSKMSExampleSig')\n        with open('output.pdf', 'wb') as outf:\n            await signers.async_sign_pdf(w, meta, signer=signer, output=outf)\n\n\nif __name__ == '__main__':\n    loop = asyncio.get_event_loop()\n    loop.run_until_complete(run())\n```\n\n----------------------------------------\n\nTITLE: Formatting Imports with isort in Python\nDESCRIPTION: This command uses isort to format Python import statements. It uses the Black profile for consistency and sets the line length to 80 characters.\nSOURCE: https://github.com/matthiasvalvekens/pyhanko/blob/master/CONTRIBUTING.md#2025-04-22_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nisort --profile black --line-length 80\n```\n\n----------------------------------------\n\nTITLE: Configuring Plugin Entry Point in TOML\nDESCRIPTION: Example of configuring a package entry point for a pyHanko CLI plugin in pyproject.toml.\nSOURCE: https://github.com/matthiasvalvekens/pyhanko/blob/master/docs/lib-guide/cli-plugins.rst#2025-04-22_snippet_2\n\nLANGUAGE: toml\nCODE:\n```\n[project.entry-points.\"pyhanko.cli_plugin.signing\"]\nyour_plugin = \"some_package.path.to.module:SomePluginClass\"\n```\n\n----------------------------------------\n\nTITLE: Referencing Plugins in YAML Configuration\nDESCRIPTION: Example of referencing plugins in pyHanko's YAML configuration file.\nSOURCE: https://github.com/matthiasvalvekens/pyhanko/blob/master/docs/lib-guide/cli-plugins.rst#2025-04-22_snippet_3\n\nLANGUAGE: yaml\nCODE:\n```\nplugins:\n    - some_package.path.to.module:SomePluginClass\n```\n\n----------------------------------------\n\nTITLE: Sphinx Documentation Structure for PyHanko PDF Metadata Package\nDESCRIPTION: A reStructuredText (rst) documentation file defining the structure for the pyhanko.pdf_utils.metadata package documentation. It uses Sphinx automodule directives to generate API documentation for each submodule.\nSOURCE: https://github.com/matthiasvalvekens/pyhanko/blob/master/docs/api-docs/pyhanko.pdf_utils.metadata.rst#2025-04-22_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\npyhanko.pdf\\_utils.metadata package\n===================================\n\nSubmodules\n----------\n\npyhanko.pdf\\_utils.metadata.info module\n---------------------------------------\n\n.. automodule:: pyhanko.pdf_utils.metadata.info\n   :members:\n   :undoc-members:\n   :show-inheritance:\n\npyhanko.pdf\\_utils.metadata.model module\n----------------------------------------\n\n.. automodule:: pyhanko.pdf_utils.metadata.model\n   :members:\n   :undoc-members:\n   :show-inheritance:\n\npyhanko.pdf\\_utils.metadata.xmp\\_xml module\n-------------------------------------------\n\n.. automodule:: pyhanko.pdf_utils.metadata.xmp_xml\n   :members:\n   :undoc-members:\n   :show-inheritance:\n\nModule contents\n---------------\n\n.. automodule:: pyhanko.pdf_utils.metadata\n   :members:\n   :undoc-members:\n   :show-inheritance:\n```\n\n----------------------------------------\n\nTITLE: Referencing dry_run flag in ReStructuredText\nDESCRIPTION: This RST footnote explains the purpose of the dry_run flag in estimating CMS object size, particularly its importance when using HSMs or requiring user input.\nSOURCE: https://github.com/matthiasvalvekens/pyhanko/blob/master/docs/lib-guide/signing.rst#2025-04-22_snippet_15\n\nLANGUAGE: rst\nCODE:\n```\n.. [#signerdryrun]\n   The ``dry_run`` flag is used in the estimation of the CMS object's size.\n   With key material held in memory it doesn't really matter all that much,\n   but if the signature is provided by a HSM, or requires additional input\n   on the user's end (such as a PIN), you typically don't want to use the \"real\"\n   signing method in dry-run mode.\n```\n\n----------------------------------------\n\nTITLE: Explaining timestamp token size estimation in ReStructuredText\nDESCRIPTION: This RST footnote discusses the difficulties in predicting the size of timestamp tokens due to various unknown factors, including embedded certificates.\nSOURCE: https://github.com/matthiasvalvekens/pyhanko/blob/master/docs/lib-guide/signing.rst#2025-04-22_snippet_16\n\nLANGUAGE: rst\nCODE:\n```\n.. [#tstsize]\n   The size of a timestamp token is difficult to predict ahead of time, since it\n   depends on many unknown factors, including the number & form of the various\n   certificates that might come embedded within them.\n```\n\n----------------------------------------\n\nTITLE: RST Documentation Structure\nDESCRIPTION: ReStructuredText markup defining the structure of the API reference documentation, including section headers, warnings, and table of contents.\nSOURCE: https://github.com/matthiasvalvekens/pyhanko/blob/master/docs/api-docs/modules.rst#2025-04-22_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n.. _api-reference:\n\n*************\nAPI reference\n*************\n\n.. warning::\n    Any function, class or method that is *not* covered by this documentation\n    is considered private API by definition.\n\n    Until pyHanko goes into beta, *any* part of the API is subject to\n    change without notice, but this applies doubly to the undocumented parts.\n    Tread with caution.\n\n\n.. toctree::\n   :maxdepth: 4\n\n   pyhanko\n   pyhanko_certvalidator\n```\n\n----------------------------------------\n\nTITLE: Refactoring Signer Class in pyHanko (Before Change)\nDESCRIPTION: Example of how the Signer class initialization was implemented before the breaking changes in version 0.18.0. The code shows a class that directly assigns values to properties that were later made read-only.\nSOURCE: https://github.com/matthiasvalvekens/pyhanko/blob/master/docs/changelog.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nclass MySigner(Signer):\n    def __init__(\n        self,\n        signing_cert: x509.Certificate,\n        cert_registry: CertificateStore,\n        *args, **kwargs\n    ):\n        self.signing_cert = signing_cert\n        self.cert_registry = cert_registry\n        self.signature_mechanism = signature_mechanism\n        super().__init__()\n```\n\n----------------------------------------\n\nTITLE: Refactoring Signer Class in pyHanko (After Change - Option 1)\nDESCRIPTION: First option for refactoring Signer class initialization after the breaking changes in version 0.18.0. This approach uses underscored attributes to store property values.\nSOURCE: https://github.com/matthiasvalvekens/pyhanko/blob/master/docs/changelog.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nclass MySigner(Signer):\n    def __init__(\n        self,\n        signing_cert: x509.Certificate,\n        cert_registry: CertificateStore,\n        *args, **kwargs\n    ):\n        self._signing_cert = signing_cert\n        self._cert_registry = cert_registry\n        self._signature_mechanism = signature_mechanism\n        super().__init__()\n```\n\n----------------------------------------\n\nTITLE: Running XML code generation script for pyHanko\nDESCRIPTION: Instructions to run the genxml.sh script from the project's root directory to generate code from XSD data files. This ensures proper code generation using xsdata.\nSOURCE: https://github.com/matthiasvalvekens/pyhanko/blob/master/external-schemata/CODEGEN.md#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngenxml.sh\n```\n\n----------------------------------------\n\nTITLE: Including pyHanko License Text Using reStructuredText Directives\nDESCRIPTION: A reStructuredText directive to include the main pyHanko license file in the documentation. This uses the literalinclude directive to embed the content of the LICENSE file from the parent directory.\nSOURCE: https://github.com/matthiasvalvekens/pyhanko/blob/master/docs/license.rst#2025-04-22_snippet_0\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. literalinclude:: ../LICENSE\n   :language: text\n```\n\n----------------------------------------\n\nTITLE: Including PyPDF2 License Text Using reStructuredText Directives\nDESCRIPTION: A reStructuredText directive to include the PyPDF2 license file in the documentation. This embeds the content of the LICENSE.PyPDF2 file from the pyhanko/pdf_utils directory.\nSOURCE: https://github.com/matthiasvalvekens/pyhanko/blob/master/docs/license.rst#2025-04-22_snippet_1\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. literalinclude:: ../pyhanko/pdf_utils/LICENSE.PyPDF2\n   :language: text\n```\n\n----------------------------------------\n\nTITLE: RST Documentation Structure for Font Package\nDESCRIPTION: ReStructuredText markup defining the documentation structure for pyhanko's font package and its submodules.\nSOURCE: https://github.com/matthiasvalvekens/pyhanko/blob/master/docs/api-docs/pyhanko.pdf_utils.font.rst#2025-04-22_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n.. _font-api-docs:\n\npyhanko.pdf\\_utils.font package\n===============================\n\nSubmodules\n----------\n\npyhanko.pdf\\_utils.font.api module\n----------------------------------\n\n.. automodule:: pyhanko.pdf_utils.font.api\n   :members:\n   :undoc-members:\n   :show-inheritance:\n\npyhanko.pdf\\_utils.font.basic module\n------------------------------------\n\n.. automodule:: pyhanko.pdf_utils.font.basic\n   :members:\n   :undoc-members:\n   :show-inheritance:\n\npyhanko.pdf\\_utils.font.opentype module\n---------------------------------------\n\n.. automodule:: pyhanko.pdf_utils.font.opentype\n   :members:\n   :undoc-members:\n   :show-inheritance:\n```\n\n----------------------------------------\n\nTITLE: Sphinx Documentation Structure for pyhanko_certvalidator.fetchers\nDESCRIPTION: Sphinx reStructuredText documentation layout defining the structure of the pyhanko_certvalidator.fetchers package. It includes toctree directives for subpackages and automodule directives for submodules with configuration for member documentation.\nSOURCE: https://github.com/matthiasvalvekens/pyhanko/blob/master/docs/api-docs/pyhanko_certvalidator.fetchers.rst#2025-04-22_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\npyhanko\\_certvalidator.fetchers package\n=======================================\n\nSubpackages\n-----------\n\n.. toctree::\n   :maxdepth: 4\n\n   pyhanko_certvalidator.fetchers.aiohttp_fetchers\n   pyhanko_certvalidator.fetchers.requests_fetchers\n\nSubmodules\n----------\n\npyhanko\\_certvalidator.fetchers.api module\n------------------------------------------\n\n.. automodule:: pyhanko_certvalidator.fetchers.api\n   :members:\n   :undoc-members:\n   :show-inheritance:\n\npyhanko\\_certvalidator.fetchers.common\\_utils module\n----------------------------------------------------\n\n.. automodule:: pyhanko_certvalidator.fetchers.common_utils\n   :members:\n   :undoc-members:\n   :show-inheritance:\n\nModule contents\n---------------\n\n.. automodule:: pyhanko_certvalidator.fetchers\n   :members:\n   :undoc-members:\n   :show-inheritance:\n```\n\n----------------------------------------\n\nTITLE: Importing Key Validation Functions from pyhanko.sign.validation\nDESCRIPTION: This snippet shows the main validation functions available in the pyhanko.sign.validation module. These functions are used for validating various types of signatures and timestamps in PDF documents.\nSOURCE: https://github.com/matthiasvalvekens/pyhanko/blob/master/docs/api-docs/pyhanko.sign.validation.rst#2025-04-22_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\nfrom pyhanko.sign.validation import validate_cms_signature, validate_detached_cms, validate_pdf_signature, validate_pdf_timestamp, add_validation_info, validate_pdf_ltv_signature\n```"
  }
]