[
  {
    "owner": "pygfx",
    "repo": "pygfx",
    "content": "TITLE: Basic Pygfx Usage Example: Rotating Cube\nDESCRIPTION: This Python code snippet creates a simple rotating cube using Pygfx. It imports the necessary modules, defines a cube mesh with a specified geometry and material, and creates an animation function to rotate the cube. The gfx.show function displays the cube and runs the animation before each render. It depends on the pygfx and pylinalg libraries.\nSOURCE: https://github.com/pygfx/pygfx/blob/main/README.md#_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\nimport pygfx as gfx\nimport pylinalg as la\n\ncube = gfx.Mesh(\n    gfx.box_geometry(200, 200, 200),\n    gfx.MeshPhongMaterial(color=\"#336699\"),\n)\n\nrot = la.quat_from_euler((0, 0.01), order=\"XY\")\n\ndef animate():\n    cube.local.rotation = la.quat_mul(rot, cube.local.rotation)\n\nif __name__ == \"__main__\":\n    gfx.show(cube, before_render=animate)\n\n```\n\n----------------------------------------\n\nTITLE: Creating an empty scene with Pygfx\nDESCRIPTION: This snippet demonstrates how to create an empty scene using Pygfx. A scene is a container for objects, lights, and cameras, representing the world to be rendered.\nSOURCE: https://github.com/pygfx/pygfx/blob/main/docs/guide.rst#_snippet_2\n\nLANGUAGE: Python\nCODE:\n```\nimport pygfx as gfx\n\nscene = gfx.Scene()\n```\n\n----------------------------------------\n\nTITLE: Creating a simple cube with Pygfx\nDESCRIPTION: This example demonstrates the basic usage of Pygfx to render a cube. It initializes a cube object with a specified geometry and material, then displays it using gfx.show.\nSOURCE: https://github.com/pygfx/pygfx/blob/main/docs/guide.rst#_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\nimport pygfx as gfx\n\ncube = gfx.Mesh(\n    gfx.box_geometry(200, 200, 200),\n    gfx.MeshPhongMaterial(color=\"#336699\"),\n)\n\nif __name__ == \"__main__\":\n    gfx.show(cube)\n```\n\n----------------------------------------\n\nTITLE: Creating a Renderer with Pygfx\nDESCRIPTION: This code creates a renderer using gfx.renderers.WgpuRenderer. It requires a canvas to be created first. The renderer draws the scene onto the canvas.\nSOURCE: https://github.com/pygfx/pygfx/blob/main/docs/guide.rst#_snippet_7\n\nLANGUAGE: Python\nCODE:\n```\nimport pygfx as gfx\nfrom rendercanvas.auto import RenderCanvas\n\ncanvas = RenderCanvas()\nrenderer = gfx.renderers.WgpuRenderer(canvas)\n\ncube = gfx.Mesh(\n    gfx.box_geometry(200, 200, 200),\n    gfx.MeshPhongMaterial(color=\"#336699\"),\n)\n\nif __name__ == \"__main__\":\n    gfx.show(cube, renderer=renderer)\n```\n\n----------------------------------------\n\nTITLE: Adding a cube to a scene\nDESCRIPTION: This code snippet adds a cube mesh object to a Pygfx scene.  The cube's geometry and material are defined before being added to the scene.\nSOURCE: https://github.com/pygfx/pygfx/blob/main/docs/guide.rst#_snippet_4\n\nLANGUAGE: Python\nCODE:\n```\ngeometry = gfx.box_geometry(200, 200, 200)\nmaterial = gfx.MeshPhongMaterial(color=\"#336699\")\ncube = gfx.Mesh(geometry, material)\nscene.add(cube)\n```\n\n----------------------------------------\n\nTITLE: Showing a complete scene with Pygfx\nDESCRIPTION: This snippet demonstrates how to display a complete scene, containing a cube, lights, and a camera, using gfx.show. The scene is rendered as-is, showing exactly what was created.\nSOURCE: https://github.com/pygfx/pygfx/blob/main/docs/guide.rst#_snippet_5\n\nLANGUAGE: Python\nCODE:\n```\ngfx.show(scene)\n```\n\n----------------------------------------\n\nTITLE: Creating a Canvas with rendercanvas.auto\nDESCRIPTION: This code creates a rendering canvas using the rendercanvas.auto module. This automatically selects an appropriate backend to create a window on your screen.\nSOURCE: https://github.com/pygfx/pygfx/blob/main/docs/guide.rst#_snippet_6\n\nLANGUAGE: Python\nCODE:\n```\nimport pygfx as gfx\nfrom rendercanvas.auto import RenderCanvas\n\ncanvas = RenderCanvas(size=(200, 200), title=\"A cube!\")\ncube = gfx.Mesh(\n    gfx.box_geometry(200, 200, 200),\n    gfx.MeshPhongMaterial(color=\"#336699\"),\n)\n\nif __name__ == \"__main__\":\n    gfx.show(cube, canvas=canvas)\n```\n\n----------------------------------------\n\nTITLE: Camera Controller Setup - Python\nDESCRIPTION: This snippet shows how to instantiate and configure a camera controller.  It involves creating a controller object (either OrbitController or PanZoomController) and adding default event handlers to the renderer.\nSOURCE: https://github.com/pygfx/pygfx/blob/main/docs/guide.rst#_snippet_13\n\nLANGUAGE: python\nCODE:\n```\ncontroller = gfx.OrbitController(camera)\ncontroller.add_default_event_handlers(renderer)\n```\n\n----------------------------------------\n\nTITLE: Initializing a Perspective Camera - Python\nDESCRIPTION: This snippet demonstrates how to instantiate a PerspectiveCamera in pygfx. The first argument is the field of view (fov) in degrees, and the second is the aspect ratio.  This camera type is generally intended for 3D content.\nSOURCE: https://github.com/pygfx/pygfx/blob/main/docs/guide.rst#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\ncamera = gfx.PerspectiveCamera(50, 4/3)\n```\n\n----------------------------------------\n\nTITLE: Initializing an Orthographic Camera - Python\nDESCRIPTION: This snippet shows how to create an OrthographicCamera in pygfx.  The first two arguments are the width and height, implicitly setting the aspect ratio. The `maintain_aspect` argument controls whether the aspect ratio should be maintained.\nSOURCE: https://github.com/pygfx/pygfx/blob/main/docs/guide.rst#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\ncamera = gfx.OrthographicCamera(500, 400, maintain_aspect=False)\n```\n\n----------------------------------------\n\nTITLE: Convenient Camera Orientation - Python\nDESCRIPTION: This snippet demonstrates convenient ways to orient cameras using `show_pos`, `show_object`, and `show_rect` methods. These methods also set the width and height, preparing the camera for controllers and automatically setting near and far clip planes.\nSOURCE: https://github.com/pygfx/pygfx/blob/main/docs/guide.rst#_snippet_12\n\nLANGUAGE: python\nCODE:\n```\n# Create a camera, in either way\ncamera = gfx.PerspectiveCamera(50, 4/3)\ncamera = gfx.OrthographicCamera()\n\n# Convenient orientation: similar to look_at\ncamera.local.position = (30, 40, 50)\ncamera.show_pos((0, 0, 0))\n\n# Convenient orientation: show an object\ncamera.show_object(target, view_dir=(-1, -1, -1))\n\n# Convenient orientation: show a rectangle\ncamera.show_rect(0, 1000, -5, 5, view_dir=(0, 0, -1))\n```\n\n----------------------------------------\n\nTITLE: Adding light and camera to a scene\nDESCRIPTION: This snippet adds ambient and directional lights, and a perspective camera to a Pygfx scene. The camera is positioned along the z-axis.\nSOURCE: https://github.com/pygfx/pygfx/blob/main/docs/guide.rst#_snippet_3\n\nLANGUAGE: Python\nCODE:\n```\n# and god said ...\nscene.add(gfx.AmbientLight())\nscene.add(gfx.DirectionalLight())\n\ncamera = gfx.PerspectiveCamera(70, 16 / 9)\ncamera.local.z = 400\n```\n\n----------------------------------------\n\nTITLE: Updating WorldObject Transforms - Python\nDESCRIPTION: This snippet demonstrates how to manipulate the transforms (position, rotation, scale) of a WorldObject using both local and world coordinates.  It also covers setting individual components of the transform.\nSOURCE: https://github.com/pygfx/pygfx/blob/main/docs/guide.rst#_snippet_14\n\nLANGUAGE: python\nCODE:\n```\ncube = gfx.Mesh(\n    gfx.box_geometry(10, 10, 10),\n    gfx.MeshPhongMaterial(color=\"#808080\"),\n)\n\ncube.world.position = (1, 2, 3)\ncube.world.rotation = la.quat_from_euler(\n    (np.pi/2, np.pi/2), order=\"YX\"\n)\ncube.world.scale = (2, 4, 6)\ncube.world.scale = 3  # uniform scale\n\n# setting components only\ncube.local.x = 1\ncube.local.y = 10\ncube.local.z = 100\n\ncube.local.scale_x = 2\ncube.local.scale_y = 4\ncube.local.scale_z = 6\n```\n\n----------------------------------------\n\nTITLE: Color Specification - Python\nDESCRIPTION: This snippet demonstrates various ways to specify colors in Pygfx, including using color names, hexadecimal codes, and RGB tuples. Colors can have 1 to 4 components (grayscale, grayscale+alpha, rgb, rgba).\nSOURCE: https://github.com/pygfx/pygfx/blob/main/docs/guide.rst#_snippet_17\n\nLANGUAGE: python\nCODE:\n```\nmaterial.color = \"red\"\nmaterial.color = \"#ff0000\"\nmaterial.color = 1, 0, 0\n```\n\n----------------------------------------\n\nTITLE: Defining a Basic Shader Class in Pygfx (Python)\nDESCRIPTION: This code snippet demonstrates the basic structure of a Pygfx shader class, including registration, initialization, binding definition, pipeline and render information, and code generation. It shows how to define a shader for a specific WorldObject and Material combination, define bindings, and specify pipeline and render information.\nSOURCE: https://github.com/pygfx/pygfx/blob/main/docs/advanced_shaders.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom pygfx.renderers.wgpu import (\n    register_wgpu_render_function, WorldObjectShader, Binding, RenderMask\n)\n\n@register_wgpu_render_function(SomeWorldObject, SomeMaterial)\nclass SomeShader(WorldObjectShader):\n\n    type = \"render\"  # must be \"render\" or \"compute\"\n\n    def ___init__(self, wobject):\n        super().__init__(wobject)\n\n        # The __init__ is a good place to examine the material and geometry and set any template-variables that\n        # affect the final wgsl. By accessing `material.has_some_value` here, the value is tracked, so that when\n        # `material.has_some_value` changes later, the shader is re-compiled.\n        if material.has_some_value:\n            self[\"some_template_variable\"] = True\n\n    def get_bindings(self, wobject, shared):\n\n        # You can also set template-variables here. Again, when things that are used here change later, this\n        # is detected, and this method will be called again. When a binding has changed (e.g. a colormap is replaced\n        # with another) while the formats etc. match, the shader code is not re-composed / re-compiled, making\n        # such actions very efficient.\n        if getattr(geometry, \"colors\"):\n            self[\"use_color_buffer\"] = True\n\n        # Collect bindings. We must return a dict mapping slot\n        # indices to Binding objects. But it's sometimes easier to\n        # collect bindings in a list and then convert to a dict.\n        bindings = [\n            Binding(\"u_stdinfo\", \"buffer/uniform\", shared.uniform_buffer),\n            Binding(\"u_wobject\", \"buffer/uniform\", wobject.uniform_buffer),\n            Binding(\"u_material\", \"buffer/uniform\", wobject.material.uniform_buffer),\n            ...\n        ]\n        bindings = {i:b for i, b in enumerate(bindings)}\n        # Generate the WGSL code for these bindings\n        self.define_bindings(0, bindings)\n        # The \"bindings\" are grouped as a dict of dicts. Often only\n        # bind-group 0 is used.\n        return {\n            0: bindings,\n        }\n\n    def get_pipeline_info(self, wobject, shared):\n        # Result. All fields are mandatory.\n        return {\n            \"primitive_topology\": wgpu.PrimitiveTopology.triangle_list,\n            \"cull_mode\": wgpu.CullMode.none,\n        }\n\n    def get_render_info(self, wobject, shared):\n        n_vertices = ...\n        n_instances = 1\n        render_mask = wobject.render_mask\n        if not render_mask:\n            render_mask = RenderMask.all\n        # Result. All fields are mandatory. The RenderMask.all is a safe\n        # value; other values are optimizations.\n        return {\n            \"indices\": (n_vertices, n_instances),\n            \"render_mask\": render_mask,\n        }\n\n    def get_code(self):\n        # Return combination of code pieces.\n        return \"\"\"\n        {$ include 'pygfx.std.wgsl' $}\n\n        @stage(vertex)\n        fn vs_main(@builtin(vertex_index) index: u32) -> @builtin(position) vec4<f32> {\n            ...\n        }\n\n        @stage(fragment)\n        fn fs_main() -> FragmentOutput {\n           ...\n        }\n\n        \"\"\"\n\n```\n\n----------------------------------------\n\nTITLE: Installing Pygfx and GLFW using pip\nDESCRIPTION: This code snippet demonstrates how to install the Pygfx library and GLFW (Graphics Library Framework) using pip, the Python package installer. GLFW is a lightweight windowing library required for Pygfx to render to a window. The -U flag ensures that the packages are upgraded to the latest version if already installed.\nSOURCE: https://github.com/pygfx/pygfx/blob/main/README.md#_snippet_0\n\nLANGUAGE: Bash\nCODE:\n```\npip install -U pygfx glfw\n```\n\n----------------------------------------\n\nTITLE: Installing Pygfx with pip\nDESCRIPTION: This code snippet shows how to install Pygfx using the pip package manager. It ensures that the latest version of Pygfx is installed.\nSOURCE: https://github.com/pygfx/pygfx/blob/main/docs/guide.rst#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\npip install -U pygfx\n```\n\n----------------------------------------\n\nTITLE: WGSL Code Example with Vertex and Fragment Shaders (WGSL)\nDESCRIPTION: This code snippet showcases a basic WGSL shader structure with vertex and fragment shader functions. The vertex shader `vs_main` takes a vertex index as input and returns a position. The fragment shader `fs_main` returns a `FragmentOutput`.  The `{$ include 'pygfx.std.wgsl' $}` directive includes standard WGSL code from Pygfx.\nSOURCE: https://github.com/pygfx/pygfx/blob/main/docs/advanced_shaders.rst#_snippet_1\n\nLANGUAGE: wgsl\nCODE:\n```\n{$ include 'pygfx.std.wgsl' $}\n\n@stage(vertex)\nfn vs_main(@builtin(vertex_index) index: u32) -> @builtin(position) vec4<f32> {\n    ...\n}\n\n@stage(fragment)\nfn fs_main() -> FragmentOutput {\n   ...\n}\n\n```\n\n----------------------------------------\n\nTITLE: Using Varyings to Pass Data (Python & WGSL)\nDESCRIPTION: This snippet shows how to define varyings in the vertex shader and use them in the fragment shader.  The vertex shader creates a `Varyings` struct and populates it with values that are then passed to the fragment shader. Pygfx automatically handles the Varyings struct definition. An explicit type cast is required.\nSOURCE: https://github.com/pygfx/pygfx/blob/main/docs/advanced_shaders.rst#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ndef get_code(self):\n    return \"\"\"\n    ...\n\n    @stage(vertex)\n    fn vs_main(@builtin(vertex_index) index: u32) -> Varyings {\n        ...\n        var varyings: Varyings;\n        varyings.position = vec4<f32>(screen_pos_ndc, ndc_pos.zw);\n        varyings.world_pos = vec3<f32>(world_pos.xyz / world_pos.w);\n        return varyings;\n    }\n\n    @stage(fragment)\n    fn fs_main(varyings: Varyings) -> FragmentOutput {\n        ...\n        let world_pos = varyings.world_pos;\n        ...\n    }\n    \"\"\"\n```\n\nLANGUAGE: wgsl\nCODE:\n```\n@stage(vertex)\nfn vs_main(@builtin(vertex_index) index: u32) -> Varyings {\n    ...\n    var varyings: Varyings;\n    varyings.position = vec4<f32>(screen_pos_ndc, ndc_pos.zw);\n    varyings.world_pos = vec3<f32>(world_pos.xyz / world_pos.w);\n    return varyings;\n}\n\n@stage(fragment)\nfn fs_main(varyings: Varyings) -> FragmentOutput {\n    ...\n    let world_pos = varyings.world_pos;\n    ...\n}\n\n```\n\n----------------------------------------\n\nTITLE: Fragment Output (Python & WGSL)\nDESCRIPTION: This code demonstrates how to define the output of a fragment shader in Pygfx.  The fragment shader creates a `FragmentOutput` struct, sets the `color` field, and returns the struct.  The structure of the FragmentOutput is predefined by Pygfx and depends on the blend mode and render pass. Additional fields can be set conditionally based on the blending mode (e.g., 'dither' or 'weighted').\nSOURCE: https://github.com/pygfx/pygfx/blob/main/docs/advanced_shaders.rst#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\ndef get_code(self):\n    return \"\"\"\n    ...\n\n    @stage(fragment)\n    fn fs_main(varyings: Varyings) -> FragmentOutput {\n        ...\n        var out: FragmentOutput;\n        out.color = vec4<f32>(...);\n        return out;\n    }\n    \"\"\"\n```\n\nLANGUAGE: wgsl\nCODE:\n```\n@stage(fragment)\nfn fs_main(varyings: Varyings) -> FragmentOutput {\n    ...\n    var out: FragmentOutput;\n    out.color = vec4<f32>(...);\n    return out;\n}\n\n```\n\n----------------------------------------\n\nTITLE: Colormapping for Images/Volumes - Python/WGSL\nDESCRIPTION: This snippet shows how to implement colormapping for image/volume data. It defines bindings for the colormap and includes the necessary WGSL code for colormapping. The shader samples the texture and applies the colormap using `sample_colormap`. Dependencies: `pygfx.std.wgsl`, `pygfx.colormap.wgsl`.\nSOURCE: https://github.com/pygfx/pygfx/blob/main/docs/advanced_shaders.rst#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\ndef get_bindings(self, wobjwect, shared):\n    ...\n    extra_bindings = self.define_img_colormap(material.map)\n    bindings.extend(extra_bindings)\n    ...\n\ndef get_code(self):\n    return \"\"\"\n    {$ include 'pygfx.std.wgsl' $}\n    {$ include 'pygfx.colormap.wgsl '$}\n    ...\n\n    @stage(fragment)\n    fn fs_main(varyings: Varyings) -> FragmentOutput {\n        ...\n        let img_value = textureSample(t_img, s_img, texcoord.xy);\n        let color = sample_colormap(img_value);\n        ...\n    }\n    \"\"\"\n```\n\n----------------------------------------\n\nTITLE: Colormapping for Points/Lines/Meshes - Python/WGSL\nDESCRIPTION: This code snippet illustrates colormapping for points, lines, and meshes using vertex input data (texture coordinates). It defines bindings for the vertex colormap and includes the relevant WGSL code. The shader samples the color directly from the varying texture coordinate using `sample_colormap`. Dependencies: `pygfx.std.wgsl`, `pygfx.colormap.wgsl`.\nSOURCE: https://github.com/pygfx/pygfx/blob/main/docs/advanced_shaders.rst#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\ndef get_bindings(self, wobjwect, shared):\n    ...\n    extra_bindings = self.define_vertex_colormap(material.map, geometry.texcoords)\n    bindings.extend(extra_bindings)\n    ...\n\ndef get_code(self):\n    return \"\"\"\n    {$ include 'pygfx.std.wgsl' $}\n    {$ include 'pygfx.colormap.wgsl '$}\n\n    ...\n    @stage(fragment)\n    fn fs_main(varyings: Varyings) -> FragmentOutput {\n        ...\n        let color = sample_colormap(varyings.texcoord);\n        ...\n    }\n    \"\"\"\n```\n\n----------------------------------------\n\nTITLE: Templating Variables in Shaders (Python & WGSL)\nDESCRIPTION: This example demonstrates how to use jinja2 templating to set variables in WGSL code from Python. The Python code sets the `scale` template variable, which is then used in the WGSL vertex shader.  Using uniforms is recommended for variables that may change often to avoid recompilation.\nSOURCE: https://github.com/pygfx/pygfx/blob/main/docs/advanced_shaders.rst#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ndef get_bindings(self, wobject, shared):\n    # Template variables can be set like this\n    self[\"scale\"] = 1.2\n    ...\n\ndef get_code(self):\n    # Return combination of code pieces.\n    return \"\"\"\n    ...\n\n    @stage(vertex)\n    fn vs_main(@builtin(vertex_index) index: u32) -> @builtin(position) vec4<f32> {\n        let something = x * {{ scale }};\n    }\n    \"\"\"\n```\n\nLANGUAGE: wgsl\nCODE:\n```\n@stage(vertex)\nfn vs_main(@builtin(vertex_index) index: u32) -> @builtin(position) vec4<f32> {\n    let something = x * {{ scale }};\n}\n\n```\n\n----------------------------------------\n\nTITLE: Falling Cube Simulation - Python\nDESCRIPTION: This snippet demonstrates a small simulation of a falling and rotating cube. It uses pygfx for rendering and pylinalg for linear algebra operations. It simulates gravity, velocity, angular moment, and IMU sensor readings.\nSOURCE: https://github.com/pygfx/pygfx/blob/main/docs/guide.rst#_snippet_16\n\nLANGUAGE: python\nCODE:\n```\nimport numpy as np\nimport pygfx as gfx\nimport pylinalg as la\n\ncompanion_cube = gfx.Mesh(\n    gfx.box_geometry(1, 1, 1),\n    gfx.MeshPhongMaterial(color=\"#808080\"),\n)\ncompanion_cube.world.position = (0, 100, 0)\n\n# add an IMU sensor to the corner of the cube (IMUs measure acceleration)\nimu_sensor = gfx.WorldObject()\ncompanion_cube.add(imu_sensor)\nimu_sensor.local.position = (0.5, 0.5, 0.5)\nimu_mass = 0.005  # kg\n\n# obligatory small rotation\nrot = la.quat_from_euler((0.01, 0.05), order=\"XY\")\naxis, angle = la.quat_to_axis_angle(rot)\n\n# simulate falling cube\ngravity = -9.81 * companion_cube.world.reference_up\nvelocity = np.zeros(3)\nupdate_frequency = 1 / 50  #  Hz\nfor _ in range(200):\n    # the cube is falling\n    velocity = velocity + update_frequency * gravity\n    companion_cube.world.position += update_frequency * velocity\n\n    # and spinning around.\n    companion_cube.local.rotation = la.quat_mul(\n        rot, companion_cube.local.rotation\n    )\n\n    # The sensor has some velocity relative to the companion cube as it rotates\n    # around the latter\n    angular_moment = angle / update_frequency\n    velocity_rotation = np.cross(angular_moment * axis, imu_sensor.local.position)\n\n    # and is thus experiencing both gravity and centripetal forces\n    local_gravity = -9.81 * imu_sensor.local.reference_up\n    local_centripetal = np.cross(angular_moment * axis, velocity_rotation)\n\n    # The IMU thus measures the composite of the above accelerations\n    observed_acceleration = local_gravity + local_centripetal\n\n    total_g = np.linalg.norm(observed_acceleration) / 9.81\n    print(f\"Feels like: {total_g:.3} g\")\n```\n\n----------------------------------------\n\nTITLE: Implementing Picking in Fragment Shader - Python/WGSL\nDESCRIPTION: This code snippet shows how to implement picking functionality in a fragment shader using WGSL. It demonstrates packing various picking-related values into a single `u64` using the `pick_pack` function, which is then assigned to the `out.pick` variable. The snippet requires a corresponding `_wgpu_get_pick_info()` method in the material to unpack the picking information.\nSOURCE: https://github.com/pygfx/pygfx/blob/main/docs/advanced_shaders.rst#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\ndef get_code(self):\n    return \"\"\"\n    ...\n\n    @stage(fragment)\n    fn fs_main(varyings: Varyings) -> FragmentOutput {\n        ...\n        var out: FragmentOutput;\n        out.color = color;\n\n        // The builtin write_pick templating variable should be used\n        // to ensure picking info is only written in the appropriate render pass\n        $$ if write_pick\n        // 20 + 26 + 6 + 6 + 6 = 64\n        out.pick = (\n            pick_pack(varyings.pick_id, 20) +\n            pick_pack(varyings.pick_idx, 26) +\n            pick_pack(u32(varyings.pick_coords.x * 64.0), 6) +\n            pick_pack(u32(varyings.pick_coords.y * 64.0), 6) +\n            pick_pack(u32(varyings.pick_coords.z * 64.0), 6)\n        );\n        $$ endif\n\n        return out;\n    }\n    \"\"\"\n```\n\n----------------------------------------\n\nTITLE: Manual Camera Orientation - Python\nDESCRIPTION: This snippet illustrates how to manually orient a PerspectiveCamera by setting its position and rotation using the `look_at` method. It requires setting the width in addition to fov and aspect ratio.\nSOURCE: https://github.com/pygfx/pygfx/blob/main/docs/guide.rst#_snippet_11\n\nLANGUAGE: python\nCODE:\n```\n# Manual orientation\ncamera = gfx.PerspectiveCamera(50, 4/3, width=100)\ncamera.local.position = (30, 40, 50)\ncamera.look_at((0, 0, 0))\n```\n\n----------------------------------------\n\nTITLE: Animating a cube using before_render\nDESCRIPTION: This code animates a cube by rotating it before each render. It uses the before_render callback of gfx.show to modify the cube's rotation.\nSOURCE: https://github.com/pygfx/pygfx/blob/main/docs/guide.rst#_snippet_8\n\nLANGUAGE: Python\nCODE:\n```\nimport pygfx as gfx\nimport pylinalg as la\n\ncube = gfx.Mesh(\n    gfx.box_geometry(200, 200, 200),\n    gfx.MeshPhongMaterial(color=\"#336699\"),\n)\n\nrot = la.quat_from_euler((0, 0.01), order=\"XY\")\n\ndef animate():\n    cube.local.rotation = la.quat_mul(rot, cube.local.rotation)\n\nif __name__ == \"__main__\":\n    gfx.show(cube, before_render=animate)\n```\n\n----------------------------------------\n\nTITLE: Enabling Picking for a Material (Python)\nDESCRIPTION: This code shows how to enable picking for a material by setting the `pick_write` parameter to `True`. This allows the shader to write picking information to the `pick` field of the `FragmentOutput` struct.\nSOURCE: https://github.com/pygfx/pygfx/blob/main/docs/advanced_shaders.rst#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\ncube = gfx.Mesh(\n    gfx.box_geometry(200, 200, 200),\n    gfx.MeshBasicMaterial(map=tex, opacity=0.8, pick_write=True),\n)\n```\n\n----------------------------------------\n\nTITLE: Including Clipping Planes Shader Chunk - Python/WGSL\nDESCRIPTION: This code snippet demonstrates how to include the WGSL code for clipping planes in a shader using the `include` directive. The `pygfx.clipping_planes.wgsl` chunk provides common features that apply to most objects. This example assumes that a fragment shader exists and the include is used within the body of `fs_main`.\nSOURCE: https://github.com/pygfx/pygfx/blob/main/docs/advanced_shaders.rst#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\ndef get_code(self):\n    return \"\"\"\n    ...\n\n    @stage(fragment)\n    fn fs_main(varyings: Varyings) -> FragmentOutput {\n        ...\n\n        // clipping planes\n        {$ include 'pygfx.clipping_planes.wgsl' $}\n\n        var out: FragmentOutput;\n        out.color = color;\n        return out;\n    }\n    \"\"\"\n```\n\n----------------------------------------\n\nTITLE: Conditional Fragment Output (WGSL)\nDESCRIPTION: This snippet shows how to conditionally set fields in the `FragmentOutput` struct based on the blending mode. It demonstrates setting `seed1` for dithered blending and `weight` for weighted blending, using `$$ if` directives to control code inclusion.\nSOURCE: https://github.com/pygfx/pygfx/blob/main/docs/advanced_shaders.rst#_snippet_5\n\nLANGUAGE: wgsl\nCODE:\n```\n...\nvar out: FragmentOutput;\nout.color = vec4<f32>(...);\n$$ if blending == 'dither'\nout.seed1 = f32(...);\n$$ endif\nreturn out;\n\n... or set the weight for weighted blending:\n\n...\nvar out: FragmentOutput;\nout.color = vec4<f32>(...);\n$$ if blending == 'weighted'\nout.weight = f32(...);\n$$ endif\nreturn out;\n```\n\n----------------------------------------\n\nTITLE: Initializing RenderCanvas for Jupyter\nDESCRIPTION: This snippet demonstrates how to initialize a RenderCanvas within a Jupyter notebook using WGPU. It creates a RenderCanvas instance and uses it to instantiate a WgpuRenderer. This setup allows rendering Pygfx scenes within the Jupyter environment.\nSOURCE: https://github.com/pygfx/pygfx/blob/main/docs/guide.rst#_snippet_18\n\nLANGUAGE: python\nCODE:\n```\nfrom rendercanvas.jupyter import RenderCanvas\n\ncanvas = RenderCanvas()\nrenderer = gfx.renderers.WgpuRenderer(canvas)\n\n...\n\ncanvas  # cell output\n```\n\n----------------------------------------\n\nTITLE: Transform Update Limitations - Python\nDESCRIPTION: This snippet highlights the limitations of in-place updates for slices of transform properties. Direct assignment to slices is not supported due to the underlying numpy arrays being read-only.  Adding or modifying the full property is, however, supported.\nSOURCE: https://github.com/pygfx/pygfx/blob/main/docs/guide.rst#_snippet_15\n\nLANGUAGE: python\nCODE:\n```\ncube.local.position += (0, 0, 3)  # ok\ncube.local.z += 3  # ok\n# The following two statements will fail with\n# ValueError: assignment destination is read-only.\ncube.local.position[2] += 3  # FAIL: ValueError\ncube.local.position[2] = 3  # FAIL: ValueError\n```\n\n----------------------------------------\n\nTITLE: Generating Class Documentation with autoclass\nDESCRIPTION: This Jinja2 snippet generates reStructuredText markup for a class's documentation using the `autoclass` directive. It configures the directive to show members, inheritance, and order members by source code order. A `minigallery` directive is also included to display class usage examples.\nSOURCE: https://github.com/pygfx/pygfx/blob/main/docs/_templates/custom_layout.rst#_snippet_2\n\nLANGUAGE: Jinja2\nCODE:\n```\n{% elif objtype == \"class\" %}\n\n.. autoclass:: {{ objname }}\n    :members:\n    :show-inheritance:\n    :member-order: bysource\n\n.. minigallery:: pygfx.{{ objname }}\n    :add-heading: Examples\n\n{% endif %}\n```\n\n----------------------------------------\n\nTITLE: Formatting and Linting Code with Ruff\nDESCRIPTION: This snippet shows how to use `ruff` to format and lint the code in the Pygfx project. It includes commands to reformat the code and check for linting errors.\nSOURCE: https://github.com/pygfx/pygfx/blob/main/CONTRIBUTING.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n# Reformat the code if necessary\nuff format .\n# Check for linting errors.\nuff check .\n```\n\n----------------------------------------\n\nTITLE: Development Install of Pygfx\nDESCRIPTION: This code snippet outlines the steps to set up a development environment for contributing to Pygfx. It includes cloning the forked repository, navigating into the directory, creating and activating a virtual environment (optional), installing the development, documentation, and example dependencies, and running the tests.\nSOURCE: https://github.com/pygfx/pygfx/blob/main/README.md#_snippet_2\n\nLANGUAGE: Bash\nCODE:\n```\n# Click the Fork button on GitHub and navigate to your fork\ngit clone <address_of_your_fork>\ncd pygfx\n# if you use a venv, create and activate it\npip install -e \".[dev,docs,examples]\"\npytest tests\n```\n\n----------------------------------------\n\nTITLE: Generating Function Documentation with autofunction\nDESCRIPTION: This Jinja2 snippet generates reStructuredText markup for a function's documentation using the `autofunction` directive. It also includes a `minigallery` directive to display examples of the function's usage, if available.\nSOURCE: https://github.com/pygfx/pygfx/blob/main/docs/_templates/custom_layout.rst#_snippet_1\n\nLANGUAGE: Jinja2\nCODE:\n```\n{% elif objtype == \"function\" %}\n\n.. autofunction:: {{ objname }}\n\n.. minigallery:: pygfx.{{ objname }}\n    :add-heading: Examples\n    :heading-level: ^\n\n{% endif %}\n```\n\n----------------------------------------\n\nTITLE: Generating Module Documentation with automodule\nDESCRIPTION: This Jinja2 snippet generates reStructuredText markup for a module's documentation using the `automodule` directive. It assumes the module's docstring has an autosummary section to produce a list of members, which Sphinx then uses to generate the module's documentation.\nSOURCE: https://github.com/pygfx/pygfx/blob/main/docs/_templates/custom_layout.rst#_snippet_0\n\nLANGUAGE: Jinja2\nCODE:\n```\n{% if objtype == \"module\" %}\n{# Assume that the module docstring has an autosummary section to produce a list of members. #}\n\n.. automodule:: {{ fullname }}\n\n{% endif %}\n```\n\n----------------------------------------\n\nTITLE: Generating Data Documentation with autodata\nDESCRIPTION: This Jinja2 snippet generates reStructuredText markup for documenting data (e.g., variables, constants) using the `autodata` directive.\nSOURCE: https://github.com/pygfx/pygfx/blob/main/docs/_templates/custom_layout.rst#_snippet_3\n\nLANGUAGE: Jinja2\nCODE:\n```\n{% else %}\n\n.. autodata:: {{ objname }}\n\n{% endif %}\n```\n\n----------------------------------------\n\nTITLE: Running Core Unit Tests in Pygfx\nDESCRIPTION: This code snippet shows how to run the core unit tests for Pygfx using pytest. It uses the -v flag for verbose output.\nSOURCE: https://github.com/pygfx/pygfx/blob/main/README.md#_snippet_3\n\nLANGUAGE: Bash\nCODE:\n```\npytest -v tests\n```\n\n----------------------------------------\n\nTITLE: Testing Pygfx Examples\nDESCRIPTION: This code snippet runs the unit tests specifically for the examples provided in the Pygfx repository, utilizing the pytest framework.\nSOURCE: https://github.com/pygfx/pygfx/blob/main/README.md#_snippet_4\n\nLANGUAGE: Bash\nCODE:\n```\npytest -v examples\n```\n\n----------------------------------------\n\nTITLE: Running Screenshot Tests with Software Rendering\nDESCRIPTION: This code snippet demonstrates how to run screenshot comparison tests for the Pygfx examples using the llvmpipe software rendering adapter. It also sets the PYGFX_WGPU_ADAPTER_NAME environment variable. These tests are used to validate rendering outputs.\nSOURCE: https://github.com/pygfx/pygfx/blob/main/README.md#_snippet_5\n\nLANGUAGE: Bash\nCODE:\n```\nPYGFX_WGPU_ADAPTER_NAME=llvmpipe pytest examples -k test_examples_compare\n```\n\n----------------------------------------\n\nTITLE: Configure Sphinx-Gallery with Pygfx Scraper - Python\nDESCRIPTION: This snippet shows how to configure Sphinx-gallery to use the Pygfx scraper by setting the image_scrapers option and using the find_examples_for_gallery function to update the configuration with example directories, ignore patterns, and filename patterns. The \"examples_dirs\", \"ignore_pattern\", and \"filename_pattern\" are set in the config dict.\nSOURCE: https://github.com/pygfx/pygfx/blob/main/docs/using_pygfx_gallery_scraper.rst#_snippet_0\n\nLANGUAGE: py\nCODE:\n```\nsphinx_gallery_conf = {\n    ...\n    \"image_scrapers\": (\"pygfx\",),\n}\n\nfrom pygfx.utils.gallery_scraper import find_examples_for_gallery\n\nextra_conf = find_examples_for_gallery(your_examples_dir)\nsphinx_gallery_conf.update(extra_conf)\n```"
  }
]