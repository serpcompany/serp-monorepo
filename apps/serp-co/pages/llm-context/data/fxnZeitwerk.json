[
  {
    "owner": "fxn",
    "repo": "zeitwerk",
    "content": "TITLE: Initializing Zeitwerk Loader for Gems\nDESCRIPTION: Example showing how to initialize and setup a Zeitwerk loader in the main file of a Ruby gem. Includes setup and optional eager loading.\nSOURCE: https://github.com/fxn/zeitwerk/blob/main/README.md#2025-04-18_snippet_0\n\nLANGUAGE: ruby\nCODE:\n```\n# lib/my_gem.rb (main file)\n\nrequire \"zeitwerk\"\nloader = Zeitwerk::Loader.for_gem\nloader.setup # ready!\n\nmodule MyGem\n  # ...\nend\n\nloader.eager_load # optionally\n```\n\n----------------------------------------\n\nTITLE: Setting Up Zeitwerk Loader for Generic Use\nDESCRIPTION: Demonstrates how to set up a Zeitwerk loader for generic use, including setting root directories.\nSOURCE: https://github.com/fxn/zeitwerk/blob/main/README.md#2025-04-18_snippet_10\n\nLANGUAGE: ruby\nCODE:\n```\nloader.push_dir(...)\nloader.push_dir(...)\nloader.setup\n```\n\n----------------------------------------\n\nTITLE: Generic Zeitwerk Loader Interface\nDESCRIPTION: Basic example of creating and configuring a generic Zeitwerk loader instance with directory pushing and setup.\nSOURCE: https://github.com/fxn/zeitwerk/blob/main/README.md#2025-04-18_snippet_1\n\nLANGUAGE: ruby\nCODE:\n```\nloader = Zeitwerk::Loader.new\nloader.push_dir(...)\nloader.setup # ready!\n```\n\n----------------------------------------\n\nTITLE: Configuring Reloadable Zeitwerk Loader\nDESCRIPTION: Demonstrates how to setup a reloadable Zeitwerk loader with directory configuration and reload capability.\nSOURCE: https://github.com/fxn/zeitwerk/blob/main/README.md#2025-04-18_snippet_2\n\nLANGUAGE: ruby\nCODE:\n```\nloader = Zeitwerk::Loader.new\nloader.push_dir(...)\nloader.enable_reloading # you need to opt-in before setup\nloader.setup\n...\nloader.reload\n```\n\n----------------------------------------\n\nTITLE: Setting Up Zeitwerk Loader for Gems\nDESCRIPTION: Shows how to use Zeitwerk's convenience method for setting up a loader specifically for gems with a standard structure.\nSOURCE: https://github.com/fxn/zeitwerk/blob/main/README.md#2025-04-18_snippet_11\n\nLANGUAGE: ruby\nCODE:\n```\nrequire \"zeitwerk\"\nloader = Zeitwerk::Loader.for_gem\nloader.setup\n\nmodule MyGem\n  # Since the setup has been performed, at this point we are already able\n  # to reference project constants, in this case MyGem::MyLogger.\n  include MyLogger\nend\n```\n\n----------------------------------------\n\nTITLE: Configuring and Using Reloading with Zeitwerk in Ruby\nDESCRIPTION: Demonstrates how to enable and use the reloading feature in Zeitwerk, which is useful for development environments where code changes frequently.\nSOURCE: https://github.com/fxn/zeitwerk/blob/main/README.md#2025-04-18_snippet_21\n\nLANGUAGE: ruby\nCODE:\n```\nloader = Zeitwerk::Loader.new\nloader.push_dir(...)\nloader.enable_reloading # you need to opt-in before setup\nloader.setup\n...\nloader.reload\n```\n\n----------------------------------------\n\nTITLE: Implementing Thread-Safe Reloading with Zeitwerk in Ruby\nDESCRIPTION: Shows how to implement thread-safe reloading using Zeitwerk and a read-write lock, which is crucial for concurrent environments like web frameworks.\nSOURCE: https://github.com/fxn/zeitwerk/blob/main/README.md#2025-04-18_snippet_22\n\nLANGUAGE: ruby\nCODE:\n```\nrequire \"concurrent/atomic/read_write_lock\"\n\nMyFramework::RELOAD_RW_LOCK = Concurrent::ReadWriteLock.new\n```\n\nLANGUAGE: ruby\nCODE:\n```\nMyFramework::RELOAD_RW_LOCK.with_read_lock do\n  serve(request)\nend\n```\n\nLANGUAGE: ruby\nCODE:\n```\nMyFramework::RELOAD_RW_LOCK.with_write_lock do\n  loader.reload\nend\n```\n\n----------------------------------------\n\nTITLE: Automatically Creating Modules for Directories in Ruby\nDESCRIPTION: Demonstrates how Zeitwerk automatically creates modules for directories without corresponding Ruby files, using an example of an 'admin' directory.\nSOURCE: https://github.com/fxn/zeitwerk/blob/main/README.md#2025-04-18_snippet_4\n\nLANGUAGE: ruby\nCODE:\n```\napp/controllers/admin/users_controller.rb -> Admin::UsersController\n```\n\n----------------------------------------\n\nTITLE: Defining Explicit Namespaces in Ruby\nDESCRIPTION: Shows how to explicitly define classes and modules that act as namespaces, using a 'Hotel' example with nested 'Pricing' module.\nSOURCE: https://github.com/fxn/zeitwerk/blob/main/README.md#2025-04-18_snippet_5\n\nLANGUAGE: ruby\nCODE:\n```\napp/models/hotel.rb         -> Hotel\napp/models/hotel/pricing.rb -> Hotel::Pricing\n```\n\n----------------------------------------\n\nTITLE: Eager Loading with Zeitwerk\nDESCRIPTION: Demonstrates how to use Zeitwerk's eager loading feature to load all managed files at once.\nSOURCE: https://github.com/fxn/zeitwerk/blob/main/README.md#2025-04-18_snippet_14\n\nLANGUAGE: ruby\nCODE:\n```\nloader.eager_load\n```\n\n----------------------------------------\n\nTITLE: Global Eager Loading with Zeitwerk in Ruby\nDESCRIPTION: Demonstrates how to trigger eager loading for all registered Zeitwerk loaders, which is useful for top-level services like web applications.\nSOURCE: https://github.com/fxn/zeitwerk/blob/main/README.md#2025-04-18_snippet_19\n\nLANGUAGE: ruby\nCODE:\n```\nZeitwerk::Loader.eager_load_all\n```\n\n----------------------------------------\n\nTITLE: Defining a Targeted on_load Callback\nDESCRIPTION: Demonstrates how to define a callback that executes when a specific constant is loaded. This example shows environment-specific API client configuration.\nSOURCE: https://github.com/fxn/zeitwerk/blob/main/README.md#2025-04-18_snippet_32\n\nLANGUAGE: ruby\nCODE:\n```\n# config/environments/development.rb\nloader.on_load(\"SomeApiClient\") do |klass, _abspath|\n  klass.endpoint = \"https://api.dev\"\nend\n\n# config/environments/production.rb\nloader.on_load(\"SomeApiClient\") do |klass, _abspath|\n  klass.endpoint = \"https://api.prod\"\nend\n```\n\n----------------------------------------\n\nTITLE: Eager Loading Namespaces with Zeitwerk in Ruby\nDESCRIPTION: Demonstrates how to eager load a specific namespace recursively using Zeitwerk. This is useful for loading portions of a project when full eager loading is not desired.\nSOURCE: https://github.com/fxn/zeitwerk/blob/main/README.md#2025-04-18_snippet_17\n\nLANGUAGE: ruby\nCODE:\n```\nloader.eager_load_namespace(MyApp::Routes)\n```\n\n----------------------------------------\n\nTITLE: Eager Loading Specific Directories with Zeitwerk in Ruby\nDESCRIPTION: Shows how to use Zeitwerk to eager load a specific directory recursively. This is useful when the loader is not eager loading the entire project but certain subtrees need to be loaded.\nSOURCE: https://github.com/fxn/zeitwerk/blob/main/README.md#2025-04-18_snippet_16\n\nLANGUAGE: ruby\nCODE:\n```\nloader.eager_load_dir(\"#{__dir__}/custom_web_app/routes\")\n```\n\n----------------------------------------\n\nTITLE: Implementing a Custom Inflector\nDESCRIPTION: Demonstrates how to create a custom inflector by subclassing Zeitwerk::Inflector and overriding the camelize method. This example handles HTML-prefixed basenames specially.\nSOURCE: https://github.com/fxn/zeitwerk/blob/main/README.md#2025-04-18_snippet_28\n\nLANGUAGE: ruby\nCODE:\n```\n# frozen_string_literal: true\n\nclass MyInflector < Zeitwerk::Inflector\n  def camelize(basename, abspath)\n    if basename =~ /\\Ahtml_(.*)/\n      \"HTML\" + super($1, abspath)\n    else\n      super\n    end\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Broadcasting Eager Load Namespace Across All Zeitwerk Loaders in Ruby\nDESCRIPTION: Shows how to eager load a namespace across all registered Zeitwerk loaders. This can be useful for frameworks supporting plugins with shared namespaces.\nSOURCE: https://github.com/fxn/zeitwerk/blob/main/README.md#2025-04-18_snippet_18\n\nLANGUAGE: ruby\nCODE:\n```\nZeitwerk::Loader.eager_load_namespace(MyFramework::Routes)\n```\n\n----------------------------------------\n\nTITLE: Loading Individual Files with Zeitwerk in Ruby\nDESCRIPTION: Shows how to load a specific Ruby file using Zeitwerk, which is useful when full eager loading is not desired but individual files need to be loaded.\nSOURCE: https://github.com/fxn/zeitwerk/blob/main/README.md#2025-04-18_snippet_20\n\nLANGUAGE: ruby\nCODE:\n```\nloader.load_file(\"#{__dir__}/custom_web_app/routes.rb\")\n```\n\n----------------------------------------\n\nTITLE: Eager Loading with Zeitwerk\nDESCRIPTION: Shows how to trigger eager loading for both individual loaders and globally across all Zeitwerk instances.\nSOURCE: https://github.com/fxn/zeitwerk/blob/main/README.md#2025-04-18_snippet_3\n\nLANGUAGE: ruby\nCODE:\n```\nloader.eager_load\n\n# Global eager loading\nZeitwerk::Loader.eager_load_all\n```\n\n----------------------------------------\n\nTITLE: Configuring Inflection Overrides in Zeitwerk\nDESCRIPTION: Demonstrates how to configure custom inflection rules for specific basenames. This allows you to override the default snake_case to CamelCase conversion for particular file or directory names.\nSOURCE: https://github.com/fxn/zeitwerk/blob/main/README.md#2025-04-18_snippet_23\n\nLANGUAGE: ruby\nCODE:\n```\nloader.inflector.inflect(\n  \"html_parser\"   => \"HTMLParser\",\n  \"mysql_adapter\" => \"MySQLAdapter\"\n)\n```\n\n----------------------------------------\n\nTITLE: Collapsing Directories in Zeitwerk\nDESCRIPTION: Shows how to configure Zeitwerk to collapse directories that exist for organizational purposes but shouldn't represent namespaces.\nSOURCE: https://github.com/fxn/zeitwerk/blob/main/README.md#2025-04-18_snippet_7\n\nLANGUAGE: ruby\nCODE:\n```\nloader.collapse(\"#{__dir__}/booking/actions\")\n```\n\n----------------------------------------\n\nTITLE: Using Glob Patterns for Directory Collapsing in Zeitwerk\nDESCRIPTION: Demonstrates the use of glob patterns to collapse multiple directories following a standardized structure.\nSOURCE: https://github.com/fxn/zeitwerk/blob/main/README.md#2025-04-18_snippet_8\n\nLANGUAGE: ruby\nCODE:\n```\nloader.collapse(\"#{__dir__}/*/actions\")\n```\n\n----------------------------------------\n\nTITLE: Zeitwerk Constant Path Resolution\nDESCRIPTION: Examples demonstrating how Zeitwerk resolves constant paths from filesystem paths using cpath_expected_at method.\nSOURCE: https://github.com/fxn/zeitwerk/blob/main/README.md#2025-04-18_snippet_44\n\nLANGUAGE: ruby\nCODE:\n```\nloader.cpath_expected_at(\"app/models\")                  # => \"Object\"\nloader.cpath_expected_at(\"app/models/user.rb\")          # => \"User\"\nloader.cpath_expected_at(\"app/models/hotel\")            # => \"Hotel\"\nloader.cpath_expected_at(\"app/models/hotel/billing.rb\") # => \"Hotel::Billing\"\n\nloader.cpath_expected_at(\"a/b/collapsed/c\") # => \"A::B::C\"\nloader.cpath_expected_at(\"a/b/collapsed\")   # => \"A::B\", edge case\nloader.cpath_expected_at(\"a/b\")             # => \"A::B\"\n```\n\n----------------------------------------\n\nTITLE: Collapsing Directories in Zeitwerk\nDESCRIPTION: Example of using the collapse method to flatten directory structures for namespace simplification.\nSOURCE: https://github.com/fxn/zeitwerk/blob/main/CHANGELOG.md#2025-04-18_snippet_11\n\nLANGUAGE: ruby\nCODE:\n```\nloader.collapse(\"booking/actions\")\n```\n\n----------------------------------------\n\nTITLE: Using Zeitwerk's cpath_expected_at Method in Ruby\nDESCRIPTION: Examples of using the cpath_expected_at method from Zeitwerk 2.6.9, which returns the expected constant path for a given file or directory path string. This helps understand how paths map to constants in the Zeitwerk loading system.\nSOURCE: https://github.com/fxn/zeitwerk/blob/main/CHANGELOG.md#2025-04-18_snippet_2\n\nLANGUAGE: ruby\nCODE:\n```\nloader.cpath_expected_at(\"app/models\")                  # => \"Object\"\nloader.cpath_expected_at(\"app/models/user.rb\")          # => \"User\"\nloader.cpath_expected_at(\"app/models/hotel\")            # => \"Hotel\"\nloader.cpath_expected_at(\"app/models/hotel/billing.rb\") # => \"Hotel::Billing\"\n```\n\n----------------------------------------\n\nTITLE: Collapsing Directories with Glob Patterns in Zeitwerk\nDESCRIPTION: Example of using the collapse method with glob patterns to support standardized project structures.\nSOURCE: https://github.com/fxn/zeitwerk/blob/main/CHANGELOG.md#2025-04-18_snippet_12\n\nLANGUAGE: ruby\nCODE:\n```\nloader.collapse(\"*/actions\")\n```\n\n----------------------------------------\n\nTITLE: Configuring Eager Load Exclusions in Ruby with Zeitwerk\nDESCRIPTION: Demonstrates how to exclude certain files or directories from eager loading using Zeitwerk. It also shows how to override this exclusion using the 'force' option.\nSOURCE: https://github.com/fxn/zeitwerk/blob/main/README.md#2025-04-18_snippet_15\n\nLANGUAGE: ruby\nCODE:\n```\ndb_adapters = \"#{__dir__}/my_gem/db_adapters\"\nloader.do_not_eager_load(db_adapters)\nloader.setup\nloader.eager_load # won't eager load the database adapters\n```\n\nLANGUAGE: ruby\nCODE:\n```\nloader.eager_load(force: true) # database adapters are eager loaded\n```\n\n----------------------------------------\n\nTITLE: Defining an on_setup Callback\nDESCRIPTION: Shows how to define a callback that executes when the loader is set up and on each reload. This is useful for performing initialization tasks.\nSOURCE: https://github.com/fxn/zeitwerk/blob/main/README.md#2025-04-18_snippet_31\n\nLANGUAGE: ruby\nCODE:\n```\nloader.on_setup do\n  # Ready to autoload here.\nend\n```\n\n----------------------------------------\n\nTITLE: Ignoring Files in Zeitwerk Loader\nDESCRIPTION: Demonstrates how to ignore specific files or directories in a Zeitwerk loader, useful for files that don't follow conventions or should not be autoloaded.\nSOURCE: https://github.com/fxn/zeitwerk/blob/main/README.md#2025-04-18_snippet_38\n\nLANGUAGE: ruby\nCODE:\n```\nkernel_ext = \"#{__dir__}/my_gem/core_ext/kernel.rb\"\nloader.ignore(kernel_ext)\nloader.setup\n\ncore_ext = \"#{__dir__}/my_gem/core_ext\"\nloader.ignore(core_ext)\nloader.setup\n\nrequire_relative \"my_gem/core_ext/kernel\"\n```\n\n----------------------------------------\n\nTITLE: Ignoring Database Adapters in Zeitwerk\nDESCRIPTION: Shows how to ignore database adapter files in a Zeitwerk loader to prevent eager loading of all adapters, and manually require the chosen adapter.\nSOURCE: https://github.com/fxn/zeitwerk/blob/main/README.md#2025-04-18_snippet_39\n\nLANGUAGE: ruby\nCODE:\n```\ndb_adapters = \"#{__dir__}/my_gem/db_adapters\"\nloader.ignore(db_adapters)\nloader.setup\n\nrequire \"my_gem/db_adapters/#{config[:db_adapter]}\"\n```\n\n----------------------------------------\n\nTITLE: Ignoring Test Files in Zeitwerk Using Glob Pattern\nDESCRIPTION: Demonstrates how to use a glob pattern to ignore test files mixed with implementation files in a Zeitwerk loader.\nSOURCE: https://github.com/fxn/zeitwerk/blob/main/README.md#2025-04-18_snippet_40\n\nLANGUAGE: ruby\nCODE:\n```\ntests = \"#{__dir__}/**/*_test.rb\"\nloader.ignore(tests)\nloader.setup\n```\n\n----------------------------------------\n\nTITLE: Configuring Unload Callback for Specific Class in Ruby\nDESCRIPTION: Demonstrates how to set up an on_unload callback for a specific class using Zeitwerk. This example clears a cache when the Country class is unloaded.\nSOURCE: https://github.com/fxn/zeitwerk/blob/main/README.md#2025-04-18_snippet_34\n\nLANGUAGE: ruby\nCODE:\n```\nloader.on_unload(\"Country\") do |klass, _abspath|\n  klass.clear_cache\nend\n```\n\n----------------------------------------\n\nTITLE: Alternative Style for Configuring Inflection Overrides\nDESCRIPTION: Shows an alternative approach to configuring inflection overrides by making multiple calls to the inflect method. This style may be preferred for readability or organization purposes.\nSOURCE: https://github.com/fxn/zeitwerk/blob/main/README.md#2025-04-18_snippet_24\n\nLANGUAGE: ruby\nCODE:\n```\nloader.inflector.inflect \"html_parser\" => \"HTMLParser\"\nloader.inflector.inflect \"mysql_adapter\" => \"MySQLAdapter\"\n```\n\n----------------------------------------\n\nTITLE: Configuring Simple Inflection Override\nDESCRIPTION: Demonstrates a simple inflection override for a single basename. This will affect all files and directories with the exact basename specified.\nSOURCE: https://github.com/fxn/zeitwerk/blob/main/README.md#2025-04-18_snippet_25\n\nLANGUAGE: ruby\nCODE:\n```\nloader.inflector.inflect(\"xml\" => \"XML\")\n```\n\n----------------------------------------\n\nTITLE: Defining Explicit Namespaces with Constant Assignment in Ruby\nDESCRIPTION: Example showing how to define explicit namespaces using constant assignments in Zeitwerk 2.7.0, where Data.define is used to create a Coordinates class. This approach now works for classes and modules that are also namespaces.\nSOURCE: https://github.com/fxn/zeitwerk/blob/main/CHANGELOG.md#2025-04-18_snippet_0\n\nLANGUAGE: ruby\nCODE:\n```\n# coordinates.rb\n\nCoordinates = Data.define(:x, :y)\n```\n\n----------------------------------------\n\nTITLE: Multiple Inflection Overrides for Related Terms\nDESCRIPTION: Shows how to configure multiple related inflection overrides to maintain consistency across a family of related terms. Both exact matches are needed as partial matches are not automatically handled.\nSOURCE: https://github.com/fxn/zeitwerk/blob/main/README.md#2025-04-18_snippet_26\n\nLANGUAGE: ruby\nCODE:\n```\nloader.inflector.inflect(\n  \"xml\"        => \"XML\",\n  \"xml_parser\" => \"XMLParser\"\n)\n```\n\n----------------------------------------\n\nTITLE: Using the General on_load Callback in Ruby\nDESCRIPTION: Example of a catch-all on_load callback that gets triggered for all loaded objects, receiving the constant path, value, and absolute file path.\nSOURCE: https://github.com/fxn/zeitwerk/blob/main/CHANGELOG.md#2025-04-18_snippet_5\n\nLANGUAGE: ruby\nCODE:\n```\nloader.on_load do |cpath, value, abspath|\n  # ...\nend\n```\n\n----------------------------------------\n\nTITLE: Configuring Custom Inflections in Zeitwerk\nDESCRIPTION: Example of overriding default inflection rules for specific basenames using the inflect method.\nSOURCE: https://github.com/fxn/zeitwerk/blob/main/CHANGELOG.md#2025-04-18_snippet_13\n\nLANGUAGE: ruby\nCODE:\n```\nloader.inflector.inflect \"mysql_adapter\" => \"MySQLAdapter\"\n```\n\n----------------------------------------\n\nTITLE: Assigning a Custom Inflector\nDESCRIPTION: Shows how to assign a custom inflector to the loader. This must be done before calling the setup method.\nSOURCE: https://github.com/fxn/zeitwerk/blob/main/README.md#2025-04-18_snippet_29\n\nLANGUAGE: ruby\nCODE:\n```\nloader.inflector = MyInflector.new\n```\n\n----------------------------------------\n\nTITLE: Setting Environment-specific Configuration with on_load in Ruby\nDESCRIPTION: Example of using on_load to configure environment-specific settings for an API client.\nSOURCE: https://github.com/fxn/zeitwerk/blob/main/CHANGELOG.md#2025-04-18_snippet_10\n\nLANGUAGE: ruby\nCODE:\n```\n# config/environments/development.rb\nloader.on_load(\"SomeApiClient\") do\n  SomeApiClient.endpoint = \"https://api.dev\"\n\n# config/environments/production.rb\nloader.on_load(\"SomeApiClient\") do\n  SomeApiClient.endpoint = \"https://api.prod\"\nend\n```\n\n----------------------------------------\n\nTITLE: Configuring Null Inflector\nDESCRIPTION: Shows how to use the experimental NullInflector which returns input unchanged. This allows filenames to exactly match their constant names without any transformation.\nSOURCE: https://github.com/fxn/zeitwerk/blob/main/README.md#2025-04-18_snippet_27\n\nLANGUAGE: ruby\nCODE:\n```\nloader.inflector = Zeitwerk::NullInflector.new\n```\n\n----------------------------------------\n\nTITLE: Using Zeitwerk NullInflector in Ruby\nDESCRIPTION: Example showing how to use the experimental NullInflector introduced in Zeitwerk 2.6.13, which returns input unchanged rather than applying any transformation. This requires files and directories to be named exactly like their constants.\nSOURCE: https://github.com/fxn/zeitwerk/blob/main/CHANGELOG.md#2025-04-18_snippet_1\n\nLANGUAGE: ruby\nCODE:\n```\nloader.inflector = Zeitwerk::NullInflector.new\n```\n\n----------------------------------------\n\nTITLE: Defining a Global on_load Callback\nDESCRIPTION: Shows how to define a callback that executes whenever any constant managed by the loader is loaded. This gives access to the constant path, value, and file path.\nSOURCE: https://github.com/fxn/zeitwerk/blob/main/README.md#2025-04-18_snippet_33\n\nLANGUAGE: ruby\nCODE:\n```\nloader.on_load do |cpath, value, abspath|\n  # ...\nend\n```\n\n----------------------------------------\n\nTITLE: Enabling Logging for Zeitwerk Loader\nDESCRIPTION: Demonstrates various ways to configure logging for a Zeitwerk loader, including using $stdout, custom callables, or objects that respond to debug.\nSOURCE: https://github.com/fxn/zeitwerk/blob/main/README.md#2025-04-18_snippet_36\n\nLANGUAGE: ruby\nCODE:\n```\nloader.log!\n\nloader.logger = method(:puts)\nloader.logger = ->(msg) { ... }\n\nloader.logger = Logger.new($stderr)\nloader.logger = Rails.logger\n\nZeitwerk::Loader.default_logger = method(:puts)\n```\n\n----------------------------------------\n\nTITLE: Using a Specific on_load Callback in Ruby\nDESCRIPTION: Example of registering an on_load callback for a specific constant, receiving the class and absolute path as parameters.\nSOURCE: https://github.com/fxn/zeitwerk/blob/main/CHANGELOG.md#2025-04-18_snippet_6\n\nLANGUAGE: ruby\nCODE:\n```\nloader.on_load(\"Service::NotificationsGateway\") do |klass, abspath|\n  # ...\nend\n```\n\n----------------------------------------\n\nTITLE: Setting Up Global Unload Callback in Zeitwerk\nDESCRIPTION: Shows how to configure a callback that runs when any constant managed by the Zeitwerk loader is unloaded. This provides access to the constant path, value, and absolute file path.\nSOURCE: https://github.com/fxn/zeitwerk/blob/main/README.md#2025-04-18_snippet_35\n\nLANGUAGE: ruby\nCODE:\n```\nloader.on_unload do |cpath, value, abspath|\n  # ...\nend\n```\n\n----------------------------------------\n\nTITLE: Using the on_unload Callback in Ruby\nDESCRIPTION: Example of an on_unload callback for a specific constant that runs before the constant gets unloaded.\nSOURCE: https://github.com/fxn/zeitwerk/blob/main/CHANGELOG.md#2025-04-18_snippet_7\n\nLANGUAGE: ruby\nCODE:\n```\nloader.on_unload(\"Country\") do |klass, _abspath|\n  klass.clear_cache\nend\n```\n\n----------------------------------------\n\nTITLE: Using a General on_unload Callback in Ruby\nDESCRIPTION: Example of a catch-all on_unload callback that gets triggered for all unloaded objects.\nSOURCE: https://github.com/fxn/zeitwerk/blob/main/CHANGELOG.md#2025-04-18_snippet_8\n\nLANGUAGE: ruby\nCODE:\n```\nloader.on_unload do |cpath, value, abspath|\n  # ...\nend\n```\n\n----------------------------------------\n\nTITLE: Setting Up Zeitwerk for Gem Extensions\nDESCRIPTION: Shows how to use Zeitwerk's specialized loader for gem extensions that follow naming conventions for extending existing libraries.\nSOURCE: https://github.com/fxn/zeitwerk/blob/main/README.md#2025-04-18_snippet_13\n\nLANGUAGE: ruby\nCODE:\n```\nrequire \"net/http\"\nrequire \"zeitwerk\"\n\nloader = Zeitwerk::Loader.for_gem_extension(Net::HTTP)\nloader.setup\n\nmodule Net::HTTP::NicheFeature\n  # Since the setup has been performed, at this point we are already able\n  # to reference project constants, in this case Net::HTTP::NicheFeature::MyMixin.\n  include MyMixin\nend\n```\n\n----------------------------------------\n\nTITLE: Including Nested Modules in Ruby Class Definition\nDESCRIPTION: Demonstrates how nested modules are available within the body of the class defining the namespace.\nSOURCE: https://github.com/fxn/zeitwerk/blob/main/README.md#2025-04-18_snippet_6\n\nLANGUAGE: ruby\nCODE:\n```\nclass Hotel < ApplicationRecord\n  include Pricing # works\n  ...\nend\n```\n\n----------------------------------------\n\nTITLE: Ignoring Extra Files in Zeitwerk Gem Setup\nDESCRIPTION: Demonstrates how to ignore extra files or directories when setting up Zeitwerk for a gem, or disable warnings about extra files.\nSOURCE: https://github.com/fxn/zeitwerk/blob/main/README.md#2025-04-18_snippet_12\n\nLANGUAGE: ruby\nCODE:\n```\nloader.ignore(\"#{__dir__}/generators\")\n\n# Alternatively, disable warnings:\nZeitwerk::Loader.for_gem(warn_on_extra_files: false)\n```\n\n----------------------------------------\n\nTITLE: Extracting Custom Inflector Pattern for Gems\nDESCRIPTION: Shows a pattern for extracting a custom inflector definition in a gem to keep the main file clean. This approach properly handles the module namespace declaration.\nSOURCE: https://github.com/fxn/zeitwerk/blob/main/README.md#2025-04-18_snippet_30\n\nLANGUAGE: ruby\nCODE:\n```\n# lib/my_gem/inflector.rb\nmodule MyGem\n  class Inflector < Zeitwerk::GemInflector\n    ...\n  end\nend\n\n# lib/my_gem.rb\nrequire \"zeitwerk\"\nrequire_relative \"my_gem/inflector\"\n\nloader = Zeitwerk::Loader.for_gem\nloader.inflector = MyGem::Inflector.new(__FILE__)\nloader.setup\n\nmodule MyGem\n  # ...\nend\n```\n\n----------------------------------------\n\nTITLE: Reopening Third-party Namespace Example in Ruby\nDESCRIPTION: Example showing how to define an Active Job adapter class by reopening existing namespaces rather than defining them new.\nSOURCE: https://github.com/fxn/zeitwerk/blob/main/README.md#2025-04-18_snippet_41\n\nLANGUAGE: ruby\nCODE:\n```\n# lib/active_job/queue_adapters/awesome_queue.rb\nmodule ActiveJob\n  module QueueAdapters\n    class AwesomeQueue\n      # ...\n    end\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Zeitwerk Setup with Third-party Namespaces\nDESCRIPTION: Setup code showing how to properly initialize Zeitwerk when working with third-party namespaces by requiring them first.\nSOURCE: https://github.com/fxn/zeitwerk/blob/main/README.md#2025-04-18_snippet_42\n\nLANGUAGE: ruby\nCODE:\n```\n# Ensure these namespaces are reopened, not defined.\nrequire \"active_job\"\nrequire \"active_job/queue_adapters\"\n\nrequire \"zeitwerk\"\n# By passing the flag, we acknowledge the extra directory lib/active_job\n# has to be managed by the loader and no warning has to be issued for it.\nloader = Zeitwerk::Loader.for_gem(warn_on_extra_files: false)\nloader.setup\n```\n\n----------------------------------------\n\nTITLE: Testing Zeitwerk Compliance with Eager Loading\nDESCRIPTION: Shows how to use eager loading to test compliance of a project with Zeitwerk's expectations in a test suite.\nSOURCE: https://github.com/fxn/zeitwerk/blob/main/README.md#2025-04-18_snippet_9\n\nLANGUAGE: ruby\nCODE:\n```\nbegin\n  loader.eager_load(force: true)\nrescue Zeitwerk::NameError => e\n  flunk e.message\nelse\n  assert true\nend\n```\n\n----------------------------------------\n\nTITLE: Referencing a Constant on Setup in Ruby\nDESCRIPTION: Example of using on_setup callback to reference a constant instead of using the deprecated preload API.\nSOURCE: https://github.com/fxn/zeitwerk/blob/main/CHANGELOG.md#2025-04-18_snippet_3\n\nLANGUAGE: ruby\nCODE:\n```\nloader.on_setup { User }\n```\n\n----------------------------------------\n\nTITLE: Eager Loading a Namespace in Ruby\nDESCRIPTION: Example of eager loading all constants in a namespace using the constants API within an on_setup callback.\nSOURCE: https://github.com/fxn/zeitwerk/blob/main/CHANGELOG.md#2025-04-18_snippet_4\n\nLANGUAGE: ruby\nCODE:\n```\nloader.on_setup do\n  Admin.constants(false).each { |cname| Admin.const_get(cname) }\nend\n```\n\n----------------------------------------\n\nTITLE: Forcing Eager Loading in Ruby\nDESCRIPTION: Example of using the eager_load method with the force flag to ignore eager load exclusions.\nSOURCE: https://github.com/fxn/zeitwerk/blob/main/CHANGELOG.md#2025-04-18_snippet_9\n\nLANGUAGE: ruby\nCODE:\n```\nloader.eager_load(force: true)\n```\n\n----------------------------------------\n\nTITLE: Zeitwerk Directory Introspection\nDESCRIPTION: Examples of using Zeitwerk's directory introspection methods to examine loader paths and namespaces.\nSOURCE: https://github.com/fxn/zeitwerk/blob/main/README.md#2025-04-18_snippet_43\n\nLANGUAGE: ruby\nCODE:\n```\nloader = Zeitwerk::Loader.new\nloader.push_dir(Pathname.new(\"/foo\"))\nloader.dirs # => [\"/foo\"]\n\nloader = Zeitwerk::Loader.new\nloader.push_dir(Pathname.new(\"/foo\"))\nloader.push_dir(Pathname.new(\"/bar\"), namespace: Bar)\nloader.dirs(namespaces: true) # => { \"/foo\" => Object, \"/bar\" => Bar }\n```\n\n----------------------------------------\n\nTITLE: Logging Pattern in Ruby for Zeitwerk\nDESCRIPTION: Demonstrates the recommended logging pattern for Zeitwerk to avoid unnecessary function calls and string interpolation when logging is disabled. This pattern checks if a logger exists before constructing and sending the message.\nSOURCE: https://github.com/fxn/zeitwerk/blob/main/PROJECT_RULES.md#2025-04-18_snippet_0\n\nLANGUAGE: ruby\nCODE:\n```\nlog(message) if logger\n```\n\n----------------------------------------\n\nTITLE: Configuring Loader Tag in Zeitwerk\nDESCRIPTION: Shows how to set a custom tag for a Zeitwerk loader, which is used in log traces to distinguish between different loaders.\nSOURCE: https://github.com/fxn/zeitwerk/blob/main/README.md#2025-04-18_snippet_37\n\nLANGUAGE: ruby\nCODE:\n```\nloader.tag = \"grep_me\"\n```\n\n----------------------------------------\n\nTITLE: Running Zeitwerk Test Suite in Bash\nDESCRIPTION: Commands to run the entire test suite or specific test files for the Zeitwerk project. This is used for development and testing of the Zeitwerk gem.\nSOURCE: https://github.com/fxn/zeitwerk/blob/main/README.md#2025-04-18_snippet_45\n\nLANGUAGE: bash\nCODE:\n```\nbin/test\n```\n\nLANGUAGE: bash\nCODE:\n```\nbin/test test/lib/zeitwerk/test_eager_load.rb\n```\n\n----------------------------------------\n\nTITLE: Focusing on Specific Tests in Ruby with minitest-focus\nDESCRIPTION: Example of how to use the minitest-focus gem to run specific tests in the Zeitwerk test suite. This is useful for developers working on specific features or bug fixes.\nSOURCE: https://github.com/fxn/zeitwerk/blob/main/README.md#2025-04-18_snippet_46\n\nLANGUAGE: ruby\nCODE:\n```\nfocus\ntest \"capitalizes the first letter\" do\n  assert_equal \"User\", camelize(\"user\")\nend\n```"
  }
]