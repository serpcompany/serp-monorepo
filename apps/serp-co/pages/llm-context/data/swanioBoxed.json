[
  {
    "owner": "swan-io",
    "repo": "boxed",
    "content": "TITLE: Using map and flatMap with Option Type in TypeScript\nDESCRIPTION: Shows how to use map() to transform values within an Option, and how flatMap() can be used to handle nested optional values.\nSOURCE: https://github.com/swan-io/boxed/blob/main/docs/docs/core-concepts.md#2025-04-22_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst some = Option.Some(1);\n// Option.Some<1>\n\nconst none = Option.None();\n// Option.None\n\nconst doubledSome = some.map((x) => x * 2);\n// Option.Some<2>\n\nconst doubledNone = none.map((x) => x * 2);\n// Option.None -> Nothing to transform!\n```\n\n----------------------------------------\n\nTITLE: Managing Asynchronous Data with AsyncData in a React Component (TypeScript)\nDESCRIPTION: Demonstrates using `AsyncData` from `@swan-io/boxed` within a React functional component (`UserPage`) to manage the state of fetching user data. It initializes the state with `AsyncData.NotAsked`, transitions to `AsyncData.Loading` when the effect runs, calls an asynchronous function (`queryUser`), and updates the state to `AsyncData.Done` upon completion. The component then uses the `match` method on the `AsyncData` state to conditionally render UI based on whether the request is not asked, loading, or done. Dependencies include React (`useState`, `useEffect`), `@swan-io/boxed` (`AsyncData`), and a hypothetical API module (`queryUser`, `User`).\nSOURCE: https://github.com/swan-io/boxed/blob/main/docs/docs/react-request.md#2025-04-22_snippet_1\n\nLANGUAGE: ts\nCODE:\n```\nimport { useState, useEffect } from \"react\";\nimport { AsyncData } from \"@swan-io/boxed\";\nimport { queryUser, User } from \"./api\";\n\ntype Props = {\n  userId: string;\n};\n\nconst UserPage = ({ userId }: Props) => {\n  // Initially, the request hasn't performed\n  const [user, setUser] = useState(() => AsyncData.NotAsked<User>());\n\n  useEffect(() => {\n    // Indicate that we started loading\n    setUser(AsyncData.Loading());\n    const cancel = queryUser({ userId }, (user) => {\n      // Then, set the received value\n      setUser(AsyncData.Done(user));\n    });\n    return cancel;\n  }, [userId]);\n\n  // We can then match on the value, in a flat way\n  return user.match({\n    NotAsked: () => null,\n    Loading: () => `Loading`,\n    Done: (user) => `Hello ${user.name}!`,\n  });\n};\n```\n\n----------------------------------------\n\nTITLE: Form Validation Using Result Type\nDESCRIPTION: Enhanced validation implementation using the Result type from @swan-io/boxed for better error handling and type safety.\nSOURCE: https://github.com/swan-io/boxed/blob/main/docs/docs/form-validation.md#2025-04-22_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Result } from \"@swan-io/boxed\";\n\nconst validate = (input: FormInput): Result<FormInput, Array<string>> => {\n  const errors = [];\n  const id = input.id.trim();\n  if (id.length !== 24) {\n    errors.push(\"Input ID is invalid\");\n  }\n  if (input.amount <= 0) {\n    errors.push(\"Invalid amount\");\n  }\n\n  // We can directly return a sanitized version if the validation passed\n  return errors.length === 0\n    ? Result.Ok({ ...input, id })\n    : Result.Error(errors);\n};\n```\n\n----------------------------------------\n\nTITLE: Implementing Cancellable API Request with Future in React\nDESCRIPTION: This snippet demonstrates how to use the Future construct from @swan-io/boxed to implement a cancellable API request in React. It shows how Future simplifies the implementation by encapsulating the AbortController logic and providing a cleaner interface for use in React components.\nSOURCE: https://github.com/swan-io/boxed/blob/main/docs/docs/cancellable-request.md#2025-04-22_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { useEffect } from \"react\";\nimport { Future, Result } from \"@swan-io/boxed\";\n\nconst callMyApi = (url: string) =>\n  Future.make((resolve) => {\n    const controller = new AbortController();\n\n    fetch(url, { signal: controller.signal })\n      .then((res) => res.json())\n      .then((json) => resolve(Result.Ok(json)))\n      .catch((error) => resolve(Result.Error(error)));\n\n    // Here, the implementation detail is managed in place\n    return () => controller.abort();\n  });\n\n// And the noise dissapears from your components!\nuseEffect(() => {\n  const request = callMyApi(\"/api\").tap(setState);\n  return () => request.cancel();\n}, []);\n```\n\n----------------------------------------\n\nTITLE: Handling Nested Optional Values with flatMap in TypeScript\nDESCRIPTION: Demonstrates how to use flatMap() to safely navigate through nested optional values in a complex object structure.\nSOURCE: https://github.com/swan-io/boxed/blob/main/docs/docs/core-concepts.md#2025-04-22_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\ntype UserInfo = {\n  name: Option<string>;\n};\n\ntype User = {\n  id: string;\n  info: Option<UserInfo>;\n};\n\nconst name = user\n  .flatMap((user) => user.info) // Returns the Option<UserInfo>\n  .flatMap((info) => info.name) // Returns the Option<string>\n  .getOr(\"Anonymous user\");\n```\n\n----------------------------------------\n\nTITLE: Using Future Methods in TypeScript\nDESCRIPTION: Examples of using various Future methods such as onResolve, onCancel, map, flatMap, and tap. These methods demonstrate how to work with Future values and chain operations.\nSOURCE: https://github.com/swan-io/boxed/blob/main/docs/docs/future.md#2025-04-22_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nFuture.value(1).onResolve(console.log);\n// Log: 1\n\nfuture.onCancel(() => {\n  // do something\n});\n\nFuture.value(3).map((x) => x * 2);\n// Future<6>\n\nFuture.value(3).flatMap((x) => Future.value(x * 2));\n// Future<6>\n\nFuture.value(3).tap(console.log);\n// Log: 3\n// Future<3>\n```\n\n----------------------------------------\n\nTITLE: Result Type Validation Usage\nDESCRIPTION: Example demonstrating how to use the Result type validation in both form submission and UI rendering contexts.\nSOURCE: https://github.com/swan-io/boxed/blob/main/docs/docs/form-validation.md#2025-04-22_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\n// A single codepath for handling the validation\nconst validation = validate(input);\n\nsetValidation(validation);\n\nvalidation.match({\n  Error: () => {} // do nothing\n  Ok: (sanitizedInput) => {\n    sendToServer(sanitizedInput)\n  }\n})\n\n// and pattern match in the UI code\n<Input\n  name=\"id\"\n  value={input.id}\n  onChange={id => setInput({...input, id}))}\n  hasError={validation.match({\n    Ok: () => false,\n    Error: (errors) => errors.includes(\"Input ID is invalid\"),\n  })}\n/>;\n```\n\n----------------------------------------\n\nTITLE: Creating Futures in TypeScript\nDESCRIPTION: Examples of creating different types of Futures, including simple values, futures with resolve callbacks, and futures with cancellation effects.\nSOURCE: https://github.com/swan-io/boxed/blob/main/docs/docs/future.md#2025-04-22_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Future } from \"@swan-io/boxed\";\n\n// Value\nconst future = Future.value(1);\n\n// Simple future\nconst otherFuture = Future.make((resolve) => {\n  resolve(1);\n});\n\n// Future with cancellation effect\nconst otherFuture = Future.make((resolve) => {\n  const timeoutId = setTimeout(() => {\n    resolve(1);\n  }, 1000);\n  return () => clearTimeout(timeoutId);\n});\n```\n\n----------------------------------------\n\nTITLE: Implementing Concurrent Operations with Future.concurrent in TypeScript\nDESCRIPTION: Demonstrates how to execute multiple operations with controlled concurrency using Future.concurrent. The example shows processing multiple user IDs with a maximum of 10 concurrent operations.\nSOURCE: https://github.com/swan-io/boxed/blob/main/docs/docs/concurrency.md#2025-04-22_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nFuture.concurrent(\n  userIds.map((userId) => {\n    // notice we return a function\n    return () => getUserById(userId);\n  }),\n  { concurrency: 10 },\n);\n```\n\n----------------------------------------\n\nTITLE: Creating AsyncData Values in TypeScript\nDESCRIPTION: Shows how to create AsyncData values using the NotAsked, Loading, and Done constructors from the @swan-io/boxed library.\nSOURCE: https://github.com/swan-io/boxed/blob/main/docs/docs/async-data.md#2025-04-22_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { AsyncData } from \"@swan-io/boxed\";\n\nconst notAsked = AsyncData.NotAsked();\n\nconst loading = AsyncData.Loading();\n\nconst done = AsyncData.Done(1);\n```\n\n----------------------------------------\n\nTITLE: Pattern Matching with AsyncData in TypeScript\nDESCRIPTION: Shows how to use the match() method for handling all possible states of AsyncData with different handler functions for each state.\nSOURCE: https://github.com/swan-io/boxed/blob/main/docs/docs/async-data.md#2025-04-22_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\nconst valueToDisplay = result.match({\n  Done: (value) => value,\n  Loading: () => \"Loading ...\",\n  NotAsked: () => \"\",\n});\n```\n\n----------------------------------------\n\nTITLE: Creating Option Values in TypeScript\nDESCRIPTION: Shows how to create Option values using Some and None constructors, with optional type parameters for explicit typing.\nSOURCE: https://github.com/swan-io/boxed/blob/main/docs/docs/option.md#2025-04-22_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Option } from \"@swan-io/boxed\";\n\nconst aName = Option.Some(\"John\");\nconst bName = Option.None();\n\n// You can enforce the type using a type parameter\nOption.Some<string>(\"John\");\nOption.None<string>();\n```\n\n----------------------------------------\n\nTITLE: Using flatMap() Method with AsyncData in TypeScript\nDESCRIPTION: Shows how to use the flatMap() method on AsyncData objects to chain operations that also return AsyncData values, with examples for all possible states.\nSOURCE: https://github.com/swan-io/boxed/blob/main/docs/docs/async-data.md#2025-04-22_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nAsyncData.Done(3).flatMap((x) =>\n  x > 2 ? AsyncData.NotAsked() : AsyncData.Done(2),\n);\n// AsyncData.NotAsked\n\nAsyncData.Done(1).flatMap((x) =>\n  x > 2 ? AsyncData.NotAsked() : AsyncData.Done(2),\n);\n// AsyncData.Done<2>\n\nAsyncData.NotAsked().flatMap((x) =>\n  x > 2 ? AsyncData.NotAsked() : AsyncData.Done(2),\n);\n// AsyncData.NotAsked\n\nAsyncData.Loading().flatMap((x) =>\n  x > 2 ? AsyncData.NotAsked() : AsyncData.Done(2),\n);\n// AsyncData.Loading\n```\n\n----------------------------------------\n\nTITLE: Extracting Values from Option Type in TypeScript\nDESCRIPTION: Demonstrates two methods for extracting values from an Option type: using getOr() for a fallback value, and using match() to handle both Some and None cases.\nSOURCE: https://github.com/swan-io/boxed/blob/main/docs/docs/core-concepts.md#2025-04-22_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// Let's assument we have `option` be of type `Option<number>`\n\n// Returns the value if present or the fallback otherwise\nconst a = option.getOr(0);\n\n// Explode the box\nconst b = option.match({\n  Some: (value) => value,\n  None: () => 0,\n});\n```\n\n----------------------------------------\n\nTITLE: Implementing Eager vs Lazy Evaluation in TypeScript\nDESCRIPTION: Demonstrates different approaches to handling eager and lazy evaluation in Boxed. Shows examples of creating eager Futures, lazy Futures via functions, and using Deferred for cases requiring lazy evaluation.\nSOURCE: https://github.com/swan-io/boxed/blob/main/docs/docs/design-choices.md#2025-04-22_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst eagerFuture = Future.make((resolve) => resolve(1));\n\nconst lazyFuture = () => Future.make((resolve) => resolve(1));\n\nconst [deferred, resolve] = Deferred.make<number>();\n```\n\n----------------------------------------\n\nTITLE: Future Result Retry Logic\nDESCRIPTION: Static method to implement retry logic for Future<Result> operations with configurable maximum attempts.\nSOURCE: https://github.com/swan-io/boxed/blob/main/docs/docs/future-result.md#2025-04-22_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nretry(getFuture: () => Future<Result<A, E>>, {max: number}): Future<Result<A, E>>\n```\n\n----------------------------------------\n\nTITLE: Using Future Static Methods in TypeScript\nDESCRIPTION: Examples of using static methods on the Future object, including isFuture, all, concurrent, wait, allFromDict, and fromPromise. These methods provide utility functions for working with collections of Futures and converting between Futures and Promises.\nSOURCE: https://github.com/swan-io/boxed/blob/main/docs/docs/future.md#2025-04-22_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nFuture.isFuture(Future.value(1));\n// true\n\nFuture.isFuture([]);\n// false\n\nFuture.all([Future.value(1), Future.value(2), Future.value(3)]);\n// Future<[1, 2, 3]>\n\nFuture.concurrent(\n  userIds.map((userId) => {\n    // notice we return a function\n    return () => getUserById(userId);\n  }),\n  { concurrency: 10 },\n);\n// Future<[...]>\n\nFuture.wait(1000).tap(() => console.log(\"Hey\"));\n// Logs \"Hey\" after 1s\n\nFuture.allFromDict({\n  a: Future.value(1),\n  b: Future.value(2),\n  c: Future.value(3),\n});\n// Future<{a: 1, b: 2, c: 3}>\n\nFuture.fromPromise(Promise.resolve(1));\n// Future<Result.Ok<1>>\n\nFuture.fromPromise(Promise.reject(1));\n// Future<Result.Error<1>>\n```\n\n----------------------------------------\n\nTITLE: Implementing Cancellation in Futures with TypeScript\nDESCRIPTION: Examples demonstrating how to implement and use cancellation in Futures, including creating cancellable Futures, cancelling Futures, and controlling cancellation propagation.\nSOURCE: https://github.com/swan-io/boxed/blob/main/docs/docs/future.md#2025-04-22_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nconst future = Future.make((resolve) => {\n  const timeoutId = setTimeout(() => {\n    resolve(1);\n  }, 1000);\n  // will run on cancellation\n  return () => clearTimeout(timeoutId);\n});\n\nfuture.cancel();\n\nconst future2 = future.map((x) => x * 2);\n\nfuture.cancel(); // Both `future` and `future2` are cancelled\n\n// disabled by default: cancelling `future2` will not cancel `future`\nconst future2 = future.map((x) => x * 2);\n\n// optin: cancelling `future2` will cancel `future`\nconst future2 = future.map((x) => x * 2, true);\n\nconst request = apiCall().map(parse, true);\n\nrequest.cancel(); // will run the cleanup effect in `apiCall`\n```\n\n----------------------------------------\n\nTITLE: Converting Nullable Values to Options\nDESCRIPTION: Demonstrates interoperability with null and undefined values by converting them to Option types.\nSOURCE: https://github.com/swan-io/boxed/blob/main/docs/docs/option.md#2025-04-22_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n// `value` being `null` or `undefined` makes a `None`\nconst a = Option.fromNullable(value);\n\n// `value` being `null` makes a `None`\nconst b = Option.fromNull(value);\n\n// `value` being `undefined` makes a `None`\nconst c = Option.fromUndefined(value);\n```\n\n----------------------------------------\n\nTITLE: Locating an Element with Boxed Array in TypeScript\nDESCRIPTION: The Array.find function searches for the first element matching a predicate and returns it wrapped in an Option. Useful for distinguishing between nullish and absent values.\nSOURCE: https://github.com/swan-io/boxed/blob/main/docs/docs/array.md#2025-04-22_snippet_3\n\nLANGUAGE: TypeScript\nCODE:\n```\nArray.find(array, (x) => x === undefined); // Some(undefined) if found, None if not found\n```\n\n----------------------------------------\n\nTITLE: Integrating AsyncData with TS Pattern in TypeScript\nDESCRIPTION: Demonstrates how to use AsyncData with the ts-pattern library for exhaustive pattern matching on all possible states.\nSOURCE: https://github.com/swan-io/boxed/blob/main/docs/docs/async-data.md#2025-04-22_snippet_15\n\nLANGUAGE: typescript\nCODE:\n```\nimport { match, P } from \"ts-pattern\";\nimport { AsyncData } from \"@swan-io/boxed\";\n\nmatch(asyncData)\n  .with(AsyncData.P.Done(P.select()), (value) => console.log(value))\n  .with(AsyncData.P.Loading, () => \"Loading ...\")\n  .with(AsyncData.P.NotAsked, () => \"\")\n  .exhaustive();\n```\n\n----------------------------------------\n\nTITLE: Implementing Delayed Retry with Attempt Counter in TypeScript\nDESCRIPTION: Shows how to implement a retry mechanism with increasing delay between attempts based on the attempt count. The delay increases linearly with each attempt, waiting attempt * 100ms between retries.\nSOURCE: https://github.com/swan-io/boxed/blob/main/docs/docs/retry.md#2025-04-22_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n// adding delay\nFuture.retry(\n  (attempt) => {\n    return Future.wait(attempt * 100).flatMap(() => getUserById(userId));\n  },\n  { max: 10 },\n);\n// Future<Result<...>>\n```\n\n----------------------------------------\n\nTITLE: Encoding Boxed Values with Serializer\nDESCRIPTION: Demonstrates how to encode nested Boxed values (AsyncData and Option types) into a JSON string. The example shows serialization of an object containing AsyncData with a nested Option type.\nSOURCE: https://github.com/swan-io/boxed/blob/main/docs/docs/serializer.md#2025-04-22_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nSerializer.encode({\n  data: AsyncData.Done({\n    name: Option.None(),\n  }),\n});\n// {\"data\":{\"__boxed_type__\":\"AsyncData\",\"tag\":\"Done\",\"value\":{\"name\":{\"__boxed_type__\":\"Option\",\"tag\":\"None\"}}}}\n```\n\n----------------------------------------\n\nTITLE: Option Type Chain Implementation\nDESCRIPTION: Simplified implementation using Option type's map and flatMap methods for cleaner optional value handling.\nSOURCE: https://github.com/swan-io/boxed/blob/main/docs/docs/nested-optional-values.md#2025-04-22_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\ninput\n  .map(parseInput)\n  .flatMap(transform)\n  .map(print)\n  .map(prettify)\n  .getOr(\"fallback\");\n```\n\n----------------------------------------\n\nTITLE: Finding First Matching Element with Boxed Array in TypeScript\nDESCRIPTION: The Array.findMap function returns the first Option.Some value from an array by applying a function to check for matching criteria. This approach assists in extracting the first valid element while managing optional values.\nSOURCE: https://github.com/swan-io/boxed/blob/main/docs/docs/array.md#2025-04-22_snippet_2\n\nLANGUAGE: TypeScript\nCODE:\n```\nArray.findMap([1, 2, 3], (x) => isEven(x) ? Option.Some(x) : Option.None()); // Option.Some(2)\n```\n\n----------------------------------------\n\nTITLE: Using map() Method with AsyncData in TypeScript\nDESCRIPTION: Demonstrates how to use the map() method on AsyncData objects to transform values in the Done state while preserving the state for NotAsked and Loading.\nSOURCE: https://github.com/swan-io/boxed/blob/main/docs/docs/async-data.md#2025-04-22_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nAsyncData.Done(2).map((x) => x * 2);\n// AsyncData.Done<4>\n\nAsyncData.Loading().map((x) => x * 2);\n// AsyncData.Loading\n\nAsyncData.NotAsked().map((x) => x * 2);\n// AsyncData.NotAsked\n```\n\n----------------------------------------\n\nTITLE: Filtering and Mapping with Boxed Array in TypeScript\nDESCRIPTION: The Array.filterMap function refines array types by returning an array of Option.Some values obtained from a provided function. It applies a boolean condition and returns matching elements, excluding Option.None outcomes.\nSOURCE: https://github.com/swan-io/boxed/blob/main/docs/docs/array.md#2025-04-22_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nArray.filterMap([1, 2, 3], (x) => isEven(x) ? Option.Some(x) : Option.None()); // [2]\n```\n\n----------------------------------------\n\nTITLE: Error Array Validation Usage\nDESCRIPTION: Example showing how to use the error array validation approach with state management.\nSOURCE: https://github.com/swan-io/boxed/blob/main/docs/docs/form-validation.md#2025-04-22_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nconst sanitized = sanitize(input);\nconst errors = validate(sanitized);\nif (errors.length) {\n  setValidation(errors);\n  // show the errors\n} else {\n  setValidation(null);\n  // send to the server\n}\n```\n\n----------------------------------------\n\nTITLE: Flat Mapping Error Values in Future\nDESCRIPTION: Method to chain Future<Result> operations by transforming Error values. Takes a function that returns a new Future<Result>.\nSOURCE: https://github.com/swan-io/boxed/blob/main/docs/docs/future-result.md#2025-04-22_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nFuture<Result<A, E>>.flatMapError<B, F>(\n  func: (value: E) => Future<Result<B, F>>,\n  propagateCancel?: boolean\n): Future<Result<A | B, F>>\n```\n\n----------------------------------------\n\nTITLE: Mapping Ok Values with Result in Future\nDESCRIPTION: Method to transform the Ok value of a Future<Result> while preserving the Result wrapper. Takes a function that returns a new Result.\nSOURCE: https://github.com/swan-io/boxed/blob/main/docs/docs/future-result.md#2025-04-22_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nFuture<Result<A, E>>.mapOkToResult<B, F>(\n  func: (value: A) => Result<B, F>,\n  propagateCancel?: boolean\n): Future<Result<B, E | F>>\n```\n\n----------------------------------------\n\nTITLE: Map Operation Examples\nDESCRIPTION: Examples of using the map function to transform Option values while maintaining their wrapped state.\nSOURCE: https://github.com/swan-io/boxed/blob/main/docs/docs/option.md#2025-04-22_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nOption.Some(2).map((x) => x * 2);\n// Option.Some<4>\n\nOption.None().map((x) => x * 2);\n// Option.None\n```\n\n----------------------------------------\n\nTITLE: Unzipping Array Pairs with Boxed Array in TypeScript\nDESCRIPTION: The Array.unzip function converts an array of pairs into two separate arrays, enabling independent processing of paired elements, which is ideal for data separation tasks.\nSOURCE: https://github.com/swan-io/boxed/blob/main/docs/docs/array.md#2025-04-22_snippet_7\n\nLANGUAGE: TypeScript\nCODE:\n```\nArray.unzip([[1, \"one\"], [2, \"two\"], [3, \"three\"]]); // [[1, 2, 3], [\"one\", \"two\", \"three\"]]\n```\n\n----------------------------------------\n\nTITLE: Using get() Method with AsyncData in TypeScript\nDESCRIPTION: Demonstrates how to safely use the get() method on AsyncData by first checking with isDone() type guard to ensure the value exists.\nSOURCE: https://github.com/swan-io/boxed/blob/main/docs/docs/async-data.md#2025-04-22_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nconst value = asyncData.get();\n// does not compile\n\nif (asyncData.isDone()) {\n  const value = asyncData.get();\n  // value\n}\n```\n\n----------------------------------------\n\nTITLE: Flat Mapping OK Results with flatMapOk Function\nDESCRIPTION: Method that chains AsyncData<Result> transformations on successful values using a provided function.\nSOURCE: https://github.com/swan-io/boxed/blob/main/docs/docs/async-data-result.md#2025-04-22_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nAsyncData<Result<A, E>>.flatMapOk<B, F>(\n  func: (value: A) => AsyncData<Result<B, F>>,\n): AsyncData<Result<B, E | F>>\n```\n\n----------------------------------------\n\nTITLE: Form Validation Using Error Array\nDESCRIPTION: Alternative validation implementation that returns an array of error messages instead of throwing exceptions.\nSOURCE: https://github.com/swan-io/boxed/blob/main/docs/docs/form-validation.md#2025-04-22_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nconst validate = (input: FormInput) => {\n  const errors = [];\n  if (input.id.trim().length !== 24) {\n    errors.push(\"Input ID is invalid\");\n  }\n  if (input.amount <= 0) {\n    errors.push(\"Invalid amount\");\n  }\n  return errors;\n};\n```\n\n----------------------------------------\n\nTITLE: FlatMap Operation Examples\nDESCRIPTION: Examples of using flatMap to chain Option operations that may result in None values.\nSOURCE: https://github.com/swan-io/boxed/blob/main/docs/docs/option.md#2025-04-22_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nOption.Some(3).flatMap((x) => (x > 2 ? Option.None() : Option.Some(2)));\n// Option.None\n\nOption.Some(1).flatMap((x) => (x > 2 ? Option.None() : Option.Some(2)));\n// Option.Some<2>\n\noption.flatMap((value) => value.optionalProperty);\n// Option<optionalProperty>\n```\n\n----------------------------------------\n\nTITLE: Filter Operation Examples\nDESCRIPTION: Examples of using filter to conditionally retain Option values based on a predicate.\nSOURCE: https://github.com/swan-io/boxed/blob/main/docs/docs/option.md#2025-04-22_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nOption.Some(3).filter((x) => x > 2);\n// Option.Some(3)\n\nOption.Some(1).filter((x) => x > 2);\n// Option.None\n```\n\n----------------------------------------\n\nTITLE: Using tap() Method with AsyncData in TypeScript\nDESCRIPTION: Demonstrates how to use the tap() method to perform side effects like logging on AsyncData values while preserving the value chain.\nSOURCE: https://github.com/swan-io/boxed/blob/main/docs/docs/async-data.md#2025-04-22_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\nasyncData.tap(console.log).map((x) => x * 2);\n```\n\n----------------------------------------\n\nTITLE: Implementing Immediate Retry with Maximum Attempts in TypeScript\nDESCRIPTION: Demonstrates how to retry a failed operation immediately up to a maximum number of attempts. The operation continues retrying until either a successful Result.Ok is returned or the maximum attempts are reached.\nSOURCE: https://github.com/swan-io/boxed/blob/main/docs/docs/retry.md#2025-04-22_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// retry immediately after failure\nFuture.retry(() => getUserById(userId), { max: 3 });\n// Future<Result<...>>\n```\n\n----------------------------------------\n\nTITLE: Option Type with Nullable Interop\nDESCRIPTION: Example showing how to integrate Option type with existing code that uses undefined values using fromNullable.\nSOURCE: https://github.com/swan-io/boxed/blob/main/docs/docs/nested-optional-values.md#2025-04-22_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nOption.fromNullable(input)\n  .map(parseInput)\n  .flatMap((input) => Option.fromNullable(transform(input)))\n  .map(print)\n  .map(prettify)\n  .getOr(\"fallback\");\n```\n\n----------------------------------------\n\nTITLE: Converting Future Result to Promise\nDESCRIPTION: Method to convert a Future<Result> into a Promise, resolving with Ok values and rejecting with Error values.\nSOURCE: https://github.com/swan-io/boxed/blob/main/docs/docs/future-result.md#2025-04-22_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nFuture<Result<A, E>>.resultToPromise(): Promise<A>\n```\n\n----------------------------------------\n\nTITLE: Mapping OK Results with mapOkToResult Function\nDESCRIPTION: Method that takes an AsyncData<Result<A, E>> and transforms successful values using a provided function that returns a new Result.\nSOURCE: https://github.com/swan-io/boxed/blob/main/docs/docs/async-data-result.md#2025-04-22_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nAsyncData<Result<A, E>>.mapOkToResult<B, F>(\n  func: (value: A) => Result<B, F>,\n): AsyncData<Result<B, E | F>>\n```\n\n----------------------------------------\n\nTITLE: Binary Search in Sorted Arrays with Boxed Array in TypeScript\nDESCRIPTION: The Array.binarySearchBy function executes binary search operations on sorted arrays, returning the index of an exact match or the first superior value, and -1 if the array is empty.\nSOURCE: https://github.com/swan-io/boxed/blob/main/docs/docs/array.md#2025-04-22_snippet_5\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst index = Array.binarySearchBy(array, \"my value\");\n```\n\n----------------------------------------\n\nTITLE: Simple Ok Value Mapping in Future\nDESCRIPTION: Method to transform the Ok value of a Future<Result> with a simple mapping function. Does not affect the Result wrapper structure.\nSOURCE: https://github.com/swan-io/boxed/blob/main/docs/docs/future-result.md#2025-04-22_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nFuture<Result<A, E>>.mapOk<B>(\n  func: (value: A) => B,\n  propagateCancel?: boolean\n): Future<Result<B, E>>\n```\n\n----------------------------------------\n\nTITLE: Dict.entries() Usage\nDESCRIPTION: Demonstrates how to get entries from a dictionary with refined types, returning an array of key-value pairs\nSOURCE: https://github.com/swan-io/boxed/blob/main/docs/docs/dict.md#2025-04-22_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst index = Dict.entries({ foo: 1, bar: 2, baz: 3 });\n// [[\"foo\", 1], [\"bar\", 2], [\"baz\", 3]];\n```\n\n----------------------------------------\n\nTITLE: Converting AsyncData to Option in TypeScript\nDESCRIPTION: Demonstrates how to convert AsyncData values to Option using the toOption() method, which maps Done to Some and both Loading and NotAsked to None.\nSOURCE: https://github.com/swan-io/boxed/blob/main/docs/docs/async-data.md#2025-04-22_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nResult.Done(2).toOption();\n// Option.Some<2>\n\nResult.Loading().toOption();\n// Option.None\n\nResult.NotAsked().toOption();\n// Option.None\n```\n\n----------------------------------------\n\nTITLE: TS-Pattern Integration Example\nDESCRIPTION: Shows how to use the Option type with the ts-pattern library for pattern matching.\nSOURCE: https://github.com/swan-io/boxed/blob/main/docs/docs/option.md#2025-04-22_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport { match, P } from \"ts-pattern\";\nimport { Option } from \"@swan-io/boxed\";\n\nmatch(myOption)\n  .with(Option.P.Some(P.select()), (value) => console.log(value))\n  .with(Option.P.None, () => \"No value\")\n  .exhaustive();\n```\n\n----------------------------------------\n\nTITLE: Using isDone() Type Guard with AsyncData in TypeScript\nDESCRIPTION: Shows how to use the isDone() type guard method to check if an AsyncData is in the Done state with examples for all states.\nSOURCE: https://github.com/swan-io/boxed/blob/main/docs/docs/async-data.md#2025-04-22_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nAsyncData.Done(2).isDone();\n// true\n\nAsyncData.Loading().isDone();\n// false\n\nAsyncData.NotAsked().isDone();\n// false\n\nif (asyncData.isDone()) {\n  const value = asyncData.get();\n}\n```\n\n----------------------------------------\n\nTITLE: Simple OK Value Mapping with mapOk Function\nDESCRIPTION: Method that transforms successful values within an AsyncData<Result> using a simple mapping function.\nSOURCE: https://github.com/swan-io/boxed/blob/main/docs/docs/async-data-result.md#2025-04-22_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nAsyncData<Result<A, E>>.mapOk<B>(\n  func: (value: A) => B,\n): AsyncData<Result<B, E>>\n```\n\n----------------------------------------\n\nTITLE: Mapping Error Values with Result in Future\nDESCRIPTION: Method to transform the Error value of a Future<Result> while preserving the Result wrapper. Takes a function that returns a new Result.\nSOURCE: https://github.com/swan-io/boxed/blob/main/docs/docs/future-result.md#2025-04-22_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nFuture<Result<A, E>>.mapErrorToResult<B, F>(\n  func: (value: E) => Result<B, F>,\n  propagateCancel?: boolean\n): Future<Result<A | B, F>>\n```\n\n----------------------------------------\n\nTITLE: Converting Futures to Promises in TypeScript\nDESCRIPTION: Example of converting a Future to a Promise using the toPromise() method.\nSOURCE: https://github.com/swan-io/boxed/blob/main/docs/docs/future.md#2025-04-22_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nFuture.value(1).toPromise();\n// Promise<1>\n```\n\n----------------------------------------\n\nTITLE: Exception Handling with Try-Catch\nDESCRIPTION: Example showing how to handle validation exceptions using try-catch blocks with state management.\nSOURCE: https://github.com/swan-io/boxed/blob/main/docs/docs/form-validation.md#2025-04-22_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\ntry {\n  const sanitized = sanitize(input);\n  validate(sanitized);\n  setValidation(null);\n\n  // send to the server\n} catch (err) {\n  setValidation(err);\n}\n```\n\n----------------------------------------\n\nTITLE: Accessing a Lazy Value in TypeScript\nDESCRIPTION: Demonstrates how to access the value of a lazy computation using the get() method. The computation happens only once on the first call to get(), and subsequent calls return the cached result.\nSOURCE: https://github.com/swan-io/boxed/blob/main/docs/docs/lazy.md#2025-04-22_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nlazy.get(); // value is computed and return here\n```\n\n----------------------------------------\n\nTITLE: Converting Arrays of AsyncData to AsyncData of Array in TypeScript\nDESCRIPTION: Demonstrates how to use the static all() method to convert an array of AsyncData values into an AsyncData containing an array of values.\nSOURCE: https://github.com/swan-io/boxed/blob/main/docs/docs/async-data.md#2025-04-22_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\nAsyncData.all([AsyncData.Done(1), AsyncData.Done(2), AsyncData.Done(3)]);\n// AsyncData.Done<[1, 2, 3]>\n\nAsyncData.all([Result.NotAsked(), AsyncData.Done(2), AsyncData.Done(3)]);\n// AsyncData.NotAsked\n\nAsyncData.all([Result.Loading(), AsyncData.Done(2), AsyncData.Done(3)]);\n// AsyncData.Loading\n```\n\n----------------------------------------\n\nTITLE: Mapping Error Results with mapErrorToResult Function\nDESCRIPTION: Method that takes an AsyncData<Result<A, E>> and transforms error values using a provided function that returns a new Result.\nSOURCE: https://github.com/swan-io/boxed/blob/main/docs/docs/async-data-result.md#2025-04-22_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nAsyncData<Result<A, E>>.mapErrorToResult<B, F>(\n  func: (value: E) => Result<B, F>,\n): AsyncData<Result<A | B, F>>\n```\n\n----------------------------------------\n\nTITLE: Form Validation Using Exceptions\nDESCRIPTION: Implementation of form validation using exception throwing for invalid inputs. Validates ID length and amount value.\nSOURCE: https://github.com/swan-io/boxed/blob/main/docs/docs/form-validation.md#2025-04-22_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst validate = (input: FormInput) => {\n  if (input.id.trim().length !== 24) {\n    throw new Error(\"Input ID is invalid\");\n  }\n  if (input.amount <= 0) {\n    throw new Error(\"Invalid amount\");\n  }\n};\n```\n\n----------------------------------------\n\nTITLE: Installing @swan-io/boxed with Package Managers\nDESCRIPTION: Commands to install the @swan-io/boxed package using either Yarn or npm package managers. This is the initial step required to use the library in a project.\nSOURCE: https://github.com/swan-io/boxed/blob/main/README.md#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n$ yarn add @swan-io/boxed\n# --- or ---\n$ npm install --save @swan-io/boxed\n```\n\n----------------------------------------\n\nTITLE: Creating and Using Deferred with TypeScript\nDESCRIPTION: Shows how to create a Deferred instance using Deferred.make(), which returns a tuple containing a future and its resolver. The future can be subscribed to using onResolve(), and the resolver can be called to set the value.\nSOURCE: https://github.com/swan-io/boxed/blob/main/docs/docs/deferred.md#2025-04-22_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Deferred } from \"@swan-io/boxed\";\n\nconst [future, resolve] = Deferred.make<string>();\n\n// subscribe to the promise\nfuture.onResolve(console.log);\n\n// resolve from elsewhere\nresolve(\"Hello!\");\n```\n\n----------------------------------------\n\nTITLE: Defining Form Input Type in TypeScript\nDESCRIPTION: TypeScript interface definition for a form input containing an ID string and amount number.\nSOURCE: https://github.com/swan-io/boxed/blob/main/docs/docs/form-validation.md#2025-04-22_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ntype FormInput = {\n  id: string;\n  amount: number;\n};\n```\n\n----------------------------------------\n\nTITLE: Finding the Index of an Element with Boxed Array in TypeScript\nDESCRIPTION: The Array.findIndex function identifies the first index meeting a given predicate and returns it wrapped in an Option. It helps track element positions while accounting for missing values.\nSOURCE: https://github.com/swan-io/boxed/blob/main/docs/docs/array.md#2025-04-22_snippet_4\n\nLANGUAGE: TypeScript\nCODE:\n```\nArray.findIndex(array, (x) => x === undefined); // Some(index) if found, None if not found\n```\n\n----------------------------------------\n\nTITLE: Dict.fromEntries() Usage\nDESCRIPTION: Shows how to create a dictionary from an array of key-value pairs\nSOURCE: https://github.com/swan-io/boxed/blob/main/docs/docs/dict.md#2025-04-22_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst dict = Dict.fromEntries([\n  [\"foo\", 1],\n  [\"bar\", 2],\n  [\"baz\", 3],\n]);\n// { foo: 1, bar: 2, baz: 3 };\n```\n\n----------------------------------------\n\nTITLE: Dict.fromOptional() Usage\nDESCRIPTION: Demonstrates how to create a dictionary from a dictionary of Options, filtering out None values\nSOURCE: https://github.com/swan-io/boxed/blob/main/docs/docs/dict.md#2025-04-22_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nDict.fromOptional({\n  foo: Option.Some(1),\n  bar: Option.None(),\n  baz: Option.None(),\n});\n// {foo: 1}\n\nDict.fromOptional({\n  foo: Option.Some(1),\n  bar: Option.Some(2),\n  baz: Option.None(),\n});\n// {foo: 1, bar: 2}\n\nDict.fromOptional({\n  foo: Option.None(),\n  bar: Option.None(),\n  baz: Option.None(),\n});\n// {}\n```\n\n----------------------------------------\n\nTITLE: Dict.keys() Usage\nDESCRIPTION: Demonstrates how to extract keys from a dictionary with refined types\nSOURCE: https://github.com/swan-io/boxed/blob/main/docs/docs/dict.md#2025-04-22_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nconst index = Dict.keys({ foo: 1, bar: 2, baz: 3 });\n// [\"foo\", \"bar\", \"baz\"];\n```\n\n----------------------------------------\n\nTITLE: Converting Array-like Objects with Boxed Array in TypeScript\nDESCRIPTION: The Array.from function converts array-like or iterable objects into true arrays. Reexported from the standard Array API, it streamlines handling objects when Boxed 'Array' is present.\nSOURCE: https://github.com/swan-io/boxed/blob/main/docs/docs/array.md#2025-04-22_snippet_8\n\nLANGUAGE: TypeScript\nCODE:\n```\nArray.from({ length: 3 }, (_, key) => key); // [0, 1, 2]\n```\n\n----------------------------------------\n\nTITLE: Converting Dictionaries of AsyncData to AsyncData of Dictionary in TypeScript\nDESCRIPTION: Shows how to use the static allFromDict() method to convert an object with AsyncData values into an AsyncData containing an object with values.\nSOURCE: https://github.com/swan-io/boxed/blob/main/docs/docs/async-data.md#2025-04-22_snippet_14\n\nLANGUAGE: typescript\nCODE:\n```\nAsyncData.allFromDict({\n  a: AsyncData.Done(1),\n  b: AsyncData.Done(2),\n  c: AsyncData.Done(3),\n});\n// AsyncData.Done<{a: 1, b: 2, c: 3}>\n\nAsyncData.allFromDict({\n  a: Result.NotAsked(),\n  b: AsyncData.Done(2),\n  c: AsyncData.Done(3),\n});\n// AsyncData.NotAsked\n\nAsyncData.allFromDict({\n  a: Result.Loading(),\n  b: AsyncData.Done(2),\n  c: AsyncData.Done(3),\n});\n// AsyncData.Loading\n```\n\n----------------------------------------\n\nTITLE: Creating Arrays with Boxed Array in TypeScript\nDESCRIPTION: The Array.of function creates new arrays from a set of arguments. As a reexport for convenience, it simplifies array instantiation when Boxed 'Array' shadows the native Array constructor.\nSOURCE: https://github.com/swan-io/boxed/blob/main/docs/docs/array.md#2025-04-22_snippet_9\n\nLANGUAGE: TypeScript\nCODE:\n```\nArray.of(1, 2, 3); // [1, 2, 3]\n```\n\n----------------------------------------\n\nTITLE: Zipping Arrays with Boxed Array in TypeScript\nDESCRIPTION: The Array.zip function creates an array of pairs by combining two input arrays element-wise. This transformation facilitates parallel data processing and manipulation.\nSOURCE: https://github.com/swan-io/boxed/blob/main/docs/docs/array.md#2025-04-22_snippet_6\n\nLANGUAGE: TypeScript\nCODE:\n```\nArray.zip([1, 2, 3], [\"one\", \"two\", \"three\"]); // [[1, \"one\"], [2, \"two\"], [3, \"three\"]]\n```\n\n----------------------------------------\n\nTITLE: Declaring Types with Optional Values\nDESCRIPTION: Type declarations for functions and variables that work with optional values using undefined.\nSOURCE: https://github.com/swan-io/boxed/blob/main/docs/docs/nested-optional-values.md#2025-04-22_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare var input: string | undefined;\ndeclare function parseInput(input: string): Array<string>;\ndeclare function transform(input: Array<string>): Array<string> | undefined;\ndeclare function print(input: Array<string>): string;\ndeclare function prettify(input: string): string;\n```\n\n----------------------------------------\n\nTITLE: Flat Mapping Ok Values in Future\nDESCRIPTION: Method to chain Future<Result> operations by transforming Ok values. Takes a function that returns a new Future<Result>.\nSOURCE: https://github.com/swan-io/boxed/blob/main/docs/docs/future-result.md#2025-04-22_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nFuture<Result<A, E>>.flatMapOk<B, F>(\n  func: (value: A) => Future<Result<B, F>>,\n  propagateCancel?: boolean\n): Future<Result<B, E | F>>\n```\n\n----------------------------------------\n\nTITLE: Checking Array Instances with Boxed Array in TypeScript\nDESCRIPTION: The Array.isArray function checks if a value is an array. Reexported from the standard Array API, it aids in type-checking when Boxed 'Array' is in effect, maintaining compatibility with native functions.\nSOURCE: https://github.com/swan-io/boxed/blob/main/docs/docs/array.md#2025-04-22_snippet_10\n\nLANGUAGE: TypeScript\nCODE:\n```\nArray.isArray(\"\"); // false\n\nArray.isArray([1, 2, 3]); // true\n```\n\n----------------------------------------\n\nTITLE: Using isLoading() Type Guard with AsyncData in TypeScript\nDESCRIPTION: Demonstrates how to use the isLoading() type guard method to check if an AsyncData is in the Loading state with examples for all states.\nSOURCE: https://github.com/swan-io/boxed/blob/main/docs/docs/async-data.md#2025-04-22_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nAsyncData.Done(2).isLoading();\n// false\n\nAsyncData.Loading().isLoading();\n// true\n\nAsyncData.NotAsked().isLoading();\n// false\n```\n\n----------------------------------------\n\nTITLE: Future Type Benchmarks - V8 Engine\nDESCRIPTION: Performance comparison between Promise and Future implementations on v8 engine. Note that Future uses synchronous listener calls instead of microtasks.\nSOURCE: https://github.com/swan-io/boxed/blob/main/benchmark/README.md#2025-04-22_snippet_4\n\nLANGUAGE: plaintext\nCODE:\n```\nPromise x 13,345,062 ops/sec ±1.63% (86 runs sampled)\nFuture x 163,971 ops/sec ±50.30% (30 runs sampled)\n```\n\n----------------------------------------\n\nTITLE: Using isNotAsked() Type Guard with AsyncData in TypeScript\nDESCRIPTION: Shows how to use the isNotAsked() type guard method to check if an AsyncData is in the NotAsked state with examples for all states.\nSOURCE: https://github.com/swan-io/boxed/blob/main/docs/docs/async-data.md#2025-04-22_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nAsyncData.Done(2).isNotAsked();\n// false\n\nAsyncData.Loading().isNotAsked();\n// false\n\nAsyncData.NotAsked().isNotAsked();\n// true\n```\n\n----------------------------------------\n\nTITLE: Result Type Benchmarks - V8 Engine\nDESCRIPTION: Performance comparison of Result type implementations in fp-ts, effect, and Boxed libraries on v8 engine.\nSOURCE: https://github.com/swan-io/boxed/blob/main/benchmark/README.md#2025-04-22_snippet_2\n\nLANGUAGE: plaintext\nCODE:\n```\nfp-ts Result x 116,486,882 ops/sec ±1.58% (96 runs sampled)\neffect Result x 26,664,690 ops/sec ±1.45% (101 runs sampled)\nBoxed Result x 28,373,628 ops/sec ±2.47% (99 runs sampled)\n```\n\n----------------------------------------\n\nTITLE: Simple Error Value Mapping in Future\nDESCRIPTION: Method to transform the Error value of a Future<Result> with a simple mapping function. Does not affect the Result wrapper structure.\nSOURCE: https://github.com/swan-io/boxed/blob/main/docs/docs/future-result.md#2025-04-22_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nFuture<Result<A, E>>.mapError<F>(\n  func: (value: E) => F,\n  propagateCancel?: boolean\n): Future<Result<A, F>>\n```\n\n----------------------------------------\n\nTITLE: Option Type Benchmarks - V8 Engine\nDESCRIPTION: Performance comparison of Option type implementations in fp-ts, effect, and Boxed libraries on v8 engine. Measures operations per second for none, some, and chain/flatMap operations.\nSOURCE: https://github.com/swan-io/boxed/blob/main/benchmark/README.md#2025-04-22_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\nfp-ts Option none x 134,019,171 ops/sec ±1.58% (94 runs sampled)\nfp-ts Option some x 90,043,117 ops/sec ±3.50% (97 runs sampled)\nfp-ts Option some chain x 2,797,176 ops/sec ±1.35% (97 runs sampled)\neffect Option none x 28,233,747 ops/sec ±0.52% (97 runs sampled)\neffect Option some x 24,837,619 ops/sec ±1.55% (90 runs sampled)\neffect Option some chain x 23,184,057 ops/sec ±3.08% (94 runs sampled)\nBoxed Option none x 610,271,309 ops/sec ±1.22% (98 runs sampled)\nBoxed Option some x 27,055,907 ops/sec ±0.09% (96 runs sampled)\nBoxed Option some flatMap x 26,768,922 ops/sec ±2.66% (88 runs sampled)\n```\n\n----------------------------------------\n\nTITLE: Creating a Lazy Value in TypeScript\nDESCRIPTION: Creates a lazy value using the Lazy function from the @swan-io/boxed library. The computation defined inside won't be executed until the first access.\nSOURCE: https://github.com/swan-io/boxed/blob/main/docs/docs/lazy.md#2025-04-22_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Lazy } from \"@swan-io/boxed\";\n\nconst lazy = Lazy(() => {\n  return myComputation();\n});\n```\n\n----------------------------------------\n\nTITLE: Future with Result Benchmarks - JSCore Engine\nDESCRIPTION: Performance comparison of Future+Result implementations across fp-ts TaskEither, effect Effect, and Future libraries on JSCore engine.\nSOURCE: https://github.com/swan-io/boxed/blob/main/benchmark/README.md#2025-04-22_snippet_7\n\nLANGUAGE: plaintext\nCODE:\n```\nfp-ts TaskEither x 724,358 ops/sec ±7.41% (83 runs sampled)\neffect Effect x 470,137 ops/sec ±0.86% (83 runs sampled)\nFuture x 707,572 ops/sec ±2.97% (72 runs sampled)\n```\n\n----------------------------------------\n\nTITLE: Using getOr() Method with AsyncData in TypeScript\nDESCRIPTION: Demonstrates how to use the getOr() method (also aliased as getWithDefault) to extract a value from AsyncData or fall back to a default value.\nSOURCE: https://github.com/swan-io/boxed/blob/main/docs/docs/async-data.md#2025-04-22_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nAsyncData.Done(2).getOr(1);\n// 2\n\nAsyncData.Loading().getOr(1);\n// 1\n\nAsyncData.NotAsked().getOr(1);\n// 1\n```\n\n----------------------------------------\n\nTITLE: Importing Dict Module\nDESCRIPTION: Shows how to import the Dict utility module from the @swan-io/boxed package\nSOURCE: https://github.com/swan-io/boxed/blob/main/docs/docs/dict.md#2025-04-22_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Dict } from \"@swan-io/boxed\";\n```\n\n----------------------------------------\n\nTITLE: Using mapOr() Method with AsyncData in TypeScript\nDESCRIPTION: Shows how to use the mapOr() method to either map a value if AsyncData is in Done state or return a default value otherwise.\nSOURCE: https://github.com/swan-io/boxed/blob/main/docs/docs/async-data.md#2025-04-22_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nAsyncData.Done(2).mapOr(1, (x) => x * 2);\n// 4\n\nAsyncData.NotAsked().mapOr(1, (x) => x * 2);\n// 1\n\nAsyncData.Loading().mapOr(1, (x) => x * 2);\n// 1\n```\n\n----------------------------------------\n\nTITLE: Installing Boxed Package with NPM\nDESCRIPTION: Command to install @swan-io/boxed package using NPM package manager.\nSOURCE: https://github.com/swan-io/boxed/blob/main/docs/docs/installation.md#2025-04-22_snippet_1\n\nLANGUAGE: console\nCODE:\n```\n$ npm install @swan-io/boxed\n```\n\n----------------------------------------\n\nTITLE: Dict.values() Usage\nDESCRIPTION: Shows how to extract values from a dictionary with refined types\nSOURCE: https://github.com/swan-io/boxed/blob/main/docs/docs/dict.md#2025-04-22_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nconst index = Dict.values({ foo: 1, bar: 2, baz: 3 });\n// [1, 2, 3];\n```\n\n----------------------------------------\n\nTITLE: Importing Boxed Array in TypeScript\nDESCRIPTION: Demonstrates how to import the Boxed Array module in TypeScript, intended for projects utilizing the '@swan-io/boxed' package. This import is a prerequisite for using advanced array manipulation functions provided by the library.\nSOURCE: https://github.com/swan-io/boxed/blob/main/docs/docs/array.md#2025-04-22_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { Array } from \"@swan-io/boxed\";\n```\n\n----------------------------------------\n\nTITLE: Simple Error Value Mapping with mapError Function\nDESCRIPTION: Method that transforms error values within an AsyncData<Result> using a simple mapping function.\nSOURCE: https://github.com/swan-io/boxed/blob/main/docs/docs/async-data-result.md#2025-04-22_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nAsyncData<Result<A, E>>.mapError<F>(\n  func: (value: E) => F,\n): AsyncData<Result<A, F>>\n```\n\n----------------------------------------\n\nTITLE: Flat Mapping Error Results with flatMapError Function\nDESCRIPTION: Method that chains AsyncData<Result> transformations on error values using a provided function.\nSOURCE: https://github.com/swan-io/boxed/blob/main/docs/docs/async-data-result.md#2025-04-22_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nAsyncData<Result<A, E>>.flatMapError<B, F>(\n  func: (value: E) => AsyncData<Result<B, F>>,\n): AsyncData<Result<A | B, F>>\n```\n\n----------------------------------------\n\nTITLE: Future Result Debugging Helpers\nDESCRIPTION: Methods for debugging Future<Result> values by tapping into Ok and Error states without affecting the chain.\nSOURCE: https://github.com/swan-io/boxed/blob/main/docs/docs/future-result.md#2025-04-22_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nFuture<Result<A, E>>.tapOk(func: (value: A) => unknown): Future<Result<A, E>>\nFuture<Result<A, E>>.tapError(func: (value: E) => unknown): Future<Result<A, E>>\n```\n\n----------------------------------------\n\nTITLE: Traditional Optional Value Handling\nDESCRIPTION: Example of handling optional values using traditional undefined checks and nullish coalescing.\nSOURCE: https://github.com/swan-io/boxed/blob/main/docs/docs/nested-optional-values.md#2025-04-22_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst parsed = input != undefined ? parseInput(input) : undefined;\nconst transformed =\n  parsed != undefined ? transform(parsed) ?? parsed : undefined;\nconst printed = transformed != undefined ? print(transformed) : undefined;\nconst value = printed != undefined ? prettify(printed) : \"fallback\";\n```\n\n----------------------------------------\n\nTITLE: Type Declarations with Option Type\nDESCRIPTION: Type declarations refactored to use Boxed's Option type instead of undefined.\nSOURCE: https://github.com/swan-io/boxed/blob/main/docs/docs/nested-optional-values.md#2025-04-22_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare var input: Option<string>;\ndeclare function parseInput(input: string): Array<string>;\ndeclare function transform(input: Array<string>): Option<Array<string>>;\ndeclare function print(input: Array<string>): string;\ndeclare function prettify(input: string): string;\n```\n\n----------------------------------------\n\nTITLE: Using isAsyncData() Type Guard in TypeScript\nDESCRIPTION: Shows how to use the static isAsyncData() type guard method to check if a value is an AsyncData instance.\nSOURCE: https://github.com/swan-io/boxed/blob/main/docs/docs/async-data.md#2025-04-22_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\nAsyncData.isAsyncData(AsyncData.Done(1));\n// true\n\nAsyncData.isAsyncData([]);\n// false\n```\n\n----------------------------------------\n\nTITLE: Installing Website Dependencies using Yarn (Console)\nDESCRIPTION: This command installs all the necessary project dependencies defined in the package manager configuration file (likely package.json). It needs to be run in the website's root directory. Requires Yarn to be installed.\nSOURCE: https://github.com/swan-io/boxed/blob/main/docs/README.md#2025-04-22_snippet_0\n\nLANGUAGE: console\nCODE:\n```\n$ yarn\n```\n\n----------------------------------------\n\nTITLE: Importing BoxedJS Serializer\nDESCRIPTION: Shows how to import the Serializer module from the @swan-io/boxed package.\nSOURCE: https://github.com/swan-io/boxed/blob/main/docs/docs/serializer.md#2025-04-22_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Serializer } from \"@swan-io/boxed\";\n```\n\n----------------------------------------\n\nTITLE: Decoding Boxed Values with Serializer\nDESCRIPTION: Shows how to decode a JSON string back into Boxed types. The example demonstrates parsing a JSON string representing an Option.None value.\nSOURCE: https://github.com/swan-io/boxed/blob/main/docs/docs/serializer.md#2025-04-22_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nSerializer.decode(`{\"__boxed_type__\":\"Option\",\"tag\":\"None\"}`); // Option.None();\n```\n\n----------------------------------------\n\nTITLE: Future with Result Benchmarks - V8 Engine\nDESCRIPTION: Performance comparison of Future+Result implementations across fp-ts TaskEither, effect Effect, and Future libraries on v8 engine.\nSOURCE: https://github.com/swan-io/boxed/blob/main/benchmark/README.md#2025-04-22_snippet_6\n\nLANGUAGE: plaintext\nCODE:\n```\nfp-ts TaskEither x 524,318 ops/sec ±1.67% (90 runs sampled)\neffect Effect x 193,219 ops/sec ±0.69% (90 runs sampled)\nFuture x 315,497 ops/sec ±10.37% (71 runs sampled)\n```\n\n----------------------------------------\n\nTITLE: Option Type Benchmarks - JSCore Engine\nDESCRIPTION: Performance comparison of Option type implementations in fp-ts, effect, and Boxed libraries on JSCore engine. Measures operations per second for none, some, and chain/flatMap operations.\nSOURCE: https://github.com/swan-io/boxed/blob/main/benchmark/README.md#2025-04-22_snippet_1\n\nLANGUAGE: plaintext\nCODE:\n```\nfp-ts Option none x 26,370,592 ops/sec ±3.01% (80 runs sampled)\nfp-ts Option some x 22,306,443 ops/sec ±3.35% (80 runs sampled)\nfp-ts Option some chain x 6,395,953 ops/sec ±0.72% (94 runs sampled)\neffect Option none x 34,944,770 ops/sec ±3.60% (80 runs sampled)\neffect Option some x 24,062,381 ops/sec ±3.20% (78 runs sampled)\neffect Option some chain x 21,272,877 ops/sec ±3.03% (77 runs sampled)\nBoxed Option none x 360,292,187 ops/sec ±52.07% (26 runs sampled)\nBoxed Option some x 42,614,750 ops/sec ±2.65% (81 runs sampled)\nBoxed Option some flatMap x 39,815,444 ops/sec ±2.15% (85 runs sampled)\n```\n\n----------------------------------------\n\nTITLE: Building Static Website Content using Yarn (Console)\nDESCRIPTION: This command compiles the Docusaurus website into static HTML, CSS, and JavaScript files. The generated static content is placed into the `build` directory and is ready for deployment on any static hosting service. Requires dependencies to be installed.\nSOURCE: https://github.com/swan-io/boxed/blob/main/docs/README.md#2025-04-22_snippet_2\n\nLANGUAGE: console\nCODE:\n```\n$ yarn build\n```\n\n----------------------------------------\n\nTITLE: Installing Boxed Package with Yarn\nDESCRIPTION: Command to install @swan-io/boxed package using Yarn package manager.\nSOURCE: https://github.com/swan-io/boxed/blob/main/docs/docs/installation.md#2025-04-22_snippet_0\n\nLANGUAGE: console\nCODE:\n```\n$ yarn add @swan-io/boxed\n```\n\n----------------------------------------\n\nTITLE: Future Type Benchmarks - JSCore Engine\nDESCRIPTION: Performance comparison between Promise and Future implementations on JSCore engine. Note that Future uses synchronous listener calls instead of microtasks.\nSOURCE: https://github.com/swan-io/boxed/blob/main/benchmark/README.md#2025-04-22_snippet_5\n\nLANGUAGE: plaintext\nCODE:\n```\nPromise x 6,744,022 ops/sec ±3.20% (83 runs sampled)\nFuture x 162,704 ops/sec ±28.63% (24 runs sampled)\n```\n\n----------------------------------------\n\nTITLE: Implementing Cancellable API Request with Native Fetch in React\nDESCRIPTION: This snippet shows how to implement a cancellable API request using the native fetch API and AbortController in a React component. It demonstrates the use of useEffect hook and how to handle the cleanup function for request cancellation.\nSOURCE: https://github.com/swan-io/boxed/blob/main/docs/docs/cancellable-request.md#2025-04-22_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { useEffect } from \"react\";\nimport { Result } from \"@swan-io/boxed\";\n\nconst callMyApi = (url, { signal }) => {\n  return fetch(url, { signal })\n    .then((res) => res.json())\n    .then((json) => Result.Ok(res))\n    .catch((error) => Result.Error(error));\n};\n\n// ...\nuseEffect(() => {\n  // Implementation details leak to your components\n  const controller = new AbortController();\n  callMyApi(\"/users\", { signal: controller.signal })\n    .then((res) => res.json())\n    .then((json) => setState(Result.Ok(json)))\n    .catch((error) => setState(Result.Error(error)));\n  return () => controller.abort();\n}, []);\n```\n\n----------------------------------------\n\nTITLE: Starting Local Development Server using Yarn (Console)\nDESCRIPTION: This command initiates a local development server for the Docusaurus website. It automatically opens the site in a browser window and provides live reloading for most changes without requiring a manual server restart. Requires dependencies to be installed first.\nSOURCE: https://github.com/swan-io/boxed/blob/main/docs/README.md#2025-04-22_snippet_1\n\nLANGUAGE: console\nCODE:\n```\n$ yarn start\n```\n\n----------------------------------------\n\nTITLE: Deploying Website via HTTPS using Yarn (Console)\nDESCRIPTION: This command builds the website and pushes it to the deployment target (specifically mentioned for GitHub Pages `gh-pages` branch) using HTTPS. It requires specifying the GitHub username via the `GIT_USER` environment variable for authentication.\nSOURCE: https://github.com/swan-io/boxed/blob/main/docs/README.md#2025-04-22_snippet_4\n\nLANGUAGE: console\nCODE:\n```\n$ GIT_USER=<Your GitHub username> yarn deploy\n```\n\n----------------------------------------\n\nTITLE: Deploying Website via SSH using Yarn (Console)\nDESCRIPTION: This command builds the website and pushes it to the deployment target (specifically mentioned for GitHub Pages `gh-pages` branch) using SSH for authentication. The `USE_SSH=true` environment variable signals Yarn to use SSH credentials.\nSOURCE: https://github.com/swan-io/boxed/blob/main/docs/README.md#2025-04-22_snippet_3\n\nLANGUAGE: console\nCODE:\n```\n$ USE_SSH=true yarn deploy\n```\n\n----------------------------------------\n\nTITLE: Defining Manual Asynchronous State in TypeScript\nDESCRIPTION: Defines a TypeScript type `UserQuery` to manually represent the state of an asynchronous request, including loading, error, and data fields. This approach is presented as potentially problematic because it can represent impossible states and may lead to nested conditional logic, which AsyncData aims to solve.\nSOURCE: https://github.com/swan-io/boxed/blob/main/docs/docs/react-request.md#2025-04-22_snippet_0\n\nLANGUAGE: ts\nCODE:\n```\ntype UserQuery = {\n  isLoading: boolean;\n  error: Error;\n  data: User;\n};\n```\n\n----------------------------------------\n\nTITLE: Result Type Benchmarks - JSCore Engine\nDESCRIPTION: Performance comparison of Result type implementations in fp-ts, effect, and Boxed libraries on JSCore engine.\nSOURCE: https://github.com/swan-io/boxed/blob/main/benchmark/README.md#2025-04-22_snippet_3\n\nLANGUAGE: plaintext\nCODE:\n```\nfp-ts Result x 24,241,558 ops/sec ±4.98% (75 runs sampled)\neffect Result x 26,450,388 ops/sec ±2.68% (79 runs sampled)\nBoxed Result x 39,799,836 ops/sec ±2.69% (81 runs sampled)\n```\n\n----------------------------------------\n\nTITLE: Markdown Documentation: Project Inspirations\nDESCRIPTION: Markdown document frontmatter and list of project inspirations, including ReScript's Belt standard library, ReScript Future, and ReScript AsyncData\nSOURCE: https://github.com/swan-io/boxed/blob/main/docs/docs/inspirations.md#2025-04-22_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n---\ntitle: Inspirations\nsidebar_label: Inspirations\n---\n\n- [ReScript's Belt Stdlib](https://rescript-lang.org/docs/manual/latest/api/belt)\n- [ReScript Future](https://github.com/bloodyowl/rescript-future)\n- [ReScript AsyncData](https://github.com/bloodyowl/rescript-asyncdata)\n```"
  }
]