[
  {
    "owner": "tree-sitter",
    "repo": "tree-sitter",
    "content": "TITLE: Matching Binary Expressions with Number Literals in Tree-sitter Query\nDESCRIPTION: Demonstrates a pattern that matches any binary_expression node whose children are both number_literal nodes. This illustrates the basic structure of a tree-sitter query pattern using S-expressions.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/docs/src/using-parsers/queries/1-syntax.md#2025-04-21_snippet_0\n\nLANGUAGE: query\nCODE:\n```\n(binary_expression (number_literal) (number_literal))\n```\n\n----------------------------------------\n\nTITLE: Building Tree-sitter C Library Source File\nDESCRIPTION: The source file required when incorporating Tree-sitter into a project's build system.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/docs/src/using-parsers/1-getting-started.md#2025-04-21_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\ntree-sitter/lib/src/lib.c\n```\n\n----------------------------------------\n\nTITLE: Parsing JSON with Tree-sitter in C\nDESCRIPTION: A complete example program that demonstrates how to use Tree-sitter to parse JSON code. It creates a parser, sets the language to JSON, parses a string, and traverses the syntax tree.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/docs/src/using-parsers/1-getting-started.md#2025-04-21_snippet_2\n\nLANGUAGE: c\nCODE:\n```\n// Filename - test-json-parser.c\n\n#include <assert.h>\n#include <string.h>\n#include <stdio.h>\n#include <tree_sitter/api.h>\n\n// Declare the `tree_sitter_json` function, which is\n// implemented by the `tree-sitter-json` library.\nconst TSLanguage *tree_sitter_json(void);\n\nint main() {\n  // Create a parser.\n  TSParser *parser = ts_parser_new();\n\n  // Set the parser's language (JSON in this case).\n  ts_parser_set_language(parser, tree_sitter_json());\n\n  // Build a syntax tree based on source code stored in a string.\n  const char *source_code = \"[1, null]\";\n  TSTree *tree = ts_parser_parse_string(\n    parser,\n    NULL,\n    source_code,\n    strlen(source_code)\n  );\n\n  // Get the root node of the syntax tree.\n  TSNode root_node = ts_tree_root_node(tree);\n\n  // Get some child nodes.\n  TSNode array_node = ts_node_named_child(root_node, 0);\n  TSNode number_node = ts_node_named_child(array_node, 0);\n\n  // Check that the nodes have the expected types.\n  assert(strcmp(ts_node_type(root_node), \"document\") == 0);\n  assert(strcmp(ts_node_type(array_node), \"array\") == 0);\n  assert(strcmp(ts_node_type(number_node), \"number\") == 0);\n\n  // Check that the nodes have the expected child counts.\n  assert(ts_node_child_count(root_node) == 1);\n  assert(ts_node_child_count(array_node) == 5);\n  assert(ts_node_named_child_count(array_node) == 2);\n  assert(ts_node_child_count(number_node) == 0);\n\n  // Print the syntax tree as an S-expression.\n  char *string = ts_node_string(root_node);\n  printf(\"Syntax tree: %s\\n\", string);\n\n  // Free all of the heap-allocated memory.\n  free(string);\n  ts_tree_delete(tree);\n  ts_parser_delete(parser);\n  return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Example Tree-sitter.json Configuration\nDESCRIPTION: A basic example of a tree-sitter.json configuration for a Ruby grammar. This demonstrates the essential fields like scope, file types, and first-line-regex that specify language detection parameters.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/docs/src/cli/init.md#2025-04-21_snippet_1\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"tree-sitter\": [\n    {\n      \"scope\": \"source.ruby\",\n      \"file-types\": [\n        \"rb\",\n        \"gemspec\",\n        \"Gemfile\",\n        \"Rakefile\"\n      ],\n      \"first-line-regex\": \"#!.*\\\\bruby$\"\n    }\n  ]\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Initial Grammar Structure for Go in Tree-sitter\nDESCRIPTION: A skeleton grammar definition for the Go language that establishes the basic structure including definitions, functions, parameters, types, blocks, statements, and expressions. This serves as a starting point for incremental grammar development.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/docs/src/creating-parsers/3-writing-the-grammar.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n{\n  // ...\n\n  rules: {\n    source_file: $ => repeat($._definition),\n\n    _definition: $ => choice(\n      $.function_definition\n      // TODO: other kinds of definitions\n    ),\n\n    function_definition: $ => seq(\n      'func',\n      $.identifier,\n      $.parameter_list,\n      $._type,\n      $.block\n    ),\n\n    parameter_list: $ => seq(\n      '(',\n       // TODO: parameters\n      ')'\n    ),\n\n    _type: $ => choice(\n      'bool'\n      // TODO: other kinds of types\n    ),\n\n    block: $ => seq(\n      '{',\n      repeat($._statement),\n      '}'\n    ),\n\n    _statement: $ => choice(\n      $.return_statement\n      // TODO: other kinds of statements\n    ),\n\n    return_statement: $ => seq(\n      'return',\n      $._expression,\n      ';'\n    ),\n\n    _expression: $ => choice(\n      $.identifier,\n      $.number\n      // TODO: other kinds of expressions\n    ),\n\n    identifier: $ => /[a-z]+/,\n\n    number: $ => /\\d+/\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Node Navigation Functions\nDESCRIPTION: Functions for navigating between nodes including child access, sibling traversal, and parent retrieval.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/docs/src/using-parsers/2-basic-parsing.md#2025-04-21_snippet_6\n\nLANGUAGE: c\nCODE:\n```\nuint32_t ts_node_child_count(TSNode);\nTSNode ts_node_child(TSNode, uint32_t);\n\nTSNode ts_node_next_sibling(TSNode);\nTSNode ts_node_prev_sibling(TSNode);\nTSNode ts_node_parent(TSNode);\n```\n\n----------------------------------------\n\nTITLE: Implementing Word Token for Keyword Extraction in JavaScript Grammar\nDESCRIPTION: A JavaScript grammar example showing how to use the `word` token to identify keywords like 'typeof' and 'instanceof'. This approach prevents incorrect matching of identifiers that contain keywords as substrings and improves parser compilation speed.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/docs/src/creating-parsers/3-writing-the-grammar.md#2025-04-21_snippet_8\n\nLANGUAGE: javascript\nCODE:\n```\ngrammar({\n  name: \"javascript\",\n\n  word: $ => $.identifier,\n\n  rules: {\n    _expression: $ =>\n      choice(\n        $.identifier,\n        $.unary_expression,\n        $.binary_expression,\n        // ...\n      ),\n\n    binary_expression: $ =>\n      choice(\n        prec.left(1, seq($._expression, \"instanceof\", $._expression)),\n        // ...\n      ),\n\n    unary_expression: $ =>\n      choice(\n        prec.left(2, seq(\"typeof\", $._expression)),\n        // ...\n      ),\n\n    identifier: $ => /[a-z_]+/,\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Creating a Basic Python Function Definition Query in Tree-sitter\nDESCRIPTION: A simple Tree-sitter query that identifies Python function definitions and captures their names. This query finds function_definition nodes and tags them with @definition.function while capturing the identifier as @name.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/docs/src/4-code-navigation.md#2025-04-21_snippet_0\n\nLANGUAGE: query\nCODE:\n```\n(function_definition\n  name: (identifier) @name) @definition.function\n```\n\n----------------------------------------\n\nTITLE: Initial Tree-sitter Grammar Template\nDESCRIPTION: JavaScript code template for the initial grammar file (grammar.js) created by the Tree-sitter init command. It includes placeholders for parser description, author information, and license.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/docs/src/creating-parsers/1-getting-started.md#2025-04-21_snippet_2\n\nLANGUAGE: js\nCODE:\n```\n/**\n * @file PARSER_DESCRIPTION\n * @author PARSER_AUTHOR_NAME PARSER_AUTHOR_EMAIL\n * @license PARSER_LICENSE\n */\n\n/// <reference types=\"tree-sitter-cli/dsl\" />\n// @ts-check\n\nmodule.exports = grammar({\n  name: 'LOWER_PARSER_NAME',\n\n  rules: {\n    // TODO: add the actual grammar rules\n    source_file: $ => 'hello'\n  }\n});\n```\n\n----------------------------------------\n\nTITLE: Tree-sitter Core API Function List\nDESCRIPTION: A comprehensive list of function names from the Tree-sitter API, which is used for incremental parsing and syntax tree manipulation. The functions are organized into categories including initialization, language operations, node manipulation, parser operations, query functionality, tree manipulation, and cursor navigation.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/lib/binding_web/lib/exports.txt#2025-04-21_snippet_0\n\nLANGUAGE: C\nCODE:\n```\n\"ts_init\",\n\"ts_language_field_count\",\n\"ts_language_field_name_for_id\",\n\"ts_language_type_is_named_wasm\",\n\"ts_language_type_is_visible_wasm\",\n\"ts_language_symbol_count\",\n\"ts_language_state_count\",\n\"ts_language_supertypes_wasm\",\n\"ts_language_subtypes_wasm\",\n\"ts_language_symbol_for_name\",\n\"ts_language_symbol_name\",\n\"ts_language_symbol_type\",\n\"ts_language_name\",\n\"ts_language_version\",\n\"ts_language_abi_version\",\n\"ts_language_metadata\",\n\"ts_language_next_state\",\n\"ts_node_field_name_for_child_wasm\",\n\"ts_node_field_name_for_named_child_wasm\",\n\"ts_node_children_by_field_id_wasm\",\n\"ts_node_first_child_for_byte_wasm\",\n\"ts_node_first_named_child_for_byte_wasm\",\n\"ts_node_child_by_field_id_wasm\",\n\"ts_node_child_count_wasm\",\n\"ts_node_child_wasm\",\n\"ts_node_children_wasm\",\n\"ts_node_descendant_for_index_wasm\",\n\"ts_node_descendant_for_position_wasm\",\n\"ts_node_descendants_of_type_wasm\",\n\"ts_node_end_index_wasm\",\n\"ts_node_end_point_wasm\",\n\"ts_node_has_changes_wasm\",\n\"ts_node_has_error_wasm\",\n\"ts_node_is_error_wasm\",\n\"ts_node_is_missing_wasm\",\n\"ts_node_is_extra_wasm\",\n\"ts_node_is_named_wasm\",\n\"ts_node_parse_state_wasm\",\n\"ts_node_next_parse_state_wasm\",\n\"ts_node_named_child_count_wasm\",\n\"ts_node_named_child_wasm\",\n\"ts_node_named_children_wasm\",\n\"ts_node_named_descendant_for_index_wasm\",\n\"ts_node_named_descendant_for_position_wasm\",\n\"ts_node_next_named_sibling_wasm\",\n\"ts_node_next_sibling_wasm\",\n\"ts_node_parent_wasm\",\n\"ts_node_child_with_descendant_wasm\",\n\"ts_node_prev_named_sibling_wasm\",\n\"ts_node_prev_sibling_wasm\",\n\"ts_node_descendant_count_wasm\",\n\"ts_node_start_index_wasm\",\n\"ts_node_start_point_wasm\",\n\"ts_node_symbol_wasm\",\n\"ts_node_grammar_symbol_wasm\",\n\"ts_node_to_string_wasm\",\n\"ts_parser_delete\",\n\"ts_parser_enable_logger_wasm\",\n\"ts_parser_new_wasm\",\n\"ts_parser_parse_wasm\",\n\"ts_parser_reset\",\n\"ts_parser_set_language\",\n\"ts_parser_set_included_ranges\",\n\"ts_parser_included_ranges_wasm\",\n\"ts_parser_set_timeout_micros\",\n\"ts_parser_timeout_micros\",\n\"ts_query_capture_count\",\n\"ts_query_capture_name_for_id\",\n\"ts_query_captures_wasm\",\n\"ts_query_delete\",\n\"ts_query_matches_wasm\",\n\"ts_query_new\",\n\"ts_query_pattern_count\",\n\"ts_query_predicates_for_pattern\",\n\"ts_query_disable_capture\",\n\"ts_query_start_byte_for_pattern\",\n\"ts_query_end_byte_for_pattern\",\n\"ts_query_string_count\",\n\"ts_query_string_value_for_id\",\n\"ts_query_disable_pattern\",\n\"ts_query_capture_quantifier_for_id\",\n\"ts_query_is_pattern_non_local\",\n\"ts_query_is_pattern_rooted\",\n\"ts_query_is_pattern_guaranteed_at_step\",\n\"ts_tree_copy\",\n\"ts_tree_cursor_current_field_id_wasm\",\n\"ts_tree_cursor_current_depth_wasm\",\n\"ts_tree_cursor_current_descendant_index_wasm\",\n\"ts_tree_cursor_current_node_id_wasm\",\n\"ts_tree_cursor_current_node_is_missing_wasm\",\n\"ts_tree_cursor_current_node_is_named_wasm\",\n\"ts_tree_cursor_current_node_type_id_wasm\",\n\"ts_tree_cursor_current_node_state_id_wasm\",\n\"ts_tree_cursor_current_node_wasm\",\n\"ts_tree_cursor_delete_wasm\",\n\"ts_tree_cursor_end_index_wasm\",\n\"ts_tree_cursor_end_position_wasm\",\n\"ts_tree_cursor_goto_first_child_wasm\",\n\"ts_tree_cursor_goto_last_child_wasm\",\n\"ts_tree_cursor_goto_first_child_for_index_wasm\",\n\"ts_tree_cursor_goto_first_child_for_position_wasm\",\n\"ts_tree_cursor_goto_next_sibling_wasm\",\n\"ts_tree_cursor_goto_previous_sibling_wasm\",\n\"ts_tree_cursor_goto_descendant_wasm\",\n\"ts_tree_cursor_goto_parent_wasm\",\n\"ts_tree_cursor_new_wasm\",\n\"ts_tree_cursor_reset_wasm\",\n\"ts_tree_cursor_reset_to_wasm\",\n\"ts_tree_cursor_start_index_wasm\",\n\"ts_tree_cursor_start_position_wasm\",\n\"ts_tree_cursor_copy_wasm\",\n\"ts_tree_delete\",\n\"ts_tree_included_ranges_wasm\",\n\"ts_tree_edit_wasm\",\n\"ts_tree_get_changed_ranges_wasm\",\n\"ts_tree_root_node_wasm\",\n\"ts_tree_root_node_with_offset_wasm\",\n\"ts_lookahead_iterator_new\",\n\"ts_lookahead_iterator_delete\",\n\"ts_lookahead_iterator_reset_state\",\n\"ts_lookahead_iterator_reset\",\n\"ts_lookahead_iterator_next\",\n\"ts_lookahead_iterator_current_symbol\",\n```\n\n----------------------------------------\n\nTITLE: Basic Usage of Web Tree-sitter\nDESCRIPTION: This snippet demonstrates the basic usage of Web Tree-sitter, including creating a parser, loading a language, parsing source code, and inspecting the syntax tree.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/lib/binding_web/README.md#2025-04-21_snippet_6\n\nLANGUAGE: javascript\nCODE:\n```\nconst parser = new Parser();\n\nconst { Language } = require('web-tree-sitter');\nconst JavaScript = await Language.load('/path/to/tree-sitter-javascript.wasm');\nparser.setLanguage(JavaScript);\n\nconst sourceCode = 'let x = 1; console.log(x);';\nconst tree = parser.parse(sourceCode);\n\nconsole.log(tree.rootNode.toString());\n\nconst callExpression = tree.rootNode.child(1).firstChild;\nconsole.log(callExpression);\n```\n\n----------------------------------------\n\nTITLE: Multi-language Parsing Implementation in C\nDESCRIPTION: Complete example showing how to parse a document containing multiple languages (ERB, HTML, and Ruby) using Tree-sitter's range-based parsing capabilities.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/docs/src/using-parsers/3-advanced-parsing.md#2025-04-21_snippet_3\n\nLANGUAGE: c\nCODE:\n```\n#include <string.h>\n#include <tree_sitter/api.h>\n\n// These functions are each implemented in their own repo.\nconst TSLanguage *tree_sitter_embedded_template(void);\nconst TSLanguage *tree_sitter_html(void);\nconst TSLanguage *tree_sitter_ruby(void);\n\nint main(int argc, const char **argv) {\n  const char *text = argv[1];\n  unsigned len = strlen(text);\n\n  // Parse the entire text as ERB.\n  TSParser *parser = ts_parser_new();\n  ts_parser_set_language(parser, tree_sitter_embedded_template());\n  TSTree *erb_tree = ts_parser_parse_string(parser, NULL, text, len);\n  TSNode erb_root_node = ts_tree_root_node(erb_tree);\n\n  // In the ERB syntax tree, find the ranges of the `content` nodes,\n  // which represent the underlying HTML, and the `code` nodes, which\n  // represent the interpolated Ruby.\n  TSRange html_ranges[10];\n  TSRange ruby_ranges[10];\n  unsigned html_range_count = 0;\n  unsigned ruby_range_count = 0;\n  unsigned child_count = ts_node_child_count(erb_root_node);\n\n  for (unsigned i = 0; i < child_count; i++) {\n    TSNode node = ts_node_child(erb_root_node, i);\n    if (strcmp(ts_node_type(node), \"content\") == 0) {\n      html_ranges[html_range_count++] = (TSRange) {\n        ts_node_start_point(node),\n        ts_node_end_point(node),\n        ts_node_start_byte(node),\n        ts_node_end_byte(node),\n      };\n    } else {\n      TSNode code_node = ts_node_named_child(node, 0);\n      ruby_ranges[ruby_range_count++] = (TSRange) {\n        ts_node_start_point(code_node),\n        ts_node_end_point(code_node),\n        ts_node_start_byte(code_node),\n        ts_node_end_byte(code_node),\n      };\n    }\n  }\n\n  // Use the HTML ranges to parse the HTML.\n  ts_parser_set_language(parser, tree_sitter_html());\n  ts_parser_set_included_ranges(parser, html_ranges, html_range_count);\n  TSTree *html_tree = ts_parser_parse_string(parser, NULL, text, len);\n  TSNode html_root_node = ts_tree_root_node(html_tree);\n\n  // Use the Ruby ranges to parse the Ruby.\n  ts_parser_set_language(parser, tree_sitter_ruby());\n  ts_parser_set_included_ranges(parser, ruby_ranges, ruby_range_count);\n  TSTree *ruby_tree = ts_parser_parse_string(parser, NULL, text, len);\n  TSNode ruby_root_node = ts_tree_root_node(ruby_tree);\n\n  // Print all three trees.\n  char *erb_sexp = ts_node_string(erb_root_node);\n  char *html_sexp = ts_node_string(html_root_node);\n  char *ruby_sexp = ts_node_string(ruby_root_node);\n  printf(\"ERB: %s\\n\", erb_sexp);\n  printf(\"HTML: %s\\n\", html_sexp);\n  printf(\"Ruby: %s\\n\", ruby_sexp);\n  return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing Tree-sitter Parser Project\nDESCRIPTION: Shell command to initialize a new Tree-sitter parser project using the Tree-sitter CLI. This command will prompt for input and create necessary project files.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/docs/src/creating-parsers/1-getting-started.md#2025-04-21_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\n# This will prompt you for input\ntree-sitter init\n```\n\n----------------------------------------\n\nTITLE: Multi-language Range Parsing in C\nDESCRIPTION: Demonstrates the TSRange structure and API for parsing specific ranges of text in different languages. Used for handling documents that contain multiple programming languages.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/docs/src/using-parsers/3-advanced-parsing.md#2025-04-21_snippet_1\n\nLANGUAGE: c\nCODE:\n```\ntypedef struct {\n  TSPoint start_point;\n  TSPoint end_point;\n  uint32_t start_byte;\n  uint32_t end_byte;\n} TSRange;\n\nvoid ts_parser_set_included_ranges(\n  TSParser *self,\n  const TSRange *ranges,\n  uint32_t range_count\n);\n```\n\n----------------------------------------\n\nTITLE: Implementing Array-Based Scanner in C\nDESCRIPTION: Example implementation of a Tree-sitter external scanner using arrays to track indentation levels and parse strings. Shows array initialization, pushing/popping elements, and string character accumulation with size constraints.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/docs/src/creating-parsers/4-external-scanners.md#2025-04-21_snippet_8\n\nLANGUAGE: c\nCODE:\n```\n#include \"tree_sitter/parser.h\"\n#include \"tree_sitter/array.h\"\n\nenum TokenType {\n  INDENT,\n  DEDENT,\n  NEWLINE,\n  STRING,\n}\n\nvoid* tree_sitter_my_language_external_scanner_create() {\n  return ts_calloc(1, sizeof(Array(int)));\n\n  // or if you want to zero out the memory yourself\n\n  Array(int) *stack = ts_malloc(sizeof(Array(int)));\n  array_init(&stack);\n  return stack;\n}\n\nbool tree_sitter_my_language_external_scanner_scan(\n  void *payload,\n  TSLexer *lexer,\n  const bool *valid_symbols\n) {\n  Array(int) *stack = payload;\n  if (valid_symbols[INDENT]) {\n    array_push(stack, lexer->get_column(lexer));\n    lexer->result_symbol = INDENT;\n    return true;\n  }\n  if (valid_symbols[DEDENT]) {\n    array_pop(stack); // this returns the popped element by value, but we don't need it\n    lexer->result_symbol = DEDENT;\n    return true;\n  }\n\n  // we can also use an array on the stack to keep track of a string\n\n  Array(char) next_string = array_new();\n\n  if (valid_symbols[STRING] && lexer->lookahead == '\"') {\n    lexer->advance(lexer, false);\n    while (lexer->lookahead != '\"' && lexer->lookahead != '\\n' && !lexer->eof(lexer)) {\n      array_push(&next_string, lexer->lookahead);\n      lexer->advance(lexer, false);\n    }\n\n    // assume we have some arbitrary constraint of not having more than 100 characters in a string\n    if (lexer->lookahead == '\"' && next_string.size <= 100) {\n      lexer->advance(lexer, false);\n      lexer->result_symbol = STRING;\n      return true;\n    }\n  }\n\n  return false;\n}\n```\n\n----------------------------------------\n\nTITLE: Matching Binary Expressions with String Literals in Tree-sitter Query\nDESCRIPTION: Shows how to create a pattern that matches any binary_expression where at least one child is a string_literal node. This example demonstrates partial child matching in tree-sitter queries.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/docs/src/using-parsers/queries/1-syntax.md#2025-04-21_snippet_1\n\nLANGUAGE: query\nCODE:\n```\n(binary_expression (string_literal))\n```\n\n----------------------------------------\n\nTITLE: Performing Syntax Highlighting on JavaScript Code\nDESCRIPTION: This code demonstrates the actual highlighting process and handling of highlight events. It passes JavaScript code to the highlighter and processes the resulting events, which include source ranges and highlight style markers.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/highlight/README.md#2025-04-21_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\nuse tree_sitter_highlight::HighlightEvent;\n\nlet highlights = highlighter.highlight(\n    &javascript_config,\n    b\"const x = new Y();\",\n    None,\n    |_| None\n).unwrap();\n\nfor event in highlights {\n    match event.unwrap() {\n        HighlightEvent::Source {start, end} => {\n            eprintln!(\"source: {start}-{end}\");\n        },\n        HighlightEvent::HighlightStart(s) => {\n            eprintln!(\"highlight style started: {s:?}\");\n        },\n        HighlightEvent::HighlightEnd => {\n            eprintln!(\"highlight style ended\");\n        },\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Tree-sitter CLI with NPM\nDESCRIPTION: Command to install the Tree-sitter CLI tool using Node Package Manager (NPM).\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/cli/README.md#2025-04-21_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\nnpm install tree-sitter-cli\n```\n\n----------------------------------------\n\nTITLE: Editing Syntax Trees in C using Tree-sitter\nDESCRIPTION: Defines structures and functions for editing syntax trees to keep them in sync with code changes. Includes TSInputEdit structure definition and functions for updating both trees and individual nodes.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/docs/src/using-parsers/3-advanced-parsing.md#2025-04-21_snippet_0\n\nLANGUAGE: c\nCODE:\n```\ntypedef struct {\n  uint32_t start_byte;\n  uint32_t old_end_byte;\n  uint32_t new_end_byte;\n  TSPoint start_point;\n  TSPoint old_end_point;\n  TSPoint new_end_point;\n} TSInputEdit;\n\nvoid ts_tree_edit(TSTree *, const TSInputEdit *);\n\n```\n\nLANGUAGE: c\nCODE:\n```\nvoid ts_node_edit(TSNode *, const TSInputEdit *);\n```\n\n----------------------------------------\n\nTITLE: Initializing Tree-sitter Parser in Rust\nDESCRIPTION: Creates a new Tree-sitter parser instance in Rust. This is the first step in using the library for parsing source code.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/lib/binding_rust/README.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse tree_sitter::{InputEdit, Language, Parser, Point};\n\nlet mut parser = Parser::new();\n```\n\n----------------------------------------\n\nTITLE: Creating a Ruby Class Definition Query with Docstring Processing\nDESCRIPTION: An advanced Tree-sitter query for Ruby that captures class definitions along with their adjacent docstrings. It uses built-in functions (#strip! and #select-adjacent!) to clean up comment syntax and select only relevant documentation.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/docs/src/4-code-navigation.md#2025-04-21_snippet_2\n\nLANGUAGE: query\nCODE:\n```\n(\n  (comment)* @doc\n  .\n  [\n    (class\n      name: [\n        (constant) @name\n        (scope_resolution\n          name: (_) @name)\n      ]) @definition.class\n    (singleton_class\n      value: [\n        (constant) @name\n        (scope_resolution\n          name: (_) @name)\n      ]) @definition.class\n  ]\n  (#strip! @doc \"^#\\\\s*\")\n  (#select-adjacent! @doc @definition.class)\n)\n```\n\n----------------------------------------\n\nTITLE: Identifying Non-Local Built-in Variables with is? Predicate\nDESCRIPTION: A Tree-sitter pattern using both #match? and #is-not? predicates to identify built-in variables that are not local variables.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/docs/src/using-parsers/queries/3-predicates-and-directives.md#2025-04-21_snippet_7\n\nLANGUAGE: query\nCODE:\n```\n((identifier) @variable.builtin\n  (#match? @variable.builtin \"^(arguments|module|console|window|document)$\")\n  (#is-not? local))\n```\n\n----------------------------------------\n\nTITLE: Executing Tree-sitter Generate Command in Bash\nDESCRIPTION: This command runs the Tree-sitter generate process. It can accept options and an optional path to a grammar file. The command generates a parser implementation based on the specified grammar.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/docs/src/cli/generate.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ntree-sitter generate [OPTIONS] [GRAMMAR_PATH] # Aliases: gen, g\n```\n\n----------------------------------------\n\nTITLE: Loading Web Tree-sitter in HTML\nDESCRIPTION: This snippet demonstrates how to load Web Tree-sitter using a standalone script in an HTML file. It includes initializing the Parser and waiting for the library to be ready.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/lib/binding_web/README.md#2025-04-21_snippet_0\n\nLANGUAGE: html\nCODE:\n```\n<script src=\"/the/path/to/web-tree-sitter.js\"></script>\n\n<script>\n  const { Parser } = window.TreeSitter;\n  Parser.init().then(() => { /* the library is ready */ });\n</script>\n```\n\n----------------------------------------\n\nTITLE: Including Field Names in Tree-sitter Test Expectations\nDESCRIPTION: Shows how to include field names in the expected syntax tree output, which helps document the relationship between nodes in the tree.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/docs/src/creating-parsers/5-writing-tests.md#2025-04-21_snippet_1\n\nLANGUAGE: query\nCODE:\n```\n(source_file\n  (function_definition\n    name: (identifier)\n    parameters: (parameter_list)\n    result: (primitive_type)\n    body: (block\n      (return_statement (number)))))\n```\n\n----------------------------------------\n\nTITLE: Node Type and Position Functions\nDESCRIPTION: Functions for accessing node type and position information in both byte offsets and row/column coordinates.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/docs/src/using-parsers/2-basic-parsing.md#2025-04-21_snippet_4\n\nLANGUAGE: c\nCODE:\n```\nconst char *ts_node_type(TSNode);\n\nuint32_t ts_node_start_byte(TSNode);\nuint32_t ts_node_end_byte(TSNode);\ntypedef struct {\n  uint32_t row;\n  uint32_t column;\n} TSPoint;\nTSPoint ts_node_start_point(TSNode);\nTSPoint ts_node_end_point(TSNode);\n```\n\n----------------------------------------\n\nTITLE: Basic Expression Grammar Structure in JavaScript\nDESCRIPTION: Demonstrates the basic flat structure for defining expression grammar rules including unary and binary expressions.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/docs/src/creating-parsers/3-writing-the-grammar.md#2025-04-21_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\n{\n  _expression: $ => choice(\n    $.identifier,\n    $.unary_expression,\n    $.binary_expression,\n    // ...\n  ),\n\n  unary_expression: $ => choice(\n    seq('-', $._expression),\n    seq('!', $._expression),\n    // ...\n  ),\n\n  binary_expression: $ => choice(\n    seq($._expression, '*', $._expression),\n    seq($._expression, '+', $._expression),\n    // ...\n  ),\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing Tree-sitter Parser with WASM Store in Rust\nDESCRIPTION: Creates a Tree-sitter parser with a WASM store, which is required for using WASM grammar files. This setup enables parsing with WebAssembly-based language grammars.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/lib/binding_rust/README.md#2025-04-21_snippet_7\n\nLANGUAGE: rust\nCODE:\n```\nuse tree_sitter::{wasmtime::Engine, Parser, WasmStore};\n\nlet engine = Engine::default();\nlet store = WasmStore::new(&engine).unwrap();\n\nlet mut parser = Parser::new();\nparser.set_wasm_store(store).unwrap();\n```\n\n----------------------------------------\n\nTITLE: Using Alternations in Tree-sitter Queries\nDESCRIPTION: Pattern that uses alternation ([]) to match either a function call to a variable or to an object property, with different captures for each case.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/docs/src/using-parsers/queries/2-operators.md#2025-04-21_snippet_7\n\nLANGUAGE: query\nCODE:\n```\n(call_expression\n  function: [\n    (identifier) @function\n    (member_expression\n      property: (property_identifier) @method)\n  ])\n```\n\n----------------------------------------\n\nTITLE: Importing Web Tree-sitter in Vite\nDESCRIPTION: This snippet demonstrates how to import and initialize Web Tree-sitter in a Vite environment using ES6 import syntax.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/lib/binding_web/README.md#2025-04-21_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nimport { Parser }  from 'web-tree-sitter';\nParser.init().then(() => { /* the library is ready */ });\n```\n\n----------------------------------------\n\nTITLE: Installing Tree-sitter CLI with Cargo\nDESCRIPTION: Command to install the Tree-sitter CLI tool using Rust's Cargo package manager with locked dependencies.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/cli/README.md#2025-04-21_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\ncargo install --locked tree-sitter-cli\n```\n\n----------------------------------------\n\nTITLE: JavaScript Syntax Highlighting Test\nDESCRIPTION: A JavaScript code example with embedded test comments that make assertions about the expected syntax highlighting. The comments use caret and arrow notations to test specific highlighting at particular positions.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/docs/src/3-syntax-highlighting.md#2025-04-21_snippet_12\n\nLANGUAGE: javascript\nCODE:\n```\nvar abc = function(d) {\n  // <- keyword\n  //          ^ keyword\n  //               ^ variable.parameter\n  // ^ function\n\n  if (a) {\n  // <- keyword\n  // ^ punctuation.bracket\n\n    foo(`foo ${bar}`);\n    // <- function\n    //    ^ string\n    //          ^ variable\n  }\n\n  baz();\n  // <- !variable\n};\n```\n\n----------------------------------------\n\nTITLE: Testing Tree-sitter Parser (Unix)\nDESCRIPTION: Shell commands to create a test file and parse it using the newly generated Tree-sitter parser on Unix-like systems.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/docs/src/creating-parsers/1-getting-started.md#2025-04-21_snippet_4\n\nLANGUAGE: sh\nCODE:\n```\necho 'hello' > example-file\ntree-sitter parse example-file\n```\n\n----------------------------------------\n\nTITLE: Language Injection Query Using Heredoc End Node\nDESCRIPTION: A scheme query that specifies language injection for heredoc content based on the language name from the heredoc_end node, allowing for dynamic language selection based on the heredoc delimiter.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/docs/src/3-syntax-highlighting.md#2025-04-21_snippet_10\n\nLANGUAGE: scheme\nCODE:\n```\n(heredoc_body\n  (heredoc_end) @injection.language) @injection.content\n```\n\n----------------------------------------\n\nTITLE: Creating Tree-sitter Query - C API\nDESCRIPTION: Function to create a new Tree-sitter query from a pattern string. Takes a language definition, source pattern, and error handling parameters. Returns a TSQuery pointer that is immutable and thread-safe.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/docs/src/using-parsers/queries/4-api.md#2025-04-21_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nTSQuery *ts_query_new(\n  const TSLanguage *language,\n  const char *source,\n  uint32_t source_len,\n  uint32_t *error_offset,\n  TSQueryError *error_type\n);\n```\n\n----------------------------------------\n\nTITLE: Using the Tree-sitter Parse Command in Bash\nDESCRIPTION: This command demonstrates the basic usage of the 'tree-sitter parse' command. It allows parsing of multiple files or file patterns, with various options available for customization.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/docs/src/cli/parse.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ntree-sitter parse [OPTIONS] [PATHS]... # Aliases: p\n```\n\n----------------------------------------\n\nTITLE: Query Match Processing Structures - C API\nDESCRIPTION: Structures for handling query matches and captures. Includes TSQueryCapture for individual node captures and TSQueryMatch for complete match information including pattern index and capture array.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/docs/src/using-parsers/queries/4-api.md#2025-04-21_snippet_4\n\nLANGUAGE: c\nCODE:\n```\ntypedef struct {\n  TSNode node;\n  uint32_t index;\n} TSQueryCapture;\n\ntypedef struct {\n  uint32_t id;\n  uint16_t pattern_index;\n  uint16_t capture_count;\n  const TSQueryCapture *captures;\n} TSQueryMatch;\n\nbool ts_query_cursor_next_match(TSQueryCursor *, TSQueryMatch *match);\n```\n\n----------------------------------------\n\nTITLE: Using Field Names in Tree-sitter Query Patterns\nDESCRIPTION: Illustrates how to make patterns more specific by using field names to match particular child nodes. This example matches an assignment_expression node with specific nested field relationships.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/docs/src/using-parsers/queries/1-syntax.md#2025-04-21_snippet_2\n\nLANGUAGE: query\nCODE:\n```\n(assignment_expression\n  left: (member_expression\n    object: (call_expression)))\n```\n\n----------------------------------------\n\nTITLE: Setting Language Injection for Doxygen Comments with set! Directive\nDESCRIPTION: A Tree-sitter pattern using the #set! directive to specify that comments matching a certain pattern should be parsed with the Doxygen language parser.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/docs/src/using-parsers/queries/3-predicates-and-directives.md#2025-04-21_snippet_8\n\nLANGUAGE: query\nCODE:\n```\n((comment) @injection.content\n  (#lua-match? @injection.content \"/[*\\/][!*\\/]<?[^a-zA-Z]\")\n  (#set! injection.language \"doxygen\"))\n```\n\n----------------------------------------\n\nTITLE: Local Variable Tracking Query for Ruby Code\nDESCRIPTION: A scheme query for tracking local variables and scopes in Ruby. This query identifies methods and blocks as scopes, parameters and assignments as definitions, and other identifiers as references.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/docs/src/3-syntax-highlighting.md#2025-04-21_snippet_7\n\nLANGUAGE: scheme\nCODE:\n```\n; locals.scm\n\n(method) @local.scope\n(do_block) @local.scope\n\n(method_parameters (identifier) @local.definition)\n(block_parameters (identifier) @local.definition)\n\n(assignment left:(identifier) @local.definition)\n\n(identifier) @local.reference\n```\n\n----------------------------------------\n\nTITLE: Extending Grammar with Type Definitions in Tree-sitter\nDESCRIPTION: An example of expanding the grammar to handle different types of Go types, including primitive types, array types, and pointer types. This demonstrates how to incrementally build out a specific part of the language grammar.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/docs/src/creating-parsers/3-writing-the-grammar.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\n{\n  // ...\n\n  _type: $ => choice(\n    $.primitive_type,\n    $.array_type,\n    $.pointer_type\n  ),\n\n  primitive_type: $ => choice(\n    'bool',\n    'int'\n  ),\n\n  array_type: $ => seq(\n    '[',\n    ']',\n    $._type\n  ),\n\n  pointer_type: $ => seq(\n    '*',\n    $._type\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: JavaScript Grammar with Array Ambiguity\nDESCRIPTION: Example of grammar rules that create intentional ambiguity between array literals and array patterns.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/docs/src/creating-parsers/3-writing-the-grammar.md#2025-04-21_snippet_5\n\nLANGUAGE: javascript\nCODE:\n```\nmodule.exports = grammar({\n  name: \"javascript\",\n\n  rules: {\n    expression: $ => choice(\n      $.identifier,\n      $.array,\n      $.pattern,\n    ),\n\n    array: $ => seq(\n      \"[\",\n      optional(seq(\n        $.expression, repeat(seq(\",\", $.expression))\n      )),\n      \"]\"\n    ),\n\n    array_pattern: $ => seq(\n      \"[\",\n      optional(seq(\n        $.pattern, repeat(seq(\",\", $.pattern))\n      )),\n      \"]\"\n    ),\n\n    pattern: $ => choice(\n      $.identifier,\n      $.array_pattern,\n    ),\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Matching Anonymous Nodes in Tree-sitter Queries\nDESCRIPTION: Demonstrates how to match specific anonymous nodes by writing their name between double quotes. This example matches a binary expression with a specific operator and right operand.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/docs/src/using-parsers/queries/1-syntax.md#2025-04-21_snippet_4\n\nLANGUAGE: query\nCODE:\n```\n(binary_expression\n  operator: \"!=\"\n  right: (null))\n```\n\n----------------------------------------\n\nTITLE: Configuring Grammar Conflicts\nDESCRIPTION: Shows how to explicitly declare intended ambiguities in the grammar using the conflicts property.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/docs/src/creating-parsers/3-writing-the-grammar.md#2025-04-21_snippet_6\n\nLANGUAGE: javascript\nCODE:\n```\n{\n  name: \"javascript\",\n\n  conflicts: $ => [\n    [$.array, $.array_pattern],\n  ],\n\n  rules: {\n    // ...\n  },\n}\n```\n\n----------------------------------------\n\nTITLE: Running Tree-sitter Init Command in Bash\nDESCRIPTION: The basic command syntax for initializing a new tree-sitter grammar repository. The init command (or its alias 'i') sets up all essential files and structure needed for grammar development.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/docs/src/cli/init.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ntree-sitter init [OPTIONS] # Aliases: i\n```\n\n----------------------------------------\n\nTITLE: Node Type Using Supertype Reference in node-types.json\nDESCRIPTION: Example showing how supertypes are used within other node type definitions. By referencing the supertype (_declaration) instead of listing all possible subtypes, the node types file becomes more concise and easier to read.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/docs/src/using-parsers/6-static-node-types.md#2025-04-21_snippet_4\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"type\": \"export_statement\",\n  \"named\": true,\n  \"fields\": {\n    \"declaration\": {\n      \"multiple\": false,\n      \"required\": false,\n      \"types\": [{ \"type\": \"_declaration\", \"named\": true }]\n    },\n    \"source\": {\n      \"multiple\": false,\n      \"required\": false,\n      \"types\": [{ \"type\": \"string\", \"named\": true }]\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Parsing Source Code with Tree-sitter in Rust\nDESCRIPTION: Demonstrates how to parse a simple Rust function using Tree-sitter. It shows how to access the root node and its properties after parsing.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/lib/binding_rust/README.md#2025-04-21_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nlet source_code = \"fn test() {}\";\nlet mut tree = parser.parse(source_code, None).unwrap();\nlet root_node = tree.root_node();\n\nassert_eq!(root_node.kind(), \"source_file\");\nassert_eq!(root_node.start_position().column, 0);\nassert_eq!(root_node.end_position().column, 12);\n```\n\n----------------------------------------\n\nTITLE: Capturing Nodes in Tree-sitter Queries\nDESCRIPTION: Pattern that matches an assignment of a function to an identifier, capturing the identifier with the name 'the-function-name'.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/docs/src/using-parsers/queries/2-operators.md#2025-04-21_snippet_0\n\nLANGUAGE: query\nCODE:\n```\n(assignment_expression\n  left: (identifier) @the-function-name\n  right: (function))\n```\n\n----------------------------------------\n\nTITLE: Using Negated Fields in Tree-sitter Queries\nDESCRIPTION: Shows how to constrain a pattern to match nodes that lack a specific field by using the '!' prefix. This example matches class declarations without type parameters.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/docs/src/using-parsers/queries/1-syntax.md#2025-04-21_snippet_3\n\nLANGUAGE: query\nCODE:\n```\n(class_declaration\n  name: (identifier) @class_name\n  !type_parameters)\n```\n\n----------------------------------------\n\nTITLE: Editing Parsed Tree with Tree-sitter in Rust\nDESCRIPTION: Shows how to update an existing syntax tree when the source code changes. This process is more efficient than reparsing the entire source code.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/lib/binding_rust/README.md#2025-04-21_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\nlet new_source_code = \"fn test(a: u32) {}\";\n\ntree.edit(&InputEdit {\n  start_byte: 8,\n  old_end_byte: 8,\n  new_end_byte: 14,\n  start_position: Point::new(0, 8),\n  old_end_position: Point::new(0, 8),\n  new_end_position: Point::new(0, 14),\n});\n\nlet new_tree = parser.parse(new_source_code, Some(&tree));\n```\n\n----------------------------------------\n\nTITLE: Compiling Tree-sitter JSON Parser with Dynamic Linking\nDESCRIPTION: Shell command to compile the JSON parser example using dynamic linking. It links against the shared Tree-sitter library instead of the static library.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/docs/src/using-parsers/1-getting-started.md#2025-04-21_snippet_4\n\nLANGUAGE: sh\nCODE:\n```\nclang                                   \\\n  -I tree-sitter/lib/include            \\\n  test-json-parser.c                    \\\n  tree-sitter-json/src/parser.c         \\\n  -ltree-sitter                         \\\n  -o test-json-parser\n./test-json-parser\n```\n\n----------------------------------------\n\nTITLE: Node Type with Children Definition in node-types.json\nDESCRIPTION: Example of a node type with a 'children' field that describes all possible named children that don't have specific fields. The structure specifies whether children are required, can appear multiple times, and their possible types.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/docs/src/using-parsers/6-static-node-types.md#2025-04-21_snippet_2\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"type\": \"array\",\n  \"named\": true,\n  \"fields\": {},\n  \"children\": {\n    \"multiple\": true,\n    \"required\": false,\n    \"types\": [\n      { \"type\": \"_expression\", \"named\": true },\n      { \"type\": \"spread_element\", \"named\": true }\n    ]\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Custom Input Parsing in Tree-sitter\nDESCRIPTION: General parsing function that accepts custom input structures. Allows for parsing text stored in specialized data structures like piece tables or ropes.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/docs/src/using-parsers/2-basic-parsing.md#2025-04-21_snippet_1\n\nLANGUAGE: c\nCODE:\n```\nTSTree *ts_parser_parse(\n  TSParser *self,\n  const TSTree *old_tree,\n  TSInput input\n);\n```\n\n----------------------------------------\n\nTITLE: Using End Anchor in Tree-sitter Queries\nDESCRIPTION: Pattern using the '.' anchor operator at the end to capture only the last expression in a block.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/docs/src/using-parsers/queries/2-operators.md#2025-04-21_snippet_10\n\nLANGUAGE: query\nCODE:\n```\n(block (_) @last-expression .)\n```\n\n----------------------------------------\n\nTITLE: Creating a JavaScript Function Assignment Query in Tree-sitter\nDESCRIPTION: A more complex Tree-sitter query that recognizes JavaScript function assignments, including both standard function declarations and arrow functions. It handles both direct identifier assignments and member expressions.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/docs/src/4-code-navigation.md#2025-04-21_snippet_1\n\nLANGUAGE: query\nCODE:\n```\n(assignment_expression\n  left: [\n    (identifier) @name\n    (member_expression\n      property: (property_identifier) @name)\n  ]\n  right: [(arrow_function) (function)]\n) @definition.function\n```\n\n----------------------------------------\n\nTITLE: Capturing Multiple Nodes in Nested Structures\nDESCRIPTION: Pattern that matches class declarations with method definitions, capturing both the class name and method name with separate named captures.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/docs/src/using-parsers/queries/2-operators.md#2025-04-21_snippet_1\n\nLANGUAGE: query\nCODE:\n```\n(class_declaration\n  name: (identifier) @the-class-name\n  body: (class_body\n    (method_definition\n      name: (property_identifier) @the-method-name)))\n```\n\n----------------------------------------\n\nTITLE: Using Middle Anchor for Consecutive Siblings\nDESCRIPTION: Pattern using the '.' anchor between child patterns to match only consecutive identifier nodes in a dotted name expression.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/docs/src/using-parsers/queries/2-operators.md#2025-04-21_snippet_11\n\nLANGUAGE: query\nCODE:\n```\n(dotted_name\n  (identifier) @prev-id\n  .\n  (identifier) @next-id)\n```\n\n----------------------------------------\n\nTITLE: Memory Allocation Example\nDESCRIPTION: Demonstrates proper memory allocation using Tree-sitter's allocation helpers instead of standard libc functions.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/docs/src/creating-parsers/4-external-scanners.md#2025-04-21_snippet_7\n\nLANGUAGE: c\nCODE:\n```\n#include \"tree_sitter/parser.h\"\n#include \"tree_sitter/alloc.h\"\n\n// ...\n\nvoid* tree_sitter_my_language_external_scanner_create() {\n  return ts_calloc(100, 1); // or ts_malloc(100)\n}\n\n// ...\n\n```\n\n----------------------------------------\n\nTITLE: ERB Template Example\nDESCRIPTION: Example of an ERB (Embedded Ruby) template showing mixed HTML and Ruby code that demonstrates the need for multi-language parsing.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/docs/src/using-parsers/3-advanced-parsing.md#2025-04-21_snippet_2\n\nLANGUAGE: erb\nCODE:\n```\n<ul>\n  <% people.each do |person| %>\n    <li><%= person.name %></li>\n  <% end %>\n</ul>\n```\n\n----------------------------------------\n\nTITLE: Formatting a Basic Tree-sitter Test in Text Files\nDESCRIPTION: Demonstrates the standard format for Tree-sitter test files, showing how to structure a test with a name, input source code, and expected syntax tree output as an S-expression.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/docs/src/creating-parsers/5-writing-tests.md#2025-04-21_snippet_0\n\nLANGUAGE: text\nCODE:\n```\n==================\nReturn statements\n==================\n\nfunc x() int {\n  return 1;\n}\n\n---\n\n(source_file\n  (function_definition\n    (identifier)\n    (parameter_list)\n    (primitive_type)\n    (block\n      (return_statement (number)))))\n```\n\n----------------------------------------\n\nTITLE: Initializing Tree-sitter Playground Module Import\nDESCRIPTION: Imports the Tree-sitter library from a CDN and initializes the playground with configuration. Sets up the global TreeSitter object and starts the playground initialization with a local=false parameter.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/docs/src/7-playground.md#2025-04-21_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport * as TreeSitter from 'https://tree-sitter.github.io/web-tree-sitter.js';\nwindow.TreeSitter = TreeSitter;\nsetTimeout(() => window.initializePlayground({local: false}), 1);\n```\n\n----------------------------------------\n\nTITLE: Field Names in Function Definition\nDESCRIPTION: Example of using named fields to provide semantic labels for parts of a syntax node.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/docs/src/creating-parsers/3-writing-the-grammar.md#2025-04-21_snippet_7\n\nLANGUAGE: javascript\nCODE:\n```\nfunction_definition: $ =>\n  seq(\n    \"func\",\n    field(\"name\", $.identifier),\n    field(\"parameters\", $.parameter_list),\n    field(\"return_type\", $._type),\n    field(\"body\", $.block),\n  );\n```\n\n----------------------------------------\n\nTITLE: Creating a Tree-sitter Highlighter Instance\nDESCRIPTION: This snippet demonstrates how to import and create a new Highlighter instance. A separate highlighter is needed for each thread used for syntax highlighting.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/highlight/README.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse tree_sitter_highlight::Highlighter;\n\nlet mut highlighter = Highlighter::new();\n```\n\n----------------------------------------\n\nTITLE: Scanner Creation Function\nDESCRIPTION: Implementation of the scanner creation function that initializes the scanner state. Called once when the language is set on a parser.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/docs/src/creating-parsers/4-external-scanners.md#2025-04-21_snippet_2\n\nLANGUAGE: c\nCODE:\n```\nvoid * tree_sitter_my_language_external_scanner_create() {\n  // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Running Tree-sitter Playground Command in Bash\nDESCRIPTION: Command to start the local Tree-sitter playground for interactive parser testing. The playground allows developers to test their parsers in a web interface.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/docs/src/cli/playground.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ntree-sitter playground [OPTIONS] # Aliases: play, pg, web-ui\n```\n\n----------------------------------------\n\nTITLE: Grouping Sibling Nodes in Tree-sitter Queries\nDESCRIPTION: Pattern that uses parentheses to group and match a comment followed by a function declaration.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/docs/src/using-parsers/queries/2-operators.md#2025-04-21_snippet_5\n\nLANGUAGE: query\nCODE:\n```\n(\n  (comment)\n  (function_declaration)\n)\n```\n\n----------------------------------------\n\nTITLE: Retrieving Current Node and Field Information in C for Tree-sitter\nDESCRIPTION: These functions retrieve information about the current node and field at the cursor's position in Tree-sitter. They return the current node, field name, and field ID respectively.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/docs/src/using-parsers/4-walking-trees.md#2025-04-21_snippet_2\n\nLANGUAGE: c\nCODE:\n```\nTSNode ts_tree_cursor_current_node(const TSTreeCursor *);\nconst char *ts_tree_cursor_current_field_name(const TSTreeCursor *);\nTSFieldId ts_tree_cursor_current_field_id(const TSTreeCursor *);\n```\n\n----------------------------------------\n\nTITLE: Parsing Multi-line Source Code with Tree-sitter in Rust\nDESCRIPTION: Demonstrates how to parse multi-line source code using a custom callback function. This method allows for efficient parsing of large files or streaming input.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/lib/binding_rust/README.md#2025-04-21_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\nlet lines = &[\n    \"pub fn foo() {\",\n    \"  1\",\n    \"}\",\n];\n\nlet tree = parser.parse_with(&mut |_byte: usize, position: Point| -> &[u8] {\n    let row = position.row as usize;\n    let column = position.column as usize;\n    if row < lines.len() {\n        if column < lines[row].as_bytes().len() {\n            &lines[row].as_bytes()[column..]\n        } else {\n            b\"\\n\"\n        }\n    } else {\n        &[]\n    }\n}, None).unwrap();\n\nassert_eq!(\n  tree.root_node().to_sexp(),\n  \"(source_file (function_item (visibility_modifier) (identifier) (parameters) (block (number_literal))))\"\n);\n```\n\n----------------------------------------\n\nTITLE: Precedence Configuration for Unary Expressions\nDESCRIPTION: Shows how to configure precedence for unary expressions to resolve operator ambiguity.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/docs/src/creating-parsers/3-writing-the-grammar.md#2025-04-21_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\n{\n  unary_expression: $ =>\n    prec(\n      2,\n      choice(\n        seq(\"-\", $._expression),\n        seq(\"!\", $._expression),\n        // ...\n      ),\n    );\n}\n```\n\n----------------------------------------\n\nTITLE: Using Test Attributes in Tree-sitter Tests\nDESCRIPTION: Demonstrates how to use test attributes to control test behavior, including skipping tests, expecting errors, failing fast, specifying language, and targeting specific platforms.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/docs/src/creating-parsers/5-writing-tests.md#2025-04-21_snippet_4\n\nLANGUAGE: text\nCODE:\n```\n=========================\nTest that will be skipped\n:skip\n=========================\n\nint main() {}\n\n-------------------------\n\n====================================\nTest that will run on Linux or macOS\n\n:platform(linux)\n:platform(macos)\n====================================\n\nint main() {}\n\n------------------------------------\n\n========================================================================\nTest that expects an error, and will fail fast if there's no parse error\n:fail-fast\n:error\n========================================================================\n\nint main ( {}\n\n------------------------------------------------------------------------\n\n=================================================\nTest that will parse with both Typescript and TSX\n:language(typescript)\n:language(tsx)\n=================================================\n\nconsole.log('Hello, world!');\n\n-------------------------------------------------\n```\n\n----------------------------------------\n\nTITLE: Using RustRegex in Tree-sitter Grammar\nDESCRIPTION: Demonstrates how to use the RustRegex class to define pattern matching in Tree-sitter grammars. This allows you to use Rust's regex syntax, which supports features like case-insensitive matching with inline flags.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/docs/src/creating-parsers/2-the-grammar-dsl.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nnew RustRegex('(?i)[a-z_][a-z0-9_]*') // matches a simple identifier\n```\n\n----------------------------------------\n\nTITLE: Matching Optional Nodes with '?' Operator\nDESCRIPTION: Pattern that matches function calls and conditionally captures a string argument if one exists using the '?' optional operator.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/docs/src/using-parsers/queries/2-operators.md#2025-04-21_snippet_4\n\nLANGUAGE: query\nCODE:\n```\n(call_expression\n  function: (identifier) @the-function\n  arguments: (arguments (string)? @the-string-arg))\n```\n\n----------------------------------------\n\nTITLE: Compiling Tree-sitter JSON Parser with Static Linking\nDESCRIPTION: Shell command to compile the JSON parser example using static linking. It includes the Tree-sitter library, the JSON grammar parser, and the necessary include paths.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/docs/src/using-parsers/1-getting-started.md#2025-04-21_snippet_3\n\nLANGUAGE: sh\nCODE:\n```\nclang                                   \\\n  -I tree-sitter/lib/include            \\\n  test-json-parser.c                    \\\n  tree-sitter-json/src/parser.c         \\\n  tree-sitter/libtree-sitter.a          \\\n  -o test-json-parser\n./test-json-parser\n```\n\n----------------------------------------\n\nTITLE: Parsing JavaScript with WASM Grammar in Tree-sitter\nDESCRIPTION: Shows how to parse JavaScript code using a WASM-based grammar in Tree-sitter. This example demonstrates the actual parsing process after setting up the WASM environment.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/lib/binding_rust/README.md#2025-04-21_snippet_9\n\nLANGUAGE: rust\nCODE:\n```\nlet source_code = \"let x = 1;\";\nlet tree = parser.parse(source_code, None).unwrap();\n\nassert_eq!(\n    tree.root_node().to_sexp(),\n    \"(program (lexical_declaration (variable_declarator name: (identifier) value: (number))))\"\n);\n```\n\n----------------------------------------\n\nTITLE: Setting Language for Tree-sitter Parser in Rust\nDESCRIPTION: Configures the Tree-sitter parser to use a specific language grammar (Rust in this example). This step is necessary before parsing source code.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/lib/binding_rust/README.md#2025-04-21_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nparser.set_language(&tree_sitter_rust::LANGUAGE.into()).expect(\"Error loading Rust grammar\");\n```\n\n----------------------------------------\n\nTITLE: Basic Node Type Information in node-types.json\nDESCRIPTION: Examples showing the basic structure of node type entries in node-types.json. Each entry includes a 'type' string representing the grammar rule and a 'named' boolean indicating whether the node corresponds to a rule name or a string literal.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/docs/src/using-parsers/6-static-node-types.md#2025-04-21_snippet_0\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"type\": \"string_literal\",\n  \"named\": true\n}\n{\n  \"type\": \"+\",\n  \"named\": false\n}\n```\n\n----------------------------------------\n\nTITLE: Matching Specific Identifier with eq? Predicate in C\nDESCRIPTION: A Tree-sitter pattern that uses the #eq? predicate to match any identifier with the text 'self', capturing it as a builtin variable.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/docs/src/using-parsers/queries/3-predicates-and-directives.md#2025-04-21_snippet_0\n\nLANGUAGE: query\nCODE:\n```\n((identifier) @variable.builtin\n  (#eq? @variable.builtin \"self\"))\n```\n\n----------------------------------------\n\nTITLE: Matching MISSING Nodes in Tree-sitter Queries\nDESCRIPTION: Shows how to query MISSING nodes that the parser inserted during error recovery. These patterns help detect syntax errors that aren't captured by ERROR node queries.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/docs/src/using-parsers/queries/1-syntax.md#2025-04-21_snippet_7\n\nLANGUAGE: query\nCODE:\n```\n(MISSING) @missing-node\n```\n\n----------------------------------------\n\nTITLE: Configuring Webpack for Web Tree-sitter\nDESCRIPTION: This snippet shows how to configure Webpack to resolve the 'fs' module when bundling Web Tree-sitter for browser use.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/lib/binding_web/README.md#2025-04-21_snippet_13\n\nLANGUAGE: javascript\nCODE:\n```\n{\n  resolve: {\n    fallback: {\n      fs: false\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Generating and Printing Code Navigation Tags in Rust\nDESCRIPTION: This code demonstrates how to compute code navigation tags for a JavaScript code snippet using the previously created context and configuration. It then iterates through the generated tags and prints their properties.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/tags/README.md#2025-04-21_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nlet tags = context.generate_tags(\n    &javascript_config,\n    b\"class A { getB() { return c(); } }\",\n    None,\n);\n\nfor tag in tags {\n    println!(\"kind: {:?}\", tag.kind);\n    println!(\"range: {:?}\", tag.range);\n    println!(\"name_range: {:?}\", tag.name_range);\n    println!(\"docs: {:?}\", tag.docs);\n}\n```\n\n----------------------------------------\n\nTITLE: Capturing Optional Repeated Nodes\nDESCRIPTION: Pattern that matches a class declaration and captures all decorator nodes if present using the '*' repetition operator.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/docs/src/using-parsers/queries/2-operators.md#2025-04-21_snippet_3\n\nLANGUAGE: query\nCODE:\n```\n(class_declaration\n  (decorator)* @the-decorator\n  name: (identifier) @the-name)\n```\n\n----------------------------------------\n\nTITLE: Query Error Types Enumeration - C API\nDESCRIPTION: Enumeration defining possible error types that can occur during query operations. Includes syntax errors, node type errors, field errors, and capture errors.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/docs/src/using-parsers/queries/4-api.md#2025-04-21_snippet_1\n\nLANGUAGE: c\nCODE:\n```\ntypedef enum {\n  TSQueryErrorNone = 0,\n  TSQueryErrorSyntax,\n  TSQueryErrorNodeType,\n  TSQueryErrorField,\n  TSQueryErrorCapture,\n} TSQueryError;\n```\n\n----------------------------------------\n\nTITLE: Importing Web Tree-sitter in Deno\nDESCRIPTION: This snippet demonstrates how to import and initialize Web Tree-sitter in a Deno environment.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/lib/binding_web/README.md#2025-04-21_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\nimport Parser from \"npm:web-tree-sitter\";\nawait Parser.init();\n// the library is ready\n```\n\n----------------------------------------\n\nTITLE: Basic Go Function Example\nDESCRIPTION: Sample Go code demonstrating function declaration with parameters for syntax highlighting purposes\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/docs/src/3-syntax-highlighting.md#2025-04-21_snippet_0\n\nLANGUAGE: go\nCODE:\n```\nfunc increment(a int) int {\n    return a + 1\n}\n```\n\n----------------------------------------\n\nTITLE: Token Scanning Function\nDESCRIPTION: Main scanning function that processes input stream and recognizes tokens. Returns true when a token is successfully recognized.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/docs/src/creating-parsers/4-external-scanners.md#2025-04-21_snippet_6\n\nLANGUAGE: c\nCODE:\n```\nbool tree_sitter_my_language_external_scanner_scan(\n  void *payload,\n  TSLexer *lexer,\n  const bool *valid_symbols\n) {\n  // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Supertype Node Definition in node-types.json\nDESCRIPTION: Example of a supertype node that represents an abstract category of syntax nodes. The 'subtypes' array lists all the specific node types that this supertype can represent, allowing for more concise type definitions.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/docs/src/using-parsers/6-static-node-types.md#2025-04-21_snippet_3\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"type\": \"_declaration\",\n  \"named\": true,\n  \"subtypes\": [\n    { \"type\": \"class_declaration\", \"named\": true },\n    { \"type\": \"function_declaration\", \"named\": true },\n    { \"type\": \"generator_function_declaration\", \"named\": true },\n    { \"type\": \"lexical_declaration\", \"named\": true },\n    { \"type\": \"variable_declaration\", \"named\": true }\n  ]\n}\n```\n\n----------------------------------------\n\nTITLE: Matching Multiple Keywords with Alternation\nDESCRIPTION: Pattern that uses alternation to match a set of JavaScript keywords and captures them as '@keyword'.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/docs/src/using-parsers/queries/2-operators.md#2025-04-21_snippet_8\n\nLANGUAGE: query\nCODE:\n```\n[\n  \"break\"\n  \"delete\"\n  \"else\"\n  \"for\"\n  \"function\"\n  \"if\"\n  \"return\"\n  \"try\"\n  \"while\"\n] @keyword\n```\n\n----------------------------------------\n\nTITLE: Configuring Syntax Highlighting Theme\nDESCRIPTION: Example JSON theme configuration for syntax highlighting, including various styling options for different code elements.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/docs/src/cli/init-config.md#2025-04-21_snippet_2\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"function\": 26,\n  \"operator\": {\n    \"bold\": true,\n    \"color\": 239\n  },\n  \"variable.builtin\": {\n    \"bold\": true\n  },\n  \"variable.parameter\": {\n    \"underline\": true\n  },\n  \"type.builtin\": {\n    \"color\": 23,\n    \"bold\": true\n  },\n  \"keyword\": 56,\n  \"type\": 23,\n  \"number\": {\n    \"bold\": true,\n    \"color\": 94\n  },\n  \"constant\": 94,\n  \"attribute\": {\n    \"color\": 124,\n    \"italic\": true\n  },\n  \"comment\": {\n    \"color\": 245,\n    \"italic\": true\n  },\n  \"constant.builtin\": {\n    \"color\": 94,\n    \"bold\": true\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Syntax Highlighting Query Pattern\nDESCRIPTION: Tree-sitter query pattern for assigning highlight names to syntax elements\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/docs/src/3-syntax-highlighting.md#2025-04-21_snippet_2\n\nLANGUAGE: scheme\nCODE:\n```\n; highlights.scm\n\n\"func\" @keyword\n\"return\" @keyword\n(type_identifier) @type\n(int_literal) @number\n(function_declaration name: (identifier) @function)\n```\n\n----------------------------------------\n\nTITLE: Binary Expression Associativity Configuration\nDESCRIPTION: Demonstrates configuring left associativity for binary operators with different precedence levels.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/docs/src/creating-parsers/3-writing-the-grammar.md#2025-04-21_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\n{\n  binary_expression: $ => choice(\n    prec.left(2, seq($._expression, '*', $._expression)),\n    prec.left(1, seq($._expression, '+', $._expression)),\n    // ...\n  ),\n}\n```\n\n----------------------------------------\n\nTITLE: Loading WASM Language Grammar for Tree-sitter in Rust\nDESCRIPTION: Demonstrates how to load a language grammar from a WASM file and set it for the parser. This allows using Tree-sitter with WebAssembly-based language definitions.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/lib/binding_rust/README.md#2025-04-21_snippet_8\n\nLANGUAGE: rust\nCODE:\n```\nconst JAVASCRIPT_GRAMMAR: &[u8] = include_bytes!(\"path/to/tree-sitter-javascript.wasm\");\n\nlet mut store = WasmStore::new(&engine).unwrap();\nlet javascript = store\n    .load_language(\"javascript\", JAVASCRIPT_GRAMMAR)\n    .unwrap();\n\nparser.set_language(&javascript).unwrap();\n```\n\n----------------------------------------\n\nTITLE: Initializing Tree Cursor in C for Tree-sitter\nDESCRIPTION: This function initializes a new tree cursor from a given node in Tree-sitter. It allows efficient traversal of the syntax tree starting from the specified node.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/docs/src/using-parsers/4-walking-trees.md#2025-04-21_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nTSTreeCursor ts_tree_cursor_new(TSNode);\n```\n\n----------------------------------------\n\nTITLE: Configuring Highlight Names for a Language\nDESCRIPTION: This snippet shows how to configure the highlight configuration with the previously defined highlight names. This step tells the highlighter which highlight types to recognize.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/highlight/README.md#2025-04-21_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\njavascript_config.configure(&highlight_names);\n```\n\n----------------------------------------\n\nTITLE: Defining External Token Types\nDESCRIPTION: Shows how to define an enum for external token types in C. The order must match the externals array in the grammar definition.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/docs/src/creating-parsers/4-external-scanners.md#2025-04-21_snippet_1\n\nLANGUAGE: c\nCODE:\n```\n#include \"tree_sitter/parser.h\"\n#include \"tree_sitter/alloc.h\"\n#include \"tree_sitter/array.h\"\n\nenum TokenType {\n  INDENT,\n  DEDENT,\n  NEWLINE\n}\n```\n\n----------------------------------------\n\nTITLE: Identifying Documentation Comments with match? Predicate\nDESCRIPTION: A Tree-sitter pattern using the #match? predicate to identify documentation comments in C that begin with three forward slashes (///).\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/docs/src/using-parsers/queries/3-predicates-and-directives.md#2025-04-21_snippet_4\n\nLANGUAGE: query\nCODE:\n```\n((comment)+ @comment.documentation\n  (#match? @comment.documentation \"^///\\\\s+.*\"))\n```\n\n----------------------------------------\n\nTITLE: Initializing Tree-sitter Project in CMake\nDESCRIPTION: Sets up the Tree-sitter project with version, description, and language settings. It also defines build options for shared libraries, WASM feature, and amalgamated source.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/lib/CMakeLists.txt#2025-04-21_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ncmake_minimum_required(VERSION 3.13)\n\nproject(tree-sitter\n        VERSION \"0.26.0\"\n        DESCRIPTION \"An incremental parsing system for programming tools\"\n        HOMEPAGE_URL \"https://tree-sitter.github.io/tree-sitter/\"\n        LANGUAGES C)\n\noption(BUILD_SHARED_LIBS \"Build using shared libraries\" ON)\noption(TREE_SITTER_FEATURE_WASM \"Enable the Wasm feature\" OFF)\noption(AMALGAMATED \"Build using an amalgamated source\" OFF)\n```\n\n----------------------------------------\n\nTITLE: Parsing Custom Data Structures with Web Tree-sitter\nDESCRIPTION: This snippet demonstrates how to parse text stored in a custom data structure (an array of lines) by providing a callback to the parse method.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/lib/binding_web/README.md#2025-04-21_snippet_8\n\nLANGUAGE: javascript\nCODE:\n```\nconst sourceLines = [\n  'let x = 1;',\n  'console.log(x);'\n];\n\nconst tree = parser.parse((index, position) => {\n  let line = sourceLines[position.row];\n  if (line) return line.slice(position.column);\n});\n```\n\n----------------------------------------\n\nTITLE: External Keywords Configuration in JavaScript\nDESCRIPTION: Example showing two approaches to configure external keyword handling in the grammar - direct keyword strings and named token aliases.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/docs/src/creating-parsers/4-external-scanners.md#2025-04-21_snippet_11\n\nLANGUAGE: javascript\nCODE:\n```\nexternals: $ => ['if', 'then', 'else']\n```\n\nLANGUAGE: javascript\nCODE:\n```\n{\n  name: \"my_language\",\n\n  externals: $ => [$.if_keyword, $.then_keyword, $.else_keyword],\n\n  rules: {\n\n    // then using it in a rule like so:\n    if_statement: $ => seq(alias($.if_keyword, 'if'), ...),\n\n    // ...\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring External Tokens in Grammar\nDESCRIPTION: Demonstrates how to declare external tokens in a Tree-sitter grammar configuration. These tokens can then be referenced elsewhere in the grammar rules.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/docs/src/creating-parsers/4-external-scanners.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\ngrammar({\n  name: \"my_language\",\n\n  externals: $ => [$.indent, $.dedent, $.newline],\n\n  // ...\n});\n```\n\n----------------------------------------\n\nTITLE: Using Tree-sitter Version Command in Bash\nDESCRIPTION: The command updates the version of a Tree-sitter grammar across multiple configuration files. It accepts a version parameter and has 'publish' as an alias. This helps maintain consistent version information across different language bindings.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/docs/src/cli/version.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ntree-sitter version <VERSION> # Aliases: publish\n```\n\n----------------------------------------\n\nTITLE: Configuring Tree-sitter Source Files in CMake\nDESCRIPTION: Determines the source files to be used based on the AMALGAMATED option. If AMALGAMATED is ON, it uses a single source file; otherwise, it glob matches all .c files in the src directory.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/lib/CMakeLists.txt#2025-04-21_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\nif(AMALGAMATED)\n  set(TS_SOURCE_FILES \"${PROJECT_SOURCE_DIR}/src/lib.c\")\nelse()\n  file(GLOB TS_SOURCE_FILES src/*.c)\n  list(REMOVE_ITEM TS_SOURCE_FILES \"${PROJECT_SOURCE_DIR}/src/lib.c\")\nendif()\n\nadd_library(tree-sitter ${TS_SOURCE_FILES})\n\ntarget_include_directories(tree-sitter PRIVATE src src/wasm include)\n```\n\n----------------------------------------\n\nTITLE: Moving Tree Cursor in C for Tree-sitter\nDESCRIPTION: These functions allow movement of the tree cursor to the first child, next sibling, or parent node in Tree-sitter. They return a boolean indicating success or failure of the movement operation.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/docs/src/using-parsers/4-walking-trees.md#2025-04-21_snippet_1\n\nLANGUAGE: c\nCODE:\n```\nbool ts_tree_cursor_goto_first_child(TSTreeCursor *);\nbool ts_tree_cursor_goto_next_sibling(TSTreeCursor *);\nbool ts_tree_cursor_goto_parent(TSTreeCursor *);\n```\n\n----------------------------------------\n\nTITLE: Loading Syntax Highlighting Configuration for JavaScript\nDESCRIPTION: This code shows how to create a HighlightConfiguration for JavaScript by loading the language and its query files. The configuration requires the language definition and three query files: highlights, injections, and locals.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/highlight/README.md#2025-04-21_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nuse tree_sitter_highlight::HighlightConfiguration;\n\nlet javascript_language = tree_sitter_javascript::language();\n\nlet mut javascript_config = HighlightConfiguration::new(\n    javascript_language,\n    \"javascript\",\n    tree_sitter_javascript::HIGHLIGHT_QUERY,\n    tree_sitter_javascript::INJECTIONS_QUERY,\n    tree_sitter_javascript::LOCALS_QUERY,\n).unwrap();\n```\n\n----------------------------------------\n\nTITLE: Using Repetition Operators in Tree-sitter Queries\nDESCRIPTION: Pattern using the '+' operator to match one or more consecutive comment nodes.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/docs/src/using-parsers/queries/2-operators.md#2025-04-21_snippet_2\n\nLANGUAGE: query\nCODE:\n```\n(comment)+\n```\n\n----------------------------------------\n\nTITLE: Theme Configuration JSON\nDESCRIPTION: JSON configuration mapping highlight names to specific colors\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/docs/src/3-syntax-highlighting.md#2025-04-21_snippet_3\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"theme\": {\n    \"keyword\": \"purple\",\n    \"function\": \"blue\",\n    \"type\": \"green\",\n    \"number\": \"brown\"\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Running WASM in Node.js with Web Tree-sitter\nDESCRIPTION: This snippet shows how to use Web Tree-sitter with a .wasm file in a Node.js environment, which can be useful for testing purposes.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/lib/binding_web/README.md#2025-04-21_snippet_11\n\nLANGUAGE: javascript\nCODE:\n```\nconst Parser = require('web-tree-sitter');\n\n(async () => {\n  await Parser.init();\n  const parser = new Parser();\n  const Lang = await Parser.Language.load('tree-sitter-javascript.wasm');\n  parser.setLanguage(Lang);\n  const tree = parser.parse('let x = 1;');\n  console.log(tree.rootNode.toString());\n})();\n```\n\n----------------------------------------\n\nTITLE: Error Recovery Scanner Configuration in JavaScript\nDESCRIPTION: Configuration example showing how to set up external scanner tokens in the grammar definition, including error sentinel tokens for recovery handling.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/docs/src/creating-parsers/4-external-scanners.md#2025-04-21_snippet_9\n\nLANGUAGE: javascript\nCODE:\n```\n{\n  name: \"my_language\",\n\n  externals: $ => [$.token1, $.token2, $.error_sentinel]\n\n  // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing Tree-sitter Configuration\nDESCRIPTION: Command to initialize a new Tree-sitter CLI configuration file in the default platform-specific location.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/docs/src/cli/init-config.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ntree-sitter init-config\n```\n\n----------------------------------------\n\nTITLE: Setting Compiler Options for Tree-sitter in CMake\nDESCRIPTION: Configures compiler-specific options for MSVC and other compilers. It disables certain warnings and enables strict error checking for incompatible types.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/lib/CMakeLists.txt#2025-04-21_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\nif(MSVC)\n  target_compile_options(tree-sitter PRIVATE\n                         /wd4018 # disable 'signed/unsigned mismatch'\n                         /wd4232 # disable 'nonstandard extension used'\n                         /wd4244 # disable 'possible loss of data'\n                         /wd4267 # disable 'possible loss of data (size_t)'\n                         /wd4701 # disable 'potentially uninitialized local variable'\n                         /we4022 # treat 'incompatible types' as an error\n                         /W4)\nelse()\n  target_compile_options(tree-sitter PRIVATE\n                         -Wall -Wextra -Wshadow -Wpedantic\n                         -Werror=incompatible-pointer-types)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Unit Testing Ruby Tags with Tree-sitter\nDESCRIPTION: Sample Ruby code with Tree-sitter test annotations for verifying tag queries. The comments with caret (^) symbols indicate the expected position and type of each definition that should be captured by the tags query.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/docs/src/4-code-navigation.md#2025-04-21_snippet_4\n\nLANGUAGE: ruby\nCODE:\n```\nmodule Foo\n  #     ^ definition.module\n  class Bar\n    #    ^ definition.class\n\n    def baz\n      #  ^ definition.method\n    end\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Running Tree-sitter Fuzz Command\nDESCRIPTION: Basic command syntax for running the tree-sitter fuzzer. The fuzz command performs random edits on parsers and validates that undoing these edits results in consistent parse trees.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/docs/src/cli/fuzz.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ntree-sitter fuzz [OPTIONS] # Aliases: f\n```\n\n----------------------------------------\n\nTITLE: Creating Query Cursor - C API\nDESCRIPTION: Function to create a new query cursor for executing queries. Returns a TSQueryCursor pointer that maintains query execution state. Cursor is not thread-safe but can be reused.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/docs/src/using-parsers/queries/4-api.md#2025-04-21_snippet_2\n\nLANGUAGE: c\nCODE:\n```\nTSQueryCursor *ts_query_cursor_new(void);\n```\n\n----------------------------------------\n\nTITLE: Field-Based Node Access\nDESCRIPTION: Functions for accessing child nodes using field names and IDs, including field name/ID conversion utilities.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/docs/src/using-parsers/2-basic-parsing.md#2025-04-21_snippet_10\n\nLANGUAGE: c\nCODE:\n```\nTSNode ts_node_child_by_field_name(\n  TSNode self,\n  const char *field_name,\n  uint32_t field_name_length\n);\n\nuint32_t ts_language_field_count(const TSLanguage *);\nconst char *ts_language_field_name_for_id(const TSLanguage *, TSFieldId);\nTSFieldId ts_language_field_id_for_name(const TSLanguage *, const char *, uint32_t);\n\nTSNode ts_node_child_by_field_id(TSNode, TSFieldId);\n```\n\n----------------------------------------\n\nTITLE: Highlighting Query for Ruby Code\nDESCRIPTION: A scheme query for syntax highlighting Ruby code, distinguishing between method calls, method definitions, and formal parameters. The query uses patterns to differentiate between local variables and methods.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/docs/src/3-syntax-highlighting.md#2025-04-21_snippet_6\n\nLANGUAGE: scheme\nCODE:\n```\n; highlights.scm\n\n(call method: (identifier) @function.method)\n(method_call method: (identifier) @function.method)\n\n(method name: (identifier) @function.method)\n\n(method_parameters (identifier) @variable.parameter)\n(block_parameters (identifier) @variable.parameter)\n\n((identifier) @function.method\n (#is-not? local))\n```\n\n----------------------------------------\n\nTITLE: Configuring WASM Support for Tree-sitter in CMake\nDESCRIPTION: Sets up WASM support if TREE_SITTER_FEATURE_WASM is enabled. It finds the required wasmtime headers and library, and configures the necessary compiler definitions and link libraries.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/lib/CMakeLists.txt#2025-04-21_snippet_3\n\nLANGUAGE: CMake\nCODE:\n```\nif(TREE_SITTER_FEATURE_WASM)\n  if(NOT DEFINED CACHE{WASMTIME_INCLUDE_DIR})\n    message(CHECK_START \"Looking for wasmtime headers\")\n    find_path(WASMTIME_INCLUDE_DIR wasmtime.h\n              PATHS ENV DEP_WASMTIME_C_API_INCLUDE)\n    if(NOT WASMTIME_INCLUDE_DIR)\n      unset(WASMTIME_INCLUDE_DIR CACHE)\n      message(FATAL_ERROR \"Could not find wasmtime headers.\\nDid you forget to set CMAKE_INCLUDE_PATH?\")\n    endif()\n    message(CHECK_PASS \"found\")\n  endif()\n\n  if(NOT DEFINED CACHE{WASMTIME_LIBRARY})\n    message(CHECK_START \"Looking for wasmtime library\")\n    find_library(WASMTIME_LIBRARY wasmtime)\n    if(NOT WASMTIME_LIBRARY)\n      unset(WASMTIME_LIBRARY CACHE)\n      message(FATAL_ERROR \"Could not find wasmtime library.\\nDid you forget to set CMAKE_LIBRARY_PATH?\")\n    endif()\n    message(CHECK_PASS \"found\")\n  endif()\n\n  target_compile_definitions(tree-sitter PUBLIC TREE_SITTER_FEATURE_WASM)\n  target_include_directories(tree-sitter SYSTEM PRIVATE \"${WASMTIME_INCLUDE_DIR}\")\n  target_link_libraries(tree-sitter PUBLIC \"${WASMTIME_LIBRARY}\")\n  set_property(TARGET tree-sitter PROPERTY C_STANDARD_REQUIRED ON)\n\n  if(NOT BUILD_SHARED_LIBS)\n    if(WIN32)\n      target_compile_definitions(tree-sitter PRIVATE WASM_API_EXTERN= WASI_API_EXTERN=)\n      target_link_libraries(tree-sitter INTERFACE ws2_32 advapi32 userenv ntdll shell32 ole32 bcrypt)\n    elseif(NOT APPLE)\n      target_link_libraries(tree-sitter INTERFACE pthread dl m)\n    endif()\n  endif()\nendif()\n```\n\n----------------------------------------\n\nTITLE: Executing Query - C API\nDESCRIPTION: Function to execute a query on a syntax node using a query cursor. Takes a cursor, query, and target node as parameters.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/docs/src/using-parsers/queries/4-api.md#2025-04-21_snippet_3\n\nLANGUAGE: c\nCODE:\n```\nvoid ts_query_cursor_exec(TSQueryCursor *, const TSQuery *, TSNode);\n```\n\n----------------------------------------\n\nTITLE: Generating Tree-sitter Parser\nDESCRIPTION: Shell command to generate the C code for the Tree-sitter parser based on the grammar defined in grammar.js.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/docs/src/creating-parsers/1-getting-started.md#2025-04-21_snippet_3\n\nLANGUAGE: sh\nCODE:\n```\ntree-sitter generate\n```\n\n----------------------------------------\n\nTITLE: Language Injection Query with Forced Language\nDESCRIPTION: A scheme query that forces a specific language (Ruby) for injected content using the #set! predicate, regardless of any language indicators in the source code.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/docs/src/3-syntax-highlighting.md#2025-04-21_snippet_11\n\nLANGUAGE: scheme\nCODE:\n```\n((heredoc_body) @injection.content\n (#set! injection.language \"ruby\"))\n```\n\n----------------------------------------\n\nTITLE: Matching Key-Value Pairs with Identical Names using eq? Predicate\nDESCRIPTION: A Tree-sitter pattern that matches key-value pairs where the key and value have identical text, using the #eq? predicate to compare two captured nodes.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/docs/src/using-parsers/queries/3-predicates-and-directives.md#2025-04-21_snippet_1\n\nLANGUAGE: query\nCODE:\n```\n(\n  (pair\n    key: (property_identifier) @key-name\n    value: (identifier) @value-name)\n  (#eq? @key-name @value-name)\n)\n```\n\n----------------------------------------\n\nTITLE: If Statement Grammar Example\nDESCRIPTION: Example grammar rule showing the structure of an if statement with named and anonymous nodes.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/docs/src/using-parsers/2-basic-parsing.md#2025-04-21_snippet_8\n\nLANGUAGE: js\nCODE:\n```\nif_statement: $ => seq(\"if\", \"(\", $._expression, \")\", $._statement);\n```\n\n----------------------------------------\n\nTITLE: Sample Ruby Code for Testing Tags Functionality\nDESCRIPTION: Example Ruby code snippet demonstrating module, class, and method definitions with comments that illustrates how docstrings are captured in the tagging process. The example shows which comments will be included based on adjacency.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/docs/src/4-code-navigation.md#2025-04-21_snippet_3\n\nLANGUAGE: ruby\nCODE:\n```\nmodule Foo\n  class Bar\n    # won't be included\n\n    # is adjacent, will be\n    def baz\n    end\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Setting Tree-sitter Target Properties in CMake\nDESCRIPTION: Configures various properties for the tree-sitter target, including C standard, visibility, position-independent code, and version information. It also sets compile definitions for POSIX compatibility.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/lib/CMakeLists.txt#2025-04-21_snippet_4\n\nLANGUAGE: CMake\nCODE:\n```\nset_target_properties(tree-sitter\n                      PROPERTIES\n                      C_STANDARD 11\n                      C_VISIBILITY_PRESET hidden\n                      POSITION_INDEPENDENT_CODE ON\n                      SOVERSION \"${PROJECT_VERSION_MAJOR}.${PROJECT_VERSION_MINOR}\"\n                      DEFINE_SYMBOL \"\")\n\ntarget_compile_definitions(tree-sitter PRIVATE _POSIX_C_SOURCE=200112L _DEFAULT_SOURCE)\n```\n\n----------------------------------------\n\nTITLE: Named Node Check and Navigation\nDESCRIPTION: Functions for working with named nodes, including existence checking and traversal operations.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/docs/src/using-parsers/2-basic-parsing.md#2025-04-21_snippet_9\n\nLANGUAGE: c\nCODE:\n```\nbool ts_node_is_named(TSNode);\n\nTSNode ts_node_named_child(TSNode, uint32_t);\nuint32_t ts_node_named_child_count(TSNode);\nTSNode ts_node_next_named_sibling(TSNode);\nTSNode ts_node_prev_named_sibling(TSNode);\n```\n\n----------------------------------------\n\nTITLE: Matching JavaScript Built-in Variables with any-of? Predicate\nDESCRIPTION: A Tree-sitter pattern that uses the #any-of? predicate to match JavaScript built-in variables by comparing against a list of specific identifier names.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/docs/src/using-parsers/queries/3-predicates-and-directives.md#2025-04-21_snippet_6\n\nLANGUAGE: query\nCODE:\n```\n((identifier) @variable.builtin\n  (#any-of? @variable.builtin\n        \"arguments\"\n        \"module\"\n        \"console\"\n        \"window\"\n        \"document\"))\n```\n\n----------------------------------------\n\nTITLE: Scanner Destruction Function\nDESCRIPTION: Implementation of the scanner cleanup function that frees allocated memory. Called when the parser is deleted or language is changed.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/docs/src/creating-parsers/4-external-scanners.md#2025-04-21_snippet_3\n\nLANGUAGE: c\nCODE:\n```\nvoid tree_sitter_my_language_external_scanner_destroy(void *payload) {\n  // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Importing Web Tree-sitter in Node.js\nDESCRIPTION: This snippet shows how to import and initialize Web Tree-sitter in a Node.js environment using require.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/lib/binding_web/README.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nconst { Parser } = require('web-tree-sitter');\nParser.init().then(() => { /* the library is ready */ });\n```\n\n----------------------------------------\n\nTITLE: Building the WASM Library for Tree-sitter\nDESCRIPTION: Commands to build the WASM library for Tree-sitter, which is required for the playground to work offline. This uses either Emscripten, Docker, or Podman.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/docs/src/6-contributing.md#2025-04-21_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\ncd lib/binding_web\nnpm install # or your JS package manager of choice\nnpm run build\n```\n\n----------------------------------------\n\nTITLE: Creating Tree-sitter Parser Project Directory\nDESCRIPTION: Shell commands to create and navigate to a new directory for a Tree-sitter parser project. The directory name follows the convention of 'tree-sitter-' followed by the lowercase name of the language.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/docs/src/creating-parsers/1-getting-started.md#2025-04-21_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\nmkdir tree-sitter-${LOWER_PARSER_NAME}\ncd tree-sitter-${LOWER_PARSER_NAME}\n```\n\n----------------------------------------\n\nTITLE: Language Injection Example with Ruby Heredoc\nDESCRIPTION: A Ruby code example demonstrating a heredoc with bash content, which would be a candidate for language injection where the content within the heredoc should be parsed as bash code.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/docs/src/3-syntax-highlighting.md#2025-04-21_snippet_8\n\nLANGUAGE: ruby\nCODE:\n```\nsystem <<-BASH.strip!\n  abc --def | ghi > jkl\nBASH\n```\n\n----------------------------------------\n\nTITLE: Error Recovery Handler in C\nDESCRIPTION: Implementation of error recovery handling in an external scanner using a sentinel token approach.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/docs/src/creating-parsers/4-external-scanners.md#2025-04-21_snippet_10\n\nLANGUAGE: c\nCODE:\n```\nbool tree_sitter_my_language_external_scanner_scan(\n  void *payload,\n  TSLexer *lexer,\n  const bool *valid_symbols\n) {\n  if (valid_symbols[ERROR_SENTINEL]) {\n    return false;\n  }\n  // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Finding Empty Comments with any-eq? Predicate\nDESCRIPTION: A Tree-sitter pattern using the #any-eq? predicate with a quantified capture to match comments that are empty (only contain '//').\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/docs/src/using-parsers/queries/3-predicates-and-directives.md#2025-04-21_snippet_2\n\nLANGUAGE: query\nCODE:\n```\n((comment)+ @comment.empty\n  (#any-eq? @comment.empty \"//\"))\n```\n\n----------------------------------------\n\nTITLE: Matching Specific MISSING Node Types in Tree-sitter\nDESCRIPTION: Demonstrates how to query for specific types of MISSING nodes. This helps identify particular syntax elements that are missing in the code.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/docs/src/using-parsers/queries/1-syntax.md#2025-04-21_snippet_8\n\nLANGUAGE: query\nCODE:\n```\n(MISSING identifier) @missing-identifier\n(MISSING \";\") @missing-semicolon\n```\n\n----------------------------------------\n\nTITLE: Tree-Sitter AST Structure\nDESCRIPTION: The corresponding abstract syntax tree (AST) representation showing how Tree-sitter breaks down the expression into nested nodes maintaining operator precedence\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/test/fixtures/test_grammars/readme_grammar/corpus.txt#2025-04-21_snippet_1\n\nLANGUAGE: lisp\nCODE:\n```\n(expression (sum\n  (expression (variable))\n  (expression (product\n     (expression (variable))\n     (expression (variable))))))\n```\n\n----------------------------------------\n\nTITLE: Testing Tree-sitter WASM Binding\nDESCRIPTION: Commands to compile test parsers to WASM and run the WASM binding tests.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/docs/src/6-contributing.md#2025-04-21_snippet_8\n\nLANGUAGE: sh\nCODE:\n```\ncargo xtask generate-fixtures --wasm\ncargo xtask test-wasm\n```\n\n----------------------------------------\n\nTITLE: Using Custom Delimiters in Tree-sitter Tests\nDESCRIPTION: Demonstrates how to use custom delimiters for test sections when the default delimiters conflict with the language syntax being tested.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/docs/src/creating-parsers/5-writing-tests.md#2025-04-21_snippet_2\n\nLANGUAGE: text\nCODE:\n```\n==================|||\nBasic module\n==================|||\n\n---- MODULE Test ----\nincrement(n) == n + 1\n====\n\n---|||\n\n(source_file\n  (module (identifier)\n    (operator (identifier)\n      (parameter_list (identifier))\n      (plus (identifier_ref) (number)))))\n```\n\n----------------------------------------\n\nTITLE: Finding Cgo Comments with match? and eq? Predicates\nDESCRIPTION: A complex Tree-sitter pattern that identifies C code embedded in Go comments before a C import statement, using both #eq? and #match? predicates together.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/docs/src/using-parsers/queries/3-predicates-and-directives.md#2025-04-21_snippet_5\n\nLANGUAGE: query\nCODE:\n```\n((comment)+ @injection.content\n  .\n  (import_declaration\n    (import_spec path: (interpreted_string_literal) @_import_c))\n  (#eq? @_import_c \"\\\"C\\\"\")\n  (#match? @injection.content \"^//\"))\n```\n\n----------------------------------------\n\nTITLE: Running Tree-sitter Dump Languages Command in Bash\nDESCRIPTION: This command prints a list of all languages known to the Tree-sitter CLI. It uses the 'parser-directories' from the config file to determine which languages to include. The command can be invoked with 'dump-languages' or its alias 'langs'.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/docs/src/cli/dump-languages.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ntree-sitter dump-languages [OPTIONS] # Aliases: langs\n```\n\n----------------------------------------\n\nTITLE: Parsing Nested Blocks in Tree-sitter\nDESCRIPTION: This snippet showcases the parsing of nested block structures, including multiple do expressions and binary expressions. It illustrates how Tree-sitter handles complex nesting and maintains the hierarchical structure in the parse tree.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/test/fixtures/test_grammars/uses_current_column/corpus.txt#2025-04-21_snippet_1\n\nLANGUAGE: tree-sitter\nCODE:\n```\na = do b\n       c + do e\n              f\n              g\n       h\ni\n\n---\n\n(block\n  (binary_expression\n    (identifier)\n    (do_expression (block\n      (identifier)\n      (binary_expression\n        (identifier)\n        (do_expression (block\n          (identifier)\n          (identifier)\n          (identifier))))\n      (identifier))))\n  (identifier))\n```\n\n----------------------------------------\n\nTITLE: Running Tree-sitter Test Command in Bash\nDESCRIPTION: Basic syntax for running the tree-sitter test command with optional parameters. The command can be abbreviated as 't' and supports various options for test filtering, debugging, and output control.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/docs/src/cli/test.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ntree-sitter test [OPTIONS] # Aliases: t\n```\n\n----------------------------------------\n\nTITLE: Defining Highlight Names for Syntax Highlighting\nDESCRIPTION: This code defines an array of highlight names that will be recognized by the highlighter. These names represent different syntax elements like keywords, functions, strings, etc.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/highlight/README.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nlet highlight_names = [\n    \"attribute\",\n    \"comment\",\n    \"constant\",\n    \"constant.builtin\",\n    \"constructor\",\n    \"embedded\",\n    \"function\",\n    \"function.builtin\",\n    \"keyword\",\n    \"module\",\n    \"number\",\n    \"operator\",\n    \"property\",\n    \"property.builtin\",\n    \"punctuation\",\n    \"punctuation.bracket\",\n    \"punctuation.delimiter\",\n    \"punctuation.special\",\n    \"string\",\n    \"string.special\",\n    \"tag\",\n    \"type\",\n    \"type.builtin\",\n    \"variable\",\n    \"variable.builtin\",\n    \"variable.parameter\",\n];\n```\n\n----------------------------------------\n\nTITLE: Running the tree-sitter tags Command in Bash\nDESCRIPTION: Command syntax for using the tree-sitter tags functionality to generate symbol tags on specified file paths. This command outputs a list of tags for code navigation purposes.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/docs/src/cli/tags.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ntree-sitter tags [OPTIONS] [PATHS]...\n```\n\n----------------------------------------\n\nTITLE: Adding Tree-sitter Tags Dependencies in Cargo.toml\nDESCRIPTION: This snippet shows how to add the tree-sitter-tags crate and language-specific crates to the project's Cargo.toml file. It includes dependencies for JavaScript and Python parsing.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/tags/README.md#2025-04-21_snippet_0\n\nLANGUAGE: toml\nCODE:\n```\n[dependencies]\ntree-sitter-tags = \"0.19\"\ntree-sitter-javascript = \"0.19\"\ntree-sitter-python = \"0.19\"\n```\n\n----------------------------------------\n\nTITLE: Configuring WASM File Location for Web Tree-sitter in Browser\nDESCRIPTION: This snippet demonstrates how to configure the location of the tree-sitter.wasm file when using Web Tree-sitter in a browser environment, particularly useful for server-side frameworks like NextJS.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/lib/binding_web/README.md#2025-04-21_snippet_12\n\nLANGUAGE: javascript\nCODE:\n```\nawait Parser.init({\n  locateFile(scriptName: string, scriptDirectory: string) {\n    return scriptName;\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Running Tree-Sitter Version Command for Release Preparation\nDESCRIPTION: Command to bump the version of a Tree-Sitter grammar to prepare for release. This updates version information in the grammar's configuration files.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/docs/src/creating-parsers/6-publishing.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ntree-sitter version 1.0.0\n```\n\n----------------------------------------\n\nTITLE: Parsing Example With Extras in Tree-sitter\nDESCRIPTION: Demonstrates how extras (typically whitespace, comments, etc.) affect parsing. The input 'a (one) b (two) (three) c d' is parsed with the parenthesized items treated as comments, which are included in the parse tree as child nodes of the module.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/test/fixtures/test_grammars/extra_non_terminals/corpus.txt#2025-04-21_snippet_1\n\nLANGUAGE: tree-sitter\nCODE:\n```\na (one) b (two) (three) c d\n\n---\n\n(module\n  (comment)\n  (comment)\n  (comment))\n```\n\n----------------------------------------\n\nTITLE: Configuring Parser Directories\nDESCRIPTION: JSON configuration for specifying directories where Tree-sitter should look for grammar repositories.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/docs/src/cli/init-config.md#2025-04-21_snippet_1\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"parser-directories\": [\n    \"/Users/my-name/code\",\n    \"/Users/my-name/other-code\"\n  ]\n}\n```\n\n----------------------------------------\n\nTITLE: Loading Tagging Queries for Python and JavaScript in Rust\nDESCRIPTION: This snippet shows how to load tagging queries for Python and JavaScript languages using the TagsConfiguration struct. It sets up configurations for both languages with their respective queries.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/tags/README.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse tree_sitter_tags::TagsConfiguration;\n\nlet python_config = TagsConfiguration::new(\n    tree_sitter_python::language(),\n    tree_sitter_python::TAGGING_QUERY,\n    \"\",\n).unwrap();\n\nlet javascript_config = TagsConfiguration::new(\n    tree_sitter_javascript::language(),\n    tree_sitter_javascript::TAGGING_QUERY,\n    tree_sitter_javascript::LOCALS_QUERY,\n).unwrap();\n```\n\n----------------------------------------\n\nTITLE: Pushing Commits and Tags to Remote Repository\nDESCRIPTION: Git command to push both the commit and the version tag to the remote repository. This makes the release available in the remote Git repository.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/docs/src/creating-parsers/6-publishing.md#2025-04-21_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\ngit push --tags origin main\n```\n\n----------------------------------------\n\nTITLE: Processing Lists in Ruby with Block Usage\nDESCRIPTION: A Ruby method that processes a list by mapping each item through a processing function within the current context. The example also shows variable assignment and array creation.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/docs/src/3-syntax-highlighting.md#2025-04-21_snippet_4\n\nLANGUAGE: ruby\nCODE:\n```\ndef process_list(list)\n  context = current_context\n  list.map do |item|\n    process_item(item, context)\n  end\nend\n\nitem = 5\nlist = [item]\n```\n\n----------------------------------------\n\nTITLE: Creating a Tree-sitter Tags Context in Rust\nDESCRIPTION: This code demonstrates how to create a TagsContext object, which is required for each thread used in tag computation.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/tags/README.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse tree_sitter_tags::TagsContext;\n\nlet context = TagsContext::new();\n```\n\n----------------------------------------\n\nTITLE: Scanner State Serialization\nDESCRIPTION: Function to serialize scanner state into a byte buffer. Called after successful token recognition to preserve scanner state.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/docs/src/creating-parsers/4-external-scanners.md#2025-04-21_snippet_4\n\nLANGUAGE: c\nCODE:\n```\nunsigned tree_sitter_my_language_external_scanner_serialize(\n  void *payload,\n  char *buffer\n) {\n  // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Tree Root Node Access\nDESCRIPTION: Function to retrieve the root node of a syntax tree.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/docs/src/using-parsers/2-basic-parsing.md#2025-04-21_snippet_5\n\nLANGUAGE: c\nCODE:\n```\nTSNode ts_tree_root_node(const TSTree *);\n```\n\n----------------------------------------\n\nTITLE: Defining a Simple Tree-sitter Grammar Rule\nDESCRIPTION: This example shows a tree-sitter grammar with a token 'the-value' being used in a rule named 'first_rule'. The first part defines the token, and the second part shows how it's used in the grammar rule.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/test/fixtures/test_grammars/start_rule_is_token/corpus.txt#2025-04-21_snippet_0\n\nLANGUAGE: tree-sitter\nCODE:\n```\nthe single token\n==========================\nthe-value\n---\n(first_rule)\n```\n\n----------------------------------------\n\nTITLE: Tree-sitter Config Documentation\nDESCRIPTION: Markdown documentation explaining the purpose and functionality of Tree-sitter's configuration system. Details how the configuration file controls the behavior of the tree-sitter command-line program.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/cli/config/README.md#2025-04-21_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n# Tree-sitter Config\n\nManages Tree-sitter's configuration file.\n\nYou can use a configuration file to control the behavior of the `tree-sitter`\ncommand-line program. This crate implements the logic for finding and the\nparsing the contents of the configuration file.\n```\n\n----------------------------------------\n\nTITLE: Configuring Installation Rules for Tree-sitter in CMake\nDESCRIPTION: Sets up installation rules for the Tree-sitter library, including the API header, pkg-config file, and the library itself. It uses GNUInstallDirs to determine standard installation directories.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/lib/CMakeLists.txt#2025-04-21_snippet_5\n\nLANGUAGE: CMake\nCODE:\n```\nconfigure_file(tree-sitter.pc.in \"${CMAKE_CURRENT_BINARY_DIR}/tree-sitter.pc\" @ONLY)\n\ninclude(GNUInstallDirs)\n\ninstall(FILES include/tree_sitter/api.h\n        DESTINATION \"${CMAKE_INSTALL_INCLUDEDIR}/tree_sitter\")\ninstall(FILES \"${CMAKE_CURRENT_BINARY_DIR}/tree-sitter.pc\"\n        DESTINATION \"${CMAKE_INSTALL_DATAROOTDIR}/pkgconfig\")\ninstall(TARGETS tree-sitter\n        LIBRARY DESTINATION \"${CMAKE_INSTALL_LIBDIR}\")\n```\n\n----------------------------------------\n\nTITLE: Running the tree-sitter build command in Bash\nDESCRIPTION: This command compiles a parser into a dynamically-loadable library. It can be run with various options to customize the build process. The PATH argument is optional and defaults to the current working directory.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/docs/src/cli/build.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ntree-sitter build [OPTIONS] [PATH] # Aliases: b\n```\n\n----------------------------------------\n\nTITLE: Expression Examples in Tree-sitter\nDESCRIPTION: Example of expression syntax showing logical OR operation and member access. The expression demonstrates combining a logical OR with a member access operation.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/test/fixtures/test_grammars/named_precedences/corpus.txt#2025-04-21_snippet_1\n\nLANGUAGE: c-like\nCODE:\n```\na || b.c;\n```\n\n----------------------------------------\n\nTITLE: Adding Tree-sitter Dependencies in Cargo.toml\nDESCRIPTION: This snippet shows how to add the tree-sitter-highlight crate and language-specific crates (in this case JavaScript) to a Rust project's Cargo.toml file.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/highlight/README.md#2025-04-21_snippet_0\n\nLANGUAGE: toml\nCODE:\n```\n[dependencies]\ntree-sitter-highlight = \"0.22.0\"\ntree-sitter-javascript = \"0.21.3\"\n```\n\n----------------------------------------\n\nTITLE: Parsing Chained Math Operations in Tree-sitter\nDESCRIPTION: Example showing how Tree-sitter grammar parses the expression 'x+y+z' into a nested tree structure. The grammar breaks down the chained addition into a hierarchical representation with nested math_operation nodes.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/test/fixtures/test_grammars/associativity_right/corpus.txt#2025-04-21_snippet_0\n\nLANGUAGE: tree-sitter-grammar\nCODE:\n```\n(expression (math_operation\n  (expression (identifier))\n  (expression (math_operation (expression (identifier)) (expression (identifier))))))\n```\n\n----------------------------------------\n\nTITLE: Parsing Single-Line Statements with External Tokens in Tree-Sitter\nDESCRIPTION: This snippet illustrates how to parse a single-line statement containing two string literals using Tree-Sitter grammar. It shows the input and the resulting AST structure for external tokens.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/test/fixtures/test_grammars/external_and_internal_tokens/corpus.txt#2025-04-21_snippet_2\n\nLANGUAGE: tree-sitter\nCODE:\n```\n'hello' 'world'\n\n---\n\n(statement (string) (string) (line_break))\n```\n\n----------------------------------------\n\nTITLE: Combining Grouping with Repetition\nDESCRIPTION: Pattern that matches a number followed by zero or more comma-separated numbers using grouping with the '*' operator.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/docs/src/using-parsers/queries/2-operators.md#2025-04-21_snippet_6\n\nLANGUAGE: query\nCODE:\n```\n(\n  (number)\n  (\",\" (number))*\n)\n```\n\n----------------------------------------\n\nTITLE: Parsing basic tokens in JavaScript with Tree-sitter\nDESCRIPTION: This snippet demonstrates how Tree-sitter parses various basic tokens in JavaScript, including comments, identifiers, operators, strings, and regular expressions.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/test/fixtures/test_grammars/precedence_on_token/corpus.txt#2025-04-21_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\n// hi\n/* hi */\nhi\n/\n\"hi\"\n/hi/\n```\n\nLANGUAGE: Tree-sitter output\nCODE:\n```\n(program\n  (comment)\n  (comment)\n  (identifier)\n  (slash)\n  (string)\n  (regex))\n```\n\n----------------------------------------\n\nTITLE: Installing Language Package for Web Tree-sitter\nDESCRIPTION: This snippet shows how to install a language package (tree-sitter-javascript) from npm to obtain the .wasm file for parsing JavaScript.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/lib/binding_web/README.md#2025-04-21_snippet_9\n\nLANGUAGE: shell\nCODE:\n```\nnpm install tree-sitter-javascript\n```\n\n----------------------------------------\n\nTITLE: Matching Constants with match? Predicate and Regex\nDESCRIPTION: A Tree-sitter pattern using the #match? predicate with a regular expression to identify identifiers written in SCREAMING_SNAKE_CASE, capturing them as constants.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/docs/src/using-parsers/queries/3-predicates-and-directives.md#2025-04-21_snippet_3\n\nLANGUAGE: query\nCODE:\n```\n((identifier) @constant\n  (#match? @constant \"^[A-Z][A-Z_]+\"))\n```\n\n----------------------------------------\n\nTITLE: Parsing Multi-Line Statements with External Tokens in Tree-Sitter\nDESCRIPTION: This example demonstrates how to parse a multi-line statement with two string literals using Tree-Sitter grammar. It shows that the resulting AST structure is the same as for single-line statements with external tokens.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/test/fixtures/test_grammars/external_and_internal_tokens/corpus.txt#2025-04-21_snippet_3\n\nLANGUAGE: tree-sitter\nCODE:\n```\n'hello'\n'world'\n\n---\n\n(statement (string) (string) (line_break))\n```\n\n----------------------------------------\n\nTITLE: Using Start Anchor in Tree-sitter Queries\nDESCRIPTION: Pattern using the '.' anchor operator to match only the first identifier in an array, capturing it as 'the-element'.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/docs/src/using-parsers/queries/2-operators.md#2025-04-21_snippet_9\n\nLANGUAGE: query\nCODE:\n```\n(array . (identifier) @the-element)\n```\n\n----------------------------------------\n\nTITLE: Committing Version Changes in Git for Release\nDESCRIPTION: Git command to commit version changes to the repository. This creates a commit with a descriptive message about the release version.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/docs/src/creating-parsers/6-publishing.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ngit commit -am \"Release 1.0.0\"\n```\n\n----------------------------------------\n\nTITLE: Editing Syntax Trees with Web Tree-sitter\nDESCRIPTION: This snippet shows how to update a syntax tree when the source code changes, which is faster than reparsing the entire code.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/lib/binding_web/README.md#2025-04-21_snippet_7\n\nLANGUAGE: javascript\nCODE:\n```\n// Replace 'let' with 'const'\nconst newSourceCode = 'const x = 1; console.log(x);';\n\ntree.edit({\n  startIndex: 0,\n  oldEndIndex: 3,\n  newEndIndex: 5,\n  startPosition: {row: 0, column: 0},\n  oldEndPosition: {row: 0, column: 3},\n  newEndPosition: {row: 0, column: 5},\n});\n\nconst newTree = parser.parse(newSourceCode, tree);\n```\n\n----------------------------------------\n\nTITLE: Generating WASM Files for Web Tree-sitter\nDESCRIPTION: This snippet demonstrates how to generate a .wasm file for a specific grammar (JavaScript in this case) using the tree-sitter CLI tool.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/lib/binding_web/README.md#2025-04-21_snippet_10\n\nLANGUAGE: shell\nCODE:\n```\nnpm install --save-dev tree-sitter-cli tree-sitter-javascript\nnpx tree-sitter build --wasm node_modules/tree-sitter-javascript\n```\n\n----------------------------------------\n\nTITLE: Representing Missing Node in Tree-sitter Syntax Tree\nDESCRIPTION: This example shows how tree-sitter indicates a missing node in a syntax tree. The source code 'abdef' is parsed, and the tree indicates that a 'c' node is missing from the expected sequence. The syntax tree representation uses the MISSING marker to indicate the expected but absent token.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/test/fixtures/test_grammars/next_sibling_from_zwt/corpus.txt#2025-04-21_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\nabdef\n```\n\nLANGUAGE: tree-sitter\nCODE:\n```\n(source\n    (MISSING \"c\"))\n```\n\n----------------------------------------\n\nTITLE: Parsing Nested Method Calls in Tree-sitter\nDESCRIPTION: Example showing how Tree-sitter parses a nested method call expression with member access. The code demonstrates a method call on object 'a' with property 'b', passing another method call 'c' with member access 'd.e' as an argument.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/test/fixtures/test_grammars/inlined_aliased_rules/corpus.txt#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\na.b(c(d.e));\n```\n\nLANGUAGE: tree-sitter-grammar\nCODE:\n```\n(statement\n  (call_expression\n    (member_expression\n      (variable_name)\n      (property_name))\n    (call_expression\n      (variable_name)\n      (member_expression\n        (variable_name)\n        (property_name)))))\n```\n\n----------------------------------------\n\nTITLE: Parsing External Tokens with State in Tree-sitter\nDESCRIPTION: This example illustrates a more complex scenario where external tokens require state. It shows how Tree-sitter can handle nested expressions within strings and incorporate external scanner functionality.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/test/fixtures/test_grammars/external_tokens/corpus.txt#2025-04-21_snippet_1\n\nLANGUAGE: tree-sitter\nCODE:\n```\n%{sup {} #{x + y} {} scanner?}\n```\n\nLANGUAGE: tree-sitter\nCODE:\n```\n(expression (string\n  (expression (sum\n    (expression (identifier))\n    (expression (identifier))))))\n```\n\n----------------------------------------\n\nTITLE: Building Tree-sitter Rust Libraries and CLI\nDESCRIPTION: Command to build the Rust libraries and the CLI tool for Tree-sitter in release mode.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/docs/src/6-contributing.md#2025-04-21_snippet_2\n\nLANGUAGE: sh\nCODE:\n```\ncargo build --release\n```\n\n----------------------------------------\n\nTITLE: Tree-sitter Highlight Command Usage\nDESCRIPTION: Basic command syntax for using tree-sitter's highlight functionality. The command accepts various options and file paths as arguments, with 'hi' available as an alias for 'highlight'.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/docs/src/cli/highlight.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ntree-sitter highlight [OPTIONS] [PATHS]... # Aliases: hi\n```\n\n----------------------------------------\n\nTITLE: Example of division operator conflict position in expression\nDESCRIPTION: Code snippet showing a position where the '/' token is valid as a division operator, demonstrating the context where a forward slash would be interpreted as division rather than a regex pattern.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/test/fixtures/test_grammars/lexical_conflicts_due_to_state_merging/readme.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\n((1) / 2)\n    ^\n```\n\n----------------------------------------\n\nTITLE: Extra Tokens at End of JavaScript File\nDESCRIPTION: This snippet demonstrates how tree-sitter handles extra tokens at the end of a file, specifically an incomplete assignment expression. The parser marks the incomplete member expression as an ERROR node.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/test/fixtures/error_corpus/javascript_errors.txt#2025-04-21_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\n// skip the equals sign\na.b =\n```\n\nLANGUAGE: scheme\nCODE:\n```\n(program\n  (comment)\n  (ERROR (member_expression (identifier) (property_identifier))))\n```\n\n----------------------------------------\n\nTITLE: Errors Inside JavaScript Template String Substitutions\nDESCRIPTION: This example demonstrates how tree-sitter handles errors within template string substitutions. The parser marks the missing values and unclosed parentheses as MISSING nodes while preserving the overall template string structure.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/test/fixtures/error_corpus/javascript_errors.txt#2025-04-21_snippet_6\n\nLANGUAGE: javascript\nCODE:\n```\nconst a = `b c ${d += } f g`\nconst h = `i ${j(k} l`\n```\n\nLANGUAGE: scheme\nCODE:\n```\n(program\n  (lexical_declaration\n    (variable_declarator\n      (identifier)\n      (template_string (string_fragment) (template_substitution\n        (augmented_assignment_expression (identifier) (MISSING identifier))) (string_fragment))))\n  (lexical_declaration\n    (variable_declarator\n      (identifier)\n      (template_string (string_fragment) (template_substitution (call_expression\n        (identifier)\n        (arguments (identifier) (MISSING \")\")))) (string_fragment)))))\n```\n\n----------------------------------------\n\nTITLE: Parsing Multiplication Expression Chain with Tree-sitter\nDESCRIPTION: Shows how Tree-sitter handles a chain of multiplication expressions 'w * x * y', demonstrating the nested expression structure in the resulting AST.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/test/fixtures/test_grammars/dynamic_precedence/corpus.txt#2025-04-21_snippet_1\n\nLANGUAGE: c\nCODE:\n```\nw * x * y\n```\n\nLANGUAGE: tree-sitter\nCODE:\n```\n(program (expression\n  (expression\n    (expression (identifier))\n    (expression (identifier)))\n  (expression (identifier))))\n```\n\n----------------------------------------\n\nTITLE: Fetching Test Fixtures for Tree-sitter\nDESCRIPTION: Command to fetch upstream grammars that are used for testing Tree-sitter.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/docs/src/6-contributing.md#2025-04-21_snippet_5\n\nLANGUAGE: sh\nCODE:\n```\ncargo xtask fetch-fixtures\n```\n\n----------------------------------------\n\nTITLE: Tree-sitter AST Structure\nDESCRIPTION: Scheme-like representation of the syntax tree generated for the Go function example\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/docs/src/3-syntax-highlighting.md#2025-04-21_snippet_1\n\nLANGUAGE: scheme\nCODE:\n```\n(source_file\n  (function_declaration\n    name: (identifier)\n    parameters: (parameter_list\n      (parameter_declaration\n        name: (identifier)\n        type: (type_identifier)))\n    result: (type_identifier)\n    body: (block\n      (return_statement\n        (expression_list\n          (binary_expression\n            left: (identifier)\n            right: (int_literal)))))))\n```\n\n----------------------------------------\n\nTITLE: Parsing Infix Expressions in Tree-sitter\nDESCRIPTION: This snippet illustrates how Tree-sitter handles infix expressions. It provides an example of infix syntax and the corresponding AST structure generated by the parser.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/test/fixtures/test_grammars/immediate_tokens/corpus.txt#2025-04-21_snippet_1\n\nLANGUAGE: tree-sitter\nCODE:\n```\na::b::c\n\n---\n\n(program\n  (infix\n    (infix\n      (identifier)\n      (identifier))\n    (identifier)))\n```\n\n----------------------------------------\n\nTITLE: Example of regex token conflict position in if statement\nDESCRIPTION: Code snippet illustrating a position where the 'regex' token is valid, showing the context where a forward slash would be interpreted as the start of a regex pattern rather than a division operator.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/test/fixtures/test_grammars/lexical_conflicts_due_to_state_merging/readme.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n(if (1) /\\w+/)\n       ^\n```\n\n----------------------------------------\n\nTITLE: Running a Tree-sitter Query Command in Bash\nDESCRIPTION: The basic syntax for running a tree-sitter query command. It accepts a path to a query file followed by optional paths to source files. The command can also be invoked using the alias 'q'.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/docs/src/cli/query.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ntree-sitter query [OPTIONS] <QUERY_PATH> [PATHS]... # Aliases: q\n```\n\n----------------------------------------\n\nTITLE: Missing Object-Literal Values in JavaScript\nDESCRIPTION: This example demonstrates an object literal with a missing value after a property key. The parse tree shows how tree-sitter handles this by creating a pair node with a MISSING identifier child node.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/test/fixtures/error_corpus/javascript_errors.txt#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\n{\n  a: b,\n  c:\n}\n```\n\nLANGUAGE: scheme\nCODE:\n```\n(program (expression_statement (object\n  (pair (property_identifier) (identifier))\n  (pair (property_identifier) (MISSING identifier)))))\n```\n\n----------------------------------------\n\nTITLE: Function Calls with Blocks in Tree-sitter\nDESCRIPTION: This snippet demonstrates the syntax for function calls with blocks and the corresponding expected parse tree. The test case shows a function call 'foo' with an argument 'bar' followed by a block containing 'baz'.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/test/fixtures/test_grammars/precedence_on_single_child_positive/corpus.txt#2025-04-21_snippet_0\n\nLANGUAGE: tree-sitter\nCODE:\n```\nfoo bar { baz }\n```\n\nLANGUAGE: tree-sitter\nCODE:\n```\n(expression (function_call\n  (identifier)\n  (expression (function_call\n    (identifier)\n    (block (expression (identifier)))))))\n```\n\n----------------------------------------\n\nTITLE: Building Web-tree-sitter Type Definitions\nDESCRIPTION: Command to generate type definitions for the Web-tree-sitter library using dts-buddy.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/lib/binding_web/CONTRIBUTING.md#2025-04-21_snippet_3\n\nLANGUAGE: sh\nCODE:\n```\nnpm run build:dts\n```\n\n----------------------------------------\n\nTITLE: Parsing Prefix Expressions as Arguments in Tree-sitter\nDESCRIPTION: This snippet demonstrates how Tree-sitter parses prefix expressions used as arguments in function calls. It shows the input code and the resulting AST structure.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/test/fixtures/test_grammars/immediate_tokens/corpus.txt#2025-04-21_snippet_0\n\nLANGUAGE: tree-sitter\nCODE:\n```\na ::b ::c\n\n---\n\n(program\n  (call\n    (call\n      (identifier)\n      (prefix (identifier)))\n    (prefix (identifier))))\n```\n\n----------------------------------------\n\nTITLE: Parsing Division Operation in Tree-sitter\nDESCRIPTION: Shows how tree-sitter parses a division operation between a parenthesized number and another number, displaying the resulting AST structure.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/test/fixtures/test_grammars/lexical_conflicts_due_to_state_merging/corpus.txt#2025-04-21_snippet_2\n\nLANGUAGE: tree-sitter\nCODE:\n```\n((1) / 2)\n```\n\nLANGUAGE: tree-sitter\nCODE:\n```\n(expression (parenthesized (expression (quotient\n  (expression (parenthesized (expression (number))))\n  (expression (number))))))\n```\n\n----------------------------------------\n\nTITLE: Unresolved Tree-sitter Grammar Conflict for Unary Operators\nDESCRIPTION: Shows a grammar conflict where the '!' operator followed by an expression and '<' symbol can be interpreted as either unary_a or unary_b with the same precedence level of 2. The conflict occurs because multiple rules can match the same token sequence.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/test/fixtures/test_grammars/partially_resolved_conflict/expected_error.txt#2025-04-21_snippet_0\n\nLANGUAGE: tree-sitter\nCODE:\n```\n'!'  expression    '<'  \n```\n\n----------------------------------------\n\nTITLE: Parsing Incomplete If Statement in Python Function\nDESCRIPTION: Shows how Tree-sitter handles an incomplete if statement with a condition but missing colon and body. The parser marks the error while preserving the function structure.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/test/fixtures/error_corpus/python_errors.txt#2025-04-21_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ndef a():\n  if a\n```\n\nLANGUAGE: scheme\nCODE:\n```\n(module\n  (function_definition\n    name: (identifier)\n    parameters: (parameters)\n    (ERROR (identifier))\n    body: (block)))\n```\n\n----------------------------------------\n\nTITLE: Parsing strings starting with double slashes in JavaScript\nDESCRIPTION: This example shows how Tree-sitter correctly parses a string that begins with double slashes, which could be mistaken for a comment. It demonstrates that string content has higher precedence than comments in the lexer.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/test/fixtures/test_grammars/precedence_on_token/corpus.txt#2025-04-21_snippet_1\n\nLANGUAGE: JavaScript\nCODE:\n```\n\"//one\\n//two\"\n```\n\nLANGUAGE: Tree-sitter output\nCODE:\n```\n(program\n  (comment)\n  (string (escape_sequence)))\n```\n\n----------------------------------------\n\nTITLE: Building Tree-sitter Parser as WASM Module in Bash\nDESCRIPTION: Note about the prerequisite to build the parser as a WASM module before using the playground command. This is done using the build subcommand with the --wasm flag.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/docs/src/cli/playground.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ntree-sitter build --wasm\n```\n\n----------------------------------------\n\nTITLE: Using Wildcard Nodes in Tree-sitter Queries\nDESCRIPTION: Shows how to use wildcard nodes (represented by underscore) to match any node. This example captures any node inside a call expression.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/docs/src/using-parsers/queries/1-syntax.md#2025-04-21_snippet_5\n\nLANGUAGE: query\nCODE:\n```\n(call (_) @call.inner)\n```\n\n----------------------------------------\n\nTITLE: Parsing Lua Do Blocks with Low Precedence\nDESCRIPTION: Example of how Tree-sitter parses a Lua expression with a do block. The do block has lower precedence, so it becomes part of the outer function call rather than binding to the preceding identifier.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/test/fixtures/test_grammars/precedence_on_subsequence/corpus.txt#2025-04-21_snippet_1\n\nLANGUAGE: lua\nCODE:\n```\na b do end\n```\n\nLANGUAGE: tree-sitter\nCODE:\n```\n(expression (function_call\n  (identifier)\n  (expression (identifier))\n  (do_block)))\n```\n\n----------------------------------------\n\nTITLE: Parsing Blocks with Leading Newlines in Tree-sitter\nDESCRIPTION: This snippet demonstrates how Tree-sitter handles blocks with leading newlines and nested do expressions. It shows the parser's ability to maintain the correct structure despite additional whitespace and multiple levels of nesting.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/test/fixtures/test_grammars/uses_current_column/corpus.txt#2025-04-21_snippet_2\n\nLANGUAGE: tree-sitter\nCODE:\n```\ndo\n\n\n   a = b\n   do\n      c\n      d\n   e\n f\n\n---\n\n(block\n  (do_expression (block\n    (binary_expression (identifier) (identifier))\n    (do_expression (block\n      (identifier)\n      (identifier)))\n    (identifier)\n    (identifier))))\n```\n\n----------------------------------------\n\nTITLE: Generating Shell Completion Scripts with Tree-Sitter CLI\nDESCRIPTION: This command generates a completion script for your shell that enables autocompletion for the tree-sitter CLI. You must specify which shell you're using with the --shell option.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/docs/src/cli/complete.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ntree-sitter complete --shell <SHELL> # Aliases: comp\n```\n\n----------------------------------------\n\nTITLE: Parsing Incomplete Expression Before Triple-Quoted String\nDESCRIPTION: Demonstrates how Tree-sitter handles an incomplete method call expression before a triple-quoted string. The parser marks the error at the incomplete expression while correctly parsing the string.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/test/fixtures/error_corpus/python_errors.txt#2025-04-21_snippet_4\n\nLANGUAGE: python\nCODE:\n```\ndef a():\n  b.\n  \"\"\"\n  c\n  \"\"\"\n```\n\nLANGUAGE: scheme\nCODE:\n```\n(module\n  (function_definition\n    name: (identifier)\n    parameters: (parameters)\n    (ERROR (identifier))\n    body: (block\n      (expression_statement (string\n        (string_start)\n        (string_content)\n        (string_end))))))\n```\n\n----------------------------------------\n\nTITLE: Missing Default Values for Function Parameters in JavaScript\nDESCRIPTION: This snippet shows a class declaration with a constructor that has a syntax error - a missing default value for a parameter. The tree-sitter parser generates an ERROR node in the parse tree to indicate the missing value.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/test/fixtures/error_corpus/javascript_errors.txt#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nclass A {\n  constructor (a, b = ) {\n    this.a = a\n  }\n\n  foo() {}\n}\n```\n\nLANGUAGE: scheme\nCODE:\n```\n(program\n  (class_declaration (identifier) (class_body\n    (method_definition\n      (property_identifier)\n      (formal_parameters (identifier) (identifier) (ERROR))\n      (statement_block (expression_statement (assignment_expression (member_expression (this) (property_identifier)) (identifier)))))\n    (method_definition\n      (property_identifier)\n      (formal_parameters)\n      (statement_block)))))\n```\n\n----------------------------------------\n\nTITLE: Node Null Check Function\nDESCRIPTION: Function to check if a node is null, used for validating node references.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/docs/src/using-parsers/2-basic-parsing.md#2025-04-21_snippet_7\n\nLANGUAGE: c\nCODE:\n```\nbool ts_node_is_null(TSNode);\n```\n\n----------------------------------------\n\nTITLE: Parsing Single-line Statements with External Tokens in Tree-sitter\nDESCRIPTION: Example showing how tree-sitter parses a single-line statement containing two string literals (external tokens). The parser recognizes this as a statement containing two string nodes.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/test/fixtures/test_grammars/external_and_internal_anonymous_tokens/corpus.txt#2025-04-21_snippet_2\n\nLANGUAGE: tree-sitter\nCODE:\n```\n'hello' 'world'\n```\n\nLANGUAGE: tree-sitter\nCODE:\n```\n(statement (string) (string))\n```\n\n----------------------------------------\n\nTITLE: Parsing Example with Unit Reductions in Tree-sitter\nDESCRIPTION: This example demonstrates how Tree-sitter processes a simple string input ('one two three four;') and generates a syntax tree with unit reductions. The tree structure shows the tokenization and hierarchical organization of the input elements.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/test/fixtures/test_grammars/aliased_unit_reductions/corpus.txt#2025-04-21_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\none two three four;\n```\n\nLANGUAGE: tree-sitter\nCODE:\n```\n(statement\n  (identifier)\n  (b_prime (identifier))\n  (c_prime (identifier))\n  (identifier))\n```\n\n----------------------------------------\n\nTITLE: Concurrent Tree Copying in C\nDESCRIPTION: Shows the API for creating thread-safe copies of syntax trees through reference counting, enabling multi-threaded parsing operations.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/docs/src/using-parsers/3-advanced-parsing.md#2025-04-21_snippet_4\n\nLANGUAGE: c\nCODE:\n```\nTSTree *ts_tree_copy(const TSTree *);\n```\n\n----------------------------------------\n\nTITLE: Parsing Lua Curly Brace Blocks with High Precedence\nDESCRIPTION: Example of how Tree-sitter parses a Lua expression with curly braces. The curly brace block binds tightly to the preceding identifier, creating a function call with the block as an argument to the second identifier.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/test/fixtures/test_grammars/precedence_on_subsequence/corpus.txt#2025-04-21_snippet_0\n\nLANGUAGE: lua\nCODE:\n```\na b {}\n```\n\nLANGUAGE: tree-sitter\nCODE:\n```\n(expression (function_call\n  (identifier)\n  (expression (function_call (identifier) (block)))))\n```\n\n----------------------------------------\n\nTITLE: Parsing Errors Within JSON Objects\nDESCRIPTION: Demonstrates how Tree-sitter handles an invalid token inside a JSON object. The parser correctly parses the valid key-value pair but marks the unexpected token 'oops' as an ERROR.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/test/fixtures/error_corpus/json_errors.txt#2025-04-21_snippet_3\n\nLANGUAGE: json\nCODE:\n```\n{ \"key1\": 1, oops }\n```\n\nLANGUAGE: tree-sitter\nCODE:\n```\n(document\n  (object\n    (pair\n      (string\n        (string_content))\n      (number))\n    (ERROR\n      (UNEXPECTED 'o'))))\n```\n\n----------------------------------------\n\nTITLE: Parsing Valid JavaScript Code with Tree-sitter\nDESCRIPTION: This snippet demonstrates how Tree-sitter successfully parses valid JavaScript code containing if statements, object literals, and while loops, generating a complete abstract syntax tree (AST).\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/test/fixtures/test_grammars/reserved_words/corpus.txt#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nif (a) {\n  var b = {\n    c: d,\n    e: f,\n  };\n  while (g) {\n    h();\n  }\n}\n```\n\nLANGUAGE: lisp\nCODE:\n```\n(program\n  (if_statement\n    (parenthesized_expression (identifier))\n      (block\n        (var_declaration\n          (identifier)\n          (object\n            (pair (identifier) (identifier))\n            (pair (identifier) (identifier))))\n        (while_statement\n          (parenthesized_expression (identifier))\n          (block (expression_statement (call_expression (identifier))))))))\n```\n\n----------------------------------------\n\nTITLE: Matching ERROR Nodes in Tree-sitter Queries\nDESCRIPTION: Demonstrates how to match ERROR nodes, which represent text the parser does not recognize. This pattern captures syntax errors in the parse tree.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/docs/src/using-parsers/queries/1-syntax.md#2025-04-21_snippet_6\n\nLANGUAGE: query\nCODE:\n```\n(ERROR) @error-node\n```\n\n----------------------------------------\n\nTITLE: Parsing Lowercase Unicode Characters with Tree-sitter\nDESCRIPTION: Test case demonstrating how tree-sitter identifies lowercase Unicode characters. The parse result shows each character sequence recognized as a 'lower' node in the syntax tree.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/test/fixtures/test_grammars/unicode_classes/corpus.txt#2025-04-21_snippet_1\n\nLANGUAGE: tree-sitter\nCODE:\n```\n    \n\n---\n\n(program\n  (lower) (lower) (lower))\n```\n\n----------------------------------------\n\nTITLE: Parsing Simple External Tokens in Tree-sitter\nDESCRIPTION: This snippet shows a simple expression with an external token. It demonstrates how Tree-sitter can parse a sum expression that includes an identifier and a string containing an external scanner reference.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/test/fixtures/test_grammars/external_tokens/corpus.txt#2025-04-21_snippet_0\n\nLANGUAGE: tree-sitter\nCODE:\n```\nx + %(sup (external) scanner?)\n```\n\nLANGUAGE: tree-sitter\nCODE:\n```\n(expression (sum (expression (identifier)) (expression (string))))\n```\n\n----------------------------------------\n\nTITLE: Parsing String Input in Tree-sitter\nDESCRIPTION: Basic function for parsing source code from a string input. Takes a parser instance, optional previous tree, input string, and length as parameters.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/docs/src/using-parsers/2-basic-parsing.md#2025-04-21_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nTSTree *ts_parser_parse_string(\n  TSParser *self,\n  const TSTree *old_tree,\n  const char *string,\n  uint32_t length\n);\n```\n\n----------------------------------------\n\nTITLE: TSInput Structure Definition\nDESCRIPTION: Structure definition for custom input handling, including payload data, read function pointer, encoding type, and custom decode function.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/docs/src/using-parsers/2-basic-parsing.md#2025-04-21_snippet_2\n\nLANGUAGE: c\nCODE:\n```\ntypedef struct {\n  void *payload;\n  const char *(*read)(\n    void *payload,\n    uint32_t byte_offset,\n    TSPoint position,\n    uint32_t *bytes_read\n  );\n  TSInputEncoding encoding;\n  DecodeFunction decode;\n} TSInput;\n```\n\n----------------------------------------\n\nTITLE: Parse Tree for Invalid Characters in Declarations\nDESCRIPTION: Displays the Tree-sitter parse tree for code with invalid characters in declarations, showing how the parser creates ERROR nodes and marks UNEXPECTED characters in the tree.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/test/fixtures/error_corpus/c_errors.txt#2025-04-21_snippet_9\n\nLANGUAGE: lisp\nCODE:\n```\n(translation_unit\n  (function_definition\n    (primitive_type)\n    (function_declarator (identifier) (parameter_list))\n    (compound_statement\n      (declaration (primitive_type) (identifier))\n      (ERROR (primitive_type) (ERROR) (identifier) (UNEXPECTED '@')))))\n```\n\n----------------------------------------\n\nTITLE: Handling Syntax Errors at Globally-Reserved Words\nDESCRIPTION: This example shows how Tree-sitter detects and reports syntax errors when a globally-reserved word is misused. The parser still attempts to recover and parse the remaining valid code.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/test/fixtures/test_grammars/reserved_words/corpus.txt#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nvar a =\n\nif (something) {\n  c();\n}\n```\n\nLANGUAGE: lisp\nCODE:\n```\n(program\n  (ERROR (identifier))\n  (if_statement\n    (parenthesized_expression (identifier))\n    (block\n      (expression_statement (call_expression (identifier))))))\n```\n\n----------------------------------------\n\nTITLE: Parsing Incomplete If Statement Condition in Python\nDESCRIPTION: Demonstrates how Tree-sitter parses an if statement with missing condition syntax (missing comparison operator). The parser identifies the error but still creates a structured AST.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/test/fixtures/error_corpus/python_errors.txt#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nif a is:\n  print b\n  print c\nprint d\n```\n\nLANGUAGE: scheme\nCODE:\n```\n(module\n  (if_statement\n    condition: (identifier)\n    (ERROR)\n    consequence: (block\n      (print_statement argument: (identifier))\n      (print_statement argument: (identifier))))\n  (print_statement argument: (identifier)))\n```\n\n----------------------------------------\n\nTITLE: Aliased Token Rule Example in Tree-sitter Grammar\nDESCRIPTION: A simple example of an aliased token rule in Tree-sitter grammar. It includes a token 'abcde' followed by an expression pattern that captures two aliased tokens X and Y.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/test/fixtures/test_grammars/aliased_token_rules/corpus.txt#2025-04-21_snippet_0\n\nLANGUAGE: tree-sitter\nCODE:\n```\nabcde\n```\n\nLANGUAGE: tree-sitter\nCODE:\n```\n(expression (X) (Y))\n```\n\n----------------------------------------\n\nTITLE: Running Tree-sitter Tests\nDESCRIPTION: Command to run the test suite for Tree-sitter.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/docs/src/6-contributing.md#2025-04-21_snippet_7\n\nLANGUAGE: sh\nCODE:\n```\ncargo xtask test\n```\n\n----------------------------------------\n\nTITLE: Parsing Conditional with Regular Expression in Tree-sitter\nDESCRIPTION: Demonstrates tree-sitter's parsing of a conditional statement containing a number and regular expression, showing the nested AST structure.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/test/fixtures/test_grammars/lexical_conflicts_due_to_state_merging/corpus.txt#2025-04-21_snippet_1\n\nLANGUAGE: tree-sitter\nCODE:\n```\n(if (1) /a+/)\n```\n\nLANGUAGE: tree-sitter\nCODE:\n```\n(expression (parenthesized (expression (conditional\n  (parenthesized (expression (number)))\n  (expression (regex))))))\n```\n\n----------------------------------------\n\nTITLE: Ruby Heredoc with SQL and Syntax Error\nDESCRIPTION: Demonstrates a Ruby code snippet with a malformed heredoc containing SQL. The code shows an incomplete method call with a heredoc argument followed by an unexpected closing parenthesis and identifier, resulting in a parse error.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/test/fixtures/error_corpus/ruby_errors.txt#2025-04-21_snippet_0\n\nLANGUAGE: ruby\nCODE:\n```\njoins <<~SQL\n  b\nSQL\n)\nc\n```\n\nLANGUAGE: s-expression\nCODE:\n```\n(program\n  (call\n    method: (identifier)\n    arguments: (argument_list\n      (heredoc_beginning)))\n  (heredoc_body\n    (heredoc_content)\n    (heredoc_end))\n  (ERROR)\n  (identifier))\n```\n\n----------------------------------------\n\nTITLE: Parse Tree for Missing Semicolons in Top-level Declarations\nDESCRIPTION: Displays the Tree-sitter parse tree for global declarations with missing semicolons, showing how each missing semicolon is identified in the tree structure.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/test/fixtures/error_corpus/c_errors.txt#2025-04-21_snippet_3\n\nLANGUAGE: lisp\nCODE:\n```\n(translation_unit\n  (declaration (primitive_type) (identifier) (MISSING \";\"))\n  (declaration (storage_class_specifier) (primitive_type) (identifier) (MISSING \";\")))\n```\n\n----------------------------------------\n\nTITLE: Defining Anonymous Token with Quotes in Tree-sitter\nDESCRIPTION: This snippet demonstrates how to define an anonymous token using single quotes in a Tree-sitter grammar. It uses the string 'hello' as an example.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/test/fixtures/test_grammars/anonymous_tokens_with_escaped_chars/corpus.txt#2025-04-21_snippet_3\n\nLANGUAGE: tree-sitter\nCODE:\n```\n'hello'\n---\n\n(first_rule)\n```\n\n----------------------------------------\n\nTITLE: Handling Missing Semicolons in C Function Statements\nDESCRIPTION: Demonstrates how Tree-sitter parses C code with missing semicolons in function statements, marking each missing semicolon with a (MISSING \";\") node in the parse tree.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/test/fixtures/error_corpus/c_errors.txt#2025-04-21_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nint main() {\n  puts(\"hello\")\n  puts(\"world\")\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Named Rules as Anonymous Tokens in Tree-sitter Grammar\nDESCRIPTION: This snippet demonstrates the definition of named rules that are aliased as anonymous tokens in a Tree-sitter grammar. It shows a simple input 'B C B' and its corresponding parse tree output.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/test/fixtures/test_grammars/named_rule_aliased_as_anonymous/corpus.txt#2025-04-21_snippet_0\n\nLANGUAGE: tree-sitter\nCODE:\n```\nB C B\n\n---\n\n(a (c) (b))\n```\n\n----------------------------------------\n\nTITLE: Parsing Regular Expression in Tree-sitter\nDESCRIPTION: Shows how tree-sitter parses a simple regular expression pattern and generates its AST representation.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/test/fixtures/test_grammars/lexical_conflicts_due_to_state_merging/corpus.txt#2025-04-21_snippet_0\n\nLANGUAGE: tree-sitter\nCODE:\n```\n/a+/\n```\n\nLANGUAGE: tree-sitter\nCODE:\n```\n(expression (regex))\n```\n\n----------------------------------------\n\nTITLE: Error Handling After Multiple Function Declarations in JavaScript\nDESCRIPTION: This example shows how tree-sitter handles an error after a sequence of function declarations. The parse tree correctly retains all function declarations and marks the incomplete variable declaration as an ERROR.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/test/fixtures/error_corpus/javascript_errors.txt#2025-04-21_snippet_5\n\nLANGUAGE: javascript\nCODE:\n```\n/*\n * The JS grammar has an ambiguity such that these functions\n * can be parsed either as function declarations or as\n * function expressions. This ambiguity causes a lot of\n * splitting and merging in the parse stack. When iterating\n * the parse stack during an error repair, there would then\n * be a very large number (> 2^16) of paths through the parse\n * stack.\n */\nfunction a() {}\nfunction b() {}\nfunction c() {}\nfunction e() {}\nfunction f() {}\nfunction g() {}\nfunction h() {}\nfunction i() {}\n\nvar x = !!!\n```\n\nLANGUAGE: scheme\nCODE:\n```\n(program\n  (comment)\n  (function_declaration (identifier) (formal_parameters) (statement_block))\n  (function_declaration (identifier) (formal_parameters) (statement_block))\n  (function_declaration (identifier) (formal_parameters) (statement_block))\n  (function_declaration (identifier) (formal_parameters) (statement_block))\n  (function_declaration (identifier) (formal_parameters) (statement_block))\n  (function_declaration (identifier) (formal_parameters) (statement_block))\n  (function_declaration (identifier) (formal_parameters) (statement_block))\n  (function_declaration (identifier) (formal_parameters) (statement_block))\n  (ERROR (identifier)))\n```\n\n----------------------------------------\n\nTITLE: Erroneous ERB Template for Food Management in Rails\nDESCRIPTION: An ERB template for a food management interface in Rails containing multiple syntax errors. The most common error is missing equals signs (=) in ERB tags that should output content, which would result in the template not displaying the intended content.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/test/fixtures/template_corpus/ruby_templates.txt#2025-04-21_snippet_0\n\nLANGUAGE: erb\nCODE:\n```\n<div>\n  <% if notice.present? %>\n    <p id=\"notice\"><% notice %></p>\n  <% end %>\n  <div>\n    <h1>Foods</h1>\n    <div>\n      <% link_to 'New food', new_food_path, class: \"block font-medium\" %>\n      <% link_to 'Search Database', database_foods_search_path, class: \"block font-medium\" %>\n    </div>\n  </div>\n\n  <% . render partial: \"form\", locals: { food: @new_food } %>\n\n  <% form_with url: \"/search\", method: :get do |form| %>\n    <% form.label :previous_query, 'Search previous foods:' %>\n    <% form.text_field :previous_query %>\n    <% form.submit \"Search\" %>\n  <% end %>\n\n  <div id=\"recipes\">\n    <% render @foods %>\n  </div>\n</div>\n```\n\n----------------------------------------\n\nTITLE: Parse Tree for Partial Declaration Lists with Preprocessor Directives\nDESCRIPTION: Shows the Tree-sitter parse tree for code with preprocessor conditionals, identifying a missing #endif directive in the nested structure through a (MISSING \"#endif\") node.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/test/fixtures/error_corpus/c_errors.txt#2025-04-21_snippet_5\n\nLANGUAGE: lisp\nCODE:\n```\n(translation_unit\n  (preproc_ifdef (identifier)\n    (linkage_specification (string_literal (string_content)) (declaration_list\n      (preproc_call (preproc_directive))\n      (comment)\n      (declaration (primitive_type) (identifier))\n      (function_definition (primitive_type) (function_declarator (identifier) (parameter_list)) (compound_statement (return_statement (number_literal))))\n      (preproc_ifdef (identifier) (MISSING \"#endif\"))))))\n```\n\n----------------------------------------\n\nTITLE: Processing Partial Declaration Lists with Preprocessor Directives\nDESCRIPTION: Demonstrates C code with preprocessor directives forming a linkage specification block, showing how Tree-sitter handles incomplete preprocessor structures with a missing #endif directive.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/test/fixtures/error_corpus/c_errors.txt#2025-04-21_snippet_4\n\nLANGUAGE: c\nCODE:\n```\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n// ok\nint b;\n\nint c() {\n  return 5;\n}\n\n#ifdef __cplusplus\n}\n#endif\n```\n\n----------------------------------------\n\nTITLE: Parsing Multiple Markdown Lists with Checkboxes in Tree-sitter\nDESCRIPTION: This grammar snippet defines the structure for multiple Markdown lists with various checkbox configurations. It captures three separate lists with different numbers of items, ignoring the presence and arrangement of checkboxes in the grammar structure.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/test/fixtures/test_grammars/external_unicode_column_alignment/corpus.txt#2025-04-21_snippet_3\n\nLANGUAGE: tree-sitter\nCODE:\n```\n(expression\n  (list\n    (list_item)\n    (list_item)\n    (list_item)\n  )\n  (list\n    (list_item)\n    (list_item)\n    (list_item)\n    (list_item)\n  )\n  (list\n    (list_item)\n    (list_item)\n  )\n)\n```\n\n----------------------------------------\n\nTITLE: Defining Empty String Rule in Tree-sitter Grammar\nDESCRIPTION: This snippet defines a Tree-sitter grammar rule named 'first_rule' that matches the empty string. It demonstrates the basic syntax for defining a rule in Tree-sitter grammars.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/test/fixtures/test_grammars/start_rule_is_blank/corpus.txt#2025-04-21_snippet_0\n\nLANGUAGE: Tree-sitter\nCODE:\n```\n(first_rule)\n```\n\n----------------------------------------\n\nTITLE: Testing Tree-sitter Parser (Windows PowerShell)\nDESCRIPTION: PowerShell commands to create a test file and parse it using the newly generated Tree-sitter parser on Windows systems.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/docs/src/creating-parsers/1-getting-started.md#2025-04-21_snippet_5\n\nLANGUAGE: pwsh\nCODE:\n```\n\"hello\" | Out-File example-file -Encoding utf8\ntree-sitter parse example-file\n```\n\n----------------------------------------\n\nTITLE: Handling Invalid Characters in C Declarations\nDESCRIPTION: Shows C code with invalid characters in a variable declaration, demonstrating how Tree-sitter marks these as errors in the parse tree with ERROR and UNEXPECTED nodes.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/test/fixtures/error_corpus/c_errors.txt#2025-04-21_snippet_8\n\nLANGUAGE: c\nCODE:\n```\nint main() {\n  int x;\n  int %$#@\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Tree-sitter Language Base URL\nDESCRIPTION: Defines the base URL for loading Tree-sitter language grammars.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/docs/src/7-playground.md#2025-04-21_snippet_1\n\nLANGUAGE: JavaScript\nCODE:\n```\nLANGUAGE_BASE_URL = \"https://tree-sitter.github.io\";\n```\n\n----------------------------------------\n\nTITLE: Handling Extra Values in Parenthesized Expressions\nDESCRIPTION: Shows C code with invalid extra values inside parenthesized expressions, demonstrating how Tree-sitter marks the unexpected elements as errors in the parse tree.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/test/fixtures/error_corpus/c_errors.txt#2025-04-21_snippet_10\n\nLANGUAGE: c\nCODE:\n```\nint main() {\n  int x = (123 123);\n}\n```\n\n----------------------------------------\n\nTITLE: Parsing Markdown List with Checkboxes in Tree-sitter\nDESCRIPTION: This grammar snippet defines the structure for a Markdown list with checkbox indicators. It captures a list with three items, where the presence of checkboxes is ignored in the grammar structure.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/test/fixtures/test_grammars/external_unicode_column_alignment/corpus.txt#2025-04-21_snippet_2\n\nLANGUAGE: tree-sitter\nCODE:\n```\n(expression\n  (list\n    (list_item)\n    (list_item)\n    (list_item)\n  )\n)\n```\n\n----------------------------------------\n\nTITLE: Custom Decode Function Definition\nDESCRIPTION: Function type definition for custom text decoding, used when input encoding is neither UTF-8 nor UTF-16.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/docs/src/using-parsers/2-basic-parsing.md#2025-04-21_snippet_3\n\nLANGUAGE: c\nCODE:\n```\ntypedef uint32_t (*DecodeFunction)(\n  const uint8_t *string,\n  uint32_t length,\n  int32_t *code_point\n);\n```\n\n----------------------------------------\n\nTITLE: Parse Tree for Extra Identifiers in Declarations\nDESCRIPTION: Displays the Tree-sitter parse tree for code with extra identifiers in declarations, showing how the unexpected identifier is marked as an ERROR node in the tree structure.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/test/fixtures/error_corpus/c_errors.txt#2025-04-21_snippet_13\n\nLANGUAGE: lisp\nCODE:\n```\n(translation_unit\n  (declaration (primitive_type) (ERROR (identifier)) (identifier))\n  (declaration (primitive_type) (init_declarator (identifier) (number_literal))))\n```\n\n----------------------------------------\n\nTITLE: Tree-sitter Grammar Conflict Interpretations\nDESCRIPTION: Shows the two possible interpretations of the token sequence, both with precedence level 2. The interpretations differ in whether unary_a or unary_b is used as the rule for parsing the expression.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/test/fixtures/test_grammars/partially_resolved_conflict/expected_error.txt#2025-04-21_snippet_1\n\nLANGUAGE: tree-sitter\nCODE:\n```\n1:  (unary_a  '!'  expression)    '<'    (precedence: 2)\n2:  (unary_b  '!'  expression)    '<'    (precedence: 2)\n```\n\n----------------------------------------\n\nTITLE: Parsing Multi-line Statements with External Tokens in Tree-sitter\nDESCRIPTION: Example showing how tree-sitter parses a multi-line statement with external tokens. Despite the line break between string literals, the parser still recognizes this as a single statement containing two string nodes.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/test/fixtures/test_grammars/external_and_internal_anonymous_tokens/corpus.txt#2025-04-21_snippet_3\n\nLANGUAGE: tree-sitter\nCODE:\n```\n'hello'\n'world'\n```\n\nLANGUAGE: tree-sitter\nCODE:\n```\n(statement (string) (string))\n```\n\n----------------------------------------\n\nTITLE: Arithmetic Expression Example\nDESCRIPTION: A simple arithmetic expression showing addition and multiplication\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/test/fixtures/test_grammars/readme_grammar/corpus.txt#2025-04-21_snippet_0\n\nLANGUAGE: text\nCODE:\n```\na + b * c\n```\n\n----------------------------------------\n\nTITLE: Parse Tree for Incomplete Expressions in Conditional Statements\nDESCRIPTION: Shows the Tree-sitter parse tree for code with incomplete expressions in if statements, identifying missing fields and identifiers with appropriate MISSING nodes in the parse tree.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/test/fixtures/error_corpus/c_errors.txt#2025-04-21_snippet_7\n\nLANGUAGE: lisp\nCODE:\n```\n(translation_unit\n  (function_definition\n    (primitive_type)\n    (function_declarator (identifier) (parameter_list))\n    (compound_statement\n      (if_statement\n        (parenthesized_expression (field_expression\n          (identifier)\n          (MISSING field_identifier)))\n        (compound_statement\n          (expression_statement (call_expression (identifier) (argument_list)))\n          (expression_statement (call_expression (identifier) (argument_list)))\n          (if_statement\n            (parenthesized_expression (pointer_expression (MISSING identifier)))\n            (expression_statement (call_expression (identifier) (argument_list)))))))))\n```\n\n----------------------------------------\n\nTITLE: Extra Complex Literals in JavaScript Expressions\nDESCRIPTION: This example shows how tree-sitter handles extra complex literals (objects) in expressions. The parser identifies the first object as an ERROR node and points out a MISSING semicolon between the function expressions.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/test/fixtures/error_corpus/javascript_errors.txt#2025-04-21_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nif ({a: 'b'} {c: 'd'}) {\n  x = function(a) { b; } function(c) { d; }\n}\n```\n\nLANGUAGE: scheme\nCODE:\n```\n(program\n  (if_statement\n    (parenthesized_expression\n      (ERROR (object (pair (property_identifier) (string (string_fragment)))))\n      (object (pair (property_identifier) (string (string_fragment)))))\n    (statement_block\n      (expression_statement\n        (assignment_expression\n          (identifier)\n          (function_expression (formal_parameters (identifier)) (statement_block (expression_statement (identifier)))))\n        (MISSING \";\"))\n      (expression_statement\n        (function_expression (formal_parameters (identifier)) (statement_block (expression_statement (identifier))))))))\n```\n\n----------------------------------------\n\nTITLE: Configuring Parse Theme\nDESCRIPTION: JSON configuration for customizing the colors used in CST (Concrete Syntax Tree) output visualization.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/docs/src/cli/init-config.md#2025-04-21_snippet_3\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"parse-theme\": {\n    \"node-kind\": [20, 20, 20],\n    \"node-text\": [255, 255, 255],\n    \"field\": [42, 42, 42],\n    \"row-color\": [255, 255, 255],\n    \"row-color-named\": [255, 130, 0],\n    \"extra\": [255, 0, 255],\n    \"error\": [255, 0, 0],\n    \"missing\": [153, 75, 0],\n    \"line-feed\": [150, 150, 150],\n    \"backtick\": [0, 200, 0],\n    \"literal\": [0, 0, 200]\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Handling Operator Associativity Conflict in Tree-sitter Grammar\nDESCRIPTION: Example of a parsing conflict in Tree-sitter where the parser cannot determine how to group expressions with multiple addition operators. The conflict arises because the grammar doesn't specify whether addition should be left or right associative.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/test/fixtures/test_grammars/associativity_missing/expected_error.txt#2025-04-21_snippet_0\n\nLANGUAGE: text\nCODE:\n```\nUnresolved conflict for symbol sequence:\n\n  expression  '+'  expression    '+'  \n\nPossible interpretations:\n\n  1:  (math_operation  expression  '+'  expression)    '+'  \n  2:  expression  '+'  (math_operation  expression    '+'  expression)\n\nPossible resolutions:\n\n  1:  Specify a left or right associativity in `math_operation`\n  2:  Add a conflict for these rules: `math_operation`\n```\n\n----------------------------------------\n\nTITLE: Defining Anonymous Token with LF Escape Sequence in Tree-sitter\nDESCRIPTION: This snippet shows the structure for defining an anonymous token using a Line Feed (LF) escape sequence in a Tree-sitter grammar. The actual escape sequence is not visible in the provided code.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/test/fixtures/test_grammars/anonymous_tokens_with_escaped_chars/corpus.txt#2025-04-21_snippet_1\n\nLANGUAGE: tree-sitter\nCODE:\n```\n\n---\n\n(first_rule)\n```\n\n----------------------------------------\n\nTITLE: Parsing Multi-Line Statements with Internal Tokens in Tree-Sitter\nDESCRIPTION: This example shows how to parse a multi-line statement with two variables using Tree-Sitter grammar. It demonstrates that the resulting AST structure is the same as for single-line statements.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/test/fixtures/test_grammars/external_and_internal_tokens/corpus.txt#2025-04-21_snippet_1\n\nLANGUAGE: tree-sitter\nCODE:\n```\na\nb\n\n---\n\n(statement (variable) (variable) (line_break))\n```\n\n----------------------------------------\n\nTITLE: Copying WASM file in package.json postinstall script\nDESCRIPTION: This snippet shows a postinstall script in package.json to copy the tree-sitter.wasm file to the public directory for use with Vite.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/lib/binding_web/README.md#2025-04-21_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\n\"postinstall\": \"cp node_modules/web-tree-sitter/tree-sitter.wasm public\"\n```\n\n----------------------------------------\n\nTITLE: Parsing Incomplete Tokens at EOF in JSON\nDESCRIPTION: Demonstrates how Tree-sitter handles incomplete tokens at the end of a file. The parser marks the incomplete 'nul' (likely intended as 'null') as an ERROR with an unexpected null character.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/test/fixtures/error_corpus/json_errors.txt#2025-04-21_snippet_5\n\nLANGUAGE: json\nCODE:\n```\nnul\n```\n\nLANGUAGE: tree-sitter\nCODE:\n```\n(document\n  (ERROR\n    (UNEXPECTED '\\0')))\n```\n\n----------------------------------------\n\nTITLE: Parsing Letterlike Numeric Characters with Tree-sitter\nDESCRIPTION: Test case demonstrating how tree-sitter handles letterlike numeric Unicode characters. The parse result shows each character recognized as a 'letter_number' node in the syntax tree.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/test/fixtures/test_grammars/unicode_classes/corpus.txt#2025-04-21_snippet_3\n\nLANGUAGE: tree-sitter\nCODE:\n```\n  \n\n---\n\n(program\n  (letter_number) (letter_number) (letter_number))\n```\n\n----------------------------------------\n\nTITLE: Parsing Return Statements with Tree-sitter\nDESCRIPTION: Example showing how Tree-sitter parses multiple return statements into an AST. The code contains two simple return statements with numeric literals, and the corresponding tree-sitter AST output shows how these are structured into return_statement nodes with number child nodes.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/test/fixtures/test_grammars/nested_inlined_rules/corpus.txt#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nreturn 1;\nreturn 2;\n```\n\nLANGUAGE: tree-sitter\nCODE:\n```\n(program\n  (return_statement (number))\n  (return_statement (number)))\n```\n\n----------------------------------------\n\nTITLE: Using Reserved Words as Object Keys\nDESCRIPTION: This snippet shows how Tree-sitter correctly handles JavaScript keywords when they are used as object property names, which is a valid use case in JavaScript.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/test/fixtures/test_grammars/reserved_words/corpus.txt#2025-04-21_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nvar x = {\n  if: a,\n  while: b,\n};\n```\n\nLANGUAGE: lisp\nCODE:\n```\n(program\n  (var_declaration\n    (identifier)\n    (object\n      (pair (identifier) (identifier))\n      (pair (identifier) (identifier)))))\n```\n\n----------------------------------------\n\nTITLE: Parsing Mathematical Symbols with Tree-sitter\nDESCRIPTION: Test case showing how tree-sitter identifies mathematical Unicode symbols. The parse result shows each symbol recognized as a 'math_sym' node in the syntax tree.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/test/fixtures/test_grammars/unicode_classes/corpus.txt#2025-04-21_snippet_2\n\nLANGUAGE: tree-sitter\nCODE:\n```\n    \n\n---\n\n(program\n  (math_sym) (math_sym) (math_sym) (math_sym) (math_sym))\n```\n\n----------------------------------------\n\nTITLE: Parsing Stray If Keyword in Python Function\nDESCRIPTION: Demonstrates how Tree-sitter handles a stray 'if' keyword inside a function definition without a condition. The parser captures this error while maintaining a valid tree structure.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/test/fixtures/error_corpus/python_errors.txt#2025-04-21_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ndef a():\n  if\n```\n\nLANGUAGE: scheme\nCODE:\n```\n(module\n  (function_definition\n    name: (identifier)\n    parameters: (parameters)\n    (ERROR)\n    body: (block)))\n```\n\n----------------------------------------\n\nTITLE: Parsing a Simple Document with Tree-sitter\nDESCRIPTION: Demonstrates the AST (Abstract Syntax Tree) output of tree-sitter when parsing a minimal document containing only the text \"a b\". The parsed structure shows a single document node.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/test/fixtures/test_grammars/epsilon_external_extra_tokens/corpus.txt#2025-04-21_snippet_0\n\nLANGUAGE: tree-sitter\nCODE:\n```\n(document)\n```\n\n----------------------------------------\n\nTITLE: Parsing Two Markdown Lists without Checkboxes in Tree-sitter\nDESCRIPTION: This grammar snippet defines the structure for two consecutive Markdown lists without checkbox indicators. It captures a list with three items followed by another list with two items.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/test/fixtures/test_grammars/external_unicode_column_alignment/corpus.txt#2025-04-21_snippet_1\n\nLANGUAGE: tree-sitter\nCODE:\n```\n(expression\n  (list\n    (list_item)\n    (list_item)\n    (list_item)\n  )\n  (list\n    (list_item)\n    (list_item)\n  )\n)\n```\n\n----------------------------------------\n\nTITLE: Parsing Arithmetic Expression Conflict Example\nDESCRIPTION: Shows an ambiguous grammar state where an expression followed by + and * operators can be interpreted in multiple ways based on different precedence and associativity rules.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/test/fixtures/test_grammars/conflicting_precedence/expected_error.txt#2025-04-21_snippet_0\n\nLANGUAGE: grammar\nCODE:\n```\nexpression  '+'  expression    '*'  \n\n1:  (sum  expression  '+'  expression)    '*'                 (precedence: 0, associativity: Left)\n2:  expression  '+'  (other_thing  expression    '*'  '*')     (precedence: -1, associativity: Left)\n3:  expression  '+'  (product  expression    '*'  expression)  (precedence: 1, associativity: Left)\n```\n\n----------------------------------------\n\nTITLE: Parsing Element at Odd Column Position with Tree-sitter\nDESCRIPTION: Example showing tree-sitter parsing 'x' at an odd column position (column 1). The parser correctly identifies and categorizes this as an 'odd_column' node within an 'x_is_at' parent node.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/test/fixtures/test_grammars/depends_on_column/corpus.txt#2025-04-21_snippet_0\n\nLANGUAGE: text\nCODE:\n```\n x\n```\n\nLANGUAGE: tree-sitter-grammar\nCODE:\n```\n(x_is_at\n  (odd_column))\n```\n\n----------------------------------------\n\nTITLE: Error Detection with Context-Specific Reserved Words\nDESCRIPTION: This example demonstrates how Tree-sitter handles errors when context-specific reserved words are misused. Note that var declarations are still recognized even within invalid syntax contexts.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/test/fixtures/test_grammars/reserved_words/corpus.txt#2025-04-21_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nvar x = {\nvar y = z;\n```\n\nLANGUAGE: lisp\nCODE:\n```\n(program\n  (ERROR (identifier))\n\n  ; Important - var declaration is still recognized,\n  ; because in this example grammar, `var` is a keyword\n  ; even within object literals.\n  (var_declaration\n    (identifier)\n    (identifier)))\n```\n\n----------------------------------------\n\nTITLE: Parsing Incomplete Method Definition in Python Class\nDESCRIPTION: Shows how Tree-sitter handles an incomplete method definition within a class. The parser identifies the error while still creating a structured representation of the class.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/test/fixtures/error_corpus/python_errors.txt#2025-04-21_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nclass A:\n  def\n\nb\n```\n\nLANGUAGE: scheme\nCODE:\n```\n(module\n  (class_definition\n    name: (identifier)\n    (ERROR)\n    body: (block))\n  (expression_statement\n    (identifier)))\n```\n\n----------------------------------------\n\nTITLE: Parsing Example Without Extras in Tree-sitter\nDESCRIPTION: Shows a basic parsing example where input text 'a b c d' is parsed into a simple module node without any extras. The output is a minimal parse tree with just the module node.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/test/fixtures/test_grammars/extra_non_terminals/corpus.txt#2025-04-21_snippet_0\n\nLANGUAGE: tree-sitter\nCODE:\n```\na b c d\n\n---\n\n(module)\n```\n\n----------------------------------------\n\nTITLE: Ambiguous Tree-sitter Grammar Sequence\nDESCRIPTION: Shows an ambiguous grammar sequence where an identifier followed by another identifier and an opening brace could be interpreted either as an expression or a function call with a block.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/test/fixtures/test_grammars/precedence_on_single_child_missing/expected_error.txt#2025-04-21_snippet_0\n\nLANGUAGE: tree-sitter\nCODE:\n```\nidentifier  identifier    '{'\n```\n\n----------------------------------------\n\nTITLE: Parse Tree for Missing Variable Names in Declarations\nDESCRIPTION: Displays the Tree-sitter parse tree for code with missing variable names in declarations, showing how each missing identifier is marked with a (MISSING identifier) node in the tree structure.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/test/fixtures/error_corpus/c_errors.txt#2025-04-21_snippet_15\n\nLANGUAGE: lisp\nCODE:\n```\n(translation_unit\n  (function_definition\n    (primitive_type)\n    (function_declarator\n      (identifier)\n      (parameter_list))\n    (compound_statement\n      (declaration\n        (struct_specifier (type_identifier))\n        (init_declarator\n          (MISSING identifier)\n          (number_literal)))\n      (declaration\n        (primitive_type)\n        (init_declarator\n          (MISSING identifier)\n          (number_literal))))))\n```\n\n----------------------------------------\n\nTITLE: Tree-sitter AST Representation of ERB Template\nDESCRIPTION: The abstract syntax tree (AST) generated by Tree-sitter for the ERB template, showing how the parser interprets the code. The AST includes an ERROR node that represents the syntactically invalid construct in the template where a dot (.) appears before the render call.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/test/fixtures/template_corpus/ruby_templates.txt#2025-04-21_snippet_1\n\nLANGUAGE: lisp\nCODE:\n```\n(program\n  (if\n    (call (identifier) (identifier))\n    (then (identifier)))\n  (call\n    (identifier)\n    (argument_list\n      (string (string_content))\n      (identifier)\n      (pair (hash_key_symbol) (string (string_content)))))\n  (call\n    (identifier)\n    (argument_list\n      (string (string_content))\n      (identifier)\n      (pair (hash_key_symbol) (string (string_content)))))\n  (ERROR)\n  (call\n    (identifier)\n    (argument_list\n      (pair (hash_key_symbol) (string (string_content)))\n      (pair (hash_key_symbol) (hash (pair (hash_key_symbol) (instance_variable))))))\n  (call\n    (identifier)\n    (argument_list\n      (pair (hash_key_symbol) (string (string_content)))\n      (pair (hash_key_symbol) (simple_symbol)))\n    (do_block\n      (block_parameters\n        (identifier))\n      (body_statement\n        (call\n          (identifier)\n          (identifier)\n          (argument_list (simple_symbol) (string (string_content))))\n  (call\n    (identifier)\n    (identifier)\n    (argument_list\n      (simple_symbol)))\n  (call\n    (identifier)\n    (identifier)\n    (argument_list (string (string_content)))))))\n  (call\n    (identifier)\n    (argument_list (instance_variable))))\n```\n\n----------------------------------------\n\nTITLE: Parsing Document with Zero-width Token in Tree-sitter\nDESCRIPTION: This snippet shows the parsed tree structure of a document containing the text 'hello'. The parse tree indicates that the document contains a zero-width token, which is a token that doesn't correspond to any visible characters in the input.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/test/fixtures/test_grammars/epsilon_external_tokens/corpus.txt#2025-04-21_snippet_0\n\nLANGUAGE: tree-sitter\nCODE:\n```\n(document (zero_width))\n```\n\n----------------------------------------\n\nTITLE: Defining Anonymous Token with Character Class in Tree-sitter\nDESCRIPTION: This snippet demonstrates how to define an anonymous token using a character class in a Tree-sitter grammar. It uses numeric characters as an example.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/test/fixtures/test_grammars/anonymous_tokens_with_escaped_chars/corpus.txt#2025-04-21_snippet_0\n\nLANGUAGE: tree-sitter\nCODE:\n```\n1234\n---\n\n(first_rule)\n```\n\n----------------------------------------\n\nTITLE: Long Sequences of Invalid Tokens in JavaScript\nDESCRIPTION: This example shows how tree-sitter handles a long sequence of invalid tokens (question marks) within a function. The parser maintains the overall function structure while marking the invalid part as an ERROR node.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/test/fixtures/error_corpus/javascript_errors.txt#2025-04-21_snippet_7\n\nLANGUAGE: javascript\nCODE:\n```\nfunction main(x) {\n  console.log('a');\n  what??????????????????????????????????????????????????\n  console.log('b');\n  return {};\n}\n```\n\nLANGUAGE: scheme\nCODE:\n```\n(program\n  (function_declaration\n    (identifier)\n    (formal_parameters (identifier))\n    (statement_block\n      (expression_statement\n        (call_expression\n          (member_expression (identifier) (property_identifier))\n          (arguments (string (string_fragment)))))\n      (expression_statement\n        (binary_expression\n          (identifier)\n          (ERROR)\n          (call_expression\n            (member_expression (identifier) (property_identifier))\n            (arguments (string (string_fragment))))))\n      (return_statement (object)))))\n```\n\n----------------------------------------\n\nTITLE: Parsing Element at Even Column Position with Tree-sitter\nDESCRIPTION: Example showing tree-sitter parsing 'x' at an even column position (column 2). The parser correctly identifies and categorizes this as an 'even_column' node within an 'x_is_at' parent node.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/test/fixtures/test_grammars/depends_on_column/corpus.txt#2025-04-21_snippet_1\n\nLANGUAGE: text\nCODE:\n```\n  x\n```\n\nLANGUAGE: tree-sitter-grammar\nCODE:\n```\n(x_is_at\n  (even_column))\n```\n\n----------------------------------------\n\nTITLE: Parsing Multi-line Statements with Internal Tokens in Tree-sitter\nDESCRIPTION: Example showing how tree-sitter parses a multi-line statement with internal tokens. Despite the line break, the parser still recognizes this as a single statement containing two variable nodes.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/test/fixtures/test_grammars/external_and_internal_anonymous_tokens/corpus.txt#2025-04-21_snippet_1\n\nLANGUAGE: tree-sitter\nCODE:\n```\na\nb\n```\n\nLANGUAGE: tree-sitter\nCODE:\n```\n(statement (variable) (variable))\n```\n\n----------------------------------------\n\nTITLE: Installing Web-tree-sitter Dependencies\nDESCRIPTION: Command to install the necessary npm dependencies for Web-tree-sitter development.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/lib/binding_web/CONTRIBUTING.md#2025-04-21_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\nnpm install\n```\n\n----------------------------------------\n\nTITLE: Extra Identifiers in JavaScript Expressions\nDESCRIPTION: This snippet contains extra identifiers in places where they don't belong syntactically. Tree-sitter identifies these as ERROR nodes in the parse tree, maintaining the overall structure while flagging the problematic parts.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/test/fixtures/error_corpus/javascript_errors.txt#2025-04-21_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nif (a b) {\n  c d;\n}\ne f;\n```\n\nLANGUAGE: scheme\nCODE:\n```\n(program\n  (if_statement\n    (parenthesized_expression\n      (identifier)\n      (ERROR (identifier)))\n    (statement_block\n      (ERROR (identifier))\n      (expression_statement (identifier))))\n  (expression_statement\n    (identifier)\n    (ERROR (identifier))))\n```\n\n----------------------------------------\n\nTITLE: Generating WASM Modules for Testing\nDESCRIPTION: Command to build the WASM modules required for testing.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/lib/binding_web/CONTRIBUTING.md#2025-04-21_snippet_6\n\nLANGUAGE: sh\nCODE:\n```\ncargo xtask generate-fixtures --wasm\n```\n\n----------------------------------------\n\nTITLE: Regenerating Test Parsers for Tree-sitter\nDESCRIPTION: Command to regenerate test parsers using your current CLI code for testing purposes.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/docs/src/6-contributing.md#2025-04-21_snippet_6\n\nLANGUAGE: sh\nCODE:\n```\ncargo xtask generate-fixtures\n```\n\n----------------------------------------\n\nTITLE: Parsing Line Breaks with Leading Whitespace\nDESCRIPTION: Shows how Tree-sitter handles line breaks followed by whitespace indentation. Demonstrates AST structure for simple identifiers with consistent indentation.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/test/fixtures/test_grammars/inverted_external_token/corpus.txt#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\na\n  b\n  c\n```\n\nLANGUAGE: tree-sitter\nCODE:\n```\n(program\n  (statement (identifier) (line_break))\n  (statement (identifier) (line_break))\n  (statement (identifier) (line_break)))\n```\n\n----------------------------------------\n\nTITLE: Handling Missing Semicolons in Top-level Declarations\nDESCRIPTION: Shows C code with missing semicolons in global variable declarations, demonstrating how Tree-sitter handles syntax errors at the top level of a file.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/test/fixtures/error_corpus/c_errors.txt#2025-04-21_snippet_2\n\nLANGUAGE: c\nCODE:\n```\nint x\nstatic int b\n```\n\n----------------------------------------\n\nTITLE: Generating Parser.c Files for Testing\nDESCRIPTION: Optional command to update the generated parser.c files for testing.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/lib/binding_web/CONTRIBUTING.md#2025-04-21_snippet_5\n\nLANGUAGE: sh\nCODE:\n```\ncargo xtask generate-fixtures\n```\n\n----------------------------------------\n\nTITLE: Handling Missing Variable Names in Declarations\nDESCRIPTION: Shows C code with missing variable names in declarations, demonstrating how Tree-sitter identifies these omissions as errors in the parse tree with MISSING nodes.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/test/fixtures/error_corpus/c_errors.txt#2025-04-21_snippet_14\n\nLANGUAGE: c\nCODE:\n```\nint a() {\n  struct x = 1;\n  int = 2;\n}\n```\n\n----------------------------------------\n\nTITLE: Parsing Uppercase Unicode Characters with Tree-sitter\nDESCRIPTION: Test case showing how tree-sitter categorizes various uppercase Unicode characters from different scripts. The parse result shows each character recognized as an 'upper' node in the syntax tree.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/test/fixtures/test_grammars/unicode_classes/corpus.txt#2025-04-21_snippet_0\n\nLANGUAGE: tree-sitter\nCODE:\n```\n          \n\n---\n\n(program\n  (upper) (upper) (upper) (upper) (upper) (upper))\n```\n\n----------------------------------------\n\nTITLE: Building Tree-sitter CLI with Faster Compilation\nDESCRIPTION: Commands to build the Tree-sitter CLI with a faster compilation profile for development iterations.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/docs/src/6-contributing.md#2025-04-21_snippet_4\n\nLANGUAGE: sh\nCODE:\n```\ncargo build --release --profile release-dev\n# or\ncargo install --path cli --profile release-dev\n```\n\n----------------------------------------\n\nTITLE: Parsing Function Call with Block Argument in Tree-sitter\nDESCRIPTION: This example demonstrates the syntax and corresponding AST structure for a function call that takes both a regular expression argument and a block argument. The AST shows how Tree-sitter recognizes and hierarchically organizes the function identifier, expression argument, and block containing another expression.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/test/fixtures/test_grammars/precedence_on_single_child_negative/corpus.txt#2025-04-21_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\nfoo bar { baz }\n```\n\nLANGUAGE: tree-sitter\nCODE:\n```\n(expression (function_call\n  (identifier)\n  (expression (identifier))\n  (block (expression (identifier)))))\n```\n\n----------------------------------------\n\nTITLE: Adding Tree-sitter and Language Dependencies in Cargo.toml\nDESCRIPTION: Specifies the Tree-sitter core library and a specific language grammar (Rust in this case) as dependencies in the Cargo.toml file.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/lib/binding_rust/README.md#2025-04-21_snippet_2\n\nLANGUAGE: toml\nCODE:\n```\n[dependencies]\ntree-sitter = \"0.24\"\ntree-sitter-rust = \"0.23\"\n```\n\n----------------------------------------\n\nTITLE: Handling Extra Identifiers in C Declarations\nDESCRIPTION: Shows C code with extra identifiers in declarations, demonstrating how Tree-sitter identifies and marks these unexpected elements as errors in the parse tree.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/test/fixtures/error_corpus/c_errors.txt#2025-04-21_snippet_12\n\nLANGUAGE: c\nCODE:\n```\nfloat x WTF;\nint y = 5;\n```\n\n----------------------------------------\n\nTITLE: Parsing Single-line Statements with Internal Tokens in Tree-sitter\nDESCRIPTION: Example showing how tree-sitter parses a single-line statement containing two internal token variables. The parser recognizes this as a statement containing two variable nodes.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/test/fixtures/test_grammars/external_and_internal_anonymous_tokens/corpus.txt#2025-04-21_snippet_0\n\nLANGUAGE: tree-sitter\nCODE:\n```\na b\n```\n\nLANGUAGE: tree-sitter\nCODE:\n```\n(statement (variable) (variable))\n```\n\n----------------------------------------\n\nTITLE: Running Web-tree-sitter Tests\nDESCRIPTION: Command to execute the test suite for Web-tree-sitter using vitest.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/lib/binding_web/CONTRIBUTING.md#2025-04-21_snippet_7\n\nLANGUAGE: sh\nCODE:\n```\nnpm test\n```\n\n----------------------------------------\n\nTITLE: Tree-sitter Grammar Interpretations\nDESCRIPTION: Demonstrates two possible interpretations of the ambiguous sequence - either as an expression containing an identifier, or as a function call with a block.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/test/fixtures/test_grammars/precedence_on_single_child_missing/expected_error.txt#2025-04-21_snippet_1\n\nLANGUAGE: tree-sitter\nCODE:\n```\n1:  identifier  (expression  identifier)    '{'  \n2:  identifier  (function_call  identifier    block)  (precedence: 0, associativity: Right)\n```\n\n----------------------------------------\n\nTITLE: Parsing Top-Level JSON Syntax Error\nDESCRIPTION: Shows how Tree-sitter handles a completely invalid JSON document with mismatched brackets. The parser produces an ERROR node at the document level.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/test/fixtures/error_corpus/json_errors.txt#2025-04-21_snippet_0\n\nLANGUAGE: json\nCODE:\n```\n[}\n```\n\nLANGUAGE: tree-sitter\nCODE:\n```\n(document\n  (ERROR))\n```\n\n----------------------------------------\n\nTITLE: Tagging a Release Version in Git Repository\nDESCRIPTION: Git command to create a version tag for the release. The tag uses the conventional 'v' prefix followed by the version number.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/docs/src/creating-parsers/6-publishing.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ngit tag -- v1.0.0\n```\n\n----------------------------------------\n\nTITLE: Parse Tree for Extra Values in Parenthesized Expressions\nDESCRIPTION: Displays the Tree-sitter parse tree for code with extra values in parenthesized expressions, showing how the first value is marked as an ERROR within the parenthesized expression.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/test/fixtures/error_corpus/c_errors.txt#2025-04-21_snippet_11\n\nLANGUAGE: lisp\nCODE:\n```\n(translation_unit\n  (function_definition\n    (primitive_type)\n    (function_declarator (identifier) (parameter_list))\n    (compound_statement\n      (declaration (primitive_type) (init_declarator\n        (identifier)\n        (parenthesized_expression\n          (ERROR (number_literal))\n          (number_literal)))))))\n```\n\n----------------------------------------\n\nTITLE: Fetching Test Grammar Fixtures\nDESCRIPTION: Command to fetch upstream grammars used for testing Web-tree-sitter.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/lib/binding_web/CONTRIBUTING.md#2025-04-21_snippet_4\n\nLANGUAGE: sh\nCODE:\n```\ncargo xtask fetch-fixtures\n```\n\n----------------------------------------\n\nTITLE: Debugging Tree-sitter Tests\nDESCRIPTION: Command to run tests under a debugger (lldb or gdb) using the -g flag.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/docs/src/6-contributing.md#2025-04-21_snippet_10\n\nLANGUAGE: sh\nCODE:\n```\ncargo xtask test -g test_does_something\n```\n\n----------------------------------------\n\nTITLE: Defining Anonymous Token with CR Escape Sequence in Tree-sitter\nDESCRIPTION: This snippet illustrates the structure for defining an anonymous token using a Carriage Return (CR) escape sequence in a Tree-sitter grammar. The actual escape sequence is not visible in the provided code.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/test/fixtures/test_grammars/anonymous_tokens_with_escaped_chars/corpus.txt#2025-04-21_snippet_2\n\nLANGUAGE: tree-sitter\nCODE:\n```\n\n---\n\n(first_rule)\n```\n\n----------------------------------------\n\nTITLE: Installing Tree-sitter TypeScript API\nDESCRIPTION: Shell command to install the Tree-sitter TypeScript API from npm, which provides documentation and type information for editing the grammar.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/docs/src/creating-parsers/1-getting-started.md#2025-04-21_snippet_6\n\nLANGUAGE: sh\nCODE:\n```\nnpm install # or your package manager of choice\n```\n\n----------------------------------------\n\nTITLE: Handling Incomplete Expressions in Conditional Statements\nDESCRIPTION: Shows C code with incomplete or malformed expressions in if statements, demonstrating how Tree-sitter handles both a missing field identifier and a missing operand for a pointer dereference.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/test/fixtures/error_corpus/c_errors.txt#2025-04-21_snippet_6\n\nLANGUAGE: c\nCODE:\n```\nint main() {\n  if (a.) {\n    b();\n    c();\n\n    if (*) d();\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Installing the Tree-sitter CLI\nDESCRIPTION: Command to install the Tree-sitter CLI tool on your system using Cargo.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/docs/src/6-contributing.md#2025-04-21_snippet_3\n\nLANGUAGE: sh\nCODE:\n```\ncargo install --path cli\n```\n\n----------------------------------------\n\nTITLE: Cloning the Tree-sitter Repository\nDESCRIPTION: Commands to clone the Tree-sitter repository from GitHub and navigate to the project directory.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/docs/src/6-contributing.md#2025-04-21_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\ngit clone https://github.com/tree-sitter/tree-sitter\ncd tree-sitter\n```\n\n----------------------------------------\n\nTITLE: Parsing Single Markdown List without Checkboxes in Tree-sitter\nDESCRIPTION: This grammar snippet defines the structure for a single Markdown list without checkbox indicators. It captures a list with three empty list items.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/test/fixtures/test_grammars/external_unicode_column_alignment/corpus.txt#2025-04-21_snippet_0\n\nLANGUAGE: tree-sitter\nCODE:\n```\n(expression\n  (list\n    (list_item)\n    (list_item)\n    (list_item)\n  )\n)\n```\n\n----------------------------------------\n\nTITLE: Handling Regex Patterns with Keyword-Like Content\nDESCRIPTION: This snippet shows how Tree-sitter correctly parses regular expressions that contain text resembling keywords, demonstrating that keyword recognition doesn't interfere with regex pattern parsing.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/test/fixtures/test_grammars/reserved_words/corpus.txt#2025-04-21_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\nvar a = /reserved-words-should-not-affect-this/;\nvar d = /if/;\n```\n\nLANGUAGE: lisp\nCODE:\n```\n(program\n  (var_declaration\n    (identifier)\n    (regex (regex_pattern)))\n  (var_declaration\n    (identifier)\n    (regex (regex_pattern))))\n```\n\n----------------------------------------\n\nTITLE: Importing Debug Version of Web Tree-sitter\nDESCRIPTION: This snippet shows how to import the debug version of Web Tree-sitter, which includes debug symbols and assertions.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/lib/binding_web/README.md#2025-04-21_snippet_5\n\nLANGUAGE: javascript\nCODE:\n```\nimport { Parser } from 'web-tree-sitter/debug'; // or require('web-tree-sitter/debug')\n\nParser.init().then(() => { /* the library is ready */ });\n```\n\n----------------------------------------\n\nTITLE: Adding Tree-sitter Build Dependency in Cargo.toml\nDESCRIPTION: Adds the 'cc' crate as a build dependency in the Cargo.toml file. This is required for building Tree-sitter language parsers.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/lib/binding_rust/README.md#2025-04-21_snippet_1\n\nLANGUAGE: toml\nCODE:\n```\n[build-dependencies]\ncc=\"*\"\n```\n\n----------------------------------------\n\nTITLE: Info Admonition Block\nDESCRIPTION: Markdown-style admonition block providing information about logging functionality in the browser console.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/docs/src/7-playground.md#2025-04-21_snippet_2\n\nLANGUAGE: Markdown\nCODE:\n```\n```admonish info\nLogging (if enabled) can be viewed in the browser's console.\n```\n```\n\n----------------------------------------\n\nTITLE: C Standard Library Function References\nDESCRIPTION: A collection of standard C library function names, including memory allocation (calloc, malloc), string operations (strcmp, strlen), memory operations (memcpy, memset), and character classification (iswalnum, iswdigit) functions.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/lib/src/wasm/stdlib-symbols.txt#2025-04-21_snippet_0\n\nLANGUAGE: C\nCODE:\n```\n\"calloc\",\n\"free\",\n\"iswalnum\",\n\"iswalpha\",\n\"iswblank\",\n\"iswdigit\",\n\"iswlower\",\n\"iswspace\",\n\"iswupper\",\n\"iswxdigit\",\n\"malloc\",\n\"memchr\",\n\"memcmp\",\n\"memcpy\",\n\"memmove\",\n\"memset\",\n\"realloc\",\n\"strcmp\",\n\"strlen\",\n\"strncat\",\n\"strncmp\",\n\"strncpy\",\n\"towlower\",\n\"towupper\",\n```\n\n----------------------------------------\n\nTITLE: Installing mdbook-admonish for Tree-sitter Documentation\nDESCRIPTION: Command to install the mdbook-admonish preprocessor for adding admonitions to Tree-sitter documentation.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/docs/src/6-contributing.md#2025-04-21_snippet_13\n\nLANGUAGE: sh\nCODE:\n```\ncargo install mdbook-admonish\n```\n\n----------------------------------------\n\nTITLE: Syntax Tree for Ruby Heredoc Example\nDESCRIPTION: A scheme representation of the syntax tree for the Ruby heredoc example, showing the structure of the method call and the heredoc content that could be injected with another language parser.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/docs/src/3-syntax-highlighting.md#2025-04-21_snippet_9\n\nLANGUAGE: scheme\nCODE:\n```\n(program\n  (method_call\n    method: (identifier)\n    arguments: (argument_list\n      (call\n        receiver: (heredoc_beginning)\n        method: (identifier))))\n  (heredoc_body\n    (heredoc_end)))\n```\n\n----------------------------------------\n\nTITLE: Mentioning Tree-sitter Command-line Program in Markdown\nDESCRIPTION: This snippet mentions the `tree-sitter` command-line program and its ability to dynamically find and build grammars at runtime. It introduces the purpose of the helper crate.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/cli/loader/README.md#2025-04-21_snippet_0\n\nLANGUAGE: Markdown\nCODE:\n```\nThe `tree-sitter` command-line program will dynamically find and build grammars\nat runtime, if you have cloned the grammars' repositories to your local\nfilesystem.\n```\n\n----------------------------------------\n\nTITLE: Running Specific Tree-sitter Tests\nDESCRIPTION: Command to run a specific test by name or partial name.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/docs/src/6-contributing.md#2025-04-21_snippet_9\n\nLANGUAGE: sh\nCODE:\n```\ncargo xtask test test_does_something\n```\n\n----------------------------------------\n\nTITLE: Running Tests for Specific Language and Example\nDESCRIPTION: Command to run tests for a specific language and corpus example in Tree-sitter.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/docs/src/6-contributing.md#2025-04-21_snippet_11\n\nLANGUAGE: sh\nCODE:\n```\ncargo xtask test -l javascript -e Arrays\n```\n\n----------------------------------------\n\nTITLE: Parsing Nested Method Calls with Tree-sitter\nDESCRIPTION: This snippet shows a complex method call expression with nested calls and member access, followed by its Tree-sitter AST representation. It demonstrates how Tree-sitter breaks down the expression into its component parts.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/test/fixtures/test_grammars/aliased_rules/corpus.txt#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n*a.b(c(d.e));\n```\n\nLANGUAGE: tree-sitter\nCODE:\n```\n(statement\n  (star)\n  (call_expression\n    (member_expression\n      (variable_name)\n      (property_name))\n    (call_expression\n      (variable_name)\n      (member_expression\n        (variable_name)\n        (property_name)))))\n```\n\n----------------------------------------\n\nTITLE: Declaration Examples in Tree-sitter\nDESCRIPTION: Examples of declaration syntax showing alternative type expressions and variable assignment. The first line demonstrates using the OR operator in a type, while the second shows member access in a type.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/test/fixtures/test_grammars/named_precedences/corpus.txt#2025-04-21_snippet_0\n\nLANGUAGE: c-like\nCODE:\n```\nA||B c = d;\nE.F g = h;\n```\n\n----------------------------------------\n\nTITLE: Node Type with Fields Definition in node-types.json\nDESCRIPTION: Example of a node type with fields that describe the possible children with specific roles. Each field includes information about whether children are required, can appear multiple times, and what types they can be.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/docs/src/using-parsers/6-static-node-types.md#2025-04-21_snippet_1\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"type\": \"method_definition\",\n  \"named\": true,\n  \"fields\": {\n    \"body\": {\n      \"multiple\": false,\n      \"required\": true,\n      \"types\": [{ \"type\": \"statement_block\", \"named\": true }]\n    },\n    \"decorator\": {\n      \"multiple\": true,\n      \"required\": false,\n      \"types\": [{ \"type\": \"decorator\", \"named\": true }]\n    },\n    \"name\": {\n      \"multiple\": false,\n      \"required\": true,\n      \"types\": [\n        { \"type\": \"computed_property_name\", \"named\": true },\n        { \"type\": \"property_identifier\", \"named\": true }\n      ]\n    },\n    \"parameters\": {\n      \"multiple\": false,\n      \"required\": true,\n      \"types\": [{ \"type\": \"formal_parameters\", \"named\": true }]\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Serving Tree-sitter Documentation Locally\nDESCRIPTION: Commands to navigate to the documentation directory and start a local server with live reloading.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/docs/src/6-contributing.md#2025-04-21_snippet_14\n\nLANGUAGE: sh\nCODE:\n```\ncd docs\nmdbook serve --open\n```\n\n----------------------------------------\n\nTITLE: Tree-sitter AST Representation of Arithmetic Expressions\nDESCRIPTION: The abstract syntax tree (AST) generated by Tree-sitter parser for the arithmetic expressions. Shows how the parser correctly handles operator precedence and parentheses.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/test/fixtures/test_grammars/inline_rules/corpus.txt#2025-04-21_snippet_1\n\nLANGUAGE: tree-sitter\nCODE:\n```\n(program\n  (statement (sum\n    (number)\n    (product (number) (number))))\n  (statement (sum\n    (product (number) (number))\n    (number)))\n  (statement (product\n    (number)\n    (parenthesized_expression (sum (number) (number))))))\n```\n\n----------------------------------------\n\nTITLE: Running Specific Tree-sitter Tests with Command Line Options\nDESCRIPTION: Shows how to run a specific test using the tree-sitter command line tool with the -i flag to filter by test name.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/docs/src/creating-parsers/5-writing-tests.md#2025-04-21_snippet_3\n\nLANGUAGE: sh\nCODE:\n```\ntree-sitter test -i 'Return statements'\n```\n\n----------------------------------------\n\nTITLE: Parsing Errors Within JSON Arrays\nDESCRIPTION: Shows how Tree-sitter handles a missing element in a JSON array. The parser recognizes the empty position between commas as an ERROR node while still parsing valid elements.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/test/fixtures/error_corpus/json_errors.txt#2025-04-21_snippet_2\n\nLANGUAGE: json\nCODE:\n```\n[1, , 2]\n```\n\nLANGUAGE: tree-sitter\nCODE:\n```\n(document\n  (array\n    (number)\n    (ERROR)\n    (number)))\n```\n\n----------------------------------------\n\nTITLE: Parsing JavaScript Member Expression with Tree-sitter\nDESCRIPTION: This example demonstrates how Tree-sitter parses a simple JavaScript member expression 'a.b.c'. The parse tree shows the hierarchical structure of the expression, breaking it down into nested member expressions and identifying variable and property names.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/test/fixtures/test_grammars/aliased_inlined_rules/corpus.txt#2025-04-21_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\na.b.c;\n```\n\nLANGUAGE: Tree-sitter\nCODE:\n```\n(statement\n  (member_expression\n    (member_expression\n      (variable_name)\n      (property_name))\n    (property_name)))\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Shift/Reduce Conflict in Ruby-like Function Calls\nDESCRIPTION: This code snippet shows an ambiguous syntax case where the parser must decide whether 'bar' is an expression argument to 'foo' or a function being called with a block. The caret indicates the position where the parser encounters the conflict.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/test/fixtures/test_grammars/precedence_on_single_child_missing/readme.md#2025-04-21_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\nfoo bar { baz }\n       ^\n```\n\n----------------------------------------\n\nTITLE: Parse Tree for Missing Semicolons in Function Statements\nDESCRIPTION: Shows the Tree-sitter parse tree representation of C code with missing semicolons after function calls, identifying each missing semicolon with a MISSING token.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/test/fixtures/error_corpus/c_errors.txt#2025-04-21_snippet_1\n\nLANGUAGE: lisp\nCODE:\n```\n(translation_unit\n  (function_definition\n    (primitive_type)\n    (function_declarator (identifier) (parameter_list))\n    (compound_statement\n      (expression_statement (call_expression (identifier) (argument_list (string_literal (string_content)))) (MISSING \";\"))\n      (expression_statement (call_expression (identifier) (argument_list (string_literal (string_content)))) (MISSING \";\")))))\n```\n\n----------------------------------------\n\nTITLE: Parsing Errors Within Nested JSON Objects\nDESCRIPTION: Shows how Tree-sitter handles complex errors in nested JSON structures. The parser correctly identifies multiple errors, including an invalid number in an object and an unexpected bracket.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/test/fixtures/error_corpus/json_errors.txt#2025-04-21_snippet_4\n\nLANGUAGE: json\nCODE:\n```\n{ \"key1\": { \"key2\": 1, 2 }, \"key3\": 3 [ }\n```\n\nLANGUAGE: tree-sitter\nCODE:\n```\n(document\n  (object\n    (pair\n      (string\n        (string_content))\n      (object\n        (pair\n          (string\n            (string_content))\n          (number))\n        (ERROR\n          (number))))\n    (pair\n      (string\n        (string_content))\n      (number))\n    (ERROR)))\n```\n\n----------------------------------------\n\nTITLE: Building Web-tree-sitter Library\nDESCRIPTION: Command to build the Web-tree-sitter library which requires a Rust toolchain to be installed.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/lib/binding_web/CONTRIBUTING.md#2025-04-21_snippet_2\n\nLANGUAGE: sh\nCODE:\n```\nnpm run build\n```\n\n----------------------------------------\n\nTITLE: Handling Unterminated Blocks in Tree-sitter\nDESCRIPTION: This snippet shows how Tree-sitter handles an unterminated block, resulting in an ERROR state. It demonstrates the parser's error handling capabilities when encountering incomplete structures.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/test/fixtures/test_grammars/uses_current_column/corpus.txt#2025-04-21_snippet_3\n\nLANGUAGE: tree-sitter\nCODE:\n```\ndo\n---\n\n(ERROR)\n```\n\n----------------------------------------\n\nTITLE: Installing mdBook for Tree-sitter Documentation\nDESCRIPTION: Command to install the mdBook CLI tool for developing Tree-sitter documentation locally.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/docs/src/6-contributing.md#2025-04-21_snippet_12\n\nLANGUAGE: sh\nCODE:\n```\ncargo install mdbook\n```\n\n----------------------------------------\n\nTITLE: Parsing Simple Blocks in Tree-sitter\nDESCRIPTION: This snippet demonstrates the parsing of a simple block structure with a do expression. It shows how Tree-sitter represents the block hierarchy and identifiers within the parse tree.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/test/fixtures/test_grammars/uses_current_column/corpus.txt#2025-04-21_snippet_0\n\nLANGUAGE: tree-sitter\nCODE:\n```\ndo a\n   e\nf\n\n---\n\n(block\n  (do_expression (block\n    (identifier)\n    (identifier)))\n  (identifier))\n```\n\n----------------------------------------\n\nTITLE: Scanner State Deserialization\nDESCRIPTION: Function to restore scanner state from a byte buffer. Used to reconstruct scanner state when handling edits or ambiguities.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/docs/src/creating-parsers/4-external-scanners.md#2025-04-21_snippet_5\n\nLANGUAGE: c\nCODE:\n```\nvoid tree_sitter_my_language_external_scanner_deserialize(\n  void *payload,\n  const char *buffer,\n  unsigned length\n) {\n  // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Parsing Unexpected Tokens in JSON\nDESCRIPTION: Demonstrates how Tree-sitter handles an unexpected token in a JSON document. The parser recognizes and marks the specific unexpected character 'b'.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/test/fixtures/error_corpus/json_errors.txt#2025-04-21_snippet_1\n\nLANGUAGE: json\nCODE:\n```\nbarf\n```\n\nLANGUAGE: tree-sitter\nCODE:\n```\n(document\n  (ERROR\n    (UNEXPECTED 'b')))\n```\n\n----------------------------------------\n\nTITLE: Parsing Extra Colon in Python Function Definition\nDESCRIPTION: Shows how Tree-sitter handles a Python function definition with an extra colon. The parser marks the syntax error with an ERROR node while still parsing the function body.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/test/fixtures/error_corpus/python_errors.txt#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ndef a()::\n  b\n  c\nd\n```\n\nLANGUAGE: scheme\nCODE:\n```\n(module\n  (function_definition\n    name: (identifier)\n    parameters: (parameters)\n    (ERROR)\n    body: (block\n      (expression_statement (identifier))\n      (expression_statement (identifier))))\n  (expression_statement (identifier)))\n```\n\n----------------------------------------\n\nTITLE: Cloning the Tree-sitter Repository\nDESCRIPTION: Commands to clone the Tree-sitter repository and navigate to the web binding directory.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/lib/binding_web/CONTRIBUTING.md#2025-04-21_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\ngit clone https://github.com/tree-sitter/tree-sitter\ncd tree-sitter/lib/binding_web\n```\n\n----------------------------------------\n\nTITLE: Parsing comments resembling regular expressions in JavaScript\nDESCRIPTION: This snippet illustrates how Tree-sitter handles a comment that could be mistaken for a regular expression. It shows that the comment token has higher precedence than the regex token in the lexer.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/test/fixtures/test_grammars/precedence_on_token/corpus.txt#2025-04-21_snippet_2\n\nLANGUAGE: JavaScript\nCODE:\n```\n/* hello */ui\n```\n\nLANGUAGE: Tree-sitter output\nCODE:\n```\n(program\n  (comment)\n  (comment)\n  (identifier))\n```\n\n----------------------------------------\n\nTITLE: Tree-sitter Include Directories\nDESCRIPTION: The include directories required when compiling Tree-sitter.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/docs/src/using-parsers/1-getting-started.md#2025-04-21_snippet_1\n\nLANGUAGE: plaintext\nCODE:\n```\ntree-sitter/lib/src\ntree-sitter/lib/include\n```\n\n----------------------------------------\n\nTITLE: Example Code with Comment Token in Tree-sitter\nDESCRIPTION: A simple code example showing a variable assignment with a comment in between. The example illustrates how tree-sitter represents and handles external tokens like comments in its parsing structure.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/test/fixtures/test_grammars/external_extra_tokens/corpus.txt#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nx = # a comment\ny\n```\n\nLANGUAGE: tree-sitter\nCODE:\n```\n(assignment (variable) (comment) (variable))\n```\n\n----------------------------------------\n\nTITLE: Parsing Single-Line Statements with Internal Tokens in Tree-Sitter\nDESCRIPTION: This snippet demonstrates how to parse a single-line statement containing two variables using Tree-Sitter grammar. It shows the input and the resulting abstract syntax tree (AST) structure.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/test/fixtures/test_grammars/external_and_internal_tokens/corpus.txt#2025-04-21_snippet_0\n\nLANGUAGE: tree-sitter\nCODE:\n```\na b\n\n---\n\n(statement (variable) (variable) (line_break))\n```\n\n----------------------------------------\n\nTITLE: Parsing Member Expressions with Line Breaks\nDESCRIPTION: Demonstrates how Tree-sitter parses member expressions split across multiple lines. Shows nested member access with dots and proper AST structure preservation.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/test/fixtures/test_grammars/inverted_external_token/corpus.txt#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\na\nb\n  .c\nd\n  .e\n  .f\n```\n\nLANGUAGE: tree-sitter\nCODE:\n```\n(program\n  (statement (identifier) (line_break))\n  (statement (member_expression (identifier) (identifier)) (line_break))\n  (statement (member_expression (member_expression (identifier) (identifier)) (identifier)) (line_break)))\n```\n\n----------------------------------------\n\nTITLE: Arithmetic Expressions Examples in JavaScript\nDESCRIPTION: Simple JavaScript arithmetic expressions demonstrating operator precedence rules with addition, multiplication and parenthesized expressions.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/test/fixtures/test_grammars/inline_rules/corpus.txt#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n1 + 2 * 3;\n4 * 5 + 6;\n7 * (8 + 9);\n```\n\n----------------------------------------\n\nTITLE: Syntax Tree Representation of Ruby Code\nDESCRIPTION: A scheme representation of the syntax tree for the Ruby list processing example, showing the hierarchical structure of methods, parameters, assignments, and method calls with blocks.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/docs/src/3-syntax-highlighting.md#2025-04-21_snippet_5\n\nLANGUAGE: scheme\nCODE:\n```\n(program\n  (method\n    name: (identifier)\n    parameters: (method_parameters\n      (identifier))\n    (assignment\n      left: (identifier)\n      right: (identifier))\n    (method_call\n      method: (call\n        receiver: (identifier)\n        method: (identifier))\n      block: (do_block\n        (block_parameters\n          (identifier))\n        (method_call\n          method: (identifier)\n          arguments: (argument_list\n            (identifier)\n            (identifier))))))\n  (assignment\n    left: (identifier)\n    right: (integer))\n  (assignment\n    left: (identifier)\n    right: (array\n      (identifier))))\n```\n\n----------------------------------------\n\nTITLE: Tree-sitter Grammar Input and AST Output\nDESCRIPTION: Shows a set of grammar input statements with labels and macros, followed by the corresponding AST structure. Demonstrates parsing of simple statements, macro statements, and label declarations with identifiers.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/test/fixtures/test_grammars/extra_non_terminals_with_shared_rules/corpus.txt#2025-04-21_snippet_0\n\nLANGUAGE: tree-sitter\nCODE:\n```\n;\n%;\n%foo:;\n;\nbar: baz:;\n;\n```\n\nLANGUAGE: tree-sitter\nCODE:\n```\n(program\n  (statement)\n  (macro_statement (statement))\n  (macro_statement (statement\n    (label_declaration (identifier))))\n  (statement)\n  (statement\n    (label_declaration (identifier))\n    (label_declaration (identifier)))\n  (statement))\n```\n\n----------------------------------------\n\nTITLE: Parsing Chained Mathematical Operations with Tree-sitter\nDESCRIPTION: This snippet shows how tree-sitter parses a simple mathematical expression 'x+y+z' into a nested tree structure. The parse tree demonstrates how tree-sitter handles operator precedence by nesting the first operation (x+y) within the second operation.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/test/fixtures/test_grammars/associativity_left/corpus.txt#2025-04-21_snippet_0\n\nLANGUAGE: text\nCODE:\n```\nx+y+z\n---\n(expression (math_operation\n  (expression (math_operation (expression (identifier)) (expression (identifier))))\n  (expression (identifier))))\n```\n\n----------------------------------------\n\nTITLE: Parsing C-style Pointer Declaration with Tree-sitter\nDESCRIPTION: Demonstrates how Tree-sitter parses a pointer declaration 'T * x', showing the resulting AST structure with declaration, type identifier and declarator nodes.\nSOURCE: https://github.com/tree-sitter/tree-sitter/blob/master/test/fixtures/test_grammars/dynamic_precedence/corpus.txt#2025-04-21_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nT * x\n```\n\nLANGUAGE: tree-sitter\nCODE:\n```\n(program (declaration\n  (type (identifier))\n  (declarator (identifier))))\n```"
  }
]