[
  {
    "owner": "reatom",
    "repo": "reatom",
    "content": "TITLE: Implementing Advanced Search Component with Reatom and React\nDESCRIPTION: This code snippet demonstrates how to create a Search component using Reatom for state management in a React application. It shows the usage of useAtom hook for managing search state, fetching issues, and handling loading states.\nSOURCE: https://github.com/reatom/reatom/blob/v3/README.md#2025-04-23_snippet_6\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useAtom } from '@reatom/npm-react'\n\nexport const Search = () => {\n  const [search, setSearch] = useAtom(searchAtom)\n  const [issues] = useAtom(fetchIssues.dataAtom)\n  // you could pass a callback to `useAtom` to create a computed atom\n  const [isLoading] = useAtom(\n    (ctx) =>\n      // even if there are no pending requests, we need to wait for retries\n      // let do not show the limit error to make him think that everything is fine for a better UX\n      ctx.spy(fetchIssues.pendingAtom) + ctx.spy(fetchIssues.retriesAtom) > 0,\n  )\n\n  return (\n    <main>\n      <input\n        value={search}\n        onChange={(e) => setSearch(e.currentTarget.value)}\n        placeholder=\"Search\"\n      />\n      {isLoading && 'Loading...'}\n      <ul>\n        {issues.map(({ title }, i) => (\n          <li key={i}>{title}</li>\n        ))}\n      </ul>\n    </main>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Reatom Context\nDESCRIPTION: Shows how to create a Reatom context instance for application-wide state management\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/src/content/docs/index.md#2025-04-23_snippet_2\n\nLANGUAGE: ts\nCODE:\n```\nimport { createCtx } from '@reatom/core'\n\nconst ctx = createCtx()\n```\n\n----------------------------------------\n\nTITLE: Implementing Optimistic Updates with Reatom Async\nDESCRIPTION: A comprehensive test example showing how to implement optimistic updates with rollback for data fetching. Demonstrates handling server errors, periodic data refreshing, and preventing unnecessary updates.\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/src/content/docs/package/async.md#2025-04-23_snippet_33\n\nLANGUAGE: typescript\nCODE:\n```\nimport { describe, test, expect } from 'vitest'\nimport { createTestCtx } from '@reatom/testing'\nimport { atom } from '@reatom/core'\nimport { onConnect } from '@reatom/hooks'\nimport { isDeepEqual, jsonClone, sleep } from '@reatom/utils'\n\nimport { reatomAsync, withAbort, withDataAtom } from '@reatom/async'\n\ndescribe('optimistic update', () => {\n  /*\n    The case: we have a list of items and we want to update one of them.\n    We want to update the list immediately, but we want to rollback the update\n    if the server returns an error.\n\n    Also, we use `onConnect` to fetch the list from the server every 5 seconds\n    and we don't want to call subscriptions extra times so we use `isDeepEqual`\n    in `withDataAtom` to prevent new reference stream if nothing really changed.\n  */\n\n  //#region BACKEND IMITATION\n  let mock = [{ id: 1, value: 1 }]\n  const api = {\n    getData: async () => jsonClone(mock),\n    putData: async (id: number, value: number) => {\n      const item = mock.find((item) => item.id === id)\n      if (item) item.value = value\n      await sleep()\n    },\n  }\n  //#endregion\n\n  // this is short for test purposes, use ~5000 in real code\n  const INTERVAL = 5\n\n  const getData = reatomAsync.from(api.getData).pipe(\n    // add `dataAtom` and map the effect payload into it\n    // try to prevent new reference stream if nothing really changed\n    withDataAtom([], (ctx, payload, state) =>\n      isDeepEqual(payload, state) ? state : payload,\n    ),\n  )\n  const putData = reatomAsync.from(api.putData)\n  putData.onCall((ctx, promise, params) => {\n    const [id, value] = params\n    const oldList = ctx.get(getData.dataAtom)\n    // optimistic update\n    const newList = getData.dataAtom(ctx, (state) =>\n      state.map((item) => (item.id === id ? { ...item, value } : item)),\n    )\n    // rollback on error\n    promise.catch((error) => {\n      if (ctx.get(getData.dataAtom) === newList) {\n        getData.dataAtom(ctx, oldList)\n      } else {\n        // TODO looks like user changed data again\n        // need to notify user about the conflict.\n      }\n      throw error\n    })\n  })\n\n  onConnect(getData.dataAtom, async (ctx) => {\n    while (ctx.isConnected()) {\n      await getData(ctx)\n      await sleep(INTERVAL)\n    }\n  })\n\n  test('optimistic update', async () => {\n    const ctx = createTestCtx()\n    const effectTrack = ctx.subscribeTrack(getData.onFulfill)\n    const dataTrack = ctx.subscribeTrack(getData.dataAtom)\n\n    // every subscription calls passed callback immediately\n    expect(effectTrack.calls.length).toBe(1)\n    expect(dataTrack.calls.length).toBe(1)\n    expect(dataTrack.lastInput()).toEqual([])\n\n    // `onConnect` calls `fetchData`, wait it and check changes\n    await sleep()\n    expect(dataTrack.calls.length).toBe(2)\n    expect(dataTrack.lastInput()).toEqual([{ id: 1, value: 1 }])\n\n    // call `updateData` and check changes\n    putData(ctx, 1, 2)\n    expect(dataTrack.calls.length).toBe(3)\n    expect(dataTrack.lastInput()).toEqual([{ id: 1, value: 2 }])\n\n    // wait for `fetchData` and check changes\n    expect(effectTrack.calls.length).toBe(2)\n    await sleep(INTERVAL)\n    // the effect is called again, but dataAtom is not updated\n    expect(effectTrack.calls.length).toBe(3)\n    expect(dataTrack.calls.length).toBe(3)\n\n    // cleanup test\n    dataTrack.unsubscribe()\n  })\n})\n\ndescribe('concurrent pooling', () => {\n  /*\n    The case: we have a long-running task and we want to pool it's progress\n    every 5 seconds. We want to abort the previous pooling if the new one\n    was started. The problem with the most tooling for async management is that no causes tracking\n    and we can't abort some step of the previous pooling if the new one was started.\n    Reatom handle it perfectly, because `ctx` is immutable and could be traced when needed.\n  */\n\n  //#region BACKEND IMITATION\n  const tasks = new Map<number, number>()\n  const api = {\n    async createTask() {\n      return Math.random()\n    },\n    async poolTask(taskId: number) {\n      await sleep(5)\n      const progress = (tasks.get(taskId) ?? -10) + 10\n      tasks.set(taskId, progress)\n\n      return progress\n    },\n  }\n  //#endregion\n\n  const createTask = reatomAsync.from(api.createTask)\n  const poolTask = reatomAsync.from(api.poolTask)\n\n  const progressAtom = atom(0)\n\n  const search = reatomAsync(async (ctx) => {\n    const taskId = await createTask(ctx)\n\n    while (true) {\n      const progress = await poolTask(ctx, taskId)\n      progressAtom(ctx, progress)\n\n      if (progress === 100) return\n    }\n  }).pipe(withAbort({ strategy: 'last-in-win' }))\n\n  test('concurrent pooling', async () => {\n    const ctx = createTestCtx()\n    const track = ctx.subscribeTrack(progressAtom)\n\n    const promise1 = search(ctx)\n    await sleep(15)\n    const promise2 = search(ctx)\n\n    await Promise.allSettled([promise1, promise2])\n\n    expect(ctx.get(progressAtom)).toBe(100)\n\n    const expectedProgress = [\n      0, 10, /* start again */ 0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100,\n    ]\n\n    // TODO time flickering\n    // expect(track.inputs()).toEqual(expectedProgress)\n  })\n})\n```\n\n----------------------------------------\n\nTITLE: Implementing a Search Component with Reatom in React\nDESCRIPTION: A React component demonstrating Reatom's integration with React using the useAtom hook. Shows how to manage state for a search input, handle loading states with computed atoms, and display search results.\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/src/content/docs/index.md#2025-04-23_snippet_6\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useAtom } from '@reatom/npm-react'\n\nexport const Search = () => {\n  const [search, setSearch] = useAtom(searchAtom)\n  const [issues] = useAtom(fetchIssues.dataAtom)\n  // you could pass a callback to `useAtom` to create a computed atom\n  const [isLoading] = useAtom(\n    (ctx) =>\n      // even if there are no pending requests, we need to wait for retries\n      // let do not show the limit error to make him think that everything is fine for a better UX\n      ctx.spy(fetchIssues.pendingAtom) + ctx.spy(fetchIssues.retriesAtom) > 0,\n  )\n\n  return (\n    <main>\n      <input\n        value={search}\n        onChange={(e) => setSearch(e.currentTarget.value)}\n        placeholder=\"Search\"\n      />\n      {isLoading && 'Loading...'}\n      <ul>\n        {issues.map(({ title }, i) => (\n          <li key={i}>{title}</li>\n        ))}\n      </ul>\n    </main>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Reatom Context\nDESCRIPTION: Demonstrates how to create a Reatom context, which is essential for reading, modifying, and subscribing to changes in atoms.\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/src/content/docs/getting-started/learning.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createCtx } from '@reatom/framework'\nconst ctx = createCtx()\n```\n\n----------------------------------------\n\nTITLE: Basic Reatom Model Implementation\nDESCRIPTION: Demonstrates core Reatom concepts including atoms, actions, and context handling for a simple greeting application\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/src/content/docs/index.md#2025-04-23_snippet_1\n\nLANGUAGE: ts\nCODE:\n```\nimport { action, atom } from '@reatom/core'\n\nconst initState = localStorage.getItem('name') ?? ''\nexport const inputAtom = atom(initState)\n\nexport const greetingAtom = atom((ctx) => {\n  // `spy` dynamically reads the atom and subscribes to it\n  const input = ctx.spy(inputAtom)\n  return input ? `Hello, ${input}!` : ''\n})\n\nexport const onSubmit = action((ctx) => {\n  const input = ctx.get(inputAtom)\n  ctx.schedule(() => {\n    localStorage.setItem('name', input)\n  })\n})\n```\n\n----------------------------------------\n\nTITLE: Creating Basic and Computed Atoms in Reatom\nDESCRIPTION: Shows how to create basic atoms with initial values and names, as well as a computed atom that depends on other atoms.\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/src/content/docs/getting-started/learning.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { atom } from '@reatom/framework'\nconst aAtom = atom(1, 'aAtom')\nconst bAtom = atom(2, 'bAtom')\nconst cAtom = atom((ctx) => ctx.spy(aAtom) + ctx.spy(bAtom), 'cAtom')\n```\n\n----------------------------------------\n\nTITLE: Implementing On-Demand Data Fetching with Reatom in TypeScript\nDESCRIPTION: This snippet demonstrates how to create a reusable async atom for fetching data on demand using Reatom. It combines the 'async' and 'hooks' packages to automatically fetch data when the atom is connected.\nSOURCE: https://github.com/reatom/reatom/blob/v3/packages/async/README.md#2025-04-23_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nimport { reatomAsync, withDataAtom } from '@reatom/async'\nimport { onConnect } from '@reatom/hooks'\n\nexport const fetchList = reatomAsync(\n  (ctx) => request('api/list', ctx.controller),\n  'fetchList',\n).pipe(withDataAtom([]))\nonConnect(fetchList.dataAtom, fetchList)\n```\n\n----------------------------------------\n\nTITLE: Creating a Form with Validation in TypeScript using @reatom/form\nDESCRIPTION: Example showing how to create a login form with field-level validation using the reatomForm API. Includes async onSubmit handler and password validation.\nSOURCE: https://github.com/reatom/reatom/blob/v3/packages/form/README.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { reatomForm } from '@reatom/form'\n\nexport const loginForm = reatomForm(\n  {\n    async onSubmit(ctx) {\n      const user = await api.login(ctx, {\n        name: ctx.get(nameField),\n        password: ctx.get(passwordField),\n      })\n    },\n  },\n  'loginForm',\n)\nexport const nameField = loginForm.reatomField({ initState: '' }, 'nameField')\nexport const passwordField = loginForm.reatomField(\n  {\n    initState: '',\n    validate(ctx, { state }) {\n      if (state.length < 6)\n        throw new Error('The password should have at least six characters.')\n    },\n  },\n  'passwordField',\n)\n```\n\n----------------------------------------\n\nTITLE: Retry with Abort Pattern in Reatom\nDESCRIPTION: Shows how to combine retry logic with abort functionality and error handling. Limits retries to 7 attempts and implements a loading state indicator.\nSOURCE: https://github.com/reatom/reatom/blob/v3/packages/async/README.md#2025-04-23_snippet_20\n\nLANGUAGE: typescript\nCODE:\n```\nimport {\n  atom,\n  reatomAsync,\n  withAbort,\n  withErrorAtom,\n  withRetry,\n} from '@reatom/async'\n\nexport const fetchList = reatomAsync(\n  (ctx) => request('api/list', ctx.controller),\n  'fetchList',\n).pipe(\n  withAbort(),\n  withRetry({\n    onReject: (ctx, error, retries) => {\n      // try to retry the request only 7 times\n      if (retries < 7) {\n        return 100 * Math.min(200, retries ** 3)\n      }\n      // otherwise do nothing - prevent retrying and show the error\n    },\n  }),\n  withErrorAtom(),\n)\nexport const isFetchListLoading = atom(\n  (ctx) =>\n    ctx.spy(fetchList.pendingAtom) > 0 || ctx.spy(fetchList.retriesAtom) > 0,\n  'isFetchListLoading',\n)\n```\n\n----------------------------------------\n\nTITLE: Basic View Implementation with Reatom\nDESCRIPTION: Demonstrates how to connect Reatom state to DOM elements and handle user interactions\nSOURCE: https://github.com/reatom/reatom/blob/v3/README.md#2025-04-23_snippet_3\n\nLANGUAGE: ts\nCODE:\n```\nimport { inputAtom, greetingAtom, onSubmit } from './model'\n\nctx.subscribe(greetingAtom, (greeting) => {\n  document.getElementById('greeting')!.innerText = greeting\n})\n\ndocument.getElementById('name').addEventListener('input', (event) => {\n  inputAtom(ctx, event.currentTarget.value)\n})\ndocument.getElementById('save').addEventListener('click', () => {\n  onSubmit(ctx)\n})\n```\n\n----------------------------------------\n\nTITLE: Basic Reatom Model Implementation\nDESCRIPTION: Demonstrates core Reatom concepts including atoms, actions, and state management with local storage integration\nSOURCE: https://github.com/reatom/reatom/blob/v3/README.md#2025-04-23_snippet_1\n\nLANGUAGE: ts\nCODE:\n```\nimport { action, atom } from '@reatom/core'\n\nconst initState = localStorage.getItem('name') ?? ''\nexport const inputAtom = atom(initState)\n\nexport const greetingAtom = atom((ctx) => {\n  // `spy` dynamically reads the atom and subscribes to it\n  const input = ctx.spy(inputAtom)\n  return input ? `Hello, ${input}!` : ''\n})\n\nexport const onSubmit = action((ctx) => {\n  const input = ctx.get(inputAtom)\n  ctx.schedule(() => {\n    localStorage.setItem('name', input)\n  })\n})\n```\n\n----------------------------------------\n\nTITLE: Implementing Basic HTTP Request Helper in TypeScript\nDESCRIPTION: A simple fetch wrapper that handles HTTP requests and JSON parsing with error handling.\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/src/content/docs/package/async.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nasync function request<T>(...params: Parameters<typeof fetch>): Promise<T> {\n  const response = await fetch(...params)\n  if (!response.ok) throw new Error(response.statusText)\n  return await response.json()\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Periodic Data Refresh in Reatom\nDESCRIPTION: This snippet demonstrates how to implement a polling pattern for periodic data refresh using Reatom's onConnect utility. It refreshes data every 5 seconds while the component is connected.\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/src/content/docs/package/async.md#2025-04-23_snippet_24\n\nLANGUAGE: typescript\nCODE:\n```\nimport {\n  reatomAsync,\n  withDataAtom,\n  withRetry,\n  onConnect,\n  sleep,\n} from '@reatom/framework'\n\nexport const fetchList = reatomAsync(\n  (ctx, search: string) => request(`/api/list?q=${search}`, ctx.controller),\n  'fetchList',\n).pipe(withDataAtom([]), withRetry())\nonConnect(fetchList.dataAtom, async (ctx) => {\n  while (ctx.isConnected()) {\n    await fetchList.retry(ctx).catch(() => {})\n    await ctx.schedule(() => sleep(5000))\n  }\n})\n```\n\n----------------------------------------\n\nTITLE: Advanced reatomAsync Implementation with Loading State and Abort Strategy\nDESCRIPTION: A comprehensive example showing how to implement a complete async model with loading state handling and request abortion to prevent race conditions. It uses onCall hooks for reactive subscription to actions.\nSOURCE: https://github.com/reatom/reatom/blob/v3/packages/async/README.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\n// ~/features/entities/model.ts\nimport { reatomAsync } from '@reatom/async'\nimport { atom } from '@reatom/core'\n\ntype Element = {\n  id: string\n  /* ... */\n}\n\nexport const listAtom = atom(new Array<Element>(), 'listAtom')\nexport const errorAtom = atom<null | Error>(null, 'errorAtom')\n// if number of pending requests are equal or more than 1 - there is a loading state\nexport const isLoadingAtom = atom(\n  (ctx) => ctx.spy(fetchList.pendingAtom) > 0,\n  'isLoadingAtom',\n)\n// store abort controller of last request to prevent race conditions\nconst abortControllerAtom = atom(new AbortController())\nconst ABORT = 'ABORT'\n\nexport const fetchList = reatomAsync((ctx, page: number) => {\n  // cancel previous request\n  ctx.get(abortControllerAtom).abort(ABORT)\n  // setup controller of current request\n  abortControllerAtom(ctx, ctx.controller)\n\n  return request<Array<Element>>(`/api/list?page=${page}`, ctx.controller)\n}, 'fetchList')\nfetchList.onFulfill.onCall(listAtom)\nfetchList.onReject.onCall((ctx, thing) => {\n  if (thing !== ABORT) {\n    const error = thing instanceof Error ? thing : new Error(String(thing))\n    errorAtom(ctx, error)\n  }\n})\n\nexport const updateElement = reatomAsync(\n  (ctx, id: string, slice: Partial<Element>) => {\n    const { signal } = ctx.controller\n    const data = JSON.stringify(slice)\n    return request(`/api/list/${id}`, { method: 'POST', data, signal })\n  },\n  'updateElement',\n)\n// refresh backend data on successful update\nupdateElement.onFulfill.onCall((ctx) => fetchList(ctx, 1))\n```\n\n----------------------------------------\n\nTITLE: Advanced Reatom Model with Async Handling\nDESCRIPTION: Implements a complex search feature with debouncing, caching, and retry logic using Reatom's advanced features\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/src/content/docs/index.md#2025-04-23_snippet_5\n\nLANGUAGE: ts\nCODE:\n```\nimport { atom, reatomAsync, withAbort, withDataAtom, withRetry, onUpdate, sleep, withCache } from \"@reatom/framework\"; // prettier-ignore\nimport * as api from './api'\n\nconst searchAtom = atom('', 'searchAtom')\n\nconst fetchIssues = reatomAsync(async (ctx, query: string) => {\n  await sleep(350) // debounce\n  const { items } = await api.fetchIssues(query, ctx.controller)\n  return items\n}, 'fetchIssues').pipe(\n  withAbort({ strategy: 'last-in-win' }),\n  withDataAtom([]),\n  withCache({ length: 50, swr: false, paramsLength: 1 }),\n  withRetry({\n    onReject(ctx, error: any, retries) {\n      // return delay in ms or -1 to prevent retries\n      return error?.message.includes('rate limit')\n        ? 100 * Math.min(500, retries ** 2)\n        : -1\n    },\n  }),\n)\n\n// run fetchIssues on every searchAtom update\nonUpdate(searchAtom, fetchIssues)\n```\n\n----------------------------------------\n\nTITLE: Accumulating Fetched Data with Reatom Async in TypeScript\nDESCRIPTION: Demonstrates how to fetch paginated data and accumulate it in the existing state. The fetchFeed atom uses withDataAtom to merge new data into the current state.\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/src/content/docs/package/async.md#2025-04-23_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nimport { reatomAsync, withDataAtom } from '@reatom/async'\n\nconst PAGE_SIZE = 10\n\nexport const fetchFeed = reatomAsync(async (ctx, page: number) => {\n  const data = await request(\n    `api/feed?page=${page}&limit?${page}`,\n    ctx.controller,\n  )\n  return { data, page }\n}, 'fetchFeed').pipe(\n  withDataAtom([], (ctx, { data, page }, state) => {\n    const newState = [...state]\n    newState.splice((page - 1) * PAGE_SIZE, PAGE_SIZE, ...data)\n    return newState\n  }),\n)\n```\n\n----------------------------------------\n\nTITLE: Creating Async Actions in Reatom\nDESCRIPTION: Shows how to create asynchronous actions using ctx.schedule for async operations and updating atoms with the fetched data.\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/src/content/docs/getting-started/learning.md#2025-04-23_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createCtx, atom, action } from '@reatom/framework'\n\nexport const dataAtom = atom(null)\n\nexport const fetchData = action(async (ctx) => {\n  const data = await ctx.schedule(async () => {\n    const response = await fetch('https://jsonplaceholder.typicode.com/todos/1')\n    const payload = await response.json()\n    return payload\n  })\n  dataAtom(ctx, data)\n})\n```\n\n----------------------------------------\n\nTITLE: Advanced Reatom Implementation with GitHub API Integration\nDESCRIPTION: Complex example showing async operations, caching, retrying, and API integration using Reatom's advanced features\nSOURCE: https://github.com/reatom/reatom/blob/v3/README.md#2025-04-23_snippet_5\n\nLANGUAGE: ts\nCODE:\n```\nimport { atom, reatomAsync, withAbort, withDataAtom, withRetry, onUpdate, sleep, withCache } from \"@reatom/framework\"; // prettier-ignore\nimport * as api from './api'\n\nconst searchAtom = atom('', 'searchAtom')\n\nconst fetchIssues = reatomAsync(async (ctx, query: string) => {\n  await sleep(350) // debounce\n  const { items } = await api.fetchIssues(query, ctx.controller)\n  return items\n}, 'fetchIssues').pipe(\n  withAbort({ strategy: 'last-in-win' }),\n  withDataAtom([]),\n  withCache({ length: 50, swr: false, paramsLength: 1 }),\n  withRetry({\n    onReject(ctx, error: any, retries) {\n      // return delay in ms or -1 to prevent retries\n      return error?.message.includes('rate limit')\n        ? 100 * Math.min(500, retries ** 2)\n        : -1\n    },\n  }),\n)\n\n// run fetchIssues on every searchAtom update\nonUpdate(searchAtom, fetchIssues)\n```\n\n----------------------------------------\n\nTITLE: Using withDataAtom for Feature Form Implementation\nDESCRIPTION: Demonstrates how to create a feature that loads data from the backend, allows user modifications, and saves changes back to the backend using withDataAtom to manage the state.\nSOURCE: https://github.com/reatom/reatom/blob/v3/packages/async/README.md#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport { reatomAsync, withDataAtom } from '@reatom/async'\n\ntype Feature = {\n  /*...*/\n}\n\nexport const fetchFeature = reatomAsync(\n  (ctx) => request<Feature>('/api/feature', ctx.controller),\n  'fetchFeature',\n).pipe(withDataAtom(null))\n// use subscription to `fetchFeature.dataAtom` to get the actual data\n\n// mutate data manually in the feature form\nexport const changeFeature = action(\n  (ctx, property: keyof Feature, value: any) => {\n    fetchUser.dataAtom(ctx, (user) => ({ ...user, [property]: value }))\n  },\n  'changeFeature',\n)\n\n// save new feature data to backend on form submit\nexport const syncFeature = reatomAsync((ctx) => {\n  const { signal } = ctx.controller\n  const body = JSON.stringify(ctx.get(fetchFeature.dataAtom))\n  return request('/api/feature', { method: 'POST', body, signal })\n}, 'syncFeature')\n```\n\n----------------------------------------\n\nTITLE: Shared Cache Implementation with React Components\nDESCRIPTION: Complex example showing how to implement shared caching across different components with React integration.\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/src/content/docs/package/async.md#2025-04-23_snippet_20\n\nLANGUAGE: typescript\nCODE:\n```\nimport {\n  atom,\n  createCtx,\n  reatomResource,\n  withDataAtom,\n  withCache,\n  createMemStorage,\n  reatomPersist,\n} from '@reatom/framework'\nimport { withLocalStorage } from '@reatom/persist-web-storage'\n\n// API request simulation\nconst fetchUserData = async (userId: number): Promise<string> => {\n  await new Promise((resolve) => setTimeout(resolve, 500)) // delay simulation\n  return `User data for ID: ${userId}`\n}\n\n// Create shared storage for caching\nconst userModelStorage = createMemStorage({ name: 'userData' })\nconst withUserDataPersist = reatomPersist(userModelStorage)\n\n// Factory function to create model instances with shared cache\nconst reatomUser = (initialUserId: number, name: string) => {\n  // Parameter atom that can be changed\n  const userIdAtom = atom(initialUserId, `${name}.userIdAtom`)\n\n  // Resource that fetches data based on the parameter\n  const userResource = reatomResource(async (ctx) => {\n    const userId = ctx.spy(userIdAtom)\n    return await fetchUserData(userId)\n  }, `${name}.userResource`).pipe(\n    withDataAtom(''),\n    withCache({\n      swr: false,\n      withPersist: () => withUserDataPersist('userData'), // Share persistence between instances\n    }),\n  )\n\n  return {\n    idAtom: userIdAtom,\n    resource: userResource,\n  }\n}\n\n// Current user model\nconst ownerModel = reatomUser(0, 'ownerModel')\nownerModel.idAtom.pipe(withLocalStorage('user-id'))\n\n// Custom user model\nconst customUserModel = reatomUser(0, 'customUserModel')\n\n// View layer\nconst OwnerLoading = reatomComponent(\n  ({ ctx }) => (ctx.spy(ownerModel.isLoadingAtom) ? <p>Loading...</p> : null),\n  'OwnerLoading',\n)\nexport const OwnerData = reatomComponent(({ ctx }) => {\n  return (\n    <div>\n      <OwnerLoading />\n      <p>Your data: {ctx.spy(ownerModel.dataAtom)}</p>\n    </div>\n  )\n}, 'OwnerData')\n\nexport const CustomUserCard = reatomComponent(({ ctx }) => {\n  return (\n    <div>\n      <h2>User inspector</h2>\n      <input\n        type=\"number\"\n        value={ctx.spy(customUserModel.idAtom)}\n        onChange={(e) => customUserModel.idAtom.set(e.target.valueAsNumber)}\n      />\n      <p>User data: {ctx.spy(ownerModel.dataAtom)}</p>\n    </div>\n  )\n}, 'CustomUserCard')\n```\n\n----------------------------------------\n\nTITLE: Complete Reatom Debugging Example with Counter\nDESCRIPTION: A full example demonstrating Reatom debugging with a counter implementation. It shows how to create atoms, derived atoms, actions, and connect the logger to track state changes.\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/src/content/docs/getting-started/debugging.md#2025-04-23_snippet_2\n\nLANGUAGE: ts\nCODE:\n```\nimport { createCtx, atom, action } from '@reatom/core'\nimport { connectLogger } from '@reatom/logger'\n\nconst ctx = createCtx()\n\nif (import.meta.env.DEV) {\n  connectLogger(ctx)\n}\n\nconst counterAtom = atom(0, 'counterAtom')\nconst doubledAtom = atom((ctx) => counterAtom * 2, 'doubledAtom')\nconst increment = action(\n  (ctx) => counterAtom(ctx, (state) => state + 1),\n  'increment',\n)\n\nctx.subscribe(doubledAtom, () => {})\n\nincrement(ctx, 24)\n```\n\n----------------------------------------\n\nTITLE: Cache Synchronization with LocalStorage in TypeScript\nDESCRIPTION: Demonstrates cache persistence and synchronization across tabs using withLocalStorage from @reatom/persist-web-storage.\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/src/content/docs/package/async.md#2025-04-23_snippet_19\n\nLANGUAGE: typescript\nCODE:\n```\nimport { reatomAsync, withCache } from '@reatom/async'\nimport { withLocalStorage } from '@reatom/persist-web-storage'\n\nexport const fetchList = reatomAsync(\n  (ctx) => request('api/list', ctx.controller),\n  'fetchList',\n).pipe(withCache({ withPersist: withLocalStorage }))\n```\n\n----------------------------------------\n\nTITLE: Setting up Reatom context in Vue application root\nDESCRIPTION: Example showing how to set up the Reatom context at the root of a Vue application, which is a prerequisite for using other Reatom functions within components.\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/src/content/docs/package/npm-vue.md#2025-04-23_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createCtx } from '@reatom/core'\nimport { createReatomVue } from '@reatom/npm-vue'\n\nconst ctx = createCtx()\napp.use(createReatomVue(ctx))\n```\n\n----------------------------------------\n\nTITLE: Using readyAtom for Conditional Rendering in React with Reatom\nDESCRIPTION: Example of using the readyAtom in a React component to conditionally render loading, error, or data states. This pattern prevents flashing of empty content during the first render.\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/src/content/docs/recipes/custom-operator.md#2025-04-23_snippet_4\n\nLANGUAGE: jsx\nCODE:\n```\nif (!ctx.spy(fetchSome.readyAtom)) {\n  return <Loading />\n}\n\nif (ctx.spy(fetchSome.errorAtom)) {\n  return <Error />\n}\n\nreturn <Data />\n```\n\n----------------------------------------\n\nTITLE: Implementing Simplified Async Resource with reatomResource in Reatom\nDESCRIPTION: Demonstrates using reatomResource to create a cleaner implementation of the same async resource, automatically handling dependencies, cancellation, and caching with the ctx.spy mechanism.\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/src/content/docs/package/async.md#2025-04-23_snippet_30\n\nLANGUAGE: typescript\nCODE:\n```\nimport { reatomResource, withDataAtom } from '@reatom/async'\n\nconst listResource = reatomResource(async (ctx) => {\n  const page = ctx.spy(pageAtom)\n  const search = ctx.spy(searchAtom)\n  return await ctx.schedule(() =>\n    request(`/api/list?page=${page}&q=${search}`, ctx.controller),\n  )\n}, 'listResource').pipe(withDataAtom([]))\n```\n\n----------------------------------------\n\nTITLE: Testing Synchronous Reatom Actions with Vitest\nDESCRIPTION: Unit test for the counter implementation using @reatom/testing helpers and Vitest. The test creates a test context, tracks atom changes, and verifies that actions modify state correctly.\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/src/content/docs/getting-started/testing.md#2025-04-23_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\n// main.test.js\nimport { expect, test } from 'vitest'\nimport { createTestCtx } from '@reatom/testing'\n\nimport { add, countAtom } from './main'\n\ntest('Test main module', () => {\n  const ctx = createTestCtx() // Create test context\n  const track = ctx.subscribeTrack(countAtom) // Record atom changes\n\n  // Check initial state\n  expect(track.calls.length).toBe(1)\n  expect(track.lastInput()).toBe(0)\n\n  // Call some actions\n  add(ctx, 5)\n  add(ctx, 10)\n\n  // Check that action \"add\" work properly\n  expect(track.calls.length).toBe(3)\n  expect(track.lastInput()).toBe(15) // it's the same as expect(ctx.get(countAtom)).toBe(15)\n})\n```\n\n----------------------------------------\n\nTITLE: Advanced Action Handling with Flow Management\nDESCRIPTION: Demonstrates advanced action handling patterns, including temporal state management and action dependencies in atoms.\nSOURCE: https://github.com/reatom/reatom/blob/v3/packages/core/README.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\n// ~/modules/someFlow\nimport { atom, batch } from '@reatom/core'\nimport { newMessage } from '~/modules/ws'\n\nconst FLOW_NAME = 'someFlow'\n\nexport const someFlowAtom = atom(0)\n\n// you need to subscribe to it to start watching `newMessage`\nexport const someFlowManagerAtom = atom((ctx) => {\n  console.log('example log for `ctx.get(newMessage)`', ctx.get(newMessage))\n\n  ctx.spy(newMessage).forEach(({ payload }) => {\n    if (payload.relation === FLOW_NAME) someFlowAtom(ctx, payload)\n\n    console.log('example log for `ctx.spy(newMessage)[N]`.payload', payload)\n  })\n})\n\n// socket service:\nsocket.on(\n  throttle(150, (msgs) =>\n    batch(ctx, () => {\n      msgs.forEach((msg) => newMessage(ctx, msg))\n    }),\n  ),\n)\n```\n\n----------------------------------------\n\nTITLE: Implementing a React Form with Reatom Form Web\nDESCRIPTION: Complete example of integrating @reatom/form-web with React, demonstrating form creation, field registration, validation, conditional logic, and form submission. The example includes various input types and demonstrates Reatom's reactive programming model for forms.\nSOURCE: https://github.com/reatom/reatom/blob/v3/packages/form-web/README.md#2025-04-23_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nimport {\n  createCtx,\n  connectLogger,\n  parseAtoms,\n  onUpdate,\n} from '@reatom/framework'\nimport { reatomContext, useAtom, useCtxBind } from '@reatom/npm-react'\nimport * as ReactDOMClient from 'react-dom/client'\nimport React from 'react'\nimport { reatomHTMLForm } from './'\n\nimport { unstable_batchedUpdates } from 'react-dom'\nimport { setupBatch } from '@reatom/npm-react'\n\nsetupBatch(unstable_batchedUpdates)\n\nconst form = reatomHTMLForm({\n  name: 'example',\n  // you could use `fieldsListAtom` for dynamic forms\n  onSubmit(ctx, { fieldsListAtom }) {\n    const data = parseAtoms(ctx, fields)\n    console.log(data)\n  },\n})\n\nconst fields = form.reatomHTMLFields({\n  name: '',\n  age: 14,\n  driver: false,\n  pet: { cat: false, dog: false },\n  hobby: [],\n})\n\nonUpdate(fields.age, (ctx, age) => {\n  fields.driver.attributesAtom.merge(ctx, { disabled: age < 18 })\n})\n\nexport default function App() {\n  const bind = useCtxBind()\n  const rerenders = React.useRef(0)\n\n  return (\n    <form ref={bind(form.register)} className=\"form\">\n      <label>\n        Name:\n        <input ref={bind(fields.name.register)} autoFocus required />\n      </label>\n      <label>\n        Age:\n        <input ref={bind(fields.age.register)} required min=\"14\" />\n      </label>\n      <label>\n        Pet:\n        <br />\n        <label>\n          Cat\n          <input ref={bind(fields.pet.cat.register)} required />\n        </label>\n        <br />\n        <label>\n          Dog\n          <input ref={bind(fields.pet.dog.register)} required />\n        </label>\n      </label>\n      <label>\n        Hobby:\n        <select ref={bind(fields.hobby.register)}>\n          <option value=\"swim\">swim</option>\n          <option value=\"walk\">walk</option>\n          <option value=\"draw\">draw</option>\n          <option value=\"music\">music</option>\n        </select>\n      </label>\n      <label>\n        Driver license:\n        <input ref={bind(fields.driver.register)} disabled />\n      </label>\n      <input type=\"submit\" />\n      <button onClick={bind(form.reset)}>reset</button>\n\n      <p>rerenders: {rerenders.current++}</p>\n    </form>\n  )\n}\n\nconst ctx = createCtx()\nconnectLogger(ctx)\n\nconst rootElement = document.getElementById('root')!\nconst root = ReactDOMClient.createRoot(rootElement)\n\nroot.render(\n  <reatomContext.Provider value={ctx}>\n    <App />\n    <style>{`\n        .form {\n          width: 5rem;\n          display: flex;\n          flex-direction: column;\n          gap: 1rem;\n        }  \n      `}</style>\n  </reatomContext.Provider>,\n)\n```\n\n----------------------------------------\n\nTITLE: Sharing Cache in Reatom Async Actions (TypeScript)\nDESCRIPTION: Demonstrates how to create an asynchronous model with a shared cache that can be used across different components. It includes a factory function for creating model instances and examples of how to use the shared cache in React components.\nSOURCE: https://github.com/reatom/reatom/blob/v3/packages/async/README.md#2025-04-23_snippet_17\n\nLANGUAGE: typescript\nCODE:\n```\nimport {\n  atom,\n  createCtx,\n  reatomResource,\n  withDataAtom,\n  withCache,\n  createMemStorage,\n  reatomPersist,\n} from '@reatom/framework'\nimport { withLocalStorage } from '@reatom/persist-web-storage'\n\n// API request simulation\nconst fetchUserData = async (userId: number): Promise<string> => {\n  await new Promise((resolve) => setTimeout(resolve, 500)) // delay simulation\n  return `User data for ID: ${userId}`\n}\n\n// Create shared storage for caching\nconst userModelStorage = createMemStorage({ name: 'userData' })\nconst withUserDataPersist = reatomPersist(userModelStorage)\n\n// Factory function to create model instances with shared cache\nconst reatomUser = (initialUserId: number, name: string) => {\n  // Parameter atom that can be changed\n  const userIdAtom = atom(initialUserId, `${name}.userIdAtom`)\n\n  // Resource that fetches data based on the parameter\n  const userResource = reatomResource(async (ctx) => {\n    const userId = ctx.spy(userIdAtom)\n    return await fetchUserData(userId)\n  }, `${name}.userResource`).pipe(\n    withDataAtom(''),\n    withCache({\n      swr: false,\n      withPersist: () => withUserDataPersist('userData'), // Share persistence between instances\n    }),\n  )\n\n  return {\n    idAtom: userIdAtom,\n    resource: userResource,\n  }\n}\n\n// Current user model\nconst ownerModel = reatomUser(0, 'ownerModel')\nownerModel.idAtom.pipe(withLocalStorage('user-id'))\n\n// Custom user model\nconst customUserModel = reatomUser(0, 'customUserModel')\n\n// View layer\nconst OwnerLoading = reatomComponent(\n  ({ ctx }) => (ctx.spy(ownerModel.isLoadingAtom) ? <p>Loading...</p> : null),\n  'OwnerLoading',\n)\nexport const OwnerData = reatomComponent(({ ctx }) => {\n  return (\n    <div>\n      <OwnerLoading />\n      <p>Your data: {ctx.spy(ownerModel.dataAtom)}</p>\n    </div>\n  )\n}, 'OwnerData')\n\nexport const CustomUserCard = reatomComponent(({ ctx }) => {\n  return (\n    <div>\n      <h2>User inspector</h2>\n      <input\n        type=\"number\"\n        value={ctx.spy(customUserModel.idAtom)}\n        onChange={(e) => customUserModel.idAtom.set(e.target.valueAsNumber)}\n      />\n      <p>User data: {ctx.spy(ownerModel.dataAtom)}</p>\n    </div>\n  )\n}, 'CustomUserCard')\n```\n\nLANGUAGE: typescript\nCODE:\n```\nexport const UserCard = reatomComponent<{ id: number }>(({ ctx, id }) => {\n  const model = useMemo(() => reatomUser(id), [id])\n  return (\n    <div>\n      <h2>User #{id}</h2>\n      {ctx.spy(model.isLoadingAtom) && <p>Loading...</p>}\n      <p>{ctx.spy(model.dataAtom)}</p>\n    </div>\n  )\n}, 'UserCard')\n```\n\n----------------------------------------\n\nTITLE: Nesting Actions in Reatom\nDESCRIPTION: Demonstrates how to nest actions, including asynchronous actions, and handle loading states and errors.\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/src/content/docs/getting-started/learning.md#2025-04-23_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nimport { action, atom } from '@reatom/core'\n\nexport const todoAtom = atom(null)\nexport const isLoadingAtom = atom(false)\n\nexport const fetchTodo = action(async (ctx) => {\n  const response = await ctx.schedule(() =>\n    fetch('https://jsonplaceholder.typicode.com/todos/1'),\n  )\n  return await response.json()\n})\n\nexport const loadTodo = action(async (ctx) => {\n  try {\n    isLoadingAtom(ctx, true)\n    const data = await ctx.schedule((ctx) => fetchTodo(ctx))\n    todoAtom(ctx, data)\n  } catch (e) {\n    console.error(e)\n  } finally {\n    isLoadingAtom(ctx, false)\n  }\n})\n```\n\n----------------------------------------\n\nTITLE: Creating and Using Actions in TypeScript\nDESCRIPTION: Demonstrates various ways to create and use actions in Reatom, including different parameter and payload configurations.\nSOURCE: https://github.com/reatom/reatom/blob/v3/packages/core/README.md#2025-04-23_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\nconst increment = action()\n// increment: Action<[], void>\nconst increment = action('increment')\n// increment: Action<[], void>\n\nconst add = action<number>()\n// add: Action<[number], number>\nconst add = action<number>('add')\n// add: Action<[number], number>\nconst add = action((ctx, value: number) => value)\n// add: Action<[number], number>\nconst add = action((ctx, value: number) => value, 'add')\n// add: Action<[number], number>\nconst splice = action((ctx, start: number, deleteCount?: number) => {\n  listAtom(ctx, (list) => {\n    const newList = list.slice(0)\n    newList.splice(start, deleteCount)\n    return newList\n  })\n})\n// splice: Action<[number, number?], number>\n```\n\n----------------------------------------\n\nTITLE: Implementing Debounced Action with Rollback in Reatom\nDESCRIPTION: Shows two approaches to implement a debounced action with timeout management and cleanup. Demonstrates proper rollback handling using ctx.schedule with priority -1.\nSOURCE: https://github.com/reatom/reatom/blob/v3/packages/core/README.md#2025-04-23_snippet_17\n\nLANGUAGE: typescript\nCODE:\n```\nconst timeoutIdAtom = atom(-1)\n\n// `timeoutIdAtom` update in a schedule causes an extra transaction, which is not handy.\nexport const doSome = action((ctx) => {\n  const timeoutId = ctx.get(timeoutIdAtom)\n\n  ctx.schedule(() => {\n    clearTimeout(timeoutId)\n    const newTimeoutId = setTimeout(some)\n    timeoutIdAtom(ctx, newTimeoutId)\n  })\n})\n// updating `timeoutIdAtom` during a transaction is more obvious.\nexport const doSome = action((ctx) => {\n  const timeoutId = ctx.get(timeoutIdAtom)\n  ctx.schedule(() => clearTimeout(timeoutId))\n\n  const newTimeoutId = setTimeout(some)\n  timeoutIdAtom(ctx, newTimeoutId)\n  ctx.schedule(() => clearTimeout(newTimeoutId), -1)\n})\n```\n\n----------------------------------------\n\nTITLE: Implementing Paginated Data Fetching with Reatom in TypeScript\nDESCRIPTION: This snippet demonstrates how to fetch paginated data and accumulate it in a single atom. It uses reatomAsync with a custom data merging function to append new data to the existing state.\nSOURCE: https://github.com/reatom/reatom/blob/v3/packages/async/README.md#2025-04-23_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nimport { reatomAsync, withDataAtom } from '@reatom/async'\n\nconst PAGE_SIZE = 10\n\nexport const fetchFeed = reatomAsync(async (ctx, page: number) => {\n  const data = await request(\n    `api/feed?page=${page}&limit?${page}`,\n    ctx.controller,\n  )\n  return { data, page }\n}, 'fetchFeed').pipe(\n  withDataAtom([], (ctx, { data, page }, state) => {\n    const newState = [...state]\n    newState.splice((page - 1) * PAGE_SIZE, PAGE_SIZE, ...data)\n    return newState\n  }),\n)\n```\n\n----------------------------------------\n\nTITLE: Creating and Using Actions in Reatom\nDESCRIPTION: Demonstrates how to create and use actions to make multiple atomic changes in a single transaction, reducing the number of subscriber calls.\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/src/content/docs/getting-started/learning.md#2025-04-23_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createCtx, atom, action } from '@reatom/framework'\n\nconst ctx = createCtx()\n\nconst aAtom = atom(1, 'aAtom')\nconst bAtom = atom(2, 'bAtom')\nconst cAtom = atom((ctx) => ctx.spy(aAtom) + ctx.spy(bAtom), 'cAtom')\n\nconst setParams = action((ctx, a: number, b: number) => {\n  console.log(`change a=${a}, b=${b}`)\n  aAtom(ctx, a)\n  bAtom(ctx, b)\n}, 'setParams')\n\nctx.subscribe(cAtom, (c) => {\n  const a = ctx.get(aAtom)\n  const b = ctx.get(bAtom)\n  console.log(`${a} + ${b} = ${c}`)\n})\n\nsetParams(ctx, 10, 12) // change a=10, b=12, 10 + 12 = 22\nsetParams(ctx, 10, 12) // change a=10, b=12, does not log the result because it hasn't changed\n```\n\n----------------------------------------\n\nTITLE: Using atom.pipe for Composition in TypeScript\nDESCRIPTION: Demonstrates how to use the atom.pipe method to apply operators and decorators to atoms in a readable and type-safe way.\nSOURCE: https://github.com/reatom/reatom/blob/v3/packages/core/README.md#2025-04-23_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\nconst countAtom = atom(0).pipe(\n  withInit(() => localStorage.getItem('COUNT') ?? 0),\n)\n// equals to\nconst countAtom = withInit(() => localStorage.getItem('COUNT') ?? 0)(atom(0))\n```\n\n----------------------------------------\n\nTITLE: Updating Atom Values in Reatom\nDESCRIPTION: Shows how to update the value of an atom using the context and demonstrates updating with a function that uses the current value.\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/src/content/docs/getting-started/learning.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { atom, createCtx } from '@reatom/framework'\n\nconst ctx = createCtx()\n\nconst aAtom = atom(1, 'aAtom')\n\nctx.get(aAtom) // 1\naAtom(ctx, 3)\nctx.get(aAtom) // 3\n\nconst greetAtom = atom('Hello', 'greetAtom')\n\ngreetAtom(ctx, (greet) => greet + ', atom') // 'Hello, atom'\ngreetAtom(ctx, (greet) => greet + ', atom') // 'Hello, atom, atom'\n```\n\n----------------------------------------\n\nTITLE: Chaining Dependent Resources with reatomResource in Reatom (TypeScript)\nDESCRIPTION: Demonstrates how to create dependent async resources where one resource depends on the result of another, with automatic cancellation of stale requests when dependencies change.\nSOURCE: https://github.com/reatom/reatom/blob/v3/packages/async/README.md#2025-04-23_snippet_27\n\nLANGUAGE: typescript\nCODE:\n```\nimport { reatomResource } from '@reatom/async'\n\nconst aResource = reatomResource(async (ctx) => {\n  const page = ctx.spy(pageAtom)\n  return await ctx.schedule(() =>\n    request(`/api/a?page=${page}`, ctx.controller),\n  )\n}, 'aResource')\nconst bResource = reatomResource(async (ctx) => {\n  const a = await ctx.spy(aResource.promiseAtom)\n  return await ctx.schedule(() => request(`/api/b/${b}`, ctx.controller))\n}, 'bResource')\n```\n\n----------------------------------------\n\nTITLE: Implementing Dependent Resources with reatomResource in Reatom\nDESCRIPTION: Shows how to create dependent resources where one resource depends on the results of another, with automatic cancellation of stale promises when dependencies change.\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/src/content/docs/package/async.md#2025-04-23_snippet_31\n\nLANGUAGE: typescript\nCODE:\n```\nimport { reatomResource } from '@reatom/async'\n\nconst aResource = reatomResource(async (ctx) => {\n  const page = ctx.spy(pageAtom)\n  return await ctx.schedule(() =>\n    request(`/api/a?page=${page}`, ctx.controller),\n  )\n}, 'aResource')\nconst bResource = reatomResource(async (ctx) => {\n  const a = await ctx.spy(aResource.promiseAtom)\n  return await ctx.schedule(() => request(`/api/b/${b}`, ctx.controller))\n}, 'bResource')\n```\n\n----------------------------------------\n\nTITLE: Implementing Concurrent Effect Management in TypeScript\nDESCRIPTION: Demonstrates using the concurrent decorator to handle async logic when an atom changes. This pattern ensures only the latest request completes while aborting previous pending requests.\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/src/content/docs/package/effects.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { concurrent } from '@reatom/effects'\n\nsomeAtom.onChange(\n  concurrent(async (ctx, some) => {\n    const other = await ctx.schedule(() => api.getOther(some))\n    otherAtom(ctx, other)\n  }),\n)\n```\n\n----------------------------------------\n\nTITLE: Handling Multiple Updates in an Atom in TypeScript\nDESCRIPTION: Shows how to handle multiple updates independently within an atom using the spy method for action-reaction scenarios.\nSOURCE: https://github.com/reatom/reatom/blob/v3/packages/core/README.md#2025-04-23_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\nexport const changeCurrency = action<string>('changeCurrency')\nexport const currencyAtom = atom((ctx, state?: string) => {\n  ctx.spy(languageAtom, (language) => {\n    state = getCurrencyByLanguage(language)\n  })\n\n  ctx.spy(changeCurrency, (currency) => {\n    state = currency\n  })\n\n  return state\n}, 'currencyAtom')\n```\n\n----------------------------------------\n\nTITLE: Using Reatom Atoms in React Component\nDESCRIPTION: Example of creating a Reatom atom and using it in a React component with the useAtom hook.\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/src/content/docs/compat/react-v2.md#2025-04-23_snippet_8\n\nLANGUAGE: jsx\nCODE:\n```\nimport { createPrimitiveAtom } from '@reatom/core-v2/primitives'\nimport { useAtom } from '@reatom/react-v2'\n\nconst nameAtom = createPrimitiveAtom('', {\n  onChange: (state, e) => e.currentTarget.value,\n})\n\nexport const Form = () => {\n  const [name, { onChange }] = useAtom(nameAtom)\n\n  return (\n    <form>\n      <label htmlFor=\"name\">Enter your name</label>\n      <input id=\"name\" value={name} onChange={onChange} />\n    </form>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Simplifying Async Model with Reatom Operators\nDESCRIPTION: Shows how to reduce boilerplate by using built-in operators like withDataAtom, withErrorAtom, withAbort, and withStatusesAtom to extend primitive fetching to useful models with minimal code.\nSOURCE: https://github.com/reatom/reatom/blob/v3/packages/async/README.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\n// ~/features/entities/model.ts\nimport { reatomAsync, withAbort, withDataAtom, withErrorAtom, withStatusesAtom } from \"@reatom/framework\"; /* prettier-ignore */\n\ntype Element = {\n  id: string\n  /* ... */\n}\n\nexport const fetchList = reatomAsync(\n  (ctx, page: number) =>\n    request<Array<Element>>(`/api/list?page=${page}`, ctx.controller),\n  'fetchList',\n  // add extra handlers with full type inference\n).pipe(withDataAtom([]), withErrorAtom(), withAbort(), withStatusesAtom())\n\nexport const updateElement = reatomAsync(\n  (ctx, id: string, slice: Partial<Element>) => {\n    const { signal } = ctx.controller\n    const data = JSON.stringify(slice)\n    return request(`/api/list/${id}`, { method: 'POST', data, signal })\n  },\n  'updateElement',\n)\nupdateElement.onFulfill.onCall((ctx) => fetchList(ctx, 1))\n```\n\n----------------------------------------\n\nTITLE: Take Filter with Type-Safe Destructuring\nDESCRIPTION: Shows how to use take filter for type-safe handling of union types and error cases.\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/src/content/docs/package/effects.md#2025-04-23_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nconst { data } = await take(ctx, someRequest, (ctx, payload, skip) =>\n  'error' in payload ? skip : payload,\n)\n```\n\n----------------------------------------\n\nTITLE: Immutable State Changes for Atoms in TypeScript\nDESCRIPTION: Shows how to perform immutable state changes on an atom, specifically adding an item to a list atom.\nSOURCE: https://github.com/reatom/reatom/blob/v3/packages/core/README.md#2025-04-23_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nexport const listAtom = atom([], 'listAtom')\n// add item\nlistAtom(ctx, (list) => [...list, newItem])\n```\n\n----------------------------------------\n\nTITLE: Implementing Caching with Reatom in TypeScript\nDESCRIPTION: This snippet demonstrates how to implement caching for async data fetching using withCache. It includes options for cache size, stale time, and stale-while-revalidate (SWR) behavior.\nSOURCE: https://github.com/reatom/reatom/blob/v3/packages/async/README.md#2025-04-23_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\nimport { reatomAsync, withDataAtom, withCache } from '@reatom/async'\n\nexport const fetchList = reatomAsync(\n  (ctx) => request('api/list', ctx.controller),\n  'fetchList',\n).pipe(withDataAtom(), withCache())\n\n// fetch data\nawait fetchList(ctx, { query: 'foo', page: 1 }) // call the effect\nconst firstResult = ctx.get(fetchList.dataAtom)\n\n// fetch another data\nawait fetchList(ctx, { query: 'bar', page: 2 })\n\n// request data with the equal parameters\nfetchList(ctx, { page: 1, query: 'foo' })\n// the cache comes to `onFulfill` and `dataAtom` as well synchronously\nisEqual(firstResult, ctx.get(fetchList.dataAtom)) // true\n```\n\n----------------------------------------\n\nTITLE: Advanced reatomAsync Implementation with State Handling\nDESCRIPTION: Extended implementation of reatomAsync with state management for list data, errors, and request lifecycle hooks.\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/src/content/docs/package/async.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { atom } from '@reatom/core'\nimport { reatomAsync } from '@reatom/async'\n\nconst listAtom = atom([])\nconst errorAtom = atom(null)\nexport const fetchList = reatomAsync(\n  (ctx, page: number) => request(`/api/list?page=${page}`, ctx.controller),\n  {\n    name: 'fetchList',\n    onFulfill(ctx, result) {\n      listAtom(ctx, result)\n    },\n    onReject(ctx, error) {\n      errorAtom(ctx, error)\n    },\n    onEffect(ctx, params, promise) {\n      // clear outdated data on request start\n      listAtom(ctx, [])\n      errorAtom(ctx, null)\n    },\n  },\n)\n```\n\n----------------------------------------\n\nTITLE: Implementing Abort Handling in Reatom\nDESCRIPTION: This example demonstrates how to use withAbort in Reatom to handle concurrent requests. It includes abort handling for both manual cancellation and automatic cancellation when the component is disconnected.\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/src/content/docs/package/async.md#2025-04-23_snippet_27\n\nLANGUAGE: typescript\nCODE:\n```\nimport { reatomAsync, withDataAtom, withAbort } from '@reatom/async'\nimport { onConnect } from '@reatom/hooks'\n\nexport const fetchList = reatomAsync(\n  (ctx, page = 1) => request(`api/list?page=${page}`, ctx.controller),\n  'fetchList',\n).pipe(withDataAtom([]), withAbort())\n\nonConnect(fetchList.dataAtom, (ctx) => {\n  fetchList(ctx)\n  // abort unneeded request\n  return () => fetchList.abort(ctx)\n})\n```\n\n----------------------------------------\n\nTITLE: Syncing Cache Across Tabs with Reatom (TypeScript)\nDESCRIPTION: Shows how to persist and sync cache across browser tabs using withLocalStorage from @reatom/persist-web-storage. It also demonstrates how to customize persistence options.\nSOURCE: https://github.com/reatom/reatom/blob/v3/packages/async/README.md#2025-04-23_snippet_16\n\nLANGUAGE: typescript\nCODE:\n```\nimport { reatomAsync, withCache } from '@reatom/async'\nimport { withLocalStorage } from '@reatom/persist-web-storage'\n\nexport const fetchList = reatomAsync(\n  (ctx) => request('api/list', ctx.controller),\n  'fetchList',\n).pipe(withCache({ withPersist: withLocalStorage }))\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport { reatomAsync, withCache } from '@reatom/async'\nimport { withLocalStorage } from '@reatom/persist-web-storage'\n\nexport const fetchList = reatomAsync(\n  (ctx) => request('api/list', ctx.controller),\n  'fetchList',\n).pipe(\n  withCache({\n    withPersist: (options) =>\n      withLocalStorage({ ...options, key: 'LIST_CACHE' }),\n  }),\n)\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport { reatomAsync, withDataAtom, withCache } from '@reatom/async'\nimport { withLocalStorage } from '@reatom/persist-web-storage'\n\nexport const fetchList = reatomAsync(\n  (ctx) => request('api/list', ctx.controller),\n  'fetchList',\n).pipe(withDataAtom([]), withCache({ withPersist }))\n```\n\n----------------------------------------\n\nTITLE: Using reatomRef for Atom State Management\nDESCRIPTION: Demonstrates converting Reatom atoms into Vue refs with reactivity support.\nSOURCE: https://github.com/reatom/reatom/blob/v3/packages/npm-vue/README.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { atom } from '@reatom/core'\nimport { reatomRef } from '@reatom/npm-vue'\n\nconst count = atom(0, 'count')\n\n// turn an atom into a ref-like object\nconst countRef = reatomRef(count)\n// selectors are supported as well\nconst countDoubleRef = reatomRef((ctx) => ctx.spy(count) * 2)\n\ncountRef // Ref<number>\ncountRef.value // 0\ncountRef.value = 3 // 3\n\ncountDoubleRef // Readonly<Ref<number>>\ncountDoubleRef.value // 6\n```\n\n----------------------------------------\n\nTITLE: Caching with Reatom Async in TypeScript\nDESCRIPTION: Demonstrates how to implement caching for async operations using withCache. The fetchList atom caches results and supports stale-while-revalidate pattern.\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/src/content/docs/package/async.md#2025-04-23_snippet_14\n\nLANGUAGE: typescript\nCODE:\n```\nimport { reatomAsync, withDataAtom, withCache } from '@reatom/async'\n\nexport const fetchList = reatomAsync(\n  (ctx) => request('api/list', ctx.controller),\n  'fetchList',\n).pipe(withDataAtom(), withCache())\n\n// fetch data\nawait fetchList(ctx, { query: 'foo', page: 1 }) // call the effect\nconst firstResult = ctx.get(fetchList.dataAtom)\n\n// fetch another data\nawait fetchList(ctx, { query: 'bar', page: 2 })\n\n// request data with the equal parameters\nfetchList(ctx, { page: 1, query: 'foo' })\n// the cache comes to `onFulfill` and `dataAtom` as well synchronously\nisEqual(firstResult, ctx.get(fetchList.dataAtom)) // true\n```\n\n----------------------------------------\n\nTITLE: Creating a Reatom Timer Atom in TypeScript\nDESCRIPTION: This snippet demonstrates how to create a timer atom using the reatomTimer function from @reatom/timer. It shows the default options for the timer, including name, interval, delayMultiplier, progressPrecision, and resetProgress.\nSOURCE: https://github.com/reatom/reatom/blob/v3/packages/timer/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { reatomTimer } from '@reatom/timer'\n\n// all options are not required, here are the defaults\nconst pomodoroAtom = reatomTimer({\n  name: 'pomodoroAtom',\n  interval: 1000, // `1000`ms - tick each second. Than lower, then more precise\n  delayMultiplier: 1000, // `1000`ms allow to pass seconds to startTimer. Use `1` to pass ms\n  progressPrecision: 2, // progress will be rounded to 2 digits after dot\n  resetProgress: true, // progress will be reset to 0 on end of timer\n})\n```\n\n----------------------------------------\n\nTITLE: Implementing Retry Logic in Reatom Async Actions (TypeScript)\nDESCRIPTION: Shows how to add retry functionality to Reatom async actions using withRetry. It demonstrates basic usage, specifying fallback parameters, and implementing custom retry logic based on error conditions and retry count.\nSOURCE: https://github.com/reatom/reatom/blob/v3/packages/async/README.md#2025-04-23_snippet_18\n\nLANGUAGE: typescript\nCODE:\n```\nimport { reatomAsync, withCache, withDataAtom, withRetry } from '@reatom/async'\n\nexport const fetchList = reatomAsync(\n  (ctx) => request('api/list', ctx.controller),\n  'fetchList',\n).pipe(withCache(), withDataAtom(), withRetry())\n\nexport const updateList = reatomAction(async () => {\n  /*  */\n}, 'updateList')\nupdateList.onFulfill.onCall(fetchList.cacheAtom.reset)\nupdateList.onFulfill.onCall(retry)\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport { reatomAsync, withRetry } from '@reatom/async'\n\nexport const fetchList = reatomAsync(\n  (ctx, page) => request(`api/list?page=${page}`, ctx.controller),\n  'fetchList',\n).pipe(withRetry({ fallbackParams: [1] }))\n\n// will call fetch(`api/list?page=1`)\nfetchList.retry(ctx)\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport { reatomAsync, withRetry } from '@reatom/async'\n\nexport const fetchList = reatomAsync(\n  (ctx) => request('api/list', ctx.controller),\n  'fetchList',\n).pipe(\n  withRetry({\n    onReject(ctx, error, retries) {\n      if (retries < 4) return 0\n    },\n  }),\n)\n```\n\n----------------------------------------\n\nTITLE: Implementing Async API Operations with Reatom\nDESCRIPTION: Example implementation of async API calls using Reatom actions and atoms. This code fetches a todo item from an API and updates state atoms accordingly, including loading state management.\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/src/content/docs/getting-started/testing.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { action, atom } from '@reatom/core'\n\nexport const todoAtom = atom(null)\nexport const isLoadingAtom = atom(false)\n\nexport const fetchTodo = action(async (ctx) => {\n  const response = await ctx.schedule(() =>\n    fetch('https://jsonplaceholder.typicode.com/todos/1'),\n  )\n  return await response.json()\n})\n\nexport const loadTodo = action(async (ctx) => {\n  try {\n    isLoadingAtom(ctx, true)\n    const data = await ctx.schedule((ctx) => fetchTodo(ctx))\n    todoAtom(ctx, data)\n  } catch (e) {\n    console.error(e)\n  } finally {\n    isLoadingAtom(ctx, false)\n  }\n})\n```\n\n----------------------------------------\n\nTITLE: Using Multiple Contexts in Reatom\nDESCRIPTION: Illustrates how to use multiple contexts with the same atom, showing that changes in one context don't affect the other.\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/src/content/docs/getting-started/learning.md#2025-04-23_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createCtx, atom } from '@reatom/framework'\n\nconst ctx1 = createCtx()\nconst ctx2 = createCtx()\n\nconst someAtom = atom(1, 'someAtom')\n\nconsole.log(ctx1.get(someAtom), ctx2.get(someAtom)) // logs: 1, 1\n\n// change value of an atom only in one context\nsomeAtom(ctx1, 100)\n\nconsole.log(ctx1.get(someAtom), ctx2.get(someAtom)) // logs: 100, 1\n```\n\n----------------------------------------\n\nTITLE: Setting Up Reatom Devtools\nDESCRIPTION: Typical setup code for initializing Reatom devtools in development environment. Creates a global devtools instance that can be accessed throughout the application.\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/src/content/docs/package/devtools.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare global {\n  var DEVTOOLS: null | Devtools\n}\nif (import.meta.env.DEV) {\n  const { createDevtools } = await import('@reatom/devtools')\n  globalThis.DEVTOOLS = createDevtools()\n} else {\n  globalThis.DEVTOOLS = null\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Optimistic Updates with Reatom in TypeScript\nDESCRIPTION: This snippet shows how to implement optimistic updates using Reatom's async atom. It updates the local state immediately while sending the update request to the server.\nSOURCE: https://github.com/reatom/reatom/blob/v3/packages/async/README.md#2025-04-23_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nimport { reatomAsync, withDataAtom } from '@reatom/async'\n\nexport const fetchList = reatomAsync(\n  (ctx) => request('api/list', ctx.controller),\n  'fetchList',\n).pipe(withDataAtom([]))\n\nexport const updateList = reatomAsync(\n  (ctx, newList) => {\n    const { signal } = ctx.controller\n    const data = JSON.stringify(newList)\n    return request('/api/list', { method: 'POST', data, signal })\n  },\n  {\n    name: 'updateList',\n    onEffect(ctx, params, promise) {\n      const [newList] = params\n      const newList = fetchList.dataAtom(ctx, newList)\n    },\n  },\n)\n```\n\n----------------------------------------\n\nTITLE: Error Handling with Reatom Async in TypeScript\nDESCRIPTION: Demonstrates how to handle errors using withErrorAtom. The errorAtom is updated on rejection and cleared on fulfillment, with custom error mapping.\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/src/content/docs/package/async.md#2025-04-23_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\nimport { reatomAsync, withErrorAtom } from '@reatom/async'\n\nexport const fetchList = reatomAsync(\n  (ctx) => request('api/list', ctx.controller),\n  'fetchList',\n).pipe(\n  withErrorAtom(\n    // optional mapper\n    (ctx, error) =>\n      error instanceof Response\n        ? error.status\n        : error?.message || 'unknown error',\n  ),\n)\n```\n\n----------------------------------------\n\nTITLE: Implementing Reatom with cookie-baker in TypeScript\nDESCRIPTION: Example demonstrating how to integrate cookie-baker with Reatom. It shows creating a cookie client with a type model, setting up real-time cookie updates, and using the Reatom adapter to manage cookies through both reactive and imperative approaches.\nSOURCE: https://github.com/reatom/reatom/blob/v3/packages/npm-cookie-baker/README.md#2025-04-23_snippet_6\n\nLANGUAGE: ts\nCODE:\n```\nimport {\n  Cookie as CookieClient,\n  createRealTimeCookie,\n} from '@cookie-baker/browser'\nimport { reatomCookie } from '@reatom/npm-cookie-baker'\n\ntype CookieModel = {\n  ga?: string\n  adc?: string\n}\n\nconst cookie = new CookieClient<CookieModel>()\nconst realTimeCookie = createRealTimeCookie(cookie)\n\nconst { cookieAtom, set, remove } = reatomCookie(cookie, realTimeCookie)\n\nconst ctx = createContext()\nctx.subscribe(cookieAtom, console.log)\n\nset(ctx, 'adc', 'dasf')\nremove(ctx, 'ga')\ncookie.set('adc', 'set-cookie-from-imperative-modify')\n```\n\n----------------------------------------\n\nTITLE: Subscribing to Atom Changes in Reatom\nDESCRIPTION: Shows how to subscribe to atom changes using the context's subscribe method and demonstrates how changes are propagated.\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/src/content/docs/getting-started/learning.md#2025-04-23_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nimport { atom, createCtx } from '@reatom/framework'\n\nconst ctx = createCtx()\n\nconst aAtom = atom(1, 'aAtom')\nconst bAtom = atom(2, 'bAtom')\nconst cAtom = atom((ctx) => ctx.spy(aAtom) + ctx.spy(bAtom), 'cAtom')\n\nctx.subscribe(cAtom, (c) => {\n  const a = ctx.get(aAtom)\n  const b = ctx.get(bAtom)\n  console.log(`${a} + ${b} = ${c}`)\n})\n\naAtom(ctx, 3) // logs: 3 + 2 = 5\nbAtom(ctx, 4) // logs: 3 + 4 = 7\nbAtom(ctx, 4) // does not log anything, as the state is not changed\n```\n\n----------------------------------------\n\nTITLE: Implementing Server-Side Rendering with Reatom Persist\nDESCRIPTION: A complete example demonstrating how to implement server-side rendering (SSR) using Reatom persist. Includes creating an SSR storage adapter, persisting atoms, and hydrating state on the client.\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/src/content/docs/package/persist.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\n// src/ssr.ts\nimport { createMemStorage, reatomPersist } from '@reatom/persist'\n\nconst ssrStorage = createMemStorage({ name: 'ssr', subscribe: false })\nexport const { snapshotAtom } = ssrStorage\nexport const withSsr = reatomPersist(ssrStorage)\n```\n\nLANGUAGE: typescript\nCODE:\n```\n// src/features/goods/model.ts\nimport { atom } from '@reatom/core'\nimport { withSsr } from 'src/ssr'\n\nexport const filtersAtom = atom('').pipe(withSsr('goods/filters'))\n\nexport const listAtom = atom(new Map()).pipe(\n  withSsr({\n    key: 'goods/list',\n    toSnapshot: (ctx, list) => [...list],\n    fromSnapshot: (ctx, snapshot) => new Map(snapshot),\n  }),\n)\n```\n\nLANGUAGE: typescript\nCODE:\n```\n// src/root.ts\nimport { createCtx } from '@reatom/core'\nimport { snapshotAtom } from 'src/ssr'\n\nexport const ssrHandler = async () => {\n  const ctx = createCtx()\n\n  await doAsyncStuffToFillTheState(ctx)\n\n  const snapshot = ctx.get(snapshotAtom)\n\n  return { snapshot }\n}\n\nexport const render = ({ snapshot }) => {\n  const ctx = createCtx()\n  snapshotAtom(ctx, snapshot)\n\n  runFeaturesAndRenderTheApp(ctx)\n}\n```\n\n----------------------------------------\n\nTITLE: Qualified reatomAsync Usage with Abort Control\nDESCRIPTION: Complete implementation showing advanced patterns including abort control, loading states, and error handling.\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/src/content/docs/package/async.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { reatomAsync } from '@reatom/async'\nimport { atom } from '@reatom/core'\n\ntype Element = {\n  id: string\n  /* ... */\n}\n\nexport const listAtom = atom(new Array<Element>(), 'listAtom')\nexport const errorAtom = atom<null | Error>(null, 'errorAtom')\nexport const isLoadingAtom = atom(\n  (ctx) => ctx.spy(fetchList.pendingAtom) > 0,\n  'isLoadingAtom',\n)\nconst abortControllerAtom = atom(new AbortController())\nconst ABORT = 'ABORT'\n\nexport const fetchList = reatomAsync((ctx, page: number) => {\n  ctx.get(abortControllerAtom).abort(ABORT)\n  abortControllerAtom(ctx, ctx.controller)\n\n  return request<Array<Element>>(`/api/list?page=${page}`, ctx.controller)\n}, 'fetchList')\n```\n\n----------------------------------------\n\nTITLE: Implementing Search Feature Model\nDESCRIPTION: Demonstrates atom creation, computed values, and action handling for a search feature. Includes state management for search input, loading state, and goods listing.\nSOURCE: https://github.com/reatom/reatom/blob/v3/packages/core/README.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\n// ~/features/search/model.ts\nimport { action, atom, batch } from '@reatom/core'\n\n// define your base mutable data references\n// by passing a primitive initial values\nconst searchAtom = atom('')\nconst isSearchingAtom = atom(false)\nconst goodsAtom = atom(new Array<Goods>())\n\n// define computed atoms to infer data\n// with smart and optimized caching\nconst tipAtom = atom((ctx) => {\n  // read and subscribe by `ctx.spy`\n  const isSearching = ctx.spy(isSearchingAtom)\n  const goodsCount = ctx.spy(goodsAtom).length\n\n  if (isSearching) {\n    return 'Searching...'\n  }\n  if (goodsCount === 0) {\n    // read atom lazy without subscribing by `get`\n    return ctx.get(searchAtom) ? 'Nothing found' : 'Try to search something'\n  }\n  if (goodsCount === 1) {\n    return `We found one treasure`\n  }\n  return `Found ${goodsCount} goods`\n})\n\n// define your actions to handle any effects and work with atoms\nconst fetchGoods = action(async (ctx, search: string) => {\n  // mutate base atoms by passing relative ctx and the new state\n  goodsAtom(ctx, [])\n\n  if (search === '') return\n\n  // all sync updates inside action automatically batched\n  // (relative atoms will compute after the function sync part)\n  isSearchingAtom(ctx, true)\n\n  // schedule side-effects\n  // which will be called after successful execution of all computations\n  const goods = await ctx.schedule(() =>\n    fetch(`/api/goods?search=${search}`).then((r) => r.json()),\n  )\n\n  // use `batch` to prevent glitches and extra effects.\n  batch(ctx, () => {\n    isSearchingAtom(ctx, false)\n    goodsAtom(ctx, goods)\n  })\n})\n// react to data changes\nsearchAtom.onChange(fetchGoods)\n```\n\n----------------------------------------\n\nTITLE: Using useAtom Hook for Basic State Access\nDESCRIPTION: Example of using the useAtom hook to access the state of a Reatom atom in a React component.\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/src/content/docs/compat/react-v2.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst [data] = useAtom(dataAtom)\n```\n\n----------------------------------------\n\nTITLE: Dynamic Atom Creation and Management in TypeScript\nDESCRIPTION: Demonstrates how to dynamically create and manage atoms, including conditional atom selection and updating nested atom structures.\nSOURCE: https://github.com/reatom/reatom/blob/v3/packages/core/README.md#2025-04-23_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nconst currencyAtom = atom('us')\nconst currenciesAtom = atom({ us: atom(0) })\nexport const currencyValueAtom = atom((ctx) => {\n  const currency = ctx.spy(currencyAtom)\n  let valueAtom = ctx.spy(currenciesAtom)[currency]\n\n  if (!valueAtom) {\n    valueAtom = atom(0)\n    currenciesAtom(ctx, (state) => ({\n      ...state,\n      [currency]: valueAtom,\n    }))\n  }\n\n  return ctx.spy(valueAtom)\n})\n\n// update could look like\nctx.get(currenciesAtom)[ctx.get(currencyAtom)](ctx, newValue)\n```\n\n----------------------------------------\n\nTITLE: Implementing Error Handling with Reatom in TypeScript\nDESCRIPTION: This snippet shows how to add error handling to an async atom using withErrorAtom. It includes a custom error mapper function to standardize error formats.\nSOURCE: https://github.com/reatom/reatom/blob/v3/packages/async/README.md#2025-04-23_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\nimport { reatomAsync, withErrorAtom } from '@reatom/async'\n\nexport const fetchList = reatomAsync(\n  (ctx) => request('api/list', ctx.controller),\n  'fetchList',\n).pipe(\n  withErrorAtom(\n    // optional mapper\n    (ctx, error) =>\n      error instanceof Response\n        ? error.status\n        : error?.message || 'unknown error',\n  ),\n)\n```\n\n----------------------------------------\n\nTITLE: Connecting Search Feature to DOM\nDESCRIPTION: Shows how to connect the search feature model to DOM elements, including subscription to atoms and event handling.\nSOURCE: https://github.com/reatom/reatom/blob/v3/packages/core/README.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\n// ~/features/search/index.ts\nimport { ctx } from '~/ctx'\nimport { tipAtom, onSearch, fetchGoods } from './model'\n\n// subscribe to your atoms\nctx.subscribe(tipAtom, (tip) => {\n  document.getElementById('goods-tip').innerText = tip\n})\n// handle user interactions by your actions\ndocument.getElementById('search-input').addEventListener('input', (event) => {\n  searchAtom(ctx, event.currentTarget.value)\n})\n```\n\n----------------------------------------\n\nTITLE: Implementing Retry with Exponential Backoff in Reatom\nDESCRIPTION: Demonstrates how to implement a progressive retry pattern with exponential backoff for failed requests. The retry delay increases with each attempt following the formula 100 * Math.min(200, retries ** 3).\nSOURCE: https://github.com/reatom/reatom/blob/v3/packages/async/README.md#2025-04-23_snippet_19\n\nLANGUAGE: typescript\nCODE:\n```\nimport { atom, reatomAsync, withRetry } from '@reatom/async'\n\nexport const fetchList = reatomAsync(\n  (ctx) => request('api/list', ctx.controller),\n  'fetchList',\n).pipe(\n  withRetry({\n    onReject: (ctx, error, retries) => 100 * Math.min(200, retries ** 3),\n  }),\n  withAssign((target, name) => ({\n    loadingAtom: atom(\n      (ctx) =>\n        ctx.spy(target.pendingAtom) > 0 || ctx.spy(target.retriesAtom) > 0,\n      `${name}.loadingAtom`,\n    ),\n  })),\n)\n```\n\n----------------------------------------\n\nTITLE: Spawn Independent Context Operations\nDESCRIPTION: Shows how to spawn operations with independent context that won't be affected by parent context abortion.\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/src/content/docs/package/effects.md#2025-04-23_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\nonConnect(someAtom, (ctx) => {\n  spawn(ctx, async (spawnCtx) => {\n    const some = await api.getSome(spawnCtx)\n    someAtom(spawnCtx, some)\n  })\n})\n```\n\n----------------------------------------\n\nTITLE: Using Reatom Atom in Svelte Component\nDESCRIPTION: Demonstrates how to create and use a Reatom atom within a Svelte component, including reactive updates.\nSOURCE: https://github.com/reatom/reatom/blob/v3/packages/npm-svelte/README.md#2025-04-23_snippet_3\n\nLANGUAGE: svelte\nCODE:\n```\n<script>\n  import { atom } from '@reatom/core'\n  import { withSvelte } from '@reatom/npm-svelte'\n\n  const count = atom(0).pipe(withSvelte)\n</script>\n\n<button on:click={() => $count++}>\n\tClicked {$count} {$count === 1 ? 'time' : 'times'}\n</button>\n```\n\n----------------------------------------\n\nTITLE: Feature Management with withDataAtom\nDESCRIPTION: Example demonstrating feature data management using withDataAtom operator for handling backend data and form state.\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/src/content/docs/package/async.md#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport { reatomAsync, withDataAtom } from '@reatom/async'\n\ntype Feature = {\n  /*...*/\n}\n\nexport const fetchFeature = reatomAsync(\n  (ctx) => request<Feature>('/api/feature', ctx.controller),\n  'fetchFeature',\n).pipe(withDataAtom(null))\n\nexport const changeFeature = action(\n  (ctx, property: keyof Feature, value: any) => {\n    fetchUser.dataAtom(ctx, (user) => ({ ...user, [property]: value }))\n  },\n  'changeFeature',\n)\n\nexport const syncFeature = reatomAsync((ctx) => {\n  const { signal } = ctx.controller\n  const body = JSON.stringify(ctx.get(fetchFeature.dataAtom))\n  return request('/api/feature', { method: 'POST', body, signal })\n}, 'syncFeature')\n```\n\n----------------------------------------\n\nTITLE: Implementing Login Form with Reatom\nDESCRIPTION: Example showing how to create a login form with field validation using Reatom form library. Demonstrates form initialization, field creation, and validation implementation.\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/src/content/docs/package/form.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { reatomForm } from '@reatom/form'\n\nexport const loginForm = reatomForm(\n  {\n    async onSubmit(ctx) {\n      const user = await api.login(ctx, {\n        name: ctx.get(nameField),\n        password: ctx.get(passwordField),\n      })\n    },\n  },\n  'loginForm',\n)\nexport const nameField = loginForm.reatomField({ initState: '' }, 'nameField')\nexport const passwordField = loginForm.reatomField(\n  {\n    initState: '',\n    validate(ctx, { state }) {\n      if (state.length < 6)\n        throw new Error('The password should have at least six characters.')\n    },\n  },\n  'passwordField'\n)\n```\n\n----------------------------------------\n\nTITLE: Handling IndexedDB Loading States in Reatom to Prevent Flickering\nDESCRIPTION: Implementation pattern to avoid flickering when using IndexedDB by adding a ready state atom and delaying rendering until data is loaded. Uses requestIdleCallback for optimal performance.\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/src/content/docs/package/persist-web-storage.md#2025-04-23_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nimport { reatomResource, withCache, onConnect, sleep } from '@reatom/framework'\nimport { withIndexedDb } from '@reatom/persist-web-storage'\n\nexport const listResource = reatomResource(\n  async (ctx) => api.getList(ctx.spy(pageAtom)),\n  'listResource',\n).pipe(withIndexedDb({ key: 'hugeListAtom', dbName: 'myCustomDb', channel }))\nconst isListReadyAtom = atom(false, 'isListReadyAtom')\nonConnect(listResource, async (ctx) => {\n  await ctx.schedule(() => new Promise((r) => requestIdleCallback(r)))\n  isListReadyAtom(ctx, true)\n  return () => isListReadyAtom(ctx, false)\n})\n```\n\n----------------------------------------\n\nTITLE: Reading Atom Values in Reatom\nDESCRIPTION: Demonstrates how to read the values of atoms using the context's get method.\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/src/content/docs/getting-started/learning.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { atom, createCtx } from '@reatom/framework'\n\nconst ctx = createCtx()\n\nconst aAtom = atom(1, 'aAtom')\nconst bAtom = atom(2, 'bAtom')\nconst cAtom = atom((ctx) => ctx.spy(aAtom) + ctx.spy(bAtom), 'cAtom')\n\nctx.get(aAtom) // 1\nctx.get(bAtom) // 2\nctx.get(cAtom) // 3\n```\n\n----------------------------------------\n\nTITLE: HistoryAtom TypeScript Interface Definition\nDESCRIPTION: TypeScript interface definition for the HistoryAtom, which extends AtomMut<History> with various navigation methods like back, forward, push, and replace.\nSOURCE: https://github.com/reatom/reatom/blob/v3/packages/npm-history/README.md#2025-04-23_snippet_2\n\nLANGUAGE: ts\nCODE:\n```\nimport { History, Location, To, Blocker } from 'history'\n\nexport interface HistoryAtom extends AtomMut<History> {\n  back: Action<[]>\n  block: Action<[blocker: Blocker], () => void>\n  forward: Action<[]>\n  go: Action<[delta: number]>\n  location: Atom<Location>\n  push: Action<[to: To, state?: any]>\n  replace: Action<[to: To, state?: any]>\n}\n\nexport const historyAtom: HistoryAtom\n```\n\n----------------------------------------\n\nTITLE: Initializing and Using reatomArray in TypeScript\nDESCRIPTION: Demonstrates the usage of reatomArray, which provides an API based on the proposal-change-array-by-copy. It includes built-in actions for array manipulation.\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/src/content/docs/package/primitives.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { reatomArray } from '@reatom/primitives'\n\nconst thingsAtom = reatomArray<Entity>()\n\n// built-in actions:\nthingsAtom.toReversed(ctx)\nthingsAtom.toSorted(ctx, (a, b) => (a.some > b.some ? -1 : 1))\nthingsAtom.toSpliced(ctx, index, count)\nthingsAtom.with(ctx, index, element)\nthingsAtom.push(ctx, element)\nthingsAtom.pop(ctx)\nthingsAtom.shift(ctx)\nthingsAtom.unshift(ctx, element)\nthingsAtom.slice(ctx, start, end)\n```\n\n----------------------------------------\n\nTITLE: Setting Up Reatom Context Provider in React\nDESCRIPTION: React component setup to provide Reatom context to the application using reatomContext.Provider.\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/src/content/docs/getting-started/setup.md#2025-04-23_snippet_3\n\nLANGUAGE: jsx\nCODE:\n```\nimport { createCtx } from '@reatom/core'\nimport { reatomContext } from '@reatom/npm-react'\nimport { Main } from './path/to/an/Main'\n\nconst ctx = createCtx()\n\nexport const App = () => (\n  <reatomContext.Provider value={ctx}>\n    <Main />\n  </reatomContext.Provider>\n)\n```\n\n----------------------------------------\n\nTITLE: Creating Computed Atoms in React Components\nDESCRIPTION: Demonstration of creating computed atoms directly inside the useAtom hook, allowing for dynamic calculations based on dependencies.\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/src/content/docs/getting-started/setup.md#2025-04-23_snippet_5\n\nLANGUAGE: jsx\nCODE:\n```\nconst nameAtom = atom('Joe')\n\nconst Greeting = () => {\n  const t = useTranslation()\n  const [name, setName] = useAtom(nameAtom)\n  const [greeting] = useAtom(\n    (ctx) => `${t('common:GREETING')} ${ctx.spy(nameAtom)}!`,\n    [t],\n  )\n\n  return (\n    <>\n      <label>\n        What is your name?:\n        <input value={name} onChange={(e) => setName(e.currentTarget.value)} />\n      </label>\n      <h1>{greeting}!</h1>\n    </>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Handling Promise States with reatomAsync Hooks\nDESCRIPTION: Shows how to use optional hooks in reatomAsync to handle different promise states. It demonstrates updating atoms based on promise fulfillment, rejection, and the effect start.\nSOURCE: https://github.com/reatom/reatom/blob/v3/packages/async/README.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { atom } from '@reatom/core'\nimport { reatomAsync } from '@reatom/async'\n\nconst listAtom = atom([])\nconst errorAtom = atom(null)\nexport const fetchList = reatomAsync(\n  (ctx, page: number) => request(`/api/list?page=${page}`, ctx.controller),\n  {\n    name: 'fetchList',\n    onFulfill(ctx, result) {\n      listAtom(ctx, result)\n    },\n    onReject(ctx, error) {\n      errorAtom(ctx, error)\n    },\n    onEffect(ctx, params, promise) {\n      // clear outdated data on request start\n      listAtom(ctx, [])\n      errorAtom(ctx, null)\n    },\n  },\n)\n```\n\n----------------------------------------\n\nTITLE: Advanced Transition to Reatom v3 API\nDESCRIPTION: Shows a more advanced transition to v3 API, using the new atom and action syntax while still maintaining compatibility with v1 through v3toV1.\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/src/content/docs/compat/core-v1.md#2025-04-23_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nimport { combine, v3toV1 } from '@reatom/core-v1'\nimport { action, atom } from '@reatom/core'\n\nconst add = action()\nconst n1Atom = atom((ctx, state = 0) => {\n  ctx.spy(add).forEach(({ payload }) => (state += payload))\n  return state\n})\nconst n2Atom = atom((ctx, state = 0) => {\n  ctx.spy(add).forEach(({ payload }) => (state += payload))\n  return state\n})\nconst sumAtom = atom((ctx) => ctx.spy(n1Atom) + ctx.spy(n2Atom))\nconst rootAtom = combine({ sumAtom: v3toV1(sumAtom) })\n```\n\n----------------------------------------\n\nTITLE: Defining Persist Adapter Interface\nDESCRIPTION: TypeScript interface definitions for creating custom persistence adapters, including storage interface and persist options\nSOURCE: https://github.com/reatom/reatom/blob/v3/packages/persist/README.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nexport const reatomPersist = (\n  storage: PersistStorage,\n): WithPersist & {\n  storageAtom: AtomMut<PersistStorage>\n}\n\nexport interface WithPersist {\n  <T extends Atom>(\n    options: string | WithPersistOptions<AtomState<T>>\n  ): (anAtom: T) => T\n}\n\nexport interface PersistStorage {\n  name: string\n  get(ctx: Ctx, key: string): PersistRecord | null\n  set(ctx: Ctx, key: string, rec: PersistRecord): void\n  clear?(ctx: Ctx, key: string): void\n  subscribe?(ctx: Ctx, key: string, callback: Fn<[]>): Unsubscribe\n}\n\nexport interface PersistRecord<T = unknown> {\n  data: T\n  id: number\n  timestamp: number\n  version: number\n  to: number\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing onConnect Hook for WebSocket Messages in TypeScript\nDESCRIPTION: Demonstrates how to use the onConnect hook to handle WebSocket messages and update an atom's state when connected.\nSOURCE: https://github.com/reatom/reatom/blob/v3/packages/hooks/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { atom } from '@reatom/core'\nimport { onConnect } from '@reatom/hooks'\n\nexport const messagesAtom = atom([], 'messagesAtom')\nconst dispose = onConnect(messagesAtom, (ctx) => {\n  const cb = (message) => {\n    messagesAtom(ctx, (messages) => [...messages, message])\n  }\n\n  WS.on('message', cb)\n\n  return () => WS.off('message', cb)\n})\n```\n\n----------------------------------------\n\nTITLE: Reatom Testing Example\nDESCRIPTION: Comprehensive test example demonstrating the usage of createTestCtx, including atom creation, action handling, mocking, and tracking state changes\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/src/content/docs/package/testing.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\ntest('createTestCtx', async () => {\n  const add = action<number>()\n  const countAtom = atom((ctx, state = 0) => {\n    ctx.spy(add, ({ payload }) => (state += payload))\n    return state\n  })\n  const ctx = createTestCtx()\n  const track = ctx.subscribeTrack(countAtom)\n\n  expect(track.calls.length).toEqual(1)\n  expect(track.lastInput()).toEqual(0)\n\n  add(ctx, 10)\n  expect(track.calls.length).toEqual(2)\n  expect(track.lastInput()).toEqual(10)\n\n  ctx.mockAction(add, (ctx, param) => 100)\n  add(ctx, 10)\n  expect(track.calls.length).toEqual(3)\n  expect(track.lastInput()).toEqual(110)\n\n  const unmock = ctx.mock(countAtom, 123)\n  expect(track.calls.length).toEqual(4)\n  expect(track.lastInput()).toEqual(123)\n  add(ctx, 10)\n  expect(track.calls.length).toEqual(4)\n  expect(track.lastInput()).toEqual(123)\n\n  unmock()\n  add(ctx, 10)\n  expect(track.calls.length).toEqual(5)\n  expect(track.lastInput()).toEqual(223)\n})\n```\n\n----------------------------------------\n\nTITLE: Implementing Retry with Exponential Backoff in Reatom\nDESCRIPTION: This snippet demonstrates how to implement a retry mechanism with exponential backoff using Reatom's async utilities. It includes a custom loading atom that considers both pending and retry states.\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/src/content/docs/package/async.md#2025-04-23_snippet_22\n\nLANGUAGE: typescript\nCODE:\n```\nimport { atom, reatomAsync, withRetry } from '@reatom/async'\n\nexport const fetchList = reatomAsync(\n  (ctx) => request('api/list', ctx.controller),\n  'fetchList',\n).pipe(\n  withRetry({\n    onReject: (ctx, error, retries) => 100 * Math.min(200, retries ** 3),\n  }),\n  withAssign((target, name) => ({\n    loadingAtom: atom(\n      (ctx) =>\n        ctx.spy(target.pendingAtom) > 0 || ctx.spy(target.retriesAtom) > 0,\n      `${name}.loadingAtom`,\n    ),\n  })),\n)\n```\n\n----------------------------------------\n\nTITLE: Testing Async Actions with Mocking in Reatom\nDESCRIPTION: Unit test for the async todo loading implementation, using action mocking to avoid real API calls. The test mocks the fetchTodo action to return predefined data and verifies that the todoAtom is updated correctly.\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/src/content/docs/getting-started/testing.md#2025-04-23_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\nimport { expect, test } from 'vitest'\nimport { createTestCtx } from '@reatom/testing'\nimport { loadTodo, fetchTodo, todoAtom } from './main'\n\ntest('Test loadData atom', async () => {\n  const ctx = createTestCtx()\n  const track = ctx.subscribeTrack(todoAtom)\n\n  // Mock action with call\n  ctx.mockAction(fetchTodo, (ctx) => Promise.resolve([{ id: 'foo' }]))\n\n  await loadTodo(ctx)\n  expect(track.lastInput()).toStrictEqual([{ id: 'foo' }])\n})\n```\n\n----------------------------------------\n\nTITLE: Defining Atoms with Function Properties in TypeScript\nDESCRIPTION: Shows atom creation using function properties. This approach defines methods, a computer function for state updates, and a change listener within an object.\nSOURCE: https://github.com/reatom/reatom/blob/v3/packages/core/history-v2.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nconst add = declareAction<number>()\n\nconst counterAtom = declareAtom(0, {\n  id: `counter`,\n  ctx: { updates: 0 },\n  methods: {\n    inc: (value:void, state) => state + 1,\n  },\n  computer: ($, state) => {\n    $(add, (value) => state += value))\n\n    if ($(shouldSyncCounterAtom)) {\n      $(globalCounterAtom, (globalCounter) => state = globalCounter)\n    }\n\n    return state\n  }\n  change: (newState, state) => (store, ctx) =>\n    console.log(\n      `counterAtom receive new value: ${state}.`,\n      `It is ${++ctx.updates} update`,\n    ),\n})\n```\n\n----------------------------------------\n\nTITLE: Initializing and Using reatomSet in TypeScript\nDESCRIPTION: Demonstrates the usage of reatomSet, which provides a wrapper around Set with built-in actions and functions for manipulation and retrieval.\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/src/content/docs/package/primitives.md#2025-04-23_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nimport { reatomSet } from '@reatom/primitives'\n\nconst setAtom = reatomSet<Entity>()\n\n// built-in actions:\nsetAtom.add(ctx, el)\nsetAtom.delete(ctx, el)\nsetAtom.clear(ctx)\nsetAtom.reset(ctx)\nsetAtom.getOrCreate(ctx, key, () => new Entity()) // non nullable entity\n\n// built-in atoms:\nctx.get(thingsAtom.sizeAtom)\n\n// built-in functions:\nsetAtom.get(ctx, key) // nullable entity\nsetAtom.has(ctx, el)\n```\n\n----------------------------------------\n\nTITLE: Installing Node.js implementation with yarn\nDESCRIPTION: Command to install the Node.js-specific implementation of cookie-baker using yarn.\nSOURCE: https://github.com/reatom/reatom/blob/v3/packages/npm-cookie-baker/README.md#2025-04-23_snippet_4\n\nLANGUAGE: sh\nCODE:\n```\nyarn add @cookie-baker/node\n```\n\n----------------------------------------\n\nTITLE: Scheduling Effects with Promise Handling in Reatom\nDESCRIPTION: Demonstrates how to schedule effects using ctx.schedule with promise handling. Shows loading state management with async data fetching.\nSOURCE: https://github.com/reatom/reatom/blob/v3/packages/core/README.md#2025-04-23_snippet_16\n\nLANGUAGE: typescript\nCODE:\n```\nconst fetchData = action((ctx) => {\n  loadingAtom(ctx, true)\n  ctx.schedule(effect).then((data) => {\n    loadingAtom(ctx, false)\n    dataAtom(ctx, data)\n  })\n})\n```\n\n----------------------------------------\n\nTITLE: Creating a Custom reatomFetch Instance in TypeScript\nDESCRIPTION: Demonstrates how to create a custom reatomFetch instance using createReatomFetch. This allows for setting application-wide default options for all requests.\nSOURCE: https://github.com/reatom/reatom/blob/v3/packages/web-fetch/README.md#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nexport const reatomFetch = createReatomFetch({\n  // client defaults\n})\n```\n\n----------------------------------------\n\nTITLE: Connecting Reatom Logger to Context\nDESCRIPTION: Code snippet showing how to connect the logger to a Reatom context. The logger is conditionally enabled only in development environment.\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/src/content/docs/getting-started/debugging.md#2025-04-23_snippet_1\n\nLANGUAGE: ts\nCODE:\n```\nimport { createCtx } from '@reatom/core'\nimport { connectLogger } from '@reatom/logger'\n\nconst ctx = createCtx()\n\nif (import.meta.env.DEV) {\n  connectLogger(ctx)\n}\n```\n\n----------------------------------------\n\nTITLE: Using withAssign Operator in TypeScript\nDESCRIPTION: Shows the usage of withAssign operator, which makes it easier to attach properties such as computed atoms and reducer actions to an atom for better code organization.\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/src/content/docs/package/primitives.md#2025-04-23_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nimport {\n  atom,\n  withAssign,\n  action,\n  reatomResource,\n  withRetry,\n} from '@reatom/framework'\n\nconst pageAtom = atom(1).pipe(\n  withAssign((pageAtom, name) => ({\n    prev: action(\n      (ctx) => pageAtom(ctx, (prev) => Math.max(1, prev - 1)),\n      `${name}.prev`,\n    ),\n    next: action((ctx) => pageAtom(ctx, (prev) => prev + 1), `${name}.next`),\n  })),\n)\n\nconst list = reatomResource(async (ctx) => {\n  const page = ctx.spy(pageAtom)\n  return await ctx.schedule(() => request(`/api/list/${page}`))\n}, 'fetchList').pipe(\n  withRetry({\n    onReject: (ctx, error, retries) => 100 * Math.min(200, retries ** 3),\n  }),\n  withAssign((list, name) => ({\n    loadingAtom: atom(\n      (ctx) => ctx.spy(list.pendingAtom) > 0 || ctx.spy(list.retriesAtom) > 0,\n      `${name}.loadingAtom`,\n    ),\n  })),\n)\n```\n\n----------------------------------------\n\nTITLE: Cache Invalidation with Loading State in TypeScript\nDESCRIPTION: Shows how to implement cache invalidation with a loading state atom to track pending operations.\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/src/content/docs/package/async.md#2025-04-23_snippet_16\n\nLANGUAGE: typescript\nCODE:\n```\nimport { reatomAsync, withCache, withDataAtom } from '@reatom/async'\n\nexport const fetchList = reatomAsync(\n  (ctx) => request('api/list', ctx.controller),\n  'fetchList',\n).pipe(withCache(), withDataAtom())\n\nexport const updateList = reatomAction(async () => {\n  /*  */\n}, 'updateList')\nupdateList.onFulfill.onCall(fetchList.cacheAtom.invalidate)\n\nexport const listLoadingAtom = atom(\n  (ctx) => ctx.spy(fetchList.pendingAtom) + ctx.spy(updateList.pendingAtom) > 0,\n)\n```\n\n----------------------------------------\n\nTITLE: Fetching User Data With Batching\nDESCRIPTION: This snippet shows how to use the 'batch' function to group multiple updates into a single transaction, improving performance and consistency.\nSOURCE: https://github.com/reatom/reatom/blob/v3/packages/core/README.md#2025-04-23_snippet_19\n\nLANGUAGE: typescript\nCODE:\n```\nimport { action, atom, batch } from '@reatom/core'\n\nexport const firstNameAtom = atom('', 'firstNameAtom')\nexport const lastNameAtom = atom('', 'lastNameAtom')\nexport const fullNameAtom = atom(\n  (ctx) => `${ctx.spy(firstNameAtom)} ${ctx.spy(lastNameAtom)}`,\n  'fullNameAtom',\n)\nexport const fetchUser = action(async (ctx, id: string) => {\n  const user = await ctx.schedule(() => api.getUser(id))\n  batch(ctx, () => {\n    firstNameAtom(ctx, user.firstName)\n    lastNameAtom(ctx, user.lastName)\n  })\n}, 'fetchUser')\n\nctx.subscribe(fullNameAtom, console.log)\n// log: \" \"\nfetchUser(ctx, 1)\n// log: \"John Doe\"\n// All good\nfetchUser(ctx, 2)\n// log: \"Mat Black\"\n```\n\n----------------------------------------\n\nTITLE: WebSocket Event Handling with Reatom\nDESCRIPTION: Implementation of a WebSocket connection handler using Reatom atoms and event listeners. Demonstrates subscription management for stock ticker data with proper cleanup.\nSOURCE: https://github.com/reatom/reatom/blob/v3/packages/web/README.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { atom, onConnect, onCtxAbort } from '@reatom/framework'\nimport { onEvent } from '@reatom/web'\n\nconst socket = new WebSocket('wss://example.com')\n\nconst reatomStock = (ticker) => {\n  const stockAtom = atom(null, `${ticker}StockAtom`)\n  onConnect(stockAtom, async (ctx) => {\n    if (socket.readyState !== WebSocket.OPEN) {\n      await onEvent(ctx, socket, 'open')\n    }\n    socket.send(JSON.stringify({ ticker, type: 'sub' }))\n    onEvent(ctx, socket, 'message', (event) => {\n      if (event.data.ticker === ticker) stockAtom(ctx, JSON.parse(event.data))\n    })\n    onEvent(ctx, socket, 'close', () => ctx.controller.abort())\n    onEvent(ctx, socket, 'error', () => ctx.controller.abort())\n    onCtxAbort(ctx, () =>\n      socket.send(JSON.stringify({ ticker, type: 'unsub' })),\n    )\n  })\n\n  return stockAtom\n}\n\nconst googStockAtom = reatomStock('GOOG')\n\nctx.subscribe(googStockAtom, updateView)\n```\n\n----------------------------------------\n\nTITLE: Simplified Resource Fetching with reatomResource in Reatom (TypeScript)\nDESCRIPTION: Shows how reatomResource reduces boilerplate by automatically handling dependencies with ctx.spy, managing request cancellation, and simplifying the overall API.\nSOURCE: https://github.com/reatom/reatom/blob/v3/packages/async/README.md#2025-04-23_snippet_26\n\nLANGUAGE: typescript\nCODE:\n```\nimport { reatomResource, withDataAtom } from '@reatom/async'\n\nconst listResource = reatomResource(async (ctx) => {\n  const page = ctx.spy(pageAtom)\n  const search = ctx.spy(searchAtom)\n  return await ctx.schedule(() =>\n    request(`/api/list?page=${page}&q=${search}`, ctx.controller),\n  )\n}, 'listResource').pipe(withDataAtom([]))\n```\n\n----------------------------------------\n\nTITLE: Defining Persist Adapter Options Interface in TypeScript\nDESCRIPTION: TypeScript interface for the options that can be passed to a persistence adapter. Includes configuration for key, serialization, migrations, subscriptions, and versioning.\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/src/content/docs/package/persist.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface WithPersistOptions<T> {\n  /**\n   * Key of the storage record.\n   */\n  key: string\n  /**\n   * Custom snapshot serializer.\n   */\n  toSnapshot?: Fn<[ctx: Ctx, state: T], unknown>\n  /**\n   * Custom snapshot deserializer.\n   */\n  fromSnapshot?: Fn<[ctx: Ctx, snapshot: unknown, state?: T], T>\n  /**\n   * A callback to call if the version of a stored snapshot is older than `version` option.\n   */\n  migration?: Fn<[ctx: Ctx, persistRecord: PersistRecord], T>\n  /**\n   * Determines whether the atom is updated on storage updates.\n   * @defaultValue true\n   */\n  subscribe?: boolean\n  /**\n   * Number of milliseconds from the snapshot creation time after which it will be deleted.\n   * @defaultValue MAX_SAFE_TIMEOUT\n   */\n  time?: number\n  /**\n   * Version of the stored snapshot. Triggers `migration`.\n   * @defaultValue 0\n   */\n  version?: number\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Computed Atom with Previous State in Reatom\nDESCRIPTION: Demonstrates creating a computed atom that uses the previous state and deep equality check to optimize updates.\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/src/content/docs/getting-started/learning.md#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport { atom, isDeepEqual } from '@reatom/framework'\n\nconst listAtom = atom<number[]>([1, 2, 3, 4, 5], 'listAtom')\n\nconst evenListAtom = atom((ctx, state = []) => {\n  const newState = ctx.spy(listAtom).filter((n) => n % 2 === 0)\n  return isDeepEqual(state, newState) ? state : newState\n}, 'evenListAtom')\n```\n\n----------------------------------------\n\nTITLE: Implementing Cookie Management with Reatom\nDESCRIPTION: Example showing how to set up and use cookie management with Reatom and cookie-baker. Demonstrates creating a cookie client, setting up real-time cookie tracking, and performing cookie operations.\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/src/content/docs/package/npm-cookie-baker.md#2025-04-23_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nimport {\n  Cookie as CookieClient,\n  createRealTimeCookie,\n} from '@cookie-baker/browser'\nimport { reatomCookie } from '@reatom/npm-cookie-baker'\n\ntype CookieModel = {\n  ga?: string\n  adc?: string\n}\n\nconst cookie = new CookieClient<CookieModel>()\nconst realTimeCookie = createRealTimeCookie(cookie)\n\nconst { cookieAtom, set, remove } = reatomCookie(cookie, realTimeCookie)\n\nconst ctx = createContext()\nctx.subscribe(cookieAtom, console.log)\n\nset(ctx, 'adc', 'dasf')\nremove(ctx, 'ga')\ncookie.set('adc', 'set-cookie-from-imperative-modify')\n```\n\n----------------------------------------\n\nTITLE: Simplified Data Fetching with Reatom onConnect\nDESCRIPTION: Simplified version of the previous example using onConnect to automatically fetch data when the component subscribes to the atom, reducing boilerplate code.\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/src/content/docs/package/hooks.md#2025-04-23_snippet_3\n\nLANGUAGE: tsx\nCODE:\n```\nimport { reatomAsync, onConnect, withDataAtom } from '@reatom/framework'\nimport { useAtom } from '@reatom/npm-react'\n\nexport const fetchList = reatomAsync(\n  (ctx) => request('api/list', ctx.controller),\n  'fetchList',\n).pipe(withDataAtom([]))\nonConnect(fetchList.dataAtom, fetchList)\n\nexport const List = () => {\n  const [list] = useAtom(fetchList.dataAtom)\n\n  return <ul>{list.map(() => '...')}</ul>\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Custom BroadcastChannel for Atom Synchronization in Reatom\nDESCRIPTION: Advanced usage of BroadcastChannel adapter where a custom channel instance is created and additional event handlers are added before using it with an atom.\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/src/content/docs/package/persist-web-storage.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { atom } from '@reatom/framework'\nimport { reatomPersistBroadcastChannel } from '@reatom/persist-web-storage'\n\nconst myChannel = new BroadcastChannel('customReusableChannel')\n\nmyChannel.onmessage((event) => {\n  console.log(event)\n  // Do some work here\n  // ...\n})\n\nconst withMyBroadcastChannel = reatomPersistBroadcastChannel(myChannel)\n\nexport const isAuthedAtom = atom('', 'isAuthedAtom').pipe(\n  withMyBroadcastChannel('isAuthedAtom'),\n)\n```\n\n----------------------------------------\n\nTITLE: Configuring Batching for React-DOM with Reatom\nDESCRIPTION: This snippet demonstrates how to set up batching for Reatom with React-DOM in React versions 16 and 17. It imports the necessary functions and configures batching to optimize updates.\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/src/content/docs/compat/react-v1.md#2025-04-23_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport { unstable_batchedUpdates } from 'react-dom'\nimport { setupBatch } from '@reatom/react-v1'\n\nsetupBatch(unstable_batchedUpdates)\n```\n\n----------------------------------------\n\nTITLE: Invalidating Cache in Reatom Async Actions (TypeScript)\nDESCRIPTION: Demonstrates how to invalidate the cache for a Reatom async action using the reset method on the cacheAtom. It also shows how to use the invalidate method to clear the cache and immediately retry the effect.\nSOURCE: https://github.com/reatom/reatom/blob/v3/packages/async/README.md#2025-04-23_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\nimport { reatomAsync, withCache, withDataAtom } from '@reatom/async'\n\nexport const fetchList = reatomAsync(\n  (ctx) => request('api/list', ctx.controller),\n  'fetchList',\n).pipe(withCache(), withDataAtom())\n\nexport const updateList = reatomAsync(async () => {\n  /*  */\n}, 'updateList')\nupdateList.onFulfill.onCall(fetchList.cacheAtom.reset)\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport { reatomAsync, withCache, withDataAtom } from '@reatom/async'\n\nexport const fetchList = reatomAsync(\n  (ctx) => request('api/list', ctx.controller),\n  'fetchList',\n).pipe(withCache(), withDataAtom())\n\nexport const updateList = reatomAction(async () => {\n  /*  */\n}, 'updateList')\nupdateList.onFulfill.onCall(fetchList.cacheAtom.invalidate)\n\nexport const listLoadingAtom = atom(\n  (ctx) => ctx.spy(fetchList.pendingAtom) + ctx.spy(updateList.pendingAtom) > 0,\n)\n```\n\n----------------------------------------\n\nTITLE: Using isInit for First-Time Call Detection in TypeScript\nDESCRIPTION: Shows how to use the isInit utility to check if an atom or action is being called for the first time in the current context.\nSOURCE: https://github.com/reatom/reatom/blob/v3/packages/hooks/README.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { action } from '@reatom/core'\nimport { isInit } from '@reatom/hooks'\n\nexport const doSome = action((ctx, payload) => {\n  if (isInit(ctx)) {\n    // setup\n  }\n  return work()\n})\n```\n\n----------------------------------------\n\nTITLE: Implementing Async Resource with Explicit Triggers in Reatom\nDESCRIPTION: Shows a traditional implementation of async resource fetching with explicit triggers, using reatomAsync with boilerplate code for connecting, triggering, and handling cleanup.\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/src/content/docs/package/async.md#2025-04-23_snippet_29\n\nLANGUAGE: typescript\nCODE:\n```\nimport { reatomAsync, withDataAtom, withAbort } from '@reatom/async'\nimport { onConnect } from '@reatom/hooks'\n\nconst fetchList = reatomAsync(async (ctx, page: string, search: string) => {\n  return await request(`/api/list?page=${page}&q=${search}`, ctx.controller)\n}, 'fetchList').pipe(withDataAtom([]), withAbort())\nonConnect(fetchList.dataAtom, (ctx) => {\n  // init\n  fetchList(ctx, ctx.get(pageAtom), ctx.get(searchAtom))\n  // cleanup\n  return () => fetchList.abort(ctx)\n})\n// trigger\npageAtom.onChange((ctx, page) =>\n  fetchSuggestion(ctx, page, ctx.get(searchAtom)),\n)\nsearchAtom.onChange((ctx, search) =>\n  fetchSuggestion(ctx, ctx.get(pageAtom), search),\n)\n```\n\n----------------------------------------\n\nTITLE: Optimistic Updates with Reatom Async in TypeScript\nDESCRIPTION: Shows how to implement optimistic updates using Reatom's async package. The updateList atom updates the local state immediately before sending the request.\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/src/content/docs/package/async.md#2025-04-23_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nimport { reatomAsync, withDataAtom } from '@reatom/async'\n\nexport const fetchList = reatomAsync(\n  (ctx) => request('api/list', ctx.controller),\n  'fetchList',\n).pipe(withDataAtom([]))\n\nexport const updateList = reatomAsync(\n  (ctx, newList) => {\n    const { signal } = ctx.controller\n    const data = JSON.stringify(newList)\n    return request('/api/list', { method: 'POST', data, signal })\n  },\n  {\n    name: 'updateList',\n    onEffect(ctx, params, promise) {\n      const [newList] = params\n      const newList = fetchList.dataAtom(ctx, newList)\n    },\n  },\n)\n```\n\n----------------------------------------\n\nTITLE: Using useAction Hook for Basic Action Dispatch\nDESCRIPTION: Example of using the useAction hook to bind an action to the store for dispatching.\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/src/content/docs/compat/react-v2.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nconst handleUpdateData = useAction(dataAtom.update)\n```\n\n----------------------------------------\n\nTITLE: Using Take Checkpoints in Reatom Async Operations\nDESCRIPTION: Demonstrates how to properly handle async operations with take checkpoints to avoid race conditions when dealing with modal confirmations and API calls.\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/src/content/docs/package/effects.md#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nconst closeDocument = reatomAsync(async (ctx) => {\n  confirmModalAtom.open(ctx, 'Are you sure you want to leave?')\n  const modalConfirmedCheckpoint = take(ctx, confirmModalAtom.close)\n\n  const presaveId = await api.presaveDocument()\n\n  await modalConfirmedCheckpoint\n\n  await api.finalizeDocument(presaveId)\n})\n```\n\n----------------------------------------\n\nTITLE: Using withInit for Lazy Browser Language Detection\nDESCRIPTION: Example of using withInit to lazily initialize an atom with the browser's preferred language when the atom is first read.\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/src/content/docs/package/hooks.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { atom } from '@reatom/core'\nimport { withInit } from '@reatom/hooks'\n\nexport const langAtom = atom('', 'langAtom').pipe(\n  withInit(\n    () =>\n      navigator.languages?.[0] ??\n      (navigator.language || navigator.userLanguage),\n  ),\n)\n```\n\n----------------------------------------\n\nTITLE: Handling Multiple Action Calls in a Batch in TypeScript\nDESCRIPTION: Illustrates how to handle multiple action calls within a batch, showing the difference between individual call returns and the action's state.\nSOURCE: https://github.com/reatom/reatom/blob/v3/packages/core/README.md#2025-04-23_snippet_14\n\nLANGUAGE: typescript\nCODE:\n```\nconst submit = action((ctx, name, password) => ({ name, password }))\n\nbatch(ctx, () => {\n  submit(ctx, 'Joe', 'Bom')\n  // { name: 'Joe', password: 'Bom' }\n\n  submit(ctx, 'Koe', 'Rog')\n  // { name: 'Koe', password: 'Rog' }\n\n  ctx.get(submit)\n  // [{ name: 'Joe', password: 'Bom' }, { name: 'Koe', password: 'Rog' }]\n})\n```\n\n----------------------------------------\n\nTITLE: Using useAction with Vue component template\nDESCRIPTION: Example of using useAction hook to bind a Reatom action to a Vue component, allowing it to be called directly from the template on button click.\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/src/content/docs/package/npm-vue.md#2025-04-23_snippet_3\n\nLANGUAGE: vue\nCODE:\n```\n<script>\nimport * as model from './model'\nimport { useAction } from '@reatom/npm-vue'\n\nconst doSomething = useAction(model.doSomething)\n</script>\n\n<template>\n  <BigBrightButton @click=\"doSomething\">Do it!</BigBrightButton>\n</template>\n```\n\n----------------------------------------\n\nTITLE: Setting up @reatom/devtools in a root file\nDESCRIPTION: Typical setup for the devtools in a root file. This code conditionally imports and initializes the devtools in development mode and makes it globally accessible via the DEVTOOLS global variable.\nSOURCE: https://github.com/reatom/reatom/blob/v3/packages/devtools/README.md#2025-04-23_snippet_1\n\nLANGUAGE: ts\nCODE:\n```\ndeclare global {\n  var DEVTOOLS: null | Devtools\n}\nif (import.meta.env.DEV) {\n  const { createDevtools } = await import('@reatom/devtools')\n  globalThis.DEVTOOLS = createDevtools()\n} else {\n  globalThis.DEVTOOLS = null\n}\n```\n\n----------------------------------------\n\nTITLE: Using Reatom Atoms in React Components\nDESCRIPTION: Example of using Reatom atoms with the useAtom hook in a React component to manage state and create derived values.\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/src/content/docs/getting-started/setup.md#2025-04-23_snippet_4\n\nLANGUAGE: jsx\nCODE:\n```\nconst nameAtom = atom('Joe')\nconst greetingAtom = atom((ctx) => `Hello, ${ctx.spy(nameAtom)}!`)\n\nconst Greeting = () => {\n  const [name, setName] = useAtom(nameAtom)\n  const [greeting] = useAtom(greetingAtom)\n\n  return (\n    <>\n      <label>\n        What is your name?:\n        <input value={name} onChange={(e) => setName(e.currentTarget.value)} />\n      </label>\n      <h1>Hello {greeting}!</h1>\n    </>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing reatomAsync with Operators\nDESCRIPTION: Example showing how to use reatomAsync with built-in operators for enhanced functionality with less boilerplate.\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/src/content/docs/package/async.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { reatomAsync, withAbort, withDataAtom, withErrorAtom, withStatusesAtom } from \"@reatom/framework\";\n\ntype Element = {\n  id: string\n  /* ... */\n}\n\nexport const fetchList = reatomAsync(\n  (ctx, page: number) =>\n    request<Array<Element>>(`/api/list?page=${page}`, ctx.controller),\n  'fetchList',\n).pipe(withDataAtom([]), withErrorAtom(), withAbort(), withStatusesAtom())\n```\n\n----------------------------------------\n\nTITLE: Implementing User Model with Atomization in Reatom\nDESCRIPTION: This snippet demonstrates how to structure a user model by atomizing the mutable name property while keeping the id as a primitive. It includes actions for fetching user data from the backend and synchronizing changes.\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/src/content/docs/recipes/atomization.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// ~/features/user/model.ts\nimport { AtomMut, action, atom } from '@reatom/core'\n\ntype UserDto = {\n  id: string\n  name: string\n}\n\ntype User = {\n  id: string\n  name: AtomMut<string>\n}\n\nexport const userAtom = atom<null | User>(null, 'user')\n\nexport const fetchUser = action(\n  (ctx) =>\n    ctx.schedule(async () => {\n      const userDto = await api.getUser()\n      const user = { id: userDto.id, name: atom(userDto.name, 'user.name') }\n      userAtom(ctx, user)\n    }),\n  'fetchUser',\n)\n\nexport const syncUserName = action((ctx) => {\n  const name = ctx.get(ctx.get(userAtom).name)\n  return ctx.schedule(() => api.updateUser({ name }))\n}, 'syncUserName')\n```\n\n----------------------------------------\n\nTITLE: Factory Function Atom Naming with Domain\nDESCRIPTION: Example of naming atoms created within a Reatom factory function using the domain convention.\nSOURCE: https://github.com/reatom/reatom/blob/v3/packages/eslint-plugin/README.md#2025-04-23_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nconst reatomFood = (config: {\n  name: string\n  calories: number\n  fat: number\n  carbs: number\n  protein: number\n}) => {\n  const { name } = config\n  const calories = atom(config.calories, `Food.calories`)\n  const fat = atom(config.fat, `Food.fat`)\n  const carbs = atom(config.carbs, `Food.carbs`)\n  const protein = atom(config.protein, `Food.protein`)\n  return { calories, fat, carbs, protein }\n}\n```\n\n----------------------------------------\n\nTITLE: Using useAction Hook with Payload Preparation\nDESCRIPTION: Example of using useAction with payload preparation before dispatch.\nSOURCE: https://github.com/reatom/reatom/blob/v3/packages/react-v2/README.md#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nconst handleUpdateData = useAction(\n  (value) => dataAtom.update({ id: props.id, value }),\n  [props.id],\n)\n```\n\n----------------------------------------\n\nTITLE: Integrating Reatom URL with React Router in TypeScript/TSX\nDESCRIPTION: Component for synchronizing Reatom's urlAtom with React Router, handling URL updates and navigation.\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/src/content/docs/package/url.md#2025-04-23_snippet_8\n\nLANGUAGE: tsx\nCODE:\n```\nimport React from 'react'\nimport { useLocation, useNavigate } from 'react-router-dom'\nimport { useCtx } from '@reatom/npm-react'\nimport { updateFromSource, urlAtom } from '@reatom/url'\n\nexport const RouterSync = () => {\n  const ctx = useCtx()\n  const setupRef = React.useRef(false)\n\n  // subscribe to location changes\n  useLocation()\n  if (ctx.get(urlAtom).href !== location.href && setupRef.current) {\n    // do not use `useEffect` to prevent race conditions (`urlAtom` reading during the render)\n    updateFromSource(ctx, new URL(location.href))\n  }\n\n  const navigate = useNavigate()\n  if (!setupRef.current) {\n    setupRef.current = true\n    urlAtom.settingsAtom(ctx, {\n      init: () => new URL(location.href),\n      sync: (_ctx, url, replace) =>\n        navigate(url.pathname + url.search, { replace }),\n    })\n    // trigger `onChange` hooks.\n    urlAtom(ctx, new URL(location.href))\n  }\n\n  return null\n}\n```\n\n----------------------------------------\n\nTITLE: Basic Periodic Data Refresh without Retry in Reatom\nDESCRIPTION: This snippet demonstrates a basic implementation of periodic data refresh without using the retry mechanism. It uses Reatom's onConnect utility for managing the refresh cycle.\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/src/content/docs/package/async.md#2025-04-23_snippet_26\n\nLANGUAGE: typescript\nCODE:\n```\nimport { reatomAsync, withAbort, withDataAtom, sleep } from '@reatom/framework'\n\nexport const fetchList = reatomAsync(\n  (ctx) => request('/api/list', ctx.controller),\n  'fetchList',\n).pipe(withAbort(), withDataAtom([]), withRetry())\nonConnect(fetchList.dataAtom, async (ctx) => {\n  while (true) {\n    await fetchList(ctx).catch(() => {})\n    await ctx.schedule(() => sleep(5000))\n  }\n})\n```\n\n----------------------------------------\n\nTITLE: Implementing Resource Reset on Disconnect in Reatom\nDESCRIPTION: Shows how to reset a resource when it's disconnected, ensuring it will be refetched when reconnected, avoiding the pitfall of duplicate initialization logic.\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/src/content/docs/package/async.md#2025-04-23_snippet_32\n\nLANGUAGE: typescript\nCODE:\n```\nonDisconnect(myResource, myResource.reset)\n```\n\n----------------------------------------\n\nTITLE: Object Property Atom Naming in Reatom\nDESCRIPTION: Example showing how to properly name a Reatom atom when it's assigned to an object property.\nSOURCE: https://github.com/reatom/reatom/blob/v3/packages/eslint-plugin/README.md#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nconst atomsRec = {\n  count: atom(0, 'atomsRec.count'),\n}\n```\n\n----------------------------------------\n\nTITLE: Basic Atom Naming in Reatom\nDESCRIPTION: Example showing how to properly name a Reatom atom according to the unit-naming-rule.\nSOURCE: https://github.com/reatom/reatom/blob/v3/packages/eslint-plugin/README.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nconst count = atom(0, 'count')\n```\n\n----------------------------------------\n\nTITLE: Using useAction Hook with Conditional Dispatch\nDESCRIPTION: Example of using useAction hook with a condition to determine whether to dispatch an action or not.\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/src/content/docs/compat/react-v2.md#2025-04-23_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nconst handleUpdateData = useAction((payload) => {\n  if (condition) return dataAtom.update(payload)\n}, [])\n```\n\n----------------------------------------\n\nTITLE: Implementing Lazy Retry Logic with onConnect in TypeScript\nDESCRIPTION: Shows how to use onConnect for implementing a lazy retry logic with infinite effects and leak safety.\nSOURCE: https://github.com/reatom/reatom/blob/v3/packages/hooks/README.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nonConnect(fetchSome.dataAtom, async (ctx) => {\n  while (true) {\n    await ctx.schedule(() => sleep(5_000))\n    await fetchSome(ctx)\n  }\n})\n```\n\n----------------------------------------\n\nTITLE: Using Separate Actions for User Data Updates\nDESCRIPTION: This snippet demonstrates how to use separate actions to update user data, providing better control and modularity.\nSOURCE: https://github.com/reatom/reatom/blob/v3/packages/core/README.md#2025-04-23_snippet_20\n\nLANGUAGE: typescript\nCODE:\n```\nimport { action, atom, batch } from '@reatom/core'\n\nexport const firstNameAtom = atom('', 'firstNameAtom')\nexport const lastNameAtom = atom('', 'lastNameAtom')\nexport const fullNameAtom = atom(\n  (ctx) => `${ctx.spy(firstNameAtom)} ${ctx.spy(lastNameAtom)}`,\n  'fullNameAtom',\n)\nexport const saveUser = action((ctx, firstName: string, lastName: string) => {\n  firstNameAtom(ctx, firstName)\n  lastNameAtom(ctx, lastName)\n}, 'saveUser')\nexport const fetchUser = action(async (ctx, id: string) => {\n  const user = await ctx.schedule(() => api.getUser(id))\n  saveUser(ctx, user.firstName, user.lastName)\n}, 'fetchUser')\n\nctx.subscribe(fullNameAtom, console.log)\n// log: \" \"\nfetchUser(ctx, 1)\n// log: \"John Doe\"\n// All good\nfetchUser(ctx, 2)\n// log: \"Mat Black\"\n```\n\n----------------------------------------\n\nTITLE: Incorrect Usage of select in Atom\nDESCRIPTION: Example demonstrating an incorrect usage pattern of select that will throw an error due to multiple calls with the same callback string representation.\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/src/content/docs/package/lens.md#2025-04-23_snippet_8\n\nLANGUAGE: ts\nCODE:\n```\nconst sumAtom = atom((ctx) =>\n  ctx\n    .spy(listAtom)\n    .reduce((acc, el) => acc + select(ctx, (ctx) => ctx.spy(el).value), 0),\n)\n```\n\n----------------------------------------\n\nTITLE: Using action.onCall for Action Hooks in TypeScript\nDESCRIPTION: Demonstrates how to use the action.onCall method to define hooks that are triggered when an action is called, providing access to payload and parameters.\nSOURCE: https://github.com/reatom/reatom/blob/v3/packages/core/README.md#2025-04-23_snippet_15\n\nLANGUAGE: typescript\nCODE:\n```\nconst doSome = action((ctx, a, b) => ({ a, b }), 'doSome')\ndoSome.onCall((ctx, payload, params) => {\n  console.log(payload, params)\n  // `doSome(ctx, 1, 2)` will log \"{ a: 1, b: 2 }, [1, 2]\"\n})\n```\n\n----------------------------------------\n\nTITLE: Creating Reactive Routing with match Operator\nDESCRIPTION: Demonstrates how to use the match operator to create a reactive routing system based on login state and URL.\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/src/content/docs/package/lens.md#2025-04-23_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nexport const routes = match(isLoggedAtom)\n  .default(() => <Auth />)\n  .truthy(\n    match((ctx) => ctx.spy(urlAtom).pathname)\n      .is('/me', () => <Profile />)\n      .default(() => <Home />),\n  )\n```\n\n----------------------------------------\n\nTITLE: Implementing History Blocking with Take Effect\nDESCRIPTION: Demonstrates using take API with history blocking to handle navigation confirmation dialogs.\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/src/content/docs/package/effects.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { take } from '@reatom/effects'\nimport { onConnect } from '@reatom/hooks'\nimport { historyAtom } from '@reatom/npm-history'\nimport { confirmModalAtom } from '~/features/modal'\n\nexport const formAtom = reatomForm(/* ... */)\n\nonConnect(formAtom, (ctx) => {\n  const unblock = historyAtom.block(ctx, async ({ retry }) => {\n    if (!ctx.get(formAtom).isSubmitted && !ctx.get(confirmModalAtom).opened) {\n      confirmModalAtom.open(ctx, 'Are you sure you want to leave?')\n\n      const confirmed = await take(ctx, confirmModalAtom.close)\n\n      if (confirmed) {\n        unblock()\n        retry()\n      }\n    }\n  })\n})\n```\n\n----------------------------------------\n\nTITLE: Testing Persisted Atoms with Mock Storage\nDESCRIPTION: Example showing how to test atoms that use persistence by mocking the storage adapter. Uses the createMemStorage utility for creating test storage with predefined values.\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/src/content/docs/package/persist.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\n// feature.ts\nimport { atom } from '@reatom/framework'\nimport { withLocalStorage } from '@reatom/persist-web-storage'\n\nexport const tokenAtom = atom('', 'tokenAtom').pipe(withLocalStorage('token'))\n```\n\nLANGUAGE: typescript\nCODE:\n```\n// feature.test.ts\nimport { test } from 'vitest'\nimport { createTestCtx } from '@reatom/testing'\nimport { createMemStorage } from '@reatom/persist'\nimport { withLocalStorage } from '@reatom/persist-web-storage'\nimport { tokenAtom } from './feature'\n\ntest('token', () => {\n  const ctx = createTestCtx()\n  const mockStorage = createMemStorage({ token: '123' })\n  withLocalStorage.storageAtom(ctx, mockStorage)\n\n  expect(ctx.get(tokenAtom).toBe('123')\n})\n```\n\n----------------------------------------\n\nTITLE: Fetching User Data Without Batching\nDESCRIPTION: This snippet demonstrates a problematic implementation of fetching user data without using batching, leading to multiple unnecessary updates.\nSOURCE: https://github.com/reatom/reatom/blob/v3/packages/core/README.md#2025-04-23_snippet_18\n\nLANGUAGE: typescript\nCODE:\n```\nimport { action, atom, batch } from '@reatom/core'\n\nexport const firstNameAtom = atom('', 'firstNameAtom')\nexport const lastNameAtom = atom('', 'lastNameAtom')\nexport const fullNameAtom = atom(\n  (ctx) => `${ctx.spy(firstNameAtom)} ${ctx.spy(lastNameAtom)}`,\n  'fullNameAtom',\n)\nexport const fetchUser = action(async (ctx, id: string) => {\n  const user = await ctx.schedule(() => api.getUser(id))\n  firstNameAtom(ctx, user.firstName)\n  lastNameAtom(ctx, user.lastName)\n}, 'fetchUser')\n\nctx.subscribe(fullNameAtom, console.log)\n// log: \" \"\nfetchUser(ctx, 1)\n// log: \"John \"\n// log: \"John Doe\"\nfetchUser(ctx, 2)\n// log: \"Mat Doe\"\n// log: \"Mat Black\"\n```\n\n----------------------------------------\n\nTITLE: Using reatomRef to convert atoms to Vue refs\nDESCRIPTION: Demonstrates how to use reatomRef to turn Reatom atoms into Vue refs that update on target atom changes. Shows examples with basic atoms and selectors.\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/src/content/docs/package/npm-vue.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { atom } from '@reatom/core'\nimport { reatomRef } from '@reatom/npm-vue'\n\nconst count = atom(0, 'count')\n\n// turn an atom into a ref-like object\nconst countRef = reatomRef(count)\n// selectors are supported as well\nconst countDoubleRef = reatomRef((ctx) => ctx.spy(count) * 2)\n\ncountRef // Ref<number>\ncountRef.value // 0\ncountRef.value = 3 // 3\n\ncountDoubleRef // Readonly<Ref<number>>\ncountDoubleRef.value // 6\n```\n\n----------------------------------------\n\nTITLE: Configuring Reatom Logger with Options in TypeScript\nDESCRIPTION: Example showing how to connect the Reatom logger to your application context with various configuration options. The snippet demonstrates both simple usage and advanced configuration including history tracking, filtering, batched logging, and timestamp formatting.\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/src/content/docs/package/logger.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { connectLogger, createLogBatched } from '@reatom/logger'\n\nif (import.meta.env.DEV) {\n  connectLogger(ctx)\n}\n\n// OR\n\nconnectLogger(\n  ctx,\n  // optional configuration\n  {\n    // the length of the atom history (patches) to store\n    history: 10,\n    // `false` by default to made your logs short\n    showCause: false,\n    // `true` by default to made your logs clear\n    skipUnnamed: true,\n    // fine tuning :)\n    skip: (patch: AtomCache) => false,\n    // `createLogBatched` by default to not spam you a lot\n    // you could pass regular `console.log` here\n    log: createLogBatched(\n      // optional configuration\n      {\n        // 500ms by default\n        debounce: 500,\n        // 5000ms by default, it helps to not stuck with WS and so on\n        limit: 5000,\n        // `toLocaleTimeString` by default\n        getTimeStamp: () => new Date().toLocaleTimeString()\n\n        log: console.log,\n        // `true` by default to group logs by name\n        shouldGroup: true,\n      },\n    ),\n    // You could customize a logs group: `Reatom ${domain}N transactions`\n    domain: '',\n  },\n)\n```\n\n----------------------------------------\n\nTITLE: Dynamic Configuration of reatomFetch in TypeScript\nDESCRIPTION: Demonstrates how to dynamically configure reatomFetch using a function. It includes examples for fetching a user by ID and performing a search with filters and sorting.\nSOURCE: https://github.com/reatom/reatom/blob/v3/packages/web-fetch/README.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nconst getUser = reatomFetch<User, string>((ctx, id) => `/api/user/${id}`)\n\nconst search = reatomFetch<SearchItem[], string, 'price' | 'orders'>(\n  (ctx, filter, sortBy) => ({\n    url: '/api/search',\n    params: { filter, sortBy },\n  }),\n)\n```\n\n----------------------------------------\n\nTITLE: Synchronizing Atom State Between Tabs with BroadcastChannel in Reatom\nDESCRIPTION: Example showing how to use the withBroadcastChannel adapter to synchronize an atom's state between browser tabs without using localStorage. This is useful for cross-tab communication.\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/src/content/docs/package/persist-web-storage.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { atom } from '@reatom/framework'\nimport { withBroadcastChannel } from '@reatom/persist-web-storage'\n\nexport const isAuthedAtom = atom('', 'isAuthedAtom').pipe(\n  withBroadcastChannel('isAuthedAtom'),\n)\n```\n\n----------------------------------------\n\nTITLE: Combining Domain and Object Naming for Reatom Units\nDESCRIPTION: Examples of Reatom atom naming that combines both domain prefixes and object property paths.\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/src/content/docs/package/eslint-plugin.md#2025-04-23_snippet_8\n\nLANGUAGE: ts\nCODE:\n```\natom(0, `${name}.atomsRec.field`)\natom(0, 'Some.atomsRec.field')\n```\n\n----------------------------------------\n\nTITLE: Optimized User Data Fetching with Batching\nDESCRIPTION: This snippet demonstrates an optimized approach to fetching user data with proper batching, reducing the number of updates and improving performance.\nSOURCE: https://github.com/reatom/reatom/blob/v3/packages/core/README.md#2025-04-23_snippet_22\n\nLANGUAGE: typescript\nCODE:\n```\nimport { action, atom, batch } from '@reatom/core'\n\nexport const isUserLoadingAtom = atom(false, 'isUserLoadingAtom')\nexport const firstNameAtom = atom('', 'firstNameAtom')\nexport const lastNameAtom = atom('', 'lastNameAtom')\nexport const fullNameAtom = atom(\n  (ctx) => `${ctx.spy(firstNameAtom)} ${ctx.spy(lastNameAtom)}`,\n  'fullNameAtom',\n)\nexport const fetchUser = action(async (ctx, id: string) => {\n  isUserLoadingAtom(ctx, true)\n  try {\n    const user = await ctx.schedule(() => api.getUser(id))\n    batch(ctx, () => {\n      isUserLoadingAtom(ctx, false)\n      firstNameAtom(ctx, user.firstName)\n      lastNameAtom(ctx, user.lastName)\n    })\n  } catch {\n    isUserLoadingAtom(ctx, false)\n  }\n}, 'fetchUser')\n```\n\n----------------------------------------\n\nTITLE: Implementing withInit for Lazy Initialization in TypeScript\nDESCRIPTION: Demonstrates the use of withInit operator for lazy initialization of atom state, including examples with browser language and dependent atoms.\nSOURCE: https://github.com/reatom/reatom/blob/v3/packages/hooks/README.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { atom } from '@reatom/core'\nimport { withInit } from '@reatom/hooks'\n\nexport const langAtom = atom('', 'langAtom').pipe(\n  withInit(\n    () =>\n      navigator.languages?.[0] ??\n      (navigator.language || navigator.userLanguage),\n  ),\n)\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport { atom } from '@reatom/core'\nimport { withInit } from '@reatom/hooks'\n\nexport const pageTitleAtom = atom('', 'pageTitleAtom')\n\nexport const searchAtom = atom('', 'searchAtom').pipe(\n  withInit((ctx) => ctx.get(pageTitleAtom)),\n)\n```\n\nLANGUAGE: typescript\nCODE:\n```\nexport const pageUptimeAtom = atom(0, 'pageUptimeAtom').pipe(\n  withInit((ctx) => {\n    setTimeout(() => pageUptimeAtom(ctx, performance.now()), 1000)\n    return performance.now()\n  }),\n)\n```\n\nLANGUAGE: typescript\nCODE:\n```\nexport const dataAtom = atom(0, 'dataAtom').pipe(\n  withInit((ctx, init) => {\n    ctx.get(socketServiceAtom).on('data', (data) => dataAtom(ctx, data))\n\n    return init(ctx)\n  }),\n)\n```\n\n----------------------------------------\n\nTITLE: Implementing onUpdate with Debounce in TypeScript\nDESCRIPTION: Demonstrates the use of onUpdate hook with a debounce function to delay or sample reactions to state updates.\nSOURCE: https://github.com/reatom/reatom/blob/v3/packages/hooks/README.md#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport { onUpdate } from '@reatom/hooks'\nimport { debounce } from '@reatom/lens'\n\nonUpdate(onChange.pipe(debounce(250)), (ctx) => fetchData(ctx))\n```\n\n----------------------------------------\n\nTITLE: Using atom.onChange for Static Logic in TypeScript\nDESCRIPTION: Shows how to use the atom.onChange method to define static logic between atoms and actions outside of a context.\nSOURCE: https://github.com/reatom/reatom/blob/v3/packages/core/README.md#2025-04-23_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\nconst searchAtom = atom('', 'searchAtom')\nconst fetchSearchSuggestion = action((ctx, search) => {\n  /* ... */\n}, 'fetchSearchSuggestion')\nsearchAtom.onChange((ctx, state) => fetchSearchSuggestion(ctx, state))\n// or just\nsearchAtom.onChange(fetchSearchSuggestion)\n```\n\n----------------------------------------\n\nTITLE: Basic Usage of withUndo with Reatom Atom\nDESCRIPTION: Example showing how to add undo/redo functionality to an existing atom using the withUndo method.\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/src/content/docs/package/undo.md#2025-04-23_snippet_1\n\nLANGUAGE: ts\nCODE:\n```\nimport { atom } from '@reatom/core'\nimport { withUndo } from '@reatom/undo'\n\nconst inputAtom = atom('').pipe(withUndo())\n```\n\n----------------------------------------\n\nTITLE: Declaring mapState Operator for Reatom in TypeScript\nDESCRIPTION: Type declaration for a mapState operator that transforms atom state using a mapper function. This pattern follows the verb prefix naming convention for operators that create new atoms.\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/src/content/docs/recipes/custom-operator.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Atom, CtxSpy } from '@reatom/core'\n\ndeclare function mapState<T, Res>(\n  mapper: Fn<[CtxSpy, T, undefined | T], Res>,\n  name?: string,\n): (anAtom: Atom<T>) => Atom<Res>\n```\n\n----------------------------------------\n\nTITLE: Binding multiple functions with useCtxBind\nDESCRIPTION: Example of using useCtxBind to create a function that binds multiple Reatom actions to a context, creating bound function versions for each action.\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/src/content/docs/package/npm-vue.md#2025-04-23_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nconst aAction = action('aAction')\nconst bAction = action('bAction')\nconst cAction = action('cAction')\n\nconst bind = useCtxBind()\nconst aFn = bind(aAction)\nconst bFn = bind(bAction)\nconst cFn = bind(cAction)\n```\n\n----------------------------------------\n\nTITLE: Using useAtom Hook in Solid.js Component\nDESCRIPTION: Demonstration of using the useAtom hook from Reatom in a Solid.js component. It creates a count atom and uses it to manage state in a button component.\nSOURCE: https://github.com/reatom/reatom/blob/v3/packages/npm-solid-js/README.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { atom } from '@reatom/framework'\nimport { useAtom } from '@reatom/npm-solid-js'\n\nconst countAtom = atom(0, 'countAtom')\n\nconst App: Component = () => {\n  const [count, setCount] = useAtom(countAtom)\n\n  return (\n    <div>\n      Count value is\n      <button onClick={() => setCount((c) => c + 1)}>{count()}</button>\n    </div>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Using mapState Operator in TypeScript\nDESCRIPTION: Demonstrates how to use the mapState operator to efficiently transform atom state while avoiding unnecessary updates.\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/src/content/docs/package/lens.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { mapState } from '@reatom/lens'\n\n// this is a typical code which have a problem with extra updates\n// in case when an element of the list changes not `myProp`\nexport const filteredListAtom = atom((ctx) =>\n  ctx.spy(listAtom).map((obj) => obj.myProp),\n)\n// `mapState` could help to solve this problem, as it pass previous state as a second argument\nexport const bAtom = listAtom.pipe(\n  mapState((ctx, list, prevState) => {\n    const newState = list.map((obj) => obj.myProp)\n    return isShallowEqual(newState, prevState) ? prevState : newState\n  }),\n)\n```\n\n----------------------------------------\n\nTITLE: Implementing withReadyAtom Operator for Async Actions in Reatom\nDESCRIPTION: Advanced custom operator that adds a readyAtom to an async action. This demonstrates handling hot/cold reactive nodes, preventing race conditions with spy, and ensuring correct state propagation for unconnected atoms.\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/src/content/docs/recipes/custom-operator.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { AsyncAction } from '@reatom/async'\nimport { Atom, atom } from '@reatom/core'\n\nexport const withReadyAtom =\n  <T extends AsyncAction & { dataAtom?: Atom }>(initState = false) =>\n  (anAsync: T): T & { readyAtom: Atom<boolean> } => {\n    // use `spy` to prevent any race conditions\n    const readyAtom = atom((ctx, state?: boolean) => {\n      // trigger connection to start the fetch if `onConnect` used\n      if (anAsync.dataAtom) ctx.spy(anAsync.dataAtom)\n\n      const pending = ctx.spy(anAsync.pendingAtom)\n\n      return state === undefined ? initState : pending === 0\n    }, `${anAsync.__reatom.name}.readyAtom`)\n\n    // grand correct state even for unconnected atom\n    anAsync.pendingAtom.onChange((ctx) => {\n      ctx.get(readyAtom)\n    })\n\n    return Object.assign(anAsync, { readyAtom })\n  }\n```\n\n----------------------------------------\n\nTITLE: TakeNested Implementation for SSR\nDESCRIPTION: Demonstrates using takeNested to track nested effect calls in SSR context with routing logic.\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/src/content/docs/package/effects.md#2025-04-23_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nawait takeNested(ctx, (trackedCtx) => {\n  historyAtom.push(trackedCtx, req.url)\n})\nrender()\n```\n\n----------------------------------------\n\nTITLE: Setting up Reatom Context Provider in Solid.js\nDESCRIPTION: Example of setting up the Reatom context provider at the root of a Solid.js application. It creates a Reatom context, connects a logger, and wraps the App component with the provider.\nSOURCE: https://github.com/reatom/reatom/blob/v3/packages/npm-solid-js/README.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createCtx, connectLogger } from '@reatom/framework'\nimport { reatomContext } from '@reatom/npm-solid-js'\n\nconst ctx = createCtx()\nconnectLogger(ctx)\n\nrender(\n  () => (\n    <reatomContext.Provider value={ctx}>\n      <App />\n    </reatomContext.Provider>\n  ),\n  document.getElementById('root')!\n)\n```\n\n----------------------------------------\n\nTITLE: Configuring reatomFetch with an Object in TypeScript\nDESCRIPTION: Shows how to use an object to configure reatomFetch instead of a simple URL string. This approach allows for more detailed configuration of the request.\nSOURCE: https://github.com/reatom/reatom/blob/v3/packages/web-fetch/README.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst getMe = reatomFetch<User>({\n  url: '/api/me',\n})\n```\n\n----------------------------------------\n\nTITLE: Filtering Fetched Data with Reatom Atoms in TypeScript\nDESCRIPTION: Shows how to create a derived atom that filters data from a fetched list. The filteredListAtom automatically triggers the fetchList action when connected.\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/src/content/docs/package/async.md#2025-04-23_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nexport const filteredListAtom = atom(\n  (ctx) => ctx.spy(fetchList.dataAtom).filter((item) => item.active),\n  'filteredListAtom',\n)\n```\n\n----------------------------------------\n\nTITLE: Using withComputed Operator in TypeScript\nDESCRIPTION: Demonstrates the usage of withComputed operator, which allows reacting to external dependencies for a changeable atom. It's used for adding extra computation logic.\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/src/content/docs/package/primitives.md#2025-04-23_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nexport const searchAtom = atom('', 'searchAtom')\nexport const pageAtom = atom(0, 'pageAtom').pipe(\n  withComputed((ctx, state) => {\n    ctx.spy(searchAtom, () => {\n      state = 0\n    })\n    return state\n  }),\n)\n```\n\n----------------------------------------\n\nTITLE: Defining Atoms with Declarative Properties in TypeScript\nDESCRIPTION: Shows how to create an atom using declarative properties. This approach uses an object to define the atom's behavior, including actions, computations, and change listeners.\nSOURCE: https://github.com/reatom/reatom/blob/v3/packages/core/history-v2.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst add = declareAction<number>()\n\nconst counterAtom = declareAtom(0, {\n  id: `counter`,\n  meta: { updates: 0 },\n  on: [add.reduce((value, state) => state + value)],\n  compute: [\n    ($, state) => ($(shouldSyncCounterAtom) ? $(globalCounterAtom) : state),\n  ],\n  assign: {\n    inc: (value: void, state) => state + 1,\n  },\n  change: [\n    (state, store, meta) =>\n      console.log(\n        `counterAtom receive new value: ${state}.`,\n        `It is ${++meta.updates} update`,\n      ),\n  ],\n})\n```\n\n----------------------------------------\n\nTITLE: Configuring React Batched Updates\nDESCRIPTION: Import statement to setup batch bindings for React 16/17 compatibility.\nSOURCE: https://github.com/reatom/reatom/blob/v3/packages/react-v2/README.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport '@reatom/react-v2/react-dom-batched-updates'\n```\n\n----------------------------------------\n\nTITLE: Defining a Reatom Model for Svelte Integration\nDESCRIPTION: TypeScript module that defines a Reatom model with atoms and actions to be used in a Svelte component.\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/src/content/docs/package/npm-svelte.md#2025-04-23_snippet_5\n\nLANGUAGE: ts\nCODE:\n```\n// model.ts\nimport { atom, action } from '@reatom/core'\n\nexport const countAtom = atom(0, 'countAtom')\nexport const timesAtom = atom(\n  (ctx) => (ctx.spy(countAtom) === 1 ? 'time' : 'times'),\n  'timesAtom',\n)\nexport const increment = action(\n  (ctx) => countAtom(ctx, (s) => ++s),\n  'increment',\n)\n```\n\n----------------------------------------\n\nTITLE: Abort Signal Handling in Reatom\nDESCRIPTION: Shows how to handle abort signals in async operations using onCtxAbort utility.\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/src/content/docs/package/effects.md#2025-04-23_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\nconst doLongImportantAsyncWork = action((ctx) =>\n  ctx.schedule(() => {\n    const timeoutId = setTimeout(() => {\n      /* ... */\n    })\n    onCtxAbort(ctx, () => clearTimeout(timeoutId))\n  }),\n)\n```\n\n----------------------------------------\n\nTITLE: Setting up historyAtom with createBrowserHistory in TypeScript\nDESCRIPTION: This snippet demonstrates how to set up the historyAtom in the root of your app using createBrowserHistory. It should be done before other dependent atoms touch the context.\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/src/content/docs/package/npm-history.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { historyAtom } from '@reatom/npm-history'\nimport { createBrowserHistory } from 'history'\n\nhistoryAtom(ctx, createBrowserHistory())\n```\n\n----------------------------------------\n\nTITLE: Specifying HTTP Method in reatomFetch with TypeScript\nDESCRIPTION: Shows two ways to specify the HTTP method for a request: using the 'method' option and using the reatomFetch.<method> shorthand. Both examples demonstrate a POST request.\nSOURCE: https://github.com/reatom/reatom/blob/v3/packages/web-fetch/README.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nconst postUser = reatomFetch<User, User>((ctx, body) => ({\n  method: 'post',\n  url: `/api/user/${id}`,\n  body,\n}))\n\nconst postUser = reatomFetch.post<User, User>((ctx, body) => ({\n  url: `/api/user/${id}`,\n  body,\n}))\n```\n\n----------------------------------------\n\nTITLE: Custom Data Mapping with Reatom Async in TypeScript\nDESCRIPTION: Shows how to map fetched data to a different atom structure. The mapAtom is updated with a transformed version of the fetchList results.\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/src/content/docs/package/async.md#2025-04-23_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\nimport { reatomMap } from '@reatom/primitives'\n// ....\nexport const mapAtom = reatomMap(new Map<string, Element>(), 'mapAtom')\nfetchList.onFulfill.onCall((ctx, payload) =>\n  mapAtom(ctx, new Map(payload.map((el) => [el.id, el]))),\n)\n```\n\n----------------------------------------\n\nTITLE: Defining Atoms with Options Builder in TypeScript\nDESCRIPTION: Demonstrates creating an atom using an options builder pattern. It includes setting an ID, metadata, action handlers, computations, and change listeners.\nSOURCE: https://github.com/reatom/reatom/blob/v3/packages/core/history-v2.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst add = declareAction<number>()\n\nconst counterAtom = declareAtom(0, (atom) =>\n  atom\n    .id(`counter`)\n    .meta({ updates: 0 })\n    .on(add, (value, state) => state + value)\n    .compute(($, state) =>\n      $(shouldSyncCounterAtom) ? $(globalCounterAtom) : state,\n    )\n    .assign({\n      inc: (value: void, state) => state + 1,\n    })\n    .change((state, store, meta) =>\n      console.log(\n        `counterAtom receive new value: ${state}.`,\n        `It is ${++meta.updates} update`,\n      ),\n    ),\n)\n```\n\n----------------------------------------\n\nTITLE: Using devtools with form state for two-way binding\nDESCRIPTION: Example of integrating devtools with form state management. This allows reinitializing the form from the devtools with the edit tool through a subscription, creating a two-way binding between the application and devtools.\nSOURCE: https://github.com/reatom/reatom/blob/v3/packages/devtools/README.md#2025-04-23_snippet_4\n\nLANGUAGE: ts\nCODE:\n```\nconst { values, init } = useForm()\nReact.useEffect(\n  () => DEVTOOLS?.state('my-form', values).subscribe(init),\n  [state],\n)\n```\n\n----------------------------------------\n\nTITLE: Basic Usage of reatomAsync with a Simple API Request\nDESCRIPTION: Demonstrates the fundamental usage of reatomAsync for fetching data from an API endpoint. The function takes a context and page number, then makes a request to the API.\nSOURCE: https://github.com/reatom/reatom/blob/v3/packages/async/README.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { reatomAsync } from '@reatom/async'\n\nexport const fetchList = reatomAsync(\n  (ctx, page: number) => request(`/api/list?page=${page}`, ctx.controller),\n  'fetchList',\n)\n```\n\n----------------------------------------\n\nTITLE: Creating a Custom Data Atom with Reatom in TypeScript\nDESCRIPTION: This snippet demonstrates how to create a custom data atom for persisting effect results. It uses reatomArray and connects it to the async atom's onFulfill event.\nSOURCE: https://github.com/reatom/reatom/blob/v3/packages/async/README.md#2025-04-23_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\nimport { reatomArray } from '@reatom/primitives'\nimport { reatomAsync } from '@reatom/async'\n\nexport type Element = {\n  id: string\n  // ...\n}\n\nexport const fetchList = reatomAsync(\n  (ctx) => request<Array<Element>>('api/list', ctx.controller),\n  'fetchList',\n)\nexport const listAtom = reatomArray(new Array<Element>(), 'listAtom')\nfetchList.onFulfill.onCall(listAtom)\n```\n\n----------------------------------------\n\nTITLE: Using Take Effect for Form Validation\nDESCRIPTION: Shows how to use the take API to implement form validation logic with async/await pattern.\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/src/content/docs/package/effects.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { action } from '@reatom/core'\nimport { take } from '@reatom/effects'\n\nexport const validateBeforeSubmit = action(async (ctx) => {\n  let errors = validate(ctx.get(formDataAtom))\n\n  while (Object.keys(errors).length) {\n    formDataAtom.errorsAtom(ctx, errors)\n    await take(ctx, formDataAtom)\n    errors = validate(ctx.get(formDataAtom))\n  }\n})\n```\n\n----------------------------------------\n\nTITLE: Implementing a Basic Fetch Request Helper in TypeScript\nDESCRIPTION: A simple helper function that wraps the fetch API for making HTTP requests. It checks if the response is OK and parses JSON data, throwing an error if the response is not successful.\nSOURCE: https://github.com/reatom/reatom/blob/v3/packages/async/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nasync function request<T>(...params: Parameters<typeof fetch>): Promise<T> {\n  const response = await fetch(...params)\n  if (!response.ok) throw new Error(response.statusText)\n  return await response.json()\n}\n```\n\n----------------------------------------\n\nTITLE: Basic View Implementation with Reatom\nDESCRIPTION: Demonstrates how to connect Reatom state to DOM elements and handle user interactions\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/src/content/docs/index.md#2025-04-23_snippet_3\n\nLANGUAGE: ts\nCODE:\n```\nimport { inputAtom, greetingAtom, onSubmit } from './model'\n\nctx.subscribe(greetingAtom, (greeting) => {\n  document.getElementById('greeting')!.innerText = greeting\n})\n\ndocument.getElementById('name').addEventListener('input', (event) => {\n  inputAtom(ctx, event.currentTarget.value)\n})\ndocument.getElementById('save').addEventListener('click', () => {\n  onSubmit(ctx)\n})\n```\n\n----------------------------------------\n\nTITLE: Implementing Search Parameter Persistence in TypeScript\nDESCRIPTION: Example of using withSearchParamsPersist to sync a number atom with a 'page' search parameter.\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/src/content/docs/package/url.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { reatomNumber } from '@reatom/primitives'\nimport { withSearchParamsPersist } from '@reatom/url'\n\nexport const pageAtom = reatomNumber(0, 'pageAtom').pipe(\n  withSearchParamsPersist('page', (page = '0') => Number(page)),\n)\n//...\npageAtom.increment(ctx)\nctx.get(urlAtom).href // http://example.com/?page=1\n```\n\n----------------------------------------\n\nTITLE: Creating an atom with undo functionality in TypeScript\nDESCRIPTION: Example of creating an atom with undo functionality using the withUndo method from @reatom/undo.\nSOURCE: https://github.com/reatom/reatom/blob/v3/packages/undo/README.md#2025-04-23_snippet_1\n\nLANGUAGE: ts\nCODE:\n```\nimport { atom } from '@reatom/core'\nimport { withUndo } from '@reatom/undo'\n\nconst inputAtom = atom('').pipe(withUndo())\n```\n\n----------------------------------------\n\nTITLE: Installing Reatom Framework\nDESCRIPTION: NPM installation command for Reatom framework and React integration\nSOURCE: https://github.com/reatom/reatom/blob/v3/README.md#2025-04-23_snippet_4\n\nLANGUAGE: sh\nCODE:\n```\nnpm i @reatom/framework @reatom/npm-react\n```\n\n----------------------------------------\n\nTITLE: Using Context Binding Utility\nDESCRIPTION: Demonstrates using useCtxBind to create a function for binding multiple actions to a context.\nSOURCE: https://github.com/reatom/reatom/blob/v3/packages/npm-vue/README.md#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nconst aAction = action('aAction')\nconst bAction = action('bAction')\nconst cAction = action('cAction')\n\nconst bind = useCtxBind()\nconst aFn = bind(aAction)\nconst bFn = bind(bAction)\nconst cFn = bind(cAction)\n```\n\n----------------------------------------\n\nTITLE: Using withInit with Dependency on Another Atom\nDESCRIPTION: Example showing how to initialize an atom's state based on the value of another atom using withInit.\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/src/content/docs/package/hooks.md#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport { atom } from '@reatom/core'\nimport { withInit } from '@reatom/hooks'\n\nexport const pageTitleAtom = atom('', 'pageTitleAtom')\n\nexport const searchAtom = atom('', 'searchAtom').pipe(\n  withInit((ctx) => ctx.get(pageTitleAtom)),\n)\n```\n\n----------------------------------------\n\nTITLE: Setting up Reatom Context in Svelte\nDESCRIPTION: Initializes the Reatom context for use in Svelte components. This should be done in the root component.\nSOURCE: https://github.com/reatom/reatom/blob/v3/packages/npm-svelte/README.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { setupCtx } from '@reatom/npm-svelte'\n\nsetupCtx()\n```\n\n----------------------------------------\n\nTITLE: Fetching Data on Demand with Reatom Async in TypeScript\nDESCRIPTION: Demonstrates how to fetch data declaratively and lazily using Reatom's async and hooks packages. The fetchList atom automatically triggers a data fetch when connected to.\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/src/content/docs/package/async.md#2025-04-23_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nimport { reatomAsync, withDataAtom } from '@reatom/async'\nimport { onConnect } from '@reatom/hooks'\n\nexport const fetchList = reatomAsync(\n  (ctx) => request('api/list', ctx.controller),\n  'fetchList',\n).pipe(withDataAtom([]))\nonConnect(fetchList.dataAtom, fetchList)\n```\n\n----------------------------------------\n\nTITLE: Using withInit for Side Effects with Timer\nDESCRIPTION: Example of using withInit to perform a side effect, setting up a timer that updates the atom's value every second.\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/src/content/docs/package/hooks.md#2025-04-23_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nexport const pageUptimeAtom = atom(0, 'pageUptimeAtom').pipe(\n  withInit((ctx) => {\n    setTimeout(() => pageUptimeAtom(ctx, performance.now()), 1000)\n    return performance.now()\n  }),\n)\n```\n\n----------------------------------------\n\nTITLE: Using reatomUndo for Multiple Atoms\nDESCRIPTION: Example showing how to create a single history line for multiple atoms using the reatomUndo method. This is useful for forms with multiple fields.\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/src/content/docs/package/undo.md#2025-04-23_snippet_3\n\nLANGUAGE: ts\nCODE:\n```\nimport { atom } from '@reatom/core'\nimport { reatomUndo } from '@reatom/undo'\n\nconst formUndoAtom = reatomUndo([emailAtom, passwordAtom], { length: 50 })\n```\n\n----------------------------------------\n\nTITLE: Basic Usage of reatomFetch in TypeScript\nDESCRIPTION: Demonstrates how to create a simple GET request using reatomFetch. It fetches user data from an API endpoint and returns a Promise of User type.\nSOURCE: https://github.com/reatom/reatom/blob/v3/packages/web-fetch/README.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst getMe = reatomFetch<User>('/api/me')\n\nawait getMe(ctx) // Promise<User>\n```\n\n----------------------------------------\n\nTITLE: Installing Reatom Core Package\nDESCRIPTION: NPM installation command for the Reatom core package\nSOURCE: https://github.com/reatom/reatom/blob/v3/README.md#2025-04-23_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\nnpm i @reatom/core\n```\n\n----------------------------------------\n\nTITLE: Setting Up historyAtom with Browser History\nDESCRIPTION: Example of configuring the historyAtom in a Reatom application using browser history. This must be done at the app root before other dependent atoms access the context.\nSOURCE: https://github.com/reatom/reatom/blob/v3/packages/npm-history/README.md#2025-04-23_snippet_1\n\nLANGUAGE: ts\nCODE:\n```\nimport { historyAtom } from '@reatom/npm-history'\nimport { createBrowserHistory } from 'history'\n\nhistoryAtom(ctx, createBrowserHistory())\n```\n\n----------------------------------------\n\nTITLE: Creating a Search Parameter Lens in TypeScript\nDESCRIPTION: Example of creating a lens for the 'filters' search parameter using searchParamsAtom.\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/src/content/docs/package/url.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { searchParamsAtom } from '@reatom/url'\n\nexport const filtersAtom = searchParamsAtom.lens('filters')\n```\n\n----------------------------------------\n\nTITLE: Using isInit for One-time Setup in Actions\nDESCRIPTION: Example demonstrating how to use isInit to check if an action is being called for the first time in the current context.\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/src/content/docs/package/hooks.md#2025-04-23_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nimport { action } from '@reatom/core'\nimport { isInit } from '@reatom/hooks'\n\nexport const doSome = action((ctx, payload) => {\n  if (isInit(ctx)) {\n    // setup\n  }\n  return work()\n})\n```\n\n----------------------------------------\n\nTITLE: Custom Data Atom with Reatom Async in TypeScript\nDESCRIPTION: Demonstrates how to use a custom atom to persist effect results. The listAtom is updated with the fetchList results using onFulfill.onCall.\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/src/content/docs/package/async.md#2025-04-23_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\nimport { reatomArray } from '@reatom/primitives'\nimport { reatomAsync } from '@reatom/async'\n\nexport type Element = {\n  id: string\n  // ...\n}\n\nexport const fetchList = reatomAsync(\n  (ctx) => request<Array<Element>>('api/list', ctx.controller),\n  'fetchList',\n)\nexport const listAtom = reatomArray(new Array<Element>(), 'listAtom')\nfetchList.onFulfill.onCall(listAtom)\n```\n\n----------------------------------------\n\nTITLE: Installing Reatom Core Package\nDESCRIPTION: NPM installation command for the Reatom core package\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/src/content/docs/index.md#2025-04-23_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\nnpm i @reatom/core\n```\n\n----------------------------------------\n\nTITLE: Creating a Computed Derived Atom in TypeScript\nDESCRIPTION: Illustrates how to create a computed derived atom using a reducer function and the ctx.spy method to subscribe to other atoms.\nSOURCE: https://github.com/reatom/reatom/blob/v3/packages/core/README.md#2025-04-23_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nconst isCountEvenAtom = atom(\n  (ctx) => ctx.spy(countAtom) % 2 === 0,\n  'isCountEven',\n)\n// isCountEvenAtom: Atom<number>\n```\n\n----------------------------------------\n\nTITLE: Initializing and Using reatomRecord in TypeScript\nDESCRIPTION: Shows the usage of reatomRecord, which provides a wrapper around object records with built-in actions for merging, resetting, and omitting properties.\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/src/content/docs/package/primitives.md#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport { reatomRecord } from '@reatom/primitives'\n\nconst themeAtom = reatomRecord({\n  color: '',\n  size: '',\n  // ...\n})\n\n// built-in actions:\nthemeAtom.merge(ctx, { color: 'red', fontSize: '12px' })\nthemeAtom.reset(ctx, 'color')\nthemeAtom.omit(ctx, 'fontSize')\n```\n\n----------------------------------------\n\nTITLE: Basic Counter Component Using Reatom with Svelte\nDESCRIPTION: Simple Svelte component that uses a Reatom atom as a store for a counter that increments on button click.\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/src/content/docs/package/npm-svelte.md#2025-04-23_snippet_3\n\nLANGUAGE: svelte\nCODE:\n```\n<script>\n  import { atom } from '@reatom/core'\n  import { withSvelte } from '@reatom/npm-svelte'\n\n  const count = atom(0).pipe(withSvelte)\n</script>\n\n<button on:click={() => $count++}>\n\tClicked {$count} {$count === 1 ? 'time' : 'times'}\n</button>\n```\n\n----------------------------------------\n\nTITLE: Installing Reatom Persist Package\nDESCRIPTION: Command to install the @reatom/persist package via npm\nSOURCE: https://github.com/reatom/reatom/blob/v3/packages/persist/README.md#2025-04-23_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\nnpm i @reatom/persist\n```\n\n----------------------------------------\n\nTITLE: Configuring Reatom Logger with TypeScript\nDESCRIPTION: Demonstrates how to set up and configure the Reatom logger with various options including history length, batching, and filtering. The logger can be configured for development environments and supports customizable logging behavior.\nSOURCE: https://github.com/reatom/reatom/blob/v3/packages/logger/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { connectLogger, createLogBatched } from '@reatom/logger'\n\nif (import.meta.env.DEV) {\n  connectLogger(ctx)\n}\n\n// OR\n\nconnectLogger(\n  ctx,\n  // optional configuration\n  {\n    // the length of the atom history (patches) to store\n    history: 10,\n    // `false` by default to made your logs short\n    showCause: false,\n    // `true` by default to made your logs clear\n    skipUnnamed: true,\n    // fine tuning :)\n    skip: (patch: AtomCache) => false,\n    // `createLogBatched` by default to not spam you a lot\n    // you could pass regular `console.log` here\n    log: createLogBatched(\n      // optional configuration\n      {\n        // 500ms by default\n        debounce: 500,\n        // 5000ms by default, it helps to not stuck with WS and so on\n        limit: 5000,\n        // `toLocaleTimeString` by default\n        getTimeStamp: () => new Date().toLocaleTimeString()\n\n        log: console.log,\n        // `true` by default to group logs by name\n        shouldGroup: true,\n      },\n    ),\n    // You could customize a logs group: `Reatom ${domain}N transactions`\n    domain: '',\n  },\n)\n```\n\n----------------------------------------\n\nTITLE: Creating Reatom-Powered Lit Components\nDESCRIPTION: This snippet demonstrates how to create a Lit component with Reatom integration. It shows setting up a context, creating atoms for state, defining actions, and using the withReatom mixin to enable reactivity within the component.\nSOURCE: https://github.com/reatom/reatom/blob/v3/packages/npm-lit/README.md#2025-04-23_snippet_0\n\nLANGUAGE: Javascript\nCODE:\n```\nimport { setupCtx, withReatom } from \"@reatom/npm-lit\";\nimport { atom, action, createCtx } from \"@reatom/core\";\nimport { LitElement, html } from \"lit\";\n\nconst ctx = createCtx();\nsetupCtx(ctx);\n\nconst count = atom(0);\nconst text = atom('Empty');\nconst countText = atom((ctx) => `Current count: ${ctx.spy(count)}`);\nconst increment = action((ctx) => {\n  count(ctx, (v) => v + 1);\n});\n\nsetTimeout(() => text(ctx, 'Not Empty'), 5000)\nsetInterval(() => increment(ctx), 1000);\n\n\nexport class Test extends withReatom(LitElement) {\n  render() {\n    return html`<div>\n      TextAtom: ${this.ctx.spy(text)} <br />\n      Render: ${this.ctx.spy(countText)} <br />\n      <button @click=\"${() => increment(ctx)}\">Inc</button>\n    </div>`;\n  }\n}\n\nif (!customElements.get(\"test-element\")) {\n  customElements.define(\"test-element\", Test);\n}\n\n```\n\n----------------------------------------\n\nTITLE: Creating Reatom Context\nDESCRIPTION: Creates a Reatom context for managing application state and computations. Essential for testing and SSR scenarios.\nSOURCE: https://github.com/reatom/reatom/blob/v3/packages/core/README.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n// ~/ctx.ts\nimport { createCtx } from '@reatom/core'\n\n// create context in the app root and use it to start all computations\n// for tests or SSR you will want to create a different context\nexport const ctx = createCtx()\n```\n\n----------------------------------------\n\nTITLE: Creating a Filtered List Atom with Reatom in TypeScript\nDESCRIPTION: This snippet shows how to create a derived atom that filters data from another atom. When connected, it automatically triggers the fetch of the original data.\nSOURCE: https://github.com/reatom/reatom/blob/v3/packages/async/README.md#2025-04-23_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nexport const filteredListAtom = atom(\n  (ctx) => ctx.spy(fetchList.dataAtom).filter((item) => item.active),\n  'filteredListAtom',\n)\n```\n\n----------------------------------------\n\nTITLE: State Logging with Devtools\nDESCRIPTION: Example demonstrating how to log state changes using devtools state tracking functionality.\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/src/content/docs/package/devtools.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nconst [state, setState] = useState()\nDEVTOOLS?.state('my-state', state)\n```\n\n----------------------------------------\n\nTITLE: Initializing and Using reatomMap in TypeScript\nDESCRIPTION: Shows the usage of reatomMap, which provides a wrapper around Map with built-in actions and functions for manipulation and retrieval.\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/src/content/docs/package/primitives.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { reatomMap } from '@reatom/primitives'\n\nconst thingsAtom = reatomMap<string, Entity>()\n\n// read map\nctx.get(thingsAtom)\n\n// built-in actions:\nthingsAtom.set(ctx, key, new Entity())\nthingsAtom.delete(ctx, key)\nthingsAtom.clear(ctx)\nthingsAtom.reset(ctx)\nthingsAtom.getOrCreate(ctx, key, () => new Entity()) // non nullable entity\nthingsAtom.entries(ctx, key)\nthingsAtom.values(ctx, key)\nthingsAtom.keys(ctx, key)\n\n// built-in functions:\nthingsAtom.get(ctx, key) // nullable entity\nthingsAtom.has(ctx, key)\n\n// built-in atoms:\nctx.get(thingsAtom.sizeAtom)\n```\n\n----------------------------------------\n\nTITLE: Updating Cache in Reatom Async Actions (TypeScript)\nDESCRIPTION: Demonstrates how to precisely manage the cache in Reatom using setWithParams and deleteWithParams methods. This approach is useful for implementing optimistic update logic.\nSOURCE: https://github.com/reatom/reatom/blob/v3/packages/async/README.md#2025-04-23_snippet_15\n\nLANGUAGE: typescript\nCODE:\n```\nimport { reatomAsync, withCache, withDataAtom } from '@reatom/async'\n\nexport const fetchElement = reatomAsync(async (ctx, id, search) => {\n  return await request(`api/list/${id}?search=${search}`, ctx.controller)\n}, 'fetchElement').pipe(withCache(), withDataAtom())\n\nexport const updateElement = reatomAction(async (ctx, id, data) => {\n  fetchElement.cacheAtom.setWithParams(ctx, [id, ''], data)\n  // call api for update...\n}, 'updateElement')\n```\n\n----------------------------------------\n\nTITLE: Installing Reatom Zod Package via NPM\nDESCRIPTION: Command to install the @reatom/npm-zod package using npm package manager.\nSOURCE: https://github.com/reatom/reatom/blob/v3/packages/npm-zod/README.md#2025-04-23_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\nnpm i @reatom/npm-zod\n```\n\n----------------------------------------\n\nTITLE: Creating a Custom Persist Adapter in TypeScript\nDESCRIPTION: TypeScript interface and implementation details for creating a custom persistence adapter using reatomPersist. Defines the core interfaces for the persistence storage system.\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/src/content/docs/package/persist.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nexport const reatomPersist = (\n  storage: PersistStorage,\n): WithPersist & {\n  storageAtom: AtomMut<PersistStorage>\n}\n\nexport interface WithPersist {\n  <T extends Atom>(\n    options: string | WithPersistOptions<AtomState<T>>\n  ): (anAtom: T) => T\n}\n\nexport interface PersistStorage {\n  name: string\n  get(ctx: Ctx, key: string): PersistRecord | null\n  set(ctx: Ctx, key: string, rec: PersistRecord): void\n  clear?(ctx: Ctx, key: string): void\n  subscribe?(ctx: Ctx, key: string, callback: Fn<[]>): Unsubscribe\n}\n\nexport interface PersistRecord<T = unknown> {\n  data: T\n  id: number\n  timestamp: number\n  version: number\n  to: number\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Atoms with Single Function in TypeScript\nDESCRIPTION: Demonstrates atom creation using a single function approach. This method combines all atom behavior into one function, including state updates, action handling, and change listeners.\nSOURCE: https://github.com/reatom/reatom/blob/v3/packages/core/history-v2.md#2025-04-23_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nconst add = declareAction<number>()\n\nconst counterAtom = declareAtom({ inc: () => null }, ($, state = 0) => {\n  const oldState = state\n\n  $((store, ctx) =>\n    console.log(\n      `counterAtom receive new value: ${state}.`,\n      `It is ${(ctx.updates = (ctx.updates ?? 0) + 1)} update`,\n    ),\n  )\n\n  $({ inc: () => state++ })\n\n  $(add, (value) => (state += value))\n\n  if ($(shouldSyncCounterAtom)) {\n    $(globalCounterAtom, (globalCounter) => (state = globalCounter))\n  }\n\n  return state\n})\n```\n\n----------------------------------------\n\nTITLE: Take Filter Implementation with Value Transformation\nDESCRIPTION: Shows how to use take with a filter function to transform event values and handle input validation.\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/src/content/docs/package/effects.md#2025-04-23_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nconst input = await take(ctx, onChange, (ctx, event) => event.target.value)\n```\n\n----------------------------------------\n\nTITLE: Correct onEvent Usage with Animation Checkpoint\nDESCRIPTION: Improved example using onEvent with a checkpoint to ensure the animation finish event is properly captured even if content loading takes a long time.\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/src/content/docs/package/web.md#2025-04-23_snippet_3\n\nLANGUAGE: ts\nCODE:\n```\nconst loadPageContent = reatomAsync(async (ctx) => {\n  const animation = heroElement.animate(heroAnimation)\n  //  We make a checkpoint before loading...\n  const animationFinishedCheckpoint = onEvent(ctx, animation, 'finish')\n\n  const content = await api.fetchContent()\n\n  // ...and we will catch that event even if content loading takes ages\n  await animationFinishedCheckpoint\n\n  pageContent(ctx, content)\n})\n```\n\n----------------------------------------\n\nTITLE: Installing Reatom Solid.js Bindings\nDESCRIPTION: Command to install the Reatom bindings for Solid.js using npm. Additional dependencies like @reatom/core or @reatom/framework and solid-js are required.\nSOURCE: https://github.com/reatom/reatom/blob/v3/packages/npm-solid-js/README.md#2025-04-23_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nnpm i @reatom/npm-solid-js\n```\n\n----------------------------------------\n\nTITLE: SSR Implementation with Reatom Persist\nDESCRIPTION: Complete example of implementing server-side rendering with persistence support\nSOURCE: https://github.com/reatom/reatom/blob/v3/packages/persist/README.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\n// src/ssr.ts\nimport { createMemStorage, reatomPersist } from '@reatom/persist'\n\nconst ssrStorage = createMemStorage({ name: 'ssr', subscribe: false })\nexport const { snapshotAtom } = ssrStorage\nexport const withSsr = reatomPersist(ssrStorage)\n```\n\nLANGUAGE: typescript\nCODE:\n```\n// src/features/goods/model.ts\nimport { atom } from '@reatom/core'\nimport { withSsr } from 'src/ssr'\n\nexport const filtersAtom = atom('').pipe(withSsr('goods/filters'))\n\nexport const listAtom = atom(new Map()).pipe(\n  withSsr({\n    key: 'goods/list',\n    toSnapshot: (ctx, list) => [...list],\n    fromSnapshot: (ctx, snapshot) => new Map(snapshot),\n  }),\n)\n```\n\nLANGUAGE: typescript\nCODE:\n```\n// src/root.ts\nimport { createCtx } from '@reatom/core'\nimport { snapshotAtom } from 'src/ssr'\n\nexport const ssrHandler = async () => {\n  const ctx = createCtx()\n\n  await doAsyncStuffToFillTheState(ctx)\n\n  const snapshot = ctx.get(snapshotAtom)\n\n  return { snapshot }\n}\n\nexport const render = ({ snapshot }) => {\n  export const ctx = createCtx()\n  snapshotAtom(ctx, snapshot)\n\n  runFeaturesAndRenderTheApp(ctx)\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing and Using reatomEnum in TypeScript\nDESCRIPTION: Demonstrates the usage of reatomEnum, which creates an enum-like atom with built-in actions for setting each value.\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/src/content/docs/package/primitives.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { reatomEnum } from '@reatom/primitives'\n\n// first element goes to init state\nconst sortFilterAtom = reatomEnum(['fullName', 'created', 'updated', 'pushed'])\n\n// built-in actions:\nsortFilterAtom.setFullName(ctx)\nsortFilterAtom.setCreated(ctx)\nsortFilterAtom.setUpdated(ctx)\nsortFilterAtom.setPushed(ctx)\n```\n\n----------------------------------------\n\nTITLE: Comparing Debounce Implementations in TypeScript\nDESCRIPTION: Shows different implementations of debounce patterns using both traditional debounce and concurrent approaches in Reatom.\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/src/content/docs/package/effects.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { withConcurrency } from '@reatom/effects'\n\nconst onChangeDebounce = debounce(\n  action((ctx, event) => {\n    inputAtom(ctx, event.currentTarget.value)\n  }),\n  500,\n)\n\nconst onChangeConcurrent = action(async (ctx, event) => {\n  await ctx.schedule(() => sleep(500))\n  inputAtom(ctx, event.currentTarget.value)\n}).pipe(withConcurrency())\n```\n\n----------------------------------------\n\nTITLE: Installing browser implementation with npm\nDESCRIPTION: Command to install the browser-specific implementation of cookie-baker using npm.\nSOURCE: https://github.com/reatom/reatom/blob/v3/packages/npm-cookie-baker/README.md#2025-04-23_snippet_3\n\nLANGUAGE: sh\nCODE:\n```\nnpm install @cookie-baker/browser\n```\n\n----------------------------------------\n\nTITLE: Type Definitions for User Lists with Atomization\nDESCRIPTION: This snippet demonstrates how to define types for a list of users using atomization. It shows the contrast between the DTO structure from the backend and the atomized structure used in the application.\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/src/content/docs/recipes/atomization.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\n// DTO\ntype Users = Array<{\n  id: string\n  name: string\n}>\n\n// App\ntype Users = AtomMut<\n  Array<{\n    id: string\n    name: AtomMut<string>\n  }>\n>\n```\n\n----------------------------------------\n\nTITLE: Status Tracking with Reatom Async in TypeScript\nDESCRIPTION: Shows how to track various statuses of an async operation using withStatusesAtom. The statusesAtom provides boolean flags for different states of the async effect.\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/src/content/docs/package/async.md#2025-04-23_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\nimport { reatomAsync, withStatusesAtom } from '@reatom/async'\n\nexport const fetchList = reatomAsync(\n  (ctx) => request('api/list', ctx.controller),\n  'fetchList',\n).pipe(withStatusesAtom())\n\n// ...\n\nconst initStatuses = ctx.get(fetchList.statusesAtom)\n\ninitStatuses.isPending // false\ninitStatuses.isFulfilled // false\ninitStatuses.isRejected // false\ninitStatuses.isSettled // false\n\ninitStatuses.isFirstPending // false\ninitStatuses.isEverPending // false\ninitStatuses.isEverSettled // false\n```\n\n----------------------------------------\n\nTITLE: Filtering Atom Updates with filter Operator\nDESCRIPTION: Shows how to use the filter operator to prevent unnecessary updates of an atom based on a comparison function.\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/src/content/docs/package/lens.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { filter } from '@reatom/lens'\nimport { isShallowEqual } from '@reatom/utils'\n\nexport const listMemoAtom = filteredListAtom.pipe(filter())\n// equals to\nexport const listMemoAtom = filteredListAtom.pipe(\n  filter((ctx, next, prev) => !isShallowEqual(next, prev)),\n)\n```\n\n----------------------------------------\n\nTITLE: Creating a Reactive Data Model with Zod Schema in TypeScript\nDESCRIPTION: Example of using @reatom/npm-zod to create a reactive data model from a Zod schema. This demonstrates defining a User schema with Zod, then using reatomZod to create a model that syncs with localStorage and initializes from stored data.\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/src/content/docs/package/npm-zod.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { parseAtoms } from '@reatom/framework'\nimport { reatomZod } from '@reatom/npm-zod'\nimport * as z from 'zod'\n\nexport const User = z.object({\n  id: z.string().readonly(),\n  email: z.string().readonly(),\n  name: z.string(),\n  age: z.number().optional(),\n})\n\nconst KEY = 'user-data'\nexport const model = reatomZod(User, {\n  sync(ctx) {\n    localStorage.setItem(KEY, JSON.stringify(parseAtoms(ctx, model)))\n  },\n  initState: JSON.parse(localStorage.getItem(KEY) || '{}'),\n})\n```\n\n----------------------------------------\n\nTITLE: Initializing and Using reatomBoolean in TypeScript\nDESCRIPTION: Shows the usage of reatomBoolean, which provides a wrapper around boolean values with built-in actions for toggling and setting the state.\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/src/content/docs/package/primitives.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { reatomBoolean } from '@reatom/primitives'\n\nconst modalAtom = reatomBoolean(false)\n\n// built-in actions:\nmodalAtom.toggle(ctx)\nmodalAtom.setTrue(ctx)\nmodalAtom.setFalse(ctx)\nmodalAtom.reset(ctx)\n```\n\n----------------------------------------\n\nTITLE: Implementing Lazy Retry Logic with onConnect in Reatom\nDESCRIPTION: Demonstrates how to implement an infinite retry loop with onConnect that safely aborts when the atom disconnects, preventing memory leaks.\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/src/content/docs/package/hooks.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n// lazy retry logic\nonConnect(fetchSome.dataAtom, async (ctx) => {\n  while (true) {\n    await ctx.schedule(() => sleep(5_000))\n    await fetchSome(ctx)\n  }\n})\n```\n\n----------------------------------------\n\nTITLE: Demonstrating toStringKey Usage in TypeScript\nDESCRIPTION: Example showing how toStringKey function converts data to string representation, with support for Map and Set structures. The function generates consistent string outputs for equivalent data structures.\nSOURCE: https://github.com/reatom/reatom/blob/v3/packages/utils/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { toStringKey } from '@reatom/utils'\n\ntoStringKey(new Map([[1, {}]]) === toStringKey(new Map([[1, {}]]) /// true\n```\n\n----------------------------------------\n\nTITLE: Creating Reatom Units with Dynamic Names from Factory Parameters\nDESCRIPTION: Example showing how to create Reatom atoms with dynamically generated names based on a 'name' parameter in a factory function.\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/src/content/docs/package/eslint-plugin.md#2025-04-23_snippet_7\n\nLANGUAGE: ts\nCODE:\n```\nconst reatomFood = (config: {\n  name: string\n  calories: number\n  fat: number\n  carbs: number\n  protein: number\n}) => {\n  const { name } = config\n  const calories = atom(config.calories, `${name}.calories`)\n  const fat = atom(config.fat, `${name}.fat`)\n  const carbs = atom(config.carbs, `${name}.carbs`)\n  const protein = atom(config.protein, `${name}.protein`)\n  return { calories, fat, carbs, protein }\n}\n```\n\n----------------------------------------\n\nTITLE: Manually Aborting Cached Promises in Reatom (TypeScript)\nDESCRIPTION: Shows how to manually abort existing promises when resetting the cache in Reatom. This is useful when you need to cancel ongoing requests during cache invalidation.\nSOURCE: https://github.com/reatom/reatom/blob/v3/packages/async/README.md#2025-04-23_snippet_14\n\nLANGUAGE: typescript\nCODE:\n```\nexport const resetListFetching = action((ctx) => {\n  for (const [, { controller }] of ctx.get(fetchList.cacheAtom)) {\n    controller.abort(toAbortError('reset'))\n  }\n  fetchList.cacheAtom.reset(ctx)\n})\n```\n\n----------------------------------------\n\nTITLE: Handling Union Types in Atoms\nDESCRIPTION: This snippet demonstrates how to handle union types in atoms using TypeScript, addressing type inference issues when spying on atoms with different types.\nSOURCE: https://github.com/reatom/reatom/blob/v3/packages/core/README.md#2025-04-23_snippet_23\n\nLANGUAGE: typescript\nCODE:\n```\nimport {\n  Atom,\n  Fn,\n  AtomProto,\n  AtomCache,\n  Action,\n  Unsubscribe,\n  Logs,\n} from '@reatom/core'\n\ndeclare module '@reatom/core' {\n  export interface Ctx {\n    // @ts-expect-error\n    get: {\n      <T extends Atom>(anAtom: T): T extends Atom<infer State> ? State : never\n      <T>(anAtom: Atom<T>): T\n      <T>(\n        cb: Fn<\n          [\n            read: Fn<[proto: AtomProto], AtomCache<any> | undefined>,\n            // this is `actualize` function and\n            // the types intentionally awkward\n            // coz it only for internal usage\n            fn?: Fn,\n          ],\n          T\n        >,\n      ): T\n    }\n    // @ts-expect-error\n    spy?: {\n      <T extends Atom>(anAtom: T): T extends Atom<infer State> ? State : never\n      <T>(anAtom: Atom<T>): T\n      <Params extends any[] = any[], Payload = any>(\n        anAction: Action<Params, Payload>,\n        cb: Fn<[call: { params: Params; payload: Payload }]>,\n      ): void\n      <T>(atom: Atom<T>, cb: Fn<[newState: T, prevState: undefined | T]>): void\n    }\n\n    schedule<T = void>(\n      cb: Fn<[Ctx], T>,\n      step?: -1 | 0 | 1 | 2,\n    ): Promise<Awaited<T>>\n\n    subscribe<T>(atom: Atom<T>, cb: Fn<[T]>): Unsubscribe\n    subscribe(cb: Fn<[patches: Logs, error?: Error]>): Unsubscribe\n\n    cause: AtomCache\n  }\n}\n\nconst nameAtom = atom('')\nconst ageAtom = atom(0)\nconst valuesAtom = atom((ctx) => [nameAtom, ageAtom].map((a) => ctx.spy(a)))\n// all fine\n```\n\n----------------------------------------\n\nTITLE: Configuring Search Parameter Persistence with Options in TypeScript\nDESCRIPTION: Example of using withSearchParamsPersist with custom options for parsing and serializing complex data.\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/src/content/docs/package/url.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport qs from 'qs'\nimport { atom } from '@reatom/core'\nimport { withSearchParamsPersist } from '@reatom/url'\n\nexport const filtersAtom = atom<Filters>({}, 'filtersAtom').pipe(\n  withSearchParamsPersist('filter', {\n    replace: true,\n    parse: (v = '') => qs.parse(v, { arrayFormat: 'bracket' }),\n    serialize: (v) => qs.stringify(v, { arrayFormat: 'bracket' }),\n  }),\n)\n```\n\n----------------------------------------\n\nTITLE: Using onConnect for WebSocket Messages with Reatom\nDESCRIPTION: Example showing how to use onConnect to subscribe to WebSocket messages when an atom has subscribers, and clean up the subscription when it no longer has subscribers.\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/src/content/docs/package/hooks.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { atom } from '@reatom/core'\nimport { onConnect } from '@reatom/hooks'\n\nexport const messagesAtom = atom([], 'messagesAtom')\nconst dispose = onConnect(messagesAtom, (ctx) => {\n  const cb = (message) => {\n    messagesAtom(ctx, (messages) => [...messages, message])\n  }\n\n  WS.on('message', cb)\n\n  return () => WS.off('message', cb)\n})\n```\n\n----------------------------------------\n\nTITLE: Fixed Animation Event Handler with Checkpoint\nDESCRIPTION: Corrected implementation using checkpoints to ensure proper animation event handling regardless of network speed.\nSOURCE: https://github.com/reatom/reatom/blob/v3/packages/web/README.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nconst loadPageContent = reatomAsync(async (ctx) => {\n  const animation = heroElement.animate(heroAnimation)\n  //  We make a checkpoint before loading...\n  const animationFinishedCheckpoint = onEvent(ctx, animation, 'finish')\n\n  const content = await api.fetchContent()\n\n  // ...and we will catch that event even if content loading takes ages\n  await animationFinishedCheckpoint\n\n  pageContent(ctx, content)\n})\n```\n\n----------------------------------------\n\nTITLE: Resetting a reatomResource on Disconnect in Reatom (TypeScript)\nDESCRIPTION: Shows the proper way to reset a resource when a component disconnects, ensuring it will be reinitialized on next connection without causing duplicate initializations.\nSOURCE: https://github.com/reatom/reatom/blob/v3/packages/async/README.md#2025-04-23_snippet_28\n\nLANGUAGE: typescript\nCODE:\n```\nonDisconnect(myResource, myResource.reset)\n```\n\n----------------------------------------\n\nTITLE: Traditional Approach for Async Resource Fetching in Reatom (TypeScript)\nDESCRIPTION: Demonstrates a verbose approach to fetching data with reatomAsync, including manual trigger setup, abort handling, and connection management.\nSOURCE: https://github.com/reatom/reatom/blob/v3/packages/async/README.md#2025-04-23_snippet_25\n\nLANGUAGE: typescript\nCODE:\n```\nimport { reatomAsync, withDataAtom, withAbort } from '@reatom/async'\nimport { onConnect } from '@reatom/hooks'\n\nconst fetchList = reatomAsync(async (ctx, page: string, search: string) => {\n  return await request(`/api/list?page=${page}&q=${search}`, ctx.controller)\n}, 'fetchList').pipe(withDataAtom([]), withAbort())\nonConnect(fetchList.dataAtom, (ctx) => {\n  // init\n  fetchList(ctx, ctx.get(pageAtom), ctx.get(searchAtom))\n  // cleanup\n  return () => fetchList.abort(ctx)\n})\n// trigger\npageAtom.onChange((ctx, page) =>\n  fetchSuggestion(ctx, page, ctx.get(searchAtom)),\n)\nsearchAtom.onChange((ctx, search) =>\n  fetchSuggestion(ctx, ctx.get(pageAtom), search),\n)\n```\n\n----------------------------------------\n\nTITLE: Form State Management with Devtools\nDESCRIPTION: Example showing how to integrate form state management with devtools, including subscription to state changes for form reinitialization.\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/src/content/docs/package/devtools.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nconst { values, init } = useForm()\nReact.useEffect(\n  () => DEVTOOLS?.state('my-form', values).subscribe(init),\n  [state],\n)\n```\n\n----------------------------------------\n\nTITLE: Take Filter with Skip Functionality\nDESCRIPTION: Demonstrates using take with skip marker to filter out unwanted values while maintaining type safety.\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/src/content/docs/package/effects.md#2025-04-23_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nconst input = await take(ctx, onChange, (ctx, event, skip) => {\n  const { value } = event.target\n  return value.length < 6 ? skip : value\n})\n```\n\n----------------------------------------\n\nTITLE: Initializing and Using reatomNumber in TypeScript\nDESCRIPTION: Demonstrates the usage of reatomNumber, which provides a wrapper around number values with built-in actions for incrementing, decrementing, and resetting.\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/src/content/docs/package/primitives.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { reatomNumber } from '@reatom/primitives'\n\nconst counterAtom = reatomNumber<Entity>()\n\n// built-in actions:\ncounterAtom.increment(ctx, value?)\ncounterAtom.decrement(ctx, value?)\ncounterAtom.random(ctx)\ncounterAtom.reset(ctx)\n```\n\n----------------------------------------\n\nTITLE: Manual Cache Reset with Promise Abortion in TypeScript\nDESCRIPTION: Implements manual cache reset with explicit abortion of pending promises using controller.abort().\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/src/content/docs/package/async.md#2025-04-23_snippet_17\n\nLANGUAGE: typescript\nCODE:\n```\nexport const resetListFetching = action((ctx) => {\n  for (const [, { controller }] of ctx.get(fetchList.cacheAtom)) {\n    controller.abort(toAbortError('reset'))\n  }\n  fetchList.cacheAtom.reset(ctx)\n})\n```\n\n----------------------------------------\n\nTITLE: Creating a Basic Reatom Atom with Proper Naming\nDESCRIPTION: Example of creating a Reatom atom with a name parameter matching the variable name, as required by the unit-naming-rule.\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/src/content/docs/package/eslint-plugin.md#2025-04-23_snippet_4\n\nLANGUAGE: ts\nCODE:\n```\nconst count = atom(0, 'count')\n```\n\n----------------------------------------\n\nTITLE: Configuring Custom IndexedDB Database for Atom Persistence in Reatom\nDESCRIPTION: Advanced configuration of IndexedDB adapter with custom database name and BroadcastChannel for real-time synchronization across tabs. Allows for more customized storage behavior.\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/src/content/docs/package/persist-web-storage.md#2025-04-23_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nimport { reatomResource, withCache } from '@reatom/framework'\nimport { withIndexedDb } from '@reatom/persist-web-storage'\n\nexport const listResource = reatomResource(\n  async (ctx) => api.getList(ctx.spy(pageAtom)),\n  'listResource',\n).pipe(withIndexedDb({ key: 'hugeListAtom', dbName: 'myCustomDb', channel }))\n```\n\n----------------------------------------\n\nTITLE: Creating Atoms with TypeScript Type Inference in Reatom\nDESCRIPTION: This snippet demonstrates how TypeScript automatically infers the correct types for different Reatom atoms based on their initialization values. It shows creating basic atoms with primitive values and a dynamic atom that depends on other atoms.\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/src/content/docs/recipes/typescript.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// AtomMut<number>\nconst numAtom = atom(3)\n\n// AtomMut<string>\nconst strAtom = atom('foo')\n\n// Atom<string | number>\nconst dynamicAtom = atom((ctx) => {\n  const num = ctx.spy(numAtom)\n  const str = ctx.spy(strAtom)\n  return num > 0 ? num : str\n})\n```\n\n----------------------------------------\n\nTITLE: Top Controller Retrieval in Actions\nDESCRIPTION: Demonstrates how to find and use the top abort controller in the cause stack for handling async operations.\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/src/content/docs/package/effects.md#2025-04-23_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\nconst doSome = action(async (ctx) => {\n  const data = await ctx.schedule(() => fetchData())\n\n  if (!data) throwAbort('nullable data', getTopController(ctx.cause))\n\n  // ... perform data\n}, 'doSome')\n```\n\n----------------------------------------\n\nTITLE: Synchronizing Atom State with localStorage in Reatom\nDESCRIPTION: Example of creating an atom and synchronizing its state with localStorage using the withLocalStorage adapter. This saves the atom's value under the specified key in browser's localStorage.\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/src/content/docs/package/persist-web-storage.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { atom } from '@reatom/framework'\nimport { withLocalStorage } from '@reatom/persist-web-storage'\n\nexport const tokenAtom = atom('', 'tokenAtom').pipe(withLocalStorage('token'))\n```\n\n----------------------------------------\n\nTITLE: Using withInit with Socket Service Subscription\nDESCRIPTION: Example showing how to use withInit to set up a subscription to a socket service for data updates.\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/src/content/docs/package/hooks.md#2025-04-23_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nexport const dataAtom = atom(0, 'dataAtom').pipe(\n  withInit((ctx, init) => {\n    ctx.get(socketServiceAtom).on('data', (data) => dataAtom(ctx, data))\n\n    return init(ctx)\n  }),\n)\n```\n\n----------------------------------------\n\nTITLE: Invalidating Cache with Reset Action in TypeScript\nDESCRIPTION: Demonstrates how to invalidate the cache using the reset action on cacheAtom to clear all cache records of an async action.\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/src/content/docs/package/async.md#2025-04-23_snippet_15\n\nLANGUAGE: typescript\nCODE:\n```\nimport { reatomAsync, withCache, withDataAtom } from '@reatom/async'\n\nexport const fetchList = reatomAsync(\n  (ctx) => request('api/list', ctx.controller),\n  'fetchList',\n).pipe(withCache(), withDataAtom())\n\nexport const updateList = reatomAsync(async () => {\n  /*  */\n}, 'updateList')\nupdateList.onFulfill.onCall(fetchList.cacheAtom.reset)\n```\n\n----------------------------------------\n\nTITLE: IndexedDB with Flicker Prevention in Reatom\nDESCRIPTION: Implementation showing how to prevent state flickering when using IndexedDB by adding a connection delay.\nSOURCE: https://github.com/reatom/reatom/blob/v3/packages/persist-web-storage/README.md#2025-04-23_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nimport { reatomResource, withCache, onConnect, sleep } from '@reatom/framework'\nimport { withIndexedDb } from '@reatom/persist-web-storage'\n\nexport const listResource = reatomResource(\n  async (ctx) => api.getList(ctx.spy(pageAtom)),\n  'listResource',\n).pipe(withIndexedDb({ key: 'hugeListAtom', dbName: 'myCustomDb', channel }))\nconst isListReadyAtom = atom(false, 'isListReadyAtom')\nonConnect(listResource, async (ctx) => {\n  await ctx.schedule(() => new Promise((r) => requestIdleCallback(r)))\n  isListReadyAtom(ctx, true)\n  return () => isListReadyAtom(ctx, false)\n})\n```\n\n----------------------------------------\n\nTITLE: Configuring UrlAtom for Server-Side Rendering in TypeScript\nDESCRIPTION: Example of setting up UrlAtom for server-side rendering by providing custom URL initialization.\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/src/content/docs/package/url.md#2025-04-23_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\n// a server handler\nexport const handler = async (req) => {\n  const ctx = createCtx()\n  const url = new URL(req.url!, `http://${req.headers.host}`)\n  setupUrlAtomSettings(ctx, () => url)\n  // do your stuff...\n}\n```\n\n----------------------------------------\n\nTITLE: TypeScript strictNullChecks Configuration for Reatom\nDESCRIPTION: This example shows how TypeScript's strictNullChecks setting affects type inference in Reatom. With strictNullChecks enabled, nullable atoms properly maintain their null type possibility, while disabling this option can lead to incorrect type inference.\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/src/content/docs/recipes/typescript.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n/* strictNullChecks: true */\n// AtomMut<string | null>\nconst nullableAtom = atom<string | null>(null)\n\n/* strictNullChecks: false */\n// AtomMut<string>\nconst nullableAtom = atom<string | null>(null)\n```\n\n----------------------------------------\n\nTITLE: Defining Atoms with Static Dependencies in TypeScript\nDESCRIPTION: Shows atom creation with static dependencies. This approach uses a function with predefined methods for handling actions, changes, and scheduling, providing a more structured way to define atom behavior.\nSOURCE: https://github.com/reatom/reatom/blob/v3/packages/core/history-v2.md#2025-04-23_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\n// decline outer actionCreators support\n\nconst counterAtom = declareAtom(\n  { shouldSyncCounterAtom, globalCounterAtom, inc: () => null },\n  ({ get, onAction, onChange, schedule }, state = 0) => {\n    const oldState = state\n\n    schedule((dispatch, ctx) =>\n      console.log(\n        `counterAtom receive new value: ${state}.`,\n        `It is ${(ctx.updates = (ctx.updates ?? 0) + 1)} update`,\n      ),\n    )\n\n    onAction(`inc`, () => state++)\n\n    if (get(`shouldSyncCounterAtom`)) {\n      onChange(`globalCounterAtom`, (globalCounter) => (state = globalCounter))\n    }\n\n    return state\n  },\n)\n```\n\n----------------------------------------\n\nTITLE: Simplified Periodic Data Refresh in Reatom\nDESCRIPTION: This example shows a simplified version of periodic data refresh using Reatom's onConnect utility. It relies on automatic abort strategy for managing the refresh cycle.\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/src/content/docs/package/async.md#2025-04-23_snippet_25\n\nLANGUAGE: typescript\nCODE:\n```\nimport { reatomAsync, withAbort, withDataAtom, withRetry, sleep } from '@reatom/framework' /* prettier-ignore */\n\nexport const fetchList = reatomAsync(\n  (ctx, search: string) => request(`/api/list?q=${search}`, ctx.controller),\n  'fetchList',\n).pipe(withAbort(), withDataAtom([]), withRetry())\nonConnect(fetchList.dataAtom, async (ctx) => {\n  while (true) {\n    await fetchList.retry(ctx).catch(() => {})\n    await ctx.schedule(() => sleep(5000))\n  }\n})\n```\n\n----------------------------------------\n\nTITLE: Persisting Atom State with Cookies in Reatom\nDESCRIPTION: Example of using the withCookie adapter to synchronize atom state with document.cookie. Includes configuration options for cookie attributes like expiration, domain, path, and security settings.\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/src/content/docs/package/persist-web-storage.md#2025-04-23_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nimport { atom } from '@reatom/framework'\nimport { withCookie } from '@reatom/persist-web-storage'\n\ninterface CookieAttributes {\n  maxAge?: number\n  expires?: Date\n  path?: string\n  domain?: string\n  secure?: boolean\n  sameSite?: 'strict' | 'lax' | 'none'\n}\n\nexport const tokenAtom = atom('', 'tokenAtom').pipe(\n  withCookie({\n    maxAge: 3600, // 1 hour\n  })('token'),\n)\n```\n\n----------------------------------------\n\nTITLE: Basic Usage of reatomAsync for Fetching Data\nDESCRIPTION: Simple implementation of reatomAsync for fetching data from an API endpoint.\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/src/content/docs/package/async.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { reatomAsync } from '@reatom/async'\n\nexport const fetchList = reatomAsync(\n  (ctx, page: number) => request(`/api/list?page=${page}`, ctx.controller),\n  'fetchList',\n)\n```\n\n----------------------------------------\n\nTITLE: Basic IndexedDB Implementation in Reatom\nDESCRIPTION: Example showing how to persist atom state to IndexedDB using withIndexedDb adapter.\nSOURCE: https://github.com/reatom/reatom/blob/v3/packages/persist-web-storage/README.md#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport { reatomResource, withCache } from '@reatom/framework'\nimport { withIndexedDb } from '@reatom/persist-web-storage'\n\nexport const listResource = reatomResource(\n  async (ctx) => api.getList(ctx.spy(pageAtom)),\n  'listResource',\n).pipe(withCache({ withPersist: withIndexedDb }))\n```\n\n----------------------------------------\n\nTITLE: Installing Dependencies for Reatom Development\nDESCRIPTION: Command to install dependencies for all packages in the Reatom repository. Requires Node.js 18 and npm 8.\nSOURCE: https://github.com/reatom/reatom/blob/v3/CONTRIBUTING.md#2025-04-23_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\nnpm install\n```\n\n----------------------------------------\n\nTITLE: Implementing Path-Specific Search Parameter Persistence in TypeScript\nDESCRIPTION: Example of using a search parameter lens with a wildcard path option for persistence across multiple routes.\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/src/content/docs/package/url.md#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport { searchParamsAtom } from '@reatom/url'\n\nexport const filtersAtom = searchParamsAtom.lens('filters', { path: '/list/*' })\n//...\nurlAtom.go('/list')\nfiltersAtom(ctx, 'some')\nctx.get(urlAtom).href // http://example.com/list?filters=some\n\nurlAtom.go('/list/123')\nctx.get(urlAtom).href // http://example.com/list/123?filters=some\nurlAtom.go('/list')\nctx.get(urlAtom).href // http://example.com/list?filters=some\n```\n\n----------------------------------------\n\nTITLE: Implementing SessionStorage Persistence in Reatom\nDESCRIPTION: Example showing how to synchronize a Reatom atom's state with sessionStorage using withSessionStorage adapter.\nSOURCE: https://github.com/reatom/reatom/blob/v3/packages/persist-web-storage/README.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { atom } from '@reatom/framework'\nimport { withSessionStorage } from '@reatom/persist-web-storage'\n\nexport const tokenAtom = atom('', 'tokenAtom').pipe(withSessionStorage('token'))\n```\n\n----------------------------------------\n\nTITLE: Creating Reatom Atoms in Object Properties with Proper Naming\nDESCRIPTION: Example showing how to name Reatom atoms that are assigned to properties of an object, following the unit-naming-rule conventions.\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/src/content/docs/package/eslint-plugin.md#2025-04-23_snippet_5\n\nLANGUAGE: ts\nCODE:\n```\nconst atomsRec = {\n  count: atom(0, 'atomsRec.count'),\n}\n```\n\n----------------------------------------\n\nTITLE: Using onEvent with WebSocket in Reatom\nDESCRIPTION: Example of using onEvent function with WebSocket to create a stock price tracker atom that subscribes to ticker updates and handles socket events.\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/src/content/docs/package/web.md#2025-04-23_snippet_1\n\nLANGUAGE: ts\nCODE:\n```\nimport { atom, onConnect, onCtxAbort } from '@reatom/framework'\nimport { onEvent } from '@reatom/web'\n\nconst socket = new WebSocket('wss://example.com')\n\nconst reatomStock = (ticker) => {\n  const stockAtom = atom(null, `${ticker}StockAtom`)\n  onConnect(stockAtom, async (ctx) => {\n    if (socket.readyState !== WebSocket.OPEN) {\n      await onEvent(ctx, socket, 'open')\n    }\n    socket.send(JSON.stringify({ ticker, type: 'sub' }))\n    onEvent(ctx, socket, 'message', (event) => {\n      if (event.data.ticker === ticker) stockAtom(ctx, JSON.parse(event.data))\n    })\n    onEvent(ctx, socket, 'close', () => ctx.controller.abort())\n    onEvent(ctx, socket, 'error', () => ctx.controller.abort())\n    onCtxAbort(ctx, () =>\n      socket.send(JSON.stringify({ ticker, type: 'unsub' })),\n    )\n  })\n\n  return stockAtom\n}\n\nconst googStockAtom = reatomStock('GOOG')\n\nctx.subscribe(googStockAtom, updateView)\n```\n\n----------------------------------------\n\nTITLE: Implementing Periodic Data Refresh in Reatom\nDESCRIPTION: Implements a polling pattern to keep data fresh using onConnect from @reatom/hooks. Includes automatic retry and data management.\nSOURCE: https://github.com/reatom/reatom/blob/v3/packages/async/README.md#2025-04-23_snippet_21\n\nLANGUAGE: typescript\nCODE:\n```\nimport {\n  reatomAsync,\n  withDataAtom,\n  withRetry,\n  onConnect,\n  sleep,\n} from '@reatom/framework'\n\nexport const fetchList = reatomAsync(\n  (ctx, search: string) => request(`/api/list?q=${search}`, ctx.controller),\n  'fetchList',\n).pipe(withDataAtom([]), withRetry())\nonConnect(fetchList.dataAtom, async (ctx) => {\n  while (ctx.isConnected()) {\n    await fetchList.retry(ctx).catch(() => {})\n    await ctx.schedule(() => sleep(5000))\n  }\n})\n```\n\n----------------------------------------\n\nTITLE: Cookie Storage Implementation in Reatom\nDESCRIPTION: Example showing how to synchronize atom state with document.cookie using withCookie adapter with custom cookie attributes.\nSOURCE: https://github.com/reatom/reatom/blob/v3/packages/persist-web-storage/README.md#2025-04-23_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nimport { atom } from '@reatom/framework'\nimport { withCookie } from '@reatom/persist-web-storage'\n\ninterface CookieAttributes {\n  maxAge?: number\n  expires?: Date\n  path?: string\n  domain?: string\n  secure?: boolean\n  sameSite?: 'strict' | 'lax' | 'none'\n}\n\nexport const tokenAtom = atom('', 'tokenAtom').pipe(\n  withCookie({\n    maxAge: 3600, // 1 hour\n  })('token'),\n)\n```\n\n----------------------------------------\n\nTITLE: Creating a Vue App plugin with createReatomVue\nDESCRIPTION: Example of creating a Vue App plugin using createReatomVue function. It creates a Reatom context and registers it with the Vue application.\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/src/content/docs/package/npm-vue.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createCtx } from '@reatom/core'\nimport { createReatomVue } from '@reatom/npm-vue'\n\nconst ctx = createCtx()\napp.use(createReatomVue(ctx))\n```\n\n----------------------------------------\n\nTITLE: Building Specific Reatom Package\nDESCRIPTION: Command to build a specific package using Turbo. Requires replacing PACKAGE_NAME with the target package identifier.\nSOURCE: https://github.com/reatom/reatom/blob/v3/CONTRIBUTING.md#2025-04-23_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\nnpx turbo run build --filter=<PACKAGE_NAME>\n```\n\n----------------------------------------\n\nTITLE: Using the devtools log method in a function\nDESCRIPTION: Example of using the DEVTOOLS.log method to log data within a function. This demonstrates the optional chaining pattern to safely use devtools even when it might not be available.\nSOURCE: https://github.com/reatom/reatom/blob/v3/packages/devtools/README.md#2025-04-23_snippet_2\n\nLANGUAGE: ts\nCODE:\n```\nfunction doSome(payload) {\n  DEVTOOLS?.log('doSome', payload)\n\n  // the rest of the code...\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing Basic Atoms for Page State in Reatom (TypeScript)\nDESCRIPTION: Creates two atoms for storing page number and search query, which will be used as dependencies for an asynchronous resource.\nSOURCE: https://github.com/reatom/reatom/blob/v3/packages/async/README.md#2025-04-23_snippet_24\n\nLANGUAGE: typescript\nCODE:\n```\nexport const pageAtom = atom(1, 'pageAtom')\nexport const searchAtom = atom('', 'searchAtom')\n```\n\n----------------------------------------\n\nTITLE: Using useAction Hook with Conditional Dispatch\nDESCRIPTION: Example of using useAction with conditional dispatch logic.\nSOURCE: https://github.com/reatom/reatom/blob/v3/packages/react-v2/README.md#2025-04-23_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nconst handleUpdateData = useAction((payload) => {\n  if (condition) return dataAtom.update(payload)\n}, [])\n```\n\n----------------------------------------\n\nTITLE: Persisting Resource State to IndexedDB in Reatom\nDESCRIPTION: Basic example of using withIndexedDB adapter with a resource atom to persist large data to IndexedDB. This approach is preferable over localStorage for storing large amounts of data.\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/src/content/docs/package/persist-web-storage.md#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport { reatomResource, withCache } from '@reatom/framework'\nimport { withIndexedDb } from '@reatom/persist-web-storage'\n\nexport const listResource = reatomResource(\n  async (ctx) => api.getList(ctx.spy(pageAtom)),\n  'listResource',\n).pipe(withCache({ withPersist: withIndexedDb }))\n```\n\n----------------------------------------\n\nTITLE: Custom IndexedDB Implementation in Reatom\nDESCRIPTION: Advanced example showing how to use IndexedDB with custom database name and broadcast channel.\nSOURCE: https://github.com/reatom/reatom/blob/v3/packages/persist-web-storage/README.md#2025-04-23_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nimport { reatomResource, withCache } from '@reatom/framework'\nimport { withIndexedDb } from '@reatom/persist-web-storage'\n\nexport const listResource = reatomResource(\n  async (ctx) => api.getList(ctx.spy(pageAtom)),\n  'listResource',\n).pipe(withIndexedDb({ key: 'hugeListAtom', dbName: 'myCustomDb', channel }))\n```\n\n----------------------------------------\n\nTITLE: Defining UrlAtom and SearchParamsAtom Types in TypeScript\nDESCRIPTION: Type definitions for the UrlAtom and SearchParamsAtom interfaces, describing their structure and methods.\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/src/content/docs/package/url.md#2025-04-23_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\n// used by `urlAtom`\nexport interface UrlAtom extends Atom<URL> {\n  (ctx: Ctx, url: URL, replace?: boolean): URL\n  (ctx: Ctx, update: (url: URL, ctx: Ctx) => URL, replace?: boolean): URL\n\n  go: Action<[path: string, replace?: boolean], URL>\n  settingsAtom: AtomMut<AtomUrlSettings>\n}\n\n// used by `searchParamsAtom`\nexport interface SearchParamsAtom extends Atom<Rec<string>> {\n  set: Action<[key: string, value: string, replace?: boolean], void>\n  del: Action<[key: string, replace?: boolean], void>\n  /** create AtomMut which will synced with the specified query parameter */\n  lens<T = string>(\n    key: string,\n    parse?: (value?: string) => T,\n    serialize?: (value: T) => undefined | string,\n  ): AtomMut<T>\n  /** create AtomMut which will synced with the specified query parameter */\n  lens<T = string>(\n    key: string,\n    options: {\n      parse?: (value?: string) => T\n      serialize?: (value: T) => undefined | string\n      replace?: boolean\n      path?: string\n    },\n  ): AtomMut<T>\n}\n```\n\n----------------------------------------\n\nTITLE: Generating New Reatom Package\nDESCRIPTION: Command to run the interactive package generator script for creating new packages in the Reatom ecosystem.\nSOURCE: https://github.com/reatom/reatom/blob/v3/CONTRIBUTING.md#2025-04-23_snippet_2\n\nLANGUAGE: sh\nCODE:\n```\nnpm run package-generator\n```\n\n----------------------------------------\n\nTITLE: React Data Fetching with Manual Abort Logic\nDESCRIPTION: Example of fetching data in React with manual abort handling using useEffect and useAction hooks from Reatom.\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/src/content/docs/package/hooks.md#2025-04-23_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\nimport { reatomAsync, withAbort, withDataAtom } from '@reatom/async'\nimport { useAtom, useAction } from '@reatom/npm-react'\n\nexport const fetchList = reatomAsync(\n  (ctx) => request('api/list', ctx.controller),\n  'fetchList',\n).pipe(withAbort(), withDataAtom([]))\n\nexport const List = () => {\n  const [list] = useAtom(fetchList.dataAtom)\n  const handleFetch = useAction(fetchList)\n  const handleAbort = useAction(fetchList.abort)\n\n  useEffect(() => {\n    handleFetch()\n    return handleAbort\n  }, [])\n\n  return <ul>{list.map(() => '...')}</ul>\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Path-Specific Search Parameter in TypeScript\nDESCRIPTION: Example of creating a search parameter lens with a specific path option.\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/src/content/docs/package/url.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { searchParamsAtom } from '@reatom/url'\n\nexport const filtersAtom = searchParamsAtom.lens('filters', { path: '/list' })\n```\n\n----------------------------------------\n\nTITLE: Using withReatom Mixin with LitElement\nDESCRIPTION: This code snippet shows the syntax for applying the withReatom mixin to a LitElement class. This mixin enables the component to subscribe to Reatom atom changes for reactive updates.\nSOURCE: https://github.com/reatom/reatom/blob/v3/packages/npm-lit/README.md#2025-04-23_snippet_1\n\nLANGUAGE: Javascript\nCODE:\n```\nwithReatom(LitElement)\n```\n\n----------------------------------------\n\nTITLE: Using Filtered Atoms with onUpdate in Reatom Hooks\nDESCRIPTION: Example showing how to use onUpdate with piped atom filters in Reatom. This allows reacting to atom updates through a filter pipeline, with the callback being optional for use in pipe chains.\nSOURCE: https://github.com/reatom/reatom/blob/v3/packages/hooks/CHANGELOG.md#2025-04-23_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\nYou could write now `onUpdate(anAtom.pipe(filter), cb)`\n\nThe second callback is optional now and you could use it in a pipe `anAtom.pipe(effect(() => {...}), onUpdate)` - this chains is active now and will react to `anAtom` updates\n```\n\n----------------------------------------\n\nTITLE: Implementing Form Component with Reatom\nDESCRIPTION: Example of implementing a form component using Reatom atoms and React bindings.\nSOURCE: https://github.com/reatom/reatom/blob/v3/packages/react-v2/README.md#2025-04-23_snippet_8\n\nLANGUAGE: jsx\nCODE:\n```\nimport { createPrimitiveAtom } from '@reatom/core-v2/primitives'\nimport { useAtom } from '@reatom/react-v2'\n\nconst nameAtom = createPrimitiveAtom('', {\n  onChange: (state, e) => e.currentTarget.value,\n})\n\nexport const Form = () => {\n  const [name, { onChange }] = useAtom(nameAtom)\n\n  return (\n    <form>\n      <label htmlFor=\"name\">Enter your name</label>\n      <input id=\"name\" value={name} onChange={onChange} />\n    </form>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing LocalStorage Persistence in Reatom\nDESCRIPTION: Example showing how to synchronize a Reatom atom's state with localStorage using withLocalStorage adapter.\nSOURCE: https://github.com/reatom/reatom/blob/v3/packages/persist-web-storage/README.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { atom } from '@reatom/framework'\nimport { withLocalStorage } from '@reatom/persist-web-storage'\n\nexport const tokenAtom = atom('', 'tokenAtom').pipe(withLocalStorage('token'))\n```\n\n----------------------------------------\n\nTITLE: Defining TestCtx Interface\nDESCRIPTION: TypeScript interface definition for TestCtx that extends Ctx with mocking and tracking capabilities. Includes methods for mocking atoms, actions, and subscription tracking.\nSOURCE: https://github.com/reatom/reatom/blob/v3/packages/testing/README.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface TestCtx extends Ctx {\n  mock<T>(anAtom: Atom<T>, fallback: T): Unsubscribe\n\n  mockAction<T>(anAction: Action<any[], T>, cb: Fn<[Ctx], T>): Unsubscribe\n\n  subscribeTrack<T, F extends Fn<[T]>>(\n    anAtom: Atom<T>,\n    cb?: F,\n  ): F & {\n    unsubscribe: Unsubscribe\n    calls: ReturnType<typeof mockFn<[T], any>>['calls']\n    lastInput: ReturnType<typeof mockFn<[T], any>>['lastInput']\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Displaying StackBlitz Link in Markdown\nDESCRIPTION: This code snippet shows how to create a clickable badge that opens the project in StackBlitz using Markdown syntax.\nSOURCE: https://github.com/reatom/reatom/blob/v3/examples/vue-search/README.md#2025-04-23_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n[![Open in StackBlitz](https://developer.stackblitz.com/img/open_in_stackblitz.svg)](https://stackblitz.com/github/artalar/reatom/tree/v3/examples/vue-search)\n```\n\n----------------------------------------\n\nTITLE: Dynamic Name-based Atom Naming in Factory Functions\nDESCRIPTION: Example of dynamically naming atoms in a factory function using a name parameter from the config.\nSOURCE: https://github.com/reatom/reatom/blob/v3/packages/eslint-plugin/README.md#2025-04-23_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nconst reatomFood = (config: {\n  name: string\n  calories: number\n  fat: number\n  carbs: number\n  protein: number\n}) => {\n  const { name } = config\n  const calories = atom(config.calories, `${name}.calories`)\n  const fat = atom(config.fat, `${name}.fat`)\n  const carbs = atom(config.carbs, `${name}.carbs`)\n  const protein = atom(config.protein, `${name}.protein`)\n  return { calories, fat, carbs, protein }\n}\n```\n\n----------------------------------------\n\nTITLE: Using useAtom Hook - Basic Implementation\nDESCRIPTION: Basic example of using useAtom hook to connect an atom to the store.\nSOURCE: https://github.com/reatom/reatom/blob/v3/packages/react-v2/README.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst [data] = useAtom(dataAtom)\n```\n\n----------------------------------------\n\nTITLE: Initializing and Using reatomString in TypeScript\nDESCRIPTION: Shows the usage of reatomString, which provides a wrapper around string values with a built-in reset action.\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/src/content/docs/package/primitives.md#2025-04-23_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nimport { reatomString } from '@reatom/primitives'\n\nconst inputAtom = reatomString()\n\n// built-in actions:\ninputAtom.reset(ctx)\n```\n\n----------------------------------------\n\nTITLE: Synchronizing Atom State with sessionStorage in Reatom\nDESCRIPTION: Example of creating an atom and synchronizing its state with sessionStorage using the withSessionStorage adapter. This persists the atom's value for the duration of the page session.\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/src/content/docs/package/persist-web-storage.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { atom } from '@reatom/framework'\nimport { withSessionStorage } from '@reatom/persist-web-storage'\n\nexport const tokenAtom = atom('', 'tokenAtom').pipe(withSessionStorage('token'))\n```\n\n----------------------------------------\n\nTITLE: Using reatomUndo to manage multiple atoms' history in TypeScript\nDESCRIPTION: Example of using reatomUndo to create a computed atom that manages the history of multiple atoms together.\nSOURCE: https://github.com/reatom/reatom/blob/v3/packages/undo/README.md#2025-04-23_snippet_3\n\nLANGUAGE: ts\nCODE:\n```\nimport { atom } from '@reatom/core'\nimport { reatomUndo } from '@reatom/undo'\n\nconst formUndoAtom = reatomUndo([emailAtom, passwordAtom], { length: 50 })\n```\n\n----------------------------------------\n\nTITLE: Importing REPL Component in Astro\nDESCRIPTION: Imports a REPL (Read-Eval-Print Loop) component from the project's components directory to create an interactive sandbox environment for prototyping with Reatom.\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/src/content/docs/repl.mdx#2025-04-23_snippet_0\n\nLANGUAGE: astro\nCODE:\n```\nimport Repl from '../../components/Repl.astro'\n\n<Repl />\n```\n\n----------------------------------------\n\nTITLE: Basic ESLint Configuration with Reatom Recommended Rules\nDESCRIPTION: A simple ESLint configuration that extends the recommended Reatom rules set.\nSOURCE: https://github.com/reatom/reatom/blob/v3/packages/eslint-plugin/README.md#2025-04-23_snippet_1\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"plugins\": [\"@reatom\"],\n  \"extends\": [\"plugin:@reatom/recommended\"]\n}\n```\n\n----------------------------------------\n\nTITLE: Reatom Logger Output Example\nDESCRIPTION: Sample console output from the Reatom logger showing a transaction with action execution and atom state changes. The output includes cause chains and state history.\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/src/content/docs/getting-started/debugging.md#2025-04-23_snippet_3\n\nLANGUAGE: plaintext\nCODE:\n```\nReatom 1 transaction\n 3:37:34 PM 477ms\n increment\n   1\n counterAtom\n   cause: \"<-- increment\"\n   history: [...]\n   newState: 1\n   oldState: 0\n   patch: {...}\n doubledAtom\n   cause: \"<-- counterAtom <-- increment\"\n   history: [...]\n   newState: 2\n   oldState: 0\n   patch: {...}\n```\n\n----------------------------------------\n\nTITLE: Complete ESLint Configuration for React+TypeScript+Prettier+Reatom\nDESCRIPTION: A comprehensive ESLint configuration that integrates Reatom with React, TypeScript, and Prettier, including custom settings for atom naming conventions.\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/src/content/docs/package/eslint-plugin.md#2025-04-23_snippet_3\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"env\": {\n    \"browser\": true,\n    \"es2022\": true\n  },\n  \"extends\": [\n    \"plugin:react/recommended\",\n    \"plugin:react/jsx-runtime\",\n    \"standard-with-typescript\",\n    \"plugin:@reatom/recommended\",\n    \"plugin:prettier/recommended\"\n  ],\n  \"overrides\": [],\n  \"parserOptions\": {\n    \"ecmaVersion\": \"latest\",\n    \"sourceType\": \"module\",\n    \"project\": [\"tsconfig.json\"]\n  },\n  \"plugins\": [\"react\", \"@reatom\", \"prettier\"],\n  \"rules\": {\n    \"@typescript-eslint/explicit-function-return-type\": \"off\",\n    \"prettier/prettier\": \"error\"\n  },\n  \"settings\": {\n    \"atomPostfix\": \"Atom\"\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Complete ESLint Configuration for React + TypeScript + Prettier with Reatom\nDESCRIPTION: A comprehensive ESLint configuration example that combines React, TypeScript, Prettier, and Reatom rules with appropriate settings.\nSOURCE: https://github.com/reatom/reatom/blob/v3/packages/eslint-plugin/README.md#2025-04-23_snippet_3\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"env\": {\n    \"browser\": true,\n    \"es2022\": true\n  },\n  \"extends\": [\n    \"plugin:react/recommended\",\n    \"plugin:react/jsx-runtime\",\n    \"standard-with-typescript\",\n    \"plugin:@reatom/recommended\",\n    \"plugin:prettier/recommended\"\n  ],\n  \"overrides\": [],\n  \"parserOptions\": {\n    \"ecmaVersion\": \"latest\",\n    \"sourceType\": \"module\",\n    \"project\": [\"tsconfig.json\"]\n  },\n  \"plugins\": [\"react\", \"@reatom\", \"prettier\"],\n  \"rules\": {\n    \"@typescript-eslint/explicit-function-return-type\": \"off\",\n    \"prettier/prettier\": \"error\"\n  },\n  \"settings\": {\n    \"atomPostfix\": \"Atom\"\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Using select in React Component with Reatom\nDESCRIPTION: Example showing how to use select function in a React component to efficiently compute list length and sum, preventing unnecessary rerenders when list contents change.\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/src/content/docs/package/lens.md#2025-04-23_snippet_7\n\nLANGUAGE: tsx\nCODE:\n```\nimport { select } from '@reatom/framework'\nimport { reatomComponent } from '@reatom/npm-react'\n\nexport const ListSum = reatomComponent(({ ctx }) => {\n  // Simple call of `ctx.spy(listAtom).length` will cause extra rerenders for elements sorting or it internal changes.\n\n  // correct optimal way, the component will rerender only on `length` change\n  const length = select(ctx, (selectCtx) => selectCtx.spy(listAtom).length)\n  // you could call `select` many times\n  const sum = select(ctx, (selectCtx) =>\n    selectCtx\n      .spy(listAtom)\n      .reduce((acc, el) => acc + selectCtx.spy(el.value), 0),\n  )\n\n  return (\n    <div>\n      The sum of {length} elements is: {sum}\n    </div>\n  )\n}, 'ListSum')\n```\n\n----------------------------------------\n\nTITLE: Using toStringKey Function in TypeScript\nDESCRIPTION: Demonstrates how to use the toStringKey utility function to convert data to a string representation. The example shows that two Map objects with the same structure result in identical string keys.\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/src/content/docs/package/utils.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { toStringKey } from '@reatom/utils'\n\ntoStringKey(new Map([[1, {}]]) === toStringKey(new Map([[1, {}]]) /// true\n```\n\n----------------------------------------\n\nTITLE: Sampling Updates with sample Operator\nDESCRIPTION: Illustrates the use of the sample operator to delay updates until another atom updates or action is called.\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/src/content/docs/package/lens.md#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport { mapPayload, sample } from '@reatom/lens'\n\nexport const lastRequestTimeAtom = fetchData.pipe(\n  mapPayload(0, () => Date.now(), 'fetchStartAtom'),\n  sample(fetchData.onSettle),\n  mapState((ctx, start) => start && Date.now() - start, 'lastRequestTimeAtom'),\n)\n```\n\n----------------------------------------\n\nTITLE: Version 3.6.1 Changelog Entry\nDESCRIPTION: Documents a bug fix release for republishing npm-svelte package without a specific tag.\nSOURCE: https://github.com/reatom/reatom/blob/v3/packages/npm-vue/CHANGELOG.md#2025-04-23_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n## [3.6.1](https://github.com/artalar/reatom/compare/npm-vue-v3.6.0...npm-vue-v3.6.1) (2024-06-22)\n\n### Bug Fixes\n\n- **npm-svelte:** republish without tag ([93c7f7f](https://github.com/artalar/reatom/commit/93c7f7f5ec58247b1b3aec854cd83b0a0ecd6a6c))\n```\n\n----------------------------------------\n\nTITLE: Declaring MockFn Function\nDESCRIPTION: TypeScript declaration for mockFn utility that creates mock functions with call tracking capabilities. Returns a function with additional properties for tracking calls and last input.\nSOURCE: https://github.com/reatom/reatom/blob/v3/packages/testing/README.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare function mockFn<I extends any[], O>(\n  fn?: (...input: I) => O,\n): ((...input: I) => O) & {\n  calls: Array<{ i: I; o: O }>\n  lastInput: Fn<[], I[0]>\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Basic Reatom State and Actions\nDESCRIPTION: Example code showing a simple Reatom counter implementation with an atom for state and an action to modify it.\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/src/content/docs/getting-started/testing.md#2025-04-23_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\n// main.js\nimport { action, atom } from '@reatom/core'\n\nexport const countAtom = atom(0)\nexport const add = action((ctx, payload) => {\n  countAtom(ctx, (state) => state + payload)\n})\n```\n\n----------------------------------------\n\nTITLE: Custom ESLint Configuration with Specific Reatom Rules\nDESCRIPTION: ESLint configuration that selectively enables specific Reatom rules rather than using the entire recommended ruleset.\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/src/content/docs/package/eslint-plugin.md#2025-04-23_snippet_2\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"plugins\": [\"@reatom\"],\n  \"rules\": {\n    \"@reatom/async-rule\": \"error\",\n    \"@reatom/unit-naming-rule\": \"error\"\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Using useAction with inline functions\nDESCRIPTION: Shows how to use useAction with plain functions instead of declared actions, allowing inline function definition with naming capability.\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/src/content/docs/package/npm-vue.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nconst doSomething = useAction((ctx) => {\n  doSomethingBad(ctx)\n  doSomethingGood(ctx)\n}, 'doSomething')\n```\n\n----------------------------------------\n\nTITLE: Binding Plain Functions as Actions\nDESCRIPTION: Examples of binding plain functions as Reatom actions with optional naming and context.\nSOURCE: https://github.com/reatom/reatom/blob/v3/packages/npm-vue/README.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nconst doSomething = useAction((ctx) => {\n  doSomethingBad(ctx)\n  doSomethingGood(ctx)\n}, 'doSomething')\n\nconst doSomething = useAction(model.doSomething, { ctx: differentCtx })\n\nconst doSomething = useAction(\n  (ctx) => {\n    doSomethingBad(ctx)\n    doSomethingGood(ctx)\n  },\n  { name: 'doSomething', ctx: differentCtx },\n)\n```\n\n----------------------------------------\n\nTITLE: Binding actions to custom context with useAction\nDESCRIPTION: Demonstrates how to bind Reatom actions to a custom context using useAction with configuration options, useful for more advanced scenarios.\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/src/content/docs/package/npm-vue.md#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nconst doSomething = useAction(model.doSomething, { ctx: differentCtx })\n\nconst doSomething = useAction(\n  (ctx) => {\n    doSomethingBad(ctx)\n    doSomethingGood(ctx)\n  },\n  { name: 'doSomething', ctx: differentCtx },\n)\n```\n\n----------------------------------------\n\nTITLE: Custom BroadcastChannel Implementation in Reatom\nDESCRIPTION: Advanced example showing how to use a custom BroadcastChannel instance with additional event handling.\nSOURCE: https://github.com/reatom/reatom/blob/v3/packages/persist-web-storage/README.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { atom } from '@reatom/framework'\nimport { reatomPersistBroadcastChannel } from '@reatom/persist-web-storage'\n\nconst myChannel = new BroadcastChannel('customReusableChannel')\n\nmyChannel.onmessage((event) => {\n  console.log(event)\n  // Do some work here\n  // ...\n})\n\nconst withMyBroadcastChannel = reatomPersistBroadcastChannel(myChannel)\n\nexport const isAuthedAtom = atom('', 'isAuthedAtom').pipe(\n  withMyBroadcastChannel('isAuthedAtom'),\n)\n```\n\n----------------------------------------\n\nTITLE: Version History in Markdown\nDESCRIPTION: Markdown formatted changelog showing version history from 3.4.1 down to 3.2.0, including commit references, bug fixes, and feature additions.\nSOURCE: https://github.com/reatom/reatom/blob/v3/packages/persist/CHANGELOG.md#2025-04-23_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n# Changelog\n\n## [3.4.1](https://github.com/artalar/reatom/compare/persist-v3.4.0...persist-v3.4.1) (2024-10-08)\n\n### Bug Fixes\n\n- **persist:** computed handling ([6d747cb](https://github.com/artalar/reatom/commit/6d747cb07a3f857876abdb39afa91e8d9a36f4f0))\n- **persist:** do not accept an action ([f6b3028](https://github.com/artalar/reatom/commit/f6b3028982bec514158ce85474f116627ada3ab2))\n- **persist:** prevent extra computed calls ([65de325](https://github.com/artalar/reatom/commit/65de32501fa22841747069f6056f0d37c43b4ec4))\n```\n\n----------------------------------------\n\nTITLE: Custom ESLint Configuration with Specific Reatom Rules\nDESCRIPTION: ESLint configuration that enables specific Reatom rules rather than using the recommended preset.\nSOURCE: https://github.com/reatom/reatom/blob/v3/packages/eslint-plugin/README.md#2025-04-23_snippet_2\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"plugins\": [\"@reatom\"],\n  \"rules\": {\n    \"@reatom/async-rule\": \"error\",\n    \"@reatom/unit-naming-rule\": \"error\"\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Atom Naming Conventions with Prefixes and Suffixes\nDESCRIPTION: Configuration object example for customizing the unit-naming-rule with prefixes and suffixes for atom names.\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/src/content/docs/package/eslint-plugin.md#2025-04-23_snippet_10\n\nLANGUAGE: ts\nCODE:\n```\n({\n  atomPrefix: '',\n  atomPostfix: 'Atom',\n})\n```\n\n----------------------------------------\n\nTITLE: Setting up Reatom Context Provider in Solid.js\nDESCRIPTION: Example of how to set up the Reatom context provider at the root of a Solid.js application. Creates a Reatom context, connects a logger, and wraps the application with the provider.\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/src/content/docs/package/npm-solid-js.md#2025-04-23_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nimport { createCtx, connectLogger } from '@reatom/framework'\nimport { reatomContext } from '@reatom/npm-solid-js'\n\nconst ctx = createCtx()\nconnectLogger(ctx)\n\nrender(\n  () => (\n    <reatomContext.Provider value={ctx}>\n      <App />\n    </reatomContext.Provider>\n  ),\n  document.getElementById('root')!,\n)\n```\n\n----------------------------------------\n\nTITLE: Using onUpdate with Debounced Fetching\nDESCRIPTION: Example showing how to use onUpdate with a debounced lens to delay data fetching until input stops changing.\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/src/content/docs/package/hooks.md#2025-04-23_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nimport { onUpdate } from '@reatom/hooks'\nimport { debounce } from '@reatom/lens'\n\nonUpdate(onChange.pipe(debounce(250)), (ctx) => fetchData(ctx))\n```\n\n----------------------------------------\n\nTITLE: Creating Store and Context Provider\nDESCRIPTION: Example of creating a Reatom store and setting up the context provider in a React application.\nSOURCE: https://github.com/reatom/reatom/blob/v3/packages/react-v2/README.md#2025-04-23_snippet_7\n\nLANGUAGE: jsx\nCODE:\n```\nimport React from 'react'\nimport { createStore } from '@reatom/core-v2'\nimport { reatomContext } from '@reatom/react-v2'\nimport { Form } from './components/Form'\n\nimport './App.css'\n\nexport const App = () => {\n  const store = createStore()\n\n  return (\n    <div className=\"App\">\n      <reatomContext.Provider value={store}>\n        <Form />\n      </reatomContext.Provider>\n    </div>\n  )\n```\n\n----------------------------------------\n\nTITLE: Exploring Chained Property Access in JavaScript\nDESCRIPTION: Demonstrates various approaches to handling chained property access and action dispatching in Reatom. It includes examples of reading atom states, subscribing to changes, and dispatching actions with different syntaxes.\nSOURCE: https://github.com/reatom/reatom/blob/v3/packages/core/history-v2.md#2025-04-23_snippet_8\n\nLANGUAGE: javascript\nCODE:\n```\n// a.b.c.d\n// ctx.spy(ctx.get(ctx.get(aAtom).b.c).d)\n// a(trz.ctx).b.c(trz.ctx).d(trz)\n// a.pipe(ctx.get).b.c.pipe(ctx.get).d(ctx.spy)\n\nconst doOne = action()\nconst doTwo = action((v /*: 0*/) => v)\nconst a1 = atom(0)\nconst a2 = atom(\n  // `trz` mean \"transaction\"\n  (trz) => {\n    // just read\n    a1(trz.ctx) * 2\n    // read and subscribe\n    a1(trz) * 2\n    // update - just pass the second argument\n    a1(trz, 123)\n    a1(trz, (s) => s + 1)\n\n    /*\n      actions are atoms too, but their state is\n      tmp array of payloads during dispatch\n    */\n\n    // just read\n    doOne(trz.ctx) // []\n    // read and subscribe\n    doOne(trz) // []\n\n    /*\n      the main question is how to describe\n      action call without payload - void - no arguments\n    */\n\n    // (1) undefined\n    doOne(trz, undefined)\n    doTwo(trz, 0)\n    // VS (2) arguments array\n    doOne(trz, [])\n    doTwo(trz, [0])\n    // VS (3) `call` overload\n    doOne.call(trz)\n    doTwo.call(trz, 0)\n    // VS (4) separate `dispatch` method\n    doOne.dispatch(trz)\n    doTwo.dispatch(trz, 0)\n    // VS (5) trz `call`\n    trz.act(doOne)\n    trz.act(doTwo, 0)\n    // VS (6) old `dispatch` by action overload\n    trz.dispatch(doOne())\n    trz.dispatch(doTwo(0))\n\n    /* result of one call - array with one element */\n\n    doOne(trz.ctx) // [undefined]\n    doTwo(trz.ctx) // [0]\n  },\n)\n```\n\n----------------------------------------\n\nTITLE: Importing atom from Reatom Core in TypeScript\nDESCRIPTION: Shows how to import the atom function from the @reatom/core package.\nSOURCE: https://github.com/reatom/reatom/blob/v3/packages/core/README.md#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport { atom } from '@reatom/core'\n```\n\n----------------------------------------\n\nTITLE: Reatom with Svelte Using Separated Model\nDESCRIPTION: Svelte component that connects to Reatom atoms and actions defined in a separate model file.\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/src/content/docs/package/npm-svelte.md#2025-04-23_snippet_4\n\nLANGUAGE: svelte\nCODE:\n```\n<script>\n\timport { withSvelte } from '@reatom/npm-svelte'\n  import { countAtom, timesAtom, increment } from './model'\n\n\tconst count = withSvelte(countAtom)\n\tconst times = withSvelte(timesAtom)\n\tconst handleIncrement = withSvelte(increment).set\n</script>\n\n<button on:click={handleIncrement}>\n\tClicked {$count} {$times}\n</button>\n```\n\n----------------------------------------\n\nTITLE: Using useAtom Hook with Selector\nDESCRIPTION: Example of using useAtom with a selector to get dependent values.\nSOURCE: https://github.com/reatom/reatom/blob/v3/packages/react-v2/README.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nconst [propAtom] = useMemo(\n  () => createAtom({ dataAtom }, ({ get }) => get('dataAtom')[props.id]),\n  [props.id],\n)\nconst [propValue] = useAtom(propAtom)\n```\n\n----------------------------------------\n\nTITLE: Setting Up Reatom Context for Svelte\nDESCRIPTION: Basic setup to initialize the Reatom context for a Svelte application.\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/src/content/docs/package/npm-svelte.md#2025-04-23_snippet_1\n\nLANGUAGE: ts\nCODE:\n```\nimport { setupCtx } from '@reatom/npm-svelte'\n\nsetupCtx()\n```\n\n----------------------------------------\n\nTITLE: Installing Reatom Core Package\nDESCRIPTION: Command to install the core Reatom package in an existing project.\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/src/content/docs/getting-started/setup.md#2025-04-23_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\nnpm i @reatom/core\n```\n\n----------------------------------------\n\nTITLE: Setting up Reatom Batching with React DOM\nDESCRIPTION: Configures batching updates for React DOM applications using unstable_batchedUpdates. Required for React versions 16 and 17 to optimize state updates.\nSOURCE: https://github.com/reatom/reatom/blob/v3/packages/react-v1/README.md#2025-04-23_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport { unstable_batchedUpdates } from 'react-dom'\nimport { setupBatch } from '@reatom/react-v1'\n\nsetupBatch(unstable_batchedUpdates)\n```\n\n----------------------------------------\n\nTITLE: Defining Reatom Model in TypeScript\nDESCRIPTION: Defines a Reatom model with atoms and an action in a separate TypeScript file for use in Svelte components.\nSOURCE: https://github.com/reatom/reatom/blob/v3/packages/npm-svelte/README.md#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\n// model.ts\nimport { atom, action } from '@reatom/core'\n\nexport const countAtom = atom(0, 'countAtom')\nexport const timesAtom = atom(\n  (ctx) => (ctx.spy(countAtom) === 1 ? 'time' : 'times'),\n  'timesAtom',\n)\nexport const increment = action(\n  (ctx) => countAtom(ctx, (s) => ++s),\n  'increment',\n)\n```\n\n----------------------------------------\n\nTITLE: Comparison of Abort Strategy in React vs Reatom\nDESCRIPTION: Compares the implementation of abort strategy for async processes in React and Reatom, demonstrating Reatom's simplified approach.\nSOURCE: https://github.com/reatom/reatom/blob/v3/packages/hooks/README.md#2025-04-23_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\nimport { reatomAsync, withAbort, withDataAtom } from '@reatom/async'\nimport { useAtom, useAction } from '@reatom/npm-react'\n\nexport const fetchList = reatomAsync(\n  (ctx) => request('api/list', ctx.controller),\n  'fetchList',\n).pipe(withAbort(), withDataAtom([]))\n\nexport const List = () => {\n  const [list] = useAtom(fetchList.dataAtom)\n  const handleFetch = useAction(fetchList)\n  const handleAbort = useAction(fetchList.abort)\n\n  useEffect(() => {\n    handleFetch()\n    return handleAbort\n  }, [])\n\n  return <ul>{list.map(() => '...')}</ul>\n}\n```\n\nLANGUAGE: tsx\nCODE:\n```\nimport { reatomAsync, onConnect, withDataAtom } from '@reatom/framework'\nimport { useAtom } from '@reatom/npm-react'\n\nexport const fetchList = reatomAsync(\n  (ctx) => request('api/list', ctx.controller),\n  'fetchList',\n).pipe(withDataAtom([]))\nonConnect(fetchList.dataAtom, fetchList)\n\nexport const List = () => {\n  const [list] = useAtom(fetchList.dataAtom)\n\n  return <ul>{list.map(() => '...')}</ul>\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Atom from Async Action with mapPayloadAwaited\nDESCRIPTION: Demonstrates how to create an atom from an async action using mapPayloadAwaited, which handles the fulfilled value of the action.\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/src/content/docs/package/lens.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { mapPayloadAwaited } from '@reatom/lens'\n\nexport const dataAtom = fetchList.pipe(\n  [],\n  mapPayloadAwaited((ctx, response) => response.data),\n  'dataAtom',\n)\n```\n\n----------------------------------------\n\nTITLE: Using useAction Hook with Payload Preparation\nDESCRIPTION: Example of using useAction hook with a custom function to prepare the payload before dispatching an action.\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/src/content/docs/compat/react-v2.md#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nconst handleUpdateData = useAction(\n  (value) => dataAtom.update({ id: props.id, value }),\n  [props.id],\n)\n```\n\n----------------------------------------\n\nTITLE: Using Devtools Logger\nDESCRIPTION: Example showing how to use the devtools logger to track function execution with payload data.\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/src/content/docs/package/devtools.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nfunction doSome(payload) {\n  DEVTOOLS?.log('doSome', payload)\n\n  // the rest of the code...\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Reatom ESLint Plugin\nDESCRIPTION: Command to install the @reatom/eslint-plugin as a development dependency in your project using npm.\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/src/content/docs/package/eslint-plugin.md#2025-04-23_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\nnpm i -D @reatom/eslint-plugin\n```\n\n----------------------------------------\n\nTITLE: Defining Atoms with Operators in TypeScript\nDESCRIPTION: Demonstrates atom creation using operators. This approach uses functions like reduce, sample, and handle to define the atom's behavior and interactions with actions.\nSOURCE: https://github.com/reatom/reatom/blob/v3/packages/core/history-v2.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nconst add = declareAction()\n\nconst counterAtom = declareAtom(\n  {\n    state: 0,\n    id: `counter`,\n    meta: { updates: 0 },\n    actions: {\n      add: (action: ActionCreator<[123]>) => reduce(action),\n    },\n  },\n  ($, state) => ($(shouldSyncCounterAtom) ? $(globalCounterAtom) : state),\n  reduce(add, (value, state) => state + value),\n  sample(add, ($, state) => state + $(someAtom)),\n  handle(add, (action, state) => ({\n    state,\n    effect: async (store) => {},\n  })),\n  change((oldState, newState) => newState),\n)\n```\n\n----------------------------------------\n\nTITLE: Setting Up Reatom Context with Logger for Development\nDESCRIPTION: Advanced setup that creates a Reatom context with logging enabled for development environments in a SvelteKit application.\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/src/content/docs/package/npm-svelte.md#2025-04-23_snippet_2\n\nLANGUAGE: ts\nCODE:\n```\nimport { createCtx, connectLogger } from '@reatom/framework'\nimport { setupCtx } from '@reatom/npm-svelte'\nimport { dev } from '$app/environment' // SvelteKit\n\nconst ctx = createCtx()\nif (dev) connectLogger(ctx)\nsetupCtx(ctx)\n```\n\n----------------------------------------\n\nTITLE: Testing Persist Storage Implementation\nDESCRIPTION: Example showing how to test persisted atoms using storage mocking\nSOURCE: https://github.com/reatom/reatom/blob/v3/packages/persist/README.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\n// feature.ts\nimport { atom } from '@reatom/framework'\nimport { withLocalStorage } from '@reatom/persist-web-storage'\n\nexport const tokenAtom = atom('', 'tokenAtom').pipe(withLocalStorage('token'))\n```\n\nLANGUAGE: typescript\nCODE:\n```\n// feature.test.ts\nimport { test } from 'vitest'\nimport { createTestCtx } from '@reatom/testing'\nimport { createMemStorage } from '@reatom/persist'\nimport { withLocalStorage } from '@reatom/persist-web-storage'\nimport { tokenAtom } from './feature'\n\ntest('token', () => {\n  const ctx = createTestCtx()\n  const mockStorage = createMemStorage({ token: '123' })\n  withLocalStorage.storageAtom(ctx, mockStorage)\n\n  expect(ctx.get(tokenAtom).toBe('123')\n})\n```\n\n----------------------------------------\n\nTITLE: Installing Reatom Form Package\nDESCRIPTION: Command to install the Reatom form package via npm\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/src/content/docs/package/form.md#2025-04-23_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\nnpm i @reatom/form\n```\n\n----------------------------------------\n\nTITLE: Values Type Definition in TypeScript\nDESCRIPTION: Shows the type definition for the Values utility type, which extracts the union type of all property values from an object type.\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/src/content/docs/package/utils.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nexport type Values<T> = T[keyof T]\n```\n\n----------------------------------------\n\nTITLE: Using Actions in Vue Components\nDESCRIPTION: Shows how to use Reatom actions within Vue components using useAction hook.\nSOURCE: https://github.com/reatom/reatom/blob/v3/packages/npm-vue/README.md#2025-04-23_snippet_3\n\nLANGUAGE: vue\nCODE:\n```\n<script>\nimport * as model from './model'\nimport { useAction } from '@reatom/npm-vue'\n\nconst doSomething = useAction(model.doSomething)\n</script>\n\n<template>\n  <BigBrightButton @click=\"doSomething\">Do it!</BigBrightButton>\n</template>\n```\n\n----------------------------------------\n\nTITLE: Retry Mechanism Implementation in TypeScript\nDESCRIPTION: Shows how to implement retry functionality for failed requests with configurable retry attempts and timing.\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/src/content/docs/package/async.md#2025-04-23_snippet_21\n\nLANGUAGE: typescript\nCODE:\n```\nimport { reatomAsync, withRetry } from '@reatom/async'\n\nexport const fetchList = reatomAsync(\n  (ctx) => request('api/list', ctx.controller),\n  'fetchList',\n).pipe(\n  withRetry({\n    onReject(ctx, error, retries) {\n      if (retries < 4) return 0\n    },\n  }),\n)\n```\n\n----------------------------------------\n\nTITLE: Final Reatom v3 Code Structure\nDESCRIPTION: Presents the final code structure using Reatom v3 API, showcasing a more concise and idiomatic usage of atoms and actions.\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/src/content/docs/compat/core-v1.md#2025-04-23_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nimport { combine, v3toV1 } from '@reatom/core-v1'\nimport { action, atom } from '@reatom/core'\n\nconst n1Atom = atom(0)\nconst n2Atom = atom(0)\nconst add = action((ctx, value) => {\n  n1Atom(ctx, (state) => state + value)\n  n2Atom(ctx, (state) => state + value)\n})\nconst sumAtom = atom((ctx) => ctx.spy(n1Atom) + ctx.spy(n2Atom))\nconst rootAtom = combine({ sumAtom: v3toV1(sumAtom) })\n```\n\n----------------------------------------\n\nTITLE: Incorrect onEvent Usage with Animation Example\nDESCRIPTION: Example showing a bug when using onEvent with animation where the animation might finish before content loads, causing the animation to freeze on the last frame.\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/src/content/docs/package/web.md#2025-04-23_snippet_2\n\nLANGUAGE: ts\nCODE:\n```\nimport { reatomAsync } from '@reatom/async'\nimport { onEvent } from '@reatom/web'\nimport { heroAnimation } from '~/feature/hero'\nimport { api } from '~/api'\n\nconst heroElement = document.getElementById('#hero')\n\nconst loadPageContent = reatomAsync(async (ctx) => {\n  // Docs: https://developer.mozilla.org/en-US/docs/Web/API/Element/animate\n  const animation = heroElement.animate(heroAnimation)\n\n  const content = await api.fetchContent()\n\n  //  Bug:\n  // If person's connection is not fast enough animation can finish before we load content.\n  // And we will be showing last frame of animation forever...\n  await onEvent(ctx, animation, 'finish')\n\n  pageContent(ctx, content)\n})\n```\n\n----------------------------------------\n\nTITLE: Installing @reatom/npm-history package using npm\nDESCRIPTION: This command installs the @reatom/npm-history package using npm. It's a prerequisite for using the Reatom history functionality in your project.\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/src/content/docs/package/npm-history.md#2025-04-23_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\nnpm i @reatom/npm-history\n```\n\n----------------------------------------\n\nTITLE: Version Control Entry - Reatom Testing Package\nDESCRIPTION: Markdown formatted changelog entries detailing version updates, bug fixes, and feature additions for the Reatom testing package from version 3.4.0 to 3.4.9.\nSOURCE: https://github.com/reatom/reatom/blob/v3/packages/testing/CHANGELOG.md#2025-04-23_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n# Changelog\n\n## [3.4.9](https://github.com/artalar/reatom/compare/testing-v3.4.8...testing-v3.4.9) (2025-03-14)\n\n### Bug Fixes\n\n* **testing:** restrictMultipleContexts ([7abb8db](https://github.com/artalar/reatom/commit/7abb8dbf470b57c2a7ffc4333add6fab9a0d193a))\n\n## [3.4.8](https://github.com/artalar/reatom/compare/testing-v3.4.7...testing-v3.4.8) (2024-12-30)\n\n### Bug Fixes\n\n- **testing:** prevent first computed reading of mocked atom [#995](https://github.com/artalar/reatom/issues/995) ([5231d20](https://github.com/artalar/reatom/commit/5231d20cbbbc2ffeefb52e574f9f281273e0e8e1))\n```\n\n----------------------------------------\n\nTITLE: Configuring Atom Name Prefixes and Suffixes\nDESCRIPTION: Configuration object for specifying prefix and suffix conventions for atom names.\nSOURCE: https://github.com/reatom/reatom/blob/v3/packages/eslint-plugin/README.md#2025-04-23_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\n({\n  atomPrefix: '',\n  atomPostfix: 'Atom',\n})\n```\n\n----------------------------------------\n\nTITLE: Comparing State Update Complexity in Redux vs Reatom\nDESCRIPTION: This code snippet compares the computational complexity of updating a user's name in a list between Redux and Reatom approaches. Redux requires O(n) operations for recreating arrays, while Reatom's atomization achieves O(1) complexity.\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/src/content/docs/recipes/atomization.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\n// redux way: O(n)\nexport const updateUserName = (state, idx, name) => {\n  const newList = [...state.users]\n  newList[idx] = { ...newList[idx], name }\n  return { ...state, list: newList }\n}\n\n// reatom way: O(1)\nexport const updateUserName = action((ctx, idx, name) => {\n  const nameAtom = ctx.get(listAtom)[idx].name\n  nameAtom(ctx, name)\n})\n```\n\n----------------------------------------\n\nTITLE: Simplified Periodic Refresh with Abort in Reatom\nDESCRIPTION: Shows a simplified version of periodic refresh implementation with automatic abort handling using the schedule feature.\nSOURCE: https://github.com/reatom/reatom/blob/v3/packages/async/README.md#2025-04-23_snippet_22\n\nLANGUAGE: typescript\nCODE:\n```\nimport { reatomAsync, withAbort, withDataAtom, withRetry, sleep } from '@reatom/framework'\n\nexport const fetchList = reatomAsync(\n  (ctx) => request('/api/list', ctx.controller),\n  'fetchList',\n).pipe(withAbort(), withDataAtom([]), withRetry())\nonConnect(fetchList.dataAtom, async (ctx) => {\n  while (true) {\n    await fetchList(ctx).catch(() => {})\n    await ctx.schedule(() => sleep(5000))\n  }\n})\n```\n\n----------------------------------------\n\nTITLE: Installing @reatom/undo package using npm\nDESCRIPTION: Command to install the @reatom/undo package using npm package manager.\nSOURCE: https://github.com/reatom/reatom/blob/v3/packages/undo/README.md#2025-04-23_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\nnpm i @reatom/undo\n```\n\n----------------------------------------\n\nTITLE: Installing @reatom/eslint-plugin via npm\nDESCRIPTION: Command to install the Reatom ESLint plugin as a development dependency using npm.\nSOURCE: https://github.com/reatom/reatom/blob/v3/packages/eslint-plugin/README.md#2025-04-23_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\nnpm i -D @reatom/eslint-plugin\n```\n\n----------------------------------------\n\nTITLE: Creating and Mutating a Mutable Atom in TypeScript\nDESCRIPTION: Demonstrates how to create a mutable atom with an initial value and name, and how to mutate it using both setter and reducer approaches.\nSOURCE: https://github.com/reatom/reatom/blob/v3/packages/core/README.md#2025-04-23_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\n// create\nconst countAtom = atom(0, 'countAtom')\n// countAtom: AtomMut<number>\n\n// mutate by setter\ncountAtom(ctx, 10)\n// updates and return 10\n\n// mutate by reducer\ncountAtom(ctx, (state) => state + 1)\n// updates and return 11\n```\n\n----------------------------------------\n\nTITLE: Persist Adapter Options Interface\nDESCRIPTION: TypeScript interface defining configuration options for persistence adapters including serialization, migration, and timing options\nSOURCE: https://github.com/reatom/reatom/blob/v3/packages/persist/README.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface WithPersistOptions<T> {\n  /**\n   * Key of the storage record.\n   */\n  key: string\n  /**\n   * Custom snapshot serializer.\n   */\n  toSnapshot?: Fn<[ctx: Ctx, state: T], unknown>\n  /**\n   * Custom snapshot deserializer.\n   */\n  fromSnapshot?: Fn<[ctx: Ctx, snapshot: unknown, state?: T], T>\n  /**\n   * A callback to call if the version of a stored snapshot is older than `version` option.\n   */\n  migration?: Fn<[ctx: Ctx, persistRecord: PersistRecord], T>\n  /**\n   * Determines whether the atom is updated on storage updates.\n   * @defaultValue true\n   */\n  subscribe?: boolean\n  /**\n   * Number of milliseconds from the snapshot creation time after which it will be deleted.\n   * @defaultValue MAX_SAFE_TIMEOUT\n   */\n  time?: number\n  /**\n   * Version of the stored snapshot. Triggers `migration`.\n   * @defaultValue 0\n   */\n  version?: number\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Reatom with Logger for Development\nDESCRIPTION: Sets up Reatom context with a logger for development environment, using SvelteKit's environment variable.\nSOURCE: https://github.com/reatom/reatom/blob/v3/packages/npm-svelte/README.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createCtx, connectLogger } from '@reatom/framework'\nimport { setupCtx } from '@reatom/npm-svelte'\nimport { dev } from '$app/environment' // SvelteKit\n\nconst ctx = createCtx()\nif (dev) connectLogger(ctx)\nsetupCtx(ctx)\n```\n\n----------------------------------------\n\nTITLE: Deduplicating Reatom Packages with NPM\nDESCRIPTION: Command to update and deduplicate Reatom framework packages using NPM's prefer-dedupe flag\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/src/content/docs/recipes/FAQ.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm i --prefer-dedupe @reatom/framework@latest\n```\n\n----------------------------------------\n\nTITLE: Installing @reatom/devtools via npm\nDESCRIPTION: Command to install the @reatom/devtools package using npm package manager. Note that this package is published with ESM bundle only.\nSOURCE: https://github.com/reatom/reatom/blob/v3/packages/devtools/README.md#2025-04-23_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\nnpm install @reatom/devtools\n```\n\n----------------------------------------\n\nTITLE: Lens Update Operators Documentation in Markdown\nDESCRIPTION: Documents the addition of new lens operators including combine, effect, withOnUpdate, toAction and introduces onDeepUpdate functionality for handling updates from the entire chain. Also includes renaming of onDeepUpdate to onLensUpdate and addition of delay operators.\nSOURCE: https://github.com/reatom/reatom/blob/v3/packages/lens/CHANGELOG.md#2025-04-23_snippet_1\n\nLANGUAGE: markdown\nCODE:\n```\n### Features\n\n- **lens:** make parseAtoms reactive\n- **lens:** map function for toAction\n\n### Bug Fixes\n\n- **lens:** add DelayOptions interface\n- **lens:** add LensEffect\n- **lens:** mapPayload 4 arg state\n- **lens:** use onUpdate\n\n### Features\n\n- **lens:** add new operators and onLensUpdate\n- **lens:** add general delay operator\n- **lens:** rename onDeepUpdate to onLensUpdate\n```\n\n----------------------------------------\n\nTITLE: Avoiding Context-Independent Closures in Reatom\nDESCRIPTION: Demonstrates a problematic pattern using external variables in atom definitions, which can lead to unexpected behavior across different contexts.\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/src/content/docs/getting-started/learning.md#2025-04-23_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createCtx, atom } from '@reatom/framework'\n\nconst ctx1 = createCtx()\nconst ctx2 = createCtx()\n\n// DON'T DO THIS\nlet someExternalVar = 1\nconst someAtom = atom(() => someExternalVar, 'someAtom')\n\n// check using ctx1\nconsole.log(ctx1.get(someAtom)) // logs: 1\n\nsomeExternalVar = 100\n\n// check using ctx1 and ctx2\nconsole.log(ctx1.get(someAtom), ctx2.get(someAtom)) // logs: 1, 100 because ctx1 cached 1 and ctx2 was only read when value changed\n```\n\n----------------------------------------\n\nTITLE: Deduplicating Reatom Packages with PNPM\nDESCRIPTION: Commands to remove and reinstall Reatom packages using PNPM for manual deduplication\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/src/content/docs/recipes/FAQ.md#2025-04-23_snippet_2\n\nLANGUAGE: sh\nCODE:\n```\npnpm rm @reatom/framework @reatom/web && pnpm i @reatom/framework@latest @reatom/web@latest\n```\n\n----------------------------------------\n\nTITLE: Installing Reatom Solid.js Package\nDESCRIPTION: Command to install the @reatom/npm-solid-js package via npm. Additionally requires @reatom/core or @reatom/framework and solid-js packages to be installed.\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/src/content/docs/package/npm-solid-js.md#2025-04-23_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\nnpm i @reatom/npm-solid-js\n```\n\n----------------------------------------\n\nTITLE: Installing Reatom React Bindings\nDESCRIPTION: Shell commands for installing the @reatom/react-v2 package using npm or yarn package managers.\nSOURCE: https://github.com/reatom/reatom/blob/v3/packages/react-v2/README.md#2025-04-23_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nnpm i @reatom/react-v2\n```\n\nLANGUAGE: shell\nCODE:\n```\nyarn add @reatom/react-v2\n```\n\n----------------------------------------\n\nTITLE: Private Atom Naming Convention\nDESCRIPTION: Example of prefixing an atom name with underscore to indicate it's private and should be hidden in Reatom inspector.\nSOURCE: https://github.com/reatom/reatom/blob/v3/packages/eslint-plugin/README.md#2025-04-23_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nconst secretState = atom(0, '_secretState')\n```\n\n----------------------------------------\n\nTITLE: Using useAtom Hook with Reatom in Solid.js\nDESCRIPTION: Example of using the useAtom hook from @reatom/npm-solid-js to create and manage state in a Solid.js component. Creates a count atom and uses it in a component with a button to increment the count.\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/src/content/docs/package/npm-solid-js.md#2025-04-23_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\nimport { atom } from '@reatom/framework'\nimport { useAtom } from '@reatom/npm-solid-js'\n\nconst countAtom = atom(0, 'countAtom')\n\nconst App: Component = () => {\n  const [count, setCount] = useAtom(countAtom)\n\n  return (\n    <div>\n      Count value is\n      <button onClick={() => setCount((c) => c + 1)}>{count()}</button>\n    </div>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Using shouldReplace Option with withUndo\nDESCRIPTION: Example demonstrating how to use the shouldReplace option to store only important updates by replacing the last state with the new one. This example shows how to save words instead of individual letters.\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/src/content/docs/package/undo.md#2025-04-23_snippet_2\n\nLANGUAGE: ts\nCODE:\n```\nconst inputAtom = atom('').pipe(\n  withUndo({ shouldReplace: (ctx, state) => !state.endsWith(' ') }),\n)\n\nfor (const letter of 'This is a test') {\n  inputAtom(ctx, (s) => s + letter)\n}\nctx.get(inputAtom) // 'This is a test'\nctx.get(inputAtom.historyAtom).length // 4\n\ninputAtom.undo(ctx)\nctx.get(inputAtom) // 'This is a'\n\ninputAtom.undo(ctx)\ninputAtom.undo(ctx)\nctx.get(inputAtom) // 'This'\n```\n\n----------------------------------------\n\nTITLE: Using useAction Hook - Basic Implementation\nDESCRIPTION: Basic example of using useAction hook to bind actions with dispatch.\nSOURCE: https://github.com/reatom/reatom/blob/v3/packages/react-v2/README.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nconst handleUpdateData = useAction(dataAtom.update)\n```\n\n----------------------------------------\n\nTITLE: Installing npm-cookie-baker with npm\nDESCRIPTION: Installation command for npm-cookie-baker and its core dependency using npm\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/src/content/docs/package/npm-cookie-baker.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm i @reatom/npm-cookie-baker @cookie-baker/core\n```\n\n----------------------------------------\n\nTITLE: Installing @reatom/npm-vue package\nDESCRIPTION: Shell command for installing the Reatom adapter for Vue using npm package manager.\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/src/content/docs/package/npm-vue.md#2025-04-23_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nnpm i @reatom/npm-vue\n```\n\n----------------------------------------\n\nTITLE: Installing Reatom Web Storage Package\nDESCRIPTION: NPM installation command for the @reatom/persist-web-storage package.\nSOURCE: https://github.com/reatom/reatom/blob/v3/packages/persist-web-storage/README.md#2025-04-23_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\nnpm i @reatom/persist-web-storage\n```\n\n----------------------------------------\n\nTITLE: Importing Batched Updates for React DOM\nDESCRIPTION: Import statement to set up batch bindings for React DOM, ensuring proper batched updates when using Reatom hooks.\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/src/content/docs/compat/react-v2.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport '@reatom/react-v2/react-dom-batched-updates'\n```\n\n----------------------------------------\n\nTITLE: Installing npm-cookie-baker with yarn\nDESCRIPTION: Installation command for npm-cookie-baker and its core dependency using yarn\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/src/content/docs/package/npm-cookie-baker.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nyarn add @reatom/npm-cookie-baker @cookie-baker/core\n```\n\n----------------------------------------\n\nTITLE: Installing Reatom Devtools Package\nDESCRIPTION: Command to install the Reatom devtools package via npm. Note that this package is published with ESM bundle only.\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/src/content/docs/package/devtools.md#2025-04-23_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nnpm install @reatom/devtools\n```\n\n----------------------------------------\n\nTITLE: Installing Reatom Persist Package\nDESCRIPTION: Command to install the @reatom/persist package via npm.\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/src/content/docs/package/persist.md#2025-04-23_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nnpm i @reatom/persist\n```\n\n----------------------------------------\n\nTITLE: Using useAtom Hook with Selector\nDESCRIPTION: Example of using useAtom hook with a selector to access a specific part of the atom state based on props.\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/src/content/docs/compat/react-v2.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nconst [propAtom] = useMemo(\n  () => createAtom({ dataAtom }, ({ get }) => get('dataAtom')[props.id]),\n  [props.id],\n)\nconst [propValue] = useAtom(propAtom)\n```\n\n----------------------------------------\n\nTITLE: Installing @reatom/persist-web-storage Package\nDESCRIPTION: Command to install the @reatom/persist-web-storage package via npm, which provides web storage adapters for Reatom atoms.\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/src/content/docs/package/persist-web-storage.md#2025-04-23_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nnpm i @reatom/persist-web-storage\n```\n\n----------------------------------------\n\nTITLE: Initial Reatom v1 Code Structure\nDESCRIPTION: Shows the initial code structure using Reatom core@1, including action declaration, atom creation, and atom combination.\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/src/content/docs/compat/core-v1.md#2025-04-23_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport { declareAction, declareAtom, map, combine } from '@reatom/core-v1'\n\nconst add = declareAction()\nconst n1Atom = declareAtom(0, (on) => [\n  on(add, (state, value) => state + value),\n])\nconst n2Atom = declareAtom(0, (on) => [\n  on(add, (state, value) => state + value),\n])\nconst sumAtom = map(combine([n1Atom, n2Atom]), ([n1, n2]) => n1 + n2)\nconst rootAtom = combine({ sumAtom })\n```\n\n----------------------------------------\n\nTITLE: Installing browser package with yarn\nDESCRIPTION: Installation command for cookie-baker browser package using yarn\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/src/content/docs/package/npm-cookie-baker.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nyarn add @cookie-baker/browser\n```\n\n----------------------------------------\n\nTITLE: Installing Reatom Vue Package\nDESCRIPTION: Command to install the Reatom Vue integration package via npm.\nSOURCE: https://github.com/reatom/reatom/blob/v3/packages/npm-vue/README.md#2025-04-23_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\nnpm i @reatom/npm-vue\n```\n\n----------------------------------------\n\nTITLE: Defining Atoms with Method Properties in TypeScript\nDESCRIPTION: Illustrates atom creation using method properties. This approach separates the atom configuration and methods into two objects, allowing for more flexibility in defining behavior.\nSOURCE: https://github.com/reatom/reatom/blob/v3/packages/core/history-v2.md#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nconst add = declareAction<number>()\n\nconst counterAtom = declareAtom(0, {\n  id: `counter`,\n  ctx: { updates: 0 },\n  change: (newState, state) => (store, ctx) =>\n    console.log(\n      `counterAtom receive new value: ${state}.`,\n      `It is ${++ctx.updates} update`,\n    ),\n}, {\n  inc: (inc: AC<void>) => ($, state) => {\n    $(inc, () => state++)\n    return state\n  },\n  computer: ($, state) => {\n    $(add, (value) => state += value))\n\n    if ($(shouldSyncCounterAtom)) {\n      $(globalCounterAtom, (globalCounter) => state = globalCounter)\n    }\n\n    return state\n  }\n})\n```\n\n----------------------------------------\n\nTITLE: Installing @reatom/web Package\nDESCRIPTION: NPM installation command for the @reatom/web package.\nSOURCE: https://github.com/reatom/reatom/blob/v3/packages/web/README.md#2025-04-23_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\nnpm i @reatom/web\n```\n\n----------------------------------------\n\nTITLE: Creating Reatom Context\nDESCRIPTION: Shows how to create a Reatom context for application-wide state management\nSOURCE: https://github.com/reatom/reatom/blob/v3/README.md#2025-04-23_snippet_2\n\nLANGUAGE: ts\nCODE:\n```\nimport { createCtx } from '@reatom/core'\n\nconst ctx = createCtx()\n```\n\n----------------------------------------\n\nTITLE: Installing browser package with npm\nDESCRIPTION: Installation command for cookie-baker browser package using npm\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/src/content/docs/package/npm-cookie-baker.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nnpm install @cookie-baker/browser\n```\n\n----------------------------------------\n\nTITLE: Installing Reatom Core Package\nDESCRIPTION: NPM installation command for the Reatom core package.\nSOURCE: https://github.com/reatom/reatom/blob/v3/packages/core/README.md#2025-04-23_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\nnpm i @reatom/core\n```\n\n----------------------------------------\n\nTITLE: Combined Naming Patterns for Atoms\nDESCRIPTION: Examples of combining object property naming and domain-based naming patterns for atoms.\nSOURCE: https://github.com/reatom/reatom/blob/v3/packages/eslint-plugin/README.md#2025-04-23_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\natom(0, `${name}.atomsRec.field`)\natom(0, 'Some.atomsRec.field')\n```\n\n----------------------------------------\n\nTITLE: Basic BroadcastChannel Implementation in Reatom\nDESCRIPTION: Example showing how to synchronize atom state between browser tabs using BroadcastChannel.\nSOURCE: https://github.com/reatom/reatom/blob/v3/packages/persist-web-storage/README.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { atom } from '@reatom/framework'\nimport { withBroadcastChannel } from '@reatom/persist-web-storage'\n\nexport const isAuthedAtom = atom('', 'isAuthedAtom').pipe(\n  withBroadcastChannel('isAuthedAtom'),\n)\n```\n\n----------------------------------------\n\nTITLE: Installing @reatom/web Package via npm\nDESCRIPTION: Command to install the @reatom/web package via npm package manager.\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/src/content/docs/package/web.md#2025-04-23_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\nnpm i @reatom/web\n```\n\n----------------------------------------\n\nTITLE: Basic ESLint Configuration with Recommended Reatom Rules\nDESCRIPTION: ESLint configuration example that extends the recommended Reatom ruleset by adding @reatom to plugins and using the recommended configuration.\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/src/content/docs/package/eslint-plugin.md#2025-04-23_snippet_1\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"plugins\": [\"@reatom\"],\n  \"extends\": [\"plugin:@reatom/recommended\"]\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Reatom React Package\nDESCRIPTION: Command to install the Reatom package for React integration.\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/src/content/docs/getting-started/setup.md#2025-04-23_snippet_2\n\nLANGUAGE: sh\nCODE:\n```\nnpm i @reatom/npm-react\n```\n\n----------------------------------------\n\nTITLE: Installing browser implementation with yarn\nDESCRIPTION: Command to install the browser-specific implementation of cookie-baker using yarn.\nSOURCE: https://github.com/reatom/reatom/blob/v3/packages/npm-cookie-baker/README.md#2025-04-23_snippet_2\n\nLANGUAGE: sh\nCODE:\n```\nyarn add @cookie-baker/browser\n```\n\n----------------------------------------\n\nTITLE: Running Reatom CJS Issue Reproduction Steps\nDESCRIPTION: A bash script that outlines the steps to reproduce the CJS-related issue in Reatom. It installs dependencies, builds the project, and starts the application.\nSOURCE: https://github.com/reatom/reatom/blob/v3/packages/cjs-import-check/README.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nyarn\nyarn build\nyarn start\n```\n\n----------------------------------------\n\nTITLE: Importing Reatom Testing Utilities\nDESCRIPTION: Basic import statement for the main testing utilities from @reatom/testing\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/src/content/docs/package/testing.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createTestCtx, mockFn } from '@reatom/testing'\n```\n\n----------------------------------------\n\nTITLE: Implementing a Delay Operator for Reatom in TypeScript\nDESCRIPTION: Custom operator implementation that adds a delay to atom updates. This example demonstrates proper handling of side effects using ctx.schedule and maintaining state between updates with proper naming for debugging.\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/src/content/docs/recipes/custom-operator.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { action, atom, Atom } from '@reatom/core'\n\n// operator accepts an options by a first argument\n// and returns function witch accepts target atom\nexport const delay =\n  <T>(ms: number) =>\n  (anAtom: Atom<T>) => {\n    // to improve debugability compute name of the new atom\n    const name = `${anAtom.__reatom.name}.delay`\n    // hide unnecessary meta by `_` prefix in name\n    const update = action<T>(`${name}._update`)\n    const updateTimeout = atom(-1, `${name}._updateTimeout`)\n\n    return atom((ctx, prevState?: T) => {\n      const state = ctx.spy(anAtom)\n      // more about action spying: https://www.reatom.dev/package/core#action-api\n      const updates = ctx.spy(update)\n\n      // first call, no need to delay\n      if (prevState === undefined) return state\n\n      // update from the schedule below\n      if (updates.length) return updates.at(-1)!.payload\n\n      // do not forget to schedule all side effects!\n      ctx.schedule(() => {\n        clearTimeout(ctx.get(updateTimeout))\n        const timeout = setTimeout(() => update(ctx, state), ms)\n        updateTimeout(ctx, timeout)\n      })\n\n      return prevState\n    }, name)\n  }\n```\n\n----------------------------------------\n\nTITLE: Installing @reatom/react-v2 package\nDESCRIPTION: Commands to install the @reatom/react-v2 package using npm or yarn. This package provides React bindings for Reatom state management.\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/src/content/docs/compat/react-v2.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm i @reatom/react-v2\n```\n\nLANGUAGE: bash\nCODE:\n```\nyarn add @reatom/react-v2\n```\n\n----------------------------------------\n\nTITLE: Opening Reatom atomization example in StackBlitz\nDESCRIPTION: A markdown link that allows users to open this example project directly in StackBlitz for interactive experimentation with the atomization pattern in Reatom.\nSOURCE: https://github.com/reatom/reatom/blob/v3/examples/react-table-atomization/README.md#2025-04-23_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n[Open in StackBlitz](https://stackblitz.com/github/artalar/reatom/tree/v3/examples/react-table-atomization)\n```\n\n----------------------------------------\n\nTITLE: Installing Reatom Testing Package\nDESCRIPTION: Command to install the @reatom/testing package which provides testing helpers for Reatom applications.\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/src/content/docs/getting-started/testing.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm i @reatom/testing\n```\n\n----------------------------------------\n\nTITLE: Installing @reatom/npm-cookie-baker using npm\nDESCRIPTION: Command to install the core package and its dependency using npm package manager.\nSOURCE: https://github.com/reatom/reatom/blob/v3/packages/npm-cookie-baker/README.md#2025-04-23_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\nnpm i @reatom/npm-cookie-baker @cookie-baker/core\n```\n\n----------------------------------------\n\nTITLE: Reatom Testing Interfaces Definition\nDESCRIPTION: TypeScript interface definitions for TestCtx and mockFn, defining the structure and types for the testing utilities\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/src/content/docs/package/testing.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface TestCtx extends Ctx {\n  mock<T>(anAtom: Atom<T>, fallback: T): Unsubscribe\n\n  mockAction<T>(anAction: Action<any[], T>, cb: Fn<[Ctx], T>): Unsubscribe\n\n  subscribeTrack<T, F extends Fn<[T]>>(\n    anAtom: Atom<T>,\n    cb?: F,\n  ): F & {\n    unsubscribe: Unsubscribe\n    calls: ReturnType<typeof mockFn<[T], any>>['calls']\n    lastInput: ReturnType<typeof mockFn<[T], any>>['lastInput']\n  }\n}\n\ndeclare function mockFn<I extends any[], O>(\n  fn?: (...input: I) => O,\n): ((...input: I) => O) & {\n  calls: Array<{ i: I; o: O }>\n  lastInput: Fn<[], I[0]>\n}\n```\n\n----------------------------------------\n\nTITLE: Debouncing Action Updates with debounce\nDESCRIPTION: Shows how to use the debounce operator to delay updates from an action by a specified timeout.\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/src/content/docs/package/lens.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { action } from '@reatom/core'\nimport { debounce, mapPayload } from '@reatom/lens'\n\nexport const startAnimation = action()\nexport const endAnimation = startAnimation.pipe(debounce(250))\n```\n\n----------------------------------------\n\nTITLE: Installing Reatom Svelte Adapter Package\nDESCRIPTION: Command to install the @reatom/npm-svelte package through npm.\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/src/content/docs/package/npm-svelte.md#2025-04-23_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\nnpm i @reatom/npm-svelte\n```\n\n----------------------------------------\n\nTITLE: Installing @reatom/url Package\nDESCRIPTION: Command to install the @reatom/url package using npm.\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/src/content/docs/package/url.md#2025-04-23_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\nnpm i @reatom/url\n```\n\n----------------------------------------\n\nTITLE: Installing Reatom Testing Package\nDESCRIPTION: Command to install the @reatom/testing package via npm\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/src/content/docs/package/testing.md#2025-04-23_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\nnpm i @reatom/testing\n```\n\n----------------------------------------\n\nTITLE: Referencing Reatom JSX Package in Markdown\nDESCRIPTION: A simple inline code reference to the @reatom/jsx package that is the focus of this example project.\nSOURCE: https://github.com/reatom/reatom/blob/v3/examples/reatom-jsx/README.md#2025-04-23_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n`@reatom/jsx`\n```\n\n----------------------------------------\n\nTITLE: Installing @reatom/undo Package\nDESCRIPTION: Command to install the @reatom/undo package using npm package manager.\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/src/content/docs/package/undo.md#2025-04-23_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\nnpm i @reatom/undo\n```\n\n----------------------------------------\n\nTITLE: Installing @reatom/web-fetch via npm\nDESCRIPTION: Command to install the @reatom/web-fetch package using npm.\nSOURCE: https://github.com/reatom/reatom/blob/v3/packages/web-fetch/README.md#2025-04-23_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\nnpm i @reatom/web-fetch\n```\n\n----------------------------------------\n\nTITLE: Installing @reatom/npm-zod Package via npm\nDESCRIPTION: Command to install the @reatom/npm-zod package using npm package manager. This is required before you can use the utility in your project.\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/src/content/docs/package/npm-zod.md#2025-04-23_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nnpm i @reatom/npm-zod\n```\n\n----------------------------------------\n\nTITLE: Installing @reatom/npm-history Package\nDESCRIPTION: Command to install the @reatom/npm-history package using npm.\nSOURCE: https://github.com/reatom/reatom/blob/v3/packages/npm-history/README.md#2025-04-23_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\nnpm i @reatom/npm-history\n```\n\n----------------------------------------\n\nTITLE: Displaying Astro Project Directory Structure\nDESCRIPTION: This snippet illustrates the standard directory structure of an Astro project, including public assets, source files with components, layouts, and pages, and the package.json configuration file.\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/README.md#2025-04-23_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\n/\n public/\n    favicon.svg\n src/\n    components/\n       Card.astro\n    layouts/\n       Layout.astro\n    pages/\n        index.astro\n package.json\n```\n\n----------------------------------------\n\nTITLE: Transforming Action Payload with mapPayload\nDESCRIPTION: Illustrates the use of mapPayload to transform the payload of an action, creating a new derived action.\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/src/content/docs/package/lens.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { mapPayload } from '@reatom/lens'\n\nexport const changeFullname = changeName.pipe(\n  mapPayload((ctx, { firstName, lastName }) => `${firstName} ${lastName}`),\n)\n```\n\n----------------------------------------\n\nTITLE: Installing Reatom Framework\nDESCRIPTION: NPM installation command for the Reatom framework and React integration packages\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/src/content/docs/index.md#2025-04-23_snippet_4\n\nLANGUAGE: sh\nCODE:\n```\nnpm i @reatom/framework @reatom/npm-react\n```\n\n----------------------------------------\n\nTITLE: Installing Reatom Package via NPM\nDESCRIPTION: Command to install a Reatom package module using npm package manager.\nSOURCE: https://github.com/reatom/reatom/blob/v3/tools/new-package-template/README.md#2025-04-23_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\nnpm install @reatom/{{name}}\n```\n\n----------------------------------------\n\nTITLE: Installing @reatom/npm-cookie-baker using yarn\nDESCRIPTION: Command to install the core package and its dependency using yarn package manager.\nSOURCE: https://github.com/reatom/reatom/blob/v3/packages/npm-cookie-baker/README.md#2025-04-23_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\nyarn add @reatom/npm-cookie-baker @cookie-baker/core\n```\n\n----------------------------------------\n\nTITLE: Markdown Changelog\nDESCRIPTION: Markdown formatted changelog showing version history and changes for the Reatom lens package from version 3.5.0 to 3.11.8.\nSOURCE: https://github.com/reatom/reatom/blob/v3/packages/lens/CHANGELOG.md#2025-04-23_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n# Changelog\n\n## [3.11.8] (2025-04-02)\n### Bug Fixes\n* **lens:** parseAtoms types\n\n## [3.11.7] (2025-03-14) \n### Bug Fixes\n* **lens:** migrate to vitest, fix parseAtom type\n\n[Additional version history truncated for brevity...]\n```\n\n----------------------------------------\n\nTITLE: Using withReducers Operator in TypeScript (Deprecated)\nDESCRIPTION: Demonstrates the usage of the deprecated withReducers operator, which adds reducer actions to an atom. It is recommended to use withAssign instead.\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/src/content/docs/package/primitives.md#2025-04-23_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\nimport { atom } from '@reatom/core'\nimport { withReducers } from '@reatom/primitives'\n\nconst pageAtom = atom(1).pipe(\n  withReducers({\n    next: (state) => state + 1,\n    prev: (state) => Math.max(1, state - 1),\n  }),\n)\n\n// `prev` and `next` actions are added automatically\npageAtom.next(ctx) // => 2\npageAtom.prev(ctx) // => 1\n```\n\n----------------------------------------\n\nTITLE: Installing @reatom/framework Package\nDESCRIPTION: Command to install the @reatom/framework package, which is an umbrella package for the most common Reatom packages.\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/src/content/docs/getting-started/learning.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm install --save @reatom/framework\n```\n\n----------------------------------------\n\nTITLE: Importing Reatom Package in TypeScript\nDESCRIPTION: Basic TypeScript import statement pattern for using Reatom package modules.\nSOURCE: https://github.com/reatom/reatom/blob/v3/tools/new-package-template/README.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport {} from '@reatom/{{name}}'\n\n// ...\n```\n\n----------------------------------------\n\nTITLE: Installing Dependencies for Reatom Packages in Shell\nDESCRIPTION: This command installs dependencies for all packages in the Reatom project, but only builds packages included in @reatom/framework, such as core, utils, async, etc. It requires Node.js 18 and npm 8.\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/src/content/docs/contributing.md#2025-04-23_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\nnpm install\n```\n\n----------------------------------------\n\nTITLE: Importing Reatom Testing Utilities\nDESCRIPTION: Basic import statement for core testing utilities including createTestCtx and mockFn.\nSOURCE: https://github.com/reatom/reatom/blob/v3/packages/testing/README.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createTestCtx, mockFn } from '@reatom/testing'\n```\n\n----------------------------------------\n\nTITLE: Creating Vue Plugin with Reatom Context\nDESCRIPTION: Creates a Vue app plugin using createReatomVue function and a Reatom context.\nSOURCE: https://github.com/reatom/reatom/blob/v3/packages/npm-vue/README.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createCtx } from '@reatom/core'\nimport { createReatomVue } from '@reatom/npm-vue'\n\nconst ctx = createCtx()\napp.use(createReatomVue(ctx))\n```\n\n----------------------------------------\n\nTITLE: Installing Reatom Svelte Package\nDESCRIPTION: Command to install the Reatom Svelte package using npm.\nSOURCE: https://github.com/reatom/reatom/blob/v3/packages/npm-svelte/README.md#2025-04-23_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\nnpm i @reatom/npm-svelte\n```\n\n----------------------------------------\n\nTITLE: Building a Specific Reatom Package in Shell\nDESCRIPTION: This command builds a specific package in the Reatom project using Turbo. Replace <PACKAGE_NAME> with the relevant package name like persist or npm-react.\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/src/content/docs/contributing.md#2025-04-23_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\nnpx turbo run build --filter=<PACKAGE_NAME>\n```\n\n----------------------------------------\n\nTITLE: Request Abort Management in Reatom\nDESCRIPTION: Demonstrates how to handle request abortion with connection lifecycle management. Includes cleanup on disconnection and automatic request cancellation.\nSOURCE: https://github.com/reatom/reatom/blob/v3/packages/async/README.md#2025-04-23_snippet_23\n\nLANGUAGE: typescript\nCODE:\n```\nimport { reatomAsync, withDataAtom, withAbort } from '@reatom/async'\nimport { onConnect } from '@reatom/hooks'\n\nexport const fetchList = reatomAsync(\n  (ctx, page = 1) => request(`api/list?page=${page}`, ctx.controller),\n  'fetchList',\n).pipe(withDataAtom([]), withAbort())\n\nonConnect(fetchList.dataAtom, (ctx) => {\n  fetchList(ctx)\n  // abort unneeded request\n  return () => fetchList.abort(ctx)\n})\n```\n\n----------------------------------------\n\nTITLE: Environment Variable Configuration for GitHub API Token\nDESCRIPTION: Example showing how to set up the GitHub API token in a .env file for making API calls. The token needs to be generated from GitHub developer settings without any special permissions.\nSOURCE: https://github.com/reatom/reatom/blob/v3/examples/tanstack-vs-reatom/README.md#2025-04-23_snippet_0\n\nLANGUAGE: env\nCODE:\n```\nVITE_GITHUB_TOKEN=BHJyG87G_8yg8yVb8YVB9Ubvu1ghvb\n```\n\n----------------------------------------\n\nTITLE: Deduplicating Reatom Packages with Yarn\nDESCRIPTION: Command to update Reatom framework and deduplicate all Reatom packages using Yarn 3/4\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/src/content/docs/recipes/FAQ.md#2025-04-23_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\nyarn add @reatom/framework@latest && yarn dedupe \"@reatom/*\"\n```\n\n----------------------------------------\n\nTITLE: Declaring withStateHistory Operator for Reatom in TypeScript\nDESCRIPTION: Type declaration for a withStateHistory operator that adds state history tracking to an atom. Uses the 'with' prefix convention for operators that mutate the passed atom rather than creating a new one.\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/src/content/docs/recipes/custom-operator.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Atom, AtomState } from '@reatom/core'\n\ndeclare function withStateHistory<T extends Atom>(\n  length: string,\n): (anAtom: T) => T & {\n  stateHistoryAtom: Atom<AtomState<T>>\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Reatom Testing Package\nDESCRIPTION: NPM installation command for the @reatom/testing package.\nSOURCE: https://github.com/reatom/reatom/blob/v3/packages/testing/README.md#2025-04-23_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\nnpm i @reatom/testing\n```\n\n----------------------------------------\n\nTITLE: Reatom Atoms and Actions in Separate Module\nDESCRIPTION: Shows how to define Reatom atoms and actions in a separate module and use them in a Svelte component.\nSOURCE: https://github.com/reatom/reatom/blob/v3/packages/npm-svelte/README.md#2025-04-23_snippet_4\n\nLANGUAGE: svelte\nCODE:\n```\n<script>\n\timport { withSvelte } from '@reatom/npm-svelte'\n  import { countAtom, timesAtom, increment } from './model'\n\n\tconst count = withSvelte(countAtom)\n\tconst times = withSvelte(timesAtom)\n\tconst handleIncrement = withSvelte(increment).set\n</script>\n\n<button on:click={handleIncrement}>\n\tClicked {$count} {$times}\n</button>\n```\n\n----------------------------------------\n\nTITLE: Creating a New Reatom Package in Shell\nDESCRIPTION: This command runs an interactive script to create a new package in the Reatom ecosystem. It should be executed in the repository root.\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/src/content/docs/contributing.md#2025-04-23_snippet_2\n\nLANGUAGE: sh\nCODE:\n```\nnpm run package-generator\n```\n\n----------------------------------------\n\nTITLE: Creating and Providing Reatom Store in React App\nDESCRIPTION: Example of creating a Reatom store and providing it to the React component tree using reatomContext.Provider.\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/src/content/docs/compat/react-v2.md#2025-04-23_snippet_7\n\nLANGUAGE: jsx\nCODE:\n```\nimport React from 'react'\nimport { createStore } from '@reatom/core-v2'\nimport { reatomContext } from '@reatom/react-v2'\nimport { Form } from './components/Form'\n\nimport './App.css'\n\nexport const App = () => {\n  // create statefull reatomContext for atoms execution\n  const store = createStore()\n\n  return (\n    <div className=\"App\">\n      <reatomContext.Provider value={store}>\n        <Form />\n      </reatomContext.Provider>\n    </div>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Reatom Form Web Library\nDESCRIPTION: Command to install the @reatom/form-web package using npm. This is the first step to incorporate Reatom form handling into your web application.\nSOURCE: https://github.com/reatom/reatom/blob/v3/packages/form-web/README.md#2025-04-23_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\nnpm i @reatom/form-web\n```\n\n----------------------------------------\n\nTITLE: Implementing shouldReplace option for withUndo in TypeScript\nDESCRIPTION: Example of using the shouldReplace option with withUndo to control how updates are stored in the history.\nSOURCE: https://github.com/reatom/reatom/blob/v3/packages/undo/README.md#2025-04-23_snippet_2\n\nLANGUAGE: ts\nCODE:\n```\nconst inputAtom = atom('').pipe(\n  withUndo({ shouldReplace: (ctx, state) => !state.endsWith(' ') }),\n)\n\nfor (const letter of 'This is a test') {\n  inputAtom(ctx, (s) => s + letter)\n}\nctx.get(inputAtom) // 'This is a test'\nctx.get(inputAtom.historyAtom).length // 4\n\ninputAtom.undo(ctx)\nctx.get(inputAtom) // 'This is a'\n\ninputAtom.undo(ctx)\ninputAtom.undo(ctx)\nctx.get(inputAtom) // 'This'\n```\n\n----------------------------------------\n\nTITLE: Combining Retry, Abort, and Error Handling in Reatom\nDESCRIPTION: This example shows how to combine retry logic with abort handling and error management in Reatom. It limits retries to 7 attempts and includes a custom loading atom.\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/src/content/docs/package/async.md#2025-04-23_snippet_23\n\nLANGUAGE: typescript\nCODE:\n```\nimport {\n  atom,\n  reatomAsync,\n  withAbort,\n  withErrorAtom,\n  withRetry,\n} from '@reatom/async'\n\nexport const fetchList = reatomAsync(\n  (ctx) => request('api/list', ctx.controller),\n  'fetchList',\n).pipe(\n  withAbort(),\n  withRetry({\n    onReject: (ctx, error, retries) => {\n      // try to retry the request only 7 times\n      if (retries < 7) {\n        return 100 * Math.min(200, retries ** 3)\n      }\n      // otherwise do nothing - prevent retrying and show the error\n    },\n  }),\n  withErrorAtom(),\n)\nexport const isFetchListLoading = atom(\n  (ctx) =>\n    ctx.spy(fetchList.pendingAtom) > 0 || ctx.spy(fetchList.retriesAtom) > 0,\n  'isFetchListLoading',\n)\n```\n\n----------------------------------------\n\nTITLE: Implementing Reactive Data Model with Reatom and Zod\nDESCRIPTION: Example showing how to create a reactive user data model using Reatom and Zod, including local storage synchronization. The code defines a User schema with required and optional fields, and creates a model that automatically syncs with localStorage.\nSOURCE: https://github.com/reatom/reatom/blob/v3/packages/npm-zod/README.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { parseAtoms } from '@reatom/framework'\nimport { reatomZod } from '@reatom/npm-zod'\nimport * as z from 'zod'\n\nexport const User = z.object({\n  id: z.string().readonly(),\n  email: z.string().readonly(),\n  name: z.string(),\n  age: z.number().optional(),\n})\n\nconst KEY = 'user-data'\nexport const model = reatomZod(User, {\n  sync(ctx) {\n    localStorage.setItem(KEY, JSON.stringify(parseAtoms(ctx, model)))\n  },\n  initState: JSON.parse(localStorage.getItem(KEY) || '{}')\n})\n```\n\n----------------------------------------\n\nTITLE: Optimistic Cache Updates in TypeScript\nDESCRIPTION: Shows how to implement optimistic updates using precise cache management methods setWithParams and deleteWithParams.\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/src/content/docs/package/async.md#2025-04-23_snippet_18\n\nLANGUAGE: typescript\nCODE:\n```\nimport { reatomAsync, withCache, withDataAtom } from '@reatom/async'\n\nexport const fetchElement = reatomAsync(async (ctx, id, search) => {\n  return await request(`api/list/${id}?search=${search}`, ctx.controller)\n}, 'fetchElement').pipe(withCache(), withDataAtom())\n\nexport const updateElement = reatomAction(async (ctx, id, data) => {\n  fetchElement.cacheAtom.setWithParams(ctx, [id, ''], data)\n  // call api for update...\n}, 'updateElement')\n```\n\n----------------------------------------\n\nTITLE: Initializing Basic Atoms for Page and Search in Reatom\nDESCRIPTION: Creates two atoms to manage pagination and search state for fetching list data. These atoms will be used as dependencies for an asynchronous resource.\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/src/content/docs/package/async.md#2025-04-23_snippet_28\n\nLANGUAGE: typescript\nCODE:\n```\nexport const pageAtom = atom(1, 'pageAtom')\nexport const searchAtom = atom('', 'searchAtom')\n```\n\n----------------------------------------\n\nTITLE: Logging state changes with devtools\nDESCRIPTION: Example of logging state changes using the DEVTOOLS.state method. This will only log when the state changes, making it useful for monitoring state updates in React components.\nSOURCE: https://github.com/reatom/reatom/blob/v3/packages/devtools/README.md#2025-04-23_snippet_3\n\nLANGUAGE: ts\nCODE:\n```\nconst [state, setState] = useState()\nDEVTOOLS?.state('my-state', state)\n```\n\n----------------------------------------\n\nTITLE: Changelog Entry Format\nDESCRIPTION: Standard format for changelog entries showing version numbers, comparison links, and categorized changes\nSOURCE: https://github.com/reatom/reatom/blob/v3/packages/eslint-plugin/CHANGELOG.md#2025-04-23_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n## [3.8.0](https://github.com/artalar/reatom/compare/eslint-plugin-v3.7.1...eslint-plugin-v3.8.0) (2025-02-05)\n\n### Features\n\n- **eslint-plugin:** schedule-import-rule ([#930](https://github.com/artalar/reatom/issues/930)) ([89d63d0](https://github.com/artalar/reatom/commit/89d63d06dd4018ef6aeed8db6daf6928f3ffd24a))\n\n### Bug Fixes\n\n- **eslint-plugin:** false-negative for `name` as prop and invalid derivation for objects inside a named factory ([#1021](https://github.com/artalar/reatom/issues/1021)) ([6b15f13](https://github.com/artalar/reatom/commit/6b15f131682d88373e6a0f9f1bb75af60a989d8a))\n```\n\n----------------------------------------\n\nTITLE: Installing node package with yarn\nDESCRIPTION: Installation command for cookie-baker node package using yarn\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/src/content/docs/package/npm-cookie-baker.md#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nyarn add @cookie-baker/node\n```\n\n----------------------------------------\n\nTITLE: Installing node package with npm\nDESCRIPTION: Installation command for cookie-baker node package using npm\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/src/content/docs/package/npm-cookie-baker.md#2025-04-23_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nnpm install @cookie-baker/node\n```\n\n----------------------------------------\n\nTITLE: Creating Reatom Units in Factory Functions with Domain Naming\nDESCRIPTION: Example of creating Reatom atoms within a factory function using domain-based naming, following the convention for reatomX factory functions.\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/src/content/docs/package/eslint-plugin.md#2025-04-23_snippet_6\n\nLANGUAGE: ts\nCODE:\n```\nconst reatomFood = (config: {\n  name: string\n  calories: number\n  fat: number\n  carbs: number\n  protein: number\n}) => {\n  const { name } = config\n  const calories = atom(config.calories, `Food.calories`)\n  const fat = atom(config.fat, `Food.fat`)\n  const carbs = atom(config.carbs, `Food.carbs`)\n  const protein = atom(config.protein, `Food.protein`)\n  return { calories, fat, carbs, protein }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining HistoryAtom interface and historyAtom in TypeScript\nDESCRIPTION: This code defines the HistoryAtom interface which extends AtomMut<History> and includes various methods for managing history. It also exports the historyAtom constant of type HistoryAtom.\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/src/content/docs/package/npm-history.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { History, Location, To, Blocker } from 'history'\n\nexport interface HistoryAtom extends AtomMut<History> {\n  back: Action<[]>\n  block: Action<[blocker: Blocker], () => void>\n  forward: Action<[]>\n  go: Action<[delta: number]>\n  location: Atom<Location>\n  push: Action<[to: To, state?: any]>\n  replace: Action<[to: To, state?: any]>\n}\n\nexport const historyAtom: HistoryAtom\n```\n\n----------------------------------------\n\nTITLE: Installing Node.js implementation with npm\nDESCRIPTION: Command to install the Node.js-specific implementation of cookie-baker using npm.\nSOURCE: https://github.com/reatom/reatom/blob/v3/packages/npm-cookie-baker/README.md#2025-04-23_snippet_5\n\nLANGUAGE: sh\nCODE:\n```\nnpm install @cookie-baker/node\n```\n\n----------------------------------------\n\nTITLE: Using Atomized User Model in React Components\nDESCRIPTION: This snippet shows how to use the atomized user model in a React component. It demonstrates accessing the atomized name property and handling user interactions with the useAtom and useAction hooks.\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/src/content/docs/recipes/atomization.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n// ~/features/user/index.tsx\nimport { useAction, useAtom } from '@reatom/npm-react'\n\n// user component\nconst [name] = useAtom((ctx) => ctx.spy(ctx.get(userAtom).name))\n\nconst handleChange = useAction((ctx, e: React.ChangeEvent<HTMLInputElement>) =>\n  ctx.get(userAtom).name(ctx, e.currentTarget.name),\n)\n\nconst handleSubmit = useAction(syncUserName)\n```\n\n----------------------------------------\n\nTITLE: Creating Private Reatom Units with Underscore Prefix\nDESCRIPTION: Example showing how to name private Reatom atoms using an underscore prefix, which signals they're not exposed from their factory.\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/src/content/docs/package/eslint-plugin.md#2025-04-23_snippet_9\n\nLANGUAGE: ts\nCODE:\n```\nconst secretState = atom(0, '_secretState')\n```\n\n----------------------------------------\n\nTITLE: Implementing Reaction Effects with Reatom\nDESCRIPTION: Demonstrates using the reaction API to create side effects with computed functions in a React component context.\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/src/content/docs/package/effects.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { atom, reaction } from '@reatom/framework'\nimport { reatomComponent } from '@reatom/npm-react'\n\nconst reatomFilters = () => {\n  const searchAtom = atom('', 'Filters.searchAtom')\n  const tagsAtom = atom(0, 'Filters.tagsAtom')\n  const pageAtom = atom(0, 'Filters.pageAtom')\n  const changeReaction = reaction(async (ctx, onChange) => {\n    const search = ctx.spy(searchAtom)\n    const tags = ctx.spy(tagsAtom)\n    const page = ctx.spy(pageAtom)\n    onChange({ search, tags, page })\n  }, 'Filters.changeReaction')\n\n  return { searchAtom, tagsAtom, pageAtom, changeReaction }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Atoms with Option Tuples in TypeScript\nDESCRIPTION: Illustrates atom creation using option tuples. This approach uses arrays to define various aspects of the atom, including ID, metadata, action handlers, and computations.\nSOURCE: https://github.com/reatom/reatom/blob/v3/packages/core/history-v2.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst add = declareAction<number>()\n\nconst counterAtom = declareAtom(\n  0,\n  [`id`, `counter`],\n  [`meta`, { updates: 0 }],\n  [add, (value, state) => state + value],\n  [`inc`, (value: void, state) => state + 1],\n  ($, state) => ($(shouldSyncCounterAtom) ? $(globalCounterAtom) : state),\n  [\n    `*`,\n    (state) => (store, meta) =>\n      console.log(\n        `counterAtom receive new value: ${state}.`,\n        `It is ${++meta.updates} update`,\n      ),\n  ],\n)\n```\n\n----------------------------------------\n\nTITLE: Creating New Reatom Project with degit\nDESCRIPTION: Commands to create a new project using a template with Vite, TypeScript, React, and Reatom ecosystem using degit.\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/src/content/docs/getting-started/setup.md#2025-04-23_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\nnpx degit github:artalar/reatom-react-ts PROJECT-NAME\ncd PROJECT-NAME\n\nnpm install\nnpm run dev\n```\n\n----------------------------------------\n\nTITLE: Values Type Definition in TypeScript\nDESCRIPTION: Type utility that extracts the union type of all values in an object type T.\nSOURCE: https://github.com/reatom/reatom/blob/v3/packages/utils/README.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nexport type Values<T> = T[keyof T]\n```\n\n----------------------------------------\n\nTITLE: Initializing a Timer with Reatom\nDESCRIPTION: Creates a timer atom with configurable options like interval, delay multiplier, and progress precision. The example shows default configurations and how to create a pomodoro timer instance.\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/src/content/docs/package/timer.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { reatomTimer } from '@reatom/timer'\n\n// all options are not required, here are the defaults\nconst pomodoroAtom = reatomTimer({\n  name: 'pomodoroAtom',\n  interval: 1000, // `1000`ms - tick each second. Than lower, then more precise\n  delayMultiplier: 1000, // `1000`ms allow to pass seconds to startTimer. Use `1` to pass ms\n  progressPrecision: 2, // progress will be rounded to 2 digits after dot\n  resetProgress: true, // progress will be reset to 0 on end of timer\n})\n```\n\n----------------------------------------\n\nTITLE: Handling Multiple Actions with Loading State\nDESCRIPTION: This snippet shows how to handle multiple actions, including loading state, without proper batching, leading to multiple unnecessary updates.\nSOURCE: https://github.com/reatom/reatom/blob/v3/packages/core/README.md#2025-04-23_snippet_21\n\nLANGUAGE: typescript\nCODE:\n```\nimport { action, atom, batch } from '@reatom/core'\n\nexport const isUserLoadingAtom = atom(false, 'isUserLoadingAtom')\nexport const firstNameAtom = atom('', 'firstNameAtom')\nexport const lastNameAtom = atom('', 'lastNameAtom')\nexport const fullNameAtom = atom(\n  (ctx) => `${ctx.spy(firstNameAtom)} ${ctx.spy(lastNameAtom)}`,\n  'fullNameAtom',\n)\nexport const saveUser = action((ctx, firstName: string, lastName: string) => {\n  firstNameAtom(ctx, firstName)\n  lastNameAtom(ctx, lastName)\n}, 'saveUser')\nexport const fetchUser = action(async (ctx, id: string) => {\n  isUserLoadingAtom(ctx, true)\n  try {\n    const user = await ctx.schedule(() => api.getUser(id))\n    saveUser(ctx, user.firstName, user.lastName)\n    isUserLoadingAtom(ctx, false)\n  } catch {\n    isUserLoadingAtom(ctx, false)\n  }\n}, 'fetchUser')\n```\n\n----------------------------------------\n\nTITLE: Installing Reatom Logger Package with npm\nDESCRIPTION: Command to install the @reatom/logger package using npm. This package provides debugging capabilities for Reatom applications.\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/src/content/docs/getting-started/debugging.md#2025-04-23_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\nnpm i @reatom/logger\n```\n\n----------------------------------------\n\nTITLE: Setting up Reatom Batching with React Native\nDESCRIPTION: Configures batching updates for React Native applications using unstable_batchedUpdates. Required for React Native to optimize state updates.\nSOURCE: https://github.com/reatom/reatom/blob/v3/packages/react-v1/README.md#2025-04-23_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { unstable_batchedUpdates } from 'react-native'\nimport { setupBatch } from '@reatom/react-v1'\n\nsetupBatch(unstable_batchedUpdates)\n```\n\n----------------------------------------\n\nTITLE: Configuring Batching for React-Native with Reatom\nDESCRIPTION: This snippet shows how to set up batching for Reatom with React-Native in React versions 16 and 17. It imports the required functions and configures batching to optimize updates in a React Native environment.\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/src/content/docs/compat/react-v1.md#2025-04-23_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { unstable_batchedUpdates } from 'react-native'\nimport { setupBatch } from '@reatom/react-v1'\n\nsetupBatch(unstable_batchedUpdates)\n```\n\n----------------------------------------\n\nTITLE: Animation Event Handler with Bug\nDESCRIPTION: Example showing incorrect implementation of animation event handling that could lead to UI issues when network is slow.\nSOURCE: https://github.com/reatom/reatom/blob/v3/packages/web/README.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { reatomAsync } from '@reatom/async'\nimport { onEvent } from '@reatom/web'\nimport { heroAnimation } from '~/feature/hero'\nimport { api } from '~/api'\n\nconst heroElement = document.getElementById('#hero')\n\nconst loadPageContent = reatomAsync(async (ctx) => {\n  // Docs: https://developer.mozilla.org/en-US/docs/Web/API/Element/animate\n  const animation = heroElement.animate(heroAnimation)\n\n  const content = await api.fetchContent()\n\n  //  Bug:\n  // If person's connection is not fast enough animation can finish before we load content.\n  // And we will be showing last frame of animation forever...\n  await onEvent(ctx, animation, 'finish')\n\n  pageContent(ctx, content)\n})\n```\n\n----------------------------------------\n\nTITLE: Installing and Running Reatom ESM Issue Reproduction\nDESCRIPTION: Commands to install dependencies, build the project, and start the reproduction test case. These commands will set up and execute the environment needed to demonstrate the ESM import issues with Reatom.\nSOURCE: https://github.com/reatom/reatom/blob/v3/packages/esm-import-check/README.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nyarn\nyarn build\nyarn start\n```\n\n----------------------------------------\n\nTITLE: Version 3.6.0 Changelog Entry\nDESCRIPTION: Documents feature additions including new Vue hooks and implementation of Vue integration, along with ESM module export fixes.\nSOURCE: https://github.com/reatom/reatom/blob/v3/packages/npm-vue/CHANGELOG.md#2025-04-23_snippet_1\n\nLANGUAGE: markdown\nCODE:\n```\n## [3.6.0](https://github.com/artalar/reatom/compare/npm-vue-v3.5.0...npm-vue-v3.6.0) (2024-06-22)\n\n### Features\n\n- **npm-vue:** add useCtx, useAction, useCtxBind ([#771](https://github.com/artalar/reatom/issues/771)) ([33d11a6](https://github.com/artalar/reatom/commit/33d11a635d12c47513ee5a6519bc078089e2ce30))\n- **npm-vue:** implement vue integration ([#734](https://github.com/artalar/reatom/issues/734)) ([a281b17](https://github.com/artalar/reatom/commit/a281b17baef6d89d3165b95c8d636d3e0f855c4b))\n\n### Bug Fixes\n\n- esm module export ([1011671](https://github.com/artalar/reatom/commit/10116719dd92d8102352a39e4ed772b8173d8668))\n- **new-package-template:** use mjs in module export ([1011671](https://github.com/artalar/reatom/commit/10116719dd92d8102352a39e4ed772b8173d8668))\n```\n\n----------------------------------------\n\nTITLE: Transitional Code Using Both v1 and v3 APIs\nDESCRIPTION: Demonstrates a transitional stage where both v1 and v3 APIs are used together. Introduces the v3toV1 adapter for compatibility.\nSOURCE: https://github.com/reatom/reatom/blob/v3/docs/src/content/docs/compat/core-v1.md#2025-04-23_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { declareAction, declareAtom, combine, v3toV1 } from '@reatom/core-v1'\nimport { atom } from '@reatom/core'\n\nconst add = declareAction()\nconst n1Atom = declareAtom(0, (on) => [\n  on(add, (state, value) => state + value),\n])\nconst n2Atom = declareAtom(0, (on) => [\n  on(add, (state, value) => state + value),\n])\nconst sumAtom = atom((ctx) => ctx.spy(n1Atom.v3atom) + ctx.spy(n2Atom.v3atom))\nconst rootAtom = combine({ sumAtom: v3toV1(sumAtom) })\n```\n\n----------------------------------------\n\nTITLE: Installing @reatom/form Package\nDESCRIPTION: Command to install the @reatom/form package via npm.\nSOURCE: https://github.com/reatom/reatom/blob/v3/packages/form/README.md#2025-04-23_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nnpm i @reatom/form\n```"
  }
]