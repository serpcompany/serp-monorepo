[
  {
    "owner": "qiskit",
    "repo": "qiskit-serverless",
    "content": "TITLE: Qiskit Function Retrieval and Execution\nDESCRIPTION: This snippet retrieves a deployed Qiskit Function using `client.get()`, runs the function asynchronously using the `run()` method, and obtains a `Job` object. The `Job` object is used to track the function execution status and retrieve the results and logs.\nSOURCE: https://github.com/qiskit/qiskit-serverless/blob/main/docs/getting_started/basic/01_running_program.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nmy_first_function = client.get(\"my-first-function\")\nmy_first_function\n```\n\nLANGUAGE: python\nCODE:\n```\njob = my_first_function.run()\njob\n```\n\nLANGUAGE: python\nCODE:\n```\njob.status()\n```\n\nLANGUAGE: python\nCODE:\n```\njob.result()\n```\n\nLANGUAGE: python\nCODE:\n```\nprint(job.logs())\n```\n\n----------------------------------------\n\nTITLE: Retrieving Results from a Qiskit Job\nDESCRIPTION: This snippet retrieves the results from a Qiskit job by calling the `result()` method on the job object. The job object is obtained from a call to run a Qiskit Function.\nSOURCE: https://github.com/qiskit/qiskit-serverless/blob/main/docs/getting_started/basic/02_arguments_and_results.ipynb#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\njob.result()\n```\n\n----------------------------------------\n\nTITLE: Parallel Quasi-Probability Calculation with QiskitFunction in Python\nDESCRIPTION: This Qiskit Function defines a distributed task to compute the quasi-probability distribution of a quantum circuit in parallel. It retrieves circuits from the function arguments, distributes the `distributed_sample` function across these circuits, collects the results using `get`, and saves the combined results. The function utilizes `qiskit_serverless` for task distribution and result management, and `qiskit` for quantum circuit operations.\nSOURCE: https://github.com/qiskit/qiskit-serverless/blob/main/docs/getting_started/basic/04_distributed_workloads.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom qiskit_serverless import get_arguments, save_result, distribute_task, get\n\nfrom qiskit import QuantumCircuit\nfrom qiskit.primitives import Sampler\n\n\n@distribute_task()\ndef distributed_sample(circuit: QuantumCircuit):\n    \"\"\"Distributed task that returns quasi distribution for given circuit.\"\"\"\n    return Sampler().run(circuit).result().quasi_dists[0]\n\n\narguments = get_arguments()\ncircuits = arguments.get(\"circuits\")\n\n\n# run distributed tasks as async function\n# we get task references as a return type\nsample_task_references = [\n    distributed_sample(circuit)\n    for circuit in circuits\n]\n\n# now we need to collect results from task references\nresults = get(sample_task_references)\n\nsave_result({\n    \"results\": results\n})\n```\n\n----------------------------------------\n\nTITLE: Getting Job Result in Python\nDESCRIPTION: This snippet retrieves the result of a completed job. The `job.result()` method waits for the job to finish (if it hasn't already) and then returns the results of the function's execution. The results will be in the format defined by the `save_result` function within the Qiskit Function.\nSOURCE: https://github.com/qiskit/qiskit-serverless/blob/main/docs/getting_started/basic/04_distributed_workloads.ipynb#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\njob.result()\n```\n\n----------------------------------------\n\nTITLE: Running a Qiskit function with ServerlessClient\nDESCRIPTION: This Python snippet demonstrates how to run a Qiskit function using the ServerlessClient. It initializes the client with a token and gateway address, creates a QiskitFunction object, uploads it to the serverless platform, and then runs the function with a set of input circuits. It shows the basic steps of creating and executing a serverless quantum program.\nSOURCE: https://github.com/qiskit/qiskit-serverless/blob/main/client/README.md#_snippet_2\n\nLANGUAGE: Python\nCODE:\n```\nfrom qiskit_serverless import ServerlessClient, QiskitFunction\nfrom qiskit.circuit.random import random_circuit\n\nclient = ServerlessClient(\n    token=\"<TOKEN>\",\n    host=\"<GATEWAY_ADDRESS>\",\n)\n\n# create function\nfunction = QiskitFunction(\n    title=\"Quickstart\",\n    entrypoint=\"program.py\",\n    working_dir=\"./src\"\n)\nclient.upload(function)\n\n# create inputs to our program\ncircuits = []\nfor _ in range(3):\n    circuit = random_circuit(3, 2)\n    circuit.measure_all()\n    circuits.append(circuit)\n\n# run program\nmy_function = client.get(\"Quickstart\")\njob = my_function.run(circuits=circuits)\n```\n\n----------------------------------------\n\nTITLE: Qiskit Runtime Program Example (main function)\nDESCRIPTION: This is an example of a Qiskit Runtime Program. It defines a `main` function that accepts a backend, user messenger, and keyword arguments. It prepares random circuits, runs them on the backend, publishes results using the user messenger, and returns a greeting message.\nSOURCE: https://github.com/qiskit/qiskit-serverless/blob/main/docs/migration/migration_from_qiskit_runtime_programs.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport random\n\nfrom qiskit import transpile\nfrom qiskit.circuit.random import random_circuit\n\n\ndef prepare_circuits(backend):\n    circuit = random_circuit(\n        num_qubits=5, depth=4, measure=True, seed=random.randint(0, 1000)\n    )\n    return transpile(circuit, backend)\n\n\ndef main(backend, user_messenger, **kwargs):\n    \"\"\"Main entry point of the program.\n\n    Args:\n        backend: Backend to submit the circuits to.\n        user_messenger: Used to communicate with the program consumer.\n        kwargs: User inputs.\n    \"\"\"\n    iterations = kwargs.pop(\"iterations\", 5)\n    for it in range(iterations):\n        qc = prepare_circuits(backend)\n        result = backend.run(qc).result()\n        user_messenger.publish({\"iteration\": it, \"counts\": result.get_counts()})\n\n    return \"Hello, World!\"\n```\n\n----------------------------------------\n\nTITLE: Running QiskitFunction with Circuits in Python\nDESCRIPTION: This snippet retrieves a Qiskit Function named 'function-with-parallel-workflow' from the serverless platform.  It then runs the retrieved function with the previously created list of quantum circuits as input, passing them as a keyword argument named 'circuits'.  The `run` method returns a `job` object, which represents the asynchronous execution of the function.\nSOURCE: https://github.com/qiskit/qiskit-serverless/blob/main/docs/getting_started/basic/04_distributed_workloads.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nparallel_function = client.get(\"function-with-parallel-workflow\")\njob = parallel_function.run(circuits=circuits)\njob\n```\n\n----------------------------------------\n\nTITLE: Running a Qiskit Function with Arguments\nDESCRIPTION: This snippet runs a Qiskit function using the `run` method, passing the previously created quantum circuit as an argument named `circuit`. The result of the `run` method is a job object.  It depends on the `qiskit_serverless` library.\nSOURCE: https://github.com/qiskit/qiskit-serverless/blob/main/docs/getting_started/basic/02_arguments_and_results.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\njob = my_function.run(circuit=circuit)\njob\n```\n\n----------------------------------------\n\nTITLE: QAOA Pattern Implementation\nDESCRIPTION: This code snippet implements the core QAOA pattern, defining a `run_qaoa` function and handling different sampler options based on whether a runtime service is provided. It parses input arguments, creates a VQE instance, and saves the optimization results.\nSOURCE: https://github.com/qiskit/qiskit-serverless/blob/main/docs/examples/02_qaoa.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n# qaoa.py\n\nimport ...\n\ndef run_qaoa(\n    ansatz: QuantumCircuit,\n    estimator: BaseEstimator,\n    operator: PauliSumOp,\n    initial_point: np.array,\n    method: str\n):\n    return minimize(cost_func, initial_point, args=(ansatz, operator, estimator), method=method)\n\n\narguments = get_arguments()\nservice = arguments.get(\"service\")\noperator = arguments.get(\"operator\")\ninitial_point = arguments.get(\"initial_point\")\nansatz = arguments.get(\"ansatz\", 1)\n...\nif service is not None:\n    # if we have service we need to open a session and create sampler\n    service = arguments.get(\"service\")        \n    backend = arguments.get(\"backend\", \"ibmq_qasm_simulator\")\n    with Session(service=service, backend=backend) as session:\n        estimator = Estimator(session=session, options=options)\nelse:\n    # if we do not have a service let's use standart local sampler\n    estimator = QiskitEstimator()\n\nresult = run_qaoa(ansatz, estimator, operator, initial_point, \"COBYLA\")\n    \nsave_result({\n    \"optimal_point\": result.x.tolist(),\n    \"optimal_value\": result.fun\n})\n```\n\n----------------------------------------\n\nTITLE: Installing qiskit_serverless using pip\nDESCRIPTION: This command installs the qiskit_serverless package using pip, the Python package installer. It allows users to interact with the Qiskit Serverless platform.\nSOURCE: https://github.com/qiskit/qiskit-serverless/blob/main/client/README.md#_snippet_0\n\nLANGUAGE: Shell\nCODE:\n```\npip install qiskit_serverless\n```\n\n----------------------------------------\n\nTITLE: Monitoring job status with ServerlessClient\nDESCRIPTION: This Python snippet shows how to monitor the status and retrieve logs of a job running on the Qiskit Serverless platform. It uses the `job.status()` method to check the current status and the `job.logs()` method to retrieve any logs generated during the job's execution.\nSOURCE: https://github.com/qiskit/qiskit-serverless/blob/main/client/README.md#_snippet_3\n\nLANGUAGE: Python\nCODE:\n```\njob.status()\n# 'DONE'\n\n# or get logs\njob.logs()\n```\n\n----------------------------------------\n\nTITLE: VQE Pattern Implementation\nDESCRIPTION: This code snippet shows the core structure of a VQE pattern implementation, including parsing input arguments, creating a `run_vqe` function that accepts an estimator instance, and using either a Qiskit Runtime Service estimator or a standard Qiskit estimator based on the availability of the service. The results from the VQE calculation are then saved.\nSOURCE: https://github.com/qiskit/qiskit-serverless/blob/main/docs/examples/01_vqe.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n# vqe.py\n\nimport ...\n\ndef run_vqe(\n    initial_parameters,\n    ansatz,\n    operator,\n    estimator,\n    method\n):\n    ...\n\narguments = get_arguments()\n\nservice = arguments.get(\"service\")\nansatz = arguments.get(\"ansatz\")\noperator = arguments.get(\"operator\")\ninitial_parameters = arguments.get(\"initial_parameters\") \noptimizer = ...\n\n...\n\nif service is not None:\n    # if we have service we need to open a session and create estimator\n    backend = arguments.get(\"backend\", \"ibmq_qasm_simulator\")\n    with Session(service=service, backend=backend) as session:\n        estimator = Estimator(session=session, options=options) # qiskit_ibm_runtime.Estimator\n        vqe_result = run_vqe( estimator=estimator, ...)\nelse:\n    # if we do not have a service let's use standart local estimator\n    estimator = QiskitEstimator() # qiskit.primitives.Estimator\n\nvqe_result, callback_dict = run_vqe(\n    initial_parameters=initial_parameters,\n    ansatz=ansatz,\n    operator=operator,\n    estimator=estimator,\n    method=method\n)\n\nsave_result({\n    \"optimal_point\": vqe_result.x.tolist(),\n    \"optimal_value\": vqe_result.fun,\n    \"optimizer_evals\": vqe_result.nfev,\n    \"optimizer_history\": callback_dict.get(\"cost_history\", []),\n    \"optimizer_time\": callback_dict.get(\"_total_time\", 0)\n})\n\n```\n\n----------------------------------------\n\nTITLE: Upload, Retrieve, Run, and Access the QiskitFunction in Python\nDESCRIPTION: This set of snippets demonstrates how to upload the defined function to the serverless platform, retrieve the function using its title, run the function, and access the resulting job status and results.  Requires a pre-configured `client` object from the previous snippet.\nSOURCE: https://github.com/qiskit/qiskit-serverless/blob/main/docs/getting_started/basic/03_dependencies.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nclient.upload(function)\nmy_function = client.get(\"function-with-dependencies\")\nmy_function\n```\n\nLANGUAGE: python\nCODE:\n```\njob = my_function.run()\njob\n```\n\nLANGUAGE: python\nCODE:\n```\njob.status()\n```\n\nLANGUAGE: python\nCODE:\n```\njob.result()\n```\n\n----------------------------------------\n\nTITLE: Inspecting Job Results in Python\nDESCRIPTION: This snippet inspects the results of the retrieved jobs by accessing the `.result()` method of each job object and printing the results.\nSOURCE: https://github.com/qiskit/qiskit-serverless/blob/main/docs/getting_started/basic/05_retrieving_past_results.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nprint(f\"Job 1 results: {retrieved_job1.result()}\")\nprint(f\"Job 2 results: {retrieved_job2.result()}\")\n```\n\n----------------------------------------\n\nTITLE: Qiskit Function Creation and Execution\nDESCRIPTION: This snippet defines a Qiskit Function that creates a two-qubit Bell state circuit, measures the results, and saves the measured probability distribution using `qiskit_serverless.save_result`. The `Sampler` primitive is used to execute the circuit and obtain quasi-distributions.\nSOURCE: https://github.com/qiskit/qiskit-serverless/blob/main/docs/getting_started/basic/01_running_program.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom qiskit import QuantumCircuit\nfrom qiskit.primitives import Sampler\n\nfrom qiskit_serverless import save_result\n\n# all print statement will be available in job logs\nprint(\"Running function...\")\n\n# creating circuit\ncircuit = QuantumCircuit(2)\ncircuit.h(0)\ncircuit.cx(0, 1)\ncircuit.measure_all()\n\n# running Sampler primitive\nsampler = Sampler()\nquasi_dists = sampler.run(circuit).result().quasi_dists\n\n# save results of function execution, \n# which will be accessible by calling `.result()`\nsave_result(quasi_dists)\nprint(\"Completed running function.\")\n```\n\n----------------------------------------\n\nTITLE: Pendulum Dependency Example in Python\nDESCRIPTION: This Python code snippet demonstrates using the `pendulum` library to calculate the difference in hours between Toronto and Vancouver timezones. It imports `pendulum` and `save_result` and then calculates the time difference, printing the result and saving it for later retrieval.\nSOURCE: https://github.com/qiskit/qiskit-serverless/blob/main/docs/getting_started/basic/03_dependencies.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom qiskit_serverless import save_result\n\nimport pendulum\n\ndt_toronto = pendulum.datetime(2012, 1, 1, tz='America/Toronto')\ndt_vancouver = pendulum.datetime(2012, 1, 1, tz='America/Vancouver')\n\ndiff = dt_vancouver.diff(dt_toronto).in_hours()\n\nprint(diff)\nsave_result({\"hours\": diff})\n```\n\n----------------------------------------\n\nTITLE: Running QAOA Job\nDESCRIPTION: This snippet runs the QAOA job on the serverless platform using the `serverless.run()` method, passing the function name and input arguments. The returned `job` object can be used to track the job's status and retrieve its results.\nSOURCE: https://github.com/qiskit/qiskit-serverless/blob/main/docs/examples/02_qaoa.ipynb#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\njob = serverless.run(\"qaoa\", arguments=input_arguments)\njob\n```\n\n----------------------------------------\n\nTITLE: Uploading Qiskit Function\nDESCRIPTION: This code defines a QiskitFunction and uploads it to the serverless platform. The function's entrypoint and working directory are specified, and dependencies are conditionally included based on whether the Qiskit Runtime Service is being used.\nSOURCE: https://github.com/qiskit/qiskit-serverless/blob/main/docs/examples/01_vqe.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom qiskit_serverless import QiskitFunction\n\nif USE_RUNTIME_SERVICE:\n    function = QiskitFunction(title=\"vqe\", entrypoint=\"vqe.py\", working_dir=\"./source_files/vqe/\")\nelse:\n    function = QiskitFunction(title=\"vqe\", entrypoint=\"vqe.py\", working_dir=\"./source_files/vqe/\",  dependencies=[\"qiskit_aer\"])\n\nserverless.upload(function)\n```\n\n----------------------------------------\n\nTITLE: Defining a Qiskit Function with Arguments (get_arguments)\nDESCRIPTION: This snippet defines a Qiskit function that retrieves arguments passed to it using `get_arguments`. It extracts a quantum circuit from the arguments, runs a sampler primitive, prints the quasi-distribution, and saves the results using `save_result`. It depends on `qiskit_serverless` and `qiskit` libraries.\nSOURCE: https://github.com/qiskit/qiskit-serverless/blob/main/docs/getting_started/basic/02_arguments_and_results.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom qiskit_serverless import get_arguments, save_result\nfrom qiskit.primitives import Sampler\n\n# get all arguments passed to this function\narguments = get_arguments()\n\n# get specific argument that we are interested in\ncircuit = arguments.get(\"circuit\")\n\nsampler = Sampler()\n\nquasi_dists = sampler.run(circuit).result().quasi_dists\n\nprint(f\"Quasi distribution: {quasi_dists[0]}\")\n\n# saving results of the execution\nsave_result({\n    \"quasi_dists\": quasi_dists[0]\n})\n```\n\n----------------------------------------\n\nTITLE: Defining and Uploading QiskitFunction in Python\nDESCRIPTION: This snippet defines a `QiskitFunction` named 'function-with-parallel-workflow', specifying its entry point as 'function_with_parallel_workflow.py' and working directory as './source_files/'. It then uploads the defined function to the Qiskit Serverless platform using the `client.upload` method.  This prepares the function for execution on the serverless infrastructure.\nSOURCE: https://github.com/qiskit/qiskit-serverless/blob/main/docs/getting_started/basic/04_distributed_workloads.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom qiskit_serverless import QiskitFunction\n\nfunction = QiskitFunction(\n    title=\"function-with-parallel-workflow\",\n    entrypoint=\"function_with_parallel_workflow.py\",\n    working_dir=\"./source_files/\",\n)\n\nclient.upload(function)\n```\n\n----------------------------------------\n\nTITLE: Define a QiskitFunction with Custom Dependencies in Python\nDESCRIPTION: This code snippet demonstrates how to define a QiskitFunction with a custom dependency ('pendulum'). The 'dependencies' argument of the QiskitFunction constructor is used to specify the list of dependencies. The entrypoint and working directory are also set to point to the location of the source file.\nSOURCE: https://github.com/qiskit/qiskit-serverless/blob/main/docs/getting_started/basic/03_dependencies.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom qiskit_serverless import QiskitFunction\n\nfunction = QiskitFunction(\n    title=\"function-with-dependencies\",\n    entrypoint=\"function.py\",\n    working_dir=\"./source_files/\",\n    dependencies=[\"pendulum\"],\n)\n```\n\n----------------------------------------\n\nTITLE: Qiskit Serverless Pattern Example\nDESCRIPTION: This code demonstrates a migrated Qiskit Serverless pattern from a Qiskit Runtime Program. It uses `get_arguments` to retrieve input arguments and `save_result` to store the final result. The program prepares random circuits, runs them using the Sampler primitive, and prints the quasi-distributions.\nSOURCE: https://github.com/qiskit/qiskit-serverless/blob/main/docs/migration/migration_from_qiskit_runtime_programs.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport random\n\nfrom qiskit import transpile\nfrom qiskit.circuit.random import random_circuit\nfrom qiskit.primitives import Sampler\n\nfrom qiskit_serverless import get_arguments, save_result\n\n\ndef prepare_circuits():\n    circuit = random_circuit(\n        num_qubits=5, depth=4, measure=True, seed=random.randint(0, 1000)\n    )\n    return transpile(circuit)\n\n\narguments = get_arguments()\niterations = arguments.get(\"iterations\", 5)\n\nfor it in range(iterations):\n    qc = prepare_circuits()\n    result = Sampler.run(qc).result()\n    print({\"iteration\": it, \"dists\": result.quasi_dists})\n\nsave_result({\"result\": \"Hello, World!\"})\n```\n\n----------------------------------------\n\nTITLE: Upload Qiskit Serverless Function with Custom Image\nDESCRIPTION: This Python code uses the Qiskit Serverless client to upload a function with a custom Docker image.  It defines the function's title, image name, provider, and description. It relies on environment variables for the token, host, and provider ID. It depends on `qiskit_serverless`.\nSOURCE: https://github.com/qiskit/qiskit-serverless/blob/main/docs/deployment/example_custom_image_function.rst#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nimport os\nfrom qiskit_serverless import QiskitFunction, ServerlessClient\n\nserverless = ServerlessClient(\n    token=os.environ.get(\"GATEWAY_TOKEN\", \"awesome_token\"),\n    host=os.environ.get(\"GATEWAY_HOST\", \"http://localhost:8000\"),\n    # If you are using the kubernetes approach the URL must be http://localhost\n)\n\nhelp = \"\"\"\n\ntitle: custom-image-function\n\ndescription: sample function implemented in a custom image\narguments:\n    service: service created with the accunt information\n    circuit: circuit\n    observable: observable\n\"\"\"\n\nfunction_with_custom_image = QiskitFunction(\n    title=\"custom-image-function\",\n    image=\"test-local-provider-function:latest\",\n    provider=os.environ.get(\"PROVIDER_ID\", \"mockprovider\"),\n    description=help\n)\nserverless.upload(function_with_custom_image)\n```\n\n----------------------------------------\n\nTITLE: Creating and Uploading a Qiskit Function\nDESCRIPTION: This snippet creates a `QiskitFunction` instance, specifying the title, entrypoint, and working directory. It then uploads the function to the serverless platform using the configured `client`. It depends on `qiskit_serverless` library.\nSOURCE: https://github.com/qiskit/qiskit-serverless/blob/main/docs/getting_started/basic/02_arguments_and_results.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom qiskit_serverless import QiskitFunction\n\nfunction = QiskitFunction(\n    title=\"function-with-arguments\",\n    entrypoint=\"function_with_arguments.py\",\n    working_dir=\"./source_files/\",\n)\n\nclient.upload(function)\n```\n\n----------------------------------------\n\nTITLE: Preparing VQE Input Arguments\nDESCRIPTION: This snippet prepares the input arguments for the VQE pattern. It defines a Hamiltonian operator, an ansatz (EfficientSU2), and other necessary parameters, including a conditional check for using the Qiskit Runtime Service. The arguments are then packaged into a dictionary.\nSOURCE: https://github.com/qiskit/qiskit-serverless/blob/main/docs/examples/01_vqe.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport numpy as np\n\n\nfrom qiskit.circuit.library import EfficientSU2\nfrom qiskit.quantum_info import SparsePauliOp\n\nfrom qiskit_ibm_runtime import QiskitRuntimeService, Estimator, Session, Options\n\nUSE_RUNTIME_SERVICE = False\n\nservice = None\nif USE_RUNTIME_SERVICE:\n    service = QiskitRuntimeService(\n        channel='ibm_quantum',\n        instance='ibm-q/open/main',\n        token='<Your Token>',\n        verify=False\n    )\n\noperator = SparsePauliOp.from_list(\n    [(\"YZ\", 0.3980), (\"ZI\", -0.3980), (\"ZZ\", -0.0113), (\"XX\", 0.1810)]\n)\nansatz = EfficientSU2(operator.num_qubits)\n\ninput_arguments = {\n    \"ansatz\": ansatz,\n    \"operator\": operator,\n    \"method\": \"COBYLA\",\n    \"service\": service,\n}\n\ninput_arguments\n```\n\n----------------------------------------\n\nTITLE: Creating and Uploading QiskitFunction\nDESCRIPTION: This snippet creates a `QiskitFunction` object, specifying the entrypoint, working directory, and dependencies. It then uploads the function to the serverless platform using the `serverless.upload()` method.\nSOURCE: https://github.com/qiskit/qiskit-serverless/blob/main/docs/examples/02_qaoa.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom qiskit_serverless import QiskitFunction\n\nfunction = QiskitFunction(\n    title=\"qaoa\", entrypoint=\"qaoa.py\", working_dir=\"./source_files/qaoa/\", dependencies=[\"qiskit_aer\"]\n)\n\nserverless.upload(function)\n```\n\n----------------------------------------\n\nTITLE: Qiskit Function Upload\nDESCRIPTION: This snippet creates a `QiskitFunction` object, specifying the title, entrypoint (Python file to execute), and working directory. The function is then uploaded to the serverless platform using the `client.upload()` method.\nSOURCE: https://github.com/qiskit/qiskit-serverless/blob/main/docs/getting_started/basic/01_running_program.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom qiskit_serverless import QiskitFunction\n\nfunction = QiskitFunction(\n    title=\"my-first-function\", entrypoint=\"function.py\", working_dir=\"./source_files/\"\n)\n\nclient.upload(function)\n```\n\n----------------------------------------\n\nTITLE: Listing Previously Executed Jobs in Python\nDESCRIPTION: This snippet retrieves a list of previously executed functions using the `.get_jobs()` method of the `QiskitServerless` object. The `limit` and `offset` parameters are used to control the size and starting point of the returned results.\nSOURCE: https://github.com/qiskit/qiskit-serverless/blob/main/docs/getting_started/basic/05_retrieving_past_results.ipynb#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nclient.get_jobs(limit=2, offset=1)\n```\n\n----------------------------------------\n\nTITLE: QAOA Input Arguments Preparation\nDESCRIPTION: This snippet prepares the input arguments for the QAOA pattern, including the operator, ansatz, and optional runtime service. It initializes the `SparsePauliOp` and `QAOAAnsatz` and defines a dictionary containing these arguments, which can then be passed to the pattern.\nSOURCE: https://github.com/qiskit/qiskit-serverless/blob/main/docs/examples/02_qaoa.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport numpy as np\n\nfrom qiskit.circuit.library import QAOAAnsatz\nfrom qiskit.quantum_info import SparsePauliOp\n\nfrom qiskit_ibm_runtime import QiskitRuntimeService\n\n\noperator = SparsePauliOp.from_list(\n    [(\"IIIZZ\", 1), (\"IIZIZ\", 1), (\"IZIIZ\", 1), (\"ZIIIZ\", 1)]\n)\nansatz = QAOAAnsatz(operator, reps=2)\nansatz = ansatz.decompose(reps=3)\nansatz.draw(fold=-1)\n```\n\n----------------------------------------\n\nTITLE: Listing Available Files in Python\nDESCRIPTION: This snippet lists the available files produced by a Qiskit Function using the `files` method.  It requires the function object as input and returns a list of filenames that are accessible.\nSOURCE: https://github.com/qiskit/qiskit-serverless/blob/main/docs/getting_started/experimental/file_download.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\navailable_files = serverless.files(my_function)\navailable_files\n```\n\n----------------------------------------\n\nTITLE: Creating a Quantum Circuit for Qiskit Function\nDESCRIPTION: This snippet creates a simple 2-qubit quantum circuit using `QuantumCircuit` from the `qiskit` library. It applies a Hadamard gate to qubit 0, a CNOT gate with qubit 0 as control and qubit 1 as target, and measures all qubits. It also draws the circuit.\nSOURCE: https://github.com/qiskit/qiskit-serverless/blob/main/docs/getting_started/basic/02_arguments_and_results.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom qiskit import QuantumCircuit\n\ncircuit = QuantumCircuit(2)\ncircuit.h(0)\ncircuit.cx(0, 1)\ncircuit.measure_all()\ncircuit.draw()\n```\n\n----------------------------------------\n\nTITLE: Accessing Job Logs in Python\nDESCRIPTION: This snippet demonstrates how to access the logs from a function execution by calling the `.logs()` method on the retrieved job object and printing the logs.\nSOURCE: https://github.com/qiskit/qiskit-serverless/blob/main/docs/getting_started/basic/05_retrieving_past_results.ipynb#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nprint(f\"Job 1 logs: {retrieved_job1.logs()}\")\n```\n\n----------------------------------------\n\nTITLE: Initializing Serverless Client\nDESCRIPTION: This code snippet initializes the ServerlessClient with a token and host, which are retrieved from environment variables. If the environment variables are not set, default values are used.\nSOURCE: https://github.com/qiskit/qiskit-serverless/blob/main/docs/examples/01_vqe.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nserverless = ServerlessClient(\n    token=os.environ.get(\"GATEWAY_TOKEN\", \"awesome_token\"),\n    host=os.environ.get(\"GATEWAY_HOST\", \"http://localhost:8000\"),\n)\nserverless\n```\n\n----------------------------------------\n\nTITLE: Defining a distributed quantum function with qiskit_serverless\nDESCRIPTION: This Python snippet demonstrates how to define a distributed quantum function using the qiskit_serverless library. It uses the `@distribute_task` decorator to convert a standard function into a distributed asynchronous task. The function samples a quantum circuit and returns quasi-distributions.\nSOURCE: https://github.com/qiskit/qiskit-serverless/blob/main/client/README.md#_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\nfrom qiskit_serverless import distribute_task, get, get_arguments, save_result\n\nfrom qiskit import QuantumCircuit\nfrom qiskit.circuit.random import random_circuit\nfrom qiskit.primitives import StatevectorSampler as Sampler\nfrom qiskit.quantum_info import SparsePauliOp\n\n# 1. let's annotate out function to convert it\n# to distributed async function\n# using `distribute_task` decorator\n@distribute_task()\ndef distributed_sample(circuit: QuantumCircuit):\n    \"\"\"Calculates quasi dists as a distributed function.\"\"\"\n    return Sampler().run([(circuit)]).result()[0].data.meas.get_counts()\n\n# 2. our program will have one arguments\n# `circuits` which will store list of circuits\n# we want to sample in parallel.\n# Let's use `get_arguments` funciton\n# to access all program arguments\narguments = get_arguments()\ncircuits = arguments.get(\"circuits\", [])\n\n# 3. run our functions in a loop\n# and get execution references back\nfunction_references = [\n    distributed_sample(circuit)\n    for circuit in circuits\n]\n\n# 4. `get` function will collect all\n# results from distributed functions\ncollected_results = get(function_references)\n\n# 5. `save_result` will save results of program execution\n# so we can access it later\nsave_result({\n    \"quasi_dists\": collected_results\n})\n```\n\n----------------------------------------\n\nTITLE: Uploading and Using Function with Custom Image in Python\nDESCRIPTION: This Python code demonstrates how to upload and use a Qiskit Function with a custom Docker image. It initializes a `ServerlessClient`, defines a `QiskitFunction` with the image, uploads the function, retrieves it, and then runs a job using the function.\nSOURCE: https://github.com/qiskit/qiskit-serverless/blob/main/docs/deployment/deploying_custom_image_function.rst#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nimport os\nfrom qiskit_serverless import QiskitFunction, ServerlessClient\n\nserverless = ServerlessClient(\n    token=os.environ.get(\"GATEWAY_TOKEN\", \"awesome_token\"),\n    host=os.environ.get(\"GATEWAY_HOST\", \"http://localhost:8000\"),\n    # If you are using the kubernetes approach the URL must be http://localhost\n)\nserverless\n\nfunction = QiskitFunction(\n    title=\"custom-image-function\",\n    image=\"test-local-provider-function:latest\",\n    provider=\"mockprovider\"\n)\nfunction\n\nserverless.upload(function)\n\nmy_function = serverless.get(\"custom-image-function\")\nmy_function\n\njob = my_function.run(test_argument_one=1, test_argument_two=\"two\")\njob\n\njob.result()\n```\n\n----------------------------------------\n\nTITLE: Generating Random Quantum Circuits in Python\nDESCRIPTION: This code snippet creates a list of three random quantum circuits, each with 2 qubits and a depth of 2, using the `random_circuit` function from `qiskit.circuit.random`. It then adds a measurement operation to each circuit. The result is a list of quantum circuits ready to be used as input for a Qiskit Function.\nSOURCE: https://github.com/qiskit/qiskit-serverless/blob/main/docs/getting_started/basic/04_distributed_workloads.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom qiskit.circuit.random import random_circuit\n\ncircuits = [random_circuit(2, 2) for _ in range(3)]\n[circuit.measure_all() for circuit in circuits]\ncircuits\n```\n\n----------------------------------------\n\nTITLE: Getting a Qiskit Function in Python\nDESCRIPTION: This snippet retrieves a Qiskit Function from the Qiskit Serverless platform using its title.  The `get` method returns the function object, which can then be used to execute jobs.\nSOURCE: https://github.com/qiskit/qiskit-serverless/blob/main/docs/getting_started/experimental/file_download.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nmy_function = serverless.get(\"file-producer\")\nmy_function\n```\n\n----------------------------------------\n\nTITLE: Waiting for Qiskit Job Results in Python\nDESCRIPTION: This snippet calls the `.result()` method on each job object to block until the results are ready. This ensures that the results are available for retrieval in subsequent steps.\nSOURCE: https://github.com/qiskit/qiskit-serverless/blob/main/docs/getting_started/basic/05_retrieving_past_results.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\njob1.result()\njob2.result()\n```\n\n----------------------------------------\n\nTITLE: Configuring the ServerlessClient\nDESCRIPTION: This snippet configures the `ServerlessClient` to interact with a Qiskit Serverless environment.  It retrieves the token and host from environment variables (`GATEWAY_TOKEN`, `GATEWAY_HOST`) or uses default values. It depends on the `qiskit_serverless` and `os` libraries.\nSOURCE: https://github.com/qiskit/qiskit-serverless/blob/main/docs/getting_started/basic/02_arguments_and_results.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom qiskit_serverless import ServerlessClient\nimport os\n\nclient = ServerlessClient(\n    token=os.environ.get(\"GATEWAY_TOKEN\", \"awesome_token\"),\n    host=os.environ.get(\"GATEWAY_HOST\", \"http://localhost:8000\"),\n    # If you are using the kubernetes approach the URL must be http://localhost\n)\nclient\n```\n\n----------------------------------------\n\nTITLE: Initialize the ServerlessClient in Python\nDESCRIPTION: This snippet shows how to initialize the ServerlessClient using environment variables for the token and host.  Default values are provided if the environment variables are not set.  This client is used to interact with the serverless platform.\nSOURCE: https://github.com/qiskit/qiskit-serverless/blob/main/docs/getting_started/basic/03_dependencies.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom qiskit_serverless import ServerlessClient\nimport os\n\nclient = ServerlessClient(\n    token=os.environ.get(\"GATEWAY_TOKEN\", \"awesome_token\"),\n    host=os.environ.get(\"GATEWAY_HOST\", \"http://localhost:8000\"),\n    # If you are using the kubernetes approach the URL must be http://localhost\n)\nclient\n```\n\n----------------------------------------\n\nTITLE: Installing Helm Chart from Specific Values File\nDESCRIPTION: This command installs the Qiskit Serverless Helm chart using a custom values file. It allows you to override the default values with your own configuration. Replace `<PATH_TO_VALUES_FILE>` with the actual path to your custom values file. It also creates a new namespace called `qiskit-serverless` if it doesn't already exist.\nSOURCE: https://github.com/qiskit/qiskit-serverless/blob/main/charts/qiskit-serverless/README.md#_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\nhelm -n qiskit-serverless install qiskit-serverless -f <PATH_TO_VALUES_FILE> --create-namespace .\n```\n\n----------------------------------------\n\nTITLE: Rebasing a Feature Branch\nDESCRIPTION: This snippet demonstrates how to rebase a feature branch onto the latest version of the main branch. It fetches the latest changes from the upstream repository, rebases the local main branch, and then rebases the feature branch onto the updated main branch. This ensures that the feature branch is up-to-date with the latest changes and reduces the likelihood of merge conflicts.\nSOURCE: https://github.com/qiskit/qiskit-serverless/blob/main/CONTRIBUTING.md#_snippet_8\n\nLANGUAGE: sh\nCODE:\n```\ngit checkout main\ngit fetch upstream\ngit rebase upstream main\ngit checkout issue-1234-new-feature\ngit rebase main issue-1234-new-feature\n```\n\n----------------------------------------\n\nTITLE: Dockerfile Configuration for Custom Image\nDESCRIPTION: This Dockerfile extends a base serverless node image and adds the necessary dependencies and structure for a custom image function. It copies the function implementation (`runner.py`) into the `/runner` directory within the image and sets the user permissions appropriately.\nSOURCE: https://github.com/qiskit/qiskit-serverless/blob/main/docs/deployment/deploying_custom_image_function.rst#_snippet_1\n\nLANGUAGE: docker\nCODE:\n```\nFROM icr.io/quantum-public/qiskit-serverless/ray-node:0.21.1\n\n# install all necessary dependencies for your custom image\n\n# copy our function implementation in `/runner/runner.py` of the docker image\nUSER 0\n\nWORKDIR /runner\nCOPY ./runner.py /runner\nWORKDIR /\n\nUSER 1000\n```\n\n----------------------------------------\n\nTITLE: Retrieving Completed Jobs in Python\nDESCRIPTION: This snippet retrieves the completed jobs from the serverless client using the job IDs obtained earlier. It uses the `client.job()` method to retrieve the job objects.\nSOURCE: https://github.com/qiskit/qiskit-serverless/blob/main/docs/getting_started/basic/05_retrieving_past_results.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nretrieved_job1 = client.job(job_id1)\nretrieved_job2 = client.job(job_id2)\n```\n\n----------------------------------------\n\nTITLE: Initializing QiskitPattern\nDESCRIPTION: This snippet shows how to initialize a `QiskitPattern` object. It sets the title, entry point, and working directory for the pattern. The entrypoint refers to the python file containing the code to be executed.\nSOURCE: https://github.com/qiskit/qiskit-serverless/blob/main/docs/migration/migration_from_qiskit_runtime_programs.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom qiskit_serverless import QiskitPattern\n\npattern = QiskitPattern(\n    title=\"migrated-pattern\", entrypoint=\"migrated_pattern.py\", working_dir=\"./src/\"\n)\n```\n\n----------------------------------------\n\nTITLE: Start Colima Container Runtime\nDESCRIPTION: Starts the Colima container runtime with specified resources (CPU, memory, and disk space). Colima is recommended for MacOS with ARM processors to avoid architecture-related problems when running Docker containers. This increases the resource allocation to help with performance.\nSOURCE: https://github.com/qiskit/qiskit-serverless/blob/main/docs/deployment/local.rst#_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\n$ colima start --cpu 4 --memory 8 --disk 100\n```\n\n----------------------------------------\n\nTITLE: Dockerfile for Custom Qiskit Serverless Image\nDESCRIPTION: This Dockerfile defines the custom Docker image for the Qiskit Serverless function. It starts from the `icr.io/quantum-public/qiskit-serverless/ray-node:0.21.1` base image, installs the `qiskit_aer` dependency using pip, copies the function implementation (`runner.py`) into the image, and sets the working directory. It also changes the user ID.\nSOURCE: https://github.com/qiskit/qiskit-serverless/blob/main/docs/deployment/example_custom_image_function.rst#_snippet_1\n\nLANGUAGE: dockerfile\nCODE:\n```\nFROM icr.io/quantum-public/qiskit-serverless/ray-node:0.21.1\n\n# install all necessary dependencies for your custom image\n\n# copy our function implementation in `/runner/runner.py` of the docker image\nUSER 0\nRUN  pip install qiskit_aer\n\nWORKDIR /runner\nCOPY ./runner.py /runner\nWORKDIR /\n\nUSER 1000\n```\n\n----------------------------------------\n\nTITLE: Getting Job Result\nDESCRIPTION: This snippet shows how to retrieve the result of a Qiskit Serverless job using the `result()` method of the job object.\nSOURCE: https://github.com/qiskit/qiskit-serverless/blob/main/docs/migration/migration_from_qiskit_runtime_programs.ipynb#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\njob.result()\n```\n\n----------------------------------------\n\nTITLE: Define Qiskit Serverless Function in runner.py\nDESCRIPTION: This Python code defines a custom Qiskit Serverless function named `custom_function`. It takes arguments such as a Qiskit Runtime Service instance, a quantum circuit, and an observable. It transpiles the circuit using preset pass managers, executes it using the EstimatorV2, and returns the expectation values. It depends on `qiskit_aer`, `qiskit_serverless`, `qiskit`, and `qiskit_ibm_runtime`.\nSOURCE: https://github.com/qiskit/qiskit-serverless/blob/main/docs/deployment/example_custom_image_function.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom qiskit_aer import AerSimulator\nfrom qiskit_serverless import get_arguments, save_result\nfrom qiskit.transpiler.preset_passmanagers import generate_preset_pass_manager\nfrom qiskit_ibm_runtime import Session\n\ndef custom_function(arguments):\n     service = arguments.get(\"service\")\n     circuit = arguments.get(\"circuit\")\n     observable = arguments.get(\"observable\")\n\n     if service:\n         backend = service.least_busy(operational=True, simulator=False, min_num_qubits=127)\n         session = Session(backend=backend)\n     else:\n         backend = AerSimulator()\n\n    target = backend.target\n    pm = generate_preset_pass_manager(target=target, optimization_level=3)\n\n    target_circuit = pm.run(circuit)\n    target_observable = observable.apply_layout(target_circuit.layout)\n\n    from qiskit_ibm_runtime import EstimatorV2 as Estimator\n    if service:\n        estimator = Estimator(session=session)\n    else:\n        estimator = Estimator(backend=backend)\n    job = estimator.run([(target_circuit, target_observable)])\n\n    if service:\n        session.close()\n    return job.result()[0].data.evs\n\nclass Runner:\n    def run(self, arguments: dict) -> dict:\n        return custom_function(arguments)\n```\n\n----------------------------------------\n\nTITLE: Running Python Linting with tox\nDESCRIPTION: This command executes the linting process for Python projects within the repository using the `tox` environment manager. It checks for code style violations and potential issues, ensuring adherence to the project's coding standards.\nSOURCE: https://github.com/qiskit/qiskit-serverless/blob/main/CONTRIBUTING.md#_snippet_11\n\nLANGUAGE: shell\nCODE:\n```\ntox -elint\n```\n\n----------------------------------------\n\nTITLE: Creating and Uploading a Qiskit Function in Python\nDESCRIPTION: This snippet creates a Qiskit Function with a title, entrypoint, and working directory. It then uploads the function to the Qiskit Serverless platform using the `upload` method. This function is designed to create files.\nSOURCE: https://github.com/qiskit/qiskit-serverless/blob/main/docs/getting_started/experimental/file_download.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfunction = QiskitFunction(\n    title=\"file-producer\", entrypoint=\"produce_files.py\", working_dir=\"./source_files/\"\n)\n\nserverless.upload(function)\n```\n\n----------------------------------------\n\nTITLE: Downloading a File in Python\nDESCRIPTION: This snippet downloads a specific file produced by a Qiskit Function using the `file_download` method. It requires the filename and the function object as input. The file is downloaded to the local machine.\nSOURCE: https://github.com/qiskit/qiskit-serverless/blob/main/docs/getting_started/experimental/file_download.ipynb#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nserverless.file_download(available_files[0], my_function)\n```\n\n----------------------------------------\n\nTITLE: Building Docker Image using Docker CLI\nDESCRIPTION: This shell command builds a Docker image named `test-local-provider-function` using the `Sample-Dockerfile` in the current directory. The `-t` flag specifies the image name and tag.\nSOURCE: https://github.com/qiskit/qiskit-serverless/blob/main/docs/deployment/deploying_custom_image_function.rst#_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\ndocker build -t test-local-provider-function -f Sample-Dockerfile .\n```\n\n----------------------------------------\n\nTITLE: Checking Job Status in Python\nDESCRIPTION: This code snippet retrieves the status of a previously submitted job. The `job.status()` method returns the current status of the job's execution, such as 'Running', 'Completed', or 'Failed'.\nSOURCE: https://github.com/qiskit/qiskit-serverless/blob/main/docs/getting_started/basic/04_distributed_workloads.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\njob.status()\n```\n\n----------------------------------------\n\nTITLE: Running Qiskit Functions in Parallel using Python\nDESCRIPTION: This snippet defines a Qiskit Function, uploads it to the serverless client, and then runs the function twice in parallel, creating two jobs. The job objects are then displayed.\nSOURCE: https://github.com/qiskit/qiskit-serverless/blob/main/docs/getting_started/basic/05_retrieving_past_results.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom qiskit_serverless import QiskitFunction\n\nfunction = QiskitFunction(\n    title=\"function-to-fetch-results\", entrypoint=\"function.py\", working_dir=\"./source_files/\"\n)\nclient.upload(function)\n\nmy_function = client.get(\"function-to-fetch-results\")\n\njob1 = my_function.run()\njob2 = my_function.run()\n\njob1, job2\n```\n\n----------------------------------------\n\nTITLE: Serverless Client Initialization\nDESCRIPTION: This snippet initializes the `ServerlessClient` with credentials obtained from environment variables (`GATEWAY_TOKEN` and `GATEWAY_HOST`).  If these variables are not set, default values are used to connect to a local Docker Compose setup.\nSOURCE: https://github.com/qiskit/qiskit-serverless/blob/main/docs/getting_started/basic/01_running_program.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom qiskit_serverless import ServerlessClient\nimport os\n```\n\nLANGUAGE: python\nCODE:\n```\nclient = ServerlessClient(\n    token=os.environ.get(\"GATEWAY_TOKEN\", \"awesome_token\"),\n    host=os.environ.get(\"GATEWAY_HOST\", \"http://localhost:8000\"),\n    # If you are using the kubernetes approach the URL must be http://localhost\n)\n\nclient\n```\n\n----------------------------------------\n\nTITLE: List Available Qiskit Serverless Functions\nDESCRIPTION: This Python code uses the Qiskit Serverless client to list all available functions. It retrieves the function list and prints the title and description of each function. It relies on environment variables for the token and host. It depends on `qiskit_serverless`.\nSOURCE: https://github.com/qiskit/qiskit-serverless/blob/main/docs/deployment/example_custom_image_function.rst#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nimport os\nfrom qiskit_serverless import ServerlessClient\n\nserverless = ServerlessClient(\n    token=os.environ.get(\"GATEWAY_TOKEN\", \"awesome_token\"),\n    host=os.environ.get(\"GATEWAY_HOST\", \"http://localhost:8000\"),\n    # If you are using the kubernetes approach the URL must be http://localhost\n)\n\nmy_functions = serverless.list()\nfor function in my_functions:\n    print(\"Name: \" + function.title)\n    print(function.description)\n    print()\n```\n\n----------------------------------------\n\nTITLE: Running Docker Compose\nDESCRIPTION: This shell command starts the services defined in the `docker-compose.yaml` file, effectively running the Qiskit Function with the custom Docker image in a local environment.\nSOURCE: https://github.com/qiskit/qiskit-serverless/blob/main/docs/deployment/deploying_custom_image_function.rst#_snippet_4\n\nLANGUAGE: shell\nCODE:\n```\ndocker-compose up\n```\n\n----------------------------------------\n\nTITLE: Running VQE Pattern\nDESCRIPTION: This snippet runs the uploaded VQE pattern using the serverless client, passing the prepared input arguments. It retrieves a job object representing the execution.\nSOURCE: https://github.com/qiskit/qiskit-serverless/blob/main/docs/examples/01_vqe.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\njob = serverless.run(\"vqe\", arguments=input_arguments)\njob\n```\n\n----------------------------------------\n\nTITLE: Retrieving Job IDs in Python\nDESCRIPTION: This snippet retrieves the job IDs from the job objects created in the previous step. It accesses the `job_id` attribute of each job object.\nSOURCE: https://github.com/qiskit/qiskit-serverless/blob/main/docs/getting_started/basic/05_retrieving_past_results.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\njob_id1 = job1.job_id\njob_id2 = job2.job_id\n```\n\n----------------------------------------\n\nTITLE: Running All Test Environments with Tox\nDESCRIPTION: This command invokes tox to run all configured test environments defined in the tox.ini file. It's the main entry point for running tests and checks.\nSOURCE: https://github.com/qiskit/qiskit-serverless/blob/main/client/tests/README.md#_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\n$ tox\n```\n\n----------------------------------------\n\nTITLE: ClusterIP URL Retrieval (Shell)\nDESCRIPTION: These shell commands retrieve the application URL when using ClusterIP as the service type. It retrieves the pod name and container port, then sets up port forwarding to access the application locally.\nSOURCE: https://github.com/qiskit/qiskit-serverless/blob/main/charts/qiskit-serverless/charts/gateway/templates/NOTES.txt#_snippet_3\n\nLANGUAGE: Shell\nCODE:\n```\nexport POD_NAME=$(kubectl get pods --namespace {{ .Release.Namespace }} -l \"app.kubernetes.io/name={{ include \"gateway.name\" . }},app.kubernetes.io/instance={{ .Release.Name }}\" -o jsonpath=\"{.items[0].metadata.name}\")\nexport CONTAINER_PORT=$(kubectl get pod --namespace {{ .Release.Namespace }} $POD_NAME -o jsonpath=\"{.spec.containers[0].ports[0].containerPort}\")\necho \"Visit http://127.0.0.1:8080 to use your application\"\nkubectl --namespace {{ .Release.Namespace }} port-forward $POD_NAME 8080:$CONTAINER_PORT\n```\n\n----------------------------------------\n\nTITLE: Retrieving Job Result\nDESCRIPTION: This snippet retrieves the result of the completed job using the `job.result()` method. The result contains the optimal point and optimal value found during the QAOA optimization.\nSOURCE: https://github.com/qiskit/qiskit-serverless/blob/main/docs/examples/02_qaoa.ipynb#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\njob.result()\n```\n\n----------------------------------------\n\nTITLE: Initializing ServerlessClient in Python\nDESCRIPTION: This snippet initializes the ServerlessClient using environment variables for the token and host. It uses default values if the environment variables are not set. The client instance is then printed.\nSOURCE: https://github.com/qiskit/qiskit-serverless/blob/main/docs/getting_started/basic/05_retrieving_past_results.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom qiskit_serverless import ServerlessClient\nimport os\n\nclient = ServerlessClient(\n    token=os.environ.get(\"GATEWAY_TOKEN\", \"awesome_token\"),\n    host=os.environ.get(\"GATEWAY_HOST\", \"http://localhost:8000\"),\n    # If you are using the kubernetes approach the URL must be http://localhost\n)\nclient\n```\n\n----------------------------------------\n\nTITLE: Install Qiskit Serverless Client\nDESCRIPTION: Installs the Qiskit Serverless client library using pip. This is a prerequisite for interacting with the server.\nSOURCE: https://github.com/qiskit/qiskit-serverless/blob/main/docs/deployment/client_configuration.rst#_snippet_0\n\nLANGUAGE: Shell\nCODE:\n```\npip install qiskit-serverless\n```\n\n----------------------------------------\n\nTITLE: Retrieving Job Result in Python\nDESCRIPTION: This snippet retrieves the result of a Qiskit Function execution using the `result` method on the job object. The result contains the output of the function.\nSOURCE: https://github.com/qiskit/qiskit-serverless/blob/main/docs/getting_started/experimental/file_download.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\njob.result()\n```\n\n----------------------------------------\n\nTITLE: Running a Qiskit Function in Python\nDESCRIPTION: This snippet runs a Qiskit Function using the `run` method. It returns a job object, which can be used to retrieve the results of the function execution.\nSOURCE: https://github.com/qiskit/qiskit-serverless/blob/main/docs/getting_started/experimental/file_download.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\njob = my_function.run()\njob\n```\n\n----------------------------------------\n\nTITLE: Ingress URL Retrieval (YAML)\nDESCRIPTION: This YAML snippet configures the application URL retrieval for an Ingress controller. It iterates through the defined hosts and paths to construct the appropriate HTTP/HTTPS URL based on TLS configuration.\nSOURCE: https://github.com/qiskit/qiskit-serverless/blob/main/charts/qiskit-serverless/charts/gateway/templates/NOTES.txt#_snippet_0\n\nLANGUAGE: YAML\nCODE:\n```\n{{- if .Values.ingress.enabled }}\n{{- range $host := .Values.ingress.hosts }}\n  {{- range .paths }}\n  http{{ if $.Values.ingress.tls }}s{{ end }}://{{ $host.host }}{{ .path }}\n  {{- end }}\n{{- end }}\n{{- end }}\n```\n\n----------------------------------------\n\nTITLE: Execute Qiskit Serverless Function\nDESCRIPTION: This Python code executes a Qiskit Serverless function named \"custom-image-function\". It retrieves the function, creates a random quantum circuit and SparsePauliOp observable, and runs the function with these arguments. It relies on environment variables for the token and host. It also sets up an optional QiskitRuntimeService if `use_service` is True, relying on the YOUR_TOKEN env var. It depends on `qiskit_serverless`, `qiskit`, and `qiskit_ibm_runtime`.\nSOURCE: https://github.com/qiskit/qiskit-serverless/blob/main/docs/deployment/example_custom_image_function.rst#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nimport os\nfrom qiskit_serverless import ServerlessClient\nfrom qiskit import QuantumCircuit\nfrom qiskit.circuit.random import random_circuit\nfrom qiskit.quantum_info import SparsePauliOp\nfrom qiskit_ibm_runtime import QiskitRuntimeService\n\n# set this True for the real Quantum system use\nuse_service=False\n\nservice = None\nif use_service:\n    service = QiskitRuntimeService(\n\ttoken=os.environ.get(\"YOUR_TOKEN\", \"\"),\n\tchannel='ibm_quantum',\n\tinstance='ibm-q/open/main',\n\tverify=False,\n    )\n\ncircuit = random_circuit(2, 2, seed=1234)\nobservable = SparsePauliOp(\"IY\")\nserverless = ServerlessClient(\n    token=os.environ.get(\"GATEWAY_TOKEN\", \"awesome_token\"),\n    host=os.environ.get(\"GATEWAY_HOST\", \"http://localhost:8000\"),\n    # If you are using the kubernetes approach the URL must be http://localhost\n)\n\nmy_function = serverless.get(\"custom-image-function\")\njob = my_function.run(service=service, circuit=circuit, observable=observable)\n\nprint(job.result())\nprint(job.logs())\n```\n\n----------------------------------------\n\nTITLE: Modify Docker Compose Definition for Custom Image\nDESCRIPTION: This YAML snippet modifies the Docker Compose configuration to use the custom-built Docker image `test-local-provider-function:latest` for the `ray-head` service. It sets the container name to `ray-head`.\nSOURCE: https://github.com/qiskit/qiskit-serverless/blob/main/docs/deployment/example_custom_image_function.rst#_snippet_3\n\nLANGUAGE: yaml\nCODE:\n```\nservices:\n    ray-head:\n        container_name: ray-head\n        image: test-local-provider-function:latest\n```\n\n----------------------------------------\n\nTITLE: Runner Class Implementation in Python\nDESCRIPTION: This Python code defines a `Runner` class with a `run` method. The `run` method takes a dictionary as input, adds an 'answer' key with the value 42, and returns the updated dictionary. This class serves as the entry point for a custom image function.\nSOURCE: https://github.com/qiskit/qiskit-serverless/blob/main/docs/deployment/deploying_custom_image_function.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nclass Runner:\n    def run(self, arguments: dict) -> dict:\n        # this is just an example\n        # your function can call for other modules, function, etc.\n        return {\n            **arguments,\n            **{\n                \"answer\": 42\n            }\n        }\n```\n\n----------------------------------------\n\nTITLE: Retrieving job results with ServerlessClient\nDESCRIPTION: This Python snippet shows how to retrieve the results of a completed job on the Qiskit Serverless platform. The `job.result()` method returns a dictionary containing the results of the function execution, in this case, quasi-distributions from sampling quantum circuits.\nSOURCE: https://github.com/qiskit/qiskit-serverless/blob/main/client/README.md#_snippet_4\n\nLANGUAGE: Python\nCODE:\n```\njob.result()\n# {'quasi_dists': [\n# {'101': 902, '011': 66, '110': 2, '111': 37, '100': 17},\n# {'100': 626, '101': 267, '001': 49, '000': 82},\n# {'010': 145, '100': 126, '011': 127, '001': 89, '110': 173, '111': 166, '000': 94, '101': 104}\n# ]}\n```\n\n----------------------------------------\n\nTITLE: Displaying Executed Programs Widget\nDESCRIPTION: This snippet calls the `.widget()` method on the `ServerlessClient` object, which renders a Jupyter widget displaying a list of executed programs and their statuses within the Jupyter environment.\nSOURCE: https://github.com/qiskit/qiskit-serverless/blob/main/docs/getting_started/basic/01_running_program.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nclient.widget()\n```\n\n----------------------------------------\n\nTITLE: Clone Qiskit Serverless Repository\nDESCRIPTION: Clones the Qiskit Serverless repository from GitHub. This downloads the project's source code and allows you to work on it locally.  It requires Git to be installed and configured with appropriate SSH keys.\nSOURCE: https://github.com/qiskit/qiskit-serverless/blob/main/docs/deployment/local.rst#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\ncd /path/to/workspace/\ngit clone git@github.com:Qiskit/qiskit-serverless.git\n```\n\n----------------------------------------\n\nTITLE: Uploading QiskitPattern\nDESCRIPTION: This code snippet demonstrates how to upload a QiskitPattern to the Qiskit Serverless platform using the `upload` method of the `ServerlessProvider`.\nSOURCE: https://github.com/qiskit/qiskit-serverless/blob/main/docs/migration/migration_from_qiskit_runtime_programs.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nserverless.upload(pattern)\n```\n\n----------------------------------------\n\nTITLE: Running QiskitPattern\nDESCRIPTION: This snippet shows how to run a QiskitPattern on the serverless platform. It specifies the pattern's title and any input arguments.  The arguments are passed as a dictionary, and the `run` method returns a job object.\nSOURCE: https://github.com/qiskit/qiskit-serverless/blob/main/docs/migration/migration_from_qiskit_runtime_programs.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\njob = serverless.run(\"migrated-pattern\", arguments={\"iterations\": 3})\njob\n```\n\n----------------------------------------\n\nTITLE: Running Docker Compose (Shell)\nDESCRIPTION: These commands navigate to the Qiskit Serverless directory and then execute Docker Compose to start the infrastructure. Requires Docker and Docker Compose to be installed. The `sudo` command might be necessary depending on your Docker setup.\nSOURCE: https://github.com/qiskit/qiskit-serverless/blob/main/README.md#_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\ncd qiskit-serverless/\nsudo docker compose up\n```\n\n----------------------------------------\n\nTITLE: Build Docker Image for Qiskit Serverless Gateway\nDESCRIPTION: This command builds a Docker image for the Qiskit Serverless Gateway. It uses the current directory as the build context and tags the image with the specified version. The resulting image is named `qiskit/qiskit-serverless/gateway:<VERSION>`.\nSOURCE: https://github.com/qiskit/qiskit-serverless/blob/main/gateway/README.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\ndocker build -t qiskit/qiskit-serverless/gateway:<VERSION> .\n```\n\n----------------------------------------\n\nTITLE: Configure ServerlessClient in Python\nDESCRIPTION: Configures the `ServerlessClient` with a token and host to communicate with the Qiskit Serverless provider. The token authenticates the client, and the host specifies the server address. Replace `<TOKEN>` and `<HOST>` with the appropriate values.\nSOURCE: https://github.com/qiskit/qiskit-serverless/blob/main/docs/deployment/client_configuration.rst#_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\nfrom qiskit_serverless import ServerlessClient\n\nclient = ServerlessClient(\n\t\t\ttoken=\"<TOKEN>\"\n\t\t\thost=\"<HOST>\",\n\t\t)\n```\n\n----------------------------------------\n\nTITLE: Initializing Serverless Client in Python\nDESCRIPTION: This snippet initializes the Qiskit Serverless client with a token and host. It retrieves the token and host from environment variables or uses default values if they are not set. It is necessary to connect with Qiskit Serverless platform.\nSOURCE: https://github.com/qiskit/qiskit-serverless/blob/main/docs/getting_started/experimental/file_download.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport os\nfrom qiskit_serverless import ServerlessClient, QiskitFunction\n\nserverless = ServerlessClient(\n    token=os.environ.get(\"GATEWAY_TOKEN\", \"awesome_token\"),\n    host=os.environ.get(\"GATEWAY_HOST\", \"http://localhost\"),\n    # If you are using the kubernetes approach the URL must be http://localhost\n)\nserverless\n```\n\n----------------------------------------\n\nTITLE: Running the Lint Environment with Tox\nDESCRIPTION: This command executes the 'lint' environment defined in tox.ini. This environment performs static analysis checks such as code formatting (Black), type checking (mypy), and code linting (pylint).\nSOURCE: https://github.com/qiskit/qiskit-serverless/blob/main/client/tests/README.md#_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\n$ tox -elint\n```\n\n----------------------------------------\n\nTITLE: Creating a New Branch from Main\nDESCRIPTION: This snippet fetches the latest changes from the upstream repository, rebases the local main branch, and then creates a new branch for working on a specific issue. The new branch is named according to the issue number and a short description. This ensures that the development work is isolated from the main branch and based on the latest code.\nSOURCE: https://github.com/qiskit/qiskit-serverless/blob/main/CONTRIBUTING.md#_snippet_5\n\nLANGUAGE: sh\nCODE:\n```\ngit checkout main\ngit fetch upstream\ngit rebase upstream main\ngit checkout -b issue-1234-new-feature\n```\n\n----------------------------------------\n\nTITLE: Running the Coverage Environment with Tox\nDESCRIPTION: This command runs the 'coverage' environment defined in tox.ini. This environment measures the code coverage of the tests and verifies that it meets a predefined threshold.\nSOURCE: https://github.com/qiskit/qiskit-serverless/blob/main/client/tests/README.md#_snippet_3\n\nLANGUAGE: sh\nCODE:\n```\n$ tox -ecoverage\n```\n\n----------------------------------------\n\nTITLE: Initializing ServerlessProvider\nDESCRIPTION: This code initializes the `ServerlessProvider` using a token and host. The token and host are typically retrieved from environment variables. This provider is used to interact with the Qiskit Serverless platform.\nSOURCE: https://github.com/qiskit/qiskit-serverless/blob/main/docs/migration/migration_from_qiskit_runtime_programs.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom qiskit_serverless import ServerlessProvider\nimport os\n\nserverless = ServerlessProvider(\n    token=os.environ.get(\"GATEWAY_TOKEN\", \"awesome_token\"),\n    host=os.environ.get(\"GATEWAY_HOST\", \"http://localhost:8000\"),\n)\nserverless\n```\n\n----------------------------------------\n\nTITLE: Qiskit Serverless Dependencies\nDESCRIPTION: This snippet defines the dependencies required for the Qiskit Serverless project, including their version constraints. These dependencies are crucial for the project's functionality and compatibility. The specified versions ensure a stable and predictable environment for the application.\nSOURCE: https://github.com/qiskit/qiskit-serverless/blob/main/client/requirements.txt#_snippet_0\n\nLANGUAGE: text\nCODE:\n```\nray[default,data]>=2.30, <3\nrequests>=2.32.2, <3\nimportlib-metadata>=5.2.0, <9\nqiskit>=1.4, <3\nqiskit-ibm-runtime>=0.29.0, <1\n# Make sure ray node and notebook node have the same version of cloudpickle\ncloudpickle==2.2.1\ntqdm>=4.66.3, <5\n# opentelemetry\nopentelemetry-api>=1.18.0, <2\nopentelemetry-sdk>=1.18.0, <2\nopentelemetry-exporter-otlp-proto-grpc>=1.18.0, <2\ns3fs>=2023.6.0\nopentelemetry-instrumentation-requests>=0.40b0\nipywidgets>=8.1.2, <9\nipython>=8.10.0, <9\nnumpy>=1.17, <3\n# Minimum version of pyarrow to support the major version from numpy\npyarrow>=16.0.0, <19\naiohttp>=3.10.0, <4\nzipp==3.19.1\ncertifi==2024.7.4\n```\n\n----------------------------------------\n\nTITLE: Running Tests for Specific Python Version with Tox\nDESCRIPTION: This command runs the tests specifically for Python version 3.11.  Other versions can be targeted by changing the py## suffix.\nSOURCE: https://github.com/qiskit/qiskit-serverless/blob/main/client/tests/README.md#_snippet_2\n\nLANGUAGE: sh\nCODE:\n```\n$ tox -epy311\n```\n\n----------------------------------------\n\nTITLE: Build Custom Qiskit Serverless Image using Docker\nDESCRIPTION: This command builds a Docker image named `test-local-provider-function` using the Dockerfile in the current directory. The `-t` flag specifies the tag for the image.\nSOURCE: https://github.com/qiskit/qiskit-serverless/blob/main/docs/deployment/example_custom_image_function.rst#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ndocker build -t test-local-provider-function .\n```\n\n----------------------------------------\n\nTITLE: Installing Helm Chart from Default Values\nDESCRIPTION: This command installs the Qiskit Serverless Helm chart using the default values defined in the `values.yaml` file. It creates a new namespace called `qiskit-serverless` if it doesn't already exist. This command deploys the Qiskit Serverless application to the Kubernetes cluster.\nSOURCE: https://github.com/qiskit/qiskit-serverless/blob/main/charts/qiskit-serverless/README.md#_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\nhelm -n qiskit-serverless install qiskit-serverless --create-namespace .\n```\n\n----------------------------------------\n\nTITLE: Dependencies List\nDESCRIPTION: This snippet lists the project's development dependencies, including pylint for linting, pytest for testing, black for code formatting, requests-mock for mocking HTTP requests, coverage for code coverage analysis, responses for mocking HTTP responses, and tox for managing virtual environments.\nSOURCE: https://github.com/qiskit/qiskit-serverless/blob/main/gateway/requirements-dev.txt#_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\npylint>=2.17.7\npytest>=6.2.5\npylint-django>=2.5.5\n# Black's formatting rules can change between major versions, so we use\n# the ~= specifier for it.\nblack~=22.12\nrequests-mock>=1.11.0\ncoverage>=5.5\nresponses>=0.23.3\ntox>=4.0.0\n```\n\n----------------------------------------\n\nTITLE: Configuring Runtime Service and Input Arguments\nDESCRIPTION: This snippet configures the Qiskit Runtime Service and sets up input arguments for the QAOA execution. It includes logic to conditionally use the runtime service based on the `USE_RUNTIME_SERVICE` flag and creates a dictionary containing all necessary input parameters.\nSOURCE: https://github.com/qiskit/qiskit-serverless/blob/main/docs/examples/02_qaoa.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nUSE_RUNTIME_SERVICE = False\n\nservice = None\nif USE_RUNTIME_SERVICE:\n    service = QiskitRuntimeService(\n        channel='ibm_quantum',\n        instance='ibm-q/open/main',\n        token='<insert your token>'\n    )\nbackend = None\n\ninput_arguments = {\n    \"initial_point\": None,\n    \"ansatz\": ansatz,\n    \"operator\": operator,\n    \"service\": service,\n    \"backend\": backend,\n}\ninput_arguments\n```\n\n----------------------------------------\n\nTITLE: Running Local Kubernetes Cluster using Tox\nDESCRIPTION: This shell command deploys a local Kubernetes cluster, likely using `tox` to manage the environment and dependencies. This sets up the environment for running Qiskit Functions on Kubernetes.\nSOURCE: https://github.com/qiskit/qiskit-serverless/blob/main/docs/deployment/deploying_custom_image_function.rst#_snippet_5\n\nLANGUAGE: shell\nCODE:\n```\ntox -e cluster-deploy\n```\n\n----------------------------------------\n\nTITLE: Running Docker Compose with Jupyter Profile (Shell)\nDESCRIPTION: This command navigates to the Qiskit Serverless directory and then executes Docker Compose with the jupyter profile to start the infrastructure. Requires Docker and Docker Compose to be installed. The `sudo` command might be necessary depending on your Docker setup.\nSOURCE: https://github.com/qiskit/qiskit-serverless/blob/main/README.md#_snippet_4\n\nLANGUAGE: shell\nCODE:\n```\n~/qiskit-serverless$ sudo docker compose --profile jupyter up\n```\n\n----------------------------------------\n\nTITLE: Pushing a Feature Branch to Origin\nDESCRIPTION: This snippet pushes a local feature branch to the remote origin repository, making the changes available for review and merging. This is the final step before submitting a pull request.\nSOURCE: https://github.com/qiskit/qiskit-serverless/blob/main/CONTRIBUTING.md#_snippet_10\n\nLANGUAGE: sh\nCODE:\n```\ngit push origin issue-1234-new-feature\n```\n\n----------------------------------------\n\nTITLE: Run Docker Compose\nDESCRIPTION: This command starts the services defined in the Docker Compose file.  It will run the ray-head service using the custom-built image.\nSOURCE: https://github.com/qiskit/qiskit-serverless/blob/main/docs/deployment/example_custom_image_function.rst#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\ndocker-compose up\n```\n\n----------------------------------------\n\nTITLE: Starting Colima with Resource Allocation (Shell)\nDESCRIPTION: This command starts Colima, a container runtime, with specified CPU, memory, and disk resources. This is recommended for Qiskit Serverless due to its high resource demands for distributed computing. Adjust the resource allocation as needed.\nSOURCE: https://github.com/qiskit/qiskit-serverless/blob/main/README.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\ncolima start --cpu 4 --memory 8 --disk 100\n```\n\n----------------------------------------\n\nTITLE: Loading Docker Image into Kind\nDESCRIPTION: This shell command loads the specified Docker image (`test-local-provider-function:latest`) into the Kind Kubernetes cluster. This step is necessary to make the image available within the Kubernetes environment.\nSOURCE: https://github.com/qiskit/qiskit-serverless/blob/main/docs/deployment/deploying_custom_image_function.rst#_snippet_6\n\nLANGUAGE: shell\nCODE:\n```\nkind load docker-image test-local-provider-function:latest\n```\n\n----------------------------------------\n\nTITLE: Checking Job Status\nDESCRIPTION: This snippet checks the status of the submitted job using the `job.status()` method. The returned status indicates the current state of the job (e.g., pending, running, completed, failed).\nSOURCE: https://github.com/qiskit/qiskit-serverless/blob/main/docs/examples/02_qaoa.ipynb#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\njob.status()\n```\n\n----------------------------------------\n\nTITLE: Modifying Docker Compose Definition\nDESCRIPTION: This YAML snippet shows how to modify the `docker-compose.yaml` file to use the newly built Docker image (`test-local-provider-function:latest`) for the `ray-head` service in a local development environment.\nSOURCE: https://github.com/qiskit/qiskit-serverless/blob/main/docs/deployment/deploying_custom_image_function.rst#_snippet_3\n\nLANGUAGE: yaml\nCODE:\n```\nservices:\n    ray-head:\n        container_name: ray-head\n        image: test-local-provider-function:latest\n```\n\n----------------------------------------\n\nTITLE: Initializing ServerlessClient\nDESCRIPTION: This snippet initializes the `ServerlessClient` with a token and host, retrieved from environment variables. It creates an instance of the client that will be used to interact with the serverless platform.\nSOURCE: https://github.com/qiskit/qiskit-serverless/blob/main/docs/examples/02_qaoa.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nserverless = ServerlessClient(\n    token=os.environ.get(\"GATEWAY_TOKEN\", \"awesome_token\"),\n    host=os.environ.get(\"GATEWAY_HOST\", \"http://localhost:8000\"),\n)\nserverless\n```\n\n----------------------------------------\n\nTITLE: Deploy to Local Kubernetes Cluster (Kind)\nDESCRIPTION: These commands deploy the custom Docker image to a local Kubernetes cluster using Kind. The first command `tox -e cluster-deploy` sets up the cluster. The second command `kind load docker-image test-local-provider-function:latest` loads the image into the Kind cluster.\nSOURCE: https://github.com/qiskit/qiskit-serverless/blob/main/docs/deployment/example_custom_image_function.rst#_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\ntox -e cluster-deploy\nkind load docker-image test-local-provider-function:latest\n```\n\n----------------------------------------\n\nTITLE: Retrieving Job Result\nDESCRIPTION: This snippet retrieves the result of the completed job.\nSOURCE: https://github.com/qiskit/qiskit-serverless/blob/main/docs/examples/01_vqe.ipynb#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\njob.result()\n```\n\n----------------------------------------\n\nTITLE: Create Python Virtual Environment (venv)\nDESCRIPTION: Creates a minimal Python virtual environment. This isolates the project's dependencies and avoids conflicts with system-level packages. The venv module is part of the Python standard library, so no extra dependencies need to be installed.\nSOURCE: https://github.com/qiskit/qiskit-serverless/blob/main/docs/deployment/local.rst#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\npython3 -m venv /path/to/virtual/environment\n```\n\n----------------------------------------\n\nTITLE: Checking Job Status\nDESCRIPTION: This code checks the status of the submitted job.\nSOURCE: https://github.com/qiskit/qiskit-serverless/blob/main/docs/examples/01_vqe.ipynb#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\njob.status()\n```\n\n----------------------------------------\n\nTITLE: Initializing ServerlessClient in Python\nDESCRIPTION: This snippet initializes a `ServerlessClient` from the `qiskit_serverless` library. It retrieves the token and host from environment variables, defaulting to 'awesome_token' and 'http://localhost:8000' respectively if these variables are not set.  This client is used to interact with the Qiskit Serverless platform.\nSOURCE: https://github.com/qiskit/qiskit-serverless/blob/main/docs/getting_started/basic/04_distributed_workloads.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom qiskit_serverless import ServerlessClient\nimport os\n\nclient = ServerlessClient(\n    token=os.environ.get(\"GATEWAY_TOKEN\", \"awesome_token\"),\n    host=os.environ.get(\"GATEWAY_HOST\", \"http://localhost:8000\"),\n    # If you are using the kubernetes approach the URL must be http://localhost\n)\n\nclient\n```\n\n----------------------------------------\n\nTITLE: Activate Python Virtual Environment\nDESCRIPTION: Activates the Python virtual environment created in the previous step. This ensures that subsequent commands use the Python interpreter and packages within the virtual environment. This step is necessary to properly isolate the project's environment.\nSOURCE: https://github.com/qiskit/qiskit-serverless/blob/main/docs/deployment/local.rst#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nsource /path/to/virtual/environment/bin/activate\n```\n\n----------------------------------------\n\nTITLE: Colima Setup for Docker and Kubernetes on macOS\nDESCRIPTION: This snippet installs and starts Colima, a tool for running Docker and Kubernetes container environments on macOS. It includes commands to install Colima and Docker using Brew, starts Colima with specified CPU and memory allocation, and checks its status.\nSOURCE: https://github.com/qiskit/qiskit-serverless/blob/main/CONTRIBUTING.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nbrew install colima\nbrew install docker\ncolima start --cpu 4 --memory 8\n```\n\n----------------------------------------\n\nTITLE: Run Docker Compose\nDESCRIPTION: Sets up the Qiskit Serverless infrastructure using Docker Compose. This command reads the docker-compose.yml file in the repository and starts the necessary containers.  Docker and Docker Compose must be installed and configured prior to running this command.\nSOURCE: https://github.com/qiskit/qiskit-serverless/blob/main/docs/deployment/local.rst#_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\n$ docker compose [--profile <PROFILE>] up\n```\n\n----------------------------------------\n\nTITLE: Running Tests with Tox\nDESCRIPTION: This snippet executes tests using tox for a specified Python environment (e.g., py311). It runs all configured tests and checks for code quality, helping to ensure that the code meets the project's standards and is free of errors.\nSOURCE: https://github.com/qiskit/qiskit-serverless/blob/main/CONTRIBUTING.md#_snippet_9\n\nLANGUAGE: sh\nCODE:\n```\ntox -epy311\n```\n\n----------------------------------------\n\nTITLE: Check Docker Version - Shell\nDESCRIPTION: This command checks if Docker is installed and displays its version.  It is a prerequisite for deploying Qiskit Serverless using Docker. The expected output is the Docker version number and build information.\nSOURCE: https://github.com/qiskit/qiskit-serverless/blob/main/docs/deployment/cloud.rst#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n$ docker --version\n```\n\n----------------------------------------\n\nTITLE: Cloning and Setting Up Git Repository\nDESCRIPTION: This snippet clones a forked repository, adds the upstream repository, configures push settings, updates the upstream, checks out the main branch, and sets up tracking. It assumes the user has forked the repository on GitHub. This is a standard procedure for setting up a local development environment to contribute to a Git project using the forking workflow.\nSOURCE: https://github.com/qiskit/qiskit-serverless/blob/main/CONTRIBUTING.md#_snippet_4\n\nLANGUAGE: sh\nCODE:\n```\n# After forking the repository in GitHub\ngit clone https://github.com/<your_username>/qiskit-serverless.git\ncd qiskit-serverless\ngit remote add upstream https://github.com/Qiskit/qiskit-serverless.git\ngit remote set-url --push upstream no_push\ngit remote update upstream\ngit checkout main\ngit branch -u upstream/main\ngit pull\n```\n\n----------------------------------------\n\nTITLE: Check Helm Version - Shell\nDESCRIPTION: This command verifies if Helm is installed and prints its version details.  Helm is required for deploying Qiskit Serverless to a Kubernetes cluster. The expected output includes the Helm version, Git commit, Git tree state, and Go version.\nSOURCE: https://github.com/qiskit/qiskit-serverless/blob/main/docs/deployment/cloud.rst#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\n$ helm version\n```\n\n----------------------------------------\n\nTITLE: Building Helm Dependencies\nDESCRIPTION: This command builds the Helm chart dependencies defined in the `Chart.yaml` file. It fetches the necessary charts and prepares them for deployment. This is a prerequisite step before installing the Qiskit Serverless chart.\nSOURCE: https://github.com/qiskit/qiskit-serverless/blob/main/charts/qiskit-serverless/README.md#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\nhelm dependency build\n```\n\n----------------------------------------\n\nTITLE: Docker Compose Up - Shell\nDESCRIPTION: This command deploys the Qiskit Serverless infrastructure using Docker Compose. It reads the `docker-compose.yml` file in the root directory of the project.  It's an easy option for local development. The command starts all services defined in the Docker Compose file.\nSOURCE: https://github.com/qiskit/qiskit-serverless/blob/main/docs/deployment/cloud.rst#_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\n$ docker compose up\n```\n\n----------------------------------------\n\nTITLE: Install qiskit_serverless via pip\nDESCRIPTION: This code snippet demonstrates how to install the `qiskit_serverless` package using pip. It first updates pip to the latest version, then installs the `qiskit_serverless` package.\nSOURCE: https://github.com/qiskit/qiskit-serverless/blob/main/docs/installation/index.rst#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\npip install --upgrade pip\npip install qiskit_serverless\n```\n\n----------------------------------------\n\nTITLE: Docker Compose Up Dev - Shell\nDESCRIPTION: This command deploys the Qiskit Serverless infrastructure using a development-specific Docker Compose configuration.  It reads the `docker-compose-dev.yaml` file. This is used when the `main` branch of the project is intended to be used.\nSOURCE: https://github.com/qiskit/qiskit-serverless/blob/main/docs/deployment/cloud.rst#_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\n$ docker compose -f docker-compose-dev.yaml up\n```\n\n----------------------------------------\n\nTITLE: Check Colima Status\nDESCRIPTION: This snippet checks the status of Colima to ensure it's running correctly, displaying information about its current state.\nSOURCE: https://github.com/qiskit/qiskit-serverless/blob/main/CONTRIBUTING.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ncolima status\n```\n\n----------------------------------------\n\nTITLE: Installing Qiskit Serverless (Shell)\nDESCRIPTION: This command installs the qiskit-serverless Python package using pip. It's recommended to run this command within a virtual environment to avoid conflicts with other Python packages. Requires pip and a Python environment.\nSOURCE: https://github.com/qiskit/qiskit-serverless/blob/main/README.md#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\npip install qiskit-serverless\n```\n\n----------------------------------------\n\nTITLE: Getting Job Logs\nDESCRIPTION: This snippet shows how to retrieve the logs of a Qiskit Serverless job using the `logs()` method of the job object. The logs typically contain output from print statements or logging messages within the pattern.\nSOURCE: https://github.com/qiskit/qiskit-serverless/blob/main/docs/migration/migration_from_qiskit_runtime_programs.ipynb#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nprint(job.logs())\n```\n\n----------------------------------------\n\nTITLE: Install Qiskit Serverless with Helm - Shell\nDESCRIPTION: This command installs Qiskit Serverless on a Kubernetes cluster using Helm.  It specifies the namespace and the chart to install from a remote release. Replace `<INSERT_YOUR_NAMESPACE>` with the desired Kubernetes namespace and `x.y.z` with the release version.\nSOURCE: https://github.com/qiskit/qiskit-serverless/blob/main/docs/deployment/cloud.rst#_snippet_4\n\nLANGUAGE: shell\nCODE:\n```\n$ helm -n <INSERT_YOUR_NAMESPACE> install qiskit-serverless --create-namespace https://github.com/Qiskit/qiskit-serverless/releases/download/vx.y.z/qiskit-serverless-x.y.z.tgz\n```\n\n----------------------------------------\n\nTITLE: List Container Images using nerdctl\nDESCRIPTION: This snippet lists all available container images managed by containerd, using the `nerdctl` CLI tool. This is useful for verifying the images that have been built or pulled.\nSOURCE: https://github.com/qiskit/qiskit-serverless/blob/main/CONTRIBUTING.md#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nnerdctl images\n```\n\n----------------------------------------\n\nTITLE: Get Kubernetes Services - Shell\nDESCRIPTION: This command retrieves a list of services running in the Kubernetes cluster using `kubectl`.  It helps identify the gateway service and its associated ClusterIP for port forwarding. The gateway service needs to be available.\nSOURCE: https://github.com/qiskit/qiskit-serverless/blob/main/docs/deployment/cloud.rst#_snippet_5\n\nLANGUAGE: shell\nCODE:\n```\n$ kubectl get service\n```\n\n----------------------------------------\n\nTITLE: Deploy Kubernetes Cluster with Kind\nDESCRIPTION: Deploys a Kubernetes cluster locally using Kind.  This initializes all the needed resources for testing. Requires `tox` to be installed.\nSOURCE: https://github.com/qiskit/qiskit-serverless/blob/main/docs/deployment/local.rst#_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\n$ tox -e cluster-deploy\n```\n\n----------------------------------------\n\nTITLE: Retrieving an Existing Qiskit Function\nDESCRIPTION: This snippet retrieves an existing Qiskit function from the serverless platform using its title. It depends on the `qiskit_serverless` library, using the client.\nSOURCE: https://github.com/qiskit/qiskit-serverless/blob/main/docs/getting_started/basic/02_arguments_and_results.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nmy_function = client.get(\"function-with-arguments\")\nmy_function\n```\n\n----------------------------------------\n\nTITLE: Kubernetes Port Forward - Shell\nDESCRIPTION: This command forwards a local port to a port on the gateway service in the Kubernetes cluster using `kubectl`.  It allows access to the Qiskit Serverless services from localhost. Replace 3333 with your desired local port.\nSOURCE: https://github.com/qiskit/qiskit-serverless/blob/main/docs/deployment/cloud.rst#_snippet_6\n\nLANGUAGE: shell\nCODE:\n```\n$  kubectl port-forward service/gateway  3333:8000\n```\n\n----------------------------------------\n\nTITLE: Commit Message Example\nDESCRIPTION: This snippet presents an example of a clear and concise commit message, including a summary and a brief explanation of the new feature. It illustrates best practices for writing informative commit messages.\nSOURCE: https://github.com/qiskit/qiskit-serverless/blob/main/CONTRIBUTING.md#_snippet_7\n\nLANGUAGE: null\nCODE:\n```\nAdd a new feature.\n\nThe new feature will provide the possibility to do something awesome.\n```\n\n----------------------------------------\n\nTITLE: Install Observability Package with Helm - Shell\nDESCRIPTION: This command installs an observability package on the Kubernetes cluster using Helm.  It specifies the namespace and the chart to install from a remote release. Replace `<INSERT_YOUR_NAMESPACE>` with the Kubernetes namespace used earlier. Also `x.y.z` with the release version.\nSOURCE: https://github.com/qiskit/qiskit-serverless/blob/main/docs/deployment/cloud.rst#_snippet_7\n\nLANGUAGE: shell\nCODE:\n```\n$ helm -n <INSERT_YOUR_NAMESPACE> install qs-observability  https://github.com/Qiskit/qiskit-serverless/releases/download/vx.y.z/qs-observability-x.y.z.tgz\n```\n\n----------------------------------------\n\nTITLE: Committing Changes\nDESCRIPTION: This snippet shows how to commit changes with a summary and notes or clarifications, ensuring clear communication about the modifications. It uses the `git commit` command.\nSOURCE: https://github.com/qiskit/qiskit-serverless/blob/main/CONTRIBUTING.md#_snippet_6\n\nLANGUAGE: sh\nCODE:\n```\ngit commit\n```\n\n----------------------------------------\n\nTITLE: Importing ServerlessClient\nDESCRIPTION: Imports the ServerlessClient from the qiskit_serverless library and the os module for environment variable access.\nSOURCE: https://github.com/qiskit/qiskit-serverless/blob/main/docs/examples/01_vqe.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom qiskit_serverless import ServerlessClient\nimport os\n```\n\n----------------------------------------\n\nTITLE: Create Python Virtual Environment (venv) - PowerShell\nDESCRIPTION: Creates a minimal Python virtual environment using PowerShell. This isolates the project's dependencies and avoids conflicts with system-level packages on Windows systems. The venv module is part of the Python standard library, so no extra dependencies need to be installed.\nSOURCE: https://github.com/qiskit/qiskit-serverless/blob/main/docs/deployment/local.rst#_snippet_2\n\nLANGUAGE: powershell\nCODE:\n```\npython3 -m venv c:\\path\\to\\virtual\\environment\n```\n\n----------------------------------------\n\nTITLE: Validating Terraform Configuration\nDESCRIPTION: This command validates the Terraform configuration files within the project. It checks for syntax errors and ensures that the configuration is valid and can be used to provision infrastructure.\nSOURCE: https://github.com/qiskit/qiskit-serverless/blob/main/CONTRIBUTING.md#_snippet_13\n\nLANGUAGE: shell\nCODE:\n```\nterraform validate\n```\n\n----------------------------------------\n\nTITLE: Activate Python Virtual Environment - PowerShell\nDESCRIPTION: Activates the Python virtual environment created in the previous step using PowerShell. This ensures that subsequent commands use the Python interpreter and packages within the virtual environment. This step is necessary to properly isolate the project's environment on Windows systems.\nSOURCE: https://github.com/qiskit/qiskit-serverless/blob/main/docs/deployment/local.rst#_snippet_3\n\nLANGUAGE: powershell\nCODE:\n```\nc:\\path\\to\\virtual\\environment\\Scripts\\Activate.ps1\n```\n\n----------------------------------------\n\nTITLE: LoadBalancer URL Retrieval (Shell)\nDESCRIPTION: These shell commands retrieve the application URL when using LoadBalancer as the service type. It waits for the LoadBalancer IP to be available and then extracts it to construct the URL.\nSOURCE: https://github.com/qiskit/qiskit-serverless/blob/main/charts/qiskit-serverless/charts/gateway/templates/NOTES.txt#_snippet_2\n\nLANGUAGE: Shell\nCODE:\n```\nexport SERVICE_IP=$(kubectl get svc --namespace {{ .Release.Namespace }} {{ include \"gateway.fullname\" . }} --template \"{{\"{{ range (index .status.loadBalancer.ingress 0) }}{{.}}{{ end }}\"}}\")\necho http://$SERVICE_IP:{{ .Values.service.port }}\n```\n\n----------------------------------------\n\nTITLE: Deploying Cluster via Tox (Shell)\nDESCRIPTION: This command executes the tox environment `cluster-deploy` to set up a Kubernetes cluster. Requires tox to be installed and configured, as well as a Kubernetes environment like Kind. The setup process can take several minutes.\nSOURCE: https://github.com/qiskit/qiskit-serverless/blob/main/README.md#_snippet_5\n\nLANGUAGE: shell\nCODE:\n```\ntox -e cluster-deploy\n```\n\n----------------------------------------\n\nTITLE: Linting Helm Charts\nDESCRIPTION: This command runs the linting process for Helm charts within the project. It verifies the structure and syntax of the Helm charts, ensuring they are valid and conform to best practices.\nSOURCE: https://github.com/qiskit/qiskit-serverless/blob/main/CONTRIBUTING.md#_snippet_12\n\nLANGUAGE: shell\nCODE:\n```\nhelm lint\n```\n\n----------------------------------------\n\nTITLE: Adding Helm Repositories\nDESCRIPTION: These commands add the Bitnami and Kuberay Helm repositories to your local Helm configuration. This allows you to access the charts needed for Qiskit Serverless deployment. This is a prerequisite step to install Qiskit Serverless.\nSOURCE: https://github.com/qiskit/qiskit-serverless/blob/main/charts/qiskit-serverless/README.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nhelm repo add bitnami https://charts.bitnami.com/bitnami\nhelm repo add kuberay https://ray-project.github.io/kuberay-helm\n```\n\n----------------------------------------\n\nTITLE: NodePort URL Retrieval (Shell)\nDESCRIPTION: These shell commands retrieve the application URL when using NodePort as the service type. It extracts the node port and IP address and constructs the URL.\nSOURCE: https://github.com/qiskit/qiskit-serverless/blob/main/charts/qiskit-serverless/charts/gateway/templates/NOTES.txt#_snippet_1\n\nLANGUAGE: Shell\nCODE:\n```\nexport NODE_PORT=$(kubectl get --namespace {{ .Release.Namespace }} -o jsonpath=\"{.spec.ports[0].nodePort}\" services {{ include \"gateway.fullname\" . }})\nexport NODE_IP=$(kubectl get nodes --namespace {{ .Release.Namespace }} -o jsonpath=\"{.items[0].status.addresses[0].address}\")\necho http://$NODE_IP:$NODE_PORT\n```\n\n----------------------------------------\n\nTITLE: List Running Containers using nerdctl\nDESCRIPTION: This snippet lists all running containers managed by containerd, using the `nerdctl` CLI tool. It provides a way to view the active containers in the Colima environment.\nSOURCE: https://github.com/qiskit/qiskit-serverless/blob/main/CONTRIBUTING.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nnerdctl ps -a\n```\n\n----------------------------------------\n\nTITLE: Importing ServerlessClient\nDESCRIPTION: Imports the `ServerlessClient` class from the `qiskit_serverless` library, and the `os` library.\nSOURCE: https://github.com/qiskit/qiskit-serverless/blob/main/docs/examples/02_qaoa.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom qiskit_serverless import ServerlessClient\nimport os\n```\n\n----------------------------------------\n\nTITLE: Cloning Qiskit Serverless Repository (Shell)\nDESCRIPTION: This command clones the Qiskit Serverless repository from GitHub to your local machine. This is a prerequisite for running the infrastructure setup scripts. Requires git to be installed.\nSOURCE: https://github.com/qiskit/qiskit-serverless/blob/main/README.md#_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\ngit clone https://github.com/Qiskit/qiskit-serverless.git\n```"
  }
]