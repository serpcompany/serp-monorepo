[
  {
    "owner": "tim-smart",
    "repo": "effect-io-ai",
    "content": "TITLE: Demonstrating Resource Management with Effect.using in TypeScript\nDESCRIPTION: This example shows how to use Effect.using to manage resource acquisition and release. It acquires a resource, uses it, and ensures it's released after use, even in case of failures or interruptions.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-using.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Console, Effect } from \"effect\"\n\nconst acquire = Console.log(\"Acquiring resource\").pipe(\n  Effect.as(1),\n  Effect.tap(Effect.addFinalizer(() => Console.log(\"Releasing resource\")))\n)\nconst use = (resource: number) => Console.log(`Using resource: ${resource}`)\n\nconst program = acquire.pipe(Effect.using(use))\n\nEffect.runFork(program)\n// Output:\n// Acquiring resource\n// Using resource: 1\n// Releasing resource\n```\n\n----------------------------------------\n\nTITLE: Using withConfigProvider with a Custom Configuration Provider in TypeScript\nDESCRIPTION: Demonstrates how to use the withConfigProvider function to execute an effect with a custom configuration provider. The example creates a provider from a Map and uses it to access a custom configuration value within an effect.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-withConfigProvider.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Config, ConfigProvider, Effect } from \"effect\"\n\nconst customProvider: ConfigProvider.ConfigProvider = ConfigProvider.fromMap(\n  new Map([[\"custom-key\", \"custom-value\"]])\n)\n\nconst program = Effect.withConfigProvider(customProvider)(\n  Effect.gen(function*() {\n    const value = yield* Config.string(\"custom-key\")\n    console.log(`Config value: ${value}`)\n  })\n)\n\nEffect.runPromise(program)\n// Output:\n// Config value: custom-value\n```\n\n----------------------------------------\n\nTITLE: Using acquireUseRelease to Manage Resource Lifecycle in TypeScript\nDESCRIPTION: This example demonstrates how to use Effect.acquireUseRelease to safely acquire, use, and release a resource. It creates a custom resource with a close method, defines the acquisition and release patterns, and ensures the resource is properly cleaned up regardless of execution outcome.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-acquireUseRelease.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Effect, Console } from \"effect\"\n\n// Define an interface for a resource\ninterface MyResource {\n  readonly contents: string\n  readonly close: () => Promise<void>\n}\n\n// Simulate resource acquisition\nconst getMyResource = (): Promise<MyResource> =>\n  Promise.resolve({\n    contents: \"lorem ipsum\",\n    close: () =>\n      new Promise((resolve) => {\n        console.log(\"Resource released\")\n        resolve()\n      })\n  })\n\n// Define how the resource is acquired\nconst acquire = Effect.tryPromise({\n  try: () =>\n    getMyResource().then((res) => {\n      console.log(\"Resource acquired\")\n      return res\n    }),\n  catch: () => new Error(\"getMyResourceError\")\n})\n\n// Define how the resource is released\nconst release = (res: MyResource) => Effect.promise(() => res.close())\n\nconst use = (res: MyResource) => Console.log(`content is ${res.contents}`)\n\n//      ┌─── Effect<void, Error, never>\n//      ▼\nconst program = Effect.acquireUseRelease(acquire, use, release)\n\nEffect.runPromise(program)\n// Output:\n// Resource acquired\n// content is lorem ipsum\n// Resource released\n```\n\n----------------------------------------\n\nTITLE: Creating Synchronous Side-Effect with Effect.sync in TypeScript\nDESCRIPTION: Demonstrates how to create an Effect that represents a synchronous side-effectful computation for logging a message. The example shows how to wrap a console.log operation in an Effect that returns void and has no errors or dependencies.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-sync.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Effect } from \"effect\"\n\nconst log = (message: string) =>\n  Effect.sync(() => {\n    console.log(message) // side effect\n  })\n\n//      ┌─── Effect<void, never, never>\n//      ▼\nconst program = log(\"Hello, World!\")\n```\n\n----------------------------------------\n\nTITLE: Combining Effects in Iterables with Effect.all in TypeScript\nDESCRIPTION: Example showing how to combine effects in an iterable using Effect.all. The function maps over an array to create effects and then combines them into a single effect that produces an array of results.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-all.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Effect, Console } from \"effect\"\n\nconst iterableOfEffects: Iterable<Effect.Effect<number>> = [1, 2, 3].map(\n  (n) => Effect.succeed(n).pipe(Effect.tap(Console.log))\n)\n\n//      ┌─── Effect<number[], never, never>\n//      ▼\nconst resultsAsArray = Effect.all(iterableOfEffects)\n\nEffect.runPromise(resultsAsArray).then(console.log)\n// Output:\n// 1\n// 2\n// 3\n// [ 1, 2, 3 ]\n```\n\n----------------------------------------\n\nTITLE: Defining Effect Interface in TypeScript\nDESCRIPTION: This code snippet defines the Effect interface, which represents a computation that can succeed or fail. It includes type parameters for the result (A), error (E), and environment (R), and extends several other interfaces and implements methods for unification and iteration.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-Effect.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface Effect<out A, out E = never, out R = never> extends Effect.Variance<A, E, R>, Pipeable {\n  readonly [Unify.typeSymbol]?: unknown\n  readonly [Unify.unifySymbol]?: EffectUnify<this>\n  readonly [Unify.ignoreSymbol]?: EffectUnifyIgnore\n  [Symbol.iterator](): EffectGenerator<Effect<A, E, R>>\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Stream from an Effect Producing Iterable\nDESCRIPTION: This code snippet demonstrates how to create a stream from an effect that produces an iterable of user data. It imports necessary components from the 'effect' module and sets up a database context for getting user data. The resulting stream is then run and logged, collecting the emitted values into a Chunk.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-fromIterableEffect.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Context, Effect, Stream } from \"effect\"\n\nclass Database extends Context.Tag(\"Database\")<\n  Database,\n  { readonly getUsers: Effect.Effect<Array<string>> }\n>() {}\n\nconst getUsers = Database.pipe(Effect.andThen((_) => _.getUsers))\n\nconst stream = Stream.fromIterableEffect(getUsers)\n\nEffect.runPromise(\n  Stream.runCollect(stream.pipe(Stream.provideService(Database, { getUsers: Effect.succeed([\"user1\", \"user2\"]) })))\n).then(console.log)\n// { _id: 'Chunk', values: [ 'user1', 'user2' ] }\n```\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const fromIterableEffect: <A, E, R>(effect: Effect.Effect<Iterable<A>, E, R>) => Stream<A, E, R>\n```\n\n----------------------------------------\n\nTITLE: Using Effect.gen for Asynchronous Control Flow in TypeScript\nDESCRIPTION: This example demonstrates how to use Effect.gen with generator functions to handle asynchronous tasks with error handling. It shows calculating a final transaction amount by fetching values asynchronously, applying a discount, and adding a service charge.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-gen.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Effect } from \"effect\"\n\nconst addServiceCharge = (amount: number) => amount + 1\n\nconst applyDiscount = (\n  total: number,\n  discountRate: number\n): Effect.Effect<number, Error> =>\n  discountRate === 0\n    ? Effect.fail(new Error(\"Discount rate cannot be zero\"))\n    : Effect.succeed(total - (total * discountRate) / 100)\n\nconst fetchTransactionAmount = Effect.promise(() => Promise.resolve(100))\n\nconst fetchDiscountRate = Effect.promise(() => Promise.resolve(5))\n\nexport const program = Effect.gen(function* () {\n  const transactionAmount = yield* fetchTransactionAmount\n  const discountRate = yield* fetchDiscountRate\n  const discountedAmount = yield* applyDiscount(\n    transactionAmount,\n    discountRate\n  )\n  const finalAmount = addServiceCharge(discountedAmount)\n  return `Final amount to charge: ${finalAmount}`\n})\n```\n\n----------------------------------------\n\nTITLE: Using Effect.bindAll for Concurrent Effect Execution in TypeScript\nDESCRIPTION: Example demonstrating how to use Effect.bindAll to concurrently execute multiple effects and combine their results in a Do notation pipeline. Shows handling of both successful and failed effects using the either mode.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-bindAll.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { Effect, Either, pipe } from \"effect\"\n\nconst result = pipe(\n  Effect.Do,\n  Effect.bind(\"x\", () => Effect.succeed(2)),\n  Effect.bindAll(({ x }) => ({\n    a: Effect.succeed(x),\n    b: Effect.fail(\"oops\"),\n  }), { concurrency: 2, mode: \"either\" })\n)\nassert.deepStrictEqual(Effect.runSync(result), { x: 2, a: Either.right(2), b: Either.left(\"oops\") })\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Effect.sleep Usage in TypeScript\nDESCRIPTION: This example shows how to use Effect.sleep to pause execution for 3 seconds within an Effect generator function. It logs messages before and after the sleep period.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-sleep.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Effect } from \"effect\"\n\nconst program = Effect.gen(function*() {\n  console.log(\"Starting task...\")\n  yield* Effect.sleep(\"3 seconds\") // Waits for 3 seconds\n  console.log(\"Task completed!\")\n})\n\nEffect.runFork(program)\n// Output:\n// Starting task...\n// Task completed!\n```\n\n----------------------------------------\n\nTITLE: Effect.Do Function Signature in TypeScript\nDESCRIPTION: The type signature for the Effect.Do function, which serves as the starting point for do notation. It returns an Effect with an empty context object and no failure or success types.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-Do.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const Do: Effect<{}, never, never>\n```\n\n----------------------------------------\n\nTITLE: Handling Different Failure Causes with Side Effects using Effect.matchCauseEffect\nDESCRIPTION: This example demonstrates how to use Effect.matchCauseEffect to handle different types of failures (Fail, Die, Interrupt) and perform side effects like logging based on the failure cause. It also shows how to handle successful outcomes.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-matchCauseEffect.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Effect, Console } from \"effect\"\n\nconst task: Effect.Effect<number, Error> = Effect.die(\"Uh oh!\")\n\nconst program = Effect.matchCauseEffect(task, {\n  onFailure: (cause) => {\n    switch (cause._tag) {\n      case \"Fail\":\n        // Handle standard failure with a logged message\n        return Console.log(`Fail: ${cause.error.message}`)\n      case \"Die\":\n        // Handle defects (unexpected errors) by logging the defect\n        return Console.log(`Die: ${cause.defect}`)\n      case \"Interrupt\":\n        // Handle interruption and log the fiberId that was interrupted\n        return Console.log(`${cause.fiberId} interrupted!`)\n    }\n    // Fallback for other causes\n    return Console.log(\"failed due to other causes\")\n  },\n  onSuccess: (value) =>\n    // Log success if the task completes successfully\n    Console.log(`succeeded with ${value} value`)\n})\n\nEffect.runPromise(program)\n// Output: \"Die: Uh oh!\"\n```\n\n----------------------------------------\n\nTITLE: Type Signature of Effect.Service in TypeScript\nDESCRIPTION: This code snippet shows the complex type signature of the Effect.Service function. It defines the structure and options for creating services, including different implementation methods (scoped, effect, sync, succeed) and additional configuration options.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-Service.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const Service: <Self = never>() => [Self] extends [never] ? MissingSelfGeneric : { <const Key extends string, const Make extends { readonly scoped: Effect<Service.AllowedType<Key, Make>, any, any>; readonly dependencies?: ReadonlyArray<Layer.Layer.Any>; readonly accessors?: boolean; readonly ಠ_ಠ: never; } | { readonly effect: Effect<Service.AllowedType<Key, Make>, any, any>; readonly dependencies?: ReadonlyArray<Layer.Layer.Any>; readonly accessors?: boolean; readonly ಠ_ಠ: never; } | { readonly sync: LazyArg<Service.AllowedType<Key, Make>>; readonly dependencies?: ReadonlyArray<Layer.Layer.Any>; readonly accessors?: boolean; readonly ಠ_ಠ: never; } | { readonly succeed: Service.AllowedType<Key, Make>; readonly dependencies?: ReadonlyArray<Layer.Layer.Any>; readonly accessors?: boolean; readonly ಠ_ಠ: never; }>(key: Key, make: Make): Service.Class<Self, Key, Make>; <const Key extends string, const Make extends NoExcessProperties<{ readonly scoped: Effect<Service.AllowedType<Key, Make>, any, any>; readonly dependencies?: ReadonlyArray<Layer.Layer.Any>; readonly accessors?: boolean; }, Make>>(key: Key, make: Make): Service.Class<Self, Key, Make>; <const Key extends string, const Make extends NoExcessProperties<{ readonly effect: Effect<Service.AllowedType<Key, Make>, any, any>; readonly dependencies?: ReadonlyArray<Layer.Layer.Any>; readonly accessors?: boolean; }, Make>>(key: Key, make: Make): Service.Class<Self, Key, Make>; <const Key extends string, const Make extends NoExcessProperties<{ readonly sync: LazyArg<Service.AllowedType<Key, Make>>; readonly dependencies?: ReadonlyArray<Layer.Layer.Any>; readonly accessors?: boolean; }, Make>>(key: Key, make: Make): Service.Class<Self, Key, Make>; <const Key extends string, const Make extends NoExcessProperties<{ readonly succeed: Service.AllowedType<Key, Make>; readonly dependencies?: ReadonlyArray<Layer.Layer.Any>; readonly accessors?: boolean; }, Make>>(key: Key, make: Make): Service.Class<Self, Key, Make>; }\n```\n\n----------------------------------------\n\nTITLE: Reducing Multiple Effects to a Single Result in TypeScript\nDESCRIPTION: Example demonstrating how to use Effect.reduceEffect to process multiple order effects and combine their results into a single value. This example shows the sequential processing of orders with different delays and accumulating their prices.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-reduceEffect.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Console, Effect } from \"effect\"\n\nconst processOrder = (id: number) =>\n  Effect.succeed({ id, price: 100 * id })\n    .pipe(Effect.tap(() => Console.log(`Order ${id} processed`)), Effect.delay(500 - (id * 100)))\n\nconst program = Effect.reduceEffect(\n  [processOrder(1), processOrder(2), processOrder(3), processOrder(4)],\n  Effect.succeed(0),\n  (acc, order, i) => acc + order.price\n)\n\nEffect.runPromise(program).then(console.log)\n// Output:\n// Order 1 processed\n// Order 2 processed\n// Order 3 processed\n// Order 4 processed\n// 1000\n```\n\n----------------------------------------\n\nTITLE: Using Effect.provideService to Provide a Random Number Generator Service in TypeScript\nDESCRIPTION: This example demonstrates how to define a service tag, use the service in an effect, and provide a concrete implementation. It shows the complete workflow from service definition to execution with Effect.provideService.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-provideService.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Effect, Context } from \"effect\"\n\n// Declaring a tag for a service that generates random numbers\nclass Random extends Context.Tag(\"MyRandomService\")<\n  Random,\n  { readonly next: Effect.Effect<number> }\n>() {}\n\n// Using the service\nconst program = Effect.gen(function* () {\n  const random = yield* Random\n  const randomNumber = yield* random.next\n  console.log(`random number: ${randomNumber}`)\n})\n\n// Providing the implementation\n//\n//      ┌─── Effect<void, never, never>\n//      ▼\nconst runnable = Effect.provideService(program, Random, {\n  next: Effect.sync(() => Math.random())\n})\n\n// Run successfully\nEffect.runPromise(runnable)\n// Example Output:\n// random number: 0.8241872233134417\n```\n\n----------------------------------------\n\nTITLE: Creating HashSets with Custom Equality Using HashSet.make in TypeScript\nDESCRIPTION: This example demonstrates how to construct a HashSet with the HashSet.make function using custom objects that implement Equal and Hash interfaces. It shows how duplicate values are handled and compares different construction methods for equality.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/HashSet-make.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Equal, Hash, HashSet, pipe } from \"effect\"\nimport assert from \"node:assert/strict\"\n\nclass Character implements Equal.Equal {\n  readonly name: string\n  readonly trait: string\n\n  constructor(name: string, trait: string) {\n    this.name = name\n    this.trait = trait\n  }\n\n  // Define equality based on name, and trait\n  [Equal.symbol](that: Equal.Equal): boolean {\n    if (that instanceof Character) {\n      return (\n        Equal.equals(this.name, that.name) &&\n        Equal.equals(this.trait, that.trait)\n      )\n    }\n    return false\n  }\n\n  // Generate a hash code based on the sum of the character's name and trait\n  [Hash.symbol](): number {\n    return Hash.hash(this.name + this.trait)\n  }\n\n  static readonly of = (name: string, trait: string): Character => {\n    return new Character(name, trait)\n  }\n}\n\nassert.strictEqual(\n  Equal.equals(\n    HashSet.make(\n      Character.of(\"Alice\", \"Curious\"),\n      Character.of(\"Alice\", \"Curious\"),\n      Character.of(\"White Rabbit\", \"Always late\"),\n      Character.of(\"Mad Hatter\", \"Tea enthusiast\")\n    ),\n    // Is the same as adding each character to an empty set\n    pipe(\n      HashSet.empty(),\n      HashSet.add(Character.of(\"Alice\", \"Curious\")),\n      HashSet.add(Character.of(\"Alice\", \"Curious\")), // Alice tried to attend twice!\n      HashSet.add(Character.of(\"White Rabbit\", \"Always late\")),\n      HashSet.add(Character.of(\"Mad Hatter\", \"Tea enthusiast\"))\n    )\n  ),\n  true,\n  \"`HashSet.make` and `HashSet.empty() + HashSet.add()` should be equal\"\n)\n\nassert.strictEqual(\n  Equal.equals(\n    HashSet.make(\n      Character.of(\"Alice\", \"Curious\"),\n      Character.of(\"Alice\", \"Curious\"),\n      Character.of(\"White Rabbit\", \"Always late\"),\n      Character.of(\"Mad Hatter\", \"Tea enthusiast\")\n    ),\n    HashSet.fromIterable([\n      Character.of(\"Alice\", \"Curious\"),\n      Character.of(\"Alice\", \"Curious\"),\n      Character.of(\"White Rabbit\", \"Always late\"),\n      Character.of(\"Mad Hatter\", \"Tea enthusiast\")\n    ])\n  ),\n  true,\n  \"`HashSet.make` and `HashSet.fromIterable` should be equal\"\n)\n```\n\n----------------------------------------\n\nTITLE: Effect.suspend Function Signature in TypeScript\nDESCRIPTION: This code snippet shows the TypeScript signature of the Effect.suspend function, which takes a lazy argument that returns an Effect and produces a new Effect.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-suspend.md#2025-04-11_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const suspend: <A, E, R>(effect: LazyArg<Effect<A, E, R>>) => Effect<A, E, R>\n```\n\n----------------------------------------\n\nTITLE: Applying Discount to Transaction Using Effect.flatMap\nDESCRIPTION: Example that demonstrates a practical application of Effect.flatMap by chaining a simulated database query with a discount calculation. Shows how to safely handle potential errors while maintaining a clean sequential flow.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-flatMap.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { pipe, Effect } from \"effect\"\n\n// Function to apply a discount safely to a transaction amount\nconst applyDiscount = (\n  total: number,\n  discountRate: number\n): Effect.Effect<number, Error> =>\n  discountRate === 0\n    ? Effect.fail(new Error(\"Discount rate cannot be zero\"))\n    : Effect.succeed(total - (total * discountRate) / 100)\n\n// Simulated asynchronous task to fetch a transaction amount from database\nconst fetchTransactionAmount = Effect.promise(() => Promise.resolve(100))\n\n// Chaining the fetch and discount application using `flatMap`\nconst finalAmount = pipe(\n  fetchTransactionAmount,\n  Effect.flatMap((amount) => applyDiscount(amount, 5))\n)\n\nEffect.runPromise(finalAmount).then(console.log)\n// Output: 95\n```\n\n----------------------------------------\n\nTITLE: Retrieving Record Value with Effect's Record.get in Typescript\nDESCRIPTION: This code snippet demonstrates how to use the `Record.get` function from the Effect library to retrieve a value from a record by a given key. It uses Node.js's assert module to verify the retrieved value against expected results. The `Option` type is utilized to handle scenarios where the key might not be present in the record.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Record-get.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { Record as R, Option } from \"effect\"\n\nconst person: Record<string, unknown> = { name: \"John Doe\", age: 35 }\n\nassert.deepStrictEqual(R.get(person, \"name\"), Option.some(\"John Doe\"))\nassert.deepStrictEqual(R.get(person, \"email\"), Option.none())\n```\n\n----------------------------------------\n\nTITLE: Racing Two Successful Effects in TypeScript\nDESCRIPTION: Demonstrates racing two effects that both succeed, with the faster one completing and the slower one being interrupted.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-race.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Effect, Console } from \"effect\"\n\nconst task1 = Effect.succeed(\"task1\").pipe(\n  Effect.delay(\"200 millis\"),\n  Effect.tap(Console.log(\"task1 done\")),\n  Effect.onInterrupt(() => Console.log(\"task1 interrupted\"))\n)\nconst task2 = Effect.succeed(\"task2\").pipe(\n  Effect.delay(\"100 millis\"),\n  Effect.tap(Console.log(\"task2 done\")),\n  Effect.onInterrupt(() => Console.log(\"task2 interrupted\"))\n)\n\nconst program = Effect.race(task1, task2)\n\nEffect.runFork(program)\n// Output:\n// task1 done\n// task2 interrupted\n```\n\n----------------------------------------\n\nTITLE: Stream.zip signature in Effect\nDESCRIPTION: Presents the type signature of the `Stream.zip` function, illustrating its generic nature and the types involved in zipping two streams together. The signature shows how it accepts two streams with potentially different element types, error types, and environment types, and returns a new stream with a tuple of the element types, a union of the error types, and a union of the environment types.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-zip.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\ndeclare const zip: { <A2, E2, R2>(that: Stream<A2, E2, R2>): <A, E, R>(self: Stream<A, E, R>) => Stream<[A, A2], E2 | E, R2 | R>; <A, E, R, A2, E2, R2>(self: Stream<A, E, R>, that: Stream<A2, E2, R2>): Stream<[A, A2], E | E2, R | R2>; }\n```\n```\n\n----------------------------------------\n\nTITLE: Using Effect.orDieWith to Customize Fiber Termination Error in TypeScript\nDESCRIPTION: This example demonstrates how to use Effect.orDieWith to handle a division by zero error, converting it into a custom fiber termination error. It shows the creation of a divide function and its usage with orDieWith to provide a more detailed error message.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-orDieWith.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Effect } from \"effect\"\n\nconst divide = (a: number, b: number) =>\n  b === 0\n    ? Effect.fail(new Error(\"Cannot divide by zero\"))\n    : Effect.succeed(a / b)\n\n//      ┌─── Effect<number, never, never>\n//      ▼\nconst program = Effect.orDieWith(\n  divide(1, 0),\n  (error) => new Error(`defect: ${error.message}`)\n)\n\nEffect.runPromise(program).catch(console.error)\n// Output:\n// (FiberFailure) Error: defect: Cannot divide by zero\n//   ...stack trace...\n```\n\n----------------------------------------\n\nTITLE: Zipping streams with Stream.zip in Effect\nDESCRIPTION: Demonstrates how to use `Stream.zip` to combine two streams into a single stream of tuples. The resulting stream will contain tuples of elements from both input streams, and it will end when either of the input streams ends. The example shows the stream being created, run, and the collected result printed to the console.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-zip.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nimport { Effect, Stream } from \"effect\"\n\n// We create two streams and zip them together.\nconst stream = Stream.zip(\n  Stream.make(1, 2, 3, 4, 5, 6),\n  Stream.make(\"a\", \"b\", \"c\")\n)\n\nEffect.runPromise(Stream.runCollect(stream)).then(console.log)\n// { _id: 'Chunk', values: [ [ 1, 'a' ], [ 2, 'b' ], [ 3, 'c' ] ] }\n```\n```\n\n----------------------------------------\n\nTITLE: Using Effect.makeLatch to Create and Control a Latch in TypeScript\nDESCRIPTION: Demonstrates how to create a latch with Effect.makeLatch, use it to control when an operation executes, and open the latch to trigger the operation. The example showcases creating a latch in the closed state, forking a fiber that waits for the latch to open, and then opening the latch after a delay.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-makeLatch.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Console, Effect } from \"effect\"\n\nconst program = Effect.gen(function*() {\n  // Create a latch, starting in the closed state\n  const latch = yield* Effect.makeLatch(false)\n\n  // Fork a fiber that logs \"open sesame\" when the latch is opened\n  const fiber = yield* Console.log(\"open sesame\").pipe(\n    latch.whenOpen,\n    Effect.fork\n  )\n\n  yield* Effect.sleep(\"1 second\")\n\n  // Open the latch\n  yield* latch.open\n  yield* fiber.await\n})\n\nEffect.runFork(program)\n// Output: open sesame (after 1 second)\n```\n\n----------------------------------------\n\nTITLE: Conditional Effect Execution with Effect.when in TypeScript\nDESCRIPTION: Example showing how to use Effect.when to conditionally execute an effect based on a boolean condition. The function validateWeightOption runs a weight validation only if the weight is non-negative, returning the result wrapped in an Option.some or Option.none appropriately.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-when.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Effect, Option } from \"effect\"\n\nconst validateWeightOption = (\n  weight: number\n): Effect.Effect<Option.Option<number>> =>\n  // Conditionally execute the effect if the weight is non-negative\n  Effect.succeed(weight).pipe(Effect.when(() => weight >= 0))\n\n// Run with a valid weight\nEffect.runPromise(validateWeightOption(100)).then(console.log)\n// Output:\n// {\n//   _id: \"Option\",\n//   _tag: \"Some\",\n//   value: 100\n// }\n\n// Run with an invalid weight\nEffect.runPromise(validateWeightOption(-5)).then(console.log)\n// Output:\n// {\n//   _id: \"Option\",\n//   _tag: \"None\"\n// }\n```\n\n----------------------------------------\n\nTITLE: Using Effect.allWith for Concurrent Task Execution in TypeScript\nDESCRIPTION: Demonstrates how to use Effect.allWith to combine and execute multiple effects concurrently. The example shows two tasks with different delays being executed with a concurrency level of 2.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-allWith.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Effect, pipe } from \"effect\"\n\nconst task1 = Effect.succeed(1).pipe(\n  Effect.delay(\"200 millis\"),\n  Effect.tap(Effect.log(\"task1 done\"))\n)\n\nconst task2 = Effect.succeed(\"hello\").pipe(\n  Effect.delay(\"100 millis\"),\n  Effect.tap(Effect.log(\"task2 done\"))\n)\n\nconst program = pipe(\n  [task1, task2],\n  // Run both effects concurrently using the concurrent option\n  Effect.allWith({ concurrency: 2 })\n)\n\nEffect.runPromise(program).then(console.log)\n// Output:\n// timestamp=... level=INFO fiber=#3 message=\"task2 done\"\n// timestamp=... level=INFO fiber=#2 message=\"task1 done\"\n// [ 1, 'hello' ]\n```\n\n----------------------------------------\n\nTITLE: Using Effect.Do for Declarative Programming in TypeScript\nDESCRIPTION: This example demonstrates how to use Effect.Do to write code in a declarative style. It shows binding variables to Effect values, accumulating multiple bindings, and using 'let' to define derived values.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-Do.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { Effect, pipe } from \"effect\"\n\nconst result = pipe(\n  Effect.Do,\n  Effect.bind(\"x\", () => Effect.succeed(2)),\n  Effect.bind(\"y\", () => Effect.succeed(3)),\n  Effect.let(\"sum\", ({ x, y }) => x + y)\n)\nassert.deepStrictEqual(Effect.runSync(result), { x: 2, y: 3, sum: 5 })\n```\n\n----------------------------------------\n\nTITLE: Partitioning a Stream into Even and Odd Numbers using Stream.partition in TypeScript\nDESCRIPTION: This example demonstrates how to use Stream.partition to split a stream of numbers from 1 to 9 into two substreams: one for even numbers and one for odd numbers. The function uses a predicate to determine if a number is even, and the resulting substreams are collected and logged.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-partition.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Effect, Stream } from \"effect\"\n\nconst partition = Stream.range(1, 9).pipe(\n  Stream.partition((n) => n % 2 === 0, { bufferSize: 5 })\n)\n\nconst program = Effect.scoped(\n  Effect.gen(function*() {\n    const [odds, evens] = yield* partition\n    console.log(yield* Stream.runCollect(odds))\n    console.log(yield* Stream.runCollect(evens))\n  })\n)\n\nEffect.runPromise(program)\n// { _id: 'Chunk', values: [ 1, 3, 5, 7, 9 ] }\n// { _id: 'Chunk', values: [ 2, 4, 6, 8 ] }\n```\n\n----------------------------------------\n\nTITLE: Handling Success and Failure with Side Effects in Effect (TypeScript)\nDESCRIPTION: Demonstrates how to use Effect.matchEffect to handle both success and failure cases of an effect, allowing for additional side effects like logging. It shows examples with both successful and failing effects.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-matchEffect.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Effect } from \"effect\"\n\nconst success: Effect.Effect<number, Error> = Effect.succeed(42)\nconst failure: Effect.Effect<number, Error> = Effect.fail(\n  new Error(\"Uh oh!\")\n)\n\nconst program1 = Effect.matchEffect(success, {\n  onFailure: (error) =>\n    Effect.succeed(`failure: ${error.message}`).pipe(\n      Effect.tap(Effect.log)\n    ),\n  onSuccess: (value) =>\n    Effect.succeed(`success: ${value}`).pipe(Effect.tap(Effect.log))\n})\n\nconsole.log(Effect.runSync(program1))\n// Output:\n// timestamp=... level=INFO fiber=#0 message=\"success: 42\"\n// success: 42\n\nconst program2 = Effect.matchEffect(failure, {\n  onFailure: (error) =>\n    Effect.succeed(`failure: ${error.message}`).pipe(\n      Effect.tap(Effect.log)\n    ),\n  onSuccess: (value) =>\n    Effect.succeed(`success: ${value}`).pipe(Effect.tap(Effect.log))\n})\n\nconsole.log(Effect.runSync(program2))\n// Output:\n// timestamp=... level=INFO fiber=#1 message=\"failure: Uh oh!\"\n// failure: Uh oh!\n```\n\n----------------------------------------\n\nTITLE: Implementing Repeatable Effects with Custom Error Handling in TypeScript\nDESCRIPTION: This example demonstrates how to use Effect.repeatOrElse to retry an operation with a custom schedule. It shows an async effect that fails after the second attempt, a schedule that allows two repetitions with delays, and a custom error handler that counts repetitions.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-repeatOrElse.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Effect, Schedule } from \"effect\"\n\nlet count = 0\n\n// Define an async effect that simulates an action with possible failures\nconst action = Effect.async<string, string>((resume) => {\n  if (count > 1) {\n    console.log(\"failure\")\n    resume(Effect.fail(\"Uh oh!\"))\n  } else {\n    count++\n    console.log(\"success\")\n    resume(Effect.succeed(\"yay!\"))\n  }\n})\n\nconst policy = Schedule.addDelay(\n  Schedule.recurs(2), // Repeat for a maximum of 2 times\n  () => \"100 millis\" // Add a delay of 100 milliseconds between repetitions\n)\n\nconst program = Effect.repeatOrElse(action, policy, () =>\n  Effect.sync(() => {\n    console.log(\"orElse\")\n    return count - 1\n  })\n)\n\nEffect.runPromise(program).then((n) => console.log(`repetitions: ${n}`))\n\n```\n\n----------------------------------------\n\nTITLE: Implementing flatMap Function for Array in TypeScript\nDESCRIPTION: Declaration of the flatMap function that applies a mapping function to each element in an array and concatenates the results. It supports both regular arrays and non-empty arrays, with appropriate type signatures for each case.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Array-flatMap.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const flatMap: { <S extends ReadonlyArray<any>, T extends ReadonlyArray<any>>(f: (a: ReadonlyArray.Infer<S>, i: number) => T): (self: S) => ReadonlyArray.AndNonEmpty<S, T, ReadonlyArray.Infer<T>>; <A, B>(self: NonEmptyReadonlyArray<A>, f: (a: A, i: number) => NonEmptyReadonlyArray<B>): NonEmptyArray<B>; <A, B>(self: ReadonlyArray<A>, f: (a: A, i: number) => ReadonlyArray<B>): Array<B>; }\n```\n\n----------------------------------------\n\nTITLE: Getting Current Time with DateTime.now in TypeScript\nDESCRIPTION: Demonstrates how to retrieve the current time using the Clock service and convert it to a DateTime object. This example uses the Effect generator syntax to obtain the current time in UTC format.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/DateTime-now.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { DateTime, Effect } from \"effect\"\n\nEffect.gen(function* () {\n  const now = yield* DateTime.now\n})\n```\n\n----------------------------------------\n\nTITLE: Using Stream.onEnd in TypeScript with Effect IO\nDESCRIPTION: Demonstrates how to use Stream.onEnd to add an effect at the end of a stream. The example creates a stream, maps values, logs intermediate results, and executes a final effect when the stream ends.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-onEnd.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Console, Effect, Stream } from \"effect\"\n\nconst stream = Stream.make(1, 2, 3).pipe(\n  Stream.map((n) => n * 2),\n  Stream.tap((n) => Console.log(`after mapping: ${n}`)),\n  Stream.onEnd(Console.log(\"Stream ended\"))\n)\n\nEffect.runPromise(Stream.runCollect(stream)).then(console.log)\n// after mapping: 2\n// after mapping: 4\n// after mapping: 6\n// Stream ended\n// { _id: 'Chunk', values: [ 2, 4, 6 ] }\n```\n\n----------------------------------------\n\nTITLE: Using Effect.cached to Cache Expensive Operations in TypeScript\nDESCRIPTION: This example demonstrates how to use Effect.cached to prevent repeated execution of expensive operations. It compares non-cached execution (which runs the expensive task twice) with cached execution (where the task runs once and its result is reused).\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-cached.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Effect, Console } from \"effect\"\n\nlet i = 1\nconst expensiveTask = Effect.promise<string>(() => {\n  console.log(\"expensive task...\")\n  return new Promise((resolve) => {\n    setTimeout(() => {\n      resolve(`result ${i++}`)\n    }, 100)\n  })\n})\n\nconst program = Effect.gen(function* () {\n  console.log(\"non-cached version:\")\n  yield* expensiveTask.pipe(Effect.andThen(Console.log))\n  yield* expensiveTask.pipe(Effect.andThen(Console.log))\n  console.log(\"cached version:\")\n  const cached = yield* Effect.cached(expensiveTask)\n  yield* cached.pipe(Effect.andThen(Console.log))\n  yield* cached.pipe(Effect.andThen(Console.log))\n})\n\nEffect.runFork(program)\n// Output:\n// non-cached version:\n// expensive task...\n// result 1\n// expensive task...\n// result 2\n// cached version:\n// expensive task...\n// result 3\n// result 3\n```\n\n----------------------------------------\n\nTITLE: Handling Errors with Effect.catchAll in TypeScript\nDESCRIPTION: This example demonstrates how to use Effect.catchAll to handle recoverable errors in an effect. It creates a program that may fail with HttpError or ValidationError, and provides a recovery mechanism using Effect.catchAll.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-catchAll.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Effect, Random } from \"effect\"\n\nclass HttpError {\n  readonly _tag = \"HttpError\"\n}\n\nclass ValidationError {\n  readonly _tag = \"ValidationError\"\n}\n\n//      ┌─── Effect<string, HttpError | ValidationError, never>\n//      ▼\nconst program = Effect.gen(function* () {\n  const n1 = yield* Random.next\n  const n2 = yield* Random.next\n  if (n1 < 0.5) {\n    yield* Effect.fail(new HttpError())\n  }\n  if (n2 < 0.5) {\n    yield* Effect.fail(new ValidationError())\n  }\n  return \"some result\"\n})\n\n//      ┌─── Effect<string, never, never>\n//      ▼\nconst recovered = program.pipe(\n  Effect.catchAll((error) =>\n    Effect.succeed(`Recovering from ${error._tag}`)\n  )\n)\n```\n\n----------------------------------------\n\nTITLE: Using prettyLogger in Effect for Enhanced Log Output in TypeScript\nDESCRIPTION: This example demonstrates how to use the prettyLogger function from the Effect library to generate visually engaging and color-enhanced log outputs. It shows how to create a program with log messages, annotations, and spans, and then run it with the pretty logger.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Logger-prettyLogger.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Effect, Logger } from \"effect\"\n\nconst program = Effect.log(\"message1\", \"message2\").pipe(\n  Effect.annotateLogs({ key1: \"value1\", key2: \"value2\" }),\n  Effect.withLogSpan(\"myspan\")\n)\n\nEffect.runFork(program.pipe(Effect.provide(Logger.pretty)))\n//         green --v                      v-- bold and cyan\n// [07:51:54.434] INFO (#0) myspan=1ms: message1\n//   message2\n//    v-- bold\n//   key2: value2\n//   key1: value1\n```\n\n----------------------------------------\n\nTITLE: Creating Background Daemon Fiber with Effect.forkDaemon\nDESCRIPTION: Demonstrates creating a daemon fiber that logs messages every second independently of its parent fiber. The example shows how the daemon continues running even after the parent fiber completes after 3 seconds.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-forkDaemon.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Effect, Console, Schedule } from \"effect\"\n\n// Daemon fiber that logs a message repeatedly every second\nconst daemon = Effect.repeat(\n  Console.log(\"daemon: still running!\"),\n  Schedule.fixed(\"1 second\")\n)\n\nconst parent = Effect.gen(function* () {\n  console.log(\"parent: started!\")\n  // Daemon fiber running independently\n  yield* Effect.forkDaemon(daemon)\n  yield* Effect.sleep(\"3 seconds\")\n  console.log(\"parent: finished!\")\n})\n\nEffect.runFork(parent)\n```\n\n----------------------------------------\n\nTITLE: Type Signature of Effect.catchAllCause Function\nDESCRIPTION: The TypeScript type signature for the catchAllCause function, showing its overloads and generic type parameters. This signature illustrates how the function handles different error types and contexts.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-catchAllCause.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const catchAllCause: { <E, A2, E2, R2>(f: (cause: Cause.Cause<E>) => Effect<A2, E2, R2>): <A, R>(self: Effect<A, E, R>) => Effect<A2 | A, E2, R2 | R>; <A, E, R, A2, E2, R2>(self: Effect<A, E, R>, f: (cause: Cause.Cause<E>) => Effect<A2, E2, R2>): Effect<A | A2, E2, R | R2>; }\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Effect.orElse Usage in TypeScript\nDESCRIPTION: This snippet demonstrates how to use the Effect.orElse function to handle both successful and failing effects. It shows how the fallback effect is used when the primary effect fails.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-orElse.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Effect } from \"effect\"\n\nconst success = Effect.succeed(\"success\")\nconst failure = Effect.fail(\"failure\")\nconst fallback = Effect.succeed(\"fallback\")\n\n// Try the success effect first, fallback is not used\nconst program1 = Effect.orElse(success, () => fallback)\nconsole.log(Effect.runSync(program1))\n// Output: \"success\"\n\n// Try the failure effect first, fallback is used\nconst program2 = Effect.orElse(failure, () => fallback)\nconsole.log(Effect.runSync(program2))\n// Output: \"fallback\"\n```\n\n----------------------------------------\n\nTITLE: Creating HTTP Web Handler from HttpApi Instance in TypeScript\nDESCRIPTION: This example demonstrates how to create an HTTP web handler from an HttpApi instance using the HttpApiBuilder.toWebHandler function. It shows how to define a custom API class, create a layer for it, and then use toWebHandler to construct a handler for HTTP requests.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/HttpApiBuilder-toWebHandler.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { HttpApi, HttpApiBuilder, HttpServer } from \"@effect/platform\"\nimport { Layer } from \"effect\"\n\nclass MyApi extends HttpApi.make(\"api\") {}\n\nconst MyApiLive = HttpApiBuilder.api(MyApi)\n\nconst { dispose, handler } = HttpApiBuilder.toWebHandler(\n  Layer.mergeAll(\n    MyApiLive,\n    // you could also use NodeHttpServer.layerContext, depending on your\n    // server's platform\n    HttpServer.layerContext\n  )\n)\n```\n\n----------------------------------------\n\nTITLE: Retrying with a Fixed Delay in TypeScript\nDESCRIPTION: Demonstrates how to use Effect.retry with a fixed delay schedule. The example simulates a task that fails initially but succeeds after a few retries.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-retry.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Effect, Schedule } from \"effect\"\n\nlet count = 0\n\n// Simulates an effect with possible failures\nconst task = Effect.async<string, Error>((resume) => {\n  if (count <= 2) {\n    count++\n    console.log(\"failure\")\n    resume(Effect.fail(new Error()))\n  } else {\n    console.log(\"success\")\n    resume(Effect.succeed(\"yay!\"))\n  }\n})\n\n// Define a repetition policy using a fixed delay between retries\nconst policy = Schedule.fixed(\"100 millis\")\n\nconst repeated = Effect.retry(task, policy)\n\nEffect.runPromise(repeated).then(console.log)\n// Output:\n// failure\n// failure\n// failure\n// success\n// yay!\n```\n\n----------------------------------------\n\nTITLE: Handling Different Failure Types with Effect.matchCause in TypeScript\nDESCRIPTION: Demonstrates how to use Effect.matchCause to handle different types of failures (standard failures, defects, and interruptions) in an Effect computation. The example shows pattern matching on the cause tag to provide specific handling for each failure type.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-matchCause.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Effect } from \"effect\"\n\nconst task: Effect.Effect<number, Error> = Effect.die(\"Uh oh!\")\n\nconst program = Effect.matchCause(task, {\n  onFailure: (cause) => {\n    switch (cause._tag) {\n      case \"Fail\":\n        // Handle standard failure\n        return `Fail: ${cause.error.message}`\n      case \"Die\":\n        // Handle defects (unexpected errors)\n        return `Die: ${cause.defect}`\n      case \"Interrupt\":\n        // Handle interruption\n        return `${cause.fiberId} interrupted!`\n    }\n    // Fallback for other causes\n    return \"failed due to other causes\"\n  },\n  onSuccess: (value) =>\n    // task completes successfully\n    `succeeded with ${value} value`\n})\n\nEffect.runPromise(program).then(console.log)\n// Output: \"Die: Uh oh!\"\n```\n\n----------------------------------------\n\nTITLE: Using Effect.loop with Result Collection in TypeScript\nDESCRIPTION: Example demonstrating how to use Effect.loop to perform an operation 5 times, collecting each iteration's result in an array. The example shows initialization, condition checking, state updating, and result handling.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-loop.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Effect } from \"effect\"\n\n// A loop that runs 5 times, collecting each iteration's result\nconst result = Effect.loop(\n  // Initial state\n  1,\n  {\n    // Condition to continue looping\n    while: (state) => state <= 5,\n    // State update function\n    step: (state) => state + 1,\n    // Effect to be performed on each iteration\n    body: (state) => Effect.succeed(state)\n  }\n)\n\nEffect.runPromise(result).then(console.log)\n// Output: [1, 2, 3, 4, 5]\n```\n\n----------------------------------------\n\nTITLE: Reading Files with Effect.async in TypeScript\nDESCRIPTION: Example of wrapping Node.js callback-based readFile function with Effect.async to handle asynchronous file reading operations. The code demonstrates proper error handling by resuming with either a successful or failed Effect.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-async.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Effect } from \"effect\"\nimport * as NodeFS from \"node:fs\"\n\nconst readFile = (filename: string) =>\n  Effect.async<Buffer, Error>((resume) => {\n    NodeFS.readFile(filename, (error, data) => {\n      if (error) {\n        // Resume with a failed Effect if an error occurs\n        resume(Effect.fail(error))\n      } else {\n        // Resume with a succeeded Effect if successful\n        resume(Effect.succeed(data))\n      }\n    })\n  })\n\n//      ┌─── Effect<Buffer, Error, never>\n//      ▼\nconst program = readFile(\"example.txt\")\n```\n\n----------------------------------------\n\nTITLE: Using cachedWithTTL with Effect in TypeScript\nDESCRIPTION: Example demonstrating how to use cachedWithTTL to cache expensive operations. Shows caching behavior with a TTL of 150 milliseconds, where results are reused within the TTL period and recomputed after expiration.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-cachedWithTTL.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Effect, Console } from \"effect\"\n\nlet i = 1\nconst expensiveTask = Effect.promise<string>(() => {\n  console.log(\"expensive task...\")\n  return new Promise((resolve) => {\n    setTimeout(() => {\n      resolve(`result ${i++}`)\n    }, 100)\n  })\n})\n\nconst program = Effect.gen(function* () {\n  const cached = yield* Effect.cachedWithTTL(expensiveTask, \"150 millis\")\n  yield* cached.pipe(Effect.andThen(Console.log))\n  yield* cached.pipe(Effect.andThen(Console.log))\n  yield* Effect.sleep(\"100 millis\")\n  yield* cached.pipe(Effect.andThen(Console.log))\n})\n\nEffect.runFork(program)\n```\n\n----------------------------------------\n\nTITLE: Applying Option.getOrElse in TypeScript\nDESCRIPTION: This snippet demonstrates the use of the Option.getOrElse method to safely handle optional values by providing fallback logic. If the Option is a Some, it returns that value; otherwise, it executes the provided onNone function.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Option-getOrElse.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Option } from \"effect\"\n\nconsole.log(Option.some(1).pipe(Option.getOrElse(() => 0)))\n// Output: 1\n\nconsole.log(Option.none().pipe(Option.getOrElse(() => 0)))\n// Output: 0\n```\n\n----------------------------------------\n\nTITLE: Using filterEffectOrElse with an Effectful Predicate in TypeScript\nDESCRIPTION: This example demonstrates how to use the filterEffectOrElse function to validate a user from an authentication function. It applies an effectful predicate to check if the user is not null, and provides a fallback effect that creates an error if the predicate fails.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-filterEffectOrElse.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Effect, pipe } from \"effect\"\n\n// Define a user interface\ninterface User {\n  readonly name: string\n}\n\n// Simulate an asynchronous authentication function\ndeclare const auth: () => Promise<User | null>\n\nconst program = pipe(\n  Effect.promise(() => auth()),\n  // Use filterEffectOrElse with an effectful predicate\n  Effect.filterEffectOrElse({\n    predicate: (user) => Effect.succeed(user !== null),\n    orElse: (user) => Effect.fail(new Error(`Unauthorized user: ${user}`))\n  }),\n)\n```\n\n----------------------------------------\n\nTITLE: Using Effect.cachedFunction for Memoizing Random Number Generation in TypeScript\nDESCRIPTION: This example demonstrates how to use Effect.cachedFunction to create a memoized version of a random number generator. It compares the behavior of the original function (which generates new random numbers on each call) with the memoized version (which returns the same result for the same input).\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-cachedFunction.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Effect, Random } from \"effect\"\n\nconst program = Effect.gen(function* () {\n  const randomNumber = (n: number) => Random.nextIntBetween(1, n)\n  console.log(\"non-memoized version:\")\n  console.log(yield* randomNumber(10))\n  console.log(yield* randomNumber(10))\n\n  console.log(\"memoized version:\")\n  const memoized = yield* Effect.cachedFunction(randomNumber)\n  console.log(yield* memoized(10))\n  console.log(yield* memoized(10))\n})\n\nEffect.runFork(program)\n// Example Output:\n// non-memoized version:\n// 2\n// 8\n// memoized version:\n// 5\n// 5\n```\n\n----------------------------------------\n\nTITLE: Effect.validate Function Signature in TypeScript\nDESCRIPTION: The TypeScript type signature for the Effect.validate function, showing its overloaded implementations and available options for controlling concurrency, batching, and finalizers behavior.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-validate.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const validate: { <B, E1, R1>(that: Effect<B, E1, R1>, options?: { readonly concurrent?: boolean | undefined; readonly batching?: boolean | \"inherit\" | undefined; readonly concurrentFinalizers?: boolean | undefined; } | undefined): <A, E, R>(self: Effect<A, E, R>) => Effect<[A, B], E1 | E, R1 | R>; <A, E, R, B, E1, R1>(self: Effect<A, E, R>, that: Effect<B, E1, R1>, options?: { readonly concurrent?: boolean | undefined; readonly batching?: boolean | \"inherit\" | undefined; readonly concurrentFinalizers?: boolean | undefined; } | undefined): Effect<[A, B], E | E1, R | R1>; }\n```\n\n----------------------------------------\n\nTITLE: Implementing unfoldChunkEffect in TypeScript for Effect.ts\nDESCRIPTION: Function signature for creating a stream by effectfully processing chunks of data. Takes an initial state S and a function that processes the state to produce chunks of type A, with potential effects E and dependencies R.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-unfoldChunkEffect.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const unfoldChunkEffect: <S, A, E, R>(s: S, f: (s: S) => Effect.Effect<Option.Option<readonly [Chunk.Chunk<A>, S]>, E, R>) => Stream<A, E, R>\n```\n\n----------------------------------------\n\nTITLE: Using Doc.seps for Layout Management in TypeScript\nDESCRIPTION: Demonstrates how to use the Doc.seps combinator to layout text with automatic handling of space vs newline separation based on available page width. Shows both cases where text fits on one line and where it needs to be split across multiple lines.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Doc-seps.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport * as Doc from \"@effect/printer/Doc\"\nimport * as String from \"effect/String\"\n\nconst doc: Doc.Doc<never> = Doc.hsep([\n  Doc.text(\"prefix\"),\n  Doc.seps(Doc.words(\"text to lay out\"))\n])\n\nassert.strictEqual(\n  Doc.render(doc, { style: \"pretty\" }),\n  \"prefix text to lay out\"\n)\n\n// If the page width is too narrow, documents are separated by newlines\nassert.strictEqual(\n  Doc.render(doc, {\n    style: \"pretty\",\n    options: { lineWidth: 20 }\n  }),\n  String.stripMargin(\n    `|prefix text\n     |to\n     |lay\n     |out`\n  )\n)\n```\n\n----------------------------------------\n\nTITLE: Combining Predicates using Predicate.and in TypeScript\nDESCRIPTION: This snippet demonstrates the use of the `Predicate.and` function to combine minimum and maximum length predicates to validate string lengths. It showcases how the combined predicate works with example assertions to verify expected outcomes. The dependencies include the `assert` module and the `Predicate` from the Effect library.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Predicate-and.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { Predicate } from \"effect\"\n\nconst minLength = (n: number) => (s: string) => s.length >= n\nconst maxLength = (n: number) => (s: string) => s.length <= n\n\nconst length = (n: number) => Predicate.and(minLength(n), maxLength(n))\n\nassert.deepStrictEqual(length(2)(\"aa\"), true)\nassert.deepStrictEqual(length(2)(\"a\"), false)\nassert.deepStrictEqual(length(2)(\"aaa\"), false)\n```\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const and: { <A, C extends A>(that: Refinement<A, C>): <B extends A>(self: Refinement<A, B>) => Refinement<A, B & C>; <A, B extends A, C extends A>(self: Refinement<A, B>, that: Refinement<A, C>): Refinement<A, B & C>; <A>(that: Predicate<A>): (self: Predicate<A>) => Predicate<A>; <A>(self: Predicate<A>, that: Predicate<A>): Predicate<A>; }\n```\n\n----------------------------------------\n\nTITLE: Implementing Layer Retry Logic in TypeScript\nDESCRIPTION: Defines a retry function that allows retrying layer construction according to a specified schedule. The function supports both curried and uncurried forms, handling generic types for return values, errors, and input requirements.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Layer-retry.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const retry: {\n  <X, E, RIn2>(schedule: Schedule.Schedule<X, NoInfer<E>, RIn2>): <ROut, RIn>(self: Layer<ROut, E, RIn>) => Layer<ROut, E, RIn2 | RIn>;\n  <ROut, E, RIn, X, RIn2>(self: Layer<ROut, E, RIn>, schedule: Schedule.Schedule<X, E, RIn2>): Layer<ROut, E, RIn | RIn2>;\n}\n```\n\n----------------------------------------\n\nTITLE: Using Effect.either to Handle Recoverable Errors in TypeScript\nDESCRIPTION: This example demonstrates how to use Effect.either to convert an effect that may fail with HttpError or ValidationError into an effect that always succeeds. The program generates random numbers and conditionally fails, then the recovered version handles both success and failure cases using Either's match function.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-either.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Effect, Either, Random } from \"effect\"\n\nclass HttpError {\n  readonly _tag = \"HttpError\"\n}\n\nclass ValidationError {\n  readonly _tag = \"ValidationError\"\n}\n\n//      ┌─── Effect<string, HttpError | ValidationError, never>\n//      ▼\nconst program = Effect.gen(function* () {\n  const n1 = yield* Random.next\n  const n2 = yield* Random.next\n  if (n1 < 0.5) {\n    yield* Effect.fail(new HttpError())\n  }\n  if (n2 < 0.5) {\n    yield* Effect.fail(new ValidationError())\n  }\n  return \"some result\"\n})\n\n//      ┌─── Effect<string, never, never>\n//      ▼\nconst recovered = Effect.gen(function* () {\n  //      ┌─── Either<string, HttpError | ValidationError>\n  //      ▼\n  const failureOrSuccess = yield* Effect.either(program)\n  return Either.match(failureOrSuccess, {\n    onLeft: (error) => `Recovering from ${error._tag}`,\n    onRight: (value) => value // Do nothing in case of success\n  })\n})\n```\n\n----------------------------------------\n\nTITLE: Declaring STM.all Signature in TypeScript\nDESCRIPTION: Declaration of the STM.all function which runs all provided transactional effects in sequence. The function supports multiple arguments, a single argument tuple/array, or a record/struct as input.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/STM-all.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const all: All.Signature\n```\n\n----------------------------------------\n\nTITLE: Executing Effectful Fold on Stream - TypeScript\nDESCRIPTION: This snippet defines the 'runFoldScopedEffect' function, which allows performing a fold operation over a stream of values using an effectful function. The method returns a scoped value that encapsulates the result of the effect. It requires parameters for the initial state and the fold function, handling both the stream and its associated effects.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-runFoldScopedEffect.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const runFoldScopedEffect: { <S, A, E2, R2>(s: S, f: (s: S, a: A) => Effect.Effect<S, E2, R2>): <E, R>(self: Stream<A, E, R>) => Effect.Effect<S, E2 | E, Scope.Scope | R2 | R>; <A, E, R, S, E2, R2>(self: Stream<A, E, R>, s: S, f: (s: S, a: A) => Effect.Effect<S, E2, R2>): Effect.Effect<S, E | E2, Scope.Scope | R | R2>; }\n```\n\n----------------------------------------\n\nTITLE: Creating Data Loaders from SQL Models in TypeScript\nDESCRIPTION: The makeDataLoaders function creates a set of data loaders for a SQL model, providing methods for inserting, finding by ID, and deleting records. It requires model information, table name, span prefix for tracing, ID column specification, and batching configuration options.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Model-makeDataLoaders.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const makeDataLoaders: <S extends AnyNoContext, Id extends (keyof S[\"Type\"]) & (keyof S[\"update\"][\"Type\"]) & (keyof S[\"fields\"])>(Model: S, options: { readonly tableName: string; readonly spanPrefix: string; readonly idColumn: Id; readonly window: DurationInput; readonly maxBatchSize?: number | undefined; }) => Effect.Effect<{ readonly insert: (insert: S[\"insert\"][\"Type\"]) => Effect.Effect<S[\"Type\"]>; readonly insertVoid: (insert: S[\"insert\"][\"Type\"]) => Effect.Effect<void>; readonly findById: (id: Schema.Schema.Type<S[\"fields\"][Id]>) => Effect.Effect<Option.Option<S[\"Type\"]>>; readonly delete: (id: Schema.Schema.Type<S[\"fields\"][Id]>) => Effect.Effect<void>; }, never, SqlClient | Scope>\n```\n\n----------------------------------------\n\nTITLE: Combining Effects in Tuples with Effect.all in TypeScript\nDESCRIPTION: Example demonstrating how to combine effects in a tuple using Effect.all. The effects are executed sequentially, and the result is a new effect containing the results as a tuple.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-all.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Effect, Console } from \"effect\"\n\nconst tupleOfEffects = [\n  Effect.succeed(42).pipe(Effect.tap(Console.log)),\n  Effect.succeed(\"Hello\").pipe(Effect.tap(Console.log))\n] as const\n\n//      ┌─── Effect<[number, string], never, never>\n//      ▼\nconst resultsAsTuple = Effect.all(tupleOfEffects)\n\nEffect.runPromise(resultsAsTuple).then(console.log)\n// Output:\n// 42\n// Hello\n// [ 42, 'Hello' ]\n```\n\n----------------------------------------\n\nTITLE: Implementing Pretty Logger in Effect TypeScript\nDESCRIPTION: This example demonstrates how to use the pretty logger in Effect to create visually engaging log outputs. It shows how to log messages, annotate logs with key-value pairs, and use log spans.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Logger-pretty.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Effect, Logger } from \"effect\"\n\nconst program = Effect.log(\"message1\", \"message2\").pipe(\n  Effect.annotateLogs({ key1: \"value1\", key2: \"value2\" }),\n  Effect.withLogSpan(\"myspan\")\n)\n\nEffect.runFork(program.pipe(Effect.provide(Logger.pretty)))\n//         green --v                      v-- bold and cyan\n// [07:51:54.434] INFO (#0) myspan=1ms: message1\n//   message2\n//    v-- bold\n//   key2: value2\n//   key1: value1\n```\n\n----------------------------------------\n\nTITLE: Effect.tryPromise Function Signature\nDESCRIPTION: The TypeScript signature for the Effect.tryPromise function, showing both overloads - one that accepts an evaluation function returning a Promise, and another that additionally accepts a catch function for custom error handling.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-tryPromise.md#2025-04-11_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const tryPromise: { <A, E>(options: { readonly try: (signal: AbortSignal) => PromiseLike<A>; readonly catch: (error: unknown) => E; }): Effect<A, E>; <A>(evaluate: (signal: AbortSignal) => PromiseLike<A>): Effect<A, Cause.UnknownException>; }\n```\n\n----------------------------------------\n\nTITLE: Handling Multiple Tagged Error Types with Effect.catchTags in TypeScript\nDESCRIPTION: This example demonstrates how to use Effect.catchTags to handle multiple error types in a single operation. It defines HttpError and ValidationError classes with _tag fields, creates a program that might fail with either error, and then uses catchTags to recover from both error types, converting them to success values.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-catchTags.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Effect, Random } from \"effect\"\n\nclass HttpError {\n  readonly _tag = \"HttpError\"\n}\n\nclass ValidationError {\n  readonly _tag = \"ValidationError\"\n}\n\n//      ┌─── Effect<string, HttpError | ValidationError, never>\n//      ▼\nconst program = Effect.gen(function* () {\n  const n1 = yield* Random.next\n  const n2 = yield* Random.next\n  if (n1 < 0.5) {\n    yield* Effect.fail(new HttpError())\n  }\n  if (n2 < 0.5) {\n    yield* Effect.fail(new ValidationError())\n  }\n  return \"some result\"\n})\n\n//      ┌─── Effect<string, never, never>\n//      ▼\nconst recovered = program.pipe(\n  Effect.catchTags({\n    HttpError: (_HttpError) =>\n      Effect.succeed(`Recovering from HttpError`),\n    ValidationError: (_ValidationError) =>\n      Effect.succeed(`Recovering from ValidationError`)\n  })\n)\n```\n\n----------------------------------------\n\nTITLE: Effect.bindAll Type Definition in TypeScript\nDESCRIPTION: Type signature for the bindAll operator showing its generic parameters and return types. Includes options for controlling concurrency, batching, execution mode, and finalizer behavior.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-bindAll.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const bindAll: { <A extends object, X extends Record<string, Effect<any, any, any>>, O extends NoExcessProperties<{ readonly concurrency?: Concurrency | undefined; readonly batching?: boolean | \"inherit\" | undefined; readonly mode?: \"default\" | \"validate\" | \"either\" | undefined; readonly concurrentFinalizers?: boolean | undefined; }, O>>(f: (a: NoInfer<A>) => [Extract<keyof X, keyof A>] extends [never] ? X : `Duplicate keys`, options?: undefined | O): <E1, R1>(self: Effect<A, E1, R1>) => [All.ReturnObject<X, false, All.ExtractMode<O>>] extends [Effect<infer Success, infer Error, infer Context>] ? Effect<{ [K in keyof A | keyof Success]: K extends keyof A ? A[K] : K extends keyof Success ? Success[K] : never; }, E1 | Error, R1 | Context> : never; <A extends object, X extends Record<string, Effect<any, any, any>>, O extends NoExcessProperties<{ readonly concurrency?: Concurrency | undefined; readonly batching?: boolean | \"inherit\" | undefined; readonly mode?: \"default\" | \"validate\" | \"either\" | undefined; readonly concurrentFinalizers?: boolean | undefined; }, O>, E1, R1>(self: Effect<A, E1, R1>, f: (a: NoInfer<A>) => [Extract<keyof X, keyof A>] extends [never] ? X : `Duplicate keys`, options?: undefined | { readonly concurrency?: Concurrency | undefined; readonly batching?: boolean | \"inherit\" | undefined; readonly mode?: \"default\" | \"validate\" | \"either\" | undefined; readonly concurrentFinalizers?: boolean | undefined; }): [All.ReturnObject<X, false, All.ExtractMode<O>>] extends [Effect<infer Success, infer Error, infer Context>] ? Effect<{ [K in keyof A | keyof Success]: K extends keyof A ? A[K] : K extends keyof Success ? Success[K] : never; }, E1 | Error, R1 | Context> : never; }\n```\n\n----------------------------------------\n\nTITLE: Effect.async Function Signature in TypeScript\nDESCRIPTION: The TypeScript type signature for the Effect.async function. It shows the function's parameters including the resume callback, AbortSignal, and optional blockingOn FiberId parameter.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-async.md#2025-04-11_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const async: <A, E = never, R = never>(resume: (callback: (_: Effect<A, E, R>) => void, signal: AbortSignal) => void | Effect<void, never, R>, blockingOn?: FiberId.FiberId) => Effect<A, E, R>\n```\n\n----------------------------------------\n\nTITLE: Effect.Tag TypeScript Type Signature\nDESCRIPTION: The type signature for the Effect.Tag function, showing how it creates a Context.TagClass with proxy methods for the service's functionality and a 'use' method for dependency injection.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-Tag.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const Tag: <const Id extends string>(id: Id) => <Self, Type extends Tag.AllowedType>() => Context.TagClass<Self, Id, Type> & (Type extends Record<PropertyKey, any> ? Tag.Proxy<Self, Type> : {}) & { use: <X>(body: (_: Type) => X) => [X] extends [Effect<infer A, infer E, infer R>] ? Effect<A, E, R | Self> : [X] extends [PromiseLike<infer A>] ? Effect<A, Cause.UnknownException, Self> : Effect<X, never, Self>; }\n```\n\n----------------------------------------\n\nTITLE: Defining HttpApi Interface in TypeScript\nDESCRIPTION: This code snippet defines the HttpApi interface with various methods for managing HTTP API endpoints, groups, errors, and middlewares. It includes type parameters for ID, Groups, Error, and Requirements.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/HttpApi-HttpApi.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface HttpApi<\n  out Id extends string,\n  out Groups extends HttpApiGroup.HttpApiGroup.Any = never,\n  in out E = never,\n  out R = never\n> extends Pipeable {\n  new(_: never): {}\n  readonly [TypeId]: TypeId\n  readonly identifier: Id\n  readonly groups: Record.ReadonlyRecord<string, Groups>\n  readonly annotations: Context.Context<never>\n  readonly errorSchema: Schema.Schema<E, unknown, R>\n  readonly middlewares: ReadonlySet<HttpApiMiddleware.TagClassAny>\n\n  /**\n   * Add a `HttpApiGroup` to the `HttpApi`.\n   */\n  add<A extends HttpApiGroup.HttpApiGroup.Any>(group: A): HttpApi<Id, Groups | A, E, R>\n  /**\n   * Add another `HttpApi` to the `HttpApi`.\n   */\n  addHttpApi<Id2 extends string, Groups2 extends HttpApiGroup.HttpApiGroup.Any, E2, R2>(\n    api: HttpApi<Id2, Groups2, E2, R2>\n  ): HttpApi<\n    Id,\n    Groups | HttpApiGroup.HttpApiGroup.AddContext<Groups2, R2>,\n    E | E2,\n    R\n  >\n  /**\n   * Add an global error to the `HttpApi`.\n   */\n  addError<A, I, RX>(\n    schema: Schema.Schema<A, I, RX>,\n    annotations?: {\n      readonly status?: number | undefined\n    }\n  ): HttpApi<Id, Groups, E | A, R | RX>\n  /**\n   * Prefix all endpoints in the `HttpApi`.\n   */\n  prefix(prefix: HttpApiEndpoint.PathSegment): HttpApi<Id, Groups, E, R>\n  /**\n   * Add a middleware to a `HttpApi`. It will be applied to all endpoints in the\n   * `HttpApi`.\n   */\n  middleware<I extends HttpApiMiddleware.HttpApiMiddleware.AnyId, S>(\n    middleware: Context.Tag<I, S>\n  ): HttpApi<\n    Id,\n    Groups,\n    E | HttpApiMiddleware.HttpApiMiddleware.Error<I>,\n    R | I | HttpApiMiddleware.HttpApiMiddleware.ErrorContext<I>\n  >\n  /**\n   * Annotate the `HttpApi`.\n   */\n  annotate<I, S>(tag: Context.Tag<I, S>, value: S): HttpApi<Id, Groups, E, R>\n  /**\n   * Annotate the `HttpApi` with a Context.\n   */\n  annotateContext<I>(context: Context.Context<I>): HttpApi<Id, Groups, E, R>\n}\n```\n\n----------------------------------------\n\nTITLE: Function Signature for Effect.sync in TypeScript\nDESCRIPTION: Shows the TypeScript type declaration for the Effect.sync function. The function takes a lazy argument (thunk) of type A and returns an Effect of A.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-sync.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const sync: <A>(thunk: LazyArg<A>) => Effect<A>\n```\n\n----------------------------------------\n\nTITLE: Creating Services with Effect.Service in TypeScript\nDESCRIPTION: This example demonstrates how to create two services, Prefix and Logger, using Effect.Service. The Prefix service is created with a sync implementation, while the Logger service is created with an effect implementation and depends on the Prefix service.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-Service.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Effect } from 'effect';\n\nclass Prefix extends Effect.Service<Prefix>()(\"Prefix\", {\n sync: () => ({ prefix: \"PRE\" })\n}) {}\n\nclass Logger extends Effect.Service<Logger>()(\"Logger\", {\n accessors: true,\n effect: Effect.gen(function* () {\n   const { prefix } = yield* Prefix\n   return {\n     info: (message: string) =>\n       Effect.sync(() => {\n         console.log(`[${prefix}][${message}]`)\n       })\n   }\n }),\n dependencies: [Prefix.Default]\n}) {}\n```\n\n----------------------------------------\n\nTITLE: Declaring the logFatal Function in TypeScript\nDESCRIPTION: Function declaration for logFatal which takes any number of messages as arguments and returns an Effect. This function logs messages at the FATAL level, suitable for reporting critical errors that cause the application to terminate or stop functioning.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-logFatal.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const logFatal: (...message: ReadonlyArray<any>) => Effect<void, never, never>\n```\n\n----------------------------------------\n\nTITLE: Short-Circuiting Behavior in Effect.all in TypeScript\nDESCRIPTION: Example demonstrating the default short-circuiting behavior of Effect.all. When any effect in the collection fails, the remaining effects won't run, and the error is propagated.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-all.md#2025-04-11_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Effect, Console } from \"effect\"\n\nconst program = Effect.all([\n  Effect.succeed(\"Task1\").pipe(Effect.tap(Console.log)),\n  Effect.fail(\"Task2: Oh no!\").pipe(Effect.tap(Console.log)),\n  // Won't execute due to earlier failure\n  Effect.succeed(\"Task3\").pipe(Effect.tap(Console.log))\n])\n\nEffect.runPromiseExit(program).then(console.log)\n// Output:\n// Task1\n// {\n//   _id: 'Exit',\n//   _tag: 'Failure',\n//   cause: { _id: 'Cause', _tag: 'Fail', failure: 'Task2: Oh no!' }\n// }\n```\n\n----------------------------------------\n\nTITLE: Using Effect.map in TypeScript\nDESCRIPTION: Demonstrates three different ways to use Effect.map for transforming values inside effects. This snippet shows the basic syntax for applying Effect.map.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-map.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst mappedEffect = pipe(myEffect, Effect.map(transformation))\n// or\nconst mappedEffect = Effect.map(myEffect, transformation)\n// or\nconst mappedEffect = myEffect.pipe(Effect.map(transformation))\n```\n\n----------------------------------------\n\nTITLE: Creating a Traced Function with a Span Name in TypeScript\nDESCRIPTION: Demonstrates how to create a traced function with a named span that captures error details and provides enhanced stack traces with location information when errors occur.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-fn.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Effect } from \"effect\"\n\nconst myfunc = Effect.fn(\"myspan\")(function* <N extends number>(n: N) {\n  yield* Effect.annotateCurrentSpan(\"n\", n) // Attach metadata to the span\n  console.log(`got: ${n}`)\n  yield* Effect.fail(new Error(\"Boom!\")) // Simulate failure\n})\n\nEffect.runFork(myfunc(100).pipe(Effect.catchAllCause(Effect.logError)))\n// Output:\n// got: 100\n// timestamp=... level=ERROR fiber=#0 cause=\"Error: Boom!\n//     at <anonymous> (/.../index.ts:6:22) <= Raise location\n//     at myspan (/.../index.ts:3:23)  <= Definition location\n//     at myspan (/.../index.ts:9:16)\" <= Call location\n```\n\n----------------------------------------\n\nTITLE: Using Either.match to Handle Either Types in TypeScript\nDESCRIPTION: Demonstrates how to use the Either.match function to handle both Left and Right cases. The example shows converting Either values to strings based on their content, with different formatting for success and error cases.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Either-match.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { pipe, Either } from \"effect\"\n\nconst onLeft  = (strings: ReadonlyArray<string>): string => `strings: ${strings.join(', ')}`\n\nconst onRight = (value: number): string => `Ok: ${value}`\n\nassert.deepStrictEqual(pipe(Either.right(1), Either.match({ onLeft, onRight })), 'Ok: 1')\nassert.deepStrictEqual(\n  pipe(Either.left(['string 1', 'string 2']), Either.match({ onLeft, onRight })),\n  'strings: string 1, string 2'\n)\n```\n\n----------------------------------------\n\nTITLE: Effect Schema parseJson Example\nDESCRIPTION: This example demonstrates how to use `Schema.parseJson` to parse a JSON string into an `unknown` type and a specific schema type (Struct with NumberFromString). It uses `assert.deepStrictEqual` to verify the parsed results.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Schema-parseJson.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport * as Schema from \"effect/Schema\"\n\nassert.deepStrictEqual(Schema.decodeUnknownSync(Schema.parseJson())(`{\"a\":\"1\"}`), { a: \"1\" })\nassert.deepStrictEqual(Schema.decodeUnknownSync(Schema.parseJson(Schema.Struct({ a: Schema.NumberFromString })))(`{\"a\":\"1\"}`), { a: 1 })\n```\n\n----------------------------------------\n\nTITLE: Using Either.all with Arrays and Objects in TypeScript\nDESCRIPTION: Demonstrates how to use Either.all function with arrays and objects. It shows how the function combines multiple Either values into a single Either containing a structure of the same shape as the input.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Either-all.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { Either } from \"effect\"\n\nassert.deepStrictEqual(Either.all([Either.right(1), Either.right(2)]), Either.right([1, 2]))\nassert.deepStrictEqual(Either.all({ right: Either.right(1), b: Either.right(\"hello\") }), Either.right({ right: 1, b: \"hello\" }))\nassert.deepStrictEqual(Either.all({ right: Either.right(1), b: Either.left(\"error\") }), Either.left(\"error\"))\n```\n\n----------------------------------------\n\nTITLE: TypeScript Signature for Effect.catchTags Function\nDESCRIPTION: This is the TypeScript type signature for the catchTags function, showing its complex generic type constraints. The function takes a cases object where each key corresponds to an error _tag, and returns a function that handles an Effect with those potential error types.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-catchTags.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const catchTags: { <E, Cases extends { [K in Extract<E, { _tag: string; }>[\"_tag\"]]+?: ((error: Extract<E, { _tag: K; }>) => Effect<any, any, any>); } & (unknown extends E ? {} : { [K in Exclude<keyof Cases, Extract<E, { _tag: string; }>[\"_tag\"]>]: never; })>(cases: Cases): <A, R>(self: Effect<A, E, R>) => Effect<A | { [K in keyof Cases]: Cases[K] extends (...args: Array<any>) => Effect<infer A, any, any> ? A : never; }[keyof Cases], Exclude<E, { _tag: keyof Cases; }> | { [K in keyof Cases]: Cases[K] extends (...args: Array<any>) => Effect<any, infer E, any> ? E : never; }[keyof Cases], R | { [K in keyof Cases]: Cases[K] extends (...args: Array<any>) => Effect<any, any, infer R> ? R : never; }[keyof Cases]>; <R, E, A, Cases extends { [K in Extract<E, { _tag: string; }>[\"_tag\"]]+?: ((error: Extract<E, { _tag: K; }>) => Effect<any, any, any>); } & (unknown extends E ? {} : { [K in Exclude<keyof Cases, Extract<E, { _tag: string; }>[\"_tag\"]>]: never; })>(self: Effect<A, E, R>, cases: Cases): Effect<A | { [K in keyof Cases]: Cases[K] extends (...args: Array<any>) => Effect<infer A, any, any> ? A : never; }[keyof Cases], Exclude<E, { _tag: keyof Cases; }> | { [K in keyof Cases]: Cases[K] extends (...args: Array<any>) => Effect<any, infer E, any> ? E : never; }[keyof Cases], R | { [K in keyof Cases]: Cases[K] extends (...args: Array<any>) => Effect<any, any, infer R> ? R : never; }[keyof Cases]>; }\n```\n\n----------------------------------------\n\nTITLE: Transforming Stream Chunks using Effect-Library in TypeScript\nDESCRIPTION: The `mapChunksEffect` function in this TypeScript snippet transforms the chunks emitted by a stream using effectful computations. It is defined for usage within the Effect library, specifically in the Stream module, and allows users to apply a transformation function to chunks, producing a new Stream. Users must ensure that the transformation function returns an Effect type corresponding to the desired output chunk type. This operation requires the Effect-TS library, and it supports multiple signatures for flexibility. Inputs include a stream instance and a transformation function, while the output is a new stream with transformed chunks.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-mapChunksEffect.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const mapChunksEffect: { <A, B, E2, R2>(f: (chunk: Chunk.Chunk<A>) => Effect.Effect<Chunk.Chunk<B>, E2, R2>): <E, R>(self: Stream<A, E, R>) => Stream<B, E2 | E, R2 | R>; <A, E, R, B, E2, R2>(self: Stream<A, E, R>, f: (chunk: Chunk.Chunk<A>) => Effect.Effect<Chunk.Chunk<B>, E2, R2>): Stream<B, E | E2, R | R2>; }\n```\n\n----------------------------------------\n\nTITLE: Creating Stream from EventListener in TypeScript\nDESCRIPTION: The `fromEventListener` function creates a Stream from an EventListener, useful for reactive programming. It requires a target EventListener, an event type as a string, and optional configurations like capture, passive, and once. The function returns a Stream object of type A, where A is inferred from the EventListener. It's available since version 3.1.0 and is dependent on the 'effect' package.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-fromEventListener.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const fromEventListener: <A = unknown>(target: EventListener<A>, type: string, options?: boolean | { readonly capture?: boolean; readonly passive?: boolean; readonly once?: boolean; readonly bufferSize?: number | \"unbounded\" | undefined; } | undefined) => Stream<A>\n```\n\n----------------------------------------\n\nTITLE: Creating a Delayed Message Effect in TypeScript\nDESCRIPTION: Example showing how to create an Effect that resolves with a string message after a 2-second delay using Effect.promise. This demonstrates wrapping a Promise-based timeout function into an Effect that is guaranteed to succeed.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-promise.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Effect } from \"effect\"\n\nconst delay = (message: string) =>\n  Effect.promise<string>(\n    () =>\n      new Promise((resolve) => {\n        setTimeout(() => {\n          resolve(message)\n        }, 2000)\n      })\n  )\n\n//      ┌─── Effect<string, never, never>\n//      ▼\nconst program = delay(\"Async operation completed successfully!\")\n```\n\n----------------------------------------\n\nTITLE: Using Effect.validateAll to Process Collection Items in TypeScript\nDESCRIPTION: This example demonstrates how to use the validateAll function to process each element in an array. The function continues processing all elements even when some fail, collecting both successes and failures. In this case, it logs numbers less than 4 and fails for numbers 4 and greater.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-validateAll.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Effect, Console } from \"effect\"\n\n//      ┌─── Effect<number[], [string, ...string[]], never>\n//      ▼\nconst program = Effect.validateAll([1, 2, 3, 4, 5], (n) => {\n  if (n < 4) {\n    return Console.log(`item ${n}`).pipe(Effect.as(n))\n  } else {\n    return Effect.fail(`${n} is not less that 4`)\n  }\n})\n\nEffect.runPromiseExit(program).then(console.log)\n// Output:\n// item 1\n// item 2\n// item 3\n// {\n//   _id: 'Exit',\n//   _tag: 'Failure',\n//   cause: {\n//     _id: 'Cause',\n//     _tag: 'Fail',\n//     failure: [ '4 is not less that 4', '5 is not less that 4' ]\n//   }\n// }\n```\n\n----------------------------------------\n\nTITLE: Creating and Using Data.Class with Equality Checking in TypeScript\nDESCRIPTION: Example of defining a Person class using Data.Class, creating instances, and testing equality. This demonstrates the automatic structural equality provided by Data.Class where instances with the same properties are considered equal.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Data-Class.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { Data, Equal } from \"effect\"\n\nclass Person extends Data.Class<{ readonly name: string }> {}\n\n// Creating instances of Person\nconst mike1 = new Person({ name: \"Mike\" })\nconst mike2 = new Person({ name: \"Mike\" })\nconst john = new Person({ name: \"John\" })\n\n// Checking equality\nassert.deepStrictEqual(Equal.equals(mike1, mike2), true)\nassert.deepStrictEqual(Equal.equals(mike1, john), false)\n```\n\n----------------------------------------\n\nTITLE: Using Effect.tap for Side Effects in Effect Chains in TypeScript\nDESCRIPTION: This example demonstrates how to use Effect.tap to log a transaction amount during processing without altering the flow of data. It shows a pipeline where a transaction amount is fetched, logged with tap, and then a discount is applied to it.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-tap.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Console, Effect, pipe } from \"effect\"\n\n// Function to apply a discount safely to a transaction amount\nconst applyDiscount = (\n  total: number,\n  discountRate: number\n): Effect.Effect<number, Error> =>\n  discountRate === 0\n    ? Effect.fail(new Error(\"Discount rate cannot be zero\"))\n    : Effect.succeed(total - (total * discountRate) / 100)\n\n// Simulated asynchronous task to fetch a transaction amount from database\nconst fetchTransactionAmount = Effect.promise(() => Promise.resolve(100))\n\nconst finalAmount = pipe(\n  fetchTransactionAmount,\n  // Log the fetched transaction amount\n  Effect.tap((amount) => Console.log(`Apply a discount to: ${amount}`)),\n  // `amount` is still available!\n  Effect.flatMap((amount) => applyDiscount(amount, 5))\n)\n\nEffect.runPromise(finalAmount).then(console.log)\n// Output:\n// Apply a discount to: 100\n// 95\n```\n\n----------------------------------------\n\nTITLE: Updating Service in Effect Stream (TypeScript)\nDESCRIPTION: Updates the specified service within the context of the `Stream`. The function takes a `Context.Tag` to identify the service and a function `f` that modifies the service. This returns a new `Stream` with the updated service in its context.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-updateService.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const updateService: { <I, S>(tag: Context.Tag<I, S>, f: (service: NoInfer<S>) => NoInfer<S>): <A, E, R>(self: Stream<A, E, R>) => Stream<A, E, I | R>; <A, E, R, I, S>(self: Stream<A, E, R>, tag: Context.Tag<I, S>, f: (service: NoInfer<S>) => NoInfer<S>): Stream<A, E, I | R>; }\n```\n\n----------------------------------------\n\nTITLE: Exporting Spans to the Console in TypeScript\nDESCRIPTION: Shows how to integrate Effect's tracing with OpenTelemetry to export span data to the console, capturing detailed information about function execution including metadata and error details.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-fn.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Effect } from \"effect\"\nimport { NodeSdk } from \"@effect/opentelemetry\"\nimport {\n  ConsoleSpanExporter,\n  BatchSpanProcessor\n} from \"@opentelemetry/sdk-trace-base\"\n\nconst myfunc = Effect.fn(\"myspan\")(function* <N extends number>(n: N) {\n  yield* Effect.annotateCurrentSpan(\"n\", n)\n  console.log(`got: ${n}`)\n  yield* Effect.fail(new Error(\"Boom!\"))\n})\n\nconst program = myfunc(100)\n\nconst NodeSdkLive = NodeSdk.layer(() => ({\n  resource: { serviceName: \"example\" },\n  // Export span data to the console\n  spanProcessor: new BatchSpanProcessor(new ConsoleSpanExporter())\n}))\n\nEffect.runFork(program.pipe(Effect.provide(NodeSdkLive)))\n// Output:\n// got: 100\n// {\n//   resource: {\n//     attributes: {\n//       'service.name': 'example',\n//       'telemetry.sdk.language': 'nodejs',\n//       'telemetry.sdk.name': '@effect/opentelemetry',\n//       'telemetry.sdk.version': '1.30.1'\n//     }\n//   },\n//   instrumentationScope: { name: 'example', version: undefined, schemaUrl: undefined },\n//   traceId: '22801570119e57a6e2aacda3dec9665b',\n//   parentId: undefined,\n//   traceState: undefined,\n//   name: 'myspan',\n//   id: '7af530c1e01bc0cb',\n//   kind: 0,\n//   timestamp: 1741182277518402.2,\n//   duration: 4300.416,\n//   attributes: {\n//     n: 100,\n//     'code.stacktrace': 'at <anonymous> (/.../index.ts:8:23)\\n' +\n//       'at <anonymous> (/.../index.ts:14:17)'\n//   },\n//   status: { code: 2, message: 'Boom!' },\n//   events: [\n//     {\n//       name: 'exception',\n//       attributes: {\n//         'exception.type': 'Error',\n//         'exception.message': 'Boom!',\n//         'exception.stacktrace': 'Error: Boom!\\n' +\n//           '    at <anonymous> (/.../index.ts:11:22)\\n' +\n//           '    at myspan (/.../index.ts:8:23)\\n' +\n//           '    at myspan (/.../index.ts:14:17)'\n//       },\n//       time: [ 1741182277, 522702583 ],\n//       droppedAttributesCount: 0\n//     }\n//   ],\n//   links: []\n// }\n```\n\n----------------------------------------\n\nTITLE: Using Effect.reduce to Process Orders Sequentially in TypeScript\nDESCRIPTION: This example demonstrates how to use Effect.reduce to process a collection of order IDs sequentially, calculating the total price. Each order is processed with a delay, and the function accumulates the total price while maintaining the processing order.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-reduce.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Console, Effect } from \"effect\"\n\nconst processOrder = (id: number) =>\n  Effect.succeed({ id, price: 100 * id })\n    .pipe(Effect.tap(() => Console.log(`Order ${id} processed`)), Effect.delay(500 - (id * 100)))\n\nconst program = Effect.reduce(\n  [1, 2, 3, 4],\n  0,\n  (acc, id, i) =>\n    processOrder(id)\n      .pipe(Effect.map((order) => acc + order.price))\n)\n\nEffect.runPromise(program).then(console.log)\n// Output:\n// Order 1 processed\n// Order 2 processed\n// Order 3 processed\n// Order 4 processed\n// 1000\n```\n\n----------------------------------------\n\nTITLE: Adding a Finalizer on Interruption in Effect\nDESCRIPTION: Illustrates how to add a finalizer to an effect that gets interrupted. The finalizer logs the exit status after the effect is interrupted, showing how finalizers provide reliable resource cleanup even during interruptions.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-addFinalizer.md#2025-04-11_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Effect, Console } from \"effect\"\n\n//      ┌─── Effect<never, never, Scope>\n//      ▼\nconst program = Effect.gen(function* () {\n  yield* Effect.addFinalizer((exit) =>\n    Console.log(`Finalizer executed. Exit status: ${exit._tag}`)\n  )\n  return yield* Effect.interrupt\n})\n\n// Wrapping the effect in a scope\n//\n//      ┌─── Effect<never, never, never>\n//      ▼\nconst runnable = Effect.scoped(program)\n\nEffect.runPromiseExit(runnable).then(console.log)\n// Output:\n// Finalizer executed. Exit status: Failure\n// {\n//   _id: 'Exit',\n//   _tag: 'Failure',\n//   cause: {\n//     _id: 'Cause',\n//     _tag: 'Interrupt',\n//     fiberId: {\n//       _id: 'FiberId',\n//       _tag: 'Runtime',\n//       id: 0,\n//       startTimeMillis: ...\n//     }\n//   }\n// }\n```\n\n----------------------------------------\n\nTITLE: Effect.gen Type Signature in TypeScript\nDESCRIPTION: The TypeScript type signature for the Effect.gen function, showing its polymorphic nature and type inference capabilities. It handles effect composition while preserving error types and contextual requirements.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-gen.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const gen: { <Eff extends YieldWrap<Effect<any, any, any>>, AEff>(f: (resume: Adapter) => Generator<Eff, AEff, never>): Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [YieldWrap<Effect<infer _A, infer E, infer _R>>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [YieldWrap<Effect<infer _A, infer _E, infer R>>] ? R : never>; <Self, Eff extends YieldWrap<Effect<any, any, any>>, AEff>(self: Self, f: (this: Self, resume: Adapter) => Generator<Eff, AEff, never>): Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [YieldWrap<Effect<infer _A, infer E, infer _R>>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [YieldWrap<Effect<infer _A, infer _E, infer R>>] ? R : never>; }\n```\n\n----------------------------------------\n\nTITLE: Retrying Operations with Fallback in TypeScript using Effect\nDESCRIPTION: This example demonstrates how to retry a failing operation multiple times according to a schedule, and execute a fallback operation if all retries fail. It simulates a task that fails the first three times and would succeed afterward, but due to the retry limit of 2, the fallback is executed instead.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-retryOrElse.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Effect, Schedule, Console } from \"effect\"\n\nlet count = 0\n\n// Simulates an effect with possible failures\nconst task = Effect.async<string, Error>((resume) => {\n  if (count <= 2) {\n    count++\n    console.log(\"failure\")\n    resume(Effect.fail(new Error()))\n  } else {\n    console.log(\"success\")\n    resume(Effect.succeed(\"yay!\"))\n  }\n})\n\n// Retry the task with a delay between retries and a maximum of 2 retries\nconst policy = Schedule.addDelay(Schedule.recurs(2), () => \"100 millis\")\n\n// If all retries fail, run the fallback effect\nconst repeated = Effect.retryOrElse(\n  task,\n  policy,\n  // fallback\n  () => Console.log(\"orElse\").pipe(Effect.as(\"default value\"))\n)\n\nEffect.runPromise(repeated).then(console.log)\n// Output:\n// failure\n// failure\n// failure\n// orElse\n// default value\n```\n\n----------------------------------------\n\nTITLE: Effect.tap Type Signature in TypeScript\nDESCRIPTION: The complex type signature for the Effect.tap function, showing its various overloads and type parameters. This signature demonstrates how tap works with different input types and preserves error and context types from both the main effect and the side effect.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-tap.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const tap: { <A, X>(f: (a: NoInfer<A>) => X): <E, R>(self: Effect<A, E, R>) => [X] extends [Effect<infer _A1, infer E1, infer R1>] ? Effect<A, E | E1, R | R1> : [X] extends [PromiseLike<infer _A1>] ? Effect<A, E | Cause.UnknownException, R> : Effect<A, E, R>; <A, X, E1, R1>(f: (a: NoInfer<A>) => Effect<X, E1, R1>, options: { onlyEffect: true; }): <E, R>(self: Effect<A, E, R>) => Effect<A, E | E1, R | R1>; <X>(f: NotFunction<X>): <A, E, R>(self: Effect<A, E, R>) => [X] extends [Effect<infer _A1, infer E1, infer R1>] ? Effect<A, E | E1, R | R1> : [X] extends [PromiseLike<infer _A1>] ? Effect<A, E | Cause.UnknownException, R> : Effect<A, E, R>; <X, E1, R1>(f: Effect<X, E1, R1>, options: { onlyEffect: true; }): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E | E1, R | R1>; <A, E, R, X>(self: Effect<A, E, R>, f: (a: NoInfer<A>) => X): [X] extends [Effect<infer _A1, infer E1, infer R1>] ? Effect<A, E | E1, R | R1> : [X] extends [PromiseLike<infer _A1>] ? Effect<A, E | Cause.UnknownException, R> : Effect<A, E, R>; <A, E, R, X, E1, R1>(self: Effect<A, E, R>, f: (a: NoInfer<A>) => Effect<X, E1, R1>, options: { onlyEffect: true; }): Effect<A, E | E1, R | R1>; <A, E, R, X>(self: Effect<A, E, R>, f: NotFunction<X>): [X] extends [Effect<infer _A1, infer E1, infer R1>] ? Effect<A, E | E1, R | R1> : [X] extends [PromiseLike<infer _A1>] ? Effect<A, E | Cause.UnknownException, R> : Effect<A, E, R>; <A, E, R, X, E1, R1>(self: Effect<A, E, R>, f: Effect<X, E1, R1>, options: { onlyEffect: true; }): Effect<A, E | E1, R | R1>; }\n```\n\n----------------------------------------\n\nTITLE: Database Query Example with Effect.provide\nDESCRIPTION: Demonstrates how to use Effect.provide to inject a database dependency into an effect. Shows creation of a Database service, implementation of a query method, and running the effect with provided dependencies.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-provide.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Context, Effect, Layer } from \"effect\"\n\nclass Database extends Context.Tag(\"Database\")<\n  Database,\n  { readonly query: (sql: string) => Effect.Effect<Array<unknown>> }\n>() {}\n\nconst DatabaseLive = Layer.succeed(\n  Database,\n  {\n    // Simulate a database query\n    query: (sql: string) => Effect.log(`Executing query: ${sql}`).pipe(Effect.as([]))\n  }\n)\n\n//      ┌─── Effect<unknown[], never, Database>\n//      ▼\nconst program = Effect.gen(function*() {\n  const database = yield* Database\n  const result = yield* database.query(\"SELECT * FROM users\")\n  return result\n})\n\n//      ┌─── Effect<unknown[], never, never>\n//      ▼\nconst runnable = Effect.provide(program, DatabaseLive)\n\nEffect.runPromise(runnable).then(console.log)\n// Output:\n// timestamp=... level=INFO fiber=#0 message=\"Executing query: SELECT * FROM users\"\n// []\n```\n\n----------------------------------------\n\nTITLE: Using Effect.fromNullable with TypeScript\nDESCRIPTION: Demonstrates how to use Effect.fromNullable to safely handle potentially null values. Shows successful case with number 1 and failure case with null value, illustrating how the function converts values into Effects that either succeed with the value or fail with NoSuchElementException.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-fromNullable.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Effect } from \"effect\"\n\n//      ┌─── Effect<number, NoSuchElementException, never>\n//      ▼\nconst maybe1 = Effect.fromNullable(1)\n\nEffect.runPromiseExit(maybe1).then(console.log)\n// Output:\n// { _id: 'Exit', _tag: 'Success', value: 1 }\n\n//      ┌─── Effect<number, NoSuchElementException, never>\n//      ▼\nconst maybe2 = Effect.fromNullable(null as number | null)\n\nEffect.runPromiseExit(maybe2).then(console.log)\n// Output:\n// {\n//   _id: 'Exit',\n//   _tag: 'Failure',\n//   cause: {\n//     _id: 'Cause',\n//     _tag: 'Fail',\n//     failure: { _tag: 'NoSuchElementException' }\n//   }\n// }\n```\n\n----------------------------------------\n\nTITLE: Fetching Data with Custom Error Handling in Effect\nDESCRIPTION: Example demonstrating how to use Effect.tryPromise with custom error handling. This approach allows remapping caught errors to a specific error type using the catch function.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-tryPromise.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Effect } from \"effect\"\n\nconst getTodo = (id: number) =>\n  Effect.tryPromise({\n    try: () => fetch(`https://jsonplaceholder.typicode.com/todos/${id}`),\n    // remap the error\n    catch: (unknown) => new Error(`something went wrong ${unknown}`)\n  })\n\n//      ┌─── Effect<Response, Error, never>\n//      ▼\nconst program = getTodo(1)\n```\n\n----------------------------------------\n\nTITLE: Fetching Data with Default Error Handling in Effect\nDESCRIPTION: Example showing how to use Effect.tryPromise to fetch a TODO item from an API with default error handling. The function captures any exceptions and propagates them as UnknownException.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-tryPromise.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Effect } from \"effect\"\n\nconst getTodo = (id: number) =>\n  // Will catch any errors and propagate them as UnknownException\n  Effect.tryPromise(() =>\n    fetch(`https://jsonplaceholder.typicode.com/todos/${id}`)\n  )\n\n//      ┌─── Effect<Response, UnknownException, never>\n//      ▼\nconst program = getTodo(1)\n```\n\n----------------------------------------\n\nTITLE: Effect.promise Function Signature in TypeScript\nDESCRIPTION: The TypeScript signature for the Effect.promise function, showing it accepts a function that takes an AbortSignal and returns a Promise-like object of type A, then returns an Effect of type A.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-promise.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const promise: <A>(evaluate: (signal: AbortSignal) => PromiseLike<A>) => Effect<A>\n```\n\n----------------------------------------\n\nTITLE: Using Effect.merge to Handle Both Success and Error Channels in TypeScript\nDESCRIPTION: This example demonstrates how to use Effect.merge to transform an effect that may fail into one that always returns a value, capturing both success and error outcomes in the success channel. The program initially has a potential error channel, and Effect.merge converts it to an effect that never fails.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-merge.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Effect } from \"effect\"\n\n//      ┌─── Effect<number, string, never>\n//      ▼\nconst program = Effect.fail(\"Oh uh!\").pipe(Effect.as(2))\n\n//      ┌─── Effect<number | string, never, never>\n//      ▼\nconst recovered = Effect.merge(program)\n```\n\n----------------------------------------\n\nTITLE: Combining Effects in Structs with Effect.all in TypeScript\nDESCRIPTION: Example demonstrating how to combine effects organized in a struct (object with named properties) using Effect.all. The result maintains the same structure as the input, with each property containing its corresponding effect's result.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-all.md#2025-04-11_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Effect, Console } from \"effect\"\n\nconst structOfEffects = {\n  a: Effect.succeed(42).pipe(Effect.tap(Console.log)),\n  b: Effect.succeed(\"Hello\").pipe(Effect.tap(Console.log))\n}\n\n//      ┌─── Effect<{ a: number; b: string; }, never, never>\n//      ▼\nconst resultsAsStruct = Effect.all(structOfEffects)\n\nEffect.runPromise(resultsAsStruct).then(console.log)\n// Output:\n// 42\n// Hello\n// { a: 42, b: 'Hello' }\n```\n\n----------------------------------------\n\nTITLE: Collecting Results with mode: 'either' in Effect.all in TypeScript\nDESCRIPTION: Example showing how to use the 'either' mode with Effect.all to run all effects regardless of failures. This mode collects both successes and failures, returning an array of Either instances.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-all.md#2025-04-11_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Effect, Console } from \"effect\"\n\nconst effects = [\n  Effect.succeed(\"Task1\").pipe(Effect.tap(Console.log)),\n  Effect.fail(\"Task2: Oh no!\").pipe(Effect.tap(Console.log)),\n  Effect.succeed(\"Task3\").pipe(Effect.tap(Console.log))\n]\n\nconst program = Effect.all(effects, { mode: \"either\" })\n\nEffect.runPromiseExit(program).then(console.log)\n// Output:\n// Task1\n// Task3\n// {\n//   _id: 'Exit',\n//   _tag: 'Success',\n//   value: [\n//     { _id: 'Either', _tag: 'Right', right: 'Task1' },\n//     { _id: 'Either', _tag: 'Left', left: 'Task2: Oh no!' },\n//     { _id: 'Either', _tag: 'Right', right: 'Task3' }\n//   ]\n// }\n```\n\n----------------------------------------\n\nTITLE: Defining the Encoded Schema Function in TypeScript\nDESCRIPTION: The encodedSchema function extracts the `Encoded` portion of a schema, creating a new schema type that follows the existing schema properties without including any prior modifications. This function is crucial for working with schemas while maintaining type integrity.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Schema-encodedSchema.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const encodedSchema: <A, I, R>(schema: Schema<A, I, R>) => SchemaClass<I>\n```\n\n----------------------------------------\n\nTITLE: Running Stream and Collecting Elements\nDESCRIPTION: The `runCollect` function takes a stream and executes it, collecting all emitted elements into a chunk. This function is designed for use with the Effect framework, requiring the Stream type as a parameter. The output is an Effect that resolves to a Chunk containing all elements from the stream along with any errors encountered during the execution.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-runCollect.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const runCollect: <A, E, R>(self: Stream<A, E, R>) => Effect.Effect<Chunk.Chunk<A>, E, R>\n```\n\n----------------------------------------\n\nTITLE: Implementing Metric Polling in TypeScript using Effect\nDESCRIPTION: Function signature for pollAndUpdate that takes a MetricPolling configuration and returns an Effect that polls for values and updates a metric. The function handles generic types for the metric type, input, environment, error, and output values.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/MetricPolling-pollAndUpdate.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const pollAndUpdate: <Type, In, R, E, Out>(self: MetricPolling<Type, In, R, E, Out>) => Effect.Effect<void, E, R>\n```\n\n----------------------------------------\n\nTITLE: Calculating Time Difference with DateTime.distance in TypeScript\nDESCRIPTION: Demonstrates how to use the DateTime.distance function to calculate the difference between two DateTime values in milliseconds. The example creates a current timestamp and another timestamp one minute later, then calculates the difference which equals 60000 milliseconds.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/DateTime-distance.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { DateTime, Effect } from \"effect\"\n\nEffect.gen(function* () {\n  const now = yield* DateTime.now\n  const other = DateTime.add(now, { minutes: 1 })\n\n  // returns 60000\n  DateTime.distance(now, other)\n})\n```\n\n----------------------------------------\n\nTITLE: Creating a Config with a Fixed Value in TypeScript\nDESCRIPTION: The 'succeed' function constructs a Config object containing a specified value. This is a basic building block for creating configurations with predefined values.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Config-succeed.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const succeed: <A>(value: A) => Config<A>\n```\n\n----------------------------------------\n\nTITLE: Creating a Frequency Metric in TypeScript using Effect\nDESCRIPTION: Demonstrates how to create a Frequency metric using the Metric.frequency function from the Effect package. This example creates an error frequency metric to count occurrences of errors.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Metric-frequency.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Metric } from \"effect\"\n\nconst errorFrequency = Metric.frequency(\"error_frequency\", {\n   description: \"Counts the occurrences of errors.\"\n});\n```\n\n----------------------------------------\n\nTITLE: Declaring prepend Function for Stream Manipulation in TypeScript\nDESCRIPTION: Defines the prepend function which takes a chunk of values and prepends them to a stream. It has two overloads: one for curried usage and another for direct application. The function works with generic types for stream elements, errors, and environments.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-prepend.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const prepend: { <B>(values: Chunk.Chunk<B>): <A, E, R>(self: Stream<A, E, R>) => Stream<B | A, E, R>; <A, E, R, B>(self: Stream<A, E, R>, values: Chunk.Chunk<B>): Stream<A | B, E, R>; }\n```\n\n----------------------------------------\n\nTITLE: Defining Option Type in TypeScript\nDESCRIPTION: Demonstrates the type signature for the Option data type, which can be either None or Some, representing optional values in the Effect library\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Option-Option.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ntype Option<A> = None<A> | Some<A>\n```\n\n----------------------------------------\n\nTITLE: Using Stream.zipWith in TypeScript with Effect Library\nDESCRIPTION: Demonstrates how to zip two streams together using Stream.zipWith, combining numbers and strings with a custom function. Shows how to create streams, combine them with a transformation function, and collect the results.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-zipWith.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Effect, Stream } from \"effect\"\n\n// We create two streams and zip them with custom logic.\nconst stream = Stream.zipWith(\n  Stream.make(1, 2, 3, 4, 5, 6),\n  Stream.make(\"a\", \"b\", \"c\"),\n  (n, s) => [n - s.length, s]\n)\n\nEffect.runPromise(Stream.runCollect(stream)).then(console.log)\n// { _id: 'Chunk', values: [ [ 0, 'a' ], [ 1, 'b' ], [ 2, 'c' ] ] }\n```\n\n----------------------------------------\n\nTITLE: Implementing Effect Timeout in TypeScript\nDESCRIPTION: Demonstrates how to add a timeout to an Effect, showing both successful execution and timeout scenarios. The example creates a task with a 2-second delay and applies a 1-second timeout, resulting in a TimeoutException.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-timeout.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Effect } from \"effect\"\n\nconst task = Effect.gen(function* () {\n  console.log(\"Start processing...\")\n  yield* Effect.sleep(\"2 seconds\") // Simulates a delay in processing\n  console.log(\"Processing complete.\")\n  return \"Result\"\n})\n\n// Output will show a TimeoutException as the task takes longer\n// than the specified timeout duration\nconst timedEffect = task.pipe(Effect.timeout(\"1 second\"))\n\nEffect.runPromiseExit(timedEffect).then(console.log)\n// Output:\n// Start processing...\n// {\n//   _id: 'Exit',\n//   _tag: 'Failure',\n//   cause: {\n//     _id: 'Cause',\n//     _tag: 'Fail',\n//     failure: { _tag: 'TimeoutException' }\n//   }\n// }\n```\n\n----------------------------------------\n\nTITLE: Mapping and Concatenating with Effect in Effect Stream (TS)\nDESCRIPTION: The `mapConcatEffect` function takes a stream and a function as input. The function transforms each element of the stream into an `Effect` that produces an `Iterable`. The resulting iterables are then flattened into a single output stream. This operation allows for effectful transformations that produce multiple values for each input element.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-mapConcatEffect.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const mapConcatEffect: { <A, A2, E2, R2>(f: (a: A) => Effect.Effect<Iterable<A2>, E2, R2>): <E, R>(self: Stream<A, E, R>) => Stream<A2, E2 | E, R2 | R>; <A, E, R, A2, E2, R2>(self: Stream<A, E, R>, f: (a: A) => Effect.Effect<Iterable<A2>, E2, R2>): Stream<A2, E | E2, R | R2>; }\n```\n\n----------------------------------------\n\nTITLE: Implementing Effect.ap Function for Applying Functions in TypeScript\nDESCRIPTION: This function combines two effects by applying the function produced by one effect to the value produced by another effect. It takes two effects as input: one that produces a function and another that produces a value, then applies the function to the value once both effects complete successfully.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-ap.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const ap: { <A, E2, R2>(that: Effect<A, E2, R2>): <B, R, E>(self: Effect<(a: A) => B, E, R>) => Effect<B, E | E2, R | R2>; <A, B, E, R, E2, R2>(self: Effect<(a: A) => B, E, R>, that: Effect<A, E2, R2>): Effect<B, E | E2, R | R2>; }\n```\n\n----------------------------------------\n\nTITLE: Handling Success and Failure Results with Effect.runSyncExit\nDESCRIPTION: Demonstrates how to use Effect.runSyncExit to handle both successful and failed effect operations, showing the structure of Exit results for each case.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-runSyncExit.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Effect } from \"effect\"\n\nconsole.log(Effect.runSyncExit(Effect.succeed(1)))\n// Output:\n// {\n//   _id: \"Exit\",\n//   _tag: \"Success\",\n//   value: 1\n// }\n\nconsole.log(Effect.runSyncExit(Effect.fail(\"my error\")))\n// Output:\n// {\n//   _id: \"Exit\",\n//   _tag: \"Failure\",\n//   cause: {\n//     _id: \"Cause\",\n//     _tag: \"Fail\",\n//     failure: \"my error\"\n//   }\n// }\n```\n\n----------------------------------------\n\nTITLE: Setting DateTime Zone Example in TypeScript\nDESCRIPTION: Demonstrates how to set a time zone for a DateTime object using Effect.gen function. Creates a DateTime instance for the current time and sets it to Europe/London timezone.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/DateTime-setZone.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { DateTime, Effect } from \"effect\"\n\nEffect.gen(function* () {\n  const now = yield* DateTime.now\n  const zone = DateTime.zoneUnsafeMakeNamed(\"Europe/London\")\n\n  // set the time zone\n  const zoned: DateTime.Zoned = DateTime.setZone(now, zone)\n})\n```\n\n----------------------------------------\n\nTITLE: Using takeUntil with Effect to Extract Elements Until Condition is Met in TypeScript\nDESCRIPTION: This example demonstrates how to use the takeUntil function to process a collection of numbers, taking elements until a specified condition is met. The predicate checks if a number is greater than 3, and the function returns all elements up to and including the first element that satisfies the condition.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-takeUntil.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Effect } from \"effect\"\n\nconst numbers = [1, 2, 3, 4, 5, 6]\nconst predicate = (n: number, i: number) => Effect.succeed(n > 3)\n\nconst program = Effect.gen(function*() {\n  const result = yield* Effect.takeUntil(numbers, predicate)\n  console.log(result)\n})\n\nEffect.runFork(program)\n// Output: [ 1, 2, 3, 4 ]\n```\n\n----------------------------------------\n\nTITLE: Configuring Multiple Configs with Config.all in TypeScript\nDESCRIPTION: Function signature for Config.all that constructs a consolidated config from a tuple, struct, or arguments of configs. It supports both array-like and record-like inputs, transforming them into appropriately typed configuration objects.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Config-all.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const all: <const Arg extends Iterable<Config<any>> | Record<string, Config<any>>>(arg: Arg) => Config<[Arg] extends [ReadonlyArray<Config<any>>] ? { -readonly [K in keyof Arg]: [Arg[K]] extends [Config<infer A>] ? A : never; } : [Arg] extends [Iterable<Config<infer A>>] ? Array<A> : [Arg] extends [Record<string, Config<any>>] ? { -readonly [K in keyof Arg]: [Arg[K]] extends [Config<infer A>] ? A : never; } : never>\n```\n\n----------------------------------------\n\nTITLE: Implementing Fibonacci Using Effect.fork in TypeScript\nDESCRIPTION: Example showing how to use Effect.fork to compute Fibonacci numbers concurrently. The code demonstrates creating a new fiber to run the Fibonacci calculation asynchronously without blocking the main execution flow.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-fork.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Effect } from \"effect\"\n\nconst fib = (n: number): Effect.Effect<number> =>\n  n < 2\n    ? Effect.succeed(n)\n    : Effect.zipWith(fib(n - 1), fib(n - 2), (a, b) => a + b)\n\n//      ┌─── Effect<RuntimeFiber<number, never>, never, never>\n//      ▼\nconst fib10Fiber = Effect.fork(fib(10))\n```\n\n----------------------------------------\n\nTITLE: Transforming Schema Instances in TypeScript\nDESCRIPTION: This snippet implements a method called transform that generates a new `Schema` by reshaping the input and output of an existing `Schema` using specified decoding and encoding functions. It supports both strict and non-strict transformation. The primary parameters include `to` and `from` for target and source schemas, respectively, with `options` dictating the decoding and encoding logic. This functionality is essential for schema manipulations in strongly-typed effect systems.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Schema-transform.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const transform: { <To extends Schema.Any, From extends Schema.Any>(to: To, options: { readonly decode: (fromA: Schema.Type<From>, fromI: Schema.Encoded<From>) => Schema.Encoded<To>; readonly encode: (toI: Schema.Encoded<To>, toA: Schema.Type<To>) => Schema.Type<From>; readonly strict?: true; } | { readonly decode: (fromA: Schema.Type<From>, fromI: Schema.Encoded<From>) => unknown; readonly encode: (toI: Schema.Encoded<To>, toA: Schema.Type<To>) => unknown; readonly strict: false; }): (from: From) => transform<From, To>; <To extends Schema.Any, From extends Schema.Any>(from: From, to: To, options: { readonly decode: (fromA: Schema.Type<From>, fromI: Schema.Encoded<From>) => Schema.Encoded<To>; readonly encode: (toI: Schema.Encoded<To>, toA: Schema.Type<To>) => Schema.Type<From>; readonly strict?: true; } | { readonly decode: (fromA: Schema.Type<From>, fromI: Schema.Encoded<From>) => unknown; readonly encode: (toI: Schema.Encoded<To>, toA: Schema.Type<To>) => unknown; readonly strict: false; }): transform<From, To>; }\n```\n\n----------------------------------------\n\nTITLE: Using Effect.orDie for Error Handling in TypeScript\nDESCRIPTION: Demonstrates how to use Effect.orDie to convert a potentially failing division operation into a fiber termination. The example shows error propagation when attempting to divide by zero, converting the error into an unrecoverable defect.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-orDie.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Effect } from \"effect\"\n\nconst divide = (a: number, b: number) =>\n  b === 0\n    ? Effect.fail(new Error(\"Cannot divide by zero\"))\n    : Effect.succeed(a / b)\n\n//      ┌─── Effect<number, never, never>\n//      ▼\nconst program = Effect.orDie(divide(1, 0))\n\nEffect.runPromise(program).catch(console.error)\n// Output:\n// (FiberFailure) Error: Cannot divide by zero\n//   ...stack trace...\n```\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const orDie: <A, E, R>(self: Effect<A, E, R>) => Effect<A, never, R>\n```\n\n----------------------------------------\n\nTITLE: Creating Semaphore with Effect in TypeScript\nDESCRIPTION: Example showing how to create a semaphore with 3 permits using Effect.makeSemaphore. The semaphore can be used to control concurrent access to shared resources.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-makeSemaphore.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Effect } from \"effect\"\n\n// Create a semaphore with 3 permits\nconst mutex = Effect.makeSemaphore(3)\n```\n\n----------------------------------------\n\nTITLE: Creating Custom Logger with Formatted Messages in TypeScript using Effect\nDESCRIPTION: This snippet demonstrates how to create a custom logger using Logger.make from the Effect library. It shows how to format log messages, set minimum log levels, and replace the default logger in a program.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Logger-make.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Effect, Logger, LogLevel } from \"effect\"\n\nconst logger = Logger.make(({ logLevel, message }) => {\n  globalThis.console.log(`[${logLevel.label}] ${message}`)\n})\n\nconst task1 = Effect.logDebug(\"task1 done\")\nconst task2 = Effect.logDebug(\"task2 done\")\n\nconst program = Effect.gen(function*() {\n  yield* Effect.log(\"start\")\n  yield* task1\n  yield* task2\n  yield* Effect.log(\"done\")\n}).pipe(\n  Logger.withMinimumLogLevel(LogLevel.Debug),\n  Effect.provide(Logger.replace(Logger.defaultLogger, logger))\n)\n\nEffect.runFork(program)\n// [INFO] start\n// [DEBUG] task1 done\n// [DEBUG] task2 done\n// [INFO] done\n```\n\n----------------------------------------\n\nTITLE: Filtering Effect with Custom Error Using Effect.filterOrFail in TypeScript\nDESCRIPTION: This example demonstrates how to use Effect.filterOrFail to filter an effect, ensure a user is not null, and narrow down the type. It shows the usage of a custom type guard and error handling.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-filterOrFail.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Effect, pipe } from \"effect\"\n\n// Define a user interface\ninterface User {\n  readonly name: string\n}\n\n// Simulate an asynchronous authentication function\ndeclare const auth: () => Promise<User | null>\n\nconst program = pipe(\n  Effect.promise(() => auth()),\n  // Use filterOrFail with a custom type guard to ensure user is not null\n  Effect.filterOrFail(\n    (user): user is User => user !== null, // Type guard\n    () => new Error(\"Unauthorized\")\n  ),\n  // 'user' now has the type `User` (not `User | null`)\n  Effect.andThen((user) => user.name)\n)\n```\n\n----------------------------------------\n\nTITLE: Monitoring Fiber Count with Effect.supervised in TypeScript\nDESCRIPTION: This example demonstrates how to use Effect.supervised to monitor the number of active fibers during a recursive Fibonacci calculation. It uses a supervisor to track child fibers and periodically logs the fiber count.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-supervised.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Effect, Supervisor, Schedule, Fiber, FiberStatus } from \"effect\"\n\n// Main program that monitors fibers while calculating a Fibonacci number\nconst program = Effect.gen(function* () {\n  // Create a supervisor to track child fibers\n  const supervisor = yield* Supervisor.track\n\n  // Start a Fibonacci calculation, supervised by the supervisor\n  const fibFiber = yield* fib(20).pipe(\n    Effect.supervised(supervisor),\n    // Fork the Fibonacci effect into a fiber\n    Effect.fork\n  )\n\n  // Define a schedule to periodically monitor the fiber count every 500ms\n  const policy = Schedule.spaced(\"500 millis\").pipe(\n    Schedule.whileInputEffect((_) =>\n      Fiber.status(fibFiber).pipe(\n        // Continue while the Fibonacci fiber is not done\n        Effect.andThen((status) => status !== FiberStatus.done)\n      )\n    )\n  )\n\n  // Start monitoring the fibers, using the supervisor to track the count\n  const monitorFiber = yield* monitorFibers(supervisor).pipe(\n    // Repeat the monitoring according to the schedule\n    Effect.repeat(policy),\n    // Fork the monitoring into its own fiber\n    Effect.fork\n  )\n\n  // Join the monitor and Fibonacci fibers to ensure they complete\n  yield* Fiber.join(monitorFiber)\n  const result = yield* Fiber.join(fibFiber)\n\n  console.log(`fibonacci result: ${result}`)\n})\n\n// Function to monitor and log the number of active fibers\nconst monitorFibers = (\n  supervisor: Supervisor.Supervisor<Array<Fiber.RuntimeFiber<any, any>>>\n): Effect.Effect<void> =>\n  Effect.gen(function* () {\n    const fibers = yield* supervisor.value // Get the current set of fibers\n    console.log(`number of fibers: ${fibers.length}`)\n  })\n\n// Recursive Fibonacci calculation, spawning fibers for each recursive step\nconst fib = (n: number): Effect.Effect<number> =>\n  Effect.gen(function* () {\n    if (n <= 1) {\n      return 1\n    }\n    yield* Effect.sleep(\"500 millis\") // Simulate work by delaying\n\n    // Fork two fibers for the recursive Fibonacci calls\n    const fiber1 = yield* Effect.fork(fib(n - 2))\n    const fiber2 = yield* Effect.fork(fib(n - 1))\n\n    // Join the fibers to retrieve their results\n    const v1 = yield* Fiber.join(fiber1)\n    const v2 = yield* Fiber.join(fiber2)\n\n    return v1 + v2 // Combine the results\n  })\n\nEffect.runPromise(program)\n// Output:\n// number of fibers: 0\n// number of fibers: 2\n// number of fibers: 6\n// number of fibers: 14\n// number of fibers: 30\n// number of fibers: 62\n// number of fibers: 126\n// number of fibers: 254\n// number of fibers: 510\n// number of fibers: 1022\n// number of fibers: 2034\n// number of fibers: 3795\n// number of fibers: 5810\n// number of fibers: 6474\n// number of fibers: 4942\n// number of fibers: 2515\n// number of fibers: 832\n// number of fibers: 170\n// number of fibers: 18\n// number of fibers: 0\n// fibonacci result: 10946\n```\n\n----------------------------------------\n\nTITLE: Effect.filter Function Signature in TypeScript\nDESCRIPTION: This code block shows the TypeScript signature of the Effect.filter function. It includes overloads for different parameter orders and options for customizing the filtering behavior.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-filter.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const filter: { <A, E, R>(predicate: (a: NoInfer<A>, i: number) => Effect<boolean, E, R>, options?: { readonly concurrency?: Concurrency | undefined; readonly batching?: boolean | \"inherit\" | undefined; readonly negate?: boolean | undefined; readonly concurrentFinalizers?: boolean | undefined; } | undefined): (elements: Iterable<A>) => Effect<Array<A>, E, R>; <A, E, R>(elements: Iterable<A>, predicate: (a: NoInfer<A>, i: number) => Effect<boolean, E, R>, options?: { readonly concurrency?: Concurrency | undefined; readonly batching?: boolean | \"inherit\" | undefined; readonly negate?: boolean | undefined; readonly concurrentFinalizers?: boolean | undefined; } | undefined): Effect<Array<A>, E, R>; }\n```\n\n----------------------------------------\n\nTITLE: Declaring a Tag with a Default Value in Effect.ts\nDESCRIPTION: This example demonstrates how to create a context tag with a default value using Context.Reference. It shows defining a SpecialNumber class that extends Context.Reference with a default value of 2048, then accessing that value in an Effect program without needing to provide an implementation.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Context-Reference.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { Context, Effect } from \"effect\"\n\nclass SpecialNumber extends Context.Reference<SpecialNumber>()(\n  \"SpecialNumber\",\n  { defaultValue: () => 2048 }\n) {}\n\n//      ┌─── Effect<void, never, never>\n//      ▼\nconst program = Effect.gen(function* () {\n  const specialNumber = yield* SpecialNumber\n  console.log(`The special number is ${specialNumber}`)\n})\n\n// No need to provide the SpecialNumber implementation\nEffect.runPromise(program)\n// Output: The special number is 2048\n```\n\n----------------------------------------\n\nTITLE: Declaring mapChunks Function for Stream Transformation in TypeScript\nDESCRIPTION: Defines the mapChunks function that transforms chunks emitted by a stream. It can be used in two ways: either by passing the stream first and then the transformation function, or by passing the transformation function first and then the stream.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-mapChunks.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const mapChunks: { <A, B>(f: (chunk: Chunk.Chunk<A>) => Chunk.Chunk<B>): <E, R>(self: Stream<A, E, R>) => Stream<B, E, R>; <A, E, R, B>(self: Stream<A, E, R>, f: (chunk: Chunk.Chunk<A>) => Chunk.Chunk<B>): Stream<B, E, R>; }\n```\n\n----------------------------------------\n\nTITLE: Combining Schedules with a Custom Function in TypeScript\nDESCRIPTION: The `intersectWith` function combines two schedules and allows execution only when both schedules allow it. This function requires a merging function to define how the intervals will be combined. The resulting schedule provides outputs as a tuple, based on the intersection of the input types of the combined schedules.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Schedule-intersectWith.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const intersectWith: { <Out2, In2, R2>(that: Schedule<Out2, In2, R2>, f: (x: Intervals.Intervals, y: Intervals.Intervals) => Intervals.Intervals): <Out, In, R>(self: Schedule<Out, In, R>) => Schedule<[Out, Out2], In & In2, R2 | R>; <Out, In, R, Out2, In2, R2>(self: Schedule<Out, In, R>, that: Schedule<Out2, In2, R2>, f: (x: Intervals.Intervals, y: Intervals.Intervals) => Intervals.Intervals): Schedule<[Out, Out2], In & In2, R | R2>; }\n```\n\n----------------------------------------\n\nTITLE: Executing Effects as Promises with Runtime.runPromise in TypeScript\nDESCRIPTION: A function that runs an Effect and returns a JavaScript Promise that resolves with the effect's value or rejects with its error. It takes a runtime, an effect to execute, and optional abort signal options. This function is meant to be used at the program's edges for interoperability with Promise-based APIs.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Runtime-runPromise.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const runPromise: { <R>(runtime: Runtime<R>): <A, E>(effect: Effect.Effect<A, E, R>, options?: { readonly signal?: AbortSignal; } | undefined) => Promise<A>; <R, A, E>(runtime: Runtime<R>, effect: Effect.Effect<A, E, R>, options?: { readonly signal?: AbortSignal; } | undefined): Promise<A>; }\n```\n\n----------------------------------------\n\nTITLE: Using JSON Logger with Effect in TypeScript\nDESCRIPTION: Demonstrates how to use the JSON logger with Effect, including logging messages, annotating logs, and adding log spans. The example shows how the output is formatted as a JSON object.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Logger-json.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Effect, Logger } from \"effect\"\n\nconst program = Effect.log(\"message1\", \"message2\").pipe(\n  Effect.annotateLogs({ key1: \"value1\", key2: \"value2\" }),\n  Effect.withLogSpan(\"myspan\")\n)\n\nEffect.runFork(program.pipe(Effect.provide(Logger.json)))\n// {\"message\":[\"message1\",\"message2\"],\"logLevel\":\"INFO\",\"timestamp\":\"...\",\"annotations\":{\"key2\":\"value2\",\"key1\":\"value1\"},\"spans\":{\"myspan\":0},\"fiberId\":\"#0\"}\n```\n\n----------------------------------------\n\nTITLE: Polling Fiber State in TypeScript using effect Package\nDESCRIPTION: The poll function tentatively observes a fiber's state, returning immediately if the fiber is not already done. It returns an Effect that resolves to an Option of the fiber's Exit state.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Fiber-poll.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const poll: <A, E>(self: Fiber<A, E>) => Effect.Effect<Option.Option<Exit.Exit<A, E>>>\n```\n\n----------------------------------------\n\nTITLE: Racing Two Failing Effects in TypeScript\nDESCRIPTION: Illustrates racing two effects that both fail, resulting in a combined failure cause containing both errors.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-race.md#2025-04-11_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Effect, Console } from \"effect\"\n\nconst task1 = Effect.fail(\"task1\").pipe(\n  Effect.delay(\"100 millis\"),\n  Effect.tap(Console.log(\"task1 done\")),\n  Effect.onInterrupt(() => Console.log(\"task1 interrupted\"))\n)\nconst task2 = Effect.fail(\"task2\").pipe(\n  Effect.delay(\"200 millis\"),\n  Effect.tap(Console.log(\"task2 done\")),\n  Effect.onInterrupt(() => Console.log(\"task2 interrupted\"))\n)\n\nconst program = Effect.race(task1, task2)\n\nEffect.runPromiseExit(program).then(console.log)\n// Output:\n// {\n//   _id: 'Exit',\n//   _tag: 'Failure',\n//   cause: {\n//     _id: 'Cause',\n//     _tag: 'Parallel',\n//     left: { _id: 'Cause', _tag: 'Fail', failure: 'task1' },\n//     right: { _id: 'Cause', _tag: 'Fail', failure: 'task2' }\n//   }\n// }\n```\n\n----------------------------------------\n\nTITLE: Effect.forEach Function Signature in TypeScript\nDESCRIPTION: The type signature for the Effect.forEach function, showing its polymorphic nature with support for different argument orders, concurrency options, and result handling configurations.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-forEach.md#2025-04-11_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const forEach: { <B, E, R, S extends Iterable<any>>(f: (a: RA.ReadonlyArray.Infer<S>, i: number) => Effect<B, E, R>, options?: { readonly concurrency?: Concurrency | undefined; readonly batching?: boolean | \"inherit\" | undefined; readonly discard?: false | undefined; readonly concurrentFinalizers?: boolean | undefined; } | undefined): (self: S) => Effect<RA.ReadonlyArray.With<S, B>, E, R>; <A, B, E, R>(f: (a: A, i: number) => Effect<B, E, R>, options: { readonly concurrency?: Concurrency | undefined; readonly batching?: boolean | \"inherit\" | undefined; readonly discard: true; readonly concurrentFinalizers?: boolean | undefined; }): (self: Iterable<A>) => Effect<void, E, R>; <B, E, R, S extends Iterable<any>>(self: S, f: (a: RA.ReadonlyArray.Infer<S>, i: number) => Effect<B, E, R>, options?: { readonly concurrency?: Concurrency | undefined; readonly batching?: boolean | \"inherit\" | undefined; readonly discard?: false | undefined; readonly concurrentFinalizers?: boolean | undefined; } | undefined): Effect<RA.ReadonlyArray.With<S, B>, E, R>; <A, B, E, R>(self: Iterable<A>, f: (a: A, i: number) => Effect<B, E, R>, options: { readonly concurrency?: Concurrency | undefined; readonly batching?: boolean | \"inherit\" | undefined; readonly discard: true; readonly concurrentFinalizers?: boolean | undefined; }): Effect<void, E, R>; }\n```\n\n----------------------------------------\n\nTITLE: Effect.catchTag Function Signature in TypeScript\nDESCRIPTION: The type signature for the Effect.catchTag function. It shows the function's overloaded nature, accepting either a tag and handler first, or an Effect instance with a tag and handler.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-catchTag.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const catchTag: { <K extends E extends { _tag: string; } ? E[\"_tag\"] : never, E, A1, E1, R1>(k: K, f: (e: NoInfer<Extract<E, { _tag: K; }>>) => Effect<A1, E1, R1>): <A, R>(self: Effect<A, E, R>) => Effect<A1 | A, E1 | Exclude<E, { _tag: K; }>, R1 | R>; <A, E, R, K extends E extends { _tag: string; } ? E[\"_tag\"] : never, R1, E1, A1>(self: Effect<A, E, R>, k: K, f: (e: Extract<E, { _tag: K; }>) => Effect<A1, E1, R1>): Effect<A | A1, E1 | Exclude<E, { _tag: K; }>, R | R1>; }\n```\n\n----------------------------------------\n\nTITLE: Running a Cleanup Function with Effect.onExit in TypeScript\nDESCRIPTION: This example demonstrates how to use Effect.onExit to ensure a cleanup function runs after an effect completes, showing cases for success, failure, and interruption scenarios. It utilizes the Effect and Console modules from the effect package.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-onExit.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Console, Effect, Exit } from \"effect\"\n\n// Define a cleanup effect that logs the result\nconst handler = Effect.onExit((exit) =>\n  Console.log(`Cleanup completed: ${Exit.getOrElse(exit, String)}`)\n)\n\n// Define a successful effect\nconst success = Console.log(\"Task completed\").pipe(\n  Effect.as(\"some result\"),\n  handler\n)\n\nEffect.runFork(success)\n// Output:\n// Task completed\n// Cleanup completed: some result\n\n// Define a failing effect\nconst failure = Console.log(\"Task failed\").pipe(\n  Effect.andThen(Effect.fail(\"some error\")),\n  handler\n)\n\nEffect.runFork(failure)\n// Output:\n// Task failed\n// Cleanup completed: Error: some error\n\n// Define an interrupted effect\nconst interruption = Console.log(\"Task interrupted\").pipe(\n  Effect.andThen(Effect.interrupt),\n  handler\n)\n\nEffect.runFork(interruption)\n// Output:\n// Task interrupted\n// Cleanup completed: All fibers interrupted without errors.\n```\n\n----------------------------------------\n\nTITLE: Implementing List.head Function in TypeScript\nDESCRIPTION: This function returns the first element of a given list, or None if the list is empty. It operates on a List<A> and returns an Option<A>.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/List-head.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const head: <A>(self: List<A>) => Option.Option<A>\n```\n\n----------------------------------------\n\nTITLE: Filtering Effects with Custom Error Handling in TypeScript\nDESCRIPTION: Example demonstrating how to use filterEffectOrFail to filter an Effect result with an effectful predicate. The example shows authentication validation that fails with a custom error if the user is null.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-filterEffectOrFail.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Effect, pipe } from \"effect\"\n\n// Define a user interface\ninterface User {\n  readonly name: string\n}\n\n// Simulate an asynchronous authentication function\ndeclare const auth: () => Promise<User | null>\n\nconst program = pipe(\n  Effect.promise(() => auth()),\n  // Use filterEffectOrFail with an effectful predicate\n  Effect.filterEffectOrFail({\n    predicate: (user) => Effect.succeed(user !== null),\n    orFailWith: () => new Error(\"Unauthorized\")\n  }),\n)\n```\n\n----------------------------------------\n\nTITLE: Using Effect.suspend to Improve TypeScript Type Inference\nDESCRIPTION: This example illustrates how Effect.suspend can help TypeScript infer types correctly in situations where multiple branches return different effect types.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-suspend.md#2025-04-11_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Effect } from \"effect\"\n\n//   Without suspend, TypeScript may struggle with type inference.\n//   Inferred type:\n//     (a: number, b: number) =>\n//       Effect<never, Error, never> | Effect<number, never, never>\nconst withoutSuspend = (a: number, b: number) =>\n  b === 0\n    ? Effect.fail(new Error(\"Cannot divide by zero\"))\n    : Effect.succeed(a / b)\n\n//   Using suspend to unify return types.\n//   Inferred type:\n//     (a: number, b: number) => Effect<number, Error, never>\nconst withSuspend = (a: number, b: number) =>\n  Effect.suspend(() =>\n    b === 0\n      ? Effect.fail(new Error(\"Cannot divide by zero\"))\n      : Effect.succeed(a / b)\n  )\n```\n\n----------------------------------------\n\nTITLE: Mapping Stream Elements with Random Effects in TypeScript\nDESCRIPTION: This example demonstrates how to use Stream.mapEffect to transform a stream of numbers into random integers between 0 and each number. It showcases the integration with Effect and Random modules.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-mapEffect.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Effect, Random, Stream } from \"effect\"\n\nconst stream = Stream.make(10, 20, 30).pipe(\n  Stream.mapEffect((n) => Random.nextIntBetween(0, n))\n)\n\nEffect.runPromise(Stream.runCollect(stream)).then(console.log)\n// Example Output: { _id: 'Chunk', values: [ 7, 19, 8 ] }\n```\n\n----------------------------------------\n\nTITLE: Combining Effects in Records with Effect.all in TypeScript\nDESCRIPTION: Example showing how to combine effects in a record (string-indexed object) using Effect.all. This pattern is useful when dealing with dynamically generated keys and consistent value types.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-all.md#2025-04-11_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Effect, Console } from \"effect\"\n\nconst recordOfEffects: Record<string, Effect.Effect<number>> = {\n  key1: Effect.succeed(1).pipe(Effect.tap(Console.log)),\n  key2: Effect.succeed(2).pipe(Effect.tap(Console.log))\n}\n\n//      ┌─── Effect<{ [x: string]: number; }, never, never>\n//      ▼\nconst resultsAsRecord = Effect.all(recordOfEffects)\n\nEffect.runPromise(resultsAsRecord).then(console.log)\n// Output:\n// 1\n// 2\n// { key1: 1, key2: 2 }\n```\n\n----------------------------------------\n\nTITLE: Using Array.intersection to Find Common Elements in TypeScript\nDESCRIPTION: This example demonstrates how to use the Array.intersection function to find common elements between two arrays. The result preserves the order based on the first iterable.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Array-intersection.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Array } from \"effect\"\n\nconst result = Array.intersection([1, 2, 3], [3, 4, 1])\nconsole.log(result) // [1, 3]\n```\n\n----------------------------------------\n\nTITLE: Using Effect.match to Handle Success and Failure Cases in TypeScript\nDESCRIPTION: This snippet demonstrates how to use Effect.match to handle both success and failure cases of an effect without triggering side effects. It shows examples with both successful and failed effects, converting them to string messages.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-match.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Effect } from \"effect\"\n\nconst success: Effect.Effect<number, Error> = Effect.succeed(42)\n\nconst program1 = Effect.match(success, {\n  onFailure: (error) => `failure: ${error.message}`,\n  onSuccess: (value) => `success: ${value}`\n})\n\n// Run and log the result of the successful effect\nEffect.runPromise(program1).then(console.log)\n// Output: \"success: 42\"\n\nconst failure: Effect.Effect<number, Error> = Effect.fail(\n  new Error(\"Uh oh!\")\n)\n\nconst program2 = Effect.match(failure, {\n  onFailure: (error) => `failure: ${error.message}`,\n  onSuccess: (value) => `success: ${value}`\n})\n\n// Run and log the result of the failed effect\nEffect.runPromise(program2).then(console.log)\n// Output: \"failure: Uh oh!\"\n```\n\n----------------------------------------\n\nTITLE: Using Effect.onError for Cleanup on Failure in TypeScript\nDESCRIPTION: This example demonstrates how to use the Effect.onError function to execute cleanup logic when an effect fails. It shows four scenarios: a successful effect (where cleanup doesn't run), a failure effect, an effect with a defect, and an interrupted effect - all demonstrating how the cleanup handler receives the cause of failure.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-onError.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Console, Effect } from \"effect\"\n\n// This handler logs the failure cause when the effect fails\nconst handler = Effect.onError((cause) =>\n  Console.log(`Cleanup completed: ${cause}`)\n)\n\n// Define a successful effect\nconst success = Console.log(\"Task completed\").pipe(\n  Effect.as(\"some result\"),\n  handler\n)\n\nEffect.runFork(success)\n// Output:\n// Task completed\n\n// Define a failing effect\nconst failure = Console.log(\"Task failed\").pipe(\n  Effect.andThen(Effect.fail(\"some error\")),\n  handler\n)\n\nEffect.runFork(failure)\n// Output:\n// Task failed\n// Cleanup completed: Error: some error\n\n// Define a failing effect\nconst defect = Console.log(\"Task failed with defect\").pipe(\n  Effect.andThen(Effect.die(\"Boom!\")),\n  handler\n)\n\nEffect.runFork(defect)\n// Output:\n// Task failed with defect\n// Cleanup completed: Error: Boom!\n\n// Define an interrupted effect\nconst interruption = Console.log(\"Task interrupted\").pipe(\n  Effect.andThen(Effect.interrupt),\n  handler\n)\n\nEffect.runFork(interruption)\n// Output:\n// Task interrupted\n// Cleanup completed: All fibers interrupted without errors.\n```\n\n----------------------------------------\n\nTITLE: Defining a Simple Resource with Effect.acquireRelease in TypeScript\nDESCRIPTION: This snippet demonstrates how to use Effect.acquireRelease to create a resource management workflow. It defines a MyResource interface, simulates resource acquisition and release, and creates an Effect that manages the resource lifecycle.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-acquireRelease.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Effect } from \"effect\"\n\n// Define an interface for a resource\ninterface MyResource {\n  readonly contents: string\n  readonly close: () => Promise<void>\n}\n\n// Simulate resource acquisition\nconst getMyResource = (): Promise<MyResource> =>\n  Promise.resolve({\n    contents: \"lorem ipsum\",\n    close: () =>\n      new Promise((resolve) => {\n        console.log(\"Resource released\")\n        resolve()\n      })\n  })\n\n// Define how the resource is acquired\nconst acquire = Effect.tryPromise({\n  try: () =>\n    getMyResource().then((res) => {\n      console.log(\"Resource acquired\")\n      return res\n    }),\n  catch: () => new Error(\"getMyResourceError\")\n})\n\n// Define how the resource is released\nconst release = (res: MyResource) => Effect.promise(() => res.close())\n\n// Create the resource management workflow\n//\n//      ┌─── Effect<MyResource, Error, Scope>\n//      ▼\nconst resource = Effect.acquireRelease(acquire, release)\n```\n\n----------------------------------------\n\nTITLE: Example Usage of Effect.timeoutFail with Custom Error Type\nDESCRIPTION: Demonstrates how to use Effect.timeoutFail to add a custom timeout error to an effect. The example shows a task that sleeps for 2 seconds, but times out after 1 second, resulting in a custom MyTimeoutError being raised.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-timeoutFail.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Effect } from \"effect\"\n\nconst task = Effect.gen(function* () {\n  console.log(\"Start processing...\")\n  yield* Effect.sleep(\"2 seconds\") // Simulates a delay in processing\n  console.log(\"Processing complete.\")\n  return \"Result\"\n})\n\nclass MyTimeoutError {\n  readonly _tag = \"MyTimeoutError\"\n}\n\nconst program = task.pipe(\n  Effect.timeoutFail({\n    duration: \"1 second\",\n    onTimeout: () => new MyTimeoutError() // Custom timeout error\n  })\n)\n\nEffect.runPromiseExit(program).then(console.log)\n// Output:\n// Start processing...\n// {\n//   _id: 'Exit',\n//   _tag: 'Failure',\n//   cause: {\n//     _id: 'Cause',\n//     _tag: 'Fail',\n//     failure: MyTimeoutError { _tag: 'MyTimeoutError' }\n//   }\n// }\n```\n\n----------------------------------------\n\nTITLE: Collecting Results with mode: 'validate' in Effect.all in TypeScript\nDESCRIPTION: Example demonstrating the 'validate' mode with Effect.all, which uses Option to indicate success or failure. Each effect returns None for success and Some with the error for failure.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-all.md#2025-04-11_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Effect, Console } from \"effect\"\n\nconst effects = [\n  Effect.succeed(\"Task1\").pipe(Effect.tap(Console.log)),\n  Effect.fail(\"Task2: Oh no!\").pipe(Effect.tap(Console.log)),\n  Effect.succeed(\"Task3\").pipe(Effect.tap(Console.log))\n]\n\nconst program = Effect.all(effects, { mode: \"validate\" })\n\nEffect.runPromiseExit(program).then((result) => console.log(\"%o\", result))\n// Output:\n// Task1\n// Task3\n// {\n//   _id: 'Exit',\n//   _tag: 'Failure',\n//   cause: {\n//     _id: 'Cause',\n//     _tag: 'Fail',\n//     failure: [\n//       { _id: 'Option', _tag: 'None' },\n//       { _id: 'Option', _tag: 'Some', value: 'Task2: Oh no!' },\n//       { _id: 'Option', _tag: 'None' }\n//     ]\n//   }\n// }\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Lazy Evaluation with Side Effects using Effect.suspend in TypeScript\nDESCRIPTION: This example shows how Effect.suspend can be used for lazy evaluation, ensuring side effects are re-executed on each invocation, unlike eager evaluation.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-suspend.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Effect } from \"effect\"\n\nlet i = 0\n\nconst bad = Effect.succeed(i++)\n\nconst good = Effect.suspend(() => Effect.succeed(i++))\n\nconsole.log(Effect.runSync(bad)) // Output: 0\nconsole.log(Effect.runSync(bad)) // Output: 0\n\nconsole.log(Effect.runSync(good)) // Output: 1\nconsole.log(Effect.runSync(good)) // Output: 2\n```\n\n----------------------------------------\n\nTITLE: Creating Integer Branded Type with Validation in TypeScript\nDESCRIPTION: Demonstrates how to create a branded integer type with runtime validation using Brand.refined. The example shows creating an Int type that ensures values are integers, with error handling for invalid inputs.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Brand-refined.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { Brand } from \"effect\"\n\ntype Int = number & Brand.Brand<\"Int\">\n\nconst Int = Brand.refined<Int>(\n  (n) => Number.isInteger(n),\n  (n) => Brand.error(`Expected ${n} to be an integer`)\n)\n\nconsole.log(Int(1))\n// 1\n\nassert.throws(() => Int(1.1))\n```\n\n----------------------------------------\n\nTITLE: Using HashSet.forEach in TypeScript with Effect Library\nDESCRIPTION: Demonstrates different ways to use the HashSet.forEach function to iterate over values in a HashSet. Shows three usage patterns: data-last (pipeable) API, pipe method, and data-first API. The time complexity is O(n).\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/HashSet-forEach.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// Syntax\nimport { HashSet, pipe } from \"effect\"\n\n// with `data-last`, a.k.a. `pipeable` API\npipe(HashSet.make(0, 1, 2), HashSet.forEach(console.log)) // logs: 0 1 2\n\n// or piped with the pipe method\nHashSet.make(0, 1, 2).pipe(HashSet.forEach(console.log)) // logs: 0 1 2\n\n// or with `data-first` API\nHashSet.forEach(HashSet.make(0, 1, 2), console.log) // logs: 0 1 2\n```\n\n----------------------------------------\n\nTITLE: Creating Window Event Listener Stream in TypeScript for Effect.io\nDESCRIPTION: Defines a function to create a Stream from window.addEventListener. It takes an event type and optional configuration options, returning a Stream of the corresponding event type.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/BrowserStream-fromEventListenerWindow.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const fromEventListenerWindow: <K extends keyof WindowEventMap>(type: K, options?: boolean | { readonly capture?: boolean; readonly passive?: boolean; readonly once?: boolean; readonly bufferSize?: number | \"unbounded\" | undefined; } | undefined) => Stream.Stream<WindowEventMap[K], never, never>\n```\n\n----------------------------------------\n\nTITLE: Example of Chaining Arithmetic Operations with pipe\nDESCRIPTION: A complete example showing how to use pipe to chain simple arithmetic operations on a number value.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Function-pipe.md#2025-04-11_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { pipe } from \"effect\"\n\n// Define simple arithmetic operations\nconst increment = (x: number) => x + 1\nconst double = (x: number) => x * 2\nconst subtractTen = (x: number) => x - 10\n\n// Sequentially apply these operations using `pipe`\nconst result = pipe(5, increment, double, subtractTen)\n\nconsole.log(result)\n// Output: 2\n```\n\n----------------------------------------\n\nTITLE: Creating Bounded Queue in TypeScript using Effect Package\nDESCRIPTION: Creates a new bounded Queue with a specified capacity. When the queue is full, additional offer calls are suspended until space becomes available. For optimal performance, it's recommended to use power of 2 capacities.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Queue-bounded.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const bounded: <A>(requestedCapacity: number) => Effect.Effect<Queue<A>>\n```\n\n----------------------------------------\n\nTITLE: Updating FiberRef Values in Effect Module\nDESCRIPTION: Function signature for updating FiberRef values of a running fiber. Takes a function that receives the runtime FiberId and current FiberRefs and returns updated FiberRefs. Returns an Effect that resolves to void.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-updateFiberRefs.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const updateFiberRefs: (f: (fiberId: FiberId.Runtime, fiberRefs: FiberRefs.FiberRefs) => FiberRefs.FiberRefs) => Effect<void>\n```\n\n----------------------------------------\n\nTITLE: Option Bind Usage Example with Do Simulation in Effect\nDESCRIPTION: This code snippet demonstrates how to use the `Option.bind` function in conjunction with `Option.Do`, `Option.let`, and `Option.filter` to perform a series of operations on `Option` values within a monadic context. It defines variables `x` and `y`, calculates their sum, and then filters the result based on a condition. The `assert.deepStrictEqual` verifies the expected output.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Option-bind.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { Option, pipe } from \"effect\"\n\nconst result = pipe(\n  Option.Do,\n  Option.bind(\"x\", () => Option.some(2)),\n  Option.bind(\"y\", () => Option.some(3)),\n  Option.let(\"sum\", ({ x, y }) => x + y),\n  Option.filter(({ x, y }) => x * y > 5)\n)\nassert.deepStrictEqual(result, Option.some({ x: 2, y: 3, sum: 5 }))\n```\n\n----------------------------------------\n\nTITLE: Handling Specific Errors with Effect.catchSome in TypeScript\nDESCRIPTION: This example demonstrates how to use Effect.catchSome to selectively catch and handle HttpError errors while letting other error types pass through. It creates a program that may fail with either HttpError or ValidationError, and then applies error handling only for HttpError.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-catchSome.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Effect, Random, Option } from \"effect\"\n\nclass HttpError {\n  readonly _tag = \"HttpError\"\n}\n\nclass ValidationError {\n  readonly _tag = \"ValidationError\"\n}\n\n//      ┌─── Effect<string, HttpError | ValidationError, never>\n//      ▼\nconst program = Effect.gen(function* () {\n  const n1 = yield* Random.next\n  const n2 = yield* Random.next\n  if (n1 < 0.5) {\n    yield* Effect.fail(new HttpError())\n  }\n  if (n2 < 0.5) {\n    yield* Effect.fail(new ValidationError())\n  }\n  return \"some result\"\n})\n\n//      ┌─── Effect<string, HttpError | ValidationError, never>\n//      ▼\nconst recovered = program.pipe(\n  Effect.catchSome((error) => {\n    // Only handle HttpError errors\n    if (error._tag === \"HttpError\") {\n      return Option.some(Effect.succeed(\"Recovering from HttpError\"))\n    } else {\n      return Option.none()\n    }\n  })\n)\n```\n\n----------------------------------------\n\nTITLE: Using Array.forEach to Iterate with Side Effects in TypeScript\nDESCRIPTION: Demonstrates how to use the Array.forEach utility function to perform side effects for each element in an array. This function accepts an iterable collection and a callback function that will be executed for each element.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Array-forEach.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Array } from \"effect\"\n\nArray.forEach([1, 2, 3], n => console.log(n)) // 1, 2, 3\n```\n\n----------------------------------------\n\nTITLE: Effect.cachedFunction Type Signature in TypeScript\nDESCRIPTION: The type signature for the cachedFunction utility, showing its parameters and return type. It accepts a function that performs an effect and an optional equivalence function for comparing inputs, returning an effectful function that creates a memoized version.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-cachedFunction.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const cachedFunction: <A, B, E, R>(f: (a: A) => Effect<B, E, R>, eq?: Equivalence<A>) => Effect<(a: A) => Effect<B, E, R>>\n```\n\n----------------------------------------\n\nTITLE: Using flow for Function Composition in TypeScript\nDESCRIPTION: Demonstrates how to use the 'flow' function to compose multiple functions together in a left-to-right manner. The example shows composing a string length function with a doubling function to create a new function that calculates twice the length of a string.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Function-flow.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { flow } from \"effect/Function\"\n\nconst len = (s: string): number => s.length\nconst double = (n: number): number => n * 2\n\nconst f = flow(len, double)\n\nassert.strictEqual(f('aaa'), 6)\n```\n\n----------------------------------------\n\nTITLE: Using Effect.repeatN to Repeat Console Log Operations in TypeScript\nDESCRIPTION: This example demonstrates how to use Effect.repeatN to repeat a console log operation a specified number of times. It imports the necessary modules, defines an action that logs 'success', and creates a program that repeats this action twice in addition to the initial execution.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-repeatN.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Effect, Console } from \"effect\"\n\nconst action = Console.log(\"success\")\nconst program = Effect.repeatN(action, 2)\n\nEffect.runPromise(program)\n```\n\n----------------------------------------\n\nTITLE: Recovering from Errors in STM Operations - TypeScript\nDESCRIPTION: This snippet shows the implementation of the catchAll function, which is used to recover from all errors encountered in STM operations. It accepts a function that maps an error to a new STM operation and applies it to the original STM context. The function is generic, accommodating multiple types of error and result scenarios, and seamlessly incorporates into the STM ecosystem by utilizing existing transactions.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/STM-catchAll.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const catchAll: { <E, B, E1, R1>(f: (e: E) => STM<B, E1, R1>): <A, R>(self: STM<A, E, R>) => STM<B | A, E1, R1 | R>; <A, E, R, B, E1, R1>(self: STM<A, E, R>, f: (e: E) => STM<B, E1, R1>): STM<A | B, E1, R | R1>; }\n```\n\n----------------------------------------\n\nTITLE: Applying Option.flatMap in Effect Library TypeScript\nDESCRIPTION: The code demonstrates using `Option.flatMap` from the Effect library to chain operations on a `User` object. It applies a function to extract the street from an `Option` of `Address`. If the street is present, it is returned wrapped in a `Some` Option. This function is useful for cleanly handling optional values without repeated null checks.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Option-flatMap.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Option } from \"effect\"\n\ninterface Address {\n  readonly city: string\n  readonly street: Option.Option<string>\n}\n\ninterface User {\n  readonly id: number\n  readonly username: string\n  readonly email: Option.Option<string>\n  readonly address: Option.Option<Address>\n}\n\nconst user: User = {\n  id: 1,\n  username: \"john_doe\",\n  email: Option.some(\"john.doe@example.com\"),\n  address: Option.some({\n    city: \"New York\",\n    street: Option.some(\"123 Main St\")\n  })\n}\n\n// Use flatMap to extract the street value\nconst street = user.address.pipe(\n  Option.flatMap((address) => address.street)\n)\n\nconsole.log(street)\n// Output: { _id: 'Option', _tag: 'Some', value: '123 Main St' }\n```\n\n----------------------------------------\n\nTITLE: Executing Asynchronous Effects with Callbacks in TypeScript\nDESCRIPTION: Function signature for runCallback that executes an Effect asynchronously and handles the result using a callback. It returns a cancellation function and accepts an effect instance along with optional runtime options. The callback receives either a success value or failure information.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-runCallback.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const runCallback: <A, E>(effect: Effect<A, E>, options?: Runtime.RunCallbackOptions<A, E> | undefined) => Runtime.Cancel<A, E>\n```\n\n----------------------------------------\n\nTITLE: Implementing JSON Logging with Effect Logger\nDESCRIPTION: Demonstrates how to use the jsonLogger to format log messages as JSON objects. The example shows logging messages with annotations and spans, which get formatted into a structured JSON output including metadata like timestamp and fiber ID.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Logger-jsonLogger.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Effect, Logger } from \"effect\"\n\nconst program = Effect.log(\"message1\", \"message2\").pipe(\n  Effect.annotateLogs({ key1: \"value1\", key2: \"value2\" }),\n  Effect.withLogSpan(\"myspan\")\n)\n\nEffect.runFork(program.pipe(Effect.provide(Logger.json)))\n// {\"message\":[\"message1\",\"message2\"],\"logLevel\":\"INFO\",\"timestamp\":\"...\",\"annotations\":{\"key2\":\"value2\",\"key1\":\"value1\"},\"spans\":{\"myspan\":0},\"fiberId\":\"#0\"}\n```\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const jsonLogger: Logger<unknown, string>\n```\n\n----------------------------------------\n\nTITLE: Merging Streams Effect-TS TypeScript\nDESCRIPTION: This snippet demonstrates merging two streams using the Effect-TS library in TypeScript. It includes the creation and scheduling of two streams and the merging operation with custom mapping functions. The final merged stream is collected and logged using a promise. Required dependency is the effect package, particularly its Stream and Schedule modules. Inputs are two streams, and the output is a single merged stream, processed by custom mapping functions.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-mergeWith.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { Effect, Schedule, Stream } from \"effect\"\n\nconst s1 = Stream.make(\"1\", \"2\", \"3\").pipe(\n  Stream.schedule(Schedule.spaced(\"100 millis\"))\n)\nconst s2 = Stream.make(4.1, 5.3, 6.2).pipe(\n  Stream.schedule(Schedule.spaced(\"200 millis\"))\n)\n\nconst stream = Stream.mergeWith(s1, s2, {\n  onSelf: (s) => parseInt(s),\n  onOther: (n) => Math.floor(n)\n})\n\nEffect.runPromise(Stream.runCollect(stream)).then(console.log)\n// { _id: 'Chunk', values: [ 1, 4, 2, 3, 5, 6 ] }\n```\n\n----------------------------------------\n\nTITLE: Defining takeUntilEffect for Stream in TypeScript\nDESCRIPTION: The takeUntilEffect function takes a predicate that evaluates to a boolean effect and returns a new stream of elements up to the point where the predicate returns true. This allows for conditional stream processing based on asynchronous criteria, significantly enhancing stream manipulation capabilities.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-takeUntilEffect.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const takeUntilEffect: { <A, E2, R2>(predicate: (a: NoInfer<A>) => Effect.Effect<boolean, E2, R2>): <E, R>(self: Stream<A, E, R>) => Stream<A, E2 | E, R2 | R>; <A, E, R, E2, R2>(self: Stream<A, E, R>, predicate: (a: A) => Effect.Effect<boolean, E2, R2>): Stream<A, E | E2, R | R2>; }\n```\n\n----------------------------------------\n\nTITLE: Using Effect.liftPredicate with Predicates in TypeScript\nDESCRIPTION: Demonstrates how to transform a predicate function into an Effect. The example shows creating a predicate for positive numbers and using it with liftPredicate to either succeed with the input value or fail with a custom error message.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-liftPredicate.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Effect } from \"effect\"\n\nconst isPositive = (n: number): boolean => n > 0\n\n// succeeds with `1`\nEffect.liftPredicate(1, isPositive, n => `${n} is not positive`)\n\n// fails with `\"0 is not positive\"`\nEffect.liftPredicate(0, isPositive, n => `${n} is not positive`)\n```\n\n----------------------------------------\n\nTITLE: Background Task Execution Example in Effect-TS\nDESCRIPTION: Demonstrates running a repeating console log effect in the background using Effect.runFork and interrupting it after 500ms. Shows how to create and manage background tasks using fibers.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-runFork.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Effect, Console, Schedule, Fiber } from \"effect\"\n\n//      ┌─── Effect<number, never, never>\n//      ▼\nconst program = Effect.repeat(\n  Console.log(\"running...\"),\n  Schedule.spaced(\"200 millis\")\n)\n\n//      ┌─── RuntimeFiber<number, never>\n//      ▼\nconst fiber = Effect.runFork(program)\n\nsetTimeout(() => {\n  Effect.runFork(Fiber.interrupt(fiber))\n}, 500)\n```\n\n----------------------------------------\n\nTITLE: TypeScript Function Signature for DateTime.getPart\nDESCRIPTION: This code snippet shows the TypeScript function signature for the DateTime.getPart function. It describes two overloads: one that takes a part parameter and returns a function, and another that takes both the DateTime object and the part parameter.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/DateTime-getPart.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const getPart: { (part: keyof DateTime.PartsWithWeekday): (self: DateTime) => number; (self: DateTime, part: keyof DateTime.PartsWithWeekday): number; }\n```\n\n----------------------------------------\n\nTITLE: Using Random.choice in TypeScript with effect package\nDESCRIPTION: This example demonstrates how to use the Random.choice function to get a random element from an array. It uses the Effect.gen function for asynchronous generation.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Random-choice.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Effect, Random } from \"effect\"\n\nEffect.gen(function* () {\n  const randomItem = yield* Random.choice([1, 2, 3])\n  console.log(randomItem)\n})\n```\n\n----------------------------------------\n\nTITLE: Defining concatMapWith Function for Channel in TypeScript\nDESCRIPTION: Declares a function that concatenates channels based on output elements, using a factory function and merging functions for terminal values. It returns a new channel with combined outputs and merged terminal values.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Channel-concatMapWith.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const concatMapWith: { <OutElem, OutElem2, InElem2, OutErr2, InErr2, OutDone, InDone2, Env2, OutDone2, OutDone3>(f: (o: OutElem) => Channel<OutElem2, InElem2, OutErr2, InErr2, OutDone, InDone2, Env2>, g: (o: OutDone, o1: OutDone) => OutDone, h: (o: OutDone, o2: OutDone2) => OutDone3): <Env, InErr, InElem, InDone, OutErr>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone2, InDone, Env>) => Channel<OutElem2, InElem & InElem2, OutErr2 | OutErr, InErr & InErr2, OutDone3, InDone & InDone2, Env2 | Env>; <OutElem, InElem, OutErr, InErr, OutDone2, InDone, Env, OutElem2, InElem2, OutErr2, InErr2, OutDone, InDone2, Env2, OutDone3>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone2, InDone, Env>, f: (o: OutElem) => Channel<OutElem2, InElem2, OutErr2, InErr2, OutDone, InDone2, Env2>, g: (o: OutDone, o1: OutDone) => OutDone, h: (o: OutDone, o2: OutDone2) => OutDone3): Channel<OutElem2, InElem & InElem2, OutErr | OutErr2, InErr & InErr2, OutDone3, InDone & InDone2, Env | Env2>; }\n```\n\n----------------------------------------\n\nTITLE: Filtering Stream with Effect in TypeScript\nDESCRIPTION: The `filterEffect` method allows for filtering elements in a stream based on an effectful predicate function. Dependencies include TypeScript and the Effect library. The primary purpose is to take each stream element and determine if it should be retained by applying the provided effectful function. Inputs are a stream and a predicate function; the output is a filtered stream with possibly modified error and environment types. Constraints enforce the use of the Effect library types and patterns.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-filterEffect.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const filterEffect: { <A, E2, R2>(f: (a: NoInfer<A>) => Effect.Effect<boolean, E2, R2>): <E, R>(self: Stream<A, E, R>) => Stream<A, E2 | E, R2 | R>; <A, E, R, E2, R2>(self: Stream<A, E, R>, f: (a: A) => Effect.Effect<boolean, E2, R2>): Stream<A, E | E2, R | R2>; }\n```\n\n----------------------------------------\n\nTITLE: Grouping Array Elements by Key in TypeScript\nDESCRIPTION: Demonstrates how to use the Array.groupBy function to split an array of objects into sub-arrays based on a specified key. The function takes an iterable and a key-generating function, returning an object with grouped non-empty arrays.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Array-groupBy.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Array } from \"effect\"\n\nconst people = [\n  { name: \"Alice\", group: \"A\" },\n  { name: \"Bob\", group: \"B\" },\n  { name: \"Charlie\", group: \"A\" }\n]\n\nconst result = Array.groupBy(people, person => person.group)\nconsole.log(result)\n// {\n//  A: [{ name: \"Alice\", group: \"A\" }, { name: \"Charlie\", group: \"A\" }],\n//  B: [{ name: \"Bob\", group: \"B\" }]\n// }\n```\n\n----------------------------------------\n\nTITLE: Recovering from Tagged Errors in TypeScript\nDESCRIPTION: This snippet declares the catchTag function which facilitates recovery from errors tagged with a specific identifier. It allows the user to pass a function that defines the handling logic for the error identified by its tag. The function can optionally be applied to a Micro effect instance, enabling more flexible error handling within the Effect framework.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Micro-catchTag.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const catchTag: { <K extends E extends { _tag: string; } ? E[\"_tag\"] : never, E, A1, E1, R1>(k: K, f: (e: Extract<E, { _tag: K; }>) => Micro<A1, E1, R1>): <A, R>(self: Micro<A, E, R>) => Micro<A1 | A, E1 | Exclude<E, { _tag: K; }>, R1 | R>; <A, E, R, K extends E extends { _tag: string; } ? E[\"_tag\"] : never, R1, E1, A1>(self: Micro<A, E, R>, k: K, f: (e: Extract<E, { _tag: K; }>) => Micro<A1, E1, R1>): Micro<A | A1, E1 | Exclude<E, { _tag: K; }>, R | R1>; }\n```\n\n----------------------------------------\n\nTITLE: Measuring Execution Time with Effect.timed in TypeScript\nDESCRIPTION: This example demonstrates how to use the Effect.timed function to measure how long an effect takes to execute. It wraps a task that sleeps for 2 seconds, then logs both the execution duration in milliseconds and the result value.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-timed.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Duration, Effect } from \"effect\"\n\nconst task = Effect.gen(function*() {\n  yield* Effect.sleep(\"2 seconds\") // Simulates some work\n  return \"some result\"\n})\n\nconst timedTask = task.pipe(Effect.timed)\n\nconst program = Effect.gen(function*() {\n  const [duration, result] = yield* timedTask\n  console.log(`Task completed in ${Duration.toMillis(duration)} ms with result: ${result}`)\n})\n\nEffect.runFork(program)\n// Output: Task completed in 2003.749125 ms with result: some result\n```\n\n----------------------------------------\n\nTITLE: Using Effect.checkInterruptible with Console Output\nDESCRIPTION: Example showing how to use Effect.checkInterruptible to handle different interruption states. Demonstrates both interruptible and uninterruptible cases using Effect.runPromise.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-checkInterruptible.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Console, Effect } from \"effect\"\n\nconst program = Effect.gen(function*() {\n  yield* Effect.checkInterruptible((isInterruptible) => {\n    if (isInterruptible) {\n      return Console.log(\"You can interrupt this operation.\")\n    } else {\n      return Console.log(\"This operation cannot be interrupted.\")\n    }\n  })\n})\n\nEffect.runPromise(program)\n// Output: You can interrupt this operation.\n\nEffect.runPromise(program.pipe(Effect.uninterruptible))\n// Output: This operation cannot be interrupted.\n```\n\n----------------------------------------\n\nTITLE: Recovering from All Errors with Effect.catchAllCause in TypeScript\nDESCRIPTION: This example demonstrates how to use Effect.catchAllCause to recover from both regular errors and defects by examining the cause of the failure. It creates a program that fails, then adds recovery logic that handles different types of errors.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-catchAllCause.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Cause, Effect } from \"effect\"\n\n// Define an effect that may fail with a recoverable or unrecoverable error\nconst program = Effect.fail(\"Something went wrong!\")\n\n// Recover from all errors by examining the cause\nconst recovered = program.pipe(\n  Effect.catchAllCause((cause) =>\n    Cause.isFailType(cause)\n      ? Effect.succeed(\"Recovered from a regular error\")\n      : Effect.succeed(\"Recovered from a defect\")\n  )\n)\n\nEffect.runPromise(recovered).then(console.log)\n// Output: \"Recovered from a regular error\"\n```\n\n----------------------------------------\n\nTITLE: Combining Layers Concurrently in TypeScript\nDESCRIPTION: The mergeAll function combines multiple layers concurrently, creating a new layer with merged input, error, and output types. It takes an array of Layer objects as input and returns a new Layer object.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Layer-mergeAll.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const mergeAll: <Layers extends [Layer<never, any, any>, ...Array<Layer<never, any, any>>]>(...layers: Layers) => Layer<{ [k in keyof Layers]: Layer.Success<Layers[k]>; }[number], { [k in keyof Layers]: Layer.Error<Layers[k]>; }[number], { [k in keyof Layers]: Layer.Context<Layers[k]>; }[number]>\n```\n\n----------------------------------------\n\nTITLE: Using Effect.timeoutOption in TypeScript\nDESCRIPTION: This example demonstrates how to use Effect.timeoutOption to handle timeouts gracefully. It creates two tasks with different timeout durations and logs the results.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-timeoutOption.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Effect } from \"effect\"\n\nconst task = Effect.gen(function* () {\n  console.log(\"Start processing...\")\n  yield* Effect.sleep(\"2 seconds\") // Simulates a delay in processing\n  console.log(\"Processing complete.\")\n  return \"Result\"\n})\n\nconst timedOutEffect = Effect.all([\n  task.pipe(Effect.timeoutOption(\"3 seconds\")),\n  task.pipe(Effect.timeoutOption(\"1 second\"))\n])\n\nEffect.runPromise(timedOutEffect).then(console.log)\n// Output:\n// Start processing...\n// Processing complete.\n// Start processing...\n// [\n//   { _id: 'Option', _tag: 'Some', value: 'Result' },\n//   { _id: 'Option', _tag: 'None' }\n// ]\n```\n\n----------------------------------------\n\nTITLE: Stream.throttle Type Definition\nDESCRIPTION: TypeScript type signature for the Stream.throttle function. Defines the function parameters including cost function, units, duration, burst size and throttling strategy options.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-throttle.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const throttle: { <A>(options: { readonly cost: (chunk: Chunk.Chunk<A>) => number; readonly units: number; readonly duration: Duration.DurationInput; readonly burst?: number | undefined; readonly strategy?: \"enforce\" | \"shape\" | undefined; }): <E, R>(self: Stream<A, E, R>) => Stream<A, E, R>; <A, E, R>(self: Stream<A, E, R>, options: { readonly cost: (chunk: Chunk.Chunk<A>) => number; readonly units: number; readonly duration: Duration.DurationInput; readonly burst?: number | undefined; readonly strategy?: \"enforce\" | \"shape\" | undefined; }): Stream<A, E, R>; }\n```\n\n----------------------------------------\n\nTITLE: Implementing Cache.makeWith in Effect-TS\nDESCRIPTION: Creates a new cache with specified capacity, time to live, and lookup function. The time to live can depend on the Exit value returned by the lookup function. This function is available since v2.0.0 of the Effect library.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Cache-makeWith.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const makeWith: <Key, Value, Error = never, Environment = never>(options: { readonly capacity: number; readonly lookup: Lookup<Key, Value, Error, Environment>; readonly timeToLive: (exit: Exit.Exit<Value, Error>) => Duration.DurationInput; }) => Effect.Effect<Cache<Key, Value, Error>, never, Environment>\n```\n\n----------------------------------------\n\nTITLE: Implementing Config Validation in TypeScript\nDESCRIPTION: The validate function returns a config that describes the same structure as the original, but performs validation during loading. It supports both refinement and predicate-based validation approaches with custom error messages.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Config-validate.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const validate: { <A, B extends A>(options: { readonly message: string; readonly validation: Refinement<A, B>; }): (self: Config<A>) => Config<B>; <A>(options: { readonly message: string; readonly validation: Predicate<A>; }): (self: Config<A>) => Config<A>; <A, B extends A>(self: Config<A>, options: { readonly message: string; readonly validation: Refinement<A, B>; }): Config<B>; <A>(self: Config<A>, options: { readonly message: string; readonly validation: Predicate<A>; }): Config<A>; }\n```\n\n----------------------------------------\n\nTITLE: Stream.filter Signature in TypeScript\nDESCRIPTION: This TypeScript declaration provides the signature for the `filter` function of the Stream module in Effect. It defines multiple overloads for the filter method, allowing for both refinement of types and predicate filtering. These signatures inform how the method can be used with different types and predicates, ensuring type safety and flexibility when filtering streams.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-filter.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const filter: { <A, B extends A>(refinement: Refinement<NoInfer<A>, B>): <E, R>(self: Stream<A, E, R>) => Stream<B, E, R>; <A, B extends A>(predicate: Predicate<B>): <E, R>(self: Stream<A, E, R>) => Stream<A, E, R>; <A, E, R, B extends A>(self: Stream<A, E, R>, refinement: Refinement<A, B>): Stream<B, E, R>; <A, E, R>(self: Stream<A, E, R>, predicate: Predicate<A>): Stream<A, E, R>; }\n```\n\n----------------------------------------\n\nTITLE: Offering a Value to a Queue in TypeScript using Effect Library\nDESCRIPTION: The offer function is used to place one value in a queue. It can be called in two ways: either by passing the value first and then the queue, or by passing the queue first and then the value. The function returns an Effect that resolves to a boolean, likely indicating whether the offer was successful.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Queue-offer.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const offer: { <A>(value: A): (self: Enqueue<A>) => Effect.Effect<boolean>; <A>(self: Enqueue<A>, value: A): Effect.Effect<boolean>; }\n```\n\n----------------------------------------\n\nTITLE: Implementing Structured Logging with Effect in TypeScript\nDESCRIPTION: This snippet demonstrates how to use the structured logger from the Effect library. It shows creating a program with log messages, annotations, and a log span, then running it with the structured logger provider.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Logger-structuredLogger.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Effect, Logger } from \"effect\"\n\nconst program = Effect.log(\"message1\", \"message2\").pipe(\n  Effect.annotateLogs({ key1: \"value1\", key2: \"value2\" }),\n  Effect.withLogSpan(\"myspan\")\n)\n\nEffect.runFork(program.pipe(Effect.provide(Logger.structured)))\n// {\n//   message: [ 'message1', 'message2' ],\n//   logLevel: 'INFO',\n//   timestamp: '2024-07-09T14:05:41.623Z',\n//   cause: undefined,\n//   annotations: { key2: 'value2', key1: 'value1' },\n//   spans: { myspan: 0 },\n//   fiberId: '#0'\n// }\n```\n\n----------------------------------------\n\nTITLE: Creating Streams from Chunks with Effect Library in TypeScript\nDESCRIPTION: This snippet demonstrates creating a stream from multiple data chunks using the `Stream.fromChunks` method of the Effect library. It imports necessary components such as Chunk and Effect, and illustrates collecting and logging the values in the composed stream. Dependencies include the `effect` package.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-fromChunks.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Chunk, Effect, Stream } from \"effect\"\n\n// Creating a stream with values from multiple Chunks\nconst stream = Stream.fromChunks(Chunk.make(1, 2, 3), Chunk.make(4, 5, 6))\n\nEffect.runPromise(Stream.runCollect(stream)).then(console.log)\n// { _id: 'Chunk', values: [ 1, 2, 3, 4, 5, 6 ] }\n```\n\n----------------------------------------\n\nTITLE: Implementing Single Execution Pattern with Effect.once in TypeScript\nDESCRIPTION: Example demonstrating how to use Effect.once to ensure an effect executes only once regardless of multiple calls. Shows comparison between regular effect execution and once-wrapped execution using Console.log statements.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-once.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Effect, Console } from \"effect\"\n\nconst program = Effect.gen(function* () {\n  const task1 = Console.log(\"task1\")\n  yield* Effect.repeatN(task1, 2)\n  const task2 = yield* Effect.once(Console.log(\"task2\"))\n  yield* Effect.repeatN(task2, 2)\n})\n\nEffect.runFork(program)\n// Output:\n// task1\n// task1\n// task1\n// task2\n```\n\n----------------------------------------\n\nTITLE: Marking an Effect as Interruptible in TypeScript\nDESCRIPTION: The `interruptible` function is used to mark an effect as interruptible. It takes an `Effect` as input and returns a new `Effect` that is marked as interruptible. This function is useful for controlling the interruptibility of effects in an Effect-based application.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-interruptible.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const interruptible: <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R>\n```\n\n----------------------------------------\n\nTITLE: Using AbortSignal for Interruption in Effect.async\nDESCRIPTION: Example showing how to utilize the AbortSignal parameter to handle interruption in an Effect.async operation. This approach allows for clean cancellation of long-running operations by listening to the abort event.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-async.md#2025-04-11_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Effect, Fiber } from \"effect\"\n\n// A task that supports interruption using AbortSignal\nconst interruptibleTask = Effect.async<void, Error>((resume, signal) => {\n  // Handle interruption\n  signal.addEventListener(\"abort\", () => {\n    console.log(\"Abort signal received\")\n    clearTimeout(timeoutId)\n  })\n\n  // Simulate a long-running task\n  const timeoutId = setTimeout(() => {\n    console.log(\"Operation completed\")\n    resume(Effect.void)\n  }, 2000)\n})\n\nconst program = Effect.gen(function* () {\n  const fiber = yield* Effect.fork(interruptibleTask)\n  // Simulate interrupting the fiber after 1 second\n  yield* Effect.sleep(\"1 second\")\n  yield* Fiber.interrupt(fiber)\n})\n\n// Run the program\nEffect.runPromise(program)\n// Output:\n// Abort signal received\n```\n\n----------------------------------------\n\nTITLE: Effect.loop Function Signature in TypeScript\nDESCRIPTION: The complete type definition for the Effect.loop function, showing its polymorphic nature and support for different options including refinement types, conditional checks, and result handling strategies.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-loop.md#2025-04-11_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const loop: { <A, B extends A, C, E, R>(initial: A, options: { readonly while: Refinement<A, B>; readonly step: (b: B) => A; readonly body: (b: B) => Effect<C, E, R>; readonly discard?: false | undefined; }): Effect<Array<C>, E, R>; <A, C, E, R>(initial: A, options: { readonly while: (a: A) => boolean; readonly step: (a: A) => A; readonly body: (a: A) => Effect<C, E, R>; readonly discard?: false | undefined; }): Effect<Array<C>, E, R>; <A, B extends A, C, E, R>(initial: A, options: { readonly while: Refinement<A, B>; readonly step: (b: B) => A; readonly body: (b: B) => Effect<C, E, R>; readonly discard: true; }): Effect<void, E, R>; <A, C, E, R>(initial: A, options: { readonly while: (a: A) => boolean; readonly step: (a: A) => A; readonly body: (a: A) => Effect<C, E, R>; readonly discard: true; }): Effect<void, E, R>; }\n```\n\n----------------------------------------\n\nTITLE: Simultaneously Filter and Map STM Effects in TypeScript\nDESCRIPTION: This TypeScript snippet defines the `collect` function in the STM module, enabling simultaneous filtering and mapping of effects. The function requires a partial function `pf` that operates on items of type `A` and returns an `Option` of type `A2`. It outputs an STM effect of type `A2` using either curried or direct application. Dependencies include the Option module from the Effect TypeScript library.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/STM-collect.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const collect: { <A, A2>(pf: (a: A) => Option.Option<A2>): <E, R>(self: STM<A, E, R>) => STM<A2, E, R>; <A, E, R, A2>(self: STM<A, E, R>, pf: (a: A) => Option.Option<A2>): STM<A2, E, R>; }\n```\n\n----------------------------------------\n\nTITLE: Implementing Parallel Sink Execution with raceWith in TypeScript\nDESCRIPTION: The raceWith method runs two sinks in parallel on the input, using the specified merge function as soon as one result or the other has been computed. It provides fine-grained control through merge decision callbacks that determine how to handle the results when either sink completes.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Sink-raceWith.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const raceWith: { <A2, In2, L2, E2, R2, A, E, A3, A4>(options: { readonly other: Sink<A2, In2, L2, E2, R2>; readonly onSelfDone: (exit: Exit.Exit<A, E>) => MergeDecision.MergeDecision<R2, E2, A2, E2 | E, A3>; readonly onOtherDone: (exit: Exit.Exit<A2, E2>) => MergeDecision.MergeDecision<R2, E, A, E2 | E, A4>; readonly capacity?: number | undefined; }): <In, L, R>(self: Sink<A, In, L, E, R>) => Sink<A3 | A4, In & In2, L2 | L, E2 | E, R2 | R>; <A, In, L, E, R, A2, In2, L2, E2, R2, A3, A4>(self: Sink<A, In, L, E, R>, options: { readonly other: Sink<A2, In2, L2, E2, R2>; readonly onSelfDone: (exit: Exit.Exit<A, E>) => MergeDecision.MergeDecision<R2, E2, A2, E | E2, A3>; readonly onOtherDone: (exit: Exit.Exit<A2, E2>) => MergeDecision.MergeDecision<R2, E, A, E | E2, A4>; readonly capacity?: number | undefined; }): Sink<A3 | A4, In & In2, L | L2, E | E2, R | R2>; }\n```\n\n----------------------------------------\n\nTITLE: Using Effect.partition to Process Items and Handle Failures in TypeScript\nDESCRIPTION: This example demonstrates how to use Effect.partition to process an array of numbers, separating even numbers (successes) from odd numbers (failures). The function continues processing all elements even when failures occur, collecting failures and successes in separate arrays.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-partition.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Effect } from \"effect\"\n\n//      ┌─── Effect<[string[], number[]], never, never>\n//      ▼\nconst program = Effect.partition([0, 1, 2, 3, 4], (n) => {\n  if (n % 2 === 0) {\n    return Effect.succeed(n)\n  } else {\n    return Effect.fail(`${n} is not even`)\n  }\n})\n\nEffect.runPromise(program).then(console.log, console.error)\n// Output:\n// [ [ '1 is not even', '3 is not even' ], [ 0, 2, 4 ] ]\n```\n\n----------------------------------------\n\nTITLE: Creating HTTP API Collection with HttpApi.make in TypeScript\nDESCRIPTION: Function signature for creating an HttpApi instance that represents a collection of HTTP endpoints. Takes an identifier string parameter and returns an HttpApi type with generic parameters for ID, never type, and HttpApiDecodeError.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/HttpApi-make.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const make: <const Id extends string>(identifier: Id) => HttpApi<Id, never, HttpApiDecodeError>\n```\n\n----------------------------------------\n\nTITLE: Creating HTTP API Layer in Effect\nDESCRIPTION: The 'api' function creates a top-level HttpApi layer. It takes an HttpApi object and returns a Layer that can be used in an Effect application to handle HTTP API requests.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/HttpApiBuilder-api.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const api: <Id extends string, Groups extends HttpApiGroup.HttpApiGroup.Any, E, R>(api: HttpApi.HttpApi<Id, Groups, E, R>) => Layer.Layer<HttpApi.Api, never, HttpApiGroup.HttpApiGroup.ToService<Id, Groups> | R | HttpApiGroup.HttpApiGroup.ErrorContext<Groups>>\n```\n\n----------------------------------------\n\nTITLE: Adding Service Charge Example with Effect.map in TypeScript\nDESCRIPTION: Illustrates a practical use case of Effect.map by adding a service charge to a transaction amount. It fetches a transaction amount asynchronously, then applies a service charge using Effect.map.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-map.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { pipe, Effect } from \"effect\"\n\nconst addServiceCharge = (amount: number) => amount + 1\n\nconst fetchTransactionAmount = Effect.promise(() => Promise.resolve(100))\n\nconst finalAmount = pipe(\n  fetchTransactionAmount,\n  Effect.map(addServiceCharge)\n)\n\nEffect.runPromise(finalAmount).then(console.log)\n// Output: 101\n```\n\n----------------------------------------\n\nTITLE: Dropping Elements from a Stream - TypeScript\nDESCRIPTION: This snippet declares a method `dropRight` which allows the user to remove a specified number of elements from the end of a Stream. It features two signatures: one for a curried approach and another for direct invocation. The method returns a new Stream with the specified elements dropped. Dependencies include the Effect library's Stream module. Key parameters are `n`, representing the number of elements to drop, and `self`, the Stream instance.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-dropRight.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const dropRight: { (n: number): <A, E, R>(self: Stream<A, E, R>) => Stream<A, E, R>; <A, E, R>(self: Stream<A, E, R>, n: number): Stream<A, E, R>; }\n```\n\n----------------------------------------\n\nTITLE: Implementing Channel.mergeOutWith in TypeScript for Effect Library\nDESCRIPTION: This function merges multiple channels emitted by a source channel using a back-pressuring strategy. It takes a number parameter indicating how many channels to merge and a function to combine the result values of completed subchannels. The function supports both curried and non-curried calling styles.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Channel-mergeOutWith.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const mergeOutWith: { <OutDone1>(n: number, f: (o1: OutDone1, o2: OutDone1) => OutDone1): <OutElem1, InElem1, OutErr1, InErr1, InDone1, Env1, InElem, OutErr, InErr, InDone, Env>(self: Channel<Channel<OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>, InElem, OutErr, InErr, OutDone1, InDone, Env>) => Channel<OutElem1, InElem & InElem1, OutErr1 | OutErr, InErr & InErr1, OutDone1, InDone & InDone1, Env1 | Env>; <OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1, InElem, OutErr, InErr, InDone, Env>(self: Channel<Channel<OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>, InElem, OutErr, InErr, OutDone1, InDone, Env>, n: number, f: (o1: OutDone1, o2: OutDone1) => OutDone1): Channel<OutElem1, InElem & InElem1, OutErr1 | OutErr, InErr & InErr1, OutDone1, InDone & InDone1, Env1 | Env>; }\n```\n\n----------------------------------------\n\nTITLE: Deduplicating Adjacent Elements in an Iterable (TypeScript)\nDESCRIPTION: Defines a function 'dedupeAdjacentWith' that removes adjacent duplicate elements from an Iterable based on a provided equivalence function. It can be used with currying or direct application.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Iterable-dedupeAdjacentWith.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const dedupeAdjacentWith: { <A>(isEquivalent: (self: A, that: A) => boolean): (self: Iterable<A>) => Iterable<A>; <A>(self: Iterable<A>, isEquivalent: (self: A, that: A) => boolean): Iterable<A>; }\n```\n\n----------------------------------------\n\nTITLE: Using Stream.Do for Declarative Style in Effect\nDESCRIPTION: This example demonstrates how to use Stream.Do to create a declarative flow. It binds variables 'x' and 'y' to Stream values and then uses 'let' to define a computed value 'sum'. The result is a Stream that contains an object with all defined variables.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-Do.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { Chunk, Effect, pipe, Stream } from \"effect\"\n\nconst result = pipe(\n  Stream.Do,\n  Stream.bind(\"x\", () => Stream.succeed(2)),\n  Stream.bind(\"y\", () => Stream.succeed(3)),\n  Stream.let(\"sum\", ({ x, y }) => x + y)\n)\nassert.deepStrictEqual(Effect.runSync(Stream.runCollect(result)), Chunk.of({ x: 2, y: 3, sum: 5 }))\n```\n\n----------------------------------------\n\nTITLE: Executing Effects with Runtime.runFork in TypeScript\nDESCRIPTION: The runFork function executes an effect using either a provided Scheduler or the global Scheduler. It returns a RuntimeFiber that represents the running computation. The function can be called in multiple ways with different parameter orders.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Runtime-runFork.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const runFork: { <R>(runtime: Runtime<R>): <A, E>(effect: Effect.Effect<A, E, R>, options?: RunForkOptions | undefined) => Fiber.RuntimeFiber<A, E>; <R, A, E>(runtime: Runtime<R>, effect: Effect.Effect<A, E, R>, options?: RunForkOptions | undefined): Fiber.RuntimeFiber<A, E>; }\n```\n\n----------------------------------------\n\nTITLE: Creating a Closeable Scope in TypeScript\nDESCRIPTION: This snippet demonstrates how to declare a function `make` that creates a new closeable scope. The function accepts an optional `ExecutionStrategy` parameter, defaulting to `sequential` if not provided. It returns an `Effect` wrapping a `CloseableScope`, and is essential for managing resources that need cleanup operations upon scope exit.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Scope-make.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const make: (executionStrategy?: ExecutionStrategy.ExecutionStrategy) => Effect.Effect<CloseableScope>\n```\n\n----------------------------------------\n\nTITLE: Retrying Until a Specific Condition is Met in TypeScript\nDESCRIPTION: Illustrates how to use Effect.retry with a custom condition. The example retries an action until a specific error condition is met.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-retry.md#2025-04-11_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Effect } from \"effect\"\n\nlet count = 0\n\n// Define an effect that simulates varying error on each invocation\nconst action = Effect.failSync(() => {\n  console.log(`Action called ${++count} time(s)`)\n  return `Error ${count}`\n})\n\n// Retry the action until a specific condition is met\nconst program = Effect.retry(action, {\n  until: (err) => err === \"Error 3\"\n})\n\nEffect.runPromiseExit(program).then(console.log)\n// Output:\n// Action called 1 time(s)\n// Action called 2 time(s)\n// Action called 3 time(s)\n// {\n//   _id: 'Exit',\n//   _tag: 'Failure',\n//   cause: { _id: 'Cause', _tag: 'Fail', failure: 'Error 3' }\n// }\n```\n\n----------------------------------------\n\nTITLE: Accessing Effect Context in TypeScript\nDESCRIPTION: Function signature for retrieving the full context of an effect. The context function returns an Effect that provides access to the Context container holding dependencies and environment values needed by the effect to run.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-context.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const context: <R>() => Effect<Context.Context<R>, never, R>\n```\n\n----------------------------------------\n\nTITLE: Handling All Defects with Effect.catchAllDefect in TypeScript\nDESCRIPTION: Demonstrates how to use Effect.catchAllDefect to handle runtime errors and other defects in an Effect-based program. It shows how to catch and log different types of defects.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-catchAllDefect.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Effect, Cause, Console } from \"effect\"\n\n// Simulating a runtime error\nconst task = Effect.dieMessage(\"Boom!\")\n\nconst program = Effect.catchAllDefect(task, (defect) => {\n  if (Cause.isRuntimeException(defect)) {\n    return Console.log(\n      `RuntimeException defect caught: ${defect.message}`\n    )\n  }\n  return Console.log(\"Unknown defect caught.\")\n})\n\n// We get an Exit.Success because we caught all defects\nEffect.runPromiseExit(program).then(console.log)\n// Output:\n// RuntimeException defect caught: Boom!\n// {\n//   _id: \"Exit\",\n//   _tag: \"Success\",\n//   value: undefined\n// }\n```\n\n----------------------------------------\n\nTITLE: Stream.takeWhile Example in Effect\nDESCRIPTION: This example demonstrates how to use `Stream.takeWhile` to create a stream that emits numbers from 0 up to (but not including) 5. It uses `Stream.iterate` to generate an infinite stream of numbers and `Stream.takeWhile` to limit the stream based on a predicate.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-takeWhile.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Effect, Stream } from \"effect\"\n\nconst stream = Stream.takeWhile(Stream.iterate(0, (n) => n + 1), (n) => n < 5)\n\nEffect.runPromise(Stream.runCollect(stream)).then(console.log)\n// { _id: 'Chunk', values: [ 0, 1, 2, 3, 4 ] }\n```\n\n----------------------------------------\n\nTITLE: Using containsWith to check array elements with custom equivalence in TypeScript\nDESCRIPTION: Example demonstrating how to use the Array.containsWith function to create a custom array element checker. It uses an equivalence function to determine if a number exists in an array.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Array-containsWith.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Array, pipe } from \"effect\"\n\nconst isEquivalent = (a: number, b: number) => a === b\nconst containsNumber = Array.containsWith(isEquivalent)\nconst result = pipe([1, 2, 3, 4], containsNumber(3))\nconsole.log(result) // true\n```\n\n----------------------------------------\n\nTITLE: Using Effect.onInterrupt for Cleanup in TypeScript\nDESCRIPTION: This example demonstrates how to use Effect.onInterrupt to register a cleanup action that runs when a fiber is interrupted. It shows three scenarios: successful completion, failure, and interruption, with the cleanup action only executing in the interruption case.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-onInterrupt.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Console, Effect } from \"effect\"\n\n// This handler is executed when the fiber is interrupted\nconst handler = Effect.onInterrupt((_fibers) => Console.log(\"Cleanup completed\"))\n\nconst success = Console.log(\"Task completed\").pipe(Effect.as(\"some result\"), handler)\n\nEffect.runFork(success)\n// Output:\n// Task completed\n\nconst failure = Console.log(\"Task failed\").pipe(Effect.andThen(Effect.fail(\"some error\")), handler)\n\nEffect.runFork(failure)\n// Output:\n// Task failed\n\nconst interruption = Console.log(\"Task interrupted\").pipe(Effect.andThen(Effect.interrupt), handler)\n\nEffect.runFork(interruption)\n// Output:\n// Task interrupted\n// Cleanup completed\n```\n\n----------------------------------------\n\nTITLE: Defining STM Interface in TypeScript for Effect-TS\nDESCRIPTION: Defines the STM generic interface that represents transactional effects. The interface extends Effect and includes various type symbols for unification and variance handling. STM enables composition of atomic operations in a transactional manner.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/STM-STM.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface STM<out A, out E = never, out R = never>\n  extends Effect.Effect<A, E, R>, STM.Variance<A, E, R>, Pipeable\n{\n  [Unify.typeSymbol]?: unknown\n  [Unify.unifySymbol]?: STMUnify<this>\n  [Unify.ignoreSymbol]?: STMUnifyIgnore\n  [Symbol.iterator](): Effect.EffectGenerator<STM<A, E, R>>\n}\n```\n\n----------------------------------------\n\nTITLE: Using tapDefect to Inspect Severe Errors in Effect Module (TypeScript)\nDESCRIPTION: This example demonstrates how to use tapDefect to inspect defects in effects. It shows two scenarios: one with a recoverable error that doesn't trigger tapDefect, and another with a severe failure that does trigger the defect handler to log the cause of the failure.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-tapDefect.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Effect, Console } from \"effect\"\n\n// Simulate a task that fails with a recoverable error\nconst task1: Effect.Effect<number, string> = Effect.fail(\"NetworkError\")\n\n// tapDefect won't log anything because NetworkError is not a defect\nconst tapping1 = Effect.tapDefect(task1, (cause) =>\n  Console.log(`defect: ${cause}`)\n)\n\nEffect.runFork(tapping1)\n// No Output\n\n// Simulate a severe failure in the system\nconst task2: Effect.Effect<number, string> = Effect.dieMessage(\n  \"Something went wrong\"\n)\n\n// Log the defect using tapDefect\nconst tapping2 = Effect.tapDefect(task2, (cause) =>\n  Console.log(`defect: ${cause}`)\n)\n\nEffect.runFork(tapping2)\n// Output:\n// defect: RuntimeException: Something went wrong\n//   ... stack trace ...\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Effect.exit Usage in TypeScript\nDESCRIPTION: This example shows how to use Effect.exit to handle both success and failure cases, including defects. It simulates a runtime error and demonstrates error handling and logging.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-exit.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Effect, Cause, Console, Exit } from \"effect\"\n\n// Simulating a runtime error\nconst task = Effect.dieMessage(\"Boom!\")\n\nconst program = Effect.gen(function* () {\n  const exit = yield* Effect.exit(task)\n  if (Exit.isFailure(exit)) {\n    const cause = exit.cause\n    if (\n      Cause.isDieType(cause) &&\n      Cause.isRuntimeException(cause.defect)\n    ) {\n      yield* Console.log(\n        `RuntimeException defect caught: ${cause.defect.message}`\n      )\n    } else {\n      yield* Console.log(\"Unknown failure caught.\")\n    }\n  }\n})\n\n// We get an Exit.Success because we caught all failures\nEffect.runPromiseExit(program).then(console.log)\n// Output:\n// RuntimeException defect caught: Boom!\n// {\n//   _id: \"Exit\",\n//   _tag: \"Success\",\n//   value: undefined\n// }\n```\n\n----------------------------------------\n\nTITLE: Using Stream.toPull in Effect-IO - TypeScript Example\nDESCRIPTION: Demonstrates how to use Stream.toPull to process a stream chunk by chunk. Creates a stream from an array, rechunks it into size 2, and continuously pulls chunks until the stream is exhausted. Shows error handling for stream completion.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-toPull.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Effect, Stream } from \"effect\"\n\n// Simulate a chunked stream\nconst stream = Stream.fromIterable([1, 2, 3, 4, 5]).pipe(Stream.rechunk(2))\n\nconst program = Effect.gen(function*() {\n  // Create an effect to get data chunks from the stream\n  const getChunk = yield* Stream.toPull(stream)\n\n  // Continuously fetch and process chunks\n  while (true) {\n    const chunk = yield* getChunk\n    console.log(chunk)\n  }\n})\n\nEffect.runPromise(Effect.scoped(program)).then(console.log, console.error)\n// { _id: 'Chunk', values: [ 1, 2 ] }\n// { _id: 'Chunk', values: [ 3, 4 ] }\n// { _id: 'Chunk', values: [ 5 ] }\n// (FiberFailure) Error: {\n//   \"_id\": \"Option\",\n//   \"_tag\": \"None\"\n// }\n```\n\n----------------------------------------\n\nTITLE: Implementing Pattern Matching with discriminatorStartsWith in TypeScript\nDESCRIPTION: Demonstrates how to use the Match.discriminatorStartsWith function to pattern match on discriminated unions based on field prefixes. The example shows matching different 'type' field values, with special handling for values starting with 'A' or 'B'.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Match-discriminatorStartsWith.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Match, pipe } from \"effect\"\n\nconst match = pipe(\n  Match.type<{ type: \"A\" } | { type: \"B\" } | { type: \"A.A\" } | {}>(),\n  Match.discriminatorStartsWith(\"type\")(\"A\", (_) => 1 as const),\n  Match.discriminatorStartsWith(\"type\")(\"B\", (_) => 2 as const),\n  Match.orElse((_) => 3 as const)\n)\n\nconsole.log(match({ type: \"A\" })) // 1\nconsole.log(match({ type: \"B\" })) // 2\nconsole.log(match({ type: \"A.A\" })) // 1\n```\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const discriminatorStartsWith: <D extends string>(field: D) => <R, P extends string, Ret, Fn extends (_: Extract<R, Record<D, `${P}${string}`>>) => Ret>(pattern: P, f: Fn) => <I, F, A, Pr>(self: Matcher<I, F, R, A, Pr, Ret>) => Matcher<I, Types.AddWithout<F, Extract<R, Record<D, `${P}${string}`>>>, Types.ApplyFilters<I, Types.AddWithout<F, Extract<R, Record<D, `${P}${string}`>>>>, A | ReturnType<Fn>, Pr, Ret>\n```\n\n----------------------------------------\n\nTITLE: Filtering Elements in Stream using TypeScript\nDESCRIPTION: This TypeScript code snippet shows how to filter a stream of numbers to only include even numbers using Effect's Stream module. It utilizes the `Stream.filter` method, combining it with `Stream.range` to create a stream of numbers from 1 to 10, which is then filtered to keep only even values. The expected output is a Promise that resolves to a Chunk containing the filtered values.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-filter.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Effect, Stream } from \"effect\"\n\nconst stream = Stream.range(1, 11).pipe(Stream.filter((n) => n % 2 === 0))\n\nEffect.runPromise(Stream.runCollect(stream)).then(console.log)\n// { _id: 'Chunk', values: [ 2, 4, 6, 8, 10 ] }\n```\n\n----------------------------------------\n\nTITLE: Declaring runCount Function in Effect Stream Module - TypeScript\nDESCRIPTION: This snippet declares the runCount function, which processes a Stream and returns an Effect that emits the number of elements processed. It uses generic types A, E, and R to represent the stream's input, error, and output types, respectively. This function is intended for use in the Effect-TS framework and requires TypeScript.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-runCount.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\ndeclare const runCount: <A, E, R>(self: Stream<A, E, R>) => Effect.Effect<number, E, R>\n```\n```\n\n----------------------------------------\n\nTITLE: Declaring Effect.annotateSpans Function in TypeScript\nDESCRIPTION: This code snippet defines the annotateSpans function in the Effect module. It allows adding key-value annotations to spans generated during effect execution, enhancing traceability and debugging of asynchronous workflows.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-annotateSpans.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const annotateSpans: { (key: string, value: unknown): <A, E, R>(effect: Effect<A, E, R>) => Effect<A, E, R>; (values: Record<string, unknown>): <A, E, R>(effect: Effect<A, E, R>) => Effect<A, E, R>; <A, E, R>(effect: Effect<A, E, R>, key: string, value: unknown): Effect<A, E, R>; <A, E, R>(effect: Effect<A, E, R>, values: Record<string, unknown>): Effect<A, E, R>; }\n```\n\n----------------------------------------\n\nTITLE: Separating an Iterable of Either Values in TypeScript\nDESCRIPTION: The `separate` function takes an Iterable of Either values and returns a tuple containing two arrays - the first with all Left values and the second with all Right values. This is useful for partitioning collections based on success/failure or other binary classifications.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Array-separate.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const separate: <T extends Iterable<Either.Either<any, any>>>(self: T) => [Array<Either.Either.Left<ReadonlyArray.Infer<T>>>, Array<Either.Either.Right<ReadonlyArray.Infer<T>>>]\n```\n\n----------------------------------------\n\nTITLE: Implementing Effect.ensuringChildren TypeScript Function Signature\nDESCRIPTION: Type signature for ensuringChildren function that takes a callback to be executed on fiber children and returns a modified Effect. The callback is guaranteed to run regardless of the effect's success or failure.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-ensuringChildren.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const ensuringChildren: { \n  <X, R2>(children: (fibers: ReadonlyArray<Fiber.RuntimeFiber<any, any>>) => Effect<X, never, R2>): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R2 | R>; \n  <A, E, R, X, R2>(self: Effect<A, E, R>, children: (fibers: ReadonlyArray<Fiber.RuntimeFiber<any, any>>) => Effect<X, never, R2>): Effect<A, E, R | R2>; \n}\n```\n\n----------------------------------------\n\nTITLE: Stream.crossWith Signature\nDESCRIPTION: Defines the `crossWith` function for composing streams in Effect. It takes two streams (`left` and `right`) and a function `f` that combines elements from both streams. It returns a new stream with the combined elements and merged error/resource types.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-crossWith.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const crossWith: { <AR, ER, RR, AL, A>(right: Stream<AR, ER, RR>, f: (left: AL, right: AR) => A): <EL, RL>(left: Stream<AL, EL, RL>) => Stream<A, EL | ER, RL | RR>; <AL, EL, RL, AR, ER, RR, A>(left: Stream<AL, EL, RL>, right: Stream<AR, ER, RR>, f: (left: AL, right: AR) => A): Stream<A, EL | ER, RL | RR>; }\n```\n\n----------------------------------------\n\nTITLE: Effect.merge Function Signature in TypeScript\nDESCRIPTION: The type signature for the Effect.merge function, showing how it transforms an Effect<A, E, R> into Effect<E | A, never, R>. This indicates that both success type A and error type E become part of the success channel, while the error channel becomes never.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-merge.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const merge: <A, E, R>(self: Effect<A, E, R>) => Effect<E | A, never, R>\n```\n\n----------------------------------------\n\nTITLE: Committing STM Transaction in TypeScript\nDESCRIPTION: The function 'commit' is declared to handle STM transactions atomically in TypeScript, using the Effect-TS framework. It takes an STM type as input and returns an Effect, encapsulating the transactional operation. Essential for ensuring transactional integrity within the STM framework.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/STM-commit.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const commit: <A, E, R>(self: STM<A, E, R>) => Effect.Effect<A, E, R>\n```\n\n----------------------------------------\n\nTITLE: Creating a Stream with Resource Cleanup using Stream.acquireRelease in TypeScript\nDESCRIPTION: Example demonstrating how to use Stream.acquireRelease to safely handle file operations. The function opens a file, provides its contents as a stream, and ensures the file is closed after the stream is consumed, regardless of how the stream terminates.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-acquireRelease.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Console, Effect, Stream } from \"effect\"\n\n// Simulating File operations\nconst open = (filename: string) =>\n  Effect.gen(function*() {\n    yield* Console.log(`Opening ${filename}`)\n    return {\n      getLines: Effect.succeed([\"Line 1\", \"Line 2\", \"Line 3\"]),\n      close: Console.log(`Closing ${filename}`)\n    }\n  })\n\nconst stream = Stream.acquireRelease(\n  open(\"file.txt\"),\n  (file) => file.close\n).pipe(Stream.flatMap((file) => file.getLines))\n\nEffect.runPromise(Stream.runCollect(stream)).then(console.log)\n// Opening file.txt\n// Closing file.txt\n// { _id: 'Chunk', values: [ [ 'Line 1', 'Line 2', 'Line 3' ] ] }\n```\n\n----------------------------------------\n\nTITLE: Using Effect.option to Handle Errors in TypeScript\nDESCRIPTION: Example demonstrating how Effect.option handles different effect outcomes: success, failure, and unrecoverable errors. It shows how successful values are wrapped in Option.some, failures are converted to Option.none, and defects still result in failure.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-option.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Effect } from \"effect\"\n\nconst maybe1 = Effect.option(Effect.succeed(1))\n\nEffect.runPromiseExit(maybe1).then(console.log)\n// Output:\n// {\n//   _id: 'Exit',\n//   _tag: 'Success',\n//   value: { _id: 'Option', _tag: 'Some', value: 1 }\n// }\n\nconst maybe2 = Effect.option(Effect.fail(\"Uh oh!\"))\n\nEffect.runPromiseExit(maybe2).then(console.log)\n// Output:\n// {\n//   _id: 'Exit',\n//   _tag: 'Success',\n//   value: { _id: 'Option', _tag: 'None' }\n// }\n\nconst maybe3 = Effect.option(Effect.die(\"Boom!\"))\n\nEffect.runPromiseExit(maybe3).then(console.log)\n// Output:\n// {\n//   _id: 'Exit',\n//   _tag: 'Failure',\n//   cause: { _id: 'Cause', _tag: 'Die', defect: 'Boom!' }\n// }\n```\n\n----------------------------------------\n\nTITLE: Using mapBoth with Effect in TypeScript\nDESCRIPTION: Example demonstrating how to use Effect.mapBoth to transform both success and error channels. Shows creation of a simulated task that fails with a string message and maps it to return a boolean on success and Error object on failure.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-mapBoth.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Effect } from \"effect\"\n\n//      ┌─── Effect<number, string, never>\n//      ▼\nconst simulatedTask = Effect.fail(\"Oh no!\").pipe(Effect.as(1))\n\n//      ┌─── Effect<boolean, Error, never>\n//      ▼\nconst modified = Effect.mapBoth(simulatedTask, {\n  onFailure: (message) => new Error(message),\n  onSuccess: (n) => n > 0\n})\n```\n\n----------------------------------------\n\nTITLE: Implementing collectAll Sink Function in TypeScript\nDESCRIPTION: Defines a sink that accumulates all incoming elements into a Chunk data structure. This generic function takes no parameters and returns a Sink that collects elements of type In into a Chunk.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Sink-collectAll.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const collectAll: <In>() => Sink<Chunk.Chunk<In>, In>\n```\n\n----------------------------------------\n\nTITLE: Implementing Effect Replication in TypeScript\nDESCRIPTION: Function declaration for replicating effects with configurable concurrency and result collection. Supports both array collection and void return modes based on the discard option. Takes a number parameter for repetition count and optional configuration for concurrency and result handling.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Micro-replicateEffect.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const replicateEffect: { \n  (n: number, options?: { readonly concurrency?: Concurrency | undefined; readonly discard?: false | undefined; }): <A, E, R>(self: Micro<A, E, R>) => Micro<Array<A>, E, R>; \n  (n: number, options: { readonly concurrency?: Concurrency | undefined; readonly discard: true; }): <A, E, R>(self: Micro<A, E, R>) => Micro<void, E, R>; \n  <A, E, R>(self: Micro<A, E, R>, n: number, options?: { readonly concurrency?: Concurrency | undefined; readonly discard?: false | undefined; }): Micro<Array<A>, E, R>; \n  <A, E, R>(self: Micro<A, E, R>, n: number, options: { readonly concurrency?: Concurrency | undefined; readonly discard: true; }): Micro<void, E, R>; \n}\n```\n\n----------------------------------------\n\nTITLE: Interrupting Fibers Waiting on a Deferred Value in TypeScript\nDESCRIPTION: A method that completes a Deferred with interruption, interrupting all fibers waiting on the Deferred's value with the specified FiberId. Returns an Effect that resolves to a boolean indicating the success of the operation.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Deferred-interruptWith.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const interruptWith: { (fiberId: FiberId.FiberId): <A, E>(self: Deferred<A, E>) => Effect.Effect<boolean>; <A, E>(self: Deferred<A, E>, fiberId: FiberId.FiberId): Effect.Effect<boolean>; }\n```\n\n----------------------------------------\n\nTITLE: Flow Function TypeScript Signature\nDESCRIPTION: Shows the complex TypeScript signature of the 'flow' function. The signature supports multiple overloads for composing different numbers of functions, with the first function potentially accepting multiple parameters and all subsequent functions being unary.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Function-flow.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const flow: { <A extends ReadonlyArray<unknown>, B = never>(ab: (...a: A) => B): (...a: A) => B; <A extends ReadonlyArray<unknown>, B = never, C = never>(ab: (...a: A) => B, bc: (b: B) => C): (...a: A) => C; <A extends ReadonlyArray<unknown>, B = never, C = never, D = never>(ab: (...a: A) => B, bc: (b: B) => C, cd: (c: C) => D): (...a: A) => D; <A extends ReadonlyArray<unknown>, B = never, C = never, D = never, E = never>(ab: (...a: A) => B, bc: (b: B) => C, cd: (c: C) => D, de: (d: D) => E): (...a: A) => E; <A extends ReadonlyArray<unknown>, B = never, C = never, D = never, E = never, F = never>(ab: (...a: A) => B, bc: (b: B) => C, cd: (c: C) => D, de: (d: D) => E, ef: (e: E) => F): (...a: A) => F; <A extends ReadonlyArray<unknown>, B = never, C = never, D = never, E = never, F = never, G = never>(ab: (...a: A) => B, bc: (b: B) => C, cd: (c: C) => D, de: (d: D) => E, ef: (e: E) => F, fg: (f: F) => G): (...a: A) => G; <A extends ReadonlyArray<unknown>, B = never, C = never, D = never, E = never, F = never, G = never, H = never>(ab: (...a: A) => B, bc: (b: B) => C, cd: (c: C) => D, de: (d: D) => E, ef: (e: E) => F, fg: (f: F) => G, gh: (g: G) => H): (...a: A) => H; <A extends ReadonlyArray<unknown>, B = never, C = never, D = never, E = never, F = never, G = never, H = never, I = never>(ab: (...a: A) => B, bc: (b: B) => C, cd: (c: C) => D, de: (d: D) => E, ef: (e: E) => F, fg: (f: F) => G, gh: (g: G) => H, hi: (h: H) => I): (...a: A) => I; <A extends ReadonlyArray<unknown>, B = never, C = never, D = never, E = never, F = never, G = never, H = never, I = never, J = never>(ab: (...a: A) => B, bc: (b: B) => C, cd: (c: C) => D, de: (d: D) => E, ef: (e: E) => F, fg: (f: F) => G, gh: (g: G) => H, hi: (h: H) => I, ij: (i: I) => J): (...a: A) => J; }\n```\n\n----------------------------------------\n\nTITLE: Using Effect.catchIf to Recover from Specific Errors\nDESCRIPTION: This example demonstrates how to use the `catchIf` function to selectively catch and recover from HttpError types while letting other error types pass through. It uses a predicate to check the error tag and provides a recovery function.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-catchIf.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Effect, Random } from \"effect\"\n\nclass HttpError {\n  readonly _tag = \"HttpError\"\n}\n\nclass ValidationError {\n  readonly _tag = \"ValidationError\"\n}\n\n//      ┌─── Effect<string, HttpError | ValidationError, never>\n//      ▼\nconst program = Effect.gen(function* () {\n  const n1 = yield* Random.next\n  const n2 = yield* Random.next\n  if (n1 < 0.5) {\n    yield* Effect.fail(new HttpError())\n  }\n  if (n2 < 0.5) {\n    yield* Effect.fail(new ValidationError())\n  }\n  return \"some result\"\n})\n\n//      ┌─── Effect<string, ValidationError, never>\n//      ▼\nconst recovered = program.pipe(\n  Effect.catchIf(\n    // Only handle HttpError errors\n    (error) => error._tag === \"HttpError\",\n    () => Effect.succeed(\"Recovering from HttpError\")\n  )\n)\n```\n\n----------------------------------------\n\nTITLE: Implementing Paginated Stream in TypeScript using Effect Library\nDESCRIPTION: This example demonstrates how to use `Stream.paginate` to create a stream that emits values up to a certain condition. It creates a stream of numbers from 0 to 3, showcasing the pagination functionality.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-paginate.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Effect, Option, Stream } from \"effect\"\n\nconst stream = Stream.paginate(0, (n) => [\n  n,\n  n < 3 ? Option.some(n + 1) : Option.none()\n])\n\nEffect.runPromise(Stream.runCollect(stream)).then(console.log)\n// { _id: 'Chunk', values: [ 0, 1, 2, 3 ] }\n```\n\n----------------------------------------\n\nTITLE: Initializing Broadcasted Stream with Range in TypeScript\nDESCRIPTION: Demonstrates broadcasting a stream of numbers to multiple downstream consumers with logging and scheduling\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-broadcast.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Console, Effect, Fiber, Schedule, Stream } from \"effect\"\n\nconst numbers = Effect.scoped(\n  Stream.range(1, 20).pipe(\n    Stream.tap((n) => Console.log(`Emit ${n} element before broadcasting`)),\n    Stream.broadcast(2, 5),\n    Stream.flatMap(([first, second]) =>\n      Effect.gen(function*() {\n        const fiber1 = yield* Stream.runFold(first, 0, (acc, e) => Math.max(acc, e)).pipe(\n          Effect.andThen((max) => Console.log(`Maximum: ${max}`)),\n          Effect.fork\n        )\n        const fiber2 = yield* second.pipe(\n          Stream.schedule(Schedule.spaced(\"1 second\")),\n          Stream.runForEach((n) => Console.log(`Logging to the Console: ${n}`)),\n          Effect.fork\n        )\n        yield* Fiber.join(fiber1).pipe(\n          Effect.zip(Fiber.join(fiber2), { concurrent: true })\n        )\n      })\n    ),\n    Stream.runCollect\n  )\n)\n\nEffect.runPromise(numbers).then(console.log)\n```\n\n----------------------------------------\n\nTITLE: Creating a Stream from Values in TypeScript using Effect Library\nDESCRIPTION: This snippet demonstrates how to create a stream using Stream.make function from the Effect library. It creates a stream of numbers and then collects and logs the result.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-make.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Effect, Stream } from \"effect\"\n\nconst stream = Stream.make(1, 2, 3)\n\nEffect.runPromise(Stream.runCollect(stream)).then(console.log)\n// { _id: 'Chunk', values: [ 1, 2, 3 ] }\n```\n\n----------------------------------------\n\nTITLE: Using Effect.bind for Do Notation in TypeScript\nDESCRIPTION: Demonstrates how to use Effect.bind and Effect.let to create a chain of operations in a declarative style. The example shows binding variables x and y to Effect values and computing their sum.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-bind.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { Effect, pipe } from \"effect\"\n\nconst result = pipe(\n  Effect.Do,\n  Effect.bind(\"x\", () => Effect.succeed(2)),\n  Effect.bind(\"y\", () => Effect.succeed(3)),\n  Effect.let(\"sum\", ({ x, y }) => x + y)\n)\nassert.deepStrictEqual(Effect.runSync(result), { x: 2, y: 3, sum: 5 })\n```\n\n----------------------------------------\n\nTITLE: Creating Database Connection and Pool\nDESCRIPTION: This snippet utilizes Effect TS to create a database connection pool with specified constraints, including minimum and maximum sizes, time-to-live, and other options. The pool includes an acquisition strategy for database connections and handles their release upon scope shutdown.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Pool-makeWithTTL.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createConnection } from \"mysql2\";\nimport { Duration, Effect, Pool } from \"effect\"\n\nconst acquireDBConnection = Effect.acquireRelease(\n  Effect.sync(() => createConnection('mysql://...')),\n  (connection) => Effect.sync(() => connection.end(() => {})),\n)\n\nconst connectionPool = Effect.flatMap(\n Pool.makeWithTTL({\n    acquire: acquireDBConnection,\n    min: 10,\n    max: 20,\n    timeToLive: Duration.seconds(60)\n  }),\n  (pool) => pool.get\n)\n```\n\n----------------------------------------\n\nTITLE: Creating a Keyed Pool with Time-to-Live in TypeScript\nDESCRIPTION: The makeWithTTLBy function creates a new pool with specified minimum and maximum sizes and time-to-live. It allows configuration of pool sizes per key and returns the pool in a Scope that governs its lifetime. When the pool is shutdown, allocated items are released in an unspecified order.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/KeyedPool-makeWithTTLBy.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const makeWithTTLBy: <K, A, E, R>(options: { readonly acquire: (key: K) => Effect.Effect<A, E, R>; readonly min: (key: K) => number; readonly max: (key: K) => number; readonly timeToLive: (key: K) => Duration.DurationInput; }) => Effect.Effect<KeyedPool<K, A, E>, never, Scope.Scope | R>\n```\n\n----------------------------------------\n\nTITLE: Zipping Streams by Distinct Keys in TypeScript\nDESCRIPTION: The `zipAllSortedByKeyLeft` function is designed to merge two streams that are individually sorted by distinct keys. It maintains the key order and fills in missing values in the resultant stream using a specified default value. This function requires that input streams are properly sorted and makes use of TypeScript's generics to ensure type safety. The dependencies include the `Stream` and `Order` modules, encapsulating stream processing and key order functionality, respectively. The function signature allows flexibility, accepting streams with various data and error types.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-zipAllSortedByKeyLeft.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const zipAllSortedByKeyLeft: { <A2, E2, R2, A, K>(options: { readonly other: Stream<readonly [K, A2], E2, R2>; readonly defaultSelf: A; readonly order: Order.Order<K>; }): <E, R>(self: Stream<readonly [K, A], E, R>) => Stream<[K, A], E2 | E, R2 | R>; <K, A, E, R, A2, E2, R2>(self: Stream<readonly [K, A], E, R>, options: { readonly other: Stream<readonly [K, A2], E2, R2>; readonly defaultSelf: A; readonly order: Order.Order<K>; }): Stream<[K, A], E | E2, R | R2>; }\n```\n\n----------------------------------------\n\nTITLE: Repeating Effects with Success Example in TypeScript\nDESCRIPTION: Demonstrates how to repeat a console log effect with a delay schedule. The effect is repeated twice with 100ms delays between executions.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-repeat.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Effect, Schedule, Console } from \"effect\"\n\nconst action = Console.log(\"success\")\nconst policy = Schedule.addDelay(Schedule.recurs(2), () => \"100 millis\")\nconst program = Effect.repeat(action, policy)\n\nEffect.runPromise(program).then((n) => console.log(`repetitions: ${n}`))\n```\n\n----------------------------------------\n\nTITLE: Effect.matchCauseEffect Function Signature\nDESCRIPTION: This code snippet shows the TypeScript signature of the Effect.matchCauseEffect function. It defines the function's type structure, including its parameters and return types.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-matchCauseEffect.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const matchCauseEffect: { <E, A2, E2, R2, A, A3, E3, R3>(options: { readonly onFailure: (cause: Cause.Cause<E>) => Effect<A2, E2, R2>; readonly onSuccess: (a: A) => Effect<A3, E3, R3>; }): <R>(self: Effect<A, E, R>) => Effect<A2 | A3, E2 | E3, R2 | R3 | R>; <A, E, R, A2, E2, R2, A3, E3, R3>(self: Effect<A, E, R>, options: { readonly onFailure: (cause: Cause.Cause<E>) => Effect<A2, E2, R2>; readonly onSuccess: (a: A) => Effect<A3, E3, R3>; }): Effect<A2 | A3, E2 | E3, R2 | R3 | R>; }\n```\n\n----------------------------------------\n\nTITLE: Creating a stream from AsyncIterable in Effect\nDESCRIPTION: This example demonstrates how to create a stream from an `AsyncIterable` using `Stream.fromAsyncIterable`. It defines an asynchronous generator function, converts it into a stream, and then collects the stream's values into a chunk using `Stream.runCollect`. Error handling is provided using a callback function.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-fromAsyncIterable.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Effect, Stream } from \"effect\"\n\nconst myAsyncIterable = async function*() {\n  yield 1\n  yield 2\n}\n\nconst stream = Stream.fromAsyncIterable(\n  myAsyncIterable(),\n  (e) => new Error(String(e)) // Error Handling\n)\n\nEffect.runPromise(Stream.runCollect(stream)).then(console.log)\n// { _id: 'Chunk', values: [ 1, 2 ] }\n```\n\n----------------------------------------\n\nTITLE: Basic Usage Syntax for Effect.andThen in TypeScript\nDESCRIPTION: Shows the various syntactic options for using the Effect.andThen method to chain actions sequentially.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-andThen.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst transformedEffect = pipe(myEffect, Effect.andThen(anotherEffect))\n// or\nconst transformedEffect = Effect.andThen(myEffect, anotherEffect)\n// or\nconst transformedEffect = myEffect.pipe(Effect.andThen(anotherEffect))\n```\n\n----------------------------------------\n\nTITLE: Using Stream.zipAllWith in TypeScript with Effect\nDESCRIPTION: Demonstrates how to zip two streams together with custom handlers for different length streams. The example shows zipping a numeric stream with a string stream, including handling cases where one stream is longer than the other.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-zipAllWith.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Effect, Stream } from \"effect\"\n\nconst stream = Stream.zipAllWith(Stream.make(1, 2, 3, 4, 5, 6), {\n  other: Stream.make(\"a\", \"b\", \"c\"),\n  onSelf: (n) => [n, \"x\"],\n  onOther: (s) => [0, s],\n  onBoth: (n, s) => [n - s.length, s]\n})\n\nEffect.runPromise(Stream.runCollect(stream)).then(console.log)\n// { _id: \"Chunk\", values: [ [ 0, \"a\" ], [ 1, \"b\" ], [ 2, \"c\" ], [ 4, \"x\" ], [ 5, \"x\" ], [ 6, \"x\" ] ] }\n```\n\n----------------------------------------\n\nTITLE: Implementing Safe Array Element Retrieval in TypeScript\nDESCRIPTION: The `get` function provides a safe way to access elements in a ReadonlyArray by index, returning an Option type. It supports both curried and non-curried invocations.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Array-get.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const get: { (index: number): <A>(self: ReadonlyArray<A>) => Option.Option<A>; <A>(self: ReadonlyArray<A>, index: number): Option.Option<A>; }\n```\n\n----------------------------------------\n\nTITLE: Implementing Stateful Collection Transformation with Effect.mapAccum\nDESCRIPTION: Demonstrates how to use Effect.mapAccum to transform an array of strings while maintaining a running state. The example shows converting strings to uppercase while tracking the total length of all strings processed.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-mapAccum.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Effect } from \"effect\"\n\n// Define an initial state and a transformation function\nconst initialState = 0\n\nconst transformation = (state: number, element: string) =>\n  Effect.succeed<[number, string]>([state + element.length, element.toUpperCase()])\n\n// Apply mapAccum to transform an array of strings\nconst program = Effect.mapAccum([\"a\", \"bb\", \"ccc\"], initialState, transformation)\n\nEffect.runPromise(program).then(([finalState, transformedCollection]) => {\n  console.log(finalState)\n  console.log(transformedCollection)\n})\n// Output:\n// 6\n// [ 'A', 'BB', 'CCC' ]\n```\n\n----------------------------------------\n\nTITLE: Implementing Effectful Input Filtering for Sinks in TypeScript\nDESCRIPTION: The filterInputEffect function allows effectful filtering of a sink's input using a predicate that returns an Effect. It supports two different calling patterns: curried and uncurried. The function preserves the type relationships between the input, output, and error types while properly combining effect requirements.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Sink-filterInputEffect.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const filterInputEffect: { <In, In1 extends In, E2, R2>(f: (input: In1) => Effect.Effect<boolean, E2, R2>): <A, L, E, R>(self: Sink<A, In, L, E, R>) => Sink<A, In1, L, E2 | E, R2 | R>; <A, In, L, E, R, In1 extends In, E2, R2>(self: Sink<A, In, L, E, R>, f: (input: In1) => Effect.Effect<boolean, E2, R2>): Sink<A, In1, L, E | E2, R | R2>; }\n```\n\n----------------------------------------\n\nTITLE: Creating a Single-Valued Pure Stream in Effect for TypeScript\nDESCRIPTION: This snippet demonstrates how to create a stream with a single numeric value using the Stream.succeed function from the Effect framework. It imports the necessary modules, creates the stream, and runs it to collect and log its values. Uses 'effect' package version 2.0.0.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-succeed.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Effect, Stream } from \"effect\"\n\n// A Stream with a single number\nconst stream = Stream.succeed(3)\n\nEffect.runPromise(Stream.runCollect(stream)).then(console.log)\n// { _id: 'Chunk', values: [ 3 ] }\n```\n\n----------------------------------------\n\nTITLE: Retrieving Services from Context using Effect\nDESCRIPTION: Demonstrates how to create and retrieve services from a Context using GenericTag. Shows creation of two services (Port and Timeout) and accessing them using Context.get.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Context-get.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { pipe, Context } from \"effect\"\n\nconst Port = Context.GenericTag<{ PORT: number }>(\"Port\")\nconst Timeout = Context.GenericTag<{ TIMEOUT: number }>(\"Timeout\")\n\nconst Services = pipe(\n  Context.make(Port, { PORT: 8080 }),\n  Context.add(Timeout, { TIMEOUT: 5000 })\n)\n\nassert.deepStrictEqual(Context.get(Services, Timeout), { TIMEOUT: 5000 })\n```\n\n----------------------------------------\n\nTITLE: Using Array.getSomes in TypeScript with Effect Library\nDESCRIPTION: Demonstrates how to use the Array.getSomes function to filter and collect Some values from an array of Options, ignoring None values. The function takes an Iterable of Option<T> and returns an array containing only the unwrapped Some values.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Array-getSomes.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Array, Option } from \"effect\"\n\nconst result = Array.getSomes([Option.some(1), Option.none(), Option.some(2)])\nconsole.log(result) // [1, 2]\n```\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const getSomes: <T extends Iterable<Option.Option<X>>, X = any>(self: T) => Array<Option.Option.Value<ReadonlyArray.Infer<T>>>\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Stream.onStart Usage in TypeScript\nDESCRIPTION: This example shows how to use Stream.onStart to add a console log at the beginning of a stream. It creates a stream of numbers, maps them, and logs each value after mapping.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-onStart.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Console, Effect, Stream } from \"effect\"\n\nconst stream = Stream.make(1, 2, 3).pipe(\n  Stream.onStart(Console.log(\"Stream started\")),\n  Stream.map((n) => n * 2),\n  Stream.tap((n) => Console.log(`after mapping: ${n}`))\n)\n\nEffect.runPromise(Stream.runCollect(stream)).then(console.log)\n// Stream started\n// after mapping: 2\n// after mapping: 4\n// after mapping: 6\n// { _id: 'Chunk', values: [ 2, 4, 6 ] }\n```\n\n----------------------------------------\n\nTITLE: Transforming Elements with Chunk.map in TypeScript\nDESCRIPTION: Example showing how to transform elements of a Chunk using the map function. The example demonstrates incrementing each number in the chunk by 1, resulting in a new chunk with transformed values.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Chunk-map.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Chunk } from \"effect\"\n\nconst result = Chunk.map(Chunk.make(1, 2), (n) => n + 1)\n\nconsole.log(result)\n// { _id: 'Chunk', values: [ 2, 3 ] }\n```\n\n----------------------------------------\n\nTITLE: Executing Effects with Exit Result Handling in TypeScript\nDESCRIPTION: Demonstrates how to use Effect.runPromiseExit to execute both successful and failing effects, returning a Promise that resolves to an Exit object containing detailed information about the outcome. This allows examining both success and failure cases in a unified way.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-runPromiseExit.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Effect } from \"effect\"\n\n// Execute a successful effect and get the Exit result as a Promise\nEffect.runPromiseExit(Effect.succeed(1)).then(console.log)\n// Output:\n// {\n//   _id: \"Exit\",\n//   _tag: \"Success\",\n//   value: 1\n// }\n\n// Execute a failing effect and get the Exit result as a Promise\nEffect.runPromiseExit(Effect.fail(\"my error\")).then(console.log)\n// Output:\n// {\n//   _id: \"Exit\",\n//   _tag: \"Failure\",\n//   cause: {\n//     _id: \"Cause\",\n//     _tag: \"Fail\",\n//     failure: \"my error\"\n//   }\n// }\n```\n\n----------------------------------------\n\nTITLE: Implementing Stream Throttling with Effect-TS\nDESCRIPTION: Example demonstrating stream throttling using the token bucket algorithm. Shows how to process stream elements with controlled timing and logging of events. Uses Schedule.spaced for input generation and applies throttling with specific cost, duration and unit parameters.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-throttle.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Chunk, Effect, Schedule, Stream } from \"effect\"\n\nlet last = Date.now()\nconst log = (message: string) =>\n  Effect.sync(() => {\n    const end = Date.now()\n    console.log(`${message} after ${end - last}ms`)\n    last = end\n  })\n\nconst stream = Stream.fromSchedule(Schedule.spaced(\"50 millis\")).pipe(\n  Stream.take(6),\n  Stream.tap((n) => log(`Received ${n}`)),\n  Stream.throttle({\n    cost: Chunk.size,\n    duration: \"100 millis\",\n    units: 1\n  }),\n  Stream.tap((n) => log(`> Emitted ${n}`))\n)\n\nEffect.runPromise(Stream.runCollect(stream)).then(console.log)\n```\n\n----------------------------------------\n\nTITLE: BigDecimal Addition Example in TypeScript\nDESCRIPTION: Demonstrates how to perform addition of two BigDecimal values using the sum function from the Effect library. The example shows adding 2 and 3 to get 5 using unsafeFromString for conversion.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/BigDecimal-sum.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { sum, unsafeFromString } from \"effect/BigDecimal\"\n\nassert.deepStrictEqual(sum(unsafeFromString(\"2\"), unsafeFromString(\"3\")), unsafeFromString(\"5\"))\n```\n\n----------------------------------------\n\nTITLE: Using Context.pick in Effect for Service Selection\nDESCRIPTION: Demonstrates how to use Context.pick to create a new Context that contains only specified services. The example shows creating a Context with multiple services (Port and Timeout) and then selecting only the Port service.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Context-pick.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { pipe, Context, Option } from \"effect\"\n\nconst Port = Context.GenericTag<{ PORT: number }>(\"Port\")\nconst Timeout = Context.GenericTag<{ TIMEOUT: number }>(\"Timeout\")\n\nconst someContext = pipe(\n  Context.make(Port, { PORT: 8080 }),\n  Context.add(Timeout, { TIMEOUT: 5000 })\n)\n\nconst Services = pipe(someContext, Context.pick(Port))\n\nassert.deepStrictEqual(Context.getOption(Services, Port), Option.some({ PORT: 8080 }))\nassert.deepStrictEqual(Context.getOption(Services, Timeout), Option.none())\n```\n\n----------------------------------------\n\nTITLE: Creating a Stream from an Iterable in Effect\nDESCRIPTION: This example demonstrates how to create an Effect Stream from an array of numbers using the `Stream.fromIterable` function. The resulting stream is then collected and printed to the console using `Stream.runCollect` and `Effect.runPromise`. This allows to work with existing data structures in a stream-based way.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-fromIterable.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Effect, Stream } from \"effect\"\n\nconst numbers = [1, 2, 3]\n\nconst stream = Stream.fromIterable(numbers)\n\nEffect.runPromise(Stream.runCollect(stream)).then(console.log)\n// { _id: 'Chunk', values: [ 1, 2, 3 ] }\n```\n\n----------------------------------------\n\nTITLE: Effect.validateAll Function Signature in TypeScript\nDESCRIPTION: The type signature for the validateAll function, showing its various overloads. It supports processing collections with options for concurrency, batching, discarding results, and concurrent finalizers. The function can be used in both curried and uncurried forms.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-validateAll.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const validateAll: { <A, B, E, R>(f: (a: A, i: number) => Effect<B, E, R>, options?: { readonly concurrency?: Concurrency | undefined; readonly batching?: boolean | \"inherit\" | undefined; readonly discard?: false | undefined; readonly concurrentFinalizers?: boolean | undefined; } | undefined): (elements: Iterable<A>) => Effect<Array<B>, RA.NonEmptyArray<E>, R>; <A, B, E, R>(f: (a: A, i: number) => Effect<B, E, R>, options: { readonly concurrency?: Concurrency | undefined; readonly batching?: boolean | \"inherit\" | undefined; readonly discard: true; readonly concurrentFinalizers?: boolean | undefined; }): (elements: Iterable<A>) => Effect<void, RA.NonEmptyArray<E>, R>; <A, B, E, R>(elements: Iterable<A>, f: (a: A, i: number) => Effect<B, E, R>, options?: { readonly concurrency?: Concurrency | undefined; readonly batching?: boolean | \"inherit\" | undefined; readonly discard?: false | undefined; readonly concurrentFinalizers?: boolean | undefined; } | undefined): Effect<Array<B>, RA.NonEmptyArray<E>, R>; <A, B, E, R>(elements: Iterable<A>, f: (a: A, i: number) => Effect<B, E, R>, options: { readonly concurrency?: Concurrency | undefined; readonly batching?: boolean | \"inherit\" | undefined; readonly discard: true; readonly concurrentFinalizers?: boolean | undefined; }): Effect<void, RA.NonEmptyArray<E>, R>; }\n```\n\n----------------------------------------\n\nTITLE: Negating a Predicate Function in TypeScript using Effect\nDESCRIPTION: Demonstrates how to use Predicate.not to negate a predicate function. The example creates an isPositive predicate by negating a 'less than zero' check.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Predicate-not.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { Predicate, Number } from \"effect\"\n\nconst isPositive = Predicate.not(Number.lessThan(0))\n\nassert.deepStrictEqual(isPositive(-1), false)\nassert.deepStrictEqual(isPositive(0), true)\nassert.deepStrictEqual(isPositive(1), true)\n```\n\n----------------------------------------\n\nTITLE: TypeScript Declaration for tapError Function\nDESCRIPTION: The TypeScript declaration for the tapError function in the Effect module. It shows the function's overloaded signature with generics representing the effect's return type, error type, and environment requirements.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-tapError.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const tapError: { <E, X, E2, R2>(f: (e: NoInfer<E>) => Effect<X, E2, R2>): <A, R>(self: Effect<A, E, R>) => Effect<A, E | E2, R2 | R>; <A, E, R, X, E2, R2>(self: Effect<A, E, R>, f: (e: E) => Effect<X, E2, R2>): Effect<A, E | E2, R | R2>; }\n```\n\n----------------------------------------\n\nTITLE: Combining Two Effects Concurrently with Effect.zip in TypeScript\nDESCRIPTION: This example shows how to run two effects concurrently using the concurrent option in Effect.zip. The tasks are executed in parallel, with the faster task (task2) completing before the slower one (task1).\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-zip.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Effect } from \"effect\"\n\nconst task1 = Effect.succeed(1).pipe(\n  Effect.delay(\"200 millis\"),\n  Effect.tap(Effect.log(\"task1 done\"))\n)\nconst task2 = Effect.succeed(\"hello\").pipe(\n  Effect.delay(\"100 millis\"),\n  Effect.tap(Effect.log(\"task2 done\"))\n)\n\n// Run both effects concurrently using the concurrent option\nconst program = Effect.zip(task1, task2, { concurrent: true })\n\nEffect.runPromise(program).then(console.log)\n// Output:\n// timestamp=... level=INFO fiber=#0 message=\"task2 done\"\n// timestamp=... level=INFO fiber=#0 message=\"task1 done\"\n// [ 1, 'hello' ]\n```\n\n----------------------------------------\n\nTITLE: Partitioning Streams with GroupByKey in TypeScript\nDESCRIPTION: This TypeScript snippet demonstrates the use of the 'groupByKey' function from the 'Effect' package to partition a stream of words into groups based on their starting letter. It processes each group to take the first two words and associates them with their respective starting letter. Key dependencies include 'pipe', 'GroupBy', and 'Stream' from the 'Effect' package.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-groupByKey.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { pipe, GroupBy, Stream } from \"effect\"\n\npipe(\n  Stream.fromIterable([\"hello\", \"world\", \"hi\", \"holla\"]),\n  Stream.groupByKey((word) => word[0]),\n  GroupBy.evaluate((key, stream) =>\n    pipe(\n      stream,\n      Stream.take(2),\n      Stream.map((words) => [key, words] as const)\n    )\n  )\n)\n```\n\n----------------------------------------\n\nTITLE: Type Signature of mapAccum - TypeScript\nDESCRIPTION: This snippet defines the type signature of the mapAccum function, specifying its generic types and how it operates on streams. The type signature is crucial for understanding the function's capabilities and constraints in a TypeScript environment.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-mapAccum.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const mapAccum: { <S, A, A2>(s: S, f: (s: S, a: A) => readonly [S, A2]): <E, R>(self: Stream<A, E, R>) => Stream<A2, E, R>; <A, E, R, S, A2>(self: Stream<A, E, R>, s: S, f: (s: S, a: A) => readonly [S, A2]): Stream<A2, E, R>; }\n```\n\n----------------------------------------\n\nTITLE: TypeScript Function Signature for Array.takeRight\nDESCRIPTION: The function signature for Array.takeRight shows both the curried and uncurried versions of the function. It can be called either by providing the number first and then the iterable, or by providing both arguments at once.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Array-takeRight.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const takeRight: { (n: number): <A>(self: Iterable<A>) => Array<A>; <A>(self: Iterable<A>, n: number): Array<A>; }\n```\n\n----------------------------------------\n\nTITLE: Implementing Chunk.modify Function in TypeScript\nDESCRIPTION: The modify function applies a transformation to an element at a specified index in a Chunk. It creates a new Chunk with the modified element or returns the original Chunk if the index is out of bounds. The function is overloaded to accept arguments in different orders.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Chunk-modify.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const modify: { <A, B>(i: number, f: (a: A) => B): (self: Chunk<A>) => Chunk<A | B>; <A, B>(self: Chunk<A>, i: number, f: (a: A) => B): Chunk<A | B>; }\n```\n\n----------------------------------------\n\nTITLE: Effect.Semaphore Interface Definition in TypeScript\nDESCRIPTION: Defines the Semaphore interface with methods for permit management including withPermits, withPermitsIfAvailable, take, release, and releaseAll. This interface enables controlled access to shared resources in concurrent operations.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-Semaphore.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface Semaphore {\n  /**\n   * Runs an effect with the given number of permits and releases the permits\n   * when the effect completes.\n   *\n   * **Details**\n   *\n   * This function acquires the specified number of permits before executing\n   * the provided effect. Once the effect finishes, the permits are released.\n   * If insufficient permits are available, the function will wait until they\n   * are released by other tasks.\n   */\n  withPermits(permits: number): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R>\n\n  /**\n   * Runs an effect only if the specified number of permits are immediately\n   * available.\n   *\n   * **Details**\n   *\n   * This function attempts to acquire the specified number of permits. If they\n   * are available, it runs the effect and releases the permits after the effect\n   * completes. If permits are not available, the effect does not execute, and\n   * the result is `Option.none`.\n   */\n  withPermitsIfAvailable(permits: number): <A, E, R>(self: Effect<A, E, R>) => Effect<Option.Option<A>, E, R>\n\n  /**\n   * Acquires the specified number of permits and returns the resulting\n   * available permits, suspending the task if they are not yet available.\n   * Concurrent pending `take` calls are processed in a first-in, first-out manner.\n   */\n  take(permits: number): Effect<number>\n\n  /**\n   * Releases the specified number of permits and returns the resulting\n   * available permits.\n   */\n  release(permits: number): Effect<number>\n\n  /**\n   * Releases all permits held by this semaphore and returns the resulting available permits.\n   */\n  releaseAll: Effect<number>\n}\n```\n\n----------------------------------------\n\nTITLE: TypeScript Function Signature for Effect.retryOrElse\nDESCRIPTION: The TypeScript type declaration for the retryOrElse function, showing its polymorphic implementation with support for different overloads. It defines the types for the effect to retry, the retry policy, and the fallback function.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-retryOrElse.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const retryOrElse: { <A1, E, R1, A2, E2, R2>(policy: Schedule.Schedule<A1, NoInfer<E>, R1>, orElse: (e: NoInfer<E>, out: A1) => Effect<A2, E2, R2>): <A, R>(self: Effect<A, E, R>) => Effect<A2 | A, E2, R1 | R2 | R>; <A, E, R, A1, R1, A2, E2, R2>(self: Effect<A, E, R>, policy: Schedule.Schedule<A1, NoInfer<E>, R1>, orElse: (e: NoInfer<E>, out: A1) => Effect<A2, E2, R2>): Effect<A | A2, E2, R | R1 | R2>; }\n```\n\n----------------------------------------\n\nTITLE: Racing a Failing and a Succeeding Effect in TypeScript\nDESCRIPTION: Shows racing two effects where one fails and the other succeeds, demonstrating that the successful effect determines the race outcome.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-race.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Effect, Console } from \"effect\"\n\nconst task1 = Effect.fail(\"task1\").pipe(\n  Effect.delay(\"100 millis\"),\n  Effect.tap(Console.log(\"task1 done\")),\n  Effect.onInterrupt(() => Console.log(\"task1 interrupted\"))\n)\nconst task2 = Effect.succeed(\"task2\").pipe(\n  Effect.delay(\"200 millis\"),\n  Effect.tap(Console.log(\"task2 done\")),\n  Effect.onInterrupt(() => Console.log(\"task2 interrupted\"))\n)\n\nconst program = Effect.race(task1, task2)\n\nEffect.runFork(program)\n// Output:\n// task2 done\n```\n\n----------------------------------------\n\nTITLE: Effect.replicate Type Signature in TypeScript\nDESCRIPTION: Type declaration for the Effect.replicate function showing its polymorphic nature. Supports both curried and uncurried calling styles with generic type parameters for the effect's success type (A), error type (E), and environment type (R).\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-replicate.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const replicate: { (n: number): <A, E, R>(self: Effect<A, E, R>) => Array<Effect<A, E, R>>; <A, E, R>(self: Effect<A, E, R>, n: number): Array<Effect<A, E, R>>; }\n```\n\n----------------------------------------\n\nTITLE: Implementing Stream Timeout Switch in TypeScript\nDESCRIPTION: Defines a function that switches to an alternative stream if the original stream doesn't produce a value within a specified duration. Takes a duration parameter and an alternative stream, returning a combined stream that can emit values from either source.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-timeoutTo.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const timeoutTo: { <A2, E2, R2>(duration: Duration.DurationInput, that: Stream<A2, E2, R2>): <A, E, R>(self: Stream<A, E, R>) => Stream<A2 | A, E2 | E, R2 | R>; <A, E, R, A2, E2, R2>(self: Stream<A, E, R>, duration: Duration.DurationInput, that: Stream<A2, E2, R2>): Stream<A | A2, E | E2, R | R2>; }\n```\n\n----------------------------------------\n\nTITLE: Defining orElseSucceed Function in TypeScript for Stream Module\nDESCRIPTION: This code snippet defines the orElseSucceed function for the Stream module. The function succeeds with a specified value if the original stream fails with a typed error. It takes a lazy argument of type A2 and returns a new stream that either succeeds with the original value or the provided fallback value.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-orElseSucceed.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const orElseSucceed: { <A2>(value: LazyArg<A2>): <A, E, R>(self: Stream<A, E, R>) => Stream<A2 | A, never, R>; <A, E, R, A2>(self: Stream<A, E, R>, value: LazyArg<A2>): Stream<A | A2, never, R>; }\n```\n\n----------------------------------------\n\nTITLE: Running Stream into PubSub in Effect\nDESCRIPTION: The `runIntoPubSub` function takes a stream and a PubSub instance as input. It publishes each element of the stream to the PubSub as a `Take`.  The `Take` type is used to signal both elements and stream completion/failure to the subscribers. The function returns an Effect that, when executed, runs the stream and publishes its elements.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-runIntoPubSub.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const runIntoPubSub: { <A, E>(pubsub: PubSub.PubSub<Take.Take<A, E>>): <R>(self: Stream<A, E, R>) => Effect.Effect<void, never, R>; <A, E, R>(self: Stream<A, E, R>, pubsub: PubSub.PubSub<Take.Take<A, E>>): Effect.Effect<void, never, R>; }\n```\n\n----------------------------------------\n\nTITLE: Constructing a HashMap from Key/Value Pairs in TypeScript\nDESCRIPTION: The make function creates a new HashMap from an array of key/value pairs. It accepts a variable number of tuple entries and returns a HashMap with inferred key and value types based on the input entries.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/HashMap-make.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const make: <Entries extends ReadonlyArray<readonly [any, any]>>(...entries: Entries) => HashMap<Entries[number] extends readonly [infer K, any] ? K : never, Entries[number] extends readonly [any, infer V] ? V : never>\n```\n\n----------------------------------------\n\nTITLE: Using Effect.filterMap for Sequential Filtering and Mapping\nDESCRIPTION: Demonstrates how to use Effect.filterMap to process an array of async tasks, filtering even numbers and mapping the results. Each task is processed sequentially with a delay, and the results are logged to the console.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-filterMap.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Console, Effect, Option } from \"effect\"\n\nconst task = (n: number) =>\n  Effect.succeed(n).pipe(\n    Effect.delay(1000 - (n * 100)),\n    Effect.tap(Console.log(`task${n} done`))\n  )\n\nconst program = Effect.filterMap(\n  [task(1), task(2), task(3), task(4)],\n  (n) => n % 2 === 0 ? Option.some(n) : Option.none()\n)\n\nEffect.runPromise(program).then(console.log)\n// Output:\n// task1 done\n// task2 done\n// task3 done\n// task4 done\n// [ 2, 4 ]\n```\n\n----------------------------------------\n\nTITLE: Implementing STM Conditional Execution with TypeScript\nDESCRIPTION: Provides a function to conditionally execute an STM transaction based on a lazy boolean predicate. Returns an Option containing the result if the predicate is true, otherwise returns None.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/STM-when.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const when: { \n  (predicate: LazyArg<boolean>): <A, E, R>(self: STM<A, E, R>) => STM<Option.Option<A>, E, R>; \n  <A, E, R>(self: STM<A, E, R>, predicate: LazyArg<boolean>): STM<Option.Option<A>, E, R>; \n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Single-Valued Stream from Scoped Resource - TypeScript\nDESCRIPTION: This code snippet demonstrates how to create a single-valued stream using the 'Stream.scoped' method. It utilizes the Effect library to manage resources, ensuring that the 'acquire' and 'release' actions are logged appropriately. The example illustrates the entire stream lifecycle, including promise execution and result collection.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-scoped.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Console, Effect, Stream } from \"effect\"\n\n// Creating a single-valued stream from a scoped resource\nconst stream = Stream.scoped(\n Effect.acquireRelease(\n   Console.log(\"acquire\"),\n   () => Console.log(\"release\")\n )).pipe(\n Stream.flatMap(() => Console.log(\"use\"))\n)\n\nEffect.runPromise(Stream.runCollect(stream)).then(console.log)\n// acquire\n// use\n// release\n// { _id: 'Chunk', values: [ undefined ] }\n```\n\n----------------------------------------\n\nTITLE: Using Effect.logDebug with Logger Configuration in TypeScript\nDESCRIPTION: Demonstrates how to use Effect.logDebug to log messages at DEBUG level and configure the minimum log level using Logger.withMinimumLogLevel. The example shows logging a debug message and setting up the logger to display DEBUG level messages.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-logDebug.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Effect, Logger, LogLevel } from \"effect\"\n\nconst program = Effect.logDebug(\"message1\").pipe(Logger.withMinimumLogLevel(LogLevel.Debug))\n\nEffect.runFork(program)\n// timestamp=... level=DEBUG fiber=#0 message=message1\n```\n\n----------------------------------------\n\nTITLE: Creating Stream with unfoldEffect Example\nDESCRIPTION: Demonstrates how to create a stream using Stream.unfoldEffect that generates values based on random boolean conditions. The example shows unfolding from an initial value and transforming it based on random boolean results.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-unfoldEffect.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Effect, Option, Random, Stream } from \"effect\"\n\nconst stream = Stream.unfoldEffect(1, (n) =>\n  Random.nextBoolean.pipe(\n    Effect.map((b) => (b ? Option.some([n, -n]) : Option.some([n, n])))\n  ))\n\nEffect.runPromise(Stream.runCollect(stream.pipe(Stream.take(5)))).then(console.log)\n// { _id: 'Chunk', values: [ 1, -1, -1, -1, -1 ] }\n```\n\n----------------------------------------\n\nTITLE: Handling Interruptions with Cleanup in Effect.async\nDESCRIPTION: Example demonstrating how to provide a cleanup effect that runs when a fiber is interrupted. This pattern is useful for resource management, showing how to create a write stream operation that cleans up by deleting the file if interrupted.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-async.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Effect, Fiber } from \"effect\"\nimport * as NodeFS from \"node:fs\"\n\n// Simulates a long-running operation to write to a file\nconst writeFileWithCleanup = (filename: string, data: string) =>\n  Effect.async<void, Error>((resume) => {\n    const writeStream = NodeFS.createWriteStream(filename)\n\n    // Start writing data to the file\n    writeStream.write(data)\n\n    // When the stream is finished, resume with success\n    writeStream.on(\"finish\", () => resume(Effect.void))\n\n    // In case of an error during writing, resume with failure\n    writeStream.on(\"error\", (err) => resume(Effect.fail(err)))\n\n    // Handle interruption by returning a cleanup effect\n    return Effect.sync(() => {\n      console.log(`Cleaning up ${filename}`)\n      NodeFS.unlinkSync(filename)\n    })\n  })\n\nconst program = Effect.gen(function* () {\n  const fiber = yield* Effect.fork(\n    writeFileWithCleanup(\"example.txt\", \"Some long data...\")\n  )\n  // Simulate interrupting the fiber after 1 second\n  yield* Effect.sleep(\"1 second\")\n  yield* Fiber.interrupt(fiber) // This will trigger the cleanup\n})\n\n// Run the program\nEffect.runPromise(program)\n// Output:\n// Cleaning up example.txt\n```\n\n----------------------------------------\n\nTITLE: Number.clamp Example in Effect\nDESCRIPTION: This example demonstrates how to use the `Number.clamp` function from the Effect library to restrict numbers within a specified range. It showcases clamping within the range, below the range, and above the range, using `node:assert` for verification.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Number-clamp.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { Number } from \"effect\"\n\nconst clamp = Number.clamp({ minimum: 1, maximum: 5 })\n\nassert.equal(clamp(3), 3)\nassert.equal(clamp(0), 1)\nassert.equal(clamp(6), 5)\n```\n\n----------------------------------------\n\nTITLE: Converting Effect with NoSuchElementException to Option in TypeScript\nDESCRIPTION: This example demonstrates how to use Effect.optionFromOptional to transform effects that might fail with NoSuchElementException into effects that succeed with Option types. It shows handling both successful values and null values.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-optionFromOptional.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Effect } from \"effect\"\n\n//      ┌─── Effect<number, NoSuchElementException, never>\n//      ▼\nconst maybe1 = Effect.fromNullable(1)\n\n//      ┌─── Effect<Option<number>, never, never>\n//      ▼\nconst option1 = Effect.optionFromOptional(maybe1)\n\nEffect.runPromise(option1).then(console.log)\n// Output: { _id: 'Option', _tag: 'Some', value: 1 }\n\n//      ┌─── Effect<number, NoSuchElementException, never>\n//      ▼\nconst maybe2 = Effect.fromNullable(null as number | null)\n\n//      ┌─── Effect<Option<number>, never, never>\n//      ▼\nconst option2 = Effect.optionFromOptional(maybe2)\n\nEffect.runPromise(option2).then(console.log)\n// Output: { _tag: 'None' }\n```\n\n----------------------------------------\n\nTITLE: Creating Arrays with Initialization Function using Array.makeBy\nDESCRIPTION: The makeBy function creates a NonEmptyArray of length n with each element i initialized with f(i). The function normalizes n to an integer >= 1 and applies the provided function to each index to generate the array elements.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Array-makeBy.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { makeBy } from \"effect/Array\"\n\nconst result = makeBy(5, n => n * 2)\nconsole.log(result) // [0, 2, 4, 6, 8]\n```\n\n----------------------------------------\n\nTITLE: Reducing an Iterable of Option Values in TypeScript\nDESCRIPTION: This code snippet demonstrates the use of the `reduceCompact` function from the `Option` module in TypeScript. It aggregates values from an iterable of Option types, skipping any None values. The initial value and a reducing function are provided, and it effectively sums the Some values present in the iterable.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Option-reduceCompact.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Option, pipe } from \"effect\"\n\nconst iterable = [Option.some(1), Option.none(), Option.some(2), Option.none()]\n\nconsole.log(pipe(iterable, Option.reduceCompact(0, (b, a) => b + a)))\n// Output: 3\n```\n\n----------------------------------------\n\nTITLE: Using Effect.allSuccesses to Process Multiple Effects\nDESCRIPTION: Example demonstrating how to use Effect.allSuccesses to run multiple effects and collect only the successful results while ignoring failures. The example creates an array of effects with both successes and failures, then uses Effect.gen to yield the successful results.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-allSuccesses.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Effect } from \"effect\"\n\nconst tasks = [\n  Effect.succeed(1),\n  Effect.fail(\"Error 1\"),\n  Effect.succeed(2),\n  Effect.fail(\"Error 2\")\n]\n\nconst program = Effect.gen(function*() {\n  const successfulResults = yield* Effect.allSuccesses(tasks)\n  console.log(successfulResults)\n})\n\nEffect.runFork(program)\n// Output: [1, 2]\n```\n\n----------------------------------------\n\nTITLE: TypeScript Function Signature for Effect.when\nDESCRIPTION: The TypeScript function signature for Effect.when, showing its overloaded nature. It supports both curried and uncurried calling styles, taking a boolean condition and an Effect, and returning an Effect that produces an Option.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-when.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const when: { (condition: LazyArg<boolean>): <A, E, R>(self: Effect<A, E, R>) => Effect<Option.Option<A>, E, R>; <A, E, R>(self: Effect<A, E, R>, condition: LazyArg<boolean>): Effect<Option.Option<A>, E, R>; }\n```\n\n----------------------------------------\n\nTITLE: Implementing Span Creation in TypeScript using Effect\nDESCRIPTION: Function signature for creating and managing trace spans in Effect. The function accepts a span name and either a direct evaluation function or span options with an evaluation function. The span is automatically closed when the effect completes and is not added to the current span stack.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-useSpan.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const useSpan: { \n  <A, E, R>(name: string, evaluate: (span: Tracer.Span) => Effect<A, E, R>): Effect<A, E, R>; \n  <A, E, R>(name: string, options: Tracer.SpanOptions, evaluate: (span: Tracer.Span) => Effect<A, E, R>): Effect<A, E, R>; \n}\n```\n\n----------------------------------------\n\nTITLE: Using validateFirst to Find First Successful Operation in TypeScript\nDESCRIPTION: This example demonstrates how to use Effect.validateFirst to process an array of numbers, returning the first value that satisfies a condition or collecting all error messages if none do. The function stops processing once it finds a value >= 4.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-validateFirst.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Effect, Console } from \"effect\"\n\n//      ┌─── Effect<number, string[], never>\n//      ▼\nconst program = Effect.validateFirst([1, 2, 3, 4, 5], (n) => {\n  if (n < 4) {\n    return Effect.fail(`${n} is not less that 4`)\n  } else {\n    return Console.log(`item ${n}`).pipe(Effect.as(n))\n  }\n})\n\nEffect.runPromise(program).then(console.log, console.error)\n// Output:\n// item 4\n// 4\n```\n\n----------------------------------------\n\nTITLE: Effect.acquireUseRelease Type Signature in TypeScript\nDESCRIPTION: The type signature for the Effect.acquireUseRelease function, showing its polymorphic nature and the types of the acquire, use, and release functions. This demonstrates the function's flexibility in handling different resource types and error scenarios.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-acquireUseRelease.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const acquireUseRelease: { <A2, E2, R2, A, X, R3>(use: (a: A) => Effect<A2, E2, R2>, release: (a: A, exit: Exit.Exit<A2, E2>) => Effect<X, never, R3>): <E, R>(acquire: Effect<A, E, R>) => Effect<A2, E2 | E, R2 | R3 | R>; <A, E, R, A2, E2, R2, X, R3>(acquire: Effect<A, E, R>, use: (a: A) => Effect<A2, E2, R2>, release: (a: A, exit: Exit.Exit<A2, E2>) => Effect<X, never, R3>): Effect<A2, E | E2, R | R2 | R3>; }\n```\n\n----------------------------------------\n\nTITLE: Appending Elements to Chunks in TypeScript\nDESCRIPTION: The append function adds a specified element to the end of a Chunk, returning a new NonEmptyChunk. It supports both curried and uncurried calling styles, allowing flexible usage in different contexts.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Chunk-append.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const append: { <A2>(a: A2): <A>(self: Chunk<A>) => NonEmptyChunk<A2 | A>; <A, A2>(self: Chunk<A>, a: A2): NonEmptyChunk<A | A2>; }\n```\n\n----------------------------------------\n\nTITLE: Creating a Failed Effect using Effect.fail in TypeScript\nDESCRIPTION: This snippet demonstrates how to use Effect.fail to create an Effect that represents a recoverable error. It creates a failure Effect with an Error object.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-fail.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Effect } from \"effect\"\n\n//      ┌─── Effect<never, Error, never>\n//      ▼\nconst failure = Effect.fail(\n  new Error(\"Operation failed due to network error\")\n)\n```\n\n----------------------------------------\n\nTITLE: Using tapErrorCause to Inspect Error Causes in Effect\nDESCRIPTION: This example demonstrates how to use tapErrorCause to access and log error causes without modifying the original effect. It shows handling both a recoverable error (NetworkError) and an irrecoverable defect (Something went wrong).\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-tapErrorCause.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Effect, Console } from \"effect\"\n\n// Create a task that fails with a NetworkError\nconst task1: Effect.Effect<number, string> = Effect.fail(\"NetworkError\")\n\nconst tapping1 = Effect.tapErrorCause(task1, (cause) =>\n  Console.log(`error cause: ${cause}`)\n)\n\nEffect.runFork(tapping1)\n// Output:\n// error cause: Error: NetworkError\n\n// Simulate a severe failure in the system\nconst task2: Effect.Effect<number, string> = Effect.dieMessage(\n  \"Something went wrong\"\n)\n\nconst tapping2 = Effect.tapErrorCause(task2, (cause) =>\n  Console.log(`error cause: ${cause}`)\n)\n\nEffect.runFork(tapping2)\n// Output:\n// error cause: RuntimeException: Something went wrong\n//   ... stack trace ...\n```\n\n----------------------------------------\n\nTITLE: Using Effect.tapBoth for Logging in TypeScript\nDESCRIPTION: Demonstrates how to use Effect.tapBoth to log both success and failure outcomes of an effect without modifying the original result. The example simulates a task that might fail and logs the outcome.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-tapBoth.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Effect, Random, Console } from \"effect\"\n\n// Simulate a task that might fail\nconst task = Effect.filterOrFail(\n  Random.nextRange(-1, 1),\n  (n) => n >= 0,\n  () => \"random number is negative\"\n)\n\n// Use tapBoth to log both success and failure outcomes\nconst tapping = Effect.tapBoth(task, {\n  onFailure: (error) => Console.log(`failure: ${error}`),\n  onSuccess: (randomNumber) =>\n    Console.log(`random number: ${randomNumber}`)\n})\n\nEffect.runFork(tapping)\n// Example Output:\n// failure: random number is negative\n```\n\n----------------------------------------\n\nTITLE: Filtering and Mapping Stream Elements Conditionally\nDESCRIPTION: Transforms stream elements using a partial function that returns an Option, processing elements until the function is no longer defined. Supports both curried and direct function call signatures.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-filterMapWhile.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const filterMapWhile: { <A, A2>(pf: (a: A) => Option.Option<A2>): <E, R>(self: Stream<A, E, R>) => Stream<A2, E, R>; <A, E, R, A2>(self: Stream<A, E, R>, pf: (a: A) => Option.Option<A2>): Stream<A2, E, R>; }\n```\n\n----------------------------------------\n\nTITLE: TypeScript Signature for Effect.unlessEffect Function\nDESCRIPTION: Defines the type signature for the unlessEffect function, which conditionally executes an effect based on the result of another effect. The function supports both curried and uncurried calling styles and returns an Option of the original effect's result type.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-unlessEffect.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const unlessEffect: { <E2, R2>(condition: Effect<boolean, E2, R2>): <A, E, R>(self: Effect<A, E, R>) => Effect<Option.Option<A>, E2 | E, R2 | R>; <A, E, R, E2, R2>(self: Effect<A, E, R>, condition: Effect<boolean, E2, R2>): Effect<Option.Option<A>, E | E2, R | R2>; }\n```\n\n----------------------------------------\n\nTITLE: Signature of Option.toRefinement function in Typescript\nDESCRIPTION: The `toRefinement` function takes a function `f` that maps a type `A` to `Option<B>`, where `B` extends `A`, and returns a type guard function that checks if a value of type `A` is also of type `B`. This type guard is useful for narrowing types and validating input.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Option-toRefinement.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const toRefinement: <A, B extends A>(f: (a: A) => Option<B>) => (a: A) => a is B\n```\n\n----------------------------------------\n\nTITLE: Implementing Resource Management with acquireUseRelease in TypeScript\nDESCRIPTION: Defines a function that manages resource lifecycle by handling acquisition, usage, and release phases. The function takes three parameters: acquire (to obtain the resource), use (to utilize the resource), and release (to clean up the resource). It ensures proper resource cleanup regardless of whether the use phase succeeds or fails.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Micro-acquireUseRelease.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const acquireUseRelease: <Resource, E, R, A, E2, R2, E3, R3>(acquire: Micro<Resource, E, R>, use: (a: Resource) => Micro<A, E2, R2>, release: (a: Resource, exit: MicroExit<A, E2>) => Micro<void, E3, R3>) => Micro<A, E | E2 | E3, R | R2 | R3>\n```\n\n----------------------------------------\n\nTITLE: Pattern Matching with Match.type in TypeScript\nDESCRIPTION: Demonstrates how to use Match.type to create a type-safe pattern matcher for handling different value types. The example shows matching on string and number types with custom handlers for each case.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Match-type.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Match } from \"effect\"\n\n// Create a matcher for values that are either strings or numbers\n//\n//      ┌─── (u: string | number) => string\n//      ▼\nconst match = Match.type<string | number>().pipe(\n  // Match when the value is a number\n  Match.when(Match.number, (n) => `number: ${n}`),\n  // Match when the value is a string\n  Match.when(Match.string, (s) => `string: ${s}`),\n  // Ensure all possible cases are handled\n  Match.exhaustive\n)\n\nconsole.log(match(0))\n// Output: \"number: 0\"\n\nconsole.log(match(\"hello\"))\n// Output: \"string: hello\"\n```\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const type: <I>() => Matcher<I, Types.Without<never>, I, never, never>\n```\n\n----------------------------------------\n\nTITLE: Converting Channel to Queue in TypeScript\nDESCRIPTION: The toQueue function converts a Channel to a Queue. It takes an Enqueue that can receive either elements or completion signals and returns a Channel that will feed elements and completion signals to the queue.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Channel-toQueue.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const toQueue: <Done, Err, Elem>(queue: Queue.Enqueue<Either.Either<Elem, Exit.Exit<Done, Err>>>) => Channel<never, Elem, never, Err, unknown, Done>\n```\n\n----------------------------------------\n\nTITLE: Using Effect.custom for Custom Stack Tracing in TypeScript\nDESCRIPTION: Demonstrates how to use Effect.custom to create a custom effect with a throwing function. This allows for custom stack tracing cutpoints in Effect operations.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-custom.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Effect } from \"effect\"\n\nconst throwingFunction = () => { throw new Error() }\nconst blowUp = Effect.custom(throwingFunction, function() {\n  return Effect.succeed(this.effect_instruction_i0())\n})\n```\n\n----------------------------------------\n\nTITLE: Retrieving STM Context in TypeScript\nDESCRIPTION: This snippet demonstrates how to retrieve the environment within an STM context using the `STM.context` function from the Effect-TS library. The function returns an `STM` value that, when executed, yields the current `Context`. It requires the Effect-TS library as a dependency.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/STM-context.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const context: <R>() => STM<Context.Context<R>, never, R>\n```\n\n----------------------------------------\n\nTITLE: Converting Iterable to Option\nDESCRIPTION: The 'fromIterable' function takes an Iterable collection and returns an Option type encapsulating the first element, if it exists; otherwise, it returns None. This function is useful for safely managing collections that may be empty.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Option-fromIterable.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Option } from \"effect\"\n\nconsole.log(Option.fromIterable([1, 2, 3]))\n// Output: { _id: 'Option', _tag: 'Some', value: 1 }\n\nconsole.log(Option.fromIterable([]))\n// Output: { _id: 'Option', _tag: 'None' }\n```\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const fromIterable: <A>(collection: Iterable<A>) => Option<A>\n```\n\n----------------------------------------\n\nTITLE: Applying a Discount Based on Fetched Amount Using Effect Chain\nDESCRIPTION: Demonstrates a practical example of using Effect.andThen to perform a sequence of operations: fetching a transaction amount, doubling it, and then applying a discount. The example compares implementation using both Effect.map/flatMap and Effect.andThen approaches.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-andThen.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { pipe, Effect } from \"effect\"\n\n// Function to apply a discount safely to a transaction amount\nconst applyDiscount = (\n  total: number,\n  discountRate: number\n): Effect.Effect<number, Error> =>\n  discountRate === 0\n    ? Effect.fail(new Error(\"Discount rate cannot be zero\"))\n    : Effect.succeed(total - (total * discountRate) / 100)\n\n// Simulated asynchronous task to fetch a transaction amount from database\nconst fetchTransactionAmount = Effect.promise(() => Promise.resolve(100))\n\n// Using Effect.map and Effect.flatMap\nconst result1 = pipe(\n  fetchTransactionAmount,\n  Effect.map((amount) => amount * 2),\n  Effect.flatMap((amount) => applyDiscount(amount, 5))\n)\n\nEffect.runPromise(result1).then(console.log)\n// Output: 190\n\n// Using Effect.andThen\nconst result2 = pipe(\n  fetchTransactionAmount,\n  Effect.andThen((amount) => amount * 2),\n  Effect.andThen((amount) => applyDiscount(amount, 5))\n)\n\nEffect.runPromise(result2).then(console.log)\n// Output: 190\n```\n\n----------------------------------------\n\nTITLE: Constructing Right Value in Either Module (TypeScript)\nDESCRIPTION: Defines the right function that constructs a new Either holding a Right value. This function is typically used to represent a successful value due to the right bias of the Either structure.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Either-right.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const right: <R>(right: R) => Either<R>\n```\n\n----------------------------------------\n\nTITLE: Finding Elements with Effect in Stream - TypeScript\nDESCRIPTION: The 'findEffect' function enables finding the first element in a stream that meets a specified condition based on an effectful predicate. It offers a signature for both curried usage and direct invocation. This function is crucial for filtering streams with side effects integrated into the predicate evaluation process.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-findEffect.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const findEffect: { <A, E2, R2>(predicate: (a: NoInfer<A>) => Effect.Effect<boolean, E2, R2>): <E, R>(self: Stream<A, E, R>) => Stream<A, E2 | E, R2 | R>; <A, E, R, E2, R2>(self: Stream<A, E, R>, predicate: (a: NoInfer<A>) => Effect.Effect<boolean, E2, R2>): Stream<A, E | E2, R | R2>; }\n```\n\n----------------------------------------\n\nTITLE: Creating localStorage Layer in Effect.js\nDESCRIPTION: Creates a KeyValueStore layer implementation that persists data using the browser's localStorage API. The layer provides persistent storage that survives between browser sessions.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/BrowserKeyValueStore-layerLocalStorage.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const layerLocalStorage: Layer.Layer<KeyValueStore.KeyValueStore, never, never>\n```\n\n----------------------------------------\n\nTITLE: Effect.option Function Signature in TypeScript\nDESCRIPTION: The type signature of the option function in the Effect module, showing it takes an Effect<A, E, R> and returns an Effect<Option<A>, never, R>. The never type indicates the resulting effect cannot fail directly.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-option.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const option: <A, E, R>(self: Effect<A, E, R>) => Effect<Option.Option<A>, never, R>\n```\n\n----------------------------------------\n\nTITLE: Replacing a Value with Effect.as in TypeScript\nDESCRIPTION: This example demonstrates how to use the Effect.as method to replace the original value inside an effect with a constant value. The code imports necessary components, creates an effect that produces the value 5, and then replaces it with the string \"new value\".\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-as.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { pipe, Effect } from \"effect\"\n\n// Replaces the value 5 with the constant \"new value\"\nconst program = pipe(Effect.succeed(5), Effect.as(\"new value\"))\n\nEffect.runPromise(program).then(console.log)\n// Output: \"new value\"\n```\n\n----------------------------------------\n\nTITLE: Interleaving Streams with Boolean Control in TypeScript\nDESCRIPTION: Demonstrates how to use the `interleaveWith` function to combine two streams based on a boolean control stream. It shows the creation of two number streams and a boolean stream, then interleaves them and collects the result.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-interleaveWith.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Effect, Stream } from \"effect\"\n\nconst s1 = Stream.make(1, 3, 5, 7, 9)\nconst s2 = Stream.make(2, 4, 6, 8, 10)\n\nconst booleanStream = Stream.make(true, false, false).pipe(Stream.forever)\n\nconst stream = Stream.interleaveWith(s1, s2, booleanStream)\n\nEffect.runPromise(Stream.runCollect(stream)).then(console.log)\n// {\n//   _id: 'Chunk',\n//   values: [\n//     1, 2,  4, 3, 6,\n//     8, 5, 10, 7, 9\n//   ]\n// }\n```\n\n----------------------------------------\n\nTITLE: Forking a Fiber in a Local Scope with Effect.forkScoped in TypeScript\nDESCRIPTION: This example demonstrates how Effect.forkScoped creates a child fiber that continues running beyond the parent fiber's lifetime. The child fiber logs a message every second and is tied to a local scope that lasts for 5 seconds, while the parent fiber completes after 3 seconds.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-forkScoped.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Effect, Console, Schedule } from \"effect\"\n\n// Child fiber that logs a message repeatedly every second\nconst child = Effect.repeat(\n  Console.log(\"child: still running!\"),\n  Schedule.fixed(\"1 second\")\n)\n\n//      ┌─── Effect<void, never, Scope>\n//      ▼\nconst parent = Effect.gen(function* () {\n  console.log(\"parent: started!\")\n  // Child fiber attached to local scope\n  yield* Effect.forkScoped(child)\n  yield* Effect.sleep(\"3 seconds\")\n  console.log(\"parent: finished!\")\n})\n\n// Program runs within a local scope\nconst program = Effect.scoped(\n  Effect.gen(function* () {\n    console.log(\"Local scope started!\")\n    yield* Effect.fork(parent)\n    // Scope lasts for 5 seconds\n    yield* Effect.sleep(\"5 seconds\")\n    console.log(\"Leaving the local scope!\")\n  })\n)\n\nEffect.runFork(program)\n// Output:\n// Local scope started!\n// parent: started!\n// child: still running!\n// child: still running!\n// child: still running!\n// parent: finished!\n// child: still running!\n// child: still running!\n// Leaving the local scope!\n```\n\n----------------------------------------\n\nTITLE: Defining retryTransient Function for HttpClient in TypeScript\nDESCRIPTION: Declares a function that retries common transient errors in HTTP client operations. It allows customization of retry behavior through options or a schedule. The function can consider additional errors as transient based on a provided predicate.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/HttpClient-retryTransient.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const retryTransient: { <B, E, R1 = never>(options: { readonly while?: Predicate.Predicate<NoInfer<E>>; readonly schedule?: Schedule.Schedule<B, NoInfer<E>, R1>; readonly times?: number; } | Schedule.Schedule<B, NoInfer<E>, R1>): <R>(self: HttpClient.With<E, R>) => HttpClient.With<E, R1 | R>; <E, R, B, R1 = never>(self: HttpClient.With<E, R>, options: { readonly while?: Predicate.Predicate<NoInfer<E>>; readonly schedule?: Schedule.Schedule<B, NoInfer<E>, R1>; readonly times?: number; } | Schedule.Schedule<B, NoInfer<E>, R1>): HttpClient.With<E, R1 | R>; }\n```\n\n----------------------------------------\n\nTITLE: Creating a Sliding Queue in Effect.ts\nDESCRIPTION: Creates a new bounded Queue with a sliding strategy. When the queue reaches capacity, new elements are added while old elements are dropped. For optimal performance, it's recommended to use power of 2 capacities.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Queue-sliding.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const sliding: <A>(requestedCapacity: number) => Effect.Effect<Queue<A>>\n```\n\n----------------------------------------\n\nTITLE: Merging Streams with Effect and TypeScript\nDESCRIPTION: This snippet demonstrates how to merge two streams in TypeScript using the Effect library. It utilizes the `Stream.merge` method, illustrating the combination of outputs from two different streams with specified scheduling. The expected output is a merged stream containing values from both input streams, interleaved according to their respective schedules.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-merge.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Effect, Schedule, Stream } from \"effect\"\n\nconst s1 = Stream.make(1, 2, 3).pipe(\n  Stream.schedule(Schedule.spaced(\"100 millis\"))\n)\nconst s2 = Stream.make(4, 5, 6).pipe(\n  Stream.schedule(Schedule.spaced(\"200 millis\"))\n)\n\nconst stream = Stream.merge(s1, s2)\n\nEffect.runPromise(Stream.runCollect(stream)).then(console.log)\n// { _id: 'Chunk', values: [ 1, 4, 2, 3, 5, 6 ] }\n```\n\n----------------------------------------\n\nTITLE: Creating a Tagged Service with Effect.Tag in TypeScript\nDESCRIPTION: Example of defining a service using Effect.Tag that creates a Notifications class with static access to its methods. The notify method becomes directly accessible as a static property of the Notifications class.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-Tag.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Effect } from \"effect\"\n\nclass Notifications extends Effect.Tag(\"Notifications\")<\n  Notifications,\n  { readonly notify: (message: string) => Effect.Effect<void> }\n>() {}\n\n// Create an effect that depends on the Notifications service\nconst action = Notifications.notify(\"Hello, world!\")\n```\n\n----------------------------------------\n\nTITLE: Using HashSet.flatMap in TypeScript with Effect Library\nDESCRIPTION: Examples of using HashSet.flatMap to transform HashSet values. The function chains over each value in a HashSet and applies a function that returns an Iterable, flattening the results into a new HashSet. Shown in both data-last (pipeable) and data-first calling styles.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/HashSet-flatMap.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// Syntax\nimport { HashSet, pipe } from \"effect\"\n\n// with `data-last`, a.k.a. `pipeable` API\npipe(\n  HashSet.make(0, 1, 2), // HashSet.HashSet<number>\n  HashSet.flatMap((n) => Array.of(String(n))) // HashSet.HashSet<string>\n)\n\n// or piped with the pipe method\nHashSet.make(0, 1, 2) // HashSet.HashSet<number>\n  .pipe(\n    HashSet.flatMap((n) => Array.of(String(n))) // HashSet.HashSet<string>\n  )\n\n// or with `data-first` API\nHashSet.flatMap(HashSet.make(0, 1, 2), (n) => Array.of(String(n)))\n```\n\n----------------------------------------\n\nTITLE: Effect.provide Type Signature\nDESCRIPTION: Comprehensive type definition for Effect.provide showing all possible overloads and type parameters. Includes support for layers, contexts, runtimes, and managed runtimes.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-provide.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const provide: { <const Layers extends [Layer.Layer.Any, ...Array<Layer.Layer.Any>]>(layers: Layers): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E | { [k in keyof Layers]: Layer.Layer.Error<Layers[k]>; }[number], { [k in keyof Layers]: Layer.Layer.Context<Layers[k]>; }[number] | Exclude<R, { [k in keyof Layers]: Layer.Layer.Success<Layers[k]>; }[number]>>; <ROut, E2, RIn>(layer: Layer.Layer<ROut, E2, RIn>): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E | E2, RIn | Exclude<R, ROut>>; <R2>(context: Context.Context<R2>): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, Exclude<R, R2>>; <R2>(runtime: Runtime.Runtime<R2>): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, Exclude<R, R2>>; <E2, R2>(managedRuntime: ManagedRuntime.ManagedRuntime<R2, E2>): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E | E2, Exclude<R, R2>>; <A, E, R, const Layers extends [Layer.Layer.Any, ...Array<Layer.Layer.Any>]>(self: Effect<A, E, R>, layers: Layers): Effect<A, E | { [k in keyof Layers]: Layer.Layer.Error<Layers[k]>; }[number], { [k in keyof Layers]: Layer.Layer.Context<Layers[k]>; }[number] | Exclude<R, { [k in keyof Layers]: Layer.Layer.Success<Layers[k]>; }[number]>>; <A, E, R, ROut, E2, RIn>(self: Effect<A, E, R>, layer: Layer.Layer<ROut, E2, RIn>): Effect<A, E | E2, RIn | Exclude<R, ROut>>; <A, E, R, R2>(self: Effect<A, E, R>, context: Context.Context<R2>): Effect<A, E, Exclude<R, R2>>; <A, E, R, R2>(self: Effect<A, E, R>, runtime: Runtime.Runtime<R2>): Effect<A, E, Exclude<R, R2>>; <A, E, E2, R, R2>(self: Effect<A, E, R>, runtime: ManagedRuntime.ManagedRuntime<R2, E2>): Effect<A, E | E2, Exclude<R, R2>>; }\n```\n\n----------------------------------------\n\nTITLE: Using Stream.mapConcat with Effect in TypeScript\nDESCRIPTION: This example uses the Effect library to demonstrate how to process streams. It uses the Stream.mapConcat function to split and flatten a set of strings into individual numbers. The example assumes that 'effect' library is installed as a prerequisite. The function takes a stream of strings, splits them, and maps them into integers. The process results in a flat stream of numbers, which is collected and logged to the console.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-mapConcat.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { Effect, Stream } from \"effect\"\n\nconst numbers = Stream.make(\"1-2-3\", \"4-5\", \"6\").pipe(\n  Stream.mapConcat((s) => s.split(\"-\")),\n  Stream.map((s) => parseInt(s))\n)\n\nEffect.runPromise(Stream.runCollect(numbers)).then(console.log)\n// { _id: 'Chunk', values: [ 1, 2, 3, 4, 5, 6 ] }\n```\n\n----------------------------------------\n\nTITLE: Filtering and Mapping Records with Effect\nDESCRIPTION: This code snippet demonstrates the usage of `Record.filterMap` to transform a record. It defines a function `f` that multiplies values greater than 2 by 2 and wraps the result in `Option.some`, otherwise returns `Option.none`. The resulting record only contains key-value pairs where `f` returned `Option.some`.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Record-filterMap.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { Record, Option } from \"effect\"\n\nconst x = { a: 1, b: 2, c: 3 }\nconst f = (a: number, key: string) => a > 2 ? Option.some(a * 2) : Option.none()\nassert.deepStrictEqual(Record.filterMap(x, f), { c: 6 })\n```\n\n----------------------------------------\n\nTITLE: Retrieving First Element from Non-Empty Array in TypeScript\nDESCRIPTION: This snippet demonstrates how to use the `Array.headNonEmpty` function to get the first element of a non-empty array. It imports the Array module from the effect package and applies the function to an array of numbers.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Array-headNonEmpty.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Array } from \"effect\"\n\nconst result = Array.headNonEmpty([1, 2, 3, 4])\nconsole.log(result) // 1\n```\n\n----------------------------------------\n\nTITLE: Creating a Stream with Finalizer in TypeScript\nDESCRIPTION: Demonstrates how to use Stream.finalizer to execute cleanup logic after stream processing, such as deleting temporary resources\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-finalizer.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Console, Effect, Stream } from \"effect\"\n\nconst application = Stream.fromEffect(Console.log(\"Application Logic.\"))\n\nconst deleteDir = (dir: string) => Console.log(`Deleting dir: ${dir}`)\n\nconst program = application.pipe(\n  Stream.concat(\n    Stream.finalizer(\n      deleteDir(\"tmp\").pipe(\n        Effect.andThen(Console.log(\"Temporary directory was deleted.\"))\n      )\n    )\n  )\n)\n\nEffect.runPromise(Stream.runCollect(program)).then(console.log)\n```\n\n----------------------------------------\n\nTITLE: Using Array.findLast to Find the Last Even Number in TypeScript\nDESCRIPTION: Example showing how to use the Array.findLast method to find the last element in an array that satisfies a condition. This example searches for the last even number in an array of integers and returns it as an Option.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Array-findLast.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Array } from \"effect\"\n\nconst result = Array.findLast([1, 2, 3, 4, 5], n => n % 2 === 0)\nconsole.log(result) // Option.some(4)\n```\n\n----------------------------------------\n\nTITLE: Executing Effects Around Request Resolution in TypeScript\nDESCRIPTION: Demonstrates how to use RequestResolver.aroundRequests to execute effects before and after resolving requests. This example shows a resolver that logs the number of requests being processed before execution and after completion.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/RequestResolver-aroundRequests.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Effect, Request, RequestResolver } from \"effect\"\n\ninterface GetUserById extends Request.Request<unknown> {\n  readonly id: number\n}\n\nconst resolver = RequestResolver.fromFunction(\n  (request: GetUserById) => ({ id: request.id, name: \"John\" })\n)\n\nRequestResolver.aroundRequests(\n  resolver,\n  (requests) => Effect.log(`got ${requests.length} requests`),\n  (requests, _) => Effect.log(`finised running ${requests.length} requests`)\n)\n```\n\n----------------------------------------\n\nTITLE: Using Either.Do for Declarative Operations with Either Values in TypeScript\nDESCRIPTION: This example demonstrates how to use Either.Do to create a pipeline that binds values to variables and computes a sum. It shows binding two values (x and y) to Either.right instances and then defining a derived value (sum) using the let function.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Either-Do.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { Either, pipe } from \"effect\"\n\nconst result = pipe(\n  Either.Do,\n  Either.bind(\"x\", () => Either.right(2)),\n  Either.bind(\"y\", () => Either.right(3)),\n  Either.let(\"sum\", ({ x, y }) => x + y)\n)\nassert.deepStrictEqual(result, Either.right({ x: 2, y: 3, sum: 5 }))\n```\n\n----------------------------------------\n\nTITLE: Creating MutableHashSet from Array in TypeScript using Effect\nDESCRIPTION: Demonstrates how to create a MutableHashSet from an array of numbers, showing how duplicate values are automatically removed. The resulting MutableHashSet is also iterable, making it compatible with functions expecting iterables like Array.from().\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/MutableHashSet-fromIterable.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { MutableHashSet } from \"effect\"\n\nconst array: Iterable<number> = [1, 2, 3, 4, 5, 1, 2, 3] // Array<T> is also Iterable<T>\nconst mutableHashSet: MutableHashSet.MutableHashSet<number> =\n  MutableHashSet.fromIterable(array)\n\nconsole.log(\n  // MutableHashSet.MutableHashSet<T> is also an Iterable<T>\n  Array.from(mutableHashSet)\n) // Output: [1, 2, 3, 4, 5]\n```\n\n----------------------------------------\n\nTITLE: Creating Context with Service Tag in TypeScript\nDESCRIPTION: Demonstrates how to create a new Context instance with a single service using Context.make. The example shows creating a Port service with a value of 8080 and verifying it with assert.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Context-make.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { Context } from \"effect\"\n\nconst Port = Context.GenericTag<{ PORT: number }>(\"Port\")\n\nconst Services = Context.make(Port, { PORT: 8080 })\n\nassert.deepStrictEqual(Context.get(Services, Port), { PORT: 8080 })\n```\n\n----------------------------------------\n\nTITLE: Implementing Custom Equality for MutableHashSet in TypeScript\nDESCRIPTION: This example demonstrates how to create a custom class (Character) that implements the Equal interface and Hash symbol for use with MutableHashSet. It shows how to define equality based on properties and generate hash codes for custom objects.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/MutableHashSet-make.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Equal, Hash, MutableHashSet } from \"effect\"\nimport assert from \"node:assert/strict\"\n\nclass Character implements Equal.Equal {\n  readonly name: string\n  readonly trait: string\n\n  constructor(name: string, trait: string) {\n    this.name = name\n    this.trait = trait\n  }\n\n  // Define equality based on name, and trait\n  [Equal.symbol](that: Equal.Equal): boolean {\n    if (that instanceof Character) {\n      return (\n        Equal.equals(this.name, that.name) &&\n        Equal.equals(this.trait, that.trait)\n      )\n    }\n    return false\n  }\n\n  // Generate a hash code based on the sum of the character's name and trait\n  [Hash.symbol](): number {\n    return Hash.hash(this.name + this.trait)\n  }\n\n  static readonly of = (name: string, trait: string): Character => {\n    return new Character(name, trait)\n  }\n}\n\nconst mutableCharacterHashSet = MutableHashSet.make(\n  Character.of(\"Alice\", \"Curious\"),\n  Character.of(\"Alice\", \"Curious\"),\n  Character.of(\"White Rabbit\", \"Always late\"),\n  Character.of(\"Mad Hatter\", \"Tea enthusiast\")\n)\n\nassert.equal(\n  MutableHashSet.has(\n    mutableCharacterHashSet,\n    Character.of(\"Alice\", \"Curious\")\n  ),\n  true\n)\nassert.equal(\n  MutableHashSet.has(\n    mutableCharacterHashSet,\n    Character.of(\"Fluffy\", \"Kind\")\n  ),\n  false\n)\n```\n\n----------------------------------------\n\nTITLE: Creating and Composing RateLimiters in TypeScript\nDESCRIPTION: This example demonstrates how to create and compose RateLimiters using the Effect library. It creates two rate limiters, one for per-minute and one for per-second limits, and composes them to apply both constraints.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/RateLimiter-make.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Effect, RateLimiter } from \"effect\";\nimport { compose } from \"effect/Function\"\n\nconst program = Effect.scoped(\n  Effect.gen(function* ($) {\n    const perMinuteRL = yield* $(RateLimiter.make({ limit: 30, interval: \"1 minutes\" }))\n    const perSecondRL = yield* $(RateLimiter.make({ limit: 2, interval: \"1 seconds\" }))\n\n    // This rate limiter respects both the 30 calls per minute\n    // and the 2 calls per second constraints.\n     const rateLimit = compose(perMinuteRL, perSecondRL)\n\n    // simulate repeated calls\n    for (let n = 0; n < 100; n++) {\n      // wrap the effect we want to limit with rateLimit\n      yield* $(rateLimit(Effect.log(\"Calling RateLimited Effect\")));\n    }\n  })\n);\n```\n\n----------------------------------------\n\nTITLE: Implementing Config Fallback in TypeScript with Effect\nDESCRIPTION: Defines a configuration fallback mechanism where if reading from the primary config fails, it falls back to a secondary config. The function takes a lazy argument for the fallback config and returns a combined config that can return either type.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Config-orElse.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const orElse: { <A2>(that: LazyArg<Config<A2>>): <A>(self: Config<A>) => Config<A2 | A>; <A, A2>(self: Config<A>, that: LazyArg<Config<A2>>): Config<A | A2>; }\n```\n\n----------------------------------------\n\nTITLE: Retrieving First Element Using Effect.head in TypeScript\nDESCRIPTION: Demonstrates how to use Effect.head to retrieve the first element from an async collection. The example shows fetching numbers with a delay and accessing the first element, with proper error handling for empty collections.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-head.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Effect } from \"effect\"\n\n// Simulate an async operation\nconst fetchNumbers = Effect.succeed([1, 2, 3]).pipe(Effect.delay(\"100 millis\"))\n\nconst program = Effect.gen(function*() {\n  const firstElement = yield* Effect.head(fetchNumbers)\n  console.log(firstElement)\n})\n\nEffect.runFork(program)\n// Output: 1\n```\n\n----------------------------------------\n\nTITLE: Using Option.gen to Create a Combined Value\nDESCRIPTION: This code snippet demonstrates how to use `Option.gen` to combine values from multiple `Option` instances. It defines two `Option` values, `maybeName` and `maybeAge`, and uses `Option.gen` to extract and combine their values into a new object. The example transforms the name to uppercase and combines it with the age.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Option-gen.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Option } from \"effect\"\n\nconst maybeName: Option.Option<string> = Option.some(\"John\")\nconst maybeAge: Option.Option<number> = Option.some(25)\n\nconst person = Option.gen(function* () {\n  const name = (yield* maybeName).toUpperCase()\n  const age = yield* maybeAge\n  return { name, age }\n})\n\nconsole.log(person)\n// Output:\n// { _id: 'Option', _tag: 'Some', value: { name: 'JOHN', age: 25 } }\n```\n\n----------------------------------------\n\nTITLE: Defining the Fiber Interface in TypeScript\nDESCRIPTION: TypeScript interface definition for Fiber, which extends Effect and includes methods for managing lightweight concurrent execution. The interface provides operations for awaiting fiber completion, retrieving children, inheriting FiberRef values, polling for status, and interrupting execution.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Fiber-Fiber.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface Fiber<out A, out E = never> extends Effect.Effect<A, E>, Fiber.Variance<A, E> {\n  /**\n   * The identity of the fiber.\n   */\n  id(): FiberId.FiberId\n\n  /**\n   * Awaits the fiber, which suspends the awaiting fiber until the result of the\n   * fiber has been determined.\n   */\n  readonly await: Effect.Effect<Exit.Exit<A, E>>\n\n  /**\n   * Retrieves the immediate children of the fiber.\n   */\n  readonly children: Effect.Effect<Array<Fiber.Runtime<any, any>>>\n\n  /**\n   * Inherits values from all `FiberRef` instances into current fiber. This\n   * will resume immediately.\n   */\n  readonly inheritAll: Effect.Effect<void>\n\n  /**\n   * Tentatively observes the fiber, but returns immediately if it is not\n   * already done.\n   */\n  readonly poll: Effect.Effect<Option.Option<Exit.Exit<A, E>>>\n\n  /**\n   * In the background, interrupts the fiber as if interrupted from the\n   * specified fiber. If the fiber has already exited, the returned effect will\n   * resume immediately. Otherwise, the effect will resume when the fiber exits.\n   */\n  interruptAsFork(fiberId: FiberId.FiberId): Effect.Effect<void>\n\n  readonly [Unify.typeSymbol]?: unknown\n  readonly [Unify.unifySymbol]?: FiberUnify<this>\n  readonly [Unify.ignoreSymbol]?: FiberUnifyIgnore\n}\n```\n\n----------------------------------------\n\nTITLE: Combining Two Effects Sequentially with Effect.zip in TypeScript\nDESCRIPTION: This example demonstrates how to combine two effects sequentially using Effect.zip. Each effect has a different delay and returns a different type of value. The combined effect returns a tuple containing both results.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-zip.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Effect } from \"effect\"\n\nconst task1 = Effect.succeed(1).pipe(\n  Effect.delay(\"200 millis\"),\n  Effect.tap(Effect.log(\"task1 done\"))\n)\nconst task2 = Effect.succeed(\"hello\").pipe(\n  Effect.delay(\"100 millis\"),\n  Effect.tap(Effect.log(\"task2 done\"))\n)\n\n// Combine the two effects together\n//\n//      ┌─── Effect<[number, string], never, never>\n//      ▼\nconst program = Effect.zip(task1, task2)\n\nEffect.runPromise(program).then(console.log)\n// Output:\n// timestamp=... level=INFO fiber=#0 message=\"task1 done\"\n// timestamp=... level=INFO fiber=#0 message=\"task2 done\"\n// [ 1, 'hello' ]\n```\n\n----------------------------------------\n\nTITLE: Taking Elements from a Stream with Effect\nDESCRIPTION: This snippet demonstrates how to use `Stream.take` to take the first 5 elements from an infinite stream generated by `Stream.iterate`. The resulting stream is then consumed using `Stream.runCollect` and the result is printed to the console. The Effect runtime is needed to run this code.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-take.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Effect, Stream } from \"effect\"\n\nconst stream = Stream.take(Stream.iterate(0, (n) => n + 1), 5)\n\nEffect.runPromise(Stream.runCollect(stream)).then(console.log)\n// { _id: 'Chunk', values: [ 0, 1, 2, 3, 4 ] }\n```\n\n----------------------------------------\n\nTITLE: Returning Minimum Between Two Numbers in Effect-TS\nDESCRIPTION: This snippet demonstrates how to import and use the `min` function from the `effect/Number` module. The function takes two numbers as input and returns the smaller of the two. The provided example asserts that the output of `min(2, 3)` equals `2`, validating the functionality of the method.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Number-min.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { min } from \"effect/Number\"\n\nassert.deepStrictEqual(min(2, 3), 2)\n```\n\n----------------------------------------\n\nTITLE: Creating Scoped Trace Spans with Effect.makeSpanScoped in TypeScript\nDESCRIPTION: Function signature for creating a new span for tracing that automatically closes when the Scope finalizes. The span is not added to the current span stack, so no child spans will be created for it.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-makeSpanScoped.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const makeSpanScoped: (name: string, options?: Tracer.SpanOptions | undefined) => Effect<Tracer.Span, never, Scope.Scope>\n```\n\n----------------------------------------\n\nTITLE: Creating Effect Stream from ReadableStream in TypeScript\nDESCRIPTION: A function that transforms a ReadableStream into an Effect Stream, allowing lazy stream creation, error handling, and optional lock release. Supports two overloaded signatures for flexible usage.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-fromReadableStream.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const fromReadableStream: { <A, E>(options: { readonly evaluate: LazyArg<ReadableStream<A>>; readonly onError: (error: unknown) => E; readonly releaseLockOnEnd?: boolean | undefined; }): Stream<A, E>; <A, E>(evaluate: LazyArg<ReadableStream<A>>, onError: (error: unknown) => E): Stream<A, E>; }\n```\n\n----------------------------------------\n\nTITLE: Using withEarlyRelease to manage resource cleanup in Effect\nDESCRIPTION: This example demonstrates how to use withEarlyRelease to obtain both a resource and its finalizer. The function allows manual control over resource cleanup while accessing the resource value. The example acquires a resource, uses it, waits for a second, and then manually triggers the finalizer.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-withEarlyRelease.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Console, Effect } from \"effect\"\n\nconst acquire = Console.log(\"Acquiring resource\").pipe(\n  Effect.as(1),\n  Effect.tap(Effect.addFinalizer(() => Console.log(\"Releasing resource\")))\n)\nconst program = Effect.gen(function*() {\n  const [finalizer, resource] = yield* Effect.withEarlyRelease(acquire)\n  console.log(`Using resource: ${resource}`)\n  yield* Effect.sleep(\"1 second\")\n  yield* finalizer\n})\n\nEffect.runFork(program.pipe(Effect.scoped))\n// Output:\n// Acquiring resource\n// Using resource: 1\n// Releasing resource\n```\n\n----------------------------------------\n\nTITLE: Effect.raceWith Function Signature in TypeScript\nDESCRIPTION: The type signature for the Effect.raceWith function, showing the complex generic typing that supports various combinations of effects and handlers. This function is available since version 2.0.0 of the effect library.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-raceWith.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const raceWith: { <A1, E1, R1, E, A, A2, E2, R2, A3, E3, R3>(other: Effect<A1, E1, R1>, options: { readonly onSelfDone: (exit: Exit.Exit<A, E>, fiber: Fiber.Fiber<A1, E1>) => Effect<A2, E2, R2>; readonly onOtherDone: (exit: Exit.Exit<A1, E1>, fiber: Fiber.Fiber<A, E>) => Effect<A3, E3, R3>; }): <R>(self: Effect<A, E, R>) => Effect<A2 | A3, E2 | E3, R1 | R2 | R3 | R>; <A, E, R, A1, E1, R1, A2, E2, R2, A3, E3, R3>(self: Effect<A, E, R>, other: Effect<A1, E1, R1>, options: { readonly onSelfDone: (exit: Exit.Exit<A, E>, fiber: Fiber.Fiber<A1, E1>) => Effect<A2, E2, R2>; readonly onOtherDone: (exit: Exit.Exit<A1, E1>, fiber: Fiber.Fiber<A, E>) => Effect<A3, E3, R3>; }): Effect<A2 | A3, E2 | E3, R | R1 | R2 | R3>; }\n```\n\n----------------------------------------\n\nTITLE: Constructing Random Service with Seeded Generator in TypeScript\nDESCRIPTION: This snippet demonstrates how to use Random.make to create two Random services with the same seed, resulting in identical random number sequences. It's useful for generating predictable random data for testing or date-based randomization.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Random-make.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { Effect, Random } from \"effect\"\n\nconst random1 = Random.make(\"myseed\")\nconst random2 = Random.make(\"myseed\")\n\nassert.equal(Effect.runSync(random1.next), Effect.runSync(random2.next))\n```\n\n----------------------------------------\n\nTITLE: Modifying Metrics with Metric.modify in TypeScript\nDESCRIPTION: The Metric.modify function allows modification of a metric with a specified update message. It can be used for operations like incrementing a gauge metric by a provided amount. The function is overloaded to accept inputs in different orders.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Metric-modify.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const modify: {\n  <In>(input: In): <Type, Out>(self: Metric<Type, In, Out>) => Effect.Effect<void>;\n  <Type, In, Out>(self: Metric<Type, In, Out>, input: In): Effect.Effect<void>;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Credit-Based Rate Limiting with RateLimiter.withCost in TypeScript\nDESCRIPTION: This example demonstrates how to use RateLimiter.withCost to create a credit-based rate limiter. It shows setting up rate limiters for query and mutation operations with different costs, as well as applying a custom cost on-the-fly.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/RateLimiter-withCost.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Effect, RateLimiter } from \"effect\";\nimport { compose } from \"effect/Function\";\n\nconst program = Effect.scoped(\n  Effect.gen(function* ($) {\n    // Create a rate limiter that has an hourly limit of 1000 credits\n    const rateLimiter = yield* $(RateLimiter.make({ limit: 1000, interval: \"1 hours\" }));\n    // Query API costs 1 credit per call ( 1 is the default cost )\n    const queryAPIRL = compose(rateLimiter, RateLimiter.withCost(1));\n    // Mutation API costs 5 credits per call\n    const mutationAPIRL = compose(rateLimiter, RateLimiter.withCost(5));\n\n    // Use the pre-defined rate limiters\n    yield* $(queryAPIRL(Effect.log(\"Sample Query\")));\n    yield* $(mutationAPIRL(Effect.log(\"Sample Mutation\")));\n\n    // Or set a cost on-the-fly\n    yield* $(\n      rateLimiter(Effect.log(\"Another query with a different cost\")).pipe(\n        RateLimiter.withCost(3)\n      )\n    );\n  })\n);\n```\n\n----------------------------------------\n\nTITLE: Racing Multiple Successful Effects in TypeScript\nDESCRIPTION: Example demonstrating racing three successful effects with different delays. Shows how the fastest effect completes while others are interrupted.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-raceAll.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Effect, Console } from \"effect\"\n\nconst task1 = Effect.succeed(\"task1\").pipe(\n  Effect.delay(\"100 millis\"),\n  Effect.tap(Console.log(\"task1 done\")),\n  Effect.onInterrupt(() => Console.log(\"task1 interrupted\"))\n)\nconst task2 = Effect.succeed(\"task2\").pipe(\n  Effect.delay(\"200 millis\"),\n  Effect.tap(Console.log(\"task2 done\")),\n  Effect.onInterrupt(() => Console.log(\"task2 interrupted\"))\n)\n\nconst task3 = Effect.succeed(\"task3\").pipe(\n  Effect.delay(\"150 millis\"),\n  Effect.tap(Console.log(\"task3 done\")),\n  Effect.onInterrupt(() => Console.log(\"task3 interrupted\"))\n)\n\nconst program = Effect.raceAll([task1, task2, task3])\n\nEffect.runFork(program)\n```\n\n----------------------------------------\n\nTITLE: Defining Stream.orElse Function in TypeScript\nDESCRIPTION: Declares the orElse function for Stream, which switches to an alternative stream if the current one fails with a typed error. It's similar to Stream.catchAll but specifically for handling typed errors.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-orElse.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const orElse: { <A2, E2, R2>(that: LazyArg<Stream<A2, E2, R2>>): <A, E, R>(self: Stream<A, E, R>) => Stream<A2 | A, E2, R2 | R>; <A, E, R, A2, E2, R2>(self: Stream<A, E, R>, that: LazyArg<Stream<A2, E2, R2>>): Stream<A | A2, E2, R | R2>; }\n```\n\n----------------------------------------\n\nTITLE: TArray someSTM Declaration (TypeScript)\nDESCRIPTION: The `someSTM` function determines if a `TArray` contains at least one element that satisfies the provided transactional predicate. It returns an `STM` computation that yields a boolean value indicating whether any element satisfies the predicate. The function supports curried and uncurried invocations.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TArray-someSTM.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const someSTM: { <A, R, E>(predicate: (value: A) => STM.STM<boolean, E, R>): (self: TArray<A>) => STM.STM<boolean, E, R>; <A, R, E>(self: TArray<A>, predicate: (value: A) => STM.STM<boolean, E, R>): STM.STM<boolean, E, R>; }\n```\n\n----------------------------------------\n\nTITLE: Implementing Stream Zipping with Latest Values in TypeScript\nDESCRIPTION: Example demonstrating how to use Stream.zipLatestAll to combine multiple streams using their latest values. The example shows three streams with different scheduling intervals being zipped together.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-zipLatestAll.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Stream, Schedule, Console, Effect } from \"effect\"\n\nconst stream = Stream.zipLatestAll(\n    Stream.fromSchedule(Schedule.spaced('1 millis')),\n    Stream.fromSchedule(Schedule.spaced('2 millis')),\n    Stream.fromSchedule(Schedule.spaced('4 millis')),\n).pipe(Stream.take(6), Stream.tap(Console.log))\n\nEffect.runPromise(Stream.runDrain(stream))\n// Output:\n// [ 0, 0, 0 ]\n// [ 1, 0, 0 ]\n// [ 1, 1, 0 ]\n// [ 2, 1, 0 ]\n// [ 3, 1, 0 ]\n// [ 3, 1, 1 ]\n// .....\n```\n\n----------------------------------------\n\nTITLE: Using Array.findFirst in Effect.ts\nDESCRIPTION: Demonstrates how to use the Array.findFirst function to locate the first element in an array that satisfies a given predicate. This function returns an Option type, containing the found element or None if no matching element exists.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Array-findFirst.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Array } from \"effect\"\n\nconst result = Array.findFirst([1, 2, 3, 4, 5], x => x > 3)\nconsole.log(result) // Option.some(4)\n```\n\n----------------------------------------\n\nTITLE: Racing Two Effects with Effect.raceFirst in TypeScript\nDESCRIPTION: Demonstrates using Effect.raceFirst to race two effects, where both tasks succeed. The first task to complete (task1) is returned, and the losing task (task2) is interrupted.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-raceFirst.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Effect, Console } from \"effect\"\n\nconst task1 = Effect.succeed(\"task1\").pipe(\n  Effect.delay(\"100 millis\"),\n  Effect.tap(Console.log(\"task1 done\")),\n  Effect.onInterrupt(() =>\n    Console.log(\"task1 interrupted\").pipe(Effect.delay(\"100 millis\"))\n  )\n)\nconst task2 = Effect.succeed(\"task2\").pipe(\n  Effect.delay(\"200 millis\"),\n  Effect.tap(Console.log(\"task2 done\")),\n  Effect.onInterrupt(() =>\n    Console.log(\"task2 interrupted\").pipe(Effect.delay(\"100 millis\"))\n  )\n)\n\nconst program = Effect.raceFirst(task1, task2).pipe(\n  Effect.tap(Console.log(\"more work...\"))\n)\n\nEffect.runPromiseExit(program).then(console.log)\n// Output:\n// task1 done\n// task2 interrupted\n// more work...\n// { _id: 'Exit', _tag: 'Success', value: 'task1' }\n```\n\n----------------------------------------\n\nTITLE: Running an Effect and Returning a Promise with Exit State in TypeScript\nDESCRIPTION: The runPromiseExit function executes an Effect and returns a JavaScript Promise that resolves with the Exit state of the effect. It can be called with either a runtime and an effect or just a runtime that returns a function accepting an effect. It supports an optional AbortSignal parameter for cancellation.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Runtime-runPromiseExit.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const runPromiseExit: { <R>(runtime: Runtime<R>): <A, E>(effect: Effect.Effect<A, E, R>, options?: { readonly signal?: AbortSignal; } | undefined) => Promise<Exit.Exit<A, E>>; <R, A, E>(runtime: Runtime<R>, effect: Effect.Effect<A, E, R>, options?: { readonly signal?: AbortSignal; } | undefined): Promise<Exit.Exit<A, E>>; }\n```\n\n----------------------------------------\n\nTITLE: Effect.replicateEffect Function Signature in TypeScript\nDESCRIPTION: The type signature for the replicateEffect function showing its polymorphic implementation. This signature shows the function's ability to handle different options including concurrency, batching, result discarding, and concurrent finalizers.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-replicateEffect.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const replicateEffect: { (n: number, options?: { readonly concurrency?: Concurrency | undefined; readonly batching?: boolean | \"inherit\" | undefined; readonly discard?: false | undefined; readonly concurrentFinalizers?: boolean | undefined; }): <A, E, R>(self: Effect<A, E, R>) => Effect<Array<A>, E, R>; (n: number, options: { readonly concurrency?: Concurrency | undefined; readonly batching?: boolean | \"inherit\" | undefined; readonly discard: true; readonly concurrentFinalizers?: boolean | undefined; }): <A, E, R>(self: Effect<A, E, R>) => Effect<void, E, R>; <A, E, R>(self: Effect<A, E, R>, n: number, options?: { readonly concurrency?: Concurrency | undefined; readonly batching?: boolean | \"inherit\" | undefined; readonly discard?: false | undefined; readonly concurrentFinalizers?: boolean | undefined; }): Effect<Array<A>, E, R>; <A, E, R>(self: Effect<A, E, R>, n: number, options: { readonly concurrency?: Concurrency | undefined; readonly batching?: boolean | \"inherit\" | undefined; readonly discard: true; readonly concurrentFinalizers?: boolean | undefined; }): Effect<void, E, R>; }\n```\n\n----------------------------------------\n\nTITLE: Implementing Atomic Folding with TMap.reduceSTM in TypeScript\nDESCRIPTION: The reduceSTM function atomically applies a transactional function to each key-value pair in a TMap, accumulating results. It accepts an initial value, a folding function, and the TMap to operate on. The function has two overloaded signatures for flexibility in usage.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TMap-reduceSTM.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const reduceSTM: { <Z, V, K, R, E>(zero: Z, f: (acc: Z, value: V, key: K) => STM.STM<Z, E, R>): (self: TMap<K, V>) => STM.STM<Z, E, R>; <Z, V, K, R, E>(self: TMap<K, V>, zero: Z, f: (acc: Z, value: V, key: K) => STM.STM<Z, E, R>): STM.STM<Z, E, R>; }\n```\n\n----------------------------------------\n\nTITLE: Declaring Monoid.tuple Function in TypeScript\nDESCRIPTION: This code snippet shows the type signature for the Monoid.tuple function. It takes variable number of Monoid instances and returns a new Monoid that operates on tuples containing the value types of the input Monoids. The function enables combining tuples element-wise using the corresponding Monoid operations.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Monoid-tuple.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const tuple: <T extends ReadonlyArray<Monoid<any>>>(...elements: T) => Monoid<{ readonly [I in keyof T]: [T[I]] extends [Monoid<infer A>] ? A : never; }>\n```\n\n----------------------------------------\n\nTITLE: Using Effect.zipRight to Execute Sequential Effects in TypeScript\nDESCRIPTION: This example demonstrates how to use Effect.zipRight to execute two effects sequentially, with the first effect running for its side effects while only returning the result of the second effect. The example shows two tasks with different delays and logging, combined using zipRight.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-zipRight.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Effect } from \"effect\"\n\nconst task1 = Effect.succeed(1).pipe(\n  Effect.delay(\"200 millis\"),\n  Effect.tap(Effect.log(\"task1 done\"))\n)\nconst task2 = Effect.succeed(\"hello\").pipe(\n  Effect.delay(\"100 millis\"),\n  Effect.tap(Effect.log(\"task2 done\"))\n)\n\nconst program = Effect.zipRight(task1, task2)\n\nEffect.runPromise(program).then(console.log)\n// Output:\n// timestamp=... level=INFO fiber=#0 message=\"task1 done\"\n// timestamp=... level=INFO fiber=#0 message=\"task2 done\"\n// hello\n```\n\n----------------------------------------\n\nTITLE: Creating a Resource Pool in Effect TypeScript\nDESCRIPTION: Creates a new pool of fixed size with configurable acquire strategy, concurrency, and target utilization. The pool is managed within a scope and allows controlled resource allocation and release.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Pool-make.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const make: <A, E, R>(options: { readonly acquire: Effect.Effect<A, E, R>; readonly size: number; readonly concurrency?: number | undefined; readonly targetUtilization?: number | undefined; }) => Effect.Effect<Pool<A, E>, never, Scope.Scope | R>\n```\n\n----------------------------------------\n\nTITLE: Retrying a Task up to 5 Times in TypeScript\nDESCRIPTION: Shows how to use Effect.retry with a maximum retry count. The example retries a failing task up to 5 times before succeeding.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-retry.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Effect } from \"effect\"\n\nlet count = 0\n\n// Simulates an effect with possible failures\nconst task = Effect.async<string, Error>((resume) => {\n  if (count <= 2) {\n    count++\n    console.log(\"failure\")\n    resume(Effect.fail(new Error()))\n  } else {\n    console.log(\"success\")\n    resume(Effect.succeed(\"yay!\"))\n  }\n})\n\n// Retry the task up to 5 times\nEffect.runPromise(Effect.retry(task, { times: 5 })).then(console.log)\n// Output:\n// failure\n// failure\n// failure\n// success\n```\n\n----------------------------------------\n\nTITLE: Creating FiberHandle-backed Runtime Function in TypeScript\nDESCRIPTION: Creates an Effect run function that is backed by a FiberHandle. This function allows running effects and returns a RuntimeFiber. It accepts optional configuration via RunForkOptions including an onlyIfMissing flag.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/FiberHandle-makeRuntime.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const makeRuntime: <R, E = unknown, A = unknown>() => Effect.Effect<(<XE extends E, XA extends A>(effect: Effect.Effect<XA, XE, R>, options?: (Runtime.RunForkOptions & { readonly onlyIfMissing?: boolean | undefined; }) | undefined) => Fiber.RuntimeFiber<XA, XE>), never, Scope.Scope | R>\n```\n\n----------------------------------------\n\nTITLE: Array Comprehension Using Effect-TS Array.bind\nDESCRIPTION: Example showing how to use Array.bind for array comprehension, demonstrating filtering and mapping operations on multiple arrays. The code creates combinations of elements from two arrays, filters them based on a condition, and transforms the results.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Array-bind.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Array, pipe } from \"effect\"\n\nconst doResult = pipe(\n  Array.Do,\n  Array.bind(\"x\", () => [1, 3, 5]),\n  Array.bind(\"y\", () => [2, 4, 6]),\n  Array.filter(({ x, y }) => x < y), // condition\n  Array.map(({ x, y }) => [x, y] as const) // transformation\n)\nconsole.log(doResult) // [[1, 2], [1, 4], [1, 6], [3, 4], [3, 6], [5, 6]]\n\n// equivalent\nconst x = [1, 3, 5],\n      y = [2, 4, 6],\n      result = [];\nfor(let i = 0; i < x.length; i++) {\n  for(let j = 0; j < y.length; j++) {\n    const _x = x[i], _y = y[j];\n    if(_x < _y) result.push([_x, _y] as const)\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Transforming Stream Elements with Stream.map in TypeScript\nDESCRIPTION: This example demonstrates how to use Stream.map to transform each element of a stream by adding 1 to each number. The result is then collected and logged.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-map.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Effect, Stream } from \"effect\"\n\nconst stream = Stream.make(1, 2, 3).pipe(Stream.map((n) => n + 1))\n\nEffect.runPromise(Stream.runCollect(stream)).then(console.log)\n// { _id: 'Chunk', values: [ 2, 3, 4 ] }\n```\n\n----------------------------------------\n\nTITLE: TypeScript Signature of Effect.liftPredicate\nDESCRIPTION: Shows the function signature for liftPredicate, which supports different overloads for working with both refinements and predicates, and provides type safety for the input value, predicate, and error handling function.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-liftPredicate.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const liftPredicate: { <A, B extends A, E>(refinement: Refinement<NoInfer<A>, B>, orFailWith: (a: NoInfer<A>) => E): (a: A) => Effect<B, E>; <A, E>(predicate: Predicate<NoInfer<A>>, orFailWith: (a: NoInfer<A>) => E): (a: A) => Effect<A, E>; <A, E, B extends A>(self: A, refinement: Refinement<A, B>, orFailWith: (a: A) => E): Effect<B, E>; <A, E>(self: A, predicate: Predicate<NoInfer<A>>, orFailWith: (a: NoInfer<A>) => E): Effect<A, E>; }\n```\n\n----------------------------------------\n\nTITLE: Using Micro.tryPromise to Convert Promises to Micro Effects in TypeScript\nDESCRIPTION: This example demonstrates how to use the Micro.tryPromise function to wrap a Promise into a Micro effect. It handles both the successful resolution of the Promise and provides error handling through a catch function that converts any errors into a specific error type.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Micro-tryPromise.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Micro } from \"effect\"\n\nMicro.tryPromise({\n  try: () => Promise.resolve(\"success\"),\n  catch: (cause) => new Error(\"caught\", { cause })\n})\n```\n\n----------------------------------------\n\nTITLE: Defining Scoped Resource Management Function in Effect Module (TypeScript)\nDESCRIPTION: The scoped function ensures that all resources used within an effect are tied to its lifetime. Finalizers for these resources are executed automatically when the effect completes, whether through success, failure, or interruption, guaranteeing proper resource cleanup without requiring explicit management.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-scoped.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const scoped: <A, E, R>(effect: Effect<A, E, R>) => Effect<A, E, Exclude<R, Scope.Scope>>\n```\n\n----------------------------------------\n\nTITLE: Defining Terminal Interface in TypeScript\nDESCRIPTION: This code snippet defines the Terminal interface with methods for interacting with a command-line interface. It includes operations for reading input, displaying output, and getting terminal dimensions.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Terminal-Terminal.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface Terminal {\n  /**\n   * The number of columns available on the platform's terminal interface.\n   */\n  readonly columns: Effect<number>\n  /**\n   * Reads a single input event from the default standard input.\n   */\n  readonly readInput: Effect<UserInput, QuitException>\n  /**\n   * Reads a single line from the default standard input.\n   */\n  readonly readLine: Effect<string, QuitException>\n  /**\n   * Displays text to the the default standard output.\n   */\n  readonly display: (text: string) => Effect<void, PlatformError>\n}\n```\n\n----------------------------------------\n\nTITLE: Extending Schemas with Effect TS in TypeScript\nDESCRIPTION: This TypeScript snippet demonstrates how to extend a base schema with additional fields using the Schema.extend method from the Effect TS library. It shows how to add more fields or index signatures to an existing schema structure. The snippet requires the Effect TS library as a dependency.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Schema-extend.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as Schema from \"effect/Schema\"\n\nconst schema = Schema.Struct({\n  a: Schema.String,\n  b: Schema.String\n})\n\n// const extended: Schema<\n//   {\n//     readonly a: string\n//     readonly b: string\n//   } & {\n//     readonly c: string\n//   } & {\n//     readonly [x: string]: string\n//   }\n// >\nconst extended = Schema.asSchema(schema.pipe(\n  Schema.extend(Schema.Struct({ c: Schema.String })), // <= you can add more fields\n  Schema.extend(Schema.Record({ key: Schema.String, value: Schema.String })) // <= you can add index signatures\n))\n```\n\n----------------------------------------\n\nTITLE: Launching Metric Polling with Schedule in TypeScript\nDESCRIPTION: Function signature for launching a metric polling operation in a background fiber using a specified schedule. The function is overloaded to accept parameters in different orders and returns an Effect containing a Fiber.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/MetricPolling-launch.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const launch: { \n  <A2, R2>(schedule: Schedule.Schedule<A2, unknown, R2>): \n    <Type, In, R, E, Out>(self: MetricPolling<Type, In, R, E, Out>) => \n      Effect.Effect<Fiber.Fiber<A2, E>, never, R2 | R | Scope.Scope>; \n  <Type, In, R, E, Out, A2, R2>(\n    self: MetricPolling<Type, In, R, E, Out>, \n    schedule: Schedule.Schedule<A2, unknown, R2>\n  ): Effect.Effect<Fiber.Fiber<A2, E>, never, Scope.Scope | R | R2>; \n}\n```\n\n----------------------------------------\n\nTITLE: Using Either.getOrThrow to Extract Values in TypeScript\nDESCRIPTION: Demonstrates how to use the getOrThrow function to extract the value from an Either type. If the Either is Right, it returns the contained value. If the Either is Left, it throws an error.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Either-getOrThrow.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { Either } from \"effect\"\n\nassert.deepStrictEqual(Either.getOrThrow(Either.right(1)), 1)\nassert.throws(() => Either.getOrThrow(Either.left(\"error\")))\n```\n\n----------------------------------------\n\nTITLE: Implementing Structured Logging in Effect\nDESCRIPTION: Demonstrates how to use the structured logger to create detailed, traceable log outputs with annotations and spans. The logger outputs messages with metadata including timestamps, log levels, causes, annotations, spans, and fiber IDs.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Logger-structured.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Effect, Logger } from \"effect\"\n\nconst program = Effect.log(\"message1\", \"message2\").pipe(\n  Effect.annotateLogs({ key1: \"value1\", key2: \"value2\" }),\n  Effect.withLogSpan(\"myspan\")\n)\n\nEffect.runFork(program.pipe(Effect.provide(Logger.structured)))\n// {\n//   message: [ 'message1', 'message2' ],\n//   logLevel: 'INFO',\n//   timestamp: '2024-07-09T14:05:41.623Z',\n//   cause: undefined,\n//   annotations: { key2: 'value2', key1: 'value1' },\n//   spans: { myspan: 0 },\n//   fiberId: '#0'\n// }\n```\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const structured: Layer.Layer<never, never, never>\n```\n\n----------------------------------------\n\nTITLE: Applying Effects to Iterable Elements with Discarded Results\nDESCRIPTION: Example demonstrating how to apply effects to each element in an array while discarding the results. The discard option is set to true, causing the function to return void instead of an array of results.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-forEach.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Effect, Console } from \"effect\"\n\n// Apply effects but discard the results\nconst result = Effect.forEach(\n  [1, 2, 3, 4, 5],\n  (n, index) =>\n    Console.log(`Currently at index ${index}`).pipe(Effect.as(n * 2)),\n  { discard: true }\n)\n\nEffect.runPromise(result).then(console.log)\n// Output:\n// Currently at index 0\n// Currently at index 1\n// Currently at index 2\n// Currently at index 3\n// Currently at index 4\n// undefined\n```\n\n----------------------------------------\n\nTITLE: Creating a Successful Effect with Effect.succeed in TypeScript\nDESCRIPTION: Creates an Effect that always succeeds with a given value. This is used when you need an effect that completes successfully with a specific value without any errors or external dependencies.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-succeed.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Effect } from \"effect\"\n\n// Creating an effect that represents a successful scenario\n//\n//      ┌─── Effect<number, never, never>\n//      ▼\nconst success = Effect.succeed(42)\n```\n\n----------------------------------------\n\nTITLE: Using isTupleOfAtLeast Function in TypeScript\nDESCRIPTION: This snippet demonstrates how to use the isTupleOfAtLeast function to check if an array has at least a specified number of elements. It includes examples of true and false cases, as well as type narrowing.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Predicate-isTupleOfAtLeast.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { isTupleOfAtLeast } from \"effect/Predicate\"\n\nassert.deepStrictEqual(isTupleOfAtLeast([1, 2, 3], 3), true);\nassert.deepStrictEqual(isTupleOfAtLeast([1, 2, 3], 2), true);\nassert.deepStrictEqual(isTupleOfAtLeast([1, 2, 3], 4), false);\n\nconst arr: number[] = [1, 2, 3, 4];\nif (isTupleOfAtLeast(arr, 3)) {\n  console.log(arr);\n  // ^? [number, number, number, ...number[]]\n}\n```\n\n----------------------------------------\n\nTITLE: Updating HashMap Values with modify Function in TypeScript\nDESCRIPTION: The `modify` function updates the value associated with a specified key in a HashMap if the key exists. It accepts a key, a transformation function, and the HashMap, returning a new HashMap with the updated value.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/HashMap-modify.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const modify: { <K, V>(key: K, f: (v: V) => V): (self: HashMap<K, V>) => HashMap<K, V>; <K, V>(self: HashMap<K, V>, key: K, f: (v: V) => V): HashMap<K, V>; }\n```\n\n----------------------------------------\n\nTITLE: Creating HTTP Protocol Layer for RPC Server in TypeScript\nDESCRIPTION: Creates a Layer for RPC server that uses streaming HTTP for communication. The function accepts configuration options including a path for the HTTP endpoint and an optional router tag for customization.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/RpcServer-layerProtocolHttp.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const layerProtocolHttp: <I = HttpRouter.Default>(options: { readonly path: HttpRouter.PathInput; readonly routerTag?: HttpRouter.HttpRouter.TagClass<I, string, any, any>; }) => Layer.Layer<Protocol, never, RpcSerialization.RpcSerialization>\n```\n\n----------------------------------------\n\nTITLE: Implementing scanRight Function for Arrays in TypeScript\nDESCRIPTION: The scanRight function accumulates values from an Iterable starting from the right, storing each intermediate result in an array. It's useful for tracking the progression of a value through a series of transformations.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Array-scanRight.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Array } from \"effect\";\n\nconst result = Array.scanRight([1, 2, 3, 4], 0, (acc, value) => acc + value)\nconsole.log(result) // [10, 9, 7, 4, 0]\n```\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const scanRight: { <B, A>(b: B, f: (b: B, a: A) => B): (self: Iterable<A>) => NonEmptyArray<B>; <A, B>(self: Iterable<A>, b: B, f: (b: B, a: A) => B): NonEmptyArray<B>; }\n```\n\n----------------------------------------\n\nTITLE: Delaying Effect Execution Example in TypeScript\nDESCRIPTION: Demonstrates how to use the Effect.delay function to postpone the execution of a console log effect by 2 seconds. The program logs \"start\" immediately and then waits 2 seconds before executing the delayed task.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-delay.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Console, Effect } from \"effect\"\n\nconst task = Console.log(\"Task executed\")\n\nconst program = Console.log(\"start\").pipe(\n  Effect.andThen(\n    // Delays the log message by 2 seconds\n    task.pipe(Effect.delay(\"2 seconds\"))\n  )\n)\n\nEffect.runFork(program)\n// Output:\n// start\n// Task executed\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Layout.smart Algorithm in TypeScript\nDESCRIPTION: This code snippet demonstrates the difference between Layout.pretty and Layout.smart algorithms for document layout. It creates a complex nested document and renders it using both algorithms, showing how Layout.smart provides better line breaking that fits within specified page width constraints.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Layout-smart.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport * as Doc from \"@effect/printer/Doc\"\nimport type * as DocStream from \"@effect/printer/DocStream\"\nimport * as Layout from \"@effect/printer/Layout\"\nimport * as PageWidth from \"@effect/printer/PageWidth\"\nimport { pipe } from \"effect/Function\"\nimport * as String from \"effect/String\"\n\n// Consider the following python-ish document:\nconst fun = <A>(doc: Doc.Doc<A>): Doc.Doc<A> =>\n  Doc.hcat([\n    pipe(\n      Doc.hcat([Doc.text(\"fun(\"), Doc.softLineBreak, doc]),\n      Doc.hang(2)\n    ),\n    Doc.text(\")\")\n  ])\n\nconst funs = <A>(doc: Doc.Doc<A>): Doc.Doc<A> =>\n  pipe(doc, fun, fun, fun, fun, fun)\n\nconst doc = funs(Doc.align(Doc.list(Doc.words(\"abcdef ghijklm\"))))\n\n// The document will be rendered using the following pipeline, where the choice\n// of layout algorithm has been left open:\nconst pageWidth = PageWidth.availablePerLine(26, 1)\nconst layoutOptions = Layout.options(pageWidth)\nconst dashes = Doc.text(Array.from({ length: 26 - 2 }, () => \"-\").join(\"\"))\nconst hr = Doc.hcat([Doc.vbar, dashes, Doc.vbar])\n\nconst render = <A>(\n  doc: Doc.Doc<A>\n) =>\n  (\n    layoutAlgorithm: (options: Layout.Layout.Options) => (doc: Doc.Doc<A>) => DocStream.DocStream<A>\n  ): string => pipe(Doc.vsep([hr, doc, hr]), layoutAlgorithm(layoutOptions), Doc.renderStream)\n\n// If rendered using `Layout.pretty`, with a page width of `26` characters per line,\n// all the calls to `fun` will fit into the first line. However, this exceeds the\n// desired `26` character page width.\nassert.strictEqual(\n  render(doc)(Layout.pretty),\n  String.stripMargin(\n    `||------------------------|\\n     |fun(fun(fun(fun(fun(\\n     |                  [ abcdef\\n     |                  , ghijklm ])))))\\n     ||------------------------|`\n  )\n)\n\n// The same document, rendered with `Layout.smart`, fits the layout contstraints:\nassert.strictEqual(\n  render(doc)(Layout.smart),\n  String.stripMargin(\n    `||------------------------|\\n     |fun(\\n     |  fun(\\n     |    fun(\\n     |      fun(\\n     |        fun(\\n     |          [ abcdef\\n     |          , ghijklm ])))))\\n     ||------------------------|`\n  )\n)\n```\n\n----------------------------------------\n\nTITLE: Stream catchAllCause Function Definition\nDESCRIPTION: This TypeScript code snippet defines the `catchAllCause` function, which allows a stream to switch to another stream if the original stream fails. It handles all causes of failure, including interruption, by providing a function that maps a `Cause` (representing the error) to a new `Stream`.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-catchAllCause.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const catchAllCause: { <E, A2, E2, R2>(f: (cause: Cause.Cause<E>) => Stream<A2, E2, R2>): <A, R>(self: Stream<A, E, R>) => Stream<A2 | A, E2, R2 | R>; <A, E, R, A2, E2, R2>(self: Stream<A, E, R>, f: (cause: Cause.Cause<E>) => Stream<A2, E2, R2>): Stream<A | A2, E2, R | R2>; }\n```\n\n----------------------------------------\n\nTITLE: Using Stream.zipLatest with Scheduled Streams in TypeScript\nDESCRIPTION: Demonstrates how to use Stream.zipLatest to combine two streams with different emission schedules. The example shows combining numeric and string streams where elements are emitted at 1-second and 500-millisecond intervals respectively.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-zipLatest.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Effect, Schedule, Stream } from \"effect\"\n\nconst s1 = Stream.make(1, 2, 3).pipe(\n  Stream.schedule(Schedule.spaced(\"1 second\"))\n)\n\nconst s2 = Stream.make(\"a\", \"b\", \"c\", \"d\").pipe(\n  Stream.schedule(Schedule.spaced(\"500 millis\"))\n)\n\nconst stream = Stream.zipLatest(s1, s2)\n\nEffect.runPromise(Stream.runCollect(stream)).then(console.log)\n// { _id: \"Chunk\", values: [ [ 1, \"a\" ], [ 1, \"b\" ], [ 2, \"b\" ], [ 2, \"c\" ], [ 2, \"d\" ], [ 3, \"d\" ] ] }\n```\n\n----------------------------------------\n\nTITLE: Handling Specific Defects with Effect.catchSomeDefect in TypeScript\nDESCRIPTION: This example demonstrates how to use Effect.catchSomeDefect to handle specific defects in an Effect-based program. It simulates a runtime error and attempts to catch an IllegalArgumentException, showing how the function behaves when the defect doesn't match the specified condition.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-catchSomeDefect.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Effect, Cause, Option, Console } from \"effect\"\n\n// Simulating a runtime error\nconst task = Effect.dieMessage(\"Boom!\")\n\nconst program = Effect.catchSomeDefect(task, (defect) => {\n  if (Cause.isIllegalArgumentException(defect)) {\n    return Option.some(\n      Console.log(\n        `Caught an IllegalArgumentException defect: ${defect.message}`\n      )\n    )\n  }\n  return Option.none()\n})\n\n// Since we are only catching IllegalArgumentException\n// we will get an Exit.Failure because we simulated a runtime error.\nEffect.runPromiseExit(program).then(console.log)\n// Output:\n// {\n//   _id: 'Exit',\n//   _tag: 'Failure',\n//   cause: {\n//     _id: 'Cause',\n//     _tag: 'Die',\n//     defect: { _tag: 'RuntimeException' }\n//   }\n// }\n```\n\n----------------------------------------\n\nTITLE: Creating a Push-Based Stream with Interval in TypeScript using Effect-TS\nDESCRIPTION: This example demonstrates how to create a push-based stream using the asyncPush method. It sets up a timer that emits 'tick' every second, handles proper resource cleanup with Effect.acquireRelease, and configures a custom buffer size with dropping strategy.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-asyncPush.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Effect, Stream } from \"effect\"\n\nStream.asyncPush<string>((emit) =>\n  Effect.acquireRelease(\n    Effect.gen(function*() {\n      yield* Effect.log(\"subscribing\")\n      return setInterval(() => emit.single(\"tick\"), 1000)\n    }),\n    (handle) =>\n      Effect.gen(function*() {\n        yield* Effect.log(\"unsubscribing\")\n        clearInterval(handle)\n      })\n  ), { bufferSize: 16, strategy: \"dropping\" })\n```\n\n----------------------------------------\n\nTITLE: Using Effect.validate to Combine Multiple Effects with Error Accumulation in TypeScript\nDESCRIPTION: This example demonstrates using Effect.validate to combine multiple effects where execution continues even when some effects fail. It shows how task1, task2, task3, and task4 are chained together with all errors accumulated rather than short-circuiting at the first failure.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-validate.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Effect, Console } from \"effect\"\n\nconst task1 = Console.log(\"task1\").pipe(Effect.as(1))\nconst task2 = Effect.fail(\"Oh uh!\").pipe(Effect.as(2))\nconst task3 = Console.log(\"task2\").pipe(Effect.as(3))\nconst task4 = Effect.fail(\"Oh no!\").pipe(Effect.as(4))\n\nconst program = task1.pipe(\n  Effect.validate(task2),\n  Effect.validate(task3),\n  Effect.validate(task4)\n)\n\nEffect.runPromiseExit(program).then(console.log)\n// Output:\n// task1\n// task2\n// {\n//   _id: 'Exit',\n//   _tag: 'Failure',\n//   cause: {\n//     _id: 'Cause',\n//     _tag: 'Sequential',\n//     left: { _id: 'Cause', _tag: 'Fail', failure: 'Oh uh!' },\n//     right: { _id: 'Cause', _tag: 'Fail', failure: 'Oh no!' }\n//   }\n// }\n```\n\n----------------------------------------\n\nTITLE: Sorting Array Using Custom Mapping Function in TypeScript\nDESCRIPTION: Demonstrates how to sort an array using a mapping function that transforms elements into comparable values. The example shows sorting strings by their length in ascending order using Order.number.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Array-sortWith.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Array, Order } from \"effect\"\n\nconst result = Array.sortWith([\"aaa\", \"b\", \"cc\"], (s) => s.length, Order.number)\nconsole.log(result) // [\"b\", \"cc\", \"aaa\"]\n\n// Explanation:\n// The array of strings is sorted based on their lengths. The mapping function `(s) => s.length`\n// converts each string into its length, and the `Order.number` specifies that the lengths should\n// be sorted in ascending order.\n```\n\n----------------------------------------\n\nTITLE: Implementing Effect.withSpan Function Signature in TypeScript\nDESCRIPTION: TypeScript function signature for withSpan that provides span wrapping functionality for effects. It accepts either a name and options first followed by the effect, or the effect first followed by name and options. The function creates a new span for tracing purposes.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-withSpan.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const withSpan: {\n  (name: string, options?: Tracer.SpanOptions | undefined): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, Exclude<R, Tracer.ParentSpan>>;\n  <A, E, R>(self: Effect<A, E, R>, name: string, options?: Tracer.SpanOptions | undefined): Effect<A, E, Exclude<R, Tracer.ParentSpan>>;\n}\n```\n\n----------------------------------------\n\nTITLE: Using softLineBreak for conditional line breaks in TypeScript\nDESCRIPTION: This example demonstrates how to use Doc.softLineBreak to conditionally format text. When there's sufficient page width, documents are concatenated directly. When page width is narrow, a line break is automatically inserted between text elements.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Doc-softLineBreak.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport * as Doc from \"@effect/printer/Doc\"\nimport * as String from \"effect/String\"\n\nconst doc: Doc.Doc<never> = Doc.hcat([\n  Doc.text(\"ThisText\"),\n  Doc.softLineBreak,\n  Doc.text(\"IsWayTooLong\")\n])\n\n// With enough space, we get direct concatenation of documents:\nassert.strictEqual(\n  Doc.render(doc, {\n    style: \"pretty\",\n    options: { lineWidth: 80 }\n  }),\n  \"ThisTextIsWayTooLong\"\n)\n\n// If the page width is narrowed to `10`, the layout algorithm will\n// introduce a line break\nassert.strictEqual(\n  Doc.render(Doc.group(doc), {\n    style: \"pretty\",\n    options: { lineWidth: 10 }\n  }),\n  String.stripMargin(\n    `|ThisText\n     |IsWayTooLong`\n  )\n)\n```\n\n----------------------------------------\n\nTITLE: Merging an Array of Effect Instances with Accumulation in TypeScript\nDESCRIPTION: Demonstrates how to use Effect.mergeAll to combine an array of Effect instances that produce numbers, summing their results. The example shows initializing an array of effects, defining an accumulator function, and running the combined effect to obtain the final sum.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-mergeAll.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Effect } from \"effect\"\n\nconst numbers = [Effect.succeed(1), Effect.succeed(2), Effect.succeed(3)]\nconst add = (sum: number, value: number, i: number) => sum + value\nconst zero = 0\n\nconst program = Effect.gen(function*() {\n  const total = yield* Effect.mergeAll(numbers, zero, add)\n  console.log(total)\n})\n\nEffect.runFork(program)\n// Output: 6\n```\n\n----------------------------------------\n\nTITLE: Defining the dropUntilEffect Function in TypeScript\nDESCRIPTION: This function is defined to drop incoming elements from a stream until the provided effectful predicate returns true. It leverages generics to allow for different input types, error types, and result types, making it versatile for different scenarios. The function signature specifies the predicate's expected input and the wrapped Effect type it operates with.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Sink-dropUntilEffect.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const dropUntilEffect: <In, E, R>(predicate: (input: In) => Effect.Effect<boolean, E, R>) => Sink<unknown, In, In, E, R>\n```\n\n----------------------------------------\n\nTITLE: Creating an Unbounded MutableQueue in TypeScript\nDESCRIPTION: The `unbounded` function creates a new unbounded `MutableQueue`. It's a generic function that needs to be parameterized with the type `A` of the elements the queue will hold. This function is available from version 2.0.0 of the Effect library.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/MutableQueue-unbounded.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const unbounded: <A>() => MutableQueue<A>\n```\n\n----------------------------------------\n\nTITLE: Declaring Recurring Schedule in TypeScript\nDESCRIPTION: Defines a schedule that continues execution until a partial function returns some value. The function `recurUntilOption` takes a partial function `pf` as parameter, which determines the continuation or cessation of the schedule. It returns a `Schedule` transforming the final value to an `Option<B>`. Requires knowledge of TypeScript and functional option pattern. Inputs are type `A` and outputs are transformed `Option<B>`. Works with v2.0.0 and above.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Schedule-recurUntilOption.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const recurUntilOption: <A, B>(pf: (a: A) => Option.Option<B>) => Schedule<Option.Option<B>, A>\n```\n\n----------------------------------------\n\nTITLE: Chaining Two Options Together in TypeScript\nDESCRIPTION: The 'andThen' function enables sequencing of two Option computations. If the first Option is Some, the second Option is evaluated, which may be a static value or a function that depends on the first Option's value. If the first Option is None, it skips the evaluation.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Option-andThen.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const andThen: { <A, B>(f: (a: A) => Option<B>): (self: Option<A>) => Option<B>; <B>(f: Option<B>): <A>(self: Option<A>) => Option<B>; <A, B>(f: (a: A) => B): (self: Option<A>) => Option<B>; <B>(f: NotFunction<B>): <A>(self: Option<A>) => Option<B>; <A, B>(self: Option<A>, f: (a: A) => Option<B>): Option<B>; <A, B>(self: Option<A>, f: Option<B>): Option<B>; <A, B>(self: Option<A>, f: (a: A) => B): Option<B>; <A, B>(self: Option<A>, f: NotFunction<B>): Option<B>; }\n```\n\n----------------------------------------\n\nTITLE: Usage Examples of Predicate.struct in TypeScript\nDESCRIPTION: These examples demonstrate different use cases of the Predicate.struct function, including combinations of Refinement and Predicate inputs for structured objects.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Predicate-struct.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n{ ab: Refinement<A, B>; cd: Refinement<C, D>, ... } -> Refinement<{ ab: A; cd: C; ... }, { ab: B; cd: D; ... }>\n{ a: Predicate<A, B>; b: Predicate<B>, ... } -> Predicate<{ a: A; b: B; ... }>\n{ ab: Refinement<A, B>; c: Predicate<C>, ... } -> Refinement<{ ab: A; c: C; ... }, { ab: B; c: С; ... }>\n```\n\n----------------------------------------\n\nTITLE: Stream.takeWhile Signature\nDESCRIPTION: This is the TypeScript declaration of the `takeWhile` function within the `Stream` module of the Effect library. It showcases the function's generic type parameters and possible overloads using `Refinement` and `Predicate` types for enhanced type safety and flexibility.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-takeWhile.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const takeWhile: { <A, B extends A>(refinement: Refinement<NoInfer<A>, B>): <E, R>(self: Stream<A, E, R>) => Stream<B, E, R>; <A>(predicate: Predicate<NoInfer<A>>): <E, R>(self: Stream<A, E, R>) => Stream<A, E, R>; <A, E, R, B extends A>(self: Stream<A, E, R>, refinement: Refinement<A, B>): Stream<B, E, R>; <A, E, R>(self: Stream<A, E, R>, predicate: Predicate<A>): Stream<A, E, R>; }\n```\n\n----------------------------------------\n\nTITLE: Implementing Timeout Handling for Uninterruptible Effects in TypeScript\nDESCRIPTION: This example demonstrates how to use Effect.disconnect to handle timeouts in uninterruptible effects. It creates a long-running task, makes it uninterruptible, applies disconnect, and sets a timeout. This allows the task to continue in the background while immediately handling the timeout.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-disconnect.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Effect } from \"effect\"\n\nconst longRunningTask = Effect.gen(function* () {\n  console.log(\"Start heavy processing...\")\n  yield* Effect.sleep(\"5 seconds\") // Simulate a long process\n  console.log(\"Heavy processing done.\")\n  return \"Data processed\"\n})\n\nconst timedEffect = longRunningTask.pipe(\n  Effect.uninterruptible,\n  // Allows the task to finish in the background if it times out\n  Effect.disconnect,\n  Effect.timeout(\"1 second\")\n)\n\nEffect.runPromiseExit(timedEffect).then(console.log)\n// Output:\n// Start heavy processing...\n// {\n//   _id: 'Exit',\n//   _tag: 'Failure',\n//   cause: {\n//     _id: 'Cause',\n//     _tag: 'Fail',\n//     failure: { _tag: 'TimeoutException' }\n//   }\n// }\n// Heavy processing done.\n```\n\n----------------------------------------\n\nTITLE: Declaring takeSomeSTM in TSet\nDESCRIPTION: This code snippet declares the `takeSomeSTM` function within the `TSet` module of the Effect library.  The function attempts to take some values from the `TSet` based on the provided STM predicate `pf`. If no values match, it retries until at least one matching value exists.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TSet-takeSomeSTM.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const takeSomeSTM: { <A, B, E, R>(pf: (a: A) => STM.STM<B, Option.Option<E>, R>): (self: TSet<A>) => STM.STM<[B, ...Array<B>], E, R>; <A, B, E, R>(self: TSet<A>, pf: (a: A) => STM.STM<B, Option.Option<E>, R>): STM.STM<[B, ...Array<B>], E, R>; }\n```\n\n----------------------------------------\n\nTITLE: Using HashSet.toggle with Different API Styles in TypeScript\nDESCRIPTION: Demonstrates different ways to use the HashSet.toggle function to toggle the presence of a value in a HashSet. The example shows the data-last (pipeable) API, piping with the pipe function, and the data-first API approaches.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/HashSet-toggle.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// Syntax\nimport { HashSet, pipe } from \"effect\"\n\n// with `data-last`, a.k.a. `pipeable` API\npipe(HashSet.make(0, 1, 2), HashSet.toggle(0))\n\n// or piped with the pipe function\nHashSet.make(0, 1, 2).pipe(HashSet.toggle(0))\n\n// or with `data-first` API\nHashSet.toggle(HashSet.make(0, 1, 2), 0)\n```\n\n----------------------------------------\n\nTITLE: Retrieving First Element from Chunk in Effect TypeScript\nDESCRIPTION: The 'head' function returns the first element of a Chunk if it exists, wrapped in an Option type. This allows for safe access to the first element without causing errors when the Chunk is empty.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Chunk-head.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const head: <A>(self: Chunk<A>) => Option<A>\n```\n\n----------------------------------------\n\nTITLE: Switching Streams on Error Tags in TypeScript\nDESCRIPTION: The `catchTags` function allows handling errors in streams by switching to different streams based on error tags. It takes a map of cases where each case corresponds to an error handler for a specific tag, allowing the stream to continue along paths determined by how errors are classified by their `_tag` property. The function relies on generic type parameters to maintain the variances in types of inputs and outputs across streams.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-catchTags.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const catchTags: { <E extends { _tag: string; }, Cases extends { [K in E[\"_tag\"]]+?: (error: Extract<E, { _tag: K; }>) => Stream<any, any, any>; }>(cases: Cases): <A, R>(self: Stream<A, E, R>) => Stream<A | { [K in keyof Cases]: Cases[K] extends (...args: Array<any>) => Stream.Variance<infer A, infer _E, infer _R> ? A : never; }[keyof Cases], Exclude<E, { _tag: keyof Cases; }> | { [K in keyof Cases]: Cases[K] extends (...args: Array<any>) => Stream.Variance<infer _A, infer E, infer _R> ? E : never; }[keyof Cases], R | { [K in keyof Cases]: Cases[K] extends (...args: Array<any>) => Stream.Variance<infer _A, infer _E, infer R> ? R : never; }[keyof Cases]>; <A, E extends { _tag: string; }, R, Cases extends { [K in E[\"_tag\"]]+?: (error: Extract<E, { _tag: K; }>) => Stream<any, any, any>; }>(self: Stream<A, E, R>, cases: Cases): Stream<A | { [K in keyof Cases]: Cases[K] extends (...args: Array<any>) => Stream.Variance<infer _R, infer _E, infer A> ? A : never; }[keyof Cases], Exclude<E, { _tag: keyof Cases; }> | { [K in keyof Cases]: Cases[K] extends (...args: Array<any>) => Stream.Variance<infer _R, infer E, infer _A> ? E : never; }[keyof Cases], R | { [K in keyof Cases]: Cases[K] extends (...args: Array<any>) => Stream.Variance<infer R, infer _E, infer _A> ? R : never; }[keyof Cases]>; }\n```\n\n----------------------------------------\n\nTITLE: Converting Stream to ReadableStream in TypeScript using Effect\nDESCRIPTION: Function signature for converting a Stream to a ReadableStream using Effect. Accepts optional queuing strategy configuration and returns an Effect containing a ReadableStream. The function supports both curried and uncurried calling patterns.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-toReadableStreamEffect.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const toReadableStreamEffect: { <A>(options?: { readonly strategy?: QueuingStrategy<A> | undefined; }): <E, R>(self: Stream<A, E, R>) => Effect.Effect<ReadableStream<A>, never, R>; <A, E, R>(self: Stream<A, E, R>, options?: { readonly strategy?: QueuingStrategy<A> | undefined; }): Effect.Effect<ReadableStream<A>, never, R>; }\n```\n\n----------------------------------------\n\nTITLE: Defining findFirst Function for List in TypeScript\nDESCRIPTION: Defines the findFirst function that returns the first element satisfying a specified predicate or refinement. It operates on List<A> and returns an Option<A> or Option<B>. The function is overloaded to handle both predicates and refinements.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/List-findFirst.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const findFirst: { <A, B extends A>(refinement: Refinement<NoInfer<A>, B>): (self: List<A>) => Option.Option<B>; <A>(predicate: Predicate<NoInfer<A>>): (self: List<A>) => Option.Option<A>; <A, B extends A>(self: List<A>, refinement: Refinement<A, B>): Option.Option<B>; <A>(self: List<A>, predicate: Predicate<A>): Option.Option<A>; }\n```\n\n----------------------------------------\n\nTITLE: Implementing findFirstIndex Function in TypeScript for Chunk Module\nDESCRIPTION: Defines a function to find the first index in a Chunk that satisfies a given predicate. It supports both curried and uncurried versions, returning an Option<number> as the result.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Chunk-findFirstIndex.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const findFirstIndex: { <A>(predicate: Predicate<A>): (self: Chunk<A>) => Option<number>; <A>(self: Chunk<A>, predicate: Predicate<A>): Option<number>; }\n```\n\n----------------------------------------\n\nTITLE: TypeScript Function Signature for Compose Function\nDESCRIPTION: This code snippet shows the TypeScript type signature for the `compose` function. It demonstrates how the function can be used with different type parameters and function compositions.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Function-compose.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const compose: { <B, C>(bc: (b: B) => C): <A>(self: (a: A) => B) => (a: A) => C; <A, B, C>(self: (a: A) => B, bc: (b: B) => C): (a: A) => C; }\n```\n\n----------------------------------------\n\nTITLE: Calculating Array Union with Custom Equivalence in TypeScript\nDESCRIPTION: A demonstration of using Array.unionWith to find the union of two arrays based on a custom equivalence function. In this example, it creates a union of [1, 2] and [2, 3] using strict equality, resulting in [1, 2, 3].\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Array-unionWith.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Array } from \"effect\"\n\nconst union = Array.unionWith([1, 2], [2, 3], (a, b) => a === b)\nconsole.log(union) // [1, 2, 3]\n```\n\n----------------------------------------\n\nTITLE: Creating Streams with Stream.asyncScoped in TypeScript\nDESCRIPTION: The asyncScoped function creates a stream from an asynchronous callback that can be called multiple times. It returns a scoped resource, and the optional error type E can be used to signal the end of the stream by setting it to None.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-asyncScoped.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const asyncScoped: <A, E = never, R = never>(register: (emit: Emit.Emit<R, E, A, void>) => Effect.Effect<unknown, E, R | Scope.Scope>, bufferSize?: number | \"unbounded\" | { readonly bufferSize?: number | undefined; readonly strategy?: \"dropping\" | \"sliding\" | \"suspend\" | undefined; } | undefined) => Stream<A, E, Exclude<R, Scope.Scope>>\n```\n\n----------------------------------------\n\nTITLE: Creating and Using FiberHandle in Effect-TS\nDESCRIPTION: Demonstrates how to create and use a FiberHandle to manage fibers with automatic interruption when the scope closes. Shows how running new fibers automatically interrupts previous ones.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/FiberHandle-make.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Effect, FiberHandle } from \"effect\"\n\nEffect.gen(function*() {\n  const handle = yield* FiberHandle.make()\n\n  // run some effects\n  yield* FiberHandle.run(handle, Effect.never)\n  // this will interrupt the previous fiber\n  yield* FiberHandle.run(handle, Effect.never)\n\n  yield* Effect.sleep(1000)\n}).pipe(\n  Effect.scoped // The fiber will be interrupted when the scope is closed\n)\n```\n\n----------------------------------------\n\nTITLE: Using isTupleOf to Check Array Length in TypeScript\nDESCRIPTION: Demonstrates how to use the isTupleOf function to determine if an array has exactly N elements, with type narrowing. It shows examples of successful and unsuccessful checks, as well as how the function narrows the type when used in a conditional statement.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Predicate-isTupleOf.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { isTupleOf } from \"effect/Predicate\"\n\nassert.deepStrictEqual(isTupleOf([1, 2, 3], 3), true);\nassert.deepStrictEqual(isTupleOf([1, 2, 3], 2), false);\nassert.deepStrictEqual(isTupleOf([1, 2, 3], 4), false);\n\nconst arr: number[] = [1, 2, 3];\nif (isTupleOf(arr, 3)) {\n  console.log(arr);\n  // ^? [number, number, number]\n}\n```\n\n----------------------------------------\n\nTITLE: Using Doc.cats Combinator in TypeScript\nDESCRIPTION: Demonstrates how to use the Doc.cats combinator to layout documents with conditional line breaks based on page width. Shows both single-line and multi-line output scenarios.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Doc-cats.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport * as Doc from \"@effect/printer/Doc\"\nimport * as String from \"effect/String\"\n\nconst doc: Doc.Doc<never> = Doc.hsep([\n  Doc.text(\"Docs:\"),\n  Doc.cats(Doc.words(\"lorem ipsum dolor\"))\n])\n\nassert.strictEqual(\n  Doc.render(doc, { style: \"pretty\" }),\n  \"Docs: loremipsumdolor\"\n)\n\n// If the document exceeds the width of the page, the documents are rendered\n// one above another\nassert.strictEqual(\n  Doc.render(doc, {\n    style: \"pretty\",\n    options: { lineWidth: 10 }\n  }),\n  String.stripMargin(\n    `|Docs: lorem\n     |ipsum\n     |dolor`\n  )\n)\n```\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const cats: <A>(docs: Iterable<Doc<A>>) => Doc<A>\n```\n\n----------------------------------------\n\nTITLE: Overriding Default Values in Context.Reference\nDESCRIPTION: This example shows how to override the default value of a Context.Reference tag. It defines a SpecialNumber class with a default value of 2048, then demonstrates how to provide a custom value (-1) when running the Effect program.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Context-Reference.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Context, Effect } from \"effect\"\n\nclass SpecialNumber extends Context.Reference<SpecialNumber>()(\n  \"SpecialNumber\",\n  { defaultValue: () => 2048 }\n) {}\n\nconst program = Effect.gen(function* () {\n  const specialNumber = yield* SpecialNumber\n  console.log(`The special number is ${specialNumber}`)\n})\n\nEffect.runPromise(program.pipe(Effect.provideService(SpecialNumber, -1)))\n// Output: The special number is -1\n```\n\n----------------------------------------\n\nTITLE: Creating a Channel from a PubSub with Scoped Effect in TypeScript\nDESCRIPTION: This function constructs a Channel from a PubSub within a scoped effect. It takes a PubSub that emits Either values containing elements or exit signals and returns a scoped Effect that produces a Channel.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Channel-fromPubSubScoped.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const fromPubSubScoped: <Done, Err, Elem>(pubsub: PubSub.PubSub<Either.Either<Elem, Exit.Exit<Done, Err>>>) => Effect.Effect<Channel<Elem, unknown, Err, unknown, Done, unknown>, never, Scope.Scope>\n```\n\n----------------------------------------\n\nTITLE: Executing Synchronous Effect in TypeScript\nDESCRIPTION: Demonstrates the usage of Effect.runSync for executing a synchronous effect that logs a message and returns a value.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-runSync.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Effect } from \"effect\"\n\nconst program = Effect.sync(() => {\n  console.log(\"Hello, World!\")\n  return 1\n})\n\nconst result = Effect.runSync(program)\n// Output: Hello, World!\n\nconsole.log(result)\n// Output: 1\n```\n\n----------------------------------------\n\nTITLE: Using globalValue for Persistent Caching in TypeScript\nDESCRIPTION: An example showing how to create a persistent cache using the globalValue function. The cache will persist as long as the module is running, even if reloaded or imported elsewhere.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/GlobalValue-globalValue.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { globalValue } from \"effect/GlobalValue\"\n\n// This cache will persist as long as the module is running,\n// even if reloaded or imported elsewhere\nconst myCache = globalValue(\n  Symbol.for(\"myCache\"),\n  () => new WeakMap<object, number>()\n)\n```\n\n----------------------------------------\n\nTITLE: Type Signature for Array.makeBy Function\nDESCRIPTION: The type signature for the makeBy function, showing it can be called in two ways: either with the mapping function first and length second (curried), or with length first and mapping function second.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Array-makeBy.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const makeBy: { <A>(f: (i: number) => A): (n: number) => NonEmptyArray<A>; <A>(n: number, f: (i: number) => A): NonEmptyArray<A>; }\n```\n\n----------------------------------------\n\nTITLE: Using Match.whenAnd for Multiple Pattern Matching in TypeScript\nDESCRIPTION: Demonstrates how to use Match.whenAnd to check multiple conditions simultaneously on a User type object. The example shows pattern matching for both age and role criteria to grant admin access.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Match-whenAnd.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Match } from \"effect\"\n\ntype User = { readonly age: number; readonly role: \"admin\" | \"user\" }\n\nconst checkUser = Match.type<User>().pipe(\n  Match.whenAnd(\n    { age: (n) => n >= 18 },\n    { role: \"admin\" },\n    () => \"Admin access granted\"\n  ),\n  Match.orElse(() => \"Access denied\")\n)\n\nconsole.log(checkUser({ age: 20, role: \"admin\" }))\n// Output: \"Admin access granted\"\n\nconsole.log(checkUser({ age: 20, role: \"user\" }))\n// Output: \"Access denied\"\n```\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const whenAnd: <R, const P extends ReadonlyArray<Types.PatternPrimitive<R> | Types.PatternBase<R>>, Ret, Fn extends (_: Types.WhenMatch<R, T.UnionToIntersection<P[number]>>) => Ret>(...args: [...patterns: P, f: Fn]) => <I, F, A, Pr>(self: Matcher<I, F, R, A, Pr, Ret>) => Matcher<I, Types.AddWithout<F, Types.PForExclude<T.UnionToIntersection<P[number]>>>, Types.ApplyFilters<I, Types.AddWithout<F, Types.PForExclude<T.UnionToIntersection<P[number]>>>>, A | ReturnType<Fn>, Pr>\n```\n\n----------------------------------------\n\nTITLE: Testing if a Value is an Object using Effect Predicate in TypeScript\nDESCRIPTION: This code snippet demonstrates the usage of the `isObject` function from the `Predicate` module in the `effect` package to test if various types of inputs are considered objects in JavaScript/TypeScript. The example uses assertions to check the function's behavior against typical inputs such as objects, arrays, null, and undefined. The code requires the `effect` package and Node.js assertions. Inputs are tested to return boolean outputs indicating if the input is an object, where typical edge cases like null and undefined are taken into account, as they are not considered objects here.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Predicate-isObject.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { isObject } from \"effect/Predicate\"\n\nassert.deepStrictEqual(isObject({}), true)\nassert.deepStrictEqual(isObject([]), true)\n\nassert.deepStrictEqual(isObject(null), false)\nassert.deepStrictEqual(isObject(undefined), false)\n```\n\n----------------------------------------\n\nTITLE: Array.findFirst Type Signature\nDESCRIPTION: The TypeScript type signature for the Array.findFirst function, showing its polymorphic nature. It supports different calling patterns including predicates, refinements, and option-returning functions.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Array-findFirst.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const findFirst: { <A, B>(f: (a: NoInfer<A>, i: number) => Option.Option<B>): (self: Iterable<A>) => Option.Option<B>; <A, B extends A>(refinement: (a: NoInfer<A>, i: number) => a is B): (self: Iterable<A>) => Option.Option<B>; <A>(predicate: (a: NoInfer<A>, i: number) => boolean): (self: Iterable<A>) => Option.Option<A>; <A, B>(self: Iterable<A>, f: (a: A, i: number) => Option.Option<B>): Option.Option<B>; <A, B extends A>(self: Iterable<A>, refinement: (a: A, i: number) => a is B): Option.Option<B>; <A>(self: Iterable<A>, predicate: (a: A, i: number) => boolean): Option.Option<A>; }\n```\n\n----------------------------------------\n\nTITLE: Effect Vitest Layer Usage Example\nDESCRIPTION: Demonstrates practical usage of layers in Effect-based testing, showing how to create and compose layers with context tags, and how to use nested layers for hierarchical test organization.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/index-layer.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { expect, layer } from \"@effect/vitest\"\nimport { Context, Effect, Layer } from \"effect\"\n\nclass Foo extends Context.Tag(\"Foo\")<Foo, \"foo\">() {\n  static Live = Layer.succeed(Foo, \"foo\")\n}\n\nclass Bar extends Context.Tag(\"Bar\")<Bar, \"bar\">() {\n  static Live = Layer.effect(\n    Bar,\n    Effect.map(Foo, () => \"bar\" as const)\n  )\n}\n\nlayer(Foo.Live)(\"layer\", (it) => {\n  it.effect(\"adds context\", () =>\n    Effect.gen(function* () {\n      const foo = yield* Foo\n      expect(foo).toEqual(\"foo\")\n    })\n  )\n\n  it.layer(Bar.Live)(\"nested\", (it) => {\n    it.effect(\"adds context\", () =>\n      Effect.gen(function* () {\n        const foo = yield* Foo\n        const bar = yield* Bar\n        expect(foo).toEqual(\"foo\")\n        expect(bar).toEqual(\"bar\")\n      })\n    )\n  })\n})\n```\n\n----------------------------------------\n\nTITLE: Retrieving a Fiber from FiberHandle in TypeScript\nDESCRIPTION: The `get` function retrieves the fiber from a FiberHandle. It returns an Effect that resolves to a RuntimeFiber or a NoSuchElementException if the fiber cannot be found.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/FiberHandle-get.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const get: <A, E>(self: FiberHandle<A, E>) => Effect.Effect<Fiber.RuntimeFiber<A, E>, NoSuchElementException>\n```\n\n----------------------------------------\n\nTITLE: Implementing Safe Key Lookup in HashMap with TypeScript\nDESCRIPTION: The get function safely retrieves values from a HashMap by key, returning an Option type that handles the possibility of missing keys. It supports both curried and uncurried calling styles.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/HashMap-get.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const get: { <K1>(key: K1): <K, V>(self: HashMap<K, V>) => Option<V>; <K, V, K1>(self: HashMap<K, V>, key: K1): Option<V>; }\n```\n\n----------------------------------------\n\nTITLE: Getting Some Values from a Record - TypeScript\nDESCRIPTION: This code snippet demonstrates the usage of the `Record.getSomes` function, which filters and returns only the 'Some' values from a given record containing `Option` values. This is useful for scenarios where you want to operate only on defined values without losing track of their keys. It requires the `effect` package, specifically the `Record` and `Option` modules.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Record-getSomes.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { Record, Option } from \"effect\"\n\nassert.deepStrictEqual(\n  Record.getSomes({ a: Option.some(1), b: Option.none(), c: Option.some(2) }),\n  { a: 1, c: 2 }\n)\n```\n\n----------------------------------------\n\nTITLE: Stream.runFold Signature (TypeScript)\nDESCRIPTION: The `Stream.runFold` function executes a pure fold over a stream, reducing all elements to a value of type `S`. It takes an initial state `s` and a folding function `f` as arguments, and returns an `Effect` that represents the result of the fold.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-runFold.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const runFold: { <S, A>(s: S, f: (s: S, a: A) => S): <E, R>(self: Stream<A, E, R>) => Effect.Effect<S, E, R>; <A, E, R, S>(self: Stream<A, E, R>, s: S, f: (s: S, a: A) => S): Effect.Effect<S, E, R>; }\n```\n\n----------------------------------------\n\nTITLE: Implementing Fallback Configuration Providers in TypeScript\nDESCRIPTION: The orElse function returns a new ConfigProvider that attempts to load configuration from the primary provider and falls back to an alternate provider if there are any issues. This enables creating resilient configuration chains with multiple data sources.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/ConfigProvider-orElse.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const orElse: { (that: LazyArg<ConfigProvider>): (self: ConfigProvider) => ConfigProvider; (self: ConfigProvider, that: LazyArg<ConfigProvider>): ConfigProvider; }\n```\n\n----------------------------------------\n\nTITLE: Implementing Division with Error Handling using Effect.dieMessage in TypeScript\nDESCRIPTION: Demonstrates how to use Effect.dieMessage to handle division by zero cases by terminating the fiber with a custom error message. The example shows implementation of a safe division function that returns an Effect.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-dieMessage.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Effect } from \"effect\"\n\nconst divide = (a: number, b: number) =>\n  b === 0\n    ? Effect.dieMessage(\"Cannot divide by zero\")\n    : Effect.succeed(a / b)\n\n//      ┌─── Effect<number, never, never>\n//      ▼\nconst program = divide(1, 0)\n\nEffect.runPromise(program).catch(console.error)\n// Output:\n// (FiberFailure) RuntimeException: Cannot divide by zero\n//   ...stack trace...\n```\n\n----------------------------------------\n\nTITLE: Defining Scope Interface in TypeScript\nDESCRIPTION: Interface definition for Scope that extends Pipeable. It includes functionality for managing execution strategies, creating child scopes, and handling finalizers. The scope provides methods for forking child scopes and adding finalizers that execute during scope closure.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Scope-Scope.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface Scope extends Pipeable {\n  readonly [ScopeTypeId]: ScopeTypeId\n  /**\n   * The execution strategy for running finalizers in this scope.\n   */\n  readonly strategy: ExecutionStrategy.ExecutionStrategy\n  /**\n   * Forks a new child scope with the specified execution strategy. The child scope\n   * will automatically be closed when this scope is closed.\n   *\n   * @internal\n   */\n  fork(strategy: ExecutionStrategy.ExecutionStrategy): Effect.Effect<Scope.Closeable>\n  /**\n   * Adds a finalizer to this scope. The finalizer will be run when the scope is closed.\n   *\n   * @internal\n   */\n  addFinalizer(finalizer: Scope.Finalizer): Effect.Effect<void>\n}\n```\n\n----------------------------------------\n\nTITLE: Using Stream.fail to Terminate with Error - TypeScript\nDESCRIPTION: This code snippet demonstrates how to create a stream that fails with a specific error message using the Effect library in TypeScript. The stream emits a failure, which is then collected and logged using Effect's runPromiseExit method. Dependencies include the Effect and Stream modules from the effect library, and it is essential to manage asynchronous operations appropriately.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-fail.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Effect, Stream } from \"effect\"\n\nconst stream = Stream.fail(\"Uh oh!\")\n\nEffect.runPromiseExit(Stream.runCollect(stream)).then(console.log)\n// {\n//   _id: 'Exit',\n//   _tag: 'Failure',\n//   cause: { _id: 'Cause', _tag: 'Fail', failure: 'Uh oh!' }\n// }\n```\n\n----------------------------------------\n\nTITLE: Providing Context to Schedule in TypeScript\nDESCRIPTION: A function that allows supplying a context to a schedule, removing the need for external dependencies during execution. Useful for scenarios involving logging, database connections, or configuration settings.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Schedule-provideContext.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const provideContext: { <R>(context: Context.Context<R>): <Out, In>(self: Schedule<Out, In, R>) => Schedule<Out, In, never>; <Out, In, R>(self: Schedule<Out, In, R>, context: Context.Context<R>): Schedule<Out, In, never>; }\n```\n\n----------------------------------------\n\nTITLE: STM.refineOrDieWith Signature\nDESCRIPTION: This code snippet displays the signature of the `STM.refineOrDieWith` function in TypeScript.  The function allows for refining the error type `E` of an `STM` transaction to a new error type `E2`. It takes a partial function `pf` to conditionally refine errors and a function `f` to transform unrefined errors into throwables.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/STM-refineOrDieWith.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const refineOrDieWith: { <E, E2>(pf: (error: E) => Option.Option<E2>, f: (error: E) => unknown): <A, R>(self: STM<A, E, R>) => STM<A, E2, R>; <A, E, R, E2>(self: STM<A, E, R>, pf: (error: E) => Option.Option<E2>, f: (error: E) => unknown): STM<A, E2, R>; }\n```\n\n----------------------------------------\n\nTITLE: Using Stream.raceAll with Multiple Scheduled Streams in TypeScript\nDESCRIPTION: This example demonstrates how to use Stream.raceAll to create a stream that takes the first 6 items from the fastest of three scheduled streams. The winning stream emits a value every millisecond, while the others are interrupted.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-raceAll.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Stream, Schedule, Console, Effect } from \"effect\"\n\nconst stream = Stream.raceAll(\n  Stream.fromSchedule(Schedule.spaced('1 millis')),\n  Stream.fromSchedule(Schedule.spaced('2 millis')),\n  Stream.fromSchedule(Schedule.spaced('4 millis')),\n).pipe(Stream.take(6), Stream.tap(Console.log))\n\nEffect.runPromise(Stream.runDrain(stream))\n// Output each millisecond from the first stream, the rest streams are interrupted\n// 0\n// 1\n// 2\n// 3\n// 4\n// 5\n```\n\n----------------------------------------\n\nTITLE: Effect.catchSome Function Signature in TypeScript\nDESCRIPTION: The type signature of the Effect.catchSome function, which takes a partial function for error handling and returns a new Effect that may recover from specific errors.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-catchSome.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const catchSome: { <E, A2, E2, R2>(pf: (e: NoInfer<E>) => Option.Option<Effect<A2, E2, R2>>): <A, R>(self: Effect<A, E, R>) => Effect<A2 | A, E | E2, R2 | R>; <A, E, R, A2, E2, R2>(self: Effect<A, E, R>, pf: (e: NoInfer<E>) => Option.Option<Effect<A2, E2, R2>>): Effect<A | A2, E | E2, R | R2>; }\n```\n\n----------------------------------------\n\nTITLE: Generating Random Integer in Range with Effect in TypeScript\nDESCRIPTION: This function generates a random integer within a specified range using the Effect library. It takes two parameters: 'min' for the lower bound and 'max' for the upper bound of the range. The function returns an Effect that, when executed, will produce a random integer within the specified range.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Random-nextIntBetween.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const nextIntBetween: (min: number, max: number) => Effect.Effect<number>\n```\n\n----------------------------------------\n\nTITLE: Validating Return Type Consistency with Match.withReturnType in TypeScript\nDESCRIPTION: This example demonstrates how to use Match.withReturnType to ensure all branches of a matcher return a specific type. It shows both correct and incorrect usage, with TypeScript enforcing type consistency.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Match-withReturnType.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Match } from \"effect\"\n\nconst match = Match.type<{ a: number } | { b: string }>().pipe(\n  // Ensure all branches return a string\n  Match.withReturnType<string>(),\n  // ❌ Type error: 'number' is not assignable to type 'string'\n  // @ts-expect-error\n  Match.when({ a: Match.number }, (_) => _.a),\n  // ✅ Correct: returns a string\n  Match.when({ b: Match.string }, (_) => _.b),\n  Match.exhaustive\n)\n```\n\n----------------------------------------\n\nTITLE: Using Match.whenOr for Pattern Matching in TypeScript\nDESCRIPTION: This example demonstrates how to use Match.whenOr to handle multiple error types with shared logic. It defines an ErrorType union type and creates a handler function that matches different error patterns.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Match-whenOr.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Match } from \"effect\"\n\ntype ErrorType =\n  | { readonly _tag: \"NetworkError\"; readonly message: string }\n  | { readonly _tag: \"TimeoutError\"; readonly duration: number }\n  | { readonly _tag: \"ValidationError\"; readonly field: string }\n\nconst handleError = Match.type<ErrorType>().pipe(\n  Match.whenOr(\n    { _tag: \"NetworkError\" },\n    { _tag: \"TimeoutError\" },\n    () => \"Retry the request\"\n  ),\n  Match.when({ _tag: \"ValidationError\" }, (_) => `Invalid field: ${_.field}`),\n  Match.exhaustive\n)\n\nconsole.log(handleError({ _tag: \"NetworkError\", message: \"No connection\" }))\n// Output: \"Retry the request\"\n\nconsole.log(handleError({ _tag: \"ValidationError\", field: \"email\" }))\n// Output: \"Invalid field: email\"\n```\n\n----------------------------------------\n\nTITLE: Using RegExp.escape Example in TypeScript\nDESCRIPTION: Demonstrates how to use RegExp.escape to safely escape special characters in a regular expression pattern string. The example shows escaping an asterisk character between two letters.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/RegExp-escape.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { RegExp } from \"effect\"\n\nassert.deepStrictEqual(RegExp.escape(\"a*b\"), \"a\\\\*b\")\n```\n\n----------------------------------------\n\nTITLE: Using Effect.eventually to Retry Operations Until Success in TypeScript\nDESCRIPTION: This example demonstrates how to use Effect.eventually to retry an operation until it succeeds. The code sets up a counter that will cause the effect to fail twice before succeeding on the third attempt, showing how errors are ignored during retries.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-eventually.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Effect } from \"effect\"\n\nlet counter = 0\n\nconst effect = Effect.try(() => {\n  counter++\n  if (counter < 3) {\n    console.log(\"running effect\")\n    throw new Error(\"error\")\n  } else {\n    console.log(\"effect done\")\n    return \"some result\"\n  }\n})\n\nconst program = Effect.eventually(effect)\n\nEffect.runPromise(program).then(console.log)\n// Output:\n// running effect\n// running effect\n// effect done\n// some result\n```\n\n----------------------------------------\n\nTITLE: Effect.exists Type Definition\nDESCRIPTION: Type signature for the Effect.exists function showing supported parameters and return types. Includes options for concurrency, batching, and concurrent finalizers.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-exists.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const exists: { <A, E, R>(predicate: (a: A, i: number) => Effect<boolean, E, R>, options?: { readonly concurrency?: Concurrency | undefined; readonly batching?: boolean | \"inherit\" | undefined; readonly concurrentFinalizers?: boolean | undefined; } | undefined): (elements: Iterable<A>) => Effect<boolean, E, R>; <A, E, R>(elements: Iterable<A>, predicate: (a: A, i: number) => Effect<boolean, E, R>, options?: { readonly concurrency?: Concurrency | undefined; readonly batching?: boolean | \"inherit\" | undefined; readonly concurrentFinalizers?: boolean | undefined; } | undefined): Effect<boolean, E, R>; }\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Either.bind Usage in Do Simulation\nDESCRIPTION: This example shows how to use Either.bind and Either.let functions within a do simulation scope to define variables and perform operations on Either values. It demonstrates binding values and calculating a sum.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Either-bind.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { Either, pipe } from \"effect\"\n\nconst result = pipe(\n  Either.Do,\n  Either.bind(\"x\", () => Either.right(2)),\n  Either.bind(\"y\", () => Either.right(3)),\n  Either.let(\"sum\", ({ x, y }) => x + y)\n)\nassert.deepStrictEqual(result, Either.right({ x: 2, y: 3, sum: 5 }))\n```\n\n----------------------------------------\n\nTITLE: Using Context.unsafeGet to Retrieve Services in TypeScript\nDESCRIPTION: Demonstrates how to safely and unsafely retrieve services from a Context using tags. The example shows creating tags for Port and Timeout services, adding a Port service to a context, and then retrieving it with Context.unsafeGet. It also shows that attempting to retrieve a service not in the context will throw an error.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Context-unsafeGet.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { Context } from \"effect\"\n\nconst Port = Context.GenericTag<{ PORT: number }>(\"Port\")\nconst Timeout = Context.GenericTag<{ TIMEOUT: number }>(\"Timeout\")\n\nconst Services = Context.make(Port, { PORT: 8080 })\n\nassert.deepStrictEqual(Context.unsafeGet(Services, Port), { PORT: 8080 })\nassert.throws(() => Context.unsafeGet(Services, Timeout))\n```\n\n----------------------------------------\n\nTITLE: Implementing Custom Timeout Handling with Effect.timeoutFailCause in TypeScript\nDESCRIPTION: This snippet demonstrates how to use Effect.timeoutFailCause to handle timeouts as exceptional cases by generating a custom defect. It includes a simulated task with a delay and applies a timeout with a custom error message.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-timeoutFailCause.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Effect, Cause } from \"effect\"\n\nconst task = Effect.gen(function* () {\n  console.log(\"Start processing...\")\n  yield* Effect.sleep(\"2 seconds\") // Simulates a delay in processing\n  console.log(\"Processing complete.\")\n  return \"Result\"\n})\n\nconst program = task.pipe(\n  Effect.timeoutFailCause({\n    duration: \"1 second\",\n    onTimeout: () => Cause.die(\"Timed out!\") // Custom defect for timeout\n  })\n)\n\nEffect.runPromiseExit(program).then(console.log)\n// Output:\n// Start processing...\n// {\n//   _id: 'Exit',\n//   _tag: 'Failure',\n//   cause: { _id: 'Cause', _tag: 'Die', defect: 'Timed out!' }\n// }\n```\n\n----------------------------------------\n\nTITLE: Type Equality Example Usage in TypeScript\nDESCRIPTION: Demonstrates how to use Types.Equals to compare type structures at compile time. Shows cases of equal and unequal types with boolean results.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Types-Equals.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport type { Types } from \"effect\"\n\ntype Res1 = Types.Equals<{ a: number }, { a: number }> // true\ntype Res2 = Types.Equals<{ a: number }, { b: number }> // false\n```\n\n----------------------------------------\n\nTITLE: Retrieving Left Values from Iterable of Either in TypeScript\nDESCRIPTION: This example demonstrates how to use the Iterable.getLefts function to extract Left values from an Iterable of Either types. It imports necessary modules, creates an array of Either values, and uses getLefts to filter out the Left values.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Iterable-getLefts.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { Iterable, Either } from \"effect\"\n\nassert.deepStrictEqual(\n  Array.from(Iterable.getLefts([Either.right(1), Either.left(\"err\"), Either.right(2)])),\n  [\"err\"]\n)\n```\n\n----------------------------------------\n\nTITLE: Creating Dual Function Using Arity in TypeScript\nDESCRIPTION: Example showing how to create a function using the dual utility that works in both data-first and data-last styles based on arity. The sum function can be called directly with two arguments or used in a pipe with one argument.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Function-dual.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { dual, pipe } from \"effect/Function\"\n\nconst sum = dual<\n  (that: number) => (self: number) => number,\n  (self: number, that: number) => number\n>(2, (self, that) => self + that)\n\nconsole.log(sum(2, 3)) // 5\nconsole.log(pipe(2, sum(3))) // 5\n```\n\n----------------------------------------\n\nTITLE: Implementing TapBoth in Stream for Effect-TS in TypeScript\nDESCRIPTION: The tapBoth function allows users to define effectful 'peek' operations for both success and failure scenarios within an Effect-TS stream. It requires specifying onFailure and onSuccess handlers that take the error or success values and return an effect. The function can be used in two forms: specifying the stream first and the options later, or directly combining both. Key parameters include the stream itself and the onFailure/onSuccess handlers. It supports advanced type inference to accommodate various effect types, and it is essential that Effect-TS is set up correctly in the environment.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-tapBoth.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const tapBoth: { <E, X1, E2, R2, A, X2, E3, R3>(options: { readonly onFailure: (e: NoInfer<E>) => Effect.Effect<X1, E2, R2>; readonly onSuccess: (a: NoInfer<A>) => Effect.Effect<X2, E3, R3>; }): <R>(self: Stream<A, E, R>) => Stream<A, E | E2 | E3, R2 | R3 | R>; <A, E, R, X1, E2, R2, X2, E3, R3>(self: Stream<A, E, R>, options: { readonly onFailure: (e: NoInfer<E>) => Effect.Effect<X1, E2, R2>; readonly onSuccess: (a: NoInfer<A>) => Effect.Effect<X2, E3, R3>; }): Stream<A, E | E2 | E3, R | R2 | R3>; }\n```\n\n----------------------------------------\n\nTITLE: Inserting Entries into a Trie in TypeScript\nDESCRIPTION: This code snippet demonstrates how to create a Trie, insert multiple entries, and verify the contents using assertions. It shows the progressive building of a Trie with string keys and number values.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Trie-insert.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { Trie } from \"effect\"\n\nconst trie1 = Trie.empty<number>().pipe(\n  Trie.insert(\"call\", 0)\n)\nconst trie2 = trie1.pipe(Trie.insert(\"me\", 1))\nconst trie3 = trie2.pipe(Trie.insert(\"mind\", 2))\nconst trie4 = trie3.pipe(Trie.insert(\"mid\", 3))\n\nassert.deepStrictEqual(Array.from(trie1), [[\"call\", 0]])\nassert.deepStrictEqual(Array.from(trie2), [[\"call\", 0], [\"me\", 1]])\nassert.deepStrictEqual(Array.from(trie3), [[\"call\", 0], [\"me\", 1], [\"mind\", 2]])\nassert.deepStrictEqual(Array.from(trie4), [[\"call\", 0], [\"me\", 1], [\"mid\", 3], [\"mind\", 2]])\n```\n\n----------------------------------------\n\nTITLE: Creating a Trie from Iterable in TypeScript\nDESCRIPTION: Demonstrates how to create a Trie from an iterable collection of key/value pairs using Trie.fromIterable. It shows the creation, comparison, and extraction of entries from the Trie.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Trie-fromIterable.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { Trie, Equal } from \"effect\"\n\nconst iterable: Array<readonly [string, number]> = [[\"call\", 0], [\"me\", 1], [\"mind\", 2], [\"mid\", 3]]\nconst trie = Trie.fromIterable(iterable)\n\n// The entries in the `Trie` are extracted in alphabetical order, regardless of the insertion order\nassert.deepStrictEqual(Array.from(trie), [[\"call\", 0], [\"me\", 1], [\"mid\", 3], [\"mind\", 2]])\nassert.equal(Equal.equals(Trie.make([\"call\", 0], [\"me\", 1], [\"mind\", 2], [\"mid\", 3]), trie), true)\n```\n\n----------------------------------------\n\nTITLE: Using Stream.zipWithIndex in Effect-TS\nDESCRIPTION: Demonstrates how to zip a stream with indices using Effect-TS's Stream module. The example shows creating a stream of names and adding zero-based indices to each element, resulting in tuples of [value, index].\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-zipWithIndex.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Effect, Stream } from \"effect\"\n\nconst stream = Stream.make(\"Mary\", \"James\", \"Robert\", \"Patricia\")\n\nconst indexedStream = Stream.zipWithIndex(stream)\n\nEffect.runPromise(Stream.runCollect(indexedStream)).then(console.log)\n// {\n//   _id: 'Chunk',\n//   values: [ [ 'Mary', 0 ], [ 'James', 1 ], [ 'Robert', 2 ], [ 'Patricia', 3 ] ]\n// }\n```\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const zipWithIndex: <A, E, R>(self: Stream<A, E, R>) => Stream<[A, number], E, R>\n```\n\n----------------------------------------\n\nTITLE: Using Match.tags for Discriminated Union Handling in TypeScript\nDESCRIPTION: Demonstrates how to use Match.tags to handle a discriminated union by mapping _tag values to specific functions. The example shows creation of an exhaustive match function for a union type with three variants.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Match-tags.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Match, pipe } from \"effect\"\n\nconst match = pipe(\n  Match.type<{ _tag: \"A\"; a: string } | { _tag: \"B\"; b: number } | { _tag: \"C\"; c: boolean }>(),\n  Match.tags({\n    A: (a) => a.a,\n    B: (b) => b.b,\n    C: (c) => c.c\n  }),\n  Match.exhaustive\n)\n```\n\n----------------------------------------\n\nTITLE: flatMapNullable Example with Employee Interface (Effect, Typescript)\nDESCRIPTION: This code demonstrates how to use `flatMapNullable` to extract a deeply nested property from an `Employee` interface that might contain `null` or `undefined` values at any level. It shows how `flatMapNullable` handles missing or nullable properties by returning `None` when a property is not available.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Option-flatMapNullable.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nimport { Option } from \"effect\"\n\ninterface Employee {\n  company?: {\n    address?: {\n      street?: {\n        name?: string\n      }\n    }\n  }\n}\n\nconst employee1: Employee = { company: { address: { street: { name: \"high street\" } } } }\n\n// Extracting a deeply nested property\nconsole.log(\n  Option.some(employee1)\n    .pipe(Option.flatMapNullable((employee) => employee.company?.address?.street?.name))\n)\n// Output: { _id: 'Option', _tag: 'Some', value: 'high street' }\n\nconst employee2: Employee = { company: { address: { street: {} } } }\n\n// Property does not exist\nconsole.log(\n  Option.some(employee2)\n    .pipe(Option.flatMapNullable((employee) => employee.company?.address?.street?.name))\n)\n// Output: { _id: 'Option', _tag: 'None' }\n```\n```\n\n----------------------------------------\n\nTITLE: Associating Metrics with Effects in TypeScript\nDESCRIPTION: The withMetric function associates a metric with the current effect, updating it as the effect progresses. It can be used in two ways: by passing the metric first, or by passing the effect first and the metric second.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-withMetric.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const withMetric: { <Type, In, Out>(metric: Metric.Metric<Type, In, Out>): <A extends In, E, R>(self: Effect<A, E, R>) => Effect<A, E, R>; <A extends In, E, R, Type, In, Out>(self: Effect<A, E, R>, metric: Metric.Metric<Type, In, Out>): Effect<A, E, R>; }\n```\n\n----------------------------------------\n\nTITLE: TypeScript Function Signature for Effect.takeUntil\nDESCRIPTION: The type signature of the takeUntil function, showing it as a curried function that can be used in two ways: either passing the predicate first and elements second, or passing both elements and predicate together. The function returns an Effect containing an array of elements.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-takeUntil.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const takeUntil: { <A, R, E>(predicate: (a: NoInfer<A>, i: number) => Effect<boolean, E, R>): (elements: Iterable<A>) => Effect<Array<A>, E, R>; <A, E, R>(elements: Iterable<A>, predicate: (a: NoInfer<A>, i: number) => Effect<boolean, E, R>): Effect<Array<A>, E, R>; }\n```\n\n----------------------------------------\n\nTITLE: TypeScript Signature for Effect.iterate Function\nDESCRIPTION: The TypeScript type signature for the Effect.iterate function, showing its polymorphic implementation that supports both Refinement and Predicate for the while condition.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-iterate.md#2025-04-11_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const iterate: { <A, B extends A, R, E>(initial: A, options: { readonly while: Refinement<A, B>; readonly body: (b: B) => Effect<A, E, R>; }): Effect<A, E, R>; <A, R, E>(initial: A, options: { readonly while: Predicate<A>; readonly body: (a: A) => Effect<A, E, R>; }): Effect<A, E, R>; }\n```\n\n----------------------------------------\n\nTITLE: Repeating Stream Elements with Schedule in TypeScript\nDESCRIPTION: The `repeatElementsWith` function enables the repetition of each element in a Stream according to a scheduling strategy. It allows the output from the original stream and the schedule to be harmonized into a unified type through provided conversion functions. This functionality requires the Effect framework's `Schedule` module and is designed to handle streams of various types, enhancing flexibility in concurrent programming.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-repeatElementsWith.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const repeatElementsWith: { <B, R2, A, C>(schedule: Schedule.Schedule<B, unknown, R2>, options: { readonly onElement: (a: A) => C; readonly onSchedule: (b: B) => C; }): <E, R>(self: Stream<A, E, R>) => Stream<C, E, R2 | R>; <A, E, R, B, R2, C>(self: Stream<A, E, R>, schedule: Schedule.Schedule<B, unknown, R2>, options: { readonly onElement: (a: A) => C; readonly onSchedule: (b: B) => C; }): Stream<C, E, R | R2>; }\n```\n\n----------------------------------------\n\nTITLE: Using Effect.takeWhile with an Array of Numbers in TypeScript\nDESCRIPTION: This example demonstrates how to use Effect.takeWhile to filter an array of numbers, taking only elements that satisfy a condition (numbers less than or equal to 3). The function processes the array and returns a new array containing only the elements that passed the predicate test.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-takeWhile.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Effect } from \"effect\"\n\nconst numbers = [1, 2, 3, 4, 5, 6]\nconst predicate = (n: number, i: number) => Effect.succeed(n <= 3)\n\nconst program = Effect.gen(function*() {\n  const result = yield* Effect.takeWhile(numbers, predicate)\n  console.log(result)\n})\n\nEffect.runFork(program)\n// Output: [1, 2, 3]\n```\n\n----------------------------------------\n\nTITLE: Using HashSet.mutate with Different Syntax Styles\nDESCRIPTION: Demonstrates different ways to use HashSet.mutate including data-last (pipeable) API, pipe function, and data-first API approaches. The function allows controlled mutation of HashSet elements within a functional context.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/HashSet-mutate.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// Syntax\nimport { HashSet, pipe } from \"effect\"\n\n// with data-last, a.k.a. pipeable API\npipe(\n  HashSet.make(1, 2, 3),\n  HashSet.mutate((set) => {\n    HashSet.add(set, 4)\n    HashSet.remove(set, 1)\n  })\n)\n\n// or piped with the pipe function\nHashSet.make(1, 2, 3).pipe(\n  HashSet.mutate((set) => {\n    HashSet.add(set, 4)\n    HashSet.remove(set, 1)\n  })\n)\n\n// or with data-first API\nHashSet.mutate(HashSet.make(1, 2, 3), (set) => {\n  HashSet.add(set, 4)\n  HashSet.remove(set, 1)\n})\n```\n\n----------------------------------------\n\nTITLE: Ensuring Stream Completion Finalizer in TypeScript\nDESCRIPTION: This snippet defines a stream using the 'effect' package and showcases the use of the `ensuring` function to execute a finalizer after the stream's own finalizers. Dependencies include 'effect' package with modules Effect, Stream, and Console. The program logs messages to the console during the stream's main logic and finalization processes.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-ensuring.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Console, Effect, Stream } from \"effect\"\n\nconst program = Stream.fromEffect(Console.log(\"Application Logic.\")).pipe(\n  Stream.concat(Stream.finalizer(Console.log(\"Finalizing the stream\"))),\n  Stream.ensuring(\n    Console.log(\"Doing some other works after stream's finalization\")\n  )\n)\n\nEffect.runPromise(Stream.runCollect(program)).then(console.log)\n// Application Logic.\n// Finalizing the stream\n// Doing some other works after stream's finalization\n// { _id: 'Chunk', values: [ undefined, undefined ] }\n\n```\n\n----------------------------------------\n\nTITLE: Option.zipWith Example\nDESCRIPTION: Demonstrates how to use `Option.zipWith` to combine two `Option` values (`maybeName` and `maybeAge`) into a `person` object using a provided function. The function transforms the name to uppercase and combines it with the age.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Option-zipWith.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Option } from \"effect\"\n\nconst maybeName: Option.Option<string> = Option.some(\"John\")\nconst maybeAge: Option.Option<number> = Option.some(25)\n\n// Combine the name and age into a person object\nconst person = Option.zipWith(maybeName, maybeAge, (name, age) => ({\n  name: name.toUpperCase(),\n  age\n}))\n\nconsole.log(person)\n// Output:\n// { _id: 'Option', _tag: 'Some', value: { name: 'JOHN', age: 25 } }\n```\n\n----------------------------------------\n\nTITLE: Adding a Finalizer on Failure in Effect\nDESCRIPTION: Shows how to add a finalizer to an effect that fails. The finalizer logs the exit status after the effect fails, demonstrating how finalizers execute even when effects fail.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-addFinalizer.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Effect, Console } from \"effect\"\n\n//      ┌─── Effect<never, string, Scope>\n//      ▼\nconst program = Effect.gen(function* () {\n  yield* Effect.addFinalizer((exit) =>\n    Console.log(`Finalizer executed. Exit status: ${exit._tag}`)\n  )\n  return yield* Effect.fail(\"Uh oh!\")\n})\n\n// Wrapping the effect in a scope\n//\n//      ┌─── Effect<never, string, never>\n//      ▼\nconst runnable = Effect.scoped(program)\n\nEffect.runPromiseExit(runnable).then(console.log)\n// Output:\n// Finalizer executed. Exit status: Failure\n// {\n//   _id: 'Exit',\n//   _tag: 'Failure',\n//   cause: { _id: 'Cause', _tag: 'Fail', failure: 'Uh oh!' }\n// }\n```\n\n----------------------------------------\n\nTITLE: Using Effect.mapError to Transform Error Types in TypeScript\nDESCRIPTION: Demonstrates how to use Effect.mapError to convert a string error into an Error object. The example shows a simulated task that fails with a string message, then transforms that error while preserving the success value type.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-mapError.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Effect } from \"effect\"\n\n//      ┌─── Effect<number, string, never>\n//      ▼\nconst simulatedTask = Effect.fail(\"Oh no!\").pipe(Effect.as(1))\n\n//      ┌─── Effect<number, Error, never>\n//      ▼\nconst mapped = Effect.mapError(\n  simulatedTask,\n  (message) => new Error(message)\n)\n```\n\n----------------------------------------\n\nTITLE: Implementing orElse Function for Sink in TypeScript\nDESCRIPTION: Defines the orElse function that switches to an alternative sink in case of failure. The function is overloaded to support both curried and non-curried invocation patterns, combining type parameters from both sinks.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Sink-orElse.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const orElse: { <A2, In2, L2, E2, R2>(that: LazyArg<Sink<A2, In2, L2, E2, R2>>): <A, In, L, E, R>(self: Sink<A, In, L, E, R>) => Sink<A2 | A, In & In2, L2 | L, E2 | E, R2 | R>; <A, In, L, E, R, A2, In2, L2, E2, R2>(self: Sink<A, In, L, E, R>, that: LazyArg<Sink<A2, In2, L2, E2, R2>>): Sink<A | A2, In & In2, L | L2, E | E2, R | R2>; }\n```\n\n----------------------------------------\n\nTITLE: Context.merge Type Signature\nDESCRIPTION: Type declaration for the Context.merge function, showing its polymorphic nature and type constraints. Supports merging contexts with different service types.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Context-merge.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const merge: { <R1>(that: Context<R1>): <Services>(self: Context<Services>) => Context<R1 | Services>; <Services, R1>(self: Context<Services>, that: Context<R1>): Context<Services | R1>; }\n```\n\n----------------------------------------\n\nTITLE: Polling Queue for First Value in TypeScript\nDESCRIPTION: The poll function returns the first value in the Queue as a Some<A>, or None if the queue is empty. It operates on a Dequeue<A> and returns an Effect that resolves to an Option<A>.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Queue-poll.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const poll: <A>(self: Dequeue<A>) => Effect.Effect<Option.Option<A>>\n```\n\n----------------------------------------\n\nTITLE: Declaring Option.getOrElse Signature in TypeScript\nDESCRIPTION: This snippet provides the TypeScript type declaration for the Option.getOrElse function, specifying the input parameters and return types for better type safety and IntelliSense.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Option-getOrElse.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const getOrElse: { <B>(onNone: LazyArg<B>): <A>(self: Option<A>) => B | A; <A, B>(self: Option<A>, onNone: LazyArg<B>): A | B; }\n```\n\n----------------------------------------\n\nTITLE: Stream.tap Example in TypeScript\nDESCRIPTION: This example demonstrates how to use `Stream.tap` to add side effects to a stream processing pipeline. It creates a stream of numbers, logs the values before and after mapping, and then collects the results. The `Console.log` effect is used to print the values to the console.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-tap.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Console, Effect, Stream } from \"effect\"\n\nconst stream = Stream.make(1, 2, 3).pipe(\n  Stream.tap((n) => Console.log(`before mapping: ${n}`)),\n  Stream.map((n) => n * 2),\n  Stream.tap((n) => Console.log(`after mapping: ${n}`))\n)\n\nEffect.runPromise(Stream.runCollect(stream)).then(console.log)\n// before mapping: 1\n// after mapping: 2\n// before mapping: 2\n// after mapping: 4\n// before mapping: 3\n// after mapping: 6\n// { _id: 'Chunk', values: [ 2, 4, 6 ] }\n```\n\n----------------------------------------\n\nTITLE: Declaring getOrThrowWith Function Signature in TypeScript\nDESCRIPTION: The `getOrThrowWith` function signature declaration in TypeScript enables extracting a value from an `Option` or throwing a custom error for `None` values using an `onNone` function. This declaration is part of supporting robust error management in applications handling `Option` types.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Option-getOrThrowWith.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const getOrThrowWith: { (onNone: () => unknown): <A>(self: Option<A>) => A; <A>(self: Option<A>, onNone: () => unknown): A; }\n```\n\n----------------------------------------\n\nTITLE: Using Match.orElse for Pattern Matching in TypeScript\nDESCRIPTION: Demonstrates how to use Match.orElse to provide a default fallback value when no patterns match in a pattern matching expression. The example shows matching on string/number values with a specific case for 'a' and a fallback for all other inputs.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Match-orElse.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Match } from \"effect\"\n\n// Create a matcher for string or number values\nconst match = Match.type<string | number>().pipe(\n  // Match when the value is \"a\"\n  Match.when(\"a\", () => \"ok\"),\n  // Fallback when no patterns match\n  Match.orElse(() => \"fallback\")\n)\n\nconsole.log(match(\"a\"))\n// Output: \"ok\"\n\nconsole.log(match(\"b\"))\n// Output: \"fallback\"\n```\n\n----------------------------------------\n\nTITLE: Creating a Dropping Queue in TypeScript with Effect\nDESCRIPTION: Creates a new bounded Queue with a dropping strategy. When the queue reaches capacity, new elements are dropped while existing elements remain. For optimal performance, it's recommended to use power of 2 capacities.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Queue-dropping.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const dropping: <A>(requestedCapacity: number) => Effect.Effect<Queue<A>>\n```\n\n----------------------------------------\n\nTITLE: Polling Elements from MutableQueue\nDESCRIPTION: The 'pollUpTo' function allows users to dequeue up to 'n' elements from the 'MutableQueue'. It returns a list containing the dequeued elements. This function is designed with overload signatures to allow flexible usage, with parameters being the number of elements to dequeue and the queue itself.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/MutableQueue-pollUpTo.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const pollUpTo: { (n: number): <A>(self: MutableQueue<A>) => Chunk.Chunk<A>; <A>(self: MutableQueue<A>, n: number): Chunk.Chunk<A>; }\n```\n\n----------------------------------------\n\nTITLE: Defining the distributedWith Function in TypeScript\nDESCRIPTION: The distributedWith function provides an advanced method for distributing elements from a Stream to multiple queues based on a user-defined decision function. It takes options specifying the size of the distribution, the maximum lag allowed, and the decision criteria, enabling complex distribution logic.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-distributedWith.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const distributedWith: { <N extends number, A>(options: { readonly size: N; readonly maximumLag: number; readonly decide: (a: A) => Effect.Effect<Predicate<number>>; }): <E, R>(self: Stream<A, E, R>) => Effect.Effect<TupleOf<N, Queue.Dequeue<Exit.Exit<A, Option.Option<E>>>>, never, Scope.Scope | R>; <A, E, R, N extends number>(self: Stream<A, E, R>, options: { readonly size: N; readonly maximumLag: number; readonly decide: (a: A) => Effect.Effect<Predicate<number>>; }): Effect.Effect<TupleOf<N, Queue.Dequeue<Exit.Exit<A, Option.Option<E>>>>, never, Scope.Scope | R>; };\n\n```\n\n----------------------------------------\n\nTITLE: Implementing Effect Micro.all Function in TypeScript\nDESCRIPTION: TypeScript declaration for the Micro.all function that executes multiple effects in sequence. It supports both iterable collections and record structures, with options for controlling concurrency and output handling.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Micro-all.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const all: <const Arg extends Iterable<Micro<any, any, any>> | Record<string, Micro<any, any, any>>, O extends NoExcessProperties<{ readonly concurrency?: Concurrency | undefined; readonly discard?: boolean | undefined; }, O>>(arg: Arg, options?: O) => All.Return<Arg, O>\n```\n\n----------------------------------------\n\nTITLE: Creating a Repeat Effect Stream in TypeScript\nDESCRIPTION: This snippet demonstrates how to create a stream using the `Stream.repeatEffect` function from the `effect` library, which generates random integers continuously. The stream collects the first five values and logs them to the console. The required dependencies are the 'effect' library, specifically the Effect, Random, and Stream modules.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-repeatEffect.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Effect, Random, Stream } from \"effect\"\n\nconst stream = Stream.repeatEffect(Random.nextInt)\n\nEffect.runPromise(Stream.runCollect(stream.pipe(Stream.take(5)))).then(console.log)\n// Example Output: { _id: 'Chunk', values: [ 3891571149, 4239494205, 2352981603, 2339111046, 1488052210 ] }\n```\n\n----------------------------------------\n\nTITLE: Creating Stream from Chunk using Effect in TypeScript\nDESCRIPTION: The snippet demonstrates how to create a stream from a chunk of values using the Stream.fromChunk function in the Effect library. Dependencies include the Effect and Stream modules from the Effect library. The function takes a Chunk as input and returns a Stream. It then uses Effect.runPromise to execute the stream and collects the result with Stream.runCollect, which is logged to the console. This example requires Effect library version 2.0.0 or higher.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-fromChunk.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Chunk, Effect, Stream } from \"effect\"\n\n// Creating a stream with values from a single Chunk\nconst stream = Stream.fromChunk(Chunk.make(1, 2, 3))\n\nEffect.runPromise(Stream.runCollect(stream)).then(console.log)\n// { _id: 'Chunk', values: [ 1, 2, 3 ] }\n```\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const fromChunk: <A>(chunk: Chunk.Chunk<A>) => Stream<A>\n```\n\n----------------------------------------\n\nTITLE: Number.clamp Signature in Effect\nDESCRIPTION: This snippet shows the TypeScript declaration for the `Number.clamp` function. It highlights the function's ability to accept options defining the minimum and maximum values, and how it can be used curried or with all arguments at once. The signature clarifies the expected input types and the resulting output type.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Number-clamp.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const clamp: { (options: { minimum: number; maximum: number; }): (self: number) => number; (self: number, options: { minimum: number; maximum: number; }): number; }\n```\n\n----------------------------------------\n\nTITLE: Repeating Effects with Failure Handling in TypeScript\nDESCRIPTION: Shows how to handle failures when repeating effects. The example simulates an action that fails after two successful attempts, demonstrating error handling in repeated effects.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-repeat.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Effect, Schedule } from \"effect\"\n\nlet count = 0\n\n// Define an async effect that simulates an action with possible failures\nconst action = Effect.async<string, string>((resume) => {\n  if (count > 1) {\n    console.log(\"failure\")\n    resume(Effect.fail(\"Uh oh!\"))\n  } else {\n    count++\n    console.log(\"success\")\n    resume(Effect.succeed(\"yay!\"))\n  }\n})\n\nconst policy = Schedule.addDelay(Schedule.recurs(2), () => \"100 millis\")\nconst program = Effect.repeat(action, policy)\n\nEffect.runPromiseExit(program).then(console.log)\n```\n\n----------------------------------------\n\nTITLE: Consuming Stream Elements with Callback - TypeScript\nDESCRIPTION: The `runForEach` function consumes each element from the stream and applies a provided callback function which executes an Effect. It is designed to work seamlessly with the Effect-TS framework, providing both higher-order function support and flexibility in handling stream elements.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-runForEach.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const runForEach: { <A, X, E2, R2>(f: (a: A) => Effect.Effect<X, E2, R2>): <E, R>(self: Stream<A, E, R>) => Effect.Effect<void, E2 | E, R2 | R>; <A, E, R, X, E2, R2>(self: Stream<A, E, R>, f: (a: A) => Effect.Effect<X, E2, R2>): Effect.Effect<void, E | E2, R | R2>; }\n```\n\n----------------------------------------\n\nTITLE: Using STM.acquireUseRelease for Transactional Resource Management in TypeScript\nDESCRIPTION: Defines a function that implements a resource acquisition pattern in Software Transactional Memory (STM). It executes an acquisition transaction interruptibly, uses the resource, then guarantees resource release in an uninterruptible way after usage completes.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/STM-acquireUseRelease.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const acquireUseRelease: { <A, A2, E2, R2, A3, E3, R3>(use: (resource: A) => STM<A2, E2, R2>, release: (resource: A) => STM<A3, E3, R3>): <E, R>(acquire: STM<A, E, R>) => Effect.Effect<A2, E2 | E3 | E, R2 | R3 | R>; <A, E, R, A2, E2, R2, A3, E3, R3>(acquire: STM<A, E, R>, use: (resource: A) => STM<A2, E2, R2>, release: (resource: A) => STM<A3, E3, R3>): Effect.Effect<A2, E | E2 | E3, R | R2 | R3>; }\n```\n\n----------------------------------------\n\nTITLE: Transforming Stream Errors in TypeScript\nDESCRIPTION: The mapError function transforms the errors emitted by a stream using a provided function. It can be used in two ways: as a curried function or with the stream as the first argument.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-mapError.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const mapError: { <E, E2>(f: (error: E) => E2): <A, R>(self: Stream<A, E, R>) => Stream<A, E2, R>; <A, E, R, E2>(self: Stream<A, E, R>, f: (error: E) => E2): Stream<A, E2, R>; }\n```\n\n----------------------------------------\n\nTITLE: Implementing takeWhile Function for Chunk Module in TypeScript\nDESCRIPTION: Defines the takeWhile function which takes elements from a Chunk as long as a predicate returns true. It supports both refinement and predicate functions, and can be used with method chaining or direct invocation.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Chunk-takeWhile.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const takeWhile: {\n  <A, B extends A>(refinement: Refinement<NoInfer<A>, B>): (self: Chunk<A>) => Chunk<B>;\n  <A>(predicate: Predicate<NoInfer<A>>): (self: Chunk<A>) => Chunk<A>;\n  <A, B extends A>(self: Chunk<A>, refinement: Refinement<A, B>): Chunk<B>;\n  <A>(self: Chunk<A>, predicate: Predicate<A>): Chunk<A>;\n}\n```\n\n----------------------------------------\n\nTITLE: Using Effect.findFirst to Find Elements Based on a Condition in TypeScript\nDESCRIPTION: This example demonstrates how to use Effect.findFirst to search through an array of numbers and find the first element that is greater than 3. The function returns an Option containing the found element.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-findFirst.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Effect } from \"effect\"\n\nconst numbers = [1, 2, 3, 4, 5]\nconst predicate = (n: number, i: number) => Effect.succeed(n > 3)\n\nconst program = Effect.gen(function*() {\n  const result = yield* Effect.findFirst(numbers, predicate)\n  console.log(result)\n})\n\nEffect.runFork(program)\n// Output: { _id: 'Option', _tag: 'Some', value: 4 }\n```\n\n----------------------------------------\n\nTITLE: Merging Streams with Tagging - TypeScript\nDESCRIPTION: This code snippet demonstrates how to merge multiple streams into a single stream with tagged values using Effect-TS. It takes a struct of streams and an options object specifying concurrency, returning a single merged stream. Required dependencies include the 'effect' package.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-mergeWithTag.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Stream } from \"effect\"\n// Stream.Stream<{ _tag: \"a\"; value: number; } | { _tag: \"b\"; value: string; }>\nconst res = Stream.mergeWithTag({\n   a: Stream.make(0),\n   b: Stream.make(\"\")\n}, { concurrency: \"unbounded\" })\n```\n\n----------------------------------------\n\nTITLE: Using Effect.ensuring for Guaranteed Cleanup in TypeScript\nDESCRIPTION: Example demonstrating how to use Effect.ensuring to guarantee cleanup operations are performed whether an effect succeeds, fails, or is interrupted. The example shows three scenarios - successful completion, failure, and interruption - each followed by guaranteed cleanup.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-ensuring.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Console, Effect } from \"effect\"\n\n// Define a cleanup effect\nconst handler = Effect.ensuring(Console.log(\"Cleanup completed\"))\n\n// Define a successful effect\nconst success = Console.log(\"Task completed\").pipe(\n  Effect.as(\"some result\"),\n  handler\n)\n\nEffect.runFork(success)\n// Output:\n// Task completed\n// Cleanup completed\n\n// Define a failing effect\nconst failure = Console.log(\"Task failed\").pipe(\n  Effect.andThen(Effect.fail(\"some error\")),\n  handler\n)\n\nEffect.runFork(failure)\n// Output:\n// Task failed\n// Cleanup completed\n\n// Define an interrupted effect\nconst interruption = Console.log(\"Task interrupted\").pipe(\n  Effect.andThen(Effect.interrupt),\n  handler\n)\n\nEffect.runFork(interruption)\n// Output:\n// Task interrupted\n// Cleanup completed\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Function Composition in TypeScript\nDESCRIPTION: This example shows how to use the `compose` function to combine two functions: `increment` and `square`. The composed function first increments a number and then squares the result.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Function-compose.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { compose } from \"effect/Function\"\n\nconst increment = (n: number) => n + 1;\nconst square = (n: number) => n * n;\n\nassert.strictEqual(compose(increment, square)(2), 9);\n```\n\n----------------------------------------\n\nTITLE: Executing Finalizers in Streams - TypeScript\nDESCRIPTION: The 'ensuringWith' function allows developers to specify a finalization action to be executed after the finalizers of a stream in TypeScript. This is crucial for resource management and ensuring clean-up actions occur even when the stream execution fails or completes successfully. Requires a stream and a finalizer callback, and it outputs a new stream that includes the finalizer logic.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-ensuringWith.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const ensuringWith: { <E, R2>(finalizer: (exit: Exit.Exit<unknown, E>) => Effect.Effect<unknown, never, R2>): <A, R>(self: Stream<A, E, R>) => Stream<A, E, R2 | R>; <A, E, R, R2>(self: Stream<A, E, R>, finalizer: (exit: Exit.Exit<unknown, E>) => Effect.Effect<unknown, never, R2>): Stream<A, E, R | R2>; }\n```\n\n----------------------------------------\n\nTITLE: Matching Array Elements with Effect Library in TypeScript\nDESCRIPTION: Demonstrates how to use the Array.match function to handle empty and non-empty array cases. It provides a concise way to apply different functions based on the array's content.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Array-match.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Array } from \"effect\"\n\nconst match = Array.match({\n  onEmpty: () => \"empty\",\n  onNonEmpty: ([head, ...tail]) => `head: ${head}, tail: ${tail.length}`\n})\nconsole.log(match([])) // \"empty\"\nconsole.log(match([1, 2, 3])) // \"head: 1, tail: 2\"\n```\n\n----------------------------------------\n\nTITLE: Declaring the logInfo Function in TypeScript\nDESCRIPTION: Declaration of the logInfo function that logs messages at the INFO level. This function takes any number of message arguments and returns an Effect instance with void as the success type and never as both the error and requirement types.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-logInfo.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const logInfo: (...message: ReadonlyArray<any>) => Effect<void, never, never>\n```\n\n----------------------------------------\n\nTITLE: Using BigDecimal.normalize to Remove Trailing Zeros in TypeScript\nDESCRIPTION: The normalize function removes trailing zeros from BigDecimal values, effectively normalizing their representation. This example demonstrates how normalize treats BigDecimal values created with different methods but representing the same value.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/BigDecimal-normalize.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { normalize, make, unsafeFromString } from \"effect/BigDecimal\"\n\nassert.deepStrictEqual(normalize(unsafeFromString(\"123.00000\")), normalize(make(123n, 0)))\nassert.deepStrictEqual(normalize(unsafeFromString(\"12300000\")), normalize(make(123n, -5)))\n```\n\n----------------------------------------\n\nTITLE: Mapping Records with Effect TS in TypeScript\nDESCRIPTION: This TypeScript snippet demonstrates the use of the 'map' function from the 'effect/Record' module to transform records. It includes examples of applying a simple transformation function and a transformation that uses keys. The 'map' function is part of the Effect TS library, requiring importing from 'effect/Record'. It takes a ReadonlyRecord and a transformation function as inputs, returning a new Record with transformed values.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Record-map.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { map } from \"effect/Record\"\n\nconst f = (n: number) => `-${n}`\n\nassert.deepStrictEqual(map({ a: 3, b: 5 }, f), { a: \"-3\", b: \"-5\" })\n\nconst g = (n: number, key: string) => `${key.toUpperCase()}-${n}`\n\nassert.deepStrictEqual(map({ a: 3, b: 5 }, g), { a: \"A-3\", b: \"B-5\" })\n```\n\n----------------------------------------\n\nTITLE: Transforming Channel Input Elements in TypeScript\nDESCRIPTION: Function signature for mapInputIn, which creates a new channel by applying a transformation function to the input channel's output elements. It supports both curried and uncurried calling styles.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Channel-mapInputIn.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const mapInputIn: { <InElem0, InElem>(f: (a: InElem0) => InElem): <OutElem, OutErr, InErr, OutDone, InDone, Env>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>) => Channel<OutElem, InElem0, OutErr, InErr, OutDone, InDone, Env>; <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, InElem0>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>, f: (a: InElem0) => InElem): Channel<OutElem, InElem0, OutErr, InErr, OutDone, InDone, Env>; }\n```\n\n----------------------------------------\n\nTITLE: Pattern Matching with Match.when in TypeScript\nDESCRIPTION: Demonstrates how to use Match.when for pattern matching against objects with age properties. Shows three scenarios: matching with a predicate function for age > 18, exact value matching for age === 18, and a fallback case for all other values.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Match-when.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Match } from \"effect\"\n\n// Create a matcher for objects with an \"age\" property\nconst match = Match.type<{ age: number }>().pipe(\n  // Match when age is greater than 18\n  Match.when({ age: (age) => age > 18 }, (user) => `Age: ${user.age}`),\n  // Match when age is exactly 18\n  Match.when({ age: 18 }, () => \"You can vote\"),\n  // Fallback case for all other ages\n  Match.orElse((user) => `${user.age} is too young`)\n)\n\nconsole.log(match({ age: 20 }))\n// Output: \"Age: 20\"\n\nconsole.log(match({ age: 18 }))\n// Output: \"You can vote\"\n\nconsole.log(match({ age: 4 }))\n// Output: \"4 is too young\"\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Array.mapAccum in TypeScript\nDESCRIPTION: This example shows how to use the Array.mapAccum function to statefully map over an array, producing new elements and accumulating a state.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Array-mapAccum.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Array } from \"effect\"\n\nconst result = Array.mapAccum([1, 2, 3], 0, (acc, n) => [acc + n, acc + n])\nconsole.log(result) // [6, [1, 3, 6]]\n```\n\n----------------------------------------\n\nTITLE: Practical Example of Array Operations with pipe\nDESCRIPTION: Demonstrates how to use pipe to chain array operations as an alternative to method chaining.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Function-pipe.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { pipe, Array } from \"effect\"\n\npipe(as, Array.map(f), Array.filter(g))\n```\n\n----------------------------------------\n\nTITLE: Number.sign Example\nDESCRIPTION: This example demonstrates how to use the `sign` function from the `effect/Number` module to determine the sign of different numbers. It uses `node:assert` to verify the expected output for negative, zero, and positive numbers. The `sign` function returns -1 for negative numbers, 0 for zero, and 1 for positive numbers.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Number-sign.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { sign } from \"effect/Number\"\n\nassert.deepStrictEqual(sign(-5), -1)\nassert.deepStrictEqual(sign(0), 0)\nassert.deepStrictEqual(sign(5), 1)\n```\n\n----------------------------------------\n\nTITLE: Using Array.flatMapNullable to Filter and Transform Arrays in TypeScript\nDESCRIPTION: This example demonstrates how to use the flatMapNullable function from Effect's Array module to map over an array of numbers and remove even numbers (by returning null for them). The function transforms [1, 2, 3] into [1, 3] by removing null values after mapping.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Array-flatMapNullable.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Array } from \"effect\"\n\nconst result = Array.flatMapNullable([1, 2, 3], n => (n % 2 === 0 ? null : n))\nconsole.log(result) // [1, 3]\n\n// Explanation:\n// The array of numbers [1, 2, 3] is mapped with a function that returns null for even numbers\n// and the number itself for odd numbers. The resulting array [1, null, 3] is then flattened\n// to remove null values, resulting in [1, 3].\n```\n\n----------------------------------------\n\nTITLE: Racing Effects with One Failure in TypeScript\nDESCRIPTION: Example showing racing three effects where one fails and two succeed. Demonstrates how the first successful effect wins.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-raceAll.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Effect, Console } from \"effect\"\n\nconst task1 = Effect.fail(\"task1\").pipe(\n  Effect.delay(\"100 millis\"),\n  Effect.tap(Console.log(\"task1 done\")),\n  Effect.onInterrupt(() => Console.log(\"task1 interrupted\"))\n)\nconst task2 = Effect.succeed(\"task2\").pipe(\n  Effect.delay(\"200 millis\"),\n  Effect.tap(Console.log(\"task2 done\")),\n  Effect.onInterrupt(() => Console.log(\"task2 interrupted\"))\n)\n\nconst task3 = Effect.succeed(\"task3\").pipe(\n  Effect.delay(\"150 millis\"),\n  Effect.tap(Console.log(\"task3 done\")),\n  Effect.onInterrupt(() => Console.log(\"task3 interrupted\"))\n)\n\nconst program = Effect.raceAll([task1, task2, task3])\n\nEffect.runFork(program)\n```\n\n----------------------------------------\n\nTITLE: Stream.scanEffect Signature\nDESCRIPTION: The `scanEffect` function takes an initial state `s` and a function `f` that transforms the state based on each element of the stream. It returns a new stream containing all intermediate state values. The function's type signature defines how it transforms a stream of type `Stream<A, E, R>` to a stream of type `Stream<S, E2 | E, R2 | R>`.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-scanEffect.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const scanEffect: { <S, A, E2, R2>(s: S, f: (s: S, a: A) => Effect.Effect<S, E2, R2>): <E, R>(self: Stream<A, E, R>) => Stream<S, E2 | E, R2 | R>; <A, E, R, S, E2, R2>(self: Stream<A, E, R>, s: S, f: (s: S, a: A) => Effect.Effect<S, E2, R2>): Stream<S, E | E2, R | R2>; }\n```\n\n----------------------------------------\n\nTITLE: Defining contextWithEffect Function in TypeScript\nDESCRIPTION: This snippet defines the contextWithEffect function, which accesses the context and performs an effectful transformation. It takes a function that transforms the context and returns an Effect, allowing for asynchronous or effectful operations.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-contextWithEffect.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const contextWithEffect: <R2, A, E, R>(f: (context: Context.Context<R2>) => Effect<A, E, R>) => Effect<A, E, R | R2>\n```\n\n----------------------------------------\n\nTITLE: Stream.runIntoPubSubScoped Function Definition\nDESCRIPTION: Defines the `runIntoPubSubScoped` function, which takes a `Stream` and a `PubSub` and publishes the stream's elements into the PubSub queue within a scoped effect.  The resulting effect requires a `Scope` to manage the stream's lifecycle.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-runIntoPubSubScoped.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const runIntoPubSubScoped: { <A, E>(pubsub: PubSub.PubSub<Take.Take<A, E>>): <R>(self: Stream<A, E, R>) => Effect.Effect<void, never, Scope.Scope | R>; <A, E, R>(self: Stream<A, E, R>, pubsub: PubSub.PubSub<Take.Take<A, E>>): Effect.Effect<void, never, Scope.Scope | R>; }\n```\n\n----------------------------------------\n\nTITLE: Implementing HashSet Reduction with Effect-TS\nDESCRIPTION: Demonstrates different ways to use HashSet.reduce to sum numbers in a HashSet. Shows three different API styles: data-last (pipeable), method chaining, and data-first approaches. The reduce operation has O(n) time complexity.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/HashSet-reduce.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { HashSet, pipe } from \"effect\"\n\nconst sum = (a: number, b: number): number => a + b\n\n// with `data-last`, a.k.a. `pipeable` API\npipe(HashSet.make(0, 1, 2), HashSet.reduce(0, sum))\n\n// or with the pipe method\nHashSet.make(0, 1, 2).pipe(HashSet.reduce(0, sum))\n\n// or with `data-first` API\nHashSet.reduce(HashSet.make(0, 1, 2), 0, sum)\n```\n\n----------------------------------------\n\nTITLE: Declaring KeyedPool.makeWith Function in TypeScript\nDESCRIPTION: Defines the makeWith function for creating a new KeyedPool. It takes options including an acquire function and a size function, and returns an Effect that produces a KeyedPool. The pool is managed within a Scope and allows configuring pool sizes per key.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/KeyedPool-makeWith.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const makeWith: <K, A, E, R>(options: { readonly acquire: (key: K) => Effect.Effect<A, E, R>; readonly size: (key: K) => number; }) => Effect.Effect<KeyedPool<K, A, E>, never, Scope.Scope | R>\n```\n\n----------------------------------------\n\nTITLE: Effect.fork Type Signature in TypeScript\nDESCRIPTION: Type declaration for the Effect.fork function showing its generic parameters and return type. The function takes an Effect with generic types for result, error, and requirements, returning a new Effect containing a RuntimeFiber.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-fork.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const fork: <A, E, R>(self: Effect<A, E, R>) => Effect<Fiber.RuntimeFiber<A, E>, never, R>\n```\n\n----------------------------------------\n\nTITLE: Partitioning Chunk Elements in TypeScript using Effect\nDESCRIPTION: The separate function takes a Chunk of Either<B, A> and returns a tuple of two Chunks, one containing all A values and the other containing all B values. This function is useful for splitting a chunk based on the Either type.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Chunk-separate.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const separate: <A, B>(self: Chunk<Either<B, A>>) => [Chunk<A>, Chunk<B>]\n```\n\n----------------------------------------\n\nTITLE: Defining scanReduce Function in TypeScript\nDESCRIPTION: The 'scanReduce' function is declared to enable stateful mapping over stream elements, producing intermediate results. It accepts a combining function and can be used in a curried or uncurried form, applicable to the 'Stream' type from the 'effect' package.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-scanReduce.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const scanReduce: { <A2, A>(f: (a2: A2 | A, a: A) => A2): <E, R>(self: Stream<A, E, R>) => Stream<A2 | A, E, R>; <A, E, R, A2>(self: Stream<A, E, R>, f: (a2: A | A2, a: A) => A2): Stream<A | A2, E, R>; }\n```\n\n----------------------------------------\n\nTITLE: Effect.fromNullable Type Signature\nDESCRIPTION: Type signature showing that fromNullable takes a value of type A and returns an Effect that resolves to NonNullable<A> or fails with NoSuchElementException.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-fromNullable.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const fromNullable: <A>(value: A) => Effect<NonNullable<A>, Cause.NoSuchElementException>\n```\n\n----------------------------------------\n\nTITLE: Adding a Finalizer on Success in Effect\nDESCRIPTION: Demonstrates how to add a finalizer to an effect that completes successfully. The finalizer logs the exit status after the effect completes, and the effect is wrapped in a scope to ensure the finalizer executes.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-addFinalizer.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Effect, Console } from \"effect\"\n\n//      ┌─── Effect<string, never, Scope>\n//      ▼\nconst program = Effect.gen(function* () {\n  yield* Effect.addFinalizer((exit) =>\n    Console.log(`Finalizer executed. Exit status: ${exit._tag}`)\n  )\n  return \"some result\"\n})\n\n// Wrapping the effect in a scope\n//\n//      ┌─── Effect<string, never, never>\n//      ▼\nconst runnable = Effect.scoped(program)\n\nEffect.runPromiseExit(runnable).then(console.log)\n// Output:\n// Finalizer executed. Exit status: Success\n// { _id: 'Exit', _tag: 'Success', value: 'some result' }\n```\n\n----------------------------------------\n\nTITLE: Creating a Sink from an Effect in TypeScript\nDESCRIPTION: The unwrap function creates a sink from an effect that produces a sink. This is useful for dynamically creating sinks based on runtime values or conditional logic.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Sink-unwrap.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const unwrap: <A, In, L, E2, R2, E, R>(effect: Effect.Effect<Sink<A, In, L, E2, R2>, E, R>) => Sink<A, In, L, E2 | E, R2 | R>\n```\n\n----------------------------------------\n\nTITLE: Defining Differ Interface in TypeScript\nDESCRIPTION: TypeScript interface definition for Differ<Value, Patch>, which provides methods for comparing values, combining patches, and applying patches to values. The interface includes type parameters for Value and Patch types.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Differ-Differ.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface Differ<in out Value, in out Patch> extends Pipeable {\n  readonly [TypeId]: {\n    readonly _V: Types.Invariant<Value>\n    readonly _P: Types.Invariant<Patch>\n  }\n  readonly empty: Patch\n  diff(oldValue: Value, newValue: Value): Patch\n  combine(first: Patch, second: Patch): Patch\n  patch(patch: Patch, oldValue: Value): Value\n}\n```\n\n----------------------------------------\n\nTITLE: Lazily Constructing Configs in TypeScript using suspend\nDESCRIPTION: The suspend function creates a lazy configuration by accepting a function that returns a Config. This allows for on-demand configuration evaluation and helps with handling circular dependencies in configurations.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Config-suspend.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const suspend: <A>(config: LazyArg<Config<A>>) => Config<A>\n```\n\n----------------------------------------\n\nTITLE: Updating Service Implementation in Effect Layer\nDESCRIPTION: A function that modifies existing service implementations in the context. It takes a service tag, transformation function, and layer as inputs, returning a new layer with the updated service. The function supports both curried and non-curried calling patterns.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Layer-updateService.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const updateService: (<I, A>(tag: Context.Tag<I, A>, f: (a: A) => A) => <A1, E1, R1>(layer: Layer<A1, E1, R1>) => Layer<A1, E1, I | R1>) & (<A1, E1, R1, I, A>(layer: Layer<A1, E1, R1>, tag: Context.Tag<I, A>, f: (a: A) => A) => Layer<A1, E1, I | R1>)\n```\n\n----------------------------------------\n\nTITLE: Type-checking Effect Values in TypeScript\nDESCRIPTION: A function that checks if a given value is an Effect value. This utility can be used to validate the type of a value before attempting to use it as an Effect value in operations that require this specific type.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-isEffect.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const isEffect: (u: unknown) => u is Effect<unknown, unknown, unknown>\n```\n\n----------------------------------------\n\nTITLE: Filtering Cause Objects with Predicates or Refinements in TypeScript\nDESCRIPTION: This function preserves parts of a Cause structure that match a given predicate or refinement. It allows retaining only specific types of errors, defects, or interruptions from a Cause while discarding unrelated parts. The function can be used with either a Predicate for general filtering or a Refinement for type-specific filtering.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Cause-filter.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const filter: { <E, EB extends E>(refinement: Refinement<Cause<NoInfer<E>>, Cause<EB>>): (self: Cause<E>) => Cause<EB>; <E>(predicate: Predicate<Cause<NoInfer<E>>>): (self: Cause<E>) => Cause<E>; <E, EB extends E>(self: Cause<E>, refinement: Refinement<Cause<E>, Cause<EB>>): Cause<EB>; <E>(self: Cause<E>, predicate: Predicate<Cause<E>>): Cause<E>; }\n```\n\n----------------------------------------\n\nTITLE: Defining Stream.haltAfter Function in TypeScript\nDESCRIPTION: Declares the haltAfter function, which is a specialized version of haltWhen. It halts the evaluation of a stream after a given duration. The function does not interrupt an element in the process of being pulled when the duration completes.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-haltAfter.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const haltAfter: { (duration: Duration.DurationInput): <A, E, R>(self: Stream<A, E, R>) => Stream<A, E, R>; <A, E, R>(self: Stream<A, E, R>, duration: Duration.DurationInput): Stream<A, E, R>; }\n```\n\n----------------------------------------\n\nTITLE: Creating DateTime Objects Using DateTime.make in Effect Library (TypeScript)\nDESCRIPTION: Examples of using the DateTime.make function from the effect package to create DateTime objects from different input sources. This function accepts a Date instance, an object with date parts, or a string that can be parsed as a date, and returns an Option<DateTime>.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/DateTime-make.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { DateTime } from \"effect\"\n\n// from Date\nDateTime.make(new Date())\n\n// from parts\nDateTime.make({ year: 2024 })\n\n// from string\nDateTime.make(\"2024-01-01\")\n```\n\n----------------------------------------\n\nTITLE: Decoding Base64 Strings to Uint8Array in TypeScript\nDESCRIPTION: Function that decodes a base64 (RFC4648) encoded string into a Uint8Array. Returns an Either type that contains either the successful Uint8Array result or a DecodeException on failure.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Encoding-decodeBase64.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const decodeBase64: (str: string) => Either.Either<Uint8Array, DecodeException>\n```\n\n----------------------------------------\n\nTITLE: Creating an Option with a Value in Effect (TypeScript)\nDESCRIPTION: Demonstrates how to use `Option.some` to create an `Option` instance that holds a value.  The example shows how to import the `Option` module from the `effect` library and then use `Option.some` to wrap the number 1.  The resulting `Option` instance represents the presence of the value 1.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Option-some.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Option } from \"effect\"\n\n// An Option holding the number 1\n//\n//      ┌─── Option<number>\n//      ▼\nconst value = Option.some(1)\n\nconsole.log(value)\n// Output: { _id: 'Option', _tag: 'Some', value: 1 }\n```\n\n----------------------------------------\n\nTITLE: TypeScript Type Signature for Effect.flatMap\nDESCRIPTION: Shows the type signature of the flatMap function in TypeScript, including its overloaded implementations and generic type parameters for proper type inference.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-flatMap.md#2025-04-11_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const flatMap: { <A, B, E1, R1>(f: (a: A) => Effect<B, E1, R1>): <E, R>(self: Effect<A, E, R>) => Effect<B, E1 | E, R1 | R>; <A, E, R, B, E1, R1>(self: Effect<A, E, R>, f: (a: A) => Effect<B, E1, R1>): Effect<B, E | E1, R | R1>; }\n```\n\n----------------------------------------\n\nTITLE: Signature Declaration for GroupByKey Function in TypeScript\nDESCRIPTION: This TypeScript snippet displays the TypeScript signature for the 'groupByKey' function, which partitions a stream based on a provided key function. It is capable of handling options like buffering. The function takes a stream and a key extraction function as parameters and returns a 'GroupBy' object.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-groupByKey.md#2025-04-11_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const groupByKey: { <A, K>(f: (a: A) => K, options?: { readonly bufferSize?: number | undefined; }): <E, R>(self: Stream<A, E, R>) => GroupBy.GroupBy<K, A, E, R>; <A, E, R, K>(self: Stream<A, E, R>, f: (a: A) => K, options?: { readonly bufferSize?: number | undefined; }): GroupBy.GroupBy<K, A, E, R>; }\n```\n\n----------------------------------------\n\nTITLE: Creating a Tagged Struct with Effect Schema\nDESCRIPTION: This example demonstrates how to use `Schema.tag` to create a tagged struct named `User` with properties for name and age. The `_tag` property is assigned the value \"User\" using `Schema.tag(\"User\")`. The `make` method is then used to create an instance of the `User` struct, automatically including the `_tag` property.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Schema-tag.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { Schema } from \"effect\"\n\nconst User = Schema.Struct({\n  _tag: Schema.tag(\"User\"),\n  name: Schema.String,\n  age: Schema.Number\n})\n\nassert.deepStrictEqual(User.make({ name: \"John\", age: 44 }), { _tag: \"User\", name: \"John\", age: 44 })\n\n```\n\n----------------------------------------\n\nTITLE: Implementing TQueue.seek Function in TypeScript for STM Operations\nDESCRIPTION: This function drops elements from a queue while they don't satisfy a predicate condition, returning the first element that does satisfy it. It retries if no elements match the predicate. The function supports both curried and non-curried usage patterns.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TQueue-seek.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const seek: { <A>(predicate: Predicate<A>): (self: TDequeue<A>) => STM.STM<A>; <A>(self: TDequeue<A>, predicate: Predicate<A>): STM.STM<A>; }\n```\n\n----------------------------------------\n\nTITLE: Using filterMapWhile to transform array elements until condition fails\nDESCRIPTION: This example demonstrates how to use the filterMapWhile function to transform array elements (squaring even numbers) until encountering an odd number, at which point processing stops. The function combines filtering and mapping operations in a single pass with short-circuit behavior.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Array-filterMapWhile.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Array, Option } from \"effect\"\n\nconst toSquareTillOdd = (x: number) => x % 2 === 0 ? Option.some(x * x) : Option.none()\n\nconst result = Array.filterMapWhile([2, 4, 5], toSquareTillOdd)\nconsole.log(result) // [4, 16]\n```\n\n----------------------------------------\n\nTITLE: Constructing a Layer with Layer.succeed in TypeScript\nDESCRIPTION: The Layer.succeed function is used to construct a layer from a specified value. It has two overloads: one that takes a tag and returns a function expecting a resource, and another that takes both a tag and a resource directly.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Layer-succeed.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const succeed: {\n  <I, S>(tag: Context.Tag<I, S>): (resource: Types.NoInfer<S>) => Layer<I>;\n  <I, S>(tag: Context.Tag<I, S>, resource: Types.NoInfer<S>): Layer<I>;\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Fixed-Size Keyed Pool in Effect-TS\nDESCRIPTION: Creates a new pool with fixed size where resources are keyed by type K. The pool's lifetime is governed by a Scope, and when shutdown, allocated items are released in an unspecified order. The acquire function is used to create new resources for given keys.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/KeyedPool-make.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const make: <K, A, E, R>(options: { readonly acquire: (key: K) => Effect.Effect<A, E, R>; readonly size: number; }) => Effect.Effect<KeyedPool<K, A, E>, never, Scope.Scope | R>\n```\n\n----------------------------------------\n\nTITLE: Defining forEach Function for List Module in TypeScript\nDESCRIPTION: Declares the forEach function that applies a specified function to each element of a List. It supports both curried and uncurried versions of the function.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/List-forEach.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const forEach: { <A, B>(f: (a: A) => B): (self: List<A>) => void; <A, B>(self: List<A>, f: (a: A) => B): void; }\n```\n\n----------------------------------------\n\nTITLE: Using Effect.mapInputContext with Service Dependencies in TypeScript\nDESCRIPTION: Demonstrates how to use Effect.mapInputContext to transform context requirements and provide services. Shows creation of service tags, generating an effect program, and mapping input context to provide partial service dependencies.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-mapInputContext.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Context, Effect } from \"effect\"\n\nclass Service1 extends Context.Tag(\"Service1\")<Service1, { readonly port: number }>() {}\nclass Service2 extends Context.Tag(\"Service2\")<Service2, { readonly connection: string }>() {}\n\nconst program = Effect.gen(function*() {\n  const service1 = yield* Service1\n  console.log(service1.port)\n  const service2 = yield* Service2\n  console.log(service2.connection)\n  return \"some result\"\n})\n\n//      ┌─── Effect<string, never, Service2>\n//      ▼\nconst programWithService1 = Effect.mapInputContext(\n  program,\n  (ctx: Context.Context<Service2>) => Context.add(ctx, Service1, { port: 3000 })\n)\n\nconst runnable = programWithService1.pipe(\n  Effect.provideService(Service2, { connection: \"localhost\" }),\n  Effect.provideService(Service1, { port: 3001 })\n)\n\nEffect.runPromise(runnable)\n// Output:\n// 3000\n// localhost\n```\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const mapInputContext: { <R2, R>(f: (context: Context.Context<R2>) => Context.Context<R>): <A, E>(self: Effect<A, E, R>) => Effect<A, E, R2>; <A, E, R, R2>(self: Effect<A, E, R>, f: (context: Context.Context<R2>) => Context.Context<R>): Effect<A, E, R2>; }\n```\n\n----------------------------------------\n\nTITLE: Using Array.partitionMap in TypeScript with Effect-TS\nDESCRIPTION: Demonstrates how to use the Array.partitionMap function to separate an array of numbers into even and odd numbers using Either.right and Either.left.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Array-partitionMap.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Array, Either } from \"effect\";\n\nconst isEven = (x: number) => x % 2 === 0\n\nconst result = Array.partitionMap([1, 2, 3, 4, 5], x =>\n  isEven(x) ? Either.right(x) : Either.left(x)\n)\nconsole.log(result)\n// [\n//   [1, 3, 5],\n//   [2, 4]\n// ]\n```\n\n----------------------------------------\n\nTITLE: Defining Cache Interface in TypeScript\nDESCRIPTION: Declares the Cache interface with methods for retrieving, refreshing, and setting cache values. It includes concurrent access safety and handles cache capacity and time-to-live constraints.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Cache-Cache.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface Cache<in out Key, in out Value, out Error = never>\n  extends ConsumerCache<Key, Value, Error>, Cache.Variance<Key, Value, Error>\n{\n  /**\n   * Retrieves the value associated with the specified key if it exists.\n   * Otherwise computes the value with the lookup function, puts it in the\n   * cache, and returns it.\n   */\n  get(key: Key): Effect.Effect<Value, Error>\n\n  /**\n   * Retrieves the value associated with the specified key if it exists as a left.\n   * Otherwise computes the value with the lookup function, puts it in the\n   * cache, and returns it as a right.\n   */\n  getEither(key: Key): Effect.Effect<Either<Value, Value>, Error>\n\n  /**\n   * Computes the value associated with the specified key, with the lookup\n   * function, and puts it in the cache. The difference between this and\n   * `get` method is that `refresh` triggers (re)computation of the value\n   * without invalidating it in the cache, so any request to the associated\n   * key can still be served while the value is being re-computed/retrieved\n   * by the lookup function. Additionally, `refresh` always triggers the\n   * lookup function, disregarding the last `Error`.\n   */\n  refresh(key: Key): Effect.Effect<void, Error>\n\n  /**\n   * Associates the specified value with the specified key in the cache.\n   */\n  set(key: Key, value: Value): Effect.Effect<void>\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Basic Tagged Enum Constructor in TypeScript\nDESCRIPTION: An example showing how to create a tagged enum constructor for HTTP error types with status codes and messages using the Data.taggedEnum function.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Data-taggedEnum.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Data } from \"effect\"\n\nconst { BadRequest, NotFound } = Data.taggedEnum<\n  | { readonly _tag: \"BadRequest\"; readonly status: 400; readonly message: string }\n  | { readonly _tag: \"NotFound\"; readonly status: 404; readonly message: string }\n>()\n\nconst notFound = NotFound({ status: 404, message: \"Not Found\" })\n```\n\n----------------------------------------\n\nTITLE: Checking Option for None with Effect in TypeScript\nDESCRIPTION: This code snippet demonstrates how to use the `Option.isNone` function from the Effect library to check if an `Option` instance represents the absence of a value (`None`). It imports the `Option` module and then uses `Option.isNone` with both `Option.some(1)` and `Option.none()` to illustrate the function's behavior, printing the results to the console.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Option-isNone.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Option } from \"effect\"\n\nconsole.log(Option.isNone(Option.some(1)))\n// Output: false\n\nconsole.log(Option.isNone(Option.none()))\n// Output: true\n```\n\n----------------------------------------\n\nTITLE: Using Record.collect in TypeScript\nDESCRIPTION: Demonstrates how to use the collect function from the Record module to transform the values of a record into an Array with a custom mapping function.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Record-collect.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { collect } from \"effect/Record\"\n\nconst x = { a: 1, b: 2, c: 3 }\nassert.deepStrictEqual(collect(x, (key, n) => [key, n]), [[\"a\", 1], [\"b\", 2], [\"c\", 3]])\n```\n\n----------------------------------------\n\nTITLE: Formatting DateTime with System's Local Time Zone and Locale\nDESCRIPTION: The formatLocal function formats a DateTime object as a string using the Intl.DateTimeFormat API. It uses the system's local time zone and locale by default, but allows customization through options parameter. Introduced in version 3.6.0.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/DateTime-formatLocal.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const formatLocal: { (options?: (Intl.DateTimeFormatOptions & { readonly locale?: string | undefined; }) | undefined): (self: DateTime) => string; (self: DateTime, options?: (Intl.DateTimeFormatOptions & { readonly locale?: string | undefined; }) | undefined): string; }\n```\n\n----------------------------------------\n\nTITLE: Creating an Empty Stream with Effect.js - TypeScript\nDESCRIPTION: Defines an empty stream using the Effect.js library, demonstrating how to import necessary modules and run a promise that collects the results from the empty stream. The expected output is a chunk with no values, showcasing the functionality of Stream.empty.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-empty.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Effect, Stream } from \"effect\"\n\nconst stream = Stream.empty\n\nEffect.runPromise(Stream.runCollect(stream)).then(console.log)\n// { _id: 'Chunk', values: [] }\n```\n\n----------------------------------------\n\nTITLE: Extracting Schema with UrlParams in TypeScript\nDESCRIPTION: This TypeScript snippet demonstrates the use of `UrlParams.schemaStruct` from the `@effect/platform` package. The function extracts and transforms schemas from a set of URL parameters. Dependencies include the `Effect` and `Schema` modules, and `node:assert` for assertions. Key inputs are the schema definition and URL parameters, while outputs include transformed schema objects. Note that it operates within an Effect context, handling errors gracefully.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/UrlParams-schemaStruct.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { Effect, Schema } from \"effect\"\nimport { UrlParams } from \"@effect/platform\"\n\nEffect.gen(function* () {\n  const urlParams = UrlParams.fromInput({ \"a\": [10, \"string\"], \"b\": false })\n  const result = yield* UrlParams.schemaStruct(Schema.Struct({\n    a: Schema.Tuple(Schema.NumberFromString, Schema.String),\n    b: Schema.BooleanFromString\n  }))(urlParams)\n\n  assert.deepStrictEqual(result, {\n    a: [10, \"string\"],\n    b: false\n  })\n})\n```\n\n----------------------------------------\n\nTITLE: Effect.map Function Signature in TypeScript\nDESCRIPTION: Provides the TypeScript type signature for the Effect.map function. It shows the function's polymorphic nature, allowing it to work with different effect types and transformation functions.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-map.md#2025-04-11_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const map: { <A, B>(f: (a: A) => B): <E, R>(self: Effect<A, E, R>) => Effect<B, E, R>; <A, E, R, B>(self: Effect<A, E, R>, f: (a: A) => B): Effect<B, E, R>; }\n```\n\n----------------------------------------\n\nTITLE: Filtering HashSet with Refinement in TypeScript\nDESCRIPTION: Example of refining a HashSet of mixed values to extract only strings using a type refinement function. Demonstrates three different syntax approaches: data-last (pipeable) API, pipe method, and data-first API.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/HashSet-filter.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n/// Syntax with Refinement\nimport { HashSet, pipe } from \"effect\"\n\nconst stringRefinement = (value: unknown): value is string =>\n  typeof value === \"string\"\n\n// with `data-last`, a.k.a. `pipeable` API\npipe(\n  HashSet.make(1, \"unos\", 2, \"two\", 3, \"trois\", 4, \"vier\"), // // HashSet.HashSet<number | string>\n  HashSet.filter(stringRefinement)\n) // HashSet.HashSet<string>\n\n// or with the pipe method\nHashSet.make(1, \"unos\", 2, \"two\", 3, \"trois\", 4, \"vier\") // HashSet.HashSet<number | string>\n  .pipe(HashSet.filter(stringRefinement)) // HashSet.HashSet<string>\n\n// or with `data-first` API\nHashSet.filter(\n  HashSet.make(1, \"unos\", 2, \"two\", 3, \"trois\", 4, \"vier\"), // HashSet.HashSet<number | string>\n  stringRefinement\n) // HashSet.HashSet<string>\n```\n\n----------------------------------------\n\nTITLE: PlatformLogger.toFile Example in Effect\nDESCRIPTION: This example demonstrates how to create a file logger using `PlatformLogger.toFile` and integrate it into an Effect application. It defines a logger that writes to `/tmp/log.txt`, replaces the default logger with it, and logs messages to the file. The example requires `@effect/platform`, `@effect/platform-node`, and `effect` packages as dependencies.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/PlatformLogger-toFile.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { PlatformLogger } from \"@effect/platform\"\nimport { NodeFileSystem, NodeRuntime } from \"@effect/platform-node\"\nimport { Effect, Layer, Logger } from \"effect\"\n\nconst fileLogger = Logger.logfmtLogger.pipe(\n  PlatformLogger.toFile(\"/tmp/log.txt\")\n)\nconst LoggerLive = Logger.replaceScoped(Logger.defaultLogger, fileLogger).pipe(\n  Layer.provide(NodeFileSystem.layer)\n)\n\nEffect.log(\"a\").pipe(\n  Effect.zipRight(Effect.log(\"b\")),\n  Effect.zipRight(Effect.log(\"c\")),\n  Effect.provide(LoggerLive),\n  NodeRuntime.runMain\n)\n```\n\n----------------------------------------\n\nTITLE: Combining Numbers Using SemigroupSum in TypeScript\nDESCRIPTION: This snippet demonstrates the use of SemigroupSum to combine two numbers through addition. It imports the SemigroupSum from the Effect library, allowing the combination operation to be performed. The example combines the numbers 2 and 3, returning the result 5.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/data-Number-SemigroupSum.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { SemigroupSum } from \"@effect/typeclass/data/Number\"\n\nconsole.log(SemigroupSum.combine(2, 3))\n// 5\n```\n\n----------------------------------------\n\nTITLE: Using Either.isRight to Check Either Types in TypeScript\nDESCRIPTION: Demonstrates how to use the `isRight` function to determine if an Either instance is a Right value. The example shows both true and false cases with assertion testing.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Either-isRight.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { Either } from \"effect\"\n\nassert.deepStrictEqual(Either.isRight(Either.right(1)), true)\nassert.deepStrictEqual(Either.isRight(Either.left(\"a\")), false)\n```\n\n----------------------------------------\n\nTITLE: Using Effect.log for Logging Messages and Error Causes in TypeScript\nDESCRIPTION: This example demonstrates how to use the Effect.log function to log multiple messages and error causes at the INFO level. The function handles various inputs including strings and Cause objects, displaying them with metadata like timestamp, log level, and fiber ID.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-log.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Cause, Effect } from \"effect\"\n\nconst program = Effect.log(\n  \"message1\",\n  \"message2\",\n  Cause.die(\"Oh no!\"),\n  Cause.die(\"Oh uh!\")\n)\n\nEffect.runFork(program)\n// Output:\n// timestamp=... level=INFO fiber=#0 message=message1 message=message2 cause=\"Error: Oh no!\n// Error: Oh uh!\"\n```\n\n----------------------------------------\n\nTITLE: Implementing Error Tracking Aspect in Effect.IO\nDESCRIPTION: Defines a trackError function that creates an aspect to monitor and update metrics when effects fail. It works with generic types for the error value and allows tracking of failures across effect chains.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Metric-trackError.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const trackError: { \n  <Type, In, Out>(metric: Metric<Type, In, Out>): <A, E extends In, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>; \n  <A, E extends In, R, Type, In, Out>(self: Effect.Effect<A, E, R>, metric: Metric<Type, In, Out>): Effect.Effect<A, E, R>; \n}\n```\n\n----------------------------------------\n\nTITLE: Replacing URL String in TypeScript\nDESCRIPTION: The `setHref` function serves to overwrite the current URL string entirely. It offers a higher-order function that accepts a string representing the new URL and returns a function to update the URL object. Dependencies include the `URL` class, and key parameters are `href` for the new URL string and `url` as the URL object being updated. The operation involves updating the `href` component of the URL, with constraints being compatibility since version 1.0.0.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Url-setHref.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const setHref: { (href: string): (url: URL) => URL; (url: URL, href: string): URL; }\n```\n\n----------------------------------------\n\nTITLE: Implementing Sequential Sink Execution with flatMap in TypeScript\nDESCRIPTION: The flatMap function runs a sink until it yields a result, then uses that result to create and run another sink. It effectively enables sequential execution of sinks, with each subsequent sink potentially depending on the result of the previous one.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Sink-flatMap.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const flatMap: { <A, A1, In, In1 extends In, L1, E1, R1>(f: (a: A) => Sink<A1, In1, L1, E1, R1>): <L, E, R>(self: Sink<A, In, L, E, R>) => Sink<A1, In & In1, L1 | L, E1 | E, R1 | R>; <A, In, L, E, R, A1, In1 extends In, L1, E1, R1>(self: Sink<A, In, L, E, R>, f: (a: A) => Sink<A1, In1, L1, E1, R1>): Sink<A1, In & In1, L | L1, E | E1, R | R1>; }\n```\n\n----------------------------------------\n\nTITLE: Implementing Batched Logging with Effect Logger\nDESCRIPTION: Demonstrates how to create a batched logger that collects log messages over a specified time window and processes them together. The example shows grouping logs for 500 milliseconds before outputting them as a batch.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Logger-batched.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Console, Effect, Logger } from \"effect\"\n\nconst LoggerLive = Logger.replaceScoped(\n  Logger.defaultLogger,\n  Logger.logfmtLogger.pipe(\n    Logger.batched(\"500 millis\", (messages) => Console.log(\"BATCH\", `[\\n${messages.join(\"\\n\")}\\n]`))\n  )\n)\n\nconst program = Effect.gen(function*() {\n  yield* Effect.log(\"one\")\n  yield* Effect.log(\"two\")\n  yield* Effect.log(\"three\")\n}).pipe(Effect.provide(LoggerLive))\n\nEffect.runFork(program)\n// BATCH [\n// timestamp=... level=INFO fiber=#0 message=one\n// timestamp=... level=INFO fiber=#0 message=two\n// timestamp=... level=INFO fiber=#0 message=three\n// ]\n```\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const batched: { <Output, R>(window: DurationInput, f: (messages: Array<Types.NoInfer<Output>>) => Effect<void, never, R>): <Message>(self: Logger<Message, Output>) => Effect<Logger<Message, void>, never, R | Scope>; <Message, Output, R>(self: Logger<Message, Output>, window: DurationInput, f: (messages: Array<Types.NoInfer<Output>>) => Effect<void, never, R>): Effect<Logger<Message, void>, never, Scope | R>; }\n```\n\n----------------------------------------\n\nTITLE: Implementing Atomic Map Transformation with transformSTM in TypeScript\nDESCRIPTION: The transformSTM function atomically updates all bindings in a TMap using a transactional function. It takes a transformation function that processes each key-value pair and returns a new key-value tuple within an STM transaction context.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TMap-transformSTM.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const transformSTM: { <K, V, R, E>(f: (key: K, value: V) => STM.STM<readonly [K, V], E, R>): (self: TMap<K, V>) => STM.STM<void, E, R>; <K, V, R, E>(self: TMap<K, V>, f: (key: K, value: V) => STM.STM<readonly [K, V], E, R>): STM.STM<void, E, R>; }\n```\n\n----------------------------------------\n\nTITLE: Implementing Effect.Latch Interface in TypeScript\nDESCRIPTION: The interface definition for Effect.Latch, a synchronization primitive that controls fiber execution based on open/closed state. It extends Effect<void> and provides methods to open, close, await, and conditionally execute operations based on the latch state.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-Latch.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface Latch extends Effect<void> {\n  /**\n   * Opens the latch, releasing all fibers waiting on it.\n   *\n   * **Details**\n   *\n   * Once the latch is opened, it remains open. Any fibers waiting on `await`\n   * will be released and can continue execution.\n   */\n  readonly open: Effect<void>\n\n  /**\n   * Opens the latch, releasing all fibers waiting on it.\n   *\n   * **Details**\n   *\n   * Once the latch is opened, it remains open. Any fibers waiting on `await`\n   * will be released and can continue execution.\n   */\n  readonly unsafeOpen: () => void\n\n  /**\n   * Releases all fibers waiting on the latch without opening it.\n   *\n   * **Details**\n   *\n   * This function lets waiting fibers proceed without permanently changing the\n   * state of the latch.\n   */\n  readonly release: Effect<void>\n\n  /**\n   * Waits for the latch to be opened.\n   *\n   * **Details**\n   *\n   * If the latch is already open, this effect completes immediately. Otherwise,\n   * it suspends the fiber until the latch is opened.\n   */\n  readonly await: Effect<void>\n\n  /**\n   * Closes the latch, blocking fibers from proceeding.\n   *\n   * **Details**\n   *\n   * This operation puts the latch into a closed state, requiring it to be\n   * reopened before waiting fibers can proceed.\n   */\n  readonly close: Effect<void>\n\n  /**\n   * Unsafely closes the latch, blocking fibers without effect guarantees.\n   *\n   * **Details**\n   *\n   * Use this operation cautiously, as it does not run within an effect context\n   * and bypasses runtime guarantees.\n   */\n  readonly unsafeClose: () => void\n\n  /**\n   * Runs the given effect only when the latch is open.\n   *\n   * **Details**\n   *\n   * This function ensures that the provided effect executes only if the latch\n   * is open. If the latch is closed, the fiber will wait until it opens.\n   */\n  readonly whenOpen: <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R>\n\n  readonly [Unify.typeSymbol]?: unknown\n  readonly [Unify.unifySymbol]?: LatchUnify<this>\n  readonly [Unify.ignoreSymbol]?: LatchUnifyIgnore\n}\n```\n\n----------------------------------------\n\nTITLE: Creating and Using a FiberSet in TypeScript with Effect Library\nDESCRIPTION: This example demonstrates how to create a FiberSet, add fibers to it using FiberSet.run, and ensure automatic interruption of fibers when the scope closes. It uses Effect.gen for generating effects and Effect.scoped for managing the lifecycle.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/FiberSet-make.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Effect, FiberSet } from \"effect\"\n\nEffect.gen(function*() {\n  const set = yield* FiberSet.make()\n\n  // run some effects and add the fibers to the set\n  yield* FiberSet.run(set, Effect.never)\n  yield* FiberSet.run(set, Effect.never)\n\n  yield* Effect.sleep(1000)\n}).pipe(\n  Effect.scoped // The fibers will be interrupted when the scope is closed\n)\n```\n\n----------------------------------------\n\nTITLE: Implementing Option.orElse Method in TypeScript\nDESCRIPTION: The `orElse` method returns a fallback `Option` when the current `Option` is `None`, allowing for graceful handling of absent values. Depending on the presence of a value in the current `Option`, it either returns itself or evaluates a provided fallback function to retrieve another `Option`.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Option-orElse.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Option } from \"effect\"\n\nconsole.log(Option.none().pipe(Option.orElse(() => Option.none())))\n// Output: { _id: 'Option', _tag: 'None' }\n\nconsole.log(Option.some(\"a\").pipe(Option.orElse(() => Option.none())))\n// Output: { _id: 'Option', _tag: 'Some', value: 'a' }\n\nconsole.log(Option.none().pipe(Option.orElse(() => Option.some(\"b\"))))\n// Output: { _id: 'Option', _tag: 'Some', value: 'b' }\n\nconsole.log(Option.some(\"a\").pipe(Option.orElse(() => Option.some(\"b\"))))\n// Output: { _id: 'Option', _tag: 'Some', value: 'a' }\n```\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const orElse: { <B>(that: LazyArg<Option<B>>): <A>(self: Option<A>) => Option<B | A>; <A, B>(self: Option<A>, that: LazyArg<Option<B>>): Option<A | B>; }\n```\n\n----------------------------------------\n\nTITLE: Filtering an Array with Effect.filter in TypeScript\nDESCRIPTION: This example demonstrates how to use Effect.filter to filter an array of numbers, keeping only the even numbers. It uses an effectful predicate and runs the effect using Effect.runFork.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-filter.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Effect } from \"effect\"\n\nconst numbers = [1, 2, 3, 4, 5]\nconst predicate = (n: number, i: number) => Effect.succeed(n % 2 === 0)\n\nconst program = Effect.gen(function*() {\n  const result = yield* Effect.filter(numbers, predicate)\n  console.log(result)\n})\n\nEffect.runFork(program)\n// Output: [2, 4]\n```\n\n----------------------------------------\n\nTITLE: Testing String Type with Effect-TS isString Function\nDESCRIPTION: Demonstrates how to use the String.isString utility function to check if a value is of type string. The function returns true for string values and false for non-string values, providing type-safe string checking.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/String-isString.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { String } from \"effect\"\n\nassert.deepStrictEqual(String.isString(\"a\"), true)\nassert.deepStrictEqual(String.isString(1), false)\n```\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const isString: Refinement<unknown, string>\n```\n\n----------------------------------------\n\nTITLE: Defining randomWith Function in TypeScript for Effect Library\nDESCRIPTION: This snippet defines the randomWith function, which takes a function that uses the Random service and returns an Effect. It retrieves the Random service from the context and applies it to the provided function.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-randomWith.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const randomWith: <A, E, R>(f: (random: Random.Random) => Effect<A, E, R>) => Effect<A, E, R>\n```\n\n----------------------------------------\n\nTITLE: Using vsep Combinator with Alignment in @effect/printer (TypeScript)\nDESCRIPTION: Demonstrates how to use the `vsep` combinator to concatenate documents vertically. The example shows both unaligned and aligned usage, where `align` is used to align the documents under their first element.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Doc-vsep.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport * as Doc from \"@effect/printer/Doc\"\nimport * as String from \"effect/String\"\n\nconst unaligned = Doc.hsep([\n  Doc.text(\"prefix\"),\n  Doc.vsep(Doc.words(\"text to lay out\"))\n])\n\nassert.strictEqual(\n  Doc.render(unaligned, { style: \"pretty\" }),\n  String.stripMargin(\n    `|prefix text\n     |to\n     |lay\n     |out`\n  )\n)\n\n// The `align` function can be used to align the documents under their first\n// element\nconst aligned = Doc.hsep([\n  Doc.text(\"prefix\"),\n  Doc.align(Doc.vsep(Doc.words(\"text to lay out\")))\n])\n\nassert.strictEqual(\n  Doc.render(aligned, { style: \"pretty\" }),\n  String.stripMargin(\n    `|prefix text\n     |       to\n     |       lay\n     |       out`\n  )\n)\n```\n\n----------------------------------------\n\nTITLE: Using Effect.dropWhile to Filter a Collection in TypeScript\nDESCRIPTION: This example demonstrates how to use Effect.dropWhile to filter a collection of numbers, dropping elements as long as they are less than or equal to 3. It uses Effect.gen for structured concurrency and runs the effect with Effect.runFork.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-dropWhile.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Effect } from \"effect\"\n\nconst numbers = [1, 2, 3, 4, 5, 6]\nconst predicate = (n: number, i: number) => Effect.succeed(n <= 3)\n\nconst program = Effect.gen(function*() {\n  const result = yield* Effect.dropWhile(numbers, predicate)\n  console.log(result)\n})\n\nEffect.runFork(program)\n// Output: [4, 5, 6]\n```\n\n----------------------------------------\n\nTITLE: Setting Scoped Reference Values in TypeScript\nDESCRIPTION: The `set` method modifies the value of a `ScopedRef` instance to a new value. It handles resource management by ensuring old resources are released while acquiring a new value. The method supports two usage patterns: a curried form and a direct invocation with both the reference and the new value. The expected input is an `Effect` that produces the new value, and the output is an effect that indicates success or failure in changing the reference.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/ScopedRef-set.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const set: { <A, R, E>(acquire: Effect.Effect<A, E, R>): (self: ScopedRef<A>) => Effect.Effect<void, E, Exclude<R, Scope.Scope>>; <A, R, E>(self: ScopedRef<A>, acquire: Effect.Effect<A, E, R>): Effect.Effect<void, E, Exclude<R, Scope.Scope>>; }\n```\n\n----------------------------------------\n\nTITLE: Pattern Matching Example Using Effect-TS Match Module\nDESCRIPTION: Demonstrates basic pattern matching usage with Effect-TS, handling string and number input types. Shows how to create a matcher, define patterns using Match.when, and ensure exhaustive matching.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Match-Matcher.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Match } from \"effect\"\n\n// Simulated dynamic input that can be a string or a number\nconst input: string | number = \"some input\"\n\n//      ┌─── string\n//      ▼\nconst result = Match.value(input).pipe(\n  // Match if the value is a number\n  Match.when(Match.number, (n) => `number: ${n}`),\n  // Match if the value is a string\n  Match.when(Match.string, (s) => `string: ${s}`),\n  // Ensure all possible cases are covered\n  Match.exhaustive\n)\n\nconsole.log(result)\n// Output: \"string: some input\"\n```\n\n----------------------------------------\n\nTITLE: Using Either.transposeOption in TypeScript\nDESCRIPTION: Demonstrates how to use Either.transposeOption to convert Option<Either<A, E>> to Either<Option<A>, E>. The example shows converting an Option containing an Either with a number value into the transposed form.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Either-transposeOption.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Effect, Either, Option } from \"effect\"\n\n//      ┌─── Option<Either<number, never>>\n//      ▼\nconst maybe = Option.some(Either.right(42))\n\n//      ┌─── Either<Option<number>, never, never>\n//      ▼\nconst result = Either.transposeOption(maybe)\n\nconsole.log(Effect.runSync(result))\n// Output: { _id: 'Option', _tag: 'Some', value: 42 }\n```\n\n----------------------------------------\n\nTITLE: Effect.zip TypeScript Function Signature\nDESCRIPTION: The TypeScript signature for the Effect.zip function, showing its polymorphic nature and the available options including concurrent execution, batching, and concurrent finalizers.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-zip.md#2025-04-11_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const zip: { <A2, E2, R2>(that: Effect<A2, E2, R2>, options?: { readonly concurrent?: boolean | undefined; readonly batching?: boolean | \"inherit\" | undefined; readonly concurrentFinalizers?: boolean | undefined; } | undefined): <A, E, R>(self: Effect<A, E, R>) => Effect<[A, A2], E2 | E, R2 | R>; <A, E, R, A2, E2, R2>(self: Effect<A, E, R>, that: Effect<A2, E2, R2>, options?: { readonly concurrent?: boolean | undefined; readonly batching?: boolean | \"inherit\" | undefined; readonly concurrentFinalizers?: boolean | undefined; } | undefined): Effect<[A, A2], E | E2, R | R2>; }\n```\n\n----------------------------------------\n\nTITLE: Defining withLive Function for Workflow Execution in TypeScript\nDESCRIPTION: The withLive function is used to execute a specified workflow with a given implementation of the live service. It has two overloaded signatures, allowing for flexible usage patterns.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TestServices-withLive.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const withLive: ((live: Live.TestLive) => <A, E, R>(effect: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>) & (<A, E, R>(effect: Effect.Effect<A, E, R>, live: Live.TestLive) => Effect.Effect<A, E, R>)\n```\n\n----------------------------------------\n\nTITLE: Defining Either.flip Function in TypeScript\nDESCRIPTION: A function that swaps the error and success cases in an Either type. This allows operations on the error channel before potentially flipping back to the original orientation.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Either-flip.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const flip: <R, L>(self: Either<R, L>) => Either<L, R>\n```\n\n----------------------------------------\n\nTITLE: Calculating Square Root of BigInt in TypeScript\nDESCRIPTION: This code snippet demonstrates how to use the BigInt.sqrt function to safely calculate the square root of bigint values. It returns an Option type, with Some containing the result for non-negative inputs, and None for negative inputs.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/BigInt-sqrt.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { BigInt, Option } from \"effect\"\n\nassert.deepStrictEqual(BigInt.sqrt(4n), Option.some(2n))\nassert.deepStrictEqual(BigInt.sqrt(9n), Option.some(3n))\nassert.deepStrictEqual(BigInt.sqrt(16n), Option.some(4n))\nassert.deepStrictEqual(BigInt.sqrt(-1n), Option.none())\n```\n\n----------------------------------------\n\nTITLE: Using Effect.catchTag to Handle Tagged Errors in TypeScript\nDESCRIPTION: Example demonstrating how to catch and handle specific errors by their _tag field. The code creates two error classes with different tags, then uses Effect.catchTag to handle only HttpError instances while letting ValidationError pass through.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-catchTag.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Effect, Random } from \"effect\"\n\nclass HttpError {\n  readonly _tag = \"HttpError\"\n}\n\nclass ValidationError {\n  readonly _tag = \"ValidationError\"\n}\n\n//      ┌─── Effect<string, HttpError | ValidationError, never>\n//      ▼\nconst program = Effect.gen(function* () {\n  const n1 = yield* Random.next\n  const n2 = yield* Random.next\n  if (n1 < 0.5) {\n    yield* Effect.fail(new HttpError())\n  }\n  if (n2 < 0.5) {\n    yield* Effect.fail(new ValidationError())\n  }\n  return \"some result\"\n})\n\n//      ┌─── Effect<string, ValidationError, never>\n//      ▼\nconst recovered = program.pipe(\n  // Only handle HttpError errors\n  Effect.catchTag(\"HttpError\", (_HttpError) =>\n    Effect.succeed(\"Recovering from HttpError\")\n  )\n)\n```\n\n----------------------------------------\n\nTITLE: Option.some Signature in Effect (TypeScript)\nDESCRIPTION: Shows the type signature of the `Option.some` function.  It defines a generic function `some` that takes a value of type `A` as input and returns an `Option<A>`. This signature indicates that `Option.some` can be used with any type.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Option-some.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const some: <A>(value: A) => Option<A>\n```\n\n----------------------------------------\n\nTITLE: Determining if Array Contains Value Satisfying Predicate - TypeScript\nDESCRIPTION: This snippet defines the TypeScript signature for the `some` method in the TArray module. It determines whether the array contains at least one value that satisfies a provided predicate. The method can be called either by passing the predicate first followed by the array or by passing both as arguments directly.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TArray-some.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const some: { <A>(predicate: Predicate<A>): (self: TArray<A>) => STM.STM<boolean>; <A>(self: TArray<A>, predicate: Predicate<A>): STM.STM<boolean>; }\n```\n\n----------------------------------------\n\nTITLE: Declaring flipWith in TypeScript\nDESCRIPTION: The flipWith function is declared to swap the error/value parameters, apply a transformation function `f`, and then swap the parameters back to their original positions. It requires the STM module, and its generic signature supports various combinations of error and value transformations. It returns a new STM instance with the transformed error and value types.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/STM-flipWith.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const flipWith: { <E, A, R, E2, A2, R2>(f: (stm: STM<E, A, R>) => STM<E2, A2, R2>): (self: STM<A, E, R>) => STM<A | A2, E | E2, R | R2>; <A, E, R, E2, A2, R2>(self: STM<A, E, R>, f: (stm: STM<E, A, R>) => STM<E2, A2, R2>): STM<A | A2, E | E2, R | R2>; }\n```\n\n----------------------------------------\n\nTITLE: Effect.onExit Function Signature in TypeScript\nDESCRIPTION: This snippet shows the TypeScript signature of the Effect.onExit function. It defines the function's type, including its parameters and return type, illustrating how it can be used with different effect types.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-onExit.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const onExit: { <A, E, X, R2>(cleanup: (exit: Exit.Exit<A, E>) => Effect<X, never, R2>): <R>(self: Effect<A, E, R>) => Effect<A, E, R2 | R>; <A, E, R, X, R2>(self: Effect<A, E, R>, cleanup: (exit: Exit.Exit<A, E>) => Effect<X, never, R2>): Effect<A, E, R | R2>; }\n```\n\n----------------------------------------\n\nTITLE: Using orElseFail to Replace Error Values in Effect\nDESCRIPTION: Demonstrates how to use the orElseFail method to replace specific error types with a standardized error message. The example validates an age value and replaces any validation errors with a generic 'invalid age' message.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-orElseFail.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Effect } from \"effect\"\n\nconst validate = (age: number): Effect.Effect<number, string> => {\n  if (age < 0) {\n    return Effect.fail(\"NegativeAgeError\")\n  } else if (age < 18) {\n    return Effect.fail(\"IllegalAgeError\")\n  } else {\n    return Effect.succeed(age)\n  }\n}\n\nconst program = Effect.orElseFail(validate(-1), () => \"invalid age\")\n\nconsole.log(Effect.runSyncExit(program))\n// Output:\n// {\n//   _id: 'Exit',\n//   _tag: 'Failure',\n//   cause: { _id: 'Cause', _tag: 'Fail', failure: 'invalid age' }\n// }\n```\n\n----------------------------------------\n\nTITLE: Reducing an Array with Effect Library in TypeScript\nDESCRIPTION: Demonstrates how to use the Array.reduce function from the Effect library to sum an array of numbers. It initializes with a starting value of 0 and adds each number in the array to the accumulator.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Array-reduce.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Array } from \"effect\"\n\nconst result = Array.reduce([1, 2, 3], 0, (acc, n) => acc + n)\nconsole.log(result) // 6\n```\n\n----------------------------------------\n\nTITLE: Using Effect.flip to Swap Success and Error Channels in TypeScript\nDESCRIPTION: This example demonstrates how to use Effect.flip to swap the success and error channels of an effect. A failing effect with a string error is flipped to become a successful effect that returns the error string.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-flip.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Effect } from \"effect\"\n\n//      ┌─── Effect<number, string, never>\n//      ▼\nconst program = Effect.fail(\"Oh uh!\").pipe(Effect.as(2))\n\n//      ┌─── Effect<string, number, never>\n//      ▼\nconst flipped = Effect.flip(program)\n```\n\n----------------------------------------\n\nTITLE: Lifting Nullable Functions to Option Context in TypeScript\nDESCRIPTION: This TypeScript snippet demonstrates the use of the 'Option.liftNullable' function from the Effect library. It lifts a function that may return null or undefined into one that returns an Option type (Some or None), facilitating safe handling of potentially missing or invalid data. The 'Option.liftNullable' requires a function with a return type that could be null or undefined and wraps it in an Option context.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Option-liftNullable.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { Option } from \"effect\"\n\nconst parse = (s: string): number | undefined => {\n  const n = parseFloat(s)\n  return isNaN(n) ? undefined : n\n}\n\nconst parseOption = Option.liftNullable(parse)\n\nconsole.log(parseOption(\"1\"))\n// Output: { _id: 'Option', _tag: 'Some', value: 1 }\n\nconsole.log(parseOption(\"not a number\"))\n// Output: { _id: 'Option', _tag: 'None' }\n```\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const liftNullable: <A extends ReadonlyArray<unknown>, B>(f: (...a: A) => B | null | undefined) => (...a: A) => Option<NonNullable<B>>\n```\n\n----------------------------------------\n\nTITLE: Creating Infinite Stream with Stream.iterate in TypeScript\nDESCRIPTION: Demonstrates how to use Stream.iterate to create an infinite stream of incrementing numbers, then take the first 10 elements and collect them into a Chunk.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-iterate.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Effect, Stream } from \"effect\"\n\n// An infinite Stream of numbers starting from 1 and incrementing\nconst stream = Stream.iterate(1, (n) => n + 1)\n\nEffect.runPromise(Stream.runCollect(stream.pipe(Stream.take(10)))).then(console.log)\n// { _id: 'Chunk', values: [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ] }\n```\n\n----------------------------------------\n\nTITLE: Declaring STM sync effect in TypeScript\nDESCRIPTION: Defines a utility function `sync` that creates an STM effect which succeeds by lazily evaluating the specified function. The snippet uses TypeScript, and the function is part of the STM module in the Effect package. It requires no additional dependencies. It accepts a single parameter 'evaluate', which is a callback function returning a value of type A. The 'sync' function returns an STM effect containing this lazily evaluated value.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/STM-sync.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const sync: <A>(evaluate: () => A) => STM<A>\n```\n\n----------------------------------------\n\nTITLE: Modifying Array Elements with Effect-TS in TypeScript\nDESCRIPTION: Demonstrates how to use the Array.modify function to apply a transformation to a specific element in an array. The function creates a new array with the modified element, or returns a copy of the original array if the index is out of bounds.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Array-modify.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Array } from \"effect\"\n\nconst result = Array.modify([1, 2, 3, 4], 2, (n) => n * 2)\nconsole.log(result) // [1, 2, 6, 4]\n```\n\n----------------------------------------\n\nTITLE: Implementing filterMap Function for Chunk Data Structure in TypeScript\nDESCRIPTION: The filterMap function provides a way to simultaneously filter and map elements in a Chunk data structure. It accepts a function that transforms elements and returns an Option type, keeping only the elements where the function returns Some value.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Chunk-filterMap.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const filterMap: { <A, B>(f: (a: A, i: number) => Option<B>): (self: Chunk<A>) => Chunk<B>; <A, B>(self: Chunk<A>, f: (a: A, i: number) => Option<B>): Chunk<B>; }\n```\n\n----------------------------------------\n\nTITLE: Splitting Arrays into Equal Chunks in TypeScript Using Effect\nDESCRIPTION: The split function divides an iterable into 'n' equally sized arrays. It returns an array of arrays, where each inner array contains a portion of the original iterable elements. The function supports both curried and uncurried calling styles.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Array-split.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Array } from \"effect\"\n\nconst result = Array.split([1, 2, 3, 4, 5, 6, 7, 8], 3)\nconsole.log(result) // [[1, 2, 3], [4, 5, 6], [7, 8]]\n```\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const split: { (n: number): <A>(self: Iterable<A>) => Array<Array<A>>; <A>(self: Iterable<A>, n: number): Array<Array<A>>; }\n```\n\n----------------------------------------\n\nTITLE: Implementing Paginated API Stream with paginateEffect in TypeScript\nDESCRIPTION: The paginateEffect function is similar to Stream.unfoldEffect but allows emission of values to end one step further than the state unfolding. It's particularly useful for integrating paginated APIs. The function takes an initial state and a function that produces an Effect containing a tuple of the current value and an Option for the next state.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-paginateEffect.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const paginateEffect: <S, A, E, R>(s: S, f: (s: S) => Effect.Effect<readonly [A, Option.Option<S>], E, R>) => Stream<A, E, R>\n```\n\n----------------------------------------\n\nTITLE: Using Effect.disconnect for Quicker Return in TypeScript\nDESCRIPTION: Illustrates how to use Effect.disconnect with Effect.raceFirst to allow for a quicker return by disconnecting the interrupt signal for both effects.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-raceFirst.md#2025-04-11_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Effect, Console } from \"effect\"\n\nconst task1 = Effect.succeed(\"task1\").pipe(\n  Effect.delay(\"100 millis\"),\n  Effect.tap(Console.log(\"task1 done\")),\n  Effect.onInterrupt(() =>\n    Console.log(\"task1 interrupted\").pipe(Effect.delay(\"100 millis\"))\n  )\n)\nconst task2 = Effect.succeed(\"task2\").pipe(\n  Effect.delay(\"200 millis\"),\n  Effect.tap(Console.log(\"task2 done\")),\n  Effect.onInterrupt(() =>\n    Console.log(\"task2 interrupted\").pipe(Effect.delay(\"100 millis\"))\n  )\n)\n\n// Race the two tasks with disconnect to allow quicker return\nconst program = Effect.raceFirst(\n  Effect.disconnect(task1),\n  Effect.disconnect(task2)\n).pipe(Effect.tap(Console.log(\"more work...\")))\n\nEffect.runPromiseExit(program).then(console.log)\n// Output:\n// task1 done\n// more work...\n// { _id: 'Exit', _tag: 'Success', value: 'task1' }\n// task2 interrupted\n```\n\n----------------------------------------\n\nTITLE: Using Array.partition to separate array elements in TypeScript\nDESCRIPTION: Example demonstrating how to use the Array.partition function to separate even and odd numbers into two separate arrays. The function returns a tuple containing the elements that don't satisfy the predicate and those that do.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Array-partition.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Array } from \"effect\"\n\nconst result = Array.partition([1, 2, 3, 4], n => n % 2 === 0)\nconsole.log(result) // [[1, 3], [2, 4]]\n```\n\n----------------------------------------\n\nTITLE: Creating Unbounded Queue in TypeScript using Effect\nDESCRIPTION: This function creates a new unbounded Queue. It takes no parameters and returns an Effect that produces a Queue of type A. The Queue is unbounded, meaning it has no fixed size limit.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Queue-unbounded.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const unbounded: <A>() => Effect.Effect<Queue<A>>\n```\n\n----------------------------------------\n\nTITLE: Creating a Channel from a Queue in TypeScript\nDESCRIPTION: This function constructs a Channel from a Queue, where the queue contains elements that can be either regular values or exit signals. This allows for building data pipelines using queue-based communication.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Channel-fromQueue.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const fromQueue: <Done, Err, Elem>(queue: Queue.Dequeue<Either.Either<Elem, Exit.Exit<Done, Err>>>) => Channel<Elem, unknown, Err, unknown, Done, unknown>\n```\n\n----------------------------------------\n\nTITLE: Creating a Stream with Changes Operator in TypeScript\nDESCRIPTION: Demonstrates how to use Stream.changes to filter out consecutive duplicate values from a stream, reducing the output to unique consecutive elements\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-changes.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Effect, Stream } from \"effect\"\n\nconst stream = Stream.make(1, 1, 1, 2, 2, 3, 4).pipe(Stream.changes)\n\nEffect.runPromise(Stream.runCollect(stream)).then(console.log)\n// { _id: 'Chunk', values: [ 1, 2, 3, 4 ] }\n```\n\n----------------------------------------\n\nTITLE: Implementing Error Cause Mapping in TypeScript Channels\nDESCRIPTION: Defines a function that transforms channel error causes. This overloaded function allows mapping error causes either through direct application or curried form, providing flexibility in error handling while preserving the channel's other type parameters.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Channel-mapErrorCause.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const mapErrorCause: { <OutErr, OutErr2>(f: (cause: Cause.Cause<OutErr>) => Cause.Cause<OutErr2>): <OutElem, InElem, InErr, OutDone, InDone, Env>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>) => Channel<OutElem, InElem, OutErr2, InErr, OutDone, InDone, Env>; <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutErr2>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>, f: (cause: Cause.Cause<OutErr>) => Cause.Cause<OutErr2>): Channel<OutElem, InElem, OutErr2, InErr, OutDone, InDone, Env>; }\n```\n\n----------------------------------------\n\nTITLE: Filtering Records using Predicate in TypeScript\nDESCRIPTION: The snippet demonstrates filtering properties from a record object based on a given predicate. It imports relevant modules, defines a sample record, and uses the filter function from the Effect library to filter values greater than 2. Dependencies include the Node.js assert module and the Effect library. Inputs include a record and a predicate function, outputting a filtered record.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Record-filter.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { filter } from \"effect/Record\"\n\nconst x = { a: 1, b: 2, c: 3, d: 4 }\nassert.deepStrictEqual(filter(x, (n) => n > 2), { c: 3, d: 4 })\n```\n\n----------------------------------------\n\nTITLE: Adjusting Time in TestClock for Effect Package in TypeScript\nDESCRIPTION: The 'adjust' function accesses a TestClock instance and increments the time by a specified duration. It runs any scheduled actions for the new time or earlier in order. This function is useful for controlling time in test scenarios.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TestClock-adjust.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const adjust: (durationInput: Duration.DurationInput) => Effect.Effect<void>\n```\n\n----------------------------------------\n\nTITLE: Validating Date Objects with TypeScript Type Guard\nDESCRIPTION: Demonstrates the usage of the isDate predicate to validate and narrow Date type inputs, supporting type safety and runtime type checking\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Predicate-isDate.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { isDate } from \"effect/Predicate\"\n\nassert.deepStrictEqual(isDate(new Date()), true)\n\nassert.deepStrictEqual(isDate(null), false)\nassert.deepStrictEqual(isDate({}), false)\n```\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const isDate: (input: unknown) => input is Date\n```\n\n----------------------------------------\n\nTITLE: Using Predicate.mapInput for String Length Validation in TypeScript\nDESCRIPTION: Demonstrates how to use Predicate.mapInput to create a predicate that checks if a string's length is greater than 2. The example imports necessary modules, defines the predicate, and tests it with different string inputs.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Predicate-mapInput.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { Predicate, Number } from \"effect\"\n\nconst minLength3 = Predicate.mapInput(Number.greaterThan(2), (s: string) => s.length)\n\nassert.deepStrictEqual(minLength3(\"a\"), false)\nassert.deepStrictEqual(minLength3(\"aa\"), false)\nassert.deepStrictEqual(minLength3(\"aaa\"), true)\nassert.deepStrictEqual(minLength3(\"aaaa\"), true)\n```\n\n----------------------------------------\n\nTITLE: Using Array.replicate in TypeScript with Effect Library\nDESCRIPTION: Example demonstrating how to use Array.replicate to create a non-empty array by repeating a value multiple times. The function accepts a value and a number, and returns an array with that value repeated n times.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Array-replicate.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Array } from \"effect\"\n\nconst result = Array.replicate(\"a\", 3)\nconsole.log(result) // [\"a\", \"a\", \"a\"]\n```\n\n----------------------------------------\n\nTITLE: Generating Random Numbers in Range with Effect.ts\nDESCRIPTION: The nextRange function returns the next numeric value within a specified range from a pseudo-random number generator. It takes minimum and maximum values as parameters and returns an Effect containing the generated number.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Random-nextRange.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const nextRange: (min: number, max: number) => Effect.Effect<number>\n```\n\n----------------------------------------\n\nTITLE: Executing Stream Cross Product\nDESCRIPTION: Shows how to generate and collect the cartesian product result using Stream.cross and Effect.runPromise\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-cross.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst product = Stream.cross(s1, s2)\n\nEffect.runPromise(Stream.runCollect(product)).then(console.log)\n```\n\n----------------------------------------\n\nTITLE: Implementing Schema.withDefaults Function Signature in TypeScript\nDESCRIPTION: Defines a function that enhances property signatures by adding default values for both decoding and construction. It provides type-safe handling of optional properties by converting them to required properties with default values.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Schema-withDefaults.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const withDefaults: { <Type>(defaults: { constructor: () => Types.NoInfer<Exclude<Type, undefined>>; decoding: () => Types.NoInfer<Exclude<Type, undefined>>; }): <Key extends PropertyKey, Encoded, R>(self: PropertySignature<\"?:\", Type, Key, \"?:\", Encoded, boolean, R>) => PropertySignature<\":\", Exclude<Type, undefined>, Key, \"?:\", Encoded, true, R>; <Type, Key extends PropertyKey, Encoded, R>(self: PropertySignature<\"?:\", Type, Key, \"?:\", Encoded, boolean, R>, defaults: { constructor: () => Types.NoInfer<Exclude<Type, undefined>>; decoding: () => Types.NoInfer<Exclude<Type, undefined>>; }): PropertySignature<\":\", Exclude<Type, undefined>, Key, \"?:\", Encoded, true, R>; }\n```\n\n----------------------------------------\n\nTITLE: Using Effect.intoDeferred with Promises in TypeScript\nDESCRIPTION: Demonstrates how to convert an Effect into a Deferred operation and handle its completion. Shows creating a Deferred, completing it with an Effect, and accessing the result value.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-intoDeferred.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Deferred, Effect } from \"effect\"\n\n// Define an effect that succeeds\nconst successEffect = Effect.succeed(42)\n\nconst program = Effect.gen(function*() {\n  // Create a deferred\n  const deferred = yield* Deferred.make<number, string>()\n\n  // Complete the deferred using the successEffect\n  const isCompleted = yield* Effect.intoDeferred(successEffect, deferred)\n\n  // Access the value of the deferred\n  const value = yield* Deferred.await(deferred)\n  console.log(value)\n\n  return isCompleted\n})\n\nEffect.runPromise(program).then(console.log)\n// Output:\n// 42\n// true\n```\n\n----------------------------------------\n\nTITLE: Using firstSuccessOf for Fallback Configuration in TypeScript\nDESCRIPTION: This example demonstrates how to use Effect.firstSuccessOf to try multiple configuration sources in sequence. It simulates retrieving configuration from various nodes, stopping at the first successful attempt, which makes it ideal for implementing fallback strategies.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-firstSuccessOf.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Effect, Console } from \"effect\"\n\ninterface Config {\n  host: string\n  port: number\n  apiKey: string\n}\n\n// Create a configuration object with sample values\nconst makeConfig = (name: string): Config => ({\n  host: `${name}.example.com`,\n  port: 8080,\n  apiKey: \"12345-abcde\"\n})\n\n// Simulate retrieving configuration from a remote node\nconst remoteConfig = (name: string): Effect.Effect<Config, Error> =>\n  Effect.gen(function* () {\n    // Simulate node3 being the only one with available config\n    if (name === \"node3\") {\n      yield* Console.log(`Config for ${name} found`)\n      return makeConfig(name)\n    } else {\n      yield* Console.log(`Unavailable config for ${name}`)\n      return yield* Effect.fail(new Error(`Config not found for ${name}`))\n    }\n  })\n\n// Define the master configuration and potential fallback nodes\nconst masterConfig = remoteConfig(\"master\")\nconst nodeConfigs = [\"node1\", \"node2\", \"node3\", \"node4\"].map(remoteConfig)\n\n// Attempt to find a working configuration,\n// starting with the master and then falling back to other nodes\nconst config = Effect.firstSuccessOf([masterConfig, ...nodeConfigs])\n\n// Run the effect to retrieve the configuration\nconst result = Effect.runSync(config)\n\nconsole.log(result)\n// Output:\n// Unavailable config for master\n// Unavailable config for node1\n// Unavailable config for node2\n// Config for node3 found\n// { host: 'node3.example.com', port: 8080, apiKey: '12345-abcde' }\n```\n\n----------------------------------------\n\nTITLE: Applying Patch Updates in TypeScript using Differ\nDESCRIPTION: The patch function applies a patch to an old value to produce a new value. It updates the old value according to the changes described in the patch. This function can be used in two ways: as a method on a Differ instance or as a standalone function.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Differ-patch.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const patch: { <Patch, Value>(patch: Patch, oldValue: Value): (self: Differ<Value, Patch>) => Value; <Patch, Value>(self: Differ<Value, Patch>, patch: Patch, oldValue: Value): Value; }\n```\n\n----------------------------------------\n\nTITLE: Effect.match Function Signature in TypeScript\nDESCRIPTION: The TypeScript signature for the Effect.match function, showing its overloaded implementation. It accepts an options object with onFailure and onSuccess handlers to transform the result of an effect.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-match.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const match: { <E, A2, A, A3>(options: { readonly onFailure: (error: E) => A2; readonly onSuccess: (value: A) => A3; }): <R>(self: Effect<A, E, R>) => Effect<A2 | A3, never, R>; <A, E, R, A2, A3>(self: Effect<A, E, R>, options: { readonly onFailure: (error: E) => A2; readonly onSuccess: (value: A) => A3; }): Effect<A2 | A3, never, R>; }\n```\n\n----------------------------------------\n\nTITLE: Creating NonEmptyArray Using Array.make in TypeScript\nDESCRIPTION: Demonstrates how to create a NonEmptyArray using the Array.make function. The function accepts one or more elements and returns a non-empty array containing those elements.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Array-make.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Array } from \"effect\"\n\nconst result = Array.make(1, 2, 3)\nconsole.log(result) // [1, 2, 3]\n```\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const make: <Elements extends NonEmptyArray<any>>(...elements: Elements) => NonEmptyArray<Elements[number]>\n```\n\n----------------------------------------\n\nTITLE: Providing Context in STM Transactions with TypeScript\nDESCRIPTION: The `provideContext` function in TypeScript allows the user to supply the required environment for an STM transaction, effectively removing its dependency on the type `R`. The function is part of the STM module and is designed to manage transaction dependencies using a given context. Its input parameters include a context of type `Context<R>` and an STM transaction. The output is an STM transaction with the same output type but without the need for the specific environment `R`. This feature has been available since version 2.0.0.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/STM-provideContext.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const provideContext: { <R>(env: Context.Context<R>): <A, E>(self: STM<A, E, R>) => STM<A, E>; <A, E, R>(self: STM<A, E, R>, env: Context.Context<R>): STM<A, E>; }\n```\n\n----------------------------------------\n\nTITLE: Partitioning Stream with groupedWithin in TypeScript\nDESCRIPTION: Demonstrates how to use Stream.groupedWithin to partition a stream based on chunk size or duration. The example creates a stream of numbers, repeats it, groups it, and then collects the results.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-groupedWithin.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Chunk, Effect, Schedule, Stream } from \"effect\"\n\nconst stream = Stream.range(0, 9).pipe(\n  Stream.repeat(Schedule.spaced(\"1 second\")),\n  Stream.groupedWithin(18, \"1.5 seconds\"),\n  Stream.take(3)\n)\n\nEffect.runPromise(Stream.runCollect(stream)).then((chunks) => console.log(Chunk.toArray(chunks)))\n// [\n//   {\n//     _id: 'Chunk',\n//     values: [\n//       0, 1, 2, 3, 4, 5, 6,\n//       7, 8, 9, 0, 1, 2, 3,\n//       4, 5, 6, 7\n//     ]\n//   },\n//   {\n//     _id: 'Chunk',\n//     values: [\n//       8, 9, 0, 1, 2,\n//       3, 4, 5, 6, 7,\n//       8, 9\n//     ]\n//   },\n//   {\n//     _id: 'Chunk',\n//     values: [\n//       0, 1, 2, 3, 4, 5, 6,\n//       7, 8, 9, 0, 1, 2, 3,\n//       4, 5, 6, 7\n//     ]\n//   }\n// ]\n```\n\n----------------------------------------\n\nTITLE: Mapping Keys in ReadonlyRecord with TypeScript\nDESCRIPTION: This snippet demonstrates the use of the `mapKeys` function from the Effect-TS library, which maps keys of a ReadonlyRecord to new keys based on a provided transformation function, while keeping their corresponding values unchanged. The `assert.deepStrictEqual` function is used to validate that the keys have been transformed correctly. It requires the Effect-TS library as a dependency.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Record-mapKeys.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { mapKeys } from \"effect/Record\"\n\nassert.deepStrictEqual(mapKeys({ a: 3, b: 5 }, (key) => key.toUpperCase()), { A: 3, B: 5 })\n```\n\n----------------------------------------\n\nTITLE: Creating a Bounded TPubSub with Sliding Strategy in TypeScript\nDESCRIPTION: This function creates a bounded TPubSub with a sliding strategy. When the TPubSub reaches capacity, it will add new messages and drop the oldest messages. For optimal performance, it's recommended to use capacity values that are powers of two.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TPubSub-sliding.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const sliding: <A>(requestedCapacity: number) => STM.STM<TPubSub<A>>\n```\n\n----------------------------------------\n\nTITLE: Stream.fromIterable Signature\nDESCRIPTION: The signature of the `fromIterable` function defines how it's used. It accepts an `Iterable<A>` as input and returns a `Stream<A>`. This signifies that it takes an iterable of type A and produces a stream that emits values of type A.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-fromIterable.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const fromIterable: <A>(iterable: Iterable<A>) => Stream<A>\n```\n\n----------------------------------------\n\nTITLE: Creating a Schedule Driver in TypeScript\nDESCRIPTION: This snippet defines a TypeScript function that returns a 'ScheduleDriver', enabling manual control over a schedule's execution. It is intended for cases where precise control is required, offering methods for state retrieval, next step execution, and schedule resetting.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Schedule-driver.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const driver: <Out, In, R>(self: Schedule<Out, In, R>) => Effect.Effect<ScheduleDriver<Out, In, R>>\n```\n\n----------------------------------------\n\nTITLE: Implementing Sequential Result Zipping in TypeScript with Effect-TS\nDESCRIPTION: Defines a zipRight function that combines two Exit results sequentially, discarding the first element and preserving any failures. The function handles both single-argument and two-argument variants with proper type handling for success and error cases.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Exit-zipRight.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const zipRight: { \n  <A2, E2>(that: Exit<A2, E2>): <A, E>(self: Exit<A, E>) => Exit<A2, E2 | E>; \n  <A, E, A2, E2>(self: Exit<A, E>, that: Exit<A2, E2>): Exit<A2, E | E2>; \n}\n```\n\n----------------------------------------\n\nTITLE: Parsing ISO8601 Duration Strings in TypeScript with Effect-TS\nDESCRIPTION: Examples of using the Duration.fromIso function to parse various ISO8601 duration formats into Duration objects. The function handles days, hours, minutes, and seconds with decimal values. It returns an Option type containing the parsed Duration.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Duration-fromIso.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Duration, Option } from \"effect\"\n\nDuration.fromIso(\"P1D\") // => Option.some(Duration.days(1))\nDuration.fromIso(\"PT1H\") // => Option.some(Duration.hours(1))\nDuration.fromIso(\"PT1M\") // => Option.some(Duration.minutes(1))\nDuration.fromIso(\"PT1.5S\") // => Option.some(Duration.seconds(1.5))\n```\n\n----------------------------------------\n\nTITLE: Parsing URL Strings with Either - TypeScript\nDESCRIPTION: This snippet demonstrates the `Url.fromString` function for parsing both absolute and relative URLs in TypeScript. It showcases how to handle potential parsing errors using the Either type, returning either a parsed URL or an IllegalArgumentException. The implementation accepts a base URL for resolving relative paths.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Url-fromString.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Url } from \"@effect/platform\"\nimport { Either } from \"effect\"\n\n// Parse an absolute URL\n//\n//      ┌─── Either<URL, IllegalArgumentException>\n//      ▼\nconst parsed = Url.fromString(\"https://example.com/path\")\n\nif (Either.isRight(parsed)) {\n  console.log(\"Parsed URL:\", parsed.right.toString())\n} else {\n  console.log(\"Error:\", parsed.left.message)\n}\n// Output: Parsed URL: https://example.com/path\n\n// Parse a relative URL with a base\nconst relativeParsed = Url.fromString(\"/relative-path\", \"https://example.com\")\n\nif (Either.isRight(relativeParsed)) {\n  console.log(\"Parsed relative URL:\", relativeParsed.right.toString())\n} else {\n  console.log(\"Error:\", relativeParsed.left.message)\n}\n// Output: Parsed relative URL: https://example.com/relative-path\n```\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const fromString: (url: string, base?: string | URL | undefined) => Either.Either<URL, Cause.IllegalArgumentException>\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Either.getRight Usage in TypeScript\nDESCRIPTION: This code snippet demonstrates how to use the Either.getRight function to convert an Either to an Option, discarding the Left value. It shows examples of converting both Right and Left values.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Either-getRight.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { Either, Option } from \"effect\"\n\nassert.deepStrictEqual(Either.getRight(Either.right('ok')), Option.some('ok'))\nassert.deepStrictEqual(Either.getRight(Either.left('err')), Option.none())\n```\n\n----------------------------------------\n\nTITLE: Declaring Retry Mechanism with Effect's Stream Module in TypeScript\nDESCRIPTION: The retry function allows streams to be re-executed according to a specified schedule when any operation in the stream fails. It extends the functionality of a stream type by incorporating schedule-based retry logic. The function is generic and supports multiple type parameters to ensure broad applicability. This snippet is applicable in scenarios where resilience is required, and stream operations might occasionally fail due to transient issues.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-retry.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const retry: { <E0 extends E, R2, E, X>(schedule: Schedule.Schedule<X, E0, R2>): <A, R>(self: Stream<A, E, R>) => Stream<A, E, R2 | R>; <A, E, R, X, E0 extends E, R2>(self: Stream<A, E, R>, schedule: Schedule.Schedule<X, E0, R2>): Stream<A, E, R | R2>; }\n```\n\n----------------------------------------\n\nTITLE: Type Signature for Effect.mergeAll Function in TypeScript\nDESCRIPTION: The TypeScript type declaration for the Effect.mergeAll function, showing its overloaded signatures. It defines the function's parameters including initial value, accumulator function, options for controlling execution, and return types.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-mergeAll.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const mergeAll: { <Z, Eff extends Effect<any, any, any>>(zero: Z, f: (z: Z, a: Effect.Success<Eff>, i: number) => Z, options?: { readonly concurrency?: Concurrency | undefined; readonly batching?: boolean | \"inherit\" | undefined; readonly concurrentFinalizers?: boolean | undefined; } | undefined): (elements: Iterable<Eff>) => Effect<Z, Effect.Error<Eff>, Effect.Context<Eff>>; <Eff extends Effect<any, any, any>, Z>(elements: Iterable<Eff>, zero: Z, f: (z: Z, a: Effect.Success<Eff>, i: number) => Z, options?: { readonly concurrency?: Concurrency | undefined; readonly batching?: boolean | \"inherit\" | undefined; readonly concurrentFinalizers?: boolean | undefined; } | undefined): Effect<Z, Effect.Error<Eff>, Effect.Context<Eff>>; }\n```\n\n----------------------------------------\n\nTITLE: Signature of Struct.omit Function\nDESCRIPTION: This snippet specifies the type signature of the Struct.omit function in TypeScript, which allows for the omission of properties from an object while providing type safety. The function can be used in two different signatures: one for providing keys as parameters and another for directly passing an object along with keys to omit. This ensures flexibility in how the function can be utilized depending on use cases.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Struct-omit.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const omit: { <Keys extends Array<PropertyKey>>(...keys: Keys): <S extends { [K in Keys[number]]?: any; }>(s: S) => Simplify<Omit<S, Keys[number]>>; <S extends object, Keys extends Array<keyof S>>(s: S, ...keys: Keys): Simplify<Omit<S, Keys[number]>>; }\n```\n\n----------------------------------------\n\nTITLE: Defining Micro.interrupt Function in TypeScript\nDESCRIPTION: Defines a constant interrupt function that aborts the current Micro effect. The function takes no parameters and returns a Micro effect type with never types for error, value and context, indicating it never returns normally.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Micro-interrupt.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const interrupt: Micro<never, never, never>\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Fiber Interruption with Effect.interrupt in TypeScript\nDESCRIPTION: This example shows how to use Effect.interrupt to stop a fiber's execution. It creates a program that logs a message, sleeps for 2 seconds, then interrupts itself before completion. The interruption is captured in the Exit type when run with runPromiseExit.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-interrupt.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Effect } from \"effect\"\n\nconst program = Effect.gen(function* () {\n  console.log(\"start\")\n  yield* Effect.sleep(\"2 seconds\")\n  yield* Effect.interrupt\n  console.log(\"done\")\n  return \"some result\"\n})\n\nEffect.runPromiseExit(program).then(console.log)\n// Output:\n// start\n// {\n//   _id: 'Exit',\n//   _tag: 'Failure',\n//   cause: {\n//     _id: 'Cause',\n//     _tag: 'Interrupt',\n//     fiberId: {\n//       _id: 'FiberId',\n//       _tag: 'Runtime',\n//       id: 0,\n//       startTimeMillis: ...\n//     }\n//   }\n// }\n```\n\n----------------------------------------\n\nTITLE: Creating Bounded PubSub\nDESCRIPTION: This snippet declares a constant 'bounded' which is a function that creates a bounded PubSub system with back pressure. It takes a capacity argument, which can either be a number or an object containing a capacity and an optional replay count. The returned effect represents the PubSub that enforces capacity limits for messages.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/PubSub-bounded.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const bounded: <A>(capacity: number | { readonly capacity: number; readonly replay?: number | undefined; }) => Effect.Effect<PubSub<A>>\n```\n\n----------------------------------------\n\nTITLE: Signature Declaration for Stream.takeUntil in TypeScript\nDESCRIPTION: The signature of the 'takeUntil' function in the Stream module of the Effect library is declared to provide an overview of its usage. This function offers two overloads: one that takes a predicate and returns a function for stream transformation, and another that directly takes a stream and a predicate, returning a transformed stream. The signature defines how the function can be integrated into stream operations.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-takeUntil.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const takeUntil: { <A>(predicate: Predicate<NoInfer<A>>): <E, R>(self: Stream<A, E, R>) => Stream<A, E, R>; <A, E, R>(self: Stream<A, E, R>, predicate: Predicate<A>): Stream<A, E, R>; }\n```\n\n----------------------------------------\n\nTITLE: Using filterMap with Effect Array Module\nDESCRIPTION: Demonstrates how to use filterMap to transform and filter array elements simultaneously. The example shows filtering even numbers and squaring them in one operation.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Array-filterMap.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Array, Option } from \"effect\"\n\nconst evenSquares = (x: number) => x % 2 === 0 ? Option.some(x * x) : Option.none()\n\nconst result = Array.filterMap([1, 2, 3, 4, 5], evenSquares);\nconsole.log(result) // [4, 16]\n```\n\n----------------------------------------\n\nTITLE: Creating a Stream from an Effect in Effect-TS - TypeScript\nDESCRIPTION: This snippet demonstrates how to create a stream using the Stream.fromEffect method provided by Effect-TS. The method takes an effect that may succeed or fail and emits the success value as a stream or terminates the stream in case of failure. The example provided shows importing necessary modules, generating a random integer, and collecting the result using Stream.runCollect.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-fromEffect.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Effect, Random, Stream } from \"effect\"\n\nconst stream = Stream.fromEffect(Random.nextInt)\n\nEffect.runPromise(Stream.runCollect(stream)).then(console.log)\n// Example Output: { _id: 'Chunk', values: [ 922694024 ] }\n```\n\n----------------------------------------\n\nTITLE: Using Data.tagged to Create Tagged Objects in TypeScript\nDESCRIPTION: This example demonstrates how to use the Data.tagged function to create a constructor for a Person interface with a specific tag. The constructor automatically adds the _tag property to the created object.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Data-tagged.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { Data } from \"effect\"\n\ninterface Person {\n  readonly _tag: \"Person\" // the tag\n  readonly name: string\n}\n\nconst Person = Data.tagged<Person>(\"Person\")\n\nconst mike = Person({ name: \"Mike\" })\n\nassert.deepEqual(mike, { _tag: \"Person\", name: \"Mike\" })\n```\n\n----------------------------------------\n\nTITLE: Using Array.prependAll to Prepend Elements in TypeScript\nDESCRIPTION: Demonstrates how to use the prependAll function from Effect-TS's Array module to combine arrays by prepending one array to another. The example shows prepending [0, 1] to [2, 3] to get [0, 1, 2, 3].\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Array-prependAll.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Array } from \"effect\"\n\nconst result = Array.prependAll([2, 3], [0, 1])\nconsole.log(result) // [0, 1, 2, 3]\n```\n\n----------------------------------------\n\nTITLE: Creating Reference-Counted Resource with RcRef.make in TypeScript\nDESCRIPTION: Demonstrates how to create an RcRef using RcRef.make. The example shows creating a resource that is lazily acquired and released when the last reference is released. It includes acquiring the resource multiple times within a scoped effect.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/RcRef-make.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Effect, RcRef } from \"effect\"\n\nEffect.gen(function*() {\n  const ref = yield* RcRef.make({\n    acquire: Effect.acquireRelease(\n      Effect.succeed(\"foo\"),\n      () => Effect.log(\"release foo\")\n    )\n  })\n\n  // will only acquire the resource once, and release it\n  // when the scope is closed\n  yield* RcRef.get(ref).pipe(\n    Effect.andThen(RcRef.get(ref)),\n    Effect.scoped\n  )\n})\n```\n\n----------------------------------------\n\nTITLE: Using functionWithSpan for Tracing in Effect Module\nDESCRIPTION: This example demonstrates how to use Effect.functionWithSpan to wrap a function that returns an Effect with a new span for tracing. The function includes a body that performs the actual operation and options that define the span name and attributes.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-functionWithSpan.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Effect } from \"effect\"\n\nconst getTodo = Effect.functionWithSpan({\n  body: (id: number) => Effect.succeed(`Got todo ${id}!`),\n  options: (id) => ({\n    name: `getTodo-${id}`,\n    attributes: { id }\n  })\n})\n```\n\n----------------------------------------\n\nTITLE: Reducing TSet in TypeScript using STM\nDESCRIPTION: This snippet declares the `reduce` function, which atomically folds a `TSet` using a pure function. It supports two method signatures for flexibility. The operation is based on a starting zero value and a combinatory function over set members. Dependencies include the Effect-TS library, specifically utilizing the STM for executing the result. Inputs are the set, initial value, and fold function. The output is a processed value encapsulated in `STM.STM<Z>`. This function is available since version 2.0.0.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TSet-reduce.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const reduce: { <Z, A>(zero: Z, f: (accumulator: Z, value: A) => Z): (self: TSet<A>) => STM.STM<Z>; <Z, A>(self: TSet<A>, zero: Z, f: (accumulator: Z, value: A) => Z): STM.STM<Z>; }\n```\n\n----------------------------------------\n\nTITLE: Defining Stream.share Method in TypeScript\nDESCRIPTION: This snippet defines the 'share' method for a Stream, which enables multicasting and provides configurations for stream capacity, replay, and idle time. The method returns an Effect that can be used with a Stream.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-share.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const share: { <A, E>(config: { readonly capacity: \"unbounded\"; readonly replay?: number | undefined; readonly idleTimeToLive?: Duration.DurationInput | undefined; } | { readonly capacity: number; readonly strategy?: \"sliding\" | \"dropping\" | \"suspend\" | undefined; readonly replay?: number | undefined; readonly idleTimeToLive?: Duration.DurationInput | undefined; }): <R>(self: Stream<A, E, R>) => Effect.Effect<Stream<A, E>, never, R | Scope.Scope>; <A, E, R>(self: Stream<A, E, R>, config: { readonly capacity: \"unbounded\"; readonly replay?: number | undefined; readonly idleTimeToLive?: Duration.DurationInput | undefined; } | { readonly capacity: number; readonly strategy?: \"sliding\" | \"dropping\" | \"suspend\" | undefined; readonly replay?: number | undefined; readonly idleTimeToLive?: Duration.DurationInput | undefined; }): Effect.Effect<Stream<A, E>, never, R | Scope.Scope>; }\n```\n\n----------------------------------------\n\nTITLE: Using Array.scan to accumulate values from an Iterable in TypeScript\nDESCRIPTION: This example demonstrates how to use the Array.scan function to track the cumulative sum of array elements. It starts with an initial value and progressively adds each element, storing the intermediate results at each step.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Array-scan.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Array } from \"effect\";\n\nconst result = Array.scan([1, 2, 3, 4], 0, (acc, value) => acc + value)\nconsole.log(result) // [0, 1, 3, 6, 10]\n\n// Explanation:\n// This function starts with the initial value (0 in this case)\n// and adds each element of the array to this accumulator one by one,\n// keeping track of the cumulative sum after each addition.\n// Each of these sums is captured in the resulting array.\n```\n\n----------------------------------------\n\nTITLE: Implementing Do Simulation with Either in TypeScript\nDESCRIPTION: Demonstrates how to use the Either.Do pattern with bind and let operations to create a declarative flow. Shows binding multiple values and computing derived values within the simulation scope.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Either-bindTo.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { Either, pipe } from \"effect\"\n\nconst result = pipe(\n  Either.Do,\n  Either.bind(\"x\", () => Either.right(2)),\n  Either.bind(\"y\", () => Either.right(3)),\n  Either.let(\"sum\", ({ x, y }) => x + y)\n)\nassert.deepStrictEqual(result, Either.right({ x: 2, y: 3, sum: 5 }))\n```\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const bindTo: { <N extends string>(name: N): <R, L>(self: Either<R, L>) => Either<{ [K in N]: R; }, L>; <R, L, N extends string>(self: Either<R, L>, name: N): Either<{ [K in N]: R; }, L>; }\n```\n\n----------------------------------------\n\nTITLE: Testing Effect.timeout with TestClock in TypeScript\nDESCRIPTION: This snippet demonstrates how to use TestClock to test the Effect.timeout function. It creates a fiber that sleeps for 5 minutes with a 1-minute timeout, adjusts the TestClock by 1 minute, and then asserts that the result is None.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TestClock-TestClock.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { Duration, Effect, Fiber, TestClock, Option, pipe } from \"effect\"\n\nEffect.gen(function*() {\n  const fiber = yield* pipe(\n    Effect.sleep(Duration.minutes(5)),\n    Effect.timeout(Duration.minutes(1)),\n    Effect.fork\n  )\n  yield* TestClock.adjust(Duration.minutes(1))\n  const result = yield* Fiber.join(fiber)\n  assert.deepStrictEqual(result, Option.none())\n})\n```\n\n----------------------------------------\n\nTITLE: Using BigInt.lcm to Find Least Common Multiple in TypeScript\nDESCRIPTION: Demonstrates how to use the lcm function from the BigInt module to calculate the least common multiple of two bigints. The example shows various use cases with different number pairs.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/BigInt-lcm.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { lcm } from \"effect/BigInt\"\n\nassert.deepStrictEqual(lcm(2n, 3n), 6n)\nassert.deepStrictEqual(lcm(2n, 4n), 4n)\nassert.deepStrictEqual(lcm(16n, 24n), 48n)\n```\n\n----------------------------------------\n\nTITLE: Implementing Channel Error Handling with catchAllCause in TypeScript\nDESCRIPTION: The catchAllCause function creates a new channel that behaves like the original, but switches to a fallback channel when the original encounters any typed error. The function accepts an error handler that produces the fallback channel based on the error cause.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Channel-catchAllCause.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const catchAllCause: { <OutErr, OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>(f: (cause: Cause.Cause<OutErr>) => Channel<OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>): <OutElem, InElem, InErr, OutDone, InDone, Env>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>) => Channel<OutElem1 | OutElem, InElem & InElem1, OutErr1, InErr & InErr1, OutDone1 | OutDone, InDone & InDone1, Env1 | Env>; <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>, f: (cause: Cause.Cause<OutErr>) => Channel<OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>): Channel<OutElem | OutElem1, InElem & InElem1, OutErr1, InErr & InErr1, OutDone | OutDone1, InDone & InDone1, Env | Env1>; }\n```\n\n----------------------------------------\n\nTITLE: Checking Positive BigDecimal Values in TypeScript\nDESCRIPTION: This code snippet demonstrates how to use the isPositive function from the BigDecimal module to check if a BigDecimal value is positive. It uses the unsafeFromString function to create BigDecimal values from string representations.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/BigDecimal-isPositive.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { isPositive, unsafeFromString } from \"effect/BigDecimal\"\n\nassert.deepStrictEqual(isPositive(unsafeFromString(\"-1\")), false)\nassert.deepStrictEqual(isPositive(unsafeFromString(\"0\")), false)\nassert.deepStrictEqual(isPositive(unsafeFromString(\"1\")), true)\n```\n\n----------------------------------------\n\nTITLE: Using foldWeightedDecompose with Stream to Process Elements Based on Weight\nDESCRIPTION: This example demonstrates using Sink.foldWeightedDecompose with a Stream to process elements based on weight constraints. The sink accumulates numbers into chunks until reaching a maximum cost of 4, with a decomposition strategy for elements that would exceed the threshold.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Sink-foldWeightedDecompose.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\npipe(\n  Stream.make(1, 5, 1),\n  Stream.transduce(\n    Sink.foldWeightedDecompose(\n      Chunk.empty<number>(),\n      4,\n      (n: number) => n,\n      (n: number) => Chunk.make(n - 1, 1),\n      (acc, el) => pipe(acc, Chunk.append(el))\n    )\n  ),\n  Stream.runCollect\n)\n```\n\n----------------------------------------\n\nTITLE: Implementing Chunk Filter Function in TypeScript\nDESCRIPTION: Defines a filter function that returns a filtered and mapped subset of elements from a Chunk. The function supports both predicate-based filtering and refinement-based filtering with type narrowing capabilities.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Chunk-filter.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const filter: {\n  <A, B extends A>(refinement: Refinement<NoInfer<A>, B>): (self: Chunk<A>) => Chunk<B>;\n  <A>(predicate: Predicate<NoInfer<A>>): (self: Chunk<A>) => Chunk<A>;\n  <A, B extends A>(self: Chunk<A>, refinement: Refinement<A, B>): Chunk<B>;\n  <A>(self: Chunk<A>, predicate: Predicate<A>): Chunk<A>;\n}\n```\n\n----------------------------------------\n\nTITLE: Schema Branding with Effect\nDESCRIPTION: This snippet demonstrates how to use `Schema.brand` to create a branded schema. It defines a schema `Int` by branding a number schema as an `Int`.  The example shows how to import the necessary module and define a new type `Int` based on the branded schema.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Schema-brand.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as Schema from \"effect/Schema\"\n\nconst Int = Schema.Number.pipe(Schema.int(), Schema.brand(\"Int\"))\ntype Int = Schema.Schema.Type<typeof Int> // number & Brand<\"Int\">\n```\n\n----------------------------------------\n\nTITLE: Creating a new TMap with initial values in TypeScript\nDESCRIPTION: The make function creates a new TMap that is initialized with specified key-value pairs. It accepts a variable number of tuple arguments, each containing a key and value, and returns an STM transaction that will produce the initialized TMap.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TMap-make.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const make: <K, V>(...entries: Array<readonly [K, V]>) => STM.STM<TMap<K, V>>\n```\n\n----------------------------------------\n\nTITLE: Using Duration.formatIso to Convert Durations to ISO8601 Strings in TypeScript\nDESCRIPTION: Demonstrates how to use the Duration.formatIso function to convert Duration values into ISO8601 formatted strings. The examples show formatting days, minutes, and milliseconds, as well as handling infinite durations which return Option.none().\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Duration-formatIso.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Duration, Option } from \"effect\"\n\nDuration.formatIso(Duration.days(1)) // => Option.some(\"P1D\")\nDuration.formatIso(Duration.minutes(90)) // => Option.some(\"PT1H30M\")\nDuration.formatIso(Duration.millis(1500)) // => Option.some(\"PT1.5S\")\nDuration.formatIso(Duration.infinity) // => Option.none()\n```\n\n----------------------------------------\n\nTITLE: Function Signature for Effect.succeed in TypeScript\nDESCRIPTION: The type signature for the Effect.succeed function, showing it accepts a generic type A and returns an Effect of type A.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-succeed.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const succeed: <A>(value: A) => Effect<A>\n```\n\n----------------------------------------\n\nTITLE: Transforming Errors with Cause.map in TypeScript\nDESCRIPTION: This function transforms errors in a Cause object by applying a function to each Fail error while leaving defects (Die) and interruptions untouched. It's useful for changing or simplifying error types in effectful workflows.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Cause-map.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const map: { <E, E2>(f: (e: E) => E2): (self: Cause<E>) => Cause<E2>; <E, E2>(self: Cause<E>, f: (e: E) => E2): Cause<E2>; }\n```\n\n----------------------------------------\n\nTITLE: Creating a lazy failing Effect with failSync in Effect Module\nDESCRIPTION: The failSync function creates an Effect that fails with the specified error, which is evaluated lazily. It accepts a lazy argument function that produces the error value.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-failSync.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const failSync: <E>(evaluate: LazyArg<E>) => Effect<never, E>\n```\n\n----------------------------------------\n\nTITLE: Reducing an Iterable with Effect.reduceRight in TypeScript\nDESCRIPTION: Demonstrates how to use Effect.reduceRight to process a collection of orders sequentially from right to left, accumulating the total price.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-reduceRight.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Console, Effect } from \"effect\"\n\nconst processOrder = (id: number) =>\n  Effect.succeed({ id, price: 100 * id })\n    .pipe(Effect.tap(() => Console.log(`Order ${id} processed`)), Effect.delay(500 - (id * 100)))\n\nconst program = Effect.reduceRight(\n  [1, 2, 3, 4],\n  0,\n  (id, acc, i) =>\n    processOrder(id)\n      .pipe(Effect.map((order) => acc + order.price))\n)\n\nEffect.runPromise(program).then(console.log)\n// Output:\n// Order 4 processed\n// Order 3 processed\n// Order 2 processed\n// Order 1 processed\n// 1000\n```\n\n----------------------------------------\n\nTITLE: Implementing Array Comprehension with Array.Do in TypeScript\nDESCRIPTION: This example demonstrates how to use Array.Do to create array comprehensions. It shows the use of bind, filter, and map functions to iterate through combinations of array elements, apply conditions, and transform the results. An equivalent imperative implementation using nested for loops is also provided for comparison.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Array-Do.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Array, pipe } from \"effect\"\n\nconst doResult = pipe(\n  Array.Do,\n  Array.bind(\"x\", () => [1, 3, 5]),\n  Array.bind(\"y\", () => [2, 4, 6]),\n  Array.filter(({ x, y }) => x < y), // condition\n  Array.map(({ x, y }) => [x, y] as const) // transformation\n)\nconsole.log(doResult) // [[1, 2], [1, 4], [1, 6], [3, 4], [3, 6], [5, 6]]\n\n// equivalent\nconst x = [1, 3, 5],\n      y = [2, 4, 6],\n      result = [];\nfor(let i = 0; i < x.length; i++) {\n  for(let j = 0; j < y.length; j++) {\n    const _x = x[i], _y = y[j];\n    if(_x < _y) result.push([_x, _y] as const)\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Extracting Field from Schema using pluck in TypeScript\nDESCRIPTION: The code snippet defines a function that extracts a specific field from a TypeScript schema using Effect-TS's pluck method. It demonstrates the usage by creating a schema of a struct and pulling out a field to decode an array of values. The expected input is a schema and a field key, and it outputs a new schema that represents the transformation of that field's data type.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Schema-pluck.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\n// Importing Schema module from Effect-TS\nimport * as Schema from \"effect/Schema\"\n\n// ---------------------------------------------\n// use case: pull out a single field from a\n// struct through a transformation\n// ---------------------------------------------\n\nconst mytable = Schema.Struct({\n  column1: Schema.NumberFromString,\n  column2: Schema.Number\n})\n\n// const pullOutColumn: S.Schema<number, {\n//     readonly column1: string;\n// }, never>\nconst pullOutColumn = mytable.pipe(Schema.pluck(\"column1\"))\n\nconsole.log(Schema.decodeUnknownEither(Schema.Array(pullOutColumn))([{ column1: \"1\", column2: 100 }, { column1: \"2\", column2: 300 }]))\n// Output: { _id: 'Either', _tag: 'Right', right: [ 1, 2 ] }\n\n```\n\nLANGUAGE: TypeScript\nCODE:\n```\n/**\n * Signature\n */\ndeclare const pluck: { <A, I, K extends keyof A & keyof I>(key: K): <R>(schema: Schema<A, I, R>) => SchemaClass<A[K], Simplify<Pick<I, K>>, R>; <A, I, R, K extends keyof A & keyof I>(schema: Schema<A, I, R>, key: K): SchemaClass<A[K], Simplify<Pick<I, K>>, R>; }\n```\n\n----------------------------------------\n\nTITLE: Creating and Using a Matcher with Match.value in TypeScript\nDESCRIPTION: Demonstrates how to create a matcher from a specific object value and use pattern matching to handle different cases. The example matches an object by its 'name' property and returns a formatted string.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Match-value.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Match } from \"effect\"\n\nconst input = { name: \"John\", age: 30 }\n\n// Create a matcher for the specific object\nconst result = Match.value(input).pipe(\n  // Match when the 'name' property is \"John\"\n  Match.when(\n    { name: \"John\" },\n    (user) => `${user.name} is ${user.age} years old`\n  ),\n  // Provide a fallback if no match is found\n  Match.orElse(() => \"Oh, not John\")\n)\n\nconsole.log(result)\n// Output: \"John is 30 years old\"\n```\n\n----------------------------------------\n\nTITLE: Implementing the 'as' Method in the Channel Module\nDESCRIPTION: Defines the 'as' method that transforms a channel by replacing its terminal output value with a specified constant value. This is functionally equivalent to mapping the channel to the given constant.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Channel-as.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const as: { <OutDone2>(value: OutDone2): <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>) => Channel<OutElem, InElem, OutErr, InErr, OutDone2, InDone, Env>; <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutDone2>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>, value: OutDone2): Channel<OutElem, InElem, OutErr, InErr, OutDone2, InDone, Env>; }\n```\n\n----------------------------------------\n\nTITLE: Defining recurs function for Effect Schedule in Typescript\nDESCRIPTION: This code snippet defines the `recurs` function, which creates a schedule that recurs a fixed number of times before terminating. The function takes a number `n` as input, representing the number of times the schedule should recur, and returns a `Schedule<number>`.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Schedule-recurs.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const recurs: (n: number) => Schedule<number>\n```\n\n----------------------------------------\n\nTITLE: Using Doc.tupled to Format Document Collection in TypeScript\nDESCRIPTION: This example demonstrates how to use the Doc.tupled function to format an array of documents as a comma-separated list enclosed in parentheses. It maps array elements to Doc objects and then applies Doc.tupled to create a formatted document.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Doc-tupled.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport * as Doc from \"@effect/printer/Doc\"\n\nconst doc = Doc.tupled(\n  [\"1\", \"20\", \"300\", \"4000\"].map(\n    (n) => (n.length === 1 ? Doc.char(n) : Doc.text(n))\n  )\n)\n\nassert.strictEqual(\n  Doc.render(doc, { style: \"pretty\" }),\n  \"(1, 20, 300, 4000)\"\n)\n```\n\n----------------------------------------\n\nTITLE: Testing HTTP Method Validity in TypeScript\nDESCRIPTION: Demonstrates how to use the HttpMethod.isHttpMethod function to check if a value is a valid HTTP method. It shows examples of testing with a valid method, an invalid lowercase method, and a non-string value.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/HttpMethod-isHttpMethod.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { HttpMethod } from \"@effect/platform\"\n\nconsole.log(HttpMethod.isHttpMethod(\"GET\"))\n// true\nconsole.log(HttpMethod.isHttpMethod(\"get\"))\n// false\nconsole.log(HttpMethod.isHttpMethod(1))\n// false\n```\n\n----------------------------------------\n\nTITLE: Defining unwrapScopedWith Function in TypeScript for Channel Module\nDESCRIPTION: This snippet defines the unwrapScopedWith function, which constructs a Channel from a function that receives a Scope and returns an Effect resulting in a Channel if successful. It handles various generic types for input/output elements, errors, and done values.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Channel-unwrapScopedWith.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const unwrapScopedWith: <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, E, R>(f: (scope: Scope.Scope) => Effect.Effect<Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>, E, R>) => Channel<OutElem, InElem, E | OutErr, InErr, OutDone, InDone, R | Env>\n```\n\n----------------------------------------\n\nTITLE: Defining Match.is Predicate in TypeScript\nDESCRIPTION: Type signature for the Match.is function that creates a predicate to match against a set of literal values. The function accepts any number of literal values (strings, numbers, booleans, etc.) and returns a type-safe refinement predicate.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Match-is.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const is: <Literals extends ReadonlyArray<string | number | bigint | boolean | null>>(...literals: Literals) => Predicate.Refinement<unknown, Literals[number]>\n```\n\n----------------------------------------\n\nTITLE: Filtering an Option in TypeScript\nDESCRIPTION: This code snippet showcases how to use the Option.filter function from the Effect library to filter out empty strings from an Option type. The implementation includes example usages demonstrating various outputs for different cases of Option values.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Option-filter.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Option } from \"effect\"\n\nconst removeEmptyString = (input: Option.Option<string>) =>\n  Option.filter(input, (value) => value !== \"\")\n\nconsole.log(removeEmptyString(Option.none()))\n// Output: { _id: 'Option', _tag: 'None' }\n\nconsole.log(removeEmptyString(Option.some(\"\")))\n// Output: { _id: 'Option', _tag: 'None' }\n\nconsole.log(removeEmptyString(Option.some(\"a\")))\n// Output: { _id: 'Option', _tag: 'Some', value: 'a' }\n```\n\n----------------------------------------\n\nTITLE: Defining Jittered Schedule Function in TypeScript\nDESCRIPTION: The `jittered` function takes an existing schedule and modifies it to randomly adjust the execution interval between 80% and 120% of the original interval. This helps in mitigating bottlenecks by varying the execution times of tasks in distributed systems.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Schedule-jittered.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const jittered: <Out, In, R>(self: Schedule<Out, In, R>) => Schedule<Out, In, R>\n```\n\n----------------------------------------\n\nTITLE: Example usage of mapEntries in Effect TS\nDESCRIPTION: This code snippet demonstrates how to use the `mapEntries` function to transform the keys and values of a record.  It imports the `mapEntries` function from the `effect/Record` module and uses `assert.deepStrictEqual` to verify the output. The example converts keys to uppercase and increments values by one.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Record-mapEntries.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { mapEntries } from \"effect/Record\"\n\nassert.deepStrictEqual(mapEntries({ a: 3, b: 5 }, (a, key) => [key.toUpperCase(), a + 1]), { A: 4, B: 6 })\n```\n\n----------------------------------------\n\nTITLE: Using isInteger Function to Check if a BigDecimal is an Integer\nDESCRIPTION: This snippet demonstrates how to use the isInteger function from the BigDecimal module to check whether a BigDecimal value represents an integer. The example shows testing various values, with integers returning true and non-integers returning false.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/BigDecimal-isInteger.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { isInteger, unsafeFromString } from \"effect/BigDecimal\"\n\nassert.deepStrictEqual(isInteger(unsafeFromString(\"0\")), true)\nassert.deepStrictEqual(isInteger(unsafeFromString(\"1\")), true)\nassert.deepStrictEqual(isInteger(unsafeFromString(\"1.1\")), false)\n```\n\n----------------------------------------\n\nTITLE: Implementing Temporary LogLevel Changes in Effect Workflows\nDESCRIPTION: Demonstrates how to temporarily modify the log level for specific parts of an Effect workflow. The example shows logging messages at different levels using LogLevel.locally to change the log level from INFO to WARNING for a subset of operations.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/LogLevel-locally.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Effect, LogLevel } from \"effect\"\n\nconst program = Effect.gen(function*() {\n  yield* Effect.log(\"message1\")\n  yield* Effect.gen(function*() {\n    yield* Effect.log(\"message2\")\n    yield* Effect.log(\"message3\")\n  }).pipe(LogLevel.locally(LogLevel.Warning))\n})\n\nEffect.runFork(program)\n// timestamp=... level=INFO fiber=#0 message=message1\n// timestamp=... level=WARN fiber=#0 message=message2\n// timestamp=... level=WARN fiber=#0 message=message3\n```\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const locally: { (self: LogLevel): <A, E, R>(use: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>; <A, E, R>(use: Effect.Effect<A, E, R>, self: LogLevel): Effect.Effect<A, E, R>; }\n```\n\n----------------------------------------\n\nTITLE: Effect.retry Function Signature in TypeScript\nDESCRIPTION: The TypeScript signature of the Effect.retry function, showing its various overloads and type parameters.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-retry.md#2025-04-11_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const retry: { <E, O extends NoExcessProperties<Retry.Options<E>, O>>(options: O): <A, R>(self: Effect<A, E, R>) => Retry.Return<R, E, A, O>; <B, E, R1>(policy: Schedule.Schedule<B, NoInfer<E>, R1>): <A, R>(self: Effect<A, E, R>) => Effect<A, E, R1 | R>; <A, E, R, O extends NoExcessProperties<Retry.Options<E>, O>>(self: Effect<A, E, R>, options: O): Retry.Return<R, E, A, O>; <A, E, R, B, R1>(self: Effect<A, E, R>, policy: Schedule.Schedule<B, E, R1>): Effect<A, E, R1 | R>; }\n```\n\n----------------------------------------\n\nTITLE: Effect.log Function Signature in TypeScript\nDESCRIPTION: The type signature for the Effect.log function showing that it accepts any number of parameters of any type and returns an Effect that never fails and has no dependencies.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-log.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const log: (...message: ReadonlyArray<any>) => Effect<void, never, never>\n```\n\n----------------------------------------\n\nTITLE: Defining orElseIfEmpty Function in TypeScript\nDESCRIPTION: Declares the orElseIfEmpty function which produces a specified element if the stream is empty. It takes an element as a lazy argument and returns a new stream that includes the original stream's elements or the specified element if empty.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-orElseIfEmpty.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const orElseIfEmpty: { <A2>(element: LazyArg<A2>): <A, E, R>(self: Stream<A, E, R>) => Stream<A2 | A, E, R>; <A, E, R, A2>(self: Stream<A, E, R>, element: LazyArg<A2>): Stream<A | A2, E, R>; }\n```\n\n----------------------------------------\n\nTITLE: Either.getOrElse Type Signature\nDESCRIPTION: Type declaration for the getOrElse function showing its polymorphic nature. It accepts a function to handle Left cases and returns either the original Right value or the transformed Left value.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Either-getOrElse.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const getOrElse: { <L, R2>(onLeft: (left: L) => R2): <R>(self: Either<R, L>) => R2 | R; <R, L, R2>(self: Either<R, L>, onLeft: (left: L) => R2): R | R2; }\n```\n\n----------------------------------------\n\nTITLE: Demonstrating untupled Function Usage in TypeScript\nDESCRIPTION: This example shows how to use the untupled function from the Effect-TS Function module. It creates a function that extracts the first element from a tuple and demonstrates its usage with assert.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Function-untupled.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { untupled } from \"effect/Function\"\n\nconst getFirst = untupled(<A, B>(tuple: [A, B]): A => tuple[0])\n\nassert.deepStrictEqual(getFirst(1, 2), 1)\n```\n\n----------------------------------------\n\nTITLE: Resource Management with Micro.acquireRelease in TypeScript\nDESCRIPTION: Function signature for creating a resource with automatic cleanup using Micro effects. The function takes an acquire operation and a release function that handles cleanup when the MicroScope closes. The release function receives both the acquired resource and the exit state.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Micro-acquireRelease.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const acquireRelease: <A, E, R>(acquire: Micro<A, E, R>, release: (a: A, exit: MicroExit<unknown, unknown>) => Micro<void>) => Micro<A, E, R | MicroScope>\n```\n\n----------------------------------------\n\nTITLE: Adding dotenv ConfigProvider in TypeScript\nDESCRIPTION: This snippet declares the function 'layerDotEnvAdd' which adds a dotenv configuration provider to the Effect-TS environment. It accepts a file path as a parameter and returns a Layer representing the configuration state. If the specified file is not found, a debug log is generated, and an empty layer is returned. It is required to handle environment configurations sensibly.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/PlatformConfigProvider-layerDotEnvAdd.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const layerDotEnvAdd: (path: string) => Layer.Layer<never, never, FileSystem.FileSystem>\n```\n\n----------------------------------------\n\nTITLE: Creating a Stream from a Queue with Options (Effect TS)\nDESCRIPTION: The `fromQueue` function creates a `Stream` from a given `Queue.Dequeue<A>`. It accepts an optional `options` object to configure the maximum chunk size and whether the queue should be shut down after the stream is evaluated. The `maxChunkSize` parameter controls the number of elements included in each chunk of the stream.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-fromQueue.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const fromQueue: <A>(queue: Queue.Dequeue<A>, options?: { readonly maxChunkSize?: number | undefined; readonly shutdown?: boolean | undefined; }) => Stream<A>\n```\n\n----------------------------------------\n\nTITLE: Caching and Invalidating Effect Results with TTL in TypeScript\nDESCRIPTION: This example demonstrates how to use Effect.cachedInvalidateWithTTL to cache an expensive task's result, retrieve it multiple times, and manually invalidate the cache. It shows the caching behavior and the ability to force recomputation.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-cachedInvalidateWithTTL.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Effect, Console } from \"effect\"\n\nlet i = 1\nconst expensiveTask = Effect.promise<string>(() => {\n  console.log(\"expensive task...\")\n  return new Promise((resolve) => {\n    setTimeout(() => {\n      resolve(`result ${i++}`)\n    }, 100)\n  })\n})\n\nconst program = Effect.gen(function* () {\n  const [cached, invalidate] = yield* Effect.cachedInvalidateWithTTL(\n    expensiveTask,\n    \"1 hour\"\n  )\n  yield* cached.pipe(Effect.andThen(Console.log))\n  yield* cached.pipe(Effect.andThen(Console.log))\n  yield* invalidate\n  yield* cached.pipe(Effect.andThen(Console.log))\n})\n\nEffect.runFork(program)\n// Output:\n// expensive task...\n// result 1\n// result 1\n// expensive task...\n// result 2\n```\n\n----------------------------------------\n\nTITLE: Retrieving Value with Fallback in TypeScript\nDESCRIPTION: The 'getOrElse' function retrieves a value associated with a specific key in a TMap. If the key is absent, it returns a provided default value. This function is generic and can handle different key-value types. Required dependencies include the Effect library which supports STM (Software Transactional Memory). The function can be invoked either by specifying the TMap instance followed by the key and fallback, or by currying the key and fallback first.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TMap-getOrElse.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const getOrElse: { <K, V>(key: K, fallback: LazyArg<V>): (self: TMap<K, V>) => STM.STM<V>; <K, V>(self: TMap<K, V>, key: K, fallback: LazyArg<V>): STM.STM<V>; }\n```\n\n----------------------------------------\n\nTITLE: Defining catchIf for Error Handling in TypeScript - Effect Library\nDESCRIPTION: The 'catchIf' function is designed to catch and handle errors that match a given predicate. It leverages TypeScript generics to provide type-safe error handling mechanisms within the Micro framework, ensuring that errors can be refined and processed appropriately. The function supports multiple overloads to cater to different types of error predicates and handling functions, promoting flexibility in error management.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Micro-catchIf.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const catchIf: { <E, EB extends E, A2, E2, R2>(refinement: Refinement<NoInfer<E>, EB>, f: (e: EB) => Micro<A2, E2, R2>): <A, R>(self: Micro<A, E, R>) => Micro<A2 | A, E2 | Exclude<E, EB>, R2 | R>; <E, A2, E2, R2>(predicate: Predicate<NoInfer<E>>, f: (e: NoInfer<E>) => Micro<A2, E2, R2>): <A, R>(self: Micro<A, E, R>) => Micro<A2 | A, E | E2, R2 | R>; <A, E, R, EB extends E, A2, E2, R2>(self: Micro<A, E, R>, refinement: Refinement<E, EB>, f: (e: EB) => Micro<A2, E2, R2>): Micro<A | A2, E2 | Exclude<E, EB>, R | R2>; <A, E, R, A2, E2, R2>(self: Micro<A, E, R>, predicate: Predicate<E>, f: (e: E) => Micro<A2, E2, R2>): Micro<A | A2, E | E2, R | R2>; }\n```\n\n----------------------------------------\n\nTITLE: Finding All Key/Value Pairs in TMap\nDESCRIPTION: The `findAll` method is designed to retrieve all key/value pairs from a TMap that satisfy a specified predicate function. The method can be invoked in a type-safe manner using TypeScript generics. It allows users to extract values from the matching entries as an array, wrapping the operation within STM for transactional safety. It can be used with either the TMap instance or passed as the first parameter.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TMap-findAll.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const findAll: { <K, V, A>(pf: (key: K, value: V) => Option.Option<A>): (self: TMap<K, V>) => STM.STM<Array<A>>; <K, V, A>(self: TMap<K, V>, pf: (key: K, value: V) => Option.Option<A>): STM.STM<Array<A>>; }\n```\n\n----------------------------------------\n\nTITLE: Creating an Indefinite Schedule in TypeScript\nDESCRIPTION: The `forever` function creates a schedule that runs indefinitely, returning an increasing count of executions (0, 1, 2, ...). It is designed to help track how many times the function has executed over time. This functionality is essential for applications requiring persistent scheduling without a predefined end.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Schedule-forever.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const forever: Schedule<number, unknown, never>\n```\n\n----------------------------------------\n\nTITLE: Retrieving All But Last Element from Non-Empty Array in TypeScript\nDESCRIPTION: The Array.initNonEmpty function takes a non-empty readonly array and returns a new array containing all elements except the last one. This is useful for operations that need to preserve most of an array's contents while excluding the final element.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Array-initNonEmpty.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Array } from \"effect\"\n\nconst result = Array.initNonEmpty([1, 2, 3, 4])\nconsole.log(result) // [1, 2, 3]\n```\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const initNonEmpty: <A>(self: NonEmptyReadonlyArray<A>) => Array<A>\n```\n\n----------------------------------------\n\nTITLE: Options.choiceWithValue Example\nDESCRIPTION: Demonstrates how to use `Options.choiceWithValue` to create a command-line option that allows users to choose between 'dog' and 'cat', mapping each choice to a corresponding `Dog` or `Cat` data structure. This example showcases how to define the choices and their associated values, resulting in an `Options` type representing the selected animal.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Options-choiceWithValue.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as Options from \"@effect/cli/Options\"\nimport * as Data from \"effect/Data\"\n\nexport type Animal = Dog | Cat\n\nexport interface Dog {\n  readonly _tag: \"Dog\"\n}\n\nexport const Dog = Data.tagged<Dog>(\"Dog\")\n\nexport interface Cat {\n  readonly _tag: \"Cat\"\n}\n\nexport const Cat = Data.tagged<Cat>(\"Cat\")\n\nexport const animal: Options.Options<Animal> = Options.choiceWithValue(\"animal\", [\n  [\"dog\", Dog()],\n  [\"cat\", Cat()],\n])\n```\n\n----------------------------------------\n\nTITLE: Concatenating Chunks with appendAll in TypeScript\nDESCRIPTION: This example demonstrates how to use the Chunk.appendAll function to concatenate two chunks containing different data types. It creates a chunk with numbers, appends a chunk with strings, and shows the combined result as an array.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Chunk-appendAll.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Chunk } from \"effect\"\n\nconst result = Chunk.make(1, 2).pipe(Chunk.appendAll(Chunk.make(\"a\", \"b\")), Chunk.toArray)\n\nconsole.log(result)\n// [ 1, 2, \"a\", \"b\" ]\n```\n\n----------------------------------------\n\nTITLE: Using Effect.tapErrorTag to Inspect NetworkError in TypeScript\nDESCRIPTION: This example demonstrates how to use Effect.tapErrorTag to inspect and log NetworkError types without altering the original effect. It creates a task that fails with a NetworkError and uses tapErrorTag to log the status code.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-tapErrorTag.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Effect, Console } from \"effect\"\n\nclass NetworkError {\n  readonly _tag = \"NetworkError\"\n  constructor(readonly statusCode: number) {}\n}\n\nclass ValidationError {\n  readonly _tag = \"ValidationError\"\n  constructor(readonly field: string) {}\n}\n\n// Create a task that fails with a NetworkError\nconst task: Effect.Effect<number, NetworkError | ValidationError> =\n  Effect.fail(new NetworkError(504))\n\n// Use tapErrorTag to inspect only NetworkError types and log the status code\nconst tapping = Effect.tapErrorTag(task, \"NetworkError\", (error) =>\n  Console.log(`expected error: ${error.statusCode}`)\n)\n\nEffect.runFork(tapping)\n// Output:\n// expected error: 504\n```\n\n----------------------------------------\n\nTITLE: Checking if an Option Contains a Value\nDESCRIPTION: This snippet demonstrates how to use the `isSome` method from the `Option` module to check if an Option instance has a value. It imports the `Option` module, uses the `isSome` method with both a 'Some' value and a 'None' value to showcase the functionality's expected outputs.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Option-isSome.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Option } from \"effect\"\n\nconsole.log(Option.isSome(Option.some(1)))\n// Output: true\n\nconsole.log(Option.isSome(Option.none()))\n// Output: false\n```\n\n----------------------------------------\n\nTITLE: Using Either.getOrElse in TypeScript\nDESCRIPTION: Demonstrates how to use Either.getOrElse to handle both Right and Left cases. The function returns the wrapped value for Right cases or applies a transformation function to Left cases.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Either-getOrElse.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { Either } from \"effect\"\n\nassert.deepStrictEqual(Either.getOrElse(Either.right(1), (error) => error + \"!\"), 1)\nassert.deepStrictEqual(Either.getOrElse(Either.left(\"not a number\"), (error) => error + \"!\"), \"not a number!\")\n```\n\n----------------------------------------\n\nTITLE: Creating MutableHashSet from Set in TypeScript using Effect with pipe\nDESCRIPTION: Shows how to create a MutableHashSet from a JavaScript Set using Effect's pipe utility. This example illustrates the composition of operations with pipe and demonstrates that MutableHashSet preserves the uniqueness property of Set.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/MutableHashSet-fromIterable.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { MutableHashSet, pipe } from \"effect\"\n\nconsole.log(\n  pipe(\n    // Set<string> is an Iterable<string>\n    new Set([\"apple\", \"banana\", \"orange\", \"apple\"]),\n    // constructs MutableHashSet from an Iterable Set\n    MutableHashSet.fromIterable,\n    // since MutableHashSet it is itself an Iterable, we can pass it to other functions expecting an Iterable\n    Array.from\n  )\n) // Output: [\"apple\", \"banana\", \"orange\"]\n```\n\n----------------------------------------\n\nTITLE: Creating Tagged Enum Data Type in TypeScript using Effect\nDESCRIPTION: Demonstrates how to create a tagged enum data type using Data.TaggedEnum from the Effect package. The example shows the creation of an HttpError type with BadRequest and NotFound variants.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Data-TaggedEnum.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { Data } from \"effect\"\n\ntype HttpError = Data.TaggedEnum<{\n  BadRequest: { readonly status: 400, readonly message: string }\n  NotFound: { readonly status: 404, readonly message: string }\n}>\n\n// Equivalent to:\ntype HttpErrorPlain =\n  | {\n    readonly _tag: \"BadRequest\"\n    readonly status: 400\n    readonly message: string\n  }\n  | {\n    readonly _tag: \"NotFound\"\n    readonly status: 404\n    readonly message: string\n  }\n```\n\n----------------------------------------\n\nTITLE: Extracting Option Values with Custom Error Handling in TypeScript\nDESCRIPTION: This TypeScript function `Option.getOrThrowWith` extracts a value from an `Option` if it exists, or throws a custom error generated by an `onNone` function if the `Option` is `None`. The function is designed to ensure fail-fast behavior with specialized error messaging. Dependencies include Node's assert module.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Option-getOrThrowWith.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { Option } from \"effect\"\n\nassert.deepStrictEqual(\n  Option.getOrThrowWith(Option.some(1), () => new Error('Unexpected None')),\n  1\n)\nassert.throws(() => Option.getOrThrowWith(Option.none(), () => new Error('Unexpected None')))\n```\n\n----------------------------------------\n\nTITLE: Adding Services to Context in Effect.js\nDESCRIPTION: Demonstrates how to add a service to an existing Context using Context.add(). The example creates a Port service, then adds a Timeout service to the same context, then retrieves both services using Context.get().\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Context-add.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { Context, pipe } from \"effect\"\n\nconst Port = Context.GenericTag<{ PORT: number }>(\"Port\")\nconst Timeout = Context.GenericTag<{ TIMEOUT: number }>(\"Timeout\")\n\nconst someContext = Context.make(Port, { PORT: 8080 })\n\nconst Services = pipe(\n  someContext,\n  Context.add(Timeout, { TIMEOUT: 5000 })\n)\n\nassert.deepStrictEqual(Context.get(Services, Port), { PORT: 8080 })\nassert.deepStrictEqual(Context.get(Services, Timeout), { TIMEOUT: 5000 })\n```\n\n----------------------------------------\n\nTITLE: Creating TMap from Iterable in TypeScript\nDESCRIPTION: Converts an iterable collection of key-value pairs into a transactional map (STM) using the Effect library. Supports generic key and value types and returns a transactional map within the STM context.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TMap-fromIterable.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const fromIterable: <K, V>(iterable: Iterable<readonly [K, V]>) => STM.STM<TMap<K, V>>\n```\n\n----------------------------------------\n\nTITLE: Combining Streams with State Management - TypeScript\nDESCRIPTION: This snippet defines a `combine` function that takes two streams and a function `f` to merge their elements. It allows the user to maintain internal state `s` during the merging process. This function is designed for use within the Effect-TS framework for functional programming in TypeScript.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-combine.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const combine: { <A2, E2, R2, S, R3, E, A, R4, R5, A3>(that: Stream<A2, E2, R2>, s: S, f: (s: S, pullLeft: Effect.Effect<A, Option.Option<E>, R3>, pullRight: Effect.Effect<A2, Option.Option<E2>, R4>) => Effect.Effect<Exit.Exit<readonly [A3, S], Option.Option<E2 | E>>, never, R5>): <R>(self: Stream<A, E, R>) => Stream<A3, E2 | E, R2 | R3 | R4 | R5 | R>; <R, A2, E2, R2, S, R3, E, A, R4, R5, A3>(self: Stream<A, E, R>, that: Stream<A2, E2, R2>, s: S, f: (s: S, pullLeft: Effect.Effect<A, Option.Option<E>, R3>, pullRight: Effect.Effect<A2, Option.Option<E2>, R4>) => Effect.Effect<Exit.Exit<readonly [A3, S], Option.Option<E2 | E>>, never, R5>): Stream<A3, E2 | E, R | R2 | R3 | R4 | R5>; }\n```\n\n----------------------------------------\n\nTITLE: Implementing schedule Function in TypeScript for Effect Module\nDESCRIPTION: TypeScript signature for the `schedule` function which repeats an effect based on a specified schedule. It has two overloads: one taking a schedule first, and one taking an effect first. The schedule determines timing and repetition patterns.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-schedule.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const schedule: { <A, R2, Out>(schedule: Schedule.Schedule<Out, NoInfer<A> | undefined, R2>): <E, R>(self: Effect<A, E, R>) => Effect<Out, E, R2 | R>; <A, E, R, R2, Out>(self: Effect<A, E, R>, schedule: Schedule.Schedule<Out, A | undefined, R2>): Effect<Out, E, R | R2>; }\n```\n\n----------------------------------------\n\nTITLE: Taking Last Elements from Stream Using Effect-TS\nDESCRIPTION: The 'takeRight' function extracts the last 'n' elements from a given stream. It can be invoked in a curried style or directly with a stream and a number parameter. The output is a stream containing the extracted elements, and it utilizes the Effect framework to run and log the results.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-takeRight.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Effect, Stream } from \"effect\"\n\nconst stream = Stream.takeRight(Stream.make(1, 2, 3, 4, 5, 6), 3)\n\nEffect.runPromise(Stream.runCollect(stream)).then(console.log)\n// { _id: 'Chunk', values: [ 4, 5, 6 ] }\n```\n\n----------------------------------------\n\nTITLE: Applying Effects to Iterable Elements with Result Collection\nDESCRIPTION: Example showing how to apply an effect to each element in an array, collecting the transformed results into a new array. The example logs the current index and returns a doubled value for each element.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-forEach.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Effect, Console } from \"effect\"\n\nconst result = Effect.forEach([1, 2, 3, 4, 5], (n, index) =>\n  Console.log(`Currently at index ${index}`).pipe(Effect.as(n * 2))\n)\n\nEffect.runPromise(result).then(console.log)\n// Output:\n// Currently at index 0\n// Currently at index 1\n// Currently at index 2\n// Currently at index 3\n// Currently at index 4\n// [ 2, 4, 6, 8, 10 ]\n```\n\n----------------------------------------\n\nTITLE: Using Prompt.all with Text and Password Prompts in TypeScript\nDESCRIPTION: This example demonstrates how to use Prompt.all to run multiple prompts sequentially. It shows two ways of using Prompt.all: with a tuple of prompts and with a record of prompts. The example includes a text prompt for username and a password prompt with validation.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Prompt-all.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as Prompt from \"@effect/cli/Prompt\"\nimport * as Effect from \"effect/Effect\"\n\nconst username = Prompt.text({\n  message: \"Enter your username: \"\n})\n\nconst password = Prompt.password({\n  message: \"Enter your password: \",\n  validate: (value) =>\n    value.length === 0\n      ? Effect.fail(\"Password cannot be empty\")\n      : Effect.succeed(value)\n})\n\nconst allWithTuple = Prompt.all([username, password])\n\nconst allWithRecord = Prompt.all({ username, password })\n```\n\n----------------------------------------\n\nTITLE: Creating a Stream that Executes Effects in TypeScript\nDESCRIPTION: This snippet defines the `execute` function that allows for the execution of an `Effect` without producing any output elements in the stream. It takes a generic `Effect` as a parameter, which encapsulates the actual computation that may produce effects.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-execute.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const execute: <X, E, R>(effect: Effect.Effect<X, E, R>) => Stream<never, E, R>\n```\n\n----------------------------------------\n\nTITLE: Using Stream.range to Create Number Stream in TypeScript\nDESCRIPTION: This example demonstrates how to use Stream.range to create a stream of numbers from 1 to 5, and then collect and log the result.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-range.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Effect, Stream } from \"effect\"\n\n// A Stream with a range of numbers from 1 to 5\nconst stream = Stream.range(1, 5)\n\nEffect.runPromise(Stream.runCollect(stream)).then(console.log)\n// { _id: 'Chunk', values: [ 1, 2, 3, 4, 5 ] }\n```\n\n----------------------------------------\n\nTITLE: Implementing Sequential Either Operations with andThen in TypeScript\nDESCRIPTION: The andThen function executes a sequence of two Either operations, allowing the second Either to depend on the result of the first. It provides multiple overload patterns for different use cases, including passing functions or direct Either values.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Either-andThen.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const andThen: { <R, R2, L2>(f: (right: R) => Either<R2, L2>): <L>(self: Either<R, L>) => Either<R2, L | L2>; <R2, L2>(f: Either<R2, L2>): <L, R1>(self: Either<R1, L>) => Either<R2, L | L2>; <R, R2>(f: (right: R) => R2): <L>(self: Either<R, L>) => Either<R2, L>; <R2>(right: NotFunction<R2>): <R1, L>(self: Either<R1, L>) => Either<R2, L>; <R, L, R2, L2>(self: Either<R, L>, f: (right: R) => Either<R2, L2>): Either<R2, L | L2>; <R, L, R2, L2>(self: Either<R, L>, f: Either<R2, L2>): Either<R2, L | L2>; <R, L, R2>(self: Either<R, L>, f: (right: R) => R2): Either<R2, L>; <R, L, R2>(self: Either<R, L>, f: NotFunction<R2>): Either<R2, L>; }\n```\n\n----------------------------------------\n\nTITLE: Testing Tagged Objects with isTagged Function in TypeScript\nDESCRIPTION: Demonstrates the usage of the isTagged function to check if a value is an object with a specific _tag property. It shows various test cases using node's assert module.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Predicate-isTagged.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { isTagged } from \"effect/Predicate\"\n\nassert.deepStrictEqual(isTagged(1, \"a\"), false)\nassert.deepStrictEqual(isTagged(null, \"a\"), false)\nassert.deepStrictEqual(isTagged({}, \"a\"), false)\nassert.deepStrictEqual(isTagged({ a: \"a\" }, \"a\"), false)\nassert.deepStrictEqual(isTagged({ _tag: \"a\" }, \"a\"), true)\nassert.deepStrictEqual(isTagged(\"a\")({ _tag: \"a\" }), true)\n```\n\n----------------------------------------\n\nTITLE: Using Effect.iterate for Effectful Iteration Example\nDESCRIPTION: An example demonstrating how to use Effect.iterate to perform an iteration with side effects. This example iterates from 1 to 6, incrementing the value on each iteration until the condition is no longer met.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-iterate.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Effect } from \"effect\"\n\nconst result = Effect.iterate(\n  // Initial result\n  1,\n  {\n    // Condition to continue iterating\n    while: (result) => result <= 5,\n    // Operation to change the result\n    body: (result) => Effect.succeed(result + 1)\n  }\n)\n\nEffect.runPromise(result).then(console.log)\n// Output: 6\n```\n\n----------------------------------------\n\nTITLE: TArray.forEach Signature (TypeScript)\nDESCRIPTION: The `forEach` function atomically applies a transactional effect to each element of a `TArray`. It takes a function `f` as input, which transforms each element of type `A` into an `STM` effect that returns void and may fail with error `E` and require environment `R`. The function returns an `STM` effect that performs the forEach operation transactionally.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TArray-forEach.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const forEach: { <A, R, E>(f: (value: A) => STM.STM<void, E, R>): (self: TArray<A>) => STM.STM<void, E, R>; <A, R, E>(self: TArray<A>, f: (value: A) => STM.STM<void, E, R>): STM.STM<void, E, R>; }\n```\n\n----------------------------------------\n\nTITLE: Creating Bounded TPubSub with Backpressure in TypeScript\nDESCRIPTION: Creates a bounded TPubSub implementation that applies backpressure to publishers when capacity is reached. The system retains messages until they've been processed by all subscribers, ensuring no messages are lost.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TPubSub-bounded.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const bounded: <A>(requestedCapacity: number) => STM.STM<TPubSub<A>>\n```\n\n----------------------------------------\n\nTITLE: Function Signature for Effect.timeoutFailCause in TypeScript\nDESCRIPTION: This code block shows the TypeScript function signature for Effect.timeoutFailCause. It describes the function's parameters and return type, illustrating how it can be used to apply a timeout with a custom failure cause to an Effect.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-timeoutFailCause.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const timeoutFailCause: { <E1>(options: { readonly onTimeout: LazyArg<Cause.Cause<E1>>; readonly duration: Duration.DurationInput; }): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E1 | E, R>; <A, E, R, E1>(self: Effect<A, E, R>, options: { readonly onTimeout: LazyArg<Cause.Cause<E1>>; readonly duration: Duration.DurationInput; }): Effect<A, E | E1, R>; }\n```\n\n----------------------------------------\n\nTITLE: Mapping Trie Entries in TypeScript using Effect\nDESCRIPTION: Demonstrates how to use the Trie.map function to transform the values in a Trie data structure. It shows mapping over values and keys separately, and includes assertions to verify the results.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Trie-map.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { Trie, Equal } from \"effect\"\n\nconst trie = Trie.empty<number>().pipe(\n  Trie.insert(\"shells\", 0),\n  Trie.insert(\"sells\", 1),\n  Trie.insert(\"she\", 2)\n)\n\nconst trieMapV = Trie.empty<number>().pipe(\n  Trie.insert(\"shells\", 1),\n  Trie.insert(\"sells\", 2),\n  Trie.insert(\"she\", 3)\n)\n\nconst trieMapK = Trie.empty<number>().pipe(\n  Trie.insert(\"shells\", 6),\n  Trie.insert(\"sells\", 5),\n  Trie.insert(\"she\", 3)\n)\n\nassert.equal(Equal.equals(Trie.map(trie, (v) => v + 1), trieMapV), true)\nassert.equal(Equal.equals(Trie.map(trie, (_, k) => k.length), trieMapK), true)\n```\n\n----------------------------------------\n\nTITLE: Splitting Lines Using Stream Module in TypeScript\nDESCRIPTION: This TypeScript snippet declares a function `splitLines` as part of the Stream module in the effect package. It is designed to process a stream of strings and split each string on newline characters, accommodating both Windows (\\r\\n) and UNIX (\\n) newline separators. The function returns a transformed stream with the same element and error types. It requires the effect package as a dependency.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-splitLines.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const splitLines: <E, R>(self: Stream<string, E, R>) => Stream<string, E, R>\n```\n\n----------------------------------------\n\nTITLE: Switching Stream on Error Tag - TypeScript\nDESCRIPTION: Defines a `catchTag` function that allows switching to a different stream when an error matching a specified tag occurs. The function accepts a tag and a function that produces a stream based on the extracted error type, returning a modified stream that integrates error handling seamlessly.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-catchTag.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const catchTag: { <K extends E[\"_tag\"] & string, E extends { _tag: string; }, A1, E1, R1>(k: K, f: (e: Extract<E, { _tag: K; }>) => Stream<A1, E1, R1>): <A, R>(self: Stream<A, E, R>) => Stream<A1 | A, E1 | Exclude<E, { _tag: K; }>, R1 | R>; <A, E extends { _tag: string; }, R, K extends E[\"_tag\"] & string, A1, E1, R1>(self: Stream<A, E, R>, k: K, f: (e: Extract<E, { _tag: K; }>) => Stream<A1, E1, R1>): Stream<A | A1, E1 | Exclude<E, { _tag: K; }>, R | R1>; }\n```\n\n----------------------------------------\n\nTITLE: Switching Streams on Error Handling in Effect-TS (TypeScript)\nDESCRIPTION: The catchSomeCause function allows for stream recovery by switching to a different stream when an error occurs. It accepts a partial function (pf) that maps causes of errors to optional alternative streams. This is essential for managing stream failures effectively and enhancing robustness.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-catchSomeCause.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const catchSomeCause: { <E, A2, E2, R2>(pf: (cause: Cause.Cause<E>) => Option.Option<Stream<A2, E2, R2>>): <A, R>(self: Stream<A, E, R>) => Stream<A2 | A, E | E2, R2 | R>; <A, E, R, A2, E2, R2>(self: Stream<A, E, R>, pf: (cause: Cause.Cause<E>) => Option.Option<Stream<A2, E2, R2>>): Stream<A | A2, E | E2, R | R2>; }\n```\n\n----------------------------------------\n\nTITLE: Creating a HashSet from a Generator Function in TypeScript\nDESCRIPTION: Demonstrates creating a HashSet from a generator function that produces Fibonacci numbers. This example shows how any iterable source, including custom generators, can be used with HashSet.fromIterable.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/HashSet-fromIterable.md#2025-04-11_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\n// Creating a HashSet from a Generator\nimport { HashSet } from \"effect\"\n\n// Generator functions return iterables\nfunction* fibonacci(n: number): Generator<number, void, unknown> {\n  let [a, b] = [0, 1]\n  for (let i = 0; i < n; i++) {\n    yield a\n    ;[a, b] = [b, a + b]\n  }\n}\n\n// Create a HashSet from the first 10 Fibonacci numbers\nconst fibonacciSet = HashSet.fromIterable(fibonacci(10))\n\nconsole.log(HashSet.toValues(fibonacciSet))\n// Outputs: [0, 1, 2, 3, 5, 8, 13, 21, 34] but in unsorted order\n```\n\n----------------------------------------\n\nTITLE: Defining a Sensitive Field in Effect SQL Schema\nDESCRIPTION: The Sensitive function creates a field that represents sensitive values that should not be exposed in JSON variants. It takes a schema parameter which can be either a Schema.Schema.All or Schema.PropertySignature.All type.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Model-Sensitive.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const Sensitive: <S extends Schema.Schema.All | Schema.PropertySignature.All>(schema: S) => Sensitive<S>\n```\n\n----------------------------------------\n\nTITLE: Folding over Sink Results in TypeScript using Effect-TS\nDESCRIPTION: The foldSink function handles both success and failure outcomes of a sink operation by providing different continuations. It takes an options object with onFailure and onSuccess handlers that each return a new sink, allowing for different processing paths based on the original sink's result.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Sink-foldSink.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const foldSink: { <E, A1, In, In1 extends In, L1, E1, R1, A, A2, In2 extends In, L2, E2, R2>(options: { readonly onFailure: (err: E) => Sink<A1, In1, L1, E1, R1>; readonly onSuccess: (a: A) => Sink<A2, In2, L2, E2, R2>; }): <L, R>(self: Sink<A, In, L, E, R>) => Sink<A1 | A2, In1 & In2, L1 | L2, E1 | E2, R1 | R2 | R>; <A, In, L, E, R, A1, In1 extends In, L1, E1, R1, A2, In2 extends In, L2, E2, R2>(self: Sink<A, In, L, E, R>, options: { readonly onFailure: (err: E) => Sink<A1, In1, L1, E1, R1>; readonly onSuccess: (a: A) => Sink<A2, In2, L2, E2, R2>; }): Sink<A1 | A2, In1 & In2, L1 | L2, E1 | E2, R | R1 | R2>; }\n```\n\n----------------------------------------\n\nTITLE: Declaring File Schema Parameter in TypeScript\nDESCRIPTION: This snippet defines a function `fileSchema` which creates a parameter for a command-line interface expecting a file path. The function parses the file content and validates it using a given schema. The `format` parameter determines the expected file format, such as 'json' or 'yaml'.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Options-fileSchema.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const fileSchema: <I, A>(name: string, schema: Schema<A, I, FileSystem | Path | Terminal>, format?: \"json\" | \"yaml\" | \"ini\" | \"toml\" | undefined) => Options<A>\n```\n\n----------------------------------------\n\nTITLE: Using Effect.bindTo with Do Notation\nDESCRIPTION: Demonstrates how to use Effect.Do with bind and let operations to create declarative code. The example shows binding values to variables and performing calculations with them.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-bindTo.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { Effect, pipe } from \"effect\"\n\nconst result = pipe(\n  Effect.Do,\n  Effect.bind(\"x\", () => Effect.succeed(2)),\n  Effect.bind(\"y\", () => Effect.succeed(3)),\n  Effect.let(\"sum\", ({ x, y }) => x + y)\n)\nassert.deepStrictEqual(Effect.runSync(result), { x: 2, y: 3, sum: 5 })\n```\n\n----------------------------------------\n\nTITLE: Merging Contexts Example in TypeScript\nDESCRIPTION: Shows how to merge two Context objects containing different services (Port and Timeout) into a single Context. Demonstrates creation of generic tags, making contexts, and accessing merged context values.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Context-merge.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { Context } from \"effect\"\n\nconst Port = Context.GenericTag<{ PORT: number }>(\"Port\")\nconst Timeout = Context.GenericTag<{ TIMEOUT: number }>(\"Timeout\")\n\nconst firstContext = Context.make(Port, { PORT: 8080 })\nconst secondContext = Context.make(Timeout, { TIMEOUT: 5000 })\n\nconst Services = Context.merge(firstContext, secondContext)\n\nassert.deepStrictEqual(Context.get(Services, Port), { PORT: 8080 })\nassert.deepStrictEqual(Context.get(Services, Timeout), { TIMEOUT: 5000 })\n```\n\n----------------------------------------\n\nTITLE: Creating and Using RcMap in TypeScript\nDESCRIPTION: This example demonstrates how to create an RcMap using RcMap.make and perform operations on it. It shows the lazy acquisition of resources and their automatic release when the scope closes.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/RcMap-make.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Effect, RcMap } from \"effect\"\n\nEffect.gen(function*() {\n  const map = yield* RcMap.make({\n    lookup: (key: string) =>\n      Effect.acquireRelease(\n        Effect.succeed(`acquired ${key}`),\n        () => Effect.log(`releasing ${key}`)\n      )\n  })\n\n  // Get \"foo\" from the map twice, which will only acquire it once.\n  // It will then be released once the scope closes.\n  yield* RcMap.get(map, \"foo\").pipe(\n    Effect.andThen(RcMap.get(map, \"foo\")),\n    Effect.scoped\n  )\n})\n```\n\n----------------------------------------\n\nTITLE: Reducing TArray using Effect-TS in TypeScript\nDESCRIPTION: The `reduce` function atomically folds elements of a `TArray` using a provided pure function in the Effect-TS framework. The function can be used in two variants: one providing the array and zero element together, and another where they are specified separately. It returns an STM (Software Transactional Memory) computation that produces the result of the reduction. The primary dependencies are the TypeScript language and the Effect-TS library, particularly the `STM` module. Key parameters include the initial zero value and a binary function `f` that combines the accumulator's result with each `TArray` element.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TArray-reduce.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const reduce: { <Z, A>(zero: Z, f: (accumulator: Z, current: A) => Z): (self: TArray<A>) => STM.STM<Z>; <Z, A>(self: TArray<A>, zero: Z, f: (accumulator: Z, current: A) => Z): STM.STM<Z>; }\n```\n\n----------------------------------------\n\nTITLE: STM.orDieWith Function Signature in Typescript\nDESCRIPTION: This code snippet shows the Typescript signature of the `STM.orDieWith` function from the Effect TS library.  The function takes an error conversion function `f` which transforms an error of type `E` to an `unknown` value, and an `STM` effect. It returns a new `STM` effect that will terminate the fiber with a defect if the original effect fails with an error.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/STM-orDieWith.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const orDieWith: { <E>(f: (error: E) => unknown): <A, R>(self: STM<A, E, R>) => STM<A, never, R>; <A, E, R>(self: STM<A, E, R>, f: (error: E) => unknown): STM<A, never, R>; }\n```\n\n----------------------------------------\n\nTITLE: Finding Index with STM in TypeScript\nDESCRIPTION: This snippet declares a utility function to find the first index in a TArray satisfying a given predicate, starting from a specified index. The function is designed to work within the STM framework in TypeScript, providing transactional safety. The function accepts a predicate and a starting index and returns an Option with the found index or none if no such entry is found.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TArray-findFirstIndexWhereFromSTM.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const findFirstIndexWhereFromSTM: { <A, R, E>(predicate: (value: A) => STM.STM<boolean, E, R>, from: number): (self: TArray<A>) => STM.STM<Option.Option<number>, E, R>; <A, R, E>(self: TArray<A>, predicate: (value: A) => STM.STM<boolean, E, R>, from: number): STM.STM<Option.Option<number>, E, R>; }\n```\n\n----------------------------------------\n\nTITLE: Creating Tracing Spans in Effect.io Framework with TypeScript\nDESCRIPTION: This function creates a new span for tracing in the Effect.io framework. It accepts a span name and optional span options, returning an Effect that produces a Tracer.Span.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-makeSpan.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const makeSpan: (name: string, options?: Tracer.SpanOptions) => Effect<Tracer.Span>\n```\n\n----------------------------------------\n\nTITLE: Effect.eventually Type Signature in TypeScript\nDESCRIPTION: The type signature for the Effect.eventually function, showing that it transforms an Effect that might fail with error E into one that never fails, while preserving the success type A and environment requirements R.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-eventually.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const eventually: <A, E, R>(self: Effect<A, E, R>) => Effect<A, never, R>\n```\n\n----------------------------------------\n\nTITLE: Creating a Bounded Queue with Sliding Strategy in TypeScript\nDESCRIPTION: Creates a bounded queue that automatically drops old values when it reaches capacity. This function creates a queue with the sliding strategy, where new values are always added and the oldest values are dropped when at capacity. It's recommended to use power-of-two values for optimal performance.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TQueue-sliding.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const sliding: <A>(requestedCapacity: number) => STM.STM<TQueue<A>>\n```\n\n----------------------------------------\n\nTITLE: Defining HttpClient.tapError Function in TypeScript\nDESCRIPTION: Declares the tapError function for HttpClient, which takes a function to be executed after an unsuccessful request. It can be used in two ways: either as a standalone function or as a method on an HttpClient instance.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/HttpClient-tapError.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const tapError: { <_, E, E2, R2>(f: (e: NoInfer<E>) => Effect.Effect<_, E2, R2>): <R>(self: HttpClient.With<E, R>) => HttpClient.With<E | E2, R | R2>; <E, R, _, E2, R2>(self: HttpClient.With<E, R>, f: (e: NoInfer<E>) => Effect.Effect<_, E2, R2>): HttpClient.With<E | E2, R | R2>; }\n```\n\n----------------------------------------\n\nTITLE: Implementing Effect Racing with Micro.raceAll in TypeScript\nDESCRIPTION: Function signature for raceAll that takes an Iterable of Micro effects and returns a new effect that completes when the first effect succeeds. The losing effects are automatically interrupted. The returned effect inherits success type, error type, and context type from the input effects.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Micro-raceAll.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const raceAll: <Eff extends Micro<any, any, any>>(all: Iterable<Eff>) => Micro<Micro.Success<Eff>, Micro.Error<Eff>, Micro.Context<Eff>>\n```\n\n----------------------------------------\n\nTITLE: Implementing Retry Logic for Micro Effects in TypeScript\nDESCRIPTION: Defines a retry function for Micro effects that allows configuring retry conditions, maximum attempts, and scheduling. The function supports both curried and non-curried forms, taking optional configuration parameters to control retry behavior.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Micro-retry.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const retry: {\n  <A, E>(options?: {\n    while?: Predicate<E> | undefined;\n    times?: number | undefined;\n    schedule?: MicroSchedule | undefined;\n  } | undefined): <R>(self: Micro<A, E, R>) => Micro<A, E, R>;\n  <A, E, R>(self: Micro<A, E, R>, options?: {\n    while?: Predicate<E> | undefined;\n    times?: number | undefined;\n    schedule?: MicroSchedule | undefined;\n  } | undefined): Micro<A, E, R>;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Parallel Finalizers in TypeScript using Effect\nDESCRIPTION: This example demonstrates how to use Effect.parallelFinalizers to run multiple finalizers concurrently in a scoped workflow. It creates a program with three finalizers, modifies it to run in parallel, and executes it within a scoped context.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-parallelFinalizers.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Console, Effect } from \"effect\"\n\n// Define a program that adds multiple finalizers\nconst program = Effect.gen(function*() {\n  yield* Effect.addFinalizer(() => Console.log(\"Finalizer 1 executed\").pipe(Effect.delay(\"300 millis\")))\n  yield* Effect.addFinalizer(() => Console.log(\"Finalizer 2 executed\").pipe(Effect.delay(\"100 millis\")))\n  yield* Effect.addFinalizer(() => Console.log(\"Finalizer 3 executed\").pipe(Effect.delay(\"200 millis\")))\n  return \"some result\"\n})\n\n// Modify the program to ensure finalizers run in parallel\nconst modified = program.pipe(Effect.parallelFinalizers)\n\nconst runnable = Effect.scoped(modified)\n\nEffect.runFork(runnable)\n// Output:\n// Finalizer 2 executed\n// Finalizer 3 executed\n// Finalizer 1 executed\n```\n\n----------------------------------------\n\nTITLE: Defining interruptAs Function in TypeScript for Fiber Interruption\nDESCRIPTION: Declares the interruptAs function, which interrupts a fiber as if interrupted from a specified fiber. It handles both cases where the fiber has already exited or is still running, resuming immediately or upon exit respectively.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Fiber-interruptAs.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const interruptAs: { (fiberId: FiberId.FiberId): <A, E>(self: Fiber<A, E>) => Effect.Effect<Exit.Exit<A, E>>; <A, E>(self: Fiber<A, E>, fiberId: FiberId.FiberId): Effect.Effect<Exit.Exit<A, E>>; }\n```\n\n----------------------------------------\n\nTITLE: Comparing BigDecimal Values with max Function in TypeScript\nDESCRIPTION: This snippet demonstrates how to use the max function from the BigDecimal module to compare two BigDecimal values. It uses the unsafeFromString function to create BigDecimal instances and asserts the expected result.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/BigDecimal-max.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { max, unsafeFromString } from \"effect/BigDecimal\"\n\nassert.deepStrictEqual(max(unsafeFromString(\"2\"), unsafeFromString(\"3\")), unsafeFromString(\"3\"))\n```\n\n----------------------------------------\n\nTITLE: Using Doc.indent for Document Indentation in TypeScript\nDESCRIPTION: This example demonstrates how to use the indent combinator to indent a portion of text from the current cursor position. It creates a document with a prefix followed by indented text that wraps according to the specified line width.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Doc-indent.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport * as Doc from \"@effect/printer/Doc\"\nimport { pipe } from \"effect/Function\"\nimport * as String from \"effect/String\"\n\nconst doc = Doc.hcat([\n  Doc.text(\"prefix\"),\n  pipe(Doc.reflow(\"The indent function indents these words!\"), Doc.indent(4))\n])\n\nassert.strictEqual(\n  Doc.render(doc, {\n    style: \"pretty\",\n    options: { lineWidth: 24 }\n  }),\n  String.stripMargin(\n    `|prefix    The indent\n     |          function\n     |          indents these\n     |          words!`\n  )\n)\n```\n\n----------------------------------------\n\nTITLE: Implementing Context Merging in Effect-IO Micro Module\nDESCRIPTION: Defines the provideContext function that merges a given Context with the current context. This function supports both curried and non-curried forms for flexibility in usage. It takes a Context parameter and returns a function that transforms a Micro instance by merging contexts.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Micro-provideContext.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const provideContext: {\n  <XR>(context: Context.Context<XR>): <A, E, R>(self: Micro<A, E, R>) => Micro<A, E, Exclude<R, XR>>;\n  <A, E, R, XR>(self: Micro<A, E, R>, context: Context.Context<XR>): Micro<A, E, Exclude<R, XR>>;\n}\n```\n\n----------------------------------------\n\nTITLE: Using Effect.exists with Iterables in TypeScript\nDESCRIPTION: Demonstrates how to use Effect.exists to check if any number in an array is greater than 2. The example shows usage with Effect.gen for handling effects and Effect.runFork for execution.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-exists.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Effect } from \"effect\"\n\nconst numbers = [1, 2, 3, 4]\nconst predicate = (n: number, i: number) => Effect.succeed(n > 2)\n\nconst program = Effect.gen(function*() {\n  const hasLargeNumber = yield* Effect.exists(numbers, predicate)\n  console.log(hasLargeNumber)\n})\n\nEffect.runFork(program)\n// Output: true\n```\n\n----------------------------------------\n\nTITLE: Declaring the whenRef Function in TypeScript\nDESCRIPTION: Type declaration for the whenRef function that conditionally executes an effect based on a Ref value meeting a predicate. The function has two overloaded signatures and returns the current value of the Ref along with an Option containing the effect result if executed.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-whenRef.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const whenRef: { <S>(ref: Ref.Ref<S>, predicate: Predicate<S>): <A, E, R>(self: Effect<A, E, R>) => Effect<[S, Option.Option<A>], E, R>; <A, E, R, S>(self: Effect<A, E, R>, ref: Ref.Ref<S>, predicate: Predicate<S>): Effect<[S, Option.Option<A>], E, R>; }\n```\n\n----------------------------------------\n\nTITLE: Combining Predicates with Predicate.or in TypeScript\nDESCRIPTION: This example demonstrates how to use Predicate.or to combine two number comparison predicates into a single nonZero predicate. It checks if a number is either less than 0 or greater than 0.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Predicate-or.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { Predicate, Number } from \"effect\"\n\nconst nonZero = Predicate.or(Number.lessThan(0), Number.greaterThan(0))\n\nassert.deepStrictEqual(nonZero(-1), true)\nassert.deepStrictEqual(nonZero(0), false)\nassert.deepStrictEqual(nonZero(1), true)\n```\n\n----------------------------------------\n\nTITLE: Interspersing Elements in a Stream using TypeScript\nDESCRIPTION: This example demonstrates how to use the Stream.intersperse function to insert an element between each item in a stream. It creates a stream of numbers and intersperses it with zeros.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-intersperse.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Effect, Stream } from \"effect\"\n\nconst stream = Stream.make(1, 2, 3, 4, 5).pipe(Stream.intersperse(0))\n\nEffect.runPromise(Stream.runCollect(stream)).then(console.log)\n// {\n//   _id: 'Chunk',\n//   values: [\n//     1, 0, 2, 0, 3,\n//     0, 4, 0, 5\n//   ]\n// }\n```\n\n----------------------------------------\n\nTITLE: Dropping elements from Stream Effect-TS TypeScript\nDESCRIPTION: This TypeScript snippet provides functionality to drop a specified number of elements from a stream using the Effect-TS library. It features a `drop` function signature which allows either the number of elements to drop first or the stream itself. The function requires the `Stream` type from Effect-TS and outputs a modified stream with fewer elements.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-drop.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const drop: { (n: number): <A, E, R>(self: Stream<A, E, R>) => Stream<A, E, R>; <A, E, R>(self: Stream<A, E, R>, n: number): Stream<A, E, R>; }\n```\n\n----------------------------------------\n\nTITLE: Conditionally Executing Effects Based on Log Level in TypeScript\nDESCRIPTION: Demonstrates how to use the `Effect.whenLogLevel` function to conditionally execute logging operations based on the current minimum log level. The trace log is not executed since the minimum log level is set to Debug, while the debug log is executed and returns a Some value.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-whenLogLevel.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Effect, Logger, LogLevel } from \"effect\"\n\nconst program = Effect.gen(function* () {\n  yield* Effect.whenLogLevel(Effect.logTrace(\"message1\"), LogLevel.Trace); // returns `None`\n  yield* Effect.whenLogLevel(Effect.logDebug(\"message2\"), LogLevel.Debug); // returns `Some`\n}).pipe(Logger.withMinimumLogLevel(LogLevel.Debug));\n\nEffect.runFork(program)\n// timestamp=... level=DEBUG fiber=#0 message=message2\n```\n\n----------------------------------------\n\nTITLE: Implementing findLast Function for Iterables in TypeScript\nDESCRIPTION: Defines a findLast function that searches for the last element in an iterable that satisfies a given predicate. The function supports multiple overloads including predicate functions, refinements, and Option-returning functions. Returns an Option containing the found element or None if no element is found.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Iterable-findLast.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const findLast: { \n  <A, B>(f: (a: NoInfer<A>, i: number) => Option<B>): (self: Iterable<A>) => Option<B>; \n  <A, B extends A>(refinement: (a: NoInfer<A>, i: number) => a is B): (self: Iterable<A>) => Option<B>; \n  <A>(predicate: (a: NoInfer<A>, i: number) => boolean): (self: Iterable<A>) => Option<A>; \n  <A, B>(self: Iterable<A>, f: (a: A, i: number) => Option<B>): Option<B>; \n  <A, B extends A>(self: Iterable<A>, refinement: (a: A, i: number) => a is B): Option<B>; \n  <A>(self: Iterable<A>, predicate: (a: A, i: number) => boolean): Option<A>; \n}\n```\n\n----------------------------------------\n\nTITLE: Declaring validateAll Function in TypeScript\nDESCRIPTION: The validateAll function in the STM module is used to process a collection of elements through a function. It accumulates errors or successes in channels. This is a lossy operation, so successful results are discarded if any errors occur. It requires the function `f` which specifies the processing logic and the elements to be processed. The outcome is captured in STM with either an array of results or errors.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/STM-validateAll.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const validateAll: { <A, B, E, R>(f: (a: A) => STM<B, E, R>): (elements: Iterable<A>) => STM<Array<B>, [E, ...Array<E>], R>; <A, B, E, R>(elements: Iterable<A>, f: (a: A) => STM<B, E, R>): STM<Array<B>, [E, ...Array<E>], R>; }\n```\n\n----------------------------------------\n\nTITLE: Constructing Live Service Layer in TypeScript\nDESCRIPTION: The liveLayer function constructs a new Live service wrapped in a Layer. It returns a Layer that provides a TestLive service and depends on DefaultServices.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TestServices-liveLayer.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const liveLayer: () => Layer.Layer<Live.TestLive, never, DefaultServices.DefaultServices>\n```\n\n----------------------------------------\n\nTITLE: Implementing HttpApi.reflect Method in TypeScript\nDESCRIPTION: Declaration of the reflect method used to extract metadata from an HttpApi instance. The method accepts an HttpApi instance and options object containing predicates and callbacks for processing groups and endpoints. It's designed to support documentation generation and tooling.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/HttpApi-reflect.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const reflect: <Id extends string, Groups extends HttpApiGroup.HttpApiGroup.Any, Error, R>(\n  self: HttpApi<Id, Groups, Error, R>,\n  options: {\n    readonly predicate?: Predicate.Predicate<{\n      readonly endpoint: HttpApiEndpoint.HttpApiEndpoint.AnyWithProps;\n      readonly group: HttpApiGroup.HttpApiGroup.AnyWithProps;\n    }>;\n    readonly onGroup: (options: {\n      readonly group: HttpApiGroup.HttpApiGroup.AnyWithProps;\n      readonly mergedAnnotations: Context.Context<never>;\n    }) => void;\n    readonly onEndpoint: (options: {\n      readonly group: HttpApiGroup.HttpApiGroup.AnyWithProps;\n      readonly endpoint: HttpApiEndpoint.HttpApiEndpoint<string, HttpMethod>;\n      readonly mergedAnnotations: Context.Context<never>;\n      readonly middleware: ReadonlySet<HttpApiMiddleware.TagClassAny>;\n      readonly payloads: ReadonlyMap<string, {\n        readonly encoding: HttpApiSchema.Encoding;\n        readonly ast: AST.AST;\n      }>;\n      readonly successes: ReadonlyMap<number, {\n        readonly ast: Option.Option<AST.AST>;\n        readonly description: Option.Option<string>;\n      }>;\n      readonly errors: ReadonlyMap<number, {\n        readonly ast: Option.Option<AST.AST>;\n        readonly description: Option.Option<string>;\n      }>;\n    }) => void;\n  }) => void\n```\n\n----------------------------------------\n\nTITLE: Declaring File Parsing Options with Effect-TS CLI in TypeScript\nDESCRIPTION: This TypeScript snippet defines a function 'fileParse' that establishes parameters expecting a file path and parses its content. It supports various file formats like JSON, YAML, INI, and TOML. The function is part of the Effect-TS CLI package, designed to enhance CLI operations by facilitating structured parsing of file contents.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Options-fileParse.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const fileParse: (name: string, format?: \\\"json\\\" | \\\"yaml\\\" | \\\"ini\\\" | \\\"toml\\\" | undefined) => Options<unknown>\n```\n\n----------------------------------------\n\nTITLE: Awaiting Queue Shutdown in TypeScript\nDESCRIPTION: This TypeScript function declares `awaitShutdown` for waiting until a queue is shut down. It accepts a `PubSub` object and returns an `Effect` that resumes once the queue is shut down. The function is part of the `Effect-TS` library and requires the library to be included in your project.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/PubSub-awaitShutdown.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const awaitShutdown: <A>(self: PubSub<A>) => Effect.Effect<void>\n```\n\n----------------------------------------\n\nTITLE: Converting Stream to Queue in Effect-TS\nDESCRIPTION: Function signature for converting a Stream to a Queue with configurable backpressure strategy and capacity. Supports 'dropping', 'sliding', 'suspend', and 'unbounded' strategies. Default configuration uses 'suspend' strategy with capacity of 2. Returns a scoped queue that stops producing values after scope closure.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-toQueue.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const toQueue: { (options?: { readonly strategy?: \"dropping\" | \"sliding\" | \"suspend\" | undefined; readonly capacity?: number | undefined; } | { readonly strategy: \"unbounded\"; } | undefined): <A, E, R>(self: Stream<A, E, R>) => Effect.Effect<Queue.Dequeue<Take.Take<A, E>>, never, Scope.Scope | R>; <A, E, R>(self: Stream<A, E, R>, options?: { readonly strategy?: \"dropping\" | \"sliding\" | \"suspend\" | undefined; readonly capacity?: number | undefined; } | { readonly strategy: \"unbounded\"; } | undefined): Effect.Effect<Queue.Dequeue<Take.Take<A, E>>, never, Scope.Scope | R>; }\n```\n\n----------------------------------------\n\nTITLE: Creating an SSE Parser in TypeScript\nDESCRIPTION: A function to create a Server-Sent Events (SSE) parser. It accepts a callback function that will be called with each parsed event. This implementation is adapted from the eventsource-parser library under MIT license.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Sse-makeParser.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const makeParser: (onParse: (event: AnyEvent) => void) => Parser\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Doc.list Usage in TypeScript\nDESCRIPTION: This example shows how to use the Doc.list function to create a formatted list of documents. It creates a list from an array of numbers, rendering them as a comma-separated list enclosed in square brackets.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Doc-list.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport * as Doc from \"@effect/printer/Doc\"\n\nconst doc = Doc.list(\n  [\"1\", \"20\", \"300\", \"4000\"].map(\n    (n) => (n.length === 1 ? Doc.char(n) : Doc.text(n))\n  )\n)\n\nassert.strictEqual(\n  Doc.render(doc, { style: \"pretty\" }),\n  \"[1, 20, 300, 4000]\"\n)\n```\n\n----------------------------------------\n\nTITLE: Creating a Keyed Pool with Time-to-Live in TypeScript\nDESCRIPTION: The makeWithTTL function creates a new pool with specified minimum and maximum sizes, and a time-to-live duration. It allows configuration of pool sizes per key and returns the pool within a Scope that manages its lifetime.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/KeyedPool-makeWithTTL.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const makeWithTTL: <K, A, E, R>(options: { readonly acquire: (key: K) => Effect.Effect<A, E, R>; readonly min: (key: K) => number; readonly max: (key: K) => number; readonly timeToLive: Duration.DurationInput; }) => Effect.Effect<KeyedPool<K, A, E>, never, Scope.Scope | R>\n```\n\n----------------------------------------\n\nTITLE: Defining Pool Interface in TypeScript\nDESCRIPTION: Interface for a generic pool of items with error handling and scoped resource management. Supports getting items, invalidating items, and providing type-safe resource lifecycle management.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Pool-Pool.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface Pool<in out A, out E = never> extends Pool.Variance<A, E>, Effect.Effect<A, E, Scope.Scope>, Pipeable {\n  readonly get: Effect.Effect<A, E, Scope.Scope>\n  invalidate(item: A): Effect.Effect<void>\n  readonly [Unify.typeSymbol]?: unknown\n  readonly [Unify.unifySymbol]?: PoolUnify<this>\n  readonly [Unify.ignoreSymbol]?: PoolUnifyIgnore\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Array Chunking in TypeScript Using Effect Library\nDESCRIPTION: The chunksOf function splits an Iterable into length-n pieces. The last chunk may be shorter if n doesn't evenly divide the length of the input. This implementation maintains the property that chunksOf(n)(xs).concat(chunksOf(n)(ys)) equals chunksOf(n)(xs.concat(ys)) when n evenly divides the length of the first array.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Array-chunksOf.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nchunksOf(n)(xs).concat(chunksOf(n)(ys)) == chunksOf(n)(xs.concat(ys)))\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Array } from \"effect\"\n\nconst result = Array.chunksOf([1, 2, 3, 4, 5], 2)\nconsole.log(result) // [[1, 2], [3, 4], [5]]\n\n// Explanation:\n// The `chunksOf` function takes an array of numbers `[1, 2, 3, 4, 5]` and a number `2`.\n// It splits the array into chunks of length 2. Since the array length is not evenly divisible by 2,\n// the last chunk contains the remaining elements.\n// The result is `[[1, 2], [3, 4], [5]]`.\n```\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const chunksOf: { (n: number): <S extends Iterable<any>>(self: S) => ReadonlyArray.With<S, NonEmptyArray<ReadonlyArray.Infer<S>>>; <A>(self: NonEmptyReadonlyArray<A>, n: number): NonEmptyArray<NonEmptyArray<A>>; <A>(self: Iterable<A>, n: number): Array<NonEmptyArray<A>>; }\n```\n\n----------------------------------------\n\nTITLE: Defining CliConfig Interface for Command-Line Argument Parsing in TypeScript\nDESCRIPTION: This code snippet defines the CliConfig interface, which contains configuration options for parsing command-line arguments. It includes settings for case sensitivity, auto-correction, built-in option handling, and display preferences for command usage and help documentation.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/CliConfig-CliConfig.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface CliConfig {\n  /**\n   * Whether or not the argument parser should be case sensitive.\n   *\n   * Defaults to `false`.\n   */\n  readonly isCaseSensitive: boolean\n  /**\n   * Levenstein distance threshold for when to show auto correct suggestions.\n   *\n   * Defaults to `2`.\n   */\n  readonly autoCorrectLimit: number\n  /**\n   * Whether or not to perform a final check of the command-line arguments for\n   * a built-in option, even if the provided command is not valid.\n   *\n   * Defaults to `false`.\n   */\n  readonly finalCheckBuiltIn: boolean\n  /**\n   * Whether or not to display all the names of an option in the usage of a\n   * particular command.\n   *\n   * Defaults to `true`.\n   */\n  readonly showAllNames: boolean\n  /**\n   * Whether or not to display built-in options in the help documentation\n   * generated for a `Command`.\n   *\n   * Defaults to `true`.\n   */\n  readonly showBuiltIns: boolean\n  /**\n   * Whether or not to display the type of an option in the usage of a\n   * particular command.\n   *\n   * Defaults to `true`.\n   */\n  readonly showTypes: boolean\n}\n```\n\n----------------------------------------\n\nTITLE: Using Doc.words to Split Text in Effect Printer\nDESCRIPTION: Example showing how to use Doc.words to split a string into individual Text documents and format them as a tuple. The function splits on a specified character (defaulting to space) and returns an array of Doc objects.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Doc-words.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport * as Doc from \"@effect/printer/Doc\"\n\nconst doc = Doc.tupled(Doc.words(\"lorem ipsum dolor\"))\n\nassert.strictEqual(\n  Doc.render(doc, { style: \"pretty\" }),\n  \"(lorem, ipsum, dolor)\"\n)\n```\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const words: (s: string, char?: string) => ReadonlyArray<Doc<never>>\n```\n\n----------------------------------------\n\nTITLE: Sorting Array Objects with Multiple Criteria in TypeScript\nDESCRIPTION: Demonstrates how to sort an array of user objects by multiple criteria (age and name) using Array.sortBy. The example shows sorting first by age in ascending order and then by name when ages are equal.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Array-sortBy.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Array, Order, pipe } from \"effect\"\n\nconst users = [\n  { name: \"Alice\", age: 30 },\n  { name: \"Bob\", age: 25 },\n  { name: \"Charlie\", age: 30 }\n]\n\nconst result = pipe(\n  users,\n  Array.sortBy(\n    Order.mapInput(Order.number, (user: (typeof users)[number]) => user.age),\n    Order.mapInput(Order.string, (user: (typeof users)[number]) => user.name)\n  )\n)\n\nconsole.log(result)\n// [\n//   { name: \"Bob\", age: 25 },\n//   { name: \"Alice\", age: 30 },\n//   { name: \"Charlie\", age: 30 }\n// ]\n```\n\n----------------------------------------\n\nTITLE: Defining TRef Interface in TypeScript\nDESCRIPTION: This code snippet defines the TRef interface in TypeScript, allowing for transactional modification of references. The key method, modify, takes a function that transforms the current reference value and returns a tuple of a new type and the new value. The modify method is unbound for flexibility in extensions.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TRef-TRef.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport interface TRef<in out A> extends TRef.Variance<A>, Pipeable {\n  /**\n   * Note: the method is unbound, exposed only for potential extensions.\n   */\n  modify<B>(f: (a: A) => readonly [B, A]): STM.STM<B>\n}\n```\n\n----------------------------------------\n\nTITLE: Array.intersectionWith Type Definition\nDESCRIPTION: TypeScript type signature for the intersectionWith function, showing its generic type parameter and function overloads for different calling patterns.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Array-intersectionWith.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const intersectionWith: <A>(isEquivalent: (self: A, that: A) => boolean) => { (that: Iterable<A>): (self: Iterable<A>) => Array<A>; (self: Iterable<A>, that: Iterable<A>): Array<A>; }\n```\n\n----------------------------------------\n\nTITLE: Defining Iterable.contains Function in TypeScript\nDESCRIPTION: This code snippet defines the Iterable.contains function, which returns a function to check if an Iterable contains a given value. It uses the default Equivalence for comparison. The function is overloaded to accept either the Iterable first or the value first.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Iterable-contains.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const contains: { <A>(a: A): (self: Iterable<A>) => boolean; <A>(self: Iterable<A>, a: A): boolean; }\n```\n\n----------------------------------------\n\nTITLE: Publishing Multiple Messages to TPubSub in Effect-TS\nDESCRIPTION: The publishAll function publishes all specified messages to a TPubSub instance, returning a boolean indicating whether the messages were successfully published. The function supports both curried and uncurried calling styles.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TPubSub-publishAll.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const publishAll: { <A>(iterable: Iterable<A>): (self: TPubSub<A>) => STM.STM<boolean>; <A>(self: TPubSub<A>, iterable: Iterable<A>): STM.STM<boolean>; }\n```\n\n----------------------------------------\n\nTITLE: Creating a HashSet from an Array in TypeScript\nDESCRIPTION: Demonstrates how to create a HashSet from an array in TypeScript, eliminating duplicate values automatically. The example shows how duplicates in the original array are removed in the resulting HashSet.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/HashSet-fromIterable.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// Creating a HashSet from an Array\nimport { HashSet, pipe } from \"effect\"\n\nconsole.log(\n  pipe(\n    [1, 2, 3, 4, 5, 1, 2, 3], // Array<number> is an Iterable<number>;  Note the duplicates.\n    HashSet.fromIterable,\n    HashSet.toValues\n  )\n) // Output: [1, 2, 3, 4, 5]\n```\n\n----------------------------------------\n\nTITLE: Defining Predicate.struct Function in TypeScript\nDESCRIPTION: The Predicate.struct function takes a record of predicates or refinements and returns a new predicate or refinement that applies to a structured object. It handles different combinations of Refinement and Predicate inputs.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Predicate-struct.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const struct: <R extends Record<string, Predicate.Any>>(fields: R) => [Extract<R[keyof R], Refinement.Any>] extends [never] ? Predicate<{ readonly [K in keyof R]: Predicate.In<R[K]>; }> : Refinement<{ readonly [K in keyof R]: R[K] extends Refinement.Any ? Refinement.In<R[K]> : Predicate.In<R[K]>; }, { readonly [K in keyof R]: R[K] extends Refinement.Any ? Refinement.Out<R[K]> : Predicate.In<R[K]>; }>\n```\n\n----------------------------------------\n\nTITLE: Creating Commands with Process Name and Arguments in TypeScript\nDESCRIPTION: The `make` function creates a command with a specified process name and an optional list of arguments. It is part of the Command module in the @effect/platform package.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Command-make.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const make: (command: string, ...args: Array<string>) => Command\n```\n\n----------------------------------------\n\nTITLE: Defining CliApp Interface in TypeScript\nDESCRIPTION: Defines the CliApp interface that represents a complete command-line application. It extends Pipeable and includes properties for name, version, executable, command, summary, and footer.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/CliApp-CliApp.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface CliApp<A> extends Pipeable {\n  readonly name: string\n  readonly version: string\n  readonly executable: string\n  readonly command: Command<A>\n  readonly summary: Span\n  readonly footer: HelpDoc\n}\n```\n\n----------------------------------------\n\nTITLE: Using orElseSucceed to Handle Errors with Default Values in TypeScript\nDESCRIPTION: This example demonstrates how to use the Effect.orElseSucceed method to ensure an effect always completes successfully by providing a default value. It shows a validation function that may fail, and how orElseSucceed can be used to guarantee a fallback result.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-orElseSucceed.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Effect } from \"effect\"\n\nconst validate = (age: number): Effect.Effect<number, string> => {\n  if (age < 0) {\n    return Effect.fail(\"NegativeAgeError\")\n  } else if (age < 18) {\n    return Effect.fail(\"IllegalAgeError\")\n  } else {\n    return Effect.succeed(age)\n  }\n}\n\nconst program = Effect.orElseSucceed(validate(-1), () => 18)\n\nconsole.log(Effect.runSyncExit(program))\n// Output:\n// { _id: 'Exit', _tag: 'Success', value: 18 }\n```\n\n----------------------------------------\n\nTITLE: Creating Gauge Metric Keys in TypeScript\nDESCRIPTION: Function signature for creating metric keys for gauges. Supports both number and bigint types through options configuration. The function accepts a name parameter and optional configuration including description and bigint flag.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/MetricKey-gauge.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const gauge: { \n  (name: string, options?: { readonly description?: string | undefined; readonly bigint?: false | undefined; }): MetricKey.Gauge<number>; \n  (name: string, options: { readonly description?: string | undefined; readonly bigint: true; }): MetricKey.Gauge<bigint>; \n}\n```\n\n----------------------------------------\n\nTITLE: Transforming Tuples with mapBoth function in effect Tuple - TypeScript\nDESCRIPTION: The `mapBoth` function in the `effect/Tuple` module enables transformation of both elements in a tuple by applying specified functions to each respective element. It requires a tuple as input and an options object containing two functions: `onFirst` and `onSecond`, which define transformations for the first and second elements of the tuple respectively. The function returns a new tuple with transformed elements. Original tuple elements remain unchanged; outputs depend on provided transformations.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Tuple-mapBoth.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { mapBoth } from \"effect/Tuple\"\n\nassert.deepStrictEqual(\n  mapBoth([\"hello\", 42], { onFirst: s => s.toUpperCase(), onSecond: n => n.toString() }),\n  [\"HELLO\", \"42\"]\n)\n```\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const mapBoth: { <L1, L2, R1, R2>(options: { readonly onFirst: (e: L1) => L2; readonly onSecond: (a: R1) => R2; }): (self: readonly [L1, R1]) => [L2, R2]; <L1, R1, L2, R2>(self: readonly [L1, R1], options: { readonly onFirst: (e: L1) => L2; readonly onSecond: (a: R1) => R2; }): [L2, R2]; }\n```\n\n----------------------------------------\n\nTITLE: Using firstSomeOf to find the first Some value in an Option array\nDESCRIPTION: This example demonstrates how to use `Option.firstSomeOf` to find the first `Some` value in an array of `Option` values. The function iterates through the array and returns the first `Some` it encounters, or `None` if no `Some` values are present.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Option-firstSomeOf.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Option } from \"effect\"\n\nconsole.log(Option.firstSomeOf([\n  Option.none(),\n  Option.some(1),\n  Option.some(2)\n]))\n// Output: { _id: 'Option', _tag: 'Some', value: 1 }\n```\n\n----------------------------------------\n\nTITLE: Using Effect.die for Division by Zero Error in TypeScript\nDESCRIPTION: Example demonstrating how to use Effect.die to handle division by zero scenarios by terminating the fiber with a custom error. Shows implementation of a safe division function that terminates execution when attempting to divide by zero.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-die.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Effect } from \"effect\"\n\nconst divide = (a: number, b: number) =>\n  b === 0\n    ? Effect.die(new Error(\"Cannot divide by zero\"))\n    : Effect.succeed(a / b)\n\n//      ┌─── Effect<number, never, never>\n//      ▼\nconst program = divide(1, 0)\n\nEffect.runPromise(program).catch(console.error)\n// Output:\n// (FiberFailure) Error: Cannot divide by zero\n//   ...stack trace...\n```\n\n----------------------------------------\n\nTITLE: Converting Layer to ManagedRuntime in TypeScript using Effect\nDESCRIPTION: Demonstrates how to use ManagedRuntime.make to create a runtime from a Layer, run an Effect, and dispose of the runtime. It includes a custom Notifications service as an example.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/ManagedRuntime-make.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Console, Effect, Layer, ManagedRuntime } from \"effect\"\n\nclass Notifications extends Effect.Tag(\"Notifications\")<\n  Notifications,\n  { readonly notify: (message: string) => Effect.Effect<void> }\n>() {\n  static Live = Layer.succeed(this, { notify: (message) => Console.log(message) })\n}\n\nasync function main() {\n  const runtime = ManagedRuntime.make(Notifications.Live)\n  await runtime.runPromise(Notifications.notify(\"Hello, world!\"))\n  await runtime.dispose()\n}\n\nmain()\n```\n\n----------------------------------------\n\nTITLE: Using HashMap.HashMap.Key Utility to Extract Key Type in TypeScript\nDESCRIPTION: This snippet demonstrates how to use the HashMap.HashMap.Key type-level utility to extract the key type from a HashMap instance. The example declares a HashMap with string keys and number values, then uses the utility to extract the key type.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/HashMap-HashMap.Key.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { HashMap } from \"effect\"\n\ndeclare const hm: HashMap.HashMap<string, number>\n\n// $ExpectType string\ntype K = HashMap.HashMap.Key<typeof hm>\n```\n\n----------------------------------------\n\nTITLE: Setting Configuration Provider with Scope in Effect-TS\nDESCRIPTION: This function sets a configuration provider within a scope and restores the original value when the scope is closed. It accepts a ConfigProvider parameter and returns an Effect that requires a Scope, has no error channel, and produces void.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-withConfigProviderScoped.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const withConfigProviderScoped: (provider: ConfigProvider) => Effect<void, never, Scope.Scope>\n```\n\n----------------------------------------\n\nTITLE: Initializing Stream with Debounce Operator in TypeScript\nDESCRIPTION: Demonstrates how to use the Stream.debounce method to control event emission timing, filtering out rapid successive events and only emitting after a specified pause\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-debounce.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Effect, Stream } from \"effect\"\n\nlet last = Date.now()\nconst log = (message: string) =>\n  Effect.sync(() => {\n    const end = Date.now()\n    console.log(`${message} after ${end - last}ms`)\n    last = end\n  })\n\nconst stream = Stream.make(1, 2, 3).pipe(\n  Stream.concat(\n    Stream.fromEffect(Effect.sleep(\"200 millis\").pipe(Effect.as(4)))\n  ),\n  Stream.concat(Stream.make(5, 6)),\n  Stream.concat(\n    Stream.fromEffect(Effect.sleep(\"150 millis\").pipe(Effect.as(7)))\n  ),\n  Stream.concat(Stream.make(8)),\n  Stream.tap((n) => log(`Received ${n}`)),\n  Stream.debounce(\"100 millis\"),\n  Stream.tap((n) => log(`> Emitted ${n}`))\n)\n\nEffect.runPromise(Stream.runCollect(stream)).then(console.log)\n```\n\n----------------------------------------\n\nTITLE: Using FiberSet.runtime to fork and manage Effect fibers in TypeScript\nDESCRIPTION: This example demonstrates how to use FiberSet.runtime to capture a Runtime and fork Effects, adding them to a FiberSet. It creates a FiberSet, captures a runtime with access to a Users context, and then uses that runtime to execute an effect. The fibers are automatically interrupted when the scope is closed due to Effect.scoped.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/FiberSet-runtime.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Context, Effect, FiberSet } from \"effect\"\n\ninterface Users {\n  readonly _: unique symbol\n}\nconst Users = Context.GenericTag<Users, {\n   getAll: Effect.Effect<Array<unknown>>\n}>(\"Users\")\n\nEffect.gen(function*() {\n  const set = yield* FiberSet.make()\n  const run = yield* FiberSet.runtime(set)<Users>()\n\n  // run some effects and add the fibers to the set\n  run(Effect.andThen(Users, _ => _.getAll))\n}).pipe(\n  Effect.scoped // The fibers will be interrupted when the scope is closed\n)\n```\n\n----------------------------------------\n\nTITLE: Defining Tap Sink Functionality in TypeScript\nDESCRIPTION: This snippet declares the tapSink functionality which allows elements emitted by a stream to be sent to a specified sink while also preserving the original stream emissions. It provides both a curried function and a direct application method.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-tapSink.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const tapSink: { <A, E2, R2>(sink: Sink.Sink<unknown, A, unknown, E2, R2>): <E, R>(self: Stream<A, E, R>) => Stream<A, E2 | E, R2 | R>; <A, E, R, E2, R2>(self: Stream<A, E, R>, sink: Sink.Sink<unknown, A, unknown, E2, R2>): Stream<A, E | E2, R | R2>; }\n```\n\n----------------------------------------\n\nTITLE: Creating a Stream from TQueue in Effect-TS\nDESCRIPTION: The `fromTQueue` function generates a stream that emits values from the provided TQueue. It leverages TypeScript generics to handle different types of values contained in the queue. It requires a valid TDequeue instance as input and returns a Stream instance that yields the same type of values.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-fromTQueue.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const fromTQueue: <A>(queue: TDequeue<A>) => Stream<A>\n```\n\n----------------------------------------\n\nTITLE: Declaring Scoped Stream Runner in TypeScript\nDESCRIPTION: This TypeScript snippet declares a function `runForEachScoped` for processing each element of a stream using a provided effect, allowing controlled finalization. It requires the `Effect` library and optionally uses `Scope`. The function accepts a stream and a function to apply to each element, returning a scoped effect.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-runForEachScoped.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const runForEachScoped: { <A, X, E2, R2>(f: (a: A) => Effect.Effect<X, E2, R2>): <E, R>(self: Stream<A, E, R>) => Effect.Effect<void, E2 | E, Scope.Scope | R2 | R>; <A, E, R, X, E2, R2>(self: Stream<A, E, R>, f: (a: A) => Effect.Effect<X, E2, R2>): Effect.Effect<void, E | E2, Scope.Scope | R | R2>; }\n```\n\n----------------------------------------\n\nTITLE: Consuming Stream Elements with a Callback in TypeScript\nDESCRIPTION: The `runForEachWhile` function takes a callback function that receives stream elements and continues to process them as long as the callback returns `true`. This function is generic, accepting types for elements, errors, and results.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-runForEachWhile.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const runForEachWhile: { <A, E2, R2>(f: (a: A) => Effect.Effect<boolean, E2, R2>): <E, R>(self: Stream<A, E, R>) => Effect.Effect<void, E2 | E, R2 | R>; <A, E, R, E2, R2>(self: Stream<A, E, R>, f: (a: A) => Effect.Effect<boolean, E2, R2>): Effect.Effect<void, E | E2, R | R2>; }\n```\n\n----------------------------------------\n\nTITLE: Scheduling Stream Output in Effect\nDESCRIPTION: The `Stream.schedule` function allows scheduling the output of a stream based on a provided `Schedule`. It takes a stream and a schedule as input and returns a new stream with the outputs scheduled according to the provided schedule. The schedule determines when and how the stream's values are emitted.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-schedule.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const schedule: { <X, A0 extends A, R2, A>(schedule: Schedule.Schedule<X, A0, R2>): <E, R>(self: Stream<A, E, R>) => Stream<A, E, R2 | R>; <A, E, R, X, A0 extends A, R2>(self: Stream<A, E, R>, schedule: Schedule.Schedule<X, A0, R2>): Stream<A, E, R | R2>; }\n```\n\n----------------------------------------\n\nTITLE: Initializing Micro.catchAllDefect TypeScript Function\nDESCRIPTION: A TypeScript function that allows catching unexpected errors in Micro effects and providing a recovery mechanism. It supports both curried and direct function call styles with flexible error and resource handling.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Micro-catchAllDefect.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const catchAllDefect: { <E, B, E2, R2>(f: (defect: unknown) => Micro<B, E2, R2>): <A, R>(self: Micro<A, E, R>) => Micro<A | B, E | E2, R | R2>; <A, E, R, B, E2, R2>(self: Micro<A, E, R>, f: (defect: unknown) => Micro<B, E2, R2>): Micro<A | B, E | E2, R | R2>; }\n```\n\n----------------------------------------\n\nTITLE: Concatenating Lists with List.appendAll in TypeScript\nDESCRIPTION: Demonstrates how to use the List.appendAll function to concatenate two lists of different types. The example shows combining a list of numbers with a list of strings.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/List-appendAll.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { List } from \"effect\"\n\nassert.deepStrictEqual(\n  List.make(1, 2).pipe(List.appendAll(List.make(\"a\", \"b\")), List.toArray),\n  [1, 2, \"a\", \"b\"]\n)\n```\n\n----------------------------------------\n\nTITLE: Using HashSet.some with Different API Styles in TypeScript\nDESCRIPTION: Example demonstrating how to use the HashSet.some function to check if any element in a HashSet satisfies a predicate. Shows three different calling styles: data-last (pipeable) API with pipe function, method chaining with pipe, and data-first API.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/HashSet-some.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// Syntax\nimport { HashSet, pipe } from \"effect\"\n\nconst set: HashSet.HashSet<number> = HashSet.make(0, 1, 2)\n\n// with `data-last`, a.k.a. `pipeable` API\npipe(\n  set,\n  HashSet.some((n) => n > 0)\n) // true\n\n// or piped with the pipe function\nset.pipe(HashSet.some((n) => n > 0)) // true\n\n// or with `data-first` API\nHashSet.some(set, (n) => n > 0) // true\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Doc.column Usage in TypeScript\nDESCRIPTION: This code snippet demonstrates how to use the Doc.column function from @effect/printer to create layouts based on column positions. It includes two examples: one showing basic column-based text layout, and another showing indented layouts with column information.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Doc-column.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport * as Doc from \"@effect/printer/Doc\"\nimport * as String from \"effect/String\"\n\n// Example 1:\nconst example1 = Doc.column((l) =>\n  Doc.hsep([Doc.text(\"Columns are\"), Doc.text(`${l}-based`)])\n)\n\nassert.strictEqual(\n  Doc.render(example1, { style: \"pretty\" }),\n  \"Columns are 0-based\"\n)\n\n// Example 2:\nconst doc = Doc.hsep([\n  Doc.text(\"prefix\"),\n  Doc.column((l) => Doc.text(`| <- column ${l}`))\n])\n\nconst example2 = Doc.vsep([0, 4, 8].map((n) => Doc.indent(n)(doc)))\n\nassert.strictEqual(\n  Doc.render(example2, { style: \"pretty\" }),\n  String.stripMargin(\n    `|prefix | <- column 7\n     |    prefix | <- column 11\n     |        prefix | <- column 15`\n  )\n)\n```\n\n----------------------------------------\n\nTITLE: Using Stream.as to Map Stream Values to a Constant Value in TypeScript\nDESCRIPTION: This example demonstrates how to use the Stream.as method to transform a stream of numbers into a stream of null values. The Stream.range function creates a stream of numbers from 1 to 5, which is then piped through Stream.as to replace all values with null.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-as.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Effect, Stream } from \"effect\"\n\nconst stream = Stream.range(1, 5).pipe(Stream.as(null))\n\nEffect.runPromise(Stream.runCollect(stream)).then(console.log)\n// { _id: 'Chunk', values: [ null, null, null, null, null ] }\n```\n\n----------------------------------------\n\nTITLE: Implementing squashWith Function in TypeScript for Error Transformation\nDESCRIPTION: The squashWith function extracts the most important defect from a Cause object, transforming failures into defects using a provided function. It processes failures, defects, and interruptions in a priority order, applying a custom transformation function to failures before returning them as defects.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Cause-squashWith.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const squashWith: { <E>(f: (error: E) => unknown): (self: Cause<E>) => unknown; <E>(self: Cause<E>, f: (error: E) => unknown): unknown; }\n```\n\n----------------------------------------\n\nTITLE: Replacing Array Element in TypeScript using Effect Library\nDESCRIPTION: Demonstrates how to use the Array.replace function from the Effect library to change an element at a specified index in an array, creating a new array. The function returns a copy of the input if the index is out of bounds.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Array-replace.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Array } from \"effect\"\n\nconst result = Array.replace(['a', 'b', 'c', 'd'], 1, 'z')\nconsole.log(result) // ['a', 'z', 'c', 'd']\n```\n\n----------------------------------------\n\nTITLE: Calculating Time Duration Between DateTimes Using Effect\nDESCRIPTION: Demonstrates how to calculate the duration between two DateTime values using Effect.gen generator function. The example shows adding a minute to the current time and calculating the difference.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/DateTime-distanceDuration.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { DateTime, Effect } from \"effect\"\n\nEffect.gen(function* () {\n  const now = yield* DateTime.now\n  const other = DateTime.add(now, { minutes: 1 })\n\n  // returns Duration.minutes(1)\n  DateTime.distanceDuration(now, other)\n})\n```\n\n----------------------------------------\n\nTITLE: Implementing Safe Array Access with Chunk.get in TypeScript\nDESCRIPTION: Function signature for safely accessing elements in a Chunk data structure. Returns an Option type containing the value if the index exists, or None if the index is out of bounds. Supports both curried and uncurried calling styles.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Chunk-get.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const get: { (index: number): <A>(self: Chunk<A>) => Option<A>; <A>(self: Chunk<A>, index: number): Option<A>; }\n```\n\n----------------------------------------\n\nTITLE: Applying a Function to Each Element in Iterable with STM (TypeScript)\nDESCRIPTION: This code snippet declares the forEach function for applying a given function to each element in an Iterable. It allows for flexible options such as whether to discard results, and it returns a new STM transactional effect that either produces a Chunk or void based on the provided options. The function supports multiple signatures for various use cases.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/STM-forEach.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const forEach: { <A, A2, E, R>(f: (a: A) => STM<A2, E, R>, options?: { readonly discard?: false | undefined; } | undefined): (elements: Iterable<A>) => STM<Array<A2>, E, R>; <A, A2, E, R>(f: (a: A) => STM<A2, E, R>, options: { readonly discard: true; }): (elements: Iterable<A>) => STM<void, E, R>; <A, A2, E, R>(elements: Iterable<A>, f: (a: A) => STM<A2, E, R>, options?: { readonly discard?: false | undefined; } | undefined): STM<Array<A2>, E, R>; <A, A2, E, R>(elements: Iterable<A>, f: (a: A) => STM<A2, E, R>, options: { readonly discard: true; }): STM<void, E, R>; }\n```\n\n----------------------------------------\n\nTITLE: Testing String Type with Effect-TS Predicate in TypeScript\nDESCRIPTION: This code snippet demonstrates the usage of the `isString` predicate from the Effect-TS library to check if input values are strings. It shows two assertions, validating both string and non-string inputs. The predicate is defined to take an unknown input type and determine if it is a string. Ensure that Node.js and the Effect-TS library are properly installed to run this example.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Predicate-isString.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { isString } from \"effect/Predicate\"\n\nassert.deepStrictEqual(isString(\"a\"), true)\n\nassert.deepStrictEqual(isString(1), false)\n```\n\n----------------------------------------\n\nTITLE: Defining FlatMap for Stream in TypeScript\nDESCRIPTION: The flatMap function transforms each element of the source stream using the provided function 'f', which returns a new stream. The results from these streams are concatenated into a single stream in a strict order. It accepts options for concurrency and buffer size, allowing for flexible execution based on the user's needs.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-flatMap.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const flatMap: { <A, A2, E2, R2>(f: (a: A) => Stream<A2, E2, R2>, options?: { readonly concurrency?: number | \"unbounded\" | undefined; readonly bufferSize?: number | undefined; readonly switch?: boolean | undefined; } | undefined): <E, R>(self: Stream<A, E, R>) => Stream<A2, E2 | E, R2 | R>; <A, E, R, A2, E2, R2>(self: Stream<A, E, R>, f: (a: A) => Stream<A2, E2, R2>, options?: { readonly concurrency?: number | \"unbounded\" | undefined; readonly bufferSize?: number | undefined; readonly switch?: boolean | undefined; } | undefined): Stream<A2, E | E2, R | R2>; }\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Trie.get Usage in TypeScript\nDESCRIPTION: This example shows how to use the Trie.get function to safely lookup values in a Trie data structure. It demonstrates inserting key-value pairs and retrieving values for both existing and non-existing keys.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Trie-get.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { Trie, Option } from \"effect\"\n\nconst trie = Trie.empty<number>().pipe(\n  Trie.insert(\"call\", 0),\n  Trie.insert(\"me\", 1),\n  Trie.insert(\"mind\", 2),\n  Trie.insert(\"mid\", 3)\n)\n\nassert.deepStrictEqual(Trie.get(trie, \"call\"), Option.some(0))\nassert.deepStrictEqual(Trie.get(trie, \"me\"), Option.some(1))\nassert.deepStrictEqual(Trie.get(trie, \"mind\"), Option.some(2))\nassert.deepStrictEqual(Trie.get(trie, \"mid\"), Option.some(3))\nassert.deepStrictEqual(Trie.get(trie, \"cale\"), Option.none())\nassert.deepStrictEqual(Trie.get(trie, \"ma\"), Option.none())\nassert.deepStrictEqual(Trie.get(trie, \"midn\"), Option.none())\nassert.deepStrictEqual(Trie.get(trie, \"mea\"), Option.none())\n```\n\n----------------------------------------\n\nTITLE: Creating Nominal Types with Brand.nominal in TypeScript\nDESCRIPTION: This example demonstrates how to create a nominal type (UserId) using Brand.nominal(). The function creates a branded type that allows distinguishing between different values of the same base type (number) without performing runtime validation.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Brand-nominal.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { Brand } from \"effect\"\n\ntype UserId = number & Brand.Brand<\"UserId\">\n\nconst UserId = Brand.nominal<UserId>()\n\nconsole.log(UserId(1))\n// 1\n```\n\n----------------------------------------\n\nTITLE: Merging Multiple Contexts in TypeScript using Effect Library\nDESCRIPTION: Demonstrates how to use Context.mergeAll to combine multiple Context objects containing different services. The example creates three separate contexts with Port, Timeout, and Host services, then merges them into a single Services context.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Context-mergeAll.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { Context } from \"effect\"\n\nconst Port = Context.GenericTag<{ PORT: number }>(\"Port\")\nconst Timeout = Context.GenericTag<{ TIMEOUT: number }>(\"Timeout\")\nconst Host = Context.GenericTag<{ HOST: string }>(\"Host\")\n\nconst firstContext = Context.make(Port, { PORT: 8080 })\nconst secondContext = Context.make(Timeout, { TIMEOUT: 5000 })\nconst thirdContext = Context.make(Host, { HOST: \"localhost\" })\n\nconst Services = Context.mergeAll(firstContext, secondContext, thirdContext)\n\nassert.deepStrictEqual(Context.get(Services, Port), { PORT: 8080 })\nassert.deepStrictEqual(Context.get(Services, Timeout), { TIMEOUT: 5000 })\nassert.deepStrictEqual(Context.get(Services, Host), { HOST: \"localhost\" })\n```\n\n----------------------------------------\n\nTITLE: Converting HashMap to Array Entries in TypeScript\nDESCRIPTION: A utility function that converts a HashMap data structure into an array of key-value pair tuples. Takes a HashMap<K, V> as input and returns Array<[K, V]> containing all entries from the map.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/HashMap-toEntries.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const toEntries: <K, V>(self: HashMap<K, V>) => Array<[K, V]>\n```\n\n----------------------------------------\n\nTITLE: Stream Concatenation Example in TypeScript\nDESCRIPTION: This code snippet demonstrates how to concatenate two streams using `Stream.concat` from the Effect library. It creates two streams, `s1` and `s2`, and concatenates them into a new stream. The resulting stream is then collected into a single chunk and printed to the console.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-concat.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Effect, Stream } from \"effect\"\n\nconst s1 = Stream.make(1, 2, 3)\nconst s2 = Stream.make(4, 5)\n\nconst stream = Stream.concat(s1, s2)\n\nEffect.runPromise(Stream.runCollect(stream)).then(console.log)\n// { _id: 'Chunk', values: [ 1, 2, 3, 4, 5 ] }\n```\n\n----------------------------------------\n\nTITLE: Defining whileOutput Function in TypeScript for Effect-TS Schedule Module\nDESCRIPTION: This code snippet defines the whileOutput function, which returns a new schedule that continues execution as long as a given predicate on the output evaluates to true. It can be used in two ways: with the schedule as the first argument or as a curried function.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Schedule-whileOutput.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const whileOutput: {\n  <Out>(f: Predicate<Out>): <In, R>(self: Schedule<Out, In, R>) => Schedule<Out, In, R>;\n  <Out, In, R>(self: Schedule<Out, In, R>, f: Predicate<Out>): Schedule<Out, In, R>;\n}\n```\n\n----------------------------------------\n\nTITLE: Partitioning a Stream with an Effectful Predicate in TypeScript\nDESCRIPTION: This example demonstrates how to use Stream.partitionEither to split a stream of numbers into even and odd substreams. It uses an effectful predicate to determine which substream each element belongs to, and then collects and logs the results.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-partitionEither.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Effect, Either, Stream } from \"effect\"\n\nconst partition = Stream.range(1, 9).pipe(\n  Stream.partitionEither(\n    (n) => Effect.succeed(n % 2 === 0 ? Either.right(n) : Either.left(n)),\n    { bufferSize: 5 }\n  )\n)\n\nconst program = Effect.scoped(\n  Effect.gen(function*() {\n    const [evens, odds] = yield* partition\n    console.log(yield* Stream.runCollect(evens))\n    console.log(yield* Stream.runCollect(odds))\n  })\n)\n\nEffect.runPromise(program)\n// { _id: 'Chunk', values: [ 1, 3, 5, 7, 9 ] }\n// { _id: 'Chunk', values: [ 2, 4, 6, 8 ] }\n```\n\n----------------------------------------\n\nTITLE: Implementing Stream Timeout in TypeScript with Effect-TS\nDESCRIPTION: Defines a timeout function that takes a duration parameter and terminates a stream if it doesn't emit values within the specified time period. The function supports both curried and uncurried calling styles, working with generic stream types.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-timeout.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const timeout: { \n  (duration: Duration.DurationInput): <A, E, R>(self: Stream<A, E, R>) => Stream<A, E, R>; \n  <A, E, R>(self: Stream<A, E, R>, duration: Duration.DurationInput): Stream<A, E, R>; \n}\n```\n\n----------------------------------------\n\nTITLE: Using BigDecimal.min Function in TypeScript\nDESCRIPTION: Demonstrates how to use the min function from the BigDecimal module to find the minimum of two BigDecimal values. It uses the unsafeFromString function to create BigDecimal instances and assert to verify the result.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/BigDecimal-min.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { min, unsafeFromString } from \"effect/BigDecimal\"\n\nassert.deepStrictEqual(min(unsafeFromString(\"2\"), unsafeFromString(\"3\")), unsafeFromString(\"2\"))\n```\n\n----------------------------------------\n\nTITLE: Effect.firstSuccessOf Type Signature in TypeScript\nDESCRIPTION: The type signature for the firstSuccessOf function, which takes an iterable of effects and returns an effect that will yield the first successful result or the error of the last effect if all fail.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-firstSuccessOf.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const firstSuccessOf: <Eff extends Effect<any, any, any>>(effects: Iterable<Eff>) => Effect<Effect.Success<Eff>, Effect.Error<Eff>, Effect.Context<Eff>>\n```\n\n----------------------------------------\n\nTITLE: Using Option.orElseSome with Effect in TypeScript\nDESCRIPTION: This example demonstrates how to use `Option.orElseSome` to provide a default value when an `Option` is `None`. If the original `Option` is `Some`, its value is returned; otherwise, the provided function is executed and its result is wrapped in `Some`.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Option-orElseSome.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Option } from \"effect\"\n\nconsole.log(Option.none().pipe(Option.orElseSome(() => \"b\")))\n// Output: { _id: 'Option', _tag: 'Some', value: 'b' }\n\nconsole.log(Option.some(\"a\").pipe(Option.orElseSome(() => \"b\")))\n// Output: { _id: 'Option', _tag: 'Some', value: 'a' }\n```\n\n----------------------------------------\n\nTITLE: Implementing Request Transformation in Effect HTTP Client - TypeScript\nDESCRIPTION: Defines a function that transforms HTTP client requests through an Effect pipeline. The function allows for effectful transformation of request objects before they are sent, supporting both curried and uncurried calling styles. It can combine error types and environment requirements from both the original client and the transformation.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/HttpClient-mapRequestInputEffect.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const mapRequestInputEffect: {\n  <E2, R2>(f: (a: ClientRequest.HttpClientRequest) => Effect.Effect<ClientRequest.HttpClientRequest, E2, R2>): <E, R>(self: HttpClient.With<E, R>) => HttpClient.With<E | E2, R | R2>;\n  <E, R, E2, R2>(self: HttpClient.With<E, R>, f: (a: ClientRequest.HttpClientRequest) => Effect.Effect<ClientRequest.HttpClientRequest, E2, R2>): HttpClient.With<E | E2, R | R2>;\n}\n```\n\n----------------------------------------\n\nTITLE: STM.ignore function signature in TypeScript\nDESCRIPTION: This code snippet shows the type signature of the `STM.ignore` function. It takes an `STM` effect with result type `A`, error type `E`, and environment type `R` as input and returns a new `STM` effect with a result type of `void`, no error type (`never`), and the same environment type `R`. This effectively ignores the original result and any potential errors.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/STM-ignore.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const ignore: <A, E, R>(self: STM<A, E, R>) => STM<void, never, R>\n```\n\n----------------------------------------\n\nTITLE: Merging Layers Concurrently in TypeScript\nDESCRIPTION: The merge function combines two layers concurrently, creating a new layer with combined input and output types. It supports both curried and uncurried versions of the function.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Layer-merge.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const merge: { <RIn2, E2, ROut2>(that: Layer<ROut2, E2, RIn2>): <RIn, E1, ROut>(self: Layer<ROut, E1, RIn>) => Layer<ROut2 | ROut, E2 | E1, RIn2 | RIn>; <RIn, E1, ROut, RIn2, E2, ROut2>(self: Layer<ROut, E1, RIn>, that: Layer<ROut2, E2, RIn2>): Layer<ROut | ROut2, E1 | E2, RIn | RIn2>; }\n```\n\n----------------------------------------\n\nTITLE: Implementing Metric Tracking Aspect in TypeScript\nDESCRIPTION: Defines a trackAll function that creates an aspect to update a metric with a specified constant value whenever the aspect is applied to an effect. The tracking occurs regardless of whether the effect succeeds or fails. The function supports both curried and non-curried parameter orders.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Metric-trackAll.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const trackAll: { \n  <In>(input: In): <Type, Out>(self: Metric<Type, In, Out>) => <A, E, R>(effect: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>; \n  <Type, In, Out>(self: Metric<Type, In, Out>, input: In): <A, E, R>(effect: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>; \n}\n```\n\n----------------------------------------\n\nTITLE: Annotating DocTree in TypeScript\nDESCRIPTION: The annotation function is used to annotate a DocTree with an annotation of type A. It can be called with the annotation first and then the DocTree, or with the DocTree first and then the annotation.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/DocTree-annotation.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const annotation: { <A>(annotation: A): <B>(self: DocTree<B>) => DocTree<A | B>; <A, B>(self: DocTree<A>, annotation: B): DocTree<A | B>; }\n```\n\n----------------------------------------\n\nTITLE: Handling Success or Failure with Either in TypeScript\nDESCRIPTION: Demonstrates using Effect.either to handle both success and failure cases when racing effects, wrapping results in an Either type.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-race.md#2025-04-11_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Effect, Console } from \"effect\"\n\nconst task1 = Effect.fail(\"task1\").pipe(\n  Effect.delay(\"100 millis\"),\n  Effect.tap(Console.log(\"task1 done\")),\n  Effect.onInterrupt(() => Console.log(\"task1 interrupted\"))\n)\nconst task2 = Effect.succeed(\"task2\").pipe(\n  Effect.delay(\"200 millis\"),\n  Effect.tap(Console.log(\"task2 done\")),\n  Effect.onInterrupt(() => Console.log(\"task2 interrupted\"))\n)\n\n// Run both tasks concurrently, wrapping the result\n// in Either to capture success or failure\nconst program = Effect.race(Effect.either(task1), Effect.either(task2))\n\nEffect.runPromise(program).then(console.log)\n// Output:\n// task2 interrupted\n// { _id: 'Either', _tag: 'Left', left: 'task1' }\n```\n\n----------------------------------------\n\nTITLE: Reading and Modifying URL Query Parameters Using TypeScript\nDESCRIPTION: This TypeScript function from the @effect/platform package allows you to read, modify, and update query parameters of a URL. It offers a functional approach by reading current parameters, applying a provided transformation function, and returning a new URL object with updated parameters. Key dependencies include the Url and UrlParams modules from @effect/platform. It requires a URL object and a transformation function, returning a new URL object with the changes applied.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Url-modifyUrlParams.md#2025-04-11_snippet_0\n\nLANGUAGE: ts\nCODE:\n```\nimport { Url, UrlParams } from \"@effect/platform\"\n\nconst myUrl = new URL(\"https://example.com?foo=bar\")\n\nconst changedUrl = Url.modifyUrlParams(myUrl, UrlParams.append(\"key\", \"value\"))\n\nconsole.log(changedUrl.toString())\n// Output: https://example.com/?foo=bar&key=value\n```\n\nLANGUAGE: ts\nCODE:\n```\ndeclare const modifyUrlParams: { (f: (urlParams: UrlParams.UrlParams) => UrlParams.UrlParams): (url: URL) => URL; (url: URL, f: (urlParams: UrlParams.UrlParams) => UrlParams.UrlParams): URL; }\n```\n\n----------------------------------------\n\nTITLE: Creating a HashMap from Iterable Collection in TypeScript\nDESCRIPTION: Creates a new HashMap from an iterable collection of key/value pairs. This function allows converting collections like arrays or other iterables into a HashMap data structure.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/HashMap-fromIterable.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const fromIterable: <K, V>(entries: Iterable<readonly [K, V]>) => HashMap<K, V>\n```\n\n----------------------------------------\n\nTITLE: Signature for Stream.mergeWith Effect-TS TypeScript\nDESCRIPTION: This TypeScript snippet, a declaration for the mergeWith function, describes how the function merges two streams, allowing for custom mapping of elements from each stream and optional configuration of the termination strategy. It establishes function overloading to account for different order and number of parameters. The function is part of the Stream module in Effect-TS. Key parameters include two input streams, mapping functions for elements, and an optional halt strategy. Outputs a merged stream.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-mergeWith.md#2025-04-11_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const mergeWith: { <A2, E2, R2, A, A3, A4>(other: Stream<A2, E2, R2>, options: { readonly onSelf: (a: A) => A3; readonly onOther: (a2: A2) => A4; readonly haltStrategy?: HaltStrategy.HaltStrategyInput | undefined; }): <E, R>(self: Stream<A, E, R>) => Stream<A3 | A4, E2 | E, R2 | R>; <A, E, R, A2, E2, R2, A3, A4>(self: Stream<A, E, R>, other: Stream<A2, E2, R2>, options: { readonly onSelf: (a: A) => A3; readonly onOther: (a2: A2) => A4; readonly haltStrategy?: HaltStrategy.HaltStrategyInput | undefined; }): Stream<A3 | A4, E | E2, R | R2>; }\n```\n\n----------------------------------------\n\nTITLE: Handling Parallel Streams with drainFork in TypeScript\nDESCRIPTION: The 'drainFork' utility handles concurrent execution of two streams, ensuring that the provided stream runs in the background as long as the main stream is active. If the main stream finishes first, it interrupts the second stream. Dependencies include the `effect` package, specifically the `Stream` module. The main parameters are 'self' and 'that', representing the primary stream and the background stream respectively. The utility returns a new stream that combines effects, with a failure occurring if the background stream fails.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-drainFork.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const drainFork: { <A2, E2, R2>(that: Stream<A2, E2, R2>): <A, E, R>(self: Stream<A, E, R>) => Stream<A, E2 | E, R2 | R>; <A, E, R, A2, E2, R2>(self: Stream<A, E, R>, that: Stream<A2, E2, R2>): Stream<A, E | E2, R | R2>; }\n```\n\n----------------------------------------\n\nTITLE: Implementing Micro.onInterrupt Handler in TypeScript\nDESCRIPTION: Defines a generic interrupt handler for Micro effects that executes a finalizer when the effect is aborted. Supports both curried and non-curried function signatures for flexibility in implementation.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Micro-onInterrupt.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const onInterrupt: {\n  <XE, XR>(finalizer: Micro<void, XE, XR>): <A, E, R>(self: Micro<A, E, R>) => Micro<A, E | XE, R | XR>;\n  <A, E, R, XE, XR>(self: Micro<A, E, R>, finalizer: Micro<void, XE, XR>): Micro<A, E | XE, R | XR>;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing FilterMapWhile Function in TypeScript\nDESCRIPTION: Defines a function that transforms elements of an Iterable as long as the specified function returns some value. The function takes a mapping function that converts elements of type A to Option<B> and returns a new Iterable of type B.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Iterable-filterMapWhile.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const filterMapWhile: { <A, B>(f: (a: A, i: number) => Option<B>): (self: Iterable<A>) => Iterable<B>; <A, B>(self: Iterable<A>, f: (a: A, i: number) => Option<B>): Iterable<B>; }\n```\n\n----------------------------------------\n\nTITLE: Implementing Recursive Fibonacci using Effect.suspend in TypeScript\nDESCRIPTION: This example demonstrates how Effect.suspend can be used to handle circular dependencies in recursive functions, preventing stack overflow errors.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-suspend.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Effect } from \"effect\"\n\nconst blowsUp = (n: number): Effect.Effect<number> =>\n  n < 2\n    ? Effect.succeed(1)\n    : Effect.zipWith(blowsUp(n - 1), blowsUp(n - 2), (a, b) => a + b)\n\nconsole.log(Effect.runSync(blowsUp(32)))\n// crash: JavaScript heap out of memory\n\nconst allGood = (n: number): Effect.Effect<number> =>\n  n < 2\n    ? Effect.succeed(1)\n    : Effect.zipWith(\n        Effect.suspend(() => allGood(n - 1)),\n        Effect.suspend(() => allGood(n - 2)),\n        (a, b) => a + b\n      )\n\nconsole.log(Effect.runSync(allGood(32)))\n// Output: 3524578\n```\n\n----------------------------------------\n\nTITLE: Creating a Traced Function with Delay in TypeScript\nDESCRIPTION: Illustrates how to use Effect.fn as a pipe function to create a pipeline that processes the effect returned by the generator function, in this case adding a delay based on the function arguments.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-fn.md#2025-04-11_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Effect } from \"effect\"\n\nconst myfunc = Effect.fn(\n  function* (n: number) {\n    console.log(`got: ${n}`)\n    yield* Effect.fail(new Error(\"Boom!\"))\n  },\n  // You can access both the created effect and the original arguments\n  (effect, n) => Effect.delay(effect, `${n / 100} seconds`)\n)\n\nEffect.runFork(myfunc(100).pipe(Effect.catchAllCause(Effect.logError)))\n// Output:\n// got: 100\n// timestamp=... level=ERROR fiber=#0 cause=\"Error: Boom! (<= after 1 second)\n```\n\n----------------------------------------\n\nTITLE: FiberSet.join Function Signature in TypeScript\nDESCRIPTION: This code snippet shows the TypeScript signature for the FiberSet.join function. It takes a FiberSet as input and returns an Effect that resolves to void or fails with an error of type E.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/FiberSet-join.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const join: <A, E>(self: FiberSet<A, E>) => Effect.Effect<void, E>\n```\n\n----------------------------------------\n\nTITLE: Defining flatMap Function for Sequential Channel Combination in TypeScript\nDESCRIPTION: The flatMap function returns a new channel that sequentially combines the original channel with another channel created by a factory function. The factory function uses the terminal value of the original channel to create the second channel. The resulting channel performs the operations of the original channel first, then the operations of the created channel.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Channel-flatMap.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const flatMap: { <OutDone, OutElem1, InElem1, OutErr1, InErr1, OutDone2, InDone1, Env1>(f: (d: OutDone) => Channel<OutElem1, InElem1, OutErr1, InErr1, OutDone2, InDone1, Env1>): <OutElem, InElem, OutErr, InErr, InDone, Env>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>) => Channel<OutElem1 | OutElem, InElem & InElem1, OutErr1 | OutErr, InErr & InErr1, OutDone2, InDone & InDone1, Env1 | Env>; <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutElem1, InElem1, OutErr1, InErr1, OutDone2, InDone1, Env1>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>, f: (d: OutDone) => Channel<OutElem1, InElem1, OutErr1, InErr1, OutDone2, InDone1, Env1>): Channel<OutElem | OutElem1, InElem & InElem1, OutErr | OutErr1, InErr & InErr1, OutDone2, InDone & InDone1, Env | Env1>; }\n```\n\n----------------------------------------\n\nTITLE: Executing Asynchronous Effects with Callbacks in TypeScript\nDESCRIPTION: The runCallback function executes an effect asynchronously and passes the exit value to a specified callback. This is an effectful operation intended for use at program boundaries. It supports multiple call signatures for flexibility.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Runtime-runCallback.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const runCallback: { <R>(runtime: Runtime<R>): <A, E>(effect: Effect.Effect<A, E, R>, options?: RunCallbackOptions<A, E> | undefined) => (fiberId?: FiberId.FiberId, options?: RunCallbackOptions<A, E> | undefined) => void; <R, A, E>(runtime: Runtime<R>, effect: Effect.Effect<A, E, R>, options?: RunCallbackOptions<A, E> | undefined): (fiberId?: FiberId.FiberId, options?: RunCallbackOptions<A, E> | undefined) => void; }\n```\n\n----------------------------------------\n\nTITLE: Declaring STM orElse Functionality in TypeScript\nDESCRIPTION: The 'orElse' function attempts the provided STM effect, and if it fails or retries, it tries a second effect. It is designed for managing sequential STM operations where the second operation acts as a fallback in case the first fails. Dependencies include the STM module, and inputs are LazyArg instances with STM-created effects. The function outputs an STM operation with a combined effect signature.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/STM-orElse.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const orElse: { <A2, E2, R2>(that: LazyArg<STM<A2, E2, R2>>): <A, E, R>(self: STM<A, E, R>) => STM<A2 | A, E2, R2 | R>; <A, E, R, A2, E2, R2>(self: STM<A, E, R>, that: LazyArg<STM<A2, E2, R2>>): STM<A | A2, E2, R | R2>; }\n```\n\n----------------------------------------\n\nTITLE: Using Boolean.eqv for XNOR Operations in TypeScript\nDESCRIPTION: The eqv function combines two boolean values using the XNOR (exclusive NOR) operation, which returns true when both inputs are the same. It can be used in both curried and uncurried forms.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Boolean-eqv.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { eqv } from \"effect/Boolean\"\n\nassert.deepStrictEqual(eqv(true, true), true)\nassert.deepStrictEqual(eqv(true, false), false)\nassert.deepStrictEqual(eqv(false, true), false)\nassert.deepStrictEqual(eqv(false, false), true)\n```\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const eqv: { (that: boolean): (self: boolean) => boolean; (self: boolean, that: boolean): boolean; }\n```\n\n----------------------------------------\n\nTITLE: Retrieving Last Element from Chunk in TypeScript\nDESCRIPTION: The last function retrieves the last element of a Chunk if it exists, returning an Option type that may or may not contain a value. This function is useful for safely accessing the last element without causing errors when the Chunk is empty.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Chunk-last.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const last: <A>(self: Chunk<A>) => Option<A>\n```\n\n----------------------------------------\n\nTITLE: Declaring filterOrElse Function for HTTP Client Response Filtering in TypeScript\nDESCRIPTION: Defines the filterOrElse function which filters the result of an HTTP client response. If the predicate fails, it runs an alternative effect. The function is overloaded to work with both curried and non-curried forms.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/HttpClient-filterOrElse.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const filterOrElse: { <E2, R2>(predicate: Predicate.Predicate<ClientResponse.HttpClientResponse>, orElse: (response: ClientResponse.HttpClientResponse) => Effect.Effect<ClientResponse.HttpClientResponse, E2, R2>): <E, R>(self: HttpClient.With<E, R>) => HttpClient.With<E2 | E, R2 | R>; <E, R, E2, R2>(self: HttpClient.With<E, R>, predicate: Predicate.Predicate<ClientResponse.HttpClientResponse>, orElse: (response: ClientResponse.HttpClientResponse) => Effect.Effect<ClientResponse.HttpClientResponse, E2, R2>): HttpClient.With<E2 | E, R2 | R>; }\n```\n\n----------------------------------------\n\nTITLE: Declaration of Option.gen\nDESCRIPTION: This code snippet shows the type declaration for `Option.gen`. It declares `gen` as a constant of type `Gen.Gen` parameterized with `OptionTypeLambda` and `Gen.Adapter<OptionTypeLambda>`. This declaration provides type safety and facilitates the generator-based syntax.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Option-gen.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const gen: Gen.Gen<OptionTypeLambda, Gen.Adapter<OptionTypeLambda>>\n```\n\n----------------------------------------\n\nTITLE: Defining RequestResolver Interface in TypeScript\nDESCRIPTION: The RequestResolver interface definition that handles execution of request batches. It includes methods for running collections of requests organized in batches for sequential and parallel execution, as well as an identification mechanism.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/RequestResolver-RequestResolver.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface RequestResolver<in A, out R = never> extends RequestResolver.Variance<A, R>, Equal.Equal, Pipeable {\n  /**\n   * Execute a collection of requests. The outer `Array` represents batches\n   * of requests that must be performed sequentially. The inner `Array`\n   * represents a batch of requests that can be performed in parallel.\n   */\n  runAll(requests: Array<Array<Request.Entry<A>>>): Effect.Effect<void, never, R>\n\n  /**\n   * Identify the data source using the specific identifier\n   */\n  identified(...identifiers: Array<unknown>): RequestResolver<A, R>\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Batched Embeddings Service with TypeScript Effect\nDESCRIPTION: Defines a function to create an Embeddings service that aggregates and batches embedding requests. The service collects requests within a specified time window and processes them together, with optional maximum batch size limits.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Embeddings-makeDataLoader.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const makeDataLoader: (options: { readonly embedMany: (input: ReadonlyArray<string>) => Effect.Effect<Array<Embeddings.Result>, AiError>; readonly window: Duration.DurationInput; readonly maxBatchSize?: number; }) => Effect.Effect<Embeddings.Service, never, Scope>\n```\n\n----------------------------------------\n\nTITLE: Streaming Command Output as Lines in TypeScript\nDESCRIPTION: Runs a command and returns the output as a stream of lines with the specified encoding. This function produces a Stream that emits each line of the command's output as a string.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Command-streamLines.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const streamLines: (command: Command, encoding?: string) => Stream<string, PlatformError, CommandExecutor>\n```\n\n----------------------------------------\n\nTITLE: Filtering Options from Lists in TypeScript using Effect-TS\nDESCRIPTION: The compact function removes all None values from a List containing Option types. It transforms List<Option<A>> into List<A> by filtering out None values and unwrapping Some values.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/List-compact.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const compact: <A>(self: List<Option.Option<A>>) => List<A>\n```\n\n----------------------------------------\n\nTITLE: Running Stream Sinks in TypeScript\nDESCRIPTION: The `run` function executes a given sink on a stream to produce either the sink's result or an error. It requires two main parameters: a `Stream` and a `Sink`. The function returns an `Effect` which indicates the successful execution with the stream's result or an error. Dependency on the `Scope` is excluded from the return type. This function is available since version 2.0.0.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-run.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const run: { <A2, A, E2, R2>(sink: Sink.Sink<A2, A, unknown, E2, R2>): <E, R>(self: Stream<A, E, R>) => Effect.Effect<A2, E2 | E, Exclude<R | R2, Scope.Scope>>; <A, E, R, A2, E2, R2>(self: Stream<A, E, R>, sink: Sink.Sink<A2, A, unknown, E2, R2>): Effect.Effect<A2, E | E2, Exclude<R | R2, Scope.Scope>>; }\n```\n\n----------------------------------------\n\nTITLE: Defining Stream.dropWhileEffect in Effect (TypeScript)\nDESCRIPTION: The `dropWhileEffect` function in the Stream API drops elements from the stream as long as the provided predicate evaluates to `true` within an effectful context. It requires the use of the `Effect.Effect` type to manage effects, and operates on a stream of type `Stream<A, E, R>`. The expected inputs include a `Stream` and a predicate function that returns an `Effect`. The result is a transformed stream where elements are skipped based on the predicate's evaluation. This function is available since version 2.0.0.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-dropWhileEffect.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const dropWhileEffect: { <A, E2, R2>(predicate: (a: NoInfer<A>) => Effect.Effect<boolean, E2, R2>): <E, R>(self: Stream<A, E, R>) => Stream<A, E2 | E, R2 | R>; <A, E, R, E2, R2>(self: Stream<A, E, R>, predicate: (a: A) => Effect.Effect<boolean, E2, R2>): Stream<A, E | E2, R | R2>; }\n```\n\n----------------------------------------\n\nTITLE: TypeScript Function Signature for Effect.parallelFinalizers\nDESCRIPTION: This code snippet shows the TypeScript function signature for the Effect.parallelFinalizers function. It takes an Effect as input and returns a modified Effect with parallel finalizer behavior.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-parallelFinalizers.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const parallelFinalizers: <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R>\n```\n\n----------------------------------------\n\nTITLE: Creating a RequestResolver with make Function in TypeScript\nDESCRIPTION: Constructs a data source with a specified identifier and method to run requests. The function takes a handler that processes batched requests and returns a RequestResolver instance.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/RequestResolver-make.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const make: <A, R>(runAll: (requests: Array<Array<A>>) => Effect.Effect<void, never, R>) => RequestResolver<A, R>\n```\n\n----------------------------------------\n\nTITLE: Using Effect.every with TypeScript Effect Framework\nDESCRIPTION: Demonstrates how to use Effect.every to check if all numbers in an array are even using an effectful predicate. The example shows creating a predicate function that returns an Effect, applying it to an array of numbers, and running the effect to get the result.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-every.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Effect } from \"effect\"\n\nconst numbers = [2, 4, 6, 8]\nconst predicate = (n: number, i: number) => Effect.succeed(n % 2 === 0)\n\nconst program = Effect.gen(function*() {\n  const allEven = yield* Effect.every(numbers, predicate)\n  console.log(allEven)\n})\n\nEffect.runFork(program)\n// Output: true\n```\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const every: { <A, E, R>(predicate: (a: A, i: number) => Effect<boolean, E, R>): (elements: Iterable<A>) => Effect<boolean, E, R>; <A, E, R>(elements: Iterable<A>, predicate: (a: A, i: number) => Effect<boolean, E, R>): Effect<boolean, E, R>; }\n```\n\n----------------------------------------\n\nTITLE: Implementing Error Handling with Channel.catchAll in TypeScript\nDESCRIPTION: The catchAll function returns a new channel that behaves like the original one, but if the original channel errors with any typed error, it switches to using the fallback channel provided by the error handler function. This allows for comprehensive error handling in channel-based operations.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Channel-catchAll.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const catchAll: { <OutErr, OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>(f: (error: OutErr) => Channel<OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>): <OutElem, InElem, InErr, OutDone, InDone, Env>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>) => Channel<OutElem1 | OutElem, InElem & InElem1, OutErr1, InErr & InErr1, OutDone1 | OutDone, InDone & InDone1, Env1 | Env>; <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>, f: (error: OutErr) => Channel<OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>): Channel<OutElem | OutElem1, InElem & InElem1, OutErr1, InErr & InErr1, OutDone | OutDone1, InDone & InDone1, Env | Env1>; }\n```\n\n----------------------------------------\n\nTITLE: Completing a Deferred with an Effect Result in TypeScript\nDESCRIPTION: This function completes a deferred value with the result of a specified effect. It returns a boolean indicating whether the completion was successful. If the deferred has already been completed, the method returns false.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Deferred-completeWith.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const completeWith: { <A, E>(effect: Effect.Effect<A, E>): (self: Deferred<A, E>) => Effect.Effect<boolean>; <A, E>(self: Deferred<A, E>, effect: Effect.Effect<A, E>): Effect.Effect<boolean>; }\n```\n\n----------------------------------------\n\nTITLE: Type Guard Conversion with Option.toRefinement in Typescript\nDESCRIPTION: This example demonstrates how to convert an Option-returning function `parseString` into a type guard `isString` using `Option.toRefinement`. The `isString` type guard is then used to check if a variable is a string, returning `true` if it is and `false` otherwise. This is useful for type narrowing and safe handling of union types.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Option-toRefinement.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Option } from \"effect\"\n\ntype MyData = string | number\n\nconst parseString = (data: MyData): Option.Option<string> =>\n  typeof data === \"string\" ? Option.some(data) : Option.none()\n\n//      ┌─── (a: MyData) => a is string\n//      ▼\nconst isString = Option.toRefinement(parseString)\n\nconsole.log(isString(\"a\"))\n// Output: true\n\nconsole.log(isString(1))\n// Output: false\n```\n\n----------------------------------------\n\nTITLE: Adding Scoped Log Annotations in TypeScript using Effect\nDESCRIPTION: Demonstrates how to add key-value annotations to logs within a specific scope using Effect.annotateLogsScoped. The example shows how annotations are applied to logs within the scope and automatically removed once the scope ends.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-annotateLogsScoped.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Effect } from \"effect\"\n\nconst program = Effect.gen(function*() {\n  yield* Effect.log(\"no annotations\")\n  yield* Effect.annotateLogsScoped({ key: \"value\" })\n  yield* Effect.log(\"message1\") // Annotation is applied to this log\n  yield* Effect.log(\"message2\") // Annotation is applied to this log\n}).pipe(Effect.scoped, Effect.andThen(Effect.log(\"no annotations again\")))\n\nEffect.runFork(program)\n// timestamp=... level=INFO fiber=#0 message=\"no annotations\"\n// timestamp=... level=INFO fiber=#0 message=message1 key=value\n// timestamp=... level=INFO fiber=#0 message=message2 key=value\n// timestamp=... level=INFO fiber=#0 message=\"no annotations again\"\n```\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const annotateLogsScoped: { (key: string, value: unknown): Effect<void, never, Scope.Scope>; (values: Record<string, unknown>): Effect<void, never, Scope.Scope>; }\n```\n\n----------------------------------------\n\nTITLE: Implementing Effect.tryMap in TypeScript\nDESCRIPTION: Function signature for Effect.tryMap that maps an effect's success value using a side-effecting try function and converts errors to typed failed effects using a catch function. Works with synchronous computations.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-tryMap.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const tryMap: { <A, B, E1>(options: { readonly try: (a: A) => B; readonly catch: (error: unknown) => E1; }): <E, R>(self: Effect<A, E, R>) => Effect<B, E1 | E, R>; <A, E, R, B, E1>(self: Effect<A, E, R>, options: { readonly try: (a: A) => B; readonly catch: (error: unknown) => E1; }): Effect<B, E | E1, R>; }\n```\n\n----------------------------------------\n\nTITLE: Using Array.dropRight in Effect-TS\nDESCRIPTION: Demonstrates how to use Array.dropRight to remove a specified number of elements from the end of an array. The function normalizes the input number to a non-negative integer and returns a new array.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Array-dropRight.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Array } from \"effect\"\n\nconst result = Array.dropRight([1, 2, 3, 4, 5], 2)\nconsole.log(result) // [1, 2, 3]\n```\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const dropRight: { (n: number): <A>(self: Iterable<A>) => Array<A>; <A>(self: Iterable<A>, n: number): Array<A>; }\n```\n\n----------------------------------------\n\nTITLE: Defining Request Interface in TypeScript\nDESCRIPTION: Defines a generic Request interface that represents a request to a data source for a value of type A that may fail with an error of type E. The interface extends Request.Variance with the same type parameters.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Request-Request.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface Request<out A, out E = never> extends Request.Variance<A, E> {}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Doc.width Usage in TypeScript\nDESCRIPTION: This example shows how to use the Doc.width combinator to make the column width of a document available while rendering. It creates an annotate function that adds width information to documents and applies it to various document layouts.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Doc-width.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport * as Doc from \"@effect/printer/Doc\"\nimport { pipe } from \"effect/Function\"\nimport * as String from \"effect/String\"\n\nconst annotate = <A>(doc: Doc.Doc<A>): Doc.Doc<A> =>\n  pipe(\n    Doc.squareBracketed(doc),\n    Doc.width((w) => Doc.text(` <- width: ${w}`))\n  )\n\nconst docs = [\n  Doc.text(\"---\"),\n  Doc.text(\"------\"),\n  Doc.indent(Doc.text(\"---\"), 3),\n  Doc.vsep([Doc.text(\"---\"), Doc.indent(Doc.text(\"---\"), 4)])\n]\n\nconst doc = Doc.align(Doc.vsep(docs.map(annotate)))\n\nassert.strictEqual(\n  Doc.render(doc, { style: \"pretty\" }),\n  String.stripMargin(\n    `|[---] <- width: 5\n     |[------] <- width: 8\n     |[   ---] <- width: 8\n     |[---\n     |    ---] <- width: 8`\n  )\n)\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Array.chop Function in TypeScript\nDESCRIPTION: This snippet demonstrates the usage of the Array.chop function from the Effect library. It shows how to process an array by doubling each element.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Array-chop.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Array } from \"effect\"\n\nconst result = Array.chop([1, 2, 3, 4, 5], (as): [number, Array<number>] => [as[0] * 2, as.slice(1)])\nconsole.log(result) // [2, 4, 6, 8, 10]\n\n// Explanation:\n// The `chopFunction` takes the first element of the array, doubles it, and then returns it along with the rest of the array.\n// The `chop` function applies this `chopFunction` recursively to the input array `[1, 2, 3, 4, 5]`,\n// resulting in a new array `[2, 4, 6, 8, 10]`.\n```\n\n----------------------------------------\n\nTITLE: Defining MetricKey Interface in TypeScript\nDESCRIPTION: Defines a TypeScript interface for MetricKey that extends MetricKey.Variance, Equal.Equal, and Pipeable. Contains properties for name, keyType, description and tags to uniquely identify metrics.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/MetricKey-MetricKey.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface MetricKey<out Type extends MetricKeyType.MetricKeyType<any, any>>\n  extends MetricKey.Variance<Type>, Equal.Equal, Pipeable\n{\n  readonly name: string\n  readonly keyType: Type\n  readonly description: Option.Option<string>\n  readonly tags: ReadonlyArray<MetricLabel.MetricLabel>\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing filterOrDieMessage Function in TypeScript for Effect Module\nDESCRIPTION: Declares the filterOrDieMessage function which filters an Effect, causing it to die with a custom error message if the predicate fails. This function can be used with both refinements and predicates, providing better error context than the standard filterOrDie.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-filterOrDieMessage.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const filterOrDieMessage: { <A, B extends A>(refinement: Refinement<NoInfer<A>, B>, message: string): <E, R>(self: Effect<A, E, R>) => Effect<B, E, R>; <A>(predicate: Predicate<NoInfer<A>>, message: string): <E, R>(self: Effect<A, E, R>) => Effect<A, E, R>; <A, E, R, B extends A>(self: Effect<A, E, R>, refinement: Refinement<A, B>, message: string): Effect<B, E, R>; <A, E, R>(self: Effect<A, E, R>, predicate: Predicate<A>, message: string): Effect<A, E, R>; }\n```\n\n----------------------------------------\n\nTITLE: Creating File Arguments with Content Reading in TypeScript\nDESCRIPTION: The 'fileContent' function creates a file argument that reads and returns both the file path and its contents as a Uint8Array. It can be customized with an optional configuration object.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Args-fileContent.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const fileContent: (config?: Args.BaseArgsConfig | undefined) => Args<readonly [path: string, content: Uint8Array]>\n```\n\n----------------------------------------\n\nTITLE: TypeScript Signature for Context.add in Effect.js\nDESCRIPTION: Provides the TypeScript type signature for the Context.add function. The function is overloaded to support both curried and non-curried calling styles for adding a tagged service to a context.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Context-add.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const add: { <T extends Tag<any, any>>(tag: T, service: Tag.Service<T>): <Services>(self: Context<Services>) => Context<Services | Tag.Identifier<T>>; <Services, T extends Tag<any, any>>(self: Context<Services>, tag: T, service: Tag.Service<T>): Context<Services | Tag.Identifier<T>>; }\n```\n\n----------------------------------------\n\nTITLE: Creating Sink from Queue Typescript\nDESCRIPTION: This snippet defines a function `fromQueue` which creates a sink that enqueues each element into a given queue. It optionally takes a configuration object with a `shutdown` flag that, when true, will shut down the queue after the sink is evaluated. This provides a mechanism to manage queuing resources efficiently within Effect-TS applications. The primary input is a queue to enqueue data, and the output is a Sink type returning void.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Sink-fromQueue.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const fromQueue: <In>(queue: Queue.Enqueue<In>, options?: { readonly shutdown?: boolean | undefined; }) => Sink<void, In>\n```\n\n----------------------------------------\n\nTITLE: Using MutableHashSet.clear to Empty a Hash Set in TypeScript\nDESCRIPTION: This example demonstrates how to use MutableHashSet.clear to remove all values from a MutableHashSet. The function returns the now-empty set, which is verified by checking that its size is 0.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/MutableHashSet-clear.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { MutableHashSet, pipe } from \"effect\"\nimport assert from \"node:assert/strict\"\n\nassert.deepStrictEqual(\n  pipe(\n    MutableHashSet.make(1, 2, 3, 4),\n    MutableHashSet.clear,\n    MutableHashSet.size\n  ),\n  0\n)\n```\n\n----------------------------------------\n\nTITLE: Implementing String.includes Function in TypeScript\nDESCRIPTION: A TypeScript function that checks if a searchString appears as a substring within a target string, optionally starting from a specified position. Returns a boolean indicating whether the substring was found.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/String-includes.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const includes: (searchString: string, position?: number) => (self: string) => boolean\n```\n\n----------------------------------------\n\nTITLE: Filtering and Mapping Stream Elements with Effects\nDESCRIPTION: A TypeScript utility function that transforms stream elements using a partial function that returns an optional effect. Allows conditional processing and mapping of stream elements while maintaining effect context.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-filterMapWhileEffect.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const filterMapWhileEffect: { <A, A2, E2, R2>(pf: (a: A) => Option.Option<Effect.Effect<A2, E2, R2>>): <E, R>(self: Stream<A, E, R>) => Stream<A2, E2 | E, R2 | R>; <A, E, R, A2, E2, R2>(self: Stream<A, E, R>, pf: (a: A) => Option.Option<Effect.Effect<A2, E2, R2>>): Stream<A2, E | E2, R | R2>; }\n```\n\n----------------------------------------\n\nTITLE: Declaring prependAllReversed Function in TypeScript\nDESCRIPTION: Defines a function that takes a prefix list and prepends it in reverse order to another list. The function supports both curried and non-curried forms, allowing for flexible usage with generic types A and B.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/List-prependAllReversed.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const prependAllReversed: { <B>(prefix: List<B>): <A>(self: List<A>) => List<A | B>; <A, B>(self: List<A>, prefix: List<B>): List<A | B>; }\n```\n\n----------------------------------------\n\nTITLE: Effect Option Mapping Example\nDESCRIPTION: Demonstrates the use of `Option.map` to transform a value within a `Some` and shows that `None` values are unchanged. The example imports the Option module from \"effect\" and uses console.log to output the result of the mapping operation.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Option-map.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Option } from \"effect\"\n\n// Mapping over a `Some`\nconst someValue = Option.some(2)\n\nconsole.log(Option.map(someValue, (n) => n * 2))\n// Output: { _id: 'Option', _tag: 'Some', value: 4 }\n\n// Mapping over a `None`\nconst noneValue = Option.none<number>()\n\nconsole.log(Option.map(noneValue, (n) => n * 2))\n// Output: { _id: 'Option', _tag: 'None' }\n```\n\n----------------------------------------\n\nTITLE: Filtering Iterable Elements with Micro Module in TypeScript\nDESCRIPTION: A function that filters elements of an iterable using an effectful predicate. Supports concurrent processing through the concurrency option and allows negation of the filter condition.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Micro-filter.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const filter: <A, E, R>(iterable: Iterable<A>, f: (a: NoInfer<A>) => Micro<boolean, E, R>, options?: { readonly concurrency?: Concurrency | undefined; readonly negate?: boolean | undefined; }) => Micro<Array<A>, E, R>\n```\n\n----------------------------------------\n\nTITLE: Converting Layer to Runtime in TypeScript\nDESCRIPTION: The toRuntime function converts a layer that requires no services into a scoped runtime. This runtime can be used to execute effects. It takes a Layer as input and returns an Effect that produces a Runtime.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Layer-toRuntime.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const toRuntime: <RIn, E, ROut>(self: Layer<ROut, E, RIn>) => Effect.Effect<Runtime.Runtime<ROut>, E, Scope.Scope | RIn>\n```\n\n----------------------------------------\n\nTITLE: Converting Nullable Values to Either Type in TypeScript\nDESCRIPTION: Example showing how to use Either.fromNullable to handle nullable values by converting them to Either types. The function takes a value and a fallback function, returning Right for non-null values and Left with the fallback for null values.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Either-fromNullable.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { Either } from \"effect\"\n\nassert.deepStrictEqual(Either.fromNullable(1, () => 'fallback'), Either.right(1))\nassert.deepStrictEqual(Either.fromNullable(null, () => 'fallback'), Either.left('fallback'))\n```\n\n----------------------------------------\n\nTITLE: Publishing all messages to a PubSub\nDESCRIPTION: This TypeScript code snippet shows the declaration of the `publishAll` function in the Effect library's `PubSub` module.  The function takes either an iterable of messages and a `PubSub` instance, or just an iterable, and returns an `Effect` that resolves to a boolean indicating whether all messages were successfully published.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/PubSub-publishAll.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const publishAll: { <A>(elements: Iterable<A>): (self: PubSub<A>) => Effect.Effect<boolean>; <A>(self: PubSub<A>, elements: Iterable<A>): Effect.Effect<boolean>; }\n```\n\n----------------------------------------\n\nTITLE: Using isBoolean Function from effect/Boolean Module in TypeScript\nDESCRIPTION: Demonstrates how to use the isBoolean function to check if a value is a boolean primitive. The function returns true when the input is a boolean and false for any other data type.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Boolean-isBoolean.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { isBoolean } from \"effect/Boolean\"\n\nassert.deepStrictEqual(isBoolean(true), true)\nassert.deepStrictEqual(isBoolean(\"true\"), false)\n```\n\n----------------------------------------\n\nTITLE: Delaying Execution with Effect-TS Micro in TypeScript\nDESCRIPTION: The `delay` function in the Micro module allows for delaying the execution of a given effect. It can be utilized by specifying the number of milliseconds as the duration for the delay. The function signature supports different type parameters for managing effects (`A`, `E`, `R`). No explicit dependencies are required, but familiarity with the Effect-TS library is necessary. The inputs are the effect and the delay duration, and it outputs a delayed effect.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Micro-delay.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const delay: { (millis: number): <A, E, R>(self: Micro<A, E, R>) => Micro<A, E, R>; <A, E, R>(self: Micro<A, E, R>, millis: number): Micro<A, E, R>; }\n```\n\n----------------------------------------\n\nTITLE: ZipWithNext Function Signature - TypeScript Definition\nDESCRIPTION: Type definition for the zipWithNext function showing it takes a Stream of type A and returns a Stream of tuples containing the current element and an Option of the next element\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-zipWithNext.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const zipWithNext: <A, E, R>(self: Stream<A, E, R>) => Stream<[A, Option.Option<A>], E, R>\n```\n\n----------------------------------------\n\nTITLE: Creating a Die Cause from an Unexpected Error in TypeScript\nDESCRIPTION: The die function wraps an unhandled or unknown defect (like a runtime crash) into a Cause. It's useful for capturing unforeseen issues in a structured way.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Cause-die.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const die: (defect: unknown) => Cause<never>\n```\n\n----------------------------------------\n\nTITLE: Filtering Collections with STM.filter in TypeScript\nDESCRIPTION: The `filter` function in the STM module is designed to filter a collection of elements based on a predicate that returns an effect. It supports two signatures: one for curried usage with a predicate and another for direct usage with both the iterable and predicate together. This approach allows developers to work seamlessly with effectful computations in their collections.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/STM-filter.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const filter: { <A, R, E>(predicate: (a: NoInfer<A>) => STM<boolean, E, R>): (iterable: Iterable<A>) => STM<Array<A>, E, R>; <A, R, E>(iterable: Iterable<A>, predicate: (a: A) => STM<boolean, E, R>): STM<Array<A>, E, R>; }\n```\n\n----------------------------------------\n\nTITLE: Effect.supervised Function Signature in TypeScript\nDESCRIPTION: This code snippet shows the TypeScript signature of the Effect.supervised function. It demonstrates how the function can be used to apply a supervisor to an Effect, enabling fiber supervision.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-supervised.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const supervised: { <X>(supervisor: Supervisor.Supervisor<X>): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R>; <A, E, R, X>(self: Effect<A, E, R>, supervisor: Supervisor.Supervisor<X>): Effect<A, E, R>; }\n```\n\n----------------------------------------\n\nTITLE: Splitting String Schema in Effect\nDESCRIPTION: This snippet showcases the `split` function from the Effect Schema module. It transforms a schema representing a string into a schema representing an array of strings by splitting the input string using the provided separator.  The function requires a string separator as input.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Schema-split.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const split: (separator: string) => transform<SchemaClass<string>, Array$<typeof String$>>\n```\n\n----------------------------------------\n\nTITLE: Implementing Layer.flatMap in TypeScript Effect Framework\nDESCRIPTION: Defines a flatMap operation that enables dynamic layer construction based on the output of another layer. The function supports both curried and uncurried forms, handling context transformation and error propagation.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Layer-flatMap.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const flatMap: { <A, A2, E2, R2>(f: (context: Context.Context<A>) => Layer<A2, E2, R2>): <E, R>(self: Layer<A, E, R>) => Layer<A2, E2 | E, R2 | R>; <A, E, R, A2, E2, R2>(self: Layer<A, E, R>, f: (context: Context.Context<A>) => Layer<A2, E2, R2>): Layer<A2, E | E2, R | R2>; }\n```\n\n----------------------------------------\n\nTITLE: Creating Summary Metric in Effect TypeScript\nDESCRIPTION: Example showing how to create a Summary metric for measuring response times with specified retention period, maximum observations, error tolerance, and quantile calculations. The metric is configured to track statistical distribution of response times including median, 90th and 99th percentiles.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Metric-summary.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Metric, Chunk } from \"effect\"\n\nconst responseTimesSummary = Metric.summary({\n  name: \"response_times_summary\",\n  maxAge: \"60 seconds\", // Retain observations for 60 seconds.\n  maxSize: 1000, // Keep a maximum of 1000 observations.\n  error: 0.01, // Allow a 1% error when calculating quantiles.\n  quantiles: [0.5, 0.9, 0.99], // Calculate 50th, 90th, and 99th percentiles.\n  description: \"Measures the distribution of response times.\"\n});\n```\n\n----------------------------------------\n\nTITLE: Using Effect.timeoutTo with Either Type in TypeScript\nDESCRIPTION: This example demonstrates how to use the Effect.timeoutTo method to handle both successful and timed-out operations, wrapping the results in an Either type. It simulates a task that takes 2 seconds but times out after 1 second.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-timeoutTo.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Effect, Either } from \"effect\"\n\nconst task = Effect.gen(function* () {\n  console.log(\"Start processing...\")\n  yield* Effect.sleep(\"2 seconds\") // Simulates a delay in processing\n  console.log(\"Processing complete.\")\n  return \"Result\"\n})\n\nconst program = task.pipe(\n  Effect.timeoutTo({\n    duration: \"1 second\",\n    onSuccess: (result): Either.Either<string, string> =>\n      Either.right(result),\n    onTimeout: (): Either.Either<string, string> =>\n      Either.left(\"Timed out!\")\n  })\n)\n\nEffect.runPromise(program).then(console.log)\n// Output:\n// Start processing...\n// {\n//   _id: \"Either\",\n//   _tag: \"Left\",\n//   left: \"Timed out!\"\n// }\n```\n\n----------------------------------------\n\nTITLE: Finding First Element with Transactional Predicate in TypeScript\nDESCRIPTION: The `findFirstSTM` function allows users to find the first element in a `TArray` that matches a transactional predicate. This function is part of the Effect-TS library and assists in concurrent programming by ensuring changes are atomic and isolated. The function signature can be used in two forms; either passing the `TArray` first or passing it as part of the function call. It requires familiarity with STM (Software Transactional Memory) and the `Option` module for handling optional values.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TArray-findFirstSTM.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const findFirstSTM: { <A, R, E>(predicate: (value: A) => STM.STM<boolean, E, R>): (self: TArray<A>) => STM.STM<Option.Option<A>, E, R>; <A, R, E>(self: TArray<A>, predicate: (value: A) => STM.STM<boolean, E, R>): STM.STM<Option.Option<A>, E, R>; }\n```\n\n----------------------------------------\n\nTITLE: Implementing Fiber interruption with interruptFork in TypeScript\nDESCRIPTION: A function that interrupts a fiber from the calling fiber. The interruption occurs in a separate daemon fiber, allowing the returned effect to resume immediately without waiting for the interruption to complete.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Fiber-interruptFork.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const interruptFork: <A, E>(self: Fiber<A, E>) => Effect.Effect<void>\n```\n\n----------------------------------------\n\nTITLE: Using HashSet.beginMutation for Efficient Multiple Operations in TypeScript\nDESCRIPTION: This example demonstrates how to use HashSet.beginMutation to create a mutable version of a HashSet for efficiently performing multiple operations. It shows the difference between mutable and immutable sets, how modifications affect each, and how to finalize changes with endMutation.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/HashSet-beginMutation.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { HashSet } from \"effect\"\nimport assert from \"node:assert/strict\"\n\nconst UPPER_BOUND = 10_000\n\nconst immutableSet = HashSet.empty<number>().pipe(HashSet.add(0))\n\n// Create a mutable version of the immutableSet\nconst mutableSet = HashSet.beginMutation(immutableSet)\n\nfor (let i = 1; i < UPPER_BOUND; i++) {\n  // Operations now modify the set in place instead of creating new instances\n  // This is more efficient when making multiple changes\n  const pointerToMutableSet = HashSet.add(mutableSet, i)\n\n  // the two sets have the same identity, hence `add` is mutating mutableSet and not returning a new HashSet instance\n  assert(Object.is(mutableSet, pointerToMutableSet))\n  assert.equal(HashSet.has(mutableSet, i), true) // `i` is in the mutableSet\n  assert.equal(HashSet.has(immutableSet, i), false) // `i` is not in the immutableSet\n}\n\nconst next = UPPER_BOUND + 1\n// When done, mark the set as immutable again\nHashSet.endMutation(mutableSet).pipe(\n  HashSet.add(next) // since this returns a new HashSet, it will not be logged as part of the mutableSet\n)\nassert.equal(HashSet.has(mutableSet, next), false)\n\nconsole.log(HashSet.toValues(immutableSet)) // [0]\nconsole.log(HashSet.toValues(mutableSet).sort((a, b) => a - b)) // [0, 1, 2, 3, ...rest]\n```\n\n----------------------------------------\n\nTITLE: Creating Custom Request Class with Effect Framework\nDESCRIPTION: Demonstrates how to create a custom request class extending Request.Class with specified Success, Error, and argument types. The example shows a basic implementation with a required id parameter.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Request-Class.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Request } from \"effect\"\n\ntype Success = string\ntype Error = never\n\nclass MyRequest extends Request.Class<Success, Error, {\n  readonly id: string\n}> {}\n```\n\n----------------------------------------\n\nTITLE: Creating Optional Configurations using Config.option in TypeScript\nDESCRIPTION: The option function converts a Config<A> into a Config<Option<A>> that returns None when the configuration data is missing and Some otherwise. This allows for handling optional configuration values in a type-safe manner.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Config-option.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const option: <A>(self: Config<A>) => Config<Option.Option<A>>\n```\n\n----------------------------------------\n\nTITLE: Removing Elements from HashSet in TypeScript\nDESCRIPTION: Demonstrates various ways to remove an element from a HashSet using the Effect package. It shows data-last (pipeable) API, piping with the pipe function, and data-first API approaches.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/HashSet-remove.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { HashSet, pipe } from \"effect\"\n\n// with `data-last`, a.k.a. `pipeable` API\npipe(HashSet.make(0, 1, 2), HashSet.remove(0))\n\n// or piped with the pipe function\nHashSet.make(0, 1, 2).pipe(HashSet.remove(0))\n\n// or with `data-first` API\nHashSet.remove(HashSet.make(0, 1, 2), 0)\n```\n\n----------------------------------------\n\nTITLE: Defining toPullIn Function in TypeScript for Channel Module\nDESCRIPTION: Declares the toPullIn function which returns an Effect that can repeatedly pull elements from a Channel within a given Scope. The function handles channel failures and returns either the channel's done value or an emitted element.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Channel-toPullIn.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const toPullIn: { (scope: Scope.Scope): <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>) => Effect.Effect<Effect.Effect<Either.Either<OutElem, OutDone>, OutErr, Env>, never, Env>; <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>, scope: Scope.Scope): Effect.Effect<Effect.Effect<Either.Either<OutElem, OutDone>, OutErr, Env>, never, Env>; }\n```\n\n----------------------------------------\n\nTITLE: Finding Minimum Array Element with Effect Array Module\nDESCRIPTION: Demonstrates how to find the minimum element in an array using the Array.min function with a number comparator. The function takes an array and an Order object to determine the comparison logic.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Array-min.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Array, Order } from \"effect\"\n\nconst result = Array.min([3, 1, 2], Order.number)\nconsole.log(result) // 1\n```\n\n----------------------------------------\n\nTITLE: Implementing Console Service Override in Effect Module\nDESCRIPTION: The withConsole function executes a workflow with a specified implementation of the console service. It supports both curried and non-curried invocation patterns for flexibility.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-withConsole.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const withConsole: { <C extends Console>(console: C): <A, E, R>(effect: Effect<A, E, R>) => Effect<A, E, R>; <A, E, R, C extends Console>(effect: Effect<A, E, R>, console: C): Effect<A, E, R>; }\n```\n\n----------------------------------------\n\nTITLE: Checking if a Value Exists in MutableHashSet in TypeScript\nDESCRIPTION: Demonstrates how to use the MutableHashSet.has method to check if a value exists in a MutableHashSet. The method has O(1) average time complexity and can be used with data-first, data-last (pipeable), or method chaining approaches.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/MutableHashSet-has.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { MutableHashSet, pipe } from \"effect\"\nimport assert from \"node:assert/strict\"\n\nassert.equal(\n  // with `data-last`, a.k.a. `pipeable` API\n  pipe(MutableHashSet.make(0, 1, 2), MutableHashSet.has(3)),\n  false\n)\n\nassert.equal(\n  // or piped with the pipe function\n  MutableHashSet.make(0, 1, 2).pipe(MutableHashSet.has(3)),\n  false\n)\n\nassert.equal(\n  // or with `data-first` API\n  MutableHashSet.has(MutableHashSet.make(0, 1, 2), 3),\n  false\n)\n```\n\n----------------------------------------\n\nTITLE: Defining HttpApiEndpoint Interface in TypeScript\nDESCRIPTION: This code snippet defines the HttpApiEndpoint interface, which represents an API endpoint. It includes various properties and methods for configuring the endpoint's behavior, such as path, method, schemas for different parts of the request and response, and middleware support.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/HttpApiEndpoint-HttpApiEndpoint.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface HttpApiEndpoint<\n  out Name extends string,\n  out Method extends HttpMethod,\n  in out Path = never,\n  in out UrlParams = never,\n  in out Payload = never,\n  in out Headers = never,\n  in out Success = void,\n  in out Error = never,\n  out R = never,\n  out RE = never\n> extends Pipeable {\n  readonly [TypeId]: TypeId\n  readonly name: Name\n  readonly path: PathSegment\n  readonly method: Method\n  readonly pathSchema: Option.Option<Schema.Schema<Path, unknown, R>>\n  readonly urlParamsSchema: Option.Option<Schema.Schema<UrlParams, unknown, R>>\n  readonly payloadSchema: Option.Option<Schema.Schema<Payload, unknown, R>>\n  readonly headersSchema: Option.Option<Schema.Schema<Headers, unknown, R>>\n  readonly successSchema: Schema.Schema<Success, unknown, R>\n  readonly errorSchema: Schema.Schema<Error, unknown, RE>\n  readonly annotations: Context.Context<never>\n  readonly middlewares: ReadonlySet<HttpApiMiddleware.TagClassAny>\n\n  addSuccess<S extends Schema.Schema.Any>(\n    schema: S,\n    annotations?: {\n      readonly status?: number | undefined\n    }\n  ): HttpApiEndpoint<\n    Name,\n    Method,\n    Path,\n    UrlParams,\n    Payload,\n    Headers,\n    Exclude<Success, void> | Schema.Schema.Type<S>,\n    Error,\n    R | Schema.Schema.Context<S>,\n    RE\n  >\n\n  addError<E extends Schema.Schema.Any>(\n    schema: E,\n    annotations?: {\n      readonly status?: number | undefined\n    }\n  ): HttpApiEndpoint<\n    Name,\n    Method,\n    Path,\n    UrlParams,\n    Payload,\n    Headers,\n    Success,\n    Error | Schema.Schema.Type<E>,\n    R,\n    RE | Schema.Schema.Context<E>\n  >\n\n  setPayload<P extends Schema.Schema.Any>(\n    schema: P & HttpApiEndpoint.ValidatePayload<Method, P>\n  ): HttpApiEndpoint<\n    Name,\n    Method,\n    Path,\n    UrlParams,\n    Schema.Schema.Type<P>,\n    Headers,\n    Success,\n    Error,\n    R | Schema.Schema.Context<P>,\n    RE\n  >\n\n  setPath<Path extends Schema.Schema.Any>(\n    schema: Path & HttpApiEndpoint.ValidatePath<Path>\n  ): HttpApiEndpoint<\n    Name,\n    Method,\n    Schema.Schema.Type<Path>,\n    UrlParams,\n    Payload,\n    Headers,\n    Success,\n    Error,\n    R | Schema.Schema.Context<Path>,\n    RE\n  >\n\n  setUrlParams<UrlParams extends Schema.Schema.Any>(\n    schema: UrlParams & HttpApiEndpoint.ValidateUrlParams<UrlParams>\n  ): HttpApiEndpoint<\n    Name,\n    Method,\n    Path,\n    Schema.Schema.Type<UrlParams>,\n    Payload,\n    Headers,\n    Success,\n    Error,\n    R | Schema.Schema.Context<Path>,\n    RE\n  >\n\n  setHeaders<H extends Schema.Schema.Any>(\n    schema: H & HttpApiEndpoint.ValidateHeaders<H>\n  ): HttpApiEndpoint<\n    Name,\n    Method,\n    Path,\n    UrlParams,\n    Payload,\n    Schema.Schema.Type<H>,\n    Success,\n    Error,\n    R | Schema.Schema.Context<H>,\n    RE\n  >\n\n  prefix(\n    prefix: PathSegment\n  ): HttpApiEndpoint<Name, Method, Path, UrlParams, Payload, Headers, Success, Error, R, RE>\n\n  middleware<I extends HttpApiMiddleware.HttpApiMiddleware.AnyId, S>(middleware: Context.Tag<I, S>): HttpApiEndpoint<\n    Name,\n    Method,\n    Path,\n    UrlParams,\n    Payload,\n    Headers,\n    Success,\n    Error | HttpApiMiddleware.HttpApiMiddleware.Error<I>,\n    R | I,\n    RE | HttpApiMiddleware.HttpApiMiddleware.ErrorContext<I>\n  >\n\n  annotate<I, S>(\n    tag: Context.Tag<I, S>,\n    value: S\n  ): HttpApiEndpoint<Name, Method, Path, UrlParams, Payload, Headers, Success, Error, R, RE>\n\n  annotateContext<I>(\n    context: Context.Context<I>\n  ): HttpApiEndpoint<Name, Method, Path, UrlParams, Payload, Headers, Success, Error, R, RE>\n}\n```\n\n----------------------------------------\n\nTITLE: Flatten Effect Stream in Typescript\nDESCRIPTION: The `flattenEffect` function flattens a stream of Effect values into a stream, executing the effects.  It allows specifying concurrency (number or \"unbounded\") and whether the order of effects matters (unordered).\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-flattenEffect.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const flattenEffect: { (options?: { readonly concurrency?: number | \\\"unbounded\\\" | undefined; readonly unordered?: boolean | undefined; } | undefined): <A, E2, R2, E, R>(self: Stream<Effect.Effect<A, E2, R2>, E, R>) => Stream<A, E2 | E, R2 | R>; <A, E2, R2, E, R>(self: Stream<Effect.Effect<A, E2, R2>, E, R>, options?: { readonly concurrency?: number | \\\"unbounded\\\" | undefined; readonly unordered?: boolean | undefined; } | undefined): Stream<A, E2 | E, R2 | R>; }\n```\n\n----------------------------------------\n\nTITLE: Defining withSpanContext Function for OpenTelemetry Span Context in TypeScript\nDESCRIPTION: Declares the withSpanContext function, which sets the effect's parent span from a given OpenTelemetry SpanContext. This is useful for attaching to a parent span when OpenTelemetry is set up outside of Effect.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Tracer-withSpanContext.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const withSpanContext: {\n  (spanContext: Otel.SpanContext): <A, E, R>(effect: Effect<A, E, R>) => Effect<A, E, Exclude<R, ParentSpan>>;\n  <A, E, R>(effect: Effect<A, E, R>, spanContext: Otel.SpanContext): Effect<A, E, Exclude<R, ParentSpan>>;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Channel Zip Operation in TypeScript\nDESCRIPTION: Defines a zip operation that composes two channels sequentially, producing a new channel that outputs a tuple containing both channels' terminal values. Supports optional concurrent execution through options parameter.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Channel-zip.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const zip: { <OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>(that: Channel<OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>, options?: { readonly concurrent?: boolean | undefined; } | undefined): <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>) => Channel<OutElem1 | OutElem, InElem & InElem1, OutErr1 | OutErr, InErr & InErr1, readonly [OutDone, OutDone1], InDone & InDone1, Env1 | Env>; <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>, that: Channel<OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>, options?: { readonly concurrent?: boolean | undefined; } | undefined): Channel<OutElem | OutElem1, InElem & InElem1, OutErr | OutErr1, InErr & InErr1, readonly [OutDone, OutDone1], InDone & InDone1, Env | Env1>; }\n```\n\n----------------------------------------\n\nTITLE: Using Effect.isFailure in TypeScript\nDESCRIPTION: Example demonstrating how to use Effect.isFailure to check if an effect has failed. Shows both a failed effect case returning true and a defect case that throws an error.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-isFailure.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Effect } from \"effect\"\n\nconst failure = Effect.fail(\"Uh oh!\")\n\nconsole.log(Effect.runSync(Effect.isFailure(failure)))\n// Output: true\n\nconst defect = Effect.dieMessage(\"BOOM!\")\n\nEffect.runSync(Effect.isFailure(defect))\n// throws: BOOM!\n```\n\n----------------------------------------\n\nTITLE: Using Effect.replicateEffect to Repeat Tasks in TypeScript\nDESCRIPTION: Example showing how to use the replicateEffect function to execute a task multiple times and collect the results. This example demonstrates a counter being incremented three times with each completion logged to the console.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-replicateEffect.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Console, Effect } from \"effect\"\n\nlet counter = 0\n\nconst task = Effect.sync(() => ++counter).pipe(\n  Effect.tap(() => Console.log(`Task completed`))\n)\n\nconst program = Effect.gen(function*() {\n  // Replicate the task 3 times and collect the results\n  const results = yield* Effect.replicateEffect(task, 3)\n  yield* Console.log(`Results: ${results.join(\", \")}`)\n})\n\nEffect.runFork(program)\n// Output:\n// Task completed\n// Task completed\n// Task completed\n// Results: 1, 2, 3\n```\n\n----------------------------------------\n\nTITLE: Executing Effectful Folds on Streams with TypeScript\nDESCRIPTION: The `runFoldEffect` function executes a fold operation over a stream of values, allowing for side effects. It requires an initial state `s` and a function `f` that combines the current state with a stream element to produce an effect. The function signature supports both curried and uncurried invocations. The primary dependencies include the Effect and Scope libraries from the Effect-TS project.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-runFoldEffect.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const runFoldEffect: { <S, A, E2, R2>(s: S, f: (s: S, a: A) => Effect.Effect<S, E2, R2>): <E, R>(self: Stream<A, E, R>) => Effect.Effect<S, E2 | E, Exclude<R | R2, Scope.Scope>>; <A, E, R, S, E2, R2>(self: Stream<A, E, R>, s: S, f: (s: S, a: A) => Effect.Effect<S, E2, R2>): Effect.Effect<S, E | E2, Exclude<R | R2, Scope.Scope>>; }\n```\n\n----------------------------------------\n\nTITLE: Defining Stream.provideServiceEffect Function in TypeScript\nDESCRIPTION: Declares the provideServiceEffect function for providing a stream with a single required service. It supports both curried and uncurried forms, allowing flexibility in usage. The function handles type inference and service exclusion in the resulting stream's context.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-provideServiceEffect.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const provideServiceEffect: { <I, S, E2, R2>(tag: Context.Tag<I, S>, effect: Effect.Effect<NoInfer<S>, E2, R2>): <A, E, R>(self: Stream<A, E, R>) => Stream<A, E2 | E, R2 | Exclude<R, I>>; <A, E, R, I, S, E2, R2>(self: Stream<A, E, R>, tag: Context.Tag<I, S>, effect: Effect.Effect<NoInfer<S>, E2, R2>): Stream<A, E2 | E, R2 | Exclude<R, I>>; }\n```\n\n----------------------------------------\n\nTITLE: Implementing Stream.scan in TypeScript\nDESCRIPTION: This snippet demonstrates how to use the `Stream.scan` function in Effect.js to calculate cumulative sums of a stream of numbers. The example showcases importing necessary modules and handling the output asynchronously with promises.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-scan.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Effect, Stream } from \"effect\"\n\nconst stream = Stream.range(1, 6).pipe(Stream.scan(0, (a, b) => a + b))\n\nEffect.runPromise(Stream.runCollect(stream)).then(console.log)\n// { _id: 'Chunk', values: [ 0,  1,  3, 6, 10, 15, 21 ] }\n```\n\n----------------------------------------\n\nTITLE: Defining asyncEffect Function in TypeScript\nDESCRIPTION: Type signature for the asyncEffect function that enables asynchronous effect registration with support for returning Effect values. The function takes a register callback that can return either an Effect<void> or void, and produces an Effect combining the error and environment types.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-asyncEffect.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const asyncEffect: <A, E, R, R3, E2, R2>(register: (callback: (_: Effect<A, E, R>) => void) => Effect<Effect<void, never, R3> | void, E2, R2>) => Effect<A, E | E2, R | R2 | R3>\n```\n\n----------------------------------------\n\nTITLE: Repeating Stream with Infinite Schedule\nDESCRIPTION: Demonstrates creating a stream that repeats a single value indefinitely using Schedule.forever, and then taking the first 5 elements\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-repeat.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Effect, Schedule, Stream } from \"effect\"\n\nconst stream = Stream.repeat(Stream.succeed(1), Schedule.forever)\n\nEffect.runPromise(Stream.runCollect(stream.pipe(Stream.take(5)))).then(console.log)\n// { _id: 'Chunk', values: [ 1, 1, 1, 1, 1 ] }\n```\n\n----------------------------------------\n\nTITLE: Creating a Bounded Queue with Back Pressure in Effect TS\nDESCRIPTION: Creates a bounded queue that will retain values until they have been taken, applying back pressure to offerors if the queue is at capacity. For optimal performance, it's recommended to use capacities that are powers of two.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TQueue-bounded.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const bounded: <A>(requestedCapacity: number) => STM.STM<TQueue<A>>\n```\n\n----------------------------------------\n\nTITLE: Decoding URI Components with Effect-TS\nDESCRIPTION: Function signature for decoding URI components into UTF-8 strings. Returns an Either type that handles successful decoding with a string result or a DecodeException on failure.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Encoding-decodeUriComponent.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const decodeUriComponent: (str: string) => Either.Either<string, DecodeException>\n```\n\n----------------------------------------\n\nTITLE: Implementing orDie Function for Stream Error Handling in TypeScript\nDESCRIPTION: The orDie function translates any failure in a stream into a stream termination. This makes the stream infallible and all failures unchecked. It takes a Stream<A, E, R> as input and returns a Stream<A, never, R>, effectively removing the error type from the stream.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-orDie.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const orDie: <A, E, R>(self: Stream<A, E, R>) => Stream<A, never, R>\n```\n\n----------------------------------------\n\nTITLE: RateLimiter.make Function Signature in TypeScript\nDESCRIPTION: The signature of the RateLimiter.make function, which takes RateLimiter.Options as an argument and returns an Effect that produces a RateLimiter. This function is available since version 2.0.0 of the library.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/RateLimiter-make.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const make: (options: RateLimiter.Options) => Effect<RateLimiter, never, Scope>\n```\n\n----------------------------------------\n\nTITLE: Transforming Sink Inputs Effectfully with mapInputEffect in TypeScript\nDESCRIPTION: Defines a function that effectfully transforms input elements for a Sink. It allows processing incoming elements through an Effect before they are passed to the sink, providing functionality for data transformation with side effects.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Sink-mapInputEffect.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const mapInputEffect: { <In0, In, E2, R2>(f: (input: In0) => Effect.Effect<In, E2, R2>): <A, L, E, R>(self: Sink<A, In, L, E, R>) => Sink<A, In0, L, E2 | E, R2 | R>; <A, In, L, E, R, In0, E2, R2>(self: Sink<A, In, L, E, R>, f: (input: In0) => Effect.Effect<In, E2, R2>): Sink<A, In0, L, E | E2, R | R2>; }\n```\n\n----------------------------------------\n\nTITLE: Grouping Array Elements with Custom Equivalence Function\nDESCRIPTION: Demonstrates how to use Array.groupWith to group consecutive equal elements in an array using a custom equivalence function. The function takes a non-empty array and returns nested non-empty arrays of grouped elements.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Array-groupWith.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Array } from \"effect\"\n\nconst result = Array.groupWith([\"a\", \"a\", \"b\", \"b\", \"b\", \"c\", \"a\"], (x, y) => x === y)\nconsole.log(result) // [[\"a\", \"a\"], [\"b\", \"b\", \"b\"], [\"c\"], [\"a\"]]\n```\n\n----------------------------------------\n\nTITLE: Defining DateTime Type in TypeScript\nDESCRIPTION: Defines the DateTime type that can represent either a UTC time or a zoned time with an associated time zone. This type is fundamental for representing points in time in the effect library.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/DateTime-DateTime.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ntype DateTime = Utc | Zoned\n```\n\n----------------------------------------\n\nTITLE: Attaching Finalizers with Schedule Ensuring in TypeScript\nDESCRIPTION: The function `ensuring` creates a new schedule that will execute a specified finalizer when the schedule finishes. It accounts for scheduling operations where the finalizer only runs if the schedule reaches completion, making it suitable for resource cleanup, logging, or other side-effects. The main prerequisite is the `Effect` type from the Effect TS library, which wraps the finalizer effect. The function accepts a schedule and a finalizer, returning a schedule of the same type.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Schedule-ensuring.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const ensuring: { <X>(finalizer: Effect.Effect<X, never, never>): <Out, In, R>(self: Schedule<Out, In, R>) => Schedule<Out, In, R>; <Out, In, R, X>(self: Schedule<Out, In, R>, finalizer: Effect.Effect<X, never, never>): Schedule<Out, In, R>; }\n```\n\n----------------------------------------\n\nTITLE: Excluding Specific Values in Pattern Matching with Match.not in TypeScript\nDESCRIPTION: Demonstrates how to use Match.not to handle all values except a specific case in pattern matching. The example shows matching string or number values, excluding 'hi' and providing a fallback case.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Match-not.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Match } from \"effect\"\n\n// Create a matcher for string or number values\nconst match = Match.type<string | number>().pipe(\n  // Match any value except \"hi\", returning \"ok\"\n  Match.not(\"hi\", () => \"ok\"),\n  // Fallback case for when the value is \"hi\"\n  Match.orElse(() => \"fallback\")\n)\n\nconsole.log(match(\"hello\"))\n// Output: \"ok\"\n\nconsole.log(match(\"hi\"))\n// Output: \"fallback\"\n```\n\n----------------------------------------\n\nTITLE: Using tryMapPromise for Promise-based Computations with Error Handling in TypeScript\nDESCRIPTION: The tryMapPromise function transforms the success value of an Effect using a Promise-returning function, converting any promise rejections into typed errors. It provides two overloads: one for applying the function to an existing Effect, and another for creating a function that can be applied to Effects. Supports interruption via AbortSignal.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-tryMapPromise.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const tryMapPromise: { <A, B, E1>(options: { readonly try: (a: A, signal: AbortSignal) => PromiseLike<B>; readonly catch: (error: unknown) => E1; }): <E, R>(self: Effect<A, E, R>) => Effect<B, E1 | E, R>; <A, E, R, B, E1>(self: Effect<A, E, R>, options: { readonly try: (a: A, signal: AbortSignal) => PromiseLike<B>; readonly catch: (error: unknown) => E1; }): Effect<B, E | E1, R>; }\n```\n\n----------------------------------------\n\nTITLE: Implementing Layer Failure Constructor in TypeScript\nDESCRIPTION: Defines a function that constructs a Layer which fails with a specified cause. This is useful for error handling and failure scenarios in Effect.io applications.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Layer-failCause.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const failCause: <E>(cause: Cause.Cause<E>) => Layer<unknown, E>\n```\n\n----------------------------------------\n\nTITLE: Defining HttpShardManager Layer without Server Websocket in TypeScript\nDESCRIPTION: This code snippet defines a layer for the ShardManager service that doesn't run a server but provides the Runners RPC client. It can be used with toHttpApp and toHttpAppWebsocket APIs to run a complete ShardManager server.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/HttpShardManager-layerNoServerWebsocket.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const layerNoServerWebsocket: (options: { readonly runnerPath: string; readonly runnerHttps?: boolean | undefined; }) => Layer.Layer<ShardManager.ShardManager, never, RpcSerialization.RpcSerialization | ShardStorage | RunnerHealth.RunnerHealth | Socket.WebSocketConstructor | ShardManager.Config | ShardingConfig>\n```\n\n----------------------------------------\n\nTITLE: Implementing Stream Zipping with Latest Values in TypeScript\nDESCRIPTION: Function signature for zipLatestWith that combines two streams by pairing each value with the latest value from the other stream. The function tracks latest values on a per-chunk basis and accepts a combining function to produce the result.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-zipLatestWith.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const zipLatestWith: { <AR, ER, RR, AL, A>(right: Stream<AR, ER, RR>, f: (left: AL, right: AR) => A): <EL, RL>(left: Stream<AL, EL, RL>) => Stream<A, EL | ER, RL | RR>; <AL, EL, RL, AR, ER, RR, A>(left: Stream<AL, EL, RL>, right: Stream<AR, ER, RR>, f: (left: AL, right: AR) => A): Stream<A, EL | ER, RL | RR>; }\n```\n\n----------------------------------------\n\nTITLE: Creating Grouped SQL Resolvers with Effect-TS\nDESCRIPTION: This function creates a SQL resolver that can handle multiple results for a single request. It groups results by a common key extracted from both the request and result objects, allowing for efficient batched database operations.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/SqlResolver-grouped.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const grouped: <T extends string, I, II, K, RI, A, IA, Row, E, RA = never, R = never>(\n  tag: T,\n  options: {\n    readonly Request: Schema.Schema<I, II, RI>;\n    readonly RequestGroupKey: (request: Types.NoInfer<I>) => K;\n    readonly Result: Schema.Schema<A, IA>;\n    readonly ResultGroupKey: (result: Types.NoInfer<A>, row: Types.NoInfer<Row>) => K;\n    readonly execute: (requests: Array<Types.NoInfer<II>>) => Effect.Effect<ReadonlyArray<Row>, E>;\n    readonly withContext?: false;\n  } | {\n    readonly Request: Schema.Schema<I, II, RI>;\n    readonly RequestGroupKey: (request: Types.NoInfer<I>) => K;\n    readonly Result: Schema.Schema<A, IA, RA>;\n    readonly ResultGroupKey: (result: Types.NoInfer<A>, row: Types.NoInfer<Row>) => K;\n    readonly execute: (requests: Array<Types.NoInfer<II>>) => Effect.Effect<ReadonlyArray<Row>, E, R>;\n    readonly withContext: true;\n  }\n) => Effect.Effect<SqlResolver<T, I, Array<A>, E, RI>, never, RA | R>\n```\n\n----------------------------------------\n\nTITLE: Converting URL Parameters to Record with @effect/platform in TypeScript\nDESCRIPTION: This code snippet demonstrates how to use the 'UrlParams.toRecord' function from the '@effect/platform' library to convert URL parameters into a Record. The function transforms the parameters such that each key maps to a string value if it is unique, or a NonEmptyArray<string> if there are multiple values for the same key. Dependencies include the '@effect/platform' module and Node's 'assert' for verification.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/UrlParams-toRecord.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { UrlParams } from \"@effect/platform\"\n\nconst urlParams = UrlParams.fromInput({ a: 1, b: true, c: \"string\", e: [1, 2, 3] })\nconst result = UrlParams.toRecord(urlParams)\n\nassert.deepStrictEqual(\n  result,\n  { \"a\": \"1\", \"b\": \"true\", \"c\": \"string\", \"e\": [\"1\", \"2\", \"3\"] }\n)\n```\n\n----------------------------------------\n\nTITLE: Combining Layers with zipWith in TypeScript Effect Framework\nDESCRIPTION: Defines a zipWith operation that combines two layers concurrently. It merges their input types and combines output types using a provided function. The operation supports type-safe error handling and context composition.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Layer-zipWith.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const zipWith: { <B, E2, R2, A, C>(that: Layer<B, E2, R2>, f: (a: Context.Context<A>, b: Context.Context<B>) => Context.Context<C>): <E, R>(self: Layer<A, E, R>) => Layer<C, E2 | E, R2 | R>; <A, E, R, B, E2, R2, C>(self: Layer<A, E, R>, that: Layer<B, E2, R2>, f: (a: Context.Context<A>, b: Context.Context<B>) => Context.Context<C>): Layer<C, E | E2, R | R2>; }\n```\n\n----------------------------------------\n\nTITLE: Effect.partition Function Signature in TypeScript\nDESCRIPTION: The type signature of the Effect.partition function, showing its overloaded versions and options. The function supports both curried and non-curried forms, and provides options for concurrency control, batching, and concurrent finalizers.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-partition.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const partition: { <A, B, E, R>(f: (a: A, i: number) => Effect<B, E, R>, options?: { readonly concurrency?: Concurrency | undefined; readonly batching?: boolean | \"inherit\" | undefined; readonly concurrentFinalizers?: boolean | undefined; } | undefined): (elements: Iterable<A>) => Effect<[excluded: Array<E>, satisfying: Array<B>], never, R>; <A, B, E, R>(elements: Iterable<A>, f: (a: A, i: number) => Effect<B, E, R>, options?: { readonly concurrency?: Concurrency | undefined; readonly batching?: boolean | \"inherit\" | undefined; readonly concurrentFinalizers?: boolean | undefined; } | undefined): Effect<[excluded: Array<E>, satisfying: Array<B>], never, R>; }\n```\n\n----------------------------------------\n\nTITLE: Implementing Chunk.take Method in TypeScript\nDESCRIPTION: Defines a take operation that extracts the first n elements from a Chunk. The function is overloaded to support both curried and regular parameter order. Returns a new Chunk containing up to n elements from the start of the input Chunk.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Chunk-take.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const take: { (n: number): <A>(self: Chunk<A>) => Chunk<A>; <A>(self: Chunk<A>, n: number): Chunk<A>; }\n```\n\n----------------------------------------\n\nTITLE: TArray findLast Signature\nDESCRIPTION: Describes the signature of the `findLast` function in the `TArray` module. It is a curried function that accepts a predicate and a TArray, returning an STM effect that resolves to an Option containing the element or None.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TArray-findLast.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const findLast: { <A>(predicate: Predicate<A>): (self: TArray<A>) => STM.STM<Option.Option<A>>; <A>(self: TArray<A>, predicate: Predicate<A>): STM.STM<Option.Option<A>>; }\n```\n\n----------------------------------------\n\nTITLE: Releasing a Write Lock in STM - TypeScript\nDESCRIPTION: This code snippet declares a function `releaseWrite` that releases a write lock held by a specific fiber. It returns the number of write locks still held by that fiber within an STM transaction. The function takes a `TReentrantLock` as input and returns an `STM.STM<number>`.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TReentrantLock-releaseWrite.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const releaseWrite: (self: TReentrantLock) => STM.STM<number>\n```\n\n----------------------------------------\n\nTITLE: Creating Batched Request Resolvers in TypeScript\nDESCRIPTION: The fromFunctionBatched function constructs a data source from a pure function that processes multiple requests at once. It takes a function that accepts a non-empty array of requests and returns corresponding results that match the same index positions.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/RequestResolver-fromFunctionBatched.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const fromFunctionBatched: <A extends Request.Request<any>>(f: (chunk: NonEmptyArray<A>) => Iterable<Request.Request.Success<A>>) => RequestResolver<A>\n```\n\n----------------------------------------\n\nTITLE: cachedWithTTL Function Signature in TypeScript\nDESCRIPTION: Type signature for the cachedWithTTL function showing its polymorphic nature and support for different parameter orderings. Takes a Duration input and an Effect, returning a new Effect.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-cachedWithTTL.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const cachedWithTTL: { (timeToLive: Duration.DurationInput): <A, E, R>(self: Effect<A, E, R>) => Effect<Effect<A, E>, never, R>; <A, E, R>(self: Effect<A, E, R>, timeToLive: Duration.DurationInput): Effect<Effect<A, E>, never, R>; }\n```\n\n----------------------------------------\n\nTITLE: Implementing ScopedCache.makeWith Function in TypeScript\nDESCRIPTION: Function signature for creating a new cache with configurable capacity, time-to-live duration, and lookup function. The TTL can be dynamically determined based on the Exit value returned by the lookup function. Returns an Effect containing the created ScopedCache.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/ScopedCache-makeWith.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const makeWith: <Key, Value, Error = never, Environment = never>(options: { readonly capacity: number; readonly lookup: Lookup<Key, Value, Error, Environment>; readonly timeToLive: (exit: Exit.Exit<Value, Error>) => Duration.DurationInput; }) => Effect.Effect<ScopedCache<Key, Value, Error>, never, Scope.Scope | Environment>\n```\n\n----------------------------------------\n\nTITLE: Defining Deferred Interface in TypeScript\nDESCRIPTION: TypeScript interface declaration for Deferred, which extends Effect and includes internal state properties. The interface represents an asynchronous variable that can be set once and awaited by multiple fibers, used for coordinating concurrent operations.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Deferred-Deferred.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface Deferred<in out A, in out E = never> extends Effect.Effect<A, E>, Deferred.Variance<A, E> {\n  /** @internal */\n  readonly state: MutableRef.MutableRef<internal.State<A, E>>\n  /** @internal */\n  readonly blockingOn: FiberId.FiberId\n  readonly [Unify.typeSymbol]?: unknown\n  readonly [Unify.unifySymbol]?: DeferredUnify<this>\n  readonly [Unify.ignoreSymbol]?: DeferredUnifyIgnore\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Channel.mergeMap Function in TypeScript\nDESCRIPTION: Declares the mergeMap function for Channel, which creates and merges new channels for each emitted element. It supports different merge strategies and concurrency options.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Channel-mergeMap.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const mergeMap: { <OutElem, OutElem1, InElem1, OutErr1, InErr1, Z, InDone1, Env1>(f: (outElem: OutElem) => Channel<OutElem1, InElem1, OutErr1, InErr1, Z, InDone1, Env1>, options: { readonly concurrency: number | \"unbounded\"; readonly bufferSize?: number | undefined; readonly mergeStrategy?: MergeStrategy.MergeStrategy | undefined; }): <InElem, OutErr, InErr, OutDone, InDone, Env>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>) => Channel<OutElem1, InElem & InElem1, OutErr1 | OutErr, InErr & InErr1, unknown, InDone & InDone1, Env1 | Env>; <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutElem1, InElem1, OutErr1, InErr1, Z, InDone1, Env1>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>, f: (outElem: OutElem) => Channel<OutElem1, InElem1, OutErr1, InErr1, Z, InDone1, Env1>, options: { readonly concurrency: number | \"unbounded\"; readonly bufferSize?: number | undefined; readonly mergeStrategy?: MergeStrategy.MergeStrategy | undefined; }): Channel<OutElem1, InElem & InElem1, OutErr | OutErr1, InErr & InErr1, unknown, InDone & InDone1, Env | Env1>; }\n```\n\n----------------------------------------\n\nTITLE: Converting Cause to Pretty Errors in TypeScript\nDESCRIPTION: A function that takes a Cause<E> and returns an array of PrettyError objects, providing detailed error information including metadata and span details for debugging purposes.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Cause-prettyErrors.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const prettyErrors: <E>(cause: Cause<E>) => Array<PrettyError>\n```\n\n----------------------------------------\n\nTITLE: Accessing the Stream Context with Effect-TS TypeScript Function\nDESCRIPTION: This TypeScript function, `contextWithStream`, is part of the Effect-TS library's Stream module. Its purpose is to access and manipulate the stream context by applying a function that receives the environment context and returns a Stream. It helps in managing dependencies by accessing environment contexts and can be used to chain or compose complex stream operations. The function signature declares generic types for input and output types, allowing for flexible stream compositions.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-contextWithStream.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const contextWithStream: <R0, A, E, R>(f: (env: Context.Context<R0>) => Stream<A, E, R>) => Stream<A, E, R0 | R>\n```\n\n----------------------------------------\n\nTITLE: Processing Command Line Arguments with Options.processCommandLine\nDESCRIPTION: The `processCommandLine` function takes command-line arguments, a configuration, and `Options` as input. It attempts to parse the arguments according to the defined options. The function returns an `Effect` that resolves to a tuple containing an `Option<ValidationError>`, an array of leftover arguments, and the constructed value of type `A`. The `Effect` also depends on `FileSystem`, `Path`, and `Terminal` services.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Options-processCommandLine.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const processCommandLine: { (args: ReadonlyArray<string>, config: CliConfig): <A>(self: Options<A>) => Effect<[Option<ValidationError>, Array<string>, A], ValidationError, FileSystem | Path | Terminal>; <A>(self: Options<A>, args: ReadonlyArray<string>, config: CliConfig): Effect<[Option<ValidationError>, Array<string>, A], ValidationError, FileSystem | Path | Terminal>; }\n```\n\n----------------------------------------\n\nTITLE: Stream.broadcastDynamic Signature (TypeScript)\nDESCRIPTION: Defines the signature for `broadcastDynamic`, a function that fans out an Effect Stream into multiple streams. It accepts a `maximumLag` parameter to control backpressure, ensuring the original stream doesn't advance too far ahead of slower downstream streams. The function returns an `Effect` that resolves to a new `Stream`.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-broadcastDynamic.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const broadcastDynamic: { (maximumLag: number | { readonly capacity: \\\"unbounded\\\"; readonly replay?: number | undefined; } | { readonly capacity: number; readonly strategy?: \\\"sliding\\\" | \\\"dropping\\\" | \\\"suspend\\\" | undefined; readonly replay?: number | undefined; }): <A, E, R>(self: Stream<A, E, R>) => Effect.Effect<Stream<A, E>, never, Scope.Scope | R>; <A, E, R>(self: Stream<A, E, R>, maximumLag: number | { readonly capacity: \\\"unbounded\\\"; readonly replay?: number | undefined; } | { readonly capacity: number; readonly strategy?: \\\"sliding\\\" | \\\"dropping\\\" | \\\"suspend\\\" | undefined; readonly replay?: number | undefined; }): Effect.Effect<Stream<A, E>, never, Scope.Scope | R>; }\n```\n\n----------------------------------------\n\nTITLE: Checking if a Number is Between Minimum and Maximum - TypeScript\nDESCRIPTION: This code snippet demonstrates how to utilize the `Number.between` method from the Effect library to check if a number lies within the defined range of minimum and maximum values, inclusive. It uses assertion tests to verify outcomes for various input numbers.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Number-between.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { Number } from \"effect\"\n\nconst between = Number.between({ minimum: 0, maximum: 5 })\n\nassert.deepStrictEqual(between(3), true)\nassert.deepStrictEqual(between(-1), false)\nassert.deepStrictEqual(between(6), false)\n```\n\n----------------------------------------\n\nTITLE: Validating Option.None in TypeScript Effect System\nDESCRIPTION: Function that ensures an Option is None and returns void, otherwise raises a NoSuchElementException. Useful for validating absence of values before execution continues.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-none.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const none: <A, E, R>(self: Effect<Option.Option<A>, E, R>) => Effect<void, E | Cause.NoSuchElementException, R>\n```\n\n----------------------------------------\n\nTITLE: Transforming STM Error Types in TypeScript\nDESCRIPTION: A utility function that allows mapping from one error type to another in STM computations. Supports both curried and uncurried function signatures, enabling flexible error handling and transformation.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/STM-mapError.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const mapError: { <E, E2>(f: (error: E) => E2): <A, R>(self: STM<A, E, R>) => STM<A, E2, R>; <A, E, R, E2>(self: STM<A, E, R>, f: (error: E) => E2): STM<A, E2, R>; }\n```\n\n----------------------------------------\n\nTITLE: Declaring runCollect Function in TypeScript for Channel Module\nDESCRIPTION: Defines the runCollect function that runs a channel until it finishes or fails, collecting its emitted output elements. The function takes a Channel as input and returns an Effect containing a tuple of collected output elements and the done value.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Channel-runCollect.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const runCollect: <OutElem, OutErr, InErr, OutDone, InDone, Env>(self: Channel<OutElem, unknown, OutErr, InErr, OutDone, InDone, Env>) => Effect.Effect<[Chunk.Chunk<OutElem>, OutDone], OutErr, Env>\n```\n\n----------------------------------------\n\nTITLE: Creating MutableHashSet from Generator Function in TypeScript with Effect\nDESCRIPTION: Demonstrates creating a MutableHashSet from a generator function that yields Fibonacci numbers. This shows how MutableHashSet can be created from any iterable source, including custom generator functions.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/MutableHashSet-fromIterable.md#2025-04-11_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { MutableHashSet } from \"effect\"\n\n// Generator functions return iterables\nfunction* fibonacci(n: number): Generator<number, void, never> {\n  let [a, b] = [0, 1]\n  for (let i = 0; i < n; i++) {\n    yield a\n    ;[a, b] = [b, a + b]\n  }\n}\n\n// Create a MutableHashSet from the first 10 Fibonacci numbers\nconst fibonacciSet = MutableHashSet.fromIterable(fibonacci(10))\n\nconsole.log(Array.from(fibonacciSet))\n// Outputs: [0, 1, 2, 3, 5, 8, 13, 21, 34] but in unsorted order\n```\n\n----------------------------------------\n\nTITLE: Using DateTime.nowAsDate to get current date in Effect\nDESCRIPTION: Demonstrates how to get the current time as a Date object using the DateTime.nowAsDate effect. This effect requires no services and cannot fail, as indicated by the never types in its signature.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/DateTime-nowAsDate.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { DateTime, Effect } from \"effect\"\n\nEffect.gen(function* () {\n  const now = yield* DateTime.nowAsDate\n})\n```\n\n----------------------------------------\n\nTITLE: Removing Duplicates from Iterables with dedupe Function in TypeScript\nDESCRIPTION: The dedupe function removes duplicates from an Iterable while preserving the order of the first occurrence of each element. It uses Equal.equivalence() from the Equal module to compare elements for equality. The function maintains type safety with conditional types to preserve array structure.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Array-dedupe.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const dedupe: <S extends Iterable<any>>(self: S) => S extends NonEmptyReadonlyArray<infer A> ? NonEmptyArray<A> : S extends Iterable<infer A> ? Array<A> : never\n```\n\n----------------------------------------\n\nTITLE: Implementing forEach Method for Chunk Module in TypeScript\nDESCRIPTION: Defines a forEach method that iterates over elements in a Chunk data structure. The method accepts a function that processes each element with its index, and can be called either with curried parameters or traditional two-parameter style. This implementation is focused on side effects rather than value transformation.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Chunk-forEach.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const forEach: { <A, B>(f: (a: A, index: number) => B): (self: Chunk<A>) => void; <A, B>(self: Chunk<A>, f: (a: A, index: number) => B): void; }\n```\n\n----------------------------------------\n\nTITLE: Constructing a tuple using Tuple.make in TypeScript\nDESCRIPTION: The `make` function constructs a new tuple from the provided values, showcasing its usage with a simple assertion example. It utilizes TypeScript generics to ensure type safety for any number of elements passed.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Tuple-make.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { make } from \"effect/Tuple\"\n\nassert.deepStrictEqual(make(1, 'hello', true), [1, 'hello', true])\n```\n\n----------------------------------------\n\nTITLE: Applying zipWith Function to Arrays in TypeScript\nDESCRIPTION: This snippet demonstrates how to use the Array.zipWith function to combine elements from two arrays using a custom function. It adds corresponding elements from two arrays.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Array-zipWith.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Array } from \"effect\"\n\nconst result = Array.zipWith([1, 2, 3], [4, 5, 6], (a, b) => a + b)\nconsole.log(result) // [5, 7, 9]\n```\n\n----------------------------------------\n\nTITLE: Implementing Metric trackDefect in TypeScript\nDESCRIPTION: Defines a utility that creates an aspect to track defects in Effect-based operations. The function can be used in two ways: either by passing the metric first and then the effect, or by passing the effect first and then the metric.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Metric-trackDefect.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const trackDefect: {\n  <Type, Out>(metric: Metric<Type, unknown, Out>): <A, E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>;\n  <A, E, R, Type, Out>(self: Effect.Effect<A, E, R>, metric: Metric<Type, unknown, Out>): Effect.Effect<A, E, R>;\n}\n```\n\n----------------------------------------\n\nTITLE: Declaring Interruptible Effect Function in TypeScript\nDESCRIPTION: Function signature for marking an effect as interruptible. When an effect is marked as interruptible, it will be interrupted immediately when an interruption is requested. Takes a Micro effect as input and returns a modified version that can be interrupted.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Micro-interruptible.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const interruptible: <A, E, R>(self: Micro<A, E, R>) => Micro<A, E, R>\n```\n\n----------------------------------------\n\nTITLE: Defining RPC Protocol Socket Server Layer in Effect\nDESCRIPTION: This code defines a Layer that provides an RPC protocol using a SocketServer for communication. The Layer is parameterized by `Protocol` and depends on `RpcSerialization.RpcSerialization` and `SocketServer.SocketServer`. This layer allows for the integration of RPC functionality with a SocketServer.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/RpcServer-layerProtocolSocketServer.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const layerProtocolSocketServer: Layer.Layer<Protocol, never, RpcSerialization.RpcSerialization | SocketServer.SocketServer>\n```\n\n----------------------------------------\n\nTITLE: Effect.annotateLogs TypeScript Function Signature\nDESCRIPTION: The function signature for annotateLogs showing its multiple overloads. It supports adding annotations as a key-value pair, as a record of values, or directly to an effect with either format.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-annotateLogs.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const annotateLogs: { (key: string, value: unknown): <A, E, R>(effect: Effect<A, E, R>) => Effect<A, E, R>; (values: Record<string, unknown>): <A, E, R>(effect: Effect<A, E, R>) => Effect<A, E, R>; <A, E, R>(effect: Effect<A, E, R>, key: string, value: unknown): Effect<A, E, R>; <A, E, R>(effect: Effect<A, E, R>, values: Record<string, unknown>): Effect<A, E, R>; }\n```\n\n----------------------------------------\n\nTITLE: Defining Optional Field Variants with Effect-TS in TypeScript\nDESCRIPTION: The code snippet defines the `FieldOption` interface that extends `VariantSchema.Field` to make fields optional. It provides specific schemas for different operations, such as 'select', 'insert', and 'update', for handling databases and JSON, making them flexible regarding nullable values and missing keys. This is especially useful when designing schemas that need to accommodate optional fields in a type-safe manner.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Model-FieldOption.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface FieldOption<S extends Schema.Schema.Any> extends\n  VariantSchema.Field<{\n    readonly select: Schema.OptionFromNullOr<S>\n    readonly insert: Schema.OptionFromNullOr<S>\n    readonly update: Schema.OptionFromNullOr<S>\n    readonly json: Schema.optionalWith<S, { as: \"Option\" }>\n    readonly jsonCreate: Schema.optionalWith<S, { as: \"Option\"; nullable: true }>\n    readonly jsonUpdate: Schema.optionalWith<S, { as: \"Option\"; nullable: true }>\n  }>\n{}\n```\n\n----------------------------------------\n\nTITLE: Using HashSet.every with Predicate in TypeScript\nDESCRIPTION: Example showing how to use HashSet.every with a regular predicate function to check if all elements in a HashSet satisfy a condition. Demonstrates all three API styles: data-last (pipeable), method chaining, and data-first.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/HashSet-every.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n// Syntax with Predicate\nimport { HashSet, pipe } from \"effect\"\n\nconst set = HashSet.make(1, 2, 3)\n\n// with `data-last`, a.k.a. `pipeable` API\npipe(\n  set,\n  HashSet.every((n) => n >= 0)\n) // true\n\n// or piped with the pipe function\nset.pipe(HashSet.every((n) => n >= 0)) // true\n\n// or with `data-first` API\nHashSet.every(set, (n) => n >= 0) // true\n```\n\n----------------------------------------\n\nTITLE: Combining Effects with Custom Function in TypeScript\nDESCRIPTION: Demonstrates how to combine two effects using zipWith, where one effect produces a number and another produces a string. The results are combined using a custom function that adds the number to the string length.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-zipWith.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Effect } from \"effect\"\n\nconst task1 = Effect.succeed(1).pipe(\n  Effect.delay(\"200 millis\"),\n  Effect.tap(Effect.log(\"task1 done\"))\n)\nconst task2 = Effect.succeed(\"hello\").pipe(\n  Effect.delay(\"100 millis\"),\n  Effect.tap(Effect.log(\"task2 done\"))\n)\n\nconst task3 = Effect.zipWith(\n  task1,\n  task2,\n  // Combines results into a single value\n  (number, string) => number + string.length\n)\n\nEffect.runPromise(task3).then(console.log)\n// Output:\n// timestamp=... level=INFO fiber=#3 message=\"task1 done\"\n// timestamp=... level=INFO fiber=#2 message=\"task2 done\"\n// 6\n```\n\n----------------------------------------\n\nTITLE: Using Struct.evolve for Object Transformation in TypeScript\nDESCRIPTION: Demonstrates how to use Struct.evolve to transform values in an object using specific transformation functions for each key. Keys without transformation functions retain their original values.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Struct-evolve.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { pipe, Struct } from \"effect\"\n\nassert.deepStrictEqual(\n  pipe(\n    { a: 'a', b: 1, c: 3 },\n    Struct.evolve({\n      a: (a) => a.length,\n      b: (b) => b * 2\n    })\n  ),\n  { a: 1, b: 2, c: 3 }\n)\n```\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const evolve: { <O, T>(t: PartialTransform<O, T>): (obj: O) => Transformed<O, T>; <O, T>(obj: O, t: PartialTransform<O, T>): Transformed<O, T>; }\n```\n\n----------------------------------------\n\nTITLE: Effect Timeout Type Definition\nDESCRIPTION: Type signature for the timeout function showing its polymorphic nature and type constraints. It defines two overloads for different parameter orderings.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-timeout.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const timeout: { (duration: Duration.DurationInput): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E | Cause.TimeoutException, R>; <A, E, R>(self: Effect<A, E, R>, duration: Duration.DurationInput): Effect<A, Cause.TimeoutException | E, R>; }\n```\n\n----------------------------------------\n\nTITLE: Checking Queue Shutdown Status in TypeScript using Effect-TS\nDESCRIPTION: The isShutdown function checks whether a queue (Dequeue or Enqueue) has been shut down. It returns an Effect that resolves to a boolean value, true if the queue is shut down, false otherwise.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Queue-isShutdown.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const isShutdown: <A>(self: Dequeue<A> | Enqueue<A>) => Effect.Effect<boolean>\n```\n\n----------------------------------------\n\nTITLE: Defining RPC Interface in TypeScript\nDESCRIPTION: This TypeScript interface definition represents an API endpoint in the Effect.ts RPC system. It includes type parameters for the endpoint tag, payload schema, success schema, error schema, and middleware. The interface provides methods to configure these aspects of the RPC endpoint.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Rpc-Rpc.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface Rpc<\n  out Tag extends string,\n  out Payload extends AnyStructSchema = Schema.Struct<{}>,\n  out Success extends Schema.Schema.Any = typeof Schema.Void,\n  out Error extends Schema.Schema.All = typeof Schema.Never,\n  out Middleware extends RpcMiddleware.TagClassAny = never\n> extends Pipeable {\n  readonly [TypeId]: TypeId\n  readonly _tag: Tag\n  readonly key: string\n  readonly payloadSchema: Payload\n  readonly successSchema: Success\n  readonly errorSchema: Error\n  readonly annotations: Context_.Context<never>\n  readonly middlewares: ReadonlySet<Middleware>\n\n  /**\n   * Set the schema for the success response of the rpc.\n   */\n  setSuccess<S extends Schema.Schema.Any>(schema: S): Rpc<\n    Tag,\n    Payload,\n    S,\n    Error,\n    Middleware\n  >\n\n  /**\n   * Set the schema for the error response of the rpc.\n   */\n  setError<E extends Schema.Schema.Any>(schema: E): Rpc<\n    Tag,\n    Payload,\n    Success,\n    E,\n    Middleware\n  >\n\n  /**\n   * Set the schema for the payload of the rpc.\n   */\n  setPayload<P extends Schema.Struct<any> | Schema.Struct.Fields>(\n    schema: P\n  ): Rpc<\n    Tag,\n    P extends Schema.Struct<infer _> ? P : P extends Schema.Struct.Fields ? Schema.Struct<P> : never,\n    Success,\n    Error,\n    Middleware\n  >\n\n  /**\n   * Add an `RpcMiddleware` to this procedure.\n   */\n  middleware<M extends RpcMiddleware.TagClassAny>(middleware: M): Rpc<\n    Tag,\n    Payload,\n    Success,\n    Error,\n    Middleware | M\n  >\n\n  /**\n   * Add an annotation on the rpc.\n   */\n  annotate<I, S>(\n    tag: Context_.Tag<I, S>,\n    value: S\n  ): Rpc<Tag, Payload, Success, Error, Middleware>\n\n  /**\n   * Merge the annotations of the rpc with the provided context.\n   */\n  annotateContext<I>(\n    context: Context_.Context<I>\n  ): Rpc<Tag, Payload, Success, Error, Middleware>\n}\n```\n\n----------------------------------------\n\nTITLE: Defining the branchAfter Function in TypeScript\nDESCRIPTION: The `branchAfter` function takes a number `n` and a function `f` as parameters, allowing users to branch a Stream after collecting `n` elements. It returns a new Stream that processes all subsequent elements using the provided function.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-branchAfter.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const branchAfter: { <A, A2, E2, R2>(n: number, f: (input: Chunk.Chunk<A>) => Stream<A2, E2, R2>): <E, R>(self: Stream<A, E, R>) => Stream<A2, E2 | E, R2 | R>; <A, E, R, A2, E2, R2>(self: Stream<A, E, R>, n: number, f: (input: Chunk.Chunk<A>) => Stream<A2, E2, R2>): Stream<A2, E | E2, R | R2>; }\n```\n\n----------------------------------------\n\nTITLE: Using Array.takeRight to Extract Elements from the End of an Array in TypeScript\nDESCRIPTION: This snippet demonstrates how to use the Array.takeRight function to keep only a specified number of elements from the end of an array. In this example, it extracts the last 3 elements from the array [1, 2, 3, 4, 5].\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Array-takeRight.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Array } from \"effect\"\n\nconst result = Array.takeRight([1, 2, 3, 4, 5], 3)\nconsole.log(result) // [3, 4, 5]\n```\n\n----------------------------------------\n\nTITLE: Constructing Channel from Option in TypeScript\nDESCRIPTION: The fromOption function creates a Channel from an Option. It takes an Option<A> as input and returns a Channel that never fails, has unknown input and environment, and produces either an A or an Option<never>.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Channel-fromOption.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const fromOption: <A>(option: Option.Option<A>) => Channel<never, unknown, Option.Option<never>, unknown, A, unknown>\n```\n\n----------------------------------------\n\nTITLE: Decoding Hex String to Uint8Array in TypeScript\nDESCRIPTION: This snippet declares a constant called Uint8ArrayFromHex which is a Schema function that takes a hex encoded string as input and converts it to a Uint8Array. It is part of the Effect-TS package and requires the TypeScript environment. The expected input is a hexadecimal string and the output is a Uint8Array representing the binary data. This function has been available since version 3.10.0 of the library.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Schema-Uint8ArrayFromHex.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const Uint8ArrayFromHex: Schema<Uint8Array<ArrayBufferLike>, string, never>\n```\n\n----------------------------------------\n\nTITLE: Union of Transactional Sets in TypeScript\nDESCRIPTION: The 'union' function declares a method to atomically transform a transactional set into the union of itself and a provided set using Software Transactional Memory (STM). The function manages concurrency and ensures atomicity during set operations. There are no specific dependencies listed, but it is implied that 'STM' and 'TSet' are part of the package that needs to be included. The parameters 'self' and 'other' are 'TSet' instances representing the sets to be combined. The outcome is an altered state of 'self', incorporating elements from 'other'. This utility is constrained to work only within the STM ecosystem provided by the 'effect' package.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TSet-union.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const union: { <A>(other: TSet<A>): (self: TSet<A>) => STM.STM<void>; <A>(self: TSet<A>, other: TSet<A>): STM.STM<void>; }\n```\n\n----------------------------------------\n\nTITLE: HashSet.make Function Signature in TypeScript\nDESCRIPTION: The TypeScript type signature for the HashSet.make function that constructs a new HashSet from a variable number of values. The function has O(n) time complexity where n is the number of elements.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/HashSet-make.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const make: <As extends ReadonlyArray<any>>(...elements: As) => HashSet<As[number]>\n```\n\n----------------------------------------\n\nTITLE: Match.tag Type Signature in TypeScript\nDESCRIPTION: Type signature for the Match.tag function showing its generic parameters and return type for pattern matching on discriminated unions.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Match-tag.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const tag: <R, P extends Types.Tags<\"_tag\", R> & string, Ret, Fn extends (_: Extract<R, Record<\"_tag\", P>>) => Ret>(...pattern: [first: P, ...values: Array<P>, f: Fn]) => <I, F, A, Pr>(self: Matcher<I, F, R, A, Pr, Ret>) => Matcher<I, Types.AddWithout<F, Extract<R, Record<\"_tag\", P>>>, Types.ApplyFilters<I, Types.AddWithout<F, Extract<R, Record<\"_tag\", P>>>>, ReturnType<Fn> | A, Pr, Ret>\n```\n\n----------------------------------------\n\nTITLE: Defining layerTestClient Layer for HttpClient in TypeScript\nDESCRIPTION: Creates a Layer producing an HttpClient with a prepended URL of the running HTTP server. This is useful for testing HTTP server implementations.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/HttpServer-layerTestClient.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const layerTestClient: Layer.Layer<Client.HttpClient, never, HttpServer | Client.HttpClient>\n```\n\n----------------------------------------\n\nTITLE: Testing Either.isLeft Function in TypeScript\nDESCRIPTION: Example code demonstrating how to use Either.isLeft to check if an Either instance is a Left value. Shows testing with both Right and Left values using assert.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Either-isLeft.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { Either } from \"effect\"\n\nassert.deepStrictEqual(Either.isLeft(Either.right(1)), false)\nassert.deepStrictEqual(Either.isLeft(Either.left(\"a\")), true)\n```\n\n----------------------------------------\n\nTITLE: Creating Counter Metrics in Effect\nDESCRIPTION: Demonstrates how to create both number and bigint counter metrics with configuration options. The counter can track cumulative values and be configured for incremental-only operation with optional descriptions.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Metric-counter.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Metric } from \"effect\"\n\nconst numberCounter = Metric.counter(\"count\", {\n  description: \"A number counter\"\n});\n\nconst bigintCounter = Metric.counter(\"count\", {\n  description: \"A bigint counter\",\n  bigint: true\n});\n```\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const counter: { (name: string, options?: { readonly description?: string | undefined; readonly bigint?: false | undefined; readonly incremental?: boolean | undefined; }): Metric.Counter<number>; (name: string, options: { readonly description?: string | undefined; readonly bigint: true; readonly incremental?: boolean | undefined; }): Metric.Counter<bigint>; }\n```\n\n----------------------------------------\n\nTITLE: Implementing Request Completion with Effect in TypeScript\nDESCRIPTION: Function declaration for completing a Request with an effectful computation. The function handles both success and failure cases of the effect workflow, mapping them to request completion and failure respectively.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Request-completeEffect.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const completeEffect: { \n  <A extends Request<any, any>, R>(\n    effect: Effect.Effect<Request.Success<A>, Request.Error<A>, R>\n  ): (self: A) => Effect.Effect<void, never, R>; \n  <A extends Request<any, any>, R>(\n    self: A, \n    effect: Effect.Effect<Request.Success<A>, Request.Error<A>, R>\n  ): Effect.Effect<void, never, R>; \n}\n```\n\n----------------------------------------\n\nTITLE: Retrieving Current Fiber in TypeScript\nDESCRIPTION: The getCurrentFiber function returns an Option containing the current RuntimeFiber if one is running. It takes no parameters and can be used to access the current execution context.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Fiber-getCurrentFiber.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const getCurrentFiber: () => Option.Option<RuntimeFiber<any, any>>\n```\n\n----------------------------------------\n\nTITLE: Implementing Conditional Fallback Configuration in TypeScript\nDESCRIPTION: The orElseIf function returns a configuration that reads from the primary config, but falls back to a specified alternative if an error occurs that satisfies a given predicate. It supports both curried and non-curried usage patterns.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Config-orElseIf.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const orElseIf: { <A2>(options: { readonly if: Predicate<ConfigError.ConfigError>; readonly orElse: LazyArg<Config<A2>>; }): <A>(self: Config<A>) => Config<A>; <A, A2>(self: Config<A>, options: { readonly if: Predicate<ConfigError.ConfigError>; readonly orElse: LazyArg<Config<A2>>; }): Config<A>; }\n```\n\n----------------------------------------\n\nTITLE: BigInt.divide Function Signature in TypeScript\nDESCRIPTION: The type signature for the BigInt.divide function, showing both the curried and uncurried calling styles. It takes two bigint parameters and returns an Option containing the result or None if dividing by zero.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/BigInt-divide.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const divide: { (that: bigint): (self: bigint) => Option.Option<bigint>; (self: bigint, that: bigint): Option.Option<bigint>; }\n```\n\n----------------------------------------\n\nTITLE: Implementing findLast Function in TypeScript for Chunk Module\nDESCRIPTION: This code snippet defines the findLast function, which searches for the last element in a Chunk that meets a specified condition. It supports both predicates and refinements, allowing for flexible searching criteria. The function returns an Option type, which may contain the found element or be empty if no element satisfies the condition.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Chunk-findLast.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const findLast: {\n  <A, B extends A>(refinement: Refinement<NoInfer<A>, B>): (self: Chunk<A>) => Option<B>;\n  <A>(predicate: Predicate<NoInfer<A>>): (self: Chunk<A>) => Option<A>;\n  <A, B extends A>(self: Chunk<A>, refinement: Refinement<A, B>): Option<B>;\n  <A>(self: Chunk<A>, predicate: Predicate<A>): Option<A>;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Exit Type in TypeScript\nDESCRIPTION: The Exit type represents the result of executing an Effect workflow with two possible variants: Success containing a value of type A, or Failure containing a Cause of type E.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Exit-Exit.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ntype Exit<A, E> = Success<A, E> | Failure<A, E>\n```\n\n----------------------------------------\n\nTITLE: Signature of Sliding Function in Effect Stream using TypeScript\nDESCRIPTION: This snippet provides the TypeScript declaration signature for the 'sliding' function. It describes the overloads and type parameters involved in the function that takes a chunk size as input and returns a stream of chunks. Understanding this signature is crucial for implementing the sliding window functionality correctly.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-sliding.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const sliding: { (chunkSize: number): <A, E, R>(self: Stream<A, E, R>) => Stream<Chunk.Chunk<A>, E, R>; <A, E, R>(self: Stream<A, E, R>, chunkSize: number): Stream<Chunk.Chunk<A>, E, R>; }\n```\n\n----------------------------------------\n\nTITLE: Retrieving Queue Size in TypeScript using Effect Library\nDESCRIPTION: This function retrieves the size of a queue, which represents the number of elements in the queue. It can return a negative value if fibers are suspended waiting for elements to be added. The function works with both Dequeue and Enqueue types.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Queue-size.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const size: <A>(self: Dequeue<A> | Enqueue<A>) => Effect.Effect<number>\n```\n\n----------------------------------------\n\nTITLE: Defining catchSome Functionality in TypeScript for STM Error Handling\nDESCRIPTION: The `catchSome` function allows users to define how to recover from specific errors that might occur during STM operations. It takes a predicate function that returns an optional STM to execute upon error. It is essential for implementing robust error recovery patterns in STM workflows. The function operates on parameters that define both the error type and return type while being compatible with the STM context.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/STM-catchSome.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const catchSome: { <E, A2, E2, R2>(pf: (error: E) => Option.Option<STM<A2, E2, R2>>): <A, R>(self: STM<A, E, R>) => STM<A2 | A, E | E2, R2 | R>; <A, E, R, A2, E2, R2>(self: STM<A, E, R>, pf: (error: E) => Option.Option<STM<A2, E2, R2>>): STM<A | A2, E | E2, R | R2>; }\n```\n\n----------------------------------------\n\nTITLE: Finding Key-Value Pair in TMap with Effect in STM (TypeScript)\nDESCRIPTION: The `findSTM` function searches a `TMap` for a key-value pair that satisfies a given predicate `f`. The predicate `f` is an effectful function returning an STM computation with `Option<E>` as error and `R` as environment. If a match is found, it extracts a value using the same effectful function within an STM transaction, handling potential errors. It returns an STM computation representing the `Option<A>` result, which can be `Some(A)` if a matching pair is found and processed successfully, or `None` otherwise.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TMap-findSTM.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const findSTM: { <K, V, A, E, R>(f: (key: K, value: V) => STM.STM<A, Option.Option<E>, R>): (self: TMap<K, V>) => STM.STM<Option.Option<A>, E, R>; <K, V, A, E, R>(self: TMap<K, V>, f: (key: K, value: V) => STM.STM<A, Option.Option<E>, R>): STM.STM<Option.Option<A>, E, R>; }\n```\n\n----------------------------------------\n\nTITLE: Using CloseableScope with Effect (TypeScript)\nDESCRIPTION: Provides a closeable scope to an Effect, ensuring that the scope is closed after the Effect completes execution, whether by success, failure, or interruption. The function takes either the scope first or the effect first, depending on the arity of the function call.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Scope-use.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const use: { (scope: CloseableScope): <A, E, R>(effect: Effect.Effect<A, E, R>) => Effect.Effect<A, E, Exclude<R, Scope>>; <A, E, R>(effect: Effect.Effect<A, E, R>, scope: CloseableScope): Effect.Effect<A, E, Exclude<R, Scope>>; }\n```\n\n----------------------------------------\n\nTITLE: Implementing Array Reduction with Effect Framework - TypeScript Example\nDESCRIPTION: Demonstrates how to use Array.reduceRight to sum numbers in an array from right to left. The function takes an initial value and a reducer function to accumulate values.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Array-reduceRight.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Array } from \"effect\"\n\nconst result = Array.reduceRight([1, 2, 3], 0, (acc, n) => acc + n)\nconsole.log(result) // 6\n```\n\n----------------------------------------\n\nTITLE: Effectfully Transforming Sink Results with mapEffect in TypeScript\nDESCRIPTION: The mapEffect function transforms a sink's result using an effectful function. It takes a function that converts the sink's output type A to an Effect producing A2, and returns a new sink with the transformed output type.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Sink-mapEffect.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const mapEffect: { <A, A2, E2, R2>(f: (a: A) => Effect.Effect<A2, E2, R2>): <In, L, E, R>(self: Sink<A, In, L, E, R>) => Sink<A2, In, L, E2 | E, R2 | R>; <A, In, L, E, R, A2, E2, R2>(self: Sink<A, In, L, E, R>, f: (a: A) => Effect.Effect<A2, E2, R2>): Sink<A2, In, L, E | E2, R | R2>; }\n```\n\n----------------------------------------\n\nTITLE: Forking Child Scope in Effect TypeScript\nDESCRIPTION: Creates a new child scope with a specified execution strategy that automatically closes when the parent scope is closed. Used for managing resource lifecycles and concurrent execution strategies.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Scope-fork.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const fork: (self: Scope, strategy: ExecutionStrategy.ExecutionStrategy) => Effect.Effect<CloseableScope>\n```\n\n----------------------------------------\n\nTITLE: Using JsonNumber Schema for JSON Number Validation in TypeScript\nDESCRIPTION: This example demonstrates how to use the JsonNumber schema to validate various number inputs. It checks for regular numbers, NaN, and positive/negative infinity.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Schema-JsonNumber.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport * as Schema from \"effect/Schema\"\n\nconst is = Schema.is(S.JsonNumber)\n\nassert.deepStrictEqual(is(42), true)\nassert.deepStrictEqual(is(Number.NaN), false)\nassert.deepStrictEqual(is(Number.POSITIVE_INFINITY), false)\nassert.deepStrictEqual(is(Number.NEGATIVE_INFINITY), false)\n```\n\n----------------------------------------\n\nTITLE: Matching STM Effect Outcomes in TypeScript\nDESCRIPTION: This snippet defines the 'matchSTM' function which allows developers to provide handlers for both success and failure cases of STM effects. It utilizes generics to ensure type safety for inputs and outputs, ensuring flexibility when dealing with various types of data and errors.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/STM-matchSTM.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const matchSTM: { <E, A1, E1, R1, A, A2, E2, R2>(options: { readonly onFailure: (e: E) => STM<A1, E1, R1>; readonly onSuccess: (a: A) => STM<A2, E2, R2>; }): <R>(self: STM<A, E, R>) => STM<A1 | A2, E1 | E2, R1 | R2 | R>; <A, E, R, A1, E1, R1, A2, E2, R2>(self: STM<A, E, R>, options: { readonly onFailure: (e: E) => STM<A1, E1, R1>; readonly onSuccess: (a: A) => STM<A2, E2, R2>; }): STM<A1 | A2, E1 | E2, R | R1 | R2>; }\n```\n\n----------------------------------------\n\nTITLE: Creating and Using an Empty HashSet in TypeScript\nDESCRIPTION: Demonstrates how to create an empty HashSet, add elements (including duplicates), and convert it to an array of values. This example showcases the uniqueness property of HashSet.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/HashSet-empty.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { HashSet, pipe } from \"effect\"\n\nconsole.log(\n  pipe(\n    // Provide a type argument to create a HashSet of a specific type\n    HashSet.empty<number>(),\n    HashSet.add(1),\n    HashSet.add(1), // Notice the duplicate\n    HashSet.add(2),\n    HashSet.toValues\n  )\n) // Output: [1, 2]\n```\n\n----------------------------------------\n\nTITLE: Converting Iterables to Arrays with Array.fromIterable in TypeScript\nDESCRIPTION: Creates a new Array from an iterable collection of values. If the input is already an array, it returns it as-is. Otherwise, it converts the iterable collection to an array.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Array-fromIterable.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Array } from \"effect\"\n\nconst result = Array.fromIterable(new Set([1, 2, 3]))\nconsole.log(result) // [1, 2, 3]\n```\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const fromIterable: <A>(collection: Iterable<A>) => Array<A>\n```\n\n----------------------------------------\n\nTITLE: Defining orDie Function for Channel Error Handling in TypeScript\nDESCRIPTION: The orDie function translates channel failure into death of the fiber. It makes all failures unchecked and removes them from the channel's type signature. It can be called with either an error argument first or the channel first.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Channel-orDie.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const orDie: { <E>(error: LazyArg<E>): <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>) => Channel<OutElem, InElem, never, InErr, OutDone, InDone, Env>; <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, E>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>, error: LazyArg<E>): Channel<OutElem, InElem, never, InErr, OutDone, InDone, Env>; }\n```\n\n----------------------------------------\n\nTITLE: Defining findFirst Function for Iterable in TypeScript\nDESCRIPTION: Declares the findFirst function which returns the first element satisfying a specified predicate or None if no such element exists. It supports various overloads for different use cases including refinements and predicates.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Iterable-findFirst.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const findFirst: { <A, B>(f: (a: NoInfer<A>, i: number) => Option<B>): (self: Iterable<A>) => Option<B>; <A, B extends A>(refinement: (a: NoInfer<A>, i: number) => a is B): (self: Iterable<A>) => Option<B>; <A>(predicate: (a: NoInfer<A>, i: number) => boolean): (self: Iterable<A>) => Option<A>; <A, B>(self: Iterable<A>, f: (a: A, i: number) => Option<B>): Option<B>; <A, B extends A>(self: Iterable<A>, refinement: (a: A, i: number) => a is B): Option<B>; <A>(self: Iterable<A>, predicate: (a: A, i: number) => boolean): Option<A>; }\n```\n\n----------------------------------------\n\nTITLE: Setting or Removing Keys in MutableHashMap Using Update Function in TypeScript\nDESCRIPTION: The modifyAt function allows setting or removing a specified key in a MutableHashMap using a provided update function. The function takes a key and a function that receives the current Option<Value> and returns an Option<Value> to determine the new state.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/MutableHashMap-modifyAt.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const modifyAt: { <K, V>(key: K, f: (value: Option.Option<V>) => Option.Option<V>): (self: MutableHashMap<K, V>) => MutableHashMap<K, V>; <K, V>(self: MutableHashMap<K, V>, key: K, f: (value: Option.Option<V>) => Option.Option<V>): MutableHashMap<K, V>; }\n```\n\n----------------------------------------\n\nTITLE: Creating Order for Array Comparison in TypeScript\nDESCRIPTION: The `array` function generates a new `Order` for an array of values leveraging a provided `Order` for the individual elements. This allows comparison of two arrays by applying the specified order to each element, with a fallback to array length in case of equality. The function is essential for comparing arrays of the same type with custom comparison logic.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Order-array.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const array: <A>(O: Order<A>) => Order<ReadonlyArray<A>>\n```\n\n----------------------------------------\n\nTITLE: Effect.forkDaemon Function Signature\nDESCRIPTION: TypeScript type signature for the forkDaemon function showing it takes an Effect and returns a RuntimeFiber.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-forkDaemon.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const forkDaemon: <A, E, R>(self: Effect<A, E, R>) => Effect<Fiber.RuntimeFiber<A, E>, never, R>\n```\n\n----------------------------------------\n\nTITLE: Parsing Numbers using Effect Schema (TypeScript)\nDESCRIPTION: Defines the `parseNumber` function which extends a schema to transform a string input into a number using `effect/Number`'s parsing capabilities.  It handles special string representations of numbers and returns an error if the parsing fails. The function takes a schema `S` that represents a string type, and transforms it into a schema that represents a number type.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Schema-parseNumber.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const parseNumber: <S extends Schema.Any, A extends string>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>) => transformOrFail<S, typeof Number$>\n```\n\n----------------------------------------\n\nTITLE: Defining WithResult Interface in TypeScript\nDESCRIPTION: This TypeScript code defines the `WithResult` interface. It encapsulates the outcome of an operation, distinguishing between success and failure cases. Each case is associated with a schema that defines the structure and types of the success or failure data.  It includes types for success, encoded success, failure, encoded failure, and result environment.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Schema-WithResult.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface WithResult<Success, SuccessEncoded, Failure, FailureEncoded, ResultR> {\n  readonly [symbolWithResult]: {\n    readonly success: Schema<Success, SuccessEncoded, ResultR>\n    readonly failure: Schema<Failure, FailureEncoded, ResultR>\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Effect Schedule Reduction with Side Effects (reduceEffect)\nDESCRIPTION: The `reduceEffect` function extends the `Schedule` type to enable effectful accumulation of schedule outputs. It takes an initial value `zero` and a reducer function `f` that returns an `Effect`, allowing for side effects during the accumulation process. The function returns a new `Schedule` with the accumulated value as its output.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Schedule-reduceEffect.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const reduceEffect: { <Z, Out, R2>(zero: Z, f: (z: Z, out: Out) => Effect.Effect<Z, never, R2>): <In, R>(self: Schedule<Out, In, R>) => Schedule<Z, In, R2 | R>; <Out, In, R, Z, R2>(self: Schedule<Out, In, R>, zero: Z, f: (z: Z, out: Out) => Effect.Effect<Z, never, R2>): Schedule<Z, In, R | R2>; }\n```\n\n----------------------------------------\n\nTITLE: Implementing Stream Timeout with Error Handling in TypeScript\nDESCRIPTION: Defines a function that fails a stream with a specified error if it does not produce a value within a given duration. The function supports both curried and non-curried parameter variations.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-timeoutFail.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const timeoutFail: { <E2>(error: LazyArg<E2>, duration: Duration.DurationInput): <A, E, R>(self: Stream<A, E, R>) => Stream<A, E2 | E, R>; <A, E, R, E2>(self: Stream<A, E, R>, error: LazyArg<E2>, duration: Duration.DurationInput): Stream<A, E | E2, R>; }\n```\n\n----------------------------------------\n\nTITLE: Using HashSet.size to Calculate Set Size in TypeScript\nDESCRIPTION: Examples demonstrating how to use the HashSet.size method to get the number of unique values in a HashSet. Shows usage with an empty set and a set containing duplicate values.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/HashSet-size.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { HashSet, pipe } from \"effect\"\nimport assert from \"node:assert/strict\"\n\nassert.deepStrictEqual(pipe(HashSet.empty(), HashSet.size), 0)\n\nassert.deepStrictEqual(\n  pipe(HashSet.make(1, 2, 2, 3, 4, 3), HashSet.size),\n  4\n)\n```\n\n----------------------------------------\n\nTITLE: Flattening Arrays using Effect Library in TypeScript\nDESCRIPTION: Demonstrates how to use the Array.flatten function to combine multiple arrays into a single flattened array. The function takes an array of arrays and returns a new array with all elements concatenated.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Array-flatten.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Array } from \"effect\"\n\nconst result = Array.flatten([[1, 2], [], [3, 4], [], [5, 6]])\nconsole.log(result) // [1, 2, 3, 4, 5, 6]\n```\n\n----------------------------------------\n\nTITLE: Type Checking Cron Instances in TypeScript\nDESCRIPTION: A type guard function that checks if a given unknown value is a Cron instance. The function performs a runtime type check and also provides type narrowing for TypeScript.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Cron-isCron.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const isCron: (u: unknown) => u is Cron\n```\n\n----------------------------------------\n\nTITLE: Flattening Nested Option Types in Effect TS using TypeScript\nDESCRIPTION: This TypeScript function `flatten` simplifies nested `Option` types by collapsing an `Option` of `Option` into a single `Option`. It returns `None` if the outer `Option` is `None` or retrieves the inner `Option` if the outer one is `Some`. This function is particularly useful for dealing with nested `Option` structures in functional programming patterns within the Effect TS library. There are no external dependencies, but it builds upon the Option module within Effect TS. The input is an `Option` wrapping another `Option`, and the output is a flattened `Option`.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Option-flatten.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const flatten: <A>(self: Option<Option<A>>) => Option<A>\n```\n\n----------------------------------------\n\nTITLE: Defining filterNot Function in TypeScript for STM Module\nDESCRIPTION: This function signature for filterNot allows users to filter a collection based on an effectual predicate, effectively removing elements that satisfy the predicate. It supports two variations: one that takes a predicate and returns a function, and one that takes both the iterable and the predicate together. It requires the NoInfer type to infer the proper type when using generics.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/STM-filterNot.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const filterNot: { <A, R, E>(predicate: (a: NoInfer<A>) => STM<boolean, E, R>): (iterable: Iterable<A>) => STM<Array<A>, E, R>; <A, R, E>(iterable: Iterable<A>, predicate: (a: A) => STM<boolean, E, R>): STM<Array<A>, E, R>; }\n```\n\n----------------------------------------\n\nTITLE: Using isUint8Array Type Guard in TypeScript\nDESCRIPTION: This snippet demonstrates how to use the isUint8Array function to check if a value is a Uint8Array. It includes examples of both successful and unsuccessful checks.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Predicate-isUint8Array.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { isUint8Array } from \"effect/Predicate\"\n\nassert.deepStrictEqual(isUint8Array(new Uint8Array()), true)\n\nassert.deepStrictEqual(isUint8Array(null), false)\nassert.deepStrictEqual(isUint8Array({}), false)\n```\n\n----------------------------------------\n\nTITLE: Executing Command and Retrieving Output as Lines in TypeScript\nDESCRIPTION: This function runs a command and returns its output as an array of strings, with each string representing a line of output. It allows specifying the encoding for the output. The function returns an Effect that requires a CommandExecutor and may result in a PlatformError.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Command-lines.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const lines: (command: Command, encoding?: string) => Effect<Array<string>, PlatformError, CommandExecutor>\n```\n\n----------------------------------------\n\nTITLE: Effect.bind Type Signature Definition\nDESCRIPTION: Type declaration for the Effect.bind function showing its generic parameters and return types. It defines how bind works with different types and constraints in the Effect monad.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-bind.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const bind: { <N extends string, A extends object, B, E2, R2>(name: Exclude<N, keyof A>, f: (a: NoInfer<A>) => Effect<B, E2, R2>): <E1, R1>(self: Effect<A, E1, R1>) => Effect<{ [K in N | keyof A]: K extends keyof A ? A[K] : B; }, E2 | E1, R2 | R1>; <A extends object, N extends string, E1, R1, B, E2, R2>(self: Effect<A, E1, R1>, name: Exclude<N, keyof A>, f: (a: NoInfer<A>) => Effect<B, E2, R2>): Effect<{ [K in N | keyof A]: K extends keyof A ? A[K] : B; }, E1 | E2, R1 | R2>; }\n```\n\n----------------------------------------\n\nTITLE: Declaring mapInputContext Function for Channel Context Transformation in TypeScript\nDESCRIPTION: This code snippet defines the mapInputContext function, which transforms the context provided to a channel. It supports two overloads: one that takes a transformation function first, and another that takes the channel first. The function allows for changing the environment type of the channel.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Channel-mapInputContext.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const mapInputContext: {\n  <Env0, Env>(f: (env: Context.Context<Env0>) => Context.Context<Env>):\n    <OutElem, InElem, OutErr, InErr, OutDone, InDone>\n    (self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>) =>\n      Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env0>;\n  <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, Env0>\n  (self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,\n   f: (env: Context.Context<Env0>) => Context.Context<Env>):\n     Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env0>;\n}\n```\n\n----------------------------------------\n\nTITLE: Acquiring a Reentrant Lock in Effect TypeScript\nDESCRIPTION: A convenience method for applications that only need reentrant locks without distinguishing between readers and writers. This function acquires a lock and returns an Effect that contains the lock count and is tied to a Scope.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TReentrantLock-lock.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const lock: (self: TReentrantLock) => Effect.Effect<number, never, Scope.Scope>\n```\n\n----------------------------------------\n\nTITLE: Defining Queue.take Function in TypeScript for Effect Library\nDESCRIPTION: Declares the take function which retrieves the oldest value from a Dequeue. If the queue is empty, it returns a computation that resumes when an item is added to the queue. The function is part of the Queue module in the Effect library.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Queue-take.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const take: <A>(self: Dequeue<A>) => Effect.Effect<A>\n```\n\n----------------------------------------\n\nTITLE: Declaring Record.difference Function in TypeScript\nDESCRIPTION: Defines the difference function for merging two records, preserving only unique entries. It supports both curried and non-curried invocations, operating on ReadonlyRecord types.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Record-difference.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const difference: { <K1 extends string, B>(that: ReadonlyRecord<K1, B>): <K0 extends string, A>(self: ReadonlyRecord<K0, A>) => Record<K0 | K1, A | B>; <K0 extends string, A, K1 extends string, B>(self: ReadonlyRecord<K0, A>, that: ReadonlyRecord<K1, B>): Record<K0 | K1, A | B>; }\n```\n\n----------------------------------------\n\nTITLE: Declare layerTest in NodeHttpServer\nDESCRIPTION: This code declares the `layerTest` constant, which is a Layer that sets up a test HTTP server. It provides `Server.HttpServer`, `Platform.HttpPlatform`, `Etag.Generator`, `NodeContext.NodeContext`, and `HttpClient.HttpClient` to the Effect environment.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/NodeHttpServer-layerTest.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const layerTest: Layer.Layer<Server.HttpServer | Platform.HttpPlatform | Etag.Generator | NodeContext.NodeContext | HttpClient.HttpClient, ServeError, never>\n```\n\n----------------------------------------\n\nTITLE: Defining withTracerDisabledWhen Function in TypeScript\nDESCRIPTION: Declares a function that disables tracing for specific HTTP client requests based on a provided predicate. It can be used in two ways: either by passing the predicate first and then the effect, or by passing the effect first and then the predicate.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/HttpClient-withTracerDisabledWhen.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const withTracerDisabledWhen: {\n  (predicate: Predicate.Predicate<ClientRequest.HttpClientRequest>): <A, E, R>(effect: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>;\n  <A, E, R>(effect: Effect.Effect<A, E, R>, predicate: Predicate.Predicate<ClientRequest.HttpClientRequest>): Effect.Effect<A, E, R>;\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Minimum Log Level in Effect Logger (TypeScript)\nDESCRIPTION: This snippet demonstrates how to use the Logger.minimumLogLevel function to control log output. It sets up a program that logs a message, sleeps, and then logs to the console. The minimum log level is set to None, effectively disabling logging.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Logger-minimumLogLevel.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Effect, Logger, LogLevel } from \"effect\"\n\nconst program = Effect.gen(function*() {\n  yield* Effect.log(\"Executing task...\")\n  yield* Effect.sleep(\"100 millis\")\n  console.log(\"task done\")\n})\n\n// Logging disabled using a layer\nEffect.runFork(program.pipe(Effect.provide(Logger.minimumLogLevel(LogLevel.None))))\n// task done\n```\n\n----------------------------------------\n\nTITLE: Implementing takeAll Function for Queue in TypeScript\nDESCRIPTION: Defines the takeAll function which removes and returns all elements from a Dequeue as a Chunk. If the queue is empty, it returns an empty collection. This function is part of the Queue module in the Effect-TS library.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Queue-takeAll.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const takeAll: <A>(self: Dequeue<A>) => Effect.Effect<Chunk.Chunk<A>>\n```\n\n----------------------------------------\n\nTITLE: Signature of Stream.bind Function\nDESCRIPTION: This snippet provides the TypeScript declaration for the bind function in the Stream module. It specifies the generic parameters and their roles, including `tag`, the function `f`, and options for concurrency and buffer size. This declaration is crucial for understanding how to implement variable bindings in streams using TypeScript.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-bind.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const bind: { <N extends string, A, B, E2, R2>(tag: Exclude<N, keyof A>, f: (_: NoInfer<A>) => Stream<B, E2, R2>, options?: { readonly concurrency?: number | \"unbounded\" | undefined; readonly bufferSize?: number | undefined; } | undefined): <E, R>(self: Stream<A, E, R>) => Stream<{ [K in N | keyof A]: K extends keyof A ? A[K] : B; }, E2 | E, R2 | R>; <A, E, R, N extends string, B, E2, R2>(self: Stream<A, E, R>, tag: Exclude<N, keyof A>, f: (_: NoInfer<A>) => Stream<B, E2, R2>, options?: { readonly concurrency?: number | \"unbounded\" | undefined; readonly bufferSize?: number | undefined; } | undefined): Stream<{ [K in N | keyof A]: K extends keyof A ? A[K] : B; }, E | E2, R | R2>; }\n```\n\n----------------------------------------\n\nTITLE: Creating a Data Source with RequestResolver.makeWithEntry in TypeScript\nDESCRIPTION: Function that constructs a data source with a specified identifier and method to run requests. It takes a runAll function that processes arrays of request entries and returns a RequestResolver instance.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/RequestResolver-makeWithEntry.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const makeWithEntry: <A, R>(runAll: (requests: Array<Array<Request.Entry<A>>>) => Effect.Effect<void, never, R>) => RequestResolver<A, R>\n```\n\n----------------------------------------\n\nTITLE: TArray findLastSTM Signature (TypeScript)\nDESCRIPTION: Defines the signature of the `findLastSTM` function. It finds the last element in a transactional array (`TArray`) that matches a provided transactional predicate, returning an `STM` computation that yields an `Option` containing the found element, or `None` if no element matches.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TArray-findLastSTM.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const findLastSTM: { <A, R, E>(predicate: (value: A) => STM.STM<boolean, E, R>): (self: TArray<A>) => STM.STM<Option.Option<A>, E, R>; <A, R, E>(self: TArray<A>, predicate: (value: A) => STM.STM<boolean, E, R>): STM.STM<Option.Option<A>, E, R>; }\n```\n\n----------------------------------------\n\nTITLE: Using constUndefined Function in TypeScript\nDESCRIPTION: Demonstrates the usage of constUndefined function which always returns undefined when called. This is a utility function that can be used as a thunk in functional programming patterns.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Function-constUndefined.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { constUndefined } from \"effect/Function\"\n\nassert.deepStrictEqual(constUndefined(), undefined)\n```\n\n----------------------------------------\n\nTITLE: Publishing Message to PubSub in TypeScript\nDESCRIPTION: The `publish` function allows for sending messages to a `PubSub` instance, returning an `Effect` that resolves to a boolean indicating success. This feature is defined for type `A` and can be used in two configurations: where the message value is curried or passed directly. The function is part of the Effect framework and relies on the `Effect` type for asynchronous operations. Input includes the message value and the `PubSub` instance, while output is a boolean indicating if the message was successfully published.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/PubSub-publish.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const publish: { <A>(value: A): (self: PubSub<A>) => Effect.Effect<boolean>; <A>(self: PubSub<A>, value: A): Effect.Effect<boolean>; }\n```\n\n----------------------------------------\n\nTITLE: Defining a MessagePack RPC Serialization Layer in TypeScript\nDESCRIPTION: Declares a Layer that provides RpcSerialization using MessagePack. This implementation offers a more compact binary format than JSON and NDJSON with better binary data support.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/RpcSerialization-layerMsgPack.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const layerMsgPack: Layer.Layer<RpcSerialization, never, never>\n```\n\n----------------------------------------\n\nTITLE: Prepending Elements to Array in TypeScript using Effect Library\nDESCRIPTION: Demonstrates how to prepend an element to the front of an Iterable to create a new NonEmptyArray. The function accepts both single argument and curried versions for flexible usage.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Array-prepend.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Array } from \"effect\"\n\nconst result = Array.prepend([2, 3, 4], 1)\nconsole.log(result) // [1, 2, 3, 4]\n```\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const prepend: { <B>(head: B): <A>(self: Iterable<A>) => NonEmptyArray<A | B>; <A, B>(self: Iterable<A>, head: B): NonEmptyArray<A | B>; }\n```\n\n----------------------------------------\n\nTITLE: Converting Record to Key-Value Array in TypeScript using Effect-TS\nDESCRIPTION: Demonstrates how to use Array.fromRecord to transform a record/object into an array of key-value tuple pairs. The function takes a readonly record with string keys and returns an array where each element is a tuple containing the key and its corresponding value.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Array-fromRecord.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Array } from \"effect\"\n\nconst result = Array.fromRecord({ a: 1, b: 2, c: 3 })\nconsole.log(result) // [[\"a\", 1], [\"b\", 2], [\"c\", 3]]\n```\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const fromRecord: <K extends string, A>(self: Readonly<Record<K, A>>) => Array<[K, A]>\n```\n\n----------------------------------------\n\nTITLE: Partitioning HashSet Elements with a Predicate in TypeScript\nDESCRIPTION: Demonstrates how to split a HashSet into two separate sets based on a predicate function that checks if numbers are even. Shows three different syntax approaches: pipeable (data-last), method chaining, and data-first API styles.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/HashSet-partition.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// Syntax with Predicate\nimport { HashSet, pipe, Predicate } from \"effect\"\n\n// with `data-last`, a.k.a. `pipeable` API\npipe(\n  HashSet.make(0, 1, 2, 3, 4, 5),\n  HashSet.partition((n) => n % 2 === 0)\n)\n\n// or with the pipe method\nHashSet.make(0, 1, 2, 3, 4, 5).pipe(\n  HashSet.partition((n) => n % 2 === 0)\n)\n\n// or with `data-first` API\nHashSet.partition(HashSet.make(0, 1, 2, 3, 4, 5), (n) => n % 2 === 0)\n```\n\n----------------------------------------\n\nTITLE: Implementing Fiber.match Function in TypeScript\nDESCRIPTION: The `match` function provides pattern matching for Fiber types, accepting handlers for both regular Fiber and RuntimeFiber variants. It returns a function that applies the appropriate handler based on the fiber type, or can be used with curried application.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Fiber-match.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const match: { <A, E, Z>(options: { readonly onFiber: (fiber: Fiber<A, E>) => Z; readonly onRuntimeFiber: (fiber: RuntimeFiber<A, E>) => Z; }): (self: Fiber<A, E>) => Z; <A, E, Z>(self: Fiber<A, E>, options: { readonly onFiber: (fiber: Fiber<A, E>) => Z; readonly onRuntimeFiber: (fiber: RuntimeFiber<A, E>) => Z; }): Z; }\n```\n\n----------------------------------------\n\nTITLE: Boolean SemigroupEqv Example\nDESCRIPTION: This code snippet demonstrates how to use the `SemigroupEqv` from `@effect/typeclass/data/Boolean` to combine boolean values. The `combine` method is used to perform the equivalence operation on two boolean inputs, returning a boolean result based on whether the inputs are equivalent.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/data-Boolean-SemigroupEqv.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nimport { SemigroupEqv } from \"@effect/typeclass/data/Boolean\"\n\nconsole.log(SemigroupEqv.combine(true, true))\n// true\nconsole.log(SemigroupEqv.combine(true, false))\n// false\nconsole.log(SemigroupEqv.combine(false, true))\n// false\nconsole.log(SemigroupEqv.combine(false, false))\n// true\n```\n```\n\n----------------------------------------\n\nTITLE: Implementing takeAll Function for Transactional Queue in TypeScript\nDESCRIPTION: The takeAll function takes all values from a transactional queue (TDequeue) and returns them as an array. If the queue is empty, it returns an empty array. This function operates within the STM (Software Transactional Memory) context.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TQueue-takeAll.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const takeAll: <A>(self: TDequeue<A>) => STM.STM<Array<A>>\n```\n\n----------------------------------------\n\nTITLE: Converting Effect Stream to ReadableStream with Runtime Configuration\nDESCRIPTION: Function signature for converting a Stream to a ReadableStream using a provided runtime. Supports optional queuing strategy configuration and handles generic types for stream elements, errors, and runtime requirements.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-toReadableStreamRuntime.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const toReadableStreamRuntime: { <A, XR>(runtime: Runtime<XR>, options?: { readonly strategy?: QueuingStrategy<A> | undefined; }): <E, R extends XR>(self: Stream<A, E, R>) => ReadableStream<A>; <A, E, XR, R extends XR>(self: Stream<A, E, R>, runtime: Runtime<XR>, options?: { readonly strategy?: QueuingStrategy<A> | undefined; }): ReadableStream<A>; }\n```\n\n----------------------------------------\n\nTITLE: Catching All Causes in Micro Effects - TypeScript\nDESCRIPTION: The 'catchAllCause' function in the Micro module allows users to handle all types of MicroCause exceptions. It takes a function that defines how to handle the cause and returns a modified Micro effect that can handle both the original and new outcomes. This function supports generic types, making it versatile for various effect types and causes.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Micro-catchAllCause.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const catchAllCause: { <E, B, E2, R2>(f: (cause: NoInfer<MicroCause<E>>) => Micro<B, E2, R2>): <A, R>(self: Micro<A, E, R>) => Micro<A | B, E2, R | R2>; <A, E, R, B, E2, R2>(self: Micro<A, E, R>, f: (cause: NoInfer<MicroCause<E>>) => Micro<B, E2, R2>): Micro<A | B, E2, R | R2>; }\n```\n\n----------------------------------------\n\nTITLE: Defining collectAllToMap Sink Function in TypeScript\nDESCRIPTION: Declares a sink that collects inputs into a HashMap. Takes a key extraction function and merge function to handle duplicate keys. Returns a Sink that produces a HashMap mapping keys of type K to values of type In.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Sink-collectAllToMap.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const collectAllToMap: <In, K>(key: (input: In) => K, merge: (x: In, y: In) => In) => Sink<HashMap.HashMap<K, In>, In>\n```\n\n----------------------------------------\n\nTITLE: Finding First Element in Stream using TypeScript\nDESCRIPTION: The 'find' method allows users to locate the first element emitted by a stream that meets a given predicate or refinement. This function requires TypeScript generics to specify the types of elements being streamed and the expected output after applying the predicate. The signature illustrates multiple overloads, allowing for flexibility in usage.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-find.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const find: { <A, B extends A>(refinement: Refinement<NoInfer<A>, B>): <E, R>(self: Stream<A, E, R>) => Stream<B, E, R>; <A>(predicate: Predicate<NoInfer<A>>): <E, R>(self: Stream<A, E, R>) => Stream<A, E, R>; <A, E, R, B extends A>(self: Stream<A, E, R>, refinement: Refinement<A, B>): Stream<B, E, R>; <A, E, R>(self: Stream<A, E, R>, predicate: Predicate<A>): Stream<A, E, R>; }\n```\n\n----------------------------------------\n\nTITLE: Using BigInt.min Function Example\nDESCRIPTION: Demonstrates how to use the min function to compare two bigint values and return the smaller one.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/BigInt-min.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { min } from \"effect/BigInt\"\n\nassert.deepStrictEqual(min(2n, 3n), 2n)\n```\n\n----------------------------------------\n\nTITLE: Using DateTime.getPartUtc in TypeScript\nDESCRIPTION: Demonstrates how to extract a specific part (year in this example) from a DateTime object in UTC timezone. The example creates a DateTime instance and retrieves its year component.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/DateTime-getPartUtc.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { DateTime } from \"effect\"\n\nconst now = DateTime.unsafeMake({ year: 2024 })\nconst year = DateTime.getPartUtc(now, \"year\")\nassert.strictEqual(year, 2024)\n```\n\n----------------------------------------\n\nTITLE: Grouping Equal Consecutive Elements in Arrays using Effect Array.group\nDESCRIPTION: Demonstrates how to use the Array.group function to group equal consecutive elements in a non-empty array into sub-arrays. The function returns a non-empty array of non-empty arrays where each sub-array contains equal consecutive elements from the original array.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Array-group.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Array } from \"effect\"\n\nconst result = Array.group([1, 1, 2, 2, 2, 3, 1])\nconsole.log(result) // [[1, 1], [2, 2, 2], [3], [1]]\n```\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const group: <A>(self: NonEmptyReadonlyArray<A>) => NonEmptyArray<NonEmptyArray<A>>\n```\n\n----------------------------------------\n\nTITLE: Accessing Stream Context with Effect - TypeScript\nDESCRIPTION: The contextWithEffect function allows users to access the context of a stream using an effect. It takes a function as an argument, which provides the necessary environment context and returns a stream that incorporates the effect. This is essential for composing and running asynchronous operations within a functional programming paradigm in TypeScript.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-contextWithEffect.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const contextWithEffect: <R0, A, E, R>(f: (env: Context.Context<R0>) => Effect.Effect<A, E, R>) => Stream<A, E, R0 | R>\n```\n\n----------------------------------------\n\nTITLE: Declaring Tagged Test Annotation in TypeScript\nDESCRIPTION: Defines a constant 'tagged' of type TestAnnotation that uses a HashSet of strings to tag tests. This annotation allows for categorizing and organizing tests with string labels.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TestAnnotation-tagged.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const tagged: TestAnnotation<HashSet.HashSet<string>>\n```\n\n----------------------------------------\n\nTITLE: Channel mergeOut Function Type Definition\nDESCRIPTION: Type definition for the mergeOut function that merges a number of channels emitted by a channel using back pressuring merge strategy. The function takes a number parameter and returns a new channel that combines multiple input channels while handling errors and back pressure.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Channel-mergeOut.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const mergeOut: { (n: number): <OutElem1, InElem1, OutErr1, InErr1, Z, InDone1, Env1, InElem, OutErr, InErr, OutDone, InDone, Env>(self: Channel<Channel<OutElem1, InElem1, OutErr1, InErr1, Z, InDone1, Env1>, InElem, OutErr, InErr, OutDone, InDone, Env>) => Channel<OutElem1, InElem & InElem1, OutErr1 | OutErr, InErr & InErr1, unknown, InDone & InDone1, Env1 | Env>; <OutElem1, InElem1, OutErr1, InErr1, Z, InDone1, Env1, InElem, OutErr, InErr, OutDone, InDone, Env>(self: Channel<Channel<OutElem1, InElem1, OutErr1, InErr1, Z, InDone1, Env1>, InElem, OutErr, InErr, OutDone, InDone, Env>, n: number): Channel<OutElem1, InElem & InElem1, OutErr1 | OutErr, InErr & InErr1, unknown, InDone & InDone1, Env1 | Env>; }\n```\n\n----------------------------------------\n\nTITLE: Adding Time Units to DateTime Objects in TypeScript\nDESCRIPTION: Demonstrates how to add time units to a DateTime object using the add function. This example shows adding 5 minutes to a DateTime object initialized at Unix epoch (0). The function handles time zone considerations when adding days, weeks, months, and years.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/DateTime-add.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { DateTime } from \"effect\"\n\n// add 5 minutes\nDateTime.unsafeMake(0).pipe(\n  DateTime.add({ minutes: 5 })\n)\n```\n\n----------------------------------------\n\nTITLE: Combining Brand Refinement Errors in TypeScript using Effect\nDESCRIPTION: This function takes a variable number of BrandErrors and combines them into a single BrandErrors object containing all refinement errors. It's used for error aggregation when working with branded types.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Brand-errors.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const errors: (...errors: Array<Brand.BrandErrors>) => Brand.BrandErrors\n```\n\n----------------------------------------\n\nTITLE: Creating Tagged Classes with Effect.io Data Module\nDESCRIPTION: Demonstrates how to create and use tagged classes with Effect.io's Data.TaggedClass constructor. Shows class creation, instance comparison, and tag access.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Data-TaggedClass.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { Data, Equal } from \"effect\"\n\nclass Person extends Data.TaggedClass(\"Person\")<{ readonly name: string }> {}\n\n// Creating instances of Person\nconst mike1 = new Person({ name: \"Mike\" })\nconst mike2 = new Person({ name: \"Mike\" })\nconst john = new Person({ name: \"John\" })\n\n// Checking equality\nassert.deepStrictEqual(Equal.equals(mike1, mike2), true)\nassert.deepStrictEqual(Equal.equals(mike1, john), false)\n\nassert.deepStrictEqual(mike1._tag, \"Person\")\n```\n\n----------------------------------------\n\nTITLE: HashSet Difference Operation Usage Examples in TypeScript\nDESCRIPTION: Demonstrates different ways to use the HashSet.difference operation including data-last (pipeable) API, piped with pipe function, and data-first API. The operation computes A - B between two sets with O(n) time complexity.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/HashSet-difference.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// Syntax\nimport { HashSet, pipe } from \"effect\"\n\n// with data-last, a.k.a. pipeable API\npipe(HashSet.make(1, 2, 3), HashSet.difference(HashSet.make(3, 4, 5)))\n\n// or piped with the pipe function\nHashSet.make(1, 2, 3).pipe(HashSet.difference(HashSet.make(3, 4, 5)))\n\n// or with data-first API\nHashSet.difference(HashSet.make(1, 2, 3), HashSet.make(3, 4, 5))\n```\n\n----------------------------------------\n\nTITLE: Declaring tagMetrics Function in TypeScript\nDESCRIPTION: This code snippet declares the tagMetrics function with multiple overloads. It allows tagging metrics in an effect with either a single key-value pair or multiple key-value pairs. The function can be used in various ways to apply tags to all metrics generated within an effect's scope.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-tagMetrics.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const tagMetrics: {\n  (key: string, value: string): <A, E, R>(effect: Effect<A, E, R>) => Effect<A, E, R>;\n  (values: Record<string, string>): <A, E, R>(effect: Effect<A, E, R>) => Effect<A, E, R>;\n  <A, E, R>(effect: Effect<A, E, R>, key: string, value: string): Effect<A, E, R>;\n  <A, E, R>(effect: Effect<A, E, R>, values: Record<string, string>): Effect<A, E, R>;\n}\n```\n\n----------------------------------------\n\nTITLE: Using Schema.NonEmptyTrimmedString for String Validation in TypeScript\nDESCRIPTION: This example demonstrates how to use Schema.NonEmptyTrimmedString to validate strings. It shows different scenarios including an empty string, a string with whitespace, and a valid non-empty trimmed string.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Schema-NonEmptyTrimmedString.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Schema } from \"effect\"\n\nconsole.log(Schema.decodeOption(Schema.NonEmptyTrimmedString)(\"\")) // Option.none()\nconsole.log(Schema.decodeOption(Schema.NonEmptyTrimmedString)(\" a \")) // Option.none()\nconsole.log(Schema.decodeOption(Schema.NonEmptyTrimmedString)(\"a\")) // Option.some(\"a\")\n```\n\n----------------------------------------\n\nTITLE: Using HashSet.intersection in TypeScript with Effect Library\nDESCRIPTION: Examples showing different ways to use the HashSet.intersection function to compute the set intersection between two collections. The function returns values present in both sets with O(n) time complexity.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/HashSet-intersection.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// Syntax\nimport { HashSet, pipe } from \"effect\"\n\n// with data-last, a.k.a. pipeable API\npipe(HashSet.make(1, 2, 3), HashSet.intersection(HashSet.make(2, 3, 4)))\n\n// or piped with the pipe function\nHashSet.make(1, 2, 3).pipe(HashSet.intersection(HashSet.make(2, 3, 4)))\n\n// or with data-first API\nHashSet.intersection(HashSet.make(1, 2, 3), HashSet.make(2, 3, 4))\n```\n\n----------------------------------------\n\nTITLE: Adding Fibers to a FiberSet in Effect TypeScript\nDESCRIPTION: This function adds a fiber to a FiberSet and automatically removes it when the fiber completes. It supports an optional configuration parameter to control interruption propagation behavior between fibers in the set.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/FiberSet-add.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const add: { <A, E, XE extends E, XA extends A>(fiber: Fiber.RuntimeFiber<XA, XE>, options?: { readonly propagateInterruption?: boolean | undefined; } | undefined): (self: FiberSet<A, E>) => Effect.Effect<void>; <A, E, XE extends E, XA extends A>(self: FiberSet<A, E>, fiber: Fiber.RuntimeFiber<XA, XE>, options?: { readonly propagateInterruption?: boolean | undefined; } | undefined): Effect.Effect<void>; }\n```\n\n----------------------------------------\n\nTITLE: Filtering Input with Predicate or Refinement in TypeScript\nDESCRIPTION: This snippet declares the filterInput function which can filter input data for Sink instances based on a provided predicate or refinement function. This enhances data manipulation, allowing for better control over the input data flowing into the Sink. The function supports both refinement and predicate signature types, returning a modified Sink instance.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Sink-filterInput.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const filterInput: { <In, In1 extends In, In2 extends In1>(f: Refinement<In1, In2>): <A, L, E, R>(self: Sink<A, In, L, E, R>) => Sink<A, In2, L, E, R>; <In, In1 extends In>(f: Predicate<In1>): <A, L, E, R>(self: Sink<A, In, L, E, R>) => Sink<A, In1, L, E, R>; }\n```\n\n----------------------------------------\n\nTITLE: Using Array.dedupeAdjacent to Remove Adjacent Duplicates in TypeScript\nDESCRIPTION: This example demonstrates how to use the Array.dedupeAdjacent function to remove adjacent duplicate elements from an array. The function processes an iterable and returns a new array containing only the unique adjacent elements.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Array-dedupeAdjacent.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Array } from \"effect\"\n\nconst result = Array.dedupeAdjacent([1, 1, 2, 2, 3, 3])\nconsole.log(result) // [1, 2, 3]\n```\n\n----------------------------------------\n\nTITLE: Constructing Channel from PubSub in TypeScript\nDESCRIPTION: This function creates a Channel from a PubSub. It takes a PubSub of Either<Elem, Exit<Done, Err>> and returns a Channel with specific type parameters. The function is part of the Channel module in the effect package.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Channel-fromPubSub.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const fromPubSub: <Done, Err, Elem>(pubsub: PubSub.PubSub<Either.Either<Elem, Exit.Exit<Done, Err>>>) => Channel<Elem, unknown, Err, unknown, Done, unknown>\n```\n\n----------------------------------------\n\nTITLE: Trie.insert Function Signature in TypeScript\nDESCRIPTION: This code snippet shows the TypeScript signature for the Trie.insert function. It demonstrates the function's overloads, allowing for both curried and non-curried usage with generic value types.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Trie-insert.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const insert: { <V1>(key: string, value: V1): <V>(self: Trie<V>) => Trie<V | V1>; <V1, V>(self: Trie<V>, key: string, value: V1): Trie<V | V1>; }\n```\n\n----------------------------------------\n\nTITLE: Shutting Down Transactional Queues in Effect-TS\nDESCRIPTION: The shutdown function interrupts any fibers suspended on queue operations like offer or take. After shutdown, future calls to offer* and take* methods will be interrupted immediately.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TQueue-shutdown.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const shutdown: <A>(self: TDequeue<A> | TEnqueue<A>) => STM.STM<void>\n```\n\n----------------------------------------\n\nTITLE: Declare 'containsWith' Function Signature in TypeScript\nDESCRIPTION: This code provides the TypeScript signature for the 'containsWith' function. It defines the function as returning a higher-order function that applies an equivalence function to compare values within an Option. This declaration is part of the 'effect' library, specifically within the Option module.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Option-containsWith.md#2025-04-11_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const containsWith: <A>(isEquivalent: (self: A, that: A) => boolean) => { (a: A): (self: Option<A>) => boolean; (self: Option<A>, a: A): boolean; }\n```\n\n----------------------------------------\n\nTITLE: Effect.onInterrupt Method Signature\nDESCRIPTION: The TypeScript signature for the Effect.onInterrupt method, showing its function overloads. It accepts a cleanup function that receives a HashSet of FiberIds representing the interruptors and returns an Effect.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-onInterrupt.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const onInterrupt: { <X, R2>(cleanup: (interruptors: HashSet.HashSet<FiberId.FiberId>) => Effect<X, never, R2>): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R2 | R>; <A, E, R, X, R2>(self: Effect<A, E, R>, cleanup: (interruptors: HashSet.HashSet<FiberId.FiberId>) => Effect<X, never, R2>): Effect<A, E, R | R2>; }\n```\n\n----------------------------------------\n\nTITLE: Defining Stream filterMapEffect TypeScript Signature\nDESCRIPTION: A complex type signature for an effectful filter and map operation on streams, allowing conditional transformation of stream elements with potential side effects\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-filterMapEffect.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const filterMapEffect: { <A, A2, E2, R2>(pf: (a: A) => Option.Option<Effect.Effect<A2, E2, R2>>): <E, R>(self: Stream<A, E, R>) => Stream<A2, E2 | E, R2 | R>; <A, E, R, A2, E2, R2>(self: Stream<A, E, R>, pf: (a: A) => Option.Option<Effect.Effect<A2, E2, R2>>): Stream<A2, E | E2, R | R2>; }\n```\n\n----------------------------------------\n\nTITLE: Emitting Unique Elements with Effect in TypeScript\nDESCRIPTION: The `changesWithEffect` function creates a new stream that emits elements only when they differ from the previously emitted one. It uses a provided effectual function to compare two elements. The function takes two parameters: `f`, which is the effectual comparator function, and `self`, which is the stream to operate on. It outputs a stream with the same element type but may have different effect and resource requirements. This functionality is available since version 2.0.0.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-changesWithEffect.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const changesWithEffect: { <A, E2, R2>(f: (x: A, y: A) => Effect.Effect<boolean, E2, R2>): <E, R>(self: Stream<A, E, R>) => Stream<A, E2 | E, R2 | R>; <A, E, R, E2, R2>(self: Stream<A, E, R>, f: (x: A, y: A) => Effect.Effect<boolean, E2, R2>): Stream<A, E | E2, R | R2>; }\n```\n\n----------------------------------------\n\nTITLE: Initializing DotEnv ConfigProvider Layer in TypeScript\nDESCRIPTION: Creates a Layer that loads environment configuration from a specified .env file path, integrated with the Effect platform's FileSystem and ConfigProvider\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/PlatformConfigProvider-layerDotEnv.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const layerDotEnv: (path: string) => Layer.Layer<never, PlatformError, FileSystem.FileSystem>\n```\n\n----------------------------------------\n\nTITLE: Effect.repeat Function Signature in TypeScript\nDESCRIPTION: TypeScript type signature for the Effect.repeat function showing its polymorphic nature and support for various options and schedule configurations.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-repeat.md#2025-04-11_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const repeat: { <O extends NoExcessProperties<Repeat.Options<A>, O>, A>(options: O): <E, R>(self: Effect<A, E, R>) => Repeat.Return<R, E, A, O>; <B, A, R1>(schedule: Schedule.Schedule<B, A, R1>): <E, R>(self: Effect<A, E, R>) => Effect<B, E, R1 | R>; <A, E, R, O extends NoExcessProperties<Repeat.Options<A>, O>>(self: Effect<A, E, R>, options: O): Repeat.Return<R, E, A, O>; <A, E, R, B, R1>(self: Effect<A, E, R>, schedule: Schedule.Schedule<B, A, R1>): Effect<B, E, R | R1>; }\n```\n\n----------------------------------------\n\nTITLE: Providing Service with STM in TypeScript\nDESCRIPTION: The provideService function enables an effect to obtain a single service it requires for its operation. This function aids in managing dependencies in a transactional context within the STM framework. It supports generics to accommodate various types and ensures correct typings while providing the necessary resource.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/STM-provideService.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const provideService: { <I, S>(tag: Context.Tag<I, S>, resource: NoInfer<S>): <A, E, R>(self: STM<A, E, R>) => STM<A, E, Exclude<R, I>>; <A, E, R, I, S>(self: STM<A, E, R>, tag: Context.Tag<I, S>, resource: NoInfer<S>): STM<A, E, Exclude<R, I>>; }\n```\n\n----------------------------------------\n\nTITLE: Implementing Stream.aggregate Method in TypeScript\nDESCRIPTION: Defines the signature for the `aggregate` method in the Stream module, which processes stream elements using a provided sink. This method creates two asynchronous execution islands to efficiently handle element processing when downstream operators are busy.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-aggregate.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const aggregate: { <B, A, A2, E2, R2>(sink: Sink.Sink<B, A | A2, A2, E2, R2>): <E, R>(self: Stream<A, E, R>) => Stream<B, E2 | E, R2 | R>; <A, E, R, B, A2, E2, R2>(self: Stream<A, E, R>, sink: Sink.Sink<B, A | A2, A2, E2, R2>): Stream<B, E | E2, R | R2>; }\n```\n\n----------------------------------------\n\nTITLE: Effect.once Type Definition in TypeScript\nDESCRIPTION: Type signature for the Effect.once function showing its generic type parameters and return type. Takes an Effect with generic type parameters A, E, R and returns an Effect that produces an Effect of void.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-once.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const once: <A, E, R>(self: Effect<A, E, R>) => Effect<Effect<void, E, R>>\n```\n\n----------------------------------------\n\nTITLE: Defining Command Input Type in TypeScript\nDESCRIPTION: Type definition for configuring the pipe established between parent and child processes' stdin stream in the Effect-TS platform library.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Command-Command.Input.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ntype Input = CommandInput\n```\n\n----------------------------------------\n\nTITLE: Converting Stream to Channel in TypeScript using Effect-TS\nDESCRIPTION: Function that transforms a Stream into a Channel. The resulting Channel produces chunks of the stream's elements while preserving error handling and resource management capabilities.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-toChannel.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const toChannel: <A, E, R>(stream: Stream<A, E, R>) => Channel.Channel<Chunk.Chunk<A>, unknown, E, unknown, unknown, unknown, R>\n```\n\n----------------------------------------\n\nTITLE: Converting HttpApi to OpenAPI Specification in TypeScript\nDESCRIPTION: The code snippet demonstrates how to use the function to transform an HttpApi instance into an OpenAPI 3.1.0 Specification. It exemplifies adding HTTP groups and endpoints before converting to a specification object. The function supports options like handling additional properties.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/OpenApi-fromApi.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { HttpApi, HttpApiEndpoint, HttpApiGroup, OpenApi } from \"@effect/platform\"\nimport { Schema } from \"effect\"\n\nconst api = HttpApi.make(\"api\").add(\n  HttpApiGroup.make(\"group\").add(\n    HttpApiEndpoint.get(\"get\", \"/items\")\n      .addSuccess(Schema.Array(Schema.String))\n  )\n)\n\nconst spec = OpenApi.fromApi(api)\n\nconsole.log(JSON.stringify(spec, null, 2))\n// Output: OpenAPI specification in JSON format\n```\n\n----------------------------------------\n\nTITLE: Effect.allWith Type Definition in TypeScript\nDESCRIPTION: Type declaration for the allWith function showing its signature with options for concurrency, batching, discard mode, and concurrent finalizers.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-allWith.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const allWith: <O extends NoExcessProperties<{ readonly concurrency?: Concurrency | undefined; readonly batching?: boolean | \"inherit\" | undefined; readonly discard?: boolean | undefined; readonly mode?: \"default\" | \"validate\" | \"either\" | undefined; readonly concurrentFinalizers?: boolean | undefined; }, O>>(options?: O) => <const Arg extends Iterable<Effect<any, any, any>> | Record<string, Effect<any, any, any>>>(arg: Arg) => All.Return<Arg, O>\n```\n\n----------------------------------------\n\nTITLE: TypeScript Type Signature for Effect.provideService\nDESCRIPTION: The type declaration for the provideService function, showing its function overloads. It demonstrates the polymorphic nature of the function, supporting both curried and uncurried calling styles.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-provideService.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const provideService: { <I, S>(tag: Context.Tag<I, S>, service: NoInfer<S>): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, Exclude<R, I>>; <A, E, R, I, S>(self: Effect<A, E, R>, tag: Context.Tag<I, S>, service: NoInfer<S>): Effect<A, E, Exclude<R, I>>; }\n```\n\n----------------------------------------\n\nTITLE: Using fillBreak for Pretty Printing in TypeScript\nDESCRIPTION: Demonstrates using the fillBreak combinator to create formatted signature documentation with aligned text and proper spacing. The example shows how to format function signatures with names and types using fillBreak to maintain consistent width and alignment.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Doc-fillBreak.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport * as Doc from \"@effect/printer/Doc\"\nimport { pipe } from \"effect/Function\"\nimport * as String from \"effect/String\"\n\ntype Signature = [name: string, type: string]\n\nconst signatures: Array<Signature> = [\n  [\"empty\", \"Doc\"],\n  [\"nest\", \"Int -> Doc -> Doc\"],\n  [\"fillSep\", \"[Doc] -> Doc\"]\n]\n\nconst prettySignature = <A>([name, type]: Signature): Doc.Doc<A> =>\n  Doc.hsep([\n    pipe(Doc.text(name), Doc.fillBreak(5)),\n    Doc.text(\"::\"),\n    Doc.text(type)\n  ])\n\nconst doc = Doc.hsep([\n  Doc.text(\"let\"),\n  Doc.align(Doc.vcat(signatures.map(prettySignature)))\n])\n```\n\n----------------------------------------\n\nTITLE: TypeScript Type Definition for Array.unzip Function\nDESCRIPTION: The type signature for the Array.unzip function, showing its generic type constraints. It handles both empty and non-empty arrays, preserving type information for both cases.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Array-unzip.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const unzip: <S extends Iterable<readonly [any, any]>>(self: S) => S extends NonEmptyReadonlyArray<readonly [infer A, infer B]> ? [NonEmptyArray<A>, NonEmptyArray<B>] : S extends Iterable<readonly [infer A, infer B]> ? [Array<A>, Array<B>] : never\n```\n\n----------------------------------------\n\nTITLE: Retrieving value from TMap using STM in Typescript\nDESCRIPTION: The `get` function retrieves a value from a `TMap` associated with a given key, wrapped in an `Option`. The operation is performed transactionally using STM. The function signature indicates that it can be called with the key first or the TMap first.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TMap-get.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const get: { <K>(key: K): <V>(self: TMap<K, V>) => STM.STM<Option.Option<V>>; <K, V>(self: TMap<K, V>, key: K): STM.STM<Option.Option<V>>; }\n```\n\n----------------------------------------\n\nTITLE: Finding First Index with Predicate in TypeScript Array\nDESCRIPTION: Demonstrates how to use the Array.findFirstIndex function to locate the index of the first element that satisfies a given predicate. The function returns an Option type containing the index if found.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Array-findFirstIndex.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Array } from \"effect\"\n\nconst result = Array.findFirstIndex([5, 3, 8, 9], x => x > 5)\nconsole.log(result) // Option.some(2)\n```\n\n----------------------------------------\n\nTITLE: Implementing Chunk.drop Function in TypeScript\nDESCRIPTION: Function declaration for dropping the first n elements from a Chunk data structure. It supports both curried and uncurried calling styles, allowing for flexible usage patterns.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Chunk-drop.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const drop: { (n: number): <A>(self: Chunk<A>) => Chunk<A>; <A>(self: Chunk<A>, n: number): Chunk<A>; }\n```\n\n----------------------------------------\n\nTITLE: Subscribing to PubSub in Effect TypeScript\nDESCRIPTION: Creates a subscription to a PubSub instance that allows repeated message retrieval within a scoped context. The method returns an Effect that provides a dequeue for consuming messages.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/PubSub-subscribe.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const subscribe: <A>(self: PubSub<A>) => Effect.Effect<Queue.Dequeue<A>, never, Scope.Scope>\n```\n\n----------------------------------------\n\nTITLE: Implementing a Sink that takes a specified number of values in TypeScript\nDESCRIPTION: Defines a function called take that creates a sink which collects a specified number of input values into a Chunk. This is useful for limiting the number of elements processed from a stream.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Sink-take.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const take: <In>(n: number) => Sink<Chunk.Chunk<In>, In, In>\n```\n\n----------------------------------------\n\nTITLE: Subtracting Duration from DateTime in TypeScript using Effect-TS\nDESCRIPTION: Demonstrates how to use DateTime.subtractDuration to subtract a duration (5 minutes) from a DateTime object. The example creates a DateTime at unix epoch and then subtracts 5 minutes from it.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/DateTime-subtractDuration.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { DateTime } from \"effect\"\n\n// subtract 5 minutes\nDateTime.unsafeMake(0).pipe(\n  DateTime.subtractDuration(\"5 minutes\")\n)\n```\n\n----------------------------------------\n\nTITLE: Lifting Option into STM with Effect TS\nDESCRIPTION: The `fromOption` function takes an `Option` as input and returns an `STM`. This allows you to work with optional values within an STM transaction. If the option is `Some(value)`, the STM will succeed with `value`; if the option is `None`, the STM will fail with `Option.Option<never>`. Note that the STM will fail with the `None` case.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/STM-fromOption.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const fromOption: <A>(option: Option.Option<A>) => STM<A, Option.Option<never>>\n```\n\n----------------------------------------\n\nTITLE: Running Effectful Folds on Stream in TypeScript\nDESCRIPTION: The `runFoldWhileEffect` function facilitates the execution of an effectful fold over a stream. It enables early termination of the fold when a specified condition is no longer met. Dependencies include the `Stream` and `Effect` modules. Parameters include the initial state `s`, a continuation predicate `cont`, and a folding function `f` which processes the stream's elements. The function outputs an effect type capturing the fold's result, constrained to scenarios where the condition holds true.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-runFoldWhileEffect.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const runFoldWhileEffect: { <S, A, E2, R2>(s: S, cont: Predicate<S>, f: (s: S, a: A) => Effect.Effect<S, E2, R2>): <E, R>(self: Stream<A, E, R>) => Effect.Effect<S, E2 | E, Exclude<R | R2, Scope.Scope>>; <A, E, R, S, E2, R2>(self: Stream<A, E, R>, s: S, cont: Predicate<S>, f: (s: S, a: A) => Effect.Effect<S, E2, R2>): Effect.Effect<S, E | E2, Exclude<R | R2, Scope.Scope>>; }\n```\n\n----------------------------------------\n\nTITLE: Effect.delay TypeScript Function Signature\nDESCRIPTION: The TypeScript type signature for the Effect.delay function, showing its two overloaded variants - one that takes the duration first followed by the effect, and another that takes the effect first followed by the duration.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-delay.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const delay: { (duration: Duration.DurationInput): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R>; <A, E, R>(self: Effect<A, E, R>, duration: Duration.DurationInput): Effect<A, E, R>; }\n```\n\n----------------------------------------\n\nTITLE: Using Schema.Struct.Field for Custom Struct Constraints in TypeScript\nDESCRIPTION: This snippet demonstrates how to use Schema.Struct.Field to create a type for adding custom constraints to struct fields. It includes a function that takes a Schema.Struct with specific field requirements and omits one of the fields.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Schema-Struct.Field.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Schema } from \"effect\"\n\nconst f = <Fields extends Record<\"a\" | \"b\", Schema.Struct.Field>>(\n  schema: Schema.Struct<Fields>\n) => {\n  return schema.omit(\"a\")\n}\n\n//      ┌─── Schema.Struct<{ b: typeof Schema.Number; }>\n//      ▼\nconst result = f(Schema.Struct({ a: Schema.String, b: Schema.Number }))\n```\n\n----------------------------------------\n\nTITLE: Parsing String to Number with Effect-TS\nDESCRIPTION: The `parse` function takes a string as input and attempts to return an optional number value. It handles special string representations for numerical values and returns an `Option<number>`, where 'None' indicates an invalid string that could not be parsed into a number.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Number-parse.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const parse: (s: string) => Option<number>\n```\n\n----------------------------------------\n\nTITLE: Retrieving and Using Random Service in Effect (TypeScript)\nDESCRIPTION: The randomWith function retrieves the Random service from the context and uses it to run a specified workflow. It takes a function that accepts a Random service and returns an Effect, then executes that effect with the provided Random service.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Random-randomWith.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const randomWith: <A, E, R>(f: (random: Random) => Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>\n```\n\n----------------------------------------\n\nTITLE: Testing for Undefined Values in TypeScript\nDESCRIPTION: This example demonstrates how to use the isUndefined function from the Predicate module to test if a value is undefined. It shows true for undefined and false for other values.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Predicate-isUndefined.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { isUndefined } from \"effect/Predicate\"\n\nassert.deepStrictEqual(isUndefined(undefined), true)\n\nassert.deepStrictEqual(isUndefined(null), false)\nassert.deepStrictEqual(isUndefined(\"undefined\"), false)\n```\n\n----------------------------------------\n\nTITLE: Using BigInt.gcd to Find Greatest Common Divisor in TypeScript\nDESCRIPTION: This example demonstrates how to use the gcd function from the BigInt module to find the greatest common divisor of two bigint values. The function accepts two bigint parameters and returns a bigint representing their GCD.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/BigInt-gcd.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { gcd } from \"effect/BigInt\"\n\nassert.deepStrictEqual(gcd(2n, 3n), 1n)\nassert.deepStrictEqual(gcd(2n, 4n), 2n)\nassert.deepStrictEqual(gcd(16n, 24n), 8n)\n```\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const gcd: { (that: bigint): (self: bigint) => bigint; (self: bigint, that: bigint): bigint; }\n```\n\n----------------------------------------\n\nTITLE: Creating a Handler for a Single HTTP Endpoint in TypeScript\nDESCRIPTION: Creates a `Handler` for a single endpoint in an HTTP API. This function takes an API definition, group name, endpoint name, and handler function to create a properly typed handler for the specified endpoint.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/HttpApiBuilder-handler.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const handler: <ApiId extends string, Groups extends HttpApiGroup.HttpApiGroup.Any, ApiError, ApiR, const GroupName extends Groups[\"identifier\"], const Name extends HttpApiGroup.HttpApiGroup.EndpointsWithName<Groups, GroupName>[\"name\"], R>(_api: HttpApi.HttpApi<ApiId, Groups, ApiError, ApiR>, _groupName: GroupName, _name: Name, f: HttpApiEndpoint.HttpApiEndpoint.HandlerWithName<HttpApiGroup.HttpApiGroup.EndpointsWithName<Groups, GroupName>, Name, ApiError | HttpApiGroup.HttpApiGroup.ErrorWithName<Groups, GroupName>, R>) => HttpApiEndpoint.HttpApiEndpoint.HandlerWithName<HttpApiGroup.HttpApiGroup.EndpointsWithName<Groups, GroupName>, Name, ApiError | HttpApiGroup.HttpApiGroup.ErrorWithName<Groups, GroupName>, R>\n```\n\n----------------------------------------\n\nTITLE: Handling Stream Errors with catchSome in TypeScript\nDESCRIPTION: The catchSome function allows switching to a different stream when an error occurs, based on the provided function to handle errors. It takes a partial function that converts errors to optional alternative streams, working either with or without an initial stream argument. Required dependencies include the Option module for handling optional values.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-catchSome.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const catchSome: { <E, A2, E2, R2>(pf: (error: E) => Option.Option<Stream<A2, E2, R2>>): <A, R>(self: Stream<A, E, R>) => Stream<A2 | A, E | E2, R2 | R>; <A, E, R, A2, E2, R2>(self: Stream<A, E, R>, pf: (error: E) => Option.Option<Stream<A2, E2, R2>>): Stream<A | A2, E | E2, R | R2>; }\n```\n\n----------------------------------------\n\nTITLE: Implementing differenceWith Function for Chunk Comparison in TypeScript\nDESCRIPTION: This function creates a Chunk of values not included in another Chunk using a provided isEquivalent function. It takes an equivalence function and returns a curried function that can be applied to two Chunks. The order and references of result values are determined by the first Chunk.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Chunk-differenceWith.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const differenceWith: <A>(isEquivalent: (self: A, that: A) => boolean) => { (that: Chunk<A>): (self: Chunk<A>) => Chunk<A>; (self: Chunk<A>, that: Chunk<A>): Chunk<A>; }\n```\n\n----------------------------------------\n\nTITLE: Grouping Consecutive Elements in TypeScript Iterable\nDESCRIPTION: This function, group, takes an Iterable of type A and returns an Iterable of NonEmptyArrays of type A. It groups equal, consecutive elements of the input Iterable into NonEmptyArrays.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Iterable-group.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const group: <A>(self: Iterable<A>) => Iterable<NonEmptyArray<A>>\n```\n\n----------------------------------------\n\nTITLE: Running SQL Queries with Schema Validation in TypeScript\nDESCRIPTION: The `findAll` function executes SQL queries with schema validation for both request and result data. It takes options including request schema, result schema, and an execution function, then returns a function that processes the request and returns an Effect with the validated results.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/SqlSchema-findAll.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const findAll: <IR, II, IA, AR, AI, A, R, E>(options: { readonly Request: Schema.Schema<IA, II, IR>; readonly Result: Schema.Schema<A, AI, AR>; readonly execute: (request: II) => Effect.Effect<ReadonlyArray<unknown>, E, R>; }) => (request: IA) => Effect.Effect<ReadonlyArray<A>, E | ParseError, R | IR | AR>\n```\n\n----------------------------------------\n\nTITLE: Partitioning a Record using Effect-TS in TypeScript\nDESCRIPTION: This code demonstrates the usage of the 'partition' function from the 'effect/Record' module, which splits a record into two based on a predicate function. The function is useful for filtering records according to specified conditions.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Record-partition.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { partition } from \"effect/Record\"\n\nassert.deepStrictEqual(\n  partition({ a: 1, b: 3 }, (n) => n > 2),\n  [{ a: 1 }, { b: 3 }]\n)\n```\n\n----------------------------------------\n\nTITLE: Creating a Stream from document.addEventListener in TypeScript\nDESCRIPTION: The fromEventListenerDocument function creates a Stream from document.addEventListener. It takes an event type and optional configuration options as parameters, and returns a Stream of the corresponding event type.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/BrowserStream-fromEventListenerDocument.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const fromEventListenerDocument: <K extends keyof DocumentEventMap>(type: K, options?: boolean | { readonly capture?: boolean; readonly passive?: boolean; readonly once?: boolean; readonly bufferSize?: number | \"unbounded\" | undefined; } | undefined) => Stream.Stream<DocumentEventMap[K], never, never>\n```\n\n----------------------------------------\n\nTITLE: Implementing Sink Summarization in TypeScript with Effect\nDESCRIPTION: Defines a function that enhances a sink by running an effect when the sink starts and completes. The summary information is calculated by applying a function to the start and end values, and is paired with the sink's result.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Sink-summarized.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const summarized: { <A2, E2, R2, A3>(summary: Effect.Effect<A2, E2, R2>, f: (start: A2, end: A2) => A3): <A, In, L, E, R>(self: Sink<A, In, L, E, R>) => Sink<[A, A3], In, L, E2 | E, R2 | R>; <A, In, L, E, R, A2, E2, R2, A3>(self: Sink<A, In, L, E, R>, summary: Effect.Effect<A2, E2, R2>, f: (start: A2, end: A2) => A3): Sink<[A, A3], In, L, E | E2, R | R2>; }\n```\n\n----------------------------------------\n\nTITLE: Defining chunksOf Function for Grouping Elements in TypeScript\nDESCRIPTION: This code snippet defines the `chunksOf` function, which groups elements in chunks of up to `n` elements. It has two overloads: one that takes the chunk size as the first argument, and another that takes the chunk and size as separate arguments.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Chunk-chunksOf.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const chunksOf: { (n: number): <A>(self: Chunk<A>) => Chunk<Chunk<A>>; <A>(self: Chunk<A>, n: number): Chunk<Chunk<A>>; }\n```\n\n----------------------------------------\n\nTITLE: TypeScript Function Signature for Stream.interleave\nDESCRIPTION: Provides the TypeScript function signature for Stream.interleave. It shows the function's type definitions and overloads for different use cases.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-interleave.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const interleave: { <A2, E2, R2>(that: Stream<A2, E2, R2>): <A, E, R>(self: Stream<A, E, R>) => Stream<A2 | A, E2 | E, R2 | R>; <A, E, R, A2, E2, R2>(self: Stream<A, E, R>, that: Stream<A2, E2, R2>): Stream<A | A2, E | E2, R | R2>; }\n```\n\n----------------------------------------\n\nTITLE: Implementing HashMap.flatMap Function in TypeScript\nDESCRIPTION: This function chains over the entries of a HashMap using a specified transformation function. It accepts a mapping function that converts each value-key pair into a new HashMap, then combines the results. The hash and equality functions of both maps must be the same.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/HashMap-flatMap.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const flatMap: { <A, K, B>(f: (value: A, key: K) => HashMap<K, B>): (self: HashMap<K, A>) => HashMap<K, B>; <K, A, B>(self: HashMap<K, A>, f: (value: A, key: K) => HashMap<K, B>): HashMap<K, B>; }\n```\n\n----------------------------------------\n\nTITLE: Implementing Paginated Stream with Effect in TypeScript\nDESCRIPTION: Defines the paginateChunkEffect function, which creates a stream by unfolding a state and emitting chunks of values. It's designed for paginated APIs, allowing emission to end one step after state unfolding.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-paginateChunkEffect.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const paginateChunkEffect: <S, A, E, R>(s: S, f: (s: S) => Effect.Effect<readonly [Chunk.Chunk<A>, Option.Option<S>], E, R>) => Stream<A, E, R>\n```\n\n----------------------------------------\n\nTITLE: Streaming Command Output in TypeScript with @effect/platform\nDESCRIPTION: The stream function starts running a command and returns the output as a Stream of Uint8Array. It requires a Command object as input and returns a Stream that may emit PlatformErrors, with CommandExecutor as its context.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Command-stream.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const stream: (command: Command) => Stream<Uint8Array, PlatformError, CommandExecutor>\n```\n\n----------------------------------------\n\nTITLE: Using FiberMap.join in Effect-TS\nDESCRIPTION: Demonstrates how to use FiberMap.join to wait for all fibers in a map to complete. Shows error propagation when a fiber fails. The example creates a fiber map, adds a failing fiber, and joins all fibers.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/FiberMap-join.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Effect, FiberMap } from \"effect\";\n\nEffect.gen(function* (_) {\n  const map = yield* _(FiberMap.make());\n  yield* _(FiberMap.set(map, \"a\", Effect.runFork(Effect.fail(\"error\"))));\n\n  // parent fiber will fail with \"error\"\n  yield* _(FiberMap.join(map));\n});\n```\n\n----------------------------------------\n\nTITLE: Partitioning a Stream with Stream.grouped in TypeScript\nDESCRIPTION: This example demonstrates how to use Stream.grouped to partition a stream of numbers into chunks of size 3. It creates a stream of numbers from 0 to 8, groups them, and then collects and logs the result.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-grouped.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Effect, Stream } from \"effect\"\n\nconst stream = Stream.range(0, 8).pipe(Stream.grouped(3))\n\nEffect.runPromise(Stream.runCollect(stream)).then((chunks) => console.log(\"%o\", chunks))\n// {\n//   _id: 'Chunk',\n//   values: [\n//     { _id: 'Chunk', values: [ 0, 1, 2, [length]: 3 ] },\n//     { _id: 'Chunk', values: [ 3, 4, 5, [length]: 3 ] },\n//     { _id: 'Chunk', values: [ 6, 7, 8, [length]: 3 ] },\n//     [length]: 3\n//   ]\n// }\n```\n\n----------------------------------------\n\nTITLE: Creating Cron Schedule in Typescript\nDESCRIPTION: Defines a function `cron` that creates a schedule based on a cron expression. It accepts either a `Cron.Cron` object or a cron expression string with an optional timezone. The schedule produces a tuple of numbers representing the start and end timestamps of the cron window. Errors in the cron expression are detected during schedule execution.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Schedule-cron.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const cron: { (cron: Cron.Cron): Schedule<[number, number]>; (expression: string, tz?: DateTime.TimeZone | string): Schedule<[number, number]>; }\n```\n\n----------------------------------------\n\nTITLE: Effect.mapError Function Signature in TypeScript\nDESCRIPTION: The type signature for the Effect.mapError function, showing it can be used both in pipeline style and as a standalone function. It transforms an effect with error type E to one with error type E2 while preserving the success type A and environment type R.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-mapError.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const mapError: { <E, E2>(f: (e: E) => E2): <A, R>(self: Effect<A, E, R>) => Effect<A, E2, R>; <A, E, R, E2>(self: Effect<A, E, R>, f: (e: E) => E2): Effect<A, E2, R>; }\n```\n\n----------------------------------------\n\nTITLE: Partitioning HashSet Elements with a Refinement in TypeScript\nDESCRIPTION: Shows how to partition a HashSet containing mixed types (strings and numbers) using a type refinement function to separate strings from numbers. Demonstrates three different syntax approaches with the same result.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/HashSet-partition.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n// Syntax with Refinement\nimport { HashSet, pipe, Predicate } from \"effect\"\n\nconst stringRefinement: Predicate.Refinement<string | number, string> = (\n  value\n) => typeof value === \"string\"\n\n// with `data-last`, a.k.a. `pipeable` API\npipe(\n  HashSet.make(1, \"unos\", 2, \"two\", 3, \"trois\", 4, \"vier\"),\n  HashSet.partition(stringRefinement)\n)\n\n// or with the pipe method\nHashSet.make(1, \"unos\", 2, \"two\", 3, \"trois\", 4, \"vier\").pipe(\n  HashSet.partition(stringRefinement)\n)\n\n// or with `data-first` API\nHashSet.partition(\n  HashSet.make(1, \"unos\", 2, \"two\", 3, \"trois\", 4, \"vier\"),\n  stringRefinement\n)\n```\n\n----------------------------------------\n\nTITLE: Handling Async Operations with Effect.runSyncExit\nDESCRIPTION: Shows how Effect.runSyncExit handles asynchronous operations by returning a Die cause, demonstrating why it should only be used with synchronous effects.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-runSyncExit.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Effect } from \"effect\"\n\nconsole.log(Effect.runSyncExit(Effect.promise(() => Promise.resolve(1))))\n// Output:\n// {\n//   _id: 'Exit',\n//   _tag: 'Failure',\n//   cause: {\n//     _id: 'Cause',\n//     _tag: 'Die',\n//     defect: [Fiber #0 cannot be resolved synchronously. This is caused by using runSync on an effect that performs async work] {\n//       fiber: [FiberRuntime],\n//       _tag: 'AsyncFiberException',\n//       name: 'AsyncFiberException'\n//     }\n//   }\n// }\n```\n\n----------------------------------------\n\nTITLE: Implementing zipWith Function in Effect-TS Chunk Module\nDESCRIPTION: Function signature for zipWith operation that combines two chunks element-wise using a provided combiner function. It supports both curried and uncurried forms, allowing flexible usage patterns. The function takes two chunks and a combining function to produce a new chunk.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Chunk-zipWith.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const zipWith: { <A, B, C>(that: Chunk<B>, f: (a: A, b: B) => C): (self: Chunk<A>) => Chunk<C>; <A, B, C>(self: Chunk<A>, that: Chunk<B>, f: (a: A, b: B) => C): Chunk<C>; }\n```\n\n----------------------------------------\n\nTITLE: Effect.parallelErrors Function Signature in TypeScript\nDESCRIPTION: The TypeScript type signature for the parallelErrors function. It takes an Effect of type A with error E and environment R and returns an Effect of the same type A but with an array of errors E and the same environment R.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-parallelErrors.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const parallelErrors: <A, E, R>(self: Effect<A, E, R>) => Effect<A, Array<E>, R>\n```\n\n----------------------------------------\n\nTITLE: Replicating STM Transaction in Effect (TypeScript)\nDESCRIPTION: The `replicateSTMDiscard` function in the Effect library executes an STM transaction a specified number of times, discarding the results. It takes the number of repetitions `n` and the STM transaction `self` as input and returns an STM transaction that performs the replication.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/STM-replicateSTMDiscard.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const replicateSTMDiscard: { (n: number): <A, E, R>(self: STM<A, E, R>) => STM<void, E, R>; <A, E, R>(self: STM<A, E, R>, n: number): STM<void, E, R>; }\n```\n\n----------------------------------------\n\nTITLE: Interrupting a Fiber in TypeScript using Effect\nDESCRIPTION: This function interrupts the execution of a given fiber. If the fiber has already completed, it immediately returns the exit state. Otherwise, it waits for the fiber to exit and then returns its exit state.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Fiber-interrupt.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const interrupt: <A, E>(self: Fiber<A, E>) => Effect.Effect<Exit.Exit<A, E>>\n```\n\n----------------------------------------\n\nTITLE: Effect.withLogSpan Type Definition\nDESCRIPTION: Type definition showing the function signatures for withLogSpan. Supports both curried and regular function call syntax for adding log spans to effects.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-withLogSpan.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const withLogSpan: { (label: string): <A, E, R>(effect: Effect<A, E, R>) => Effect<A, E, R>; <A, E, R>(effect: Effect<A, E, R>, label: string): Effect<A, E, R>; }\n```\n\n----------------------------------------\n\nTITLE: Defining effectDiscard Function in Layer Module (TypeScript)\nDESCRIPTION: This snippet defines the effectDiscard function in the Layer module. It constructs a layer from a specified effect, discarding its output. The function takes an Effect as input and returns a Layer.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Layer-effectDiscard.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const effectDiscard: <X, E, R>(effect: Effect.Effect<X, E, R>) => Layer<never, E, R>\n```\n\n----------------------------------------\n\nTITLE: Scheduling with Stream.scheduleWith in TypeScript\nDESCRIPTION: This code snippet defines a function `scheduleWith` that allows users to schedule output emissions from a stream based on a given schedule. The function takes a `schedule` and an `options` parameter to manage how elements and schedule events are handled. It is designed for use with Effect-TS streams, allowing for fine control of scheduled stream outputs.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-scheduleWith.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const scheduleWith: { <B, A0 extends A, R2, A, C>(schedule: Schedule.Schedule<B, A0, R2>, options: { readonly onElement: (a: A) => C; readonly onSchedule: (b: B) => C; }): <E, R>(self: Stream<A, E, R>) => Stream<C, E, R2 | R>; <A, E, R, B, A0 extends A, R2, C>(self: Stream<A, E, R>, schedule: Schedule.Schedule<B, A0, R2>, options: { readonly onElement: (a: A) => C; readonly onSchedule: (b: B) => C; }): Stream<C, E, R | R2>; }\n```\n\n----------------------------------------\n\nTITLE: Defining Array.every Function in TypeScript\nDESCRIPTION: This code snippet defines the 'every' function for the Array module. It checks if a predicate holds true for every element in a ReadonlyArray. The function has overloads for both refinement and predicate functions, and can be used with method chaining or direct application.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Array-every.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const every: {\n  <A, B extends A>(refinement: (a: NoInfer<A>, i: number) => a is B): (self: ReadonlyArray<A>) => self is ReadonlyArray<B>;\n  <A>(predicate: (a: NoInfer<A>, i: number) => boolean): (self: ReadonlyArray<A>) => boolean;\n  <A, B extends A>(self: ReadonlyArray<A>, refinement: (a: A, i: number) => a is B): self is ReadonlyArray<B>;\n  <A>(self: ReadonlyArray<A>, predicate: (a: A, i: number) => boolean): boolean;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing TestClock.sleep Function in TypeScript\nDESCRIPTION: Defines a sleep function that simulates blocking the current fiber until a specified duration has passed. It's used for testing time-dependent operations by adjusting the clock time.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TestClock-sleep.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const sleep: (durationInput: Duration.DurationInput) => Effect.Effect<void>\n```\n\n----------------------------------------\n\nTITLE: Declaring awaitShutdown Function for Queue in TypeScript\nDESCRIPTION: Defines the awaitShutdown function for Dequeue or Enqueue types. This function returns an Effect that waits until the queue is shutdown. If the queue is already shutdown, the Effect resumes immediately.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Queue-awaitShutdown.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const awaitShutdown: <A>(self: Dequeue<A> | Enqueue<A>) => Effect.Effect<void>\n```\n\n----------------------------------------\n\nTITLE: Defining offerAll Function Signature in TypeScript for TQueue\nDESCRIPTION: Type signature for the offerAll function that offers multiple values from an iterable to a transactional queue (TEnqueue). The function has two overloaded versions: a curried version that takes an iterable and returns a function that takes a queue, and a non-curried version that takes a queue and an iterable directly.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TQueue-offerAll.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const offerAll: { <A>(iterable: Iterable<A>): (self: TEnqueue<A>) => STM.STM<boolean>; <A>(self: TEnqueue<A>, iterable: Iterable<A>): STM.STM<boolean>; }\n```\n\n----------------------------------------\n\nTITLE: Using Array.matchRight for Pattern Matching in TypeScript\nDESCRIPTION: Demonstrates how to use Array.matchRight to handle empty and non-empty arrays. The function takes an options object with onEmpty and onNonEmpty handlers, distinguishing between empty arrays and arrays with at least one element.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Array-matchRight.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Array } from \"effect\"\n\nconst matchRight = Array.matchRight({\n  onEmpty: () => \"empty\",\n  onNonEmpty: (init, last) => `init: ${init.length}, last: ${last}`\n})\nconsole.log(matchRight([])) // \"empty\"\nconsole.log(matchRight([1, 2, 3])) // \"init: 2, last: 3\"\n```\n\n----------------------------------------\n\nTITLE: Emitting a Sliding Window of Elements in Effect Stream using TypeScript\nDESCRIPTION: This snippet demonstrates how to use the 'Stream.sliding' method to emit a sliding window of elements. It utilizes the 'pipe' function to create a stream from a set of numbers and collects the sliding windows of size 'n'. Required dependencies include the 'effect' library. The input is a stream of numbers, and the output is a collection of chunks representing the sliding windows.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-sliding.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { pipe, Stream } from \"effect\"\n\npipe(\n  Stream.make(1, 2, 3, 4),\n  Stream.sliding(2),\n  Stream.runCollect\n)\n// => Chunk(Chunk(1, 2), Chunk(2, 3), Chunk(3, 4))\n```\n\n----------------------------------------\n\nTITLE: Using Stream.race to Combine Streams in Effect-TS\nDESCRIPTION: This example demonstrates how to use Stream.race to combine two streams, where the resulting stream mirrors the first upstream to emit an item. The example uses scheduled streams with different intervals.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-race.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Stream, Schedule, Console, Effect } from \"effect\"\n\nconst stream = Stream.fromSchedule(Schedule.spaced('2 millis')).pipe(\n  Stream.race(Stream.fromSchedule(Schedule.spaced('1 millis'))),\n  Stream.take(6),\n  Stream.tap(Console.log)\n)\n\nEffect.runPromise(Stream.runDrain(stream))\n// Output each millisecond from the first stream, the rest streams are interrupted\n// 0\n// 1\n// 2\n// 3\n// 4\n// 5\n```\n\n----------------------------------------\n\nTITLE: Implementing Error Tracking with Metric.trackErrorWith in TypeScript\nDESCRIPTION: Defines a function that creates an aspect to track errors in Effect types. The function takes a metric and an error mapping function to transform the error value before updating the metric. Supports both curried and uncurried calling styles.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Metric-trackErrorWith.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const trackErrorWith: {\n  <Type, In, Out, In2>(\n    metric: Metric<Type, In, Out>,\n    f: (error: In2) => In\n  ): <A, E extends In2, R>(\n    effect: Effect.Effect<A, E, R>\n  ) => Effect.Effect<A, E, R>;\n  <A, E extends In2, R, Type, In, Out, In2>(\n    self: Effect.Effect<A, E, R>,\n    metric: Metric<Type, In, Out>,\n    f: (error: In2) => In\n  ): Effect.Effect<A, E, R>;\n}\n```\n\n----------------------------------------\n\nTITLE: Example: Replacing Record Values with Effect Record\nDESCRIPTION: This example demonstrates how to use `Record.replace` to replace the value of a key in a record. It shows the expected behavior when the key exists and when it does not.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Record-replace.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { Record } from \"effect\"\n\nassert.deepStrictEqual(Record.replace(\"a\", 3)({ a: 1, b: 2 }), { a: 3, b: 2 });\nassert.deepStrictEqual(Record.replace(\"c\", 3)({ a: 1, b: 2 }), { a: 1, b: 2 });\n```\n\n----------------------------------------\n\nTITLE: Defining Request Entry Interface in TypeScript\nDESCRIPTION: Defines a TypeScript interface for Request.Entry that tracks requests and their results using a Deferred reference. The interface includes the original request, a deferred result, listeners, fiber ID, and completion state. It's designed to handle requests with different result types while maintaining type safety.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Request-Entry.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface Entry<out R> extends Entry.Variance<R> {\n  readonly request: R\n  readonly result: Deferred<\n    [R] extends [Request<infer _A, infer _E>] ? _A : never,\n    [R] extends [Request<infer _A, infer _E>] ? _E : never\n  >\n  readonly listeners: Listeners\n  readonly ownerId: FiberId\n  readonly state: {\n    completed: boolean\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Declaring provideContext Function in TypeScript\nDESCRIPTION: Function signature for provideContext, which eliminates a Channel's dependency on environment by providing the required context. It can be used in two forms: either passing the environment first, or passing the channel first followed by the environment.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Channel-provideContext.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const provideContext: { <Env>(env: Context.Context<Env>): <OutElem, InElem, OutErr, InErr, OutDone, InDone>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>) => Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, never>; <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>, env: Context.Context<Env>): Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, never>; }\n```\n\n----------------------------------------\n\nTITLE: Defining HTTP API Handlers Interface in TypeScript\nDESCRIPTION: Defines a TypeScript interface for HTTP API handlers with generic type parameters for error handling, context requirements, and endpoint definitions. Includes methods for handling both regular and raw responses, with proper type inference and constraints.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/HttpApiBuilder-Handlers.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface Handlers<\n  E,\n  Provides,\n  R,\n  Endpoints extends HttpApiEndpoint.HttpApiEndpoint.Any = never\n> extends Pipeable {\n  readonly [HandlersTypeId]: {\n    _Endpoints: Covariant<Endpoints>\n  }\n  readonly group: HttpApiGroup.HttpApiGroup.AnyWithProps\n  readonly handlers: Chunk.Chunk<Handlers.Item<E, R>>\n\n  /**\n   * Add the implementation for an `HttpApiEndpoint` to a `Handlers` group.\n   */\n  handle<Name extends HttpApiEndpoint.HttpApiEndpoint.Name<Endpoints>, R1>(\n    name: Name,\n    handler: HttpApiEndpoint.HttpApiEndpoint.HandlerWithName<Endpoints, Name, E, R1>\n  ): Handlers<\n    E,\n    Provides,\n    | R\n    | Exclude<\n      HttpApiEndpoint.HttpApiEndpoint.ExcludeProvided<\n        Endpoints,\n        Name,\n        R1 | HttpApiEndpoint.HttpApiEndpoint.ContextWithName<Endpoints, Name>\n      >,\n      Provides\n    >,\n    HttpApiEndpoint.HttpApiEndpoint.ExcludeName<Endpoints, Name>\n  >\n\n  /**\n   * Add the implementation for an `HttpApiEndpoint` to a `Handlers` group.\n   * This version of the api allows you to return the full response object.\n   */\n  handleRaw<Name extends HttpApiEndpoint.HttpApiEndpoint.Name<Endpoints>, R1>(\n    name: Name,\n    handler: HttpApiEndpoint.HttpApiEndpoint.HandlerResponseWithName<Endpoints, Name, E, R1>\n  ): Handlers<\n    E,\n    Provides,\n    | R\n    | Exclude<\n      HttpApiEndpoint.HttpApiEndpoint.ExcludeProvided<\n        Endpoints,\n        Name,\n        R1 | HttpApiEndpoint.HttpApiEndpoint.ContextWithName<Endpoints, Name>\n      >,\n      Provides\n    >,\n    HttpApiEndpoint.HttpApiEndpoint.ExcludeName<Endpoints, Name>\n  >\n}\n```\n\n----------------------------------------\n\nTITLE: Building Layer with Scope Management in TypeScript\nDESCRIPTION: Function signature for buildWithScope operation that constructs a Layer into an Effect value with controlled resource lifecycle management. Resources are released when the specified scope closes unless explicitly extended. Supports both curried and uncurried calling patterns.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Layer-buildWithScope.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const buildWithScope: { \n  (scope: Scope.Scope): <RIn, E, ROut>(self: Layer<ROut, E, RIn>) => Effect.Effect<Context.Context<ROut>, E, RIn>; \n  <RIn, E, ROut>(self: Layer<ROut, E, RIn>, scope: Scope.Scope): Effect.Effect<Context.Context<ROut>, E, RIn>; \n}\n```\n\n----------------------------------------\n\nTITLE: Type Signature for Effect.runPromiseExit\nDESCRIPTION: The function signature for runPromiseExit showing its TypeScript type definition. It accepts an Effect and optional options including an AbortSignal, and returns a Promise resolving to an Exit object.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-runPromiseExit.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const runPromiseExit: <A, E>(effect: Effect<A, E, never>, options?: { readonly signal?: AbortSignal; } | undefined) => Promise<Exit.Exit<A, E>>\n```\n\n----------------------------------------\n\nTITLE: Recovering with catchTag in STM - TypeScript\nDESCRIPTION: The catchTag function allows for the recovery from a specified tagged error within the STM (Software Transactional Memory) module. It requires a tag (K), which is a specific string identifying the error, and a function (f) that defines how to handle the error. It handles inputs of type STM<A, E, R> and provides outputs of a combined STM<A1 | A, E1 | Exclude<E, {_tag: K;}>, R1 | R>. There are no external dependencies, but the function is primarily used within TypeScript projects that implement STM.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/STM-catchTag.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const catchTag: { <K extends E[\"_tag\"] & string, E extends { _tag: string; }, A1, E1, R1>(k: K, f: (e: Extract<E, { _tag: K; }>) => STM<A1, E1, R1>): <A, R>(self: STM<A, E, R>) => STM<A1 | A, E1 | Exclude<E, { _tag: K; }>, R1 | R>; <A, E extends { _tag: string; }, R, K extends E[\"_tag\"] & string, A1, E1, R1>(self: STM<A, E, R>, k: K, f: (e: Extract<E, { _tag: K; }>) => STM<A1, E1, R1>): STM<A | A1, E1 | Exclude<E, { _tag: K; }>, R | R1>; }\n```\n\n----------------------------------------\n\nTITLE: Joining Array Elements with Separator in TypeScript\nDESCRIPTION: Demonstrates how to use the Array.join function to concatenate array elements with a specified separator. The function takes an iterable of strings and a separator string, returning a single joined string.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Array-join.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Array } from \"effect\"\n\nconst strings = [\"a\", \"b\", \"c\"]\nconst joined = Array.join(strings, \"-\")\nconsole.log(joined) // \"a-b-c\"\n```\n\n----------------------------------------\n\nTITLE: Defining Layer.tap Function in TypeScript\nDESCRIPTION: Declares the Layer.tap function, which performs a specified effect if a layer succeeds. It accepts a function that takes a context and returns an Effect, and can be applied to a Layer.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Layer-tap.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const tap: { <ROut, XR extends ROut, RIn2, E2, X>(f: (context: Context.Context<XR>) => Effect.Effect<X, E2, RIn2>): <RIn, E>(self: Layer<ROut, E, RIn>) => Layer<ROut, E2 | E, RIn2 | RIn>; <RIn, E, ROut, XR extends ROut, RIn2, E2, X>(self: Layer<ROut, E, RIn>, f: (context: Context.Context<XR>) => Effect.Effect<X, E2, RIn2>): Layer<ROut, E | E2, RIn | RIn2>; }\n```\n\n----------------------------------------\n\nTITLE: Defining Valid Date Filter using TypeScript in Effect.ts\nDESCRIPTION: This snippet declares a constant 'validDate' that is a filter designed to accept only valid date objects in the Effect.ts schema. It enhances data integrity by preventing the processing of erroneous date values. The filter can accept optional annotations for additional constraint specifications.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Schema-validDate.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const validDate: <S extends Schema.Any>(annotations?: Annotations.Filter<Schema.Type<S>>) => <A extends Date>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>) => filter<S>\n```\n\n----------------------------------------\n\nTITLE: Defining Channel Generic Interface in TypeScript\nDESCRIPTION: Defines a generic Channel interface that supports bidirectional I/O operations with configurable types for input/output elements, errors, and completion values. The interface extends Channel.Variance and Pipeable, providing type safety and composability.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Channel-Channel.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface Channel<\n  out OutElem,\n  in InElem = unknown,\n  out OutErr = never,\n  in InErr = unknown,\n  out OutDone = void,\n  in InDone = unknown,\n  out Env = never\n> extends\n  Channel.Variance<\n    OutElem,\n    InElem,\n    OutErr,\n    InErr,\n    OutDone,\n    InDone,\n    Env\n  >,\n  Pipeable\n{\n  [Unify.typeSymbol]?: unknown\n  [Unify.unifySymbol]?: ChannelUnify<this>\n  [Unify.ignoreSymbol]?: ChannelUnifyIgnore\n}\n```\n\n----------------------------------------\n\nTITLE: Effect.mapAccum Type Definition\nDESCRIPTION: Type signature for the mapAccum function showing its polymorphic nature and support for different collection types with state transformation.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-mapAccum.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const mapAccum: { <S, A, B, E, R, I extends Iterable<A> = Iterable<A>>(initial: S, f: (state: S, a: RA.ReadonlyArray.Infer<I>, i: number) => Effect<readonly [S, B], E, R>): (elements: I) => Effect<[S, RA.ReadonlyArray.With<I, B>], E, R>; <A, S, B, E, R, I extends Iterable<A> = Iterable<A>>(elements: I, initial: S, f: (state: S, a: RA.ReadonlyArray.Infer<I>, i: number) => Effect<readonly [S, B], E, R>): Effect<[S, RA.ReadonlyArray.With<I, B>], E, R>; }\n```\n\n----------------------------------------\n\nTITLE: Implementing Error Handler for Micro Effects in TypeScript\nDESCRIPTION: Defines an overloaded function signature for handling errors in Micro effects. When a Micro effect fails, it executes a provided finalizer effect with the MicroCause of the failure. The function supports both curried and regular parameter versions.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Micro-onError.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const onError: { <A, E, XE, XR>(f: (cause: MicroCause<NoInfer<E>>) => Micro<void, XE, XR>): <R>(self: Micro<A, E, R>) => Micro<A, E | XE, R | XR>; <A, E, R, XE, XR>(self: Micro<A, E, R>, f: (cause: MicroCause<NoInfer<E>>) => Micro<void, XE, XR>): Micro<A, E | XE, R | XR>; }\n```\n\n----------------------------------------\n\nTITLE: Testing if a Value is a Symbol - Effect Library - TypeScript\nDESCRIPTION: This code snippet tests the functionality of the `isSymbol` function from the Effect library's Predicate module. It uses assertions to verify that the function correctly identifies symbols versus other types. The snippet requires the Effect library and Node's assertion module as dependencies.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Predicate-isSymbol.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { isSymbol } from \"effect/Predicate\"\n\nassert.deepStrictEqual(isSymbol(Symbol.for(\"a\")), true)\n\nassert.deepStrictEqual(isSymbol(\"a\"), false)\n```\n\n----------------------------------------\n\nTITLE: Setting Scheduling Priority in Effect Operations\nDESCRIPTION: Function signature for withSchedulingPriority that allows setting the scheduling priority used when yielding. It provides two overloads - one that takes priority first and another that takes the Effect instance first.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-withSchedulingPriority.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const withSchedulingPriority: { (priority: number): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R>; <A, E, R>(self: Effect<A, E, R>, priority: number): Effect<A, E, R>; }\n```\n\n----------------------------------------\n\nTITLE: Using Effect.annotateLogs to add metadata to log messages in TypeScript\nDESCRIPTION: This example demonstrates how to add a custom annotation ('taskId') to all log messages generated within an effect. The annotation appears alongside each log message in the output, providing additional context for better traceability.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-annotateLogs.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Effect } from \"effect\"\n\nconst program = Effect.gen(function*() {\n  yield* Effect.log(\"message1\")\n  yield* Effect.log(\"message2\")\n}).pipe(Effect.annotateLogs(\"taskId\", \"1234\")) // Annotation as key/value pair\n\nEffect.runFork(program)\n// timestamp=... level=INFO fiber=#0 message=message1 taskId=1234\n// timestamp=... level=INFO fiber=#0 message=message2 taskId=1234\n```\n\n----------------------------------------\n\nTITLE: Replicating Effects in TypeScript\nDESCRIPTION: The `replicate` function allows for the replication of a given STM effect a specified number of times. If the number is zero or negative, it returns an empty array. The function's signature demonstrates the use of generics for flexibility in the types of effects it can handle.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/STM-replicate.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const replicate: { (n: number): <A, E, R>(self: STM<A, E, R>) => Array<STM<A, E, R>>; <A, E, R>(self: STM<A, E, R>, n: number): Array<STM<A, E, R>>; }\n```\n\n----------------------------------------\n\nTITLE: Checking Option Values with Equivalence Function in TypeScript\nDESCRIPTION: The snippet showcases how to determine if an Option object contains a specific value using a custom equivalence function. The function 'containsWith' utilizes this equivalence function to compare values within an Option object to a provided value, outputting true or false based on presence and equivalence. This requires importing the Number and Option modules from the 'effect' package.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Option-containsWith.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { Number, Option } from \"effect\"\n\nconst contains = Option.containsWith(Number.Equivalence)\n\nconsole.log(Option.some(2).pipe(contains(2)))\n// Output: true\n\nconsole.log(Option.some(1).pipe(contains(2)))\n// Output: false\n\nconsole.log(Option.none().pipe(contains(2)))\n// Output: false\n\n```\n\n----------------------------------------\n\nTITLE: Combining Records with Monoid Union in TypeScript\nDESCRIPTION: This snippet demonstrates how to create a Monoid union of two records using the `getMonoidUnion` function from the Effect library. It illustrates how to combine values of matching keys using a specific Monoid instance, as well as handling cases where keys only exist in one record. Dependencies include `@effect/typeclass` for the Monoid instance and `@effect/typeclass/data/Record` for the Record operations.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/data-Record-getMonoidUnion.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as NumberInstances from \"@effect/typeclass/data/Number\"\nimport { getMonoidUnion } from \"@effect/typeclass/data/Record\"\n\nconst monoid = getMonoidUnion(NumberInstances.MonoidSum)\n\nconsole.log(monoid.combine({ a: 1 }, { a: 1, b: 3 }))\n// { a: 2, b: 3 }\n\nconsole.log(monoid.combine({ a: 1 }, monoid.empty))\n// { a: 1 }\n```\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const getMonoidUnion: <A>(value: monoid.Monoid<A>) => monoid.Monoid<Record.ReadonlyRecord<string, A>>\n```\n\n----------------------------------------\n\nTITLE: Declaring STM.flatMap TypeScript Function\nDESCRIPTION: Type signature for the flatMap method in the STM module, which enables sequential composition of transactional effects with complex type handling for error and resource management\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/STM-flatMap.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const flatMap: { <A, A2, E1, R1>(f: (a: A) => STM<A2, E1, R1>): <E, R>(self: STM<A, E, R>) => STM<A2, E1 | E, R1 | R>; <A, E, R, A2, E1, R1>(self: STM<A, E, R>, f: (a: A) => STM<A2, E1, R1>): STM<A2, E | E1, R | R1>; }\n```\n\n----------------------------------------\n\nTITLE: Implementing Stream Generation with unfold in TypeScript\nDESCRIPTION: Demonstrates creating a stream by generating consecutive numbers starting from 1. Uses Stream.unfold to generate values and Stream.take to limit the output to 5 elements.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-unfold.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Effect, Option, Stream } from \"effect\"\n\nconst stream = Stream.unfold(1, (n) => Option.some([n, n + 1]))\n\nEffect.runPromise(Stream.runCollect(stream.pipe(Stream.take(5)))).then(console.log)\n// { _id: 'Chunk', values: [ 1, 2, 3, 4, 5 ] }\n```\n\n----------------------------------------\n\nTITLE: Implementing Stream Leftover Collection in TypeScript\nDESCRIPTION: A function that enhances a Sink by collecting any leftover elements when the sink processing succeeds. The function returns a new Sink that produces both the original result and the leftovers as a tuple.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Sink-collectLeftover.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const collectLeftover: <A, In, L, E, R>(self: Sink<A, In, L, E, R>) => Sink<[A, Chunk.Chunk<L>], In, never, E, R>\n```\n\n----------------------------------------\n\nTITLE: Declaring Cause.pretty Function in TypeScript\nDESCRIPTION: TypeScript function declaration for pretty-printing a Cause object into a human-readable string. Takes a Cause<E> parameter and optional rendering options to configure the output format. Useful for logging, debugging, and displaying structured errors.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Cause-pretty.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const pretty: <E>(cause: Cause<E>, options?: { readonly renderErrorCause?: boolean | undefined; }) => string\n```\n\n----------------------------------------\n\nTITLE: Illustrating Windowed Schedule Behavior\nDESCRIPTION: This text-based diagram illustrates the behavior of a windowed schedule created with a 10-second interval. It shows how actions and sleep periods are distributed across fixed time windows.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Schedule-windowed.md#2025-04-11_snippet_1\n\nLANGUAGE: text\nCODE:\n```\n     10s        10s        10s       10s\n|----------|----------|----------|----------|\n|action------|sleep---|act|-sleep|action----|\n```\n\n----------------------------------------\n\nTITLE: Defining provideSomeLayer Function in TypeScript for Stream Module\nDESCRIPTION: This code snippet defines the provideSomeLayer function, which splits the context of a Stream into two parts. It provides one part using a specified Layer and leaves the remainder as R0. The function has two overloads to handle different parameter orders.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-provideSomeLayer.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const provideSomeLayer: {\n  <RIn, E2, ROut>(layer: Layer.Layer<ROut, E2, RIn>): <A, E, R>(self: Stream<A, E, R>) => Stream<A, E2 | E, RIn | Exclude<R, ROut>>;\n  <A, E, R, RIn, E2, ROut>(self: Stream<A, E, R>, layer: Layer.Layer<ROut, E2, RIn>): Stream<A, E | E2, RIn | Exclude<R, ROut>>;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Request Error Handling in TypeScript with Effect-TS\nDESCRIPTION: Defines a fail function that completes a Request with a specified error. The function has two overloads - one taking the error first and returning a function that accepts the request, and another taking both request and error parameters directly. Both return an Effect of void.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Request-fail.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const fail: {\n  <A extends Request<any, any>>(error: Request.Error<A>): (self: A) => Effect.Effect<void>;\n  <A extends Request<any, any>>(self: A, error: Request.Error<A>): Effect.Effect<void>;\n}\n```\n\n----------------------------------------\n\nTITLE: Extending Layer Scope in TypeScript\nDESCRIPTION: The `extendScope` function extends the scope of a layer, creating a new layer that delays resource release until the scope the resulting effect depends on is closed. This allows for more flexible resource management in Effect applications.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Layer-extendScope.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const extendScope: <RIn, E, ROut>(self: Layer<ROut, E, RIn>) => Layer<ROut, E, Scope.Scope | RIn>\n```\n\n----------------------------------------\n\nTITLE: Type Signature of the pipe Function\nDESCRIPTION: The complex type signature of the pipe function, showing its polymorphic nature and support for up to 20 function arguments.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Function-pipe.md#2025-04-11_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const pipe: { <A>(a: A): A; <A, B = never>(a: A, ab: (a: A) => B): B; <A, B = never, C = never>(a: A, ab: (a: A) => B, bc: (b: B) => C): C; <A, B = never, C = never, D = never>(a: A, ab: (a: A) => B, bc: (b: B) => C, cd: (c: C) => D): D; <A, B = never, C = never, D = never, E = never>(a: A, ab: (a: A) => B, bc: (b: B) => C, cd: (c: C) => D, de: (d: D) => E): E; <A, B = never, C = never, D = never, E = never, F = never>(a: A, ab: (a: A) => B, bc: (b: B) => C, cd: (c: C) => D, de: (d: D) => E, ef: (e: E) => F): F; <A, B = never, C = never, D = never, E = never, F = never, G = never>(a: A, ab: (a: A) => B, bc: (b: B) => C, cd: (c: C) => D, de: (d: D) => E, ef: (e: E) => F, fg: (f: F) => G): G; <A, B = never, C = never, D = never, E = never, F = never, G = never, H = never>(a: A, ab: (a: A) => B, bc: (b: B) => C, cd: (c: C) => D, de: (d: D) => E, ef: (e: E) => F, fg: (f: F) => G, gh: (g: G) => H): H; <A, B = never, C = never, D = never, E = never, F = never, G = never, H = never, I = never>(a: A, ab: (a: A) => B, bc: (b: B) => C, cd: (c: C) => D, de: (d: D) => E, ef: (e: E) => F, fg: (f: F) => G, gh: (g: G) => H, hi: (h: H) => I): I; <A, B = never, C = never, D = never, E = never, F = never, G = never, H = never, I = never, J = never>(a: A, ab: (a: A) => B, bc: (b: B) => C, cd: (c: C) => D, de: (d: D) => E, ef: (e: E) => F, fg: (f: F) => G, gh: (g: G) => H, hi: (h: H) => I, ij: (i: I) => J): J; <A, B = never, C = never, D = never, E = never, F = never, G = never, H = never, I = never, J = never, K = never>(a: A, ab: (a: A) => B, bc: (b: B) => C, cd: (c: C) => D, de: (d: D) => E, ef: (e: E) => F, fg: (f: F) => G, gh: (g: G) => H, hi: (h: H) => I, ij: (i: I) => J, jk: (j: J) => K): K; <A, B = never, C = never, D = never, E = never, F = never, G = never, H = never, I = never, J = never, K = never, L = never>(a: A, ab: (a: A) => B, bc: (b: B) => C, cd: (c: C) => D, de: (d: D) => E, ef: (e: E) => F, fg: (f: F) => G, gh: (g: G) => H, hi: (h: H) => I, ij: (i: I) => J, jk: (j: J) => K, kl: (k: K) => L): L; <A, B = never, C = never, D = never, E = never, F = never, G = never, H = never, I = never, J = never, K = never, L = never, M = never>(a: A, ab: (a: A) => B, bc: (b: B) => C, cd: (c: C) => D, de: (d: D) => E, ef: (e: E) => F, fg: (f: F) => G, gh: (g: G) => H, hi: (h: H) => I, ij: (i: I) => J, jk: (j: J) => K, kl: (k: K) => L, lm: (l: L) => M): M; <A, B = never, C = never, D = never, E = never, F = never, G = never, H = never, I = never, J = never, K = never, L = never, M = never, N = never>(a: A, ab: (a: A) => B, bc: (b: B) => C, cd: (c: C) => D, de: (d: D) => E, ef: (e: E) => F, fg: (f: F) => G, gh: (g: G) => H, hi: (h: H) => I, ij: (i: I) => J, jk: (j: J) => K, kl: (k: K) => L, lm: (l: L) => M, mn: (m: M) => N): N; <A, B = never, C = never, D = never, E = never, F = never, G = never, H = never, I = never, J = never, K = never, L = never, M = never, N = never, O = never>(a: A, ab: (a: A) => B, bc: (b: B) => C, cd: (c: C) => D, de: (d: D) => E, ef: (e: E) => F, fg: (f: F) => G, gh: (g: G) => H, hi: (h: H) => I, ij: (i: I) => J, jk: (j: J) => K, kl: (k: K) => L, lm: (l: L) => M, mn: (m: M) => N, no: (n: N) => O): O; <A, B = never, C = never, D = never, E = never, F = never, G = never, H = never, I = never, J = never, K = never, L = never, M = never, N = never, O = never, P = never>(a: A, ab: (a: A) => B, bc: (b: B) => C, cd: (c: C) => D, de: (d: D) => E, ef: (e: E) => F, fg: (f: F) => G, gh: (g: G) => H, hi: (h: H) => I, ij: (i: I) => J, jk: (j: J) => K, kl: (k: K) => L, lm: (l: L) => M, mn: (m: M) => N, no: (n: N) => O, op: (o: O) => P): P; <A, B = never, C = never, D = never, E = never, F = never, G = never, H = never, I = never, J = never, K = never, L = never, M = never, N = never, O = never, P = never, Q = never>(a: A, ab: (a: A) => B, bc: (b: B) => C, cd: (c: C) => D, de: (d: D) => E, ef: (e: E) => F, fg: (f: F) => G, gh: (g: G) => H, hi: (h: H) => I, ij: (i: I) => J, jk: (j: J) => K, kl: (k: K) => L, lm: (l: L) => M, mn: (m: M) => N, no: (n: N) => O, op: (o: O) => P, pq: (p: P) => Q): Q; <A, B = never, C = never, D = never, E = never, F = never, G = never, H = never, I = never, J = never, K = never, L = never, M = never, N = never, O = never, P = never, Q = never, R = never>(a: A, ab: (a: A) => B, bc: (b: B) => C, cd: (c: C) => D, de: (d: D) => E, ef: (e: E) => F, fg: (f: F) => G, gh: (g: G) => H, hi: (h: H) => I, ij: (i: I) => J, jk: (j: J) => K, kl: (k: K) => L, lm: (l: L) => M, mn: (m: M) => N, no: (n: N) => O, op: (o: O) => P, pq: (p: P) => Q, qr: (q: Q) => R): R; <A, B = never, C = never, D = never, E = never, F = never, G = never, H = never, I = never, J = never, K = never, L = never, M = never, N = never, O = never, P = never, Q = never, R = never, S = never>(a: A, ab: (a: A) => B, bc: (b: B) => C, cd: (c: C) => D, de: (d: D) => E, ef: (e: E) => F, fg: (f: F) => G, gh: (g: G) => H, hi: (h: H) => I, ij: (i: I) => J, jk: (j: J) => K, kl: (k: K) => L, lm: (l: L) => M, mn: (m: M) => N, no: (n: N) => O, op: (o: O) => P, pq: (p: P) => Q, qr: (q: Q) => R, rs: (r: R) => S): S; <A, B = never, C = never, D = never, E = never, F = never, G = never, H = never, I = never, J = never, K = never, L = never, M = never, N = never, O = never, P = never, Q = never, R = never, S = never, T = never>(a: A, ab: (a: A) => B, bc: (b: B) => C, cd: (c: C) => D, de: (d: D) => E, ef: (e: E) => F, fg: (f: F) => G, gh: (g: G) => H, hi: (h: H) => I, ij: (i: I) => J, jk: (j: J) => K, kl: (k: K) => L, lm: (l: L) => M, mn: (m: M) => N, no: (n: N) => O, op: (o: O) => P, pq: (p: P) => Q, qr: (q: Q) => R, rs: (r: R) => S, st: (s: S) => T): T; }\n```\n\n----------------------------------------\n\nTITLE: STM.check Declaration in Typescript\nDESCRIPTION: This code snippet shows the declaration of the `check` function within the `STM` module of the Effect library. The `check` function takes a lazy argument, which is a function that returns a boolean, and returns an `STM` that represents a transactional computation that either succeeds with void or retries the transaction based on the boolean value.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/STM-check.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const check: (predicate: LazyArg<boolean>) => STM<void>\n```\n\n----------------------------------------\n\nTITLE: Declaring Stream Repetition with Schedule in TypeScript\nDESCRIPTION: Creates a stream that repeatedly executes an effect based on a defined schedule, supporting conditional and timed repetition of effects with potential type transformations\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-repeatEffectWithSchedule.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const repeatEffectWithSchedule: <A, E, R, X, A0 extends A, R2>(effect: Effect.Effect<A, E, R>, schedule: Schedule.Schedule<X, A0, R2>) => Stream<A, E, R | R2>\n```\n\n----------------------------------------\n\nTITLE: Creating Data Sources from Pure Functions using RequestResolver.fromFunction in TypeScript\nDESCRIPTION: Constructs a data source from a pure function. This function takes a request handler and returns a RequestResolver that can process requests of type A, returning their success values.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/RequestResolver-fromFunction.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const fromFunction: <A extends Request.Request<any>>(f: (request: A) => Request.Request.Success<A>) => RequestResolver<A>\n```\n\n----------------------------------------\n\nTITLE: Declaring Type Assertion Function in TypeScript\nDESCRIPTION: This snippet declares a generic function 'asserts' that checks if a value complies with a given schema. It requires a schema and optional parse options, returns a function that asserts whether the input is of the specified type. If the validation fails, it throws a 'ParseError'.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/ParseResult-asserts.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const asserts: <A, I, R>(schema: Schema.Schema<A, I, R>, options?: AST.ParseOptions) => (u: unknown, overrideOptions?: AST.ParseOptions) => asserts u is A\n```\n\n----------------------------------------\n\nTITLE: Testing TSet Emptiness with Effect-TS in TypeScript\nDESCRIPTION: The `isEmpty` function checks if a `TSet` instance is empty using the Effect-TS library's STM module. It uses a generic type parameter `A` to maintain type safety across different uses of the `TSet`. This function requires the `STM` module from Effect-TS and returns a boolean wrapped in STM, indicating the set's empty state. No additional input is expected other than the `TSet` instance. This implementation leverages TypeScript's type system to ensure robust transactional operations on shared mutable states.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TSet-isEmpty.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const isEmpty: <A>(self: TSet<A>) => STM.STM<boolean>\n```\n\n----------------------------------------\n\nTITLE: Implementing Fiber Join Operation in TypeScript\nDESCRIPTION: Defines the join operation for Fiber type that suspends the joining fiber until the result is determined. The operation handles error cases and fiber interruptions, with special behavior for inner interruptions that can be caught and recovered.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Fiber-join.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const join: <A, E>(self: Fiber<A, E>) => Effect.Effect<A, E>\n```\n\n----------------------------------------\n\nTITLE: Inserting an Element at a Specific Index in an Array using Effect.Array\nDESCRIPTION: This function inserts an element at the specified index, creating a new NonEmptyArray, or returns None if the index is out of bounds. It demonstrates the usage of the Array.insertAt function from the Effect library.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Array-insertAt.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Array } from \"effect\"\n\nconst result = Array.insertAt(['a', 'b', 'c', 'e'], 3, 'd')\nconsole.log(result) // Option.some(['a', 'b', 'c', 'd', 'e'])\n```\n\n----------------------------------------\n\nTITLE: Adding Elements with Effect-TS in TypeScript\nDESCRIPTION: The `TSet.add` function allows users to store new elements in a set using the Effect library. It provides a method that takes a value and returns a function that, given a set (`TSet<A>`), performs a stateful transaction (`STM`) to add the element. This functionality is available since version 2.0.0 and requires the STM module from Effect. The function can be invoked in a curried form or by passing both the set and the value directly.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TSet-add.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const add: { <A>(value: A): (self: TSet<A>) => STM.STM<void>; <A>(self: TSet<A>, value: A): STM.STM<void>; }\n```\n\n----------------------------------------\n\nTITLE: Conceptual Implementation of Effect.loop in TypeScript\nDESCRIPTION: A pseudocode representation showing how Effect.loop works internally, demonstrating the loop structure with state management and result collection.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-loop.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nlet state = initial\nconst result = []\n\nwhile (options.while(state)) {\n  result.push(options.body(state)) // Perform the effectful operation\n  state = options.step(state) // Update the state\n}\n\nreturn result\n```\n\n----------------------------------------\n\nTITLE: Defining Capitalized String Schema Filter in TypeScript\nDESCRIPTION: A generic schema transformation that validates whether a string begins with a capital letter. It can be applied to existing string schemas with optional annotations for custom error handling or metadata.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Schema-capitalized.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const capitalized: <S extends Schema.Any>(annotations?: Annotations.Filter<Schema.Type<S>>) => <A extends string>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>) => filter<S>\n```\n\n----------------------------------------\n\nTITLE: Implementing Layer Context in TypeScript\nDESCRIPTION: Function that constructs a Layer to pass along specified context as output. Takes a generic type parameter R and returns a Layer that never fails and preserves the input context type.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Layer-context.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const context: <R>() => Layer<R, never, R>\n```\n\n----------------------------------------\n\nTITLE: Calculating Maximum of Two Intervals in TypeScript\nDESCRIPTION: This function returns the maximum of two Interval objects. It can be called with two separate arguments or using method chaining.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/ScheduleInterval-max.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const max: { (that: Interval): (self: Interval) => Interval; (self: Interval, that: Interval): Interval; }\n```\n\n----------------------------------------\n\nTITLE: Creating Synchronous Sinks with Lazy Evaluation in TypeScript\nDESCRIPTION: The `sync` function creates a sink that immediately completes with the value returned by the provided lazy evaluation function. This allows for deferred computation of sink values.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Sink-sync.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const sync: <A>(evaluate: LazyArg<A>) => Sink<A, unknown>\n```\n\n----------------------------------------\n\nTITLE: Defining Mailbox Interface in TypeScript for Effect Library\nDESCRIPTION: This code snippet defines the Mailbox interface, which extends ReadonlyMailbox. It includes methods for offering messages, handling errors, and managing the mailbox state. The interface is generic, allowing for different types of messages and errors.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Mailbox-Mailbox.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface Mailbox<in out A, in out E = never> extends ReadonlyMailbox<A, E> {\n  readonly [TypeId]: TypeId\n  /**\n   * Add a message to the mailbox. Returns `false` if the mailbox is done.\n   */\n  readonly offer: (message: A) => Effect<boolean>\n  /**\n   * Add a message to the mailbox. Returns `false` if the mailbox is done.\n   */\n  readonly unsafeOffer: (message: A) => boolean\n  /**\n   * Add multiple messages to the mailbox. Returns the remaining messages that\n   * were not added.\n   */\n  readonly offerAll: (messages: Iterable<A>) => Effect<Chunk<A>>\n  /**\n   * Add multiple messages to the mailbox. Returns the remaining messages that\n   * were not added.\n   */\n  readonly unsafeOfferAll: (messages: Iterable<A>) => Chunk<A>\n  /**\n   * Fail the mailbox with an error. If the mailbox is already done, `false` is\n   * returned.\n   */\n  readonly fail: (error: E) => Effect<boolean>\n  /**\n   * Fail the mailbox with a cause. If the mailbox is already done, `false` is\n   * returned.\n   */\n  readonly failCause: (cause: Cause<E>) => Effect<boolean>\n  /**\n   * Signal that the mailbox is complete. If the mailbox is already done, `false` is\n   * returned.\n   */\n  readonly end: Effect<boolean>\n  /**\n   * Signal that the mailbox is done. If the mailbox is already done, `false` is\n   * returned.\n   */\n  readonly done: (exit: Exit<void, E>) => Effect<boolean>\n  /**\n   * Signal that the mailbox is done. If the mailbox is already done, `false` is\n   * returned.\n   */\n  readonly unsafeDone: (exit: Exit<void, E>) => boolean\n  /**\n   * Shutdown the mailbox, canceling any pending operations.\n   * If the mailbox is already done, `false` is returned.\n   */\n  readonly shutdown: Effect<boolean>\n}\n```\n\n----------------------------------------\n\nTITLE: Concatenating Stream Values into String in TypeScript\nDESCRIPTION: The mkString function takes a Stream of strings and returns an Effect that produces a single concatenated string. It combines all string values from the input stream into one output string.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-mkString.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const mkString: <E, R>(self: Stream<string, E, R>) => Effect.Effect<string, E, R>\n```\n\n----------------------------------------\n\nTITLE: Unzipping Chunk Elements in TypeScript with Effect-TS\nDESCRIPTION: The unzip function takes a Chunk of tuples (pairs) and separates them into two separate Chunks. It works as the reverse operation of zip, splitting paired elements back into their original collections.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Chunk-unzip.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const unzip: <A, B>(self: Chunk<readonly [A, B]>) => [Chunk<A>, Chunk<B>]\n```\n\n----------------------------------------\n\nTITLE: Implementing Deferred.complete Function in TypeScript\nDESCRIPTION: This function completes a deferred with the result of a specified effect. It returns a boolean indicating whether the completion was successful. If the deferred has already been completed, it returns false. Note that Deferred.completeWith is faster if memoization of the effect result is not needed.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Deferred-complete.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const complete: {\n  <A, E>(effect: Effect.Effect<A, E>): (self: Deferred<A, E>) => Effect.Effect<boolean>;\n  <A, E>(self: Deferred<A, E>, effect: Effect.Effect<A, E>): Effect.Effect<boolean>;\n}\n```\n\n----------------------------------------\n\nTITLE: Formatting DateTime Objects with Intl.DateTimeFormat in TypeScript\nDESCRIPTION: This function provides a way to format DateTime objects as strings using the Intl.DateTimeFormat API. It offers two call signatures - one that takes a format followed by a DateTime object, and another that takes a DateTime object followed by a format parameter.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/DateTime-formatIntl.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const formatIntl: { (format: Intl.DateTimeFormat): (self: DateTime) => string; (self: DateTime, format: Intl.DateTimeFormat): string; }\n```\n\n----------------------------------------\n\nTITLE: Retrieving the Last Element from a Non-Empty Array in TypeScript\nDESCRIPTION: The `lastNonEmpty` function retrieves the last element from a non-empty array. It takes a non-empty array as an argument and returns its last element. This provides type safety as it works specifically with the NonEmptyReadonlyArray type.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Array-lastNonEmpty.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Array } from \"effect\"\n\nconst result = Array.lastNonEmpty([1, 2, 3, 4])\nconsole.log(result) // 4\n```\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const lastNonEmpty: <A>(self: NonEmptyReadonlyArray<A>) => A\n```\n\n----------------------------------------\n\nTITLE: Using Effect.sandbox with Error Handling in TypeScript\nDESCRIPTION: This example demonstrates how to use Effect.sandbox to expose detailed error causes from an Effect. It shows how to catch different error types (Die, Interrupt, Fail) using catchTags, and how to restore original error handling with unsandbox.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-sandbox.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Effect, Console } from \"effect\"\n\n//      ┌─── Effect<string, Error, never>\n//      ▼\nconst task = Effect.fail(new Error(\"Oh uh!\")).pipe(\n  Effect.as(\"primary result\")\n)\n\n//      ┌─── Effect<string, Cause<Error>, never>\n//      ▼\nconst sandboxed = Effect.sandbox(task)\n\nconst program = Effect.catchTags(sandboxed, {\n  Die: (cause) =>\n    Console.log(`Caught a defect: ${cause.defect}`).pipe(\n      Effect.as(\"fallback result on defect\")\n    ),\n  Interrupt: (cause) =>\n    Console.log(`Caught a defect: ${cause.fiberId}`).pipe(\n      Effect.as(\"fallback result on fiber interruption\")\n    ),\n  Fail: (cause) =>\n    Console.log(`Caught a defect: ${cause.error}`).pipe(\n      Effect.as(\"fallback result on failure\")\n    )\n})\n\n// Restore the original error handling with unsandbox\nconst main = Effect.unsandbox(program)\n\nEffect.runPromise(main).then(console.log)\n// Output:\n// Caught a defect: Oh uh!\n// fallback result on failure\n```\n\n----------------------------------------\n\nTITLE: Grouping Stream Elements in Effect-TS\nDESCRIPTION: This snippet demonstrates how to group a stream of names by the first letter using the Stream.groupBy function of the Effect-TS library. It imports necessary modules such as Chunk, Effect, GroupBy, and Stream, then creates a stream from an iterable of names. The stream is processed by grouping elements based on their first character and evaluating the resulting grouped streams to compute their sizes. The final results are collected and logged as chunks of key-size pairs. This snippet requires Effect-TS library and its dependencies to function properly.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-groupBy.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Chunk, Effect, GroupBy, Stream } from \"effect\"\n\nconst groupByKeyResult = Stream.fromIterable([\n  \"Mary\",\n  \"James\",\n  \"Robert\",\n  \"Patricia\",\n  \"John\",\n  \"Jennifer\",\n  \"Rebecca\",\n  \"Peter\"\n]).pipe(\n  Stream.groupBy((name) => Effect.succeed([name.substring(0, 1), name]))\n)\n\nconst stream = GroupBy.evaluate(groupByKeyResult, (key, stream) =>\n  Stream.fromEffect(\n    Stream.runCollect(stream).pipe(\n      Effect.andThen((chunk) => [key, Chunk.size(chunk)] as const)\n    )\n  ))\n\nEffect.runPromise(Stream.runCollect(stream)).then(console.log)\n// {\n//   _id: 'Chunk',\n//   values: [ [ 'M', 1 ], [ 'J', 3 ], [ 'R', 2 ], [ 'P', 2 ] ]\n// }\n\n```\n\n----------------------------------------\n\nTITLE: Encoding Input to Hexadecimal String in TypeScript\nDESCRIPTION: The encodeHex function takes either a Uint8Array or a string as input and returns a hexadecimal string representation. This function is part of the Encoding module in the Effect package and has been available since version 2.0.0.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Encoding-encodeHex.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const encodeHex: (input: Uint8Array | string) => string\n```\n\n----------------------------------------\n\nTITLE: Creating Cookies from Set-Cookie Headers in TypeScript\nDESCRIPTION: Function signature for creating a Cookies object from either a single Set-Cookie header string or an iterable of Set-Cookie header strings. Returns a Cookies type object.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Cookies-fromSetCookie.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const fromSetCookie: (headers: Iterable<string> | string) => Cookies\n```\n\n----------------------------------------\n\nTITLE: STM.option: Convert STM Failure to Option in Typescript\nDESCRIPTION: The `STM.option` function converts the failure channel of an STM computation into an `Option`. This allows you to handle potential errors within the STM transaction by representing them as the presence or absence of a value.  It takes an `STM<A, E, R>` as input and returns `STM<Option.Option<A>, never, R>`, where the failure type `E` is eliminated and a successful result is wrapped in `Some` or failure is represented by `None`.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/STM-option.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const option: <A, E, R>(self: STM<A, E, R>) => STM<Option.Option<A>, never, R>\n```\n\n----------------------------------------\n\nTITLE: Adding Values to a HashSet in Effect Library (TypeScript)\nDESCRIPTION: Demonstrates three different ways to add a value to a HashSet: using the data-last (pipeable) API, piping with the pipe function, and using the data-first API. The function has O(1) average time complexity.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/HashSet-add.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// Syntax\nimport { HashSet, pipe } from \"effect\"\n\n// with data-last, a.k.a. pipeable API\npipe(HashSet.empty(), HashSet.add(0), HashSet.add(0))\n\n// or piped with the pipe function\nHashSet.empty().pipe(HashSet.add(0))\n\n// or with data-first API\nHashSet.add(HashSet.empty(), 0)\n```\n\n----------------------------------------\n\nTITLE: Retrieving All Keys from a Transactional Map in TypeScript\nDESCRIPTION: The keys function collects all keys stored in a TMap and returns them as an array. It operates within the STM (Software Transactional Memory) context, making it safe for concurrent operations.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TMap-keys.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const keys: <K, V>(self: TMap<K, V>) => STM.STM<Array<K>>\n```\n\n----------------------------------------\n\nTITLE: Declaring filterMap Function for HashMap in TypeScript\nDESCRIPTION: Defines the filterMap function that maps over entries of a HashMap using a specified partial function and filters out None values. It can be used in two ways: as a higher-order function or directly on a HashMap instance.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/HashMap-filterMap.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const filterMap: { <A, K, B>(f: (value: A, key: K) => Option<B>): (self: HashMap<K, A>) => HashMap<K, B>; <K, A, B>(self: HashMap<K, A>, f: (value: A, key: K) => Option<B>): HashMap<K, B>; }\n```\n\n----------------------------------------\n\nTITLE: Updating Records with effect/Record in TypeScript\nDESCRIPTION: The 'set' function is used to add or update key-value pairs in a record, preserving immutability. Dependencies include the 'effect' package and 'node:assert'. The function takes a record, a key, and a value, returning a new record with the updated or added key-value pair. Supported since v2.0.0.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Record-set.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { set } from \"effect/Record\"\n\nassert.deepStrictEqual(set(\"a\", 5)({ a: 1, b: 2 }), { a: 5, b: 2 });\nassert.deepStrictEqual(set(\"c\", 5)({ a: 1, b: 2 }), { a: 1, b: 2, c: 5 });\n```\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const set: { <K extends string | symbol, K1 extends K | ((string | symbol) & {}), B>(key: K1, value: B): <A>(self: ReadonlyRecord<K, A>) => Record<K | K1, A | B>; <K extends string | symbol, A, K1 extends K | ((string | symbol) & {}), B>(self: ReadonlyRecord<K, A>, key: K1, value: B): Record<K | K1, A | B>; }\n```\n\n----------------------------------------\n\nTITLE: Array.reduce Function Signature in TypeScript\nDESCRIPTION: Provides the TypeScript signature for the Array.reduce function. It shows two overloads: one for curried usage and another for direct usage. The function takes an initial value, a reducer function, and an iterable of elements.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Array-reduce.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const reduce: { <B, A>(b: B, f: (b: B, a: A, i: number) => B): (self: Iterable<A>) => B; <A, B>(self: Iterable<A>, b: B, f: (b: B, a: A, i: number) => B): B; }\n```\n\n----------------------------------------\n\nTITLE: Defining pipeThroughChannel Function for Stream in TypeScript\nDESCRIPTION: Declares the pipeThroughChannel function, which pipes all values from a stream through a provided channel. It supports both curried and uncurried forms, allowing flexible usage with different parameter orders.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-pipeThroughChannel.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const pipeThroughChannel: { <R2, E, E2, A, A2>(channel: Channel.Channel<Chunk.Chunk<A2>, Chunk.Chunk<A>, E2, E, unknown, unknown, R2>): <R>(self: Stream<A, E, R>) => Stream<A2, E2, R2 | R>; <R, R2, E, E2, A, A2>(self: Stream<A, E, R>, channel: Channel.Channel<Chunk.Chunk<A2>, Chunk.Chunk<A>, E2, E, unknown, unknown, R2>): Stream<A2, E2, R | R2>; }\n```\n\n----------------------------------------\n\nTITLE: Defining rejectSTM in TypeScript with Effect-TS\nDESCRIPTION: The rejectSTM function is a TypeScript function that takes a partial function as an argument and processes an STM computation accordingly. If the partial function matches the input, it translates the match into a failure; otherwise, it will continue with the held value. This function is a higher-order function that enhances the handling of side effects in concurrent programming with Effect-TS.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/STM-rejectSTM.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const rejectSTM: { <A, E2, R2>(pf: (a: A) => Option.Option<STM<E2, E2, R2>>): <E, R>(self: STM<A, E, R>) => STM<A, E2 | E, R2 | R>; <A, E, R, E2, R2>(self: STM<A, E, R>, pf: (a: A) => Option.Option<STM<E2, E2, R2>>): STM<A, E | E2, R | R2>; }\n```\n\n----------------------------------------\n\nTITLE: STM.zipWith Signature\nDESCRIPTION: This snippet showcases the signature of the `STM.zipWith` function, detailing its generic types and parameters. It highlights the function's ability to accept two STM values and a combiner function to produce a new STM value with a combined result.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/STM-zipWith.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const zipWith: { <A1, E1, R1, A, A2>(that: STM<A1, E1, R1>, f: (a: A, b: A1) => A2): <E, R>(self: STM<A, E, R>) => STM<A2, E1 | E, R1 | R>; <A, E, R, A1, E1, R1, A2>(self: STM<A, E, R>, that: STM<A1, E1, R1>, f: (a: A, b: A1) => A2): STM<A2, E | E1, R | R1>; }\n```\n\n----------------------------------------\n\nTITLE: Setting Current Time Zone in Effect for DateTime Operations\nDESCRIPTION: This snippet demonstrates how to use the `withCurrentZoneNamed` function to set a specific time zone (Europe/London) for DateTime operations within an Effect. It shows how to get the current time in the specified time zone.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/DateTime-withCurrentZoneNamed.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { DateTime, Effect } from \"effect\"\n\nEffect.gen(function* () {\n  // will use the \"Europe/London\" time zone\n  const now = yield* DateTime.nowInCurrentZone\n}).pipe(DateTime.withCurrentZoneNamed(\"Europe/London\"))\n```\n\n----------------------------------------\n\nTITLE: Synchronous Micro Effect Execution in TypeScript\nDESCRIPTION: Provides a method to run a Micro effect synchronously and extract its success value. Useful for scenarios requiring immediate effect resolution without async handling.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Micro-runSync.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const runSync: <A, E>(effect: Micro<A, E>) => A\n```\n\n----------------------------------------\n\nTITLE: Using FiberMap to manage multiple fibers in TypeScript\nDESCRIPTION: This example demonstrates how to create a FiberMap, run multiple effects as fibers stored in the map, and ensure they're properly cleaned up when the scope closes. The fibers are automatically removed from the map when they complete, and all fibers are interrupted when the scope ends.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/FiberMap-make.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Effect, FiberMap } from \"effect\"\n\nEffect.gen(function*() {\n  const map = yield* FiberMap.make<string>()\n\n  // run some effects and add the fibers to the map\n  yield* FiberMap.run(map, \"fiber a\", Effect.never)\n  yield* FiberMap.run(map, \"fiber b\", Effect.never)\n\n  yield* Effect.sleep(1000)\n}).pipe(\n  Effect.scoped // The fibers will be interrupted when the scope is closed\n)\n```\n\n----------------------------------------\n\nTITLE: Stream.acquireRelease Function Signature in TypeScript\nDESCRIPTION: The type signature for the Stream.acquireRelease function. It takes an acquire effect that produces a resource and a release function that cleans up the resource, returning a stream that will automatically manage the resource's lifecycle.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-acquireRelease.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const acquireRelease: <A, E, R, R2, X>(acquire: Effect.Effect<A, E, R>, release: (resource: A, exit: Exit.Exit<unknown, unknown>) => Effect.Effect<X, never, R2>) => Stream<A, E, R | R2>\n```\n\n----------------------------------------\n\nTITLE: Array.cartesian Function Signature in TypeScript\nDESCRIPTION: This code snippet shows the TypeScript signature for the Array.cartesian function. It demonstrates that the function can be called with two arrays or as a curried function.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Array-cartesian.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const cartesian: { <B>(that: ReadonlyArray<B>): <A>(self: ReadonlyArray<A>) => Array<[A, B]>; <A, B>(self: ReadonlyArray<A>, that: ReadonlyArray<B>): Array<[A, B]>; }\n```\n\n----------------------------------------\n\nTITLE: Implementing Effect Summarization in TypeScript\nDESCRIPTION: The 'summarized' function allows computing a summary value before and after effect execution, combining these values with the execution result. It supports two overloads for flexible usage.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-summarized.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const summarized: { <B, E2, R2, C>(summary: Effect<B, E2, R2>, f: (start: B, end: B) => C): <A, E, R>(self: Effect<A, E, R>) => Effect<[C, A], E2 | E, R2 | R>; <A, E, R, B, E2, R2, C>(self: Effect<A, E, R>, summary: Effect<B, E2, R2>, f: (start: B, end: B) => C): Effect<[C, A], E2 | E, R2 | R>; }\n```\n\n----------------------------------------\n\nTITLE: Signature of Stream.mapConcat Function in TypeScript\nDESCRIPTION: The Stream.mapConcat function takes a transformation function that maps each element to an iterable and flattens these into a single stream. Its signature is provided for reference, and it accepts parameters of types A, A2 for mapping, and E, R for stream processing. This is part of the 'effect' library and the mapping function and stream should conform to the expected types.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-mapConcat.md#2025-04-11_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const mapConcat: { <A, A2>(f: (a: A) => Iterable<A2>): <E, R>(self: Stream<A, E, R>) => Stream<A2, E, R>; <A, E, R, A2>(self: Stream<A, E, R>, f: (a: A) => Iterable<A2>): Stream<A2, E, R>; }\n```\n\n----------------------------------------\n\nTITLE: Function Signature for withCurrentZone in DateTime Module\nDESCRIPTION: TypeScript declaration for the withCurrentZone function, showing its polymorphic interface. The function can be used in two ways: by passing the zone first as a curried parameter, or by passing both the effect and zone together.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/DateTime-withCurrentZone.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const withCurrentZone: { (zone: TimeZone): <A, E, R>(effect: Effect.Effect<A, E, R>) => Effect.Effect<A, E, Exclude<R, CurrentTimeZone>>; <A, E, R>(effect: Effect.Effect<A, E, R>, zone: TimeZone): Effect.Effect<A, E, Exclude<R, CurrentTimeZone>>; }\n```\n\n----------------------------------------\n\nTITLE: Request Transformation Method Definition in TypeScript\nDESCRIPTION: Defines the mapRequestEffect method that allows effectful transformation of HTTP client requests. The method supports both curried and uncurried forms, enabling request modification before sending.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/HttpClient-mapRequestEffect.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const mapRequestEffect: { <E2, R2>(f: (a: ClientRequest.HttpClientRequest) => Effect.Effect<ClientRequest.HttpClientRequest, E2, R2>): <E, R>(self: HttpClient.With<E, R>) => HttpClient.With<E | E2, R | R2>; <E, R, E2, R2>(self: HttpClient.With<E, R>, f: (a: ClientRequest.HttpClientRequest) => Effect.Effect<ClientRequest.HttpClientRequest, E2, R2>): HttpClient.With<E | E2, R | R2>; }\n```\n\n----------------------------------------\n\nTITLE: Implementing forEach Iterator in TypeScript with Micro Module\nDESCRIPTION: Defines a forEach function that processes elements of an iterable using provided effect function. Supports optional concurrency control and result collection or discarding. Returns either an array of results or void based on the discard option.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Micro-forEach.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const forEach: { <A, B, E, R>(iterable: Iterable<A>, f: (a: A, index: number) => Micro<B, E, R>, options?: { readonly concurrency?: Concurrency | undefined; readonly discard?: false | undefined; }): Micro<Array<B>, E, R>; <A, B, E, R>(iterable: Iterable<A>, f: (a: A, index: number) => Micro<B, E, R>, options: { readonly concurrency?: Concurrency | undefined; readonly discard: true; }): Micro<void, E, R>; }\n```\n\n----------------------------------------\n\nTITLE: Defining Stream.onError Function in TypeScript\nDESCRIPTION: Declares the onError function for handling stream errors. It takes a cleanup effect that runs if the stream fails, providing the error cause. The function can be used in two ways: either passing the cleanup first, or the stream first.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-onError.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const onError: { <E, X, R2>(cleanup: (cause: Cause.Cause<E>) => Effect.Effect<X, never, R2>): <A, R>(self: Stream<A, E, R>) => Stream<A, E, R2 | R>; <A, E, R, X, R2>(self: Stream<A, E, R>, cleanup: (cause: Cause.Cause<E>) => Effect.Effect<X, never, R2>): Stream<A, E, R | R2>; }\n```\n\n----------------------------------------\n\nTITLE: Defining Channel.succeed Function in TypeScript\nDESCRIPTION: This snippet defines the succeed function in the Channel module. It constructs a channel that immediately succeeds with a specified value. The function is generic, taking a value of type A and returning a Channel with specific type parameters.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Channel-succeed.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const succeed: <A>(value: A) => Channel<never, unknown, never, unknown, A, unknown>\n```\n\n----------------------------------------\n\nTITLE: Zipping STM Values\nDESCRIPTION: This snippet declares the zip function, which allows for sequential zipping of two STM values. It supports both single and multiple arguments for zipping, producing a combined STM effect. Dependencies include the STM module which provides the necessary types and functionality.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/STM-zip.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const zip: { <A1, E1, R1>(that: STM<A1, E1, R1>): <A, E, R>(self: STM<A, E, R>) => STM<[A, A1], E1 | E, R1 | R>; <A, E, R, A1, E1, R1>(self: STM<A, E, R>, that: STM<A1, E1, R1>): STM<[A, A1], E | E1, R | R1>; }\n```\n\n----------------------------------------\n\nTITLE: Signature of Record.get Function in Typescript\nDESCRIPTION: This code shows the type signature of the `Record.get` function from the Effect library.  It takes a record and a key as input, returning an Option containing the value associated with the key or Option.none() if the key is not found. It uses generics to define the types of the key and value.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Record-get.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const get: { <K extends string | symbol>(key: NoInfer<K>): <A>(self: ReadonlyRecord<K, A>) => Option.Option<A>; <K extends string | symbol, A>(self: ReadonlyRecord<K, A>, key: NoInfer<K>): Option.Option<A>; }\n```\n\n----------------------------------------\n\nTITLE: Declaring Fibonacci Schedule in TypeScript\nDESCRIPTION: This TypeScript function declares a schedule with delays based on the Fibonacci sequence. Starting with an initial delay of 'one,' it recursively sums the two previous delays. The schedule is useful for scenarios requiring progressive backoff strategies. The key parameter is 'one', a duration input representing the base delay unit. The function outputs a schedule of type 'Schedule<Duration.Duration>'.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Schedule-fibonacci.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const fibonacci: (one: Duration.DurationInput) => Schedule<Duration.Duration>\n```\n\n----------------------------------------\n\nTITLE: TypeScript Declaration Signature for Stream.asyncPush\nDESCRIPTION: The type signature of the asyncPush function showing its parameters and return type. It accepts a register function for emitting values and an optional configuration object for buffer size and strategy.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-asyncPush.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const asyncPush: <A, E = never, R = never>(register: (emit: Emit.EmitOpsPush<E, A>) => Effect.Effect<unknown, E, R | Scope.Scope>, options?: { readonly bufferSize: \"unbounded\"; } | { readonly bufferSize?: number | undefined; readonly strategy?: \"dropping\" | \"sliding\" | undefined; } | undefined) => Stream<A, E, Exclude<R, Scope.Scope>>\n```\n\n----------------------------------------\n\nTITLE: Racing Concurrent Effects with Custom Handlers in TypeScript\nDESCRIPTION: Example demonstrating how to race two effects with custom handlers for completion. This shows how to create two tasks with different delays, run them concurrently, and handle the results when either completes first, including proper interruption handling.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-raceWith.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Effect, Console } from \"effect\"\n\nconst task1 = Effect.succeed(\"task1\").pipe(\n  Effect.delay(\"100 millis\"),\n  Effect.tap(Console.log(\"task1 done\")),\n  Effect.onInterrupt(() =>\n    Console.log(\"task1 interrupted\").pipe(Effect.delay(\"100 millis\"))\n  )\n)\nconst task2 = Effect.succeed(\"task2\").pipe(\n  Effect.delay(\"200 millis\"),\n  Effect.tap(Console.log(\"task2 done\")),\n  Effect.onInterrupt(() =>\n    Console.log(\"task2 interrupted\").pipe(Effect.delay(\"100 millis\"))\n  )\n)\n\nconst program = Effect.raceWith(task1, task2, {\n  onSelfDone: (exit) => Console.log(`task1 exited with ${exit}`),\n  onOtherDone: (exit) => Console.log(`task2 exited with ${exit}`)\n})\n\nEffect.runFork(program)\n// Output:\n// task1 done\n// task1 exited with {\n//   \"_id\": \"Exit\",\n//   \"_tag\": \"Success\",\n//   \"value\": \"task1\"\n// }\n// task2 interrupted\n```\n\n----------------------------------------\n\nTITLE: Attaching Property Signature to Schema in Effect\nDESCRIPTION: This example demonstrates how to use `S.attachPropertySignature` to add a \"kind\" property to `Circle` and `Square` schemas, creating a `Shape` union schema. This allows discriminating between circle and square shapes based on the \"kind\" property after decoding.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Schema-attachPropertySignature.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport * as S from \"effect/Schema\"\nimport { pipe } from \"effect/Function\"\n\nconst Circle = S.Struct({ radius: S.Number })\nconst Square = S.Struct({ sideLength: S.Number })\nconst Shape = S.Union(\n  Circle.pipe(S.attachPropertySignature(\"kind\", \"circle\")),\n  Square.pipe(S.attachPropertySignature(\"kind\", \"square\"))\n)\n\nassert.deepStrictEqual(S.decodeSync(Shape)({ radius: 10 }), {\n  kind: \"circle\",\n  radius: 10\n})\n```\n\n----------------------------------------\n\nTITLE: Implementing String Concatenation in TypeScript Effect-TS\nDESCRIPTION: Defines a type-safe string concatenation function that works with string literals at runtime. The function is overloaded to support both curried and direct two-parameter usage patterns.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/String-concat.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const concat: { <B extends string>(that: B): <A extends string>(self: A) => Concat<A, B>; <A extends string, B extends string>(self: A, that: B): Concat<A, B>; }\n```\n\n----------------------------------------\n\nTITLE: Splitting Array Using Array.splitAt in TypeScript\nDESCRIPTION: Demonstrates how to split an array into two segments using Array.splitAt function. The first segment contains the first n elements, and the second segment contains the remaining elements.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Array-splitAt.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Array } from \"effect\"\n\nconst result = Array.splitAt([1, 2, 3, 4, 5], 3)\nconsole.log(result) // [[1, 2, 3], [4, 5]]\n```\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const splitAt: { (n: number): <A>(self: Iterable<A>) => [beforeIndex: Array<A>, fromIndex: Array<A>]; <A>(self: Iterable<A>, n: number): [beforeIndex: Array<A>, fromIndex: Array<A>]; }\n```\n\n----------------------------------------\n\nTITLE: Function Signature for takeFirstSTM in TMap Module\nDESCRIPTION: The takeFirstSTM function takes a partial function that processes key-value pairs and returns an STM effect that might return a value or None. It will retry until a matching value is found in the transactional map.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TMap-takeFirstSTM.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const takeFirstSTM: { <K, V, A, E, R>(pf: (key: K, value: V) => STM.STM<A, Option.Option<E>, R>): (self: TMap<K, V>) => STM.STM<A, E, R>; <K, V, A, E, R>(self: TMap<K, V>, pf: (key: K, value: V) => STM.STM<A, Option.Option<E>, R>): STM.STM<A, E, R>; }\n```\n\n----------------------------------------\n\nTITLE: Declaring Custom Test for Schedule in TypeScript\nDESCRIPTION: The snippet defines a `check` function that filters schedule executions based on a custom boolean test function that operates on input-output pairs. It requires the `Schedule` type and a test function as dependencies. The main parameters are the schedule itself and the test function. Expected in/outputs are schedules being continued or terminated based on the test result. The feature is available since v2.0.0.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Schedule-check.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const check: { <In, Out>(test: (input: In, output: Out) => boolean): <R>(self: Schedule<Out, In, R>) => Schedule<Out, In, R>; <Out, In, R>(self: Schedule<Out, In, R>, test: (input: In, output: Out) => boolean): Schedule<Out, In, R>; }\n```\n\n----------------------------------------\n\nTITLE: Composing Configurations with Custom Function in TypeScript\nDESCRIPTION: The zipWith function allows combining two Config objects using a provided function. It supports both curried and uncurried versions, enabling flexible composition of configurations.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Config-zipWith.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const zipWith: { <B, A, C>(that: Config<B>, f: (a: A, b: B) => C): (self: Config<A>) => Config<C>; <A, B, C>(self: Config<A>, that: Config<B>, f: (a: A, b: B) => C): Config<C>; }\n```\n\n----------------------------------------\n\nTITLE: Array.unionWith Function Signature in TypeScript\nDESCRIPTION: The type signature for the unionWith function, which supports different input types including regular iterables and non-empty arrays. The function returns a new array containing the union of elements based on the provided equivalence relation.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Array-unionWith.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const unionWith: { <S extends Iterable<any>, T extends Iterable<any>>(that: T, isEquivalent: (self: ReadonlyArray.Infer<S>, that: ReadonlyArray.Infer<T>) => boolean): (self: S) => ReadonlyArray.OrNonEmpty<S, T, ReadonlyArray.Infer<S> | ReadonlyArray.Infer<T>>; <A, B>(self: NonEmptyReadonlyArray<A>, that: Iterable<B>, isEquivalent: (self: A, that: B) => boolean): NonEmptyArray<A | B>; <A, B>(self: Iterable<A>, that: NonEmptyReadonlyArray<B>, isEquivalent: (self: A, that: B) => boolean): NonEmptyArray<A | B>; <A, B>(self: Iterable<A>, that: Iterable<B>, isEquivalent: (self: A, that: B) => boolean): Array<A | B>; }\n```\n\n----------------------------------------\n\nTITLE: Iterating with STM Function in TypeScript\nDESCRIPTION: This snippet demonstrates a transactional iteration utility using the STM module. It provides a mechanism to iterate with a transactional body function until a certain condition is met, starting from an initial state 's'. This approach is particularly useful in managing concurrent updates to shared state while preserving atomicity. Prerequisites include familiarity with STM (Software Transactional Memory) and TypeScript. The 'iterate' function expects an initial state, a continuation predicate, and a transactional body function as parameters and outputs an updated state of type STM.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/STM-iterate.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst s = initial\n\nwhile (cont(s)) {\n  s = body(s)\n}\n\nreturn s\n```\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const iterate: <Z, E, R>(initial: Z, options: { readonly while: Predicate<Z>; readonly body: (z: Z) => STM<Z, E, R>; }) => STM<Z, E, R>\n```\n\n----------------------------------------\n\nTITLE: Using Effect.ignoreLogged to Ignore Results While Logging Failures in TypeScript\nDESCRIPTION: The ignoreLogged function takes an effect and returns a new effect that ignores whether the original succeeds or fails, but logs any failures at the Debug level. This is useful when you want your program to continue regardless of the result, while still keeping track of potential issues.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-ignoreLogged.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const ignoreLogged: <A, E, R>(self: Effect<A, E, R>) => Effect<void, never, R>\n```\n\n----------------------------------------\n\nTITLE: Appending Elements to List in TypeScript using Effect-TS\nDESCRIPTION: Function signature for appending an element to the end of a List data structure. The function supports both curried and uncurried forms, accepting a List<A> and an element of type B, returning a new Cons containing elements of type A | B.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/List-append.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const append: { <B>(element: B): <A>(self: List<A>) => Cons<A | B>; <A, B>(self: List<A>, element: B): Cons<A | B>; }\n```\n\n----------------------------------------\n\nTITLE: Declaring takeFirstSTM in TypeScript\nDESCRIPTION: The takeFirstSTM function is a declaration for fetching the first matching value in a TSet or retrying until one becomes available. It takes a partial function to operate on values of the set and returns a transactional STM operation. This requires the Effect-TS library, particularly the STM and Option modules. It supports patterns where transactional memory operations are needed.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TSet-takeFirstSTM.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const takeFirstSTM: { <A, B, E, R>(pf: (a: A) => STM.STM<B, Option.Option<E>, R>): (self: TSet<A>) => STM.STM<B, E, R>; <A, B, E, R>(self: TSet<A>, pf: (a: A) => STM.STM<B, Option.Option<E>, R>): STM.STM<B, E, R>; }\n```\n\n----------------------------------------\n\nTITLE: Transforming Elements in TArray\nDESCRIPTION: The transform function provides a mechanism to atomically update all elements within a TArray instance using a pure function. It can be invoked with either the TArray itself and the function or just the function, binding it to the TArray in a curried form. This function ensures that updates maintain integrity and are performed in a safe concurrent manner, leveraging STM (Software Transactional Memory).\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TArray-transform.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const transform: { <A>(f: (value: A) => A): (self: TArray<A>) => STM.STM<void>; <A>(self: TArray<A>, f: (value: A) => A): STM.STM<void>; }\n```\n\n----------------------------------------\n\nTITLE: Defining the withSpanScoped Function in TypeScript\nDESCRIPTION: Declaration of the `withSpanScoped` function which creates a new tracing span around an effect. This function provides both curried and uncurried versions, allowing for flexible usage patterns. The span is tied to a Scope and will be ended when the Scope is finalized.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-withSpanScoped.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const withSpanScoped: { (name: string, options?: Tracer.SpanOptions): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, Exclude<R, Tracer.ParentSpan> | Scope.Scope>; <A, E, R>(self: Effect<A, E, R>, name: string, options?: Tracer.SpanOptions): Effect<A, E, Exclude<R, Tracer.ParentSpan> | Scope.Scope>; }\n```\n\n----------------------------------------\n\nTITLE: Constructing Scoped Layer in TypeScript\nDESCRIPTION: Defines a function that constructs a layer from a scoped effect. The function takes an Effect instance and returns a Layer that excludes the Scope type from its requirements.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Layer-scopedDiscard.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const scopedDiscard: <X, E, R>(effect: Effect.Effect<X, E, R>) => Layer<never, E, Exclude<R, Scope.Scope>>\n```\n\n----------------------------------------\n\nTITLE: Using Shell Pipe Syntax in Commands\nDESCRIPTION: Example of how command piping in shells works, demonstrating the syntax for connecting the output of one command to the input of another.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Command-pipeTo.md#2025-04-11_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\ncommand1 | command2\n```\n\n----------------------------------------\n\nTITLE: Effect.orDieWith Function Signature in TypeScript\nDESCRIPTION: The signature of the Effect.orDieWith function, showing its polymorphic nature and the types it works with. It takes an Effect and a function to transform the error, returning a new Effect with the error type set to 'never'.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-orDieWith.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const orDieWith: { <E>(f: (error: E) => unknown): <A, R>(self: Effect<A, E, R>) => Effect<A, never, R>; <A, E, R>(self: Effect<A, E, R>, f: (error: E) => unknown): Effect<A, never, R>; }\n```\n\n----------------------------------------\n\nTITLE: Implementing Document Concatenation with fillCat in TypeScript\nDESCRIPTION: A function that concatenates documents horizontally with empty spaces between them until page width is exceeded, then inserts line breaks. When grouped, documents are separated by empty space rather than newlines.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Doc-fillCat.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const fillCat: <A>(docs: Iterable<Doc<A>>) => Doc<A>\n```\n\n----------------------------------------\n\nTITLE: Typescript Schedule Intersection Function Signature\nDESCRIPTION: A type declaration for the intersect function that combines two schedules, using their intersection as input and producing a tuple of both schedules' outputs\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Schedule-intersect.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const intersect: { <Out2, In2, R2>(that: Schedule<Out2, In2, R2>): <Out, In, R>(self: Schedule<Out, In, R>) => Schedule<[Out, Out2], In & In2, R2 | R>; <Out, In, R, Out2, In2, R2>(self: Schedule<Out, In, R>, that: Schedule<Out2, In2, R2>): Schedule<[Out, Out2], In & In2, R | R2>; }\n```\n\n----------------------------------------\n\nTITLE: Checking if Input is a Promise using Effect Predicate\nDESCRIPTION: This code snippet demonstrates how to use the `isPromise` guard from the `effect/Predicate` module to check if a given value is a Promise. It uses `node:assert` to verify the expected behavior.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Predicate-isPromise.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { isPromise } from \"effect/Predicate\"\n\nassert.deepStrictEqual(isPromise({}), false)\nassert.deepStrictEqual(isPromise(Promise.resolve(\"hello\")), true)\n```\n\n----------------------------------------\n\nTITLE: Joining Multiple Fibers in Effect-TS\nDESCRIPTION: The `joinAll` function takes an iterable of fibers and returns an Effect that completes with an array of all successful fiber results. If any fiber errors (except for interruption errors), the returned Effect will fail with that error.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Fiber-joinAll.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const joinAll: <A, E>(fibers: Iterable<Fiber<A, E>>) => Effect.Effect<Array<A>, E>\n```\n\n----------------------------------------\n\nTITLE: Racing Multiple Failing Effects in TypeScript\nDESCRIPTION: Example showing racing three effects that all fail. Demonstrates how the function handles complete failure scenarios.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-raceAll.md#2025-04-11_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Effect, Console } from \"effect\"\n\nconst task1 = Effect.fail(\"task1\").pipe(\n  Effect.delay(\"100 millis\"),\n  Effect.tap(Console.log(\"task1 done\")),\n  Effect.onInterrupt(() => Console.log(\"task1 interrupted\"))\n)\nconst task2 = Effect.fail(\"task2\").pipe(\n  Effect.delay(\"200 millis\"),\n  Effect.tap(Console.log(\"task2 done\")),\n  Effect.onInterrupt(() => Console.log(\"task2 interrupted\"))\n)\n\nconst task3 = Effect.fail(\"task3\").pipe(\n  Effect.delay(\"150 millis\"),\n  Effect.tap(Console.log(\"task3 done\")),\n  Effect.onInterrupt(() => Console.log(\"task3 interrupted\"))\n)\n\nconst program = Effect.raceAll([task1, task2, task3])\n\nEffect.runPromiseExit(program).then(console.log)\n```\n\n----------------------------------------\n\nTITLE: Declaring Helper Function for Stream Changes with TypeScript\nDESCRIPTION: The `changesWith` function returns a stream that emits elements only when they differ from the previous element, based on a provided equality function. This function is part of the `effect` package's `Stream` module. It requires a comparison function `f` to determine equality between two elements. No additional dependencies are needed beyond the core type definitions.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-changesWith.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const changesWith: { <A>(f: (x: A, y: A) => boolean): <E, R>(self: Stream<A, E, R>) => Stream<A, E, R>; <A, E, R>(self: Stream<A, E, R>, f: (x: A, y: A) => boolean): Stream<A, E, R>; }\n```\n\n----------------------------------------\n\nTITLE: Creating a Trie using Trie.make in TypeScript\nDESCRIPTION: Demonstrates how to construct a new Trie instance using the Trie.make function. It shows creating a Trie with two entries, comparing it with a Trie created from an iterable, and accessing the entries.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Trie-make.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { Trie, Equal } from \"effect\"\n\nconst trie = Trie.make([\"ca\", 0], [\"me\", 1])\n\nassert.deepStrictEqual(Array.from(trie), [[\"ca\", 0], [\"me\", 1]])\nassert.equal(Equal.equals(Trie.fromIterable([[\"ca\", 0], [\"me\", 1]]), trie), true)\n```\n\n----------------------------------------\n\nTITLE: Implementing Service Provider in Effect-TS Micro Module\nDESCRIPTION: Defines a service provider function that can add services to the current context. The function supports two overloads: one that takes a tag and service first, and another that takes a Micro instance first followed by tag and service. Returns a new Micro instance with the provided service context.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Micro-provideService.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const provideService: {\n  <I, S>(tag: Context.Tag<I, S>, service: S): <A, E, R>(self: Micro<A, E, R>) => Micro<A, E, Exclude<R, I>>;\n  <A, E, R, I, S>(self: Micro<A, E, R>, tag: Context.Tag<I, S>, service: S): Micro<A, E, Exclude<R, I>>;\n}\n```\n\n----------------------------------------\n\nTITLE: Creating and Managing Scoped Resources in Effect Module\nDESCRIPTION: Creates a Scope resource, passes it to a specified function, and automatically closes the scope when the effect completes through success, failure, or interruption. This ensures proper resource lifecycle management.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-scopedWith.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const scopedWith: <A, E, R>(f: (scope: Scope.Scope) => Effect<A, E, R>) => Effect<A, E, R>\n```\n\n----------------------------------------\n\nTITLE: Filtering HashSet with Predicate in TypeScript\nDESCRIPTION: Example of filtering positive numbers from a HashSet using a Predicate function. Shows three different syntax approaches: data-last (pipeable) API, pipe method, and data-first API. The operation has O(n) time complexity.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/HashSet-filter.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// Syntax with  Predicate\nimport { HashSet, type Predicate, pipe } from \"effect\"\n\nconst filterPositiveNumbers: Predicate.Predicate<number> = (n) => n > 0\n\n// with `data-last`, a.k.a. `pipeable` API\npipe(\n  HashSet.make(-2, -1, 0, 1, 2),\n  HashSet.filter(filterPositiveNumbers)\n)\n\n// or with the pipe method\nHashSet.make(-2, -1, 0, 1, 2).pipe(HashSet.filter(filterPositiveNumbers))\n\n// or with `data-first` API\nHashSet.filter(HashSet.make(-2, -1, 0, 1, 2), filterPositiveNumbers)\n```\n\n----------------------------------------\n\nTITLE: Record.some Signature (TypeScript)\nDESCRIPTION: This code snippet defines the type signature for the `Record.some` function in TypeScript. The function takes a predicate and a read-only record as input. The predicate takes a value and a key from the record and returns a boolean. The function returns true if any entry in the record satisfies the predicate, and false otherwise.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Record-some.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const some: { <A, K extends string>(predicate: (value: A, key: K) => boolean): (self: ReadonlyRecord<K, A>) => boolean; <K extends string, A>(self: ReadonlyRecord<K, A>, predicate: (value: A, key: K) => boolean): boolean; }\n```\n\n----------------------------------------\n\nTITLE: Using BigDecimal.sign Function in TypeScript\nDESCRIPTION: This example demonstrates how to use the sign function from the BigDecimal module to determine if a number is negative (-1), zero (0), or positive (1). It utilizes the unsafeFromString function to create BigDecimal values.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/BigDecimal-sign.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { sign, unsafeFromString } from \"effect/BigDecimal\"\n\nassert.deepStrictEqual(sign(unsafeFromString(\"-5\")), -1)\nassert.deepStrictEqual(sign(unsafeFromString(\"0\")), 0)\nassert.deepStrictEqual(sign(unsafeFromString(\"5\")), 1)\n```\n\n----------------------------------------\n\nTITLE: Getting the Head Element of a ReadonlyArray in TypeScript\nDESCRIPTION: This TypeScript snippet declares a constant `head` which retrieves the first element of a `ReadonlyArray`. If the array is empty, it returns 'None'. This function provides a way to safely access array elements in a TypeScript environment with strong typing. It depends on the `Schema` framework and requires a compatible version 3.10.0 or later. Inputs include a schema object conforming to `S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>`, and the output is either the first element or 'None'.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Schema-head.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const head: <S extends Schema.Any, A extends ReadonlyArray<unknown>>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>) => transform<S, OptionFromSelf<SchemaClass<A[number]>>>\n```\n\n----------------------------------------\n\nTITLE: Example Config Unwrapping in TypeScript\nDESCRIPTION: Demonstrates how to use Config.unwrap to construct a configuration from a wrapped options interface. Shows a practical example of converting a Config.Wrap<Options> type to Config<Options>.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Config-unwrap.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Config, unwrap } from \"./Config\"\n\ninterface Options { key: string }\n\nconst makeConfig = (config: Config.Wrap<Options>): Config<Options> => unwrap(config)\n```\n\n----------------------------------------\n\nTITLE: Implementing Context Access in Effect-TS Channels\nDESCRIPTION: Function signature for contextWithChannel that allows accessing the context of a channel within another channel. Takes a function that receives the environment context and returns a new channel with combined environment types.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Channel-contextWithChannel.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const contextWithChannel: <Env, OutElem, InElem, OutErr, InErr, OutDone, InDone, Env1>(f: (env: Context.Context<Env>) => Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env1>) => Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env | Env1>\n```\n\n----------------------------------------\n\nTITLE: Creating a Scoped Cache with `ScopedCache.make` in Effect\nDESCRIPTION: This snippet shows the signature of the `ScopedCache.make` function. It constructs a new cache within an Effect, utilizing provided options for lookup, capacity, and time-to-live. The Effect requires a Scope and the environment of the lookup function to manage the cache's lifecycle.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/ScopedCache-make.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const make: <Key, Value, Error = never, Environment = never>(options: { readonly lookup: Lookup<Key, Value, Error, Environment>; readonly capacity: number; readonly timeToLive: Duration.DurationInput; }) => Effect.Effect<ScopedCache<Key, Value, Error>, never, Scope.Scope | Environment>\n```\n\n----------------------------------------\n\nTITLE: Implementing MonoidSum in TypeScript\nDESCRIPTION: This code snippet demonstrates the use of `MonoidSum` from the `@effect/typeclass` package, which represents numbers as a monoid under addition. The `combine` method adds two numbers together, while `MonoidSum.empty` represents the identity element, 0. The snippet requires the `@effect/typeclass` package and demonstrates basic addition using the monoid's `combine` method.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/data-Number-MonoidSum.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { MonoidSum } from \"@effect/typeclass/data/Number\"\n\nconsole.log(MonoidSum.combine(2, 3))\n// 5\nconsole.log(MonoidSum.combine(2, MonoidSum.empty))\n// 2\n```\n\n----------------------------------------\n\nTITLE: Checking if the Queue is Empty - TypeScript\nDESCRIPTION: This snippet declares a function that checks whether a TPriorityQueue is empty. It returns a boolean wrapped in an STM, which is used in the Effect-TS framework. The function is generic and can accept any type of element in the queue.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TPriorityQueue-isEmpty.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const isEmpty: <A>(self: TPriorityQueue<A>) => STM.STM<boolean>\n```\n\n----------------------------------------\n\nTITLE: Using BigInt lessThan Comparison in TypeScript\nDESCRIPTION: Example demonstrating how to use the lessThan function to compare BigInt values. Shows three cases: comparing smaller, equal, and larger values.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/BigInt-lessThan.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { lessThan } from \"effect/BigInt\"\n\nassert.deepStrictEqual(lessThan(2n, 3n), true)\nassert.deepStrictEqual(lessThan(3n, 3n), false)\nassert.deepStrictEqual(lessThan(4n, 3n), false)\n```\n\n----------------------------------------\n\nTITLE: Setting TestClock Time using Effect Library in TypeScript\nDESCRIPTION: This TypeScript snippet declares the `setTime` function, allowing users to set the time on a `TestClock` instance. It accepts a `DateTime.DateTime.Input` as input and performs scheduled actions up to that new time. Essential dependency includes the Effect library.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TestClock-setTime.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const setTime: (input: DateTime.DateTime.Input) => Effect.Effect<void>\n```\n\n----------------------------------------\n\nTITLE: Defining Repeat Forever Functionality in TypeScript\nDESCRIPTION: This snippet declares a constant named `repeatForever`, which is an alias for a scheduling method that executes indefinitely. It utilizes TypeScript's type system to define specific generics for the scheduling function.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Schedule-repeatForever.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const repeatForever: Schedule<number, unknown, never>\n```\n\n----------------------------------------\n\nTITLE: Converting Effect Stream to ReadableStream Type Definition\nDESCRIPTION: TypeScript type definition for the toReadableStream function that converts an Effect Stream to a Web API ReadableStream. The function accepts optional queuing strategy configuration and handles generic type parameters for stream values and errors.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-toReadableStream.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const toReadableStream: { <A>(options?: { readonly strategy?: QueuingStrategy<A> | undefined; }): <E>(self: Stream<A, E>) => ReadableStream<A>; <A, E>(self: Stream<A, E>, options?: { readonly strategy?: QueuingStrategy<A> | undefined; }): ReadableStream<A>; }\n```\n\n----------------------------------------\n\nTITLE: Zipping Sinks with zipRight in Effect\nDESCRIPTION: The `zipRight` function combines two `Sink` instances. The function returns a new `Sink` that processes the inputs of both original sinks (`self` and `that`).  The returned sink only returns the result of the `that` sink. It takes an optional `concurrent` option to determine if the sinks should run concurrently.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Sink-zipRight.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const zipRight: { <A2, In, In2 extends In, L2, E2, R2>(that: Sink<A2, In2, L2, E2, R2>, options?: { readonly concurrent?: boolean | undefined; } | undefined): <A, L, E, R>(self: Sink<A, In, L, E, R>) => Sink<A2, In & In2, L2 | L, E2 | E, R2 | R>; <A, In, L, E, R, A2, In2 extends In, L2, E2, R2>(self: Sink<A, In, L, E, R>, that: Sink<A2, In2, L2, E2, R2>, options?: { readonly concurrent?: boolean | undefined; } | undefined): Sink<A2, In & In2, L | L2, E | E2, R | R2>; }\n```\n\n----------------------------------------\n\nTITLE: Using Context.getOption to retrieve tagged values in TypeScript\nDESCRIPTION: This example demonstrates how to use Context.getOption to retrieve values from a context using tags. It creates generic tags for Port and Timeout, constructs a context with only the Port tag, and then shows how getOption returns Some when the tag exists and None when it doesn't.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Context-getOption.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { Context, Option } from \"effect\"\n\nconst Port = Context.GenericTag<{ PORT: number }>(\"Port\")\nconst Timeout = Context.GenericTag<{ TIMEOUT: number }>(\"Timeout\")\n\nconst Services = Context.make(Port, { PORT: 8080 })\n\nassert.deepStrictEqual(Context.getOption(Services, Port), Option.some({ PORT: 8080 }))\nassert.deepStrictEqual(Context.getOption(Services, Timeout), Option.none())\n```\n\n----------------------------------------\n\nTITLE: Checking Key Existence in Trie using Effect Library in TypeScript\nDESCRIPTION: This snippet demonstrates how to use the Trie.has function to check for the existence of keys in a Trie data structure. It creates a Trie with multiple key-value pairs and then checks for the presence of various keys.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Trie-has.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { Trie } from \"effect\"\n\nconst trie = Trie.empty<number>().pipe(\n  Trie.insert(\"call\", 0),\n  Trie.insert(\"me\", 1),\n  Trie.insert(\"mind\", 2),\n  Trie.insert(\"mid\", 3)\n)\n\nassert.equal(Trie.has(trie, \"call\"), true)\nassert.equal(Trie.has(trie, \"me\"), true)\nassert.equal(Trie.has(trie, \"mind\"), true)\nassert.equal(Trie.has(trie, \"mid\"), true)\nassert.equal(Trie.has(trie, \"cale\"), false)\nassert.equal(Trie.has(trie, \"ma\"), false)\nassert.equal(Trie.has(trie, \"midn\"), false)\nassert.equal(Trie.has(trie, \"mea\"), false)\n```\n\n----------------------------------------\n\nTITLE: Retrieving Command Exit Code in Effect Platform\nDESCRIPTION: Function that returns the exit code of a command after the process has completed execution. It uses Effect to handle the operation and can result in a PlatformError if the command fails.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Command-exitCode.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const exitCode: (self: Command) => Effect<ExitCode, PlatformError, CommandExecutor>\n```\n\n----------------------------------------\n\nTITLE: Flattening Commands in TypeScript\nDESCRIPTION: The flatten function takes a Command and returns a non-empty array of StandardCommands. For StandardCommands, it returns a single-element array. For PipedCommands, it extracts all commands in the pipe into an array from left to right.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Command-flatten.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const flatten: (self: Command) => NonEmptyReadonlyArray<StandardCommand>\n```\n\n----------------------------------------\n\nTITLE: Using Effect.whenEffect with Random Values in TypeScript\nDESCRIPTION: Example showing how to use whenEffect to conditionally execute a random number generation effect based on a random boolean condition. The result is wrapped in an Option type.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-whenEffect.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Effect, Random } from \"effect\"\n\nconst randomIntOption = Random.nextInt.pipe(\n  Effect.whenEffect(Random.nextBoolean)\n)\n\nconsole.log(Effect.runSync(randomIntOption))\n// Example Output:\n// { _id: 'Option', _tag: 'Some', value: 8609104974198840 }\n```\n\n----------------------------------------\n\nTITLE: Creating Single-Value Sink from Effect in TypeScript\nDESCRIPTION: The `fromEffect` function creates a single-value sink produced from an effect. It takes an effect and returns a sink that can consume a single value of type A, with error type E and environment type R.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Sink-fromEffect.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const fromEffect: <A, E, R>(effect: Effect.Effect<A, E, R>) => Sink<A, unknown, never, E, R>\n```\n\n----------------------------------------\n\nTITLE: Implementing Channel Concatenation with Custom Merging in TypeScript\nDESCRIPTION: Defines a function that concatenates channels by feeding outputs to a factory function, using custom strategies for merging terminal values and handling upstream/downstream operations. The function supports complex type parameters for handling various input/output elements, errors, and environments.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Channel-concatMapWithCustom.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const concatMapWithCustom: { <OutElem, OutElem2, InElem2, OutErr2, InErr2, OutDone, InDone2, Env2, OutDone2, OutDone3>(f: (o: OutElem) => Channel<OutElem2, InElem2, OutErr2, InErr2, OutDone, InDone2, Env2>, g: (o: OutDone, o1: OutDone) => OutDone, h: (o: OutDone, o2: OutDone2) => OutDone3, onPull: (upstreamPullRequest: UpstreamPullRequest.UpstreamPullRequest<OutElem>) => UpstreamPullStrategy.UpstreamPullStrategy<OutElem2>, onEmit: (elem: OutElem2) => ChildExecutorDecision.ChildExecutorDecision): <Env, InErr, InElem, InDone, OutErr>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone2, InDone, Env>) => Channel<OutElem2, InElem & InElem2, OutErr2 | OutErr, InErr & InErr2, OutDone3, InDone & InDone2, Env2 | Env>; <OutElem, InElem, OutErr, InErr, OutDone2, InDone, Env, OutElem2, InElem2, OutErr2, InErr2, OutDone, InDone2, Env2, OutDone3>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone2, InDone, Env>, f: (o: OutElem) => Channel<OutElem2, InElem2, OutErr2, InErr2, OutDone, InDone2, Env2>, g: (o: OutDone, o1: OutDone) => OutDone, h: (o: OutDone, o2: OutDone2) => OutDone3, onPull: (upstreamPullRequest: UpstreamPullRequest.UpstreamPullRequest<OutElem>) => UpstreamPullStrategy.UpstreamPullStrategy<OutElem2>, onEmit: (elem: OutElem2) => ChildExecutorDecision.ChildExecutorDecision): Channel<OutElem2, InElem & InElem2, OutErr | OutErr2, InErr & InErr2, OutDone3, InDone & InDone2, Env | Env2>; }\n```\n\n----------------------------------------\n\nTITLE: Defining Sink.dimapEffect Transformation\nDESCRIPTION: A higher-order function that allows effectful transformations of sink inputs and results. Provides flexibility in modifying input types and processing results within the Effect ecosystem.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Sink-dimapEffect.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const dimapEffect: { <In0, In, E2, R2, A, A2, E3, R3>(options: { readonly onInput: (input: In0) => Effect.Effect<In, E2, R2>; readonly onDone: (a: A) => Effect.Effect<A2, E3, R3>; }): <L, E, R>(self: Sink<A, In, L, E, R>) => Sink<A2, In0, L, E2 | E3 | E, R2 | R3 | R>; <A, In, L, E, R, In0, E2, R2, A2, E3, R3>(self: Sink<A, In, L, E, R>, options: { readonly onInput: (input: In0) => Effect.Effect<In, E2, R2>; readonly onDone: (a: A) => Effect.Effect<A2, E3, R3>; }): Sink<A2, In0, L, E | E2 | E3, R | R2 | R3>; }\n```\n\n----------------------------------------\n\nTITLE: Removing Entries from TSet in TypeScript\nDESCRIPTION: The `removeIf` function is designed to remove entries from a `TSet` data structure based on a given predicate. It offers an option to either discard the removed items or return them. The function relies on the `Predicate` type for specifying conditions and includes options for configuring the return type. It requires the `STM` module for state management. The expected input is a `TSet` and a predicate, and the output can be either `void` or an `Array` depending on the chosen option.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TSet-removeIf.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const removeIf: { <A>(predicate: Predicate<A>, options: { readonly discard: true; }): (self: TSet<A>) => STM.STM<void>; <A>(predicate: Predicate<A>, options?: { readonly discard: false; }): (self: TSet<A>) => STM.STM<Array<A>>; <A>(self: TSet<A>, predicate: Predicate<A>, options: { readonly discard: true; }): STM.STM<void>; <A>(self: TSet<A>, predicate: Predicate<A>, options?: { readonly discard: false; }): STM.STM<Array<A>>; }\n```\n\n----------------------------------------\n\nTITLE: Initializing Semigroup Union for Records in TypeScript\nDESCRIPTION: This code demonstrates the usage of `getSemigroupUnion` from the `@effect/typeclass/data/Record` module to create a semigroup that combines two records. The `MonoidSum` from `@effect/typeclass/data/Number` is used to sum the values of matching keys. If a key exists only in one record, it is included in the result.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/data-Record-getSemigroupUnion.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as NumberInstances from \"@effect/typeclass/data/Number\"\nimport { getSemigroupUnion } from \"@effect/typeclass/data/Record\"\n\nconsole.log(getSemigroupUnion(NumberInstances.MonoidSum).combine({ a: 1 }, { a: 1, b: 3 }))\n// { a: 2, b: 3 }\n```\n\n----------------------------------------\n\nTITLE: Declaring the yieldNow function in TypeScript for the Micro module\nDESCRIPTION: Defines the yieldNow function that pauses the execution of the current Micro effect and resumes it on the next scheduler tick. It returns a Micro effect that resolves to void and never produces an error.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Micro-yieldNow.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const yieldNow: Micro<void, never, never>\n```\n\n----------------------------------------\n\nTITLE: Declaring SemigroupMax Signature\nDESCRIPTION: This snippet declares the type signature for the SemigroupMax instance within the @effect/typeclass package. It specifies that SemigroupMax conforms to the semigroup.Semigroup interface, specifically for the number type, establishing its role in combining two numbers to return the larger one.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/data-Number-SemigroupMax.md#2025-04-11_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const SemigroupMax: semigroup.Semigroup<number>\n```\n\n----------------------------------------\n\nTITLE: Defining Parallel Execution Strategy in TypeScript\nDESCRIPTION: Declares a function parallelN that creates an ExecutionStrategy for executing effects in parallel with a specified concurrency limit. It takes a number parameter to set the maximum number of concurrent fibers.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/ExecutionStrategy-parallelN.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const parallelN: (parallelism: number) => ExecutionStrategy\n```\n\n----------------------------------------\n\nTITLE: Effect.all Function Signature in TypeScript\nDESCRIPTION: The TypeScript function signature for Effect.all, showing its parameter types and return type. The function accepts an iterable or record of effects along with optional configuration parameters.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-all.md#2025-04-11_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const all: <const Arg extends Iterable<Effect<any, any, any>> | Record<string, Effect<any, any, any>>, O extends NoExcessProperties<{ readonly concurrency?: Concurrency | undefined; readonly batching?: boolean | \"inherit\" | undefined; readonly discard?: boolean | undefined; readonly mode?: \"default\" | \"validate\" | \"either\" | undefined; readonly concurrentFinalizers?: boolean | undefined; }, O>>(arg: Arg, options?: O) => All.Return<Arg, O>\n```\n\n----------------------------------------\n\nTITLE: Applying Functions to HashMap Entries with forEach in TypeScript\nDESCRIPTION: Implementation signature for the forEach function that applies a specified function to each entry in a HashMap collection. The function can be called in both fluent and pipeline styles.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/HashMap-forEach.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const forEach: { <V, K>(f: (value: V, key: K) => void): (self: HashMap<K, V>) => void; <V, K>(self: HashMap<K, V>, f: (value: V, key: K) => void): void; }\n```\n\n----------------------------------------\n\nTITLE: Transforming Configuration Path Names with ConfigProvider.mapInputPath in TypeScript\nDESCRIPTION: A function that returns a new config provider with transformed path configuration names. This enables adapting property names between different naming conventions. The function supports both curried and non-curried calling styles.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/ConfigProvider-mapInputPath.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const mapInputPath: { (f: (path: string) => string): (self: ConfigProvider) => ConfigProvider; (self: ConfigProvider, f: (path: string) => string): ConfigProvider; }\n```\n\n----------------------------------------\n\nTITLE: Combining Loggers with zip Function in TypeScript\nDESCRIPTION: The `zip` function combines two loggers to create a new logger that logs to both. It takes two Logger instances and returns a new Logger that combines their message types and outputs.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Logger-zip.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const zip: { <Message2, Output2>(that: Logger<Message2, Output2>): <Message, Output>(self: Logger<Message, Output>) => Logger<Message & Message2, [Output, Output2]>; <Message, Output, Message2, Output2>(self: Logger<Message, Output>, that: Logger<Message2, Output2>): Logger<Message & Message2, [Output, Output2]>; }\n```\n\n----------------------------------------\n\nTITLE: Generating Next Random Number with Effect in TypeScript\nDESCRIPTION: The next function returns the next numeric value from the pseudo-random number generator. It is an Effect that produces a number without any requirements or error possibilities.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Random-next.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const next: Effect.Effect<number, never, never>\n```\n\n----------------------------------------\n\nTITLE: Defining isChunk Function in TypeScript\nDESCRIPTION: Declares the isChunk function which checks if a given value is a Chunk<unknown>. It has two overloads: one for Iterable<A> and another for unknown types.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Chunk-isChunk.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const isChunk: { <A>(u: Iterable<A>): u is Chunk<A>; (u: unknown): u is Chunk<unknown>; }\n```\n\n----------------------------------------\n\nTITLE: Separating Either Values in Records with TypeScript\nDESCRIPTION: This snippet demonstrates how to partition a record of 'Either' values into two separate records using the 'separate' function from the 'effect' package. The 'Record.separate' method is employed to extract 'Left' and 'Right' values into distinct records. It expects a record with 'Either' values and outputs a tuple of two records, segmented by 'Left' and 'Right'.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Record-separate.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { Record, Either } from \"effect\"\n\nassert.deepStrictEqual(\n  Record.separate({ a: Either.left(\"e\"), b: Either.right(1) }),\n  [{ a: \"e\" }, { b: 1 }]\n)\n```\n\n----------------------------------------\n\nTITLE: Transforming Micro Effect to Option in TypeScript\nDESCRIPTION: Function signature for converting a Micro effect into an Option type. It wraps successful values in Some and returns None for expected errors, effectively transforming error handling into the Option monad pattern.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Micro-option.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const option: <A, E, R>(self: Micro<A, E, R>) => Micro<Option.Option<A>, never, R>\n```\n\n----------------------------------------\n\nTITLE: Defining Stream.provideServiceStream Function in TypeScript\nDESCRIPTION: This code snippet defines the provideServiceStream function in the Stream module. It allows providing a stream with a single required service. If multiple services are needed, Stream.provideContext should be used instead.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-provideServiceStream.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const provideServiceStream: { <I, S, E2, R2>(tag: Context.Tag<I, S>, stream: Stream<NoInfer<S>, E2, R2>): <A, E, R>(self: Stream<A, E, R>) => Stream<A, E2 | E, R2 | Exclude<R, I>>; <A, E, R, I, S, E2, R2>(self: Stream<A, E, R>, tag: Context.Tag<I, S>, stream: Stream<NoInfer<S>, E2, R2>): Stream<A, E2 | E, R2 | Exclude<R, I>>; }\n```\n\n----------------------------------------\n\nTITLE: Option.contains Signature\nDESCRIPTION: This snippet shows the type declaration of the `Option.contains` function. It defines the function's input parameters and return type, providing a clear understanding of its signature.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Option-contains.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const contains: { <A>(a: A): (self: Option<A>) => boolean; <A>(self: Option<A>, a: A): boolean; }\n```\n\n----------------------------------------\n\nTITLE: Using isNonEmptyArray Function in TypeScript\nDESCRIPTION: Demonstrates how to use the isNonEmptyArray function to check if an array contains at least one element. The function acts as a type guard, narrowing the type to NonEmptyArray when true.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Array-isNonEmptyArray.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Array } from \"effect\"\n\nconsole.log(Array.isNonEmptyArray([])) // false\nconsole.log(Array.isNonEmptyArray([1, 2, 3])) // true\n```\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const isNonEmptyArray: <A>(self: Array<A>) => self is NonEmptyArray<A>\n```\n\n----------------------------------------\n\nTITLE: Defining BaseQueue Interface for Queue Implementations in TypeScript\nDESCRIPTION: This code snippet defines the BaseQueue interface, which serves as the foundation for all Queue implementations in the Effect library. It includes methods for checking capacity, size, activity status, and managing the queue's lifecycle.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Queue-BaseQueue.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface BaseQueue {\n  /**\n   * Returns the number of elements the queue can hold.\n   */\n  capacity(): number\n\n  /**\n   * Returns false if shutdown has been called.\n   */\n  isActive(): boolean\n\n  /**\n   * Retrieves the size of the queue, which is equal to the number of elements\n   * in the queue. This may be negative if fibers are suspended waiting for\n   * elements to be added to the queue.\n   */\n  readonly size: Effect.Effect<number>\n\n  /**\n   * Retrieves the size of the queue, which is equal to the number of elements\n   * in the queue. This may be negative if fibers are suspended waiting for\n   * elements to be added to the queue. Returns None if shutdown has been called\n   */\n  unsafeSize(): Option.Option<number>\n\n  /**\n   * Returns `true` if the `Queue` contains at least one element, `false`\n   * otherwise.\n   */\n  readonly isFull: Effect.Effect<boolean>\n\n  /**\n   * Returns `true` if the `Queue` contains zero elements, `false` otherwise.\n   */\n  readonly isEmpty: Effect.Effect<boolean>\n\n  /**\n   * Interrupts any fibers that are suspended on `offer` or `take`. Future calls\n   * to `offer*` and `take*` will be interrupted immediately.\n   */\n  readonly shutdown: Effect.Effect<void>\n\n  /**\n   * Returns `true` if `shutdown` has been called, otherwise returns `false`.\n   */\n  readonly isShutdown: Effect.Effect<boolean>\n\n  /**\n   * Waits until the queue is shutdown. The `Effect` returned by this method will\n   * not resume until the queue has been shutdown. If the queue is already\n   * shutdown, the `Effect` will resume right away.\n   */\n  readonly awaitShutdown: Effect.Effect<void>\n}\n```\n\n----------------------------------------\n\nTITLE: Formatting DateTime Objects as UTC Strings in TypeScript\nDESCRIPTION: The formatUtc function formats a DateTime object as a string using the Intl.DateTimeFormat API, forcing the time zone to be UTC. It supports two call signatures: one that returns a formatting function and another that directly formats a DateTime object.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/DateTime-formatUtc.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const formatUtc: { (options?: (Intl.DateTimeFormatOptions & { readonly locale?: string | undefined; }) | undefined): (self: DateTime) => string; (self: DateTime, options?: (Intl.DateTimeFormatOptions & { readonly locale?: string | undefined; }) | undefined): string; }\n```\n\n----------------------------------------\n\nTITLE: Effect.ensuring Type Signature in TypeScript\nDESCRIPTION: The TypeScript type signature for the Effect.ensuring function, showing its overloaded implementation with type parameters for different scenarios. It supports both curried and non-curried calling patterns.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-ensuring.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const ensuring: { <X, R1>(finalizer: Effect<X, never, R1>): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R1 | R>; <A, E, R, X, R1>(self: Effect<A, E, R>, finalizer: Effect<X, never, R1>): Effect<A, E, R1 | R>; }\n```\n\n----------------------------------------\n\nTITLE: Creating Redacted Values with Redacted.make in TypeScript\nDESCRIPTION: Demonstrates how to create a Redacted instance to securely hide sensitive values like API keys. The function takes any value of type A and returns a Redacted<A> instance that prevents the value from being exposed in logs or string representations.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Redacted-make.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Redacted } from \"effect\"\n\nconst API_KEY = Redacted.make(\"1234567890\")\n```\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const make: <A>(value: A) => Redacted<A>\n```\n\n----------------------------------------\n\nTITLE: Creating Empty HashMap in Effect TypeScript Library\nDESCRIPTION: Creates a new empty HashMap instance. This function initializes an empty map with generically typed keys and values, allowing for type-safe collections.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/HashMap-empty.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const empty: <K = never, V = never>() => HashMap<K, V>\n```\n\n----------------------------------------\n\nTITLE: Capturing FiberRef Changes in Effect Workflows in TypeScript\nDESCRIPTION: A utility function that returns a new workflow which executes an original Effect and captures the changes in FiberRef values. The function returns both the FiberRefsPatch (representing changes) and the original Effect's result.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-diffFiberRefs.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const diffFiberRefs: <A, E, R>(self: Effect<A, E, R>) => Effect<[FiberRefsPatch.FiberRefsPatch, A], E, R>\n```\n\n----------------------------------------\n\nTITLE: Defining orElseEither Function in TypeScript\nDESCRIPTION: The orElseEither function is declared to return a transactional effect which favors the left side unless the left side fails. In such cases, it defaults to the specified right side effect. This is useful for robust error handling in transactional contexts, returning an Either type encapsulating the results.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/STM-orElseEither.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const orElseEither: { <A2, E2, R2>(that: LazyArg<STM<A2, E2, R2>>): <A, E, R>(self: STM<A, E, R>) => STM<Either.Either<A2, A>, E2, R2 | R>; <A, E, R, A2, E2, R2>(self: STM<A, E, R>, that: LazyArg<STM<A2, E2, R2>>): STM<Either.Either<A2, A>, E2, R | R2>; };\n```\n\n----------------------------------------\n\nTITLE: Generating Random Integers in a Range with TRandom.nextIntBetween in TypeScript\nDESCRIPTION: The nextIntBetween function returns the next integer within a specified range (from low to high) from a transactional pseudo-random number generator. It returns an STM (Software Transactional Memory) effect that produces a number.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TRandom-nextIntBetween.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const nextIntBetween: (low: number, high: number) => STM.STM<number, never, TRandom>\n```\n\n----------------------------------------\n\nTITLE: Prepending Elements to Iterable in TypeScript\nDESCRIPTION: Demonstrates how to use the Iterable.prependAll function to prepend elements from one iterable to another. The function takes two iterables and returns a new iterable with the elements from the second iterable followed by the elements from the first.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Iterable-prependAll.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { Iterable } from \"effect\"\n\nassert.deepStrictEqual(\n  Array.from(Iterable.prependAll([1, 2], [\"a\", \"b\"])),\n  [\"a\", \"b\", 1, 2]\n)\n```\n\n----------------------------------------\n\nTITLE: Mapping Exit Success/Failure Types in TypeScript\nDESCRIPTION: Function declaration for mapBoth that allows mapping both success and failure cases of an Exit type. It supports both curried and direct application patterns, taking transformation functions for both error and success scenarios.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Exit-mapBoth.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const mapBoth: { <E, A, E2, A2>(options: { readonly onFailure: (e: E) => E2; readonly onSuccess: (a: A) => A2; }): (self: Exit<A, E>) => Exit<A2, E2>; <A, E, E2, A2>(self: Exit<A, E>, options: { readonly onFailure: (e: E) => E2; readonly onSuccess: (a: A) => A2; }): Exit<A2, E2>; }\n```\n\n----------------------------------------\n\nTITLE: Transforming a ConfigProvider within a Specific Path in TypeScript\nDESCRIPTION: This function returns a new config provider that transforms the original provider with a specified function within a given path. It provides both curried and uncurried versions for flexibility in usage patterns.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/ConfigProvider-within.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const within: { (path: ReadonlyArray<string>, f: (self: ConfigProvider) => ConfigProvider): (self: ConfigProvider) => ConfigProvider; (self: ConfigProvider, path: ReadonlyArray<string>, f: (self: ConfigProvider) => ConfigProvider): ConfigProvider; }\n```\n\n----------------------------------------\n\nTITLE: Implementing Timeout with Fallback in Effect Micro Module\nDESCRIPTION: The timeoutOrElse method returns an effect that will timeout the original effect and execute a fallback if the timeout elapses before producing a value. It safely interrupts the running effect if the timeout occurs.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Micro-timeoutOrElse.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const timeoutOrElse: { <A2, E2, R2>(options: { readonly duration: number; readonly onTimeout: LazyArg<Micro<A2, E2, R2>>; }): <A, E, R>(self: Micro<A, E, R>) => Micro<A | A2, E | E2, R | R2>; <A, E, R, A2, E2, R2>(self: Micro<A, E, R>, options: { readonly duration: number; readonly onTimeout: LazyArg<Micro<A2, E2, R2>>; }): Micro<A | A2, E | E2, R | R2>; }\n```\n\n----------------------------------------\n\nTITLE: Implementing NDJSON Serialization Layer for RPC in TypeScript\nDESCRIPTION: A RPC serialization layer that uses NDJSON format for message serialization. This layer is recommended when the protocol doesn't support message framing, otherwise the layerJson option is preferable.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/RpcSerialization-layerNdjson.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const layerNdjson: Layer.Layer<RpcSerialization, never, never>\n```\n\n----------------------------------------\n\nTITLE: Creating a Schedule for a Specific Minute of the Hour - Effect\nDESCRIPTION: The `minuteOfHour` function creates a schedule that recurs every specified minute of each hour. The schedule triggers once per hour at the specified `minute`, starting exactly at `minute:00` (zero seconds). It produces a count of executions, representing how many times it has run.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Schedule-minuteOfHour.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const minuteOfHour: (minute: number) => Schedule<number>\n```\n\n----------------------------------------\n\nTITLE: Merging Streams with Defined Concurrency in TypeScript\nDESCRIPTION: This TypeScript code snippet defines the mergeAll method within the Effect-TS library, designed to merge several streams concurrently. The function accepts options to specify the concurrency level, allowing either a number or the term 'unbounded', and an optional bufferSize. The primary purpose is to control how many streams can run in parallel, optimizing performance and resource usage.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-mergeAll.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const mergeAll: { (options: { readonly concurrency: number | \"unbounded\"; readonly bufferSize?: number | undefined; }): <A, E, R>(streams: Iterable<Stream<A, E, R>>) => Stream<A, E, R>; <A, E, R>(streams: Iterable<Stream<A, E, R>>, options: { readonly concurrency: number | \"unbounded\"; readonly bufferSize?: number | undefined; }): Stream<A, E, R>; }\n```\n\n----------------------------------------\n\nTITLE: Creating Gauge Metrics in TypeScript using Effect Library\nDESCRIPTION: Demonstrates how to create gauge metrics using the Metric.gauge function from the Effect library. It shows examples of creating both number and bigint gauges with descriptions.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Metric-gauge.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Metric } from \"effect\"\n\nconst numberGauge = Metric.gauge(\"memory_usage\", {\n  description: \"A gauge for memory usage\"\n});\n\nconst bigintGauge = Metric.gauge(\"cpu_load\", {\n  description: \"A gauge for CPU load\",\n  bigint: true\n});\n```\n\n----------------------------------------\n\nTITLE: Retrieving First Element from a ReadonlyArray in TypeScript\nDESCRIPTION: The head function gets the first element of a ReadonlyArray and returns it wrapped in an Option type. If the array is empty, it returns None. This provides a safe way to access the first element without encountering undefined errors.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Array-head.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const head: <A>(self: ReadonlyArray<A>) => Option.Option<A>\n```\n\n----------------------------------------\n\nTITLE: Basic Usage of the pipe Function in Effect Library\nDESCRIPTION: Example showing the basic syntax and usage pattern of the pipe function. It demonstrates how to chain function calls in a sequential manner.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Function-pipe.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { pipe } from \"effect\"\n\nconst result = pipe(input, func1, func2, ..., funcN)\n```\n\n----------------------------------------\n\nTITLE: Defining mergeLeft Function for Stream Merging in TypeScript\nDESCRIPTION: Declares a function that merges two streams, keeping values from the left stream and discarding values from the right stream. It supports both curried and non-curried function calls.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-mergeLeft.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const mergeLeft: { <AR, ER, RR>(right: Stream<AR, ER, RR>): <AL, EL, RL>(left: Stream<AL, EL, RL>) => Stream<AL, ER | EL, RR | RL>; <AL, EL, RL, AR, ER, RR>(left: Stream<AL, EL, RL>, right: Stream<AR, ER, RR>): Stream<AL, EL | ER, RL | RR>; }\n```\n\n----------------------------------------\n\nTITLE: Deduplicating Adjacent Elements in a Chunk (TypeScript)\nDESCRIPTION: A function that removes consecutive duplicate elements from a Chunk data structure. It preserves the original order while ensuring that identical adjacent elements are reduced to a single occurrence.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Chunk-dedupeAdjacent.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const dedupeAdjacent: <A>(self: Chunk<A>) => Chunk<A>\n```\n\n----------------------------------------\n\nTITLE: Mapping Effect Error to Option.Some in TypeScript\nDESCRIPTION: This function transforms the error channel of an Effect into an Option type. If an error occurs, it wraps the error in Some; if the effect succeeds, the success value passes through unchanged.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-asSomeError.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const asSomeError: <A, E, R>(self: Effect<A, E, R>) => Effect<A, Option.Option<E>, R>\n```\n\n----------------------------------------\n\nTITLE: Removing Duplicates from a Chunk in TypeScript\nDESCRIPTION: The dedupe function removes duplicate elements from a Chunk, keeping only the first occurrence of each element. It takes a Chunk of type A as input and returns a new Chunk of the same type with duplicates removed.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Chunk-dedupe.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const dedupe: <A>(self: Chunk<A>) => Chunk<A>\n```\n\n----------------------------------------\n\nTITLE: Type Signature for repeatOrElse Function in Effect-TS\nDESCRIPTION: The type signature for the repeatOrElse function in the Effect-TS library. It shows the function's polymorphic nature and how it handles different type parameters for the effect, schedule, and error handler.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-repeatOrElse.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const repeatOrElse: { <R2, A, B, E, E2, R3>(schedule: Schedule.Schedule<B, A, R2>, orElse: (error: E, option: Option.Option<B>) => Effect<B, E2, R3>): <R>(self: Effect<A, E, R>) => Effect<B, E2, R2 | R3 | R>; <A, E, R, R2, B, E2, R3>(self: Effect<A, E, R>, schedule: Schedule.Schedule<B, A, R2>, orElse: (error: E, option: Option.Option<B>) => Effect<B, E2, R3>): Effect<B, E2, R | R2 | R3>; }\n```\n\n----------------------------------------\n\nTITLE: Transforming Sink Input Chunks in TypeScript using Effect-TS\nDESCRIPTION: The mapInputChunks function transforms a sink's input chunks using a provided transformation function. The transformation must preserve chunking-invariance. It supports both curried and data-last style invocations.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Sink-mapInputChunks.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const mapInputChunks: { <In0, In>(f: (chunk: Chunk.Chunk<In0>) => Chunk.Chunk<In>): <A, L, E, R>(self: Sink<A, In, L, E, R>) => Sink<A, In0, L, E, R>; <A, In, L, E, R, In0>(self: Sink<A, In, L, E, R>, f: (chunk: Chunk.Chunk<In0>) => Chunk.Chunk<In>): Sink<A, In0, L, E, R>; }\n```\n\n----------------------------------------\n\nTITLE: Transform TArray elements atomically with transactional effect (Effect-TS, TypeScript)\nDESCRIPTION: The `transformSTM` function atomically updates each element of a `TArray` by applying a transactional effect (`STM`). It takes a function `f` that transforms each element `A` into an `STM` effect. The effect is performed transactionally, ensuring atomicity and consistency.  The function has two call signatures, allowing for curried or direct application.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TArray-transformSTM.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const transformSTM: { <A, R, E>(f: (value: A) => STM.STM<A, E, R>): (self: TArray<A>) => STM.STM<void, E, R>; <A, R, E>(self: TArray<A>, f: (value: A) => STM.STM<A, E, R>): STM.STM<void, E, R>; }\n```\n\n----------------------------------------\n\nTITLE: Interleaving Streams in TypeScript using Effect\nDESCRIPTION: Demonstrates how to use Stream.interleave to alternate values from two streams. The function combines two streams by pulling values alternately until both are exhausted.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-interleave.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Effect, Stream } from \"effect\"\n\nconst s1 = Stream.make(1, 2, 3)\nconst s2 = Stream.make(4, 5, 6)\n\nconst stream = Stream.interleave(s1, s2)\n\nEffect.runPromise(Stream.runCollect(stream)).then(console.log)\n// { _id: 'Chunk', values: [ 1, 4, 2, 5, 3, 6 ] }\n```\n\n----------------------------------------\n\nTITLE: Using Effect.withTracerEnabled to Disable Tracer in TypeScript\nDESCRIPTION: This snippet demonstrates how to disable the tracer for an Effect operation with a span. The span 'my-span' will not be registered with the tracer because the tracer is explicitly disabled.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-withTracerEnabled.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Effect } from \"effect\"\n\nEffect.succeed(42).pipe(\n  Effect.withSpan(\"my-span\"),\n  // the span will not be registered with the tracer\n  Effect.withTracerEnabled(false)\n)\n```\n\n----------------------------------------\n\nTITLE: Implementing Success Tracking in Effect Metric\nDESCRIPTION: Defines a method that creates an aspect to monitor and update metrics based on the success values of applied effects. The method supports both curried and uncurried function signatures for flexibility in usage.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Metric-trackSuccess.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const trackSuccess: { \n  <Type, In, Out>(metric: Metric<Type, In, Out>): <A extends In, E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>; \n  <A extends In, E, R, Type, In, Out>(self: Effect.Effect<A, E, R>, metric: Metric<Type, In, Out>): Effect.Effect<A, E, R>; \n}\n```\n\n----------------------------------------\n\nTITLE: Omitting Properties from Object Using Effect TS\nDESCRIPTION: This snippet demonstrates the usage of the Struct.omit function from the Effect library to create a new object by omitting specified properties from an existing object. It includes two assertions to verify the expected output after omitting the property 'c' from an object with properties 'a', 'b', and 'c'. The output is checked against the expected result to ensure correctness.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Struct-omit.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { pipe, Struct } from \"effect\"\n\nassert.deepStrictEqual(pipe({ a: \"a\", b: 1, c: true }, Struct.omit(\"c\")), { a: \"a\", b: 1 })\nassert.deepStrictEqual(Struct.omit({ a: \"a\", b: 1, c: true }, \"c\"), { a: \"a\", b: 1 })\n```\n\n----------------------------------------\n\nTITLE: Transforming Schemas with Effect-TS in TypeScript\nDESCRIPTION: The `transformOrFail` function allows creating a new schema by transforming the input and output of an existing schema using specified decoding and encoding functions. It relies on the Effect-TS framework and requires schema types, parse options, and transformation AST. The function provides options for strict or non-strict mode, influencing error handling during transformations. The inputs to the decode/encode functions are dependent on the schema type and can result in different transformation effects.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Schema-transformOrFail.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const transformOrFail: { <To extends Schema.Any, From extends Schema.Any, RD, RE>(to: To, options: { readonly decode: (fromA: Schema.Type<From>, options: ParseOptions, ast: AST.Transformation, fromI: Schema.Encoded<From>) => Effect.Effect<Schema.Encoded<To>, ParseResult.ParseIssue, RD>; readonly encode: (toI: Schema.Encoded<To>, options: ParseOptions, ast: AST.Transformation, toA: Schema.Type<To>) => Effect.Effect<Schema.Type<From>, ParseResult.ParseIssue, RE>; readonly strict?: true; } | { readonly decode: (fromA: Schema.Type<From>, options: ParseOptions, ast: AST.Transformation, fromI: Schema.Encoded<From>) => Effect.Effect<unknown, ParseResult.ParseIssue, RD>; readonly encode: (toI: Schema.Encoded<To>, options: ParseOptions, ast: AST.Transformation, toA: Schema.Type<To>) => Effect.Effect<unknown, ParseResult.ParseIssue, RE>; readonly strict: false; }): (from: From) => transformOrFail<From, To, RD | RE>; <To extends Schema.Any, From extends Schema.Any, RD, RE>(from: From, to: To, options: { readonly decode: (fromA: Schema.Type<From>, options: ParseOptions, ast: AST.Transformation, fromI: Schema.Encoded<From>) => Effect.Effect<Schema.Encoded<To>, ParseResult.ParseIssue, RD>; readonly encode: (toI: Schema.Encoded<To>, options: ParseOptions, ast: AST.Transformation, toA: Schema.Type<To>) => Effect.Effect<Schema.Type<From>, ParseResult.ParseIssue, RE>; readonly strict?: true; } | { readonly decode: (fromA: Schema.Type<From>, options: ParseOptions, ast: AST.Transformation, fromI: Schema.Encoded<From>) => Effect.Effect<unknown, ParseResult.ParseIssue, RD>; readonly encode: (toI: Schema.Encoded<To>, options: ParseOptions, ast: AST.Transformation, toA: Schema.Type<To>) => Effect.Effect<unknown, ParseResult.ParseIssue, RE>; readonly strict: false; }): transformOrFail<From, To, RD | RE>; }\n```\n\n----------------------------------------\n\nTITLE: Using Effect.replicate with Console Output in TypeScript\nDESCRIPTION: Demonstrates how to use Effect.replicate to create and execute multiple copies of an effect that logs to the console. Shows creating a basic effect, replicating it 3 times, and running each replicated effect in sequence.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-replicate.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Console, Effect } from \"effect\"\n\nconst task = Effect.succeed(\"Hello, World!\").pipe(\n  Effect.tap(Console.log)\n)\n\nconst program = Effect.gen(function*() {\n  // Replicate the task 3 times\n  const tasks = Effect.replicate(task, 3)\n  for (const t of tasks) {\n    // Run each task\n    yield* t\n  }\n})\n\nEffect.runFork(program)\n// Output:\n// Hello, World!\n// Hello, World!\n// Hello, World!\n```\n\n----------------------------------------\n\nTITLE: Creating HTTP API Handlers using HttpApiBuilder.group in TypeScript\nDESCRIPTION: The group function creates a Layer that implements all endpoints in an HttpApi. It provides a handler implementation pattern where unimplemented Handlers are passed to a build function for implementation. Endpoints can be implemented using the handlers.handle API.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/HttpApiBuilder-group.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const group: <ApiId extends string, Groups extends HttpApiGroup.HttpApiGroup.Any, ApiError, ApiR, const Name extends HttpApiGroup.HttpApiGroup.Name<Groups>, Return>(api: HttpApi.HttpApi<ApiId, Groups, ApiError, ApiR>, groupName: Name, build: (handlers: Handlers.FromGroup<ApiError, ApiR, HttpApiGroup.HttpApiGroup.WithName<Groups, Name>>) => Handlers.ValidateReturn<Return>) => Layer.Layer<HttpApiGroup.ApiGroup<ApiId, Name>, Handlers.Error<Return>, Exclude<Handlers.Context<Return> | HttpApiGroup.HttpApiGroup.MiddlewareWithName<Groups, Name>, Scope>>\n```\n\n----------------------------------------\n\nTITLE: Creating Arrays from Values with Array.ensure in TypeScript\nDESCRIPTION: The Array.ensure function creates a new array from a value that might not already be an array. It handles both single values and existing arrays, ensuring the output is always an array without unnecessary nesting.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Array-ensure.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Array } from \"effect\"\n\nconsole.log(Array.ensure(\"a\")) // [\"a\"]\nconsole.log(Array.ensure([\"a\"])) // [\"a\"]\nconsole.log(Array.ensure([\"a\", \"b\", \"c\"])) // [\"a\", \"b\", \"c\"]\n```\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const ensure: <A>(self: ReadonlyArray<A> | A) => Array<A>\n```\n\n----------------------------------------\n\nTITLE: Splitting Streams with Effect - TypeScript\nDESCRIPTION: This snippet demonstrates how to split a stream of numbers from 1 to 10 using the 'Stream.split' method provided by the Effect library. It splits the stream into chunks where the splitting criterion is defined by a predicate function that checks divisibility by 4. The example uses several functional programming utilities such as 'pipe', 'Stream.split', and 'Stream.runCollect'.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-split.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { pipe, Stream } from \\\"effect\\\"\n\npipe(\n  Stream.range(1, 10),\n  Stream.split((n) => n % 4 === 0),\n  Stream.runCollect\n)\n// => Chunk(Chunk(1, 2, 3), Chunk(5, 6, 7), Chunk(9))\n```\n\n----------------------------------------\n\nTITLE: Flattening Channel Terminal Values in TypeScript\nDESCRIPTION: The flatten function returns a new channel that flattens the terminal value of the input channel. It can only be called if the terminal value of the input channel is another channel with compatible types. This function combines the input and output elements, errors, and environments of both channels.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Channel-flatten.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const flatten: <OutElem, InElem, OutErr, InErr, OutElem1, InElem1, OutErr1, InErr1, OutDone2, InDone1, Env1, InDone, Env>(self: Channel<OutElem, InElem, OutErr, InErr, Channel<OutElem1, InElem1, OutErr1, InErr1, OutDone2, InDone1, Env1>, InDone, Env>) => Channel<OutElem | OutElem1, InElem & InElem1, OutErr | OutErr1, InErr & InErr1, OutDone2, InDone & InDone1, Env1 | Env>\n```\n\n----------------------------------------\n\nTITLE: Creating Unbounded Transactional PubSub in TypeScript\nDESCRIPTION: The `unbounded` function creates an unbounded transactional publish-subscribe channel. It returns an STM effect that produces a TPubSub instance that can handle messages of type A.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TPubSub-unbounded.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const unbounded: <A>() => STM.STM<TPubSub<A>>\n```\n\n----------------------------------------\n\nTITLE: Retrieving Runtime Flags in Effect\nDESCRIPTION: A function that returns an Effect which succeeds with the current runtime flags. These flags govern behavior and features of the runtime system.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-getRuntimeFlags.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const getRuntimeFlags: Effect<RuntimeFlags.RuntimeFlags, never, never>\n```\n\n----------------------------------------\n\nTITLE: Generating Random Boolean Values in TypeScript using Effect\nDESCRIPTION: This function returns the next boolean value from a pseudo-random number generator. It is part of the Random module in the effect package and returns an Effect that resolves to a boolean value.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Random-nextBoolean.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const nextBoolean: Effect.Effect<boolean, never, never>\n```\n\n----------------------------------------\n\nTITLE: Using HashSet.has Method in TypeScript\nDESCRIPTION: Demonstrates how to use the HashSet.has method to check if a value exists in a HashSet. The method has O(1) average time complexity and supports both data-first and data-last (pipeable) API styles.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/HashSet-has.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// Syntax\nimport { HashSet, pipe } from \"effect\"\n\n// with `data-last`, a.k.a. `pipeable` API\npipe(HashSet.make(0, 1, 2), HashSet.has(3)) // false\n\n// or piped with the pipe function\nHashSet.make(0, 1, 2).pipe(HashSet.has(3)) // false\n\n// or with `data-first` API\nHashSet.has(HashSet.make(0, 1, 2), 3) // false\n```\n\n----------------------------------------\n\nTITLE: Implementing Conditional Element Processing with Sink.forEachWhile in TypeScript\nDESCRIPTION: Creates a sink that executes a provided effectful function for each input element until the function returns false. This allows for conditional processing of a stream of elements.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Sink-forEachWhile.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const forEachWhile: <In, E, R>(f: (input: In) => Effect.Effect<boolean, E, R>) => Sink<void, In, In, E, R>\n```\n\n----------------------------------------\n\nTITLE: Pattern Matching with Option Module in TypeScript\nDESCRIPTION: The Option.match function enables pattern matching on an Option for handling both Some and None cases in a concise manner. When the Option is None, the onNone function is executed; when it is Some, the onSome function is run with the value. This functionality requires the effect library, specifically the Option module. The main parameters are the Option to be matched and the functions to handle each case (onNone and onSome). The expected input is an Option type and the return is the result from executing either onNone or onSome. The main constraint is the need for TypeScript support.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Option-match.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { Option } from \"effect\"\n\nconst foo = Option.some(1)\n\nconst message = Option.match(foo, {\n  onNone: () => \"Option is empty\",\n  onSome: (value) => `Option has a value: ${value}`\n})\n\nconsole.log(message)\n// Output: \"Option has a value: 1\"\n```\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const match: { <B, A, C = B>(options: { readonly onNone: LazyArg<B>; readonly onSome: (a: A) => C; }): (self: Option<A>) => B | C; <A, B, C = B>(self: Option<A>, options: { readonly onNone: LazyArg<B>; readonly onSome: (a: A) => C; }): B | C; }\n```\n\n----------------------------------------\n\nTITLE: Capturing Runtime for Fiber Management with FiberHandle.runtimePromise in TypeScript\nDESCRIPTION: This function captures a Runtime and uses it to fork Effect operations, adding the forked fibers to the FiberHandle. It returns a run function that produces Promises which resolve when the fiber completes. Available since version 3.13.0.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/FiberHandle-runtimePromise.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const runtimePromise: <A, E>(self: FiberHandle<A, E>) => <R = never>() => Effect.Effect<(<XE extends E, XA extends A>(effect: Effect.Effect<XA, XE, R>, options?: (Runtime.RunForkOptions & { readonly propagateInterruption?: boolean | undefined; }) | undefined) => Promise<XA>), never, R>\n```\n\n----------------------------------------\n\nTITLE: STM.repeatUntil signature\nDESCRIPTION: Describes the signature of the `STM.repeatUntil` function in TypeScript. The function takes an STM effect and a predicate, and returns a new STM effect that repeats the original until the predicate is satisfied.  It's crucial to ensure the predicate will eventually be true to avoid an infinite loop.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/STM-repeatUntil.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const repeatUntil: { <A>(predicate: Predicate<A>): <E, R>(self: STM<A, E, R>) => STM<A, E, R>; <A, E, R>(self: STM<A, E, R>, predicate: Predicate<A>): STM<A, E, R>; }\n```\n\n----------------------------------------\n\nTITLE: Accessing MicroScope with TypeScript\nDESCRIPTION: This TypeScript snippet declares a constant named `scope` that is used to access the current `MicroScope` in an Effect-TS application. No external dependencies are required besides the Effect-TS library itself, and it uses a generic type `Micro` to denote the scope. It is introduced in version 3.4.0 and helps manage the execution scope of micro-level operations.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Micro-scope.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const scope: Micro<MicroScope, never, MicroScope>;\n```\n\n----------------------------------------\n\nTITLE: Transforming Context in RequestResolver with mapInputContext in TypeScript\nDESCRIPTION: The mapInputContext function allows providing a data source with part of its required context. It maps a context transformation function to convert from one context type to another, enabling context dependency management for request resolvers.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/RequestResolver-mapInputContext.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const mapInputContext: { <R0, R>(f: (context: Context.Context<R0>) => Context.Context<R>): <A extends Request.Request<any, any>>(self: RequestResolver<A, R>) => RequestResolver<A, R0>; <R, A extends Request.Request<any, any>, R0>(self: RequestResolver<A, R>, f: (context: Context.Context<R0>) => Context.Context<R>): RequestResolver<A, R0>; }\n```\n\n----------------------------------------\n\nTITLE: Reversing List Elements in TypeScript using Effect-TS\nDESCRIPTION: Function signature for reversing elements in a List data structure. Takes a List<A> as input and returns a new List<A> with elements in reverse order. Part of the Effect-TS core package.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/List-reverse.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const reverse: <A>(self: List<A>) => List<A>\n```\n\n----------------------------------------\n\nTITLE: STM.reject Signature\nDESCRIPTION: This code snippet shows the type signature of the `STM.reject` function. It defines two overloaded function types: one where the partial function `pf` is passed first, and another where the STM transaction `self` is passed first.  It takes a partial function that maps a value `A` to an optional error `E2` and an STM transaction `STM<A, E, R>`, returning a new STM transaction `STM<A, E2 | E, R>` that can fail with either the original error type `E` or the new error type `E2`.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/STM-reject.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const reject: { <A, E2>(pf: (a: A) => Option.Option<E2>): <E, R>(self: STM<A, E, R>) => STM<A, E2 | E, R>; <A, E, R, E2>(self: STM<A, E, R>, pf: (a: A) => Option.Option<E2>): STM<A, E | E2, R>; }\n```\n\n----------------------------------------\n\nTITLE: Defining Custom Schedule with TypeScript\nDESCRIPTION: Creates a flexible scheduling mechanism that allows custom state management, input handling, and iteration control. The function enables developers to implement complex scheduling logic beyond predefined patterns.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Schedule-makeWithState.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const makeWithState: <S, In, Out, R = never>(initial: S, step: (now: number, input: In, state: S) => Effect.Effect<readonly [S, Out, ScheduleDecision.ScheduleDecision], never, R>) => Schedule<Out, In, R>\n```\n\n----------------------------------------\n\nTITLE: Using HashSet.map in TypeScript with Different Syntax Styles\nDESCRIPTION: Demonstrates three ways to map over the values of a HashSet using different API styles: data-last (pipeable), method chaining, and data-first approaches. The example converts numbers to strings.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/HashSet-map.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// Syntax\nimport { HashSet, pipe } from \"effect\"\n\n// with `data-last`, a.k.a. `pipeable` API\npipe(\n  HashSet.make(0, 1, 2), // HashSet.HashSet<number>\n  HashSet.map(String) // HashSet.HashSet<string>\n)\n\n// or piped with the pipe method\nHashSet.make(0, 1, 2).pipe(HashSet.map(String))\n\n// or with `data-first` API\nHashSet.map(HashSet.make(0, 1, 2), String)\n```\n\n----------------------------------------\n\nTITLE: Context.get Function Type Definition\nDESCRIPTION: Type signature for the Context.get function showing its polymorphic nature and support for different tag types and service configurations.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Context-get.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const get: { <I, S>(tag: Reference<I, S>): <Services>(self: Context<Services>) => S; <Services, I extends Services, S>(tag: Tag<I, S>): (self: Context<Services>) => S; <Services, I, S>(self: Context<Services>, tag: Reference<I, S>): S; <Services, I extends Services, S>(self: Context<Services>, tag: Tag<I, S>): S; }\n```\n\n----------------------------------------\n\nTITLE: Using FiberHandle.runtime to Fork Effects in TypeScript\nDESCRIPTION: This example demonstrates how to use FiberHandle.runtime to capture a Runtime, fork Effects, and manage fibers. It showcases creating a FiberHandle, capturing a Runtime, and running Effects with automatic fiber management.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/FiberHandle-runtime.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Context, Effect, FiberHandle } from \"effect\"\n\ninterface Users {\n  readonly _: unique symbol\n}\nconst Users = Context.GenericTag<Users, {\n   getAll: Effect.Effect<Array<unknown>>\n}>(\"Users\")\n\nEffect.gen(function*() {\n  const handle = yield* FiberHandle.make()\n  const run = yield* FiberHandle.runtime(handle)<Users>()\n\n  // run an effect and set the fiber in the handle\n  run(Effect.andThen(Users, _ => _.getAll))\n\n  // this will interrupt the previous fiber\n  run(Effect.andThen(Users, _ => _.getAll))\n}).pipe(\n  Effect.scoped // The fiber will be interrupted when the scope is closed\n)\n```\n\n----------------------------------------\n\nTITLE: Sink.every predicate function\nDESCRIPTION: Defines a sink that returns `true` if all input elements satisfy the provided predicate function, and `false` otherwise. It takes a predicate function of type `Predicate<In>` as input, which determines whether an element `In` satisfies a condition. The result is a `Sink` which takes input of type `In` and produces a boolean value indicating if every element satisfied the predicate.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Sink-every.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const every: <In>(predicate: Predicate<In>) => Sink<boolean, In, In>\n```\n\n----------------------------------------\n\nTITLE: Effect.tapBoth Type Signature in TypeScript\nDESCRIPTION: Provides the type signature for the Effect.tapBoth function. It shows the function's polymorphic nature, handling different effect types for success and failure cases.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-tapBoth.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const tapBoth: { <E, X, E2, R2, A, X1, E3, R3>(options: { readonly onFailure: (e: NoInfer<E>) => Effect<X, E2, R2>; readonly onSuccess: (a: NoInfer<A>) => Effect<X1, E3, R3>; }): <R>(self: Effect<A, E, R>) => Effect<A, E | E2 | E3, R2 | R3 | R>; <A, E, R, X, E2, R2, X1, E3, R3>(self: Effect<A, E, R>, options: { readonly onFailure: (e: E) => Effect<X, E2, R2>; readonly onSuccess: (a: A) => Effect<X1, E3, R3>; }): Effect<A, E | E2 | E3, R | R2 | R3>; }\n```\n\n----------------------------------------\n\nTITLE: TypeScript Schedule Delay Transformation Function\nDESCRIPTION: Defines a specialized function for modifying schedule delays dynamically, allowing custom delay computation logic such as jitter or exponential backoff\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Schedule-delayed.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const delayed: { (f: (duration: Duration.Duration) => Duration.DurationInput): <Out, In, R>(self: Schedule<Out, In, R>) => Schedule<Out, In, R>; <Out, In, R>(self: Schedule<Out, In, R>, f: (duration: Duration.Duration) => Duration.DurationInput): Schedule<Out, In, R>; }\n```\n\n----------------------------------------\n\nTITLE: Adding Exit Finalizer to Scope in Effect-TS\nDESCRIPTION: Function signature for adding a finalizer to a scope that receives the Exit value when the scope is closed. This allows conditional handling based on the exit status. References the simpler addFinalizer function as a related method.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Scope-addFinalizerExit.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const addFinalizerExit: (self: Scope, finalizer: Scope.Finalizer) => Effect.Effect<void>\n```\n\n----------------------------------------\n\nTITLE: Removing Entries from a Trie in TypeScript using Effect\nDESCRIPTION: This example demonstrates how to use the Trie.remove function to delete entries from a Trie data structure. It shows the creation of a Trie, insertion of multiple key-value pairs, and removal of specific keys.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Trie-remove.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { Trie, Option } from \"effect\"\n\nconst trie = Trie.empty<number>().pipe(\n  Trie.insert(\"call\", 0),\n  Trie.insert(\"me\", 1),\n  Trie.insert(\"mind\", 2),\n  Trie.insert(\"mid\", 3)\n)\n\nconst trie1 = trie.pipe(Trie.remove(\"call\"))\nconst trie2 = trie1.pipe(Trie.remove(\"mea\"))\n\nassert.deepStrictEqual(Trie.get(trie, \"call\"), Option.some(0))\nassert.deepStrictEqual(Trie.get(trie1, \"call\"), Option.none())\nassert.deepStrictEqual(Trie.get(trie2, \"call\"), Option.none())\n```\n\n----------------------------------------\n\nTITLE: Enqueuing Stream Elements into Queue with Effect-TS in TypeScript\nDESCRIPTION: This TypeScript declaration defines a function `runIntoQueue` that enqueues elements from a stream into a queue using the Effect-TS library. It allows elements of type `A` with error type `E` to be enqueued into a provided queue, supporting different configurations based on the order of parameters. The function handles stream completion and failure signals and returns an `Effect` which requires no input and produces a result of type `R`. Key prerequisites include the `Effect` and `Stream` modules from Effect-TS.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-runIntoQueue.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const runIntoQueue: { <A, E>(queue: Queue.Enqueue<Take.Take<A, E>>): <R>(self: Stream<A, E, R>) => Effect.Effect<void, never, R>; <A, E, R>(self: Stream<A, E, R>, queue: Queue.Enqueue<Take.Take<A, E>>): Effect.Effect<void, never, R>; }\n```\n\n----------------------------------------\n\nTITLE: Stream flattenExitOption in Typescript\nDESCRIPTION: This TypeScript code snippet defines the `flattenExitOption` function within the Effect library's Stream module. It takes a stream of `Exit` values, where a `None` error signals the end of the stream. The function returns a new stream that emits the successful values from the input stream, re-emitting errors and handling stream termination.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-flattenExitOption.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const flattenExitOption: <A, E2, E, R>(self: Stream<Exit.Exit<A, Option.Option<E2>>, E, R>) => Stream<A, E | E2, R>\n```\n\n----------------------------------------\n\nTITLE: Making a New TPriorityQueue in TypeScript\nDESCRIPTION: This function signature declares a method to create a new TPriorityQueue. It takes an ordering function and an array of elements to initialize the queue, returning a transaction that resolves to a TPriorityQueue instance.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TPriorityQueue-make.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const make: <A>(order: Order.Order<A>) => (...elements: Array<A>) => STM.STM<TPriorityQueue<A>>\n```\n\n----------------------------------------\n\nTITLE: Effect.raceFirst Function Signature in TypeScript\nDESCRIPTION: The TypeScript signature of the Effect.raceFirst function, showing its polymorphic nature and the types it accepts and returns.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-raceFirst.md#2025-04-11_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const raceFirst: { <A2, E2, R2>(that: Effect<A2, E2, R2>): <A, E, R>(self: Effect<A, E, R>) => Effect<A2 | A, E2 | E, R2 | R>; <A, E, R, A2, E2, R2>(self: Effect<A, E, R>, that: Effect<A2, E2, R2>): Effect<A | A2, E | E2, R | R2>; }\n```\n\n----------------------------------------\n\nTITLE: Querying Values in Trie with Prefix - TypeScript\nDESCRIPTION: This snippet demonstrates how to create a Trie, insert values, and retrieve an iterable of values that start with a given prefix. The example showcases the usage of the Trie data structure in a TypeScript environment, leveraging assertions for validation.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Trie-valuesWithPrefix.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { Trie } from \"effect\"\n\nconst trie = Trie.empty<number>().pipe(\n  Trie.insert(\"she\", 0),\n  Trie.insert(\"shells\", 1),\n  Trie.insert(\"sea\", 2),\n  Trie.insert(\"shore\", 3)\n)\n\nconst result = Array.from(Trie.valuesWithPrefix(trie, \"she\"))\n\n// 0: \"she\", 1: \"shells\"\nassert.deepStrictEqual(result, [0, 1])\n```\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const valuesWithPrefix: { (prefix: string): <V>(self: Trie<V>) => IterableIterator<V>; <V>(self: Trie<V>, prefix: string): IterableIterator<V>; }\n```\n\n----------------------------------------\n\nTITLE: TypeScript Signature of Stream.race Function in Effect-TS\nDESCRIPTION: This code snippet shows the TypeScript signature of the Stream.race function in the Effect-TS library. It defines the function's type and parameters for combining two streams.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-race.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const race: { <AR, ER, RR>(right: Stream<AR, ER, RR>): <AL, EL, RL>(left: Stream<AL, EL, RL>) => Stream<AL | AR, EL | ER, RL | RR>; <AL, EL, RL, AR, ER, RR>(left: Stream<AL, EL, RL>, right: Stream<AR, ER, RR>): Stream<AL | AR, EL | ER, RL | RR>; }\n```\n\n----------------------------------------\n\nTITLE: Mapping Over HashMap Entries in TypeScript\nDESCRIPTION: This function maps over the entries of a HashMap using a specified function to transform values while preserving keys. It provides both pipeable and standard calling conventions.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/HashMap-map.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const map: { <A, V, K>(f: (value: V, key: K) => A): (self: HashMap<K, V>) => HashMap<K, A>; <K, V, A>(self: HashMap<K, V>, f: (value: V, key: K) => A): HashMap<K, A>; }\n```\n\n----------------------------------------\n\nTITLE: Implementing Stream Throttling with Token Bucket Algorithm in TypeScript\nDESCRIPTION: TypeScript type declaration for throttleEffect function that controls stream bandwidth using token bucket algorithm. Supports both 'enforce' and 'shape' strategies, with configurable burst limits and chunk cost calculation. The function can either drop chunks that exceed bandwidth limits or delay them based on the chosen strategy.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-throttleEffect.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const throttleEffect: {\n  <A, E2, R2>(options: {\n    readonly cost: (chunk: Chunk.Chunk<A>) => Effect.Effect<number, E2, R2>;\n    readonly units: number;\n    readonly duration: Duration.DurationInput;\n    readonly burst?: number | undefined;\n    readonly strategy?: \"enforce\" | \"shape\" | undefined;\n  }): <E, R>(self: Stream<A, E, R>) => Stream<A, E2 | E, R2 | R>;\n  <A, E, R, E2, R2>(self: Stream<A, E, R>, options: {\n    readonly cost: (chunk: Chunk.Chunk<A>) => Effect.Effect<number, E2, R2>;\n    readonly units: number;\n    readonly duration: Duration.DurationInput;\n    readonly burst?: number | undefined;\n    readonly strategy?: \"enforce\" | \"shape\" | undefined;\n  }): Stream<A, E | E2, R | R2>;\n}\n```\n\n----------------------------------------\n\nTITLE: Channel.mapOutEffectPar Signature in TypeScript\nDESCRIPTION: Type signature for the mapOutEffectPar function which creates a channel that applies a ZIO function to each emitted output element, processing n elements in parallel. The function has two overloads to support both curried and standard invocation patterns.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Channel-mapOutEffectPar.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const mapOutEffectPar: { <OutElem, OutElem1, OutErr1, Env1>(f: (o: OutElem) => Effect.Effect<OutElem1, OutErr1, Env1>, n: number): <InElem, OutErr, InErr, OutDone, InDone, Env>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>) => Channel<OutElem1, InElem, OutErr1 | OutErr, InErr, OutDone, InDone, Env1 | Env>; <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutElem1, OutErr1, Env1>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>, f: (o: OutElem) => Effect.Effect<OutElem1, OutErr1, Env1>, n: number): Channel<OutElem1, InElem, OutErr | OutErr1, InErr, OutDone, InDone, Env | Env1>; }\n```\n\n----------------------------------------\n\nTITLE: Constructing Synchronous Channel with Effect.io\nDESCRIPTION: Creates a channel that immediately succeeds with a lazily evaluated value. The function takes a LazyArg parameter and returns a Channel that never fails, has no input requirements, and produces the evaluated output.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Channel-sync.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const sync: <OutDone>(evaluate: LazyArg<OutDone>) => Channel<never, unknown, never, unknown, OutDone, unknown>\n```\n\n----------------------------------------\n\nTITLE: Taking First Matching Value from TMap in TypeScript\nDESCRIPTION: Describes the takeFirst function that takes the first matching value from a TMap, or retries until there is one. The function accepts a partial function that is applied to each key-value pair and returns an Option of a result value.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TMap-takeFirst.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const takeFirst: { <K, V, A>(pf: (key: K, value: V) => Option.Option<A>): (self: TMap<K, V>) => STM.STM<A>; <K, V, A>(self: TMap<K, V>, pf: (key: K, value: V) => Option.Option<A>): STM.STM<A>; }\n```\n\n----------------------------------------\n\nTITLE: Signature of fromAsyncIterable in Effect\nDESCRIPTION: This code snippet shows the TypeScript declaration for the `fromAsyncIterable` function within the `effect` library. It accepts an `AsyncIterable` of type `A` and an error handling function that transforms an unknown error into an error of type `E`. It returns a `Stream` of type `A` that can emit errors of type `E`.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-fromAsyncIterable.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const fromAsyncIterable: <A, E>(iterable: AsyncIterable<A>, onError: (e: unknown) => E) => Stream<A, E>\n```\n\n----------------------------------------\n\nTITLE: Stream.map Function Signature in TypeScript\nDESCRIPTION: This code snippet shows the TypeScript signature for the Stream.map function. It can be used in two ways: as a standalone function or as a method on a Stream instance.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-map.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const map: { <A, B>(f: (a: A) => B): <E, R>(self: Stream<A, E, R>) => Stream<B, E, R>; <A, E, R, B>(self: Stream<A, E, R>, f: (a: A) => B): Stream<B, E, R>; }\n```\n\n----------------------------------------\n\nTITLE: Creating a daily schedule with Effect TS\nDESCRIPTION: The `dayOfMonth` function from the `effect` package creates a schedule that triggers on a specific day of the month. The schedule triggers at midnight on the specified day and increments a counter with each execution. The `day` parameter determines the day of the month to trigger the schedule.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Schedule-dayOfMonth.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const dayOfMonth: (day: number) => Schedule<number>\n```\n\n----------------------------------------\n\nTITLE: Implementing Layer.orElse Function in TypeScript\nDESCRIPTION: Defines a type-safe function that executes a primary layer and falls back to an alternative layer if the first execution fails. The function accepts generic type parameters for different output types, error types, and requirement types.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Layer-orElse.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const orElse: { <A2, E2, R2>(that: LazyArg<Layer<A2, E2, R2>>): <A, E, R>(self: Layer<A, E, R>) => Layer<A & A2, E2 | E, R2 | R>; <A, E, R, A2, E2, R2>(self: Layer<A, E, R>, that: LazyArg<Layer<A2, E2, R2>>): Layer<A & A2, E | E2, R | R2>; }\n```\n\n----------------------------------------\n\nTITLE: Defining mapBoth Function for Stream Transformation in TypeScript\nDESCRIPTION: The mapBoth function returns a stream with both failure and success channels mapped by specified onFailure and onSuccess functions. It can be used in two ways: as a standalone function or as a method on a Stream instance.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-mapBoth.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const mapBoth: { <E, E2, A, A2>(options: { readonly onFailure: (e: E) => E2; readonly onSuccess: (a: A) => A2; }): <R>(self: Stream<A, E, R>) => Stream<A2, E2, R>; <A, E, R, E2, A2>(self: Stream<A, E, R>, options: { readonly onFailure: (e: E) => E2; readonly onSuccess: (a: A) => A2; }): Stream<A2, E2, R>; }\n```\n\n----------------------------------------\n\nTITLE: Creating a Cost-Limited Folding Sink in TypeScript\nDESCRIPTION: Creates a sink that folds elements of type `In` into a structure of type `S`, stopping when the accumulated cost (determined by the `costFn`) exceeds the specified maximum. Note that elements with individual costs larger than the maximum will still be processed, potentially exceeding the limit.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Sink-foldWeighted.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const foldWeighted: <S, In>(options: { readonly initial: S; readonly maxCost: number; readonly cost: (s: S, input: In) => number; readonly body: (s: S, input: In) => S; }) => Sink<S, In, In>\n```\n\n----------------------------------------\n\nTITLE: Transforming and Filtering Numbers with Option.filterMap in Effect\nDESCRIPTION: This example demonstrates how to use `Option.filterMap` to transform and filter Option values. It checks if a number is even, and if so, transforms it into a string indicating it is even. Otherwise, it returns Option.none().\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Option-filterMap.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Option } from \"effect\"\n\n// Transform and filter numbers\nconst transformEven = (n: Option.Option<number>): Option.Option<string> =>\n  Option.filterMap(n, (n) => (n % 2 === 0 ? Option.some(`Even: ${n}`) : Option.none()))\n\nconsole.log(transformEven(Option.none()))\n// Output: { _id: 'Option', _tag: 'None' }\n\nconsole.log(transformEven(Option.some(1)))\n// Output: { _id: 'Option', _tag: 'None' }\n\nconsole.log(transformEven(Option.some(2)))\n// Output: { _id: 'Option', _tag: 'Some', value: 'Even: 2' }\n```\n\n----------------------------------------\n\nTITLE: Adding Multiple Cookies to a Cookies Object in TypeScript\nDESCRIPTION: The unsafeSetAll function adds multiple cookies to a Cookies object, throwing an error if any cookie is invalid. It provides both curried and direct application patterns for flexibility in usage.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Cookies-unsafeSetAll.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const unsafeSetAll: { (cookies: Iterable<readonly [name: string, value: string, options?: Cookie[\"options\"]]>): (self: Cookies) => Cookies; (self: Cookies, cookies: Iterable<readonly [name: string, value: string, options?: Cookie[\"options\"]]>): Cookies; }\n```\n\n----------------------------------------\n\nTITLE: Declaring contextWithSTM Function in TypeScript\nDESCRIPTION: This snippet defines the 'contextWithSTM' function which takes a function as an argument. This function accepts the transaction environment and returns a new STM that includes the results from the provided function alongside the original environment. It is critical for executing transactions within specified contexts, enhancing the transactional capabilities of Effect-TS.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/STM-contextWithSTM.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const contextWithSTM: <R0, A, E, R>(f: (environment: Context.Context<R0>) => STM<A, E, R>) => STM<A, E, R0 | R>\n```\n\n----------------------------------------\n\nTITLE: Creating Failing Take with Error Message - TypeScript\nDESCRIPTION: This function creates a failing Take instance that carries a specified error message. It is designed for use in contexts where error handling through effect management is required. The function takes a string message as its parameter, which will be used to describe the error in the failing Take. Expected inputs are a string indicating the error message, and the output is a Take instance that represents a failure with the provided message.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Take-dieMessage.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const dieMessage: (message: string) => Take<never>\n```\n\n----------------------------------------\n\nTITLE: Flattening Nested STM Effects\nDESCRIPTION: This function takes a nested STM effect and flattens it into a single STM effect, combining the error and return types. It is particularly useful for simplifying the handling of complex nested effects in TypeScript applications using the Effect library.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/STM-flatten.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const flatten: <A, E2, R2, E, R>(self: STM<STM<A, E2, R2>, E, R>) => STM<A, E2 | E, R2 | R>\n```\n\n----------------------------------------\n\nTITLE: Rechunking Effect Stream in TypeScript\nDESCRIPTION: This code snippet demonstrates the signature of the `rechunk` function within the `Stream` module of the Effect library.  It takes a number `n` representing the desired chunk size and a stream `self` of type `Stream<A, E, R>` as input. It returns a new `Stream<A, E, R>` where the elements are re-chunked into the specified size.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-rechunk.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const rechunk: { (n: number): <A, E, R>(self: Stream<A, E, R>) => Stream<A, E, R>; <A, E, R>(self: Stream<A, E, R>, n: number): Stream<A, E, R>; }\n```\n\n----------------------------------------\n\nTITLE: Defining logError Function Signature in TypeScript\nDESCRIPTION: Function signature for logError which takes variadic messages and returns an Effect that performs ERROR level logging. The returned Effect has void as the success type and never as both the error and requirement types.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-logError.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const logError: (...message: ReadonlyArray<any>) => Effect<void, never, never>\n```\n\n----------------------------------------\n\nTITLE: Updating URL Path using Effect-TS\nDESCRIPTION: The function 'setPathname' allows updating the path of a URL object using Effect-TS. It takes either a single parameter, 'pathname', and returns a function expecting a URL, or it takes both 'url' and 'pathname' directly to return a new URL with the updated path. This utility is part of '@effect/platform', and it's available since version 1.0.0.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Url-setPathname.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const setPathname: { (pathname: string): (url: URL) => URL; (url: URL, pathname: string): URL; }\n```\n\n----------------------------------------\n\nTITLE: Comparing BigDecimal Values with equals Function in TypeScript\nDESCRIPTION: The equals function checks if two BigDecimal values are equal. It can be used in both curried and non-curried form, providing flexibility in function application. The function takes two BigDecimal parameters and returns a boolean result.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/BigDecimal-equals.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const equals: { (that: BigDecimal): (self: BigDecimal) => boolean; (self: BigDecimal, that: BigDecimal): boolean; }\n```\n\n----------------------------------------\n\nTITLE: Serializing Cookies to Set-Cookie Headers in TypeScript\nDESCRIPTION: Function that converts a Cookies object into an array of strings, where each string represents a Set-Cookie header. This is useful for setting cookies in HTTP responses.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Cookies-toSetCookieHeaders.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const toSetCookieHeaders: (self: Cookies) => Array<string>\n```\n\n----------------------------------------\n\nTITLE: Getting Keys from HashMap in TypeScript Effect Package\nDESCRIPTION: A function that extracts all keys from a HashMap data structure and returns them as a HashSet. This allows accessing just the keys of the map in set form for further operations.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/HashMap-keySet.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const keySet: <K, V>(self: HashMap<K, V>) => HashSet<K>\n```\n\n----------------------------------------\n\nTITLE: Converting Option<Effect> to Effect<Option> in TypeScript\nDESCRIPTION: This snippet demonstrates how to use Effect.transposeOption to convert an Option containing an Effect into an Effect containing an Option. It shows the transformation of Option<Effect<number, never, never>> to Effect<Option<number>, never, never>.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-transposeOption.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Effect, Option } from \"effect\"\n\n//      ┌─── Option<Effect<number, never, never>>\n//      ▼\nconst maybe = Option.some(Effect.succeed(42))\n\n//      ┌─── Effect<Option<number>, never, never>\n//      ▼\nconst result = Effect.transposeOption(maybe)\n\nconsole.log(Effect.runSync(result))\n// Output: { _id: 'Option', _tag: 'Some', value: 42 }\n```\n\n----------------------------------------\n\nTITLE: Awaiting Multiple Fibers Completion in Effect TypeScript\nDESCRIPTION: The awaitAll function waits for all fibers in the provided iterable to complete, either successfully or with an error. It returns an Effect containing the Exit values of all fibers, preserving the structure of the input iterable.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Fiber-awaitAll.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const awaitAll: <const T extends Iterable<Fiber<any, any>>>(fibers: T) => Effect.Effect<[T] extends [ReadonlyArray<infer U>] ? number extends T[\"length\"] ? Array<U extends Fiber<infer A, infer E> ? Exit.Exit<A, E> : never> : { -readonly [K in keyof T]: T[K] extends Fiber<infer A, infer E> ? Exit.Exit<A, E> : never; } : Array<T extends Iterable<infer U> ? U extends Fiber<infer A, infer E> ? Exit.Exit<A, E> : never : never>>\n```\n\n----------------------------------------\n\nTITLE: Demonstrating BigInt.divide Usage in TypeScript\nDESCRIPTION: Example showing how to use the BigInt.divide function to perform division operations on bigint values. The function returns an Option type that contains the result or None if dividing by zero.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/BigInt-divide.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { BigInt, Option } from \"effect\"\n\nassert.deepStrictEqual(BigInt.divide(6n, 3n), Option.some(2n))\nassert.deepStrictEqual(BigInt.divide(6n, 0n), Option.none())\n```\n\n----------------------------------------\n\nTITLE: Implementing Channel.ensuring Function in TypeScript\nDESCRIPTION: Function signature for Channel.ensuring which returns a new channel with an attached finalizer that is guaranteed to execute regardless of whether the channel completes. It supports both curried and non-curried calling styles.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Channel-ensuring.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const ensuring: { <Z, Env1>(finalizer: Effect.Effect<Z, never, Env1>): <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>) => Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env1 | Env>; <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, Z, Env1>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>, finalizer: Effect.Effect<Z, never, Env1>): Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env | Env1>; }\n```\n\n----------------------------------------\n\nTITLE: Checking Element Presence in TSet using TypeScript\nDESCRIPTION: This snippet declares the 'has' function which tests if a specific value is present in a TSet instance. It can be used in two ways: as a curried function or as a direct invocation with two parameters. The function returns an STM that results in a boolean indicating presence.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TSet-has.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const has: { <A>(value: A): (self: TSet<A>) => STM.STM<boolean>; <A>(self: TSet<A>, value: A): STM.STM<boolean>; }\n```\n\n----------------------------------------\n\nTITLE: Removing a Key from a TypeScript Record\nDESCRIPTION: Demonstrates removing a key from a record using the `remove` function from the `effect/Record` module. The function returns a new record without the specified key, maintaining immutability.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Record-remove.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { remove } from \"effect/Record\"\n\nassert.deepStrictEqual(remove({ a: 1, b: 2 }, \"a\"), { b: 2 })\n```\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const remove: { <K extends string | symbol, X extends K>(key: X): <A>(self: ReadonlyRecord<K, A>) => Record<Exclude<K, X>, A>; <K extends string | symbol, A, X extends K>(self: ReadonlyRecord<K, A>, key: X): Record<Exclude<K, X>, A>; }\n```\n\n----------------------------------------\n\nTITLE: Patching FiberRef Values with FiberRefsPatch in TypeScript\nDESCRIPTION: This function applies changes described by a FiberRefsPatch to a collection of FiberRef values. It accepts a fiber ID, the original FiberRefs collection, and returns a function that applies the patch to produce updated FiberRefs. The function is curried and can be called in two ways.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/FiberRefsPatch-patch.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const patch: { (fiberId: FiberId.Runtime, oldValue: FiberRefs.FiberRefs): (self: FiberRefsPatch) => FiberRefs.FiberRefs; (self: FiberRefsPatch, fiberId: FiberId.Runtime, oldValue: FiberRefs.FiberRefs): FiberRefs.FiberRefs; }\n```\n\n----------------------------------------\n\nTITLE: Doc.pageWidth Function Signature in TypeScript\nDESCRIPTION: The type signature for the pageWidth function in the @effect/printer/Doc module. It takes a function that receives the current PageWidth and returns a Doc, producing a Doc that can respond to available page width.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Doc-pageWidth.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const pageWidth: <A>(react: (pageWidth: PageWidth) => Doc<A>) => Doc<A>\n```\n\n----------------------------------------\n\nTITLE: Using Effect.loop with Discarded Results in TypeScript\nDESCRIPTION: Example showing how to use Effect.loop with the discard option set to true, which causes the function to ignore intermediate results and return void. This is useful for side-effect-only operations.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-loop.md#2025-04-11_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Effect, Console } from \"effect\"\n\nconst result = Effect.loop(\n  // Initial state\n  1,\n  {\n    // Condition to continue looping\n    while: (state) => state <= 5,\n    // State update function\n    step: (state) => state + 1,\n    // Effect to be performed on each iteration\n    body: (state) => Console.log(`Currently at state ${state}`),\n    // Discard intermediate results\n    discard: true\n  }\n)\n\nEffect.runPromise(result).then(console.log)\n// Output:\n// Currently at state 1\n// Currently at state 2\n// Currently at state 3\n// Currently at state 4\n// Currently at state 5\n// undefined\n```\n\n----------------------------------------\n\nTITLE: Defining asyncEffect Function in TypeScript for Stream Creation\nDESCRIPTION: Creates a stream from an asynchronous callback that can be called multiple times. The registration function returns an Effect. The optionality of error type E can signal the end of the stream by setting it to None.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-asyncEffect.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const asyncEffect: <A, E = never, R = never>(register: (emit: Emit.Emit<R, E, A, void>) => Effect.Effect<unknown, E, R>, bufferSize?: number | \"unbounded\" | { readonly bufferSize?: number | undefined; readonly strategy?: \"dropping\" | \"sliding\" | \"suspend\" | undefined; } | undefined) => Stream<A, E, R>\n```\n\n----------------------------------------\n\nTITLE: Creating Directory Option in Effect CLI\nDESCRIPTION: Defines a CLI option that expects a directory path with optional configuration parameters. Allows specifying a name and optional path-related configuration for directory selection.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Options-directory.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const directory: (name: string, config?: Options.PathOptionsConfig) => Options<string>\n```\n\n----------------------------------------\n\nTITLE: Constructing Effects with Fiber Descriptor Information in TypeScript\nDESCRIPTION: The descriptorWith function allows creating an effect by providing a function that receives the current Fiber's descriptor. This can be used to access information about the executing fiber when building effects.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-descriptorWith.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const descriptorWith: <A, E, R>(f: (descriptor: Fiber.Fiber.Descriptor) => Effect<A, E, R>) => Effect<A, E, R>\n```\n\n----------------------------------------\n\nTITLE: Defining OpenAI Telemetry Attributes Type\nDESCRIPTION: Creates a comprehensive type for telemetry attributes that combines generic AI telemetry attributes with OpenAI-specific request and response attributes. Used for tracking and monitoring OpenAI API interactions.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/OpenAiTelemetry-OpenAiTelemetry.AllAttributes.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ntype AllAttributes = AiTelemetry.GenAI.AllAttributes & RequestAttributes & ResponseAttributes\n```\n\n----------------------------------------\n\nTITLE: Initializing Do Notation Block in Effect Micro Module\nDESCRIPTION: Defines a constant Do that starts a do notation block in the Micro module. It takes empty object type parameters, never type for error handling, and never type for output.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Micro-Do.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const Do: Micro<{}, never, never>\n```\n\n----------------------------------------\n\nTITLE: Creating a WebSocket RPC Protocol Layer in TypeScript\nDESCRIPTION: Defines a function to create an RPC protocol layer that uses WebSockets for communication. This protocol can be configured with a specific path and an optional router tag for HTTP routing integration.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/RpcServer-layerProtocolWebsocket.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const layerProtocolWebsocket: <I = HttpRouter.Default>(options: { readonly path: HttpRouter.PathInput; readonly routerTag?: HttpRouter.HttpRouter.TagClass<I, string, any, any>; }) => Layer.Layer<Protocol, never, RpcSerialization.RpcSerialization>\n```\n\n----------------------------------------\n\nTITLE: Concatenating Iterables with appendAll Function\nDESCRIPTION: Defines a function that combines two iterables into a single iterable containing elements from both collections. The function supports both curried and non-curried invocation patterns.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Iterable-appendAll.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const appendAll: { <B>(that: Iterable<B>): <A>(self: Iterable<A>) => Iterable<A | B>; <A, B>(self: Iterable<A>, that: Iterable<B>): Iterable<A | B>; }\n```\n\n----------------------------------------\n\nTITLE: Array.union TypeScript type signature\nDESCRIPTION: The type signature for the Array.union function in the Effect library. It defines multiple overloaded versions to handle various combinations of array types including regular arrays, non-empty arrays, and iterables, with appropriate return type inference.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Array-union.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const union: { <T extends Iterable<any>>(that: T): <S extends Iterable<any>>(self: S) => ReadonlyArray.OrNonEmpty<S, T, ReadonlyArray.Infer<S> | ReadonlyArray.Infer<T>>; <A, B>(self: NonEmptyReadonlyArray<A>, that: ReadonlyArray<B>): NonEmptyArray<A | B>; <A, B>(self: ReadonlyArray<A>, that: NonEmptyReadonlyArray<B>): NonEmptyArray<A | B>; <A, B>(self: Iterable<A>, that: Iterable<B>): Array<A | B>; }\n```\n\n----------------------------------------\n\nTITLE: Creating Stream from Effect Option in TypeScript\nDESCRIPTION: This snippet defines a TypeScript function that creates a stream from an effect that may produce a value of type `A` or result in an empty stream. It uses constructs from the Effect-TS library. The function is generic in nature, taking an effect that returns an optional value and converting it into a stream. To use this snippet, ensure you have the Effect-TS library installed.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-fromEffectOption.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const fromEffectOption: <A, E, R>(effect: Effect.Effect<A, Option.Option<E>, R>) => Stream<A, E, R>\n```\n\n----------------------------------------\n\nTITLE: Creating DateTime from Date Object in TypeScript\nDESCRIPTION: Function signature for creating a DateTime object from a JavaScript Date instance. The function converts a standard JavaScript Date object into an Utc DateTime representation, throwing an IllegalArgumentException if the provided Date is invalid.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/DateTime-unsafeFromDate.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const unsafeFromDate: (date: Date) => Utc\n```\n\n----------------------------------------\n\nTITLE: Using Effect.ignore Example in TypeScript\nDESCRIPTION: Demonstrates how to use Effect.ignore to discard both success and failure values from an Effect, transforming it into an Effect<void, never, never>.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-ignore.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Effect } from \"effect\"\n\n//      ┌─── Effect<number, string, never>\n//      ▼\nconst task = Effect.fail(\"Uh oh!\").pipe(Effect.as(5))\n\n//      ┌─── Effect<void, never, never>\n//      ▼\nconst program = Effect.ignore(task)\n```\n\n----------------------------------------\n\nTITLE: Shuffling Iterable Elements with Random.shuffle in TypeScript\nDESCRIPTION: Defines a function that uses a pseudo-random number generator to shuffle the elements of an iterable. It returns an Effect that produces a Chunk containing the shuffled elements.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Random-shuffle.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const shuffle: <A>(elements: Iterable<A>) => Effect.Effect<Chunk.Chunk<A>>\n```\n\n----------------------------------------\n\nTITLE: Defining mapAccumEffect Function in TypeScript for Stream Module\nDESCRIPTION: This code snippet defines the mapAccumEffect function, which statefully and effectfully maps over the elements of a stream to produce new elements. It takes an initial state, a mapping function, and returns a new stream.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-mapAccumEffect.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const mapAccumEffect: { <S, A, A2, E2, R2>(s: S, f: (s: S, a: A) => Effect.Effect<readonly [S, A2], E2, R2>): <E, R>(self: Stream<A, E, R>) => Stream<A2, E2 | E, R2 | R>; <A, E, R, S, A2, E2, R2>(self: Stream<A, E, R>, s: S, f: (s: S, a: A) => Effect.Effect<readonly [S, A2], E2, R2>): Stream<A2, E | E2, R | R2>; }\n```\n\n----------------------------------------\n\nTITLE: Reducing Schedule Outputs in TypeScript\nDESCRIPTION: The 'reduce' function in TypeScript provides a way to accumulate schedule results over time using a reducer function. It requires an initial value ('zero') and uses the reducer function ('f') to update this value every time the schedule produces an output. This is particularly useful for tasks such as tracking statistics or aggregating results over multiple executions. The function is part of the Effect library's Schedule module.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Schedule-reduce.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const reduce: { <Out, Z>(zero: Z, f: (z: Z, out: Out) => Z): <In, R>(self: Schedule<Out, In, R>) => Schedule<Z, In, R>; <Out, In, R, Z>(self: Schedule<Out, In, R>, zero: Z, f: (z: Z, out: Out) => Z): Schedule<Z, In, R>; }\n```\n\n----------------------------------------\n\nTITLE: Implementing Conditional Stream Filtering in TypeScript\nDESCRIPTION: Defines a when function that takes a boolean test condition and returns a stream. If the condition is true, returns the original stream; if false, returns an empty stream. The function supports both curried and regular parameter ordering.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-when.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const when: { \n  (test: LazyArg<boolean>): <A, E, R>(self: Stream<A, E, R>) => Stream<A, E, R>; \n  <A, E, R>(self: Stream<A, E, R>, test: LazyArg<boolean>): Stream<A, E, R>; \n}\n```\n\n----------------------------------------\n\nTITLE: Getting Left Value from Either using Effect\nDESCRIPTION: This snippet demonstrates the usage of Option.getLeft to extract the left value from an Either type. It wraps the value in a Some if the Either is a Left, or returns None if it's a Right. This is useful for error handling workflows that prioritize the Left value.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Option-getLeft.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Either, Option } from \"effect\"\n\nconsole.log(Option.getLeft(Either.right(\"ok\")))\n// Output: { _id: 'Option', _tag: 'None' }\n\nconsole.log(Option.getLeft(Either.left(\"err\")))\n// Output: { _id: 'Option', _tag: 'Some', value: 'err' }\n```\n\n----------------------------------------\n\nTITLE: Inserting Values into Trie using Effect (TypeScript)\nDESCRIPTION: This snippet demonstrates how to insert key-value pairs into a Trie and retrieve them in alphabetical order. It uses the Effect framework's Trie module to manage the data structure. Dependencies include the Effect library and Node.js assert module for validation.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Trie-values.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { Trie } from \"effect\"\n\nconst trie = Trie.empty<number>().pipe(\n  Trie.insert(\"call\", 0),\n  Trie.insert(\"me\", 1),\n  Trie.insert(\"and\", 2)\n)\n\nconst result = Array.from(Trie.values(trie))\nassert.deepStrictEqual(result, [2, 0, 1])\n```\n\n----------------------------------------\n\nTITLE: Defining takeWhile Function for Iterable in TypeScript\nDESCRIPTION: Declares the takeWhile function for Iterable, which calculates the longest initial Iterable where all elements satisfy a specified predicate. It supports both refinement and predicate functions, and can be used with method chaining or direct application.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Iterable-takeWhile.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const takeWhile: { <A, B extends A>(refinement: (a: NoInfer<A>, i: number) => a is B): (self: Iterable<A>) => Iterable<B>; <A>(predicate: (a: NoInfer<A>, i: number) => boolean): (self: Iterable<A>) => Iterable<A>; <A, B extends A>(self: Iterable<A>, refinement: (a: A, i: number) => a is B): Iterable<B>; <A>(self: Iterable<A>, predicate: (a: A, i: number) => boolean): Iterable<A>; }\n```\n\n----------------------------------------\n\nTITLE: Transforming Sink Chunks in TypeScript\nDESCRIPTION: The `dimapChunks` function allows for the transformation of input chunks and the result of a sink in the 'effect' package by applying provided transformation functions. It requires input transformation and output transformation functions provided in an options object. The function supports two main forms: applying it to a self-contained sink with options, or partially applying the transformations to prepare for a future sink. It is typically used to adjust data formats or intercept results for modification.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Sink-dimapChunks.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const dimapChunks: { <In0, In, A, A2>(options: { readonly onInput: (chunk: Chunk.Chunk<In0>) => Chunk.Chunk<In>; readonly onDone: (a: A) => A2; }): <L, E, R>(self: Sink<A, In, L, E, R>) => Sink<A2, In0, L, E, R>; <A, In, L, E, R, In0, A2>(self: Sink<A, In, L, E, R>, options: { readonly onInput: (chunk: Chunk.Chunk<In0>) => Chunk.Chunk<In>; readonly onDone: (a: A) => A2; }): Sink<A2, In0, L, E, R>; }\n```\n\n----------------------------------------\n\nTITLE: SemigroupXor Example in TypeScript\nDESCRIPTION: This code demonstrates the usage of `SemigroupXor` to combine boolean values using exclusive disjunction. The `combine` method is used to perform the XOR operation on different combinations of true and false values, and the results are logged to the console.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/data-Boolean-SemigroupXor.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { SemigroupXor } from \"@effect/typeclass/data/Boolean\"\n\nconsole.log(SemigroupXor.combine(true, true))\n// false\nconsole.log(SemigroupXor.combine(true, false))\n// true\nconsole.log(SemigroupXor.combine(false, true))\n// true\nconsole.log(SemigroupXor.combine(false, false))\n// false\n```\n\n----------------------------------------\n\nTITLE: Testing HTTP Server with NodeHttpServer.layerTest in Effect\nDESCRIPTION: This code snippet demonstrates how to use `NodeHttpServer.layerTest` to start a test HTTP server on a random port and make a request to it using `HttpClient`.  It asserts that the response status code is 404 after serving an empty `HttpRouter`.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/NodeHttpServer-layerTest.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { HttpClient, HttpRouter, HttpServer } from \"@effect/platform\"\nimport { NodeHttpServer } from \"@effect/platform-node\"\nimport { Effect } from \"effect\"\n\nEffect.gen(function*() {\n  yield* HttpServer.serveEffect(HttpRouter.empty)\n  const response = yield* HttpClient.get(\"/\")\n  assert.strictEqual(response.status, 404)\n}).pipe(Effect.provide(NodeHttpServer.layerTest))\n```\n\n----------------------------------------\n\nTITLE: Using Array.intersperse to Place Elements Between Array Items in TypeScript\nDESCRIPTION: Demonstrates how to use the Array.intersperse function to insert a value between each element of an array. In this example, the number 0 is placed between each element of the array [1, 2, 3], resulting in [1, 0, 2, 0, 3].\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Array-intersperse.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Array } from \"effect\"\n\nconst result = Array.intersperse([1, 2, 3], 0)\nconsole.log(result) // [1, 0, 2, 0, 3]\n```\n\n----------------------------------------\n\nTITLE: Defining runIntoQueueScoped Function in TypeScript\nDESCRIPTION: The runIntoQueueScoped function allows executing a Stream with an Enqueue queue, returning a scoped effect. This function supports both single and multiple parameters, facilitating flexibility in stream processing within scoped effects.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-runIntoQueueScoped.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const runIntoQueueScoped: { <A, E>(queue: Queue.Enqueue<Take.Take<A, E>>): <R>(self: Stream<A, E, R>) => Effect.Effect<void, never, Scope.Scope | R>; <A, E, R>(self: Stream<A, E, R>, queue: Queue.Enqueue<Take.Take<A, E>>): Effect.Effect<void, never, Scope.Scope | R>; }\n```\n\n----------------------------------------\n\nTITLE: Implementing dropRight Function for Chunk in TypeScript\nDESCRIPTION: Defines the dropRight function which removes the last n elements from a Chunk. It can be called with either the number of elements to drop first, or the Chunk and number of elements as arguments.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Chunk-dropRight.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const dropRight: { (n: number): <A>(self: Chunk<A>) => Chunk<A>; <A>(self: Chunk<A>, n: number): Chunk<A>; }\n```\n\n----------------------------------------\n\nTITLE: Creating Cron Instance with Cron.make in TypeScript\nDESCRIPTION: The Cron.make function creates a Cron instance. It accepts an object with various time parameters including seconds, minutes, hours, days, months, weekdays, and an optional timezone. Each time parameter is specified as an Iterable of numbers.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Cron-make.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const make: (values: { readonly seconds?: Iterable<number> | undefined; readonly minutes: Iterable<number>; readonly hours: Iterable<number>; readonly days: Iterable<number>; readonly months: Iterable<number>; readonly weekdays: Iterable<number>; readonly tz?: DateTime.TimeZone | undefined; }) => Cron\n```\n\n----------------------------------------\n\nTITLE: Implementing Cookie Management in Effect HTTP Client\nDESCRIPTION: A function that associates a Ref of cookies with an HTTP client to enable cookie handling across requests. It takes a cookie reference and HTTP client as parameters and returns an enhanced HTTP client with cookie management capabilities.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/HttpClient-withCookiesRef.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const withCookiesRef: { \n  (ref: Ref<Cookies>): <E, R>(self: HttpClient.With<E, R>) => HttpClient.With<E, R>; \n  <E, R>(self: HttpClient.With<E, R>, ref: Ref<Cookies>): HttpClient.With<E, R>; \n}\n```\n\n----------------------------------------\n\nTITLE: Declaring Chunk.join Function in TypeScript\nDESCRIPTION: Defines the join function for the Chunk module. It takes a separator string and a Chunk of strings, joining the elements with the separator. The function is overloaded to allow for different argument orders.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Chunk-join.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const join: { (sep: string): (self: Chunk<string>) => string; (self: Chunk<string>, sep: string): string; }\n```\n\n----------------------------------------\n\nTITLE: Implementing Semigroup Reverse Operation in TypeScript\nDESCRIPTION: Creates a new Semigroup by reversing the order of arguments in the combine operation of an existing Semigroup. This is useful for creating dual algebraic structures.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Semigroup-reverse.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const reverse: <A>(S: Semigroup<A>) => Semigroup<A>\n```\n\n----------------------------------------\n\nTITLE: Implementing Effectful Fold Operations with Sink.foldLeftEffect in TypeScript\nDESCRIPTION: The foldLeftEffect function creates a sink that processes inputs by applying an effectful folding function to each input along with the accumulated state. It starts with an initial state value and returns a Sink that produces the final accumulated state as its result.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Sink-foldLeftEffect.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const foldLeftEffect: <S, In, E, R>(s: S, f: (s: S, input: In) => Effect.Effect<S, E, R>) => Sink<S, In, In, E, R>\n```\n\n----------------------------------------\n\nTITLE: Completing a Deferred with a value in TypeScript\nDESCRIPTION: The succeed function completes a Deferred with a specified value. It returns an Effect that resolves to a boolean indicating whether the operation was successful or not. The function has two overloaded signatures for flexibility in usage.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Deferred-succeed.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const succeed: { <A>(value: A): <E>(self: Deferred<A, E>) => Effect.Effect<boolean>; <A, E>(self: Deferred<A, E>, value: A): Effect.Effect<boolean>; }\n```\n\n----------------------------------------\n\nTITLE: Applying a Function to Array Head Using modifyNonEmptyHead in TypeScript\nDESCRIPTION: Demonstrates how to use the modifyNonEmptyHead function to apply a transformation to the first element of a non-empty array. The function takes an array and a transformation function, returning a new array with the modified head element while preserving the rest of the elements.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Array-modifyNonEmptyHead.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Array } from \"effect\"\n\nconst result = Array.modifyNonEmptyHead([1, 2, 3], n => n * 10)\nconsole.log(result) // [10, 2, 3]\n```\n\n----------------------------------------\n\nTITLE: Merging Values in a TMap with TypeScript\nDESCRIPTION: The merge function allows storing a value in a TMap. If the key already exists, it merges the existing value with the new one using the provided function f. It returns an STM effect that yields the resulting value.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TMap-merge.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const merge: { <K, V>(key: K, value: V, f: (x: V, y: V) => V): (self: TMap<K, V>) => STM.STM<V>; <K, V>(self: TMap<K, V>, key: K, value: V, f: (x: V, y: V) => V): STM.STM<V>; }\n```\n\n----------------------------------------\n\nTITLE: Getting Current Time with Custom Time Zone in TypeScript using Effect\nDESCRIPTION: This snippet demonstrates how to use the nowInCurrentZone function from the DateTime module to get the current time. It sets the current time zone to 'Europe/London' and retrieves the current time as a DateTime.Zoned object.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/DateTime-nowInCurrentZone.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { DateTime, Effect } from \"effect\"\n\nEffect.gen(function* () {\n  // will use the \"Europe/London\" time zone\n  const now = yield* DateTime.nowInCurrentZone\n}).pipe(DateTime.withCurrentZoneNamed(\"Europe/London\"))\n```\n\n----------------------------------------\n\nTITLE: Implementing Channel.mergeWith in TypeScript\nDESCRIPTION: The mergeWith function returns a new channel that merges the current channel with another specified channel. It allows custom handling of early termination through the onSelfDone and onOtherDone merge decision functions.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Channel-mergeWith.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const mergeWith: { <OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1, OutDone, OutErr, OutErr2, OutDone2, OutErr3, OutDone3>(options: { readonly other: Channel<OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>; readonly onSelfDone: (exit: Exit.Exit<OutDone, OutErr>) => MergeDecision.MergeDecision<Env1, OutErr1, OutDone1, OutErr2, OutDone2>; readonly onOtherDone: (ex: Exit.Exit<OutDone1, OutErr1>) => MergeDecision.MergeDecision<Env1, OutErr, OutDone, OutErr3, OutDone3>; }): <Env, InErr, InElem, InDone, OutElem>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>) => Channel<OutElem1 | OutElem, InElem & InElem1, OutErr2 | OutErr3, InErr & InErr1, OutDone2 | OutDone3, InDone & InDone1, Env1 | Env>; <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1, OutErr2, OutDone2, OutErr3, OutDone3>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>, options: { readonly other: Channel<OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>; readonly onSelfDone: (exit: Exit.Exit<OutDone, OutErr>) => MergeDecision.MergeDecision<Env1, OutErr1, OutDone1, OutErr2, OutDone2>; readonly onOtherDone: (ex: Exit.Exit<OutDone1, OutErr1>) => MergeDecision.MergeDecision<Env1, OutErr, OutDone, OutErr3, OutDone3>; }): Channel<OutElem | OutElem1, InElem & InElem1, OutErr2 | OutErr3, InErr & InErr1, OutDone2 | OutDone3, InDone & InDone1, Env | Env1>; }\n```\n\n----------------------------------------\n\nTITLE: Initializing Broadcasted Stream Queues in TypeScript\nDESCRIPTION: Creates multiple synchronized queues from a stream with configurable maximum lag and queue management strategies. Allows different queues to consume stream values at different speeds while maintaining backpressure control.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-broadcastedQueues.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const broadcastedQueues: { <N extends number>(n: N, maximumLag: number | { readonly capacity: \"unbounded\"; readonly replay?: number | undefined; } | { readonly capacity: number; readonly strategy?: \"sliding\" | \"dropping\" | \"suspend\" | undefined; readonly replay?: number | undefined; }): <A, E, R>(self: Stream<A, E, R>) => Effect.Effect<TupleOf<N, Queue.Dequeue<Take.Take<A, E>>>, never, Scope.Scope | R>; <A, E, R, N extends number>(self: Stream<A, E, R>, n: N, maximumLag: number | { readonly capacity: \"unbounded\"; readonly replay?: number | undefined; } | { readonly capacity: number; readonly strategy?: \"sliding\" | \"dropping\" | \"suspend\" | undefined; readonly replay?: number | undefined; }): Effect.Effect<TupleOf<N, Queue.Dequeue<Take.Take<A, E>>>, never, Scope.Scope | R>; }\n```\n\n----------------------------------------\n\nTITLE: Declaring a Schema in TypeScript\nDESCRIPTION: This snippet defines a const function 'declare' which is used to declare schemas in the Effect framework. It enforces a context based on the provided type parameters, allowing for flexible encoding and decoding functions tailored to specific input types. The implementation ensures type safety by utilizing TypeScript's type inference capabilities and constructs for effectful programming.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Schema-declare.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const declare: { <A>(is: (input: unknown) => input is A, annotations?: Annotations.Schema<A>): declare<A>; <A, I, const P extends ReadonlyArray<Schema.All>>(typeParameters: P, options: { readonly decode: (...typeParameters: { readonly [K in keyof P]: Schema<Schema.Type<P[K]>, Schema.Encoded<P[K]>, never>; }) => (input: unknown, options: ParseOptions, ast: AST.Declaration) => Effect.Effect<A, ParseResult.ParseIssue, never>; readonly encode: (...typeParameters: { readonly [K in keyof P]: Schema<Schema.Type<P[K]>, Schema.Encoded<P[K]>, never>; }) => (input: unknown, options: ParseOptions, ast: AST.Declaration) => Effect.Effect<I, ParseResult.ParseIssue, never>; }, annotations?: Annotations.Schema<A, { readonly [K in keyof P]: Schema.Type<P[K]>; }>): declare<A, I, P>; }\n```\n\n----------------------------------------\n\nTITLE: Updating URL Hash Fragment with Effect Platform in TypeScript\nDESCRIPTION: The setHash function updates the hash fragment of a URL. It provides overloaded signatures allowing either a curried approach or direct application. This functionality is part of the Effect Platform's URL module, and is available since version 1.0.0. The function takes a string representing the new hash and a URL object as parameters, and returns a modified URL object with the new hash.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Url-setHash.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const setHash: { (hash: string): (url: URL) => URL; (url: URL, hash: string): URL; }\n```\n\n----------------------------------------\n\nTITLE: Atomically Transforming All Entries in TMap using STM in TypeScript\nDESCRIPTION: The transform function atomically updates all key-value bindings in a TMap using a pure function. It provides both curried and uncurried versions to support different calling styles. The function expects a transformation that takes a key and value and returns a new key-value pair as a readonly tuple.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TMap-transform.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const transform: { <K, V>(f: (key: K, value: V) => readonly [K, V]): (self: TMap<K, V>) => STM.STM<void>; <K, V>(self: TMap<K, V>, f: (key: K, value: V) => readonly [K, V]): STM.STM<void>; }\n```\n\n----------------------------------------\n\nTITLE: Effect Metric Summary Type Definition\nDESCRIPTION: TypeScript type declaration for the Metric.summary function, defining the required options including name, maxAge, maxSize, error tolerance, quantiles array, and optional description.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Metric-summary.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const summary: (options: { readonly name: string; readonly maxAge: Duration.DurationInput; readonly maxSize: number; readonly error: number; readonly quantiles: ReadonlyArray<number>; readonly description?: string | undefined; }) => Metric.Summary<number>\n```\n\n----------------------------------------\n\nTITLE: Composing Two Schedules in TypeScript\nDESCRIPTION: This function enables the chaining of two schedules, where the output of the first schedule is used as the input for the second schedule. This composition is crucial for building intricate scheduling logics. It allows schedules to influence each other, facilitating more dynamic behavior in asynchronous workflows.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Schedule-compose.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const compose: { <Out2, Out, R2>(that: Schedule<Out2, Out, R2>): <In, R>(self: Schedule<Out, In, R>) => Schedule<Out2, In, R2 | R>; <Out, In, R, Out2, R2>(self: Schedule<Out, In, R>, that: Schedule<Out2, Out, R2>): Schedule<Out2, In, R | R2>; }\n```\n\n----------------------------------------\n\nTITLE: Creating Array Equivalence Relation in TypeScript\nDESCRIPTION: The getEquivalence function creates an equivalence relation for arrays. It takes an equivalence function for individual elements and returns an equivalence function for arrays of those elements. This is useful for comparing arrays of custom types or when specific comparison logic is needed.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Array-getEquivalence.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Array } from \"effect\"\n\nconst eq = Array.getEquivalence<number>((a, b) => a === b)\nconsole.log(eq([1, 2, 3], [1, 2, 3])) // true\n```\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const getEquivalence: <A>(isEquivalent: Equivalence.Equivalence<A>) => Equivalence.Equivalence<ReadonlyArray<A>>\n```\n\n----------------------------------------\n\nTITLE: Implementing Predicate Check on Chunk Elements in TypeScript\nDESCRIPTION: The 'some' function checks if a predicate holds true for some element in a Chunk. It returns a boolean indicating whether the predicate is satisfied for at least one element. The function is overloaded to work with both curried and non-curried forms.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Chunk-some.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const some: { <A>(predicate: Predicate<NoInfer<A>>): (self: Chunk<A>) => self is NonEmptyChunk<A>; <A>(self: Chunk<A>, predicate: Predicate<A>): self is NonEmptyChunk<A>; }\n```\n\n----------------------------------------\n\nTITLE: Defining ParseIssue Type in TypeScript\nDESCRIPTION: This snippet defines the `ParseIssue` type, encapsulating various error categories that can arise during the parsing process. It includes errors related to types, missing values, unexpected values, forbidden values, and composite issues. Each error type serves to provide detailed information on the nature of the parsing error and aids in debugging and error handling.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/ParseResult-ParseIssue.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ntype ParseIssue = | Type\n  | Missing\n  | Unexpected\n  | Forbidden\n  // composite\n  | Pointer\n  | Refinement\n  | Transformation\n  | Composite\n```\n\n----------------------------------------\n\nTITLE: Transforming Elements in TSet Using STM\nDESCRIPTION: The 'transform' function is a high-order function that takes a pure function 'f' and applies it atomically to all elements of a TSet. It can be used in both curried and non-curried forms. This function is essential for ensuring that updates to the TSet are safe and consistent within the context of Software Transactional Memory (STM).\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TSet-transform.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const transform: { <A>(f: (a: A) => A): (self: TSet<A>) => STM.STM<void>; <A>(self: TSet<A>, f: (a: A) => A): STM.STM<void>; }\n```\n\n----------------------------------------\n\nTITLE: Typing Atomic Array Predicate Evaluation in TypeScript\nDESCRIPTION: Defines a function that checks if all elements in a transactional array meet a specific predicate condition using the STM (Software Transactional Memory) monad\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TArray-every.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const every: { <A>(predicate: Predicate<A>): (self: TArray<A>) => STM.STM<boolean>; <A>(self: TArray<A>, predicate: Predicate<A>): STM.STM<boolean>; }\n```\n\n----------------------------------------\n\nTITLE: Implementing Request Transformation in TypeScript HttpClient\nDESCRIPTION: Declares a function that appends a transformation to the request object before sending it. The function can be used in two ways: either by passing the transformation function first, or by passing the HttpClient instance first followed by the transformation function.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/HttpClient-mapRequest.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const mapRequest: { \n  (f: (a: ClientRequest.HttpClientRequest) => ClientRequest.HttpClientRequest): <E, R>(self: HttpClient.With<E, R>) => HttpClient.With<E, R>; \n  <E, R>(self: HttpClient.With<E, R>, f: (a: ClientRequest.HttpClientRequest) => ClientRequest.HttpClientRequest): HttpClient.With<E, R>; \n}\n```\n\n----------------------------------------\n\nTITLE: Setting Fiber in FiberMap - TypeScript Effect-TS\nDESCRIPTION: Defines a set operation that adds a fiber to the FiberMap with automatic removal upon completion. The operation includes options for conditional setting and interruption propagation. If a key exists, the previous fiber will be interrupted unless specified otherwise.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/FiberMap-set.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const set: { \n  <K, A, E, XE extends E, XA extends A>(\n    key: K, \n    fiber: Fiber.RuntimeFiber<XA, XE>, \n    options?: { \n      readonly onlyIfMissing?: boolean | undefined; \n      readonly propagateInterruption?: boolean | undefined; \n    } | undefined\n  ): (self: FiberMap<K, A, E>) => Effect.Effect<void>; \n  <K, A, E, XE extends E, XA extends A>(\n    self: FiberMap<K, A, E>, \n    key: K, \n    fiber: Fiber.RuntimeFiber<XA, XE>, \n    options?: { \n      readonly onlyIfMissing?: boolean | undefined; \n      readonly propagateInterruption?: boolean | undefined; \n    } | undefined\n  ): Effect.Effect<void>; \n}\n```\n\n----------------------------------------\n\nTITLE: Building Layer into Scoped Value in TypeScript\nDESCRIPTION: The build function constructs a layer into a scoped value. It takes a Layer as input and returns an Effect that produces a Context of the output type. The function requires a Scope and the input requirements of the layer.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Layer-build.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const build: <RIn, E, ROut>(self: Layer<ROut, E, RIn>) => Effect.Effect<Context.Context<ROut>, E, Scope.Scope | RIn>\n```\n\n----------------------------------------\n\nTITLE: Executing Workflow with Test Config in TypeScript\nDESCRIPTION: The withTestConfig function executes a specified workflow with a custom implementation of the config service for testing. It can be called in two ways: either by passing the config first and then the effect, or by passing the effect first and then the config.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TestServices-withTestConfig.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const withTestConfig: ((config: TestConfig.TestConfig) => <A, E, R>(effect: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>) & (<A, E, R>(effect: Effect.Effect<A, E, R>, config: TestConfig.TestConfig) => Effect.Effect<A, E, R>)\n```\n\n----------------------------------------\n\nTITLE: Defining provideService Function for Stream Module in TypeScript\nDESCRIPTION: This code snippet defines the provideService function for the Stream module. It allows providing a stream with a single required service. The function has two overloads to support different usage patterns.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-provideService.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const provideService: {\n  <I, S>(tag: Context.Tag<I, S>, resource: NoInfer<S>): <A, E, R>(self: Stream<A, E, R>) => Stream<A, E, Exclude<R, I>>;\n  <A, E, R, I, S>(self: Stream<A, E, R>, tag: Context.Tag<I, S>, resource: NoInfer<S>): Stream<A, E, Exclude<R, I>>;\n}\n```\n\n----------------------------------------\n\nTITLE: Converting Callback Functions to Effect Type in TypeScript\nDESCRIPTION: A complex conditional type that transforms callback-style functions into functions that return Effect types. It supports function overloading with up to 10 different argument combinations and preserves type information for arguments and return values while converting callbacks to Effect returns.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effectify-Effectify.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ntype Effectify<T, E> = T extends {\n  (...args: ArgsWithCallback<infer Args1, infer _E1, infer A1>): infer _R1\n  (...args: ArgsWithCallback<infer Args2, infer _E2, infer A2>): infer _R2\n  (...args: ArgsWithCallback<infer Args3, infer _E3, infer A3>): infer _R3\n  (...args: ArgsWithCallback<infer Args4, infer _E4, infer A4>): infer _R4\n  (...args: ArgsWithCallback<infer Args5, infer _E5, infer A5>): infer _R5\n  (...args: ArgsWithCallback<infer Args6, infer _E6, infer A6>): infer _R6\n  (...args: ArgsWithCallback<infer Args7, infer _E7, infer A7>): infer _R7\n  (...args: ArgsWithCallback<infer Args8, infer _E8, infer A8>): infer _R8\n  (...args: ArgsWithCallback<infer Args9, infer _E9, infer A9>): infer _R9\n  (...args: ArgsWithCallback<infer Args10, infer _E10, infer A10>): infer _R10\n} ? {\n    (...args: Args1): Effect.Effect<WithoutNull<A1>, E>\n    (...args: Args2): Effect.Effect<WithoutNull<A2>, E>\n    (...args: Args3): Effect.Effect<WithoutNull<A3>, E>\n    (...args: Args4): Effect.Effect<WithoutNull<A4>, E>\n    (...args: Args5): Effect.Effect<WithoutNull<A5>, E>\n    (...args: Args6): Effect.Effect<WithoutNull<A6>, E>\n    (...args: Args7): Effect.Effect<WithoutNull<A7>, E>\n    (...args: Args8): Effect.Effect<WithoutNull<A8>, E>\n    (...args: Args9): Effect.Effect<WithoutNull<A9>, E>\n    (...args: Args10): Effect.Effect<WithoutNull<A10>, E>\n  }\n  : T extends {\n    (...args: ArgsWithCallback<infer Args1, infer _E1, infer A1>): infer _R1\n    (...args: ArgsWithCallback<infer Args2, infer _E2, infer A2>): infer _R2\n    (...args: ArgsWithCallback<infer Args3, infer _E3, infer A3>): infer _R3\n    (...args: ArgsWithCallback<infer Args4, infer _E4, infer A4>): infer _R4\n    (...args: ArgsWithCallback<infer Args5, infer _E5, infer A5>): infer _R5\n    (...args: ArgsWithCallback<infer Args6, infer _E6, infer A6>): infer _R6\n    (...args: ArgsWithCallback<infer Args7, infer _E7, infer A7>): infer _R7\n    (...args: ArgsWithCallback<infer Args8, infer _E8, infer A8>): infer _R8\n    (...args: ArgsWithCallback<infer Args9, infer _E9, infer A9>): infer _R9\n  } ? {\n      (...args: Args1): Effect.Effect<WithoutNull<A1>, E>\n      (...args: Args2): Effect.Effect<WithoutNull<A2>, E>\n      (...args: Args3): Effect.Effect<WithoutNull<A3>, E>\n      (...args: Args4): Effect.Effect<WithoutNull<A4>, E>\n      (...args: Args5): Effect.Effect<WithoutNull<A5>, E>\n      (...args: Args6): Effect.Effect<WithoutNull<A6>, E>\n      (...args: Args7): Effect.Effect<WithoutNull<A7>, E>\n      (...args: Args8): Effect.Effect<WithoutNull<A8>, E>\n      (...args: Args9): Effect.Effect<WithoutNull<A9>, E>\n    }\n  : T extends {\n    (...args: ArgsWithCallback<infer Args1, infer _E1, infer A1>): infer _R1\n  } ? {\n      (...args: Args1): Effect.Effect<WithoutNull<A1>, E>\n    }\n  : never\n```\n\n----------------------------------------\n\nTITLE: Creating a ScopedRef with Effect (TypeScript)\nDESCRIPTION: The `make` function creates a `ScopedRef` from a lazy argument. It returns an `Effect` that, when executed within a `Scope`, produces the `ScopedRef`. The `Scope` provides the necessary context for resource management when the `ScopedRef` is no longer needed.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/ScopedRef-make.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const make: <A>(evaluate: LazyArg<A>) => Effect.Effect<ScopedRef<A>, never, Scope.Scope>\n```\n\n----------------------------------------\n\nTITLE: Declaring untilInput Function in TypeScript\nDESCRIPTION: Defines the untilInput function which returns a new schedule that stops execution when a given predicate on the input evaluates to true. It can be used in two ways: by passing the predicate first, or by passing the schedule first.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Schedule-untilInput.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const untilInput: { <In>(f: Predicate<In>): <Out, R>(self: Schedule<Out, In, R>) => Schedule<Out, In, R>; <Out, In, R>(self: Schedule<Out, In, R>, f: Predicate<In>): Schedule<Out, In, R>; }\n```\n\n----------------------------------------\n\nTITLE: Using scopeWith Function in Effect Module\nDESCRIPTION: The scopeWith function accesses the current scope and uses it to perform a specified effect. It takes a function that receives a Scope object and returns an Effect.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-scopeWith.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const scopeWith: <A, E, R>(f: (scope: Scope.Scope) => Effect<A, E, R>) => Effect<A, E, R | Scope.Scope>\n```\n\n----------------------------------------\n\nTITLE: Pattern Matching Example with Match.tag in TypeScript\nDESCRIPTION: Demonstrates how to use Match.tag to pattern match on a discriminated union based on _tag field. Shows matching multiple tags and handling different event types with custom responses.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Match-tag.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Match } from \"effect\"\n\ntype Event =\n  | { readonly _tag: \"fetch\" }\n  | { readonly _tag: \"success\"; readonly data: string }\n  | { readonly _tag: \"error\"; readonly error: Error }\n  | { readonly _tag: \"cancel\" }\n\n// Create a Matcher for Either<number, string>\nconst match = Match.type<Event>().pipe(\n  // Match either \"fetch\" or \"success\"\n  Match.tag(\"fetch\", \"success\", () => `Ok!`),\n  // Match \"error\" and extract the error message\n  Match.tag(\"error\", (event) => `Error: ${event.error.message}`),\n  // Match \"cancel\"\n  Match.tag(\"cancel\", () => \"Cancelled\"),\n  Match.exhaustive\n)\n\nconsole.log(match({ _tag: \"success\", data: \"Hello\" }))\n// Output: \"Ok!\"\n\nconsole.log(match({ _tag: \"error\", error: new Error(\"Oops!\") }))\n// Output: \"Error: Oops!\"\n```\n\n----------------------------------------\n\nTITLE: Defining Channel.mapEffect Type Signature in TypeScript\nDESCRIPTION: Defines a type signature for the mapEffect function that transforms a channel by applying an effectful function to its terminal value. The function supports both curried and uncurried forms, handling type parameters for elements, errors, and environments.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Channel-mapEffect.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const mapEffect: { <OutDone, OutDone1, OutErr1, Env1>(f: (o: OutDone) => Effect.Effect<OutDone1, OutErr1, Env1>): <OutElem, InElem, OutErr, InErr, InDone, Env>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>) => Channel<OutElem, InElem, OutErr1 | OutErr, InErr, OutDone1, InDone, Env1 | Env>; <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutDone1, OutErr1, Env1>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>, f: (o: OutDone) => Effect.Effect<OutDone1, OutErr1, Env1>): Channel<OutElem, InElem, OutErr | OutErr1, InErr, OutDone1, InDone, Env | Env1>; }\n```\n\n----------------------------------------\n\nTITLE: Implementing TQueue.peek Function in TypeScript\nDESCRIPTION: The peek function allows viewing the next element in a transactional queue without removing it. It will retry if the queue is empty until an element becomes available. This function works with the TDequeue type and returns an STM effect that resolves to the next queue element.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TQueue-peek.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const peek: <A>(self: TDequeue<A>) => STM.STM<A>\n```\n\n----------------------------------------\n\nTITLE: Implementing collectAllWhile in TypeScript Effect-TS Sink Module\nDESCRIPTION: Defines a function that accumulates incoming elements into a chunk as long as they satisfy a given predicate or refinement. The function is overloaded to handle both Refinement and Predicate type conditions.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Sink-collectAllWhile.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const collectAllWhile: { <In, Out extends In>(refinement: Refinement<In, Out>): Sink<Chunk.Chunk<Out>, In, In>; <In>(predicate: Predicate<In>): Sink<Chunk.Chunk<In>, In, In>; }\n```\n\n----------------------------------------\n\nTITLE: Converting Effect to Fiber in TypeScript\nDESCRIPTION: Lifts an Effect into a Fiber, enabling concurrent execution of effects. Takes an Effect<A, E> as input and returns an Effect that produces a Fiber<A, E>.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Fiber-fromEffect.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const fromEffect: <A, E>(effect: Effect.Effect<A, E>) => Effect.Effect<Fiber<A, E>>\n```\n\n----------------------------------------\n\nTITLE: Declaring Cause.match Function in TypeScript\nDESCRIPTION: Defines the match function for the Cause module. It transforms a Cause into a single value using custom handlers for each possible case, including Empty, Fail, Die, Interrupt, Sequential, and Parallel causes.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Cause-match.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const match: { <Z, E>(options: { readonly onEmpty: Z; readonly onFail: (error: E) => Z; readonly onDie: (defect: unknown) => Z; readonly onInterrupt: (fiberId: FiberId.FiberId) => Z; readonly onSequential: (left: Z, right: Z) => Z; readonly onParallel: (left: Z, right: Z) => Z; }): (self: Cause<E>) => Z; <Z, E>(self: Cause<E>, options: { readonly onEmpty: Z; readonly onFail: (error: E) => Z; readonly onDie: (defect: unknown) => Z; readonly onInterrupt: (fiberId: FiberId.FiberId) => Z; readonly onSequential: (left: Z, right: Z) => Z; readonly onParallel: (left: Z, right: Z) => Z; }): Z; }\n```\n\n----------------------------------------\n\nTITLE: Converting Record to Iterable in TypeScript using Effect-TS\nDESCRIPTION: Example demonstrating how to convert a record object into an iterable of key-value pairs using the fromRecord function. The function takes a readonly record and returns an iterable containing tuples of the record's keys and values.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Iterable-fromRecord.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { fromRecord } from \"effect/Iterable\"\n\nconst x = { a: 1, b: 2, c: 3 }\nassert.deepStrictEqual(Array.from(fromRecord(x)), [[\"a\", 1], [\"b\", 2], [\"c\", 3]])\n```\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const fromRecord: <K extends string, A>(self: Readonly<Record<K, A>>) => Iterable<[K, A]>\n```\n\n----------------------------------------\n\nTITLE: Type Signature of isTagged Function in TypeScript\nDESCRIPTION: Provides the type signature for the isTagged function, showing its overloaded nature. It can be used both as a curried function and with two arguments.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Predicate-isTagged.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const isTagged: { <K extends string>(tag: K): (self: unknown) => self is { _tag: K; }; <K extends string>(self: unknown, tag: K): self is { _tag: K; }; }\n```\n\n----------------------------------------\n\nTITLE: Implementing HashSet Collection Sink in TypeScript\nDESCRIPTION: Defines a sink that accumulates all input values into a HashSet collection. The sink takes a generic type parameter In for the input values and returns a Sink that produces a HashSet containing all collected values of type In.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Sink-collectAllToSet.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const collectAllToSet: <In>() => Sink<HashSet.HashSet<In>, In>\n```\n\n----------------------------------------\n\nTITLE: Defining Array.span Function in TypeScript\nDESCRIPTION: Declares the span function for splitting an Iterable into two arrays based on a predicate. It supports both refinement and predicate functions, and can be used with curried or non-curried syntax.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Array-span.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const span: {\n  <A, B extends A>(refinement: (a: NoInfer<A>, i: number) => a is B): (self: Iterable<A>) => [init: Array<B>, rest: Array<Exclude<A, B>>];\n  <A>(predicate: (a: NoInfer<A>, i: number) => boolean): (self: Iterable<A>) => [init: Array<A>, rest: Array<A>];\n  <A, B extends A>(self: Iterable<A>, refinement: (a: A, i: number) => a is B): [init: Array<B>, rest: Array<Exclude<A, B>>];\n  <A>(self: Iterable<A>, predicate: (a: A, i: number) => boolean): [init: Array<A>, rest: Array<A>];\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Effect Racing with Micro.raceAllFirst in TypeScript\nDESCRIPTION: Defines a function that races multiple effects and returns the result of the first effect to complete, whether success or failure. The function interrupts all other effects once a winner is determined. Takes an Iterable of Micro effects as input and returns a new Micro effect.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Micro-raceAllFirst.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const raceAllFirst: <Eff extends Micro<any, any, any>>(all: Iterable<Eff>) => Micro<Micro.Success<Eff>, Micro.Error<Eff>, Micro.Context<Eff>>\n```\n\n----------------------------------------\n\nTITLE: Declaring the Signature for Stream.scan\nDESCRIPTION: This snippet provides the type signature for the `scan` function used within the Effect.js Stream module. It defines a higher-order function that takes an initial state and a reducer function to produce a new stream with stateful results.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-scan.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const scan: { <S, A>(s: S, f: (s: S, a: A) => S): <E, R>(self: Stream<A, E, R>) => Stream<S, E, R>; <A, E, R, S>(self: Stream<A, E, R>, s: S, f: (s: S, a: A) => S): Stream<S, E, R>; }\n```\n\n----------------------------------------\n\nTITLE: Implementing Conditional Effect Execution with Effect.unless in TypeScript\nDESCRIPTION: Function signature for Effect.unless which conditionally executes an effect only if the provided condition is false. Returns an Option that contains the effect's result when executed, or None when the condition is true. Two overloaded versions are provided to support different parameter ordering.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-unless.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const unless: { (condition: LazyArg<boolean>): <A, E, R>(self: Effect<A, E, R>) => Effect<Option.Option<A>, E, R>; <A, E, R>(self: Effect<A, E, R>, condition: LazyArg<boolean>): Effect<Option.Option<A>, E, R>; }\n```\n\n----------------------------------------\n\nTITLE: Effect.takeWhile Type Signature in TypeScript\nDESCRIPTION: The type signature for the Effect.takeWhile function, which shows it can be used in two ways: either by providing the predicate first and then the elements (curried form), or by providing both the elements and predicate together.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-takeWhile.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const takeWhile: { <A, E, R>(predicate: (a: NoInfer<A>, i: number) => Effect<boolean, E, R>): (elements: Iterable<A>) => Effect<Array<A>, E, R>; <A, E, R>(elements: Iterable<A>, predicate: (a: NoInfer<A>, i: number) => Effect<boolean, E, R>): Effect<Array<A>, E, R>; }\n```\n\n----------------------------------------\n\nTITLE: Hiding Cursor in Terminal using ANSI Escape Codes\nDESCRIPTION: Defines a constant cursorHide of type Ansi that represents the ANSI escape sequence for hiding the terminal cursor. This is commonly used in terminal-based applications where you want to temporarily hide the cursor.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Ansi-cursorHide.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const cursorHide: Ansi\n```\n\n----------------------------------------\n\nTITLE: Combining Two Sinks with zipWith in TypeScript\nDESCRIPTION: The zipWith function feeds inputs to one sink until it yields a result, then switches to another sink until it yields a result, and finally combines the two results using a provided function. It supports an optional configuration for concurrent processing.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Sink-zipWith.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const zipWith: { <A2, In, In2 extends In, L2, E2, R2, A, A3>(that: Sink<A2, In2, L2, E2, R2>, f: (a: A, a2: A2) => A3, options?: { readonly concurrent?: boolean | undefined; } | undefined): <L, E, R>(self: Sink<A, In, L, E, R>) => Sink<A3, In & In2, L2 | L, E2 | E, R2 | R>; <A, In, L, E, R, A2, In2 extends In, L2, E2, R2, A3>(self: Sink<A, In, L, E, R>, that: Sink<A2, In2, L2, E2, R2>, f: (a: A, a2: A2) => A3, options?: { readonly concurrent?: boolean | undefined; } | undefined): Sink<A3, In & In2, L | L2, E | E2, R | R2>; }\n```\n\n----------------------------------------\n\nTITLE: Defining a Layer for Runner Health Checking via RPC in TypeScript\nDESCRIPTION: Creates a Layer that provides RunnerHealth functionality by directly pinging a Runner to check its health status. It depends on ShardingConfig and the Runners.RpcClientProtocol components.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/RunnerHealth-layerRpc.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const layerRpc: Layer.Layer<RunnerHealth, never, ShardingConfig | Runners.RpcClientProtocol>\n```\n\n----------------------------------------\n\nTITLE: TypeScript Function Signature for Trie.empty()\nDESCRIPTION: This code snippet shows the TypeScript function signature for the Trie.empty() function. It indicates that the function takes no parameters and returns a Trie<V> where V is the type of values stored in the Trie.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Trie-empty.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const empty: <V = never>() => Trie<V>\n```\n\n----------------------------------------\n\nTITLE: Offering Values to a Transactional Priority Queue in TypeScript\nDESCRIPTION: The 'offer' function adds a specified value to a transactional priority queue. It supports both curried and uncurried calling styles, returning an STM transaction that completes the operation.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TPriorityQueue-offer.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const offer: { <A>(value: A): (self: TPriorityQueue<A>) => STM.STM<void>; <A>(self: TPriorityQueue<A>, value: A): STM.STM<void>; }\n```\n\n----------------------------------------\n\nTITLE: Replacing Success Values in Micro Effects with TypeScript\nDESCRIPTION: Implementation of the 'as' function that creates a Micro effect by replacing the success value of an existing effect. It provides two overloads: one for curried usage and another for direct value replacement.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Micro-as.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const as: {\n  <A, B>(value: B): <E, R>(self: Micro<A, E, R>) => Micro<B, E, R>;\n  <A, E, R, B>(self: Micro<A, E, R>, value: B): Micro<B, E, R>;\n}\n```\n\n----------------------------------------\n\nTITLE: Subscribing to TPubSub in TypeScript\nDESCRIPTION: This function subscribes to receive messages from a TPubSub instance. It returns a TDequeue that can be evaluated multiple times to take messages. The caller is responsible for unsubscribing by shutting down the queue.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TPubSub-subscribe.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const subscribe: <A>(self: TPubSub<A>) => STM.STM<TQueue.TDequeue<A>>\n```\n\n----------------------------------------\n\nTITLE: Implementing Iterable.zip Function in TypeScript\nDESCRIPTION: Function signature for zip operation that takes two Iterables and combines them into an Iterable of pairs. Supports both curried and uncurried versions of the function.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Iterable-zip.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const zip: { <B>(that: Iterable<B>): <A>(self: Iterable<A>) => Iterable<[A, B]>; <A, B>(self: Iterable<A>, that: Iterable<B>): Iterable<[A, B]>; }\n```\n\n----------------------------------------\n\nTITLE: Implementing Map Collection Sink in TypeScript\nDESCRIPTION: Defines a sink that collects the first n keys into a map using a keying function. When duplicate keys are encountered, values are merged using a provided merge function. Returns a Sink that produces a HashMap.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Sink-collectAllToMapN.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const collectAllToMapN: <In, K>(n: number, key: (input: In) => K, merge: (x: In, y: In) => In) => Sink<HashMap.HashMap<K, In>, In, In>\n```\n\n----------------------------------------\n\nTITLE: Implementing Exit.all for collecting Exit values in TypeScript\nDESCRIPTION: The all function collects all of the specified exit values into a Some<Exit<List<A>, E>>. If the provided iterable contains no elements, None will be returned. It accepts an options object with a parallel flag.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Exit-all.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const all: <A, E>(exits: Iterable<Exit<A, E>>, options?: { readonly parallel?: boolean | undefined; } | undefined) => Option.Option<Exit<Array<A>, E>>\n```\n\n----------------------------------------\n\nTITLE: Implementing Effect.unsandbox Function in TypeScript\nDESCRIPTION: TypeScript function signature for unsandbox, which takes an Effect with detailed error cause information and returns an Effect with simplified error handling. The function removes the detailed Cause<E> error tracking and restores the original error channel.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-unsandbox.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const unsandbox: <A, E, R>(self: Effect<A, Cause.Cause<E>, R>) => Effect<A, E, R>\n```\n\n----------------------------------------\n\nTITLE: Executing Fold Over Stream Values Using Effect Library in TypeScript\nDESCRIPTION: This TypeScript declaration defines a method to run a fold operation over a stream of values, allowing for both curried and uncurried applications. It requires the Effect library as a dependency to manage side effects and scoped values.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-runFoldScoped.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const runFoldScoped: { <S, A>(s: S, f: (s: S, a: A) => S): <E, R>(self: Stream<A, E, R>) => Effect.Effect<S, E, Scope.Scope | R>; <A, E, R, S>(self: Stream<A, E, R>, s: S, f: (s: S, a: A) => S): Effect.Effect<S, E, Scope.Scope | R>; }\n```\n\n----------------------------------------\n\nTITLE: Extracting DateTime Parts in TypeScript\nDESCRIPTION: The toParts function takes a DateTime object and returns an object containing its different parts, adjusted for the time zone. It returns a DateTime.PartsWithWeekday object.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/DateTime-toParts.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const toParts: (self: DateTime) => DateTime.PartsWithWeekday\n```\n\n----------------------------------------\n\nTITLE: Defining Channel.map Function in TypeScript\nDESCRIPTION: Declares a map function for Channel that applies a transformation to the terminal value. It supports both curried and uncurried versions, allowing flexible usage patterns.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Channel-map.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const map: { <OutDone, OutDone2>(f: (out: OutDone) => OutDone2): <OutElem, InElem, OutErr, InErr, InDone, Env>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>) => Channel<OutElem, InElem, OutErr, InErr, OutDone2, InDone, Env>; <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutDone2>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>, f: (out: OutDone) => OutDone2): Channel<OutElem, InElem, OutErr, InErr, OutDone2, InDone, Env>; }\n```\n\n----------------------------------------\n\nTITLE: Declaring Finite Schema in Effect Module TypeScript\nDESCRIPTION: This TypeScript snippet defines a function 'finite' that ensures a given schema only accepts finite numbers, excluding NaN and Infinity values. It uses generics to infer types, dependent on other types and context provided by the Effect schema module.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Schema-finite.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const finite: <S extends Schema.Any>(annotations?: Annotations.Filter<Schema.Type<S>>) => <A extends number>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>) => filter<S>\n```\n\n----------------------------------------\n\nTITLE: Creating a Sink with Die Message in TypeScript\nDESCRIPTION: A type-level function that generates a Sink which immediately terminates with a RuntimeException containing a specified error message. This allows graceful error handling and controlled sink termination.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Sink-dieMessage.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const dieMessage: (message: string) => Sink<never, unknown>\n```\n\n----------------------------------------\n\nTITLE: Clamping BigDecimal Values in Effect Schema Module using TypeScript\nDESCRIPTION: This snippet defines a TypeScript function `clampBigDecimal` from the Effect Schema module. It is used to clamp a BigDecimal value between a given minimum and maximum. The function takes two BigDecimal parameters for the range and returns a function that applies this clamping transformation, leveraging the library's Schema type constraints. No explicit external dependencies are required beyond the library itself.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Schema-clampBigDecimal.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const clampBigDecimal: (minimum: bigDecimal_.BigDecimal, maximum: bigDecimal_.BigDecimal) => <S extends Schema.Any, A extends bigDecimal_.BigDecimal>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>) => transform<S, filter<SchemaClass<A>>>\n```\n\n----------------------------------------\n\nTITLE: Using SemigroupMax in TypeScript\nDESCRIPTION: This example demonstrates how to use the SemigroupMax from the @effect/typeclass library to compute the maximum of two numeric values. The necessary dependency is the @effect/typeclass package, and the combine method is utilized to achieve the operation. The expected output from combining inputs 2 and 3 is 3.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/data-Number-SemigroupMax.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { SemigroupMax } from \"@effect/typeclass/data/Number\"\n\nconsole.log(SemigroupMax.combine(2, 3))\n// 3\n```\n\n----------------------------------------\n\nTITLE: Updating Context in Effect Micro Module\nDESCRIPTION: The updateContext function allows modification of the Context within a Micro effect. It takes a mapping function that transforms a context of type R2 to a context of type R, and returns a function that transforms a Micro effect with environment R to one with environment R2.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Micro-updateContext.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const updateContext: { <R2, R>(f: (context: Context.Context<R2>) => Context.Context<NoInfer<R>>): <A, E>(self: Micro<A, E, R>) => Micro<A, E, R2>; <A, E, R, R2>(self: Micro<A, E, R>, f: (context: Context.Context<R2>) => Context.Context<NoInfer<R>>): Micro<A, E, R2>; }\n```\n\n----------------------------------------\n\nTITLE: Declaring the annotateCurrentSpan Function in TypeScript\nDESCRIPTION: Function signature for annotateCurrentSpan which adds key-value annotations to the currently active span. It supports two overloads: one for adding a single key-value pair and another for adding multiple key-value pairs as a record.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-annotateCurrentSpan.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const annotateCurrentSpan: { (key: string, value: unknown): Effect<void>; (values: Record<string, unknown>): Effect<void>; }\n```\n\n----------------------------------------\n\nTITLE: Testing Number Predicate using Effect in TypeScript\nDESCRIPTION: This snippet demonstrates the use of the isNumber predicate to determine if a given value is a number. It utilizes Node's assert module to verify the correctness of the predicate function. The key functionality includes importing the isNumber function from the effect/Predicate module and testing its output with different inputs, asserting true when the input is a number and false otherwise.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Predicate-isNumber.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { isNumber } from \"effect/Predicate\"\n\nassert.deepStrictEqual(isNumber(2), true)\n\nassert.deepStrictEqual(isNumber(\"2\"), false)\n```\n\n----------------------------------------\n\nTITLE: Transforming Values in TMap\nDESCRIPTION: The `transformValues` function atomically updates all values in a TMap using a provided pure function. It offers two signature variations: one that accepts a function and returns a function expecting TMap, and another that takes both the TMap and the function directly. This function is essential for functional programming paradigms where immutability and side-effect-free operations are crucial.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TMap-transformValues.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const transformValues: { <V>(f: (value: V) => V): <K>(self: TMap<K, V>) => STM.STM<void>; <K, V>(self: TMap<K, V>, f: (value: V) => V): STM.STM<void>; }\n```\n\n----------------------------------------\n\nTITLE: Stream.Do Type Signature in Effect\nDESCRIPTION: The type signature for the Stream.Do method. It shows Stream.Do returns a Stream with an empty object type, and never emits errors or values by default until other operations are chained.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-Do.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const Do: Stream<{}, never, never>\n```\n\n----------------------------------------\n\nTITLE: Implementing Unbounded Layout Algorithm in TypeScript\nDESCRIPTION: The unbounded function implements a layout algorithm that lays out a document with an Unbounded page width. It takes a Doc<A> as input and returns a DocStream<A>.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Layout-unbounded.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const unbounded: <A>(self: Doc<A>) => DocStream<A>\n```\n\n----------------------------------------\n\nTITLE: Implementing Fiber Interruption in TypeScript using Effect\nDESCRIPTION: Function signature for interruptAllAs which interrupts multiple fibers using a specified FiberId. The function is overloaded to accept parameters in two different orders - either (fiberId, fibers) or (fibers, fiberId).\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Fiber-interruptAllAs.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const interruptAllAs: { \n  (fiberId: FiberId.FiberId): (fibers: Iterable<Fiber<any, any>>) => Effect.Effect<void>; \n  (fibers: Iterable<Fiber<any, any>>, fiberId: FiberId.FiberId): Effect.Effect<void>; \n}\n```\n\n----------------------------------------\n\nTITLE: Effect.filterOrFail Function Signature in TypeScript\nDESCRIPTION: This code snippet shows the complex type signature of the Effect.filterOrFail function, including its various overloads for different use cases and type scenarios.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-filterOrFail.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const filterOrFail: { <A, B extends A, E2>(refinement: Refinement<NoInfer<A>, B>, orFailWith: (a: NoInfer<A>) => E2): <E, R>(self: Effect<A, E, R>) => Effect<B, E2 | E, R>; <A, E2>(predicate: Predicate<NoInfer<A>>, orFailWith: (a: NoInfer<A>) => E2): <E, R>(self: Effect<A, E, R>) => Effect<A, E2 | E, R>; <A, B extends A>(refinement: Refinement<NoInfer<A>, B>): <E, R>(self: Effect<A, E, R>) => Effect<B, Cause.NoSuchElementException | E, R>; <A>(predicate: Predicate<NoInfer<A>>): <E, R>(self: Effect<A, E, R>) => Effect<A, Cause.NoSuchElementException | E, R>; <A, E, R, B extends A, E2>(self: Effect<A, E, R>, refinement: Refinement<A, B>, orFailWith: (a: A) => E2): Effect<B, E | E2, R>; <A, E, R, E2>(self: Effect<A, E, R>, predicate: Predicate<A>, orFailWith: (a: A) => E2): Effect<A, E | E2, R>; <A, E, R, B extends A>(self: Effect<A, E, R>, refinement: Refinement<A, B>): Effect<B, E | Cause.NoSuchElementException, R>; <A, E, R>(self: Effect<A, E, R>, predicate: Predicate<A>): Effect<A, E | Cause.NoSuchElementException, R>; }\n```\n\n----------------------------------------\n\nTITLE: Appending an Element to an Array in TypeScript using Effect-TS\nDESCRIPTION: This code snippet demonstrates how to use the Array.append function from the Effect-TS library to add an element to the end of an array. It creates a new NonEmptyArray with the appended element.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Array-append.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Array } from \"effect\"\n\nconst result = Array.append([1, 2, 3], 4);\nconsole.log(result) // [1, 2, 3, 4]\n```\n\n----------------------------------------\n\nTITLE: Implementing Chunk Union Operation in TypeScript\nDESCRIPTION: Defines a union operation that combines two Chunks and returns a new Chunk containing unique values from both inputs. The function is overloaded to support both curried and uncurried calling styles with proper type inference.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Chunk-union.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const union: { <A>(that: Chunk<A>): <B>(self: Chunk<B>) => Chunk<A | B>; <A, B>(self: Chunk<A>, that: Chunk<B>): Chunk<A | B>; }\n```\n\n----------------------------------------\n\nTITLE: Declaring Keys Function in RedBlackTree Module\nDESCRIPTION: The `keys` function retrieves all keys present in a RedBlackTree instance in sorted order. It accepts a RedBlackTree of generic types K and V and returns an IterableIterator of keys. This utility is part of the `RedBlackTree` module in the `effect` package and requires the RedBlackTree type to be defined.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/RedBlackTree-keys.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const keys: <K, V>(self: RedBlackTree<K, V>) => IterableIterator<K>\n```\n\n----------------------------------------\n\nTITLE: Converting Option to Micro Effect in TypeScript\nDESCRIPTION: Function that transforms an Option type into a Micro effect. If the option is None, it fails with NoSuchElementException. If the option contains a value, it succeeds with that value.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Micro-fromOption.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const fromOption: <A>(option: Option.Option<A>) => Micro<A, NoSuchElementException>\n```\n\n----------------------------------------\n\nTITLE: Checking Array Containment in TypeScript using Effect Library\nDESCRIPTION: Demonstrates how to use the Array.contains function from the Effect library to check if a ReadonlyArray contains a specific value. The function returns a boolean indicating whether the value is present in the array.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Array-contains.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Array, pipe } from \"effect\"\n\nconst result = pipe(['a', 'b', 'c', 'd'], Array.contains('c'))\nconsole.log(result) // true\n```\n\n----------------------------------------\n\nTITLE: Adding Cookies with Cookies.set in TypeScript\nDESCRIPTION: Function for adding a cookie to a Cookies object. It supports both curried and direct calling styles and returns an Either type containing either the updated Cookies object or a CookiesError.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Cookies-set.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const set: { (name: string, value: string, options?: Cookie[\"options\"]): (self: Cookies) => Either.Either<Cookies, CookiesError>; (self: Cookies, name: string, value: string, options?: Cookie[\"options\"]): Either.Either<Cookies, CookiesError>; }\n```\n\n----------------------------------------\n\nTITLE: Transforming Schedule Output in Effect TS\nDESCRIPTION: The `map` function in the Effect TS Schedule module transforms the outputs of an existing schedule using a provided function `f`, without modifying its timing and recurrence behavior. This allows for adjusting the output format or applying further processing. It requires a transformation function `f` and optionally a schedule as parameters, and returns a new schedule with transformed outputs.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Schedule-map.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const map: { <Out, Out2>(f: (out: Out) => Out2): <In, R>(self: Schedule<Out, In, R>) => Schedule<Out2, In, R>; <Out, In, R, Out2>(self: Schedule<Out, In, R>, f: (out: Out) => Out2): Schedule<Out2, In, R>; }\n```\n\n----------------------------------------\n\nTITLE: Creating Stream from Effect using Stream.unwrap\nDESCRIPTION: A TypeScript function that unwraps an Effect containing a Stream into a Stream. The function handles the composition of error types and environment requirements from both the Effect and the inner Stream.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-unwrap.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const unwrap: <A, E2, R2, E, R>(effect: Effect.Effect<Stream<A, E2, R2>, E, R>) => Stream<A, E | E2, R | R2>\n```\n\n----------------------------------------\n\nTITLE: Splitting a Sink Based on Predicate in TypeScript\nDESCRIPTION: Defines a function that splits a sink on a specified predicate, creating a new sink that consumes elements until an element after the first satisfies the predicate. The function supports both curried and uncurried calling styles.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Sink-splitWhere.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const splitWhere: { <In>(f: Predicate<In>): <A, L extends In, E, R>(self: Sink<A, In, L, E, R>) => Sink<A, In, In, E, R>; <A, In, L extends In, E, R>(self: Sink<A, In, L, E, R>, f: Predicate<In>): Sink<A, In, In, E, R>; }\n```\n\n----------------------------------------\n\nTITLE: Effect.reduceWhile Function Signature in TypeScript\nDESCRIPTION: This code snippet shows the TypeScript type signature for the Effect.reduceWhile function. It defines the function's polymorphic nature and its ability to work with different types of elements and effects.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-reduceWhile.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const reduceWhile: { <Z, A, E, R>(zero: Z, options: { readonly while: Predicate<Z>; readonly body: (s: Z, a: A, i: number) => Effect<Z, E, R>; }): (elements: Iterable<A>) => Effect<Z, E, R>; <A, Z, E, R>(elements: Iterable<A>, zero: Z, options: { readonly while: Predicate<Z>; readonly body: (s: Z, a: A, i: number) => Effect<Z, E, R>; }): Effect<Z, E, R>; }\n```\n\n----------------------------------------\n\nTITLE: Intersecting Sets using Effect-TS TypeScript\nDESCRIPTION: The `intersection` function atomically transforms a set into its intersection with another set. It is part of the `TSet` module in the Effect-TS library. The function returns a STM.STM<void> type, indicating a transactional, side-effect managed operation. The main dependencies are the `TSet` type and the STM (Software Transactional Memory) framework from Effect-TS. Users must specify two `TSet` objects to perform the intersection operation. The operation assumes that the `TSet` is already initialized and compatible with other transactional operations.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TSet-intersection.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const intersection: { <A>(other: TSet<A>): (self: TSet<A>) => STM.STM<void>; <A>(self: TSet<A>, other: TSet<A>): STM.STM<void>; }\n```\n\n----------------------------------------\n\nTITLE: TypeScript Function Signature for Effect.timeoutFail\nDESCRIPTION: Shows the TypeScript type declaration for the timeoutFail function, detailing its parameters and return types. The function supports both methods and pipeline syntax for applying timeout behavior to Effect instances.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-timeoutFail.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const timeoutFail: { <E1>(options: { readonly onTimeout: LazyArg<E1>; readonly duration: Duration.DurationInput; }): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E1 | E, R>; <A, E, R, E1>(self: Effect<A, E, R>, options: { readonly onTimeout: LazyArg<E1>; readonly duration: Duration.DurationInput; }): Effect<A, E | E1, R>; }\n```\n\n----------------------------------------\n\nTITLE: Defining ConsumerCache Interface in TypeScript\nDESCRIPTION: This code snippet defines the ConsumerCache interface, which extends Cache.ConsumerVariance. It includes methods for retrieving, invalidating, and querying cache entries, as well as accessing cache statistics.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Cache-ConsumerCache.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface ConsumerCache<in out Key, out Value, out Error = never>\n  extends Cache.ConsumerVariance<Key, Value, Error>\n{\n  /**\n   * Retrieves the value associated with the specified key if it exists.\n   * Otherwise returns `Option.none`.\n   */\n  getOption(key: Key): Effect.Effect<Option.Option<Value>, Error>\n\n  /**\n   * Retrieves the value associated with the specified key if it exists and the\n   * lookup function has completed. Otherwise returns `Option.none`.\n   */\n  getOptionComplete(key: Key): Effect.Effect<Option.Option<Value>>\n\n  /**\n   * Returns statistics for this cache.\n   */\n  readonly cacheStats: Effect.Effect<CacheStats>\n\n  /**\n   * Returns whether a value associated with the specified key exists in the\n   * cache.\n   */\n  contains(key: Key): Effect.Effect<boolean>\n\n  /**\n   * Returns statistics for the specified entry.\n   */\n  entryStats(key: Key): Effect.Effect<Option.Option<EntryStats>>\n\n  /**\n   * Invalidates the value associated with the specified key.\n   */\n  invalidate(key: Key): Effect.Effect<void>\n\n  /**\n   * Invalidates the value associated with the specified key if the predicate holds.\n   */\n  invalidateWhen(key: Key, predicate: Predicate.Predicate<Value>): Effect.Effect<void>\n\n  /**\n   * Invalidates all values in the cache.\n   */\n  readonly invalidateAll: Effect.Effect<void>\n\n  /**\n   * Returns the approximate number of values in the cache.\n   */\n  readonly size: Effect.Effect<number>\n\n  /**\n   * Returns an approximation of the values in the cache.\n   */\n  readonly keys: Effect.Effect<Array<Key>>\n\n  /**\n   * Returns an approximation of the values in the cache.\n   */\n  readonly values: Effect.Effect<Array<Value>>\n\n  /**\n   * Returns an approximation of the values in the cache.\n   */\n  readonly entries: Effect.Effect<Array<[Key, Value]>>\n}\n```\n\n----------------------------------------\n\nTITLE: Declaring provideServiceEffect Function in TypeScript\nDESCRIPTION: Defines the provideServiceEffect function with two overloads. It allows dynamically providing a service implementation using an effect, useful for lazy initialization or fetching configurations.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-provideServiceEffect.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const provideServiceEffect: { <I, S, E1, R1>(tag: Context.Tag<I, S>, effect: Effect<NoInfer<S>, E1, R1>): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E | E1, R1 | Exclude<R, I>>; <A, E, R, I, S, E1, R1>(self: Effect<A, E, R>, tag: Context.Tag<I, S>, effect: Effect<NoInfer<S>, E1, R1>): Effect<A, E | E1, R1 | Exclude<R, I>>; }\n```\n\n----------------------------------------\n\nTITLE: Defining Custom Prompt Function in TypeScript\nDESCRIPTION: This code snippet defines the custom function for creating a Prompt. It takes an initial state and handlers as parameters, returning a Prompt of type Output. The initial state can be a pure value or an Effect, allowing for effectful computations in initialization.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Prompt-custom.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const custom: <State, Output>(initialState: State | Effect<State, never, Prompt.Environment>, handlers: Prompt.Handlers<State, Output>) => Prompt<Output>\n```\n\n----------------------------------------\n\nTITLE: Filtering 2xx Status Responses in HttpClient (TypeScript)\nDESCRIPTION: The filterStatusOk function is used to filter HTTP responses, allowing only those with 2xx status codes to pass through. It takes an HttpClient instance and returns a new HttpClient that includes this filtering behavior, potentially adding a ResponseError to the error type.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/HttpClient-filterStatusOk.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const filterStatusOk: <E, R>(self: HttpClient.With<E, R>) => HttpClient.With<E | Error.ResponseError, R>\n```\n\n----------------------------------------\n\nTITLE: Channel.ensuringWith TypeScript Function Signature\nDESCRIPTION: The ensuringWith function accepts a finalizer function and attaches it to a channel. The finalizer executes when the channel begins execution regardless of completion. This function provides both curried and uncurried variants.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Channel-ensuringWith.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const ensuringWith: { <OutDone, OutErr, Env2>(finalizer: (e: Exit.Exit<OutDone, OutErr>) => Effect.Effect<unknown, never, Env2>): <OutElem, InElem, InErr, InDone, Env>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>) => Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env2 | Env>; <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, Env2>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>, finalizer: (e: Exit.Exit<OutDone, OutErr>) => Effect.Effect<unknown, never, Env2>): Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env | Env2>; }\n```\n\n----------------------------------------\n\nTITLE: Setting Security Cookies in HTTP API Handlers with Effect-TS\nDESCRIPTION: Example usage of the HttpApiBuilder.securitySetCookie function to set a cookie from an HttpApiSecurity.HttpApiKey instance in an endpoint handler. This is used for authentication purposes.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/HttpApiBuilder-securitySetCookie.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nhandlers.handle(\n  \"authenticate\",\n  (_) => HttpApiBuilder.securitySetCookie(security, \"secret123\")\n)\n```\n\n----------------------------------------\n\nTITLE: Stream Merge Signature Definition\nDESCRIPTION: This section defines the TypeScript signature for the `merge` function, detailing the type parameters involved in merging streams. It outlines the inputs required for the function, including the streams to be merged and any optional halt strategies that dictate the termination behavior. This is crucial for developers to understand the typings and usage patterns when working with the Stream module.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-merge.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const merge: { <A2, E2, R2>(that: Stream<A2, E2, R2>, options?: { readonly haltStrategy?: HaltStrategy.HaltStrategyInput | undefined; } | undefined): <A, E, R>(self: Stream<A, E, R>) => Stream<A2 | A, E2 | E, R2 | R>; <A, E, R, A2, E2, R2>(self: Stream<A, E, R>, that: Stream<A2, E2, R2>, options?: { readonly haltStrategy?: HaltStrategy.HaltStrategyInput | undefined; } | undefined): Stream<A | A2, E | E2, R | R2>; }\n```\n\n----------------------------------------\n\nTITLE: Function Signature for modifyNonEmptyLast in TypeScript\nDESCRIPTION: This code snippet shows the TypeScript type signature for the `modifyNonEmptyLast` function. It demonstrates that the function can be called with the array and transformation function in either order, and specifies the input and output types.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Array-modifyNonEmptyLast.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const modifyNonEmptyLast: { <A, B>(f: (a: A) => B): (self: NonEmptyReadonlyArray<A>) => NonEmptyArray<A | B>; <A, B>(self: NonEmptyReadonlyArray<A>, f: (a: A) => B): NonEmptyArray<A | B>; }\n```\n\n----------------------------------------\n\nTITLE: Mapping Take Container Values in TypeScript\nDESCRIPTION: A type-level transformation function that applies a mapping function to the value inside a Take container, preserving the original error type. Supports both curried and direct application styles.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Take-map.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const map: { \n  <A, B>(f: (a: A) => B): <E>(self: Take<A, E>) => Take<B, E>;\n  <A, E, B>(self: Take<A, E>, f: (a: A) => B): Take<B, E>;\n}\n```\n\n----------------------------------------\n\nTITLE: Stream.aggregateWithin Function Signature in TypeScript\nDESCRIPTION: The `aggregateWithin` function aggregates stream elements using a provided sink and schedule, returning only the successful results. It's similar to `aggregateWithinEither` but filters out non-Right results.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-aggregateWithin.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const aggregateWithin: { <B, A, A2, E2, R2, C, R3>(sink: Sink.Sink<B, A | A2, A2, E2, R2>, schedule: Schedule.Schedule<C, Option.Option<B>, R3>): <E, R>(self: Stream<A, E, R>) => Stream<B, E2 | E, R2 | R3 | R>; <A, E, R, B, A2, E2, R2, C, R3>(self: Stream<A, E, R>, sink: Sink.Sink<B, A | A2, A2, E2, R2>, schedule: Schedule.Schedule<C, Option.Option<B>, R3>): Stream<B, E | E2, R | R2 | R3>; }\n```\n\n----------------------------------------\n\nTITLE: Extracting Keys from TypeScript Record\nDESCRIPTION: A type-safe function that retrieves the keys of a given record as an array of strings. Supports records with string or symbol keys and any value type. Part of the Effect-TS library's Record module.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Record-keys.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const keys: <K extends string | symbol, A>(self: ReadonlyRecord<K, A>) => Array<K & string>\n```\n\n----------------------------------------\n\nTITLE: Transforming Take to Effect in TypeScript\nDESCRIPTION: Converts a Take<A, E> type to an Effect<Chunk.Chunk<A>, Option.Option<E>>, allowing transformation of Take structures into Effect computations with optional error handling\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Take-done.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const done: <A, E>(self: Take<A, E>) => Effect.Effect<Chunk.Chunk<A>, Option.Option<E>>\n```\n\n----------------------------------------\n\nTITLE: Creating Named Time Zones with Error Handling in TypeScript\nDESCRIPTION: Function to create a named time zone from an IANA time zone identifier. Returns an Effect that resolves to a Named TimeZone or fails with an IllegalArgumentException if the time zone is invalid.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/DateTime-zoneMakeNamedEffect.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const zoneMakeNamedEffect: (zoneId: string) => Effect.Effect<TimeZone.Named, IllegalArgumentException>\n```\n\n----------------------------------------\n\nTITLE: Zipping Chunks in TypeScript using Effect Package\nDESCRIPTION: The zip function combines two Chunks pointwise, creating a new Chunk of tuples. It can be used with either curried or uncurried syntax. The function works with Chunks of different types A and B.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Chunk-zip.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const zip: { <B>(that: Chunk<B>): <A>(self: Chunk<A>) => Chunk<[A, B]>; <A, B>(self: Chunk<A>, that: Chunk<B>): Chunk<[A, B]>; }\n```\n\n----------------------------------------\n\nTITLE: Extracting Value from TArray using get\nDESCRIPTION: The 'get' function is designed to extract a value from a TArray based on the specified index. It can be called with either an index alone or with the TArray and an index, returning an STM that resolves to the element at that index. This function is mutable and defined for use in a TypeScript environment.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TArray-get.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const get: { (index: number): <A>(self: TArray<A>) => STM.STM<A>; <A>(self: TArray<A>, index: number): STM.STM<A>; }\n```\n\n----------------------------------------\n\nTITLE: Implementing Config.map Function in TypeScript\nDESCRIPTION: Defines a map function for Config objects that transforms the value produced by a config while preserving its structure. The function supports both curried and non-curried invocation styles.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Config-map.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const map: { <A, B>(f: (a: A) => B): (self: Config<A>) => Config<B>; <A, B>(self: Config<A>, f: (a: A) => B): Config<B>; }\n```\n\n----------------------------------------\n\nTITLE: Stream.split Signature - TypeScript\nDESCRIPTION: The Stream.split function offers several type signatures allowing splitting of streams based on a predicate or a refinement. It returns a new stream of chunks formed by excluding elements that satisfy the given condition. The method accepts parameters for type refinement and predicate determination, supporting versatile stream manipulations.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-split.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const split: { <A, B extends A>(refinement: Refinement<NoInfer<A>, B>): <E, R>(self: Stream<A, E, R>) => Stream<Chunk.Chunk<Exclude<A, B>>, E, R>; <A>(predicate: Predicate<NoInfer<A>>): <E, R>(self: Stream<A, E, R>) => Stream<Chunk.Chunk<A>, E, R>; <A, E, R, B extends A>(self: Stream<A, E, R>, refinement: Refinement<A, B>): Stream<Chunk.Chunk<Exclude<A, B>>, E, R>; <A, E, R>(self: Stream<A, E, R>, predicate: Predicate<A>): Stream<Chunk.Chunk<A>, E, R>; }\n```\n\n----------------------------------------\n\nTITLE: Implementing Chainable.tap Function in TypeScript\nDESCRIPTION: This code snippet defines the Chainable.tap function, which returns an effect that effectfully 'peeks' at the success of another effect. It uses complex TypeScript generics to handle various type scenarios and ensure type safety across different kinds of effects.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Chainable-tap.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const tap: <F extends TypeLambda>(F: Chainable<F>) => {\n  <A, R2, O2, E2, _>(f: (a: A) => Kind<F, R2, O2, E2, _>): <R1, O1, E1>(self: Kind<F, R1, O1, E1, A>) => Kind<F, R1 & R2, O2 | O1, E2 | E1, A>;\n  <R1, O1, E1, A, R2, O2, E2, _>(self: Kind<F, R1, O1, E1, A>, f: (a: A) => Kind<F, R2, O2, E2, _>): Kind<F, R1 & R2, O1 | O2, E1 | E2, A>;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Channel.concatAll Function in TypeScript\nDESCRIPTION: The concatAll function takes a channel that produces other channels and concatenates them sequentially into a single channel. This is useful for composing multiple channel operations that need to be executed in sequence.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Channel-concatAll.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const concatAll: <OutElem, InElem, OutErr, InErr, InDone, Env>(channels: Channel<Channel<OutElem, InElem, OutErr, InErr, any, InDone, Env>, InElem, OutErr, InErr, any, InDone, Env>) => Channel<OutElem, InElem, OutErr, InErr, any, InDone, Env>\n```\n\n----------------------------------------\n\nTITLE: Defining orElseEither Function Signature in TypeScript\nDESCRIPTION: Declares the signature of the orElseEither function, which switches to an alternative stream if the current one fails with a typed error. It returns a new stream that combines the results of both streams using Either.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-orElseEither.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const orElseEither: { <A2, E2, R2>(that: LazyArg<Stream<A2, E2, R2>>): <A, E, R>(self: Stream<A, E, R>) => Stream<Either.Either<A2, A>, E2, R2 | R>; <A, E, R, A2, E2, R2>(self: Stream<A, E, R>, that: LazyArg<Stream<A2, E2, R2>>): Stream<Either.Either<A2, A>, E2, R | R2>; }\n```\n\n----------------------------------------\n\nTITLE: Transforming Iterables into Records with Effect in TypeScript\nDESCRIPTION: The 'fromIterableWith' function takes an iterable and a projection function to generate a record. It maps each value of the iterable to a tuple containing a key and a value, which forms the record. Dependencies include 'node:assert' for assertion and 'effect/Record' for the function itself. The input is an iterable, and the output is a record with the specified key-value mappings.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Record-fromIterableWith.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { fromIterableWith } from \"effect/Record\"\n\nconst input = [1, 2, 3, 4]\n\nassert.deepStrictEqual(\n  fromIterableWith(input, a => [String(a), a * 2]),\n  { '1': 2, '2': 4, '3': 6, '4': 8 }\n)\n```\n\n----------------------------------------\n\nTITLE: Accessing Clock Service with Effect.clock in TypeScript\nDESCRIPTION: Demonstrates how to use Effect.clock to retrieve the Clock service and access the current time in milliseconds. The example shows using Effect.gen with a generator function to sequence operations.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-clock.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Effect } from \"effect\"\n\nconst program = Effect.gen(function*() {\n  const clock = yield* Effect.clock\n  const currentTime = yield* clock.currentTimeMillis\n  console.log(`Current time in milliseconds: ${currentTime}`)\n})\n\nEffect.runFork(program)\n// Example Output:\n// Current time in milliseconds: 1735484796134\n```\n\n----------------------------------------\n\nTITLE: Declaring Scoped Stream Queue Operation in TypeScript\nDESCRIPTION: This snippet declares a TypeScript function `runIntoQueueElementsScoped` which enables enqueueing elements from a stream into a specified queue while ensuring they are processed within a scoped ZIO context. It can take a queue as a parameter and returns an effect that encapsulates the stream execution. This functionality is intended for scenarios that require controlled resource management and compositional handling of effects.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-runIntoQueueElementsScoped.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const runIntoQueueElementsScoped: { <A, E>(queue: Queue.Enqueue<Exit.Exit<A, Option.Option<E>>>): <R>(self: Stream<A, E, R>) => Effect.Effect<void, never, Scope.Scope | R>; <A, E, R>(self: Stream<A, E, R>, queue: Queue.Enqueue<Exit.Exit<A, Option.Option<E>>>): Effect.Effect<void, never, Scope.Scope | R>; }\n```\n\n----------------------------------------\n\nTITLE: Implementing Stream Error Tap in TypeScript\nDESCRIPTION: A method that allows intercepting and performing side effects on stream errors without interrupting the stream's flow. Enables logging, error tracking, or additional error processing.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-tapError.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const tapError: { <E, X, E2, R2>(f: (error: NoInfer<E>) => Effect.Effect<X, E2, R2>): <A, R>(self: Stream<A, E, R>) => Stream<A, E | E2, R2 | R>; <A, E, R, X, E2, R2>(self: Stream<A, E, R>, f: (error: E) => Effect.Effect<X, E2, R2>): Stream<A, E | E2, R | R2>; }\n```\n\n----------------------------------------\n\nTITLE: Defining withMaxOpsBeforeYield Function in TypeScript\nDESCRIPTION: Defines the withMaxOpsBeforeYield function, which sets the maximum number of operations before yield by the default schedulers. It has two overloads: one that takes priority as the first argument, and another that takes the Effect as the first argument and priority as the second.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-withMaxOpsBeforeYield.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const withMaxOpsBeforeYield: { (priority: number): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R>; <A, E, R>(self: Effect<A, E, R>, priority: number): Effect<A, E, R>; }\n```\n\n----------------------------------------\n\nTITLE: Defining takeBetween Function for Queue in TypeScript\nDESCRIPTION: Declares the takeBetween function which takes a minimum and maximum number of elements from a Dequeue. It returns an Effect that resolves to a Chunk of elements. The function suspends if fewer than the minimum number of elements are available.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Queue-takeBetween.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const takeBetween: { (min: number, max: number): <A>(self: Dequeue<A>) => Effect.Effect<Chunk.Chunk<A>>; <A>(self: Dequeue<A>, min: number, max: number): Effect.Effect<Chunk.Chunk<A>>; }\n```\n\n----------------------------------------\n\nTITLE: Type Signature for Micro.tryPromise Function in TypeScript\nDESCRIPTION: The type signature for the Micro.tryPromise function, showing it accepts an options object with try and catch functions and returns a Micro effect. The try function receives an AbortSignal and returns a Promise, while the catch function converts errors to a specific type.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Micro-tryPromise.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const tryPromise: <A, E>(options: { readonly try: (signal: AbortSignal) => PromiseLike<A>; readonly catch: (error: unknown) => E; }) => Micro<A, E>\n```\n\n----------------------------------------\n\nTITLE: Defining filterLogLevel Function for Logger in TypeScript\nDESCRIPTION: This snippet defines the filterLogLevel function, which returns a modified version of a logger that only logs messages when the log level satisfies a specified predicate. It supports both curried and non-curried function calls.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Logger-filterLogLevel.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const filterLogLevel: {\n  (f: (logLevel: LogLevel.LogLevel) => boolean): <Message, Output>(self: Logger<Message, Output>) => Logger<Message, Option.Option<Output>>;\n  <Message, Output>(self: Logger<Message, Output>, f: (logLevel: LogLevel.LogLevel) => boolean): Logger<Message, Option.Option<Output>>;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Serializable Interface in TypeScript for Effect Library\nDESCRIPTION: This code snippet defines the Serializable interface, which allows objects to specify their own schema for serialization. It uses a symbol property to associate a Schema with the object.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Schema-Serializable.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface Serializable<A, I, R> {\n  readonly [symbolSerializable]: Schema<A, I, R>\n}\n```\n\n----------------------------------------\n\nTITLE: Using Effect.withLogSpan for Performance Tracking in TypeScript\nDESCRIPTION: Demonstrates how to use Effect.withLogSpan to monitor execution duration of an effect. The example shows wrapping a sleep operation with a log span that outputs timing information.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-withLogSpan.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Effect } from \"effect\"\n\nconst program = Effect.gen(function*() {\n  yield* Effect.sleep(\"1 second\")\n  yield* Effect.log(\"The job is finished!\")\n}).pipe(Effect.withLogSpan(\"myspan\"))\n\nEffect.runFork(program)\n// timestamp=... level=INFO fiber=#0 message=\"The job is finished!\" myspan=1011ms\n```\n\n----------------------------------------\n\nTITLE: Declaring DateTime Insert Field in TypeScript\nDESCRIPTION: The snippet declares a constant `DateTimeInsertFromNumber`, representing a date-time value field. This field is implemented to automatically take the current UTC date-time upon insertion, serialized as a number. It is designed to be excluded during updates but can be selected for reading. No external dependencies are required, but the `DateTime.Utc` object is necessary for time retrieval.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Model-DateTimeInsertFromNumber.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const DateTimeInsertFromNumber: DateTimeInsertFromNumber\n```\n\n----------------------------------------\n\nTITLE: Defining Ignored Test Annotation in TypeScript\nDESCRIPTION: Declares a constant 'ignored' of type TestAnnotation<number> for counting ignored tests in the Effect framework. This annotation is used to track the number of tests that have been marked as ignored during test execution.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TestAnnotation-ignored.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const ignored: TestAnnotation<number>\n```\n\n----------------------------------------\n\nTITLE: Using takeSomeSTM Function in Effect.ts TMap Module\nDESCRIPTION: This function takes all matching values from a TMap that satisfy a predicate function, or retries until there is at least one match. The predicate function processes each key-value pair and returns an STM operation. The result is a non-empty array of successfully processed values.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TMap-takeSomeSTM.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const takeSomeSTM: { <K, V, A, E, R>(pf: (key: K, value: V) => STM.STM<A, Option.Option<E>, R>): (self: TMap<K, V>) => STM.STM<[A, ...Array<A>], E, R>; <K, V, A, E, R>(self: TMap<K, V>, pf: (key: K, value: V) => STM.STM<A, Option.Option<E>, R>): STM.STM<[A, ...Array<A>], E, R>; }\n```\n\n----------------------------------------\n\nTITLE: Exposing Stream Chunks in TypeScript\nDESCRIPTION: This TypeScript snippet declares a function 'chunks' which takes a 'Stream' as input and returns a 'Stream' of 'Chunk.Chunk' elements. It allows exposing the underlying chunks of the stream as a stream itself, facilitating chunk-based processing. The function is part of the Effect-TS library starting from version 2.0.0 and can be found in the 'Stream.ts' module.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-chunks.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const chunks: <A, E, R>(self: Stream<A, E, R>) => Stream<Chunk.Chunk<A>, E, R>\n```\n\n----------------------------------------\n\nTITLE: Implementing collectAllWhileEffect in TypeScript Effect-IO\nDESCRIPTION: Function signature for collecting elements into a chunk while they satisfy a given effectful predicate. The function takes a predicate that returns an Effect boolean and returns a Sink that accumulates elements meeting the condition.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Sink-collectAllWhileEffect.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const collectAllWhileEffect: <In, E, R>(predicate: (input: In) => Effect.Effect<boolean, E, R>) => Sink<Chunk.Chunk<In>, In, In, E, R>\n```\n\n----------------------------------------\n\nTITLE: Declaring size Function in TArray for TypeScript\nDESCRIPTION: This snippet defines the signature for the size function in the TArray module. The function accepts a TArray instance and returns its size as a number. It is a generic function that works with any type of elements in the TArray.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TArray-size.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const size: <A>(self: TArray<A>) => number\n```\n\n----------------------------------------\n\nTITLE: Configuring API Key Security Scheme in TypeScript\nDESCRIPTION: Creates an API key security scheme with configurable options for key placement in header, query, or cookie. The function accepts an options object specifying the key name and optional location parameter, defaulting to 'header'.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/HttpApiSecurity-apiKey.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const apiKey: (options: { readonly key: string; readonly in?: \"header\" | \"query\" | \"cookie\" | undefined; }) => ApiKey\n```\n\n----------------------------------------\n\nTITLE: Racing Effects with One Failure in TypeScript\nDESCRIPTION: Shows the behavior of Effect.raceFirst when one task fails and the other succeeds. The failing task (task1) completes first and its failure is returned.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-raceFirst.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Effect, Console } from \"effect\"\n\nconst task1 = Effect.fail(\"task1\").pipe(\n  Effect.delay(\"100 millis\"),\n  Effect.tap(Console.log(\"task1 done\")),\n  Effect.onInterrupt(() =>\n    Console.log(\"task1 interrupted\").pipe(Effect.delay(\"100 millis\"))\n  )\n)\nconst task2 = Effect.succeed(\"task2\").pipe(\n  Effect.delay(\"200 millis\"),\n  Effect.tap(Console.log(\"task2 done\")),\n  Effect.onInterrupt(() =>\n    Console.log(\"task2 interrupted\").pipe(Effect.delay(\"100 millis\"))\n  )\n)\n\nconst program = Effect.raceFirst(task1, task2).pipe(\n  Effect.tap(Console.log(\"more work...\"))\n)\n\nEffect.runPromiseExit(program).then(console.log)\n// Output:\n// task2 interrupted\n// {\n//   _id: 'Exit',\n//   _tag: 'Failure',\n//   cause: { _id: 'Cause', _tag: 'Fail', failure: 'task1' }\n// }\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Trie.longestPrefixOf Usage in TypeScript\nDESCRIPTION: This example shows how to use the Trie.longestPrefixOf function to find the longest prefix match in a Trie data structure. It creates a Trie with several key-value pairs and demonstrates various prefix lookups.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Trie-longestPrefixOf.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { Trie, Option } from \"effect\"\n\nconst trie = Trie.empty<number>().pipe(\n  Trie.insert(\"shells\", 0),\n  Trie.insert(\"sells\", 1),\n  Trie.insert(\"she\", 2)\n)\n\nassert.deepStrictEqual(Trie.longestPrefixOf(trie, \"sell\"), Option.none())\nassert.deepStrictEqual(Trie.longestPrefixOf(trie, \"sells\"), Option.some([\"sells\", 1]))\nassert.deepStrictEqual(Trie.longestPrefixOf(trie, \"shell\"), Option.some([\"she\", 2]))\nassert.deepStrictEqual(Trie.longestPrefixOf(trie, \"shellsort\"), Option.some([\"shells\", 0]))\n```\n\n----------------------------------------\n\nTITLE: Creating ScopedRef from Effect in Typescript\nDESCRIPTION: Creates a new `ScopedRef` from an effect that resourcefully produces a value. The `fromAcquire` function takes an `Effect` that, when executed, acquires a resource of type `A`. It returns an `Effect` that yields a `ScopedRef<A>`, and handles the release of the resource when the scope is closed. The required scope is automatically added as a requirement to the returned effect.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/ScopedRef-fromAcquire.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const fromAcquire: <A, E, R>(acquire: Effect.Effect<A, E, R>) => Effect.Effect<ScopedRef<A>, E, Scope.Scope | R>\n```\n\n----------------------------------------\n\nTITLE: Using Effect.transposeMapOption with Option values in TypeScript\nDESCRIPTION: This example demonstrates how to use Effect.transposeMapOption to transform Option values. When applied to None, it returns an Effect that resolves to None without executing the mapping function. When applied to Some, it executes the mapping function on the inner value and wraps the result in Some.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-transposeMapOption.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Effect, Option, pipe } from \"effect\"\n\n//          ┌─── Effect<Option<number>, never, never>>\n//          ▼\nconst noneResult = pipe(\n  Option.none(),\n  Effect.transposeMapOption(() => Effect.succeed(42)) // will not be executed\n)\nconsole.log(Effect.runSync(noneResult))\n// Output: { _id: 'Option', _tag: 'None' }\n\n//          ┌─── Effect<Option<number>, never, never>>\n//          ▼\nconst someSuccessResult = pipe(\n  Option.some(42),\n  Effect.transposeMapOption((value) => Effect.succeed(value * 2))\n)\nconsole.log(Effect.runSync(someSuccessResult))\n// Output: { _id: 'Option', _tag: 'Some', value: 84 }\n```\n\n----------------------------------------\n\nTITLE: Defining PubSub Interface in TypeScript for Effect Library\nDESCRIPTION: This code snippet defines the PubSub interface, which represents an asynchronous message hub. It includes methods for publishing single and multiple messages, and subscribing to receive messages. The interface extends Queue.Enqueue and Pipeable.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/PubSub-PubSub.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface PubSub<in out A> extends Queue.Enqueue<A>, Pipeable {\n  /**\n   * Publishes a message to the `PubSub`, returning whether the message was published\n   * to the `PubSub`.\n   */\n  publish(value: A): Effect.Effect<boolean>\n\n  /**\n   * Publishes all of the specified messages to the `PubSub`, returning whether they\n   * were published to the `PubSub`.\n   */\n  publishAll(elements: Iterable<A>): Effect.Effect<boolean>\n\n  /**\n   * Subscribes to receive messages from the `PubSub`. The resulting subscription can\n   * be evaluated multiple times within the scope to take a message from the `PubSub`\n   * each time.\n   */\n  readonly subscribe: Effect.Effect<Queue.Dequeue<A>, never, Scope.Scope>\n}\n```\n\n----------------------------------------\n\nTITLE: Finding First Element in Transactional Array with TypeScript\nDESCRIPTION: A polymorphic function that searches a TArray and returns the first element matching a given predicate within a Software Transactional Memory (STM) context. Returns an Option containing the first matching element or None if no match is found.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TArray-findFirst.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const findFirst: { <A>(predicate: Predicate<A>): (self: TArray<A>) => STM.STM<Option.Option<A>>; <A>(self: TArray<A>, predicate: Predicate<A>): STM.STM<Option.Option<A>>; }\n```\n\n----------------------------------------\n\nTITLE: Checking Interruption RuntimeFlag in Effect.ts\nDESCRIPTION: This function checks if the Interruption RuntimeFlag is enabled in a given RuntimeFlags object. It returns true if the flag is enabled and false otherwise.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/RuntimeFlags-interruption.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const interruption: (self: RuntimeFlags) => boolean\n```\n\n----------------------------------------\n\nTITLE: Accessing Context with Effect Microservice in Typescript\nDESCRIPTION: The `service` function in the `Micro` module provides a way to access a given `Context.Tag` from the environment within the Effect-TS framework. The function signature outlines how to specify the Context Tag and the resulting Micro service.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Micro-service.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const service: { <I, S>(tag: Context.Reference<I, S>): Micro<S>; <I, S>(tag: Context.Tag<I, S>): Micro<S, never, I>; }\n```\n\n----------------------------------------\n\nTITLE: Generating FastCheck Arbitrary from Schema in TypeScript\nDESCRIPTION: The make function converts a Schema type into a fast-check Arbitrary that can generate random values of type A. This enables property-based testing for values that conform to a defined schema.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Arbitrary-make.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const make: <A, I, R>(schema: Schema.Schema<A, I, R>) => FastCheck.Arbitrary<A>\n```\n\n----------------------------------------\n\nTITLE: Defining mapInputEffect Function in Effect.ts Channel Module\nDESCRIPTION: Declaration of the mapInputEffect function that transforms an input channel's done value using an effectual function. It provides two function overloads for different parameter ordering, allowing developers to apply an Effect-producing transformation to a channel's completion value.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Channel-mapInputEffect.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const mapInputEffect: { <InDone0, InDone, InErr, Env1>(f: (i: InDone0) => Effect.Effect<InDone, InErr, Env1>): <OutElem, InElem, OutErr, OutDone, Env>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>) => Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone0, Env1 | Env>; <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, InDone0, Env1>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>, f: (i: InDone0) => Effect.Effect<InDone, InErr, Env1>): Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone0, Env | Env1>; }\n```\n\n----------------------------------------\n\nTITLE: Implementing Layer Launch Function in Effect TypeScript\nDESCRIPTION: Function signature for launching a layer that runs until interrupted. Takes a Layer with generic type parameters for input requirements (RIn), error type (E), and output type (ROut). Returns an Effect that never completes normally, may error with type E, and requires RIn.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Layer-launch.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const launch: <RIn, E, ROut>(self: Layer<ROut, E, RIn>) => Effect.Effect<never, E, RIn>\n```\n\n----------------------------------------\n\nTITLE: Declaring scheduleFrom Function in TypeScript\nDESCRIPTION: Declares the scheduleFrom function, which runs an effect repeatedly according to a schedule. It takes an initial input value and a schedule, and returns an effect that completes when the schedule ends or the effect fails.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-scheduleFrom.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const scheduleFrom: { <R2, In, Out>(initial: In, schedule: Schedule.Schedule<Out, In, R2>): <E, R>(self: Effect<In, E, R>) => Effect<Out, E, R2 | R>; <In, E, R, R2, Out>(self: Effect<In, E, R>, initial: In, schedule: Schedule.Schedule<Out, In, R2>): Effect<Out, E, R | R2>; }\n```\n\n----------------------------------------\n\nTITLE: Converting Strings to BigDecimal Objects in TypeScript\nDESCRIPTION: Demonstrates how to parse numerical strings into BigDecimal objects. The function returns an Option type containing the BigDecimal if parsing succeeds, or None if the string is not a valid number.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/BigDecimal-fromString.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { BigDecimal, Option } from \"effect\"\n\nassert.deepStrictEqual(BigDecimal.fromString(\"123\"), Option.some(BigDecimal.make(123n, 0)))\nassert.deepStrictEqual(BigDecimal.fromString(\"123.456\"), Option.some(BigDecimal.make(123456n, 3)))\nassert.deepStrictEqual(BigDecimal.fromString(\"123.abc\"), Option.none())\n```\n\n----------------------------------------\n\nTITLE: Flattening Streams in TypeScript with Effect IO\nDESCRIPTION: A type-safe function to flatten streams of streams, supporting optional concurrency and buffer size configurations. Concatenates inner streams in strict order, with the ability to control parallel processing.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-flatten.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const flatten: { (options?: { readonly concurrency?: number | \"unbounded\" | undefined; readonly bufferSize?: number | undefined; } | undefined): <A, E2, R2, E, R>(self: Stream<Stream<A, E2, R2>, E, R>) => Stream<A, E2 | E, R2 | R>; <A, E2, R2, E, R>(self: Stream<Stream<A, E2, R2>, E, R>, options?: { readonly concurrency?: number | \"unbounded\" | undefined; readonly bufferSize?: number | undefined; } | undefined): Stream<A, E2 | E, R2 | R>; }\n```\n\n----------------------------------------\n\nTITLE: Converting Duration to Human-Readable String in TypeScript\nDESCRIPTION: Demonstrates the usage of Duration.format function to convert Duration objects to human-readable strings. It shows examples of formatting durations of 1000 milliseconds (1 second) and 1001 milliseconds.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Duration-format.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Duration } from \"effect\"\n\nDuration.format(Duration.millis(1000)) // \"1s\"\nDuration.format(Duration.millis(1001)) // \"1s 1ms\"\n```\n\n----------------------------------------\n\nTITLE: Transforming Elements Atomically in TSet using TypeScript\nDESCRIPTION: This snippet defines the 'transformSTM' function in TypeScript, enabling atomic transformation of all elements in a TSet with a specified transactional function. It provides a flexible signature allowing the function to be applied either as a curried function or in a direct invocation style. This is essential for applications requiring safe concurrent updates to data structures.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TSet-transformSTM.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const transformSTM: { <A, R, E>(f: (a: A) => STM.STM<A, E, R>): (self: TSet<A>) => STM.STM<void, E, R>; <A, R, E>(self: TSet<A>, f: (a: A) => STM.STM<A, E, R>): STM.STM<void, E, R>; }\n```\n\n----------------------------------------\n\nTITLE: Defining chunksOf Function for Splitting Iterables in TypeScript\nDESCRIPTION: Declares the chunksOf function which splits an Iterable into length-n pieces. The function is overloaded to accept either the chunk size first or the Iterable first. The last chunk may be shorter if n doesn't evenly divide the Iterable's length.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Iterable-chunksOf.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const chunksOf: { (n: number): <A>(self: Iterable<A>) => Iterable<Array<A>>; <A>(self: Iterable<A>, n: number): Iterable<Array<A>>; }\n```\n\n----------------------------------------\n\nTITLE: Creating DateTime.Zoned Object in TypeScript\nDESCRIPTION: Demonstrates how to use the DateTime.makeZoned function to create a DateTime.Zoned object. The function takes a Date object and an options object with a timeZone property.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/DateTime-makeZoned.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { DateTime } from \"effect\"\n\nDateTime.makeZoned(new Date(), { timeZone: \"Europe/London\" })\n```\n\n----------------------------------------\n\nTITLE: Array.groupBy Function Signature in TypeScript\nDESCRIPTION: The type signature for the Array.groupBy function, which supports both curried and non-curried usage. It takes an iterable and a key-generating function, returning a record of non-empty arrays grouped by the generated keys.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Array-groupBy.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const groupBy: { <A, K extends string | symbol>(f: (a: A) => K): (self: Iterable<A>) => Record<Record.ReadonlyRecord.NonLiteralKey<K>, NonEmptyArray<A>>; <A, K extends string | symbol>(self: Iterable<A>, f: (a: A) => K): Record<Record.ReadonlyRecord.NonLiteralKey<K>, NonEmptyArray<A>>; }\n```\n\n----------------------------------------\n\nTITLE: Implementing takeUpTo Function for Queue in TypeScript\nDESCRIPTION: Defines the takeUpTo function which takes up to a maximum number of values from a queue. It returns an Effect containing a Chunk of values. The function is overloaded to accept parameters in different orders.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Queue-takeUpTo.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const takeUpTo: { (max: number): <A>(self: Dequeue<A>) => Effect.Effect<Chunk.Chunk<A>>; <A>(self: Dequeue<A>, max: number): Effect.Effect<Chunk.Chunk<A>>; }\n```\n\n----------------------------------------\n\nTITLE: Declaring Mutable Schema Function in TypeScript\nDESCRIPTION: This TypeScript function declaration, named 'mutable', generates a new schema with shallow mutable properties from an existing schema. It uses generic typing to operate on any schema type ('S extends Schema.Any') and returns a mutable version of it. A prerequisite is the 'effect' package, particularly the Schema module.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Schema-mutable.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const mutable: <S extends Schema.Any>(schema: S) => mutable<S>\n```\n\n----------------------------------------\n\nTITLE: Testing Non-Null Values with Effect Predicate in TypeScript\nDESCRIPTION: This code snippet demonstrates the use of the 'isNotNull' function from the Effect library's Predicate module to test if a given value is not null. The 'assert' module from Node.js is used to verify the expected outcomes. The function 'isNotNull' takes an input of any type and returns a boolean indicating if the input is not null. It requires the Effect library to be installed and is available since version 2.0.0.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Predicate-isNotNull.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { isNotNull } from \"effect/Predicate\"\n\nassert.deepStrictEqual(isNotNull(undefined), true)\nassert.deepStrictEqual(isNotNull(\"null\"), true)\n\nassert.deepStrictEqual(isNotNull(null), false)\n```\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const isNotNull: <A>(input: A) => input is Exclude<A, null>\n```\n\n----------------------------------------\n\nTITLE: Array.mapAccum Function Signature in TypeScript\nDESCRIPTION: The type signature for the Array.mapAccum function, which allows for stateful mapping over an iterable, producing new elements of type B and accumulating a state of type S.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Array-mapAccum.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const mapAccum: { <S, A, B, I extends Iterable<A> = Iterable<A>>(s: S, f: (s: S, a: ReadonlyArray.Infer<I>, i: number) => readonly [S, B]): (self: I) => [state: S, mappedArray: ReadonlyArray.With<I, B>]; <S, A, B, I extends Iterable<A> = Iterable<A>>(self: I, s: S, f: (s: S, a: ReadonlyArray.Infer<I>, i: number) => readonly [S, B]): [state: S, mappedArray: ReadonlyArray.With<I, B>]; }\n```\n\n----------------------------------------\n\nTITLE: Declaring Stream FilterMap Function in TypeScript\nDESCRIPTION: This TypeScript code snippet declares a `filterMap` function that operates on streams. It allows the user to pass a partial function `pf`, which filters and maps input stream elements of type `A` to output stream elements of type `B` if the transformation produces a value. This method is part of a stream-processing library requiring familiarity with Option types and is utilized to efficiently handle stream data by combining filter and map operations.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-filterMap.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const filterMap: { <A, B>(pf: (a: A) => Option.Option<B>): <E, R>(self: Stream<A, E, R>) => Stream<B, E, R>; <A, E, R, B>(self: Stream<A, E, R>, pf: (a: A) => Option.Option<B>): Stream<B, E, R>; }\n```\n\n----------------------------------------\n\nTITLE: Creating an Empty Trie in TypeScript using Effect\nDESCRIPTION: This example demonstrates how to create an empty Trie using the Trie.empty() function from the Effect package. It also shows how to verify the size of the empty Trie and that it contains no elements.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Trie-empty.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { Trie, Equal } from \"effect\"\n\nconst trie = Trie.empty<string>()\n\nassert.equal(Trie.size(trie), 0)\nassert.deepStrictEqual(Array.from(trie), [])\n```\n\n----------------------------------------\n\nTITLE: Effect Schema parseJson Signature\nDESCRIPTION: This code snippet displays the signature of the `parseJson` function, showcasing its ability to accept a schema and optional parse options or just parse options. It shows the generic type constraints and return type of the function.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Schema-parseJson.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const parseJson: { <S extends Schema.Any>(schema: S, options?: ParseJsonOptions): transform<SchemaClass<unknown, string>, S>; (options?: ParseJsonOptions): SchemaClass<unknown, string>; }\n```\n\n----------------------------------------\n\nTITLE: Defining provideContext Function for Stream in TypeScript\nDESCRIPTION: Declares the provideContext function which takes a Context and a Stream as input, and returns a new Stream without the R dependency. It can be called with arguments in either order.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-provideContext.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const provideContext: { <R>(context: Context.Context<R>): <A, E>(self: Stream<A, E, R>) => Stream<A, E>; <A, E, R>(self: Stream<A, E, R>, context: Context.Context<R>): Stream<A, E>; }\n```\n\n----------------------------------------\n\nTITLE: Creating a No-op Runner Health Layer in TypeScript\nDESCRIPTION: A layer implementation that always considers a Runner healthy, regardless of actual status. This layer is particularly useful for testing scenarios where you want to bypass health checks.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/RunnerHealth-layerNoop.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const layerNoop: Layer.Layer<RunnerHealth, never, never>\n```\n\n----------------------------------------\n\nTITLE: Converting TMap to ReadonlyMap in TypeScript Effect Library\nDESCRIPTION: The toMap function collects all key-value bindings from a TMap and returns them as a ReadonlyMap wrapped in an STM transaction. This allows for safely retrieving the map's contents within the STM transactional context.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TMap-toMap.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const toMap: <K, V>(self: TMap<K, V>) => STM.STM<ReadonlyMap<K, V>>\n```\n\n----------------------------------------\n\nTITLE: Providing Context with STM in TypeScript\nDESCRIPTION: The 'provideSomeContext' function splits a given context into two parts, allowing one to be utilized by a specified layer while leaving the remainder intact. This is useful for maintaining state across different layers of a functional application. The function supports two signatures: one for providing the context alongside an STM instance and another that allows context to be applied after the STM instance is defined.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/STM-provideSomeContext.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const provideSomeContext: { <R>(context: Context.Context<R>): <R1, E, A>(self: STM<A, E, R1>) => STM<A, E, Exclude<R1, R>>; <R, R1, E, A>(self: STM<A, E, R1>, context: Context.Context<R>): STM<A, E, Exclude<R1, R>>; }\n```\n\n----------------------------------------\n\nTITLE: Declaring a Sink with Finalizer in TypeScript\nDESCRIPTION: This TypeScript snippet demonstrates the declaration of a `Sink` with an attached finalizer using the Effect-TS library. It defines the `ensuring` function, which guarantees the execution of a finalizer as soon as the sink begins. Dependencies include the Effect-TS library with its Sink module. Key parameters of the function are the sink object and its finalizer, which will ensure execution post sink initiation. This approach adheres to version v2.0.0 of the library.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Sink-ensuring.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const ensuring: { <X, R2>(finalizer: Effect.Effect<X, never, R2>): <A, In, L, E, R>(self: Sink<A, In, L, E, R>) => Sink<A, In, L, E, R2 | R>; <A, In, L, E, R, X, R2>(self: Sink<A, In, L, E, R>, finalizer: Effect.Effect<X, never, R2>): Sink<A, In, L, E, R | R2>; }\n```\n\n----------------------------------------\n\nTITLE: Declaring Effect.withClock Function in TypeScript\nDESCRIPTION: Function signature for the withClock method that allows executing an Effect workflow with a specified Clock service implementation. The function is overloaded to support different calling patterns.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-withClock.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const withClock: { <C extends Clock.Clock>(clock: C): <A, E, R>(effect: Effect<A, E, R>) => Effect<A, E, R>; <C extends Clock.Clock, A, E, R>(effect: Effect<A, E, R>, clock: C): Effect<A, E, R>; }\n```\n\n----------------------------------------\n\nTITLE: Creating Unique Value Intersections Between Multiple Chunks in TypeScript\nDESCRIPTION: The intersection function creates a Chunk containing unique values that are included in all given Chunks. The order and references of resulting values are determined by the original Chunk. This function can be used with both curried and uncurried syntax patterns.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Chunk-intersection.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const intersection: { <A>(that: Chunk<A>): <B>(self: Chunk<B>) => Chunk<A & B>; <A, B>(self: Chunk<A>, that: Chunk<B>): Chunk<A & B>; }\n```\n\n----------------------------------------\n\nTITLE: Retrieving Services with Fallback using Context.getOrElse in TypeScript\nDESCRIPTION: The getOrElse function retrieves a service from the context that corresponds to a given tag. If the service is not found, it returns the provided fallback value. It supports both curried and uncurried calling styles.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Context-getOrElse.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const getOrElse: { <S, I, B>(tag: Tag<I, S>, orElse: LazyArg<B>): <Services>(self: Context<Services>) => S | B; <Services, S, I, B>(self: Context<Services>, tag: Tag<I, S>, orElse: LazyArg<B>): S | B; }\n```\n\n----------------------------------------\n\nTITLE: Function Signature for filterEffectOrElse in TypeScript\nDESCRIPTION: The type definition for the filterEffectOrElse function, showing its polymorphic interface with two overloads. It accepts options with a predicate function that returns an Effect of boolean and an orElse function that provides an alternative Effect.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-filterEffectOrElse.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const filterEffectOrElse: { <A, E2, R2, A2, E3, R3>(options: { readonly predicate: (a: NoInfer<A>) => Effect<boolean, E2, R2>; readonly orElse: (a: NoInfer<A>) => Effect<A2, E3, R3>; }): <E, R>(self: Effect<A, E, R>) => Effect<A | A2, E | E2 | E3, R | R2 | R3>; <A, E, R, E2, R2, A2, E3, R3>(self: Effect<A, E, R>, options: { readonly predicate: (a: A) => Effect<boolean, E2, R2>; readonly orElse: (a: A) => Effect<A2, E3, R3>; }): Effect<A | A2, E | E2 | E3, R | R2 | R3>; }\n```\n\n----------------------------------------\n\nTITLE: Defining the validateWith Function in TypeScript\nDESCRIPTION: TypeScript type signature for the validateWith function, which combines two effects sequentially while accumulating errors. The function provides options for concurrent execution, batching, and finalizer behavior.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-validateWith.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const validateWith: { <B, E1, R1, A, C>(that: Effect<B, E1, R1>, f: (a: A, b: B) => C, options?: { readonly concurrent?: boolean | undefined; readonly batching?: boolean | \"inherit\" | undefined; readonly concurrentFinalizers?: boolean | undefined; } | undefined): <E, R>(self: Effect<A, E, R>) => Effect<C, E1 | E, R1 | R>; <A, E, R, B, E1, R1, C>(self: Effect<A, E, R>, that: Effect<B, E1, R1>, f: (a: A, b: B) => C, options?: { readonly concurrent?: boolean | undefined; readonly batching?: boolean | \"inherit\" | undefined; readonly concurrentFinalizers?: boolean | undefined; } | undefined): Effect<C, E | E1, R | R1>; }\n```\n\n----------------------------------------\n\nTITLE: Defining catchAll Function in TypeScript for Layer Module\nDESCRIPTION: Declares the catchAll function which recovers from all errors in a Layer. It takes an error handler function and returns a new Layer that combines the original Layer with error recovery.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Layer-catchAll.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const catchAll: { <E, RIn2, E2, ROut2>(onError: (error: E) => Layer<ROut2, E2, RIn2>): <RIn, ROut>(self: Layer<ROut, E, RIn>) => Layer<ROut & ROut2, E2, RIn2 | RIn>; <RIn, E, ROut, RIn2, E2, ROut2>(self: Layer<ROut, E, RIn>, onError: (error: E) => Layer<ROut2, E2, RIn2>): Layer<ROut & ROut2, E2, RIn | RIn2>; }\n```\n\n----------------------------------------\n\nTITLE: Updating Multiple FiberRef Values with FiberId in TypeScript\nDESCRIPTION: The `updateManyAs` function provides a way to update the values of multiple specified `FiberRef` & value pairs using a provided `FiberId`. It supports both curried and non-curried calling styles, allowing flexible usage patterns.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/FiberRefs-updateManyAs.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const updateManyAs: { (options: { readonly forkAs?: FiberId.Single | undefined; readonly entries: readonly [readonly [FiberRef.FiberRef<any>, readonly [readonly [FiberId.Single, any], ...Array<readonly [FiberId.Single, any]>]], ...Array<readonly [FiberRef.FiberRef<any>, readonly [readonly [FiberId.Single, any], ...Array<readonly [FiberId.Single, any]>]]>]; }): (self: FiberRefs) => FiberRefs; (self: FiberRefs, options: { readonly forkAs?: FiberId.Single | undefined; readonly entries: readonly [readonly [FiberRef.FiberRef<any>, readonly [readonly [FiberId.Single, any], ...Array<readonly [FiberId.Single, any]>]], ...Array<readonly [FiberRef.FiberRef<any>, readonly [readonly [FiberId.Single, any], ...Array<readonly [FiberId.Single, any]>]]>]; }): FiberRefs; }\n```\n\n----------------------------------------\n\nTITLE: Implementing Exit.zip Function in TypeScript\nDESCRIPTION: Defines a zip function that combines two Exit values into a tuple result. If either Exit is failed, returns the combined failure Cause. The function is overloaded to support both curried and uncurried forms.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Exit-zip.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const zip: { \n  <A2, E2>(that: Exit<A2, E2>): <A, E>(self: Exit<A, E>) => Exit<[A, A2], E2 | E>; \n  <A, E, A2, E2>(self: Exit<A, E>, that: Exit<A2, E2>): Exit<[A, A2], E | E2>; \n}\n```\n\n----------------------------------------\n\nTITLE: Converting Optional Properties in TypeScript with Effect Schema\nDESCRIPTION: This snippet defines the `optionalToOptional` function, which allows for the transformation of optional properties between different schema types, using custom encode and decode functions. It accepts two schemas as inputs and returns a new property signature for the transformed optional property. Dependencies include the Effect library's Option type and Schema type.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Schema-optionalToOptional.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const optionalToOptional: <FA, FI, FR, TA, TI, TR>(from: Schema<FA, FI, FR>, to: Schema<TA, TI, TR>, options: { readonly decode: (o: option_.Option<FA>) => option_.Option<TI>; readonly encode: (o: option_.Option<TI>) => option_.Option<FA>; }) => PropertySignature<\"?:\", TA, never, \"?:\", FI, false, FR | TR>\n```\n\n----------------------------------------\n\nTITLE: Using Array.difference in TypeScript with Effect\nDESCRIPTION: Demonstrates how to use the Array.difference function to create an array of values from the first iterable that are not present in the second iterable. The order and references of result values are determined by the first iterable.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Array-difference.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Array } from \"effect\"\n\nconst difference = Array.difference([1, 2, 3], [2, 3, 4])\nconsole.log(difference) // [1]\n```\n\n----------------------------------------\n\nTITLE: Finding Index Using Effect Library in TypeScript\nDESCRIPTION: The `findFirstIndexFrom` function is used to obtain the first index of a given value in a TArray, starting the search at a specified index. This function is declared as part of the Effect-TS library and is invoked within a transactional STM context. The function accepts three parameters: a value to search, a starting index, and optionally, the TArray itself. The output is an STM wrapping an Option of number, representing the index if found, or none if not. Ensure Effect-TS is installed to utilize this function.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TArray-findFirstIndexFrom.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const findFirstIndexFrom: { <A>(value: A, from: number): (self: TArray<A>) => STM.STM<Option.Option<number>>; <A>(self: TArray<A>, value: A, from: number): STM.STM<Option.Option<number>>; }\n```\n\n----------------------------------------\n\nTITLE: Validating Upstream Pull Requests in TypeScript\nDESCRIPTION: The `isUpstreamPullRequest` function checks if a given value is of the type `UpstreamPullRequest`. This is a type guard function declaring that if the function returns true, the unknown value can safely be used as an `UpstreamPullRequest`. There are no specific parameters other than the input value to be checked. The function outputs a boolean value. It requires the UpstreamPullRequest type definition and is an essential part of filtering and validating data within the module.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/UpstreamPullRequest-isUpstreamPullRequest.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const isUpstreamPullRequest: (u: unknown) => u is UpstreamPullRequest<unknown>\n```\n\n----------------------------------------\n\nTITLE: Checking FiberStatus Type in TypeScript\nDESCRIPTION: This function is a type guard that checks if the provided value is of type FiberStatus. It returns true if the value is a FiberStatus, and false otherwise. This can be useful for runtime type checking and type narrowing in TypeScript.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/FiberStatus-isFiberStatus.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const isFiberStatus: (u: unknown) => u is FiberStatus\n```\n\n----------------------------------------\n\nTITLE: Decoding Base64 URL Strings in TypeScript\nDESCRIPTION: Function signature for decoding base64 URL-encoded strings into Uint8Arrays. Returns an Either type that contains either the decoded Uint8Array or a DecodeException in case of failure.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Encoding-decodeBase64Url.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const decodeBase64Url: (str: string) => Either.Either<Uint8Array, DecodeException>\n```\n\n----------------------------------------\n\nTITLE: Implementing Record Union Operation in TypeScript\nDESCRIPTION: Function signature for merging two records while preserving entries from both. It provides two overloads: one taking a record and combine function, and another taking two records and a combine function. The combine function determines how to merge overlapping values.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Record-union.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const union: { \n  <K1 extends string, A, B, C>(that: ReadonlyRecord<K1, B>, combine: (selfValue: A, thatValue: B) => C): <K0 extends string>(self: ReadonlyRecord<K0, A>) => Record<K0 | K1, A | B | C>; \n  <K0 extends string, A, K1 extends string, B, C>(self: ReadonlyRecord<K0, A>, that: ReadonlyRecord<K1, B>, combine: (selfValue: A, thatValue: B) => C): Record<K0 | K1, A | B | C>; \n}\n```\n\n----------------------------------------\n\nTITLE: Subscribing to TPubSub with Scoped Lifetime in TypeScript\nDESCRIPTION: Creates a scoped subscription to a TPubSub instance. The subscription returns a TDequeue that can be used multiple times within the scope to retrieve messages from the TPubSub.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TPubSub-subscribeScoped.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const subscribeScoped: <A>(self: TPubSub<A>) => Effect.Effect<TQueue.TDequeue<A>, never, Scope.Scope>\n```\n\n----------------------------------------\n\nTITLE: Updating Service in Micro Environment with Context.Tag or Reference in TypeScript\nDESCRIPTION: Function signature for updateService which allows modifying a service in the environment. It supports various overloads for working with Context.Tag or Context.Reference, enabling functional updates to services within a Micro effect. Available since v3.11.0.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Micro-updateService.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const updateService: { <I, A>(tag: Context.Reference<I, A>, f: (value: A) => A): <XA, E, R>(self: Micro<XA, E, R>) => Micro<XA, E, R>; <I, A>(tag: Context.Tag<I, A>, f: (value: A) => A): <XA, E, R>(self: Micro<XA, E, R>) => Micro<XA, E, R | I>; <XA, E, R, I, A>(self: Micro<XA, E, R>, tag: Context.Reference<I, A>, f: (value: A) => A): Micro<XA, E, R>; <XA, E, R, I, A>(self: Micro<XA, E, R>, tag: Context.Tag<I, A>, f: (value: A) => A): Micro<XA, E, R | I>; }\n```\n\n----------------------------------------\n\nTITLE: Defining STM.tapBoth for Transactional Effects in TypeScript\nDESCRIPTION: This code snippet defines the tapBoth function that enables transactional effects to handle both success and failure outcomes effectively. It accepts options for success and failure handlers, which return transactional effects, and applies them to an STM instance. This allows the user to define specific behavior for different outcomes in a safe and type-checked manner.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/STM-tapBoth.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const tapBoth: { <XE extends E, A2, E2, R2, XA extends A, A3, E3, R3, A, E>(options: { readonly onFailure: (error: XE) => STM<A2, E2, R2>; readonly onSuccess: (value: XA) => STM<A3, E3, R3>; }): <R>(self: STM<A, E, R>) => STM<A, E | E2 | E3, R2 | R3 | R>; <A, E, R, XE extends E, A2, E2, R2, XA extends A, A3, E3, R3>(self: STM<A, E, R>, options: { readonly onFailure: (error: XE) => STM<A2, E2, R2>; readonly onSuccess: (value: XA) => STM<A3, E3, R3>; }): STM<A, E | E2 | E3, R | R2 | R3>; }\n```\n\n----------------------------------------\n\nTITLE: Match.tagsExhaustive Type Definition\nDESCRIPTION: Type signature for the tagsExhaustive function showing its generic parameters and return type. Handles pattern matching on discriminated unions with _tag field.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Match-tagsExhaustive.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const tagsExhaustive: <R, Ret, P extends { readonly [Tag in Types.Tags<\"_tag\", R> & string]: (_: Extract<R, Record<\"_tag\", Tag>>) => Ret; } & { readonly [Tag in Exclude<keyof P, Types.Tags<\"_tag\", R>>]: never; }>(fields: P) => <I, F, A, Pr>(self: Matcher<I, F, R, A, Pr, Ret>) => [Pr] extends [never] ? (u: I) => Unify<A | ReturnType<P[keyof P]>> : Unify<A | ReturnType<P[keyof P]>>\n```\n\n----------------------------------------\n\nTITLE: SemigroupMin Signature in Typescript\nDESCRIPTION: This code shows the type declaration of the `SemigroupMin` constant. It declares `SemigroupMin` as a `semigroup.Semigroup<number>`, indicating that it is a semigroup instance that operates on numbers.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/data-Number-SemigroupMin.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const SemigroupMin: semigroup.Semigroup<number>\n```\n\n----------------------------------------\n\nTITLE: Building a Record from Key-Value Pairs using TypeScript\nDESCRIPTION: This code snippet demonstrates the usage of the 'fromEntries' function from 'effect/Record' to create a record from an array of key-value pairs. It imports necessary modules and asserts the correctness of the resulting record. The function will overwrite previous values if there are conflicting keys.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Record-fromEntries.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { fromEntries } from \"effect/Record\"\n\nconst input: Array<[string, number]> = [[\"a\", 1], [\"b\", 2]]\n\nassert.deepStrictEqual(fromEntries(input), { a: 1, b: 2 })\n```\n\n----------------------------------------\n\nTITLE: Using BigInt.subtract Function in TypeScript\nDESCRIPTION: Example demonstrating how to use the subtract function from the BigInt module to perform subtraction on bigint values. The function subtracts the second argument from the first.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/BigInt-subtract.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { subtract } from \"effect/BigInt\"\n\nassert.deepStrictEqual(subtract(2n, 3n), -1n)\n```\n\n----------------------------------------\n\nTITLE: Consuming Stream Elements Using runForEachChunk\nDESCRIPTION: The runForEachChunk function consumes elements from a Stream, applying a specified callback to each Chunk. It can be used either as a standalone function or as a method on a Stream instance. The function expects a callback that takes a Chunk of type A and returns an Effect, offering a flexible way to handle stream processing.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-runForEachChunk.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const runForEachChunk: { <A, X, E2, R2>(f: (a: Chunk.Chunk<A>) => Effect.Effect<X, E2, R2>): <E, R>(self: Stream<A, E, R>) => Effect.Effect<void, E2 | E, R2 | R>; <A, E, R, X, E2, R2>(self: Stream<A, E, R>, f: (a: Chunk.Chunk<A>) => Effect.Effect<X, E2, R2>): Effect.Effect<void, E | E2, R | R2>; };\n```\n\n----------------------------------------\n\nTITLE: Schedule Composition with andThen in Effect\nDESCRIPTION: The `andThen` function combines two schedules, executing them sequentially.  The first schedule `self` runs to completion, then the second schedule `that` begins.  The output types are merged (`Out | Out2`), and the input types are intersected (`In & In2`).\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Schedule-andThen.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const andThen: { <Out2, In2, R2>(that: Schedule<Out2, In2, R2>): <Out, In, R>(self: Schedule<Out, In, R>) => Schedule<Out2 | Out, In & In2, R2 | R>; <Out, In, R, Out2, In2, R2>(self: Schedule<Out, In, R>, that: Schedule<Out2, In2, R2>): Schedule<Out | Out2, In & In2, R | R2>; }\n```\n\n----------------------------------------\n\nTITLE: Taking a Value from TPriorityQueue in TypeScript\nDESCRIPTION: This function takes a value from the priority queue, retrying until a value is available in the queue. It operates within the STM (Software Transactional Memory) context of the Effect-TS library.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TPriorityQueue-take.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const take: <A>(self: TPriorityQueue<A>) => STM.STM<A>\n```\n\n----------------------------------------\n\nTITLE: Creating TArray from Iterable in TypeScript\nDESCRIPTION: This snippet defines a function that constructs a new TArray from an iterable collection. It utilizes the STM framework for transactional memory operations. The generic function accepts an iterable of any type <A> and returns an STM monad encapsulating a TArray of type <A>. This requires the 'effect' package and specifically the TArray module from Effect-TS.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TArray-fromIterable.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const fromIterable: <A>(iterable: Iterable<A>) => STM.STM<TArray<A>>\n```\n\n----------------------------------------\n\nTITLE: Getting RedBlackTree Size in Typescript\nDESCRIPTION: The `size` function retrieves the number of key-value pairs stored in a `RedBlackTree`. It accepts a `RedBlackTree` as input and returns a number representing the size of the tree. The function is part of the `effect` package.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/RedBlackTree-size.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const size: <K, V>(self: RedBlackTree<K, V>) => number\n```\n\n----------------------------------------\n\nTITLE: Combining Schedules in TypeScript\nDESCRIPTION: The 'scheduleUnion' function merges two MicroSchedules, deciding to recur if either requires it and using the minimum duration between recurrences. The function is defined in two signatures, allowing for flexible use. It does not list any specific prerequisites, but it operates within the Effect-TS library's Micro module, indicating a dependency on this ecosystem. Typically, inputs include two MicroSchedules, and it outputs a combined schedule. It has the constraint of relying on correctly implemented MicroSchedules.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Micro-scheduleUnion.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const scheduleUnion: { (that: MicroSchedule): (self: MicroSchedule) => MicroSchedule; (self: MicroSchedule, that: MicroSchedule): MicroSchedule; }\n```\n\n----------------------------------------\n\nTITLE: Awaiting TPubSub Shutdown in TypeScript\nDESCRIPTION: This function allows waiting until a TPubSub instance is shutdown. It returns an STM that will not resume until the queue has been shutdown. If the TPubSub is already shutdown, the STM will resume immediately.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TPubSub-awaitShutdown.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const awaitShutdown: <A>(self: TPubSub<A>) => STM.STM<void>\n```\n\n----------------------------------------\n\nTITLE: Replacing Array Element with Option in TypeScript\nDESCRIPTION: Demonstrates how to use the Array.replaceOption function to replace an element in an array, returning an Option of the updated array. This function is part of the effect package.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Array-replaceOption.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Array } from \"effect\"\n\nconst result = Array.replaceOption([1, 2, 3], 1, 4)\nconsole.log(result) // Option.some([1, 4, 3])\n```\n\n----------------------------------------\n\nTITLE: Removing Elements with Predicate from TPriorityQueue in TypeScript\nDESCRIPTION: The removeIf function removes all elements from a priority queue that match a specified predicate. It's implemented as an STM transaction that allows for composable, atomic operations on the queue.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TPriorityQueue-removeIf.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const removeIf: { <A>(predicate: Predicate<A>): (self: TPriorityQueue<A>) => STM.STM<void>; <A>(self: TPriorityQueue<A>, predicate: Predicate<A>): STM.STM<void>; }\n```\n\n----------------------------------------\n\nTITLE: Generating Random Integer with Effect in TypeScript\nDESCRIPTION: This function returns the next integer value from a pseudo-random number generator. It uses the Effect type to represent the computation, which has no input requirements and no error type.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Random-nextInt.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const nextInt: Effect.Effect<number, never, never>\n```\n\n----------------------------------------\n\nTITLE: Defining Reloadable Interface in TypeScript\nDESCRIPTION: Defines a generic Reloadable interface that extends Reloadable.Variance<A>. Contains two internal properties: scopedRef for managing the scoped reference to the implementation, and reload for handling the reloading functionality.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Reloadable-Reloadable.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface Reloadable<in out A> extends Reloadable.Variance<A> {\n  /**\n   * @internal\n   */\n  readonly scopedRef: ScopedRef.ScopedRef<A>\n  /**\n   * @internal\n   */\n  readonly reload: Effect.Effect<void, unknown>\n}\n```\n\n----------------------------------------\n\nTITLE: Parsing Cookie Headers in TypeScript with Effect Platform\nDESCRIPTION: This function parses a cookie header string into a record of key-value pairs. The implementation is adapted from the fastify-cookie library under MIT License.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Cookies-parseHeader.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const parseHeader: (header: string) => Record<string, string>\n```\n\n----------------------------------------\n\nTITLE: Using fill() for Formatting Function Signatures in TypeScript\nDESCRIPTION: This example demonstrates how to use the `fill` combinator to create a neatly formatted display of function signatures. It creates a layout where function names are padded to a consistent width before their type signatures, resulting in aligned output.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Doc-fill.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport * as Doc from \"@effect/printer/Doc\"\nimport { pipe } from \"effect/Function\"\nimport * as String from \"effect/String\"\n\ntype Signature = [name: string, type: string]\n\nconst signatures: Array<Signature> = [\n  [\"empty\", \"Doc\"],\n  [\"nest\", \"Int -> Doc -> Doc\"],\n  [\"fillSep\", \"[Doc] -> Doc\"]\n]\n\nconst prettySignature = <A>([name, type]: Signature): Doc.Doc<A> =>\n  Doc.hsep([\n    pipe(Doc.text(name), Doc.fill(5)),\n    Doc.text(\"::\"),\n    Doc.text(type)\n  ])\n\nconst doc = Doc.hsep([\n  Doc.text(\"let\"),\n  Doc.align(Doc.vcat(signatures.map(prettySignature)))\n])\n\nassert.strictEqual(\n  Doc.render(doc, { style: \"pretty\" }),\n  String.stripMargin(\n    `|let empty :: Doc\n     |    nest  :: Int -> Doc -> Doc\n     |    fillSep :: [Doc] -> Doc`\n  )\n)\n```\n\n----------------------------------------\n\nTITLE: Implementing orElse Function for Either Type in TypeScript\nDESCRIPTION: The orElse function returns self if it is a Right, or applies the provided function to the Left value otherwise. This enables error handling or transformation of the error channel in functional programming patterns.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Either-orElse.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const orElse: { <L, R2, L2>(that: (left: L) => Either<R2, L2>): <R>(self: Either<R, L>) => Either<R | R2, L2>; <R, L, R2, L2>(self: Either<R, L>, that: (left: L) => Either<R2, L2>): Either<R | R2, L2>; }\n```\n\n----------------------------------------\n\nTITLE: Implementing Stream Aggregation with Timing Controls in TypeScript\nDESCRIPTION: This function aggregates elements using a provided sink until it completes or until a delay specified by a schedule has passed. It divides the stream into two asynchronous islands running on separate fibers, and returns either the aggregated value or the schedule output.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-aggregateWithinEither.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const aggregateWithinEither: { <B, A, A2, E2, R2, C, R3>(sink: Sink.Sink<B, A | A2, A2, E2, R2>, schedule: Schedule.Schedule<C, Option.Option<B>, R3>): <E, R>(self: Stream<A, E, R>) => Stream<Either.Either<B, C>, E2 | E, R2 | R3 | R>; <A, E, R, B, A2, E2, R2, C, R3>(self: Stream<A, E, R>, sink: Sink.Sink<B, A | A2, A2, E2, R2>, schedule: Schedule.Schedule<C, Option.Option<B>, R3>): Stream<Either.Either<B, C>, E | E2, R | R2 | R3>; }\n```\n\n----------------------------------------\n\nTITLE: Using Doc.catWithLine to Concatenate Documents with Line Breaks in TypeScript\nDESCRIPTION: This example demonstrates how to use the `catWithLine` function to concatenate two character documents with a line break between them. The example creates a document and renders it with the 'pretty' style, showing the output with each character on a separate line.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Doc-catWithLine.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport * as Doc from \"@effect/printer/Doc\"\nimport { pipe } from \"effect/Function\"\nimport * as String from \"effect/String\"\n\nconst doc: Doc.Doc<never> = pipe(\n  Doc.char(\"a\"),\n  Doc.catWithLine(Doc.char(\"b\"))\n)\n\nassert.strictEqual(\n  Doc.render(doc, { style: \"pretty\" }),\n  String.stripMargin(\n    `|a\n     |b`\n  )\n)\n```\n\n----------------------------------------\n\nTITLE: Implementing Config.repeat function in TypeScript\nDESCRIPTION: The repeat function takes a Config<A> and returns a Config<Array<A>>, allowing the creation of a config that describes a sequence of values, each with the same structure as the original config.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Config-repeat.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const repeat: <A>(self: Config<A>) => Config<Array<A>>\n```\n\n----------------------------------------\n\nTITLE: Flattening Iterables in Stream\nDESCRIPTION: The flattenIterables function takes a Stream of Iterable types and returns a new Stream where the nested iterables are flattened. This is useful for processing multiple levels of iterables without losing their structure. The function uses generics to maintain type safety across different data types, and it requires the Effect library's Stream module to function correctly.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-flattenIterables.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const flattenIterables: <A, E, R>(self: Stream<Iterable<A>, E, R>) => Stream<A, E, R>\n```\n\n----------------------------------------\n\nTITLE: Creating Dual Function Using Predicate in TypeScript\nDESCRIPTION: Example showing how to create a dual function that determines its style (data-first or data-last) using a predicate function instead of arity. This is useful for functions with optional arguments or variable arity.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Function-dual.md#2025-04-11_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { dual, pipe } from \"effect/Function\"\n\nconst sum = dual<\n  (that: number) => (self: number) => number,\n  (self: number, that: number) => number\n>(\n  (args) => args.length === 2,\n  (self, that) => self + that\n)\n\nconsole.log(sum(2, 3)) // 5\nconsole.log(pipe(2, sum(3))) // 5\n```\n\n----------------------------------------\n\nTITLE: Declaring whenSTM in Effect STM TypeScript\nDESCRIPTION: The 'whenSTM' function facilitates conditional execution of STM operations based on predicates with side-effects. It is part of the Effect library's STM module, allowing developers to express conditional logic within STM transactions. The function accepts either a predicate followed by an STM operation or vice versa and returns a new STM wrapping the possible result in an Option. There are no external dependencies, but it requires working knowledge of the Effect library's STM abstractions.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/STM-whenSTM.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const whenSTM: { <E2, R2>(predicate: STM<boolean, E2, R2>): <A, E, R>(self: STM<A, E, R>) => STM<Option.Option<A>, E2 | E, R2 | R>; <A, E, R, E2, R2>(self: STM<A, E, R>, predicate: STM<boolean, E2, R2>): STM<Option.Option<A>, E | E2, R | R2>; }\n```\n\n----------------------------------------\n\nTITLE: Using decrement Function with BigInt in TypeScript\nDESCRIPTION: Demonstrates how to use the decrement function from the effect/BigInt module to decrease a BigInt value by 1n. This example imports the function and shows its basic usage with assertion testing.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/BigInt-decrement.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { decrement } from \"effect/BigInt\"\n\nassert.deepStrictEqual(decrement(3n), 2n)\n```\n\n----------------------------------------\n\nTITLE: Implementing HaltStrategy Pattern Matching in TypeScript\nDESCRIPTION: Defines a pattern matching function for HaltStrategy that allows folding over different halt strategy cases (left, right, both, either) using provided case functions. The function supports both curried and direct invocation patterns.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/StreamHaltStrategy-match.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const match: { \n  <Z>(options: { \n    readonly onLeft: () => Z; \n    readonly onRight: () => Z; \n    readonly onBoth: () => Z; \n    readonly onEither: () => Z; \n  }): (self: HaltStrategy) => Z; \n  <Z>(self: HaltStrategy, options: { \n    readonly onLeft: () => Z; \n    readonly onRight: () => Z; \n    readonly onBoth: () => Z; \n    readonly onEither: () => Z; \n  }): Z; \n}\n```\n\n----------------------------------------\n\nTITLE: Implementing List Reduction in TypeScript\nDESCRIPTION: Defines a reduce function that folds over list elements using a specified function and initial value. The function supports both curried and non-curried forms, allowing flexible usage patterns in functional programming contexts.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/List-reduce.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const reduce: { <Z, A>(zero: Z, f: (b: Z, a: A) => Z): (self: List<A>) => Z; <A, Z>(self: List<A>, zero: Z, f: (b: Z, a: A) => Z): Z; }\n```\n\n----------------------------------------\n\nTITLE: Type Signature for orElseSucceed in Effect Module\nDESCRIPTION: The TypeScript type signature for the orElseSucceed method, showing its overloaded forms and type parameters. It demonstrates how the method transforms effects with potential failures into effects that never fail by providing a fallback value.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-orElseSucceed.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const orElseSucceed: { <A2>(evaluate: LazyArg<A2>): <A, E, R>(self: Effect<A, E, R>) => Effect<A2 | A, never, R>; <A, E, R, A2>(self: Effect<A, E, R>, evaluate: LazyArg<A2>): Effect<A | A2, never, R>; }\n```\n\n----------------------------------------\n\nTITLE: Declaring UUID Class in TypeScript\nDESCRIPTION: This code snippet declares a class named UUID that represents a Universally Unique Identifier (UUID). It ensures that any string passed conforms to the standard UUID format, providing a type-safe way to handle UUIDs in TypeScript applications.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Schema-UUID.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare class UUID\n```\n\n----------------------------------------\n\nTITLE: Defining STM Match Operation in TypeScript\nDESCRIPTION: A type-safe method for handling STM effects that allows transforming the result based on success or failure states. Provides flexible error and value processing without retrying the original effect.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/STM-match.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const match: { <E, A2, A, A3>(options: { readonly onFailure: (error: E) => A2; readonly onSuccess: (value: A) => A3; }): <R>(self: STM<A, E, R>) => STM<A2 | A3, never, R>; <A, E, R, A2, A3>(self: STM<A, E, R>, options: { readonly onFailure: (error: E) => A2; readonly onSuccess: (value: A) => A3; }): STM<A2 | A3, never, R>; }\n```\n\n----------------------------------------\n\nTITLE: Creating an SQL Resolver for Finding Records by ID in TypeScript\nDESCRIPTION: Creates a resolver that resolves database results by ID. It accepts schemas for ID and Result types, a function to extract the ID from a result, and an execute function that performs the actual query. Supports both context-aware and context-free execution patterns.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/SqlResolver-findById.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const findById: <T extends string, I, II, RI, A, IA, Row, E, RA = never, R = never>(tag: T, options: { readonly Id: Schema.Schema<I, II, RI>; readonly Result: Schema.Schema<A, IA>; readonly ResultId: (result: Types.NoInfer<A>, row: Types.NoInfer<Row>) => I; readonly execute: (requests: Array<Types.NoInfer<II>>) => Effect.Effect<ReadonlyArray<Row>, E>; readonly withContext?: false; } | { readonly Id: Schema.Schema<I, II, RI>; readonly Result: Schema.Schema<A, IA, RA>; readonly ResultId: (result: Types.NoInfer<A>, row: Types.NoInfer<Row>) => I; readonly execute: (requests: Array<Types.NoInfer<II>>) => Effect.Effect<ReadonlyArray<Row>, E, R>; readonly withContext: true; }) => Effect.Effect<SqlResolver<T, I, Option.Option<A>, E, RI>, never, RA | R>\n```\n\n----------------------------------------\n\nTITLE: Pattern Matching Example with Match.discriminator\nDESCRIPTION: Demonstrates how to use Match.discriminator to pattern match on objects with a discriminant field 'type'. The example shows matching multiple variants of a discriminated union and handling different cases.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Match-discriminator.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Match, pipe } from \"effect\"\n\nconst match = pipe(\n  Match.type<{ type: \"A\"; a: string } | { type: \"B\"; b: number } | { type: \"C\"; c: boolean }>(),\n  Match.discriminator(\"type\")(\"A\", \"B\", (_) => `A or B: ${_.type}`),\n  Match.discriminator(\"type\")(\"C\", (_) => `C(${_.c})`),\n  Match.exhaustive\n)\n```\n\n----------------------------------------\n\nTITLE: Binding Variables with Stream.bind in TypeScript\nDESCRIPTION: This snippet demonstrates how to use the bind function within a do simulation in the Stream module. It shows how to define and bind variables 'x' and 'y', and how to calculate their sum using the let function. The dependencies include 'effect' and 'assert' from Node.js. The expected output is a collection with bound variable values.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-bind.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { Chunk, Effect, pipe, Stream } from \"effect\"\n\nconst result = pipe(\n  Stream.Do,\n  Stream.bind(\"x\", () => Stream.succeed(2)),\n  Stream.bind(\"y\", () => Stream.succeed(3)),\n  Stream.let(\"sum\", ({ x, y }) => x + y)\n)\nassert.deepStrictEqual(Effect.runSync(Stream.runCollect(result)), Chunk.of({ x: 2, y: 3, sum: 5 }))\n```\n\n----------------------------------------\n\nTITLE: HashSet.flatMap Function Signature in TypeScript\nDESCRIPTION: The TypeScript type signature for the HashSet.flatMap function. It shows both the data-first and data-last (pipeable) overloads, taking a function that maps elements to Iterables which are then flattened.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/HashSet-flatMap.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const flatMap: { <A, B>(f: (a: A) => Iterable<B>): (self: HashSet<A>) => HashSet<B>; <A, B>(self: HashSet<A>, f: (a: A) => Iterable<B>): HashSet<B>; }\n```\n\n----------------------------------------\n\nTITLE: Inserting Multiple Entries into a Trie in TypeScript\nDESCRIPTION: This example demonstrates how to use Trie.insertMany to insert multiple key-value pairs into a Trie data structure. It compares the result with individually inserting entries using Trie.insert.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Trie-insertMany.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { Trie, Equal } from \"effect\"\n\nconst trie = Trie.empty<number>().pipe(\n  Trie.insert(\"shells\", 0),\n  Trie.insert(\"sells\", 1),\n  Trie.insert(\"she\", 2)\n)\n\nconst trieInsert = Trie.empty<number>().pipe(\n  Trie.insert(\"shells\", 0),\n  Trie.insertMany(\n    [[\"sells\", 1], [\"she\", 2]]\n  )\n)\n\nassert.equal(\n  Equal.equals(trie, trieInsert),\n  true\n)\n```\n\n----------------------------------------\n\nTITLE: TSet.forEach Signature (TypeScript)\nDESCRIPTION: Defines the signature for the `forEach` function within the `TSet` module. This function allows applying a transactional effect to each element of a `TSet`. It is available since v2.0.0.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TSet-forEach.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const forEach: { <A, R, E>(f: (value: A) => STM.STM<void, E, R>): (self: TSet<A>) => STM.STM<void, E, R>; <A, R, E>(self: TSet<A>, f: (value: A) => STM.STM<void, E, R>): STM.STM<void, E, R>; }\n```\n\n----------------------------------------\n\nTITLE: Merging Annotations with the Effect Package in TypeScript\nDESCRIPTION: The `annotations` function allows the merging of new annotations with existing ones, potentially overwriting duplicates. It supports both curried and non-curried versions. The function relies on a generic schema provided by the Annotations.GenericSchema and is designed to be flexible with different types of Annotable.All. Inputs include the self object of type S and a set of annotations to merge. The output is an updated self object with merged annotations. This functionality is part of the Effect package, starting from version 3.10.0.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Schema-annotations.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const annotations: { <S extends Annotable.All>(annotations: Annotations.GenericSchema<Schema.Type<S>>): (self: S) => Annotable.Self<S>; <S extends Annotable.All>(self: S, annotations: Annotations.GenericSchema<Schema.Type<S>>): Annotable.Self<S>; }\n```\n\n----------------------------------------\n\nTITLE: Implementing stripMargin Function in TypeScript\nDESCRIPTION: Function declaration for stripMargin that removes leading whitespace and '|' character from each line of a string. Used for cleaning up indented multiline strings in TypeScript code.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/String-stripMargin.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const stripMargin: (self: string) => string\n```\n\n----------------------------------------\n\nTITLE: Filtering and Retrying Transactions with Predicate - TypeScript\nDESCRIPTION: This code snippet defines the `retryWhile` function, allowing users to retry a transaction in STM while a specified predicate returns `true` for the produced value. It can be called either with the predicate first or having both the predicate and STM instance provided together. The function enhances control over transactional workflows.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/STM-retryWhile.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const retryWhile: { <A>(predicate: Predicate<A>): <E, R>(self: STM<A, E, R>) => STM<A, E, R>; <A, E, R>(self: STM<A, E, R>, predicate: Predicate<A>): STM<A, E, R>; }\n```\n\n----------------------------------------\n\nTITLE: Determining Read Lock Status in TReentrantLock with TypeScript\nDESCRIPTION: This function checks if any fiber has obtained a read lock on the provided TReentrantLock object. It returns an STM (Software Transactional Memory) boolean indicating the lock status. The function takes a TReentrantLock instance as a parameter and does not have any specific limitations apart from the requirements of the STM environment.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TReentrantLock-readLocked.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const readLocked: (self: TReentrantLock) => STM.STM<boolean>\n```\n\n----------------------------------------\n\nTITLE: Creating Bounded PubSub with Sliding Strategy in TypeScript\nDESCRIPTION: The `sliding` function creates a bounded PubSub that adds new messages and drops old ones when at capacity. It's recommended to use capacities that are powers of two for optimal performance. The function can take either a number or an object with capacity and optional replay properties.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/PubSub-sliding.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const sliding: <A>(capacity: number | { readonly capacity: number; readonly replay?: number | undefined; }) => Effect.Effect<PubSub<A>>\n```\n\n----------------------------------------\n\nTITLE: Effect.sleep Function Signature in TypeScript\nDESCRIPTION: This code snippet shows the TypeScript signature for the Effect.sleep function. It takes a DurationInput parameter and returns an Effect of void.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-sleep.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const sleep: (duration: Duration.DurationInput) => Effect<void>\n```\n\n----------------------------------------\n\nTITLE: Declaring runtimePromise Function in TypeScript for FiberSet Module\nDESCRIPTION: This function captures a Runtime and uses it to fork Effects, adding the forked fibers to the FiberSet. It returns a run function that returns Promises. The function takes a FiberSet as input and returns an Effect that, when run, provides a function to fork effects and return promises.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/FiberSet-runtimePromise.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const runtimePromise: <A, E>(self: FiberSet<A, E>) => <R = never>() => Effect.Effect<(<XE extends E, XA extends A>(effect: Effect.Effect<XA, XE, R>, options?: (Runtime.RunForkOptions & { readonly propagateInterruption?: boolean | undefined; }) | undefined) => Promise<XA>), never, R>\n```\n\n----------------------------------------\n\nTITLE: Defining orDie Function for Layer Error Handling in TypeScript\nDESCRIPTION: The orDie function translates effect failure into death of the fiber, making all failures unchecked and not part of the layer's type. It takes a Layer with potential errors and returns a Layer where errors are never explicitly handled.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Layer-orDie.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const orDie: <A, E, R>(self: Layer<A, E, R>) => Layer<A, never, R>\n```\n\n----------------------------------------\n\nTITLE: TypeScript Declaration for Sink.zip Function\nDESCRIPTION: This TypeScript declaration defines the zip function for the Sink module. It allows combining two sinks by feeding inputs until each yields a result, then combining the results into a tuple. The function supports both fluent and pipe-first style with an optional concurrent flag.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Sink-zip.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const zip: { <A2, In, In2 extends In, L2, E2, R2>(that: Sink<A2, In2, L2, E2, R2>, options?: { readonly concurrent?: boolean | undefined; } | undefined): <A, L, E, R>(self: Sink<A, In, L, E, R>) => Sink<[A, A2], In & In2, L2 | L, E2 | E, R2 | R>; <A, In, L, E, R, A2, In2 extends In, L2, E2, R2>(self: Sink<A, In, L, E, R>, that: Sink<A2, In2, L2, E2, R2>, options?: { readonly concurrent?: boolean | undefined; } | undefined): Sink<[A, A2], In & In2, L | L2, E | E2, R | R2>; }\n```\n\n----------------------------------------\n\nTITLE: Transforming Schedule Input Context in TypeScript\nDESCRIPTION: A functional utility to modify a schedule's required context using a mapping function. Enables dependency environment adaptation without altering the schedule's core logic.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Schedule-mapInputContext.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const mapInputContext: { <R0, R>(f: (env0: Context.Context<R0>) => Context.Context<R>): <Out, In>(self: Schedule<Out, In, R>) => Schedule<Out, In, R0>; <Out, In, R, R0>(self: Schedule<Out, In, R>, f: (env0: Context.Context<R0>) => Context.Context<R>): Schedule<Out, In, R0>; }\n```\n\n----------------------------------------\n\nTITLE: Using Array.extend to Transform Arrays in TypeScript\nDESCRIPTION: Demonstrates how to use Array.extend to transform an array by mapping each subarray to its length. The function processes each subarray starting from each element (creating subarrays [1,2,3], [2,3], [3]) and returns an array of the results.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Array-extend.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Array } from \"effect\"\n\nconst result = Array.extend([1, 2, 3], as => as.length)\nconsole.log(result) // [3, 2, 1]\n\n// Explanation:\n// The function maps each subarray starting from each element to its length.\n// The subarrays are: [1, 2, 3], [2, 3], [3].\n// The lengths are: 3, 2, 1.\n// Therefore, the result is [3, 2, 1].\n```\n\n----------------------------------------\n\nTITLE: Running Effects with FiberMap in TypeScript\nDESCRIPTION: Function signature for running an Effect and managing its fiber in a FiberMap. The function supports optional configuration for fiber execution behavior and handles automatic cleanup when fibers complete. It provides two overloads for different usage patterns.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/FiberMap-run.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const run: { <K, A, E>(self: FiberMap<K, A, E>, key: K, options?: { readonly onlyIfMissing?: boolean | undefined; readonly propagateInterruption?: boolean | undefined; } | undefined): <R, XE extends E, XA extends A>(effect: Effect.Effect<XA, XE, R>) => Effect.Effect<Fiber.RuntimeFiber<XA, XE>, never, R>; <K, A, E, R, XE extends E, XA extends A>(self: FiberMap<K, A, E>, key: K, effect: Effect.Effect<XA, XE, R>, options?: { readonly onlyIfMissing?: boolean | undefined; readonly propagateInterruption?: boolean | undefined; } | undefined): Effect.Effect<Fiber.RuntimeFiber<XA, XE>, never, R>; }\n```\n\n----------------------------------------\n\nTITLE: Using Match.tagsExhaustive for Pattern Matching in TypeScript\nDESCRIPTION: Demonstrates how to use Match.tagsExhaustive to perform exhaustive pattern matching on a discriminated union with three variants (A, B, C). The function ensures all possible tag values are handled at compile time.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Match-tagsExhaustive.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Match, pipe } from \"effect\"\n\nconst match = pipe(\n  Match.type<{ _tag: \"A\"; a: string } | { _tag: \"B\"; b: number } | { _tag: \"C\"; c: boolean }>(),\n  Match.tagsExhaustive({\n    A: (a) => a.a,\n    B: (b) => b.b,\n    C: (c) => c.c\n  })\n)\n```\n\n----------------------------------------\n\nTITLE: Implementing Channel.toPull Function in TypeScript\nDESCRIPTION: Function signature for toPull that converts a Channel into a scoped Effect. The resulting Effect can be used to repeatedly pull elements from the Channel, handling both success and failure cases. The pull effect returns either an emitted element or the channel's done value.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Channel-toPull.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const toPull: <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>) => Effect.Effect<Effect.Effect<Either.Either<OutElem, OutDone>, OutErr, Env>, never, Scope.Scope | Env>\n```\n\n----------------------------------------\n\nTITLE: Declaring the scheduleForked Function in TypeScript\nDESCRIPTION: Type declaration for the scheduleForked function that runs an effect repeatedly on a new fiber according to a given schedule. The function supports two calling patterns and returns a RuntimeFiber that allows monitoring the execution.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-scheduleForked.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const scheduleForked: { <Out, R2>(schedule: Schedule.Schedule<Out, unknown, R2>): <A, E, R>(self: Effect<A, E, R>) => Effect<Fiber.RuntimeFiber<Out, E>, never, Scope.Scope | R2 | R>; <A, E, R, Out, R2>(self: Effect<A, E, R>, schedule: Schedule.Schedule<Out, unknown, R2>): Effect<Fiber.RuntimeFiber<Out, E>, never, Scope.Scope | R | R2>; }\n```\n\n----------------------------------------\n\nTITLE: Initializing Infinite Stream from Effect Chunks in TypeScript\nDESCRIPTION: Creates a stream that repeatedly generates chunks of values from a provided effect, continuing indefinitely. The stream will reproduce chunks produced by the original effect without termination.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-repeatEffectChunk.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const repeatEffectChunk: <A, E, R>(effect: Effect.Effect<Chunk.Chunk<A>, E, R>) => Stream<A, E, R>\n```\n\n----------------------------------------\n\nTITLE: Defining pipeThroughChannelOrFail Function in TypeScript\nDESCRIPTION: This code snippet defines the pipeThroughChannelOrFail function, which pipes all values from a stream through a provided channel. It passes through any error emitted by the stream unchanged. The function supports both curried and uncurried versions.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-pipeThroughChannelOrFail.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const pipeThroughChannelOrFail: {\n  <R2, E, E2, A, A2>(chan: Channel.Channel<Chunk.Chunk<A2>, Chunk.Chunk<A>, E2, E, unknown, unknown, R2>): <R>(self: Stream<A, E, R>) => Stream<A2, E | E2, R2 | R>;\n  <R, R2, E, E2, A, A2>(self: Stream<A, E, R>, chan: Channel.Channel<Chunk.Chunk<A2>, Chunk.Chunk<A>, E2, E, unknown, unknown, R2>): Stream<A2, E | E2, R | R2>;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Chunk Splitting Using Predicate in TypeScript\nDESCRIPTION: Function signature for splitWhere that splits a chunk into two parts based on a predicate. Returns a tuple containing chunks before and after (including) the matching element. The function supports both curried and uncurried calling styles.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Chunk-splitWhere.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const splitWhere: { <A>(predicate: Predicate<NoInfer<A>>): (self: Chunk<A>) => [beforeMatch: Chunk<A>, fromMatch: Chunk<A>]; <A>(self: Chunk<A>, predicate: Predicate<A>): [beforeMatch: Chunk<A>, fromMatch: Chunk<A>]; }\n```\n\n----------------------------------------\n\nTITLE: Collecting Fiber Results into a Single Result Array in TypeScript\nDESCRIPTION: This function collects multiple fibers into a single fiber that produces an in-order array of their results. It takes an iterable of fibers as input and returns a new fiber that resolves to an array of the original fibers' results.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Fiber-all.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const all: <A, E>(fibers: Iterable<Fiber<A, E>>) => Fiber<ReadonlyArray<A>, E>\n```\n\n----------------------------------------\n\nTITLE: Converting Either to Option with getRight TypeScript Function\nDESCRIPTION: Demonstrates how to use Option.getRight to transform an Either into an Option by extracting the right value or returning None if the Either is Left\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Option-getRight.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Either, Option } from \"effect\"\n\nconsole.log(Option.getRight(Either.right(\"ok\")))\n// Output: { _id: 'Option', _tag: 'Some', value: 'ok' }\n\nconsole.log(Option.getRight(Either.left(\"err\")))\n// Output: { _id: 'Option', _tag: 'None' }\n```\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const getRight: <R, L>(self: Either<R, L>) => Option<R>\n```\n\n----------------------------------------\n\nTITLE: Checking Existence in Iterable with STM (TypeScript)\nDESCRIPTION: The exists function determines if any element in an Iterable satisfies the specified effectual predicate. It supports both a curried form and a direct form, allowing flexible usage depending on whether the iterable or predicate is provided first. The function returns an STM instance indicating whether any match was found.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/STM-exists.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const exists: { <A, R, E>(predicate: (a: NoInfer<A>) => STM<boolean, E, R>): (iterable: Iterable<A>) => STM<boolean, E, R>; <A, R, E>(iterable: Iterable<A>, predicate: (a: A) => STM<boolean, E, R>): STM<boolean, E, R>; }\n```\n\n----------------------------------------\n\nTITLE: Effect.reduceRight Function Signature in TypeScript\nDESCRIPTION: The TypeScript signature for the Effect.reduceRight function, showing its type parameters and overloads.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-reduceRight.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const reduceRight: { <A, Z, R, E>(zero: Z, f: (a: A, z: Z, i: number) => Effect<Z, E, R>): (elements: Iterable<A>) => Effect<Z, E, R>; <A, Z, R, E>(elements: Iterable<A>, zero: Z, f: (a: A, z: Z, i: number) => Effect<Z, E, R>): Effect<Z, E, R>; }\n```\n\n----------------------------------------\n\nTITLE: RedBlackTree forEach Function Declaration\nDESCRIPTION: The `forEach` function iterates through each node of the RedBlackTree in order and applies the provided function `f` to each key-value pair. It can be used in a curried or non-curried manner. The function requires a RedBlackTree instance and a function that accepts a key and a value from the tree.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/RedBlackTree-forEach.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const forEach: { <K, V>(f: (key: K, value: V) => void): (self: RedBlackTree<K, V>) => void; <K, V>(self: RedBlackTree<K, V>, f: (key: K, value: V) => void): void; }\n```\n\n----------------------------------------\n\nTITLE: Constructing a List in TypeScript using List.of\nDESCRIPTION: The 'of' function constructs a new List<A> from a single specified value. It returns a Cons<A>, which is a non-empty list containing the given value.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/List-of.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const of: <A>(value: A) => Cons<A>\n```\n\n----------------------------------------\n\nTITLE: Type Signature for findFirstIndex Function in TypeScript\nDESCRIPTION: Provides the type signature for the findFirstIndex function. It supports both curried and non-curried forms, taking a predicate function and an iterable, and returning an Option of a number.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Array-findFirstIndex.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const findFirstIndex: { <A>(predicate: (a: NoInfer<A>, i: number) => boolean): (self: Iterable<A>) => Option.Option<number>; <A>(self: Iterable<A>, predicate: (a: A, i: number) => boolean): Option.Option<number>; }\n```\n\n----------------------------------------\n\nTITLE: Defining Effect.daemonChildren Function in TypeScript\nDESCRIPTION: Declares a constant function daemonChildren that takes an Effect<A, E, R> and returns a new Effect<A, E, R>. This function creates a workflow that doesn't supervise fibers forked by the input workflow.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-daemonChildren.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const daemonChildren: <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R>\n```\n\n----------------------------------------\n\nTITLE: Defining EventGroup Interface in TypeScript\nDESCRIPTION: Defines the EventGroup generic interface which serves as a collection of Event objects. It includes methods for adding new events with specific tags, payloads, and error handling, as well as adding error schemas to all events in the group.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/EventGroup-EventGroup.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface EventGroup<\n  out Events extends Event.Any = never\n> extends Pipeable {\n  new(_: never): {}\n\n  readonly [TypeId]: TypeId\n  readonly events: Record.ReadonlyRecord<string, Events>\n\n  /**\n   * Add an `Event` to the `EventGroup`.\n   */\n  add<\n    Tag extends string,\n    Payload extends Schema.Schema.Any = typeof Schema.Void,\n    Success extends Schema.Schema.Any = typeof Schema.Void,\n    Error extends Schema.Schema.All = typeof Schema.Never\n  >(options: {\n    readonly tag: Tag\n    readonly primaryKey: (payload: Schema.Schema.Type<Payload>) => string\n    readonly payload?: Payload\n    readonly success?: Success\n    readonly error?: Error\n  }): EventGroup<Events | Event<Tag, Payload, Success, Error>>\n\n  /**\n   * Add an error schema to all the events in the `EventGroup`.\n   */\n  addError<Error extends Schema.Schema.Any>(error: Error): EventGroup<Event.AddError<Events, Error>>\n}\n```\n\n----------------------------------------\n\nTITLE: Checking List Type in TypeScript using Effect Library\nDESCRIPTION: The isList function is a type guard that determines whether a given value is a List. It can be used with both known Iterable types and unknown values, providing type narrowing in TypeScript.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/List-isList.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const isList: { <A>(u: Iterable<A>): u is List<A>; (u: unknown): u is List<unknown>; }\n```\n\n----------------------------------------\n\nTITLE: Converting Cookies Object to Header String in TypeScript\nDESCRIPTION: Function signature for converting a Cookies object into a Cookie header string representation. Takes a Cookies object as input and returns a formatted string suitable for use as an HTTP Cookie header.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Cookies-toCookieHeader.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const toCookieHeader: (self: Cookies) => string\n```\n\n----------------------------------------\n\nTITLE: Executing Micro Effects with Promise Return in TypeScript\nDESCRIPTION: Function signature for runPromise that executes a Micro effect and returns a Promise resolving to the successful computation value. Takes an effect and optional configuration including abort signal and scheduler.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Micro-runPromise.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const runPromise: <A, E>(effect: Micro<A, E>, options?: { readonly signal?: AbortSignal | undefined; readonly scheduler?: MicroScheduler | undefined; } | undefined) => Promise<A>\n```\n\n----------------------------------------\n\nTITLE: Accessing Stream Context in Effect (TS)\nDESCRIPTION: This code snippet demonstrates how to access the entire context of an Effect Stream using the `context` function. The function returns a `Stream` that emits the `Context` of type `R`, where `R` represents the environment type of the stream. It has no dependencies other than the Effect library's Stream and Context modules.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-context.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const context: <R>() => Stream<Context.Context<R>, never, R>\n```\n\n----------------------------------------\n\nTITLE: Lazily constructing a Channel using suspend function in TypeScript\nDESCRIPTION: The suspend function lazily constructs a channel from a given side effect. It takes a LazyArg function that returns a Channel and returns a new Channel with the same type parameters. This allows for deferred evaluation of channel creation.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Channel-suspend.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const suspend: <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>(evaluate: LazyArg<Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>>) => Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>\n```\n\n----------------------------------------\n\nTITLE: TSet toArray Function Declaration (Effect/TS)\nDESCRIPTION: This code snippet declares the `toArray` function.  It takes a `TSet<A>` as input and returns an `STM.STM<Array<A>>`, representing a transactional operation that yields an array containing all elements from the TSet. The function is part of the Effect library's TSet module.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TSet-toArray.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const toArray: <A>(self: TSet<A>) => STM.STM<Array<A>>\n```\n\n----------------------------------------\n\nTITLE: Matching Ordering Values Using Effect - TypeScript\nDESCRIPTION: This code snippet demonstrates how to use the 'Ordering.match' function which returns specified values based on the ordering comparison results. The function takes an object with three properties (onLessThan, onEqual, onGreaterThan) that correspond to the possible outcomes of an ordering comparison. It is essential to import necessary dependencies from the 'effect' library.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Ordering-match.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { Ordering } from \"effect\"\nimport { constant } from \"effect/Function\"\n\nconst toMessage = Ordering.match({\n  onLessThan: constant('less than'),\n  onEqual: constant('equal'),\n  onGreaterThan: constant('greater than')\n})\n\nassert.deepStrictEqual(toMessage(-1), \"less than\")\nassert.deepStrictEqual(toMessage(0), \"equal\")\nassert.deepStrictEqual(toMessage(1), \"greater than\")\n```\n\n----------------------------------------\n\nTITLE: Encoding Text Stream in Effect\nDESCRIPTION: This snippet defines the `encodeText` function, which transforms a `Stream` of strings into a `Stream` of `Uint8Array` chunks. The function takes a stream of strings as input and returns a stream of `Uint8Array`.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-encodeText.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const encodeText: <E, R>(self: Stream<string, E, R>) => Stream<Uint8Array, E, R>\n```\n\n----------------------------------------\n\nTITLE: Implementing Defect Tracking With Metrics in TypeScript\nDESCRIPTION: Defines a function that creates an aspect for tracking defects in Effect operations. The aspect updates a metric by applying a transformation function to defect throwables. It supports both curried and standard function call syntax.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Metric-trackDefectWith.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const trackDefectWith: { <Type, In, Out>(metric: Metric<Type, In, Out>, f: (defect: unknown) => In): <A, E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>; <A, E, R, Type, In, Out>(self: Effect.Effect<A, E, R>, metric: Metric<Type, In, Out>, f: (defect: unknown) => In): Effect.Effect<A, E, R>; }\n```\n\n----------------------------------------\n\nTITLE: Implementing GroupBy.first Function in TypeScript\nDESCRIPTION: The first function allows limiting the number of groups to consider in a Stream. It takes a number parameter and returns a function that transforms a GroupBy instance, or can be called with both parameters directly. This function has been available since version 2.0.0.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/GroupBy-first.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const first: { (n: number): <K, V, E, R>(self: GroupBy<K, V, E, R>) => GroupBy<K, V, E, R>; <K, V, E, R>(self: GroupBy<K, V, E, R>, n: number): GroupBy<K, V, E, R>; }\n```\n\n----------------------------------------\n\nTITLE: Declaring patchFiberRefs Function in TypeScript\nDESCRIPTION: Defines the patchFiberRefs function, which takes a FiberRefsPatch object and returns an Effect that applies the specified changes to the FiberRef values for the current fiber. This function allows for dynamic modification of fiber-local state during execution.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-patchFiberRefs.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const patchFiberRefs: (patch: FiberRefsPatch.FiberRefsPatch) => Effect<void>\n```\n\n----------------------------------------\n\nTITLE: Implementing Effect Transplantation in TypeScript\nDESCRIPTION: Function signature for transplant operation that allows grafting effects to higher-level scopes. Takes a function parameter that receives a grafter function, which can be used to transplant effects between different fiber scopes. Returns an Effect with the same type parameters as the input effect.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-transplant.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const transplant: <A, E, R>(f: (grafter: <A2, E2, R2>(effect: Effect<A2, E2, R2>) => Effect<A2, E2, R2>) => Effect<A, E, R>) => Effect<A, E, R>\n```\n\n----------------------------------------\n\nTITLE: Constructing Exit.Success in TypeScript\nDESCRIPTION: Function signature for creating a new Exit.Success instance containing a value of type A. Used to represent successful completion of an operation with a result value.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Exit-succeed.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const succeed: <A>(value: A) => Exit<A>\n```\n\n----------------------------------------\n\nTITLE: Implementing Chunk Collection Sink in TypeScript\nDESCRIPTION: Defines a function that creates a sink to collect a specified number of input elements into a chunk. The sink processes input elements of type In and produces a Chunk.Chunk<In> as output.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Sink-collectAllN.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const collectAllN: <In>(n: number) => Sink<Chunk.Chunk<In>, In, In>\n```\n\n----------------------------------------\n\nTITLE: Implementing getOrElse Function for Exit Type in TypeScript\nDESCRIPTION: This function returns the value A if the Exit is a Success, otherwise returns an alternate value computed from a function that receives the Cause<E> of the failure. It supports both curried and uncurried calling styles.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Exit-getOrElse.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const getOrElse: { <E, A2>(orElse: (cause: Cause.Cause<E>) => A2): <A>(self: Exit<A, E>) => A2 | A; <A, E, A2>(self: Exit<A, E>, orElse: (cause: Cause.Cause<E>) => A2): A | A2; }\n```\n\n----------------------------------------\n\nTITLE: Converting Optional Schema Properties in Effect TypeScript\nDESCRIPTION: A type-level transformation function that converts optional schema properties to required ones using custom decode and encode functions. Handles cases where properties can be missing during input or output serialization.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Schema-optionalToRequired.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const optionalToRequired: <FA, FI, FR, TA, TI, TR>(from: Schema<FA, FI, FR>, to: Schema<TA, TI, TR>, options: { readonly decode: (o: option_.Option<FA>) => TI; readonly encode: (ti: TI) => option_.Option<FA>; }) => PropertySignature<\":\", TA, never, \"?:\", FI, false, FR | TR>\n```\n\n----------------------------------------\n\nTITLE: Type Signature for Effect.orElseFail Method\nDESCRIPTION: The TypeScript type signature for the orElseFail method, showing that it accepts an evaluation function for the new error and returns a function that transforms an Effect with one error type to an Effect with a different error type.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-orElseFail.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const orElseFail: { <E2>(evaluate: LazyArg<E2>): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E2, R>; <A, E, R, E2>(self: Effect<A, E, R>, evaluate: LazyArg<E2>): Effect<A, E2, R>; }\n```\n\n----------------------------------------\n\nTITLE: Creating Monoid for ReadonlyArray in TypeScript\nDESCRIPTION: The array function creates and returns a Monoid for ReadonlyArray<A> given a type A. The empty value for this Monoid is the empty array.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Monoid-array.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const array: <A>() => Monoid<ReadonlyArray<A>>\n```\n\n----------------------------------------\n\nTITLE: Type Signature of isEmpty Function in Effect Package\nDESCRIPTION: Provides the TypeScript type signature for the isEmpty function. It takes an Iterable<A> as input and returns a boolean, with a type predicate indicating an empty iterable.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Iterable-isEmpty.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const isEmpty: <A>(self: Iterable<A>) => self is Iterable<never>\n```\n\n----------------------------------------\n\nTITLE: Declaring TArray.findFirstIndexWhereSTM in Effect-TS TypeScript\nDESCRIPTION: The `findFirstIndexWhereSTM` function is used to find the index of the first element in a transactional array `TArray` that satisfies a given transactional predicate. It utilizes STM (Software Transactional Memory) to ensure safe concurrent operations. The function is polymorphic over types `A`, `R`, and `E`, where `A` is the type of elements in the array, `R` is the environment required by the STM effect, and `E` is the type of errors that may occur. The function returns an `Option.Option<number>` wrapped in STM, which indicates the index of the found element or none if no element matches.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TArray-findFirstIndexWhereSTM.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const findFirstIndexWhereSTM: { <A, R, E>(predicate: (value: A) => STM.STM<boolean, E, R>): (self: TArray<A>) => STM.STM<Option.Option<number>, E, R>; <A, R, E>(self: TArray<A>, predicate: (value: A) => STM.STM<boolean, E, R>): STM.STM<Option.Option<number>, E, R>; }\n```\n\n----------------------------------------\n\nTITLE: Type Definition for Subtract in TypeScript\nDESCRIPTION: This snippet defines the TypeScript signature for the 'subtract' function in the Effect library. It supports two forms: a curried form which takes a single number first and returns a function that takes the second number, and an uncurried form that takes both numbers directly. It is designed for flexibility and is part of the Effect library since version 2.0.0.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Number-subtract.md#2025-04-11_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const subtract: { (that: number): (self: number) => number; (self: number, that: number): number; }\n```\n\n----------------------------------------\n\nTITLE: Configuring HTTP Client Tracer Propagation in TypeScript\nDESCRIPTION: Type declaration for withTracerPropagation function that enables or disables tracing propagation for HTTP requests. The function provides two overloads - one takes the enabled flag first, the other takes an effect first followed by the enabled flag. Both return an Effect that preserves the original type parameters.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/HttpClient-withTracerPropagation.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const withTracerPropagation: { (enabled: boolean): <A, E, R>(effect: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>; <A, E, R>(effect: Effect.Effect<A, E, R>, enabled: boolean): Effect.Effect<A, E, R>; }\n```\n\n----------------------------------------\n\nTITLE: Creating a Fail Cause in TypeScript\nDESCRIPTION: The `fail` function constructs a `Cause` carrying an error of type `E`. It's used to represent a known or anticipated failure in effectful computations. This function is available since version 2.0.0 of the package.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Cause-fail.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const fail: <E>(error: E) => Cause<E>\n```\n\n----------------------------------------\n\nTITLE: Checking Transactional Effect Success in Effect TS\nDESCRIPTION: The `isSuccess` function checks if a given transactional effect `STM` is a success. It takes an `STM` as input and returns a new `STM` that resolves to a boolean value indicating whether the original `STM` represents a successful transaction.  It relies on the Effect TS library's `STM` module.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/STM-isSuccess.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const isSuccess: <A, E, R>(self: STM<A, E, R>) => STM<boolean, never, R>\n```\n\n----------------------------------------\n\nTITLE: Signature Definition for Number.between - TypeScript\nDESCRIPTION: This snippet defines the TypeScript signature for the `between` function, which can either receive an options object containing the minimum and maximum values or take a number as the first parameter followed by options. This is essential for understanding the expected parameters and return types.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Number-between.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const between: { (options: { minimum: number; maximum: number; }): (self: number) => boolean; (self: number, options: { minimum: number; maximum: number; }): boolean; }\n```\n\n----------------------------------------\n\nTITLE: BigInt.min Function Signature\nDESCRIPTION: Type declaration for the min function showing both curried and uncurried versions for comparing bigint values.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/BigInt-min.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const min: { (that: bigint): (self: bigint) => bigint; (self: bigint, that: bigint): bigint; }\n```\n\n----------------------------------------\n\nTITLE: Rounding Numbers in TypeScript with Effect\nDESCRIPTION: A utility function that rounds a number to a specified number of decimal places. Supports both curried and direct function call styles.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Number-round.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { round } from \"effect/Number\"\n\nassert.deepStrictEqual(round(1.1234, 2), 1.12)\nassert.deepStrictEqual(round(1.567, 2), 1.57)\n```\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const round: { (precision: number): (self: number) => number; (self: number, precision: number): number; }\n```\n\n----------------------------------------\n\nTITLE: Implementing atomic folding with TMap.reduce in TypeScript\nDESCRIPTION: The reduce function atomically folds over key-value pairs in a TMap using a pure function. It accepts an initial value, a folding function, and the TMap to operate on. The function is overloaded to support both curried and non-curried calling styles.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TMap-reduce.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const reduce: { <Z, K, V>(zero: Z, f: (acc: Z, value: V, key: K) => Z): (self: TMap<K, V>) => STM.STM<Z>; <K, V, Z>(self: TMap<K, V>, zero: Z, f: (acc: Z, value: V, key: K) => Z): STM.STM<Z>; }\n```\n\n----------------------------------------\n\nTITLE: Calculating Remainder with BigDecimal in TypeScript\nDESCRIPTION: Demonstrates how to use the BigDecimal.remainder function to calculate the remainder when dividing two BigDecimal numbers. The function returns an Option type, with Some containing the result or None if the divisor is zero.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/BigDecimal-remainder.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { BigDecimal, Option } from \"effect\"\n\nassert.deepStrictEqual(BigDecimal.remainder(BigDecimal.unsafeFromString(\"2\"), BigDecimal.unsafeFromString(\"2\")), Option.some(BigDecimal.unsafeFromString(\"0\")))\nassert.deepStrictEqual(BigDecimal.remainder(BigDecimal.unsafeFromString(\"3\"), BigDecimal.unsafeFromString(\"2\")), Option.some(BigDecimal.unsafeFromString(\"1\")))\nassert.deepStrictEqual(BigDecimal.remainder(BigDecimal.unsafeFromString(\"-4\"), BigDecimal.unsafeFromString(\"2\")), Option.some(BigDecimal.unsafeFromString(\"0\")))\n```\n\n----------------------------------------\n\nTITLE: Defining provideMerge Function for Layer Composition in TypeScript\nDESCRIPTION: The provideMerge function combines two layers by feeding the output of one layer into the input of another. It results in a new layer with inputs from the first layer and outputs from both layers. This function is overloaded to allow for different calling patterns.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Layer-provideMerge.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const provideMerge: {\n  <RIn, E, ROut>(self: Layer<ROut, E, RIn>):\n    <RIn2, E2, ROut2>(that: Layer<ROut2, E2, RIn2>) =>\n      Layer<ROut | ROut2, E | E2, RIn | Exclude<RIn2, ROut>>;\n  <RIn2, E2, ROut2, RIn, E, ROut>(\n    that: Layer<ROut2, E2, RIn2>,\n    self: Layer<ROut, E, RIn>\n  ): Layer<ROut2 | ROut, E2 | E, RIn | Exclude<RIn2, ROut>>;\n}\n```\n\n----------------------------------------\n\nTITLE: Effect.filterMap Type Signature\nDESCRIPTION: Type declaration for the Effect.filterMap function, showing its polymorphic nature and support for both curried and uncurried forms. The function works with Effect types and returns a new Effect containing filtered and mapped results.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-filterMap.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const filterMap: { <Eff extends Effect<any, any, any>, B>(pf: (a: Effect.Success<Eff>) => Option.Option<B>): (elements: Iterable<Eff>) => Effect<Array<B>, Effect.Error<Eff>, Effect.Context<Eff>>; <Eff extends Effect<any, any, any>, B>(elements: Iterable<Eff>, pf: (a: Effect.Success<Eff>) => Option.Option<B>): Effect<Array<B>, Effect.Error<Eff>, Effect.Context<Eff>>; }\n```\n\n----------------------------------------\n\nTITLE: Initializing Predicate.isRecord Type Guard in TypeScript\nDESCRIPTION: A type guard function that checks if an input is a record object, returning true for plain objects and false for other types like arrays, null, undefined, and functions.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Predicate-isRecord.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { isRecord } from \"effect/Predicate\"\n\nassert.deepStrictEqual(isRecord({}), true)\nassert.deepStrictEqual(isRecord({ a: 1 }), true)\n\nassert.deepStrictEqual(isRecord([]), false)\nassert.deepStrictEqual(isRecord([1, 2, 3]), false)\nassert.deepStrictEqual(isRecord(null), false)\nassert.deepStrictEqual(isRecord(undefined), false)\nassert.deepStrictEqual(isRecord(() => null), false)\n```\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const isRecord: (input: unknown) => input is { [x: string | symbol]: unknown; }\n```\n\n----------------------------------------\n\nTITLE: Defining STM.as Function for Value Mapping in Transactional Memory Operations\nDESCRIPTION: Declares the `as` function which maps the success value of an STM effect to a specified constant value. The function provides two call signatures - one for curried application and another for direct application with both the STM instance and the new value.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/STM-as.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const as: { <A2>(value: A2): <A, E, R>(self: STM<A, E, R>) => STM<A2, E, R>; <A, E, R, A2>(self: STM<A, E, R>, value: A2): STM<A2, E, R>; }\n```\n\n----------------------------------------\n\nTITLE: Creating Stream from Scoped Effect using unwrapScoped\nDESCRIPTION: Function signature for unwrapScoped that creates a stream from a scoped Effect. It takes an Effect that produces a Stream and returns a new Stream with combined error types and resource requirements, excluding the Scope.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-unwrapScoped.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const unwrapScoped: <A, E2, R2, E, R>(effect: Effect.Effect<Stream<A, E2, R2>, E, R>) => Stream<A, E | E2, R2 | Exclude<R, Scope.Scope>>\n```\n\n----------------------------------------\n\nTITLE: Declaring WebSocket Constructor Layer in TypeScript for Browser Environments\nDESCRIPTION: Defines a Layer that provides a WebSocket constructor implementation using the browser's global WebSocket object. This allows the Effect.io platform to create WebSocket connections in browser environments.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/BrowserSocket-layerWebSocketConstructor.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const layerWebSocketConstructor: Layer.Layer<Socket.WebSocketConstructor, never, never>\n```\n\n----------------------------------------\n\nTITLE: Removing a Key from TMap in STM Context with TypeScript\nDESCRIPTION: The 'remove' function removes a binding for a given key from a TMap. It provides both curried and uncurried variants to allow flexible usage patterns within software transactional memory operations.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TMap-remove.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const remove: { <K>(key: K): <V>(self: TMap<K, V>) => STM.STM<void>; <K, V>(self: TMap<K, V>, key: K): STM.STM<void>; }\n```\n\n----------------------------------------\n\nTITLE: Implementing Config.zip Function in TypeScript for the Effect-TS Library\nDESCRIPTION: The zip function composes two Config objects into a single Config that produces a tuple of their values. It supports both curried and uncurried calling styles, allowing for flexible composition patterns in the Effect-TS ecosystem.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Config-zip.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const zip: { <B>(that: Config<B>): <A>(self: Config<A>) => Config<[A, B]>; <A, B>(self: Config<A>, that: Config<B>): Config<[A, B]>; }\n```\n\n----------------------------------------\n\nTITLE: Implementing Conditional Logic with Micro.when in TypeScript\nDESCRIPTION: The `when` function serves as a conditional operator within the Micro module, equivalent to `if (p) exp`. It allows for conditionally executing effects based on either a boolean value or another Micro effect that resolves to a boolean.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Micro-when.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const when: { <E2 = never, R2 = never>(condition: LazyArg<boolean> | Micro<boolean, E2, R2>): <A, E, R>(self: Micro<A, E, R>) => Micro<Option.Option<A>, E | E2, R | R2>; <A, E, R, E2 = never, R2 = never>(self: Micro<A, E, R>, condition: LazyArg<boolean> | Micro<boolean, E2, R2>): Micro<Option.Option<A>, E | E2, R | R2>; }\n```\n\n----------------------------------------\n\nTITLE: Creating Cookies with Validation in TypeScript\nDESCRIPTION: The unsafeMakeCookie function creates a new cookie object, throwing an error if the provided parameters are invalid. It accepts a name, value, and optional configuration options for the cookie.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Cookies-unsafeMakeCookie.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const unsafeMakeCookie: (name: string, value: string, options?: Cookie[\"options\"] | undefined) => Cookie\n```\n\n----------------------------------------\n\nTITLE: Converting Strings to BigInt Values with Option Types in TypeScript\nDESCRIPTION: The fromString function takes a string input and attempts to convert it to a bigint. It returns Option.some(bigint) for valid numeric strings and Option.none() for empty strings or strings with non-numeric characters. This provides safe conversion with proper error handling.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/BigInt-fromString.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { BigInt as BI, Option } from \"effect\"\n\nassert.deepStrictEqual(BI.fromString(\"42\"), Option.some(BigInt(42)))\nassert.deepStrictEqual(BI.fromString(\" \"), Option.none())\nassert.deepStrictEqual(BI.fromString(\"a\"), Option.none())\n```\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const fromString: (s: string) => Option.Option<bigint>\n```\n\n----------------------------------------\n\nTITLE: Implementing HashMap Mutation in TypeScript\nDESCRIPTION: Defines a mutate function that accepts a HashMap and a mutation function. The function provides a way to modify the HashMap within a controlled context, returning the modified HashMap. Supports both curried and uncurried function calls.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/HashMap-mutate.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const mutate: { \n  <K, V>(f: (self: HashMap<K, V>) => void): (self: HashMap<K, V>) => HashMap<K, V>; \n  <K, V>(self: HashMap<K, V>, f: (self: HashMap<K, V>) => void): HashMap<K, V>; \n}\n```\n\n----------------------------------------\n\nTITLE: Retrieving the Last Option in TArray with TypeScript\nDESCRIPTION: This snippet declares a TypeScript constant 'lastOption' that defines a function for obtaining the last element of a TArray, returning an Option type wrapped in an STM context. It is suitable for use with STM for safe concurrent operations on arrays.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TArray-lastOption.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const lastOption: <A>(self: TArray<A>) => STM.STM<Option.Option<A>>\n```\n\n----------------------------------------\n\nTITLE: Creating CRUD Repository from Model in Effect/SQL\nDESCRIPTION: The makeRepository function creates a simple CRUD repository from a model, providing standard operations like insert, update, find by ID, and delete. It requires a Model object and configuration options including table name, span prefix for tracing, and the column name for the ID field.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Model-makeRepository.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const makeRepository: <S extends Any, Id extends (keyof S[\"Type\"]) & (keyof S[\"update\"][\"Type\"]) & (keyof S[\"fields\"])>(Model: S, options: { readonly tableName: string; readonly spanPrefix: string; readonly idColumn: Id; }) => Effect.Effect<{ readonly insert: (insert: S[\"insert\"][\"Type\"]) => Effect.Effect<S[\"Type\"], never, S[\"Context\"] | S[\"insert\"][\"Context\"]>; readonly insertVoid: (insert: S[\"insert\"][\"Type\"]) => Effect.Effect<void, never, S[\"Context\"] | S[\"insert\"][\"Context\"]>; readonly update: (update: S[\"update\"][\"Type\"]) => Effect.Effect<S[\"Type\"], never, S[\"Context\"] | S[\"update\"][\"Context\"]>; readonly updateVoid: (update: S[\"update\"][\"Type\"]) => Effect.Effect<void, never, S[\"Context\"] | S[\"update\"][\"Context\"]>; readonly findById: (id: Schema.Schema.Type<S[\"fields\"][Id]>) => Effect.Effect<Option.Option<S[\"Type\"]>, never, S[\"Context\"] | Schema.Schema.Context<S[\"fields\"][Id]>>; readonly delete: (id: Schema.Schema.Type<S[\"fields\"][Id]>) => Effect.Effect<void, never, Schema.Schema.Context<S[\"fields\"][Id]>>; }, never, SqlClient>\n```\n\n----------------------------------------\n\nTITLE: Implementing Random Service Integration in TypeScript Effect Module\nDESCRIPTION: Function signature for withRandom that allows executing effects with a custom Random service implementation. The function supports two overloads - one taking the Random service first and effect second, and another taking effect first and Random service second.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-withRandom.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const withRandom: { <X extends Random.Random>(value: X): <A, E, R>(effect: Effect<A, E, R>) => Effect<A, E, R>; <X extends Random.Random, A, E, R>(effect: Effect<A, E, R>, value: X): Effect<A, E, R>; }\n```\n\n----------------------------------------\n\nTITLE: Implementing Error Recovery in Effect Layer Module\nDESCRIPTION: Defines a catchAllCause function that provides error recovery functionality for Layer operations. It takes an error handler function that processes a Cause<E> and returns a new Layer. The function supports both curried and uncurried forms for flexibility in usage.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Layer-catchAllCause.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const catchAllCause: { <E, RIn2, E2, ROut2>(onError: (cause: Cause.Cause<E>) => Layer<ROut2, E2, RIn2>): <RIn, ROut>(self: Layer<ROut, E, RIn>) => Layer<ROut & ROut2, E2, RIn2 | RIn>; <RIn, E, ROut, RIn2, E2, ROut22>(self: Layer<ROut, E, RIn>, onError: (cause: Cause.Cause<E>) => Layer<ROut22, E2, RIn2>): Layer<ROut & ROut22, E2, RIn | RIn2>; }\n```\n\n----------------------------------------\n\nTITLE: Converting DateTime to Epoch Milliseconds in TypeScript\nDESCRIPTION: This function retrieves the milliseconds since the Unix epoch (January 1, 1970, 00:00:00 UTC) from a DateTime object. It takes a DateTime instance and returns a number representing the milliseconds.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/DateTime-toEpochMillis.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const toEpochMillis: (self: DateTime) => number\n```\n\n----------------------------------------\n\nTITLE: Deleting Elements from Chunks in Effect Library (TypeScript)\nDESCRIPTION: The `remove` function deletes the element at the specified index and creates a new `Chunk`. It can be used in both curried and uncurried forms, accepting either the index first or the chunk first.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Chunk-remove.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const remove: { (i: number): <A>(self: Chunk<A>) => Chunk<A>; <A>(self: Chunk<A>, i: number): Chunk<A>; }\n```\n\n----------------------------------------\n\nTITLE: Testing Boolean XOR Operation in TypeScript\nDESCRIPTION: Example test cases demonstrating the XOR operation between boolean values using the Effect library's Boolean module. Shows all possible combinations of true/false inputs and their expected outputs.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Boolean-xor.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { xor } from \"effect/Boolean\"\n\nassert.deepStrictEqual(xor(true, true), false)\nassert.deepStrictEqual(xor(true, false), true)\nassert.deepStrictEqual(xor(false, true), true)\nassert.deepStrictEqual(xor(false, false), false)\n```\n\n----------------------------------------\n\nTITLE: Creating Stream from Mailbox in TypeScript\nDESCRIPTION: The toStream function converts a ReadonlyMailbox into a Stream. It takes a ReadonlyMailbox<A, E> as input and returns a Stream<A, E>. This function has been available since version 3.8.0 of the package.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Mailbox-toStream.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const toStream: <A, E>(self: ReadonlyMailbox<A, E>) => Stream<A, E>\n```\n\n----------------------------------------\n\nTITLE: Running Parallel Sinks with raceBoth in Effect-TS\nDESCRIPTION: The `raceBoth` function runs two sinks in parallel on the same input, returning the result or error from whichever sink completes first. It accepts an optional capacity parameter for controlling concurrency and returns the result as an Either type.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Sink-raceBoth.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const raceBoth: { <A1, In1, L1, E1, R1>(that: Sink<A1, In1, L1, E1, R1>, options?: { readonly capacity?: number | undefined; } | undefined): <A, In, L, E, R>(self: Sink<A, In, L, E, R>) => Sink<Either.Either<A1, A>, In & In1, L1 | L, E1 | E, R1 | R>; <A, In, L, E, R, A1, In1, L1, E1, R1>(self: Sink<A, In, L, E, R>, that: Sink<A1, In1, L1, E1, R1>, options?: { readonly capacity?: number | undefined; } | undefined): Sink<Either.Either<A1, A>, In & In1, L | L1, E | E1, R | R1>; }\n```\n\n----------------------------------------\n\nTITLE: Checking for Error Type in TypeScript\nDESCRIPTION: A type guard function that determines whether an input is an instance of the Error class. Returns true for Error objects and false for other types.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Predicate-isError.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { isError } from \"effect/Predicate\"\n\nassert.deepStrictEqual(isError(new Error()), true)\n\nassert.deepStrictEqual(isError(null), false)\nassert.deepStrictEqual(isError({}), false)\n```\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const isError: (input: unknown) => input is Error\n```\n\n----------------------------------------\n\nTITLE: Signature of Stream.fromChunks Function in TypeScript\nDESCRIPTION: This snippet presents the TypeScript declaration of the `fromChunks` function used to create a Stream from several chunks. The function takes an arbitrary number of chunks as arguments and outputs a Stream of type A. Utilization requires the `effect` package.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-fromChunks.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const fromChunks: <A>(...chunks: Array<Chunk.Chunk<A>>) => Stream<A>\n```\n\n----------------------------------------\n\nTITLE: Implementing Scoped Console Service Replacement in Effect\nDESCRIPTION: This function sets a custom console service implementation for the duration of a scope and restores the original implementation when the scope closes. It requires a Scope dependency to track the lifecycle.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-withConsoleScoped.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const withConsoleScoped: <A extends Console>(console: A) => Effect<void, never, Scope.Scope>\n```\n\n----------------------------------------\n\nTITLE: Declaring interruptWhenDeferred Function in TypeScript for Channel Interruption Control\nDESCRIPTION: TypeScript type signature for the interruptWhenDeferred function that allows interrupting a channel when a deferred is completed. The function supports two calling patterns - either passing the deferred first and then the channel, or passing the channel first and then the deferred. It handles the race condition between channel completion and deferred completion.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Channel-interruptWhenDeferred.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const interruptWhenDeferred: { <OutDone1, OutErr1>(deferred: Deferred.Deferred<OutDone1, OutErr1>): <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>) => Channel<OutElem, InElem, OutErr1 | OutErr, InErr, OutDone1 | OutDone, InDone, Env>; <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutDone1, OutErr1>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>, deferred: Deferred.Deferred<OutDone1, OutErr1>): Channel<OutElem, InElem, OutErr | OutErr1, InErr, OutDone | OutDone1, InDone, Env>; }\n```\n\n----------------------------------------\n\nTITLE: Testing if a value is a function using Predicate.isFunction in TypeScript\nDESCRIPTION: This example demonstrates how to use the `isFunction` predicate from the `effect/Predicate` module to check if a value is a function.  It imports the `assert` module for testing and `isFunction` from `effect/Predicate`. It asserts that `isFunction(isFunction)` returns `true` and `isFunction(\"function\")` returns `false`.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Predicate-isFunction.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { isFunction } from \"effect/Predicate\"\n\nassert.deepStrictEqual(isFunction(isFunction), true)\n\nassert.deepStrictEqual(isFunction(\"function\"), false)\n```\n\n----------------------------------------\n\nTITLE: Splitting a Chunk at a Specified Index in TypeScript\nDESCRIPTION: The splitAt function divides a Chunk into two parts at the specified index n. It returns a tuple containing the chunk elements before the index and the chunk elements from the index onwards.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Chunk-splitAt.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const splitAt: { (n: number): <A>(self: Chunk<A>) => [beforeIndex: Chunk<A>, fromIndex: Chunk<A>]; <A>(self: Chunk<A>, n: number): [beforeIndex: Chunk<A>, fromIndex: Chunk<A>]; }\n```\n\n----------------------------------------\n\nTITLE: Initializing Manual Reloadable Service Layer - TypeScript\nDESCRIPTION: Creates a new reloadable service from a layer that describes the construction of a static service. Takes a context tag and options containing the layer configuration as parameters.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Reloadable-manual.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const manual: <I, S, In, E>(tag: Context.Tag<I, S>, options: { readonly layer: Layer.Layer<I, E, In>; }) => Layer.Layer<Reloadable<I>, E, In>\n```\n\n----------------------------------------\n\nTITLE: Creating a Channel Buffer in TypeScript\nDESCRIPTION: Creates a channel backed by a buffer. When the buffer is empty, the channel passthrough its input as output. When non-empty, the value inside the buffer is passed along as output.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Channel-buffer.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const buffer: <InElem, InErr, InDone>(options: { readonly empty: InElem; readonly isEmpty: Predicate<InElem>; readonly ref: Ref.Ref<InElem>; }) => Channel<InElem, InElem, InErr, InErr, InDone, InDone, never>\n```\n\n----------------------------------------\n\nTITLE: Creating a Histogram Metric in TypeScript using Effect Library\nDESCRIPTION: This snippet demonstrates how to create a histogram metric using the Metric.histogram function from the Effect library. It sets up a latency histogram with linear boundaries.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Metric-histogram.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Metric, MetricBoundaries } from \"effect\"\n\nconst latencyHistogram = Metric.histogram(\"latency_histogram\",\n  MetricBoundaries.linear({ start: 0, width: 10, count: 11 }),\n  \"Measures the distribution of request latency.\"\n);\n```\n\n----------------------------------------\n\nTITLE: Signature of the 'tap' Function in TypeScript\nDESCRIPTION: This generic TypeScript signature defines the 'tap' function which applies a unary function to an 'Option' type. It supports two overloads to work with either currying or direct application. Key parameters are a function 'f' that transforms an input of type 'A' to an 'Option' of type 'X', and an 'Option' object. Outputs are returned as 'Option' of type 'A'.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Option-tap.md#2025-04-11_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const tap: { <A, X>(f: (a: A) => Option<X>): (self: Option<A>) => Option<A>; <A, X>(self: Option<A>, f: (a: A) => Option<X>): Option<A>; }\n```\n\n----------------------------------------\n\nTITLE: Broadcasting Streams to Dynamic Queues in TypeScript\nDESCRIPTION: This function converts a stream into a dynamic amount of broadcasted queues, allowing each chunk of data to be sent to multiple queues. The slowest queue can buffer a specified maximum lag before applying back pressure. Possible maximum lag configurations include unbounded capacity or specified capacity with various strategies.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-broadcastedQueuesDynamic.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const broadcastedQueuesDynamic: { (maximumLag: number | { readonly capacity: \"unbounded\"; readonly replay?: number | undefined; } | { readonly capacity: number; readonly strategy?: \"sliding\" | \"dropping\" | \"suspend\" | undefined; readonly replay?: number | undefined; }): <A, E, R>(self: Stream<A, E, R>) => Effect.Effect<Effect.Effect<Queue.Dequeue<Take.Take<A, E>>, never, Scope.Scope>, never, Scope.Scope | R>; <A, E, R>(self: Stream<A, E, R>, maximumLag: number | { readonly capacity: \"unbounded\"; readonly replay?: number | undefined; } | { readonly capacity: number; readonly strategy?: \"sliding\" | \"dropping\" | \"suspend\" | undefined; readonly replay?: number | undefined; }): Effect.Effect<Effect.Effect<Queue.Dequeue<Take.Take<A, E>>, never, Scope.Scope>, never, Scope.Scope | R>; }\n```\n\n----------------------------------------\n\nTITLE: Subtracting Numbers with Effect in TypeScript\nDESCRIPTION: This snippet demonstrates how to perform subtraction operations on two numbers using the 'subtract' function from the Effect library's Number module. It includes a practical example utilizing the assert module to verify subtraction results. The 'subtract' function takes two numbers either in a curried form or a direct form, returning their difference. The main dependency is the 'effect/Number' module.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Number-subtract.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport * as assert from \"node:assert\"\\nimport { subtract } from \"effect/Number\"\\n\\nassert.deepStrictEqual(subtract(2, 3), -1)\n```\n\n----------------------------------------\n\nTITLE: Defining Type-Safe Pattern Matching for Defined Values in TypeScript\nDESCRIPTION: Declares a constant 'defined' that matches any defined (non-null and non-undefined) value. It uses a type predicate to narrow the type of the input to exclude null and undefined.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Match-defined.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const defined: <A>(u: A) => u is A & {}\n```\n\n----------------------------------------\n\nTITLE: Creating TPriorityQueue from Iterable - TypeScript\nDESCRIPTION: This snippet declares a function `fromIterable` which constructs a `TPriorityQueue` from an iterable collection of values. It requires the `Order` type for determining the ordering of elements in the queue. The input is the iterable collection and the output is an STM operation that results in a `TPriorityQueue` instance.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TPriorityQueue-fromIterable.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const fromIterable: <A>(order: Order.Order<A>) => (iterable: Iterable<A>) => STM.STM<TPriorityQueue<A>>\n```\n\n----------------------------------------\n\nTITLE: Type Definition for Layer.match in TypeScript\nDESCRIPTION: Type signature for Layer.match function that feeds error or output services into failure or success layers. It takes options for handling both failure and success cases, returning a new combined layer.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Layer-match.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const match: {\n  <E, A2, E2, R2, A, A3, E3, R3>(\n    options: {\n      readonly onFailure: (error: E) => Layer<A2, E2, R2>;\n      readonly onSuccess: (context: Context.Context<A>) => Layer<A3, E3, R3>;\n    }\n  ): <R>(self: Layer<A, E, R>) => Layer<A2 & A3, E2 | E3, R2 | R3 | R>;\n  <A, E, R, A2, E2, R2, A3, E3, R3>(\n    self: Layer<A, E, R>,\n    options: {\n      readonly onFailure: (error: E) => Layer<A2, E2, R2>;\n      readonly onSuccess: (context: Context.Context<A>) => Layer<A3, E3, R3>;\n    }\n  ): Layer<A2 & A3, E2 | E3, R | R2 | R3>;\n}\n```\n\n----------------------------------------\n\nTITLE: Declaring Nested ConfigProvider Function in TypeScript\nDESCRIPTION: Defines a nested function that creates a new config provider by nesting all configuration under a specified property name. Supports both curried and regular function call syntax.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/ConfigProvider-nested.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const nested: { \n  (name: string): (self: ConfigProvider) => ConfigProvider; \n  (self: ConfigProvider, name: string): ConfigProvider; \n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Line Iterator for Strings in TypeScript\nDESCRIPTION: Defines a function that creates an IterableIterator to process strings line by line. It returns an iterator that yields each line from the input string with trailing newline characters removed.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/String-linesIterator.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const linesIterator: (self: string) => LinesIterator\n```\n\n----------------------------------------\n\nTITLE: Using Stream.takeUntil with Effect in TypeScript\nDESCRIPTION: This code snippet demonstrates how to use the 'takeUntil' function from the Effect library's Stream module. It takes elements from an iterative stream of numbers starting from 0, stopping when the predicate condition (number equals 4) is met. This example requires the 'effect' package, and utilizes the 'Effect.runPromise' to execute the stream collecting process, outputting the collected values. Input is an infinite stream starting from 0, with output being the collected chunk of numbers up to 4.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-takeUntil.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Effect, Stream } from \"effect\"\n\nconst stream = Stream.takeUntil(Stream.iterate(0, (n) => n + 1), (n) => n === 4)\n\nEffect.runPromise(Stream.runCollect(stream)).then(console.log)\n// { _id: 'Chunk', values: [ 0, 1, 2, 3, 4 ] }\n```\n\n----------------------------------------\n\nTITLE: Function Signature for Data.tagged in TypeScript\nDESCRIPTION: The type signature for the Data.tagged function, which takes a tag string and returns a constructor for objects with that tag. The constructor automatically adds the specified tag to the created objects.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Data-tagged.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const tagged: <A extends { readonly _tag: string; }>(tag: A[\"_tag\"]) => Case.Constructor<A, \"_tag\">\n```\n\n----------------------------------------\n\nTITLE: HashSet.beginMutation Function Signature in TypeScript\nDESCRIPTION: The type signature for the HashSet.beginMutation function, which takes a HashSet of type A and returns the same HashSet but in a mutable state for in-place modifications.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/HashSet-beginMutation.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const beginMutation: <A>(self: HashSet<A>) => HashSet<A>\n```\n\n----------------------------------------\n\nTITLE: Initializing Trie with Numeric Values\nDESCRIPTION: Creates a Trie data structure with string keys and numeric values, demonstrating Trie insertion\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Trie-unsafeGet.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst trie = Trie.empty<number>().pipe(\n  Trie.insert(\"call\", 0),\n  Trie.insert(\"me\", 1)\n)\n```\n\n----------------------------------------\n\nTITLE: Combining Boolean Values with SemigroupSome in TypeScript\nDESCRIPTION: The code demonstrates the use of the SemigroupSome from the @effect/typeclass library, which combines Boolean values using a logical OR operation. It's a semigroup pattern under disjunction where any true value will make the result true. Requires the @effect/typeclass package. Inputs are Boolean values, and the outcome is a single Boolean result reflective of OR logic.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/data-Boolean-SemigroupSome.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { SemigroupSome } from \"@effect/typeclass/data/Boolean\"\n\nconsole.log(SemigroupSome.combine(true, true))\n// true\nconsole.log(SemigroupSome.combine(true, false))\n// true\nconsole.log(SemigroupSome.combine(false, true))\n// true\nconsole.log(SemigroupSome.combine(false, false))\n// false\n```\n\n----------------------------------------\n\nTITLE: Implementing Stream Timeout with Custom Failure Cause in TypeScript\nDESCRIPTION: Defines a function that fails a stream with a specified cause if no value is produced within a given duration. The function accepts a lazy cause argument and duration input, and can be applied to streams with various type parameters.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-timeoutFailCause.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const timeoutFailCause: { <E2>(cause: LazyArg<Cause.Cause<E2>>, duration: Duration.DurationInput): <A, E, R>(self: Stream<A, E, R>) => Stream<A, E2 | E, R>; <A, E, R, E2>(self: Stream<A, E, R>, cause: LazyArg<Cause.Cause<E2>>, duration: Duration.DurationInput): Stream<A, E | E2, R>; }\n```\n\n----------------------------------------\n\nTITLE: Creating Successful STM Transaction in TypeScript\nDESCRIPTION: Generates an STM effect that immediately succeeds with the provided value. Used for creating simple, constant STM transactions without complex logic or potential failures.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/STM-succeed.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const succeed: <A>(value: A) => STM<A>\n```\n\n----------------------------------------\n\nTITLE: Modifying Property Key with Effect Schema\nDESCRIPTION: The `fromKey` function is used to change the property key during schema encoding. It enhances the property signature by allowing a different key to be specified for the encoded type. This function provides flexibility in how data is represented in the encoded format, allowing for customization based on specific needs.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Schema-fromKey.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const fromKey: { <Key extends PropertyKey>(key: Key): <TypeToken extends PropertySignature.Token, Type, EncodedToken extends PropertySignature.Token, Encoded, HasDefault extends boolean, R>(self: PropertySignature<TypeToken, Type, PropertyKey, EncodedToken, Encoded, HasDefault, R>) => PropertySignature<TypeToken, Type, Key, EncodedToken, Encoded, HasDefault, R>; <Type, TypeToken extends PropertySignature.Token, Encoded, EncodedToken extends PropertySignature.Token, HasDefault extends boolean, R, Key extends PropertyKey>(self: PropertySignature<TypeToken, Type, PropertyKey, EncodedToken, Encoded, HasDefault, R>, key: Key): PropertySignature<TypeToken, Type, Key, EncodedToken, Encoded, HasDefault, R>; }\n```\n\n----------------------------------------\n\nTITLE: Using tapError to Log Errors in Effect\nDESCRIPTION: This example demonstrates how to use the tapError function to log error messages when an effect fails. A task is simulated to fail with a string error, and tapError is used to log the error message without affecting the original failure.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-tapError.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Effect, Console } from \"effect\"\n\n// Simulate a task that fails with an error\nconst task: Effect.Effect<number, string> = Effect.fail(\"NetworkError\")\n\n// Use tapError to log the error message when the task fails\nconst tapping = Effect.tapError(task, (error) =>\n  Console.log(`expected error: ${error}`)\n)\n\nEffect.runFork(tapping)\n// Output:\n// expected error: NetworkError\n```\n\n----------------------------------------\n\nTITLE: Defining mergeRight Function for Stream Merging in TypeScript\nDESCRIPTION: Declares the mergeRight function which merges two streams, keeping only the values from the right stream. It supports both curried and non-curried forms, handling various type parameters for streams.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-mergeRight.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const mergeRight: { <AR, ER, RR>(right: Stream<AR, ER, RR>): <AL, EL, RL>(left: Stream<AL, EL, RL>) => Stream<AR, ER | EL, RR | RL>; <AL, EL, RL, AR, ER, RR>(left: Stream<AL, EL, RL>, right: Stream<AR, ER, RR>): Stream<AR, EL | ER, RL | RR>; }\n```\n\n----------------------------------------\n\nTITLE: Implementing Stream Element Collection with Predicate in TypeScript\nDESCRIPTION: Defines a function that accumulates incoming elements into a chunk until a specified predicate condition is met. The function takes a predicate and returns a Sink that processes elements of type In and produces a Chunk containing the collected elements.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Sink-collectAllUntil.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const collectAllUntil: <In>(p: Predicate<In>) => Sink<Chunk.Chunk<In>, In, In>\n```\n\n----------------------------------------\n\nTITLE: Lifting Predicate to Option Context in TypeScript\nDESCRIPTION: The snippet demonstrates using the 'liftPredicate' function to convert a predicate into a function that returns an Option. It requires the 'effect' package and focuses on transforming predicates/refinements into Options. It takes a predicate as input and outputs an Option, either 'Some' with the value if true, or 'None' if false.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Option-liftPredicate.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Option } from \"effect\"\n\n// Check if a number is positive\nconst isPositive = (n: number) => n > 0\n\n//      ┌─── (b: number) => Option<number>\n//      ▼\nconst parsePositive = Option.liftPredicate(isPositive)\n\nconsole.log(parsePositive(1))\n// Output: { _id: 'Option', _tag: 'Some', value: 1 }\n\nconsole.log(parsePositive(-1))\n// OUtput: { _id: 'Option', _tag: 'None' }\n```\n\n----------------------------------------\n\nTITLE: Modifying Schedule Delay with Effectful Function in Typescript\nDESCRIPTION: This TypeScript code defines the `modifyDelayEffect` function which allows modifying a schedule's delay using an effectful function. The function takes the schedule's output and the originally computed duration and returns a new adjusted duration wrapped in an `Effect`. The returned schedule will have an adjusted delay based on the provided Effect.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Schedule-modifyDelayEffect.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const modifyDelayEffect: { <Out, R2>(f: (out: Out, duration: Duration.Duration) => Effect.Effect<Duration.DurationInput, never, R2>): <In, R>(self: Schedule<Out, In, R>) => Schedule<Out, In, R2 | R>; <Out, In, R, R2>(self: Schedule<Out, In, R>, f: (out: Out, duration: Duration.Duration) => Effect.Effect<Duration.DurationInput, never, R2>): Schedule<Out, In, R | R2>; }\n```\n\n----------------------------------------\n\nTITLE: Modifying Trie Values in TypeScript using Effect\nDESCRIPTION: Demonstrates how to use the Trie.modify function to update values in a Trie data structure. It shows inserting initial values, modifying an existing value, and attempting to modify a non-existent key.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Trie-modify.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { Trie, Equal, Option } from \"effect\"\n\nconst trie = Trie.empty<number>().pipe(\n  Trie.insert(\"shells\", 0),\n  Trie.insert(\"sells\", 1),\n  Trie.insert(\"she\", 2)\n)\n\nassert.deepStrictEqual(trie.pipe(Trie.modify(\"she\", (v) => v + 10), Trie.get(\"she\")), Option.some(12))\n\nassert.equal(Equal.equals(trie.pipe(Trie.modify(\"me\", (v) => v)), trie), true)\n```\n\n----------------------------------------\n\nTITLE: Using Cron.match to Check Date Against Cron Pattern in TypeScript\nDESCRIPTION: Demonstrates how to use the Cron.match function to check if a specific date falls within a cron expression time window. The example parses a cron expression and tests it against two different dates.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Cron-match.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { Cron, Either } from \"effect\"\n\nconst cron = Either.getOrThrow(Cron.parse(\"0 4 8-14 * *\"))\nassert.deepStrictEqual(Cron.match(cron, new Date(\"2021-01-08 04:00:00\")), true)\nassert.deepStrictEqual(Cron.match(cron, new Date(\"2021-01-08 05:00:00\")), false)\n```\n\n----------------------------------------\n\nTITLE: Using Array.modifyOption in TypeScript\nDESCRIPTION: Demonstrates how to use Array.modifyOption to safely modify an element at a specific index in an array. Returns Some with modified array if index exists, None if index is out of bounds.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Array-modifyOption.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Array } from \"effect\"\n\nconst input = [1, 2, 3, 4]\nconst result = Array.modifyOption(input, 2, (n) => n * 2)\nconsole.log(result) // Option.some([1, 2, 6, 4])\n\nconst outOfBoundsResult = Array.modifyOption(input, 5, (n) => n * 2)\nconsole.log(outOfBoundsResult) // Option.none()\n```\n\n----------------------------------------\n\nTITLE: Implementing Infinite Effect Repetition in TypeScript\nDESCRIPTION: Function signature for forever(), which takes a Micro effect and repeats it indefinitely until a failure occurs. The function transforms a Micro<A, E, R> into Micro<never, E, R>, indicating it never completes successfully unless an error occurs.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Micro-forever.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const forever: <A, E, R>(self: Micro<A, E, R>) => Micro<never, E, R>\n```\n\n----------------------------------------\n\nTITLE: Declaring Effect.labelMetrics Function in TypeScript\nDESCRIPTION: This code snippet defines the signature of the Effect.labelMetrics function. It allows adding labels to metrics within an effect using MetricLabel objects. The function can be called with labels first or with the effect first, providing flexibility in usage.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-labelMetrics.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const labelMetrics: { (labels: Iterable<MetricLabel.MetricLabel>): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R>; <A, E, R>(self: Effect<A, E, R>, labels: Iterable<MetricLabel.MetricLabel>): Effect<A, E, R>; }\n```\n\n----------------------------------------\n\nTITLE: Retrieving and Using Live Service in Tests with TypeScript\nDESCRIPTION: The liveWith function retrieves the Live service for a test and uses it to run a specified workflow. It takes a function that accepts a TestLive instance and returns an Effect, then executes that Effect.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TestServices-liveWith.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const liveWith: <A, E, R>(f: (live: Live.TestLive) => Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>\n```\n\n----------------------------------------\n\nTITLE: Defining FiberSet.run Function Signature in TypeScript\nDESCRIPTION: This code snippet defines the signature of the FiberSet.run function. It allows forking an Effect and adding the resulting fiber to a FiberSet. The function can be called with or without options, and supports different type parameters for flexibility.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/FiberSet-run.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const run: { <A, E>(self: FiberSet<A, E>, options?: { readonly propagateInterruption?: boolean | undefined; } | undefined): <R, XE extends E, XA extends A>(effect: Effect.Effect<XA, XE, R>) => Effect.Effect<Fiber.RuntimeFiber<XA, XE>, never, R>; <A, E, R, XE extends E, XA extends A>(self: FiberSet<A, E>, effect: Effect.Effect<XA, XE, R>, options?: { readonly propagateInterruption?: boolean | undefined; } | undefined): Effect.Effect<Fiber.RuntimeFiber<XA, XE>, never, R>; }\n```\n\n----------------------------------------\n\nTITLE: Implementing Side Effects for Unexpected Errors in Micro Module\nDESCRIPTION: The tapDefect function allows performing a side effect when unexpected errors (defects) occur in a Micro instance. It takes a function that handles the defect and returns a new Micro that maintains the original success value but may introduce additional error types.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Micro-tapDefect.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const tapDefect: { <E, B, E2, R2>(f: (defect: unknown) => Micro<B, E2, R2>): <A, R>(self: Micro<A, E, R>) => Micro<A, E | E2, R | R2>; <A, E, R, B, E2, R2>(self: Micro<A, E, R>, f: (defect: unknown) => Micro<B, E2, R2>): Micro<A, E | E2, R | R2>; }\n```\n\n----------------------------------------\n\nTITLE: Using FiberHandle.join with Effect in TypeScript\nDESCRIPTION: Demonstrates how to use FiberHandle.join to handle fiber termination. When any fiber in the handle fails, the effect terminates with the first failure that occurred.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/FiberHandle-join.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Effect, FiberHandle } from \"effect\";\n\nEffect.gen(function* (_) {\n  const handle = yield* _(FiberHandle.make());\n  yield* _(FiberHandle.set(handle, Effect.runFork(Effect.fail(\"error\"))));\n\n  // parent fiber will fail with \"error\"\n  yield* _(FiberHandle.join(handle));\n});\n```\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const join: <A, E>(self: FiberHandle<A, E>) => Effect.Effect<void, E>\n```\n\n----------------------------------------\n\nTITLE: Defining provideLayer Function for Stream in TypeScript\nDESCRIPTION: Declares the provideLayer function which provides a Layer to a Stream, translating it to another level. It has two overloads: one for providing a Layer to a Stream, and another for providing a Stream and a Layer.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-provideLayer.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const provideLayer: {\n  <RIn, E2, ROut>(layer: Layer.Layer<ROut, E2, RIn>): <A, E>(self: Stream<A, E, ROut>) => Stream<A, E2 | E, RIn>;\n  <A, E, RIn, E2, ROut>(self: Stream<A, E, ROut>, layer: Layer.Layer<ROut, E2, RIn>): Stream<A, E | E2, RIn>;\n}\n```\n\n----------------------------------------\n\nTITLE: Zipping Stream Elements with Previous and Next Values in TypeScript\nDESCRIPTION: Demonstrates how to use Stream.zipWithPreviousAndNext to create a stream where each element is combined with its previous and next elements in an Option wrapper. The function transforms a stream of single values into a stream of tuples containing the previous, current, and next elements.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-zipWithPreviousAndNext.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Chunk, Effect, Stream } from \"effect\"\n\nconst stream = Stream.zipWithPreviousAndNext(Stream.make(1, 2, 3, 4))\n\nEffect.runPromise(Stream.runCollect(stream)).then((chunk) => console.log(Chunk.toArray(chunk)))\n// [\n//   [\n//     { _id: 'Option', _tag: 'None' },\n//     1,\n//     { _id: 'Option', _tag: 'Some', value: 2 }\n//   ],\n//   [\n//     { _id: 'Option', _tag: 'Some', value: 1 },\n//     2,\n//     { _id: 'Option', _tag: 'Some', value: 3 }\n//   ],\n//   [\n//     { _id: 'Option', _tag: 'Some', value: 2 },\n//     3,\n//     { _id: 'Option', _tag: 'Some', value: 4 }\n//   ],\n//   [\n//     { _id: 'Option', _tag: 'Some', value: 3 },\n//     4,\n//     { _id: 'Option', _tag: 'None' }\n//   ]\n// ]\n```\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const zipWithPreviousAndNext: <A, E, R>(self: Stream<A, E, R>) => Stream<[Option.Option<A>, A, Option.Option<A>], E, R>\n```\n\n----------------------------------------\n\nTITLE: Declaring linkSpanCurrent Function in TypeScript\nDESCRIPTION: Defines the linkSpanCurrent function which adds span links to the current span. It has two overloads: one for adding a single span link with optional attributes, and another for adding multiple span links.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-linkSpanCurrent.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const linkSpanCurrent: { (span: Tracer.AnySpan, attributes?: Readonly<Record<string, unknown>> | undefined): Effect<void>; (links: ReadonlyArray<Tracer.SpanLink>): Effect<void>; }\n```\n\n----------------------------------------\n\nTITLE: Implementing Retry Logic with TypeScript STM\nDESCRIPTION: This TypeScript code snippet introduces the 'eventually' function in the STM module that retries a given transactional operation until it succeeds without error. The function takes a STM operation that may fail and wraps it to continue retrying until a success is encountered. This is useful in scenarios requiring idempotent operations and continuous retry support. Since v2.0.0.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/STM-eventually.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const eventually: <A, E, R>(self: STM<A, E, R>) => STM<A, E, R>\n```\n\n----------------------------------------\n\nTITLE: Declaring isReadonlyRecord function in Typescript\nDESCRIPTION: This code declares the `isReadonlyRecord` function. It accepts an unknown input and returns a boolean value indicating whether the input is a readonly record with string or symbol keys and unknown values. It utilizes a type predicate to narrow the type of the input if it is a readonly record.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Predicate-isReadonlyRecord.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const isReadonlyRecord: (input: unknown) => input is { readonly [x: string | symbol]: unknown; }\n```\n\n----------------------------------------\n\nTITLE: Checking Queue Emptiness in TypeScript using Effect Library\nDESCRIPTION: The isEmpty function returns a boolean Effect indicating whether a Queue contains zero elements. It works with both Dequeue and Enqueue types.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Queue-isEmpty.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const isEmpty: <A>(self: Dequeue<A> | Enqueue<A>) => Effect.Effect<boolean>\n```\n\n----------------------------------------\n\nTITLE: Lifting a Binary Function to Work with Option Values - TypeScript\nDESCRIPTION: This code demonstrates how to lift a binary function to operate on two `Option` values, returning a wrapped result based on their state. It includes an example of using an `add` function, shows the output for different cases of `Option` values, and specifies the function signature for `lift2`.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Option-lift2.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { Option } from \"effect\"\n\n// A binary function to add two numbers\nconst add = (a: number, b: number): number => a + b\n\n// Lift the `add` function to work with `Option` values\nconst addOptions = Option.lift2(add)\n\n// Both `Option`s are `Some`\nconsole.log(addOptions(Option.some(2), Option.some(3)))\n// Output: { _id: 'Option', _tag: 'Some', value: 5 }\n\n// One `Option` is `None`\nconsole.log(addOptions(Option.some(2), Option.none()))\n// Output: { _id: 'Option', _tag: 'None' }\n\n```\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const lift2: <A, B, C>(f: (a: A, b: B) => C) => { (that: Option<B>): (self: Option<A>) => Option<C>; (self: Option<A>, that: Option<B>): Option<C>; }\n\n```\n\n----------------------------------------\n\nTITLE: Constructing Failing Layer in TypeScript\nDESCRIPTION: The 'fail' function constructs a layer that fails with the specified error. It takes an error of type E as input and returns a Layer of unknown type that can fail with error E.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Layer-fail.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const fail: <E>(error: E) => Layer<unknown, E>\n```\n\n----------------------------------------\n\nTITLE: Implementing Patch Combination with Differ in TypeScript\nDESCRIPTION: Defines a type signature for combining two patches using Differ. The method supports both curried and uncurried forms, allowing flexible patch combination while maintaining type safety. The operation is designed to be associative and potentially commutative for concurrent fiber operations.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Differ-combine.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const combine: { <Patch>(first: Patch, second: Patch): <Value>(self: Differ<Value, Patch>) => Patch; <Value, Patch>(self: Differ<Value, Patch>, first: Patch, second: Patch): Patch; }\n```\n\n----------------------------------------\n\nTITLE: Defining collect function for Channel transformation in TypeScript\nDESCRIPTION: This code snippet defines the collect function for the Channel module. It returns a new channel that filters and transforms the outputs of the original channel using a specified partial function.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Channel-collect.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const collect: { <OutElem, OutElem2>(pf: (o: OutElem) => Option.Option<OutElem2>): <InElem, OutErr, InErr, OutDone, InDone, Env>(self: Channel<OutElem, unknown, never, unknown, void, unknown, never>) => Channel<OutElem2, InElem, OutErr, InErr, OutDone, InDone, Env>; <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutElem2>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>, pf: (o: OutElem) => Option.Option<OutElem2>): Channel<OutElem2, InElem, OutErr, InErr, OutDone, InDone, Env>; }\n```\n\n----------------------------------------\n\nTITLE: Wrapping Promises in Micro Effects - TypeScript\nDESCRIPTION: Function signature for wrapping a Promise into a Micro effect. Takes a function that accepts an AbortSignal and returns a Promise. Errors are captured in the MicroCause type's Die variant without type-level tracking.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Micro-promise.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const promise: <A>(evaluate: (signal: AbortSignal) => PromiseLike<A>) => Micro<A>\n```\n\n----------------------------------------\n\nTITLE: Array.take Function Type Signature\nDESCRIPTION: Type declaration for the Array.take function showing its polymorphic implementation. It can be called with arguments in either order: (n)(iterable) or (iterable, n).\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Array-take.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const take: { (n: number): <A>(self: Iterable<A>) => Array<A>; <A>(self: Iterable<A>, n: number): Array<A>; }\n```\n\n----------------------------------------\n\nTITLE: Function Signature for Effect.withTracerEnabled in TypeScript\nDESCRIPTION: This shows the TypeScript type signature for the withTracerEnabled function. It can be used in two ways: as a curried function or with direct application to an effect and a boolean parameter.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-withTracerEnabled.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const withTracerEnabled: { (enabled: boolean): <A, E, R>(effect: Effect<A, E, R>) => Effect<A, E, R>; <A, E, R>(effect: Effect<A, E, R>, enabled: boolean): Effect<A, E, R>; }\n```\n\n----------------------------------------\n\nTITLE: Checking for NeverFlat Type in TypeScript\nDESCRIPTION: A type guard function that returns true if the provided Flatten instance is of NeverFlat type, false otherwise. Used for type narrowing in TypeScript.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Flatten-isNeverFlat.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const isNeverFlat: <A>(a: Flatten<A>) => a is NeverFlat<A>\n```\n\n----------------------------------------\n\nTITLE: Implementing Option Wrapping Function in TypeScript\nDESCRIPTION: Defines a function succeedSome that takes a value of type A and returns an Effect containing an Option.Some of that value. This is useful for working with optional values in the Effect monad.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-succeedSome.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const succeedSome: <A>(value: A) => Effect<Option.Option<A>>\n```\n\n----------------------------------------\n\nTITLE: Either.filterOrLeft Type Signature in TypeScript\nDESCRIPTION: The type signature for the Either.filterOrLeft function. It supports both refinement and predicate functions, and can be used in both pipe-first and pipe-last styles. The function allows filtering of Either right values and converting them to left values when conditions aren't met.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Either-filterOrLeft.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const filterOrLeft: { <R, B extends R, L2>(refinement: Refinement<NoInfer<R>, B>, orLeftWith: (right: NoInfer<R>) => L2): <L>(self: Either<R, L>) => Either<B, L2 | L>; <R, L2>(predicate: Predicate<NoInfer<R>>, orLeftWith: (right: NoInfer<R>) => L2): <L>(self: Either<R, L>) => Either<R, L2 | L>; <R, L, B extends R, L2>(self: Either<R, L>, refinement: Refinement<R, B>, orLeftWith: (right: R) => L2): Either<B, L | L2>; <R, L, E2>(self: Either<R, L>, predicate: Predicate<R>, orLeftWith: (right: R) => E2): Either<R, L | E2>; }\n```\n\n----------------------------------------\n\nTITLE: Logging Messages with Specified Log Level in Effect (TypeScript)\nDESCRIPTION: This snippet demonstrates how to use the Effect.logWithLevel function to log messages or error causes at a specified log level. It shows an example of logging an error message along with a cause.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-logWithLevel.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Cause, Effect, LogLevel } from \"effect\"\n\nconst program = Effect.logWithLevel(\n  LogLevel.Error,\n  \"Critical error encountered\",\n  Cause.die(\"System failure!\")\n)\n\nEffect.runFork(program)\n// Output:\n// timestamp=... level=ERROR fiber=#0 message=Critical error encountered cause=\"Error: System failure!\"\n```\n\n----------------------------------------\n\nTITLE: Setting HashMap Values in TypeScript using Effect-TS\nDESCRIPTION: Function signature for setting a key-value pair in a HashMap using the internal hashing function. Supports both curried and uncurried versions of the operation.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/HashMap-set.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const set: { <K, V>(key: K, value: V): (self: HashMap<K, V>) => HashMap<K, V>; <K, V>(self: HashMap<K, V>, key: K, value: V): HashMap<K, V>; }\n```\n\n----------------------------------------\n\nTITLE: STM Unless Declaration (Typescript)\nDESCRIPTION: Declares the `unless` function, which takes a predicate and an STM transaction. If the predicate evaluates to false, the transaction is executed; otherwise, it's skipped, resulting in `Option.None`. The function provides two call signatures for flexibility.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/STM-unless.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const unless: { (predicate: LazyArg<boolean>): <A, E, R>(self: STM<A, E, R>) => STM<Option.Option<A>, E, R>; <A, E, R>(self: STM<A, E, R>, predicate: LazyArg<boolean>): STM<Option.Option<A>, E, R>; }\n```\n\n----------------------------------------\n\nTITLE: Creating Ordered SQL Resolvers with Schema Validation in TypeScript\nDESCRIPTION: Creates a resolver for SQL queries that validates both input requests and output results using schemas. The resolver ensures that result length matches request length, mapping them in order. It supports both context-aware and regular execution modes.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/SqlResolver-ordered.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const ordered: <T extends string, I, II, RI, A, IA, _, E, RA = never, R = never>(tag: T, options: { readonly Request: Schema.Schema<I, II, RI>; readonly Result: Schema.Schema<A, IA>; readonly execute: (requests: Array<Types.NoInfer<II>>) => Effect.Effect<ReadonlyArray<_>, E>; readonly withContext?: false; } | { readonly Request: Schema.Schema<I, II, RI>; readonly Result: Schema.Schema<A, IA, RA>; readonly execute: (requests: Array<Types.NoInfer<II>>) => Effect.Effect<ReadonlyArray<_>, E, R>; readonly withContext: true; }) => Effect.Effect<SqlResolver<T, I, A, E | ResultLengthMismatch, RI>, never, RA | R>\n```\n\n----------------------------------------\n\nTITLE: Combining Multiple Errors from Concurrent Operations in Effect\nDESCRIPTION: This example demonstrates how to use Effect.parallelErrors to combine errors from concurrently running operations. The code creates three failing effects and runs them concurrently, combining all errors into a single array using parallelErrors.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-parallelErrors.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Effect } from \"effect\"\n\nconst fail1 = Effect.fail(\"Oh uh!\")\nconst fail2 = Effect.fail(\"Oh no!\")\nconst die = Effect.dieMessage(\"Boom!\")\n\n// Run all effects concurrently and capture all errors\nconst program = Effect.all([fail1, fail2, die], {\n  concurrency: \"unbounded\"\n}).pipe(Effect.asVoid, Effect.parallelErrors)\n\nEffect.runPromiseExit(program).then(console.log)\n// Output:\n// {\n//   _id: 'Exit',\n//   _tag: 'Failure',\n//   cause: { _id: 'Cause', _tag: 'Fail', failure: [ 'Oh uh!', 'Oh no!' ] }\n// }\n```\n\n----------------------------------------\n\nTITLE: Defining Iterable.take Function Signature in TypeScript\nDESCRIPTION: Declares the signature for the Iterable.take function, which creates a new Iterable containing a maximum number of elements from the start of an existing Iterable. The function normalizes the input to a non-negative integer.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Iterable-take.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const take: { (n: number): <A>(self: Iterable<A>) => Iterable<A>; <A>(self: Iterable<A>, n: number): Iterable<A>; }\n```\n\n----------------------------------------\n\nTITLE: Declaring Union Function for Combining Schedules in TypeScript\nDESCRIPTION: This code snippet defines the 'union' function that combines two schedules. It allows execution to continue as long as at least one schedule permits it, using the shorter delay when both produce delays. The function is overloaded to handle different input combinations.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Schedule-union.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const union: { <Out2, In2, R2>(that: Schedule<Out2, In2, R2>): <Out, In, R>(self: Schedule<Out, In, R>) => Schedule<[Out, Out2], In & In2, R2 | R>; <Out, In, R, Out2, In2, R2>(self: Schedule<Out, In, R>, that: Schedule<Out2, In2, R2>): Schedule<[Out, Out2], In & In2, R | R2>; }\n```\n\n----------------------------------------\n\nTITLE: Constructing Exit.Failure with die function in TypeScript\nDESCRIPTION: Function signature for creating an Exit.Failure instance from an unrecoverable defect. Takes an unknown type parameter and returns an Exit type that never succeeds.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Exit-die.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const die: (defect: unknown) => Exit<never>\n```\n\n----------------------------------------\n\nTITLE: Creating a Folding Sink with Element Count Limit in TypeScript\nDESCRIPTION: Creates a sink that folds elements of type `In` into a structure of type `S` until a maximum number of elements have been processed. This function is similar to `Sink.foldWeighted` but uses a constant cost function of `1` per element.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Sink-foldUntil.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const foldUntil: <In, S>(s: S, max: number, f: (s: S, input: In) => S) => Sink<S, In, In>\n```\n\n----------------------------------------\n\nTITLE: Defining RequestResolver.eitherWith Function in TypeScript\nDESCRIPTION: Declaration of the eitherWith function which creates a new data source that executes requests by transforming them into requests that either one data source or another can execute. It provides two overloaded function signatures for different parameter orderings.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/RequestResolver-eitherWith.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const eitherWith: { <A extends Request.Request<any, any>, R2, B extends Request.Request<any, any>, C extends Request.Request<any, any>>(that: RequestResolver<B, R2>, f: (_: Request.Entry<C>) => Either.Either<Request.Entry<B>, Request.Entry<A>>): <R>(self: RequestResolver<A, R>) => RequestResolver<C, R2 | R>; <R, A extends Request.Request<any, any>, R2, B extends Request.Request<any, any>, C extends Request.Request<any, any>>(self: RequestResolver<A, R>, that: RequestResolver<B, R2>, f: (_: Request.Entry<C>) => Either.Either<Request.Entry<B>, Request.Entry<A>>): RequestResolver<C, R | R2>; }\n```\n\n----------------------------------------\n\nTITLE: Declaring BooleanFromString Schema Class in TypeScript\nDESCRIPTION: Defines a BooleanFromString class that converts string values 'true' and 'false' to their corresponding boolean values. This schema is part of the Schema module in the effect package.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Schema-BooleanFromString.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare class BooleanFromString\n```\n\n----------------------------------------\n\nTITLE: Creating Interrupt Exit in TypeScript Effect Framework\nDESCRIPTION: Creates a new Exit.Failure instance from a FiberId to indicate that a Fiber running an Effect workflow was terminated due to interruption. Returns an Exit type with a never type parameter.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Exit-interrupt.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const interrupt: (fiberId: FiberId.FiberId) => Exit<never>\n```\n\n----------------------------------------\n\nTITLE: STM.mapInputContext Function Signature (TypeScript)\nDESCRIPTION: This code snippet shows the TypeScript signature of the `mapInputContext` function. It takes a function `f` that transforms a context of type `Context.Context<R0>` to `Context.Context<R>`, and applies it to an `STM` effect, changing its environment type from `R` to `R0`. It also shows an overloaded signature where the `STM` effect is provided as the first argument.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/STM-mapInputContext.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const mapInputContext: { <R0, R>(f: (context: Context.Context<R0>) => Context.Context<R>): <A, E>(self: STM<A, E, R>) => STM<A, E, R0>; <A, E, R0, R>(self: STM<A, E, R>, f: (context: Context.Context<R0>) => Context.Context<R>): STM<A, E, R0>; }\n```\n\n----------------------------------------\n\nTITLE: BigInt Increment Function Signature\nDESCRIPTION: TypeScript type declaration for the increment function that takes a bigint parameter and returns a bigint value.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/BigInt-increment.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const increment: (n: bigint) => bigint\n```\n\n----------------------------------------\n\nTITLE: TypeScript Signature for isMap Function\nDESCRIPTION: This snippet declares the TypeScript signature for the 'isMap' function, which provides type safety by specifying that it takes an unknown input and returns a type guard that checks if the input is a Map. This ensures that users of the function can rely on its return type in TypeScript contexts.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Predicate-isMap.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const isMap: (input: unknown) => input is Map<unknown, unknown>\n```\n\n----------------------------------------\n\nTITLE: BigDecimal.fromString Function Signature in TypeScript\nDESCRIPTION: Type signature for the fromString function that converts a string to a BigDecimal Option. The function takes a string parameter and returns an Option that may contain a BigDecimal value.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/BigDecimal-fromString.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const fromString: (s: string) => Option.Option<BigDecimal>\n```\n\n----------------------------------------\n\nTITLE: Constructing a Differ for ReadonlyArray in TypeScript\nDESCRIPTION: Defines a function that constructs a differ for readonly arrays. The function takes a differ for individual elements and returns a differ that can calculate patches between arrays of those elements.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Differ-readonlyArray.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const readonlyArray: <Value, Patch>(differ: Differ<Value, Patch>) => Differ<ReadonlyArray<Value>, Differ.ReadonlyArray.Patch<Value, Patch>>\n```\n\n----------------------------------------\n\nTITLE: Executing Effectful Fold over Stream in TypeScript\nDESCRIPTION: The snippet provides a TypeScript declaration for executing an effectful fold operation on a stream of values. It returns a scoped stream value, enabling early stopping of the fold process when a given condition is not fulfilled. The function requires effect input parameters and utilizes generics for flexibility across different effect types. The scope of the stream is captured using the 'Scope.Scope'.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-runFoldWhileScopedEffect.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const runFoldWhileScopedEffect: { <S, A, E2, R2>(s: S, cont: Predicate<S>, f: (s: S, a: A) => Effect.Effect<S, E2, R2>): <E, R>(self: Stream<A, E, R>) => Effect.Effect<S, E2 | E, R2 | R | Scope.Scope>; <A, E, R, S, E2, R2>(self: Stream<A, E, R>, s: S, cont: Predicate<S>, f: (s: S, a: A) => Effect.Effect<S, E2, R2>): Effect.Effect<S, E | E2, Scope.Scope | R | R2>; }\n```\n\n----------------------------------------\n\nTITLE: Defining Chunk.replace Function in TypeScript\nDESCRIPTION: Declares the replace function for the Chunk module. This function allows changing an element at a specified index in a Chunk, creating a new Chunk or returning the input if the index is out of bounds. It supports both curried and non-curried calling styles.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Chunk-replace.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const replace: { <B>(i: number, b: B): <A>(self: Chunk<A>) => Chunk<B | A>; <A, B>(self: Chunk<A>, i: number, b: B): Chunk<B | A>; }\n```\n\n----------------------------------------\n\nTITLE: Decoding Base64 URL String to UTF-8 in TypeScript\nDESCRIPTION: This function decodes a base64 URL encoded string into a UTF-8 string. It returns an Either type, containing either the decoded string or a DecodeException if the decoding fails.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Encoding-decodeBase64UrlString.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const decodeBase64UrlString: (str: string) => Either.Either<string, DecodeException>\n```\n\n----------------------------------------\n\nTITLE: Defining WithPageWidth Interface for Reactive Document in TypeScript\nDESCRIPTION: This code snippet defines the WithPageWidth interface, which extends Doc.Variance<A>. It includes a _tag property set to \"WithPageWidth\" and a react method that takes a PageWidth parameter and returns a Doc<A>.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Doc-WithPageWidth.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface WithPageWidth<A> extends Doc.Variance<A> {\n  readonly _tag: \"WithPageWidth\"\n  readonly react: (pageWidth: PageWidth) => Doc<A>\n}\n```\n\n----------------------------------------\n\nTITLE: Using Array.pad to extend an array with fill values in TypeScript\nDESCRIPTION: Demonstrates how to use the Array.pad function to create a new array of specified length by extending an existing array with fill values. If the original array is shorter than the target length, it's padded with the fill value; if longer, it's truncated.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Array-pad.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Array } from \"effect\"\n\nconst result = Array.pad([1, 2, 3], 6, 0)\nconsole.log(result) // [1, 2, 3, 0, 0, 0]\n```\n\n----------------------------------------\n\nTITLE: Stream runHead Declaration (TypeScript)\nDESCRIPTION: Defines the `runHead` function which consumes a stream and returns an Effect that resolves to an Option containing the first value emitted by the stream. The rest of the stream's elements are discarded. The function depends on the `Effect` and `Option` modules from the Effect ecosystem.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-runHead.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const runHead: <A, E, R>(self: Stream<A, E, R>) => Effect.Effect<Option.Option<A>, E, R>\n```\n\n----------------------------------------\n\nTITLE: Converting Effect to Channel in TypeScript\nDESCRIPTION: Function signature for fromEffect that converts an Effect instance into a Channel. Takes an Effect with generic types for output (A), error (E), and environment (R) and returns a Channel that can process this effect.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Channel-fromEffect.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const fromEffect: <A, E, R>(effect: Effect.Effect<A, E, R>) => Channel<never, unknown, E, unknown, A, unknown, R>\n```\n\n----------------------------------------\n\nTITLE: Interrupting Multiple Fibers in Effect-TS\nDESCRIPTION: This function interrupts all fibers provided in the iterable and awaits their interruption to complete. It returns an Effect that resolves to void once all fibers have been interrupted.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Fiber-interruptAll.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const interruptAll: (fibers: Iterable<Fiber<any, any>>) => Effect.Effect<void>\n```\n\n----------------------------------------\n\nTITLE: Implementing Doc.fillSep Combinator in TypeScript\nDESCRIPTION: The fillSep combinator concatenates documents horizontally with spaces between them until page width is exceeded, then uses line breaks. When grouped, documents are separated by spaces instead of newlines. Takes an Iterable of Doc<A> and returns a Doc<A>.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Doc-fillSep.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const fillSep: <A>(docs: Iterable<Doc<A>>) => Doc<A>\n```\n\n----------------------------------------\n\nTITLE: Defining orDieWith Function for Stream Error Handling in TypeScript\nDESCRIPTION: This code snippet defines the orDieWith function, which takes a stream and a function to convert errors to defects. It returns a new stream that terminates on errors, converting them to defects using the provided function.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-orDieWith.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const orDieWith: { <E>(f: (e: E) => unknown): <A, R>(self: Stream<A, E, R>) => Stream<A, never, R>; <A, E, R>(self: Stream<A, E, R>, f: (e: E) => unknown): Stream<A, never, R>; }\n```\n\n----------------------------------------\n\nTITLE: Adding Cookies with unsafeSet in @effect/platform\nDESCRIPTION: The unsafeSet function allows adding a cookie to a Cookies object with optional cookie settings. It supports both curried and uncurried calling styles, making it flexible for various programming patterns.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Cookies-unsafeSet.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const unsafeSet: { (name: string, value: string, options?: Cookie[\"options\"]): (self: Cookies) => Cookies; (self: Cookies, name: string, value: string, options?: Cookie[\"options\"]): Cookies; }\n```\n\n----------------------------------------\n\nTITLE: Declaring Fiber.mapEffect Function Signature in TypeScript\nDESCRIPTION: Defines a function signature for mapEffect that transforms fiber values using an effect-producing function. It supports both curried and uncurried forms, handling error types appropriately in the transformation.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Fiber-mapEffect.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const mapEffect: { <A, A2, E2>(f: (a: A) => Effect.Effect<A2, E2>): <E>(self: Fiber<A, E>) => Fiber<A2, E2 | E>; <A, E, A2, E2>(self: Fiber<A, E>, f: (a: A) => Effect.Effect<A2, E2>): Fiber<A2, E | E2>; }\n```\n\n----------------------------------------\n\nTITLE: Traversing Entries with RedBlackTree TypeScript\nDESCRIPTION: The 'lessThanEqual' function in TypeScript is designed to return an iterator for traversing entries in a RedBlackTree where keys are less than or equal to a specified key. It requires a type parameter 'K' for the key and optionally 'V' for the value. The primary input is the RedBlackTree instance and the key for comparison, and it outputs an Iterable of key-value pairs meeting the condition.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/RedBlackTree-lessThanEqual.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const lessThanEqual: { <K>(key: K): <V>(self: RedBlackTree<K, V>) => Iterable<[K, V]>; <K, V>(self: RedBlackTree<K, V>, key: K): Iterable<[K, V]>; }\n```\n\n----------------------------------------\n\nTITLE: Implementing Iterable Contains With Custom Equivalence in TypeScript\nDESCRIPTION: Defines a higher-order function that creates a predicate to check if an Iterable contains a specific value using a custom equivalence function. The function can be used in both curried and uncurried forms.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Iterable-containsWith.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const containsWith: <A>(isEquivalent: (self: A, that: A) => boolean) => { (a: A): (self: Iterable<A>) => boolean; (self: Iterable<A>, a: A): boolean; }\n```\n\n----------------------------------------\n\nTITLE: Effect.forkIn Type Signature\nDESCRIPTION: Type declaration for the Effect.forkIn function showing its polymorphic nature and return types. The function accepts a scope and an effect, returning a new effect that produces a runtime fiber.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-forkIn.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const forkIn: { (scope: Scope.Scope): <A, E, R>(self: Effect<A, E, R>) => Effect<Fiber.RuntimeFiber<A, E>, never, R>; <A, E, R>(self: Effect<A, E, R>, scope: Scope.Scope): Effect<Fiber.RuntimeFiber<A, E>, never, R>; }\n```\n\n----------------------------------------\n\nTITLE: Checking for Value Containment in TArray with Effect TS\nDESCRIPTION: This snippet declares a method 'contains' which determines if a TArray contains a specified value, using static typing. It requires the STM library from the Effect TS suite. It has two overloads that allow either currying with a single value or direct application with both TArray and value as arguments. The method returns an STM monad resolving to a boolean indicating presence or absence of the value within the array.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TArray-contains.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const contains: { <A>(value: A): (self: TArray<A>) => STM.STM<boolean>; <A>(self: TArray<A>, value: A): STM.STM<boolean>; }\n```\n\n----------------------------------------\n\nTITLE: Function Signature for Stream.groupedWithin in TypeScript\nDESCRIPTION: Provides the TypeScript function signature for Stream.groupedWithin. It shows two overloads: one for curried usage and another for direct application to a stream.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-groupedWithin.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const groupedWithin: { (chunkSize: number, duration: Duration.DurationInput): <A, E, R>(self: Stream<A, E, R>) => Stream<Chunk.Chunk<A>, E, R>; <A, E, R>(self: Stream<A, E, R>, chunkSize: number, duration: Duration.DurationInput): Stream<Chunk.Chunk<A>, E, R>; }\n```\n\n----------------------------------------\n\nTITLE: Effect.clockWith Function Signature in TypeScript\nDESCRIPTION: This code snippet shows the TypeScript signature of the Effect.clockWith function. It takes a function that receives a Clock object and returns an Effect, and returns an Effect with the same type parameters.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-clockWith.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const clockWith: <A, E, R>(f: (clock: Clock.Clock) => Effect<A, E, R>) => Effect<A, E, R>\n```\n\n----------------------------------------\n\nTITLE: Implementing Error Handling with Micro.catchAll in TypeScript\nDESCRIPTION: Function signature for catchAll, which allows catching and handling errors in Micro effects. It provides two overloads: one for curried usage and another for direct usage. The function enables recovery from expected errors by transforming them into new Micro effects.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Micro-catchAll.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const catchAll: { <E, B, E2, R2>(f: (e: NoInfer<E>) => Micro<B, E2, R2>): <A, R>(self: Micro<A, E, R>) => Micro<A | B, E2, R | R2>; <A, E, R, B, E2, R2>(self: Micro<A, E, R>, f: (e: NoInfer<E>) => Micro<B, E2, R2>): Micro<A | B, E2, R | R2>; }\n```\n\n----------------------------------------\n\nTITLE: Prepending Elements to Chunk Data Structure - TypeScript\nDESCRIPTION: Function signature for prepending an element to a Chunk, creating a new NonEmptyChunk. Supports both curried and uncurried calling styles. The function is generic over types A and B, allowing for type-safe prepending of elements.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Chunk-prepend.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const prepend: { <B>(elem: B): <A>(self: Chunk<A>) => NonEmptyChunk<B | A>; <A, B>(self: Chunk<A>, elem: B): NonEmptyChunk<A | B>; }\n```\n\n----------------------------------------\n\nTITLE: Declaring Channel.concatMap Function in TypeScript\nDESCRIPTION: Type declaration for the concatMap function that transforms a Channel by mapping its outputs through a factory function and concatenating the resulting channels. The function supports generic type parameters for elements, errors, environment, and done signals for both input and output channels.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Channel-concatMap.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const concatMap: { <OutElem, OutElem2, InElem2, OutErr2, InErr2, X, InDone2, Env2>(f: (o: OutElem) => Channel<OutElem2, InElem2, OutErr2, InErr2, X, InDone2, Env2>): <Env, InErr, InElem, InDone, OutErr, OutDone>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>) => Channel<OutElem2, InElem & InElem2, OutErr2 | OutErr, InErr & InErr2, unknown, InDone & InDone2, Env2 | Env>; <Env, InErr, InElem, InDone, OutErr, OutDone, OutElem, OutElem2, Env2, InErr2, InElem2, InDone2, OutErr2, X>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>, f: (o: OutElem) => Channel<OutElem2, InElem2, OutErr2, InErr2, X, InDone2, Env2>): Channel<OutElem2, InElem & InElem2, OutErr | OutErr2, InErr & InErr2, unknown, InDone & InDone2, Env | Env2>; }\n```\n\n----------------------------------------\n\nTITLE: Converting Numbers to BigInt with Safety Checks in TypeScript\nDESCRIPTION: The `fromNumber` function takes a number and returns an Option of bigint. It returns Option.none() if the number is outside JavaScript's safe integer range, otherwise it converts the number to a bigint and returns Option.some(bigint).\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/BigInt-fromNumber.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { BigInt as BI, Option } from \"effect\"\n\nassert.deepStrictEqual(BI.fromNumber(42), Option.some(BigInt(42)))\nassert.deepStrictEqual(BI.fromNumber(Number.MAX_SAFE_INTEGER + 1), Option.none())\nassert.deepStrictEqual(BI.fromNumber(Number.MIN_SAFE_INTEGER - 1), Option.none())\n```\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const fromNumber: (n: number) => Option.Option<bigint>\n```\n\n----------------------------------------\n\nTITLE: Function Signature for DateTime.setZoneOffset in TypeScript\nDESCRIPTION: The type signature for the setZoneOffset function, showing its polymorphic interface. It can be called with either (offset, options)(datetime) or (datetime, offset, options) parameter orders.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/DateTime-setZoneOffset.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const setZoneOffset: { (offset: number, options?: { readonly adjustForTimeZone?: boolean | undefined; }): (self: DateTime) => Zoned; (self: DateTime, offset: number, options?: { readonly adjustForTimeZone?: boolean | undefined; }): Zoned; }\n```\n\n----------------------------------------\n\nTITLE: Defining GroupBy.evaluate Function in TypeScript\nDESCRIPTION: This snippet defines the evaluate function for the GroupBy module. It takes a function to be applied to each group and an optional buffer size. The function processes all groups and returns a Stream of results.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/GroupBy-evaluate.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const evaluate: { <K, V, E, A, E2, R2>(f: (key: K, stream: Stream.Stream<V, E, never>) => Stream.Stream<A, E2, R2>, options?: { readonly bufferSize?: number | undefined; } | undefined): <R>(self: GroupBy<K, V, E, R>) => Stream.Stream<A, E | E2, R2 | R>; <K, V, E, R, A, E2, R2>(self: GroupBy<K, V, E, R>, f: (key: K, stream: Stream.Stream<V, E, never>) => Stream.Stream<A, E2, R2>, options?: { readonly bufferSize?: number | undefined; } | undefined): Stream.Stream<A, E | E2, R | R2>; }\n```\n\n----------------------------------------\n\nTITLE: Creating Equivalence for Records - Effect-TS TypeScript\nDESCRIPTION: The function `getEquivalence` is defined to facilitate the creation of an `Equivalence` for records by utilizing a given `Equivalence` for its values. It is a generic TypeScript function extending the `Equivalence` type for any record with keys of type string and values of type A. This utility is used to maintain consistency in value comparisons within records and requires the TypeScript language features. Its signature defines it for read-only records, returning an Equivalence object that works on these records.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Record-getEquivalence.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const getEquivalence: <K extends string, A>(equivalence: Equivalence<A>) => Equivalence<ReadonlyRecord<K, A>>\n```\n\n----------------------------------------\n\nTITLE: Defining RPC Handler Interface in TypeScript\nDESCRIPTION: This TypeScript interface defines the structure for an RPC handler, used within the Effect library. It includes a unique symbol, a tag for identifying the handler, and the handler function itself which processes requests along with headers. The function returns either an Effect or a Stream. This interface requires the 'Effect' and 'Stream' types, possibly from the Effect library, and is intended for use in applications utilizing remote procedure calls.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Rpc-Handler.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport interface Handler<Tag extends string> {\n  readonly _: unique symbol\n  readonly tag: Tag\n  readonly handler: (request: any, headers: Headers) => Effect<any, any> | Stream<any, any>\n  readonly context: Context<never>\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Redacted Text Argument in Effect CLI Args Module (TypeScript)\nDESCRIPTION: The redacted function creates a text argument, optionally allowing a custom argument name (defaulting to \"redacted\"). It returns an Args<Redacted> type. This function is useful for handling sensitive input that should not be displayed or logged.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Args-redacted.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const redacted: (config?: Args.BaseArgsConfig) => Args<Redacted>\n```\n\n----------------------------------------\n\nTITLE: Initializing Record Replacement with Effect Option\nDESCRIPTION: Demonstrates how to use Record.replaceOption to replace a value in a record, with handling for successful and unsuccessful replacements\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Record-replaceOption.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { Record, Option } from \"effect\"\n\nassert.deepStrictEqual(\n  Record.replaceOption({ a: 1, b: 2, c: 3 }, 'a', 10),\n  Option.some({ a: 10, b: 2, c: 3 })\n)\nassert.deepStrictEqual(Record.replaceOption(Record.empty<string>(), 'a', 10), Option.none())\n```\n\n----------------------------------------\n\nTITLE: Effect.catchIf Function Signature\nDESCRIPTION: The TypeScript type signature for the `catchIf` function, showing its various overloads. It supports both refinement functions that narrow error types and predicate functions for testing error conditions.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-catchIf.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const catchIf: { <E, EB extends E, A2, E2, R2>(refinement: Refinement<NoInfer<E>, EB>, f: (e: EB) => Effect<A2, E2, R2>): <A, R>(self: Effect<A, E, R>) => Effect<A2 | A, E2 | Exclude<E, EB>, R2 | R>; <E, A2, E2, R2>(predicate: Predicate<NoInfer<E>>, f: (e: NoInfer<E>) => Effect<A2, E2, R2>): <A, R>(self: Effect<A, E, R>) => Effect<A2 | A, E | E2, R2 | R>; <A, E, R, EB extends E, A2, E2, R2>(self: Effect<A, E, R>, refinement: Refinement<E, EB>, f: (e: EB) => Effect<A2, E2, R2>): Effect<A | A2, E2 | Exclude<E, EB>, R | R2>; <A, E, R, A2, E2, R2>(self: Effect<A, E, R>, predicate: Predicate<E>, f: (e: E) => Effect<A2, E2, R2>): Effect<A | A2, E | E2, R | R2>; }\n```\n\n----------------------------------------\n\nTITLE: Creating Timer Metric with Boundaries in TypeScript\nDESCRIPTION: This function creates a timer metric based on a histogram with specified boundaries. It tracks durations in milliseconds and automatically adds a time unit tag. The function takes a name, an array of boundaries, and an optional description.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Metric-timerWithBoundaries.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const timerWithBoundaries: (name: string, boundaries: ReadonlyArray<number>, description?: string) => Metric<MetricKeyType.MetricKeyType.Histogram, Duration.Duration, MetricState.MetricState.Histogram>\n```\n\n----------------------------------------\n\nTITLE: Using Array.window Function in TypeScript\nDESCRIPTION: Demonstrates how to use the Array.window function to create sliding windows of size n from an array. The example shows creating windows of size 3 from a number array, and handling an invalid window size that's larger than the array.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Array-window.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { Array } from \"effect\"\n\nconst numbers = [1, 2, 3, 4, 5]\nassert.deepStrictEqual(Array.window(numbers, 3), [[1, 2, 3], [2, 3, 4], [3, 4, 5]])\nassert.deepStrictEqual(Array.window(numbers, 6), [])\n```\n\n----------------------------------------\n\nTITLE: Declaring the Signature of mapKeys Function in TypeScript\nDESCRIPTION: This snippet provides the TypeScript declaration for the `mapKeys` function, which defines its type signature. The function can be invoked in a curried form or with both parameters passed at once. The types represent a transformations from keys of type K to K2 while preserving the value type A in the records. It is a generic function that works for ReadonlyRecord input types.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Record-mapKeys.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const mapKeys: { <K extends string, A, K2 extends string>(f: (key: K, a: A) => K2): (self: ReadonlyRecord<K, A>) => Record<K2, A>; <K extends string, A, K2 extends string>(self: ReadonlyRecord<K, A>, f: (key: K, a: A) => K2): Record<K2, A>; }\n```\n\n----------------------------------------\n\nTITLE: Using transformLiterals in Effect Schema\nDESCRIPTION: This snippet demonstrates the use of the transformLiterals method from the effect Schema module to map numerical values to string representations. It imports necessary modules and defines a schema that transforms numeric codes for animals into their respective string literals using assert.deepStrictEqual to verify the transformation. The method accepts pairs of literal values to transform between, ensuring type safety in encoding and decoding operations.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Schema-transformLiterals.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \\\"node:assert\\\"\\nimport * as S from \\\"effect/Schema\\\"\\n\\nconst Animal = S.transformLiterals(\\n  [0, \\\"cat\\\"],\\n  [1, \\\"dog\\\"],\\n  [2, \\\"cow\\\"]\\n)\\n\\nassert.deepStrictEqual(S.decodeSync(Animal)(1), \\\"dog\\\")\n```\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const transformLiterals: { <const A extends AST.Members<readonly [from: AST.LiteralValue, to: AST.LiteralValue]>>(...pairs: A): Union<{ -readonly [I in keyof A]: transformLiteral<A[I][1], A[I][0]>; }>; <Encoded extends AST.LiteralValue, Type extends AST.LiteralValue>(pairs: [Encoded, Type]): transformLiteral<Type, Encoded>; <const A extends ReadonlyArray<readonly [from: AST.LiteralValue, to: AST.LiteralValue]>>(...pairs: A): Schema<A[number][1], A[number][0]>; }\n```\n\n----------------------------------------\n\nTITLE: Zipping Streams with Default Values in TypeScript\nDESCRIPTION: This snippet demonstrates how to use the `zipAll` method to combine two streams into a single stream of pairs. It takes two streams and handles varying lengths by applying default values to the missing elements. The example shows how to execute the stream and log the collected results.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-zipAll.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Effect, Stream } from \"effect\"\n\nconst stream = Stream.zipAll(Stream.make(1, 2, 3, 4, 5, 6), {\n  other: Stream.make(\"a\", \"b\", \"c\"),\n  defaultSelf: 0,\n  defaultOther: \"x\"\n})\n\nEffect.runPromise(Stream.runCollect(stream)).then(console.log)\n// { _id: \"Chunk\", values: [ [ 1, \"a\" ], [ 2, \"b\" ], [ 3, \"c\" ], [ 4, \"x\" ], [ 5, \"x\" ], [ 6, \"x\" ] ] }\n```\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const zipAll: { <A2, E2, R2, A>(options: { readonly other: Stream<A2, E2, R2>; readonly defaultSelf: A; readonly defaultOther: A2; }): <E, R>(self: Stream<A, E, R>) => Stream<[A, A2], E2 | E, R2 | R>; <A, E, R, A2, E2, R2>(self: Stream<A, E, R>, options: { readonly other: Stream<A2, E2, R2>; readonly defaultSelf: A; readonly defaultOther: A2; }): Stream<[A, A2], E | E2, R | R2>; }\n```\n\n----------------------------------------\n\nTITLE: Defining Recurring Schedule Function in TypeScript\nDESCRIPTION: The sync function returns a schedule that recurs indefinitely, evaluating a given function to produce a constant value. It takes a lazy argument of type A and returns a Schedule of type A.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Schedule-sync.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const sync: <A>(evaluate: LazyArg<A>) => Schedule<A>\n```\n\n----------------------------------------\n\nTITLE: Reducing HashMap Entries with HashMap.reduce Function in TypeScript\nDESCRIPTION: The HashMap.reduce function reduces a specified state over the entries of a HashMap. It accepts an initial accumulator value and a reducer function that processes each key-value pair, returning a single accumulated result. The function supports both curried and direct invocation patterns.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/HashMap-reduce.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const reduce: { <Z, V, K>(zero: Z, f: (accumulator: Z, value: V, key: K) => Z): (self: HashMap<K, V>) => Z; <K, V, Z>(self: HashMap<K, V>, zero: Z, f: (accumulator: Z, value: V, key: K) => Z): Z; }\n```\n\n----------------------------------------\n\nTITLE: Declaring RedBlackTree.findFirst Type Signature in TypeScript\nDESCRIPTION: Defines the type signature for the findFirst function that takes a key and returns an Option containing the first associated value in the Red-Black Tree. Supports both curried and uncurried function calls.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/RedBlackTree-findFirst.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const findFirst: { <K>(key: K): <V>(self: RedBlackTree<K, V>) => Option<V>; <K, V>(self: RedBlackTree<K, V>, key: K): Option<V>; }\n```\n\n----------------------------------------\n\nTITLE: Declaring Exponential Schedules Function in TypeScript\nDESCRIPTION: This TypeScript function 'exponential' declares a schedule that recurs indefinitely with exponentially increasing delays. The function accepts a base duration and an optional factor that determines the exponential growth of delay. The key parameter 'base' sets the initial delay, and 'factor', if provided, alters the exponential growth, defaulting to a doubling effect when not specified.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Schedule-exponential.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const exponential: (base: Duration.DurationInput, factor?: number) => Schedule<Duration.Duration>\n```\n\n----------------------------------------\n\nTITLE: Converting BigInt to Number in TypeScript\nDESCRIPTION: This function takes a bigint and returns an Option of number. It safely converts the bigint to a number if it's within JavaScript's safe integer range, otherwise returns Option.none().\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/BigInt-toNumber.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { BigInt as BI, Option } from \"effect\"\n\nassert.deepStrictEqual(BI.toNumber(BigInt(42)), Option.some(42))\nassert.deepStrictEqual(BI.toNumber(BigInt(Number.MAX_SAFE_INTEGER) + BigInt(1)), Option.none())\nassert.deepStrictEqual(BI.toNumber(BigInt(Number.MIN_SAFE_INTEGER) - BigInt(1)), Option.none())\n```\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const toNumber: (b: bigint) => Option.Option<number>\n```\n\n----------------------------------------\n\nTITLE: Using Match.either for User Role Extraction in TypeScript\nDESCRIPTION: This example demonstrates how to use Match.either to extract user roles and handle both matched and unmatched cases. It creates a matcher that wraps the result in an Either, allowing clear differentiation between successful matches and unmatched cases.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Match-either.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Match } from \"effect\"\n\ntype User = { readonly role: \"admin\" | \"editor\" | \"viewer\" }\n\n// Create a matcher to extract user roles\nconst getRole = Match.type<User>().pipe(\n  Match.when({ role: \"admin\" }, () => \"Has full access\"),\n  Match.when({ role: \"editor\" }, () => \"Can edit content\"),\n  Match.either // Wrap the result in an Either\n)\n\nconsole.log(getRole({ role: \"admin\" }))\n// Output: { _id: 'Either', _tag: 'Right', right: 'Has full access' }\n\nconsole.log(getRole({ role: \"viewer\" }))\n// Output: { _id: 'Either', _tag: 'Left', left: { role: 'viewer' } }\n```\n\n----------------------------------------\n\nTITLE: TypeScript Type Signature for Effect.reduceEffect\nDESCRIPTION: The complete type signature for the reduceEffect function, showing its polymorphic nature with support for different parameter orders and execution options like concurrency, batching, and concurrent finalizers.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-reduceEffect.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const reduceEffect: { <Z, E, R, Eff extends Effect<any, any, any>>(zero: Effect<Z, E, R>, f: (z: NoInfer<Z>, a: Effect.Success<Eff>, i: number) => Z, options?: { readonly concurrency?: Concurrency | undefined; readonly batching?: boolean | \"inherit\" | undefined; readonly concurrentFinalizers?: boolean | undefined; } | undefined): (elements: Iterable<Eff>) => Effect<Z, E | Effect.Error<Eff>, R | Effect.Context<Eff>>; <Eff extends Effect<any, any, any>, Z, E, R>(elements: Iterable<Eff>, zero: Effect<Z, E, R>, f: (z: NoInfer<Z>, a: Effect.Success<Eff>, i: number) => Z, options?: { readonly concurrency?: Concurrency | undefined; readonly batching?: boolean | \"inherit\" | undefined; readonly concurrentFinalizers?: boolean | undefined; } | undefined): Effect<Z, E | Effect.Error<Eff>, R | Effect.Context<Eff>>; }\n```\n\n----------------------------------------\n\nTITLE: Type Checking Branded Types Base Compatibility in TypeScript\nDESCRIPTION: A utility type that validates all branded types share the same base type. It uses conditional types to compare the unbranded versions of each type, ensuring type safety across branded type operations.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Brand-Brand.EnsureCommonBase.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ntype EnsureCommonBase<Brands> = {\n    [B in keyof Brands]: Brand.Unbranded<Brand.FromConstructor<Brands[0]>> extends\n      Brand.Unbranded<Brand.FromConstructor<Brands[B]>>\n      ? Brand.Unbranded<Brand.FromConstructor<Brands[B]>> extends Brand.Unbranded<Brand.FromConstructor<Brands[0]>>\n        ? Brands[B]\n      : Brands[B]\n      : \"ERROR: All brands should have the same base type\"\n  }\n```\n\n----------------------------------------\n\nTITLE: Checking Failure State of Take in TypeScript\nDESCRIPTION: This snippet defines the TypeScript declaration for the `isFailure` function, which checks if the given `take` is in a failure state. It is part of the `effect` package and requires the `TypeScript` language for implementation. The function signature requires a `Take<A, E>` type argument and returns a boolean indicating whether the `take` is a failure.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Take-isFailure.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const isFailure: <A, E>(self: Take<A, E>) => boolean\n```\n\n----------------------------------------\n\nTITLE: Setting DateTime Time Zone Using IANA Identifier in Effect\nDESCRIPTION: Demonstrates how to use the setZoneNamed function to set a DateTime's time zone using an IANA identifier. The function returns an Option type that will be None if the time zone is invalid.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/DateTime-setZoneNamed.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { DateTime, Effect } from \"effect\"\n\nEffect.gen(function* () {\n  const now = yield* DateTime.now\n  // set the time zone, returns an Option\n  DateTime.setZoneNamed(now, \"Europe/London\")\n})\n```\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const setZoneNamed: { (zoneId: string, options?: { readonly adjustForTimeZone?: boolean | undefined; }): (self: DateTime) => Option.Option<Zoned>; (self: DateTime, zoneId: string, options?: { readonly adjustForTimeZone?: boolean | undefined; }): Option.Option<Zoned>; }\n```\n\n----------------------------------------\n\nTITLE: Interrupting a Fiber with FiberId - TypeScript\nDESCRIPTION: The `interruptAs` function takes a `FiberId` as its parameter and interrupts the fiber executing the effect. It is part of the STM module within the effect package. It requires a valid `FiberId` and returns an STM effect that does not produce any value (never). This implementation is available since version 2.0.0.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/STM-interruptAs.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const interruptAs: (fiberId: FiberId.FiberId) => STM<never>\n```\n\n----------------------------------------\n\nTITLE: Defining Deferred.done Function Signature in TypeScript\nDESCRIPTION: TypeScript function signature for Deferred.done which takes an Exit value and returns an Effect containing a boolean result. The function supports both curried and uncurried forms for completing a Deferred value with an Exit result. Returns true if the Deferred was completed, false if it was already completed.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Deferred-done.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const done: { <A, E>(exit: Exit.Exit<A, E>): (self: Deferred<A, E>) => Effect.Effect<boolean>; <A, E>(self: Deferred<A, E>, exit: Exit.Exit<A, E>): Effect.Effect<boolean>; }\n```\n\n----------------------------------------\n\nTITLE: Creating MutableHashMap from Iterable in TypeScript\nDESCRIPTION: Creates a new MutableHashMap instance from an iterable collection of key/value pairs. This function takes any iterable that produces key-value tuples and converts it into a MutableHashMap data structure.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/MutableHashMap-fromIterable.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const fromIterable: <K, V>(entries: Iterable<readonly [K, V]>) => MutableHashMap<K, V>\n```\n\n----------------------------------------\n\nTITLE: Folding over ExecutionStrategy using match function in TypeScript\nDESCRIPTION: The match function allows folding over an ExecutionStrategy value using provided case functions for Sequential, Parallel, and ParallelN strategies. It provides both curried and uncurried variations of the function.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/ExecutionStrategy-match.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const match: { <A>(options: { readonly onSequential: LazyArg<A>; readonly onParallel: LazyArg<A>; readonly onParallelN: (n: number) => A; }): (self: ExecutionStrategy) => A; <A>(self: ExecutionStrategy, options: { readonly onSequential: LazyArg<A>; readonly onParallel: LazyArg<A>; readonly onParallelN: (n: number) => A; }): A; }\n```\n\n----------------------------------------\n\nTITLE: Defining StringFromHex Schema in TypeScript\nDESCRIPTION: Declares a constant StringFromHex of type Schema that decodes a hex-encoded string into a UTF-8 string. It takes a string input, produces a string output, and never throws an error.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Schema-StringFromHex.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const StringFromHex: Schema<string, string, never>\n```\n\n----------------------------------------\n\nTITLE: Effect.clock Type Signature in TypeScript\nDESCRIPTION: Shows the TypeScript type signature for the Effect.clock function. It returns an Effect that provides a Clock.Clock service with no errors or required context.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-clock.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const clock: Effect<Clock.Clock, never, never>\n```\n\n----------------------------------------\n\nTITLE: Setting Minimum Log Level in Effect Logger\nDESCRIPTION: Demonstrates how to set a minimum log level for logging operations using Logger.withMinimumLogLevel. This controls which messages are displayed based on their severity level, with the example showing debug level message logging.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Logger-withMinimumLogLevel.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Effect, Logger, LogLevel } from \"effect\"\n\nconst program = Effect.logDebug(\"message1\").pipe(Logger.withMinimumLogLevel(LogLevel.Debug))\n\nEffect.runFork(program)\n// timestamp=... level=DEBUG fiber=#0 message=message1\n```\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const withMinimumLogLevel: { (level: LogLevel.LogLevel): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R>; <A, E, R>(self: Effect<A, E, R>, level: LogLevel.LogLevel): Effect<A, E, R>; }\n```\n\n----------------------------------------\n\nTITLE: Partitioning Options with TypeScript\nDESCRIPTION: The partitionMap function splits an Option into two Options, utilizing a mapping function that produces an Either. The first Option contains the value from the Left side of the Either, whereas the second contains the Right side. Both Options are None if the input Option is None. The function is part of the Effect library and is useful for filtering and categorizing Options.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Option-partitionMap.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const partitionMap: { <A, B, C>(f: (a: A) => Either<C, B>): (self: Option<A>) => [left: Option<B>, right: Option<C>]; <A, B, C>(self: Option<A>, f: (a: A) => Either<C, B>): [left: Option<B>, right: Option<C>]; }\n```\n\n----------------------------------------\n\nTITLE: Option.exists Example in TypeScript\nDESCRIPTION: This example demonstrates how to use `Option.exists` with both `Some` and `None` options, using a predicate to check if a number is even. It showcases the function's behavior when the condition is met, not met, and when the option is `None`.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Option-exists.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Option } from \"effect\"\n\nconst isEven = (n: number) => n % 2 === 0\n\nconsole.log(Option.some(2).pipe(Option.exists(isEven)))\n// Output: true\n\nconsole.log(Option.some(1).pipe(Option.exists(isEven)))\n// Output: false\n\nconsole.log(Option.none().pipe(Option.exists(isEven)))\n// Output: false\n```\n\n----------------------------------------\n\nTITLE: Defining Redacted Config Function in TypeScript\nDESCRIPTION: Declares a function 'redacted' that constructs a config for redacted values. It can be called with an optional name parameter or with an existing Config<A> to create a Config<Redacted.Redacted<A>>.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Config-redacted.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const redacted: { (name?: string): Config<Redacted.Redacted>; <A>(config: Config<A>): Config<Redacted.Redacted<A>>; }\n```\n\n----------------------------------------\n\nTITLE: Defining mapConcatChunk Function for Stream Transformation in TypeScript\nDESCRIPTION: Declares a function mapConcatChunk that maps each element of a stream to a chunk and flattens the chunks into the output stream. It supports both curried and uncurried usage patterns.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-mapConcatChunk.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const mapConcatChunk: { <A, A2>(f: (a: A) => Chunk.Chunk<A2>): <E, R>(self: Stream<A, E, R>) => Stream<A2, E, R>; <A, E, R, A2>(self: Stream<A, E, R>, f: (a: A) => Chunk.Chunk<A2>): Stream<A2, E, R>; }\n```\n\n----------------------------------------\n\nTITLE: Reversing Elements in a Chunk with Effect.ts\nDESCRIPTION: Example of using Chunk.reverse() to reverse the order of elements in a Chunk. The function preserves the NonEmptyChunk type when reversing a non-empty chunk.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Chunk-reverse.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Chunk } from \"effect\"\n\nconst chunk = Chunk.make(1, 2, 3)\nconst result = Chunk.reverse(chunk)\n\nconsole.log(result)\n// { _id: 'Chunk', values: [ 3, 2, 1 ] }\n```\n\n----------------------------------------\n\nTITLE: Defining List Type in TypeScript\nDESCRIPTION: Defines the List type as a union of Cons and Nil types, representing a linked list structure. This implementation is immutable and optimized for LIFO operations.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/List-List.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ntype List<A> = Cons<A> | Nil<A>\n```\n\n----------------------------------------\n\nTITLE: Extracting Values from TMap in TypeScript\nDESCRIPTION: Defines a function to collect all values from a TMap using STM, requiring the STM module from Effect-TS. The function returns an STM effect that, when executed, yields an array of values stored in the map. Inputs are the TMap object, and the output is an STM encapsulating the values array.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TMap-values.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const values: <K, V>(self: TMap<K, V>) => STM.STM<Array<V>>\n```\n\n----------------------------------------\n\nTITLE: Retrieving Optional Service from Context in TypeScript\nDESCRIPTION: This function retrieves a service from the context and wraps it in an Option. It returns a Some containing the service if available, or a None if the service is not found. This is useful for handling the absence of a service gracefully without causing an error.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-serviceOption.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const serviceOption: <I, S>(tag: Context.Tag<I, S>) => Effect<Option.Option<S>>\n```\n\n----------------------------------------\n\nTITLE: Defining RateLimiter Interface in TypeScript\nDESCRIPTION: This code snippet defines the RateLimiter interface, which takes an Effect task and returns a rate-limited version of that task. The rate limiting is applied only to the start of the effect, not to concurrent executions.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/RateLimiter-RateLimiter.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface RateLimiter {\n  <A, E, R>(task: Effect<A, E, R>): Effect<A, E, R>\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Cause.defects Function in TypeScript\nDESCRIPTION: This snippet defines the signature of the Cause.defects function. It takes a Cause<E> as input and returns a Chunk.Chunk<unknown> containing all unrecoverable defects (Die errors). This function is useful for capturing unexpected errors that may require special handling or logging.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Cause-defects.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const defects: <E>(self: Cause<E>) => Chunk.Chunk<unknown>\n```\n\n----------------------------------------\n\nTITLE: Using Trie.toEntriesWithPrefix in TypeScript\nDESCRIPTION: Demonstrates how to use the Trie.toEntriesWithPrefix function to retrieve entries with a specific prefix from a Trie data structure. The example creates a Trie with string keys and number values, then retrieves entries starting with 'she'.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Trie-toEntriesWithPrefix.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { Trie } from \"effect\"\n\nconst trie = Trie.empty<number>().pipe(\n  Trie.insert(\"shells\", 0),\n  Trie.insert(\"sells\", 1),\n  Trie.insert(\"sea\", 2),\n  Trie.insert(\"she\", 3)\n)\n\nconst result = Trie.toEntriesWithPrefix(trie, \"she\")\nassert.deepStrictEqual(result, [[\"she\", 3], [\"shells\", 0]])\n```\n\n----------------------------------------\n\nTITLE: Defining Layer.failSync Function in TypeScript\nDESCRIPTION: This code snippet defines the Layer.failSync function, which constructs a layer that fails with a specified error. It takes a lazy argument of type E and returns a Layer that can fail with an error of type E.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Layer-failSync.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const failSync: <E>(evaluate: LazyArg<E>) => Layer<unknown, E>\n```\n\n----------------------------------------\n\nTITLE: Defining untilOutput Function in TypeScript for Schedule Module\nDESCRIPTION: Declares the untilOutput function which returns a new schedule that stops execution when a given predicate on the output evaluates to true. It can be used with both curried and uncurried forms.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Schedule-untilOutput.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const untilOutput: { <Out>(f: Predicate<Out>): <In, R>(self: Schedule<Out, In, R>) => Schedule<Out, In, R>; <Out, In, R>(self: Schedule<Out, In, R>, f: Predicate<Out>): Schedule<Out, In, R>; }\n```\n\n----------------------------------------\n\nTITLE: Getting the Size of a TPubSub using STM in TypeScript\nDESCRIPTION: Retrieves the size of the TPubSub, which is equal to the number of elements in the TPubSub. This may be negative if fibers are suspended waiting for elements to be added to the TPubSub.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TPubSub-size.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const size: <A>(self: TPubSub<A>) => STM.STM<number>\n```\n\n----------------------------------------\n\nTITLE: Defining Command Interface in TypeScript\nDESCRIPTION: Defines the Command interface which represents a command in a command-line application. The interface extends Command.Variance<A> and Pipeable, allowing for command-line applications with one or multiple commands.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/CommandDescriptor-Command.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface Command<A> extends Command.Variance<A>, Pipeable {}\n```\n\n----------------------------------------\n\nTITLE: Declaring interruptWhenDeferred Function in TypeScript\nDESCRIPTION: Defines the interruptWhenDeferred function for Stream, which interrupts stream evaluation when a provided Deferred resolves. It handles both success and failure cases of the Deferred.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-interruptWhenDeferred.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const interruptWhenDeferred: { <X, E2>(deferred: Deferred.Deferred<X, E2>): <A, E, R>(self: Stream<A, E, R>) => Stream<A, E2 | E, R>; <A, E, R, X, E2>(self: Stream<A, E, R>, deferred: Deferred.Deferred<X, E2>): Stream<A, E | E2, R>; }\n```\n\n----------------------------------------\n\nTITLE: Using TMap.removeIf to Remove Entries Based on Predicate in Effect\nDESCRIPTION: This function removes entries from a TMap that satisfy a specified predicate. It provides options to either discard removed entries or return them as an array of key-value pairs. The function can be used with both curried and non-curried syntax patterns.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TMap-removeIf.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const removeIf: { <K, V>(predicate: (key: K, value: V) => boolean, options: { readonly discard: true; }): (self: TMap<K, V>) => STM.STM<void>; <K, V>(predicate: (key: K, value: V) => boolean, options?: { readonly discard: false; }): (self: TMap<K, V>) => STM.STM<Array<[K, V]>>; <K, V>(self: TMap<K, V>, predicate: (key: K, value: V) => boolean, options: { readonly discard: true; }): STM.STM<void>; <K, V>(self: TMap<K, V>, predicate: (key: K, value: V) => boolean, options?: { readonly discard: false; }): STM.STM<Array<[K, V]>>; }\n```\n\n----------------------------------------\n\nTITLE: TypeScript STM filterOrElse Type Declaration\nDESCRIPTION: Complex type signature for filterOrElse function supporting refinement and predicate-based filtering with alternative STM computations\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/STM-filterOrElse.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const filterOrElse: { \n  <A, B extends A, C, E2, R2>(refinement: Refinement<NoInfer<A>, B>, orElse: (a: NoInfer<A>) => STM<C, E2, R2>): <E, R>(self: STM<A, E, R>) => STM<B | C, E2 | E, R2 | R>; \n  <A, B, E2, R2>(predicate: Predicate<NoInfer<A>>, orElse: (a: NoInfer<A>) => STM<B, E2, R2>): <E, R>(self: STM<A, E, R>) => STM<A | B, E2 | E, R2 | R>; \n  <A, E, R, B extends A, C, E2, R2>(self: STM<A, E, R>, refinement: Refinement<A, B>, orElse: (a: A) => STM<C, E2, R2>): STM<B | C, E | E2, R | R2>; \n  <A, E, R, B, E2, R2>(self: STM<A, E, R>, predicate: Predicate<A>, orElse: (a: A) => STM<B, E2, R2>): STM<A | B, E | E2, R | R2>; \n}\n```\n\n----------------------------------------\n\nTITLE: Providing a Service to a Schedule in Effect TS\nDESCRIPTION: The `provideService` function allows supplying a service to an Effect Schedule, effectively resolving a dependency required by the schedule.  This function takes a Context.Tag representing the service type and the service implementation. It returns a new Schedule that no longer requires the provided service from the external environment.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Schedule-provideService.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const provideService: { <I, S>(tag: Context.Tag<I, S>, service: Types.NoInfer<S>): <Out, In, R>(self: Schedule<Out, In, R>) => Schedule<Out, In, Exclude<R, I>>; <Out, In, R, I, S>(self: Schedule<Out, In, R>, tag: Context.Tag<I, S>, service: Types.NoInfer<S>): Schedule<Out, In, Exclude<R, I>>; }\n```\n\n----------------------------------------\n\nTITLE: Creating Weighted Folding Sink with Effects in TypeScript\nDESCRIPTION: Creates a sink that effectfully folds elements of type In into a structure of type S, stopping when the total cost (determined by costFn) reaches a maximum threshold. Both the folding operation and cost calculation can have side effects.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Sink-foldWeightedEffect.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const foldWeightedEffect: <S, In, E, R, E2, R2>(options: { readonly initial: S; readonly maxCost: number; readonly cost: (s: S, input: In) => Effect.Effect<number, E, R>; readonly body: (s: S, input: In) => Effect.Effect<S, E2, R2>; }) => Sink<S, In, In, E | E2, R | R2>\n```\n\n----------------------------------------\n\nTITLE: Constructing Array Config in TypeScript\nDESCRIPTION: This function constructs a config for an array of values. It takes a config for a single value and an optional name parameter, returning a Config object for an array of those values.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Config-array.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const array: <A>(config: Config<A>, name?: string) => Config<Array<A>>\n```\n\n----------------------------------------\n\nTITLE: Implementing Iterable.some Predicate Check in TypeScript\nDESCRIPTION: Defines a function that checks if any element in an Iterable satisfies a given predicate. The function supports both curried and uncurried forms, taking a predicate function that receives both the element and its index.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Iterable-some.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const some: { <A>(predicate: (a: A, i: number) => boolean): (self: Iterable<A>) => boolean; <A>(self: Iterable<A>, predicate: (a: A, i: number) => boolean): boolean; }\n```\n\n----------------------------------------\n\nTITLE: Clamp Number with Effect Schema\nDESCRIPTION: This code snippet shows the type signature of the `clamp` function in the Effect Schema module. It takes a minimum and maximum number as input, and returns a function that transforms a schema to clamp a numerical value between those limits. It depends on Effect-TS and its Schema module.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Schema-clamp.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const clamp: (minimum: number, maximum: number) => <S extends Schema.Any, A extends number>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>) => transform<S, filter<SchemaClass<A>>>\n```\n\n----------------------------------------\n\nTITLE: Type Signature for Effect.repeatN Function in TypeScript\nDESCRIPTION: This code snippet shows the type signature for the repeatN function, which can be called in two ways: either by passing the number of repetitions first, or by passing the effect first followed by the number of repetitions.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-repeatN.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const repeatN: { (n: number): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R>; <A, E, R>(self: Effect<A, E, R>, n: number): Effect<A, E, R>; }\n```\n\n----------------------------------------\n\nTITLE: Typescript Schedule zipLeft Type Declaration\nDESCRIPTION: Defines a polymorphic function that combines two schedules, allowing intersection of inputs and merging of environments while preserving the left schedule's output\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Schedule-zipLeft.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const zipLeft: { <Out2, In2, R2>(that: Schedule<Out2, In2, R2>): <Out, In, R>(self: Schedule<Out, In, R>) => Schedule<Out, In & In2, R2 | R>; <Out, In, R, Out2, In2, R2>(self: Schedule<Out, In, R>, that: Schedule<Out2, In2, R2>): Schedule<Out, In & In2, R | R2>; }\n```\n\n----------------------------------------\n\nTITLE: Retrieving TestConfig and Running Workflow in TypeScript\nDESCRIPTION: The testConfigWith function retrieves the TestConfig service for a test and uses it to run a specified workflow. It takes a function that accepts TestConfig as an argument and returns an Effect.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TestServices-testConfigWith.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const testConfigWith: <A, E, R>(f: (config: TestConfig.TestConfig) => Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>\n```\n\n----------------------------------------\n\nTITLE: Effect Sink: dropUntil Signature\nDESCRIPTION: This snippet shows the TypeScript signature of the `dropUntil` function in the Effect Sink module. The `dropUntil` function takes a predicate as input and returns a `Sink` that drops incoming elements until the predicate returns true for an element.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Sink-dropUntil.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const dropUntil: <In>(predicate: Predicate<In>) => Sink<unknown, In, In>\n```\n\n----------------------------------------\n\nTITLE: Configuring Parallel Request Execution in Effect-TS\nDESCRIPTION: The batchN function returns a data source that executes at most n requests in parallel. It can be called in two ways: either passing the parallelism limit first and then the resolver, or passing the resolver first and then the parallelism limit.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/RequestResolver-batchN.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const batchN: { (n: number): <A, R>(self: RequestResolver<A, R>) => RequestResolver<A, R>; <A, R>(self: RequestResolver<A, R>, n: number): RequestResolver<A, R>; }\n```\n\n----------------------------------------\n\nTITLE: Creating File Arguments with Schema Validation in TypeScript\nDESCRIPTION: The fileSchema function creates a file argument that reads, parses and validates its contents. It takes a Schema and an optional configuration object, and returns an Args instance for the validated file content.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Args-fileSchema.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const fileSchema: <I, A>(schema: Schema<A, I, FileSystem | Path | Terminal>, config?: Args.FormatArgsConfig | undefined) => Args<A>\n```\n\n----------------------------------------\n\nTITLE: Using isEmptyArray to Check for Empty Arrays in Effect\nDESCRIPTION: Demonstrates how to use the isEmptyArray function from the Effect library to check if an array is empty. The function returns true for empty arrays and false otherwise, with type narrowing capability.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Array-isEmptyArray.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Array } from \"effect\"\n\nconsole.log(Array.isEmptyArray([])) // true\nconsole.log(Array.isEmptyArray([1, 2, 3])) // false\n```\n\n----------------------------------------\n\nTITLE: Comparing BigDecimal Values with greaterThanOrEqualTo\nDESCRIPTION: Demonstrates usage of greaterThanOrEqualTo function to compare BigDecimal values. The function returns true if the first value is greater than or equal to the second value, and false otherwise. Uses the unsafeFromString utility to create BigDecimal instances.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/BigDecimal-greaterThanOrEqualTo.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { greaterThanOrEqualTo, unsafeFromString } from \"effect/BigDecimal\"\n\nassert.deepStrictEqual(greaterThanOrEqualTo(unsafeFromString(\"2\"), unsafeFromString(\"3\")), false)\nassert.deepStrictEqual(greaterThanOrEqualTo(unsafeFromString(\"3\"), unsafeFromString(\"3\")), true)\nassert.deepStrictEqual(greaterThanOrEqualTo(unsafeFromString(\"4\"), unsafeFromString(\"3\")), true)\n```\n\n----------------------------------------\n\nTITLE: Catching Causes in Effect-TS Micro Module Using TypeScript\nDESCRIPTION: The `catchCauseIf` function allows selective catching of `MicroCause` objects from `Micro` effects using a predicate or refinement. Dependencies include TypeScript and the Effect-TS library with the `Micro` module. It requires definition of refinements or predicates to determine catchable causes. Inputs include a `Micro` effect and a function to handle the cause. The output is a new `Micro` effect with revised error and result types. It is suitable for handling errors without full exception throwing.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Micro-catchCauseIf.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const catchCauseIf: { <E, B, E2, R2, EB extends MicroCause<E>>(refinement: Refinement<MicroCause<E>, EB>, f: (cause: EB) => Micro<B, E2, R2>): <A, R>(self: Micro<A, E, R>) => Micro<A | B, Exclude<E, MicroCause.Error<EB>> | E2, R | R2>; <E, B, E2, R2>(predicate: Predicate<MicroCause<NoInfer<E>>>, f: (cause: NoInfer<MicroCause<E>>) => Micro<B, E2, R2>): <A, R>(self: Micro<A, E, R>) => Micro<A | B, E | E2, R | R2>; <A, E, R, B, E2, R2, EB extends MicroCause<E>>(self: Micro<A, E, R>, refinement: Refinement<MicroCause<E>, EB>, f: (cause: EB) => Micro<B, E2, R2>): Micro<A | B, Exclude<E, MicroCause.Error<EB>> | E2, R | R2>; <A, E, R, B, E2, R2>(self: Micro<A, E, R>, predicate: Predicate<MicroCause<NoInfer<E>>>, f: (cause: NoInfer<MicroCause<E>>) => Micro<B, E2, R2>): Micro<A | B, E | E2, R | R2>; }\n```\n\n----------------------------------------\n\nTITLE: Declaring Empty TMap Function in TypeScript\nDESCRIPTION: This code snippet declares a function named 'empty' that returns an instance of STM.STM containing an empty TMap for the given key-value types. It leverages the generic types K and V, allowing for flexibility in the types of keys and values used. This function is part of the STM (Software Transactional Memory) operations provided by the Effect-TS library.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TMap-empty.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const empty: <K, V>() => STM.STM<TMap<K, V>>\n```\n\n----------------------------------------\n\nTITLE: Match.orElse Type Signature\nDESCRIPTION: Type signature for the Match.orElse function showing its generic type parameters and return type. The function takes a fallback function and returns a matcher that incorporates the fallback case.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Match-orElse.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const orElse: <RA, Ret, F extends (_: RA) => Ret>(f: F) => <I, R, A, Pr>(self: Matcher<I, R, RA, A, Pr, Ret>) => [Pr] extends [never] ? (input: I) => Unify<ReturnType<F> | A> : Unify<ReturnType<F> | A>\n```\n\n----------------------------------------\n\nTITLE: Constructing URL Config in TypeScript\nDESCRIPTION: The 'url' function creates a configuration for a URL value. It optionally takes a name parameter and returns a Config<URL> object.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Config-url.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const url: (name?: string) => Config<URL>\n```\n\n----------------------------------------\n\nTITLE: TypeScript Signature for tapDefect Function in Effect Module\nDESCRIPTION: The type signature for the tapDefect function in the Effect module. It defines the function overloads that allow using tapDefect both through pipe syntax and traditional function call syntax.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-tapDefect.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const tapDefect: { <X, E2, R2>(f: (cause: Cause.Cause<never>) => Effect<X, E2, R2>): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E2 | E, R2 | R>; <A, E, R, X, E2, R2>(self: Effect<A, E, R>, f: (cause: Cause.Cause<never>) => Effect<X, E2, R2>): Effect<A, E | E2, R | R2>; }\n```\n\n----------------------------------------\n\nTITLE: BigDecimal.min Function Signature in TypeScript\nDESCRIPTION: Provides the TypeScript signature for the min function in the BigDecimal module. The function is overloaded to accept arguments in different orders for flexibility.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/BigDecimal-min.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const min: { (that: BigDecimal): (self: BigDecimal) => BigDecimal; (self: BigDecimal, that: BigDecimal): BigDecimal; }\n```\n\n----------------------------------------\n\nTITLE: Creating Records from Iterable Using Effect Library in TypeScript\nDESCRIPTION: This snippet demonstrates the usage of the 'fromIterableBy' function from the Effect library to transform an iterable of user objects into a record, where each user's ID serves as the key. The function ensures that the application's data structure can be efficiently accessed using the keys derived from the provided mapping function.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Record-fromIterableBy.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { fromIterableBy } from \"effect/Record\"\n\nconst users = [\n  { id: \"2\", name: \"name2\" },\n  { id: \"1\", name: \"name1\" }\n]\n\nassert.deepStrictEqual(\n  fromIterableBy(users, user => user.id),\n  {\n    \"2\": { id: \"2\", name: \"name2\" },\n    \"1\": { id: \"1\", name: \"name1\" }\n  }\n)\n```\n\n----------------------------------------\n\nTITLE: Running Stream to get last value in Effect (TypeScript)\nDESCRIPTION: The `runLast` function in the Effect library runs a given stream to completion. It then extracts the last emitted value from the stream and returns it wrapped in an `Option`. If the stream is empty, it returns `None`.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-runLast.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const runLast: <A, E, R>(self: Stream<A, E, R>) => Effect.Effect<Option.Option<A>, E, R>\n```\n\n----------------------------------------\n\nTITLE: Type Signature of Stream.iterate Function in TypeScript\nDESCRIPTION: Defines the type signature for the Stream.iterate function, which takes an initial value and a next function to generate an infinite stream.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-iterate.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const iterate: <A>(value: A, next: (value: A) => A) => Stream<A>\n```\n\n----------------------------------------\n\nTITLE: Updating a Service Implementation with Effect.updateService in TypeScript\nDESCRIPTION: The updateService function modifies an existing service implementation in the context. It retrieves the current service, applies a transformation function, and replaces the original service with the transformed one. This is useful for adapting service behavior at runtime.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-updateService.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const updateService: { <I, S>(tag: Context.Tag<I, S>, f: (service: NoInfer<S>) => NoInfer<S>): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R | I>; <A, E, R, I, S>(self: Effect<A, E, R>, tag: Context.Tag<I, S>, f: (service: NoInfer<S>) => NoInfer<S>): Effect<A, E, R | I>; }\n```\n\n----------------------------------------\n\nTITLE: Executing Delayed Micro Effect with Observer in TypeScript\nDESCRIPTION: Demonstrates how to execute a Micro effect with a delay and attach an observer to handle the result. The example creates a Micro effect that succeeds with value 42, adds a 1-second delay, and logs the exit value through an observer.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Micro-runFork.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as Micro from \"effect/Micro\"\n\nconst handle = Micro.succeed(42).pipe(\n  Micro.delay(1000),\n  Micro.runFork\n)\n\nhandle.addObserver((exit) => {\n  console.log(exit)\n})\n```\n\n----------------------------------------\n\nTITLE: Defining STM Error Refinement Function\nDESCRIPTION: A utility function that allows selective error handling in STM transactions by allowing transformation or filtering of errors. It can refine errors partially or completely based on a predicate function.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/STM-refineOrDie.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const refineOrDie: { <E, E2>(pf: (error: E) => Option.Option<E2>): <A, R>(self: STM<A, E, R>) => STM<A, E2, R>; <A, E, R, E2>(self: STM<A, E, R>, pf: (error: E) => Option.Option<E2>): STM<A, E2, R>; }\n```\n\n----------------------------------------\n\nTITLE: Negating STM Effect in TypeScript\nDESCRIPTION: This TypeScript snippet defines a function that returns a new STM effect where the boolean value of the specified effect is negated. This utility can be used to transform the result of an STM effect. The function operates on processes described by STM, allowing transactional memory operations. The main requirement is the `STM` module itself, with appropriate type parameters. The function takes a single STM effect as a parameter, and it outputs a new STM effect with its boolean result inverted.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/STM-negate.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const negate: <E, R>(self: STM<boolean, E, R>) => STM<boolean, E, R>\n```\n\n----------------------------------------\n\nTITLE: Declaring interruptAsFork Function in TypeScript\nDESCRIPTION: Declares the interruptAsFork function, which interrupts a fiber as if interrupted from a specified fiber. It takes a FiberId and returns an Effect that interrupts the fiber. The function can be called with arguments in two different orders.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Fiber-interruptAsFork.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const interruptAsFork: { (fiberId: FiberId.FiberId): <A, E>(self: Fiber<A, E>) => Effect.Effect<void>; <A, E>(self: Fiber<A, E>, fiberId: FiberId.FiberId): Effect.Effect<void>; }\n```\n\n----------------------------------------\n\nTITLE: Implementing Stream.zipFlatten in TypeScript with Effect-TS\nDESCRIPTION: Function signature for zipFlatten operation that combines two streams into tuples. The function takes a stream of arrays and another stream, combining them element-wise until one stream ends. Supports generic typing for element types, error types, and environment types.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-zipFlatten.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const zipFlatten: { <A2, E2, R2>(that: Stream<A2, E2, R2>): <A extends ReadonlyArray<any>, E, R>(self: Stream<A, E, R>) => Stream<[...A, A2], E2 | E, R2 | R>; <A extends ReadonlyArray<any>, E, R, A2, E2, R2>(self: Stream<A, E, R>, that: Stream<A2, E2, R2>): Stream<[...A, A2], E | E2, R | R2>; }\n```\n\n----------------------------------------\n\nTITLE: Implementing Exit.exists Function Signature in TypeScript\nDESCRIPTION: Defines a function signature for exists that takes a predicate or refinement and returns a type guard or boolean based on the Success value of an Exit type. The function can be called with either the predicate first or the Exit value first.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Exit-exists.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const exists: { \n  <A, B extends A>(refinement: Refinement<NoInfer<A>, B>): <E>(self: Exit<A, E>) => self is Exit<B>; \n  <A>(predicate: Predicate<NoInfer<A>>): <E>(self: Exit<A, E>) => boolean; \n  <A, E, B extends A>(self: Exit<A, E>, refinement: Refinement<A, B>): self is Exit<B>; \n  <A, E>(self: Exit<A, E>, predicate: Predicate<A>): boolean; \n}\n```\n\n----------------------------------------\n\nTITLE: Defining Layer.matchCause Function Signature in TypeScript\nDESCRIPTION: Defines a function that handles both success and failure cases of a Layer, allowing transformation of the layer's output or error into new layers. The function takes options for handling both failure (with cause) and success (with context) scenarios.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Layer-matchCause.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const matchCause: { <E, A2, E2, R2, A, A3, E3, R3>(options: { readonly onFailure: (cause: Cause.Cause<E>) => Layer<A2, E2, R2>; readonly onSuccess: (context: Context.Context<A>) => Layer<A3, E3, R3>; }): <R>(self: Layer<A, E, R>) => Layer<A2 & A3, E2 | E3, R2 | R3 | R>; <A, E, R, A2, E2, R2, A3, E3, R3>(self: Layer<A, E, R>, options: { readonly onFailure: (cause: Cause.Cause<E>) => Layer<A2, E2, R2>; readonly onSuccess: (context: Context.Context<A>) => Layer<A3, E3, R3>; }): Layer<A2 & A3, E2 | E3, R | R2 | R3>; }\n```\n\n----------------------------------------\n\nTITLE: Creating Nested Configuration in TypeScript using Effect-TS Config\nDESCRIPTION: The nested function returns a config that has the current configuration nested as a property of the specified name. It can be used in two ways: either by passing the name first, or by passing the config first and then the name.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Config-nested.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const nested: { (name: string): <A>(self: Config<A>) => Config<A>; <A>(self: Config<A>, name: string): Config<A>; }\n```\n\n----------------------------------------\n\nTITLE: Transforming Sink Results with Sink.map in TypeScript\nDESCRIPTION: The map function takes a transformation function and applies it to a Sink's result value. It supports both curried and uncurried calling styles, allowing developers to transform the output type of a Sink while preserving its input type and error handling characteristics.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Sink-map.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const map: { <A, A2>(f: (a: A) => A2): <In, L, E, R>(self: Sink<A, In, L, E, R>) => Sink<A2, In, L, E, R>; <A, In, L, E, R, A2>(self: Sink<A, In, L, E, R>, f: (a: A) => A2): Sink<A2, In, L, E, R>; }\n```\n\n----------------------------------------\n\nTITLE: Defining Stream.pipeThrough Function in TypeScript\nDESCRIPTION: This code snippet defines the `pipeThrough` function for the Stream module. It allows piping all values from a stream through a provided sink. The function is overloaded to handle different parameter orders and types.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-pipeThrough.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const pipeThrough: {\n  <A2, A, L, E2, R2>(sink: Sink.Sink<A2, A, L, E2, R2>): <E, R>(self: Stream<A, E, R>) => Stream<L, E2 | E, R2 | R>;\n  <A, E, R, A2, L, E2, R2>(self: Stream<A, E, R>, sink: Sink.Sink<A2, A, L, E2, R2>): Stream<L, E | E2, R | R2>;\n}\n```\n\n----------------------------------------\n\nTITLE: Creating TArray with make in Effect\nDESCRIPTION: This snippet shows the signature of the `make` function in the `TArray` module of the `effect` package. It allows the creation of a new `TArray` instance by passing a variable number of elements, and returns an STM effect.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TArray-make.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const make: <Elements extends [any, ...Array<any>]>(...elements: Elements) => STM.STM<TArray<Elements[number]>>\n```\n\n----------------------------------------\n\nTITLE: Stream Cross Type Signature\nDESCRIPTION: Provides the TypeScript type declaration for the Stream.cross method, showcasing its complex generic type handling\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-cross.md#2025-04-11_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const cross: { \n  <AR, ER, RR>(right: Stream<AR, ER, RR>): \n  <AL, EL, RL>(left: Stream<AL, EL, RL>) => Stream<[AL, AR], EL | ER, RL | RR>; \n  <AL, ER, RR, AR, EL, RL>(left: Stream<AL, ER, RR>, right: Stream<AR, EL, RL>): \n  Stream<[AL, AR], EL | ER, RL | RR>; \n}\n```\n\n----------------------------------------\n\nTITLE: Transforming Sink Input Elements with mapInput in Effect.js\nDESCRIPTION: The mapInput function transforms a sink's input elements using a provided transformation function. It allows adapting a sink to work with different input types by applying a conversion function to incoming data before processing.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Sink-mapInput.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const mapInput: { <In0, In>(f: (input: In0) => In): <A, L, E, R>(self: Sink<A, In, L, E, R>) => Sink<A, In0, L, E, R>; <A, In, L, E, R, In0>(self: Sink<A, In, L, E, R>, f: (input: In0) => In): Sink<A, In0, L, E, R>; }\n```\n\n----------------------------------------\n\nTITLE: Creating ConfigProvider from Environment Variables in TypeScript\nDESCRIPTION: Creates a config provider that loads configuration from context variables. It accepts optional configuration for path delimiter and sequence delimiter with defaults of '_' and ',' respectively.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/ConfigProvider-fromEnv.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const fromEnv: (options?: Partial<ConfigProvider.FromEnvConfig>) => ConfigProvider\n```\n\n----------------------------------------\n\nTITLE: Handling Errors with Effect.runSync in TypeScript\nDESCRIPTION: Shows incorrect usage of Effect.runSync with failing or asynchronous effects, resulting in exceptions being thrown.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-runSync.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Effect } from \"effect\"\n\ntry {\n  // Attempt to run an effect that fails\n  Effect.runSync(Effect.fail(\"my error\"))\n} catch (e) {\n  console.error(e)\n}\n// Output:\n// (FiberFailure) Error: my error\n\ntry {\n  // Attempt to run an effect that involves async work\n  Effect.runSync(Effect.promise(() => Promise.resolve(1)))\n} catch (e) {\n  console.error(e)\n}\n// Output:\n// (FiberFailure) AsyncFiberException: Fiber #0 cannot be resolved synchronously. This is caused by using runSync on an effect that performs async work\n```\n\n----------------------------------------\n\nTITLE: Defining orElseIfEmptyStream Function in TypeScript for Stream Module\nDESCRIPTION: This code snippet defines the orElseIfEmptyStream function, which switches to a provided stream if the current stream is empty. It takes a lazy argument of a stream and returns a function that combines the original and alternative streams.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-orElseIfEmptyStream.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const orElseIfEmptyStream: { <A2, E2, R2>(stream: LazyArg<Stream<A2, E2, R2>>): <A, E, R>(self: Stream<A, E, R>) => Stream<A2 | A, E2 | E, R2 | R>; <A, E, R, A2, E2, R2>(self: Stream<A, E, R>, stream: LazyArg<Stream<A2, E2, R2>>): Stream<A | A2, E | E2, R | R2>; }\n```\n\n----------------------------------------\n\nTITLE: Constructing a Config for Sequence Values with Config.chunk in TypeScript\nDESCRIPTION: This function constructs a Config for a sequence of values. It takes a configuration for a single value and optionally a name parameter, returning a Config that produces a Chunk containing multiple values of that type.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Config-chunk.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const chunk: <A>(config: Config<A>, name?: string) => Config<Chunk.Chunk<A>>\n```\n\n----------------------------------------\n\nTITLE: TypeScript Signature of withCurrentZoneLocal Function\nDESCRIPTION: This code block shows the TypeScript signature of the withCurrentZoneLocal function. It takes an Effect as input and returns a new Effect with the CurrentTimeZone dependency removed.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/DateTime-withCurrentZoneLocal.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const withCurrentZoneLocal: <A, E, R>(effect: Effect.Effect<A, E, R>) => Effect.Effect<A, E, Exclude<R, CurrentTimeZone>>\n```\n\n----------------------------------------\n\nTITLE: Mapping Input Error in Effect Channel\nDESCRIPTION: The mapInputError function creates a new channel that applies a transformation function to the input channel's error value. It preserves all other aspects of the channel while allowing error type conversion.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Channel-mapInputError.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const mapInputError: { <InErr0, InErr>(f: (a: InErr0) => InErr): <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>) => Channel<OutElem, InElem, OutErr, InErr0, OutDone, InDone, Env>; <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, InErr0>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>, f: (a: InErr0) => InErr): Channel<OutElem, InElem, OutErr, InErr0, OutDone, InDone, Env>; }\n```\n\n----------------------------------------\n\nTITLE: Permissions Interface Definition in Effect TS\nDESCRIPTION: Defines the `Permissions` interface, a wrapper around the browser's Permission API, using Effect TS. It provides a `query` method to fetch the status of a given permission.  The query method returns an Effect that resolves to a PermissionStatus object which includes the name of the permission being queried.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Permissions-Permissions.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface Permissions {\n  readonly [TypeId]: TypeId\n\n  /**\n   * Returns the state of a user permission on the global scope.\n   */\n  readonly query: <Name extends PermissionName>(\n    name: Name\n  ) => Effect.Effect<\n    // `name` is identical to the name passed to Permissions.query\n    // https://developer.mozilla.org/en-US/docs/Web/API/PermissionStatus\n    Omit<PermissionStatus, \"name\"> & { name: Name },\n    PermissionsError\n  >\n}\n```\n\n----------------------------------------\n\nTITLE: Effect Schema Tag Function Signature\nDESCRIPTION: This snippet displays the TypeScript declaration for the `Schema.tag` function.  It shows that the function accepts a literal value `Tag` and returns a type `tag<Tag>`. This is used to create a property signature representing the tag.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Schema-tag.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const tag: <Tag extends AST.LiteralValue>(tag: Tag) => tag<Tag>\n```\n\n----------------------------------------\n\nTITLE: Declaring interruptAfter Function in TypeScript for Stream Module\nDESCRIPTION: Defines the interruptAfter function, which is a specialized version of Stream.interruptWhen. It interrupts the evaluation of a stream after a given Duration. The function is overloaded to accept parameters in different orders.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-interruptAfter.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const interruptAfter: { (duration: Duration.DurationInput): <A, E, R>(self: Stream<A, E, R>) => Stream<A, E, R>; <A, E, R>(self: Stream<A, E, R>, duration: Duration.DurationInput): Stream<A, E, R>; }\n```\n\n----------------------------------------\n\nTITLE: Defining ConfigProvider Interface in TypeScript\nDESCRIPTION: Defines the ConfigProvider interface that provides configuration based on a specified structure. It includes methods for loading configurations and flattening the provider into a simplified version for flat key/value properties.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/ConfigProvider-ConfigProvider.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface ConfigProvider extends ConfigProvider.Proto, Pipeable {\n  /**\n   * Loads the specified configuration, or fails with a config error.\n   */\n  load<A>(config: Config.Config<A>): Effect.Effect<A, ConfigError.ConfigError>\n  /**\n   * Flattens this config provider into a simplified config provider that knows\n   * only how to deal with flat (key/value) properties.\n   */\n  readonly flattened: ConfigProvider.Flat\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Channel.drain in TypeScript\nDESCRIPTION: Defines a function that creates a new channel which reads and ignores all elements from an upstream output channel, then terminates with the upstream result value. This function is useful for processing streams where the intermediate values are not needed.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Channel-drain.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const drain: <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>) => Channel<never, InElem, OutErr, InErr, OutDone, InDone, Env>\n```\n\n----------------------------------------\n\nTITLE: Effect.addFinalizer Type Signature\nDESCRIPTION: The TypeScript type signature for the addFinalizer function, showing its parameters and return type. It takes a finalizer function that receives an Exit value and returns an Effect that requires Scope.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-addFinalizer.md#2025-04-11_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const addFinalizer: <X, R>(finalizer: (exit: Exit.Exit<unknown, unknown>) => Effect<X, never, R>) => Effect<void, never, Scope.Scope | R>\n```\n\n----------------------------------------\n\nTITLE: Modifying Last Element of Non-Empty Array in TypeScript\nDESCRIPTION: The `modifyNonEmptyLast` function applies a transformation to the last element of a non-empty array, creating a new array. It takes a non-empty array and a transformation function as input, and returns a new non-empty array with the last element modified.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Array-modifyNonEmptyLast.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Array } from \"effect\"\n\nconst result = Array.modifyNonEmptyLast([1, 2, 3], n => n * 2)\nconsole.log(result) // [1, 2, 6]\n```\n\n----------------------------------------\n\nTITLE: Stream catchAll Function Signature\nDESCRIPTION: The `catchAll` function provides a mechanism for error handling in streams. It takes a function that maps the error type `E` to a new stream `Stream<A2, E2, R2>`, allowing the program to switch to a different stream when an error occurs. The function is available in two forms, as a curried and uncurried version.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-catchAll.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const catchAll: { <E, A2, E2, R2>(f: (error: E) => Stream<A2, E2, R2>): <A, R>(self: Stream<A, E, R>) => Stream<A2 | A, E2, R2 | R>; <A, E, R, A2, E2, R2>(self: Stream<A, E, R>, f: (error: E) => Stream<A2, E2, R2>): Stream<A | A2, E2, R | R2>; }\n```\n\n----------------------------------------\n\nTITLE: Effect.timed Function Signature in TypeScript\nDESCRIPTION: The type signature for the Effect.timed function, showing it takes an Effect<A, E, R> and returns an Effect that produces a tuple containing both the Duration and the original result.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-timed.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const timed: <A, E, R>(self: Effect<A, E, R>) => Effect<[duration: Duration.Duration, result: A], E, R>\n```\n\n----------------------------------------\n\nTITLE: Defining withAnnotationsScoped Function - Effect-TS - TypeScript\nDESCRIPTION: The `withAnnotationsScoped` function sets the implementation of the annotations service for testing purposes. It takes an `Annotations.TestAnnotations` object as input and returns an `Effect.Effect` that can be used to manage the scope of the annotations implementation. Upon the completion of the scope, the original value is restored, allowing for clean state management in tests.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TestServices-withAnnotationsScoped.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const withAnnotationsScoped: (annotations: Annotations.TestAnnotations) => Effect.Effect<void, never, Scope.Scope>\n```\n\n----------------------------------------\n\nTITLE: Implementing Error Recovery with Effect.catchSomeCause in TypeScript\nDESCRIPTION: Function signature for catchSomeCause that allows recovering from specific causes using a partial function. The function takes a handler that processes Cause<E> and returns an optional Effect, with flexible type parameters for input/output effect types.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-catchSomeCause.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const catchSomeCause: { <E, A2, E2, R2>(f: (cause: Cause.Cause<NoInfer<E>>) => Option.Option<Effect<A2, E2, R2>>): <A, R>(self: Effect<A, E, R>) => Effect<A2 | A, E | E2, R2 | R>; <A, E, R, A2, E2, R2>(self: Effect<A, E, R>, f: (cause: Cause.Cause<NoInfer<E>>) => Option.Option<Effect<A2, E2, R2>>): Effect<A2 | A, E | E2, R2 | R>; }\n```\n\n----------------------------------------\n\nTITLE: Extracting Values from Either with Custom Error Handling\nDESCRIPTION: Example demonstrating how to use getOrThrowWith to extract values from Either types, with custom error handling for Left cases. Shows both successful value extraction and error throwing scenarios.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Either-getOrThrowWith.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { Either } from \"effect\"\n\nassert.deepStrictEqual(\n  Either.getOrThrowWith(Either.right(1), () => new Error('Unexpected Left')),\n  1\n)\nassert.throws(() => Either.getOrThrowWith(Either.left(\"error\"), () => new Error('Unexpected Left')))\n```\n\n----------------------------------------\n\nTITLE: Accessing Scheduled Effect Times using TestClock - TypeScript\nDESCRIPTION: This snippet defines the `sleeps` function from the `TestClock` module, which returns a list of scheduled effect execution times. It utilizes the Effect framework and the Chunk type for the output. The function requires an instance of `TestClock` to be present in the context.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TestClock-sleeps.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const sleeps: () => Effect.Effect<Chunk.Chunk<number>>\n```\n\n----------------------------------------\n\nTITLE: TypeScript Function Signature for Effect.andThen\nDESCRIPTION: The detailed type signature for the Effect.andThen function, showing its polymorphic nature and various overloads that handle different types of input functions and return values.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-andThen.md#2025-04-11_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const andThen: { <A, X>(f: (a: NoInfer<A>) => X): <E, R>(self: Effect<A, E, R>) => [X] extends [Effect<infer A1, infer E1, infer R1>] ? Effect<A1, E | E1, R | R1> : [X] extends [PromiseLike<infer A1>] ? Effect<A1, E | Cause.UnknownException, R> : Effect<X, E, R>; <X>(f: NotFunction<X>): <A, E, R>(self: Effect<A, E, R>) => [X] extends [Effect<infer A1, infer E1, infer R1>] ? Effect<A1, E | E1, R | R1> : [X] extends [PromiseLike<infer A1>] ? Effect<A1, E | Cause.UnknownException, R> : Effect<X, E, R>; <A, E, R, X>(self: Effect<A, E, R>, f: (a: NoInfer<A>) => X): [X] extends [Effect<infer A1, infer E1, infer R1>] ? Effect<A1, E | E1, R | R1> : [X] extends [PromiseLike<infer A1>] ? Effect<A1, E | Cause.UnknownException, R> : Effect<X, E, R>; <A, E, R, X>(self: Effect<A, E, R>, f: NotFunction<X>): [X] extends [Effect<infer A1, infer E1, infer R1>] ? Effect<A1, E | E1, R | R1> : [X] extends [PromiseLike<infer A1>] ? Effect<A1, E | Cause.UnknownException, R> : Effect<X, E, R>; }\n```\n\n----------------------------------------\n\nTITLE: Effect.whenEffect Function Signature in TypeScript\nDESCRIPTION: TypeScript type signature for the whenEffect function, showing its polymorphic nature and type constraints. Defines the function's type parameters and return types.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-whenEffect.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const whenEffect: { <E, R>(condition: Effect<boolean, E, R>): <A, E2, R2>(effect: Effect<A, E2, R2>) => Effect<Option.Option<A>, E | E2, R | R2>; <A, E2, R2, E, R>(self: Effect<A, E2, R2>, condition: Effect<boolean, E, R>): Effect<Option.Option<A>, E2 | E, R2 | R>; }\n```\n\n----------------------------------------\n\nTITLE: Creating a Schedule with Effect TS in Typescript\nDESCRIPTION: This snippet declares a constant `fromDelay` which creates a schedule that triggers once after a specified delay. It requires a `Duration` input and returns a `Schedule` object with the same `Duration`. The schedule will execute a task once after the specified duration without repetition. Dependencies include Duration from Effect TS. Parameters involve the delay duration as input and the schedule object as output.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Schedule-fromDelay.md#2025-04-11_snippet_0\n\nLANGUAGE: Typescript\nCODE:\n```\ndeclare const fromDelay: (delay: Duration.DurationInput) => Schedule<Duration.Duration>\n```\n\n----------------------------------------\n\nTITLE: Failing a Deferred with Error in TypeScript\nDESCRIPTION: The fail function is used to fail a Deferred with a specified error. This error will be propagated to all fibers waiting on the value of the Deferred. The function returns an Effect that resolves to a boolean.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Deferred-fail.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const fail: { <E>(error: E): <A>(self: Deferred<A, E>) => Effect.Effect<boolean>; <A, E>(self: Deferred<A, E>, error: E): Effect.Effect<boolean>; }\n```\n\n----------------------------------------\n\nTITLE: Function Signature for Effect.makeLatch in TypeScript\nDESCRIPTION: The TypeScript function signature for Effect.makeLatch, showing that it accepts an optional boolean parameter for the initial state and returns an Effect that produces a Latch instance.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-makeLatch.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const makeLatch: (open?: boolean | undefined) => Effect<Latch, never, never>\n```\n\n----------------------------------------\n\nTITLE: Stream.raceAll Function Signature in TypeScript\nDESCRIPTION: This code snippet shows the TypeScript signature for the Stream.raceAll function. It takes multiple streams as arguments and returns a new stream that emits values from the first stream to produce a value.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-raceAll.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const raceAll: <S extends ReadonlyArray<Stream<any, any, any>>>(...streams: S) => Stream<Stream.Success<S[number]>, Stream.Error<S[number]>, Stream.Context<S[number]>>\n```\n\n----------------------------------------\n\nTITLE: Declaring Composite Class in TypeScript\nDESCRIPTION: This snippet defines the Composite class, which is used to represent a collection of parsing errors along with contextual details. Key properties include 'ast', which holds the abstract syntax tree, 'actual' for the actual value parsed, 'issues' containing potential parse issues, and an optional 'output' for any resulting value. Dependencies include the AST and ParseIssue types.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/ParseResult-Composite.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare class Composite { constructor(\n    readonly ast: AST.AST,\n    readonly actual: unknown,\n    readonly issues: SingleOrNonEmpty<ParseIssue>,\n    readonly output?: unknown\n  ) }\n```\n\n----------------------------------------\n\nTITLE: TypeScript Function Signature for Array.intersection\nDESCRIPTION: The type declaration for the intersection function showing it supports both curried and non-curried usage patterns. It works with any Iterable types and returns an array of common elements.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Array-intersection.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const intersection: { <B>(that: Iterable<B>): <A>(self: Iterable<A>) => Array<A & B>; <A, B>(self: Iterable<A>, that: Iterable<B>): Array<A & B>; }\n```\n\n----------------------------------------\n\nTITLE: Defining offerAll Function for Queue in TypeScript\nDESCRIPTION: Declares the offerAll function for different queue types (Bounded, Unbounded, Sliding, Dropping). It takes an iterable and a queue, and returns an Effect with a boolean result. The behavior varies based on the queue type and its capacity.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Queue-offerAll.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const offerAll: { <A>(iterable: Iterable<A>): (self: Enqueue<A>) => Effect.Effect<boolean>; <A>(self: Enqueue<A>, iterable: Iterable<A>): Effect.Effect<boolean>; }\n```\n\n----------------------------------------\n\nTITLE: Either.match TypeScript Function Signature\nDESCRIPTION: The type signature for the Either.match function, showing its overloaded nature. It can be used either in pipeline style or with direct application, taking options containing onLeft and onRight handler functions.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Either-match.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const match: { <L, B, R, C = B>(options: { readonly onLeft: (left: L) => B; readonly onRight: (right: R) => C; }): (self: Either<R, L>) => B | C; <R, L, B, C = B>(self: Either<R, L>, options: { readonly onLeft: (left: L) => B; readonly onRight: (right: R) => C; }): B | C; }\n```\n\n----------------------------------------\n\nTITLE: Encoding Data to Base64 in TypeScript with Effect IO\nDESCRIPTION: This function encodes a Uint8Array or string input into a base64 (RFC4648) formatted string. It's part of the Effect IO library's Encoding module and supports both binary and text data as input.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Encoding-encodeBase64.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const encodeBase64: (input: Uint8Array | string) => string\n```\n\n----------------------------------------\n\nTITLE: Declaring Uninterruptible Effect Function in TypeScript\nDESCRIPTION: Defines a function that flags an effect as uninterruptible, meaning that when the effect is interrupted, it will be allowed to continue running until completion. This function was introduced in version 3.4.0 of the effect package.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Micro-uninterruptible.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const uninterruptible: <A, E, R>(self: Micro<A, E, R>) => Micro<A, E, R>\n```\n\n----------------------------------------\n\nTITLE: Mapping STM Effects in TypeScript\nDESCRIPTION: This snippet demonstrates the declaration of a \\'map\\' function within the STM module. The \\'map\\' function is designed to transform the output of an STM effect using a given function \\'f\\'. It supports function overloading to accommodate different usage patterns. The function is part of the Effect-TS library and is dependent on the STM module. It expects a mapping function \\'f\\' and an STM instance, transforming the value type of the STM effect while preserving the error and resource types.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/STM-map.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const map: { <A, B>(f: (a: A) => B): <E, R>(self: STM<A, E, R>) => STM<B, E, R>; <A, E, R, B>(self: STM<A, E, R>, f: (a: A) => B): STM<B, E, R>; }\n```\n\n----------------------------------------\n\nTITLE: Creating MutableList from Iterable in TypeScript\nDESCRIPTION: The `fromIterable` function initializes a new `MutableList` using an `Iterable` collection of values. It requires a generic type A and an iterable of type A as input, and returns a `MutableList` containing the input values. This function is part of the `effect` package and is available since version 2.0.0.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/MutableList-fromIterable.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const fromIterable: <A>(iterable: Iterable<A>) => MutableList<A>\n```\n\n----------------------------------------\n\nTITLE: TPriorityQueue takeOption Declaration\nDESCRIPTION: This snippet declares the `takeOption` function within the `TPriorityQueue` module. It takes a `TPriorityQueue` of type `A` as input and returns an STM computation that yields an `Option` of type `A`. The `Option` will contain a value if one is available in the queue, or `None` if the queue is empty.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TPriorityQueue-takeOption.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const takeOption: <A>(self: TPriorityQueue<A>) => STM.STM<Option.Option<A>>\n```\n\n----------------------------------------\n\nTITLE: Defining Chunk Difference Function in TypeScript\nDESCRIPTION: Declares a function 'difference' that creates a new Chunk containing elements from the first Chunk that are not present in the second Chunk. It preserves the order and references of values from the first Chunk.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Chunk-difference.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const difference: { <A>(that: Chunk<A>): (self: Chunk<A>) => Chunk<A>; <A>(self: Chunk<A>, that: Chunk<A>): Chunk<A>; }\n```\n\n----------------------------------------\n\nTITLE: Defining Character Schema in TypeScript using Effect\nDESCRIPTION: Declares a 'Char' class that represents a schema for a single character. This schema can be used for validation and data modeling of character data within the Effect library ecosystem.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Schema-Char.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare class Char\n```\n\n----------------------------------------\n\nTITLE: Wrapping Micro Effect Values in Some - TypeScript\nDESCRIPTION: Type signature for the asSome function that takes a Micro effect and wraps its success value in a Some option type. This preserves the error type E and environment type R while transforming the success type A into Option<A>.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Micro-asSome.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const asSome: <A, E, R>(self: Micro<A, E, R>) => Micro<Option.Option<A>, E, R>\n```\n\n----------------------------------------\n\nTITLE: Find Last Index From in TArray\nDESCRIPTION: Defines the `findLastIndexFrom` function to find the last index of a value within a TArray up to a specific end index. It leverages the STM monad for transactional state management, returning an Option containing the index or None if the value is not found or the array is empty.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TArray-findLastIndexFrom.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const findLastIndexFrom: { <A>(value: A, end: number): (self: TArray<A>) => STM.STM<Option.Option<number>>; <A>(self: TArray<A>, value: A, end: number): STM.STM<Option.Option<number>>; }\n```\n\n----------------------------------------\n\nTITLE: Type Signature for uninterruptibleMask Function in TypeScript\nDESCRIPTION: The type signature for the uninterruptibleMask function, showing it takes a function that receives a restore callback which can be used to make specific effects interruptible again.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Micro-uninterruptibleMask.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const uninterruptibleMask: <A, E, R>(f: (restore: <A, E, R>(effect: Micro<A, E, R>) => Micro<A, E, R>) => Micro<A, E, R>) => Micro<A, E, R>\n```\n\n----------------------------------------\n\nTITLE: Updating Mapping in TMap Using UpdateWith Function\nDESCRIPTION: The updateWith function provides a way to update the value associated with a specified key in a TMap. It takes a key and a function that operates on the current value (if it exists) and returns an optional new value. The function produces a new STM that can either provide the updated value or indicate the absence of it if removed.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TMap-updateWith.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const updateWith: { <K, V>(key: K, f: (value: Option.Option<V>) => Option.Option<V>): (self: TMap<K, V>) => STM.STM<Option.Option<V>>; <K, V>(self: TMap<K, V>, key: K, f: (value: Option.Option<V>) => Option.Option<V>): STM.STM<Option.Option<V>>; }\n```\n\n----------------------------------------\n\nTITLE: TypeScript Function Signature for Metric.gauge in Effect Library\nDESCRIPTION: Provides the TypeScript function signature for the Metric.gauge function. It shows the overloaded function signatures for creating number and bigint gauges with optional configuration options.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Metric-gauge.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const gauge: { (name: string, options?: { readonly description?: string | undefined; readonly bigint?: false | undefined; }): Metric.Gauge<number>; (name: string, options: { readonly description?: string | undefined; readonly bigint: true; }): Metric.Gauge<bigint>; }\n```\n\n----------------------------------------\n\nTITLE: Creating Numeric Config in Effect-TS\nDESCRIPTION: Function signature for creating a config that handles numeric (float) values. Takes an optional name parameter and returns a Config instance typed for numbers.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Config-number.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const number: (name?: string) => Config<number>\n```\n\n----------------------------------------\n\nTITLE: Function Signature for withConfigProvider in TypeScript\nDESCRIPTION: Shows the TypeScript type signature for the withConfigProvider function. The function accepts a provider parameter and returns a higher-order function that takes an Effect and returns a new Effect with the same type parameters.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-withConfigProvider.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const withConfigProvider: { (provider: ConfigProvider): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R>; <A, E, R>(self: Effect<A, E, R>, provider: ConfigProvider): Effect<A, E, R>; }\n```\n\n----------------------------------------\n\nTITLE: Implementing Chunk.partition Function in TypeScript\nDESCRIPTION: The partition function separates elements of a Chunk into two groups based on a predicate that also exposes the element index. It supports type refinement and both curried and non-curried usage patterns. The function returns a tuple with excluded and satisfying elements.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Chunk-partition.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const partition: { <A, B extends A>(refinement: (a: NoInfer<A>, i: number) => a is B): (self: Chunk<A>) => [excluded: Chunk<Exclude<A, B>>, satisfying: Chunk<B>]; <A>(predicate: (a: NoInfer<A>, i: number) => boolean): (self: Chunk<A>) => [excluded: Chunk<A>, satisfying: Chunk<A>]; <A, B extends A>(self: Chunk<A>, refinement: (a: A, i: number) => a is B): [excluded: Chunk<Exclude<A, B>>, satisfying: Chunk<B>]; <A>(self: Chunk<A>, predicate: (a: A, i: number) => boolean): [excluded: Chunk<A>, satisfying: Chunk<A>]; }\n```\n\n----------------------------------------\n\nTITLE: Filtering Queue Elements with TPriorityQueue.retainIf in TypeScript\nDESCRIPTION: Provides a function that retains only elements in a transactional priority queue that match a given predicate. This function returns an STM transaction that, when executed, will filter the queue contents based on the provided condition.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TPriorityQueue-retainIf.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const retainIf: { <A>(predicate: Predicate<A>): (self: TPriorityQueue<A>) => STM.STM<void>; <A>(self: TPriorityQueue<A>, predicate: Predicate<A>): STM.STM<void>; }\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Either.liftPredicate Usage in TypeScript\nDESCRIPTION: This example shows how to use the Either.liftPredicate function to transform a predicate function into an Either type. It demonstrates both successful and failing cases.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Either-liftPredicate.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { pipe, Either } from \"effect\"\n\nconst isPositive = (n: number): boolean => n > 0\n\nassert.deepStrictEqual(\n  pipe(\n    1,\n    Either.liftPredicate(isPositive, n => `${n} is not positive`)\n  ),\n  Either.right(1)\n)\nassert.deepStrictEqual(\n  pipe(\n    0,\n    Either.liftPredicate(isPositive, n => `${n} is not positive`)\n  ),\n  Either.left(\"0 is not positive\")\n)\n```\n\n----------------------------------------\n\nTITLE: Declaring Micro.forkDaemon Function in TypeScript\nDESCRIPTION: Defines a function that runs a Micro effect in a new MicroFiber that can be awaited, joined, or aborted independently of its parent Micro. The fiber continues running even after the parent Micro completes execution.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Micro-forkDaemon.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const forkDaemon: <A, E, R>(self: Micro<A, E, R>) => Micro<MicroFiber<A, E>, never, R>\n```\n\n----------------------------------------\n\nTITLE: Configuring Random Service Implementation in Effect Scope\nDESCRIPTION: Function that sets a custom Random service implementation for a specified scope and restores the original implementation when the scope closes. Takes a Random implementation as input and returns an Effect that requires a Scope.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-withRandomScoped.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const withRandomScoped: <A extends Random.Random>(value: A) => Effect<void, never, Scope.Scope>\n```\n\n----------------------------------------\n\nTITLE: Signature of Standard Schema V1 Function in TypeScript\nDESCRIPTION: This code snippet provides the TypeScript signature for the 'standardSchemaV1' function. It describes the function’s ability to create a Standard Schema V1 object, with optional override options. Dependencies include the definition of Schema classes. The description focuses on generic parameter types and return types.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Schema-standardSchemaV1.md#2025-04-11_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const standardSchemaV1: <A, I>(schema: Schema<A, I, never>, overrideOptions?: AST.ParseOptions) => StandardSchemaV1<I, A> & SchemaClass<A, I, never>\n```\n\n----------------------------------------\n\nTITLE: Defining Metric.map Function in TypeScript\nDESCRIPTION: Declares a function that creates a new metric by transforming the output state type of an existing metric. It supports both curried and non-curried versions of the function.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Metric-map.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const map: { <Out, Out2>(f: (out: Out) => Out2): <Type, In>(self: Metric<Type, In, Out>) => Metric<Type, In, Out2>; <Type, In, Out, Out2>(self: Metric<Type, In, Out>, f: (out: Out) => Out2): Metric<Type, In, Out2>; }\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Either.getLeft Usage in TypeScript\nDESCRIPTION: This example shows how to use the Either.getLeft function to convert an Either to an Option, discarding the value. It demonstrates the behavior for both right and left cases.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Either-getLeft.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { Either, Option } from \"effect\"\n\nassert.deepStrictEqual(Either.getLeft(Either.right('ok')), Option.none())\nassert.deepStrictEqual(Either.getLeft(Either.left('err')), Option.some('err'))\n```\n\n----------------------------------------\n\nTITLE: Defining tapError Function Signature in TypeScript for Layer Module\nDESCRIPTION: Declares the signature of the tapError function, which performs a specified effect if a layer fails. It supports both curried and uncurried forms, allowing for flexible error handling in layer compositions.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Layer-tapError.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const tapError: { <E, XE extends E, RIn2, E2, X>(f: (e: XE) => Effect.Effect<X, E2, RIn2>): <RIn, ROut>(self: Layer<ROut, E, RIn>) => Layer<ROut, E | E2, RIn2 | RIn>; <RIn, E, XE extends E, ROut, RIn2, E2, X>(self: Layer<ROut, E, RIn>, f: (e: XE) => Effect.Effect<X, E2, RIn2>): Layer<ROut, E | E2, RIn | RIn2>; }\n```\n\n----------------------------------------\n\nTITLE: Accessing Runtime for Task Execution in Effect Library\nDESCRIPTION: Returns an effect that accesses the runtime, which can be used to (unsafely) execute tasks. This is useful for integration with legacy code that must call back into Effect code.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-runtime.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const runtime: <R = never>() => Effect<Runtime.Runtime<R>, never, R>\n```\n\n----------------------------------------\n\nTITLE: Taking Multiple Elements from Transactional Priority Queue in TypeScript\nDESCRIPTION: The takeUpTo function extracts up to a specified maximum number of elements from a transactional priority queue. It returns an STM transaction that will yield an array containing the extracted elements.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TPriorityQueue-takeUpTo.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const takeUpTo: { (n: number): <A>(self: TPriorityQueue<A>) => STM.STM<Array<A>>; <A>(self: TPriorityQueue<A>, n: number): STM.STM<Array<A>>; }\n```\n\n----------------------------------------\n\nTITLE: Signature Declaration for isObject Function in TypeScript\nDESCRIPTION: This code snippet provides the TypeScript signature declaration for the `isObject` utility in the `Predicate` module. It defines `isObject` as a function that takes an unknown type as input and returns a type guard that determines whether the input is an object. This signature is crucial for understanding the expected input and output types when using the function within TypeScript projects.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Predicate-isObject.md#2025-04-11_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const isObject: (input: unknown) => input is object\n```\n\n----------------------------------------\n\nTITLE: Implementing Type Check for Layer in TypeScript\nDESCRIPTION: Defines a function 'isLayer' that checks if a given value is of type Layer. It returns true if the input is a Layer instance, false otherwise. This function is useful for type-safe operations on Layer objects.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Layer-isLayer.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const isLayer: (u: unknown) => u is Layer<unknown, unknown, unknown>\n```\n\n----------------------------------------\n\nTITLE: Implementing RequestResolver.fromEffectTagged in TypeScript\nDESCRIPTION: Constructs a data source from a list of tags paired to functions, handling batched requests. Each function takes a list of requests and returns a list of results of the same size, with each result corresponding to the same index in the request list.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/RequestResolver-fromEffectTagged.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const fromEffectTagged: <A extends Request.Request<any, any> & { readonly _tag: string; }>() => <Fns extends { readonly [Tag in A[\"_tag\"]]: [Extract<A, { readonly _tag: Tag; }>] extends [infer Req] ? Req extends Request.Request<infer ReqA, infer ReqE> ? (requests: Array<Req>) => Effect.Effect<Iterable<ReqA>, ReqE, any> : never : never; }>(fns: Fns) => RequestResolver<A, ReturnType<Fns[keyof Fns]> extends Effect.Effect<infer _A, infer _E, infer R> ? R : never>\n```\n\n----------------------------------------\n\nTITLE: Modifying Values in MutableHashMap in TypeScript\nDESCRIPTION: Updates the value of a specified key within a MutableHashMap by applying a transformation function to the existing value. The function has two call signatures - a curried version and a direct version.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/MutableHashMap-modify.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const modify: { <K, V>(key: K, f: (v: V) => V): (self: MutableHashMap<K, V>) => MutableHashMap<K, V>; <K, V>(self: MutableHashMap<K, V>, key: K, f: (v: V) => V): MutableHashMap<K, V>; }\n```\n\n----------------------------------------\n\nTITLE: Creating a Linear Schedule in Effect\nDESCRIPTION: This code snippet shows the declaration of the `linear` function within the `Schedule` module.  It takes a base duration as input and returns a schedule that produces durations. The delay increases linearly with each execution.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Schedule-linear.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const linear: (base: Duration.DurationInput) => Schedule<Duration.Duration>\n```\n\n----------------------------------------\n\nTITLE: Implementing Layer Suspension in TypeScript\nDESCRIPTION: Defines a function to lazily construct a Layer, preventing infinite recursion when creating layers that reference themselves. Takes a lazy evaluation function that returns a Layer and returns a new Layer with the same type parameters.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Layer-suspend.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const suspend: <RIn, E, ROut>(evaluate: LazyArg<Layer<ROut, E, RIn>>) => Layer<ROut, E, RIn>\n```\n\n----------------------------------------\n\nTITLE: Take.match Function Definition in Effect TS\nDESCRIPTION: The `Take.match` function allows you to pattern match on a `Take<A, E>` value. It takes an object with `onEnd`, `onFailure`, and `onSuccess` functions to handle the different states of the `Take` data structure.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Take-match.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const match: { <Z, E, Z2, A, Z3>(options: { readonly onEnd: () => Z; readonly onFailure: (cause: Cause.Cause<E>) => Z2; readonly onSuccess: (chunk: Chunk.Chunk<A>) => Z3; }): (self: Take<A, E>) => Z | Z2 | Z3; <A, E, Z, Z2, Z3>(self: Take<A, E>, options: { readonly onEnd: () => Z; readonly onFailure: (cause: Cause.Cause<E>) => Z2; readonly onSuccess: (chunk: Chunk.Chunk<A>) => Z3; }): Z | Z2 | Z3; }\n```\n\n----------------------------------------\n\nTITLE: Transforming Chunk Elements with Option Return Type in TypeScript\nDESCRIPTION: The filterMapWhile function transforms elements of a chunk as long as the specified function returns some value (a Some option). It stops processing once the function returns None. This is available in two call styles: curried and uncurried.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Chunk-filterMapWhile.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const filterMapWhile: { <A, B>(f: (a: A) => Option<B>): (self: Chunk<A>) => Chunk<B>; <A, B>(self: Chunk<A>, f: (a: A) => Option<B>): Chunk<B>; }\n```\n\n----------------------------------------\n\nTITLE: Implementing Metric Tracking in TypeScript with Effect.io\nDESCRIPTION: Defines a function that creates an aspect to track metrics based on successful effect completions. The function takes a metric and a transformation function as input, applying the transformation to successful values before updating the metric.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Metric-trackSuccessWith.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const trackSuccessWith: { \n  <Type, In, Out, In2>(\n    metric: Metric<Type, In, Out>, \n    f: (value: In2) => In\n  ): <A extends In2, E, R>(\n    self: Effect.Effect<A, E, R>\n  ) => Effect.Effect<A, E, R>; \n  <A extends In2, E, R, Type, In, Out, In2>(\n    self: Effect.Effect<A, E, R>, \n    metric: Metric<Type, In, Out>, \n    f: (value: In2) => In\n  ): Effect.Effect<A, E, R>; \n}\n```\n\n----------------------------------------\n\nTITLE: Repeating an Effect until None in TypeScript\nDESCRIPTION: Creates a stream that repeats an effect until it fails, specifically designed to drain an iterator. The method takes an iterator, invokes its 'next' method to retrieve values, and manages the streaming process with the Effect monad, ensuring proper error handling if the iteration completes.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-repeatEffectOption.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// In this example, we're draining an Iterator to create a stream from it\nimport { Stream, Effect, Option } from \"effect\"\n\nconst drainIterator = <A>(it: Iterator<A>): Stream.Stream<A> =>\n  Stream.repeatEffectOption(\n    Effect.sync(() => it.next()).pipe(\n      Effect.andThen((res) => {\n        if (res.done) {\n          return Effect.fail(Option.none())\n        }\n        return Effect.succeed(res.value)\n      })\n    )\n  )\n```\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const repeatEffectOption: <A, E, R>(effect: Effect.Effect<A, Option.Option<E>, R>) => Stream<A, E, R>\n```\n\n----------------------------------------\n\nTITLE: Removing Defects from a Cause Using a Partial Function in TypeScript\nDESCRIPTION: The stripSomeDefects function removes matching defects from a Cause using a partial function. It applies a user-defined extraction function to each defect (Die) and removes those that match. If all defects match, it returns None. Otherwise, it returns a Cause with the unmatched defects.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Cause-stripSomeDefects.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const stripSomeDefects: { (pf: (defect: unknown) => Option.Option<unknown>): <E>(self: Cause<E>) => Option.Option<Cause<E>>; <E>(self: Cause<E>, pf: (defect: unknown) => Option.Option<unknown>): Option.Option<Cause<E>>; }\n```\n\n----------------------------------------\n\nTITLE: PlatformLogger.toFile Function Signature\nDESCRIPTION: This snippet presents the TypeScript signature of the `PlatformLogger.toFile` function. It shows the function's parameters (path: string, options?: OpenFileOptions) and its return type (Effect<Logger.Logger<Message, void>, PlatformError, Scope | FileSystem>). The signature clarifies the function's input and output types within the Effect ecosystem.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/PlatformLogger-toFile.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const toFile: { (path: string, options?: (OpenFileOptions & { readonly batchWindow?: DurationInput | undefined; }) | undefined): <Message>(self: Logger.Logger<Message, string>) => Effect<Logger.Logger<Message, void>, PlatformError, Scope | FileSystem>; <Message>(self: Logger.Logger<Message, string>, path: string, options?: (OpenFileOptions & { readonly batchWindow?: DurationInput | undefined; }) | undefined): Effect<Logger.Logger<Message, void>, PlatformError, Scope | FileSystem>; }\n```\n\n----------------------------------------\n\nTITLE: Retrieving TestClock Service in TypeScript\nDESCRIPTION: Declares a function to retrieve the TestClock service for test scenarios, allowing precise control over time-based operations and scheduling\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TestClock-testClock.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const testClock: () => Effect.Effect<TestClock>\n```\n\n----------------------------------------\n\nTITLE: Retrieving Console Service from Context in Effect Module\nDESCRIPTION: The consoleWith function retrieves the Console service from the context and provides it to the specified effectful function. This allows for console operations within the Effect monad.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-consoleWith.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const consoleWith: <A, E, R>(f: (console: Console) => Effect<A, E, R>) => Effect<A, E, R>\n```\n\n----------------------------------------\n\nTITLE: Implementing Micro.repeat Function in TypeScript\nDESCRIPTION: Defines a repeat function that takes options for controlling repetition behavior of Micro effects. The function allows specifying a predicate condition, number of repetitions, and a schedule for the repetition. Only handles successful results for repetition.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Micro-repeat.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const repeat: { \n  <A, E>(options?: { \n    while?: Predicate<A> | undefined; \n    times?: number | undefined; \n    schedule?: MicroSchedule | undefined; \n  } | undefined): <R>(self: Micro<A, E, R>) => Micro<A, E, R>; \n  <A, E, R>(self: Micro<A, E, R>, options?: { \n    while?: Predicate<A> | undefined; \n    times?: number | undefined; \n    schedule?: MicroSchedule | undefined; \n  } | undefined): Micro<A, E, R>; \n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Choice Arguments in Effect CLI TypeScript\nDESCRIPTION: Function signature for creating a choice argument that allows selecting from predefined options. Takes an array of string-value pairs as choices and optional configuration parameters. Returns an Args instance of the selected type.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Args-choice.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const choice: <A>(choices: ReadonlyArray<[string, A]>, config?: Args.BaseArgsConfig) => Args<A>\n```\n\n----------------------------------------\n\nTITLE: Generating Random Numbers in a Range using TRandom in Effect.ts\nDESCRIPTION: Returns the next number within a specified minimum and maximum range from the pseudo-random number generator in an STM transaction context. This function is available since version 2.0.0 of the effect package.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TRandom-nextRange.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const nextRange: (min: number, max: number) => STM.STM<number, never, TRandom>\n```\n\n----------------------------------------\n\nTITLE: Declaring Delayed Schedule in Effect TS with TypeScript\nDESCRIPTION: The `delayedSchedule` function takes a schedule and modifies it to delay each interval based on its produced delays, allowing execution control. It is part of the Effect TS library, relying on the `Schedule` type. The function results in a new `Schedule` with the same input and output but altered execution timing.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Schedule-delayedSchedule.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const delayedSchedule: <In, R>(schedule: Schedule<Duration.Duration, In, R>) => Schedule<Duration.Duration, In, R>\n```\n\n----------------------------------------\n\nTITLE: Optimizing Document Nodes with @effect/printer in TypeScript\nDESCRIPTION: This snippet demonstrates the use of the `optimize` function from the '@effect/printer/Optimize' module to enhance the efficiency of document layouts by combining text nodes. It shows a comparison between inefficient and optimized document representations using the `Doc` module for creating document nodes. The `optimize` function accepts a `FusionDepth` for controlling optimization depth, and is crucial when handling numerous concatenated document fragments.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Optimize-optimize.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as Doc from \"@effect/printer/Doc\"\nimport * as Optimize from \"@effect/printer/Optimize\"\n\n// The document below contains a chain of four entries in the output `DocStream`\nconst inefficient = Doc.hsep([\n  Doc.char(\"a\"),\n  Doc.char(\"b\"),\n  Doc.char(\"c\"),\n  Doc.char(\"d\")\n])\n\n// However, the above document is fully equivalent to the tightly packed\n// document below which is only a single entry in the output `DocStream` and\n// can be processed much more efficiently.\nconst efficient = Doc.text(\"abcd\")\n\n// We can optimize the `inefficient` document using `Optimize`\nOptimize.optimize(Optimize.Deep)(inefficient)\n```\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const optimize: { (depth: FusionDepth): <A>(self: Doc<A>) => Doc<A>; <A>(self: Doc<A>, depth: FusionDepth): Doc<A>; }\n```\n\n----------------------------------------\n\nTITLE: Removing Entry from RedBlackTree in TypeScript\nDESCRIPTION: Function signature for removing the first entry with a specified key from a Red-Black Tree. Supports both curried and uncurried calling styles.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/RedBlackTree-removeFirst.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const removeFirst: { <K>(key: K): <V>(self: RedBlackTree<K, V>) => RedBlackTree<K, V>; <K, V>(self: RedBlackTree<K, V>, key: K): RedBlackTree<K, V>; }\n```\n\n----------------------------------------\n\nTITLE: Defining Type Simplification Logic in TypeScript\nDESCRIPTION: This snippet defines the logic behind the `Simplify` type utility function in TypeScript. It iteratively maps over the keys of the given type `A` and reconstructs the type by iterating over its keys. The utility outputs a single type, simplifying composite types without altering their structure.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Types-Simplify.md#2025-04-11_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\ntype Simplify<A> = {\n  [K in keyof A]: A[K]\n} extends infer B ? B : never\n```\n\n----------------------------------------\n\nTITLE: Creating a Sink to Extract the First Value in Effect (TypeScript)\nDESCRIPTION: The `Sink.head` function creates a sink that extracts the first value from a stream. It returns a `Sink` that processes input values (`In`) and produces an `Option<In>`, which will be `Some(value)` if there's a first element or `None` if the stream is empty. This function is part of the `effect` library and requires the `Sink` and `Option` modules.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Sink-head.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const head: <In>() => Sink<Option.Option<In>, In, In>\n```\n\n----------------------------------------\n\nTITLE: Storing Values in Transactional Maps with TMap.set in TypeScript\nDESCRIPTION: The set function stores a new key-value binding into a transactional map. It can be used in two ways: curried (providing key and value first, then the map) or with all parameters at once. Returns an STM effect that completes the operation.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TMap-set.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const set: { <K, V>(key: K, value: V): (self: TMap<K, V>) => STM.STM<void>; <K, V>(self: TMap<K, V>, key: K, value: V): STM.STM<void>; }\n```\n\n----------------------------------------\n\nTITLE: Creating SortedSet from Iterable in TypeScript\nDESCRIPTION: Function that creates a new SortedSet from an iterable collection of values. It requires an Order object to determine the sorting of elements. The function has two overloads to provide flexibility in parameter ordering.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/SortedSet-fromIterable.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const fromIterable: { <B>(ord: Order<B>): <A extends B>(iterable: Iterable<A>) => SortedSet<A>; <A extends B, B>(iterable: Iterable<A>, ord: Order<B>): SortedSet<A>; }\n```\n\n----------------------------------------\n\nTITLE: Implementing Paginated Stream Creation in TypeScript\nDESCRIPTION: The paginateChunk function creates a stream that unfolds a state, emitting chunks of values and potentially ending one step after the state unfolding. It's particularly useful for working with paginated APIs.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-paginateChunk.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const paginateChunk: <S, A>(s: S, f: (s: S) => readonly [Chunk.Chunk<A>, Option.Option<S>]) => Stream<A>\n```\n\n----------------------------------------\n\nTITLE: HashSet.forEach Type Signature in TypeScript\nDESCRIPTION: Shows the type signature for the HashSet.forEach function. It provides both data-first and data-last (pipeable) overloads for the function.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/HashSet-forEach.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const forEach: { <A>(f: (value: A) => void): (self: HashSet<A>) => void; <A>(self: HashSet<A>, f: (value: A) => void): void; }\n```\n\n----------------------------------------\n\nTITLE: Running Effect into Mailbox - TypeScript Implementation\nDESCRIPTION: Function signature for running an Effect into a Mailbox where success completes the mailbox and failure fails it. The function supports both curried and uncurried forms, allowing flexible usage patterns.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Mailbox-into.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const into: { \n  <A, E>(self: Mailbox<A, E>): <AX, EX extends E, RX>(effect: Effect<AX, EX, RX>) => Effect<boolean, never, RX>; \n  <AX, E, EX extends E, RX, A>(effect: Effect<AX, EX, RX>, self: Mailbox<A, E>): Effect<boolean, never, RX>; \n}\n```\n\n----------------------------------------\n\nTITLE: Creating Elapsed Time Schedule in TypeScript\nDESCRIPTION: The 'elapsed' schedule function continuously tracks the total duration since its initiation, making it useful for monitoring execution time and delays.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Schedule-elapsed.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const elapsed: Schedule<Duration.Duration, unknown, never>\n```\n\n----------------------------------------\n\nTITLE: Creating a HashSet from another HashSet in TypeScript\nDESCRIPTION: Shows how to create a new HashSet from an existing HashSet. This works because HashSet implements the Iterable interface, making it compatible with fromIterable.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/HashSet-fromIterable.md#2025-04-11_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\n//  Creating a HashSet from another HashSet\nimport { HashSet, pipe } from \"effect\"\n\nconsole.log(\n  pipe(\n    // since HashSet implements the Iterable interface, we can use it to create a new HashSet\n    HashSet.make(1, 2, 3, 4),\n    HashSet.fromIterable,\n    HashSet.toValues // turns the HashSet back into an array\n  )\n) // Output: [1, 2, 3, 4]\n```\n\n----------------------------------------\n\nTITLE: Implementing Lazy Sink Construction with Sink.suspend in TypeScript\nDESCRIPTION: Declares a function that enables lazy construction of Sink instances that may require effects for their creation. The function takes a lazy argument that evaluates to a Sink and returns a Sink with the same type parameters.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Sink-suspend.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const suspend: <A, In, L, E, R>(evaluate: LazyArg<Sink<A, In, L, E, R>>) => Sink<A, In, L, E, R>\n```\n\n----------------------------------------\n\nTITLE: Implementing splitNonEmptyAt Function in TypeScript\nDESCRIPTION: Function declaration for splitting a NonEmptyChunk into two segments. Takes a number parameter n (>= 1) and returns a tuple containing the first n elements and the remaining elements. The first segment is guaranteed to be non-empty while the second segment may be empty.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Chunk-splitNonEmptyAt.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const splitNonEmptyAt: { \n  (n: number): <A>(self: NonEmptyChunk<A>) => [beforeIndex: NonEmptyChunk<A>, fromIndex: Chunk<A>]; \n  <A>(self: NonEmptyChunk<A>, n: number): [beforeIndex: NonEmptyChunk<A>, fromIndex: Chunk<A>]; \n}\n```\n\n----------------------------------------\n\nTITLE: Creating a NonEmptyChunk using Chunk.make in TypeScript\nDESCRIPTION: The make function builds a NonEmptyChunk from a non-empty collection of elements. It accepts variadic arguments and ensures the chunk will contain at least one element through the type system.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Chunk-make.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const make: <As extends readonly [any, ...ReadonlyArray<any>]>(...as: As) => NonEmptyChunk<As[number]>\n```\n\n----------------------------------------\n\nTITLE: Interrupting a Deferred with Fiber ID in Effect-TS Library\nDESCRIPTION: This function completes a Deferred with interruption, interrupting all fibers waiting on the value of the Deferred with the FiberId of the fiber calling this method. It returns an Effect that resolves to a boolean value.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Deferred-interrupt.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const interrupt: <A, E>(self: Deferred<A, E>) => Effect.Effect<boolean>\n```\n\n----------------------------------------\n\nTITLE: Effect.catchSomeDefect Function Signature in TypeScript\nDESCRIPTION: This code snippet shows the TypeScript signature of the Effect.catchSomeDefect function. It illustrates the function's type parameters and overloads, providing insight into its usage with different argument orders.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-catchSomeDefect.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const catchSomeDefect: { <A2, E2, R2>(pf: (defect: unknown) => Option.Option<Effect<A2, E2, R2>>): <A, E, R>(self: Effect<A, E, R>) => Effect<A2 | A, E2 | E, R2 | R>; <A, E, R, A2, E2, R2>(self: Effect<A, E, R>, pf: (defect: unknown) => Option.Option<Effect<A2, E2, R2>>): Effect<A | A2, E | E2, R | R2>; }\n```\n\n----------------------------------------\n\nTITLE: TypeScript Function Signature for Effect.cached\nDESCRIPTION: The TypeScript type signature for the Effect.cached function, showing how it takes an Effect and returns an Effect that produces a cached Effect.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-cached.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const cached: <A, E, R>(self: Effect<A, E, R>) => Effect<Effect<A, E, R>>\n```\n\n----------------------------------------\n\nTITLE: Implementing a Sink that processes chunks of data using Effect in TypeScript\nDESCRIPTION: Creates a sink that executes the provided effectful function for every chunk fed to it. The function takes a chunk of input data and returns an Effect, allowing for side effects to be performed on each chunk of data flowing through the sink.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Sink-forEachChunk.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const forEachChunk: <In, X, E, R>(f: (input: Chunk.Chunk<In>) => Effect.Effect<X, E, R>) => Sink<void, In, never, E, R>\n```\n\n----------------------------------------\n\nTITLE: Using DateTime.withCurrentZoneOffset with Effect in TypeScript\nDESCRIPTION: Demonstrates how to use the DateTime.withCurrentZoneOffset function to set a specific time zone offset for date/time operations. This example creates an effect that gets the current time in the system's local time zone, then applies a custom offset of 3 hours (in milliseconds).\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/DateTime-withCurrentZoneOffset.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { DateTime, Effect } from \"effect\"\n\nEffect.gen(function* () {\n  // will use the system's local time zone\n  const now = yield* DateTime.nowInCurrentZone\n}).pipe(DateTime.withCurrentZoneOffset(3 * 60 * 60 * 1000))\n```\n\n----------------------------------------\n\nTITLE: Defining UnknownException Interface in TypeScript\nDESCRIPTION: Interface definition for handling unknown or unexpected errors. It extends YieldableError and includes properties for type identification and capturing unknown error objects. This is useful for wrapping low-level or third-party library errors with minimal context.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Cause-UnknownException.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface UnknownException extends YieldableError {\n  readonly _tag: \"UnknownException\"\n  readonly [UnknownExceptionTypeId]: UnknownExceptionTypeId\n  readonly error: unknown\n}\n```\n\n----------------------------------------\n\nTITLE: Type Signature for Stream.paginate Function in TypeScript\nDESCRIPTION: This code snippet shows the type signature of the `Stream.paginate` function. It takes an initial state of type S and a function that produces a tuple of the current value and an optional next state.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-paginate.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const paginate: <S, A>(s: S, f: (s: S) => readonly [A, Option.Option<S>]) => Stream<A>\n```\n\n----------------------------------------\n\nTITLE: Creating Boolean Config in Effect\nDESCRIPTION: Constructs a configuration object for handling boolean values. The function accepts an optional name parameter and returns a Config instance typed for boolean values.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Config-boolean.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const boolean: (name?: string) => Config<boolean>\n```\n\n----------------------------------------\n\nTITLE: Defining CacheStats Interface in TypeScript\nDESCRIPTION: Interface definition for tracking cache performance metrics in Effect library. Represents a point-in-time snapshot of cache statistics including the number of cache hits, misses, and current cache size.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Cache-CacheStats.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface CacheStats {\n  readonly hits: number\n  readonly misses: number\n  readonly size: number\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Synchronous Configuration with Config.sync in TypeScript\nDESCRIPTION: This function constructs a configuration object containing a specified lazy value. It allows for synchronous creation of configs without side effects.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Config-sync.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const sync: <A>(value: LazyArg<A>) => Config<A>\n```\n\n----------------------------------------\n\nTITLE: Creating a Layer from Time Zone Offset in DateTime Module\nDESCRIPTION: This function creates a Layer from a given time zone offset. It is used for providing the CurrentTimeZone context to Effect applications, allowing timezone-aware date/time operations.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/DateTime-layerCurrentZoneOffset.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const layerCurrentZoneOffset: (offset: number) => Layer.Layer<CurrentTimeZone>\n```\n\n----------------------------------------\n\nTITLE: Stream.onStart Function Signature in TypeScript\nDESCRIPTION: This code block presents the TypeScript signature for the Stream.onStart function. It shows the function's type definition, including its parameters and return types.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-onStart.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const onStart: { <_, E2, R2>(effect: Effect.Effect<_, E2, R2>): <A, E, R>(self: Stream<A, E, R>) => Stream<A, E2 | E, R2 | R>; <A, E, R, _, E2, R2>(self: Stream<A, E, R>, effect: Effect.Effect<_, E2, R2>): Stream<A, E | E2, R | R2>; }\n```\n\n----------------------------------------\n\nTITLE: Implementing Config.mapOrFail Function in TypeScript\nDESCRIPTION: Declares a function that returns a new config with the same structure but potentially different values. It applies a fallible mapping function that returns Either<B, ConfigError>.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Config-mapOrFail.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const mapOrFail: { <A, B>(f: (a: A) => Either.Either<B, ConfigError.ConfigError>): (self: Config<A>) => Config<B>; <A, B>(self: Config<A>, f: (a: A) => Either.Either<B, ConfigError.ConfigError>): Config<B>; }\n```\n\n----------------------------------------\n\nTITLE: Converting Option Values to Option Errors in STM - TypeScript\nDESCRIPTION: The 'some' function in the STM module converts an option on values into an option on errors. It returns an STM instance with the specified type transformation. This function assumes the presence of the Option and STM types, typically available through the Effect-TS libraries. The primary parameters include 'self' which is an STM encapsulating an option on a value, and the function alters the STM structure to focus on error options instead. The function requires the Effect-TS library dependencies and targets scenarios where type-safe transactional operations are necessary.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/STM-some.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const some: <A, E, R>(self: STM<Option.Option<A>, E, R>) => STM<A, Option.Option<E>, R>\n```\n\n----------------------------------------\n\nTITLE: Implementing flatMap Function for Micro Effects in TypeScript\nDESCRIPTION: Defines a flatMap function that transforms a Micro effect by mapping its success value to another Micro effect and flattening the result. The function supports both curried and uncurried forms, handling error types E and E2, and requirement types R and R2.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Micro-flatMap.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const flatMap: { \n  <A, B, E2, R2>(f: (a: A) => Micro<B, E2, R2>): <E, R>(self: Micro<A, E, R>) => Micro<B, E | E2, R | R2>; \n  <A, E, R, B, E2, R2>(self: Micro<A, E, R>, f: (a: A) => Micro<B, E2, R2>): Micro<B, E | E2, R | R2>; \n}\n```\n\n----------------------------------------\n\nTITLE: Command.pipeTo Function TypeScript Definition\nDESCRIPTION: TypeScript signature for the Command.pipeTo function which allows piping commands together. The function supports both curried and non-curried calling styles for piping one command's output to another.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Command-pipeTo.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const pipeTo: { (into: Command): (self: Command) => Command; (self: Command, into: Command): Command; }\n```\n\n----------------------------------------\n\nTITLE: Stream.fromPull signature in TypeScript\nDESCRIPTION: Defines the signature of the `fromPull` function in TypeScript. This function takes an effect that produces an effect which yields a chunk of elements or signals the end of the stream. It returns a `Stream` of elements, with potential errors and resource requirements.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-fromPull.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const fromPull: <R, R2, E, A>(effect: Effect.Effect<Effect.Effect<Chunk.Chunk<A>, Option.Option<E>, R2>, never, Scope.Scope | R>) => Stream<A, E, R2 | Exclude<R, Scope.Scope>>\n```\n\n----------------------------------------\n\nTITLE: Defining filterOrFail Function for HttpClient in TypeScript\nDESCRIPTION: Declares a function that filters the result of an HTTP response or throws an error if the predicate fails. It can be used in two ways: as a higher-order function or directly with an HttpClient instance.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/HttpClient-filterOrFail.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const filterOrFail: { <E2>(predicate: Predicate.Predicate<ClientResponse.HttpClientResponse>, orFailWith: (response: ClientResponse.HttpClientResponse) => E2): <E, R>(self: HttpClient.With<E, R>) => HttpClient.With<E2 | E, R>; <E, R, E2>(self: HttpClient.With<E, R>, predicate: Predicate.Predicate<ClientResponse.HttpClientResponse>, orFailWith: (response: ClientResponse.HttpClientResponse) => E2): HttpClient.With<E2 | E, R>; }\n```\n\n----------------------------------------\n\nTITLE: Acquiring Read Lock in TReentrantLock with STM in TypeScript\nDESCRIPTION: Acquires a read lock in a transactional manner. The transaction will suspend until no other fiber is holding a write lock. Returns the number of read locks held by the calling fiber.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TReentrantLock-acquireRead.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const acquireRead: (self: TReentrantLock) => STM.STM<number>\n```\n\n----------------------------------------\n\nTITLE: Dropping Elements Until Effectful Predicate Returns True - TypeScript\nDESCRIPTION: This snippet defines the dropUntilEffect function which drops elements from the stream until the provided effectful predicate evaluates to true. It uses TypeScript generics to ensure type safety for various input types. The function signature indicates that it can be called either with a predicate first or with both stream and predicate together.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-dropUntilEffect.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const dropUntilEffect: { <A, E2, R2>(predicate: (a: NoInfer<A>) => Effect.Effect<boolean, E2, R2>): <E, R>(self: Stream<A, E, R>) => Stream<A, E2 | E, R2 | R>; <A, E, R, E2, R2>(self: Stream<A, E, R>, predicate: (a: NoInfer<A>) => Effect.Effect<boolean, E2, R2>): Stream<A, E | E2, R | R2>; }\n```\n\n----------------------------------------\n\nTITLE: Creating Constant Functions with Function.constant in TypeScript\nDESCRIPTION: Demonstrates how to use the constant function to create a function that always returns the same value. It shows an example of creating a constant null function and asserting its behavior.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Function-constant.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { constant } from \"effect/Function\"\n\nconst constNull = constant(null)\n\nassert.deepStrictEqual(constNull(), null)\nassert.deepStrictEqual(constNull(), null)\n```\n\n----------------------------------------\n\nTITLE: DateTime.subtract Method Signature\nDESCRIPTION: The function signature for the DateTime.subtract method, showing it accepts a partial PartsForMath object and can be used with pipe or called directly with parameters.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/DateTime-subtract.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const subtract: { (parts: Partial<DateTime.PartsForMath>): <A extends DateTime>(self: A) => A; <A extends DateTime>(self: A, parts: Partial<DateTime.PartsForMath>): A; }\n```\n\n----------------------------------------\n\nTITLE: STM: Checking if STM is a Failure in Typescript\nDESCRIPTION: This code snippet defines the `isFailure` function which takes an STM effect as input and returns another STM effect that resolves to a boolean indicating whether the input STM effect is a failure. The return type STM effect never fails, and has the same environment R as the original STM effect.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/STM-isFailure.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const isFailure: <A, E, R>(self: STM<A, E, R>) => STM<boolean, never, R>\n```\n\n----------------------------------------\n\nTITLE: Effectfully Transforming Input and Output Chunks in TypeScript\nDESCRIPTION: The 'dimapChunksEffect' function transforms both input chunks and result of a sink using specified transformation functions. It enforces chunking-invariance through its implementation. The function takes parameters for input transformation and result-handling; it returns a modified Sink instance that processes the data accordingly.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Sink-dimapChunksEffect.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const dimapChunksEffect: { <In0, In, E2, R2, A, A2, E3, R3>(options: { readonly onInput: (chunk: Chunk.Chunk<In0>) => Effect.Effect<Chunk.Chunk<In>, E2, R2>; readonly onDone: (a: A) => Effect.Effect<A2, E3, R3>; }): <L, E, R>(self: Sink<A, In, L, E, R>) => Sink<A2, In0, L, E2 | E3 | E, R2 | R3 | R>; <A, In, L, E, R, In0, E2, R2, A2, E3, R3>(self: Sink<A, In, L, E, R>, options: { readonly onInput: (chunk: Chunk.Chunk<In0>) => Effect.Effect<Chunk.Chunk<In>, E2, R2>; readonly onDone: (a: A) => Effect.Effect<A2, E3, R3>; }): Sink<A2, In0, L, E | E2 | E3, R | R2 | R3>; }\n```\n\n----------------------------------------\n\nTITLE: Declaring Command.string Function in TypeScript\nDESCRIPTION: Defines a function that runs a command and returns its entire output as a string with the specified encoding. If no encoding is provided, it defaults to 'utf-8'. The function can be called with either curried or regular parameter order.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Command-string.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const string: { (encoding?: string): (command: Command) => Effect<string, PlatformError, CommandExecutor>; (command: Command, encoding?: string): Effect<string, PlatformError, CommandExecutor>; }\n```\n\n----------------------------------------\n\nTITLE: Terminating a Deferred with a Defect in TypeScript\nDESCRIPTION: The `die` function kills a Deferred with a specified defect that propagates to all fibers waiting on the Deferred's value. It returns an Effect that resolves to a boolean indicating the operation result.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Deferred-die.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const die: { (defect: unknown): <A, E>(self: Deferred<A, E>) => Effect.Effect<boolean>; <A, E>(self: Deferred<A, E>, defect: unknown): Effect.Effect<boolean>; }\n```\n\n----------------------------------------\n\nTITLE: Declaring STM.tap Function in TypeScript\nDESCRIPTION: The STM.tap function allows users to 'peek' at the success of a transactional effect by taking a function and returning a transactional effect that combines results. This function supports two signatures to allow flexibility in usage. It generally requires the Effect-TS library and is a part of its STM module.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/STM-tap.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const tap: { <A, X, E2, R2>(f: (a: A) => STM<X, E2, R2>): <E, R>(self: STM<A, E, R>) => STM<A, E2 | E, R2 | R>; <A, E, R, X, E2, R2>(self: STM<A, E, R>, f: (a: A) => STM<X, E2, R2>): STM<A, E | E2, R | R2>; }\n```\n\n----------------------------------------\n\nTITLE: Signature of Option.flatMap in TypeScript's Effect Library\nDESCRIPTION: Provides the TypeScript declaration of the `flatMap` function in the Effect library's `Option` module. This signature outlines that `flatMap` can operate in two styles: applying a function to a self-contained `Option` or accepting a separate function and `Option` value as arguments. Both styles return an `Option` type, based on the function's result.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Option-flatMap.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const flatMap: { <A, B>(f: (a: A) => Option<B>): (self: Option<A>) => Option<B>; <A, B>(self: Option<A>, f: (a: A) => Option<B>): Option<B>; }\n```\n\n----------------------------------------\n\nTITLE: Declaring ANSI Cursor Restore Position Function in TypeScript\nDESCRIPTION: Defines a constant for restoring the cursor position along with shift state and formatting attributes. If no previous save exists, it resets these attributes to their defaults.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Ansi-cursorRestorePosition.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const cursorRestorePosition: Ansi\n```\n\n----------------------------------------\n\nTITLE: Implementing Bounded.between function in TypeScript\nDESCRIPTION: This function checks if a value is between the lower and upper limit of a bound. It takes a Bounded<A> instance and returns a function that accepts a value of type A and returns a boolean.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Bounded-between.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const between: <A>(B: Bounded<A>) => (a: A) => boolean\n```\n\n----------------------------------------\n\nTITLE: Obtaining a read lock in a scoped context with TReentrantLock in TypeScript\nDESCRIPTION: This function obtains a read lock on a reentrant lock in a scoped context. It returns an Effect that resolves to a number, has no error channel, and requires a Scope context. The returned number likely represents a lock acquisition count or identifier.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TReentrantLock-readLock.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const readLock: (self: TReentrantLock) => Effect.Effect<number, never, Scope.Scope>\n```\n\n----------------------------------------\n\nTITLE: Finding First Value with Partial Function in TypeScript\nDESCRIPTION: The collectFirst function applies a partial function to the first element in a TArray. It can be used in two ways: as a curried function taking a partial function and then the TArray, or as a function taking both arguments at once. This function returns an STM that resolves to an Option containing the result of the partial function application.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TArray-collectFirst.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const collectFirst: { <A, B>(pf: (a: A) => Option.Option<B>): (self: TArray<A>) => STM.STM<Option.Option<B>>; <A, B>(self: TArray<A>, pf: (a: A) => Option.Option<B>): STM.STM<Option.Option<B>>; }\n```\n\n----------------------------------------\n\nTITLE: Declaring the Separate Function Signature in TypeScript\nDESCRIPTION: This snippet outlines the TypeScript signature for the 'separate' function. It accepts a record comprising 'Either' values and returns a tuple of two records. The returned records are divided into 'Left' and 'Right' records based on the structure of the input.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Record-separate.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const separate: <K extends string, A, B>(self: ReadonlyRecord<K, Either<B, A>>) => [Record<ReadonlyRecord.NonLiteralKey<K>, A>, Record<ReadonlyRecord.NonLiteralKey<K>, B>]\n```\n\n----------------------------------------\n\nTITLE: Array.rotate Example Usage in TypeScript\nDESCRIPTION: Demonstrates how to use the Array.rotate function to rotate elements in an array by a specified number of positions. The example shows rotating an array of strings by 2 positions.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Array-rotate.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Array } from \"effect\"\n\nconst result = Array.rotate(['a', 'b', 'c', 'd'], 2)\nconsole.log(result) // ['c', 'd', 'a', 'b']\n```\n\n----------------------------------------\n\nTITLE: Checking if a value is a Context object in TypeScript\nDESCRIPTION: The isContext function determines whether the provided argument is a Context object. It returns a boolean indicating the result, with type narrowing for TypeScript.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Context-isContext.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { Context } from \"effect\"\n\nassert.strictEqual(Context.isContext(Context.empty()), true)\n```\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const isContext: (input: unknown) => input is Context<never>\n```\n\n----------------------------------------\n\nTITLE: Type Signature for mapFirst Function in TypeScript\nDESCRIPTION: This code snippet provides the type signature for the `mapFirst` function. It supports two different styles of invocation: one where the function is curried and another where both the tuple and the function are provided at once. This allows for flexible usage depending on the developer's preference.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Tuple-mapFirst.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const mapFirst: { <L1, L2>(f: (left: L1) => L2): <R>(self: readonly [L1, R]) => [L2, R]; <L1, R, L2>(self: readonly [L1, R], f: (left: L1) => L2): [L2, R]; }\n```\n\n----------------------------------------\n\nTITLE: Removing Cookies in Effect Platform TypeScript\nDESCRIPTION: Function signature for removing a cookie by name from the Cookies object. Provides two call signatures - one curried and one direct with two parameters.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Cookies-remove.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const remove: { (name: string): (self: Cookies) => Cookies; (self: Cookies, name: string): Cookies; }\n```\n\n----------------------------------------\n\nTITLE: Running an Effect and Managing its Fiber with FiberHandle in TypeScript\nDESCRIPTION: The run function executes an Effect and adds the forked fiber to a FiberHandle. When the fiber completes, it's automatically removed from the FiberHandle. Options allow controlling when fibers should be added and how interruption propagates.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/FiberHandle-run.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const run: { <A, E>(self: FiberHandle<A, E>, options?: { readonly onlyIfMissing?: boolean; readonly propagateInterruption?: boolean | undefined; }): <R, XE extends E, XA extends A>(effect: Effect.Effect<XA, XE, R>) => Effect.Effect<Fiber.RuntimeFiber<XA, XE>, never, R>; <A, E, R, XE extends E, XA extends A>(self: FiberHandle<A, E>, effect: Effect.Effect<XA, XE, R>, options?: { readonly onlyIfMissing?: boolean; readonly propagateInterruption?: boolean | undefined; }): Effect.Effect<Fiber.RuntimeFiber<XA, XE>, never, R>; }\n```\n\n----------------------------------------\n\nTITLE: Defining CommandInput Type for Process stdin Configuration in TypeScript\nDESCRIPTION: Defines the CommandInput type used to configure the pipe between parent and child processes' stdin streams. It can be set to 'inherit', 'pipe', or a Stream of Uint8Array with PlatformError. The default value is 'pipe'.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Command-CommandInput.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ntype CommandInput = \"inherit\" | \"pipe\" | Stream<Uint8Array, PlatformError>\n```\n\n----------------------------------------\n\nTITLE: Implementing List.partitionMap Function in TypeScript\nDESCRIPTION: This function partitions a list into two lists based on a specified function that returns Either<C, B>. The first list contains elements that resulted in Left, and the second list contains elements that resulted in Right.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/List-partitionMap.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const partitionMap: { <A, B, C>(f: (a: A) => Either.Either<C, B>): (self: List<A>) => [left: List<B>, right: List<C>]; <A, B, C>(self: List<A>, f: (a: A) => Either.Either<C, B>): [left: List<B>, right: List<C>]; }\n```\n\n----------------------------------------\n\nTITLE: Defining CauseReducer Interface in TypeScript\nDESCRIPTION: Interface definition for CauseReducer that transforms Cause<E> into type Z. It includes methods for handling empty cases, failures, defects, interruptions, and both sequential and parallel combinations. Each method receives context of type C and returns type Z.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Cause-CauseReducer.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface CauseReducer<in C, in E, in out Z> {\n  emptyCase(context: C): Z\n  failCase(context: C, error: E): Z\n  dieCase(context: C, defect: unknown): Z\n  interruptCase(context: C, fiberId: FiberId.FiberId): Z\n  sequentialCase(context: C, left: Z, right: Z): Z\n  parallelCase(context: C, left: Z, right: Z): Z\n}\n```\n\n----------------------------------------\n\nTITLE: Applying forEach to Trie Entries in TypeScript\nDESCRIPTION: Demonstrates how to use Trie.forEach to iterate over entries in a Trie data structure. The function applies a callback to each entry, accumulating a value based on the entry's value and key length.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Trie-forEach.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { Trie } from \"effect\"\n\nlet value = 0\n\nTrie.empty<number>().pipe(\n  Trie.insert(\"shells\", 0),\n  Trie.insert(\"sells\", 1),\n  Trie.insert(\"she\", 2),\n  Trie.forEach((n, key) => {\n    value += n + key.length\n  })\n)\n\nassert.equal(value, 17)\n```\n\n----------------------------------------\n\nTITLE: Filtering TMap Entries with retainIf Function in TypeScript\nDESCRIPTION: The retainIf function retains entries in a TMap that satisfy a specified predicate function and returns the removed entries. It has an option to discard removed entries instead of returning them. The function operates within an STM transaction context.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TMap-retainIf.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const retainIf: { <K, V>(predicate: (key: K, value: V) => boolean, options: { readonly discard: true; }): (self: TMap<K, V>) => STM.STM<void>; <K, V>(predicate: (key: K, value: V) => boolean, options?: { readonly discard: false; }): (self: TMap<K, V>) => STM.STM<Array<[K, V]>>; <K, V>(self: TMap<K, V>, predicate: (key: K, value: V) => boolean, options: { readonly discard: true; }): STM.STM<void>; <K, V>(self: TMap<K, V>, predicate: (key: K, value: V) => boolean, options?: { readonly discard: false; }): STM.STM<Array<[K, V]>>; }\n```\n\n----------------------------------------\n\nTITLE: Creating HashMap Differs in TypeScript with effect/Differ\nDESCRIPTION: Constructs a differ that knows how to diff a `HashMap` of keys and values given a differ that knows how to diff the values. This function is available since version 2.0.0 of the effect package.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Differ-hashMap.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const hashMap: <Key, Value, Patch>(differ: Differ<Value, Patch>) => Differ<HashMap<Key, Value>, Differ.HashMap.Patch<Key, Value, Patch>>\n```\n\n----------------------------------------\n\nTITLE: Defining Stream.refineOrDieWith TypeScript Function\nDESCRIPTION: A type-level function for selectively handling stream errors by allowing partial error refinement and conversion to defects. Provides granular control over error processing in stream operations.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-refineOrDieWith.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const refineOrDieWith: { <E, E2>(pf: (error: E) => Option.Option<E2>, f: (error: E) => unknown): <A, R>(self: Stream<A, E, R>) => Stream<A, E2, R>; <A, E, R, E2>(self: Stream<A, E, R>, pf: (error: E) => Option.Option<E2>, f: (error: E) => unknown): Stream<A, E2, R>; }\n```\n\n----------------------------------------\n\nTITLE: Implementing Request.succeed in TypeScript for Effect\nDESCRIPTION: Function signature for the succeed method that completes a Request with the specified value. It can be used in two forms: either by passing the value first or by passing the request object first.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Request-succeed.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const succeed: { <A extends Request<any, any>>(value: Request.Success<A>): (self: A) => Effect.Effect<void>; <A extends Request<any, any>>(self: A, value: Request.Success<A>): Effect.Effect<void>; }\n```\n\n----------------------------------------\n\nTITLE: Type Signature for Either.isRight Function\nDESCRIPTION: The TypeScript type signature for the isRight function, which takes an Either<R, L> and returns a type predicate indicating whether the input is a Right<L, R>.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Either-isRight.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const isRight: <R, L>(self: Either<R, L>) => self is Right<L, R>\n```\n\n----------------------------------------\n\nTITLE: Creating ConfigProvider from Flat Structure in TypeScript\nDESCRIPTION: Function signature for creating a new ConfigProvider from a flat key/value provider where nested configuration is represented in dot-notation string keys. Used to transform flat configuration into hierarchical config structure.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/ConfigProvider-fromFlat.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const fromFlat: (flat: ConfigProvider.Flat) => ConfigProvider\n```\n\n----------------------------------------\n\nTITLE: Converting Option to Exit in TypeScript\nDESCRIPTION: The fromOption function converts an Option<A> into an Exit<void, A>. This utility function helps transform optional values into the Exit type system used throughout the Effect library.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Exit-fromOption.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const fromOption: <A>(option: Option.Option<A>) => Exit<A, void>\n```\n\n----------------------------------------\n\nTITLE: Defining Metric.tagged Function in TypeScript\nDESCRIPTION: Declares the tagged function for the Metric module. This function returns a new metric with additional tags. It can be called with either the metric as the first argument or as a curried function.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Metric-tagged.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const tagged: { <Type, In, Out>(key: string, value: string): (self: Metric<Type, In, Out>) => Metric<Type, In, Out>; <Type, In, Out>(self: Metric<Type, In, Out>, key: string, value: string): Metric<Type, In, Out>; }\n```\n\n----------------------------------------\n\nTITLE: Defining trackDurationWith Function in TypeScript for Effect Metric Tracking\nDESCRIPTION: This code snippet defines the trackDurationWith function, which returns an aspect to update a metric with the duration of effect execution. It requires a function to convert Duration to the metric's input type.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Metric-trackDurationWith.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const trackDurationWith: {\n  <Type, In, Out>(metric: Metric<Type, In, Out>, f: (duration: Duration.Duration) => In):\n    <A, E, R>(effect: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>;\n  <A, E, R, Type, In, Out>(self: Effect.Effect<A, E, R>, metric: Metric<Type, In, Out>, f: (duration: Duration.Duration) => In):\n    Effect.Effect<A, E, R>;\n}\n```\n\n----------------------------------------\n\nTITLE: Stream Ensuring Function Signature in TypeScript\nDESCRIPTION: This code presents the TypeScript signature for the `ensuring` function from the 'effect' package's Stream module. It allows attaching a finalizer to a stream, which will execute after the stream and any of its internal finalizers complete. The signature supports a flexible combination of input stream and finalizer stream, taking into account potential dependencies and resource requirements.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-ensuring.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const ensuring: { <X, R2>(finalizer: Effect.Effect<X, never, R2>): <A, E, R>(self: Stream<A, E, R>) => Stream<A, E, R2 | R>; <A, E, R, X, R2>(self: Stream<A, E, R>, finalizer: Effect.Effect<X, never, R2>): Stream<A, E, R | R2>; }\n\n```\n\n----------------------------------------\n\nTITLE: Defining modifyAt Function for HashMap in TypeScript\nDESCRIPTION: The modifyAt function is used to set or remove a specified key in a HashMap. It takes a key, an update function, and the HashMap itself as parameters. The update function is called with the current value of the key (or None if it doesn't exist) to determine the new state of the key-value pair.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/HashMap-modifyAt.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const modifyAt: { <K, V>(key: K, f: HashMap.UpdateFn<V>): (self: HashMap<K, V>) => HashMap<K, V>; <K, V>(self: HashMap<K, V>, key: K, f: HashMap.UpdateFn<V>): HashMap<K, V>; }\n```\n\n----------------------------------------\n\nTITLE: Defining Cause.Fail Interface in TypeScript\nDESCRIPTION: TypeScript interface definition for Cause.Fail, which represents an expected error within a Cause. The interface extends Cause.Variance<E>, Equal.Equal, Pipeable, and Inspectable, providing error handling functionality with type safety.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Cause-Fail.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface Fail<out E> extends Cause.Variance<E>, Equal.Equal, Pipeable, Inspectable {\n  readonly _tag: \"Fail\"\n  readonly error: E\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Sink with Error Cause in TypeScript\nDESCRIPTION: This TypeScript snippet defines the `failCause` function, which creates a sink that always halts with a specified error cause. It is useful in scenarios where precise control over error handling is needed within the Effect TS library. The function's parameter `cause` specifies the error cause, and it returns a sink configured to handle this cause.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Sink-failCause.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const failCause: <E>(cause: Cause.Cause<E>) => Sink<never, unknown, never, E>\n```\n\n----------------------------------------\n\nTITLE: Defining dropWhileEffect Function - TypeScript\nDESCRIPTION: The 'dropWhileEffect' function takes a predicate as an argument and returns a Sink that processes elements based on whether the predicate condition is met. It requires TypeScript generics for input type, error type, and the context type associated with the effect. The function signature indicates that it will return a Sink that can handle inputs of the specified type.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Sink-dropWhileEffect.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const dropWhileEffect: <In, E, R>(predicate: (input: In) => Effect.Effect<boolean, E, R>) => Sink<unknown, In, In, E, R>\n```\n\n----------------------------------------\n\nTITLE: Creating Exit.Failure from Cause in TypeScript\nDESCRIPTION: The failCause function constructs a new Exit.Failure from a specified Cause of type E. It's used for handling failure cases in the Effect system.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Exit-failCause.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const failCause: <E>(cause: Cause.Cause<E>) => Exit<never, E>\n```\n\n----------------------------------------\n\nTITLE: Implementing Right-to-Left List Reduction in TypeScript\nDESCRIPTION: The reduceRight function folds over the elements of a list using a specified function, starting from the last element and using an initial value. It supports both curried and uncurried versions.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/List-reduceRight.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const reduceRight: { <Z, A>(zero: Z, f: (accumulator: Z, value: A) => Z): (self: List<A>) => Z; <Z, A>(self: List<A>, zero: Z, f: (accumulator: Z, value: A) => Z): Z; }\n```\n\n----------------------------------------\n\nTITLE: Defining Router Class in TypeScript\nDESCRIPTION: Declaration of the Router class in the HttpApiBuilder module that serves as the base router for API endpoints. This is part of the @effect/platform package.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/HttpApiBuilder-Router.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare class Router\n```\n\n----------------------------------------\n\nTITLE: Defining matchEffect Function for Take Module in TypeScript\nDESCRIPTION: Declares the matchEffect function, which is an effectful version of Take.fold. It folds over the failure cause, success value, and end-of-stream marker to yield an effect. The function accepts options for handling end-of-stream, failure, and success scenarios.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Take-matchEffect.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const matchEffect: { <Z, E2, R, E, Z2, R2, A, Z3, E3, R3>(options: { readonly onEnd: Effect.Effect<Z, E2, R>; readonly onFailure: (cause: Cause.Cause<E>) => Effect.Effect<Z2, E2, R2>; readonly onSuccess: (chunk: Chunk.Chunk<A>) => Effect.Effect<Z3, E3, R3>; }): (self: Take<A, E>) => Effect.Effect<Z | Z2 | Z3, E2 | E | E3, R | R2 | R3>; <A, E, Z, E2, R, Z2, R2, Z3, E3, R3>(self: Take<A, E>, options: { readonly onEnd: Effect.Effect<Z, E2, R>; readonly onFailure: (cause: Cause.Cause<E>) => Effect.Effect<Z2, E2, R2>; readonly onSuccess: (chunk: Chunk.Chunk<A>) => Effect.Effect<Z3, E3, R3>; }): Effect.Effect<Z | Z2 | Z3, E | E2 | E3, R | R2 | R3>; }\n```\n\n----------------------------------------\n\nTITLE: Implementing removeMany Operation for HashMap in TypeScript\nDESCRIPTION: Function declaration for removing multiple entries from a HashMap based on provided keys. Supports both curried and uncurried function calls to remove entries matching an iterable collection of keys from a HashMap.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/HashMap-removeMany.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const removeMany: { <K>(keys: Iterable<K>): <V>(self: HashMap<K, V>) => HashMap<K, V>; <K, V>(self: HashMap<K, V>, keys: Iterable<K>): HashMap<K, V>; }\n```\n\n----------------------------------------\n\nTITLE: Filtering Optional Values in Chunk Module\nDESCRIPTION: TypeScript function signature for the compact operation that filters out optional values from a Chunk data structure. Takes a Chunk containing Option<A> values and returns a new Chunk containing only the defined values of type A.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Chunk-compact.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const compact: <A>(self: Chunk<Option<A>>) => Chunk<A>\n```\n\n----------------------------------------\n\nTITLE: Constructing TestConfig Layer in TypeScript\nDESCRIPTION: The testConfigLayer function creates a new Layer for the TestConfig service. It takes an object with parameters for repeats, retries, samples, and shrinks, which are used to configure the testing environment.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TestServices-testConfigLayer.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const testConfigLayer: (params: { readonly repeats: number; readonly retries: number; readonly samples: number; readonly shrinks: number; }) => Layer.Layer<TestConfig.TestConfig>\n```\n\n----------------------------------------\n\nTITLE: Type Signature for Effect.allSuccesses Function\nDESCRIPTION: The TypeScript type signature for the Effect.allSuccesses function, showing its parameters, options, and return type. It accepts an iterable of effects and optional configuration for concurrency, batching, and finalizer behavior.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-allSuccesses.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const allSuccesses: <X extends Effect<any, any, any>>(elements: Iterable<X>, options?: { readonly concurrency?: Concurrency | undefined; readonly batching?: boolean | \"inherit\" | undefined; readonly concurrentFinalizers?: boolean | undefined; } | undefined) => Effect<Array<Effect.Success<X>>, never, Effect.Context<X>>\n```\n\n----------------------------------------\n\nTITLE: Declaring lessThanOrEqualTo in TypeScript Schema\nDESCRIPTION: This TypeScript function 'lessThanOrEqualTo' is designed to check if a given number is less than or equal to a specified maximum. It utilizes schema annotations to validate the input number against the given upper limit. Dependencies include the 'Schema' module and applicable TypeScript types.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Schema-lessThanOrEqualTo.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const lessThanOrEqualTo: <S extends Schema.Any>(maximum: number, annotations?: Annotations.Filter<Schema.Type<S>>) => <A extends number>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>) => filter<S>\n```\n\n----------------------------------------\n\nTITLE: Implementing MicroFiber Fork Operation in TypeScript\nDESCRIPTION: Defines a forkIn function that executes a Micro effect in a new MicroFiber with lifecycle management. The function takes a MicroScope parameter to control the fiber's lifetime and returns a new Micro effect containing the MicroFiber.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Micro-forkIn.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const forkIn: { \n  (scope: MicroScope): <A, E, R>(self: Micro<A, E, R>) => Micro<MicroFiber<A, E>, never, R>; \n  <A, E, R>(self: Micro<A, E, R>, scope: MicroScope): Micro<MicroFiber<A, E>, never, R>; \n}\n```\n\n----------------------------------------\n\nTITLE: Formatting BigDecimal Examples in TypeScript\nDESCRIPTION: Demonstrates how to format BigDecimal values into strings using the format function. Shows examples with negative numbers, decimal values, and small decimal values. The function automatically uses scientific notation for values with scale >= 16.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/BigDecimal-format.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { format, unsafeFromString } from \"effect/BigDecimal\"\n\nassert.deepStrictEqual(format(unsafeFromString(\"-5\")), \"-5\")\nassert.deepStrictEqual(format(unsafeFromString(\"123.456\")), \"123.456\")\nassert.deepStrictEqual(format(unsafeFromString(\"-0.00000123\")), \"-0.00000123\")\n```\n\n----------------------------------------\n\nTITLE: Defining whileInput Function for Schedule Modification in TypeScript\nDESCRIPTION: Declares a function that modifies a schedule to continue execution while a predicate holds true for its input. It supports both curried and non-curried forms, allowing flexible usage with different schedule and predicate combinations.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Schedule-whileInput.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const whileInput: { <In>(f: Predicate<In>): <Out, R>(self: Schedule<Out, In, R>) => Schedule<Out, In, R>; <Out, In, R>(self: Schedule<Out, In, R>, f: Predicate<In>): Schedule<Out, In, R>; }\n```\n\n----------------------------------------\n\nTITLE: Creating Schema with Definitions in Effect Platform TypeScript\nDESCRIPTION: The function `makeWithDefs` allows the creation of JSON schemas with additional definition records. It includes options to customize the reference and properties strategies. Dependencies include `Schema` and specific types for strategy options. Parameters like `defs`, `defsPath`, `topLevelReferenceStrategy`, and `additionalPropertiesStrategy` determine the schema's configuration. The output is a `JsonSchema`, and the default behavior includes keeping the top-level reference and disallowing additional properties.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/OpenApiJsonSchema-makeWithDefs.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const makeWithDefs: <A, I, R>(schema: Schema.Schema<A, I, R>, options: { readonly defs: Record<string, any>; readonly defsPath?: string | undefined; readonly topLevelReferenceStrategy?: TopLevelReferenceStrategy | undefined; readonly additionalPropertiesStrategy?: AdditionalPropertiesStrategy | undefined; }) => JsonSchema\n```\n\n----------------------------------------\n\nTITLE: Initializing TArray Predicate Evaluation in TypeScript\nDESCRIPTION: Provides a function to atomically check if every element in a transactional array satisfies a given predicate. Supports both curried and direct function call styles with complex type handling for return and error types.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TArray-everySTM.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const everySTM: { <A, R, E>(predicate: (value: A) => STM.STM<boolean, E, R>): (self: TArray<A>) => STM.STM<boolean, E, R>; <A, R, E>(self: TArray<A>, predicate: (value: A) => STM.STM<boolean, E, R>): STM.STM<boolean, E, R>; }\n```\n\n----------------------------------------\n\nTITLE: TypeScript Function Signature for Chunk.prependAll\nDESCRIPTION: This code block shows the TypeScript signature for the Chunk.prependAll function. It includes various overloads to handle different combinations of Chunk and NonEmptyChunk types.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Chunk-prependAll.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const prependAll: { <S extends Chunk<any>, T extends Chunk<any>>(that: T): (self: S) => Chunk.OrNonEmpty<S, T, Chunk.Infer<S> | Chunk.Infer<T>>; <A, B>(self: Chunk<A>, that: NonEmptyChunk<B>): NonEmptyChunk<A | B>; <A, B>(self: NonEmptyChunk<A>, that: Chunk<B>): NonEmptyChunk<A | B>; <A, B>(self: Chunk<A>, that: Chunk<B>): Chunk<A | B>; }\n```\n\n----------------------------------------\n\nTITLE: Using Layout.compact for Document Formatting in TypeScript\nDESCRIPTION: Demonstrates the usage of Layout.compact function to format documents without indentation. The example shows the difference between 'pretty' and 'compact' rendering styles using a nested document structure.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Layout-compact.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport * as Doc from \"@effect/printer/Doc\"\nimport { pipe } from \"effect/Function\"\nimport * as String from \"effect/String\"\n\nconst doc = pipe(\n  Doc.vsep([\n    Doc.text(\"lorem\"),\n    Doc.text(\"ipsum\"),\n    pipe(\n      Doc.vsep([Doc.text(\"dolor\"), Doc.text(\"sit\")]),\n      Doc.hang(4)\n    )\n  ]),\n  Doc.hang(4)\n)\n\nassert.strictEqual(\n  Doc.render(doc, { style: \"pretty\" }),\n  String.stripMargin(\n    `|lorem\n     |    ipsum\n     |    dolor\n     |        sit`\n  )\n)\n\nassert.strictEqual(\n  Doc.render(doc, { style: \"compact\" }),\n  String.stripMargin(\n    `|lorem\n     |ipsum\n     |dolor\n     |sit`\n  )\n)\n```\n\n----------------------------------------\n\nTITLE: Declaring Layer.discard Function in TypeScript\nDESCRIPTION: Defines the Layer.discard function which takes a Layer as input and returns a new Layer with its output replaced by void. This is useful when you want to include a layer only for its side-effects.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Layer-discard.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const discard: <RIn, E, ROut>(self: Layer<ROut, E, RIn>) => Layer<never, E, RIn>\n```\n\n----------------------------------------\n\nTITLE: Defining failCauseSync Function in TypeScript Channel Module\nDESCRIPTION: Function signature for creating a Channel that fails immediately with a lazily evaluated Cause. The function takes a lazy evaluation function that produces a Cause<E> and returns a Channel that will fail with that cause.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Channel-failCauseSync.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const failCauseSync: <E>(evaluate: LazyArg<Cause.Cause<E>>) => Channel<never, unknown, E, unknown, never, unknown>\n```\n\n----------------------------------------\n\nTITLE: MutableList reset function in Effect\nDESCRIPTION: This code snippet shows the type definition for the `reset` function in the `MutableList` module of the Effect library. The `reset` function takes a `MutableList` as input and returns the same `MutableList` after removing all elements from it. It requires the Effect library.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/MutableList-reset.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const reset: <A>(self: MutableList<A>) => MutableList<A>\n```\n\n----------------------------------------\n\nTITLE: Implementing Queue Shutdown in TypeScript with Effect\nDESCRIPTION: Defines a shutdown function for Queue that interrupts fibers suspended on offer or take operations. It works with both Dequeue and Enqueue types and returns an Effect of void.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Queue-shutdown.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const shutdown: <A>(self: Dequeue<A> | Enqueue<A>) => Effect.Effect<void>\n```\n\n----------------------------------------\n\nTITLE: Implementing groupBy Function in TypeScript\nDESCRIPTION: Function signature for groupBy that splits an Iterable into sub-non-empty-arrays stored in an object. It accepts a function that returns a string/symbol key and groups elements based on that key. The function can be used in both curried and non-curried forms.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Iterable-groupBy.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const groupBy: { <A, K extends string | symbol>(f: (a: A) => K): (self: Iterable<A>) => Record<Record.ReadonlyRecord.NonLiteralKey<K>, NonEmptyArray<A>>; <A, K extends string | symbol>(self: Iterable<A>, f: (a: A) => K): Record<Record.ReadonlyRecord.NonLiteralKey<K>, NonEmptyArray<A>>; }\n```\n\n----------------------------------------\n\nTITLE: Effect.raceAll Type Signature in TypeScript\nDESCRIPTION: Type signature showing the function's type parameters and return type for racing multiple effects.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-raceAll.md#2025-04-11_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const raceAll: <Eff extends Effect<any, any, any>>(all: Iterable<Eff>) => Effect<Effect.Success<Eff>, Effect.Error<Eff>, Effect.Context<Eff>>\n```\n\n----------------------------------------\n\nTITLE: DateTime.toUtc Function Type Signature\nDESCRIPTION: Type declaration for the toUtc function, which takes a DateTime object and returns a DateTime.Utc object. This provides the function signature for TypeScript type checking.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/DateTime-toUtc.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const toUtc: (self: DateTime) => Utc\n```\n\n----------------------------------------\n\nTITLE: Using Doc.hang for indentation in TypeScript with @effect/printer\nDESCRIPTION: This example demonstrates using the 'hang' combinator to indent text relative to the current column position. It combines a prefix with reflowed text that is indented by 4 spaces, showing how the text wraps with the proper indentation level maintained.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Doc-hang.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport * as Doc from \"@effect/printer/Doc\"\nimport { pipe } from \"effect/Function\"\nimport * as String from \"effect/String\"\n\nconst doc = Doc.hsep([\n  Doc.text(\"prefix\"),\n  pipe(Doc.reflow(\"Indenting these words with hang\"), Doc.hang(4))\n])\n\nassert.strictEqual(\n  Doc.render(doc, {\n    style: \"pretty\",\n    options: { lineWidth: 24 }\n  }),\n  String.stripMargin(\n    `|prefix Indenting these\n     |           words with\n     |           hang`\n  )\n)\n```\n\n----------------------------------------\n\nTITLE: Defining uninterruptibleMask Function in TypeScript\nDESCRIPTION: This snippet defines the uninterruptibleMask function, which behaves like 'uninterruptible' but provides a 'restore' function to restore interruptibility in specific code regions. It takes a function as an argument and returns an Effect.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-uninterruptibleMask.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const uninterruptibleMask: <A, E, R>(f: (restore: <AX, EX, RX>(effect: Effect<AX, EX, RX>) => Effect<AX, EX, RX>) => Effect<A, E, R>) => Effect<A, E, R>\n```\n\n----------------------------------------\n\nTITLE: Defining Layer.project Function in TypeScript\nDESCRIPTION: Declares the project function for the Layer module. It allows projecting out part of a service output by a layer using a specified function. The function supports two overloads with different parameter orders.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Layer-project.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const project: { <I1, S1, I2, S2>(tagA: Context.Tag<I1, S1>, tagB: Context.Tag<I2, S2>, f: (a: Types.NoInfer<S1>) => Types.NoInfer<S2>): <RIn, E>(self: Layer<I1, E, RIn>) => Layer<I2, E, RIn>; <RIn, E, I1, S1, I2, S2>(self: Layer<I1, E, RIn>, tagA: Context.Tag<I1, S1>, tagB: Context.Tag<I2, S2>, f: (a: Types.NoInfer<S1>) => Types.NoInfer<S2>): Layer<I2, E, RIn>; }\n```\n\n----------------------------------------\n\nTITLE: Declaring Sink Die Function in TypeScript\nDESCRIPTION: The `die` function creates and returns a sink that halts due to the specified defect. It is a part of the Sink module in the Effect package. The function does not require any specific dependencies but expects a defect input of type `unknown`. This function outputs a Sink with no successful output (`never`) and accepts any type of defect.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Sink-die.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const die: (defect: unknown) => Sink<never, unknown>\n```\n\n----------------------------------------\n\nTITLE: Checking Running Status of Fibers in TypeScript\nDESCRIPTION: Function that determines if a FiberStatus is in the 'Running' state. It returns a boolean value and also acts as a type guard, narrowing the type to 'Running' when true.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/FiberStatus-isRunning.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const isRunning: (self: FiberStatus) => self is Running\n```\n\n----------------------------------------\n\nTITLE: Constructing Scoped Layer in TypeScript\nDESCRIPTION: Defines a function for constructing a layer from a scoped effect. The function supports two overloads: one taking a context tag and effect separately, and another combining them into a single call. Returns a Layer type that excludes Scope from its requirements.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Layer-scoped.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const scoped: {\n  <I, S>(tag: Context.Tag<I, S>): <E, R>(effect: Effect.Effect<Types.NoInfer<S>, E, R>) => Layer<I, E, Exclude<R, Scope.Scope>>;\n  <I, S, E, R>(tag: Context.Tag<I, S>, effect: Effect.Effect<Types.NoInfer<S>, E, R>): Layer<I, E, Exclude<R, Scope.Scope>>;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining mapRequestInput Function in TypeScript for HttpClient\nDESCRIPTION: Declares a function mapRequestInput that prepends a transformation of the request object before sending it. It can be used in two ways: either by passing the transformation function first, or by passing the HttpClient instance first.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/HttpClient-mapRequestInput.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const mapRequestInput: {\n  (f: (a: ClientRequest.HttpClientRequest) => ClientRequest.HttpClientRequest): <E, R>(self: HttpClient.With<E, R>) => HttpClient.With<E, R>;\n  <E, R>(self: HttpClient.With<E, R>, f: (a: ClientRequest.HttpClientRequest) => ClientRequest.HttpClientRequest): HttpClient.With<E, R>;\n}\n```\n\n----------------------------------------\n\nTITLE: Checking if a Cause is Empty in TypeScript\nDESCRIPTION: A function that checks if a Cause is entirely empty, returning true if it contains no errors, defects, or interruptions. It's useful for verifying if a computation had no failures.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Cause-isEmpty.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const isEmpty: <E>(self: Cause<E>) => boolean\n```\n\n----------------------------------------\n\nTITLE: TaggedStruct Function Signature in TypeScript\nDESCRIPTION: This code snippet shows the TypeScript signature for the TaggedStruct function. It takes a tag value and a fields object as parameters, and returns a TaggedStruct type.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Schema-TaggedStruct.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const TaggedStruct: <Tag extends AST.LiteralValue, Fields extends Struct.Fields>(value: Tag, fields: Fields) => TaggedStruct<Tag, Fields>\n```\n\n----------------------------------------\n\nTITLE: Type predicate with schema and options in Typescript\nDESCRIPTION: Defines a function `is` that takes a schema and optional parse options as input and returns a type predicate. This predicate checks if a given value `u` conforms to the specified schema `schema`. The default value for `exact` in `AST.ParseOptions` is `true`. The function signature shows the type parameters `A`, `I`, and `R` representing the output type, input type, and resources type of the schema respectively.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/ParseResult-is.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const is: <A, I, R>(schema: Schema.Schema<A, I, R>, options?: AST.ParseOptions) => (u: unknown, overrideOptions?: AST.ParseOptions | number) => u is A\n```\n\n----------------------------------------\n\nTITLE: Declaring collectAllToSetN Sink Function in TypeScript\nDESCRIPTION: Defines a sink function that collects up to n distinct inputs into a HashSet. The function takes a number parameter n and returns a Sink that works with HashSet data structure.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Sink-collectAllToSetN.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const collectAllToSetN: <In>(n: number) => Sink<HashSet.HashSet<In>, In, In>\n```\n\n----------------------------------------\n\nTITLE: Combining Causes Sequentially in TypeScript with Effect\nDESCRIPTION: The `sequential` function merges two errors that occurred in sequence, such as a main error followed by a finalization error. It preserves both errors to provide complete failure information when handling errors in Effect.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Cause-sequential.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const sequential: <E, E2>(left: Cause<E>, right: Cause<E2>) => Cause<E | E2>\n```\n\n----------------------------------------\n\nTITLE: Implementing a Folding Sink Operation in TypeScript\nDESCRIPTION: A function that creates a sink for folding inputs with a provided function, termination predicate, and initial state. It processes inputs sequentially, combining them into a single result value while checking a continuation condition.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Sink-fold.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const fold: <S, In>(s: S, contFn: Predicate<S>, f: (s: S, input: In) => S) => Sink<S, In, In>\n```\n\n----------------------------------------\n\nTITLE: Adding Delay to Schedule with Effect in TypeScript\nDESCRIPTION: The 'addDelayEffect' function is designed to apply an effectfully computed delay to each interval within a schedule. It achieves this by utilizing an effectful function that produces a delay duration based on the schedule's output. The primary use case is when delays need to be computed through effects rather than pure functions. Dependencies include the 'Effect' and 'Schedule' modules from the 'effect' package, requiring TypeScript support.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Schedule-addDelayEffect.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const addDelayEffect: { <Out, R2>(f: (out: Out) => Effect.Effect<Duration.DurationInput, never, R2>): <In, R>(self: Schedule<Out, In, R>) => Schedule<Out, In, R2 | R>; <Out, In, R, R2>(self: Schedule<Out, In, R>, f: (out: Out) => Effect.Effect<Duration.DurationInput, never, R2>): Schedule<Out, In, R | R2>; }\n```\n\n----------------------------------------\n\nTITLE: Function Signature for headNonEmpty in TypeScript\nDESCRIPTION: This code block shows the TypeScript signature for the `headNonEmpty` function. It takes a `NonEmptyReadonlyArray<A>` as input and returns an element of type `A`.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Array-headNonEmpty.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const headNonEmpty: <A>(self: NonEmptyReadonlyArray<A>) => A\n```\n\n----------------------------------------\n\nTITLE: Extracting Optional Values with Error Handling in TypeScript\nDESCRIPTION: The `someOrFail` function extracts an optional value from a stream and throws a specified error if the value is not present. It supports both lazy error creation and direct error passing. The function is generic, allowing different types for the value, error, and the stream.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-someOrFail.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const someOrFail: { <E2>(error: LazyArg<E2>): <A, E, R>(self: Stream<Option.Option<A>, E, R>) => Stream<A, E2 | E, R>; <A, E, R, E2>(self: Stream<Option.Option<A>, E, R>, error: LazyArg<E2>): Stream<A, E | E2, R>; }\n```\n\n----------------------------------------\n\nTITLE: Converting DateTime to Date in TypeScript using Effect Library\nDESCRIPTION: This function converts a DateTime object to a JavaScript Date object, applying the time zone first. It takes a DateTime object as input and returns a Date object.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/DateTime-toDate.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const toDate: (self: DateTime) => Date\n```\n\n----------------------------------------\n\nTITLE: Stream.zipWith Type Signature in TypeScript\nDESCRIPTION: Type signature for the Stream.zipWith function showing its polymorphic nature and type parameters. Defines the function's overloads for different usage patterns.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-zipWith.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const zipWith: { <AR, ER, RR, AL, A>(right: Stream<AR, ER, RR>, f: (left: AL, right: AR) => A): <EL, RL>(left: Stream<AL, EL, RL>) => Stream<A, EL | ER, RL | RR>; <AL, EL, RL, AR, ER, RR, A>(left: Stream<AL, EL, RL>, right: Stream<AR, ER, RR>, f: (left: AL, right: AR) => A): Stream<A, EL | ER, RL | RR>; }\n```\n\n----------------------------------------\n\nTITLE: Running an Effect Schedule in Typescript\nDESCRIPTION: Executes a schedule with provided inputs and collects all outputs into a `Chunk`. The schedule execution begins at the given timestamp `now` and proceeds according to the schedule's definition. It accepts the schedule itself, the starting timestamp, and an iterable of input values.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Schedule-run.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const run: { <In>(now: number, input: Iterable<In>): <Out, R>(self: Schedule<Out, In, R>) => Effect.Effect<Chunk.Chunk<Out>, never, R>; <Out, In, R>(self: Schedule<Out, In, R>, now: number, input: Iterable<In>): Effect.Effect<Chunk.Chunk<Out>, never, R>; }\n```\n\n----------------------------------------\n\nTITLE: Finding Minimum Value with Effect Order.min in Typescript\nDESCRIPTION: This code snippet demonstrates the signature of the `Order.min` function in Typescript. It takes an `Order` instance for a specific type `A` and returns a function that can compare two values of type `A` to determine the minimum. If the values are equal, the first argument is returned.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Order-min.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const min: <A>(O: Order<A>) => { (that: A): (self: A) => A; (self: A, that: A): A; }\n```\n\n----------------------------------------\n\nTITLE: Declaring ShardManagerClient Class in TypeScript\nDESCRIPTION: Defines the ShardManagerClient class that provides functionality to communicate with the ShardManager. Part of the @effect/cluster package's core functionality.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/ShardManager-ShardManagerClient.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare class ShardManagerClient\n```\n\n----------------------------------------\n\nTITLE: Wrapping a stream with tracing in Effect-TS\nDESCRIPTION: The 'withSpan' function allows developers to wrap a given stream in a new tracing span. This improves observability in asynchronous workflows. It accepts a name for the span and optional tracing options, returning a modified stream with enhanced tracing capabilities.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-withSpan.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const withSpan: { (name: string, options?: Tracer.SpanOptions | undefined): <A, E, R>(self: Stream<A, E, R>) => Stream<A, E, Exclude<R, Tracer.ParentSpan>>; <A, E, R>(self: Stream<A, E, R>, name: string, options?: Tracer.SpanOptions | undefined): Stream<A, E, Exclude<R, Tracer.ParentSpan>>; }\n```\n\n----------------------------------------\n\nTITLE: Using logfmtLogger in Effect for Human-Readable Logging (TypeScript)\nDESCRIPTION: Demonstrates how to use the logfmtLogger to output logs in a human-readable format. The example shows logging messages, annotating logs with key-value pairs, and using log spans.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Logger-logfmtLogger.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Effect, Logger } from \"effect\"\n\nconst program = Effect.log(\"message1\", \"message2\").pipe(\n  Effect.annotateLogs({ key1: \"value1\", key2: \"value2\" }),\n  Effect.withLogSpan(\"myspan\")\n)\n\nEffect.runFork(program.pipe(Effect.provide(Logger.logFmt)))\n// timestamp=... level=INFO fiber=#0 message=message1 message=message2 myspan=0ms key2=value2 key1=value1\n```\n\n----------------------------------------\n\nTITLE: Declaring STM Reduce Function in TypeScript\nDESCRIPTION: Provides a flexible type signature for reducing iterables with side effects, supporting different function call patterns and handling transactional state transformations\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/STM-reduce.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const reduce: { <S, A, E, R>(zero: S, f: (s: S, a: A) => STM<S, E, R>): (iterable: Iterable<A>) => STM<S, E, R>; <S, A, E, R>(iterable: Iterable<A>, zero: S, f: (s: S, a: A) => STM<S, E, R>): STM<S, E, R>; }\n```\n\n----------------------------------------\n\nTITLE: Using BigDecimal.greaterThan to Compare BigDecimal Values in TypeScript\nDESCRIPTION: This example demonstrates how to use the greaterThan function from the BigDecimal module to compare two BigDecimal values. The function returns true if the first argument is greater than the second, otherwise false.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/BigDecimal-greaterThan.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { greaterThan, unsafeFromString } from \"effect/BigDecimal\"\n\nassert.deepStrictEqual(greaterThan(unsafeFromString(\"2\"), unsafeFromString(\"3\")), false)\nassert.deepStrictEqual(greaterThan(unsafeFromString(\"3\"), unsafeFromString(\"3\")), false)\nassert.deepStrictEqual(greaterThan(unsafeFromString(\"4\"), unsafeFromString(\"3\")), true)\n```\n\n----------------------------------------\n\nTITLE: Taking All Elements from a Transactional Priority Queue in TypeScript\nDESCRIPTION: The takeAll function atomically removes and returns all values from a TPriorityQueue. It returns an STM effect that will produce an array containing all the elements that were in the queue.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TPriorityQueue-takeAll.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const takeAll: <A>(self: TPriorityQueue<A>) => STM.STM<Array<A>>\n```\n\n----------------------------------------\n\nTITLE: Declaring Schedule.upTo Function in TypeScript\nDESCRIPTION: Defines the upTo function which takes a duration and a schedule, returning a new schedule that limits execution to the specified duration. It can be called with arguments in either order.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Schedule-upTo.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const upTo: { (duration: Duration.DurationInput): <Out, In, R>(self: Schedule<Out, In, R>) => Schedule<Out, In, R>; <Out, In, R>(self: Schedule<Out, In, R>, duration: Duration.DurationInput): Schedule<Out, In, R>; }\n```\n\n----------------------------------------\n\nTITLE: Declaring Stream Fold Operation in TypeScript\nDESCRIPTION: This TypeScript code snippet declares the function 'runFoldWhile' to reduce elements in a stream to a single value. The operation halts when a specified predicate condition is no longer satisfied. It aims to provide flexibility in handling streams by allowing early exit based on conditions. Dependencies include the 'Effect' library for stream and effect handling.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-runFoldWhile.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const runFoldWhile: { <S, A>(s: S, cont: Predicate<S>, f: (s: S, a: A) => S): <E, R>(self: Stream<A, E, R>) => Effect.Effect<S, E, R>; <A, E, R, S>(self: Stream<A, E, R>, s: S, cont: Predicate<S>, f: (s: S, a: A) => S): Effect.Effect<S, E, R>; }\n```\n\n----------------------------------------\n\nTITLE: Schedule Type Definition in Typescript\nDESCRIPTION: This code snippet defines the `Schedule` interface in TypeScript. It outlines the structure of a schedule, including type parameters for output, input, and requirements, as well as the `initial` state and the `step` function for determining the next action based on time, input, and current state.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Schedule-Schedule.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nexport interface Schedule<out Out, in In = unknown, out R = never> extends Schedule.Variance<Out, In, R>, Pipeable {\n  /**\n   * Initial State\n   */\n  readonly initial: any\n  /**\n   * Schedule Step\n   */\n  step(\n    now: number,\n    input: In,\n    state: any\n  ): Effect.Effect<readonly [any, Out, ScheduleDecision.ScheduleDecision], never, R>\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Declaring Stream.dieMessage in TypeScript\nDESCRIPTION: The `dieMessage` function creates a stream in TypeScript that terminates with an exception based on the provided message. It is part of the 'effect' package's 'Stream' module and is used to produce a stream that always fails with a specified error message. This functionality is crucial for error handling in streams. It does not require any special dependencies besides the 'effect' package. The only parameter 'message' is a string describing the exception message, the output is a stream that will never emit any valid values due to the error.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-dieMessage.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const dieMessage: (message: string) => Stream<never>\n```\n\n----------------------------------------\n\nTITLE: Implementing Timeout Functionality for Micro Effects in TypeScript\nDESCRIPTION: The timeout function returns an effect that will timeout the provided effect, failing with a TimeoutException if the timeout elapses before the effect produces a value. The running effect will be safely interrupted if the timeout happens.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Micro-timeout.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const timeout: { (millis: number): <A, E, R>(self: Micro<A, E, R>) => Micro<A, E | TimeoutException, R>; <A, E, R>(self: Micro<A, E, R>, millis: number): Micro<A, E | TimeoutException, R>; }\n```\n\n----------------------------------------\n\nTITLE: Defining HelpDoc Type in TypeScript\nDESCRIPTION: TypeScript type definition for HelpDoc, which models documentation for command-line applications. HelpDoc can be composed of different content items including Empty, Header, Paragraph, DescriptionList, Enumeration, and Sequence.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/HelpDoc-HelpDoc.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ntype HelpDoc = Empty | Header | Paragraph | DescriptionList | Enumeration | Sequence\n```\n\n----------------------------------------\n\nTITLE: Defining mergeEither Function in TypeScript for Stream Module\nDESCRIPTION: This code snippet defines the mergeEither function for the Stream module. It merges two streams to produce a stream of eithers. The function is overloaded to handle different parameter orders.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-mergeEither.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const mergeEither: { <A2, E2, R2>(that: Stream<A2, E2, R2>): <A, E, R>(self: Stream<A, E, R>) => Stream<Either.Either<A2, A>, E2 | E, R2 | R>; <A, E, R, A2, E2, R2>(self: Stream<A, E, R>, that: Stream<A2, E2, R2>): Stream<Either.Either<A2, A>, E | E2, R | R2>; }\n```\n\n----------------------------------------\n\nTITLE: Using HashSet.endMutation to make a mutable HashSet immutable in TypeScript\nDESCRIPTION: This example demonstrates the complete lifecycle of HashSet mutation. It shows how to begin mutation, modify a set in place, end mutation to make it immutable again, and the difference in behavior before and after endMutation is called. It illustrates how operations create new instances after ending mutation while preserving the original set's values.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/HashSet-endMutation.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { HashSet } from \"effect\"\nimport assert from \"node:assert/strict\"\n\n// Create a mutable set\nconst mutableSet = HashSet.beginMutation(HashSet.empty<number>())\n\n// Add some elements to the mutable set\nHashSet.add(mutableSet, 1)\nHashSet.add(mutableSet, 2)\n\n// Before endMutation, operations modify the set in place\nconst sameSet = HashSet.add(mutableSet, 3)\nassert(Object.is(mutableSet, sameSet)) // true - same object reference\nassert.deepStrictEqual(HashSet.toValues(mutableSet).sort(), [1, 2, 3])\n\n// Make the set immutable again\nconst immutableSet = HashSet.endMutation(mutableSet)\n\n// endMutation returns the same set instance, now made immutable\nassert(Object.is(mutableSet, immutableSet)) // true - same object reference\n\n// After endMutation, operations create new instances\nconst newSet = HashSet.add(immutableSet, 4)\nassert(!Object.is(immutableSet, newSet)) // false - different object references\n\n// The original set remains unchanged\nassert.deepStrictEqual(HashSet.toValues(immutableSet).sort(), [1, 2, 3])\n\n// The new set contains the added element\nassert.deepStrictEqual(HashSet.toValues(newSet).sort(), [1, 2, 3, 4])\n```\n\n----------------------------------------\n\nTITLE: Using Doc.reflow for Text Layout in Effect TS\nDESCRIPTION: This example demonstrates how to use Doc.reflow to format a long text string by splitting it into multiple lines based on a specified line width. The function breaks text at spaces and inserts softLine breaks that adapt to the available width.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Doc-reflow.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport * as Doc from \"@effect/printer/Doc\"\nimport * as String from \"effect/String\"\n\nconst doc = Doc.reflow(\n  \"Lorem ipsum dolor sit amet, consectetur adipisicing elit, \" +\n    \"sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.\"\n)\n\nassert.strictEqual(\n  Doc.render(doc, {\n    style: \"pretty\",\n    options: { lineWidth: 32 }\n  }),\n  String.stripMargin(\n    `|Lorem ipsum dolor sit amet,\n     |consectetur adipisicing elit,\n     |sed do eiusmod tempor incididunt\n     |ut labore et dolore magna\n     |aliqua.`\n  )\n)\n```\n\n----------------------------------------\n\nTITLE: Retrieving the First Die Defect from a Cause in TypeScript\nDESCRIPTION: The dieOption function extracts the first unexpected failure (Die) from a Cause object and returns it wrapped in an Option. This is useful for diagnosing the primary defect in a chain of errors.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Cause-dieOption.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const dieOption: <E>(self: Cause<E>) => Option.Option<unknown>\n```\n\n----------------------------------------\n\nTITLE: Checking Subrecord with TypeScript\nDESCRIPTION: This TypeScript snippet declares a function `isSubrecord` which checks if a given record (`self`) is a subrecord of another (`that`). It uses generic types to ensure the keys and values are consistent across both records. Default equality checks are used to compare the records' keys and values. This version is since v2.0.0.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Record-isSubrecord.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const isSubrecord: { <K extends string, A>(that: ReadonlyRecord<K, A>): (self: ReadonlyRecord<K, A>) => boolean; <K extends string, A>(self: ReadonlyRecord<K, A>, that: ReadonlyRecord<K, A>): boolean; }\n```\n\n----------------------------------------\n\nTITLE: Implementing Chunk.sort Function in TypeScript\nDESCRIPTION: Type definition for a function that sorts elements in a Chunk data structure. It accepts an Order instance for comparison and returns a new sorted Chunk. The function supports both curried and uncurried calling patterns.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Chunk-sort.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const sort: { <B>(O: Order.Order<B>): <A extends B>(self: Chunk<A>) => Chunk<A>; <A extends B, B>(self: Chunk<A>, O: Order.Order<B>): Chunk<A>; }\n```\n\n----------------------------------------\n\nTITLE: Creating Interrupted Fiber in TypeScript Effect-IO\nDESCRIPTION: Function signature for constructing a Fiber that is already in an interrupted state. Takes a FiberId parameter and returns a Fiber that will never succeed.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Fiber-interrupted.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const interrupted: (fiberId: FiberId.FiberId) => Fiber<never>\n```\n\n----------------------------------------\n\nTITLE: Function Signature for HashSet.fromIterable in TypeScript\nDESCRIPTION: The TypeScript type signature for the HashSet.fromIterable function, showing it accepts any iterable collection of type A and returns a HashSet containing elements of type A.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/HashSet-fromIterable.md#2025-04-11_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const fromIterable: <A>(elements: Iterable<A>) => HashSet<A>\n```\n\n----------------------------------------\n\nTITLE: Using Boolean.match with True/False Handlers in TypeScript\nDESCRIPTION: Example demonstrating how to use the Boolean.match function to execute different code paths based on a boolean value. The function accepts a boolean and an options object with onTrue and onFalse handlers.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Boolean-match.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { Boolean } from \"effect\"\n\nassert.deepStrictEqual(Boolean.match(true, { onFalse: () => \"It's false!\", onTrue: () => \"It's true!\" }), \"It's true!\")\n```\n\n----------------------------------------\n\nTITLE: Converting Record to Key-Value Entries using Effect-TS\nDESCRIPTION: Demonstrates how to use the toEntries function to convert a record object into an array of key-value tuple pairs. The function accepts a readonly record and returns an array where each element is a tuple containing a key and its corresponding value.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Record-toEntries.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { toEntries } from \"effect/Record\"\n\nconst x = { a: 1, b: 2, c: 3 }\nassert.deepStrictEqual(toEntries(x), [[\"a\", 1], [\"b\", 2], [\"c\", 3]])\n```\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const toEntries: <K extends string, A>(self: ReadonlyRecord<K, A>) => Array<[K, A]>\n```\n\n----------------------------------------\n\nTITLE: Type Signature for Function.tupled\nDESCRIPTION: The TypeScript type declaration for the tupled utility function, showing how it transforms a function of multiple arguments into one that accepts a tuple.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Function-tupled.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const tupled: <A extends ReadonlyArray<unknown>, B>(f: (...a: A) => B) => (a: A) => B\n```\n\n----------------------------------------\n\nTITLE: Testing if a TMap is Empty in STM Context with TypeScript\nDESCRIPTION: This function tests whether a transactional map (TMap) is empty. It returns an STM transaction that evaluates to a boolean value indicating if the map contains no entries. The function works with TMap instances of any key and value types.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TMap-isEmpty.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const isEmpty: <K, V>(self: TMap<K, V>) => STM.STM<boolean>\n```\n\n----------------------------------------\n\nTITLE: Peeking at Next Queue Element in STM Context\nDESCRIPTION: The peekOption function allows viewing the next element in a queue without removing it. It returns None if the queue is empty and operates within the STM transactional context.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TQueue-peekOption.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const peekOption: <A>(self: TDequeue<A>) => STM.STM<Option.Option<A>>\n```\n\n----------------------------------------\n\nTITLE: Array.sortBy Type Signature\nDESCRIPTION: Type signature for the Array.sortBy function showing its generic type constraints and return types. The function accepts multiple Order parameters and returns a sorted array maintaining type safety.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Array-sortBy.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const sortBy: <S extends Iterable<any>>(...orders: ReadonlyArray<Order.Order<ReadonlyArray.Infer<S>>>) => (self: S) => S extends NonEmptyReadonlyArray<infer A> ? NonEmptyArray<A> : S extends Iterable<infer A> ? Array<A> : never\n```\n\n----------------------------------------\n\nTITLE: Checking if a value is a FiberId in TypeScript\nDESCRIPTION: A type predicate function that determines whether the specified unknown value is a FiberId instance. This function is used for type narrowing in TypeScript, allowing for safe use of FiberId-specific operations.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/FiberId-isFiberId.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const isFiberId: (self: unknown) => self is FiberId\n```\n\n----------------------------------------\n\nTITLE: Declaring forkScoped Function in TypeScript\nDESCRIPTION: TypeScript declaration for the forkScoped function that runs a Micro effect in a new MicroFiber. The function takes a Micro effect and returns a new Micro effect that produces a MicroFiber, with the fiber's lifetime attached to the current MicroScope.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Micro-forkScoped.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const forkScoped: <A, E, R>(self: Micro<A, E, R>) => Micro<MicroFiber<A, E>, never, R | MicroScope>\n```\n\n----------------------------------------\n\nTITLE: Forking FiberRefs for Child Fiber in TypeScript\nDESCRIPTION: The forkAs function allows forking a collection of fiber refs as a specified child fiber id. This operation may modify the values of the fiber refs based on the individual fiber refs in the collection. It accepts a FiberId.Single and returns a function that takes FiberRefs and returns FiberRefs, or it can be called with both arguments directly.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/FiberRefs-forkAs.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const forkAs: { (childId: FiberId.Single): (self: FiberRefs) => FiberRefs; (self: FiberRefs, childId: FiberId.Single): FiberRefs; }\n```\n\n----------------------------------------\n\nTITLE: Transforming Schedule Input Type in TypeScript\nDESCRIPTION: Modifies a schedule to accept a different input type by providing a conversion function. Enables flexible input transformation while maintaining the schedule's core logic.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Schedule-mapInput.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const mapInput: { <In, In2>(f: (in2: In2) => In): <Out, R>(self: Schedule<Out, In, R>) => Schedule<Out, In2, R>; <Out, In, R, In2>(self: Schedule<Out, In, R>, f: (in2: In2) => In): Schedule<Out, In2, R>; }\n```\n\n----------------------------------------\n\nTITLE: Defining HttpApiGroup Interface in TypeScript\nDESCRIPTION: Declares the HttpApiGroup interface with generic types for ID, Endpoints, Error, and other properties. Includes methods for adding endpoints, error schemas, middlewares, and annotations.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/HttpApiGroup-HttpApiGroup.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface HttpApiGroup<\n  out Id extends string,\n  out Endpoints extends HttpApiEndpoint.HttpApiEndpoint.Any = never,\n  in out Error = HttpApiDecodeError,\n  out R = never,\n  out TopLevel extends (true | false) = false\n> extends Pipeable {\n  new(_: never): {}\n  readonly [TypeId]: TypeId\n  readonly identifier: Id\n  readonly topLevel: TopLevel\n  readonly endpoints: Record.ReadonlyRecord<string, Endpoints>\n  readonly errorSchema: Schema.Schema<Error, unknown, R>\n  readonly annotations: Context.Context<never>\n  readonly middlewares: ReadonlySet<HttpApiMiddleware.TagClassAny>\n\n  add<A extends HttpApiEndpoint.HttpApiEndpoint.Any>(\n    endpoint: A\n  ): HttpApiGroup<Id, Endpoints | A, Error, R, TopLevel>\n\n  addError<A, I, RX>(\n    schema: Schema.Schema<A, I, RX>,\n    annotations?: {\n      readonly status?: number | undefined\n    }\n  ): HttpApiGroup<Id, Endpoints, Error | A, R | RX, TopLevel>\n\n  prefix(prefix: HttpApiEndpoint.PathSegment): HttpApiGroup<Id, Endpoints, Error, R, TopLevel>\n\n  middleware<I extends HttpApiMiddleware.HttpApiMiddleware.AnyId, S>(middleware: Context.Tag<I, S>): HttpApiGroup<\n    Id,\n    Endpoints,\n    Error | HttpApiMiddleware.HttpApiMiddleware.Error<I>,\n    R | I | HttpApiMiddleware.HttpApiMiddleware.ErrorContext<I>,\n    TopLevel\n  >\n\n  middlewareEndpoints<I extends HttpApiMiddleware.HttpApiMiddleware.AnyId, S>(\n    middleware: Context.Tag<I, S>\n  ): HttpApiGroup<\n    Id,\n    HttpApiEndpoint.HttpApiEndpoint.AddContext<Endpoints, I>,\n    Error,\n    R,\n    TopLevel\n  >\n\n  annotateContext<I>(context: Context.Context<I>): HttpApiGroup<Id, Endpoints, Error, R, TopLevel>\n\n  annotate<I, S>(tag: Context.Tag<I, S>, value: S): HttpApiGroup<Id, Endpoints, Error, R, TopLevel>\n\n  annotateEndpointsContext<I>(context: Context.Context<I>): HttpApiGroup<Id, Endpoints, Error, R, TopLevel>\n\n  annotateEndpoints<I, S>(tag: Context.Tag<I, S>, value: S): HttpApiGroup<Id, Endpoints, Error, R, TopLevel>\n}\n```\n\n----------------------------------------\n\nTITLE: Reducing Trie Entries in TypeScript using Effect Library\nDESCRIPTION: Demonstrates how to use the Trie.reduce function to aggregate values or keys from a Trie data structure. The example shows summing numeric values and concatenating string keys.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Trie-reduce.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { Trie } from \"effect\"\n\nconst trie = Trie.empty<number>().pipe(\n  Trie.insert(\"shells\", 0),\n  Trie.insert(\"sells\", 1),\n  Trie.insert(\"she\", 2)\n)\n\nassert.equal(\n  trie.pipe(\n    Trie.reduce(0, (acc, n) => acc + n)\n  ),\n  3\n)\nassert.equal(\n  trie.pipe(\n    Trie.reduce(10, (acc, n) => acc + n)\n  ),\n  13\n)\nassert.equal(\n  trie.pipe(\n    Trie.reduce(\"\", (acc, _, key) => acc + key)\n  ),\n  \"sellssheshells\"\n)\n```\n\n----------------------------------------\n\nTITLE: Providing CurrentTimeZone to an Effect using withCurrentZone\nDESCRIPTION: Demonstrates how to provide the CurrentTimeZone context to an effect using the withCurrentZone function. The example creates a time zone for Europe/London and then uses it to get the current time in that zone.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/DateTime-withCurrentZone.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { DateTime, Effect } from \"effect\"\n\nconst zone = DateTime.zoneUnsafeMakeNamed(\"Europe/London\")\n\nEffect.gen(function* () {\n  const now = yield* DateTime.nowInCurrentZone\n}).pipe(DateTime.withCurrentZone(zone))\n```\n\n----------------------------------------\n\nTITLE: Combining Two Options into a Tuple - TypeScript\nDESCRIPTION: This function `product` takes two Option instances and returns an Option containing a tuple of their values if both are present (Some). If either is None, it returns None, making it useful for safely combining values while ensuring validity.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Option-product.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const product: <A, B>(self: Option<A>, that: Option<B>) => Option<[A, B]>;\n```\n\n----------------------------------------\n\nTITLE: Removing Entries from HashMap in TypeScript\nDESCRIPTION: The remove function is used to delete an entry for a specified key in a HashMap using the internal hashing function. It can be called with the key first or the HashMap first, providing flexibility in usage.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/HashMap-remove.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const remove: { <K>(key: K): <V>(self: HashMap<K, V>) => HashMap<K, V>; <K, V>(self: HashMap<K, V>, key: K): HashMap<K, V>; }\n```\n\n----------------------------------------\n\nTITLE: Creating Adaptable Documents with pageWidth in TypeScript\nDESCRIPTION: This example demonstrates how to use Doc.pageWidth to create a document that adapts based on available page width. It creates a horizontally separated document that shows different content depending on whether the page width is bounded or unbounded, including the line width and ribbon fraction when available.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Doc-pageWidth.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport * as Doc from \"@effect/printer/Doc\"\nimport * as String from \"effect/String\"\n\nconst doc = Doc.hsep([\n  Doc.text(\"prefix\"),\n  Doc.pageWidth((pageWidth) => {\n    switch (pageWidth._tag) {\n      case \"AvailablePerLine\": {\n        const { lineWidth, ribbonFraction } = pageWidth\n        return Doc.squareBracketed(\n          Doc.text(`Width: ${lineWidth}, Ribbon Fraction: ${ribbonFraction}`)\n        )\n      }\n      case \"Unbounded\": {\n        return Doc.empty\n      }\n    }\n  })\n])\n\nconst example = Doc.vsep([0, 4, 8].map((n) => Doc.indent(n)(doc)))\n\nassert.strictEqual(\n  Doc.render(example, {\n    style: \"pretty\",\n    options: { lineWidth: 32 }\n  }),\n  String.stripMargin(\n    `|prefix [Width: 32, Ribbon Fraction: 1]\n     |    prefix [Width: 32, Ribbon Fraction: 1]\n     |        prefix [Width: 32, Ribbon Fraction: 1]`\n  )\n)\n```\n\n----------------------------------------\n\nTITLE: Transforming TMap Values Atomically Using STM in TypeScript\nDESCRIPTION: A function that atomically updates all values in a TMap using a transactional function. It takes a function that transforms each value and returns a new STM transaction that applies this transformation to all values in the map.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TMap-transformValuesSTM.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const transformValuesSTM: { <V, R, E>(f: (value: V) => STM.STM<V, E, R>): <K>(self: TMap<K, V>) => STM.STM<void, E, R>; <K, V, R, E>(self: TMap<K, V>, f: (value: V) => STM.STM<V, E, R>): STM.STM<void, E, R>; }\n```\n\n----------------------------------------\n\nTITLE: Effectfully Transforming Sink Input Chunks in TypeScript\nDESCRIPTION: This function allows effectful transformation of a sink's input chunks. The transformation function must preserve chunking-invariance. It provides both curried and uncurried variants for flexible usage patterns.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Sink-mapInputChunksEffect.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const mapInputChunksEffect: { <In0, In, E2, R2>(f: (chunk: Chunk.Chunk<In0>) => Effect.Effect<Chunk.Chunk<In>, E2, R2>): <A, L, E, R>(self: Sink<A, In, L, E, R>) => Sink<A, In0, L, E2 | E, R2 | R>; <A, In, L, E, R, In0, E2, R2>(self: Sink<A, In, L, E, R>, f: (chunk: Chunk.Chunk<In0>) => Effect.Effect<Chunk.Chunk<In>, E2, R2>): Sink<A, In0, L, E | E2, R | R2>; }\n```\n\n----------------------------------------\n\nTITLE: Adding a Finalizer to a Sink in Effect\nDESCRIPTION: The `ensuringWith` function adds a finalizer to a sink. This finalizer is guaranteed to execute as long as the sink starts, regardless of whether it completes successfully or fails. The finalizer receives the `Exit` value of the sink's execution, allowing it to access information about the result (success or failure) and any errors that occurred.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Sink-ensuringWith.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const ensuringWith: { <A, E, X, R2>(finalizer: (exit: Exit.Exit<A, E>) => Effect.Effect<X, never, R2>): <In, L, R>(self: Sink<A, In, L, E, R>) => Sink<A, In, L, E, R2 | R>; <A, In, L, E, R, X, R2>(self: Sink<A, In, L, E, R>, finalizer: (exit: Exit.Exit<A, E>) => Effect.Effect<X, never, R2>): Sink<A, In, L, E, R | R2>; }\n```\n\n----------------------------------------\n\nTITLE: Defining whileOutputEffect Function in TypeScript for Effect Package\nDESCRIPTION: Declares a function that modifies an existing schedule to continue execution while an effectful condition holds true for its output. It takes a predicate function and returns a new schedule that stops when the predicate returns false.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Schedule-whileOutputEffect.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const whileOutputEffect: { <Out, R2>(f: (out: Out) => Effect.Effect<boolean, never, R2>): <In, R>(self: Schedule<Out, In, R>) => Schedule<Out, In, R2 | R>; <Out, In, R, R2>(self: Schedule<Out, In, R>, f: (out: Out) => Effect.Effect<boolean, never, R2>): Schedule<Out, In, R | R2>; }\n```\n\n----------------------------------------\n\nTITLE: Defining instanceOf Function in TypeScript for Effect-IO-AI\nDESCRIPTION: This snippet defines the instanceOf function, which creates a SafeRefinement for matching instances of a given class. It takes a constructor as an argument and returns a type-safe refinement for instances of that class.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Match-instanceOf.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const instanceOf: <A extends abstract new (...args: any) => any>(constructor: A) => SafeRefinement<InstanceType<A>, never>\n```\n\n----------------------------------------\n\nTITLE: Combining Chunks from Two Streams (TypeScript)\nDESCRIPTION: This function combines chunks from the current stream and another specified stream using a provided function 'f', which can maintain internal state through parameter 's'. The function returns a new stream containing the combined chunks and handles errors using Option.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-combineChunks.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const combineChunks: { <A2, E2, R2, S, R3, E, A, R4, R5, A3>(that: Stream<A2, E2, R2>, s: S, f: (s: S, pullLeft: Effect.Effect<Chunk.Chunk<A>, Option.Option<E>, R3>, pullRight: Effect.Effect<Chunk.Chunk<A2>, Option.Option<E2>, R4>) => Effect.Effect<Exit.Exit<readonly [Chunk.Chunk<A3>, S], Option.Option<E2 | E>>, never, R5>): <R>(self: Stream<A, E, R>) => Stream<A3, E2 | E, R2 | R3 | R4 | R5 | R>; <R, A2, E2, R2, S, R3, E, A, R4, R5, A3>(self: Stream<A, E, R>, that: Stream<A2, E2, R2>, s: S, f: (s: S, pullLeft: Effect.Effect<Chunk.Chunk<A>, Option.Option<E>, R3>, pullRight: Effect.Effect<Chunk.Chunk<A2>, Option.Option<E2>, R4>) => Effect.Effect<Exit.Exit<readonly [Chunk.Chunk<A3>, S], Option.Option<E2 | E>>, never, R5>): Stream<A3, E2 | E, R | R2 | R3 | R4 | R5>; }\n```\n\n----------------------------------------\n\nTITLE: Record.pop Example Usage in Effect\nDESCRIPTION: Demonstrates how to use the `Record.pop` function from the Effect library to retrieve and remove a value from a record. It uses `assert.deepStrictEqual` to verify the expected output, which is an Option containing a tuple of the removed value and the updated record, or Option.none() if the key is missing.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Record-pop.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { Record as R, Option } from \"effect\"\n\nassert.deepStrictEqual(R.pop({ a: 1, b: 2 }, \"a\"), Option.some([1, { b: 2 }]))\nassert.deepStrictEqual(R.pop({ a: 1, b: 2 } as Record<string, number>, \"c\"), Option.none())\n```\n\n----------------------------------------\n\nTITLE: Converting Nullable Values to Option in TypeScript with Effect\nDESCRIPTION: The 'Option.fromNullable' function is used to convert a nullable value into an Option type. If the provided value is null or undefined, it returns None; otherwise, it wraps the value in a Some. There are no explicit dependencies besides the 'effect' package, and the function expects a single parameter which is the potentially nullable value. It outputs an Option type that is either 'None' or 'Some', encapsulating the value if it exists.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Option-fromNullable.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Option } from \"effect\"\n\nconsole.log(Option.fromNullable(undefined))\n// Output: { _id: 'Option', _tag: 'None' }\n\nconsole.log(Option.fromNullable(null))\n// Output: { _id: 'Option', _tag: 'None' }\n\nconsole.log(Option.fromNullable(1))\n// Output: { _id: 'Option', _tag: 'Some', value: 1 }\n```\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const fromNullable: <A>(nullableValue: A) => Option<NonNullable<A>>\n```\n\n----------------------------------------\n\nTITLE: Checking HashMap Entries Using Custom Hash in TypeScript\nDESCRIPTION: The hasHash function checks if a specified key has an entry in a HashMap using a custom hash value. It offers two calling patterns via currying - one where the key and hash are provided first, followed by the HashMap, and another where the HashMap is provided first, followed by the key and hash.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/HashMap-hasHash.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const hasHash: { <K1>(key: K1, hash: number): <K, V>(self: HashMap<K, V>) => boolean; <K, V, K1>(self: HashMap<K, V>, key: K1, hash: number): boolean; }\n```\n\n----------------------------------------\n\nTITLE: Reversing Ordering Values in Effect\nDESCRIPTION: This example demonstrates how to use the `reverse` function from the `effect/Ordering` module to invert the ordering of values. It imports the `assert` module for testing and the `reverse` function from `effect/Ordering`. The example uses `assert.deepStrictEqual` to verify that the `reverse` function correctly inverts the ordering values 1, -1, and 0.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Ordering-reverse.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { reverse } from \"effect/Ordering\"\n\nassert.deepStrictEqual(reverse(1), -1)\nassert.deepStrictEqual(reverse(-1), 1)\nassert.deepStrictEqual(reverse(0), 0)\n```\n\n----------------------------------------\n\nTITLE: Checking Key Existence in FiberMap - TypeScript\nDESCRIPTION: Function signature for checking if a key exists within a FiberMap. The function supports both curried and non-curried invocation patterns and returns an Effect containing a boolean result.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/FiberMap-has.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const has: { <K>(key: K): <A, E>(self: FiberMap<K, A, E>) => Effect.Effect<boolean>; <K, A, E>(self: FiberMap<K, A, E>, key: K): Effect.Effect<boolean>; }\n```\n\n----------------------------------------\n\nTITLE: Adding Parent Span to Tracer in Effect Layer (TypeScript)\nDESCRIPTION: The parentSpan function adds a provided span to the span stack. It takes a Tracer.AnySpan as input and returns a Layer of Tracer.ParentSpan. This function is used for managing tracing spans in the Effect framework.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Layer-parentSpan.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const parentSpan: (span: Tracer.AnySpan) => Layer<Tracer.ParentSpan>\n```\n\n----------------------------------------\n\nTITLE: Creating Sink from Channel in TypeScript\nDESCRIPTION: Converts a Channel with specific type parameters into a Sink, enabling complex streaming data transformations with type safety and composability\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Sink-fromChannel.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const fromChannel: <L, In, E, A, R>(channel: Channel.Channel<Chunk.Chunk<L>, Chunk.Chunk<In>, E, never, A, unknown, R>) => Sink<A, In, L, E, R>\n```\n\n----------------------------------------\n\nTITLE: Converting Failure Channel to Either - STM Module TypeScript\nDESCRIPTION: This TypeScript snippet demonstrates how to convert the failure channel of an STM into an Either type. This is useful for functionally handling errors without throwing exceptions. The core functionality is provided by the `either` function, which requires an instance of STM as input and returns a transformed STM with an Either type. The `Either` module from the external library Effect (v2.0.0) is a prerequisite.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/STM-either.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const either: <A, E, R>(self: STM<A, E, R>) => STM<Either.Either<A, E>, never, R>\n```\n\n----------------------------------------\n\nTITLE: Extracting Primary Defect from Cause Object in TypeScript\nDESCRIPTION: The squash function reduces a Cause to its most important defect following a priority order: first checking for failures, then defects, and finally creating an InterruptedException if the cause stems from an interruption. This is useful for error reporting and logging scenarios.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Cause-squash.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const squash: <E>(self: Cause<E>) => unknown\n```\n\n----------------------------------------\n\nTITLE: Implementing foldLeft Function in Effect Sink Module (TypeScript)\nDESCRIPTION: Defines a function that creates a sink which folds inputs with a provided function and initial state. The function takes an initial state of type S and a folding function that combines the current state with each input to produce a new state.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Sink-foldLeft.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const foldLeft: <S, In>(s: S, f: (s: S, input: In) => S) => Sink<S, In>\n```\n\n----------------------------------------\n\nTITLE: Formatting DateTime as ISO String with Offset in TypeScript\nDESCRIPTION: This function, formatIsoOffset, takes a DateTime object and returns a string formatted as an ISO date with an offset. It is part of the DateTime module in the effect package.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/DateTime-formatIsoOffset.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const formatIsoOffset: (self: DateTime) => string\n```\n\n----------------------------------------\n\nTITLE: Localizing FiberRef Values in RequestResolver\nDESCRIPTION: The locally function creates a new data source with a localized FiberRef value. It provides two overloaded versions: one that takes the FiberRef and value first, and another that takes the RequestResolver first.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/RequestResolver-locally.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const locally: { <A>(self: FiberRef<A>, value: A): <R, B extends Request.Request<any, any>>(use: RequestResolver<B, R>) => RequestResolver<B, R>; <R, B extends Request.Request<any, any>, A>(use: RequestResolver<B, R>, self: FiberRef<A>, value: A): RequestResolver<B, R>; }\n```\n\n----------------------------------------\n\nTITLE: Effect.custom Function Signature in TypeScript\nDESCRIPTION: Provides the TypeScript signature for the Effect.custom function. It shows overloads for different numbers of instructions (1 to 3) that can be passed to the function.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-custom.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const custom: { <X, A, E, R>(i0: X, body: (this: { effect_instruction_i0: X; }) => Effect<A, E, R>): Effect<A, E, R>; <X, Y, A, E, R>(i0: X, i1: Y, body: (this: { effect_instruction_i0: X; effect_instruction_i1: Y; }) => Effect<A, E, R>): Effect<A, E, R>; <X, Y, Z, A, E, R>(i0: X, i1: Y, i2: Z, body: (this: { effect_instruction_i0: X; effect_instruction_i1: Y; effect_instruction_i2: Z; }) => Effect<A, E, R>): Effect<A, E, R>; }\n```\n\n----------------------------------------\n\nTITLE: Parsing Cron Expressions in TypeScript with Effect-TS\nDESCRIPTION: Example of using the Cron.parse function to convert a cron expression string into a structured Cron object. The example demonstrates parsing a cron expression for scheduling at 04:00 on days 8-14 of each month.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Cron-parse.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { Cron, Either } from \"effect\"\n\n// At 04:00 on every day-of-month from 8 through 14.\nassert.deepStrictEqual(Cron.parse(\"0 0 4 8-14 * *\"), Either.right(Cron.make({\n  seconds: [0],\n  minutes: [0],\n  hours: [4],\n  days: [8, 9, 10, 11, 12, 13, 14],\n  months: [],\n  weekdays: []\n})))\n```\n\n----------------------------------------\n\nTITLE: Accessing Channel Context with a Function in TypeScript\nDESCRIPTION: The contextWith function allows accessing the environment context of a channel and transforming it with a provided function. It creates a channel that gives access to the environment and transforms it to the specified output.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Channel-contextWith.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const contextWith: <Env, OutDone>(f: (env: Context.Context<Env>) => OutDone) => Channel<never, unknown, never, unknown, OutDone, unknown, Env>\n```\n\n----------------------------------------\n\nTITLE: Defining TReentrantLock Interface in TypeScript\nDESCRIPTION: Defines the TReentrantLock interface that extends TReentrantLock.Proto. This interface represents a reentrant read/write lock that allows multiple concurrent readers but only one writer at a time. It includes readLock and writeLock methods for acquiring locks in scoped contexts.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TReentrantLock-TReentrantLock.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface TReentrantLock extends TReentrantLock.Proto {}\n```\n\n----------------------------------------\n\nTITLE: Defining Effect.succeedNone Type Signature in TypeScript\nDESCRIPTION: Type signature for the succeedNone function that returns an effect which succeeds with None (Option.Option<never>). This function creates an effect that represents the absence of a value without throwing an error.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-succeedNone.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const succeedNone: Effect<Option.Option<never>, never, never>\n```\n\n----------------------------------------\n\nTITLE: Creating Tagged Request Class in Effect\nDESCRIPTION: Example showing how to create a custom Request class with a tagged constructor. The example creates a MyRequest class with a string success type, never error type, and a name property.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Request-TaggedClass.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Request } from \"effect\"\n\ntype Success = string\ntype Error = never\n\nclass MyRequest extends Request.TaggedClass(\"MyRequest\")<Success, Error, {\n  readonly name: string\n}> {}\n```\n\n----------------------------------------\n\nTITLE: Creating SortedMap from Iterable Collection in TypeScript\nDESCRIPTION: The fromIterable function creates a new SortedMap from an iterable collection of key/value pairs. It requires an Order instance to determine the sorting of keys. The function supports two calling conventions for flexibility.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/SortedMap-fromIterable.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const fromIterable: { <B>(ord: Order<B>): <K extends B, V>(iterable: Iterable<readonly [K, V]>) => SortedMap<K, V>; <K extends B, V, B>(iterable: Iterable<readonly [K, V]>, ord: Order<B>): SortedMap<K, V>; }\n```\n\n----------------------------------------\n\nTITLE: Appending Elements to Tuples - Effect Library TypeScript\nDESCRIPTION: This function, `appendElement`, allows appending an element to the end of a tuple. It is implemented in TypeScript as part of the Effect library's Tuple module. The function accepts an argument 'that' of any type and combines it with an existing tuple 'self'. It is designed to maintain type safety using generics, ensuring that the element is properly added to the tuple. The function can take two forms: a curried version that first takes 'that' and then 'self', and a direct application form that takes both 'self' and 'that'. Since v2.0.0.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Tuple-appendElement.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const appendElement: { <B>(that: B): <A extends ReadonlyArray<unknown>>(self: A) => [...A, B]; <A extends ReadonlyArray<unknown>, B>(self: A, that: B): [...A, B]; }\n```\n\n----------------------------------------\n\nTITLE: Implementing Cursor Positioning in TypeScript with Effect Printer ANSI\nDESCRIPTION: The cursorTo function moves the terminal cursor to specified column and optional row coordinates. It takes 0-based indices as input but adjusts them to the 1-based values required by ANSI control sequences. Row parameter is optional.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Ansi-cursorTo.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const cursorTo: (column: number, row?: number) => Ansi\n```\n\n----------------------------------------\n\nTITLE: Combining BigInt Values Using MonoidMultiply - TypeScript\nDESCRIPTION: This snippet demonstrates the usage of the MonoidMultiply from the '@effect/typeclass/data/BigInt' module. It shows how to combine two BigInt values and how to use the empty value for multiplication. The expected output for the first combine operation is 6n, while combining with the empty value returns the other value, here 2n.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/data-BigInt-MonoidMultiply.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { MonoidMultiply } from \"@effect/typeclass/data/BigInt\"\n\nconsole.log(MonoidMultiply.combine(2n, 3n))\n// 6n\nconsole.log(MonoidMultiply.combine(2n, MonoidMultiply.empty))\n// 2n\n```\n\n----------------------------------------\n\nTITLE: Offering Element to MutableQueue in TypeScript\nDESCRIPTION: Defines a method to offer an element to a MutableQueue in TypeScript, returning success status. It requires the 'effect' package and the MutableQueue module. Parameters include the queue itself and the value to be enqueued, returning a boolean indicating success.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/MutableQueue-offer.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const offer: { <A>(self: MutableQueue<A>, value: A): boolean; <A>(value: A): (self: MutableQueue<A>) => boolean; }\n```\n\n----------------------------------------\n\nTITLE: Defining Sink.race Method in TypeScript\nDESCRIPTION: The race method runs two sinks in parallel on the same input, returning the result or error from whichever one finishes first. This allows for competitive execution of data sinks. The method provides two call signatures for flexibility.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Sink-race.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const race: { <R1, E1, In1, L1, A1>(that: Sink<A1, In1, L1, E1, R1>): <A, In, L, E, R>(self: Sink<A, In, L, E, R>) => Sink<A1 | A, In & In1, L1 | L, E1 | E, R1 | R>; <A, In, L, E, R, A1, In1, L1, E1, R1>(self: Sink<A, In, L, E, R>, that: Sink<A1, In1, L1, E1, R1>): Sink<A | A1, In & In1, L | L1, E | E1, R | R1>; }\n```\n\n----------------------------------------\n\nTITLE: Defining concatAllWith Function for Channel Concatenation in TypeScript\nDESCRIPTION: This function concatenates a channel of channels sequentially. It takes three parameters: the channels to concatenate, a function to combine output values, and a function to combine the final output with the overall output.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Channel-concatAllWith.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const concatAllWith: <OutElem, InElem2, OutErr2, InErr2, OutDone, InDone2, Env2, InElem, OutErr, InErr, OutDone2, InDone, Env, OutDone3>(channels: Channel<Channel<OutElem, InElem2, OutErr2, InErr2, OutDone, InDone2, Env2>, InElem, OutErr, InErr, OutDone2, InDone, Env>, f: (o: OutDone, o1: OutDone) => OutDone, g: (o: OutDone, o2: OutDone2) => OutDone3) => Channel<OutElem, InElem & InElem2, OutErr2 | OutErr, InErr & InErr2, OutDone3, InDone & InDone2, Env2 | Env>\n```\n\n----------------------------------------\n\nTITLE: Implementing Sink Collection in TypeScript\nDESCRIPTION: Function signature for collectAllFrom, which takes a Sink and returns a new Sink that accumulates results into a Chunk. The function processes input of type In, produces output of type A, and handles errors of type E within context R.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Sink-collectAllFrom.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const collectAllFrom: <A, In, L extends In, E, R>(self: Sink<A, In, L, E, R>) => Sink<Chunk.Chunk<A>, In, L, E, R>\n```\n\n----------------------------------------\n\nTITLE: Stream.partitionEither Function Signature in TypeScript\nDESCRIPTION: This code snippet shows the TypeScript signature of the Stream.partitionEither function. It defines the function's type, including its parameters and return type, demonstrating its polymorphic nature and the use of generics.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-partitionEither.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const partitionEither: { <A, A3, A2, E2, R2>(predicate: (a: NoInfer<A>) => Effect.Effect<Either.Either<A3, A2>, E2, R2>, options?: { readonly bufferSize?: number | undefined; } | undefined): <E, R>(self: Stream<A, E, R>) => Effect.Effect<[left: Stream<A2, E2 | E, never>, right: Stream<A3, E2 | E, never>], E2 | E, Scope.Scope | R2 | R>; <A, E, R, A3, A2, E2, R2>(self: Stream<A, E, R>, predicate: (a: A) => Effect.Effect<Either.Either<A3, A2>, E2, R2>, options?: { readonly bufferSize?: number | undefined; } | undefined): Effect.Effect<[left: Stream<A2, E | E2, never>, right: Stream<A3, E | E2, never>], E | E2, Scope.Scope | R | R2>; }\n```\n\n----------------------------------------\n\nTITLE: Defining orElseFail Function for Stream in TypeScript\nDESCRIPTION: Declares the orElseFail function for Stream, which fails with a given error if the original stream fails with a typed error. It can be used in two ways: by passing the error first, or by passing the stream first and then the error.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-orElseFail.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const orElseFail: { <E2>(error: LazyArg<E2>): <A, E, R>(self: Stream<A, E, R>) => Stream<A, E2, R>; <A, E, R, E2>(self: Stream<A, E, R>, error: LazyArg<E2>): Stream<A, E2, R>; }\n```\n\n----------------------------------------\n\nTITLE: Checking if ExecutionStrategy is Parallel in TypeScript\nDESCRIPTION: A function that determines whether the provided ExecutionStrategy is an instance of Parallel. Returns true for Parallel strategies and false otherwise. This function uses TypeScript type predicates for type narrowing.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/ExecutionStrategy-isParallel.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const isParallel: (self: ExecutionStrategy) => self is Parallel\n```\n\n----------------------------------------\n\nTITLE: Implementing List.flatMap Type Definition in TypeScript\nDESCRIPTION: Type definition for the flatMap function that maps and concatenates list elements. The function accepts a mapping function that transforms each element and index into a new list, then flattens the results. Supports both regular Lists and Cons (non-empty lists).\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/List-flatMap.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const flatMap: { \n  <S extends List<any>, T extends List<any>>(f: (a: List.Infer<S>, i: number) => T): (self: S) => List.AndNonEmpty<S, T, List.Infer<T>>; \n  <A, B>(self: Cons<A>, f: (a: A, i: number) => Cons<B>): Cons<B>; \n  <A, B>(self: List<A>, f: (a: A, i: number) => List<B>): List<B>; \n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Sink with the Last Value in TypeScript\nDESCRIPTION: A function that creates a sink containing only the last value processed. It returns an Option type that will be None if no values were processed, or Some containing the last value.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Sink-last.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const last: <In>() => Sink<Option.Option<In>, In, In>\n```\n\n----------------------------------------\n\nTITLE: Ordering.match Function Signature - TypeScript\nDESCRIPTION: This snippet defines the TypeScript signature for the 'Ordering.match' function, which is overloaded to accept both an options object and an ordering value. It highlights the expected parameters and return types, facilitating type safety and autocompletion in TypeScript environments.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Ordering-match.md#2025-04-11_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const match: { <A, B, C = B>(options: { readonly onLessThan: LazyArg<A>; readonly onEqual: LazyArg<B>; readonly onGreaterThan: LazyArg<C>; }): (self: Ordering) => A | B | C; <A, B, C = B>(o: Ordering, options: { readonly onLessThan: LazyArg<A>; readonly onEqual: LazyArg<B>; readonly onGreaterThan: LazyArg<C>; }): A | B | C; }\n```\n\n----------------------------------------\n\nTITLE: Layer Error Mapping Function Definition in TypeScript\nDESCRIPTION: Defines an overloaded function for mapping error types in Effect-TS layers. The function takes either an error mapping function first followed by a layer, or a layer followed by an error mapping function, and returns a new layer with transformed error type.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Layer-mapError.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const mapError: { <E, E2>(f: (error: E) => E2): <A, R>(self: Layer<A, E, R>) => Layer<A, E2, R>; <A, E, R, E2>(self: Layer<A, E, R>, f: (error: E) => E2): Layer<A, E2, R>; }\n```\n\n----------------------------------------\n\nTITLE: TypeScript Signature for Array.zipWith Function\nDESCRIPTION: This code block provides the TypeScript signature for the Array.zipWith function. It shows various overloads for different input types, including NonEmptyReadonlyArray and Iterable.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Array-zipWith.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const zipWith: { <B, A, C>(that: NonEmptyReadonlyArray<B>, f: (a: A, b: B) => C): (self: NonEmptyReadonlyArray<A>) => NonEmptyArray<C>; <B, A, C>(that: Iterable<B>, f: (a: A, b: B) => C): (self: Iterable<A>) => Array<C>; <A, B, C>(self: NonEmptyReadonlyArray<A>, that: NonEmptyReadonlyArray<B>, f: (a: A, b: B) => C): NonEmptyArray<C>; <B, A, C>(self: Iterable<A>, that: Iterable<B>, f: (a: A, b: B) => C): Array<C>; }\n```\n\n----------------------------------------\n\nTITLE: Using Array.unprepend to Split an Array in TypeScript\nDESCRIPTION: Demonstrates how to use Array.unprepend to extract the first element and remaining elements from an array. It returns a tuple where the first element is the head of the array and the second element is an array containing the remaining elements.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Array-unprepend.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Array } from \"effect\";\n\nconst result = Array.unprepend([1, 2, 3, 4])\nconsole.log(result) // [1, [2, 3, 4]]\n```\n\n----------------------------------------\n\nTITLE: Peeking First Element from TypeScript Priority Queue\nDESCRIPTION: A functional method that retrieves the first element of a priority queue without removing it, returning an Option type to handle potential empty queue scenarios\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TPriorityQueue-peekOption.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const peekOption: <A>(self: TPriorityQueue<A>) => STM.STM<Option.Option<A>>\n```\n\n----------------------------------------\n\nTITLE: Constructing a Channel from a Scoped Effect in TypeScript\nDESCRIPTION: The unwrapScoped function constructs a Channel from a scoped effect that will result in a Channel if successful. It takes a scoped Effect that produces a Channel and returns a new Channel, unwrapping the inner Channel while preserving the scope's lifetime.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Channel-unwrapScoped.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const unwrapScoped: <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, E, R>(self: Effect.Effect<Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>, E, R>) => Channel<OutElem, InElem, E | OutErr, InErr, OutDone, InDone, Env | Exclude<R, Scope.Scope>>\n```\n\n----------------------------------------\n\nTITLE: Implementing Client-Only Runners Layer in Effect Cluster\nDESCRIPTION: A TypeScript function that creates a Runners layer for client-only operation. This layer will not register with the ShardManager or receive shard assignments, making it suitable for embedding a cluster client inside another effect application.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/RunnerServer-layerClientOnly.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const layerClientOnly: Layer.Layer<Sharding.Sharding | Runners.Runners, never, MessageStorage.MessageStorage | ShardingConfig | Runners.RpcClientProtocol>\n```\n\n----------------------------------------\n\nTITLE: Calculating Time Zone Offset for Zoned DateTime in TypeScript\nDESCRIPTION: This function calculates the time zone offset of a DateTime.Zoned object in milliseconds. It takes a Zoned object as input and returns a number representing the offset.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/DateTime-zonedOffset.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const zonedOffset: (self: Zoned) => number\n```\n\n----------------------------------------\n\nTITLE: Defining Micro.andThen Function Signature in TypeScript\nDESCRIPTION: TypeScript type declaration for the andThen function that provides flexible chaining of Micro effects. It supports both function and non-function arguments, combining map and flatMap functionality into a single API. The function can handle direct Micro effect passing and maintains proper type inference for error and environment types.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Micro-andThen.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const andThen: { <A, X>(f: (a: A) => X): <E, R>(self: Micro<A, E, R>) => [X] extends [Micro<infer A1, infer E1, infer R1>] ? Micro<A1, E | E1, R | R1> : Micro<X, E, R>; <X>(f: NotFunction<X>): <A, E, R>(self: Micro<A, E, R>) => [X] extends [Micro<infer A1, infer E1, infer R1>] ? Micro<A1, E | E1, R | R1> : Micro<X, E, R>; <A, E, R, X>(self: Micro<A, E, R>, f: (a: A) => X): [X] extends [Micro<infer A1, infer E1, infer R1>] ? Micro<A1, E | E1, R | R1> : Micro<X, E, R>; <A, E, R, X>(self: Micro<A, E, R>, f: NotFunction<X>): [X] extends [Micro<infer A1, infer E1, infer R1>] ? Micro<A1, E | E1, R | R1> : Micro<X, E, R>; }\n```\n\n----------------------------------------\n\nTITLE: Defining Effect.forkAll Function in TypeScript\nDESCRIPTION: Defines the Effect.forkAll function, which forks multiple effects and returns a composite fiber. It has overloads for discarding results and handling different input types.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-forkAll.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const forkAll: {\n  (options?: { readonly discard?: false | undefined; } | undefined): <Eff extends Effect<any, any, any>>(effects: Iterable<Eff>) => Effect<Fiber.Fiber<Array<Effect.Success<Eff>>, Effect.Error<Eff>>, never, Effect.Context<Eff>>;\n  (options: { readonly discard: true; }): <Eff extends Effect<any, any, any>>(effects: Iterable<Eff>) => Effect<void, never, Effect.Context<Eff>>;\n  <Eff extends Effect<any, any, any>>(effects: Iterable<Eff>, options?: { readonly discard?: false | undefined; } | undefined): Effect<Fiber.Fiber<Array<Effect.Success<Eff>>, Effect.Error<Eff>>, never, Effect.Context<Eff>>;\n  <Eff extends Effect<any, any, any>>(effects: Iterable<Eff>, options: { readonly discard: true; }): Effect<void, never, Effect.Context<Eff>>;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining HttpClient.retry Function in TypeScript\nDESCRIPTION: Declares the retry function for HttpClient, which allows retrying requests based on a schedule or policy. It supports various overloads for different use cases, including options-based and policy-based retries.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/HttpClient-retry.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const retry: {\n  <E, O extends NoExcessProperties<Effect.Retry.Options<E>, O>>(options: O): <R>(self: HttpClient.With<E, R>) => Retry.Return<R, E, O>;\n  <B, E, R1>(policy: Schedule.Schedule<B, NoInfer<E>, R1>): <R>(self: HttpClient.With<E, R>) => HttpClient.With<E, R1 | R>;\n  <E, R, O extends NoExcessProperties<Effect.Retry.Options<E>, O>>(self: HttpClient.With<E, R>, options: O): Retry.Return<R, E, O>;\n  <E, R, B, R1>(self: HttpClient.With<E, R>, policy: Schedule.Schedule<B, E, R1>): HttpClient.With<E, R1 | R>;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Sequential Interface in TypeScript\nDESCRIPTION: Interface definition for Sequential composition of Causes in Effect.ts. This interface represents sequential error composition, maintaining both errors when a main effect and its finalizer fail. It extends Cause.Variance, Equal.Equal, Pipeable, and Inspectable interfaces.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Cause-Sequential.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface Sequential<out E> extends Cause.Variance<E>, Equal.Equal, Pipeable, Inspectable {\n  readonly _tag: \"Sequential\"\n  readonly left: Cause<E>\n  readonly right: Cause<E>\n}\n```\n\n----------------------------------------\n\nTITLE: Parallel Zipping Exit Results in TypeScript\nDESCRIPTION: The zipPar function parallelly combines two Exit results into a tuple. If either Exit is a failure, it returns the combined Cause of the failures. This operation is useful for concurrent processing of Exit instances.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Exit-zipPar.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const zipPar: { <A2, E2>(that: Exit<A2, E2>): <A, E>(self: Exit<A, E>) => Exit<[A, A2], E2 | E>; <A, E, A2, E2>(self: Exit<A, E>, that: Exit<A2, E2>): Exit<[A, A2], E | E2>; }\n```\n\n----------------------------------------\n\nTITLE: Setting DateTime Timezone Using IANA Identifier in TypeScript\nDESCRIPTION: Demonstrates how to set a DateTime's timezone using an IANA timezone identifier. The function throws an IllegalArgumentException if the timezone is invalid. Supports optional adjustment for timezone differences.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/DateTime-unsafeSetZoneNamed.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { DateTime, Effect } from \"effect\"\n\nEffect.gen(function* () {\n  const now = yield* DateTime.now\n  // set the time zone\n  DateTime.unsafeSetZoneNamed(now, \"Europe/London\")\n})\n```\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const unsafeSetZoneNamed: { (zoneId: string, options?: { readonly adjustForTimeZone?: boolean | undefined; }): (self: DateTime) => Zoned; (self: DateTime, zoneId: string, options?: { readonly adjustForTimeZone?: boolean | undefined; }): Zoned; }\n```\n\n----------------------------------------\n\nTITLE: Setting Working Directory Configuration in Effect Platform Commands\nDESCRIPTION: Defines a function to set the working directory for command execution. The function supports both curried and non-curried calling styles, allowing configuration of working directory for both single commands and piped command sequences.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Command-workingDirectory.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const workingDirectory: { (cwd: string): (self: Command) => Command; (self: Command, cwd: string): Command; }\n```\n\n----------------------------------------\n\nTITLE: Initializing Empty RedBlackTree in TypeScript\nDESCRIPTION: Creates an empty RedBlackTree instance with specified key type K and optional value type V. Requires an Order<K> parameter to define key comparison behavior for tree operations.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/RedBlackTree-empty.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const empty: <K, V = never>(ord: Order<K>) => RedBlackTree<K, V>\n```\n\n----------------------------------------\n\nTITLE: Declaring Permissions Layer for Browser Navigation\nDESCRIPTION: Creates a layer that provides access to browser permissions through the navigator.permissions API. This layer allows interaction with browser permission capabilities without directly exposing the underlying implementation.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Permissions-layer.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const layer: Layer.Layer<Permissions, never, never>\n```\n\n----------------------------------------\n\nTITLE: Creating HttpApiGroup in TypeScript\nDESCRIPTION: The 'make' function creates an HttpApiGroup with a specified identifier and optional topLevel flag. It returns an HttpApiGroup with generic type parameters for Id, request/response types, and topLevel status.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/HttpApiGroup-make.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const make: <const Id extends string, const TopLevel extends (true | false) = false>(identifier: Id, options?: { readonly topLevel?: TopLevel | undefined; }) => HttpApiGroup<Id, never, never, never, TopLevel>\n```\n\n----------------------------------------\n\nTITLE: Declaring provideServiceEffect Function in TypeScript\nDESCRIPTION: Type declaration for the provideServiceEffect function which creates a service using a Micro effect and adds it to the current context. The function supports two overloads - one where the tag and acquire parameters come first, and another where self comes first followed by tag and acquire.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Micro-provideServiceEffect.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const provideServiceEffect: { <I, S, E2, R2>(tag: Context.Tag<I, S>, acquire: Micro<S, E2, R2>): <A, E, R>(self: Micro<A, E, R>) => Micro<A, E | E2, Exclude<R, I> | R2>; <A, E, R, I, S, E2, R2>(self: Micro<A, E, R>, tag: Context.Tag<I, S>, acquire: Micro<S, E2, R2>): Micro<A, E | E2, Exclude<R, I> | R2>; }\n```\n\n----------------------------------------\n\nTITLE: Creating a Sink Halting with Defect - TypeScript\nDESCRIPTION: This snippet defines the dieSync function which creates a sink that halts with the specified defect. It leverages the LazyArg type to allow lazy evaluation of the defect value. The function signature indicates it returns a Sink that will never successfully output a value, represented by the 'never' type.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Sink-dieSync.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const dieSync: (evaluate: LazyArg<unknown>) => Sink<never, unknown>\n```\n\n----------------------------------------\n\nTITLE: Declaring Schema.Defect Class in TypeScript\nDESCRIPTION: Defines the Schema.Defect class for handling JavaScript errors. It decodes objects into Error instances and encodes Error instances back into plain objects, facilitating error serialization across network boundaries.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Schema-Defect.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare class Defect\n```\n\n----------------------------------------\n\nTITLE: Creating a Manual Resource in Effect TS\nDESCRIPTION: This code snippet declares a constant function 'manual', which creates a new Resource value that requires manual refreshing. The function takes an 'acquire' effect as an argument and returns a new Effect that represents the Resource. Note that automatic error retries are not handled within this function, and users should apply their own retry policies if desired.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Resource-manual.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const manual: <A, E, R>(acquire: Effect.Effect<A, E, R>) => Effect.Effect<Resource<A, E>, never, Scope.Scope | R>\n```\n\n----------------------------------------\n\nTITLE: Implementing a Chunk Generator with makeBy in TypeScript\nDESCRIPTION: A function that returns a Chunk of length n with each element initialized with f(i). The length parameter n is normalized to an integer greater than or equal to 1, ensuring a non-empty chunk is always returned.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Chunk-makeBy.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const makeBy: { <A>(f: (i: number) => A): (n: number) => NonEmptyChunk<A>; <A>(n: number, f: (i: number) => A): NonEmptyChunk<A>; }\n```\n\n----------------------------------------\n\nTITLE: Using BigInt.clamp to Restrict Values to a Range in TypeScript\nDESCRIPTION: Demonstrates how to use the BigInt.clamp function to ensure a BigInt value falls within a specified range. The function returns the minimum value if the input is below the range, the maximum value if above the range, or the original value if within range.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/BigInt-clamp.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { BigInt } from \"effect\"\n\nconst clamp = BigInt.clamp({ minimum: 1n, maximum: 5n })\n\nassert.equal(clamp(3n), 3n)\nassert.equal(clamp(0n), 1n)\nassert.equal(clamp(6n), 5n)\n```\n\n----------------------------------------\n\nTITLE: Defining STM filterOrFail TypeScript Signature\nDESCRIPTION: A complex type signature allowing conditional filtering of STM computations with customizable error handling. Supports both refinement and predicate-based filtering with the ability to generate specific error conditions.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/STM-filterOrFail.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const filterOrFail: { <A, B extends A, E2>(refinement: Refinement<NoInfer<A>, B>, orFailWith: (a: NoInfer<A>) => E2): <E, R>(self: STM<A, E, R>) => STM<B, E2 | E, R>; <A, E2>(predicate: Predicate<NoInfer<A>>, orFailWith: (a: NoInfer<A>) => E2): <E, R>(self: STM<A, E, R>) => STM<A, E2 | E, R>; <A, E, R, B extends A, E2>(self: STM<A, E, R>, refinement: Refinement<A, B>, orFailWith: (a: A) => E2): STM<B, E | E2, R>; <A, E, R, E2>(self: STM<A, E, R>, predicate: Predicate<A>, orFailWith: (a: A) => E2): STM<A, E | E2, R>; }\n```\n\n----------------------------------------\n\nTITLE: Defining HTTP Layer for ShardManager in TypeScript\nDESCRIPTION: Declares a constant layerHttp that creates an HTTP layer for the ShardManager server. It adds a route to the provided HttpRouter.Tag, defaulting to HttpRouter.Default. The layer has dependencies on various modules including ShardStorage, ShardingConfig, and HttpServer.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/HttpShardManager-layerHttp.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const layerHttp: Layer.Layer<ShardManager.ShardManager, never, ShardStorage | ShardingConfig | RpcSerialization.RpcSerialization | RunnerHealth.RunnerHealth | ShardManager.Config | HttpClient.HttpClient | HttpServer.HttpServer>\n```\n\n----------------------------------------\n\nTITLE: Interrupting Stream Evaluation with Effect-TS (TypeScript)\nDESCRIPTION: This snippet demonstrates the `interruptWhen` function, allowing a stream to be interrupted when a specified effect completes successfully. Dependencies include the `Effect-TS` library. The function takes an effect and a stream, returning a new stream that can be interrupted if the effect completes with a failure, propagating that failure. The signature supports both currying and direct application patterns.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-interruptWhen.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const interruptWhen: { <X, E2, R2>(effect: Effect.Effect<X, E2, R2>): <A, E, R>(self: Stream<A, E, R>) => Stream<A, E2 | E, R2 | R>; <A, E, R, X, E2, R2>(self: Stream<A, E, R>, effect: Effect.Effect<X, E2, R2>): Stream<A, E | E2, R | R2>; }\n```\n\n----------------------------------------\n\nTITLE: BigInt SemigroupMax Signature in Typescript\nDESCRIPTION: This code snippet shows the type declaration of the `SemigroupMax` constant.  It defines `SemigroupMax` as a `Semigroup` of type `bigint`.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/data-BigInt-SemigroupMax.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const SemigroupMax: semigroup.Semigroup<bigint>\n```\n\n----------------------------------------\n\nTITLE: Inheriting FiberRef Values in TypeScript using Effect\nDESCRIPTION: The `inheritAll` function allows inheriting values from all `FiberRef` instances into the current fiber. This operation resumes immediately without waiting. It takes a Fiber instance as an argument and returns an Effect that resolves to void.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Fiber-inheritAll.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const inheritAll: <A, E>(self: Fiber<A, E>) => Effect.Effect<void>\n```\n\n----------------------------------------\n\nTITLE: Type Signature for functionWithSpan in Effect Module\nDESCRIPTION: The type signature for Effect.functionWithSpan, showing the function parameters and return type. It accepts an object with body, options, and optional captureStackTrace properties, and returns a function that produces a unified Effect.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-functionWithSpan.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const functionWithSpan: <Args extends Array<any>, Ret extends Effect<any, any, any>>(options: { readonly body: (...args: Args) => Ret; readonly options: FunctionWithSpanOptions | ((...args: Args) => FunctionWithSpanOptions); readonly captureStackTrace?: boolean | undefined; }) => (...args: Args) => Unify.Unify<Ret>\n```\n\n----------------------------------------\n\nTITLE: Defining RuntimeFiber Interface in TypeScript for Effect Library\nDESCRIPTION: Definition of the RuntimeFiber interface that extends Fiber and provides runtime capabilities for effect execution. It includes methods for fiber management, status tracking, observer handling, and context access. This interface is fundamental for concurrent programming in the Effect library.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Fiber-RuntimeFiber.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface RuntimeFiber<out A, out E = never> extends Fiber<A, E>, Fiber.RuntimeVariance<A, E> {\n  /**\n   * Reads the current number of ops that have occurred since the last yield\n   */\n  get currentOpCount(): number\n\n  /**\n   * Reads the current value of a fiber ref\n   */\n  getFiberRef<X>(fiberRef: FiberRef<X>): X\n\n  /**\n   * The identity of the fiber.\n   */\n  id(): FiberId.Runtime\n\n  /**\n   * The status of the fiber.\n   */\n  readonly status: Effect.Effect<FiberStatus.FiberStatus>\n\n  /**\n   * Returns the current `RuntimeFlags` the fiber is running with.\n   */\n  readonly runtimeFlags: Effect.Effect<RuntimeFlags.RuntimeFlags>\n\n  /**\n   * Adds an observer to the list of observers.\n   */\n  addObserver(observer: (exit: Exit.Exit<A, E>) => void): void\n\n  /**\n   * Removes the specified observer from the list of observers that will be\n   * notified when the fiber exits.\n   */\n  removeObserver(observer: (exit: Exit.Exit<A, E>) => void): void\n\n  /**\n   * Retrieves all fiber refs of the fiber.\n   */\n  getFiberRefs(): FiberRefs.FiberRefs\n\n  /**\n   * Unsafely observes the fiber, but returns immediately if it is not\n   * already done.\n   */\n  unsafePoll(): Exit.Exit<A, E> | null\n\n  /**\n   * In the background, interrupts the fiber as if interrupted from the\n   * specified fiber. If the fiber has already exited, the returned effect will\n   * resume immediately. Otherwise, the effect will resume when the fiber exits.\n   */\n  unsafeInterruptAsFork(fiberId: FiberId.FiberId): void\n\n  /**\n   * Gets the current context\n   */\n  get currentContext(): Context<never>\n\n  /**\n   * Gets the current context\n   */\n  get currentDefaultServices(): Context<DefaultServices>\n\n  /**\n   * Gets the current scheduler\n   */\n  get currentScheduler(): Scheduler\n\n  /**\n   * Gets the current tracer\n   */\n  get currentTracer(): Tracer\n\n  /**\n   * Gets the current span\n   */\n  get currentSpan(): AnySpan | undefined\n\n  /**\n   * Gets the current supervisor\n   */\n  get currentSupervisor(): Supervisor<unknown>\n\n  readonly [Unify.typeSymbol]?: unknown\n  readonly [Unify.unifySymbol]?: RuntimeFiberUnify<this>\n  readonly [Unify.ignoreSymbol]?: RuntimeFiberUnifyIgnore\n}\n```\n\n----------------------------------------\n\nTITLE: Invalidating Resource Pool Items in TypeScript\nDESCRIPTION: This TypeScript snippet declares the 'invalidate' function, which is part of the 'effect' package's `Pool` module. The function supports lazy and eager item invalidation in an `Effect` framework-managed pool. Key parameters include the item to be invalidated and the pool instance. It outputs an `Effect` that ensures the item's scope is managed correctly. No external dependencies are required beyond the `effect` package itself.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Pool-invalidate.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const invalidate: { <A>(value: A): <E>(self: Pool<A, E>) => Effect.Effect<void, never, Scope.Scope>; <A, E>(self: Pool<A, E>, value: A): Effect.Effect<void, never, Scope.Scope>; }\n```\n\n----------------------------------------\n\nTITLE: Either.bind Function Signature\nDESCRIPTION: The TypeScript signature for the Either.bind function, showing its overloaded nature and type constraints. It defines how the function can be used to bind new values in an Either context.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Either-bind.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const bind: { <N extends string, A extends object, B, L2>(name: Exclude<N, keyof A>, f: (a: NoInfer<A>) => Either<B, L2>): <L1>(self: Either<A, L1>) => Either<{ [K in N | keyof A]: K extends keyof A ? A[K] : B; }, L1 | L2>; <A extends object, L1, N extends string, B, L2>(self: Either<A, L1>, name: Exclude<N, keyof A>, f: (a: NoInfer<A>) => Either<B, L2>): Either<{ [K in N | keyof A]: K extends keyof A ? A[K] : B; }, L1 | L2>; }\n```\n\n----------------------------------------\n\nTITLE: Defining withClockScoped function for Clock service implementation in Effect module\nDESCRIPTION: This function sets the implementation of the Clock service to a specified value and restores it to its original value when the scope is closed. It returns an Effect that requires a Scope, has no error channel, and produces void.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-withClockScoped.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const withClockScoped: <C extends Clock.Clock>(clock: C) => Effect<void, never, Scope.Scope>\n```\n\n----------------------------------------\n\nTITLE: Defining None RuntimeFlag in TypeScript\nDESCRIPTION: Declares a constant named 'None' representing the absence of any runtime flags in the effect system. This is used as a base value when no specific runtime flags need to be enabled.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/RuntimeFlags-None.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const None: RuntimeFlag\n```\n\n----------------------------------------\n\nTITLE: Type Checking Function for TDequeue in TypeScript\nDESCRIPTION: A function that checks if a given value is of type TDequeue. It returns true if the value is a TDequeue instance and false otherwise. This is useful for type narrowing in TypeScript.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TQueue-isTDequeue.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const isTDequeue: (u: unknown) => u is TDequeue<unknown>\n```\n\n----------------------------------------\n\nTITLE: Suspending Transaction Creation with TypeScript\nDESCRIPTION: This snippet defines the `suspend` function in the Effect STM module which allows the lazy suspension of the transaction creation. It takes a function `evaluate` of type `LazyArg<STM<A, E, R>>` and returns a suspended STM transaction which can be evaluated later. The function is designed to work with generic parameters A (input), E (error), and R (result). The function signature is useful in composing complex transactional workflows while deferring execution until necessary.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/STM-suspend.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const suspend: <A, E, R>(evaluate: LazyArg<STM<A, E, R>>) => STM<A, E, R>\n```\n\n----------------------------------------\n\nTITLE: Implementing HashMap.every Function in TypeScript\nDESCRIPTION: The every function checks if all entries in a HashMap meet a specific condition. It provides two call signatures for flexible usage - either passing a predicate function first, or passing the HashMap first. The predicate function receives both the value and key for each entry.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/HashMap-every.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const every: { <K, A>(predicate: (a: NoInfer<A>, k: K) => boolean): (self: HashMap<K, A>) => boolean; <K, A>(self: HashMap<K, A>, predicate: (a: A, k: K) => boolean): boolean; }\n```\n\n----------------------------------------\n\nTITLE: Creating single-valued pure stream in TypeScript\nDESCRIPTION: The function 'sync' is a declaration from the Effect-TS library (specifically from the Stream module). It creates a stream containing a single value, which is computed lazily. The evaluate parameter is a lazy argument that computes the value of type A. The function returns a Stream encapsulating type A, providing a mechanism to handle async operations with purity in a functional manner. The function assumes the presence of Effect-TS library as a dependency.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-sync.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const sync: <A>(evaluate: LazyArg<A>) => Stream<A>\n```\n\n----------------------------------------\n\nTITLE: Array.sortWith Type Definition\nDESCRIPTION: Type signature for the sortWith function showing supported parameter types and return values. Handles both empty and non-empty arrays, with generic type parameters for input and mapped values.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Array-sortWith.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const sortWith: { <S extends Iterable<any>, B>(f: (a: ReadonlyArray.Infer<S>) => B, order: Order.Order<B>): (self: S) => ReadonlyArray.With<S, ReadonlyArray.Infer<S>>; <A, B>(self: NonEmptyReadonlyArray<A>, f: (a: A) => B, O: Order.Order<B>): NonEmptyArray<A>; <A, B>(self: Iterable<A>, f: (a: A) => B, order: Order.Order<B>): Array<A>; }\n```\n\n----------------------------------------\n\nTITLE: Retrieving Keys from HashMap - TypeScript Effect Library\nDESCRIPTION: Function that returns an IterableIterator containing all keys stored within a HashMap data structure. The function takes a HashMap instance as input and provides type safety through generic parameters K and V representing key and value types.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/HashMap-keys.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const keys: <K, V>(self: HashMap<K, V>) => IterableIterator<K>\n```\n\n----------------------------------------\n\nTITLE: Serializing Cookie Object to String in TypeScript\nDESCRIPTION: Function signature for serializing a Cookie object into its string representation. Adapted from the fastify-cookie library under MIT License.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Cookies-serializeCookie.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const serializeCookie: (self: Cookie) => string\n```\n\n----------------------------------------\n\nTITLE: Removing Elements from TSet in TypeScript\nDESCRIPTION: The 'removeAll' function removes elements from a transactional set (TSet) by taking an iterable collection. It requires the Effect-TS STM module to handle transactional memory operations. This utility is designed for concurrent usage in functional programming scenarios. The function accepts either the set and iterable together or in a curried form, returning an STM action.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TSet-removeAll.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const removeAll: { <A>(iterable: Iterable<A>): (self: TSet<A>) => STM.STM<void>; <A>(self: TSet<A>, iterable: Iterable<A>): STM.STM<void>; }\n```\n\n----------------------------------------\n\nTITLE: Implementing Fiber.mapFiber Function in TypeScript\nDESCRIPTION: A function that passes the success value of a fiber to a callback function, which returns a new fiber. The function then continues with this returned fiber. This enables chaining fiber operations where the result of one fiber determines the next fiber to execute.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Fiber-mapFiber.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const mapFiber: { <E, E2, A, B>(f: (a: A) => Fiber<B, E2>): (self: Fiber<A, E>) => Effect.Effect<Fiber<B, E | E2>>; <A, E, E2, B>(self: Fiber<A, E>, f: (a: A) => Fiber<B, E2>): Effect.Effect<Fiber<B, E | E2>>; }\n```\n\n----------------------------------------\n\nTITLE: Inheriting FiberRef Values in TypeScript using Effect\nDESCRIPTION: This function inherits values from all FiberRef instances from a child fiber into the current fiber. It takes a FiberRefs parameter and returns an Effect that completes with void when inheritance is done.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-inheritFiberRefs.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const inheritFiberRefs: (childFiberRefs: FiberRefs.FiberRefs) => Effect<void>\n```\n\n----------------------------------------\n\nTITLE: Array.partition TypeScript Function Signature\nDESCRIPTION: The complete type signature for the Array.partition function. It supports both predicates and type refinements, and can be used in both curried and non-curried forms.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Array-partition.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const partition: { <A, B extends A>(refinement: (a: NoInfer<A>, i: number) => a is B): (self: Iterable<A>) => [excluded: Array<Exclude<A, B>>, satisfying: Array<B>]; <A>(predicate: (a: NoInfer<A>, i: number) => boolean): (self: Iterable<A>) => [excluded: Array<A>, satisfying: Array<A>]; <A, B extends A>(self: Iterable<A>, refinement: (a: A, i: number) => a is B): [excluded: Array<Exclude<A, B>>, satisfying: Array<B>]; <A>(self: Iterable<A>, predicate: (a: A, i: number) => boolean): [excluded: Array<A>, satisfying: Array<A>]; }\n```\n\n----------------------------------------\n\nTITLE: Retrieving Last Element from List in TypeScript\nDESCRIPTION: The 'last' function returns the last element of the specified list, or None if the list is empty. It takes a List<A> as input and returns an Option<A>.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/List-last.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const last: <A>(self: List<A>) => Option.Option<A>\n```\n\n----------------------------------------\n\nTITLE: Retrieving Sized Test Service in Effect TypeScript\nDESCRIPTION: Provides a function to retrieve the Sized service for a test and execute a workflow with it. Allows dynamic test sizing and configuration through the Sized.TestSized interface.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TestServices-sizedWith.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const sizedWith: <A, E, R>(f: (sized: Sized.TestSized) => Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>\n```\n\n----------------------------------------\n\nTITLE: Filtering with Exceptions in STM - TypeScript\nDESCRIPTION: The filterOrDieMessage function allows for filtering on STM objects with a conditional predicate or refinement. If the condition fails, it results in a RuntimeException with the given message. It is crucial for ensuring that certain constraints are met or otherwise handled through exceptions. Dependencies include the Refinement and Predicate types, and it primarily involves STM object manipulations, returning a modified or original STM object.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/STM-filterOrDieMessage.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const filterOrDieMessage: { <A, B extends A>(refinement: Refinement<NoInfer<A>, B>, message: string): <E, R>(self: STM<A, E, R>) => STM<B, E, R>; <A>(predicate: Predicate<NoInfer<A>>, message: string): <E, R>(self: STM<A, E, R>) => STM<A, E, R>; <A, E, R, B extends A>(self: STM<A, E, R>, refinement: Refinement<A, B>, message: string): STM<B, E, R>; <A, E, R>(self: STM<A, E, R>, predicate: Predicate<A>, message: string): STM<A, E, R>; }\n```\n\n----------------------------------------\n\nTITLE: Creating Non-Empty String Configuration in Effect-TS\nDESCRIPTION: The nonEmptyString function constructs a config for a non-empty string value. It optionally accepts a name parameter to identify the configuration entry and returns a Config object that validates the input is a non-empty string.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Config-nonEmptyString.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const nonEmptyString: (name?: string) => Config<string>\n```\n\n----------------------------------------\n\nTITLE: Executing Workflows with Lock in TypeScript\nDESCRIPTION: The withLock function allows for executing a specified workflow under the protection of a TReentrantLock, ensuring thread safety during concurrent operations. It offers flexibility with function overloading to accept either a TReentrantLock instance as the first argument or as a second argument after the effect. This function is part of the Effect library for functional programming in TypeScript.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TReentrantLock-withLock.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const withLock: { (self: TReentrantLock): <A, E, R>(effect: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>; <A, E, R>(effect: Effect.Effect<A, E, R>, self: TReentrantLock): Effect.Effect<A, E, R>; }\n```\n\n----------------------------------------\n\nTITLE: Defining Stream Repetition with Optional Error Handling in TypeScript\nDESCRIPTION: Creates a stream that repeatedly executes an effect producing chunks of values, stopping when the effect returns None. Supports generic type parameters for chunk values, error types, and effect requirements.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-repeatEffectChunkOption.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const repeatEffectChunkOption: <A, E, R>(effect: Effect.Effect<Chunk.Chunk<A>, Option.Option<E>, R>) => Stream<A, E, R>\n```\n\n----------------------------------------\n\nTITLE: Defining Stream.chunksWith TypeScript Function Signature\nDESCRIPTION: A complex TypeScript function signature for stream chunk transformation that supports curried and direct function application. Allows transforming stream chunks with full type safety and preservation of error and resource contexts.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-chunksWith.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const chunksWith: { <A, E, R, A2, E2, R2>(f: (stream: Stream<Chunk.Chunk<A>, E, R>) => Stream<Chunk.Chunk<A2>, E2, R2>): (self: Stream<A, E, R>) => Stream<A2, E | E2, R | R2>; <A, E, R, A2, E2, R2>(self: Stream<A, E, R>, f: (stream: Stream<Chunk.Chunk<A>, E, R>) => Stream<Chunk.Chunk<A2>, E2, R2>): Stream<A2, E | E2, R | R2>; }\n```\n\n----------------------------------------\n\nTITLE: Defining Effect.matchEffect Function Signature (TypeScript)\nDESCRIPTION: Provides the TypeScript function signature for Effect.matchEffect. It shows the complex type definition including generics for handling different effect types and outcomes.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-matchEffect.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const matchEffect: { <E, A2, E2, R2, A, A3, E3, R3>(options: { readonly onFailure: (e: E) => Effect<A2, E2, R2>; readonly onSuccess: (a: A) => Effect<A3, E3, R3>; }): <R>(self: Effect<A, E, R>) => Effect<A2 | A3, E2 | E3, R2 | R3 | R>; <A, E, R, A2, E2, R2, A3, E3, R3>(self: Effect<A, E, R>, options: { readonly onFailure: (e: E) => Effect<A2, E2, R2>; readonly onSuccess: (a: A) => Effect<A3, E3, R3>; }): Effect<A2 | A3, E2 | E3, R2 | R3 | R>; }\n```\n\n----------------------------------------\n\nTITLE: Using Function.apply to Apply a Function to a Value in TypeScript\nDESCRIPTION: Demonstrates how to use the apply function from the effect/Function module to apply a function to a given value. The example shows applying the length function from effect/String to a string value.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Function-apply.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { pipe, apply } from \"effect/Function\"\nimport { length } from \"effect/String\"\n\nassert.deepStrictEqual(pipe(length, apply(\"hello\")), 5)\n```\n\n----------------------------------------\n\nTITLE: Configuring HTTP Redirect Behavior in TypeScript\nDESCRIPTION: The followRedirects function configures an HttpClient to follow HTTP redirects up to a specified number of times. It can be used with or without specifying the maximum number of redirects.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/HttpClient-followRedirects.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const followRedirects: { (maxRedirects?: number | undefined): <E, R>(self: HttpClient.With<E, R>) => HttpClient.With<E, R>; <E, R>(self: HttpClient.With<E, R>, maxRedirects?: number | undefined): HttpClient.With<E, R>; }\n```\n\n----------------------------------------\n\nTITLE: Creating a Bounded MutableQueue in TypeScript\nDESCRIPTION: This code snippet declares a constant 'bounded' which is a function that creates a new bounded MutableQueue with a specified capacity. It is a generic function that accepts a number representing the capacity and returns a MutableQueue of the same type specified by parameter A. This snippet is intended for use in the Effect-TS framework and requires TypeScript as a prerequisite.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/MutableQueue-bounded.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const bounded: <A>(capacity: number) => MutableQueue<A>\n```\n\n----------------------------------------\n\nTITLE: Declaring TSet.takeSome Transactional Extraction Method\nDESCRIPTION: A utility method in the Effect library that takes matching values from a transactional set, with built-in retry logic to ensure at least one value is returned. Supports two function signatures for flexible usage.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TSet-takeSome.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const takeSome: { <A, B>(pf: (a: A) => Option.Option<B>): (self: TSet<A>) => STM.STM<[B, ...Array<B>]>; <A, B>(self: TSet<A>, pf: (a: A) => Option.Option<B>): STM.STM<[B, ...Array<B>]>; }\n```\n\n----------------------------------------\n\nTITLE: Constructing Left Either Instances in TypeScript\nDESCRIPTION: The left function constructs a new Either holding a Left value. It's typically used to represent a failure case in the Either structure, which is right-biased. The function takes a single parameter of type L and returns an Either<never, L>.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Either-left.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const left: <L>(left: L) => Either<never, L>\n```\n\n----------------------------------------\n\nTITLE: Implementing Effectful Folding of Chunks with Sink.foldChunksEffect in TypeScript\nDESCRIPTION: Defines a sink that effectfully folds input chunks using a provided function, termination predicate, and initial state. The continuation function is checked for the initial value and after processing each chunk. Both the folding function and continuation function must preserve chunking-invariance.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Sink-foldChunksEffect.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const foldChunksEffect: <S, In, E, R>(s: S, contFn: Predicate<S>, f: (s: S, chunk: Chunk.Chunk<In>) => Effect.Effect<S, E, R>) => Sink<S, In, In, E, R>\n```\n\n----------------------------------------\n\nTITLE: Applying Effectful Transformation to Schedule Output in TypeScript\nDESCRIPTION: The `mapEffect` function modifies an existing Schedule by applying a provided effectful function to its output values. It retains the original timing and recurrence characteristics of the Schedule, enabling the use of side effects or asynchronous processing before the final output is utilized. This is pertinent for scenarios involving transformations that need to manage effects in scheduling.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Schedule-mapEffect.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const mapEffect: { <Out, Out2, R2>(f: (out: Out) => Effect.Effect<Out2, never, R2>): <In, R>(self: Schedule<Out, In, R>) => Schedule<Out2, In, R2 | R>; <Out, In, R, Out2, R2>(self: Schedule<Out, In, R>, f: (out: Out) => Effect.Effect<Out2, never, R2>): Schedule<Out2, In, R | R2>; };\n```\n\n----------------------------------------\n\nTITLE: Stream Finalizer Type Signature\nDESCRIPTION: Official type declaration for Stream.finalizer method, demonstrating its generic type parameters and effect handling\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-finalizer.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const finalizer: <R, X>(finalizer: Effect.Effect<X, never, R>) => Stream<void, never, R>\n```\n\n----------------------------------------\n\nTITLE: Retrieving Root Fibers in Effect-TS\nDESCRIPTION: Function that returns an array of all root fibers in the Effect runtime system. This is an unsafe operation that provides access to the underlying fiber management system.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Fiber-unsafeRoots.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const unsafeRoots: (_: void) => Array<RuntimeFiber<any, any>>\n```\n\n----------------------------------------\n\nTITLE: Using DateTime.getPart to Extract Year from DateTime in TypeScript\nDESCRIPTION: This example demonstrates how to use the DateTime.getPart function to extract the year from a DateTime object. It creates a DateTime instance for the year 2024 in the Europe/London time zone and then retrieves the year value.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/DateTime-getPart.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { DateTime } from \"effect\"\n\nconst now = DateTime.unsafeMakeZoned({ year: 2024 }, { timeZone: \"Europe/London\" })\nconst year = DateTime.getPart(now, \"year\")\nassert.strictEqual(year, 2024)\n```\n\n----------------------------------------\n\nTITLE: Using Cause.stripFailures to Remove Failures and Interrupts in TypeScript\nDESCRIPTION: The stripFailures function removes Fail and Interrupt nodes from a Cause, keeping only defects (Die). It returns a Cause<never> directly, which can still store Die or finalizer-related defects. This is useful for analyzing only the irrecoverable portion of an error.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Cause-stripFailures.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const stripFailures: <E>(self: Cause<E>) => Cause<never>\n```\n\n----------------------------------------\n\nTITLE: Implementing Chunk Differ in TypeScript\nDESCRIPTION: Function signature for constructing a differ that can process Chunks of values using an existing differ implementation. Takes a differ for individual values and returns a new differ that works with Chunks of those values.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Differ-chunk.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const chunk: <Value, Patch>(differ: Differ<Value, Patch>) => Differ<Chunk<Value>, Differ.Chunk.Patch<Value, Patch>>\n```\n\n----------------------------------------\n\nTITLE: Testing Undefined Value with Predicate in TypeScript\nDESCRIPTION: This snippet demonstrates the usage of the 'isNotUndefined' function from the 'effect/Predicate' module. It checks whether provided values are not 'undefined', returning 'true' for any non-undefined value and 'false' for 'undefined'. The snippet also includes import statements and example assertions with 'node:assert'.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Predicate-isNotUndefined.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { isNotUndefined } from \"effect/Predicate\"\n\nassert.deepStrictEqual(isNotUndefined(null), true)\nassert.deepStrictEqual(isNotUndefined(\"undefined\"), true)\n\nassert.deepStrictEqual(isNotUndefined(undefined), false)\n```\n\n----------------------------------------\n\nTITLE: Type Signature of Doc.catWithSoftLine in TypeScript\nDESCRIPTION: This code snippet shows the type signature of the catWithSoftLine function. It demonstrates that the function can be used both as a curried function and with two arguments directly.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Doc-catWithSoftLine.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const catWithSoftLine: { <B>(that: Doc<B>): <A>(self: Doc<A>) => Doc<B | A>; <A, B>(self: Doc<A>, that: Doc<B>): Doc<A | B>; }\n```\n\n----------------------------------------\n\nTITLE: Checking object property with hasProperty in Effect TS\nDESCRIPTION: The `hasProperty` function checks if a value is an object containing a specified property key. It takes a property key as an argument and returns a predicate function that checks if a given value is an object with that property. The function has two signatures: one where the value to check comes first and one where the property key comes first.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Predicate-hasProperty.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const hasProperty: { <P extends PropertyKey>(property: P): (self: unknown) => self is { [K in P]: unknown; }; <P extends PropertyKey>(self: unknown, property: P): self is { [K in P]: unknown; }; }\n```\n\n----------------------------------------\n\nTITLE: Conditional STM Operation with Predicate Evaluation\nDESCRIPTION: A utility function that evaluates a predicate and returns either a success value or an error based on the predicate's result. Allows lazy evaluation of condition, error, and result.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/STM-cond.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const cond: <A, E>(predicate: LazyArg<boolean>, error: LazyArg<E>, result: LazyArg<A>) => STM<A, E>\n```\n\n----------------------------------------\n\nTITLE: Defining FiberRefsPatch Union Type in TypeScript\nDESCRIPTION: The FiberRefsPatch type definition, which represents different possible operations on FiberRefs. It can be Empty, Add, Remove, Update, or AndThen types, allowing for various transformations of FiberRef values between fibers.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/FiberRefsPatch-FiberRefsPatch.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ntype FiberRefsPatch = Empty | Add | Remove | Update | AndThen\n```\n\n----------------------------------------\n\nTITLE: Checking if a Predicate Holds for Some SortedSet Elements in TypeScript\nDESCRIPTION: The 'some' function checks if at least one element in a SortedSet satisfies the given predicate function. It provides both curried and uncurried versions for flexibility in function composition.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/SortedSet-some.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const some: { <A>(predicate: Predicate<A>): (self: SortedSet<A>) => boolean; <A>(self: SortedSet<A>, predicate: Predicate<A>): boolean; }\n```\n\n----------------------------------------\n\nTITLE: Converting Readonly to Mutable in TypeScript using Effect-TS\nDESCRIPTION: The code demonstrates how to convert immutable structures into mutable ones in TypeScript by using the `Types.Mutable` utility from the Effect-TS package. Dependencies include the Effect-TS library, which must be imported. The type utility is applied to structures such as objects with readonly properties, read-only arrays, tuples, and records. The primary input is any TypeScript type, and the output is a new type with its properties made mutable.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Types-Mutable.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport type { Types } from \"effect\"\n\ntype MutableStruct = Types.Mutable<{ readonly a: string; readonly b: number }> // { a: string; b: number; }\n\ntype MutableArray = Types.Mutable<ReadonlyArray<string>> // string[]\n\ntype MutableTuple = Types.Mutable<readonly [string, number]> // [string, number]\n\ntype MutableRecord = Types.Mutable<{ readonly [_: string]: number }> // { [x: string]: number; }\n```\n\n----------------------------------------\n\nTITLE: Defining TupleOfAtLeast Type in TypeScript\nDESCRIPTION: A type-level utility that creates a tuple with at least N elements of type T, ensuring type safety for tuple declarations with a minimum length\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Types-TupleOfAtLeast.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ntype [...TupleOf<N, T>, ...T[]] = [...TupleOf<N, T>, ...Array<T>]\n```\n\n----------------------------------------\n\nTITLE: Implementing FiberId.getOrElse in TypeScript\nDESCRIPTION: Defines a function that returns the first FiberId if it is not None, otherwise returns the provided fallback FiberId. The function supports both curried and uncurried calling styles.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/FiberId-getOrElse.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const getOrElse: { (that: FiberId): (self: FiberId) => FiberId; (self: FiberId, that: FiberId): FiberId; }\n```\n\n----------------------------------------\n\nTITLE: TypeScript Type Signature for DateTime.subtractDuration\nDESCRIPTION: The type signature for the subtractDuration function, showing its polymorphic usage patterns. It can be called with either (duration)(dateTime) or (dateTime, duration) parameter orders.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/DateTime-subtractDuration.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const subtractDuration: { (duration: Duration.DurationInput): <A extends DateTime>(self: A) => A; <A extends DateTime>(self: A, duration: Duration.DurationInput): A; }\n```\n\n----------------------------------------\n\nTITLE: Boolean SemigroupEqv Signature\nDESCRIPTION: This code snippet shows the type signature of the `SemigroupEqv` constant.  It declares `SemigroupEqv` as a constant of type `semigroup.Semigroup<boolean>`, indicating that it represents a semigroup for boolean values. It depends on the `semigroup` module from `@effect/typeclass`.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/data-Boolean-SemigroupEqv.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\ndeclare const SemigroupEqv: semigroup.Semigroup<boolean>\n```\n```\n\n----------------------------------------\n\nTITLE: Merging Error and Success Channels in STM\nDESCRIPTION: This snippet declares the merge function which merges the error channel into the success channel of an STM effect, facilitating combined types for error handling. It is a generic function designed to work with any input and output types defined by STM.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/STM-merge.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const merge: <A, E, R>(self: STM<A, E, R>) => STM<E | A, never, R>\n```\n\n----------------------------------------\n\nTITLE: Calculating Size of Iterable in TypeScript\nDESCRIPTION: This function returns the number of elements in a given Iterable. It takes an Iterable<A> as input and returns a number representing its size.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Iterable-size.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const size: <A>(self: Iterable<A>) => number\n```\n\n----------------------------------------\n\nTITLE: Using HashSet.isSubset in TypeScript with Effect Library\nDESCRIPTION: Demonstrates various ways to check if one HashSet is a subset of another using data-last (pipeable), pipe function, and data-first APIs. The function returns true if every element in the first set is also in the second set, with O(n) time complexity.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/HashSet-isSubset.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { HashSet, pipe } from \"effect\"\n\nconst set1 = HashSet.make(0, 1)\nconst set2 = HashSet.make(1, 2)\nconst set3 = HashSet.make(0, 1, 2)\n\n// with `data-last`, a.k.a. `pipeable` API\npipe(set1, HashSet.isSubset(set2)) // false\npipe(set1, HashSet.isSubset(set3)) // true\n\n// or piped with the pipe function\nset1.pipe(HashSet.isSubset(set2)) // false\nset1.pipe(HashSet.isSubset(set3)) // true\n\n// or with `data-first` API\nHashSet.isSubset(set1, set2) // false\nHashSet.isSubset(set1, set3) // true)\n```\n\n----------------------------------------\n\nTITLE: Stream.zipLatest Type Signature in TypeScript\nDESCRIPTION: Type signature for the zipLatest function showing its polymorphic nature and type constraints. The function can be called with either two separate stream arguments or through method chaining.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-zipLatest.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const zipLatest: { <AR, ER, RR>(right: Stream<AR, ER, RR>): <AL, EL, RL>(left: Stream<AL, EL, RL>) => Stream<[AL, AR], EL | ER, RL | RR>; <AL, EL, RL, AR, ER, RR>(left: Stream<AL, EL, RL>, right: Stream<AR, ER, RR>): Stream<[AL, AR], EL | ER, RL | RR>; }\n```\n\n----------------------------------------\n\nTITLE: Using Redacted.getEquivalence for Comparing Sensitive Data in TypeScript\nDESCRIPTION: Demonstrates how to use the Redacted.getEquivalence function to safely compare redacted values without exposing their contents. The example shows comparing API keys using string equivalence while maintaining their confidentiality.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Redacted-getEquivalence.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { Redacted, Equivalence } from \"effect\"\n\nconst API_KEY1 = Redacted.make(\"1234567890\")\nconst API_KEY2 = Redacted.make(\"1-34567890\")\nconst API_KEY3 = Redacted.make(\"1234567890\")\n\nconst equivalence = Redacted.getEquivalence(Equivalence.string)\n\nassert.equal(equivalence(API_KEY1, API_KEY2), false)\nassert.equal(equivalence(API_KEY1, API_KEY3), true)\n```\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const getEquivalence: <A>(isEquivalent: Equivalence.Equivalence<A>) => Equivalence.Equivalence<Redacted<A>>\n```\n\n----------------------------------------\n\nTITLE: Counting Array Elements with Predicate in TypeScript\nDESCRIPTION: A type-safe function for counting array elements that match a given predicate within a Software Transactional Memory (STM) transaction. Supports both curried and direct function call styles.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TArray-count.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const count: { <A>(predicate: Predicate<A>): (self: TArray<A>) => STM.STM<number>; <A>(self: TArray<A>, predicate: Predicate<A>): STM.STM<number>; }\n```\n\n----------------------------------------\n\nTITLE: Defining Stream.some Function in TypeScript\nDESCRIPTION: This snippet defines the Stream.some function, which utilizes generics to convert a stream of Option values into a stream of Option errors. It is crucial for handling error states in functional programming contexts using streams. It requires the Effect-TS library version 2.0.0 or later and works with the Option and Stream modules.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-some.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const some: <A, E, R>(self: Stream<Option.Option<A>, E, R>) => Stream<A, Option.Option<E>, R>\n```\n\n----------------------------------------\n\nTITLE: Mapping Exit Success Values in TypeScript\nDESCRIPTION: Defines a map function that transforms the Success value of an Exit type. It can be used in two ways: either by providing the mapping function first, or by providing the Exit value first followed by the mapping function.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Exit-map.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const map: { <A, B>(f: (a: A) => B): <E>(self: Exit<A, E>) => Exit<B, E>; <A, E, B>(self: Exit<A, E>, f: (a: A) => B): Exit<B, E>; }\n```\n\n----------------------------------------\n\nTITLE: Creating Cache Statistics Object in TypeScript\nDESCRIPTION: This function constructs a new CacheStats object with specified hit count, miss count, and size metrics. It's used for tracking and analyzing cache performance.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Cache-makeCacheStats.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const makeCacheStats: (options: { readonly hits: number; readonly misses: number; readonly size: number; }) => CacheStats\n```\n\n----------------------------------------\n\nTITLE: Converting Option toArray using Effect TypeScript\nDESCRIPTION: This code snippet demonstrates the use of Option.toArray from the Effect library to convert an Option into an Array in TypeScript. When the Option is Some, it returns an array containing the value, and when None, it results in an empty array. This conversion is defined for generic Option types, supporting generic input elements A.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Option-toArray.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { Option } from \"effect\"\n\nconsole.log(Option.toArray(Option.some(1)))\n// Output: [1]\n\nconsole.log(Option.toArray(Option.none()))\n// Output: []\n```\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const toArray: <A>(self: Option<A>) => Array<A>\n```\n\n----------------------------------------\n\nTITLE: Signature of composeK Function in TypeScript\nDESCRIPTION: This code provides the TypeScript declaration for the `composeK` function, which defines its capability to chain two functions returning Options. The function signature supports two variations for flexibility, allowing optional chaining with specific data flow from one function's output to another function's input.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Option-composeK.md#2025-04-11_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const composeK: { <B, C>(bfc: (b: B) => Option<C>): <A>(afb: (a: A) => Option<B>) => (a: A) => Option<C>; <A, B, C>(afb: (a: A) => Option<B>, bfc: (b: B) => Option<C>): (a: A) => Option<C>; }\n```\n\n----------------------------------------\n\nTITLE: Defining partitionMap Function for Chunk Partitioning in TypeScript\nDESCRIPTION: This code snippet defines the partitionMap function, which partitions the elements of a chunk into two chunks using a provided function. It accepts a function that maps elements to Either<C, B> and returns a tuple of two chunks.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Chunk-partitionMap.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const partitionMap: { <A, B, C>(f: (a: A) => Either<C, B>): (self: Chunk<A>) => [left: Chunk<B>, right: Chunk<C>]; <A, B, C>(self: Chunk<A>, f: (a: A) => Either<C, B>): [left: Chunk<B>, right: Chunk<C>]; }\n```\n\n----------------------------------------\n\nTITLE: Filtering and Mapping with Concurrency in Effect\nDESCRIPTION: This snippet shows the type signature for the `filterMap` function in the Effect library. It takes an iterable, a function that returns a `Micro` effect of an `Option`, and an optional concurrency setting. It returns a `Micro` effect that results in an array of the mapped values.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Micro-filterMap.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const filterMap: <A, B, E, R>(iterable: Iterable<A>, f: (a: NoInfer<A>) => Micro<Option.Option<B>, E, R>, options?: { readonly concurrency?: Concurrency | undefined; }) => Micro<Array<B>, E, R>\n```\n\n----------------------------------------\n\nTITLE: Declaring PubSub Shutdown Function in TypeScript\nDESCRIPTION: Declares a function that interrupts any fibers suspended on 'offer' or 'take' operations and causes future calls to 'offer*' and 'take*' to be interrupted immediately. It takes a PubSub instance as an argument and returns an Effect that resolves to void.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/PubSub-shutdown.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const shutdown: <A>(self: PubSub<A>) => Effect.Effect<void>\n```\n\n----------------------------------------\n\nTITLE: Lifting Either into STM Function\nDESCRIPTION: This function, fromEither, takes an Either type as input and lifts it into an STM context, providing a means to work with values that may represent either success or failure in a transactional manner. The function signature indicates generics for success (A) and failure (E) types, allowing for versatile usage across various scenarios.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/STM-fromEither.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const fromEither: <A, E>(either: Either.Either<A, E>) => STM<A, E>\n```\n\n----------------------------------------\n\nTITLE: Using BigDecimal.multiply in TypeScript\nDESCRIPTION: Example demonstrating how to multiply two BigDecimal values using the multiply function from the effect/BigDecimal module. This example shows creation of BigDecimal values using unsafeFromString and their multiplication.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/BigDecimal-multiply.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { multiply, unsafeFromString } from \"effect/BigDecimal\"\n\nassert.deepStrictEqual(multiply(unsafeFromString(\"2\"), unsafeFromString(\"3\")), unsafeFromString(\"6\"))\n```\n\n----------------------------------------\n\nTITLE: Effect.validateFirst Function Signature in TypeScript\nDESCRIPTION: The TypeScript signature for the validateFirst function, showing its two overloaded variations - one taking a function first and one taking elements first. Both support optional configuration parameters for concurrency, batching, and finalizers.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-validateFirst.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const validateFirst: { <A, B, E, R>(f: (a: A, i: number) => Effect<B, E, R>, options?: { readonly concurrency?: Concurrency | undefined; readonly batching?: boolean | \"inherit\" | undefined; readonly concurrentFinalizers?: boolean | undefined; } | undefined): (elements: Iterable<A>) => Effect<B, Array<E>, R>; <A, B, E, R>(elements: Iterable<A>, f: (a: A, i: number) => Effect<B, E, R>, options?: { readonly concurrency?: Concurrency | undefined; readonly batching?: boolean | \"inherit\" | undefined; readonly concurrentFinalizers?: boolean | undefined; } | undefined): Effect<B, Array<E>, R>; }\n```\n\n----------------------------------------\n\nTITLE: Checking Subrecord Existence using TypeScript\nDESCRIPTION: This snippet declares the 'isSubrecordBy' function which checks if all keys and values of one record are present in another. It utilizes an Equivalence type for comparison and can be used with two different calling conventions for convenience.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Record-isSubrecordBy.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const isSubrecordBy: <A>(equivalence: Equivalence<A>) => { <K extends string>(that: ReadonlyRecord<K, A>): (self: ReadonlyRecord<K, A>) => boolean; <K extends string>(self: ReadonlyRecord<K, A>, that: ReadonlyRecord<K, A>): boolean; }\n```\n\n----------------------------------------\n\nTITLE: Constructing Layer from Effect in TypeScript\nDESCRIPTION: Function signature for creating a Layer from an Effect. Supports two overloads: one taking a context tag and effect separately, and another using curried parameters. The function creates a Layer with specified input type I, error type E, and environment type R.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Layer-effect.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const effect: {\n  <I, S>(tag: Context.Tag<I, S>): <E, R>(effect: Effect.Effect<Types.NoInfer<S>, E, R>) => Layer<I, E, R>;\n  <I, S, E, R>(tag: Context.Tag<I, S>, effect: Effect.Effect<Types.NoInfer<S>, E, R>): Layer<I, E, R>;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining delayedEffect for Dynamic Scheduling in TypeScript\nDESCRIPTION: The delayedEffect function accepts an effectful function and modifies the current schedule with a computed delay. The function signature illustrates how it can return a modified schedule based on the provided delay-computing function.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Schedule-delayedEffect.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const delayedEffect: { <R2>(f: (duration: Duration.Duration) => Effect.Effect<Duration.DurationInput, never, R2>): <Out, In, R>(self: Schedule<Out, In, R>) => Schedule<Out, In, R2 | R>; <Out, In, R, R2>(self: Schedule<Out, In, R>, f: (duration: Duration.Duration) => Effect.Effect<Duration.DurationInput, never, R2>): Schedule<Out, In, R | R2>; }\n```\n\n----------------------------------------\n\nTITLE: Splitting Chunks into Equal Parts - TypeScript Effect Library\nDESCRIPTION: Function signature for splitting a Chunk into n equally sized chunks. The function supports both curried and uncurried calling styles, taking a number parameter for the split count and returning nested Chunks.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Chunk-split.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const split: { (n: number): <A>(self: Chunk<A>) => Chunk<Chunk<A>>; <A>(self: Chunk<A>, n: number): Chunk<Chunk<A>>; }\n```\n\n----------------------------------------\n\nTITLE: Declaring scheduleAddDelay Function in TypeScript\nDESCRIPTION: The `scheduleAddDelay` function is declared to compute a new `MicroSchedule` by modifying existing delays. It can be called with either a function returning a number and a `MicroSchedule`, or just a function returning a number, with the context being the current schedule. The expected input is a function returning a delay in milliseconds, and it outputs a modified `MicroSchedule` instance.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Micro-scheduleAddDelay.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const scheduleAddDelay: { (f: () => number): (self: MicroSchedule) => MicroSchedule; (self: MicroSchedule, f: () => number): MicroSchedule; }\n```\n\n----------------------------------------\n\nTITLE: DateTime.nearest Function Signature in TypeScript\nDESCRIPTION: The type signature for the DateTime.nearest function, showing its various overloads and parameters. The function accepts a time unit part and optional settings like weekStartsOn for week-based operations.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/DateTime-nearest.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const nearest: { (part: DateTime.UnitSingular, options?: { readonly weekStartsOn?: 0 | 1 | 2 | 3 | 4 | 5 | 6 | undefined; }): <A extends DateTime>(self: A) => A; <A extends DateTime>(self: A, part: DateTime.UnitSingular, options?: { readonly weekStartsOn?: 0 | 1 | 2 | 3 | 4 | 5 | 6 | undefined; }): A; }\n```\n\n----------------------------------------\n\nTITLE: Multiplying BigInt Values in a Collection with Effect/BigInt\nDESCRIPTION: The `multiplyAll` function takes an iterable collection of BigInt values and returns their product. It reduces the collection by multiplying each value together.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/BigInt-multiplyAll.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { multiplyAll } from \"effect/BigInt\"\n\nassert.deepStrictEqual(multiplyAll([2n, 3n, 4n]), 24n)\n```\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const multiplyAll: (collection: Iterable<bigint>) => bigint\n```\n\n----------------------------------------\n\nTITLE: Taking Multiple Elements from a Queue in TypeScript STM\nDESCRIPTION: This function takes a specified number of elements from a queue. If fewer than the requested elements are available, it retries until they become available. The function supports both curried and uncurried calling styles.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TQueue-takeN.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const takeN: { (n: number): <A>(self: TDequeue<A>) => STM.STM<Array<A>>; <A>(self: TDequeue<A>, n: number): STM.STM<Array<A>>; }\n```\n\n----------------------------------------\n\nTITLE: Testing if a value is a RegExp in TypeScript\nDESCRIPTION: This code snippet demonstrates how to use the `Predicate.isRegExp` function from the `effect` package to check if a value is a regular expression. It imports the `assert` module from Node.js and the `Predicate` module from `effect`, then uses `assert.deepStrictEqual` to verify the function's output for both a RegExp object and a string.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Predicate-isRegExp.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { Predicate } from \"effect\"\n\nassert.deepStrictEqual(Predicate.isRegExp(/a/), true)\nassert.deepStrictEqual(Predicate.isRegExp(\"a\"), false)\n```\n\n----------------------------------------\n\nTITLE: Boolean.match Type Signature in TypeScript\nDESCRIPTION: The type signature for the Boolean.match function, showing its function overloads. It can be used in both curried and non-curried forms, with generic type parameters for the return values of the handlers.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Boolean-match.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const match: { <A, B = A>(options: { readonly onFalse: LazyArg<A>; readonly onTrue: LazyArg<B>; }): (value: boolean) => A | B; <A, B>(value: boolean, options: { readonly onFalse: LazyArg<A>; readonly onTrue: LazyArg<B>; }): A | B; }\n```\n\n----------------------------------------\n\nTITLE: Defining Transformation Class in TypeScript\nDESCRIPTION: This TypeScript code snippet defines the Transformation class used to represent transformation errors within the Effect module's ParseResult. It requires an abstract syntax tree, the actual object being transformed, the kind of transformation, and a parsing issue as parameters. This class aids in the structured handling of errors during various transformations.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/ParseResult-Transformation.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare class Transformation { constructor(\n    readonly ast: AST.Transformation,\n    readonly actual: unknown,\n    readonly kind: \"Encoded\" | \"Transformation\" | \"Type\",\n    readonly issue: ParseIssue\n  ) }\n```\n\n----------------------------------------\n\nTITLE: Using BigInt.sum for Addition in Effect Library\nDESCRIPTION: Demonstrates how to use the sum function from the BigInt module to add two bigint values. The function supports both curried and uncurried calling styles for flexibility.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/BigInt-sum.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { sum } from \"effect/BigInt\"\n\nassert.deepStrictEqual(sum(2n, 3n), 5n)\n```\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const sum: { (that: bigint): (self: bigint) => bigint; (self: bigint, that: bigint): bigint; }\n```\n\n----------------------------------------\n\nTITLE: Finding Maximum Number with Effect Number.max\nDESCRIPTION: Function that compares two numbers and returns the larger value. Supports both direct and curried function call patterns, providing flexibility in numeric comparisons.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Number-max.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { max } from \"effect/Number\"\n\nassert.deepStrictEqual(max(2, 3), 3)\n```\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const max: { (that: number): (self: number) => number; (self: number, that: number): number; }\n```\n\n----------------------------------------\n\nTITLE: Implementing Channel Folding in TypeScript\nDESCRIPTION: Defines a foldChannel function that allows folding over the result of a channel. The function handles both success and failure cases through provided callbacks, supporting generic type parameters for flexible input/output types.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Channel-foldChannel.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const foldChannel: { <OutErr, OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1, OutDone, OutElem2, InElem2, OutErr2, InErr2, OutDone2, InDone2, Env2>(options: { readonly onFailure: (error: OutErr) => Channel<OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>; readonly onSuccess: (done: OutDone) => Channel<OutElem2, InElem2, OutErr2, InErr2, OutDone2, InDone2, Env2>; }): <Env, InErr, InElem, InDone, OutElem>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>) => Channel<OutElem1 | OutElem2 | OutElem, InElem & InElem1 & InElem2, OutErr1 | OutErr2, InErr & InErr1 & InErr2, OutDone1 | OutDone2, InDone & InDone1 & InDone2, Env1 | Env2 | Env>; <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1, OutElem2, InElem2, OutErr2, InErr2, OutDone2, InDone2, Env2>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>, options: { readonly onFailure: (error: OutErr) => Channel<OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>; readonly onSuccess: (done: OutDone) => Channel<OutElem2, InElem2, OutErr2, InErr2, OutDone2, InDone2, Env2>; }): Channel<OutElem | OutElem1 | OutElem2, InElem & InElem1 & InElem2, OutErr1 | OutErr2, InErr & InErr1 & InErr2, OutDone1 | OutDone2, InDone & InDone1 & InDone2, Env | Env1 | Env2>; }\n```\n\n----------------------------------------\n\nTITLE: Constructing Service Layer in TypeScript\nDESCRIPTION: The service function constructs a layer that accesses and returns a specified service from the context. It takes a Context.Tag as an argument and returns a Layer.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Layer-service.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const service: <I, S>(tag: Context.Tag<I, S>) => Layer<I, never, I>\n```\n\n----------------------------------------\n\nTITLE: Initializing Stream from Schedule in TypeScript\nDESCRIPTION: Creates a stream that emits values based on a configured schedule, demonstrating periodic value generation with limited recurrence\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-fromSchedule.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Effect, Schedule, Stream } from \"effect\"\n\n// Emits values every 1 second for a total of 5 emissions\nconst schedule = Schedule.spaced(\"1 second\").pipe(\n  Schedule.compose(Schedule.recurs(5))\n)\n\nconst stream = Stream.fromSchedule(schedule)\n\nEffect.runPromise(Stream.runCollect(stream)).then(console.log)\n// { _id: 'Chunk', values: [ 0, 1, 2, 3, 4 ] }\n```\n\n----------------------------------------\n\nTITLE: Refreshing Resources in Effect.ts\nDESCRIPTION: The refresh function allows refreshing a resource's cache. It returns an Effect that won't complete until the refresh operation either succeeds or fails. This is part of the Resource module in the effect package.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Resource-refresh.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const refresh: <A, E>(self: Resource<A, E>) => Effect.Effect<void, E>\n```\n\n----------------------------------------\n\nTITLE: Either.all Function Signature in TypeScript\nDESCRIPTION: Provides the TypeScript signature for the Either.all function. It shows the complex generic type definition that allows the function to work with various input types and maintain type safety.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Either-all.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const all: <const I extends Iterable<Either<any, any>> | Record<string, Either<any, any>>>(input: I) => [I] extends [ReadonlyArray<Either<any, any>>] ? Either<{ -readonly [K in keyof I]: [I[K]] extends [Either<infer R, any>] ? R : never; }, I[number] extends never ? never : [I[number]] extends [Either<any, infer L>] ? L : never> : [I] extends [Iterable<Either<infer R, infer L>>] ? Either<Array<R>, L> : Either<{ -readonly [K in keyof I]: [I[K]] extends [Either<infer R, any>] ? R : never; }, I[keyof I] extends never ? never : [I[keyof I]] extends [Either<any, infer L>] ? L : never>\n```\n\n----------------------------------------\n\nTITLE: Declaring zipAllSortedByKeyRight Stream Operation in TypeScript\nDESCRIPTION: Defines a function that zips two streams sorted by distinct keys, keeping only values from the right stream. The operation uses a default value to fill missing entries and requires constant space. Both input streams must be pre-sorted by distinct keys for correct operation.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-zipAllSortedByKeyRight.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const zipAllSortedByKeyRight: { <K, A2, E2, R2>(options: { readonly other: Stream<readonly [K, A2], E2, R2>; readonly defaultOther: A2; readonly order: Order.Order<K>; }): <A, E, R>(self: Stream<readonly [K, A], E, R>) => Stream<[K, A2], E2 | E, R2 | R>; <A, E, R, K, A2, E2, R2>(self: Stream<readonly [K, A], E, R>, options: { readonly other: Stream<readonly [K, A2], E2, R2>; readonly defaultOther: A2; readonly order: Order.Order<K>; }): Stream<[K, A2], E | E2, R | R2>; }\n```\n\n----------------------------------------\n\nTITLE: Applying Function to Record Element or Returning None - TypeScript\nDESCRIPTION: This snippet demonstrates the use of the `modifyOption` function to apply a transformation to a value in a record identified by a specific key. If the key does not exist, it returns `None`. It uses assertions to validate the functionality of the method.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Record-modifyOption.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { Record as R, Option } from \"effect\"\n\nconst f = (x: number) => x * 2\n\nassert.deepStrictEqual(\n R.modifyOption({ a: 3 }, 'a', f),\n Option.some({ a: 6 })\n)\nassert.deepStrictEqual(\n R.modifyOption({ a: 3 } as Record<string, number>, 'b', f),\n Option.none()\n)\n```\n\n----------------------------------------\n\nTITLE: Configuring Structural Region State in Effect Utility\nDESCRIPTION: Defines an experimental configuration object for structural region state testing, allowing custom boolean comparison and feature toggling\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Utils-structuralRegionState.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const structuralRegionState: { enabled: boolean; tester: ((a: unknown, b: unknown) => boolean) | undefined; }\n```\n\n----------------------------------------\n\nTITLE: Defining Resource Interface in TypeScript\nDESCRIPTION: Defines the Resource interface that extends Effect.Effect. A Resource represents a value that can be loaded into memory and refreshed. It includes internal properties for scopedRef and acquire, along with type unification symbols.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Resource-Resource.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface Resource<in out A, in out E = never> extends Effect.Effect<A, E>, Resource.Variance<A, E> {\n  /** @internal */\n  readonly scopedRef: ScopedRef.ScopedRef<Exit.Exit<A, E>>\n  /** @internal */\n  readonly acquire: Effect.Effect<A, E, Scope.Scope>\n\n  readonly [Unify.typeSymbol]?: unknown\n  readonly [Unify.unifySymbol]?: ResourceUnify<this>\n  readonly [Unify.ignoreSymbol]?: ResourceUnifyIgnore\n}\n```\n\n----------------------------------------\n\nTITLE: Retrieving Current Version from Reloadable Service in TypeScript\nDESCRIPTION: Function signature for retrieving the current version of a reloadable service using a context tag. Takes a Context.Tag parameter and returns an Effect that contains the reloadable service instance.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Reloadable-get.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const get: <I, S>(tag: Context.Tag<I, S>) => Effect.Effect<S, never, Reloadable<I>>\n```\n\n----------------------------------------\n\nTITLE: BigDecimal.normalize Function Signature in TypeScript\nDESCRIPTION: The type definition for the normalize function in the BigDecimal module. It takes a BigDecimal value and returns a normalized BigDecimal value with trailing zeros removed.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/BigDecimal-normalize.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const normalize: (self: BigDecimal) => BigDecimal\n```\n\n----------------------------------------\n\nTITLE: Declaring orElse Function for Fiber Combination in TypeScript\nDESCRIPTION: Defines the orElse function that combines two fibers, preferring the first but falling back to the second on failure. Interrupting the resulting fiber will interrupt both fibers sequentially from left to right.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Fiber-orElse.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const orElse: { <A2, E2>(that: Fiber<A2, E2>): <A, E>(self: Fiber<A, E>) => Fiber<A2 | A, E2 | E>; <A, E, A2, E2>(self: Fiber<A, E>, that: Fiber<A2, E2>): Fiber<A | A2, E | E2>; }\n```\n\n----------------------------------------\n\nTITLE: Configuring Secret Values in Effect.io TypeScript\nDESCRIPTION: Function signature for constructing a config that handles secret values. Takes an optional name parameter and returns a Config instance wrapping a Secret type.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Config-secret.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const secret: (name?: string) => Config<Secret.Secret>\n```\n\n----------------------------------------\n\nTITLE: Declaring isFull Function for Queue in TypeScript\nDESCRIPTION: Declares the isFull function which returns a boolean Effect indicating whether a Queue contains at least one element. It works with both Dequeue and Enqueue types.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Queue-isFull.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const isFull: <A>(self: Dequeue<A> | Enqueue<A>) => Effect.Effect<boolean>\n```\n\n----------------------------------------\n\nTITLE: Checking Exit Failure Status in TypeScript\nDESCRIPTION: The isFailure function is a type guard that determines if an Exit instance is a Failure. It takes an Exit<A, E> as input and returns a boolean indicating whether it's a Failure<A, E>.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Exit-isFailure.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const isFailure: <A, E>(self: Exit<A, E>) => self is Failure<A, E>\n```\n\n----------------------------------------\n\nTITLE: TArray findFirstIndex Declaration (TypeScript)\nDESCRIPTION: Declares the `findFirstIndex` function, which finds the first index of a specific value within a `TArray`. It returns an `STM` effect that resolves to an `Option` containing either the index or `None` if the value is not found.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TArray-findFirstIndex.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const findFirstIndex: { <A>(value: A): (self: TArray<A>) => STM.STM<Option.Option<number>>; <A>(self: TArray<A>, value: A): STM.STM<Option.Option<number>>; }\n```\n\n----------------------------------------\n\nTITLE: TypeScript declaration for Effect.mapErrorCause function\nDESCRIPTION: Declares the mapErrorCause function that maps the failure cause of an Effect. It supports both pipeable style and data-first style, allowing transformation of the Cause<E> to Cause<E2> while preserving the success type and environment type.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-mapErrorCause.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const mapErrorCause: { <E, E2>(f: (cause: Cause.Cause<E>) => Cause.Cause<E2>): <A, R>(self: Effect<A, E, R>) => Effect<A, E2, R>; <A, E, R, E2>(self: Effect<A, E, R>, f: (cause: Cause.Cause<E>) => Cause.Cause<E2>): Effect<A, E2, R>; }\n```\n\n----------------------------------------\n\nTITLE: Converting Cookies to Record in TypeScript\nDESCRIPTION: The toRecord function converts a Cookies object to a Record<string, string>. It takes a Cookies object as input and returns a plain JavaScript object where keys are cookie names and values are cookie values.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Cookies-toRecord.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const toRecord: (self: Cookies) => Record<string, string>\n```\n\n----------------------------------------\n\nTITLE: BigDecimal.remainder Function Signature in TypeScript\nDESCRIPTION: Defines the type signature of the BigDecimal.remainder function. It shows two overloads: one taking the divisor as the first argument for currying, and another taking both the dividend and divisor directly.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/BigDecimal-remainder.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const remainder: { (divisor: BigDecimal): (self: BigDecimal) => Option.Option<BigDecimal>; (self: BigDecimal, divisor: BigDecimal): Option.Option<BigDecimal>; }\n```\n\n----------------------------------------\n\nTITLE: Reducing TArray using STM\nDESCRIPTION: The `reduceSTM` function performs an atomic fold on a `TArray` using a provided transactional function. Dependencies include the STM and TArray packages from the `effect` library. This function takes an initial accumulator value `zero` and a function `f` that operates transactionally on the accumulator and the current value of the array. The expected output is a new STM instance containing the folded result of the TArray operation. Special care should be taken regarding transactional memory, ensuring consistency and isolation of operations.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TArray-reduceSTM.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const reduceSTM: { <Z, A, R, E>(zero: Z, f: (accumulator: Z, current: A) => STM.STM<Z, E, R>): (self: TArray<A>) => STM.STM<Z, E, R>; <Z, A, R, E>(self: TArray<A>, zero: Z, f: (accumulator: Z, current: A) => STM.STM<Z, E, R>): STM.STM<Z, E, R>; }\n```\n\n----------------------------------------\n\nTITLE: Converting DateTime to UTC Timezone in Effect\nDESCRIPTION: Demonstrates how to convert a DateTime object with a specific timezone (Europe/London) to a DateTime.Utc object. The example creates a zoned DateTime for the year 2024 and then converts it to UTC.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/DateTime-toUtc.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { DateTime } from \"effect\"\n\nconst now = DateTime.unsafeMakeZoned({ year: 2024 }, { timeZone: \"Europe/London\" })\n\n// set as UTC\nconst utc: DateTime.Utc = DateTime.toUtc(now)\n```\n\n----------------------------------------\n\nTITLE: Type Signature for Array.intersperse Function in TypeScript\nDESCRIPTION: The type signature for the Array.intersperse function, showing its overloaded implementations for different input types. It handles both regular arrays and non-empty arrays, with appropriate return type inference.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Array-intersperse.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const intersperse: { <B>(middle: B): <S extends Iterable<any>>(self: S) => ReadonlyArray.With<S, ReadonlyArray.Infer<S> | B>; <A, B>(self: NonEmptyReadonlyArray<A>, middle: B): NonEmptyArray<A | B>; <A, B>(self: Iterable<A>, middle: B): Array<A | B>; }\n```\n\n----------------------------------------\n\nTITLE: Using FiberMap.runtime to Fork Effects in TypeScript\nDESCRIPTION: This example demonstrates how to use FiberMap.runtime to capture a Runtime and fork Effects, adding the forked fibers to the FiberMap. It shows the setup of a Users context and the forking of two effects using the captured runtime.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/FiberMap-runtime.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Context, Effect, FiberMap } from \"effect\"\n\ninterface Users {\n  readonly _: unique symbol\n}\nconst Users = Context.GenericTag<Users, {\n   getAll: Effect.Effect<Array<unknown>>\n}>(\"Users\")\n\nEffect.gen(function*() {\n  const map = yield* FiberMap.make<string>()\n  const run = yield* FiberMap.runtime(map)<Users>()\n\n  // run some effects and add the fibers to the map\n  run(\"effect-a\", Effect.andThen(Users, _ => _.getAll))\n  run(\"effect-b\", Effect.andThen(Users, _ => _.getAll))\n}).pipe(\n  Effect.scoped // The fibers will be interrupted when the scope is closed\n)\n```\n\n----------------------------------------\n\nTITLE: FiberMap.make Type Signature in TypeScript\nDESCRIPTION: The type signature for the FiberMap.make function, which creates a new FiberMap. It returns an Effect that requires a Scope and produces a FiberMap that can store fibers indexed by keys of type K, with effect type parameters A and E.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/FiberMap-make.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const make: <K, A = unknown, E = unknown>() => Effect.Effect<FiberMap<K, A, E>, never, Scope.Scope>\n```\n\n----------------------------------------\n\nTITLE: Simplifying Type Signatures with TypeScript\nDESCRIPTION: The code snippet demonstrates how to simplify a compound type signature in TypeScript using the `Types.Simplify` utility from the Effect package. It merges the properties of multiple types into a single cohesive type. The snippet requires TypeScript and the Effect library as dependencies and outputs a simplified type.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Types-Simplify.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport type { Types } from \"effect\"\n\ntype Res = Types.Simplify<{ a: number } & { b: number }> // { a: number; b: number; }\n```\n\n----------------------------------------\n\nTITLE: Using Channel.mapInputErrorEffect to Transform Input Channel Errors with Effects\nDESCRIPTION: This function creates a new channel that applies an effectual function to input channel error values. It allows for transforming errors from one type to another using effects, enabling more sophisticated error handling in channel compositions.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Channel-mapInputErrorEffect.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const mapInputErrorEffect: { <InErr0, InDone, InErr, Env1>(f: (error: InErr0) => Effect.Effect<InDone, InErr, Env1>): <OutElem, InElem, OutErr, OutDone, Env>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>) => Channel<OutElem, InElem, OutErr, InErr0, OutDone, InDone, Env1 | Env>; <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, InErr0, Env1>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>, f: (error: InErr0) => Effect.Effect<InDone, InErr, Env1>): Channel<OutElem, InElem, OutErr, InErr0, OutDone, InDone, Env | Env1>; }\n```\n\n----------------------------------------\n\nTITLE: Declaring middlewareOpenApi Function in TypeScript\nDESCRIPTION: Defines a middleware function that adds an openapi.json endpoint to the API. It accepts optional configuration for the path and additional properties strategy.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/HttpApiBuilder-middlewareOpenApi.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const middlewareOpenApi: (options?: { readonly path?: HttpApiEndpoint.PathSegment | undefined; readonly additionalPropertiesStrategy?: OpenApi.AdditionalPropertiesStrategy | undefined; } | undefined) => Layer.Layer<never, never, HttpApi.Api>\n```\n\n----------------------------------------\n\nTITLE: Implementing findFirst Function in TypeScript Effect Package\nDESCRIPTION: Function signature for findFirst that returns the first element satisfying a predicate or refinement condition from a Chunk data structure. The function supports both predicate-based filtering and type refinement, returning an Option type containing the found element or None if no element matches.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Chunk-findFirst.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const findFirst: { <A, B extends A>(refinement: Refinement<NoInfer<A>, B>): (self: Chunk<A>) => Option<B>; <A>(predicate: Predicate<NoInfer<A>>): (self: Chunk<A>) => Option<A>; <A, B extends A>(self: Chunk<A>, refinement: Refinement<A, B>): Option<B>; <A>(self: Chunk<A>, predicate: Predicate<A>): Option<A>; }\n```\n\n----------------------------------------\n\nTITLE: Creating STM Values from Partial Functions in TypeScript\nDESCRIPTION: The STM.attempt function creates an STM value from a partial (but pure) function. It encapsulates a lazy evaluation within the STM transaction context, handling potential errors that might occur during evaluation.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/STM-attempt.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const attempt: <A>(evaluate: LazyArg<A>) => STM<A, unknown>\n```\n\n----------------------------------------\n\nTITLE: Using MutableHashSet.add Method in TypeScript\nDESCRIPTION: Demonstrates different ways to add elements to a MutableHashSet using both data-last (pipeable) and data-first API styles. The add method checks if the set contains the element and adds it if not, with O(1) average time complexity.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/MutableHashSet-add.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { MutableHashSet, pipe } from \"effect\"\n\n// with data-last, a.k.a. pipeable API\npipe(\n  MutableHashSet.empty(),\n  MutableHashSet.add(0),\n  MutableHashSet.add(0)\n)\n\n// or piped with the pipe function\nMutableHashSet.empty().pipe(MutableHashSet.add(0))\n\n// or with data-first API\nMutableHashSet.add(MutableHashSet.empty(), 0)\n```\n\n----------------------------------------\n\nTITLE: Type signature for Array.scan function in TypeScript\nDESCRIPTION: The type definition for the Array.scan function, showing its overloaded versions. It can be used with curried or uncurried calling styles, taking an initial accumulator value and a function to combine the accumulator with each element.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Array-scan.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const scan: { <B, A>(b: B, f: (b: B, a: A) => B): (self: Iterable<A>) => NonEmptyArray<B>; <A, B>(self: Iterable<A>, b: B, f: (b: B, a: A) => B): NonEmptyArray<B>; }\n```\n\n----------------------------------------\n\nTITLE: Implementing Parallel Right-Biased Zipping for Exit Results in TypeScript\nDESCRIPTION: The zipParRight function parallelly combines two Exit results, discarding the first element and keeping only the second one. If either result fails, it returns the combined failure causes. This is useful for executing two operations in parallel when only the result of the second operation is needed.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Exit-zipParRight.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const zipParRight: { <A2, E2>(that: Exit<A2, E2>): <A, E>(self: Exit<A, E>) => Exit<A2, E2 | E>; <A, E, A2, E2>(self: Exit<A, E>, that: Exit<A2, E2>): Exit<A2, E | E2>; }\n```\n\n----------------------------------------\n\nTITLE: Reducing STM Transactions in TypeScript\nDESCRIPTION: Provides a type-safe method to reduce multiple STM transactions into a single transaction by applying a custom reduce function. Supports sequential processing and type-safe error and environment combination.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/STM-reduceAll.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const reduceAll: { <A, E2, R2>(initial: STM<A, E2, R2>, f: (x: A, y: A) => A): <E, R>(iterable: Iterable<STM<A, E, R>>) => STM<A, E2 | E, R2 | R>; <A, E, R, E2, R2>(iterable: Iterable<STM<A, E, R>>, initial: STM<A, E2, R2>, f: (x: A, y: A) => A): STM<A, E | E2, R | R2>; }\n```\n\n----------------------------------------\n\nTITLE: Function.apply Type Signature in TypeScript\nDESCRIPTION: The type signature for the apply function from the effect/Function module. It shows that apply takes a value of type A and returns a function that takes a function from A to B and returns B.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Function-apply.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const apply: <A>(a: A) => <B>(self: (a: A) => B) => B\n```\n\n----------------------------------------\n\nTITLE: Committing Transactions Atomically - Effect-TS - TypeScript\nDESCRIPTION: The commitEither function commits a transaction of type STM atomically, returning an Effect that represents the outcome of the transaction. It is generic over three types: A for the return value, E for the error type, and R for the environment type.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/STM-commitEither.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const commitEither: <A, E, R>(self: STM<A, E, R>) => Effect.Effect<A, E, R>\n```\n\n----------------------------------------\n\nTITLE: Implementing Chunk Equivalence Comparison in TypeScript\nDESCRIPTION: Creates an Equivalence function for Chunk<A> by using a provided equivalence function for type A. This allows comparing two chunks of equal length to determine if they are equivalent.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Chunk-getEquivalence.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const getEquivalence: <A>(isEquivalent: Equivalence.Equivalence<A>) => Equivalence.Equivalence<Chunk<A>>\n```\n\n----------------------------------------\n\nTITLE: Draining Remaining Elements in Sink.ignoreLeftover - TypeScript\nDESCRIPTION: The 'ignoreLeftover' function allows for draining remaining elements from a stream after the sink has completed processing. It is a utility that takes a Sink and returns a new Sink that does not emit any leftover elements (indicated by the 'never' type for leftovers). This is particularly useful in stream processing to ensure no elements are left unprocessed.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Sink-ignoreLeftover.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const ignoreLeftover: <A, In, L, E, R>(self: Sink<A, In, L, E, R>) => Sink<A, In, never, E, R>\n```\n\n----------------------------------------\n\nTITLE: Effect.zipRight Function Signature in TypeScript\nDESCRIPTION: The type signature for the Effect.zipRight function, showing its overloaded forms. The function supports options for concurrent execution, batching, and concurrent finalizers. It combines two effects and returns an effect that produces the result of the second effect.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-zipRight.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const zipRight: { <A2, E2, R2>(that: Effect<A2, E2, R2>, options?: { readonly concurrent?: boolean | undefined; readonly batching?: boolean | \"inherit\" | undefined; readonly concurrentFinalizers?: boolean | undefined; }): <A, E, R>(self: Effect<A, E, R>) => Effect<A2, E2 | E, R2 | R>; <A, E, R, A2, E2, R2>(self: Effect<A, E, R>, that: Effect<A2, E2, R2>, options?: { readonly concurrent?: boolean | undefined; readonly batching?: boolean | \"inherit\" | undefined; readonly concurrentFinalizers?: boolean | undefined; }): Effect<A2, E2 | E, R2 | R>; }\n```\n\n----------------------------------------\n\nTITLE: Implementing Effect Racing in TypeScript with Micro Module\nDESCRIPTION: A generic function that races two effects together, returning the first one to complete while interrupting the other. Takes two Micro effects with generic type parameters for value, error and environment types. Returns a combined effect that resolves to either result.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Micro-race.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const race: {\n  <A2, E2, R2>(that: Micro<A2, E2, R2>): <A, E, R>(self: Micro<A, E, R>) => Micro<A | A2, E | E2, R | R2>;\n  <A, E, R, A2, E2, R2>(self: Micro<A, E, R>, that: Micro<A2, E2, R2>): Micro<A | A2, E | E2, R | R2>;\n}\n```\n\n----------------------------------------\n\nTITLE: Creating an Immediately Completing Sink in TypeScript\nDESCRIPTION: The succeed function creates a sink that immediately ends with the specified value. It doesn't process any input and just returns the provided value as its result.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Sink-succeed.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const succeed: <A>(a: A) => Sink<A, unknown>\n```\n\n----------------------------------------\n\nTITLE: Calculating Maximum Interval in TypeScript\nDESCRIPTION: Defines a function 'max' that returns the maximum of two Intervals, determined by which has the latest start time. It can be used in two ways: as a curried function or with both arguments provided at once.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/ScheduleIntervals-max.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const max: { (that: Intervals): (self: Intervals) => Intervals; (self: Intervals, that: Intervals): Intervals; }\n```\n\n----------------------------------------\n\nTITLE: Creating Stream from Chunk Queue in Effect (TypeScript)\nDESCRIPTION: This function creates a `Stream` from a `Queue` of `Chunk` values. The `shutdown` option controls whether the queue is shut down after the stream is consumed. It returns a `Stream` of type `A`.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-fromChunkQueue.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const fromChunkQueue: <A>(queue: Queue.Dequeue<Chunk.Chunk<A>>, options?: { readonly shutdown?: boolean | undefined; }) => Stream<A>\n```\n\n----------------------------------------\n\nTITLE: Constructing HttpApp from HttpApi in TypeScript\nDESCRIPTION: The httpApp function creates an HttpApp from an HttpApi instance. It returns an Effect that requires HttpApi.Api, Router, or Middleware and produces an HttpApp.Default with HttpRouter.HttpRouter.DefaultServices.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/HttpApiBuilder-httpApp.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const httpApp: Effect.Effect<HttpApp.Default<never, HttpRouter.HttpRouter.DefaultServices>, never, HttpApi.Api | Router | Middleware>\n```\n\n----------------------------------------\n\nTITLE: Defining untilInputEffect Function in TypeScript\nDESCRIPTION: Declares the untilInputEffect function, which returns a new schedule that stops execution when a given effectful predicate on the input evaluates to true. It supports both curried and uncurried forms.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Schedule-untilInputEffect.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const untilInputEffect: { <In, R2>(f: (input: In) => Effect.Effect<boolean, never, R2>): <Out, R>(self: Schedule<Out, In, R>) => Schedule<Out, In, R2 | R>; <Out, In, R, R2>(self: Schedule<Out, In, R>, f: (input: In) => Effect.Effect<boolean, never, R2>): Schedule<Out, In, R | R2>; }\n```\n\n----------------------------------------\n\nTITLE: Declaring Micro Sandbox Function in TypeScript\nDESCRIPTION: The 'sandbox' function in the Micro module of the Effect-TS library transforms the error type of a given Micro instance to a MicroCause object, enabling more comprehensive error handling. Requires understanding of the Effect-TS library's Micro and MicroCause structures. This function takes a Micro instance as input and returns a new Micro instance with its error type replaced by MicroCause.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Micro-sandbox.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const sandbox: <A, E, R>(self: Micro<A, E, R>) => Micro<A, MicroCause<E>, R>\n```\n\n----------------------------------------\n\nTITLE: Folding UpstreamPullRequest into a Value in Effect TS\nDESCRIPTION: The match function processes an UpstreamPullRequest by providing handlers for both pulled values and scenarios with no upstream. It takes options that define these handlers, allowing for flexible handling of different states. This function is a generic and can work with various types for the value and output.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/UpstreamPullRequest-match.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const match: { <A, Z>(options: { readonly onPulled: (value: A) => Z; readonly onNoUpstream: (activeDownstreamCount: number) => Z; }): (self: UpstreamPullRequest<A>) => Z; <A, Z>(self: UpstreamPullRequest<A>, options: { readonly onPulled: (value: A) => Z; readonly onNoUpstream: (activeDownstreamCount: number) => Z; }): Z; }\n```\n\n----------------------------------------\n\nTITLE: Retrieving Cause From Failed Exits in TypeScript\nDESCRIPTION: The causeOption function returns a Some<Cause<E>> if the specified exit is a Failure, or None otherwise. This allows safely accessing the cause of failure when handling Exit instances.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Exit-causeOption.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const causeOption: <A, E>(self: Exit<A, E>) => Option.Option<Cause.Cause<E>>\n```\n\n----------------------------------------\n\nTITLE: Declaring unsafeSet Function for FiberHandle in TypeScript\nDESCRIPTION: Defines the unsafeSet function for setting a fiber in a FiberHandle. It allows setting a fiber with options for interruption, checking if a fiber is already running, and propagating interruption. The function can be called with the FiberHandle as the first argument or as a method on the FiberHandle object.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/FiberHandle-unsafeSet.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const unsafeSet: { <A, E, XE extends E, XA extends A>(fiber: Fiber.RuntimeFiber<XA, XE>, options?: { readonly interruptAs?: FiberId.FiberId | undefined; readonly onlyIfMissing?: boolean | undefined; readonly propagateInterruption?: boolean | undefined; }): (self: FiberHandle<A, E>) => void; <A, E, XE extends E, XA extends A>(self: FiberHandle<A, E>, fiber: Fiber.RuntimeFiber<XA, XE>, options?: { readonly interruptAs?: FiberId.FiberId | undefined; readonly onlyIfMissing?: boolean | undefined; readonly propagateInterruption?: boolean | undefined; }): void; }\n```\n\n----------------------------------------\n\nTITLE: TestClock Interface Definition in TypeScript\nDESCRIPTION: This snippet defines the TestClock interface, which extends the Clock interface. It includes methods for adjusting time, setting time, saving the current state, and retrieving scheduled sleeps.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TestClock-TestClock.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface TestClock extends Clock.Clock {\n  adjust(duration: Duration.DurationInput): Effect.Effect<void>\n  adjustWith(duration: Duration.DurationInput): <A, E, R>(effect: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>\n  readonly save: Effect.Effect<Effect.Effect<void>>\n  setTime(time: number): Effect.Effect<void>\n  readonly sleeps: Effect.Effect<Chunk.Chunk<number>>\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Flat Configuration Provider in Effect.js (TypeScript)\nDESCRIPTION: The makeFlat function creates a new flat config provider with specified options for loading configuration values, enumerating child paths, and path patching. It returns a ConfigProvider.Flat instance that can be used to manage application configuration.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/ConfigProvider-makeFlat.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const makeFlat: (options: { readonly load: <A>(path: ReadonlyArray<string>, config: Config.Config.Primitive<A>, split: boolean) => Effect.Effect<Array<A>, ConfigError.ConfigError>; readonly enumerateChildren: (path: ReadonlyArray<string>) => Effect.Effect<HashSet.HashSet<string>, ConfigError.ConfigError>; readonly patch: PathPatch.PathPatch; }) => ConfigProvider.Flat\n```\n\n----------------------------------------\n\nTITLE: Defining sequentialFinalizers Function in Effect Module (TypeScript)\nDESCRIPTION: Declaration of a function that ensures finalizers are run sequentially in reverse order of their addition. This modifies the default behavior of finalizers within a scoped workflow, particularly when the scope is configured to run finalizers concurrently.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-sequentialFinalizers.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const sequentialFinalizers: <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R>\n```\n\n----------------------------------------\n\nTITLE: Defining Config Interface in TypeScript\nDESCRIPTION: Defines a generic Config interface that extends Config.Variance and Effect.Effect interfaces. The Config type is used to describe configuration data structures with error handling via ConfigError.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Config-Config.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface Config<out A> extends Config.Variance<A>, Effect.Effect<A, ConfigError.ConfigError> {}\n```\n\n----------------------------------------\n\nTITLE: Creating Array Equivalence in TypeScript\nDESCRIPTION: Defines a function 'array' that creates an Equivalence for arrays. It takes an Equivalence for individual elements and returns an Equivalence for arrays of those elements. This allows for comparing arrays based on their content rather than reference equality.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Equivalence-array.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const array: <A>(item: Equivalence<A>) => Equivalence<ReadonlyArray<A>>\n```\n\n----------------------------------------\n\nTITLE: Creating STM Effect with Optional Value in TypeScript\nDESCRIPTION: Declares a function that generates an STM effect containing an optional value. This utility allows wrapping a value in an Option type within the STM (Software Transactional Memory) context.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/STM-succeedSome.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const succeedSome: <A>(value: A) => STM<Option.Option<A>>\n```\n\n----------------------------------------\n\nTITLE: Creating File Arguments with Args.file in TypeScript\nDESCRIPTION: The Args.file function creates a file argument for command-line interfaces. It optionally accepts a custom configuration and returns an Args instance of type string. The default argument name is 'file' if not specified.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Args-file.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const file: (config?: Args.PathArgsConfig) => Args<string>\n```\n\n----------------------------------------\n\nTITLE: Defining STM tapError Transactional Error Handler\nDESCRIPTION: Provides a functional way to intercept and potentially transform errors in STM transactions while preserving the original effect's result. Supports error inspection and side effects without modifying the main effect's outcome.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/STM-tapError.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const tapError: { <E, X, E2, R2>(f: (error: NoInfer<E>) => STM<X, E2, R2>): <A, R>(self: STM<A, E, R>) => STM<A, E | E2, R2 | R>; <A, E, R, X, E2, R2>(self: STM<A, E, R>, f: (error: E) => STM<X, E2, R2>): STM<A, E | E2, R | R2>; }\n```\n\n----------------------------------------\n\nTITLE: Inserting Entries and Querying with Prefix - TypeScript\nDESCRIPTION: This snippet demonstrates how to insert entries into a Trie and retrieve them based on a specified prefix. It utilizes the `Trie` class from the `effect` package and asserts the expected output against actual results. Dependencies include the `effect` package and Node.js assert module.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Trie-entriesWithPrefix.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { Trie } from \"effect\"\n\nconst trie = Trie.empty<number>().pipe(\n  Trie.insert(\"she\", 0),\n  Trie.insert(\"shells\", 1),\n  Trie.insert(\"sea\", 2),\n  Trie.insert(\"shore\", 3)\n)\n\nconst result = Array.from(Trie.entriesWithPrefix(trie, \"she\"))\nassert.deepStrictEqual(result, [[\"she\", 0], [\"shells\", 1]])\n```\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const entriesWithPrefix: { (prefix: string): <V>(self: Trie<V>) => IterableIterator<[string, V]>; <V>(self: Trie<V>, prefix: string): IterableIterator<[string, V]>; }\n```\n\n----------------------------------------\n\nTITLE: Tagging MetricKey in Typescript\nDESCRIPTION: This code snippet defines the `tagged` function, which is used to add a key-value tag to a `MetricKey` object in the Effect library. The function returns a new `MetricKey` with the specified tag appended. It supports curried and non-curried usage, enhancing flexibility.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/MetricKey-tagged.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const tagged: { (key: string, value: string): <Type extends MetricKeyType.MetricKeyType<any, any>>(self: MetricKey<Type>) => MetricKey<Type>; <Type extends MetricKeyType.MetricKeyType<any, any>>(self: MetricKey<Type>, key: string, value: string): MetricKey<Type>; }\n```\n\n----------------------------------------\n\nTITLE: ExcludeTag Usage Example in Effect\nDESCRIPTION: This example demonstrates how to use the `ExcludeTag` type to exclude a tagged object with the tag 'a' from a union type. The resulting type `Res` will be `string | { _tag: \"b\" }`.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Types-ExcludeTag.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport type { Types } from \"effect\"\n\ntype Res = Types.ExcludeTag<string | { _tag: \"a\" } | { _tag: \"b\" }, \"a\"> // string | { _tag: \"b\" }\n```\n\n----------------------------------------\n\nTITLE: Defining GenAI Token Telemetry Attributes Interface in TypeScript\nDESCRIPTION: Interface definition for token attributes used in AI telemetry that follows the GenAI specification. The interface includes an optional type property that can be a string, null, or undefined.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/AiTelemetry-GenAI.TokenAttributes.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface TokenAttributes {\n    readonly type?: string | null | undefined\n  }\n```\n\n----------------------------------------\n\nTITLE: Declaring text function in TypeScript for @effect/printer Doc module\nDESCRIPTION: This function creates a document containing a string of text. The text must be at least two characters long and cannot contain newline characters. Returns a Doc type with never as its error type.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Doc-text.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const text: (text: string) => Doc<never>\n```\n\n----------------------------------------\n\nTITLE: Declaring MutableQueue Capacity in TypeScript\nDESCRIPTION: This snippet declares a constant function that retrieves the capacity of a MutableQueue, denoting how many elements it can accommodate. It requires a MutableQueue instance as input and returns the number of elements it can hold, with a note that it can also support unbounded queues.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/MutableQueue-capacity.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const capacity: <A>(self: MutableQueue<A>) => number\n```\n\n----------------------------------------\n\nTITLE: Defining Layer.scopedContext Function in TypeScript\nDESCRIPTION: Function signature for creating a layer from a scoped effect that returns one or more services. The function takes an Effect that produces a Context and returns a Layer excluding the Scope type from its requirements.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Layer-scopedContext.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const scopedContext: <A, E, R>(effect: Effect.Effect<Context.Context<A>, E, R>) => Layer<A, E, Exclude<R, Scope.Scope>>\n```\n\n----------------------------------------\n\nTITLE: Declaring STM Retry in Typescript\nDESCRIPTION: This code snippet defines the `retry` constant as an `STM` (Software Transactional Memory) action that never produces a value, never fails, and never requires an environment.  It essentially represents an abort and retry operation within an STM transaction, useful when transactional variables have changed during the transaction's execution.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/STM-retry.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const retry: STM<never, never, never>\n```\n\n----------------------------------------\n\nTITLE: Declaration of firstSomeOf function\nDESCRIPTION: This code snippet presents the type signature of the `firstSomeOf` function within the Effect Option module.  It clarifies how the function takes an Iterable of Options and returns an Option of the same type, handling the case where the input Iterable may contain different option types via type inference.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Option-firstSomeOf.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const firstSomeOf: <T, C extends Iterable<Option<T>> = Iterable<Option<T>>>(collection: C) => [C] extends [Iterable<Option<infer A>>] ? Option<A> : never\n```\n\n----------------------------------------\n\nTITLE: TypeScript Function Signature for nowInCurrentZone in Effect Library\nDESCRIPTION: This code block shows the TypeScript function signature for the nowInCurrentZone function. It returns an Effect that produces a Zoned DateTime object and requires a CurrentTimeZone.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/DateTime-nowInCurrentZone.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const nowInCurrentZone: Effect.Effect<Zoned, never, CurrentTimeZone>\n```\n\n----------------------------------------\n\nTITLE: Decrementing a Number using Effect\nDESCRIPTION: This code snippet demonstrates how to use the `decrement` function from the `effect/Number` module to subtract 1 from a number. It imports the necessary modules, calls `decrement` with an initial value, and then asserts that the result is equal to the expected value. The example relies on `node:assert` for verification.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Number-decrement.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { decrement } from \"effect/Number\"\n\nassert.deepStrictEqual(decrement(3), 2)\n```\n\n----------------------------------------\n\nTITLE: Transforming Stream to Either Stream in TypeScript\nDESCRIPTION: Converts a Stream to expose failures and successes as an Either type, preventing stream failures by representing them within the success case\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-either.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const either: <A, E, R>(self: Stream<A, E, R>) => Stream<Either.Either<A, E>, never, R>\n```\n\n----------------------------------------\n\nTITLE: Implementing takeN Function for Queue in TypeScript\nDESCRIPTION: Defines the takeN function which takes a specified number of elements from a queue. It can be called with the number of elements first, or with the queue first. If fewer elements are available than requested, it suspends until they become available.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Queue-takeN.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const takeN: { (n: number): <A>(self: Dequeue<A>) => Effect.Effect<Chunk.Chunk<A>>; <A>(self: Dequeue<A>, n: number): Effect.Effect<Chunk.Chunk<A>>; }\n```\n\n----------------------------------------\n\nTITLE: TypeScript Type Signature for Record.replaceOption\nDESCRIPTION: Provides the complex type signature for the Record.replaceOption function, supporting different parameter arrangements and type inference\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Record-replaceOption.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const replaceOption: { <K extends string | symbol, B>(key: NoInfer<K>, b: B): <A>(self: ReadonlyRecord<K, A>) => Option.Option<Record<K, A | B>>; <K extends string | symbol, A, B>(self: ReadonlyRecord<K, A>, key: NoInfer<K>, b: B): Option.Option<Record<K, A | B>>; }\n```\n\n----------------------------------------\n\nTITLE: DateTime.add Function Signature in TypeScript\nDESCRIPTION: The type signature for the DateTime.add function, which accepts a Partial<DateTime.PartsForMath> object containing time units to add. The function is overloaded to support both method chaining and direct parameter passing patterns.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/DateTime-add.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const add: { (parts: Partial<DateTime.PartsForMath>): <A extends DateTime>(self: A) => A; <A extends DateTime>(self: A, parts: Partial<DateTime.PartsForMath>): A; }\n```\n\n----------------------------------------\n\nTITLE: TypeScript Type Signature for Stream.as Method\nDESCRIPTION: The type signature for the Stream.as method, showing it can be used in both pipe and traditional function call styles. It takes a value of type B and returns a function that transforms a Stream<A, E, R> into a Stream<B, E, R>.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-as.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const as: { <B>(value: B): <A, E, R>(self: Stream<A, E, R>) => Stream<B, E, R>; <A, E, R, B>(self: Stream<A, E, R>, value: B): Stream<B, E, R>; }\n```\n\n----------------------------------------\n\nTITLE: Type Signature of Array.chop Function in TypeScript\nDESCRIPTION: This snippet shows the type signature of the Array.chop function. It illustrates the function's polymorphic nature, accepting different types of iterables and returning arrays.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Array-chop.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const chop: { <S extends Iterable<any>, B>(f: (as: NonEmptyReadonlyArray<ReadonlyArray.Infer<S>>) => readonly [B, ReadonlyArray<ReadonlyArray.Infer<S>>]): (self: S) => ReadonlyArray.With<S, ReadonlyArray.Infer<S>>; <A, B>(self: NonEmptyReadonlyArray<A>, f: (as: NonEmptyReadonlyArray<A>) => readonly [B, ReadonlyArray<A>]): NonEmptyArray<B>; <A, B>(self: Iterable<A>, f: (as: NonEmptyReadonlyArray<A>) => readonly [B, ReadonlyArray<A>]): Array<B>; }\n```\n\n----------------------------------------\n\nTITLE: Merging Records with Intersection Function - TypeScript\nDESCRIPTION: The `intersection` function merges two records by retaining only the entries existing in both records. It takes two records and a combination function that determines how to merge the values of intersected keys. The function ensures the merged record retains only keys present in both input records. Dependencies include basic TypeScript and the ReadonlyRecord interface. Input records should be readonly and follow the specified key-value structure.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Record-intersection.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const intersection: { <K1 extends string, A, B, C>(that: ReadonlyRecord<K1, B>, combine: (selfValue: A, thatValue: B) => C): <K0 extends string>(self: ReadonlyRecord<K0, A>) => Record<ReadonlyRecord.IntersectKeys<K0, K1>, C>; <K0 extends string, A, K1 extends string, B, C>(self: ReadonlyRecord<K0, A>, that: ReadonlyRecord<K1, B>, combine: (selfValue: A, thatValue: B) => C): Record<ReadonlyRecord.IntersectKeys<K0, K1>, C>; }\n```\n\n----------------------------------------\n\nTITLE: TypeScript Signature of Iterable.getSomes Function\nDESCRIPTION: This code snippet shows the TypeScript signature of the getSomes function. It takes an Iterable of Options and returns an Iterable of the inner type of the Some values.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Iterable-getSomes.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const getSomes: <A>(self: Iterable<Option<A>>) => Iterable<A>\n```\n\n----------------------------------------\n\nTITLE: Interspersing Elements in a Stream with Affixes in TypeScript\nDESCRIPTION: The intersperseAffixes function adds a prefix, suffix, and interspersed elements to a stream. It takes an options object with start, middle, and end values, and applies them to the stream elements.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-intersperseAffixes.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Effect, Stream } from \"effect\"\n\nconst stream = Stream.make(1, 2, 3, 4, 5).pipe(\n  Stream.intersperseAffixes({\n    start: \"[\",\n    middle: \"-\",\n    end: \"]\"\n  })\n)\n\nEffect.runPromise(Stream.runCollect(stream)).then(console.log)\n// {\n//   _id: 'Chunk',\n//   values: [\n//     '[', 1,   '-', 2,   '-',\n//     3,   '-', 4,   '-', 5,\n//     ']'\n//   ]\n// }\n```\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const intersperseAffixes: { <A2, A3, A4>(options: { readonly start: A2; readonly middle: A3; readonly end: A4; }): <A, E, R>(self: Stream<A, E, R>) => Stream<A2 | A3 | A4 | A, E, R>; <A, E, R, A2, A3, A4>(self: Stream<A, E, R>, options: { readonly start: A2; readonly middle: A3; readonly end: A4; }): Stream<A | A2 | A3 | A4, E, R>; }\n```\n\n----------------------------------------\n\nTITLE: Implementing zipRight in FlatMap Module for TypeScript Effect\nDESCRIPTION: A variant of flatMap that ignores the value produced by the first effect. It takes a FlatMap type and returns a function that combines two effects, keeping only the result of the second one.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/FlatMap-zipRight.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const zipRight: <F extends TypeLambda>(F: FlatMap<F>) => { <R2, O2, E2, B>(that: Kind<F, R2, O2, E2, B>): <R1, O1, E1, _>(self: Kind<F, R1, O1, E1, _>) => Kind<F, R1 & R2, O2 | O1, E2 | E1, B>; <R1, O1, E1, _, R2, O2, E2, B>(self: Kind<F, R1, O1, E1, _>, that: Kind<F, R2, O2, E2, B>): Kind<F, R1 & R2, O1 | O2, E1 | E2, B>; }\n```\n\n----------------------------------------\n\nTITLE: Parsing TimeZone from String in Effect DateTime Module\nDESCRIPTION: Attempts to parse a TimeZone object from a string representation. Returns an Option type that contains the TimeZone if parsing succeeds, or None if it fails.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/DateTime-zoneFromString.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const zoneFromString: (zone: string) => Option.Option<TimeZone>\n```\n\n----------------------------------------\n\nTITLE: Creating HttpApi Middleware Layer in TypeScript\nDESCRIPTION: The middleware function creates an HttpApi level middleware Layer. It supports various overloads for different use cases, including options for context handling and specific API configurations.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/HttpApiBuilder-middleware.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const middleware: {\n  <EX = never, RX = never>(\n    middleware: MiddlewareFn<never> | Effect.Effect<MiddlewareFn<never>, EX, RX>,\n    options?: { readonly withContext?: false | undefined; }\n  ): Layer.Layer<never, EX, Exclude<RX, Scope>>;\n\n  <R, EX = never, RX = never>(\n    middleware: MiddlewareFn<never, R> | Effect.Effect<MiddlewareFn<never, R>, EX, RX>,\n    options: { readonly withContext: true; }\n  ): Layer.Layer<never, EX, Exclude<HttpRouter.HttpRouter.ExcludeProvided<R> | RX, Scope>>;\n\n  <ApiId extends string, Groups extends HttpApiGroup.HttpApiGroup.Any, Error, ErrorR, EX = never, RX = never>(\n    api: HttpApi.HttpApi<ApiId, Groups, Error, ErrorR>,\n    middleware: MiddlewareFn<NoInfer<Error>> | Effect.Effect<MiddlewareFn<NoInfer<Error>>, EX, RX>,\n    options?: { readonly withContext?: false | undefined; }\n  ): Layer.Layer<never, EX, Exclude<RX, Scope>>;\n\n  <ApiId extends string, Groups extends HttpApiGroup.HttpApiGroup.Any, Error, ErrorR, R, EX = never, RX = never>(\n    api: HttpApi.HttpApi<ApiId, Groups, Error, ErrorR>,\n    middleware: MiddlewareFn<NoInfer<Error>, R> | Effect.Effect<MiddlewareFn<NoInfer<Error>, R>, EX, RX>,\n    options: { readonly withContext: true; }\n  ): Layer.Layer<never, EX, Exclude<HttpRouter.HttpRouter.ExcludeProvided<R> | RX, Scope>>;\n}\n```\n\n----------------------------------------\n\nTITLE: TypeScript Function Signature for isEmptyArray\nDESCRIPTION: The type signature for the isEmptyArray function, showing that it narrows the type to empty array ([]) when returning true. It takes an array of any type and returns a type predicate.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Array-isEmptyArray.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const isEmptyArray: <A>(self: Array<A>) => self is []\n```\n\n----------------------------------------\n\nTITLE: RedBlackTree Insert Function in Typescript\nDESCRIPTION: The `insert` function inserts a new key-value pair into a RedBlackTree. It accepts either the key and value with the tree to modify passed to it later, or the tree, key, and value as separate arguments. The function returns a new RedBlackTree with the inserted item, maintaining the Red-Black Tree properties.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/RedBlackTree-insert.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const insert: { <K, V>(key: K, value: V): (self: RedBlackTree<K, V>) => RedBlackTree<K, V>; <K, V>(self: RedBlackTree<K, V>, key: K, value: V): RedBlackTree<K, V>; }\n```\n\n----------------------------------------\n\nTITLE: Checking for CharStream Type in DocStream Module (TypeScript)\nDESCRIPTION: A utility function that returns true if the provided DocStream instance is a CharStream, false otherwise. Used for type checking and narrowing in the DocStream module.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/DocStream-isCharStream.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const isCharStream: <A>(self: DocStream<A>) => self is CharStream<A>\n```\n\n----------------------------------------\n\nTITLE: Creating FiberId Instance - TypeScript Effect-TS\nDESCRIPTION: Function signature for unsafely creating a new FiberId instance in Effect-TS. The function takes a void parameter and returns a Runtime type. This is an unsafe operation that should be used with caution.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/FiberId-unsafeMake.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const unsafeMake: (_: void) => Runtime\n```\n\n----------------------------------------\n\nTITLE: Defining Clipboard Layer for Browser Navigator API in TypeScript\nDESCRIPTION: Creates a layer that directly interfaces with the browser's navigator.clipboard API. This allows Effect applications to interact with the clipboard in a type-safe manner.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Clipboard-layer.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const layer: Layer.Layer<Clipboard, never, never>\n```\n\n----------------------------------------\n\nTITLE: Reloading Tagged Services in Effect-TS\nDESCRIPTION: Function signature for reloading a service identified by a Context.Tag. Takes a tag parameter and returns an Effect that requires a Reloadable<I> capability and may fail with an unknown error.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Reloadable-reload.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const reload: <I, S>(tag: Context.Tag<I, S>) => Effect.Effect<void, unknown, Reloadable<I>>\n```\n\n----------------------------------------\n\nTITLE: Constructing Channel from AsyncInputConsumer in TypeScript\nDESCRIPTION: Function signature for creating a Channel from an AsyncInputConsumer. The function takes an AsyncInputConsumer with error, element, and done type parameters and returns a Channel with corresponding type parameters.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Channel-fromInput.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const fromInput: <Err, Elem, Done>(input: SingleProducerAsyncInput.AsyncInputConsumer<Err, Elem, Done>) => Channel<Elem, unknown, Err, unknown, Done, unknown>\n```\n\n----------------------------------------\n\nTITLE: Defining tapOutput Function for Schedule Module in TypeScript\nDESCRIPTION: Declares a tapOutput function that returns a new schedule running an effectful function for each output before continuing execution. It allows side effects to be performed on each output produced by the schedule without modifying its behavior.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Schedule-tapOutput.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const tapOutput: { <X, R2, Out>(f: (out: Types.NoInfer<Out>) => Effect.Effect<X, never, R2>): <In, R>(self: Schedule<Out, In, R>) => Schedule<Out, In, R2 | R>; <Out, In, R, X, R2>(self: Schedule<Out, In, R>, f: (out: Out) => Effect.Effect<X, never, R2>): Schedule<Out, In, R | R2>; }\n```\n\n----------------------------------------\n\nTITLE: Declaring Effect.never Function in TypeScript\nDESCRIPTION: Declares a constant 'never' of type Effect that represents an effect running indefinitely without producing any result. It's comparable to an infinite loop but doesn't consume CPU cycles.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-never.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const never: Effect<never, never, never>\n```\n\n----------------------------------------\n\nTITLE: String Type Predicate Signature in TypeScript\nDESCRIPTION: The `isString` function is a TypeScript predicate that takes an input of type unknown and determines if it is a string. This signature is crucial for ensuring type-safety and correctness when integrating this predicate function in various codebases.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Predicate-isString.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const isString: (input: unknown) => input is string\n```\n\n----------------------------------------\n\nTITLE: Creating List Constructor Function in TypeScript\nDESCRIPTION: Defines a cons function that constructs a new List.Cons<A> by combining a head value of type A with a tail of type List<A>. This is a fundamental list construction operation in the Effect library.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/List-cons.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const cons: <A>(head: A, tail: List<A>) => Cons<A>\n```\n\n----------------------------------------\n\nTITLE: Defining Concurrency Types in TypeScript\nDESCRIPTION: Describes the possible concurrency configurations for executing multiple Effect operations, supporting numeric limits, unbounded parallelism, and inheritance of concurrency settings\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Types-Concurrency.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ntype Concurrency = number | \"unbounded\" | \"inherit\"\n```\n\n----------------------------------------\n\nTITLE: Defining Exit.Failure Interface in TypeScript\nDESCRIPTION: Interface definition for representing a failed Effect workflow. It contains the cause of the failure of type E and implements Effect.Effect, Pipeable, and Inspectable interfaces. It also includes type unification symbols and internal properties.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Exit-Failure.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface Failure<out A, out E> extends Effect.Effect<A, E>, Pipeable, Inspectable {\n  readonly _tag: \"Failure\"\n  readonly _op: \"Failure\"\n  readonly cause: Cause.Cause<E>\n  [Unify.typeSymbol]?: unknown\n  [Unify.unifySymbol]?: ExitUnify<this>\n  [Unify.ignoreSymbol]?: ExitUnifyIgnore\n  /** @internal */\n  readonly effect_instruction_i0: Cause.Cause<E>\n}\n```\n\n----------------------------------------\n\nTITLE: Retrieving Immediate Children of a Fiber in TypeScript\nDESCRIPTION: The 'children' function retrieves the immediate children of a given fiber. It takes a Fiber<A, E> as input and returns an Effect that resolves to an array of RuntimeFiber instances. This function is useful for inspecting the hierarchy of fibers in an Effect-based application.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Fiber-children.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const children: <A, E>(self: Fiber<A, E>) => Effect.Effect<Array<RuntimeFiber<any, any>>>\n```\n\n----------------------------------------\n\nTITLE: Take Interface Definition in Effect\nDESCRIPTION: Defines the `Take` interface, which represents a single take from a queue. It extends `Take.Variance` and `Pipeable`, and contains a readonly `exit` property of type `Exit.Exit<Chunk.Chunk<A>, Option.Option<E>>` to represent the result of the take operation.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Take-Take.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface Take<out A, out E = never> extends Take.Variance<A, E>, Pipeable {\n  /** @internal */\n  readonly exit: Exit.Exit<Chunk.Chunk<A>, Option.Option<E>>\n}\n```\n\n----------------------------------------\n\nTITLE: Mapping Fiber Values in TypeScript\nDESCRIPTION: The map function allows transformation of the value computed by a Fiber. It takes a transformation function and applies it to the Fiber's result. This function supports both curried and uncurried forms for flexibility in usage.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Fiber-map.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const map: { <A, B>(f: (a: A) => B): <E>(self: Fiber<A, E>) => Fiber<B, E>; <A, E, B>(self: Fiber<A, E>, f: (a: A) => B): Fiber<B, E>; }\n```\n\n----------------------------------------\n\nTITLE: Defining HttpClient.tap Function in TypeScript\nDESCRIPTION: Declares the `tap` function for the HttpClient, which allows chaining an additional effect after a successful HTTP request. It takes a function that operates on the HttpClientResponse and returns an Effect.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/HttpClient-tap.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const tap: {\n  <_, E2, R2>(f: (response: ClientResponse.HttpClientResponse) => Effect.Effect<_, E2, R2>):\n    <E, R>(self: HttpClient.With<E, R>) => HttpClient.With<E | E2, R | R2>;\n  <E, R, _, E2, R2>(self: HttpClient.With<E, R>,\n    f: (response: ClientResponse.HttpClientResponse) => Effect.Effect<_, E2, R2>):\n      HttpClient.With<E | E2, R | R2>;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining DocStream Type in TypeScript\nDESCRIPTION: The definition of the DocStream type, which represents a document that has been laid out for rendering. DocStream is a union of various stream types including FailedStream, EmptyStream, CharStream, TextStream, LineStream, PushAnnotationStream, and PopAnnotationStream.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/DocStream-DocStream.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ntype DocStream<A> = | FailedStream<A>\n  | EmptyStream<A>\n  | CharStream<A>\n  | TextStream<A>\n  | LineStream<A>\n  | PushAnnotationStream<A>\n  | PopAnnotationStream<A>\n```\n\n----------------------------------------\n\nTITLE: Converting TMap Bindings to HashMap in TypeScript\nDESCRIPTION: This TypeScript snippet declares a function named `toHashMap` which takes a TMap of key-value pairings and returns an STM that converts the bindings into a HashMap. This functionality is part of Effect-TS's effect package and uses the STM library to handle state transitions in a transactional memory system. It requires the Effect-TS library as a dependency.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TMap-toHashMap.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const toHashMap: <K, V>(self: TMap<K, V>) => STM.STM<HashMap.HashMap<K, V>>\n```\n\n----------------------------------------\n\nTITLE: Struct.pick TypeScript Type Signature\nDESCRIPTION: Provides the complex type signature for the Struct.pick function, showcasing its flexible property selection capabilities with generics and type inference\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Struct-pick.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const pick: { <Keys extends Array<PropertyKey>>(...keys: Keys): <S extends { [K in Keys[number]]?: any; }>(s: S) => MatchRecord<S, { [K in Keys[number]]?: S[K]; }, Simplify<Pick<S, Keys[number]>>>; <S extends object, Keys extends Array<keyof S>>(s: S, ...keys: Keys): MatchRecord<S, { [K in Keys[number]]?: S[K]; }, Simplify<Pick<S, Keys[number]>>>; }\n```\n\n----------------------------------------\n\nTITLE: Type Checking MergeDecision in TypeScript\nDESCRIPTION: Defines a function 'isMergeDecision' that checks if a given value is of type MergeDecision. It returns true if the value is a MergeDecision, false otherwise. This function is useful for runtime type checking.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/MergeDecision-isMergeDecision.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const isMergeDecision: (u: unknown) => u is MergeDecision<unknown, unknown, unknown, unknown, unknown>\n```\n\n----------------------------------------\n\nTITLE: Defining orDieWith Function for Error Termination in Channel Module\nDESCRIPTION: The orDieWith function converts error handling in a Channel by terminating the fiber with errors rather than propagating them. It takes a function parameter that converts the OutErr type to an unknown type which becomes a defect.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Channel-orDieWith.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const orDieWith: { <OutErr>(f: (e: OutErr) => unknown): <OutElem, InElem, InErr, OutDone, InDone, Env>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>) => Channel<OutElem, InElem, never, InErr, OutDone, InDone, Env>; <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>, f: (e: OutErr) => unknown): Channel<OutElem, InElem, never, InErr, OutDone, InDone, Env>; }\n```\n\n----------------------------------------\n\nTITLE: Combining 'Micro' Effects in TypeScript\nDESCRIPTION: This TypeScript declaration exports a utility called 'zip' that combines two 'Micro' effects into a single effect. It has two overloaded signatures that allow for flexibility in order of arguments and optional concurrency settings. The utility outputs a 'Micro' that returns a tuple of results from the input 'Micro' effects, potentially altering error and resource types. No additional dependencies are assumed besides the 'effect' package.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Micro-zip.md#2025-04-11_snippet_0\n\nLANGUAGE: ts\nCODE:\n```\ndeclare const zip: { <A2, E2, R2>(that: Micro<A2, E2, R2>, options?: { readonly concurrent?: boolean | undefined; } | undefined): <A, E, R>(self: Micro<A, E, R>) => Micro<[A, A2], E2 | E, R2 | R>; <A, E, R, A2, E2, R2>(self: Micro<A, E, R>, that: Micro<A2, E2, R2>, options?: { readonly concurrent?: boolean | undefined; }): Micro<[A, A2], E | E2, R | R2>; }\n```\n\n----------------------------------------\n\nTITLE: Splitting a List at a Specified Index in TypeScript\nDESCRIPTION: The splitAt function splits a given list into two lists at the specified index. It can be used in two ways: either by providing the index first and then the list, or by providing the list first and then the index.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/List-splitAt.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const splitAt: { (n: number): <A>(self: List<A>) => [beforeIndex: List<A>, fromIndex: List<A>]; <A>(self: List<A>, n: number): [beforeIndex: List<A>, fromIndex: List<A>]; }\n```\n\n----------------------------------------\n\nTITLE: Defining Handlers Interface for Prompt in TypeScript\nDESCRIPTION: This code snippet defines the Handlers interface used by Prompts to manage rendering, input processing, and screen clearing. It includes three functions: render for displaying the current frame, process for handling user input, and clear for preparing the screen for the next frame.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Prompt-Prompt.Handlers.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface Handlers<State, Output> {\n    readonly render: (\n      state: State,\n      action: Action<State, Output>\n    ) => Effect<string, never, Environment>\n    readonly process: (\n      input: UserInput,\n      state: State\n    ) => Effect<Action<State, Output>, never, Environment>\n    readonly clear: (\n      state: State,\n      action: Action<State, Output>\n    ) => Effect<string, never, Environment>\n  }\n```\n\n----------------------------------------\n\nTITLE: Retrieving First Element from Non-Empty Chunk in TypeScript\nDESCRIPTION: The headNonEmpty function returns the first element of a non-empty chunk. It takes a NonEmptyChunk<A> as input and returns an element of type A. This function is part of the Chunk module in the effect package.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Chunk-headNonEmpty.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const headNonEmpty: <A>(self: NonEmptyChunk<A>) => A\n```\n\n----------------------------------------\n\nTITLE: Declaring Less Than Function - TypeScript\nDESCRIPTION: This code snippet defines the 'lessThan' function signature in TypeScript for the Effect Order module. It utilizes generic types to ensure type safety when comparing values. The 'lessThan' function can be called both as a curried function or with two parameters for direct comparison.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Order-lessThan.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const lessThan: <A>(O: Order<A>) => { (that: A): (self: A) => boolean; (self: A, that: A): boolean; }\n```\n\n----------------------------------------\n\nTITLE: Creating Supervisor with fibersIn in TypeScript\nDESCRIPTION: This function creates a new supervisor to track children fibers encapsulated in a mutable reference sorted set. It returns an Effect that encapsulates the operation of creating the Supervisor, which manages fibers in the context of the Effect-TS library.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Supervisor-fibersIn.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const fibersIn: (ref: MutableRef.MutableRef<SortedSet.SortedSet<Fiber.RuntimeFiber<any, any>>>) => Effect.Effect<Supervisor<SortedSet.SortedSet<Fiber.RuntimeFiber<any, any>>>>\n```\n\n----------------------------------------\n\nTITLE: Defining FiberMap.unsafeSet Function in TypeScript\nDESCRIPTION: Declares the unsafeSet function for adding a fiber to a FiberMap. It handles cases where the key already exists, with options for interrupting previous fibers and controlling propagation of interruptions. The function is overloaded to allow for different parameter orders.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/FiberMap-unsafeSet.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const unsafeSet: { <K, A, E, XE extends E, XA extends A>(key: K, fiber: Fiber.RuntimeFiber<XA, XE>, options?: { readonly interruptAs?: FiberId.FiberId | undefined; readonly onlyIfMissing?: boolean | undefined; readonly propagateInterruption?: boolean | undefined; } | undefined): (self: FiberMap<K, A, E>) => void; <K, A, E, XE extends E, XA extends A>(self: FiberMap<K, A, E>, key: K, fiber: Fiber.RuntimeFiber<XA, XE>, options?: { readonly interruptAs?: FiberId.FiberId | undefined; readonly onlyIfMissing?: boolean | undefined; readonly propagateInterruption?: boolean | undefined; } | undefined): void; }\n```\n\n----------------------------------------\n\nTITLE: Type Signature for Array.unappend Function in TypeScript\nDESCRIPTION: The type signature for the Array.unappend function, which takes a non-empty array and returns a tuple containing the array without its last element and the last element.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Array-unappend.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const unappend: <A>(self: NonEmptyReadonlyArray<A>) => [arrayWithoutLastElement: Array<A>, lastElement: A]\n```\n\n----------------------------------------\n\nTITLE: Checking for DecodeException Type in TypeScript\nDESCRIPTION: A type guard function that determines if a value is a DecodeException. Returns true if the provided value is an instance of DecodeException, false otherwise. This function is useful for error handling in decode operations.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Encoding-isDecodeException.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const isDecodeException: (u: unknown) => u is DecodeException\n```\n\n----------------------------------------\n\nTITLE: Retrieving Original Error in Effect.io TypeScript\nDESCRIPTION: Utility function that unwraps and returns the original error object from any library-specific error proxies. This function is essential for accessing native error properties and stack traces during debugging or when integrating with external systems.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Cause-originalError.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const originalError: <E>(obj: E) => E\n```\n\n----------------------------------------\n\nTITLE: Defining TMap Interface in TypeScript\nDESCRIPTION: The TMap interface provides a framework for creating a transactional map that supports key-value pair storage with conflict resolution. This interface extends the Variance class, allowing for flexible key and value types. No additional dependencies are specified beyond those inherent to TypeScript.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TMap-TMap.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface TMap<in out K, in out V> extends TMap.Variance<K, V> {}\n```\n\n----------------------------------------\n\nTITLE: Implementing MetricPolling.zip Type Definition in TypeScript\nDESCRIPTION: Defines a type signature for zipping two polling metrics together. The operation combines two MetricPolling instances into a single MetricPolling that produces a tuple of their outputs while preserving their input types and error handling.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/MetricPolling-zip.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const zip: { \n  <Type2, In2, R2, E2, Out2>(that: MetricPolling<Type2, In2, R2, E2, Out2>): \n    <Type, In, R, E, Out>(self: MetricPolling<Type, In, R, E, Out>) => \n      MetricPolling<readonly [Type, Type2], readonly [In, In2], R2 | R, E2 | E, [Out, Out2]>; \n  <Type, In, R, E, Out, Type2, In2, R2, E2, Out2>(\n    self: MetricPolling<Type, In, R, E, Out>, \n    that: MetricPolling<Type2, In2, R2, E2, Out2>\n  ): MetricPolling<readonly [Type, Type2], readonly [In, In2], R | R2, E | E2, [Out, Out2]>; \n}\n```\n\n----------------------------------------\n\nTITLE: Accessing Elements in a Tuple - TypeScript\nDESCRIPTION: The snippet demonstrates how to use the Tuple.at method from the Effect library to retrieve an element from a specific index in a tuple. It requires the Effect library and Node's assert module for assertion testing. The snippet shows importing the necessary modules and asserts the equality of the retrieved element.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Tuple-at.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { Tuple } from \"effect\"\n\nassert.deepStrictEqual(Tuple.at([1, 'hello', true], 1), 'hello')\n```\n\n----------------------------------------\n\nTITLE: Determining Non-Empty Chunks in TypeScript\nDESCRIPTION: The 'isNonEmpty' function checks if a given Chunk is not empty. It takes a Chunk<A> as input and returns a boolean indicating whether the chunk is a NonEmptyChunk<A>. This function is useful for type narrowing and ensuring that operations are only performed on non-empty chunks.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Chunk-isNonEmpty.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const isNonEmpty: <A>(self: Chunk<A>) => self is NonEmptyChunk<A>\n```\n\n----------------------------------------\n\nTITLE: Using Array.setNonEmptyHead to Replace the First Element in a Non-Empty Array in TypeScript\nDESCRIPTION: This example demonstrates how to use the Array.setNonEmptyHead function to replace the first element of a non-empty array, creating a new array. The function takes an array and a new value, returning a new array with the head element replaced.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Array-setNonEmptyHead.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Array } from \"effect\"\n\nconst result = Array.setNonEmptyHead([1, 2, 3], 10)\nconsole.log(result) // [10, 2, 3]\n```\n\n----------------------------------------\n\nTITLE: Implementing Scope Extension in Effect-TS\nDESCRIPTION: Declares a function that extends an Effect's scope. The function can be called with either the scope first followed by the effect, or with the effect and scope parameters reversed. It returns an Effect with the Scope requirement removed from the type parameter R.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Scope-extend.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const extend: { \n  (scope: Scope): <A, E, R>(effect: Effect.Effect<A, E, R>) => Effect.Effect<A, E, Exclude<R, Scope>>; \n  <A, E, R>(effect: Effect.Effect<A, E, R>, scope: Scope): Effect.Effect<A, E, Exclude<R, Scope>>; \n}\n```\n\n----------------------------------------\n\nTITLE: Implementing collectAllUntilEffect in TypeScript Effect IO\nDESCRIPTION: Function signature for collecting incoming elements into a chunk until a given effectful predicate is satisfied. The function takes a predicate that returns an Effect of boolean and returns a Sink that accumulates elements.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Sink-collectAllUntilEffect.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const collectAllUntilEffect: <In, E, R>(p: (input: In) => Effect.Effect<boolean, E, R>) => Sink<Chunk.Chunk<In>, In, In, E, R>\n```\n\n----------------------------------------\n\nTITLE: STM.filterOrDie signature\nDESCRIPTION: The `filterOrDie` function filters the result of an `STM` transaction. It can be used with a predicate or a refinement. If the condition is not met, the transaction dies with the provided `defect`. It supports both curried and non-curried invocations.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/STM-filterOrDie.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const filterOrDie: { <A, B extends A>(refinement: Refinement<NoInfer<A>, B>, defect: LazyArg<unknown>): <E, R>(self: STM<A, E, R>) => STM<B, E, R>; <A>(predicate: Predicate<NoInfer<A>>, defect: LazyArg<unknown>): <E, R>(self: STM<A, E, R>) => STM<A, E, R>; <A, E, R, B extends A>(self: STM<A, E, R>, refinement: Refinement<A, B>, defect: LazyArg<unknown>): STM<B, E, R>; <A, E, R>(self: STM<A, E, R>, predicate: Predicate<A>, defect: LazyArg<unknown>): STM<A, E, R>; }\n```\n\n----------------------------------------\n\nTITLE: Extracting Right Values from Either Array in TypeScript\nDESCRIPTION: Demonstrates how to use the Array.getRights function to filter and collect Right values from an array of Either types, ignoring Left values.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Array-getRights.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Array, Either } from \"effect\"\n\nconst result = Array.getRights([Either.right(1), Either.left(\"err\"), Either.right(2)])\nconsole.log(result) // [1, 2]\n```\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const getRights: <T extends Iterable<Either.Either<any, any>>>(self: T) => Array<Either.Either.Right<ReadonlyArray.Infer<T>>>\n```\n\n----------------------------------------\n\nTITLE: Channel.provideLayer Function Definition in TypeScript\nDESCRIPTION: The provideLayer function provides a Layer to a Channel, translating it to a different environment. It supports two calling patterns: either providing just the layer, or providing both the channel and the layer.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Channel-provideLayer.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const provideLayer: { <Env, OutErr2, Env0>(layer: Layer.Layer<Env, OutErr2, Env0>): <OutElem, InElem, OutErr, InErr, OutDone, InDone>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>) => Channel<OutElem, InElem, OutErr2 | OutErr, InErr, OutDone, InDone, Env0>; <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutErr2, Env0>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>, layer: Layer.Layer<Env, OutErr2, Env0>): Channel<OutElem, InElem, OutErr | OutErr2, InErr, OutDone, InDone, Env0>; }\n```\n\n----------------------------------------\n\nTITLE: Extracting Tag Type with TypeScript\nDESCRIPTION: This code snippet demonstrates the creation and use of the `ExtractTag` type in TypeScript, which extracts a specific type from a union of types based on the `_tag` key. The purpose of this utility is to streamline the use of tagged types within TypeScript, ensuring type correctness and differentiation. No additional dependencies are required other than TypeScript, and it can handle any type that includes a `_tag` field.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Types-ExtractTag.md#2025-04-11_snippet_0\n\nLANGUAGE: ts\nCODE:\n```\nimport type { Types } from \"effect\"\n\ntype Res = Types.ExtractTag<{ _tag: \"a\", a: number } | { _tag: \"b\", b: number }, \"b\"> // { _tag: \"b\", b: number }\n```\n\nLANGUAGE: ts\nCODE:\n```\ntype ExtractTag<E, K> = Extract<E, { _tag: K }>\n```\n\n----------------------------------------\n\nTITLE: Implementing Parent Span Management in Effect TypeScript\nDESCRIPTION: Function declaration for withParentSpan that adds a provided span to the current span stack. It supports both curried and non-curried function calls, operating on Effect types with generic type parameters.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-withParentSpan.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const withParentSpan: { (span: Tracer.AnySpan): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, Exclude<R, Tracer.ParentSpan>>; <A, E, R>(self: Effect<A, E, R>, span: Tracer.AnySpan): Effect<A, E, Exclude<R, Tracer.ParentSpan>>; }\n```\n\n----------------------------------------\n\nTITLE: Converting DateTime to Start of Time Unit in TypeScript\nDESCRIPTION: Demonstrates how to use DateTime.startOf to convert a DateTime instance to the start of a specified time unit. In this example, a datetime is converted to the start of the day, resulting in the time component being set to 00:00:00.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/DateTime-startOf.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { DateTime } from \"effect\"\n\n// returns \"2024-01-01T00:00:00Z\"\nDateTime.unsafeMake(\"2024-01-01T12:00:00Z\").pipe(\n  DateTime.startOf(\"day\"),\n  DateTime.formatIso\n)\n```\n\n----------------------------------------\n\nTITLE: Generating Integer Range Array in TypeScript using Effect Package\nDESCRIPTION: Demonstrates the usage of the range function from the Array module in the Effect package. This function creates a NonEmptyArray containing a sequence of integers from the start to the end value, inclusive.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Array-range.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { range } from \"effect/Array\"\n\nconst result = range(1, 3)\nconsole.log(result) // [1, 2, 3]\n```\n\n----------------------------------------\n\nTITLE: Creating Repeatedly Running Channels in TypeScript\nDESCRIPTION: This function creates a channel which repeatedly runs the provided channel. It takes a Channel instance and returns a new Channel that will execute the original channel's operations repeatedly.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Channel-repeated.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const repeated: <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>) => Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>\n```\n\n----------------------------------------\n\nTITLE: Implementing mapLeft Function for Bicovariant TypeClass in TypeScript\nDESCRIPTION: Provides a default implementation of mapLeft for bicovariant functors. The function allows mapping over the left (error) type of a bifunctor while preserving the right type. It supports both curried and uncurried calling styles.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Bicovariant-mapLeft.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const mapLeft: <F extends TypeLambda>(F: Bicovariant<F>) => { <E, G>(f: (e: E) => G): <R, O, A>(self: Kind<F, R, O, E, A>) => Kind<F, R, O, G, A>; <R, O, E, A, G>(self: Kind<F, R, O, E, A>, f: (e: E) => G): Kind<F, R, O, G, A>; }\n```\n\n----------------------------------------\n\nTITLE: Getting HashMap Entry Count in TypeScript\nDESCRIPTION: TypeScript function declaration for retrieving the number of entries in a HashMap. Takes a HashMap of generic key-value types and returns a number representing the total count of entries.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/HashMap-size.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const size: <K, V>(self: HashMap<K, V>) => number\n```\n\n----------------------------------------\n\nTITLE: Unwrapping an Effect into a Channel in TypeScript\nDESCRIPTION: The unwrap function constructs a Channel from an Effect that will result in a Channel if successful. It combines the error type from both the Effect and the resulting Channel.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Channel-unwrap.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const unwrap: <OutElem, InElem, OutErr, InErr, OutDone, InDone, R2, E, R>(channel: Effect.Effect<Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, R2>, E, R>) => Channel<OutElem, InElem, E | OutErr, InErr, OutDone, InDone, R | R2>\n```\n\n----------------------------------------\n\nTITLE: Transforming Schedule with mapBothEffect - TypeScript\nDESCRIPTION: The mapBothEffect function enables the transformation of inputs and outputs of a given schedule through effectful computations. It takes an options object that specifies effectful transformation functions for both inputs and outputs. The function accommodates complex computations, including side effects, during the transformation process.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Schedule-mapBothEffect.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const mapBothEffect: { <In2, In, R2, Out, R3, Out2>(options: { readonly onInput: (input: In2) => Effect.Effect<In, never, R2>; readonly onOutput: (out: Out) => Effect.Effect<Out2, never, R3>; }): <R>(self: Schedule<Out, In, R>) => Schedule<Out2, In2, R2 | R3 | R>; <Out, In, R, In2, R2, Out2, R3>(self: Schedule<Out, In, R>, options: { readonly onInput: (input: In2) => Effect.Effect<In, never, R2>; readonly onOutput: (out: Out) => Effect.Effect<Out2, never, R3>; }): Schedule<Out2, In2, R | R2 | R3>; }\n```\n\n----------------------------------------\n\nTITLE: Stream.fail Function Signature - TypeScript\nDESCRIPTION: This snippet provides the function signature for the Stream.fail method, which takes an error of generic type E and returns a stream that never emits values and always fails with the provided error. It is necessary to understand this signature for proper type handling when working with error streams in TypeScript.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-fail.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const fail: <E>(error: E) => Stream<never, E>\n```\n\n----------------------------------------\n\nTITLE: Retrieving Fiber ID in STM Transaction\nDESCRIPTION: A specialized STM operation that returns the unique identifier of the current fiber executing the transaction. This method is part of the Effect library's Software Transactional Memory implementation and provides context about the executing fiber.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/STM-fiberId.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const fiberId: STM<FiberId.FiberId, never, never>\n```\n\n----------------------------------------\n\nTITLE: Acquiring Write Locks with TReentrantLock in TypeScript\nDESCRIPTION: Function for acquiring a write lock in a transactional memory context. The transaction suspends until no other fibers are holding read or write locks, and it returns the number of write locks held by the current fiber after acquisition.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TReentrantLock-acquireWrite.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const acquireWrite: (self: TReentrantLock) => STM.STM<number>\n```\n\n----------------------------------------\n\nTITLE: Declaring withWriteLock in Typescript\nDESCRIPTION: Defines the `withWriteLock` function, which takes a `TReentrantLock` instance and an `Effect` as input, and returns an `Effect` that executes the given effect with a write lock. It supports curried and non-curried forms.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TReentrantLock-withWriteLock.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const withWriteLock: { (self: TReentrantLock): <A, E, R>(effect: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>; <A, E, R>(effect: Effect.Effect<A, E, R>, self: TReentrantLock): Effect.Effect<A, E, R>; }\n```\n\n----------------------------------------\n\nTITLE: Checking if a value is a TEnqueue in TypeScript\nDESCRIPTION: A type guard function that checks if an unknown value is an instance of TEnqueue. Returns true if the value is a TEnqueue instance, false otherwise.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TQueue-isTEnqueue.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const isTEnqueue: (u: unknown) => u is TEnqueue<unknown>\n```\n\n----------------------------------------\n\nTITLE: Combining FiberIds in TypeScript using Effect-TS\nDESCRIPTION: Defines a combine function that merges two FiberId instances. The function supports both curried and uncurried calling styles, allowing flexible usage patterns in the Effect-TS ecosystem.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/FiberId-combine.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const combine: { (that: FiberId): (self: FiberId) => FiberId; (self: FiberId, that: FiberId): FiberId; }\n```\n\n----------------------------------------\n\nTITLE: Declaring RuntimeMetrics Flag in TypeScript\nDESCRIPTION: Defines the RuntimeMetrics constant, a runtime flag that determines whether the Effect runtime system will collect metrics. While this flag has a small performance impact, it provides valuable operational insights that can be exported to monitoring tools like Prometheus.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/RuntimeFlags-RuntimeMetrics.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const RuntimeMetrics: RuntimeFlag\n```\n\n----------------------------------------\n\nTITLE: Creating File Parsing Arguments with Args.fileParse in TypeScript\nDESCRIPTION: Creates a file argument that reads and parses the contents of a file. This function can be configured with a custom argument name (defaulting to \"file\") and returns an Args type with unknown content.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Args-fileParse.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const fileParse: (config?: Args.FormatArgsConfig | undefined) => Args<unknown>\n```\n\n----------------------------------------\n\nTITLE: Declaring orElseSucceed Function in Effect STM Module in TypeScript\nDESCRIPTION: The `orElseSucceed` function attempts to execute a given STM effect, and if it either fails or retries, it instead returns a specified fallback value. This utility is part of the `effect` package and is used to provide alternative success paths for STM computations. The function takes a `LazyArg` parameter that supplies the fallback value and returns a modified STM operation.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/STM-orElseSucceed.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const orElseSucceed: { <A2>(value: LazyArg<A2>): <A, E, R>(self: STM<A, E, R>) => STM<A2 | A, never, R>; <A, E, R, A2>(self: STM<A, E, R>, value: LazyArg<A2>): STM<A | A2, never, R>; }\n```\n\n----------------------------------------\n\nTITLE: FiberSet.make Function Signature in TypeScript\nDESCRIPTION: This code snippet shows the TypeScript signature for the FiberSet.make function. It creates a FiberSet for managing fibers of type A with possible error type E, and requires a Scope for proper resource management.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/FiberSet-make.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const make: <A = unknown, E = unknown>() => Effect.Effect<FiberSet<A, E>, never, Scope.Scope>\n```\n\n----------------------------------------\n\nTITLE: Creating Counter MetricKey in TypeScript\nDESCRIPTION: Function signature for creating a metric key counter with configurable options. Supports both number and bigint counter types based on configuration. Allows setting description and incremental behavior through options object.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/MetricKey-counter.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const counter: { \n  (name: string, options?: { \n    readonly description?: string | undefined; \n    readonly bigint?: false | undefined; \n    readonly incremental?: boolean | undefined; \n  }): MetricKey.Counter<number>; \n  (name: string, options: { \n    readonly description?: string | undefined; \n    readonly bigint: true; \n    readonly incremental?: boolean | undefined; \n  }): MetricKey.Counter<bigint>; \n}\n```\n\n----------------------------------------\n\nTITLE: Updating URL Host in Effect Platform (Typescript)\nDESCRIPTION: The `setHost` function is used to update the host (domain and port) of a URL object.  It accepts either the new host string as the first argument and returns a function to apply to a URL, or the URL object and the new host string as arguments. The function returns a new URL object with the updated host.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Url-setHost.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const setHost: { (host: string): (url: URL) => URL; (url: URL, host: string): URL; }\n```\n\n----------------------------------------\n\nTITLE: Using Array.tailNonEmpty to Get All Elements Except First in TypeScript\nDESCRIPTION: Example demonstrating how to use the tailNonEmpty function from the Array module to extract all elements except the first from a non-empty array. The function returns a new array containing all elements after the first element.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Array-tailNonEmpty.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Array } from \"effect\"\n\nconst result = Array.tailNonEmpty([1, 2, 3, 4])\nconsole.log(result) // [2, 3, 4]\n```\n\n----------------------------------------\n\nTITLE: Declaring the increment function in Typescript\nDESCRIPTION: This snippet shows the type declaration for the `increment` function. It declares a constant named `increment` that is a function taking a number as input (`n: number`) and returns a number (`=> number`). This signature defines the expected input and output types for the `increment` function.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Number-increment.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const increment: (n: number) => number\n```\n\n----------------------------------------\n\nTITLE: Effect.interrupt Type Signature in TypeScript\nDESCRIPTION: This code snippet shows the type signature of the Effect.interrupt function. It is defined as an Effect that takes no input, produces no error, and returns no value.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-interrupt.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const interrupt: Effect<never, never, never>\n```\n\n----------------------------------------\n\nTITLE: Defining GroupBy Interface in TypeScript\nDESCRIPTION: TypeScript interface definition for GroupBy which extends GroupBy.Variance and Pipeable. It represents a grouped stream with a property 'grouped' that contains a Stream of key-value pairs where values are queues of takes.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/GroupBy-GroupBy.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface GroupBy<out K, out V, out E = never, out R = never> extends GroupBy.Variance<K, V, E, R>, Pipeable {\n  readonly grouped: Stream.Stream<readonly [K, Queue.Dequeue<Take.Take<V, E>>], E, R>\n}\n```\n\n----------------------------------------\n\nTITLE: Defining FittingPredicate Interface in TypeScript\nDESCRIPTION: Defines a type interface for a predicate function that determines whether a DocStream fits within specified layout constraints. The predicate considers the original indentation, current column position, and handles alternative DocStream comparisons.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Layout-Layout.FittingPredicate.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface FittingPredicate<A> {\n    (\n      stream: DocStream<A>,\n      indentation: number,\n      currentColumn: number,\n      comparator: LazyArg<DocStream<A>>\n    ): boolean\n  }\n```\n\n----------------------------------------\n\nTITLE: Type Signature of Array.max Function in Effect Library\nDESCRIPTION: This code block shows the type signature of the Array.max function. It accepts an Order object for comparison and can be called with either the array first and Order second, or Order first and array second.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Array-max.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const max: { <A>(O: Order.Order<A>): (self: NonEmptyReadonlyArray<A>) => A; <A>(self: NonEmptyReadonlyArray<A>, O: Order.Order<A>): A; }\n```\n\n----------------------------------------\n\nTITLE: Sum function signature in Effect/Number\nDESCRIPTION: This snippet shows the function signature of the `sum` function in the `effect/Number` module. It indicates that `sum` is a curried function that can take one argument at a time or both arguments at once.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Number-sum.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const sum: { (that: number): (self: number) => number; (self: number, that: number): number; }\n```\n\n----------------------------------------\n\nTITLE: Option.filterMap Signature in Effect\nDESCRIPTION: This snippet shows the TypeScript declaration of the `filterMap` function.  It shows how the function can be called as either `filterMap(f)(self)` or `filterMap(self, f)`. It uses generics A and B to specify the input and output types of the Option values.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Option-filterMap.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const filterMap: { <A, B>(f: (a: A) => Option<B>): (self: Option<A>) => Option<B>; <A, B>(self: Option<A>, f: (a: A) => Option<B>): Option<B>; }\n```\n\n----------------------------------------\n\nTITLE: Reducing Entries in RedBlackTree - TypeScript\nDESCRIPTION: The function 'reduce' allows accumulating or transforming the entries of a RedBlackTree. It can operate with either a functional or a curried approach, taking an initial 'zero' state and an accumulator function 'f'. The accumulator function is applied to each entry, with parameters for the current accumulator value, entry value, and entry key. The result is the final accumulated state. This requires TypeScript and the RedBlackTree implementation as dependencies. Key constraints include requiring correct generic typing for types Z, V, and K.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/RedBlackTree-reduce.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const reduce: { <Z, V, K>(zero: Z, f: (accumulator: Z, value: V, key: K) => Z): (self: RedBlackTree<K, V>) => Z; <Z, V, K>(self: RedBlackTree<K, V>, zero: Z, f: (accumulator: Z, value: V, key: K) => Z): Z; }\n```\n\n----------------------------------------\n\nTITLE: Implementing filterMap Function for Lists in TypeScript\nDESCRIPTION: Function declaration for filterMap that takes a partial function and applies it to list elements. The function filters elements while transforming them, returning only successful transformations wrapped in Option type. Supports both curried and uncurried forms.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/List-filterMap.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const filterMap: { <A, B>(f: (a: A) => Option.Option<B>): (self: List<A>) => List<B>; <A, B>(self: List<A>, f: (a: A) => Option.Option<B>): List<B>; }\n```\n\n----------------------------------------\n\nTITLE: Transforming Schedule Inputs to Outputs in TypeScript\nDESCRIPTION: The `passthrough` function modifies a schedule so it outputs its input values instead of the original output values. The timing of the schedule's execution remains unchanged. This requires no external dependencies and assumes familiarity with generic types and schedule structures. The function accepts a schedule of type `Schedule<Out, In, R>` and outputs a schedule of type `Schedule<In, In, R>`. There are no specific constraints, aside from maintaining correct input types.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Schedule-passthrough.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const passthrough: <Out, In, R>(self: Schedule<Out, In, R>) => Schedule<In, In, R>\n```\n\n----------------------------------------\n\nTITLE: Subtracting Time Units from DateTime in TypeScript\nDESCRIPTION: This snippet demonstrates how to subtract time units from a DateTime object using the subtract method. The example shows how to subtract 5 minutes from a DateTime initialized at timestamp 0.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/DateTime-subtract.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { DateTime } from \"effect\"\n\n// subtract 5 minutes\nDateTime.unsafeMake(0).pipe(\n  DateTime.subtract({ minutes: 5 })\n)\n```\n\n----------------------------------------\n\nTITLE: Creating Semigroup Instance with TypeScript\nDESCRIPTION: Function signature for creating a Semigroup instance with a required combine operation and optional combineMany implementation. The combineMany parameter can be customized for performance optimizations, otherwise it uses a default implementation.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Semigroup-make.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const make: <A>(combine: Semigroup<A>[\"combine\"], combineMany?: Semigroup<A>[\"combineMany\"]) => Semigroup<A>\n```\n\n----------------------------------------\n\nTITLE: Declaring Atomic Array Reduction with STM in TypeScript\nDESCRIPTION: The `reduceOptionSTM` signature defines a method for reducing a non-empty TArray using a transactional binary operator, ensuring atomicity. This function requires the `STM` module for transactional memory operations in TypeScript. It accepts a binary function `f` and a TArray `self`, returning a transactional option of the reduced value. This functionality is critical in concurrent programming where atomic operations ensure data consistency and prevent race conditions.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TArray-reduceOptionSTM.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const reduceOptionSTM: { <A, R, E>(f: (x: A, y: A) => STM.STM<A, E, R>): (self: TArray<A>) => STM.STM<Option.Option<A>, E, R>; <A, R, E>(self: TArray<A>, f: (x: A, y: A) => STM.STM<A, E, R>): STM.STM<Option.Option<A>, E, R>; }\n```\n\n----------------------------------------\n\nTITLE: Function Signature for fromIterableBy in TypeScript\nDESCRIPTION: This snippet provides the TypeScript declaration for the 'fromIterableBy' function, which specifies its generic parameters and describes its input and output types. This is useful for understanding how to implement the function properly within the TypeScript type system.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Record-fromIterableBy.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const fromIterableBy: <A, K extends string | symbol>(items: Iterable<A>, f: (a: A) => K) => Record<ReadonlyRecord.NonLiteralKey<K>, A>\n```\n\n----------------------------------------\n\nTITLE: Type Signature of Effect Record.filterMap\nDESCRIPTION: This code defines the type signature of the `Record.filterMap` function in the Effect library. It shows how the function takes a record and a mapping function as input, and returns a new record with potentially different keys and values based on the `Option` type returned by the mapping function.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Record-filterMap.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const filterMap: { <K extends string, A, B>(f: (a: A, key: K) => Option.Option<B>): (self: ReadonlyRecord<K, A>) => Record<ReadonlyRecord.NonLiteralKey<K>, B>; <K extends string, A, B>(self: ReadonlyRecord<K, A>, f: (a: A, key: K) => Option.Option<B>): Record<ReadonlyRecord.NonLiteralKey<K>, B>; }\n```\n\n----------------------------------------\n\nTITLE: foldWeightedDecompose Function Signature in TypeScript\nDESCRIPTION: The TypeScript function signature for Sink.foldWeightedDecompose, showing its parameters and return type. It creates a sink that folds elements until a maximum cost is reached, with a decomposition strategy for handling threshold-exceeding elements.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Sink-foldWeightedDecompose.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const foldWeightedDecompose: <S, In>(options: { readonly initial: S; readonly maxCost: number; readonly cost: (s: S, input: In) => number; readonly decompose: (input: In) => Chunk.Chunk<In>; readonly body: (s: S, input: In) => S; }) => Sink<S, In, In>\n```\n\n----------------------------------------\n\nTITLE: Creating Effect from Fiber TypeScript Type Definition\nDESCRIPTION: Type definition for the fromFiber function that converts a Fiber instance into an Effect value. The function takes a Fiber with generic type parameters for success (A) and error (E) values and returns a corresponding Effect.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-fromFiber.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const fromFiber: <A, E>(fiber: Fiber.Fiber<A, E>) => Effect<A, E>\n```\n\n----------------------------------------\n\nTITLE: Defining Take.tap Function in TypeScript\nDESCRIPTION: Declares a const tap function that returns an effect for effectfully 'peeking' at the success of a take. It supports both curried and uncurried calling styles, handling different generic types for input and output effects.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Take-tap.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const tap: {\n  <A, X, E2, R>(f: (chunk: Chunk.Chunk<A>) => Effect.Effect<X, E2, R>): <E>(self: Take<A, E>) => Effect.Effect<void, E2 | E, R>;\n  <A, E, X, E2, R>(self: Take<A, E>, f: (chunk: Chunk.Chunk<A>) => Effect.Effect<X, E2, R>): Effect.Effect<void, E | E2, R>;\n}\n```\n\n----------------------------------------\n\nTITLE: Combining Differs with orElseEither in TypeScript\nDESCRIPTION: The `orElseEither` function combines two differs to produce a new differ that can handle the sum of their values. It allows creating a differ for `Either<Value2, Value>` types based on existing differs for `Value` and `Value2`.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Differ-orElseEither.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const orElseEither: { <Value2, Patch2>(that: Differ<Value2, Patch2>): <Value, Patch>(self: Differ<Value, Patch>) => Differ<Either<Value2, Value>, Differ.Or.Patch<Value, Value2, Patch, Patch2>>; <Value, Patch, Value2, Patch2>(self: Differ<Value, Patch>, that: Differ<Value2, Patch2>): Differ<Either<Value2, Value>, Differ.Or.Patch<Value, Value2, Patch, Patch2>>; }\n```\n\n----------------------------------------\n\nTITLE: Effect.forkScoped TypeScript Function Signature\nDESCRIPTION: The TypeScript type signature for the forkScoped function in the Effect module. It takes an Effect and returns a new Effect that creates a RuntimeFiber when executed. The returned Effect requires a Scope and the same environment as the input Effect.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-forkScoped.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const forkScoped: <A, E, R>(self: Effect<A, E, R>) => Effect<Fiber.RuntimeFiber<A, E>, never, Scope.Scope | R>\n```\n\n----------------------------------------\n\nTITLE: Creating SubscriptionRef with Effect-TS\nDESCRIPTION: The `make` function is a generic function that takes a value of any type and returns an Effect that produces a SubscriptionRef containing that value. This function allows users to create SubscriptionRefs that can be used for managing subscription-based state in applications. It is declared as a constant function and is generically typed to support any value type.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/SubscriptionRef-make.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const make: <A>(value: A) => Effect.Effect<SubscriptionRef<A>>\n```\n\n----------------------------------------\n\nTITLE: Defining HttpApiBuilder.serve Function in TypeScript\nDESCRIPTION: Declares the 'serve' function that builds an HttpApp from an HttpApi instance and serves it using an HttpServer. It accepts an optional middleware function to modify the HttpApp before serving.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/HttpApiBuilder-serve.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const serve: <R = never>(middleware?: (httpApp: HttpApp.Default) => HttpApp.Default<never, R>) => Layer.Layer<never, never, HttpServer.HttpServer | HttpRouter.HttpRouter.DefaultServices | Exclude<R, Scope | HttpServerRequest.HttpServerRequest> | HttpApi.Api>\n```\n\n----------------------------------------\n\nTITLE: Setting Fiber in FiberHandle with TypeScript\nDESCRIPTION: Function signature for setting a fiber in a FiberHandle with options for controlling fiber interruption behavior. Supports both curried and uncurried calling styles. Includes options for only setting if missing and controlling interruption propagation.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/FiberHandle-set.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const set: {\n  <A, E, XE extends E, XA extends A>(\n    fiber: Fiber.RuntimeFiber<XA, XE>,\n    options?: {\n      readonly onlyIfMissing?: boolean;\n      readonly propagateInterruption?: boolean | undefined;\n    }\n  ): (self: FiberHandle<A, E>) => Effect.Effect<void>;\n  <A, E, XE extends E, XA extends A>(\n    self: FiberHandle<A, E>,\n    fiber: Fiber.RuntimeFiber<XA, XE>,\n    options?: {\n      readonly onlyIfMissing?: boolean;\n      readonly propagateInterruption?: boolean | undefined;\n    }\n  ): Effect.Effect<void>;\n}\n```\n\n----------------------------------------\n\nTITLE: Declaration of partitionMap Function in TypeScript\nDESCRIPTION: The 'partitionMap' function is declared to partition records using a specified mapping function in TypeScript. It takes in a record and applies a function that yields an Either type, returning a tuple of two records. The first record contains elements mapped to 'Left' and the second to 'Right'. This function is part of the 'effect' package.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Record-partitionMap.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const partitionMap: { <K extends string, A, B, C>(f: (a: A, key: K) => Either<C, B>): (self: ReadonlyRecord<K, A>) => [left: Record<ReadonlyRecord.NonLiteralKey<K>, B>, right: Record<ReadonlyRecord.NonLiteralKey<K>, C>]; <K extends string, A, B, C>(self: ReadonlyRecord<K, A>, f: (a: A, key: K) => Either<C, B>): [left: Record<ReadonlyRecord.NonLiteralKey<K>, B>, right: Record<ReadonlyRecord.NonLiteralKey<K>, C>]; }\n```\n\n----------------------------------------\n\nTITLE: DateTime.withDateUtc Type Definition\nDESCRIPTION: Type signature for the withDateUtc function showing its polymorphic nature. It can be used both in pipeable and traditional function call styles.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/DateTime-withDateUtc.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const withDateUtc: { <A>(f: (date: Date) => A): (self: DateTime) => A; <A>(self: DateTime, f: (date: Date) => A): A; }\n```\n\n----------------------------------------\n\nTITLE: HashSet.empty Function Signature in TypeScript\nDESCRIPTION: The type signature for the HashSet.empty function, which creates an empty HashSet. It's a generic function that can create a HashSet of any type A.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/HashSet-empty.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const empty: <A = never>() => HashSet<A>\n```\n\n----------------------------------------\n\nTITLE: Moving Cursor to Previous Line with AnsiDoc in TypeScript\nDESCRIPTION: Function that moves the cursor to the beginning of the line a specified number of rows up, with a default of 1 row. Returns an AnsiDoc object for terminal manipulation.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/AnsiDoc-cursorPrevLine.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const cursorPrevLine: (rows?: number) => AnsiDoc\n```\n\n----------------------------------------\n\nTITLE: TaggedClass Type Signature\nDESCRIPTION: Type signature for the TaggedClass constructor function, showing its generic parameters and return type structure.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Request-TaggedClass.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const TaggedClass: <Tag extends string>(tag: Tag) => new <Success, Error, A extends Record<string, any>>(args: Types.Equals<Omit<A, keyof Request<unknown, unknown>>, {}> extends true ? void : { readonly [P in keyof A as P extends \"_tag\" | keyof Request<unknown, unknown> ? never : P]: A[P]; }) => Request<Success, Error> & Readonly<A> & { readonly _tag: Tag; }\n```\n\n----------------------------------------\n\nTITLE: Effect.catchAllDefect Function Signature in TypeScript\nDESCRIPTION: The TypeScript type signature for the Effect.catchAllDefect function. It shows the function's polymorphic nature and how it can be used with different Effect types.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-catchAllDefect.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const catchAllDefect: { <A2, E2, R2>(f: (defect: unknown) => Effect<A2, E2, R2>): <A, E, R>(self: Effect<A, E, R>) => Effect<A2 | A, E2 | E, R2 | R>; <A, E, R, A2, E2, R2>(self: Effect<A, E, R>, f: (defect: unknown) => Effect<A2, E2, R2>): Effect<A | A2, E | E2, R | R2>; }\n```\n\n----------------------------------------\n\nTITLE: DateTime UTC Manipulation Example in TypeScript\nDESCRIPTION: Demonstrates how to use DateTime.withDateUtc to extract the timestamp from a DateTime object. The function takes a DateTime object and applies a callback function to its UTC Date representation.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/DateTime-withDateUtc.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { DateTime } from \"effect\"\n\n// get the date in milliseconds\nDateTime.unsafeMake(0).pipe(\n  DateTime.withDateUtc((date) => date.getTime())\n)\n```\n\n----------------------------------------\n\nTITLE: Defining Boolean Monoid for Conjunction in Typescript\nDESCRIPTION: This code snippet defines a constant `MonoidEvery` as a boolean monoid under conjunction. It's part of the `@effect/typeclass` package in Effect TS.  The `empty` value, which serves as the identity, is defined as `true`.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/data-Boolean-MonoidEvery.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const MonoidEvery: monoid.Monoid<boolean>\n```\n\n----------------------------------------\n\nTITLE: Creating Streams for Cross Product\nDESCRIPTION: Demonstrates initializing streams with numeric and string elements to be used in cross product generation\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-cross.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst s1 = Stream.make(1, 2, 3)\nconst s2 = Stream.make(\"a\", \"b\")\n```\n\n----------------------------------------\n\nTITLE: Either.isLeft Type Signature Definition\nDESCRIPTION: Type signature for the isLeft function showing it takes an Either<R, L> and returns a type predicate indicating if it's a Left<L, R>.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Either-isLeft.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const isLeft: <R, L>(self: Either<R, L>) => self is Left<L, R>\n```\n\n----------------------------------------\n\nTITLE: Retrieving Random Numbers with TRandom.next in TypeScript\nDESCRIPTION: This function returns the next number from the pseudo-random number generator in a transactional context. It's part of the TRandom module in the effect package and returns an STM effect that produces a number.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TRandom-next.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const next: STM.STM<number, never, TRandom>\n```\n\n----------------------------------------\n\nTITLE: MutableHashSet.add TypeScript Function Signature\nDESCRIPTION: The TypeScript type signature for the add function in MutableHashSet module, showing both data-first and data-last (pipeable) overloads.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/MutableHashSet-add.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const add: { <V>(key: V): (self: MutableHashSet<V>) => MutableHashSet<V>; <V>(self: MutableHashSet<V>, key: V): MutableHashSet<V>; }\n```\n\n----------------------------------------\n\nTITLE: Implementing Timed Stream Emission with Effect Stream.tick\nDESCRIPTION: Demonstrates how to create a stream that emits void values at regular intervals using Stream.tick. The example logs timestamps between emissions to show the timing accuracy of approximately 1 second intervals.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-tick.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Effect, Stream } from \"effect\"\n\nlet last = Date.now()\nconst log = (message: string) =>\n  Effect.sync(() => {\n    const end = Date.now()\n    console.log(`${message} after ${end - last}ms`)\n    last = end\n  })\n\nconst stream = Stream.tick(\"1 seconds\").pipe(Stream.tap(() => log(\"tick\")))\n\nEffect.runPromise(Stream.runCollect(stream.pipe(Stream.take(5)))).then(console.log)\n// tick after 4ms\n// tick after 1003ms\n// tick after 1001ms\n// tick after 1002ms\n// tick after 1002ms\n// { _id: 'Chunk', values: [ undefined, undefined, undefined, undefined, undefined ] }\n```\n\n----------------------------------------\n\nTITLE: Stream.dropWhile Function Signature in Typescript\nDESCRIPTION: This code snippet shows the function signature of `dropWhile` in the Effect Stream module. It takes either a predicate function or a stream and a predicate function as arguments, and returns a new stream with elements dropped as long as the predicate is true.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-dropWhile.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const dropWhile: { <A>(predicate: Predicate<NoInfer<A>>): <E, R>(self: Stream<A, E, R>) => Stream<A, E, R>; <A, E, R>(self: Stream<A, E, R>, predicate: Predicate<A>): Stream<A, E, R>; }\n```\n\n----------------------------------------\n\nTITLE: Failing a Deferred with a Cause in TypeScript\nDESCRIPTION: The failCauseSync function fails a Deferred with a specified Cause, which is then propagated to all fibers waiting on the Deferred's value. It returns an Effect that resolves to a boolean.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Deferred-failCauseSync.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const failCauseSync: { <E>(evaluate: LazyArg<Cause.Cause<E>>): <A>(self: Deferred<A, E>) => Effect.Effect<boolean>; <A, E>(self: Deferred<A, E>, evaluate: LazyArg<Cause.Cause<E>>): Effect.Effect<boolean>; }\n```\n\n----------------------------------------\n\nTITLE: Identifying Request in TypeScript\nDESCRIPTION: This TypeScript function determines if a given value is of type Request by returning true if the criteria are met, or false otherwise. It's intended for use in the Effect-TS library, where it helps manage and handle Request objects more reliably. No additional dependencies are required, and the input is any unknown type with output as a boolean indicating whether the input is a Request.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Request-isRequest.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const isRequest: (u: unknown) => u is Request<unknown, unknown>\n```\n\n----------------------------------------\n\nTITLE: Creating Standard Schema with Effect Schema Module in TypeScript\nDESCRIPTION: The snippet demonstrates the use of a utility function 'Schema.standardSchemaV1', which creates a schema object confirming to the Standard Schema v1 specification. It includes defining a schema with synchronous validation capabilities, which may return a Promise if asynchronous components are included. Dependencies include the 'effect' package. Inputs are defined schemas, and outputs are standard schema objects. Limitations include potential Promises for asynchronous components.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Schema-standardSchemaV1.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { Schema } from \"effect\"\n\nconst schema = Schema.Struct({\n  name: Schema.String\n})\n\n//      ┌─── StandardSchemaV1<{ readonly name: string; }>\n//      ▼\nconst standardSchema = Schema.standardSchemaV1(schema)\n```\n\n----------------------------------------\n\nTITLE: Using Array.matchLeft for Pattern Matching in TypeScript\nDESCRIPTION: Demonstrates how to use the Array.matchLeft function to handle different array states. The function takes an options object with onEmpty and onNonEmpty handlers, allowing different behavior for empty arrays versus arrays with elements.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Array-matchLeft.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Array } from \"effect\"\n\nconst matchLeft = Array.matchLeft({\n  onEmpty: () => \"empty\",\n  onNonEmpty: (head, tail) => `head: ${head}, tail: ${tail.length}`\n})\nconsole.log(matchLeft([])) // \"empty\"\nconsole.log(matchLeft([1, 2, 3])) // \"head: 1, tail: 2\"\n```\n\n----------------------------------------\n\nTITLE: Defining Line Interface in TypeScript\nDESCRIPTION: Defines the Line interface which extends Doc.Variance<A> and represents a document with a hard line break. This interface is part of the @effect/printer package's Doc module.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Doc-Line.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface Line<A> extends Doc.Variance<A> {\n  readonly _tag: \"Line\"\n}\n```\n\n----------------------------------------\n\nTITLE: Defining recurUntil Function - TypeScript\nDESCRIPTION: The recurUntil function creates a schedule that will execute repeatedly until the predicate function evaluates to true, allowing for flexible scheduling based on conditions.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Schedule-recurUntil.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const recurUntil: <A>(f: Predicate<A>) => Schedule<A, A>\n```\n\n----------------------------------------\n\nTITLE: Declaring MutableList Head Function in TypeScript\nDESCRIPTION: This TypeScript snippet declares a function named 'head' to retrieve the first element of a MutableList, returning undefined if the list is empty. Requires the 'effect' package and TypeScript environment. Input: MutableList. Output: First element or undefined.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/MutableList-head.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const head: <A>(self: MutableList<A>) => A | undefined\n```\n\n----------------------------------------\n\nTITLE: STM.mapBoth Signature\nDESCRIPTION: The `mapBoth` function transforms an `STM` effect, modifying both its success and failure channels. It accepts an object with `onFailure` and `onSuccess` functions to map the respective channels. The function returns a new `STM` effect with the transformed types.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/STM-mapBoth.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const mapBoth: { <E, E2, A, A2>(options: { readonly onFailure: (error: E) => E2; readonly onSuccess: (value: A) => A2; }): <R>(self: STM<A, E, R>) => STM<A2, E2, R>; <A, E, R, E2, A2>(self: STM<A, E, R>, options: { readonly onFailure: (error: E) => E2; readonly onSuccess: (value: A) => A2; }): STM<A2, E2, R>; }\n```\n\n----------------------------------------\n\nTITLE: Adding GenAI Annotations to Span in TypeScript\nDESCRIPTION: The `addGenAIAnnotations` function applies OpenAi GenAI telemetry attributes to a specified `Span`, mutating it directly. It accepts either options first, then span or span first then options as arguments. This functionality is part of the `@effect/ai-openai` package.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/OpenAiTelemetry-addGenAIAnnotations.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const addGenAIAnnotations: ((options: OpenAiTelemetryAttributeOptions) => (span: Span) => void) & ((span: Span, options: OpenAiTelemetryAttributeOptions) => void)\n```\n\n----------------------------------------\n\nTITLE: Array.match Function Signature in TypeScript\nDESCRIPTION: Provides the TypeScript type signature for the Array.match function. It shows the function's polymorphic nature, allowing for different return types for empty and non-empty cases.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Array-match.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const match: { <B, A, C = B>(options: { readonly onEmpty: LazyArg<B>; readonly onNonEmpty: (self: NonEmptyReadonlyArray<A>) => C; }): (self: ReadonlyArray<A>) => B | C; <A, B, C = B>(self: ReadonlyArray<A>, options: { readonly onEmpty: LazyArg<B>; readonly onNonEmpty: (self: NonEmptyReadonlyArray<A>) => C; }): B | C; }\n```\n\n----------------------------------------\n\nTITLE: Removing Array Elements with Effect Package in TypeScript\nDESCRIPTION: Demonstrates the usage of Array.remove function from the Effect package to delete an element at a specified index from an array. It also shows the behavior when the index is out of bounds.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Array-remove.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Array } from \"effect\"\n\nconst input = [1, 2, 3, 4]\nconst result = Array.remove(input, 2)\nconsole.log(result) // [1, 2, 4]\n\nconst outOfBoundsResult = Array.remove(input, 5)\nconsole.log(outOfBoundsResult) // [1, 2, 3, 4]\n```\n\n----------------------------------------\n\nTITLE: Modifying Document Annotations in TypeScript\nDESCRIPTION: Function that changes document annotations to different annotations or removes them. It takes a transformation function that converts annotations of type A to an Iterable of type B, and applies it to a DocTree.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/DocTree-alterAnnotations.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const alterAnnotations: { <A, B>(f: (a: A) => Iterable<B>): (self: DocTree<A>) => DocTree<B>; <A, B>(self: DocTree<A>, f: (a: A) => Iterable<B>): DocTree<B>; }\n```\n\n----------------------------------------\n\nTITLE: Declaring getOrThrow function signature in TypeScript\nDESCRIPTION: This code snippet declares the type signature for the `getOrThrow` function within the `Option` module.  It shows that the function takes an `Option<A>` as input and returns a value of type `A`, throwing an error if the option is `None`.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Option-getOrThrow.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const getOrThrow: <A>(self: Option<A>) => A\n```\n\n----------------------------------------\n\nTITLE: Signature of mergeWithTag Function - TypeScript\nDESCRIPTION: This signature definition outlines the TypeScript type for the 'mergeWithTag' function in Effect-TS, explaining how streams are merged. It specifies that the function accepts a struct of streams and options for concurrency and buffer size.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-mergeWithTag.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const mergeWithTag: { <S extends { [k in string]: Stream<any, any, any>; }>(streams: S, options: { readonly concurrency: number | \"unbounded\"; readonly bufferSize?: number | undefined; }): Stream<{ [K in keyof S]: { _tag: K; value: Stream.Success<S[K]>; }; }[keyof S], Stream.Error<S[keyof S]>, Stream.Context<S[keyof S]>>; (options: { readonly concurrency: number | \"unbounded\"; readonly bufferSize?: number | undefined; }): <S extends { [k in string]: Stream<any, any, any>; }>(streams: S) => Stream<{ [K in keyof S]: { _tag: K; value: Stream.Success<S[K]>; }; }[keyof S], Stream.Error<S[keyof S]>, Stream.Context<S[keyof S]>>; }\n```\n\n----------------------------------------\n\nTITLE: Constructing Channel from Either in TypeScript\nDESCRIPTION: This function constructs a channel from an Either type. It takes an Either as input and returns a Channel. The Channel type parameters indicate that it never yields, has unknown input type, output type L, and unknown environment type.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Channel-fromEither.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const fromEither: <R, L>(either: Either.Either<R, L>) => Channel<never, unknown, L, unknown, R, unknown>\n```\n\n----------------------------------------\n\nTITLE: Function Signature for Array.range in TypeScript\nDESCRIPTION: Provides the TypeScript function signature for the range function in the Array module. It takes two number parameters (start and end) and returns a NonEmptyArray of numbers.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Array-range.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const range: (start: number, end: number) => NonEmptyArray<number>\n```\n\n----------------------------------------\n\nTITLE: TMap.forEach Signature\nDESCRIPTION: The `forEach` function iterates over each key-value pair in a `TMap` and applies a provided transactional effect. It returns an `STM` effect that represents the sequential execution of the effect for each pair.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TMap-forEach.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const forEach: { <K, V, X, E, R>(f: (key: K, value: V) => STM.STM<X, E, R>): (self: TMap<K, V>) => STM.STM<void, E, R>; <K, V, X, E, R>(self: TMap<K, V>, f: (key: K, value: V) => STM.STM<X, E, R>): STM.STM<void, E, R>; }\n```\n\n----------------------------------------\n\nTITLE: Defining runDrain Function in TypeScript for Channel Module\nDESCRIPTION: Declares the runDrain function which runs a channel until the end is received. It takes a Channel as input and returns an Effect. The function is generic, allowing for various types of elements, errors, and environments.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Channel-runDrain.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const runDrain: <OutElem, OutErr, InErr, OutDone, InDone, Env>(self: Channel<OutElem, unknown, OutErr, InErr, OutDone, InDone, Env>) => Effect.Effect<OutDone, OutErr, Env>\n```\n\n----------------------------------------\n\nTITLE: Modifying a Record Element\nDESCRIPTION: This snippet demonstrates how to apply a function to a specific key in a record using the Record.modify method from Effect-TS. If the key is present, the value is transformed; if the key is absent, the original record is returned unchanged. It uses assertions to validate the expected outcomes.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Record-modify.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { Record as R } from \"effect\"\n\nconst f = (x: number) => x * 2\n\nassert.deepStrictEqual(\n R.modify({ a: 3 }, 'a', f),\n { a: 6 }\n)\nassert.deepStrictEqual(\n R.modify({ a: 3 } as Record<string, number>, 'b', f),\n { a: 3 }\n)\n```\n\n----------------------------------------\n\nTITLE: Publishing Messages to TPubSub using STM Transactions in TypeScript\nDESCRIPTION: This function publishes a message to a TPubSub instance, returning a boolean STM value indicating whether the message was successfully published. It supports both curried and uncurried calling styles.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TPubSub-publish.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const publish: { <A>(value: A): (self: TPubSub<A>) => STM.STM<boolean>; <A>(self: TPubSub<A>, value: A): STM.STM<boolean>; }\n```\n\n----------------------------------------\n\nTITLE: Converting STM Result to Void in TypeScript\nDESCRIPTION: The asVoid function maps the success value of an STM to void. It preserves the success/failure state of the original STM, maintaining the same error if the original fails.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/STM-asVoid.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const asVoid: <A, E, R>(self: STM<A, E, R>) => STM<void, E, R>\n```\n\n----------------------------------------\n\nTITLE: Function Signature for Array.tailNonEmpty in TypeScript\nDESCRIPTION: TypeScript type signature for the tailNonEmpty function which takes a non-empty readonly array of type A and returns an array of the same type A. This signature shows the function operates on NonEmptyReadonlyArray types.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Array-tailNonEmpty.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const tailNonEmpty: <A>(self: NonEmptyReadonlyArray<A>) => Array<A>\n```\n\n----------------------------------------\n\nTITLE: Using Effect.zipLeft to Execute Sequential Effects in TypeScript\nDESCRIPTION: Example demonstrating how to use Effect.zipLeft to execute two effects sequentially, keeping only the result of the first effect while still executing the second effect for its side effects.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-zipLeft.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Effect } from \"effect\"\n\nconst task1 = Effect.succeed(1).pipe(\n  Effect.delay(\"200 millis\"),\n  Effect.tap(Effect.log(\"task1 done\"))\n)\nconst task2 = Effect.succeed(\"hello\").pipe(\n  Effect.delay(\"100 millis\"),\n  Effect.tap(Effect.log(\"task2 done\"))\n)\n\nconst program = Effect.zipLeft(task1, task2)\n\nEffect.runPromise(program).then(console.log)\n// Output:\n// timestamp=... level=INFO fiber=#0 message=\"task1 done\"\n// timestamp=... level=INFO fiber=#0 message=\"task2 done\"\n// 1\n```\n\n----------------------------------------\n\nTITLE: Checking All Entries in a Record\nDESCRIPTION: This code snippet declares a TypeScript function 'every' that checks if all entries in a ReadonlyRecord meet a certain condition defined by a predicate or refinement function. It supports both type guards and boolean predicates, allowing for versatile usage depending on the needs of the caller. It is recommended for use in TypeScript projects where strong type checking is desired.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Record-every.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const every: { <A, K extends string, B extends A>(refinement: (value: A, key: K) => value is B): (self: ReadonlyRecord<K, A>) => self is ReadonlyRecord<K, B>; <A, K extends string>(predicate: (value: A, key: K) => boolean): (self: ReadonlyRecord<K, A>) => boolean; <A, K extends string, B extends A>(self: ReadonlyRecord<K, A>, refinement: (value: A, key: K) => value is B): self is ReadonlyRecord<K, B>; <K extends string, A>(self: ReadonlyRecord<K, A>, predicate: (value: A, key: K) => boolean): boolean; }\n```\n\n----------------------------------------\n\nTITLE: Implementing Line Iterator with Separators in TypeScript\nDESCRIPTION: Function declaration for linesWithSeparators that returns an IterableIterator (LinesIterator) which yields each line from an input string including the trailing newline characters. This utility helps in processing text line by line while maintaining original line endings.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/String-linesWithSeparators.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const linesWithSeparators: (s: string) => LinesIterator\n```\n\n----------------------------------------\n\nTITLE: Retrieving TestClock Service in Effect (TypeScript)\nDESCRIPTION: The `testClockWith` function retrieves the TestClock service and executes a provided Effect workflow. It takes a function `f` which accepts a `TestClock` instance and returns an `Effect` that represents the workflow to be executed. This allows tests to interact with and control the flow of time.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TestClock-testClockWith.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const testClockWith: <A, E, R>(f: (testClock: TestClock) => Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>\n```\n\n----------------------------------------\n\nTITLE: Type Signature for Array.insertAt Function in Effect\nDESCRIPTION: The type signature for the insertAt function shows it can be used in both curried and non-curried forms. It takes an iterable, an index, and an element to insert, and returns an Option of NonEmptyArray.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Array-insertAt.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const insertAt: { <B>(i: number, b: B): <A>(self: Iterable<A>) => Option.Option<NonEmptyArray<A | B>>; <A, B>(self: Iterable<A>, i: number, b: B): Option.Option<NonEmptyArray<A | B>>; }\n```\n\n----------------------------------------\n\nTITLE: Implementing Array.some Function in TypeScript\nDESCRIPTION: The `some` function checks if a predicate holds true for at least one element in a ReadonlyArray. It returns a boolean indicating whether the array contains at least one element that satisfies the provided predicate function. The function is overloaded to work with either curried or non-curried calling styles.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Array-some.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const some: { <A>(predicate: (a: NoInfer<A>, i: number) => boolean): (self: ReadonlyArray<A>) => self is NonEmptyReadonlyArray<A>; <A>(self: ReadonlyArray<A>, predicate: (a: A, i: number) => boolean): self is NonEmptyReadonlyArray<A>; }\n```\n\n----------------------------------------\n\nTITLE: Identity Function Type Signature in TypeScript\nDESCRIPTION: Type declaration for the identity function, showing it accepts a generic type parameter A and returns the same type. The function takes a single parameter and returns it unchanged.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Function-identity.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const identity: <A>(a: A) => A\n```\n\n----------------------------------------\n\nTITLE: Implementing Sink.findEffect in TypeScript for Conditional Value Processing\nDESCRIPTION: Defines the findEffect function that creates a sink which processes input values until one satisfies the specified predicate. The function returns the first value that meets the predicate condition wrapped in an Option, or None if no value satisfies the condition.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Sink-findEffect.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const findEffect: { <A, E2, R2>(f: (a: A) => Effect.Effect<boolean, E2, R2>): <In, L extends In, E, R>(self: Sink<A, In, L, E, R>) => Sink<Option.Option<A>, In, L, E2 | E, R2 | R>; <A, In, L extends In, E, R, E2, R2>(self: Sink<A, In, L, E, R>, f: (a: A) => Effect.Effect<boolean, E2, R2>): Sink<Option.Option<A>, In, L, E | E2, R | R2>; }\n```\n\n----------------------------------------\n\nTITLE: Checking Number Less Than or Equal in TypeScript\nDESCRIPTION: The snippet uses the 'lessThanOrEqualTo' function from the 'effect/Number' module to determine if a given number is less than or equal to another. It demonstrates its usage with assertions. Requires 'assert' from 'node:assert' and 'lessThanOrEqualTo' from 'effect/Number'. It takes two numbers and returns a boolean, constrained by the two provided parameters.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Number-lessThanOrEqualTo.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { lessThanOrEqualTo } from \"effect/Number\"\n\nassert.deepStrictEqual(lessThanOrEqualTo(2, 3), true)\nassert.deepStrictEqual(lessThanOrEqualTo(3, 3), true)\nassert.deepStrictEqual(lessThanOrEqualTo(4, 3), false)\n```\n\n----------------------------------------\n\nTITLE: Type Signature for Stream.mapEffect in TypeScript\nDESCRIPTION: This code block defines the type signature for the Stream.mapEffect function. It includes multiple overloads to support different use cases, including options for concurrency and custom key-based mapping.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-mapEffect.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const mapEffect: { <A, A2, E2, R2>(f: (a: A) => Effect.Effect<A2, E2, R2>, options?: { readonly concurrency?: number | \"unbounded\" | undefined; readonly unordered?: boolean | undefined; } | undefined): <E, R>(self: Stream<A, E, R>) => Stream<A2, E2 | E, R2 | R>; <A, A2, E2, R2, K>(f: (a: A) => Effect.Effect<A2, E2, R2>, options: { readonly key: (a: A) => K; readonly bufferSize?: number | undefined; }): <E, R>(self: Stream<A, E, R>) => Stream<A2, E2 | E, R2 | R>; <A, E, R, A2, E2, R2>(self: Stream<A, E, R>, f: (a: A) => Effect.Effect<A2, E2, R2>, options?: { readonly concurrency?: number | \"unbounded\" | undefined; readonly unordered?: boolean | undefined; } | undefined): Stream<A2, E | E2, R | R2>; <A, E, R, A2, E2, R2, K>(self: Stream<A, E, R>, f: (a: A) => Effect.Effect<A2, E2, R2>, options: { readonly key: (a: A) => K; readonly bufferSize?: number | undefined; }): Stream<A2, E | E2, R | R2>; }\n```\n\n----------------------------------------\n\nTITLE: Using isTruthy Function in TypeScript\nDESCRIPTION: Demonstrates how to use the isTruthy function from the Predicate module to test if values are truthy. The example shows testing for truthy and falsy values.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Predicate-isTruthy.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { isTruthy } from \"effect/Predicate\"\n\nassert.deepStrictEqual(isTruthy(1), true)\nassert.deepStrictEqual(isTruthy(0), false)\nassert.deepStrictEqual(isTruthy(\"\"), false)\n```\n\n----------------------------------------\n\nTITLE: Intersecting Intervals in TypeScript\nDESCRIPTION: This snippet declares a function to find the intersection of two Interval instances using a flexible API where parameters can be applied in different orders. It allows for operations with different Interval objects, requiring the 'Intervals' type. Inputs and outputs are expected to be of type 'Intervals'.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/ScheduleIntervals-intersect.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const intersect: { (that: Intervals): (self: Intervals) => Intervals; (self: Intervals, that: Intervals): Intervals; }\n```\n\n----------------------------------------\n\nTITLE: Declaring Die Function in STM Module TypeScript\nDESCRIPTION: The `die` function allows the transactional effect to fail with a specified defect in the STM module. There are no additional dependencies outside the Effect library itself. The function takes a single parameter `defect` of any type, and it returns an STM effect that never succeeds. It is available since version 2.0.0.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/STM-die.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const die: (defect: unknown) => STM<never>\n```\n\n----------------------------------------\n\nTITLE: Checking Non-Empty Intervals in TypeScript\nDESCRIPTION: The isNonEmpty function determines whether a given Interval is non-empty. It takes an Interval as input and returns a boolean value. This function is part of the ScheduleInterval module in the Effect package.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/ScheduleInterval-isNonEmpty.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const isNonEmpty: (self: Interval) => boolean\n```\n\n----------------------------------------\n\nTITLE: Using Context.empty Function in TypeScript\nDESCRIPTION: Demonstrates how to use the Context.empty function to create an empty Context and verify it using the isContext function.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Context-empty.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { Context } from \"effect\"\n\nassert.strictEqual(Context.isContext(Context.empty()), true)\n```\n\n----------------------------------------\n\nTITLE: Checking if a Doc is a Text type in TypeScript\nDESCRIPTION: This function determines whether the provided Doc is a Text, returning a boolean value. It acts as a type guard that narrows the type to Text<A> when it returns true.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Doc-isText.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const isText: <A>(self: Doc<A>) => self is Text<A>\n```\n\n----------------------------------------\n\nTITLE: Defining pipeToOrFail Function Signature in TypeScript\nDESCRIPTION: Declares the signature of the pipeToOrFail function, which returns a new channel that pipes the output of one channel into another while preserving failures. It supports both curried and uncurried versions of the function.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Channel-pipeToOrFail.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const pipeToOrFail: { <OutElem2, OutElem, OutErr2, OutDone2, OutDone, Env2>(that: Channel<OutElem2, OutElem, OutErr2, never, OutDone2, OutDone, Env2>): <InElem, OutErr, InErr, InDone, Env>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>) => Channel<OutElem2, InElem, OutErr2 | OutErr, InErr, OutDone2, InDone, Env2 | Env>; <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutElem2, OutErr2, OutDone2, Env2>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>, that: Channel<OutElem2, OutElem, OutErr2, never, OutDone2, OutDone, Env2>): Channel<OutElem2, InElem, OutErr | OutErr2, InErr, OutDone2, InDone, Env | Env2>; }\n```\n\n----------------------------------------\n\nTITLE: Implementing zipLeft Operation for Chainable Type Class\nDESCRIPTION: Type definition for the zipLeft operation that sequences effects while preserving the value of the first effect. It takes two effects and returns a new effect that combines their requirements and error types but maintains the value type of the first effect.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Chainable-zipLeft.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const zipLeft: <F extends TypeLambda>(F: Chainable<F>) => { \n  <R2, O2, E2, _>(that: Kind<F, R2, O2, E2, _>): \n    <R1, O1, E1, A>(self: Kind<F, R1, O1, E1, A>) => Kind<F, R1 & R2, O2 | O1, E2 | E1, A>; \n  <R1, O1, E1, A, R2, O2, E2, _>(self: Kind<F, R1, O1, E1, A>, that: Kind<F, R2, O2, E2, _>): \n    Kind<F, R1 & R2, O1 | O2, E1 | E2, A>; \n}\n```\n\n----------------------------------------\n\nTITLE: Array.bindTo Function Signature in TypeScript\nDESCRIPTION: The TypeScript signature of the bindTo function in the Array module. This function is used to start the binding process in a Do simulation, allowing variable naming and type inference.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Array-bindTo.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const bindTo: { <N extends string>(tag: N): <A>(self: ReadonlyArray<A>) => Array<{ [K in N]: A; }>; <A, N extends string>(self: ReadonlyArray<A>, tag: N): Array<{ [K in N]: A; }>; }\n```\n\n----------------------------------------\n\nTITLE: Trie.map Function Signature in TypeScript\nDESCRIPTION: Provides the TypeScript signature for the Trie.map function. It shows two overloads: one for curried usage and another for direct application. The function maps over entries of a Trie, transforming values based on the provided function.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Trie-map.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const map: { <A, V>(f: (value: V, key: string) => A): (self: Trie<V>) => Trie<A>; <V, A>(self: Trie<V>, f: (value: V, key: string) => A): Trie<A>; }\n```\n\n----------------------------------------\n\nTITLE: Declaring takeFirst Function in Typescript\nDESCRIPTION: This code snippet defines the `takeFirst` function within the `TSet` module. It takes a partial function `pf` and a transactional set `self` as input. The partial function transforms elements of type `A` to an optional `B`. The function returns an STM effect that produces a value of type `B`, representing the first matching element or retries until such an element is available.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TSet-takeFirst.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const takeFirst: { <A, B>(pf: (a: A) => Option.Option<B>): (self: TSet<A>) => STM.STM<B>; <A, B>(self: TSet<A>, pf: (a: A) => Option.Option<B>): STM.STM<B>; }\n```\n\n----------------------------------------\n\nTITLE: Creating Bounded TPubSub with Dropping Strategy in TypeScript\nDESCRIPTION: Creates a bounded TPubSub that drops new messages when the queue reaches capacity. The function takes a requested capacity parameter and returns an STM effect that produces a TPubSub instance.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TPubSub-dropping.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const dropping: <A>(requestedCapacity: number) => STM.STM<TPubSub<A>>\n```\n\n----------------------------------------\n\nTITLE: Creating Cookies with Error Handling in TypeScript\nDESCRIPTION: Function signature for creating a new cookie with optional configuration. Returns Either type containing successful Cookie creation or CookiesError. Takes name, value, and optional cookie options as parameters.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Cookies-makeCookie.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const makeCookie: (name: string, value: string, options?: Cookie[\"options\"] | undefined) => Either.Either<Cookie, CookiesError>\n```\n\n----------------------------------------\n\nTITLE: Defining Cause.reduce Function Signature in TypeScript\nDESCRIPTION: This code snippet defines the signature of the Cause.reduce function. It is a polymorphic function that takes an initial value, a combining function, and a Cause, and reduces the Cause to a single value.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Cause-reduce.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const reduce: {\n  <Z, E>(zero: Z, pf: (accumulator: Z, cause: Cause<E>) => Option.Option<Z>): (self: Cause<E>) => Z;\n  <Z, E>(self: Cause<E>, zero: Z, pf: (accumulator: Z, cause: Cause<E>) => Option.Option<Z>): Z;\n}\n```\n\n----------------------------------------\n\nTITLE: Transforming Sink Errors with mapError in TypeScript\nDESCRIPTION: The mapError function transforms errors emitted by a sink using a provided function f. It supports two calling styles: either passing the transformation function first (curried), or passing the sink first followed by the transformation function.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Sink-mapError.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const mapError: { <E, E2>(f: (error: E) => E2): <A, In, L, R>(self: Sink<A, In, L, E, R>) => Sink<A, In, L, E2, R>; <A, In, L, E, R, E2>(self: Sink<A, In, L, E, R>, f: (error: E) => E2): Sink<A, In, L, E2, R>; }\n```\n\n----------------------------------------\n\nTITLE: Type Signature for Array.differenceWith in TypeScript\nDESCRIPTION: The type signature for the differenceWith function, which takes an equivalence function and returns a curried function that can be applied to two iterables to compute their difference, or to one iterable at a time.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Array-differenceWith.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const differenceWith: <A>(isEquivalent: (self: A, that: A) => boolean) => { (that: Iterable<A>): (self: Iterable<A>) => Array<A>; (self: Iterable<A>, that: Iterable<A>): Array<A>; }\n```\n\n----------------------------------------\n\nTITLE: TypeScript Stream CrossRight Type Definition\nDESCRIPTION: Defines a complex stream composition function that generates a new stream by crossing left and right streams, preserving right stream elements. Supports curried and direct function signatures with type-safe generic parameters.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-crossRight.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const crossRight: { \n  <AR, ER, RR>(right: Stream<AR, ER, RR>): \n    <AL, EL, RL>(left: Stream<AL, EL, RL>) => Stream<AR, EL | ER, RL | RR>; \n  <AL, EL, RL, AR, ER, RR>(left: Stream<AL, EL, RL>, right: Stream<AR, ER, RR>): \n    Stream<AR, EL | ER, RL | RR>; \n}\n```\n\n----------------------------------------\n\nTITLE: Schedule.fixed Definition\nDESCRIPTION: Defines a function `fixed` that creates a schedule which recurs at a fixed interval. The `interval` parameter specifies the duration between executions.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Schedule-fixed.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const fixed: (interval: Duration.DurationInput) => Schedule<number>\n```\n\n----------------------------------------\n\nTITLE: Effect.zipLeft Function Signature in TypeScript\nDESCRIPTION: The TypeScript function signature for Effect.zipLeft, showing its type parameters and overloaded versions that support both pipe-first and traditional function call patterns.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-zipLeft.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const zipLeft: { <A2, E2, R2>(that: Effect<A2, E2, R2>, options?: { readonly concurrent?: boolean | undefined; readonly batching?: boolean | \"inherit\" | undefined; readonly concurrentFinalizers?: boolean | undefined; } | undefined): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E2 | E, R2 | R>; <A, E, R, A2, E2, R2>(self: Effect<A, E, R>, that: Effect<A2, E2, R2>, options?: { readonly concurrent?: boolean | undefined; readonly batching?: boolean | \"inherit\" | undefined; readonly concurrentFinalizers?: boolean | undefined; } | undefined): Effect<A, E | E2, R | R2>; }\n```\n\n----------------------------------------\n\nTITLE: Defining the Args Interface in TypeScript\nDESCRIPTION: Defines the Args interface which represents arguments that can be passed to a command-line application. It extends Args.Variance<A> and Pipeable interfaces.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Args-Args.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface Args<A> extends Args.Variance<A>, Pipeable {}\n```\n\n----------------------------------------\n\nTITLE: MutableList pop in Effect (TypeScript)\nDESCRIPTION: Removes the last value from the mutable list and returns it. If the list is empty, it returns `undefined`. It requires a `MutableList<A>` as input and returns a value of type `A | undefined`.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/MutableList-pop.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const pop: <A>(self: MutableList<A>) => A | undefined\n```\n\n----------------------------------------\n\nTITLE: Creating Auto-Refreshing Resources with Resource.auto in TypeScript\nDESCRIPTION: This function creates a Resource value that is automatically refreshed according to a specified scheduling policy. It requires an acquisition effect and a schedule for refreshing. Note that error retrying is not handled automatically and must be implemented separately.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Resource-auto.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const auto: <A, E, R, Out, R2>(acquire: Effect.Effect<A, E, R>, policy: Schedule.Schedule<Out, unknown, R2>) => Effect.Effect<Resource<A, E>, never, R | R2 | Scope.Scope>\n```\n\n----------------------------------------\n\nTITLE: Annotating with Effect in TypeScript\nDESCRIPTION: This TypeScript code snippet declares the `annotate` function, which takes a `TestAnnotation` key and a value of type `A` as arguments. It returns an `Effect` that, when executed, appends the annotation to the annotation map. The function accesses an `Annotations` instance in the context.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TestServices-annotate.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const annotate: <A>(key: TestAnnotation.TestAnnotation<A>, value: A) => Effect.Effect<void>\n```\n\n----------------------------------------\n\nTITLE: Creating Exponential Metric Boundaries in TypeScript\nDESCRIPTION: Helper method that generates histogram bucket boundaries with exponentially increasing values. Takes configuration options including start value, growth factor, and number of buckets to create.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/MetricBoundaries-exponential.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const exponential: (options: { readonly start: number; readonly factor: number; readonly count: number; }) => MetricBoundaries\n```\n\n----------------------------------------\n\nTITLE: Implementing Boolean NAND Operation in TypeScript\nDESCRIPTION: Demonstrates the usage of the 'nand' function from the 'effect/Boolean' module which performs a logical NAND operation. The function returns true if at least one of the inputs is false.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Boolean-nand.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { nand } from \"effect/Boolean\"\n\nassert.deepStrictEqual(nand(true, true), false)\nassert.deepStrictEqual(nand(true, false), true)\nassert.deepStrictEqual(nand(false, true), true)\nassert.deepStrictEqual(nand(false, false), true)\n```\n\n----------------------------------------\n\nTITLE: Removing first element from MutableList in TypeScript\nDESCRIPTION: The shift method is designed to remove the first element from a MutableList and return it, or undefined if the list is empty. It provides a way to efficiently manage list elements, and is a common operation in list manipulation. The method utilizes TypeScript generics to ensure type safety.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/MutableList-shift.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const shift: <A>(self: MutableList<A>) => A | undefined\n```\n\n----------------------------------------\n\nTITLE: Creating Zoned DateTime from String - TypeScript\nDESCRIPTION: Function signature for creating a DateTime.Zoned object from a string input. The function expects a string in the format 'YYYY-MM-DDTHH:mm:ss.sss+HH:MM[Time/Zone]' and returns an Option containing the parsed DateTime.Zoned object if successful.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/DateTime-makeZonedFromString.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const makeZonedFromString: (input: string) => Option.Option<Zoned>\n```\n\n----------------------------------------\n\nTITLE: Declaring isNesting function in TypeScript\nDESCRIPTION: This code snippet declares the isNesting function, which takes a Doc<A> as input and returns a boolean indicating whether it is of type Nesting<A>. The function uses a type predicate to narrow the type if true.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Doc-isNesting.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const isNesting: <A>(self: Doc<A>) => self is Nesting<A>\n```\n\n----------------------------------------\n\nTITLE: Stream Changes TypeScript Type Signature\nDESCRIPTION: Provides the type declaration for the Stream.changes method, showing its generic type parameters and return type structure for stream transformation\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-changes.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const changes: <A, E, R>(self: Stream<A, E, R>) => Stream<A, E, R>\n```\n\n----------------------------------------\n\nTITLE: Stream.accumulateChunks Method Implementation in TypeScript\nDESCRIPTION: This function re-chunks the elements of a stream by accumulating each underlying chunk. It takes a Stream of type A with error type E and runtime R, and returns a stream of the same types after applying the chunking operation.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-accumulateChunks.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const accumulateChunks: <A, E, R>(self: Stream<A, E, R>) => Stream<A, E, R>\n```\n\n----------------------------------------\n\nTITLE: Number.sign Signature\nDESCRIPTION: This code snippet displays the TypeScript signature of the `sign` function from the `effect/Number` module. The `sign` function takes a number as input and returns a value of type `Ordering`, indicating the sign of the number. `Ordering` is likely an enum or type representing the possible orderings: less than, equal to, or greater than.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Number-sign.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const sign: (n: number) => Ordering\n```\n\n----------------------------------------\n\nTITLE: Returning Iterator for Less Than Comparison - TypeScript\nDESCRIPTION: This snippet declares a function named 'lessThan' which is designed to return an iterator over entries in a RedBlackTree that have keys less than a specified key. It supports both a single argument usage, where the self parameter is inferred, and a two-argument usage for explicit clarity. This functionality aids in efficiently accessing subsets of data without full tree traversal.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/RedBlackTree-lessThan.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const lessThan: { <K>(key: K): <V>(self: RedBlackTree<K, V>) => Iterable<[K, V]>; <K, V>(self: RedBlackTree<K, V>, key: K): Iterable<[K, V]>; }\n```\n\n----------------------------------------\n\nTITLE: Implementing HashMap unsafeGet Operation in TypeScript\nDESCRIPTION: Function signature for unsafely retrieving a value from a HashMap using a key. The function supports both curried and uncurried calling styles. Note that this is an unsafe operation that may throw if the key doesn't exist.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/HashMap-unsafeGet.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const unsafeGet: { <K1>(key: K1): <K, V>(self: HashMap<K, V>) => V; <K, V, K1>(self: HashMap<K, V>, key: K1): V; }\n```\n\n----------------------------------------\n\nTITLE: STM.orDie Function Signature\nDESCRIPTION: This TypeScript code snippet defines the signature of the `STM.orDie` function.  It takes an `STM` effect that can potentially fail (with error type `E`) and transforms it into an `STM` effect that never fails (error type `never`), causing the fiber to terminate instead. The `STM` effect also has a success type `A` and environment `R`.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/STM-orDie.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const orDie: <A, E, R>(self: STM<A, E, R>) => STM<A, never, R>\n```\n\n----------------------------------------\n\nTITLE: Adding Fixed Offset Time Zone to DateTime in TypeScript\nDESCRIPTION: This example demonstrates how to set a time zone offset to a DateTime object. The offset is specified in milliseconds, with this example using a 3-hour offset (3 * 60 * 60 * 1000 ms).\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/DateTime-setZoneOffset.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { DateTime, Effect } from \"effect\"\n\nEffect.gen(function* () {\n  const now = yield* DateTime.now\n\n  // set the offset time zone in milliseconds\n  const zoned: DateTime.Zoned = DateTime.setZoneOffset(now, 3 * 60 * 60 * 1000)\n})\n```\n\n----------------------------------------\n\nTITLE: TArray reduceOption Signature in Typescript\nDESCRIPTION: This snippet shows the Typescript signature of the `reduceOption` function in the Effect `TArray` module. The function atomically reduces a TArray using a binary operator `f` and returns an `Option` within an `STM` transaction. There are two overloaded signatures for ease of use.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TArray-reduceOption.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const reduceOption: { <A>(f: (x: A, y: A) => A): (self: TArray<A>) => STM.STM<Option.Option<A>>; <A>(self: TArray<A>, f: (x: A, y: A) => A): STM.STM<Option.Option<A>>; }\n```\n\n----------------------------------------\n\nTITLE: Defining URL Schema in TypeScript with Effect\nDESCRIPTION: Declares a schema class for URL objects, providing type-safe URL representation in the Effect ecosystem. Used for schema validation and type inference related to URL types.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Schema-URLFromSelf.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare class URLFromSelf\n```\n\n----------------------------------------\n\nTITLE: Querying Record Size in Effect TS - TypeScript\nDESCRIPTION: This snippet demonstrates the use of the 'size' function to return the count of key/value pairs in a record. The code uses the assert module for testing the functionality. The size function takes a ReadonlyRecord as input and outputs the number of entries in that record.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Record-size.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { size } from \"effect/Record\";\n\nassert.deepStrictEqual(size({ a: \"a\", b: 1, c: true }), 3);\n```\n\n----------------------------------------\n\nTITLE: Effect.runSyncExit Type Signature\nDESCRIPTION: TypeScript type signature for the runSyncExit function showing its parameter and return types.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-runSyncExit.md#2025-04-11_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const runSyncExit: <A, E>(effect: Effect<A, E>) => Exit.Exit<A, E>\n```\n\n----------------------------------------\n\nTITLE: Using BigDecimal.between for Range Comparison in TypeScript\nDESCRIPTION: Demonstrates how to use BigDecimal.between to check if a number falls within an inclusive range. The function accepts minimum and maximum BigDecimal values and returns a boolean indicating if the tested value is within that range.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/BigDecimal-between.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { BigDecimal } from \"effect\"\n\nconst between = BigDecimal.between({\n  minimum: BigDecimal.unsafeFromString(\"1\"),\n  maximum: BigDecimal.unsafeFromString(\"5\") }\n)\n\nassert.deepStrictEqual(between(BigDecimal.unsafeFromString(\"3\")), true)\nassert.deepStrictEqual(between(BigDecimal.unsafeFromString(\"0\")), false)\nassert.deepStrictEqual(between(BigDecimal.unsafeFromString(\"6\")), false)\n```\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const between: { (options: { minimum: BigDecimal; maximum: BigDecimal; }): (self: BigDecimal) => boolean; (self: BigDecimal, options: { minimum: BigDecimal; maximum: BigDecimal; }): boolean; }\n```\n\n----------------------------------------\n\nTITLE: HashSet.size Method Type Signature in TypeScript\nDESCRIPTION: Type definition for the HashSet.size method, which takes a HashSet of any type and returns a number representing the count of unique values in the set.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/HashSet-size.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const size: <A>(self: HashSet<A>) => number\n```\n\n----------------------------------------\n\nTITLE: Executing SQL Query with Schema Validation and First Result Extraction\nDESCRIPTION: The findOne function executes a SQL query with both request and result schema validation. It takes request data, validates it against the request schema, executes the query, and validates the first result against the result schema, returning it as an Option type.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/SqlSchema-findOne.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const findOne: <IR, II, IA, AR, AI, A, R, E>(options: { readonly Request: Schema.Schema<IA, II, IR>; readonly Result: Schema.Schema<A, AI, AR>; readonly execute: (request: II) => Effect.Effect<ReadonlyArray<unknown>, E, R>; }) => (request: IA) => Effect.Effect<Option.Option<A>, E | ParseError, R | IR | AR>\n```\n\n----------------------------------------\n\nTITLE: Capturing Metric Snapshots in Effect-TS\nDESCRIPTION: Function signature for capturing a snapshot of all metrics recorded by the application. Returns an Effect containing an array of untyped MetricPair values with no requirements and no error type.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Metric-snapshot.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const snapshot: Effect.Effect<Array<MetricPair.MetricPair.Untyped>, never, never>\n```\n\n----------------------------------------\n\nTITLE: Declaring RedBlackTree.atReversed Function in TypeScript\nDESCRIPTION: Function signature for atReversed method that returns an iterator pointing to an element at a specific index in a Red-Black Tree. The iterator traverses elements in reverse order. Takes an index and a RedBlackTree as parameters and returns an Iterable of key-value pairs.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/RedBlackTree-atReversed.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const atReversed: { (index: number): <K, V>(self: RedBlackTree<K, V>) => Iterable<[K, V]>; <K, V>(self: RedBlackTree<K, V>, index: number): Iterable<[K, V]>; }\n```\n\n----------------------------------------\n\nTITLE: Converting ConfigProvider Property Names to Uppercase in TypeScript\nDESCRIPTION: A function that creates a new ConfigProvider instance with all property names converted to uppercase. This is useful for adapting camelCase property names to match different configuration naming conventions.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/ConfigProvider-upperCase.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const upperCase: (self: ConfigProvider) => ConfigProvider\n```\n\n----------------------------------------\n\nTITLE: Converting Channel to Sink in TypeScript\nDESCRIPTION: This function converts a Channel to a Sink. It takes a Channel with specific generic types and returns a Sink with corresponding types. The function is part of the Channel module in the effect package.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Channel-toSink.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const toSink: <OutElem, InElem, OutErr, InErr, OutDone, Env>(self: Channel<Chunk.Chunk<OutElem>, Chunk.Chunk<InElem>, OutErr, InErr, OutDone, unknown, Env>) => Sink.Sink<OutDone, InElem, OutElem, OutErr, Env>\n```\n\n----------------------------------------\n\nTITLE: Declaring Uppercase Validation Function in TypeScript\nDESCRIPTION: This snippet declares a TypeScript function `uppercased` that takes optional filtering annotations and returns a function used to validate if a string is uppercase. It leverages generics to ensure type safety with various schema types.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Schema-uppercased.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const uppercased: <S extends Schema.Any>(annotations?: Annotations.Filter<Schema.Type<S>>) => <A extends string>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>) => filter<S>\n```\n\n----------------------------------------\n\nTITLE: Implementing Cursor Position Save Operation in TypeScript\nDESCRIPTION: Defines a constant for saving the cursor position along with shift state and formatting attributes in ANSI-compatible terminals. This operation allows for storing the current cursor state which can be restored later.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Ansi-cursorSavePosition.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const cursorSavePosition: Ansi\n```\n\n----------------------------------------\n\nTITLE: RedBlackTree.lessThanReversed in TypeScript\nDESCRIPTION: Describes the `lessThanReversed` function in the `RedBlackTree` module, which returns an iterator for traversing entries in reverse order with keys less than the specified key. The function can be called with the key first, returning a curried function that accepts the `RedBlackTree`, or with both the `RedBlackTree` and the key.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/RedBlackTree-lessThanReversed.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const lessThanReversed: { <K>(key: K): <V>(self: RedBlackTree<K, V>) => Iterable<[K, V]>; <K, V>(self: RedBlackTree<K, V>, key: K): Iterable<[K, V]>; }\n```\n\n----------------------------------------\n\nTITLE: Declaring Channel.mapError Function in TypeScript\nDESCRIPTION: TypeScript declaration for mapError function that transforms the error type of a Channel. The function takes an error mapping function and returns a new Channel with transformed error type while preserving other type parameters.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Channel-mapError.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const mapError: { <OutErr, OutErr2>(f: (err: OutErr) => OutErr2): <OutElem, InElem, InErr, OutDone, InDone, Env>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>) => Channel<OutElem, InElem, OutErr2, InErr, OutDone, InDone, Env>; <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutErr2>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>, f: (err: OutErr) => OutErr2): Channel<OutElem, InElem, OutErr2, InErr, OutDone, InDone, Env>; }\n```\n\n----------------------------------------\n\nTITLE: Defining mapInput Function for Metric Transformation in TypeScript\nDESCRIPTION: This code snippet defines the mapInput function, which returns a new metric that accepts updates of a specified new type. The new type must be transformable to the input type of the original metric. The function is overloaded to allow for different argument orders.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Metric-mapInput.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const mapInput: { <In, In2>(f: (input: In2) => In): <Type, Out>(self: Metric<Type, In, Out>) => Metric<Type, In2, Out>; <Type, In, Out, In2>(self: Metric<Type, In, Out>, f: (input: In2) => In): Metric<Type, In2, Out>; }\n```\n\n----------------------------------------\n\nTITLE: Retrieving First Element from List in TypeScript\nDESCRIPTION: A function that returns the first element of a List<A>. This is an unsafe operation as it does not handle empty lists. Operates on the Effect library's List data structure.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/List-unsafeHead.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const unsafeHead: <A>(self: List<A>) => A\n```\n\n----------------------------------------\n\nTITLE: Function Signature for encloseSep in TypeScript\nDESCRIPTION: The type signature for the `encloseSep` function, showing its overloaded variants. It can be called with either the enclosures and separator first followed by documents, or with documents first followed by enclosures and separator.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Doc-encloseSep.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const encloseSep: { <A, B, C>(left: Doc<A>, right: Doc<B>, sep: Doc<C>): <D>(docs: Iterable<Doc<D>>) => Doc<A | B | C | D>; <A, B, C, D>(docs: Iterable<Doc<D>>, left: Doc<A>, right: Doc<B>, sep: Doc<C>): Doc<A | B | C | D>; }\n```\n\n----------------------------------------\n\nTITLE: Option.asVoid signature in TypeScript\nDESCRIPTION: Describes the type signature of the `asVoid` function within the `Option` module of the Effect library.  The function takes an `Option` of any type and returns an `Option<void>`. It effectively discards the value contained within the `Some` variant, replacing it with `void` while leaving `None` variants untouched.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Option-asVoid.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const asVoid: <_>(self: Option<_>) => Option<void>\n```\n\n----------------------------------------\n\nTITLE: Creating a Sink with Leftovers in TypeScript\nDESCRIPTION: The `leftover` function creates a sink that does not consume any input but provides the given chunk as its leftovers. This is useful for processing data streams where you need to pass unconsumed data to downstream operations.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Sink-leftover.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const leftover: <L>(chunk: Chunk.Chunk<L>) => Sink<void, unknown, L>\n```\n\n----------------------------------------\n\nTITLE: Type Signature for Array.forEach Function in TypeScript\nDESCRIPTION: Shows the TypeScript type signature of the Array.forEach function. It supports both curried and non-curried forms, with the callback receiving both the array element and its index position.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Array-forEach.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const forEach: { <A>(f: (a: A, i: number) => void): (self: Iterable<A>) => void; <A>(self: Iterable<A>, f: (a: A, i: number) => void): void; }\n```\n\n----------------------------------------\n\nTITLE: TMap.has: Checking Key Existence in TypeScript with STM\nDESCRIPTION: The `TMap.has` function tests whether a given key exists within a transactional map (TMap) using Software Transactional Memory (STM). It takes either the key and TMap as separate arguments or curried with the key first, and returns an STM action that resolves to a boolean indicating the presence of the key.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TMap-has.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const has: { <K>(key: K): <V>(self: TMap<K, V>) => STM.STM<boolean>; <K, V>(self: TMap<K, V>, key: K): STM.STM<boolean>; }\n```\n\n----------------------------------------\n\nTITLE: Using String.takeRight in TypeScript with Effect Library\nDESCRIPTION: Example demonstrating how to use the takeRight function to extract characters from the end of a string. Returns the specified number of characters from the string's end, with special handling for edge cases like large numbers and floats.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/String-takeRight.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { String } from \"effect\"\n\nassert.deepStrictEqual(String.takeRight(\"Hello World\", 5), \"World\")\n```\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const takeRight: { (n: number): (self: string) => string; (self: string, n: number): string; }\n```\n\n----------------------------------------\n\nTITLE: Data.Class Constructor Type Signature in TypeScript\nDESCRIPTION: The type signature for the Data.Class constructor, which takes a record of properties and returns a readonly version of those properties. The constructor uses conditional types to make the argument optional if the record is empty.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Data-Class.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const Class: new <A extends Record<string, any> = {}>(args: Types.Equals<A, {}> extends true ? void : { readonly [P in keyof A]: A[P]; }) => Readonly<A>\n```\n\n----------------------------------------\n\nTITLE: Defining YieldableError Interface in TypeScript\nDESCRIPTION: Defines the YieldableError interface, which extends Pipeable, Inspectable, and Readonly<Error>. It includes type identifiers for Effect, Stream, Sink, and Channel, as well as an iterator method for generating Effect instances.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Cause-YieldableError.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport interface YieldableError extends Pipeable, Inspectable, Readonly<Error> {\n  readonly [Effect.EffectTypeId]: Effect.Effect.VarianceStruct<never, this, never>\n  readonly [Stream.StreamTypeId]: Stream.Stream.VarianceStruct<never, this, never>\n  readonly [Sink.SinkTypeId]: Sink.Sink.VarianceStruct<never, unknown, never, this, never>\n  readonly [Channel.ChannelTypeId]: Channel.Channel.VarianceStruct<never, unknown, this, unknown, never, unknown, never>\n  [Symbol.iterator](): Effect.EffectGenerator<Effect.Effect<never, this, never>>\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Integer Ranges with Chunk.range in TypeScript\nDESCRIPTION: Creates a non-empty `Chunk` containing a range of integers, including both the start and end values. Returns a `NonEmptyChunk<number>` that guarantees at least one element.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Chunk-range.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const range: (start: number, end: number) => NonEmptyChunk<number>\n```\n\n----------------------------------------\n\nTITLE: Mapping Schedule Input and Output with mapBoth in Effect\nDESCRIPTION: The `mapBoth` function transforms a schedule's input and output types. It takes an object with `onInput` and `onOutput` functions, which define the transformations. `onInput` transforms the new input type `In2` to the original input type `In`, while `onOutput` transforms the original output type `Out` to the new output type `Out2`. The function returns a new schedule with the transformed types.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Schedule-mapBoth.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const mapBoth: { <In2, In, Out, Out2>(options: { readonly onInput: (in2: In2) => In; readonly onOutput: (out: Out) => Out2; }): <R>(self: Schedule<Out, In, R>) => Schedule<Out2, In2, R>; <Out, In, R, In2, Out2>(self: Schedule<Out, In, R>, options: { readonly onInput: (in2: In2) => In; readonly onOutput: (out: Out) => Out2; }): Schedule<Out2, In2, R>; }\n```\n\n----------------------------------------\n\nTITLE: Cron.parse Function Signature in TypeScript\nDESCRIPTION: Type definition for the Cron.parse function that takes a cron expression string and optional timezone parameter. It returns an Either type containing either a successfully parsed Cron object or a ParseError.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Cron-parse.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const parse: (cron: string, tz?: DateTime.TimeZone | string) => Either.Either<Cron, ParseError>\n```\n\n----------------------------------------\n\nTITLE: Record.pop Function Signature in Effect\nDESCRIPTION: Shows the TypeScript signature of the `Record.pop` function in the Effect library. It details the generic types used for the key (K) and value (A), and how it returns an `Option` of a tuple containing the value and the updated record with the key excluded.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Record-pop.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const pop: { <K extends string | symbol, X extends K>(key: X): <A>(self: ReadonlyRecord<K, A>) => Option.Option<[A, Record<Exclude<K, X>, A>]>; <K extends string | symbol, A, X extends K>(self: ReadonlyRecord<K, A>, key: X): Option.Option<[A, Record<Exclude<K, X>, A>]>; }\n```\n\n----------------------------------------\n\nTITLE: Enhancing Schedules with effect-io-ai - TypeScript\nDESCRIPTION: The `onDecision` function returns a modified schedule that executes a specified effect each time a scheduling decision is made. The effect function takes the current schedule output and the decision as parameters, allowing for enhanced logic like logging. There are no explicit dependencies, though it assumes familiarity with the Effect-TS framework. It does not limit inputs and outputs as it wraps around existing schedules and enhances them without modifying their core behavior.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Schedule-onDecision.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const onDecision: { <Out, X, R2>(f: (out: Out, decision: ScheduleDecision.ScheduleDecision) => Effect.Effect<X, never, R2>): <In, R>(self: Schedule<Out, In, R>) => Schedule<Out, In, R2 | R>; <Out, In, R, X, R2>(self: Schedule<Out, In, R>, f: (out: Out, decision: ScheduleDecision.ScheduleDecision) => Effect.Effect<X, never, R2>): Schedule<Out, In, R | R2>; }\n```\n\n----------------------------------------\n\nTITLE: Using Array.unappend to Separate an Array's Last Element in TypeScript\nDESCRIPTION: This example demonstrates how to use the Array.unappend function to split a non-empty array into a tuple containing the array without its last element and the last element itself.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Array-unappend.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Array } from \"effect\";\n\nconst result = Array.unappend([1, 2, 3, 4])\nconsole.log(result) // [[1, 2, 3], 4]\n```\n\n----------------------------------------\n\nTITLE: Array.matchLeft Type Signature in TypeScript\nDESCRIPTION: Shows the type declaration for the Array.matchLeft function. It supports both curried and uncurried calling styles, taking options with handlers for empty and non-empty array cases.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Array-matchLeft.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const matchLeft: { <B, A, C = B>(options: { readonly onEmpty: LazyArg<B>; readonly onNonEmpty: (head: A, tail: Array<A>) => C; }): (self: ReadonlyArray<A>) => B | C; <A, B, C = B>(self: ReadonlyArray<A>, options: { readonly onEmpty: LazyArg<B>; readonly onNonEmpty: (head: A, tail: Array<A>) => C; }): B | C; }\n```\n\n----------------------------------------\n\nTITLE: Retrieving Array Length in TypeScript\nDESCRIPTION: This function returns the number of elements in a ReadonlyArray. It accepts a ReadonlyArray of any type and returns a number representing the array's length.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Array-length.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const length: <A>(self: ReadonlyArray<A>) => number\n```\n\n----------------------------------------\n\nTITLE: STM.reduceRight Signature\nDESCRIPTION: The `STM.reduceRight` function folds an `Iterable<A>` using an effectual function `f`, working sequentially from right to left. It takes an initial value `zero` and a function `f` that combines the accumulator and the current element into a new `STM` action.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/STM-reduceRight.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const reduceRight: { <S, A, R, E>(zero: S, f: (s: S, a: A) => STM<S, E, R>): (iterable: Iterable<A>) => STM<S, E, R>; <S, A, R, E>(iterable: Iterable<A>, zero: S, f: (s: S, a: A) => STM<S, E, R>): STM<S, E, R>; }\n```\n\n----------------------------------------\n\nTITLE: Context.Reference TypeScript Signature\nDESCRIPTION: The type signature for the Context.Reference function in Effect.ts, showing the expected parameters and return types. It demonstrates how to create a reference class with type parameters for Self, Id, and Service.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Context-Reference.md#2025-04-11_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const Reference: <Self>() => <const Id extends string, Service>(id: Id, options: { readonly defaultValue: () => Service; }) => ReferenceClass<Self, Id, Service>\n```\n\n----------------------------------------\n\nTITLE: Buffering Elements in Stream\nDESCRIPTION: This code snippet demonstrates how to use the `Stream.buffer` combinator to allow a faster producer to operate independently of a slower consumer by buffering elements. It logs the values before and after buffering and illustrates the use of scheduling for spaced execution.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-buffer.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Console, Effect, Schedule, Stream } from \"effect\"\n\nconst stream = Stream.range(1, 10).pipe(\n  Stream.tap((n) => Console.log(`before buffering: ${n}`)),\n  Stream.buffer({ capacity: 4 }),\n  Stream.tap((n) => Console.log(`after buffering: ${n}`)),\n  Stream.schedule(Schedule.spaced(\"5 seconds\"))\n)\n\nEffect.runPromise(Stream.runCollect(stream)).then(console.log)\n// before buffering: 1\n// before buffering: 2\n// before buffering: 3\n// before buffering: 4\n// before buffering: 5\n// before buffering: 6\n// after buffering: 1\n// after buffering: 2\n// before buffering: 7\n// after buffering: 3\n// before buffering: 8\n// after buffering: 4\n// before buffering: 9\n// after buffering: 5\n// before buffering: 10\n// ...\n```\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const buffer: { (options: { readonly capacity: \"unbounded\"; } | { readonly capacity: number; readonly strategy?: \"dropping\" | \"sliding\" | \"suspend\" | undefined; }): <A, E, R>(self: Stream<A, E, R>) => Stream<A, E, R>; <A, E, R>(self: Stream<A, E, R>, options: { readonly capacity: \"unbounded\"; } | { readonly capacity: number; readonly strategy?: \"dropping\" | \"sliding\" | \"suspend\" | undefined; }): Stream<A, E, R>; }\n```\n\n----------------------------------------\n\nTITLE: Implementing MergeStrategy Match Function in TypeScript\nDESCRIPTION: Defines a function that folds a MergeStrategy into a value of type A. Provides both curried and uncurried versions of the function, accepting options for handling backpressure and buffer sliding cases.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/MergeStrategy-match.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const match: { \n  <A>(options: { readonly onBackPressure: () => A; readonly onBufferSliding: () => A; }): (self: MergeStrategy) => A; \n  <A>(self: MergeStrategy, options: { readonly onBackPressure: () => A; readonly onBufferSliding: () => A; }): A; \n}\n```\n\n----------------------------------------\n\nTITLE: Implementing List Prepend Operation in TypeScript\nDESCRIPTION: Function declaration for prepending an element to the beginning of a list. The function is overloaded to support both curried and non-curried usage patterns, returning a Cons type that represents the new list with the prepended element.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/List-prepend.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const prepend: { <B>(element: B): <A>(self: List<A>) => Cons<A | B>; <A, B>(self: List<A>, element: B): Cons<A | B>; }\n```\n\n----------------------------------------\n\nTITLE: Declaring Transactional Effect Failure\nDESCRIPTION: The `dieSync` function signature declares that it takes a lazily evaluated argument and returns an STM that signifies a failure. This is used to handle errors gracefully within transactional contexts.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/STM-dieSync.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const dieSync: (evaluate: LazyArg<unknown>) => STM<never>\n```\n\n----------------------------------------\n\nTITLE: Implementing Array.init Function in TypeScript\nDESCRIPTION: A function that returns all elements except the last one from an Iterable, creating a new Array. If the Iterable is empty, it returns None.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Array-init.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const init: <A>(self: Iterable<A>) => Option.Option<Array<A>>\n```\n\n----------------------------------------\n\nTITLE: Defining orElse Function for Channel Composition in TypeScript\nDESCRIPTION: Declares the orElse function for Channel composition. It creates a new channel that performs operations of the first channel until failure, then switches to the fallback channel. The function is overloaded to handle different parameter orders.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Channel-orElse.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const orElse: { <OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>(that: LazyArg<Channel<OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>>): <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>) => Channel<OutElem1 | OutElem, InElem & InElem1, OutErr1, InErr & InErr1, OutDone1 | OutDone, InDone & InDone1, Env1 | Env>; <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>, that: LazyArg<Channel<OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>>): Channel<OutElem | OutElem1, InElem & InElem1, OutErr1, InErr & InErr1, OutDone | OutDone1, InDone & InDone1, Env | Env1>; }\n```\n\n----------------------------------------\n\nTITLE: TypeScript Signature of Stream.partition Function\nDESCRIPTION: This code block shows the TypeScript signature of the Stream.partition function. It defines multiple overloads to handle different input types and return types, including support for refinements and predicates.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-partition.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const partition: { <C extends A, B extends A, A = C>(refinement: Refinement<NoInfer<A>, B>, options?: { bufferSize?: number | undefined; } | undefined): <E, R>(self: Stream<C, E, R>) => Effect.Effect<[excluded: Stream<Exclude<C, B>, E, never>, satisfying: Stream<B, E, never>], E, R | Scope.Scope>; <A>(predicate: Predicate<A>, options?: { bufferSize?: number | undefined; } | undefined): <E, R>(self: Stream<A, E, R>) => Effect.Effect<[excluded: Stream<A, E, never>, satisfying: Stream<A, E, never>], E, Scope.Scope | R>; <C extends A, E, R, B extends A, A = C>(self: Stream<C, E, R>, refinement: Refinement<A, B>, options?: { bufferSize?: number | undefined; } | undefined): Effect.Effect<[excluded: Stream<Exclude<C, B>, E, never>, satisfying: Stream<B, E, never>], E, R | Scope.Scope>; <A, E, R>(self: Stream<A, E, R>, predicate: Predicate<A>, options?: { bufferSize?: number | undefined; } | undefined): Effect.Effect<[excluded: Stream<A, E, never>, satisfying: Stream<A, E, never>], E, R | Scope.Scope>; }\n```\n\n----------------------------------------\n\nTITLE: Declaring Effect Service Function Type\nDESCRIPTION: Type declaration for serviceFunction that creates a function using a service from context to produce a value. Takes a service getter and a function that uses the service to create a function accepting arguments and returning an Effect.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-serviceFunction.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const serviceFunction: <T extends Effect<any, any, any>, Args extends Array<any>, A>(getService: T, f: (_: Effect.Success<T>) => (...args: Args) => A) => (...args: Args) => Effect<A, Effect.Error<T>, Effect.Context<T>>\n```\n\n----------------------------------------\n\nTITLE: Array.bind Type Signature in Effect-TS\nDESCRIPTION: Type declaration for the Array.bind function in Effect-TS, showing its generic type parameters and return types. The function supports binding new values to array operations while maintaining type safety.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Array-bind.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const bind: { <A extends object, N extends string, B>(tag: Exclude<N, keyof A>, f: (a: NoInfer<A>) => ReadonlyArray<B>): (self: ReadonlyArray<A>) => Array<{ [K in N | keyof A]: K extends keyof A ? A[K] : B; }>; <A extends object, N extends string, B>(self: ReadonlyArray<A>, tag: Exclude<N, keyof A>, f: (a: NoInfer<A>) => ReadonlyArray<B>): Array<{ [K in N | keyof A]: K extends keyof A ? A[K] : B; }>; }\n```\n\n----------------------------------------\n\nTITLE: Converting Option to Array using Effect-TS\nDESCRIPTION: Demonstrates how to convert an Option type to an array using Array.fromOption. Returns a single-element array for Some values and an empty array for None values.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Array-fromOption.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Array, Option } from \"effect\"\n\nconsole.log(Array.fromOption(Option.some(1))) // [1]\nconsole.log(Array.fromOption(Option.none())) // []\n```\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const fromOption: <A>(self: Option.Option<A>) => Array<A>\n```\n\n----------------------------------------\n\nTITLE: Reversing Array Elements using Effect Library\nDESCRIPTION: Demonstrates how to use Array.reverse to reverse the elements of an array. Returns a new array with elements in reverse order without modifying the original array.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Array-reverse.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Array } from \"effect\"\n\nconst result = Array.reverse([1, 2, 3, 4])\nconsole.log(result) // [4, 3, 2, 1]\n```\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const reverse: <S extends Iterable<any>>(self: S) => S extends NonEmptyReadonlyArray<infer A> ? NonEmptyArray<A> : S extends Iterable<infer A> ? Array<A> : never\n```\n\n----------------------------------------\n\nTITLE: Using BigInt.greaterThanOrEqualTo Function in TypeScript\nDESCRIPTION: A function that compares two bigint values to determine if one is greater than or equal to another. It can be used in two ways: curried (taking one argument at a time) or with both arguments at once. Returns a boolean result.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/BigInt-greaterThanOrEqualTo.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { greaterThanOrEqualTo } from \"effect/BigInt\"\n\nassert.deepStrictEqual(greaterThanOrEqualTo(2n, 3n), false)\nassert.deepStrictEqual(greaterThanOrEqualTo(3n, 3n), true)\nassert.deepStrictEqual(greaterThanOrEqualTo(4n, 3n), true)\n```\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const greaterThanOrEqualTo: { (that: bigint): (self: bigint) => boolean; (self: bigint, that: bigint): boolean; }\n```\n\n----------------------------------------\n\nTITLE: Finding Last Index with Predicate in TypeScript Chunk Implementation\nDESCRIPTION: Function signature for finding the last index in a Chunk where a predicate condition is true. The function supports both curried and uncurried forms, returning an Option type containing the found index.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Chunk-findLastIndex.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const findLastIndex: { <A>(predicate: Predicate<A>): (self: Chunk<A>) => Option<number>; <A>(self: Chunk<A>, predicate: Predicate<A>): Option<number>; }\n```\n\n----------------------------------------\n\nTITLE: Checking Predicates for List Elements in TypeScript\nDESCRIPTION: The 'every' function checks if a predicate holds true for every element in a List. It supports both refinement and predicate functions, allowing for type narrowing and boolean checks respectively.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/List-every.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const every: { <A, B extends A>(refinement: Refinement<NoInfer<A>, B>): (self: List<A>) => self is List<B>; <A>(predicate: Predicate<A>): (self: List<A>) => boolean; <A, B extends A>(self: List<A>, refinement: Refinement<A, B>): self is List<B>; <A>(self: List<A>, predicate: Predicate<A>): boolean; }\n```\n\n----------------------------------------\n\nTITLE: Defining flipCauseOption Function in TypeScript for Effect Package\nDESCRIPTION: This function transforms a Cause<Option<E>> into an Option<Cause<E>>. It filters out failures with None errors and returns a Cause of remaining errors or None if all errors were None. This is useful for handling optional errors in effect-based programming.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Cause-flipCauseOption.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const flipCauseOption: <E>(self: Cause<Option.Option<E>>) => Option.Option<Cause<E>>\n```\n\n----------------------------------------\n\nTITLE: Url.urlParams Signature in Typescript\nDESCRIPTION: This code snippet shows the type signature of the `Url.urlParams` function.  It takes a `URL` object as input and returns a `UrlParams.UrlParams` object, which represents the URL's query parameters. This indicates the function's expected input type and the structure of the data it returns, providing type safety and clarity in code.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Url-urlParams.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const urlParams: (url: URL) => UrlParams.UrlParams\n```\n\n----------------------------------------\n\nTITLE: Retrieving Fiber Write Locks Count in TReentrantLock Module\nDESCRIPTION: This function retrieves the number of acquired write locks for a specific fiber. It takes a TReentrantLock instance as input and returns an STM effect that resolves to the number of write locks held by the current fiber.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TReentrantLock-fiberWriteLocks.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const fiberWriteLocks: (self: TReentrantLock) => STM.STM<number>\n```\n\n----------------------------------------\n\nTITLE: Retrieving Values from HashMap in TypeScript\nDESCRIPTION: Function signature for obtaining an IterableIterator of values from a HashMap. Takes a HashMap<K,V> as input and returns an IterableIterator that yields the values of type V stored in the HashMap.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/HashMap-values.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const values: <K, V>(self: HashMap<K, V>) => IterableIterator<V>\n```\n\n----------------------------------------\n\nTITLE: Using Array.take Function Example in TypeScript\nDESCRIPTION: Demonstrates how to use Array.take to extract the first N elements from an array. The function accepts an Iterable and a number parameter to specify how many elements to keep from the start.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Array-take.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Array } from \"effect\"\n\nconst result = Array.take([1, 2, 3, 4, 5], 3)\nconsole.log(result) // [1, 2, 3]\n```\n\n----------------------------------------\n\nTITLE: Defining groupWith Function for Iterable in TypeScript\nDESCRIPTION: This code snippet defines the groupWith function, which groups equal, consecutive elements of an Iterable into NonEmptyArrays. It uses an isEquivalent function to determine equality between elements. The function is overloaded to accept arguments in different orders.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Iterable-groupWith.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const groupWith: {\n  <A>(isEquivalent: (self: A, that: A) => boolean): (self: Iterable<A>) => Iterable<NonEmptyArray<A>>;\n  <A>(self: Iterable<A>, isEquivalent: (self: A, that: A) => boolean): Iterable<NonEmptyArray<A>>;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Stream.zipLeft Type Definition in TypeScript\nDESCRIPTION: Type definition for the zipLeft operation that zips two streams together point-wise but only keeps the outputs of the left stream. The operation supports both curried and uncurried versions and continues until either stream ends.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-zipLeft.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const zipLeft: {\n  <AR, ER, RR>(right: Stream<AR, ER, RR>): <AL, EL, RL>(left: Stream<AL, EL, RL>) => Stream<AL, ER | EL, RR | RL>;\n  <AL, EL, RL, AR, ER, RR>(left: Stream<AL, EL, RL>, right: Stream<AR, ER, RR>): Stream<AL, EL | ER, RL | RR>;\n}\n```\n\n----------------------------------------\n\nTITLE: Channel.emitCollect Function Signature in TypeScript\nDESCRIPTION: The emitCollect function creates a new channel that collects both the output elements and terminal value of a channel, then emits them together as a tuple. This is useful when you need to capture both the streamed data and the final result of a channel operation.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Channel-emitCollect.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const emitCollect: <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>) => Channel<[Chunk.Chunk<OutElem>, OutDone], InElem, OutErr, InErr, void, InDone, Env>\n```\n\n----------------------------------------\n\nTITLE: Layer Function Type Definition in TypeScript\nDESCRIPTION: Type definition for the layer function that enables sharing a Layer between multiple tests. Supports optional test group naming and configuration options including memoization and timeout settings.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/index-layer.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const layer: <R, E>(layer_: Layer.Layer<R, E>, options?: { readonly memoMap?: Layer.MemoMap; readonly timeout?: Duration.DurationInput; }) => { (f: (it: Vitest.MethodsNonLive<R>) => void): void; (name: string, f: (it: Vitest.MethodsNonLive<R>) => void): void; }\n```\n\n----------------------------------------\n\nTITLE: Declaring uninterruptible Effect Function in TypeScript\nDESCRIPTION: This function marks an Effect as uninterruptible, meaning it cannot be interrupted during execution. It takes an Effect with generic type parameters for result value, error, and environment requirement, and returns the same Effect with uninterruptibility.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-uninterruptible.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const uninterruptible: <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R>\n```\n\n----------------------------------------\n\nTITLE: Schedule.modifyDelay Signature\nDESCRIPTION: This snippet shows the TypeScript signature of the `modifyDelay` function within the `Schedule` module. It details how to use the function to modify the delay between executions of a schedule, using a provided function that takes the schedule's output and current duration, and returns a new duration.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Schedule-modifyDelay.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const modifyDelay: { <Out>(f: (out: Out, duration: Duration.Duration) => Duration.DurationInput): <In, R>(self: Schedule<Out, In, R>) => Schedule<Out, In, R>; <Out, In, R>(self: Schedule<Out, In, R>, f: (out: Out, duration: Duration.Duration) => Duration.DurationInput): Schedule<Out, In, R>; }\n```\n\n----------------------------------------\n\nTITLE: Creating Cookies Object from Iterable in TypeScript\nDESCRIPTION: The fromIterable function creates a Cookies object from an Iterable of Cookie items. This utility function helps in constructing Cookies objects from various iterable sources like arrays or sets of Cookie objects.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Cookies-fromIterable.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const fromIterable: (cookies: Iterable<Cookie>) => Cookies\n```\n\n----------------------------------------\n\nTITLE: Defining HttpShardManager.layerWebsocket Layer in TypeScript\nDESCRIPTION: Declares a Websocket layer for the ShardManager server that adds a route to the provided HttpRouter.Tag. It has dependencies on various services and configurations, and uses the HttpRouter.Default tag by default.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/HttpShardManager-layerWebsocket.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const layerWebsocket: Layer.Layer<ShardManager.ShardManager, never, ShardStorage | ShardingConfig | RpcSerialization.RpcSerialization | RunnerHealth.RunnerHealth | ShardManager.Config | Socket.WebSocketConstructor | HttpServer.HttpServer>\n```\n\n----------------------------------------\n\nTITLE: Flattening Chunks in TypeScript using Effect Library\nDESCRIPTION: The flatten function takes a chunk of chunks and concatenates them into a single chunk. It is part of the Chunk module in the effect package. The function is generic, working with any type of nested chunks.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Chunk-flatten.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const flatten: <S extends Chunk<Chunk<any>>>(self: S) => Chunk.Flatten<S>\n```\n\n----------------------------------------\n\nTITLE: Implementing Stream.unwrapScopedWith in TypeScript\nDESCRIPTION: Function signature for creating a stream from a scoped effect. Takes a function that receives a Scope and returns an Effect containing a Stream. The resulting stream emits a single element from the effect's result.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-unwrapScopedWith.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const unwrapScopedWith: <A, E2, R2, E, R>(f: (scope: Scope.Scope) => Effect.Effect<Stream<A, E2, R2>, E, R>) => Stream<A, E | E2, R | R2>\n```\n\n----------------------------------------\n\nTITLE: Demonstrating vcat Combinator Usage in TypeScript\nDESCRIPTION: This example shows how to use the vcat combinator to concatenate words vertically. It imports necessary modules, creates a Doc using vcat and words, and then renders the result.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Doc-vcat.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport * as Doc from \"@effect/printer/Doc\"\nimport * as String from \"effect/String\"\n\nconst doc: Doc.Doc<never> = Doc.vcat(Doc.words(\"lorem ipsum dolor\"))\n\nassert.strictEqual(\n  Doc.render(doc, { style: \"pretty\" }),\n  String.stripMargin(\n    `|lorem\n     |ipsum\n     |dolor`\n  )\n)\n```\n\n----------------------------------------\n\nTITLE: Retrieving Root Fibers in Effect-TS\nDESCRIPTION: The roots function returns an Effect that resolves to an array containing all root fibers in the Effect runtime. This is useful for inspecting or manipulating the set of top-level running fibers.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Fiber-roots.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const roots: Effect.Effect<Array<RuntimeFiber<any, any>>, never, never>\n```\n\n----------------------------------------\n\nTITLE: Defining Schema.Duration Class in TypeScript\nDESCRIPTION: This code snippet declares the Duration class within the Schema module of the effect package. It is used to create a schema that converts JSON-compatible tagged unions into Duration objects.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Schema-Duration.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare class Duration\n```\n\n----------------------------------------\n\nTITLE: Retrieving the Order Instance from a SortedMap in TypeScript\nDESCRIPTION: The getOrder function retrieves the Order<K> instance that a SortedMap<K, V> uses to maintain its sorting order. This is useful when you need to access the comparison function used by the map for its keys.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/SortedMap-getOrder.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const getOrder: <K, V>(self: SortedMap<K, V>) => Order<K>\n```\n\n----------------------------------------\n\nTITLE: Defining fileText Function for File Arguments in TypeScript\nDESCRIPTION: This code snippet defines the fileText function in the Args module. It creates a file argument that reads its contents, with an optional custom argument name (defaulting to 'file'). The function returns an Args type with a tuple containing the file path and content.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Args-fileText.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const fileText: (config?: Args.BaseArgsConfig | undefined) => Args<readonly [path: string, content: string]>\n```\n\n----------------------------------------\n\nTITLE: Creating RuntimeFlagsPatch with RuntimeFlags.diff in TypeScript\nDESCRIPTION: The diff function creates a RuntimeFlagsPatch which describes the difference between two RuntimeFlags objects. It can be used in both curried and non-curried forms.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/RuntimeFlags-diff.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const diff: { (that: RuntimeFlags): (self: RuntimeFlags) => RuntimeFlagsPatch.RuntimeFlagsPatch; (self: RuntimeFlags, that: RuntimeFlags): RuntimeFlagsPatch.RuntimeFlagsPatch; }\n```\n\n----------------------------------------\n\nTITLE: Creating Constant Metrics with Metric.succeed in TypeScript\nDESCRIPTION: Function signature for creating a metric that ignores its input and always produces a constant output value. This is useful for creating static metrics that don't depend on input data.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Metric-succeed.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const succeed: <Out>(out: Out) => Metric<void, unknown, Out>\n```\n\n----------------------------------------\n\nTITLE: Defining Sequence Function in TypeScript\nDESCRIPTION: This snippet defines a generic 'sequence' function that allows for sequencing operations in a traversable context. It accepts a Traversable type and an Applicative type and returns a function that takes a traversable structure and produces an applicative structure.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Traversable-sequence.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const sequence: <T extends TypeLambda>(T: Traversable<T>) => <F extends TypeLambda>(F: Applicative<F>) => <TR, TO, TE, R, O, E, A>(self: Kind<T, TR, TO, TE, Kind<F, R, O, E, A>>) => Kind<F, R, O, E, Kind<T, TR, TO, TE, A>>\n```\n\n----------------------------------------\n\nTITLE: Declaring Doc.lbrace Constant in TypeScript\nDESCRIPTION: Defines a constant 'lbrace' of type Doc<never> representing a document containing a single '{' character. This is part of the @effect/printer package's Doc module.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Doc-lbrace.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const lbrace: Doc<never>\n```\n\n----------------------------------------\n\nTITLE: Converting DateTime to UTC Date in TypeScript\nDESCRIPTION: This function converts a DateTime object to its corresponding UTC Date. It takes a DateTime object as input and returns a Date object representing the UTC time.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/DateTime-toDateUtc.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const toDateUtc: (self: DateTime) => Date\n```\n\n----------------------------------------\n\nTITLE: Array.reduceRight Type Signature in Effect Framework\nDESCRIPTION: Type signature for the reduceRight function showing its polymorphic nature. It supports both curried and non-curried forms, accepting an iterable, initial value, and reducer function.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Array-reduceRight.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const reduceRight: { <B, A>(b: B, f: (b: B, a: A, i: number) => B): (self: Iterable<A>) => B; <A, B>(self: Iterable<A>, b: B, f: (b: B, a: A, i: number) => B): B; }\n```\n\n----------------------------------------\n\nTITLE: Setting Current Timezone for DateTime in Effect TypeScript\nDESCRIPTION: Demonstrates how to set a DateTime object's timezone to the current timezone using the Effect library. The example shows setting the timezone to 'Europe/London' using DateTime.setZoneCurrent and withCurrentZoneNamed.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/DateTime-setZoneCurrent.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { DateTime, Effect } from \"effect\"\n\nEffect.gen(function* () {\n  const now = yield* DateTime.now\n\n  // set the time zone to \"Europe/London\"\n  const zoned = yield* DateTime.setZoneCurrent(now)\n}).pipe(DateTime.withCurrentZoneNamed(\"Europe/London\"))\n```\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const setZoneCurrent: (self: DateTime) => Effect.Effect<Zoned, never, CurrentTimeZone>\n```\n\n----------------------------------------\n\nTITLE: Using HashSet.every with Refinement in TypeScript\nDESCRIPTION: Example demonstrating how to use HashSet.every with a Refinement function to check and narrow the type of all elements in a HashSet. Shows three different syntax approaches: data-last (pipeable), method chaining, and data-first.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/HashSet-every.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// Syntax with Refinement\nimport { HashSet, pipe, Predicate } from \"effect\"\n\nconst numberOrString = HashSet.make(1, \"1\", \"one\", \"uno\")\n\n// with `data-last`, a.k.a. `pipeable` API and `Refinement`\npipe(\n  numberOrString, // HashSet.HashSet<number | string>\n  HashSet.every(Predicate.isString)\n) // HashSet.HashSet<string>\n\n// or piped with the pipe function and  `Refinement`\nnumberOrString // HashSet.HashSet<number | string>\n  .pipe(HashSet.every(Predicate.isString)) // HashSet.HashSet<string>\n\n// or with `data-first` API and `Refinement`\nHashSet.every(\n  numberOrString, // HashSet.HashSet<number | string>\n  Predicate.isString\n) // HashSet.HashSet<string>\n```\n\n----------------------------------------\n\nTITLE: Creating Windowed Schedule in TypeScript\nDESCRIPTION: This function creates a schedule that divides time into fixed interval-long windows, triggering execution at the start of each new window. It waits until the next time window boundary before executing, with each window spanning a fixed duration specified by the interval.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Schedule-windowed.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const windowed: (interval: Duration.DurationInput) => Schedule<number>\n```\n\n----------------------------------------\n\nTITLE: Signature of mapEntries function in Effect TS\nDESCRIPTION: This snippet presents the TypeScript signature of the `mapEntries` function. It showcases the function's generic types, input parameters, and return type. The function accepts a mapping function `f` and a `ReadonlyRecord` as input, returning a transformed `Record`.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Record-mapEntries.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const mapEntries: { <K extends string, A, K2 extends string, B>(f: (a: A, key: K) => readonly [K2, B]): (self: ReadonlyRecord<K, A>) => Record<K2, B>; <K extends string, A, K2 extends string, B>(self: ReadonlyRecord<K, A>, f: (a: A, key: K) => [K2, B]): Record<K2, B>; }\n```\n\n----------------------------------------\n\nTITLE: HashSet.endMutation Function Signature in TypeScript\nDESCRIPTION: The TypeScript type signature for the endMutation function in the HashSet module. This function takes a mutable HashSet of type A and returns an immutable HashSet of the same type.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/HashSet-endMutation.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const endMutation: <A>(self: HashSet<A>) => HashSet<A>\n```\n\n----------------------------------------\n\nTITLE: Scaling BigDecimal Numbers in TypeScript\nDESCRIPTION: Function declaration for scaling BigDecimal values to a specified scale. Provides two function signatures: one for curried usage and one for direct two-parameter usage. When scaling down, the value is rounded to the nearest integer.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/BigDecimal-scale.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const scale: { (scale: number): (self: BigDecimal) => BigDecimal; (self: BigDecimal, scale: number): BigDecimal; }\n```\n\n----------------------------------------\n\nTITLE: Creating Order Instances for Option Type\nDESCRIPTION: This code snippet demonstrates how to create an Order instance for `Option<A>` types using a provided Order for the inner type. It includes examples of comparing different Option instances based on defined rules, such as `None` being less than any `Some` value.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Option-getOrder.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Number, Option } from \"effect\"\n\nconst order = Option.getOrder(Number.Order)\n\nconsole.log(order(Option.none(), Option.none()))\n// Output: 0\n\nconsole.log(order(Option.none(), Option.some(1)))\n// Output: -1\n\nconsole.log(order(Option.some(1), Option.none()))\n// Output: 1\n\nconsole.log(order(Option.some(1), Option.some(2)))\n// Output: -1\n\nconsole.log(order(Option.some(1), Option.some(1)))\n// Output: 0\n```\n\n----------------------------------------\n\nTITLE: Type Signature for isInteger Function\nDESCRIPTION: This snippet shows the TypeScript type declaration for the isInteger function in the BigDecimal module. The function takes a BigDecimal parameter and returns a boolean indicating whether the value is an integer.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/BigDecimal-isInteger.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const isInteger: (n: BigDecimal) => boolean\n```\n\n----------------------------------------\n\nTITLE: Summing BigInt Values with sumAll Function in TypeScript\nDESCRIPTION: The sumAll function takes an Iterable of bigint values and calculates their sum, returning a single bigint. This utility simplifies aggregating large integer values that exceed JavaScript's Number limits.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/BigInt-sumAll.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { sumAll } from \"effect/BigInt\"\n\nassert.deepStrictEqual(sumAll([2n, 3n, 4n]), 9n)\n```\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const sumAll: (collection: Iterable<bigint>) => bigint\n```\n\n----------------------------------------\n\nTITLE: Defining BaseTQueue Interface in TypeScript\nDESCRIPTION: The BaseTQueue interface defines the core requirements for all TQueue implementations in the effect library. It includes methods for capacity management, size checking, state validation, and shutdown procedures. The interface works with STM (Software Transactional Memory) for managing concurrent operations.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TQueue-BaseTQueue.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface BaseTQueue {\n  /**\n   * Returns the number of elements the queue can hold.\n   */\n  capacity(): number\n\n  /**\n   * Retrieves the size of the queue, which is equal to the number of elements\n   * in the queue. This may be negative if fibers are suspended waiting for\n   * elements to be added to the queue.\n   */\n  readonly size: STM.STM<number>\n\n  /**\n   * Returns `true` if the `TQueue` contains at least one element, `false`\n   * otherwise.\n   */\n  readonly isFull: STM.STM<boolean>\n\n  /**\n   * Returns `true` if the `TQueue` contains zero elements, `false` otherwise.\n   */\n  readonly isEmpty: STM.STM<boolean>\n\n  /**\n   * Interrupts any fibers that are suspended on `offer` or `take`. Future calls\n   * to `offer*` and `take*` will be interrupted immediately.\n   */\n  readonly shutdown: STM.STM<void>\n\n  /**\n   * Returns `true` if `shutdown` has been called, otherwise returns `false`.\n   */\n  readonly isShutdown: STM.STM<boolean>\n\n  /**\n   * Waits until the queue is shutdown. The `STM` returned by this method will\n   * not resume until the queue has been shutdown. If the queue is already\n   * shutdown, the `STM` will resume right away.\n   */\n  readonly awaitShutdown: STM.STM<void>\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Pre-Failed Fiber in TypeScript\nDESCRIPTION: This function creates a fiber that has already failed with the specified error value. It returns a Fiber instance with a generic error type E and never as the success type, indicating the fiber will never succeed.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Fiber-fail.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const fail: <E>(error: E) => Fiber<never, E>\n```\n\n----------------------------------------\n\nTITLE: Option.contains Example\nDESCRIPTION: This example demonstrates how to use the `Option.contains` function to check if an `Option` contains a specific value. It showcases the function's behavior with both `Some` and `None` options.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Option-contains.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Option } from \"effect\"\n\nconsole.log(Option.some(2).pipe(Option.contains(2)))\n// Output: true\n\nconsole.log(Option.some(1).pipe(Option.contains(2)))\n// Output: false\n\nconsole.log(Option.none().pipe(Option.contains(2)))\n// Output: false\n```\n\n----------------------------------------\n\nTITLE: HashSet.add Function Signature in Effect Library (TypeScript)\nDESCRIPTION: The type signature for the HashSet.add function, showing both data-first and data-last (pipeable) overloads. It accepts a value of type A and returns a function that takes and returns a HashSet<A>, or directly takes a HashSet<A> and a value, returning a HashSet<A>.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/HashSet-add.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const add: { <A>(value: A): (self: HashSet<A>) => HashSet<A>; <A>(self: HashSet<A>, value: A): HashSet<A>; }\n```\n\n----------------------------------------\n\nTITLE: Using lessThanOrEqualTo Function with BigDecimal in TypeScript\nDESCRIPTION: Example demonstrating how to use the lessThanOrEqualTo function to compare BigDecimal values. The function returns true if the first BigDecimal is less than or equal to the second, and false otherwise.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/BigDecimal-lessThanOrEqualTo.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { lessThanOrEqualTo, unsafeFromString } from \"effect/BigDecimal\"\n\nassert.deepStrictEqual(lessThanOrEqualTo(unsafeFromString(\"2\"), unsafeFromString(\"3\")), true)\nassert.deepStrictEqual(lessThanOrEqualTo(unsafeFromString(\"3\"), unsafeFromString(\"3\")), true)\nassert.deepStrictEqual(lessThanOrEqualTo(unsafeFromString(\"4\"), unsafeFromString(\"3\")), false)\n```\n\n----------------------------------------\n\nTITLE: Declaring Stream.scanReduceEffect Type Signature in TypeScript\nDESCRIPTION: Defines a complex type signature for a stream transformation function that allows stateful and effectful mapping of stream elements. Supports curried and non-curried function applications with flexible type inference.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-scanReduceEffect.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const scanReduceEffect: { <A2, A, E2, R2>(f: (a2: A2 | A, a: A) => Effect.Effect<A2 | A, E2, R2>): <E, R>(self: Stream<A, E, R>) => Stream<A2 | A, E2 | E, R2 | R>; <A, E, R, A2, E2, R2>(self: Stream<A, E, R>, f: (a2: A | A2, a: A) => Effect.Effect<A | A2, E2, R2>): Stream<A | A2, E | E2, R | R2>; }\n```\n\n----------------------------------------\n\nTITLE: Updating Element in TArray using Effect-TS\nDESCRIPTION: This snippet declares the update function, which updates an element in the specified TArray based on the provided index and transformation function. It provides two signatures: the first comprises the parameters (index, transformation function) and returns a function that takes a TArray instance; the second directly takes a TArray instance along with index and transformation function as arguments.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TArray-update.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const update: { <A>(index: number, f: (value: A) => A): (self: TArray<A>) => STM.STM<void>; <A>(self: TArray<A>, index: number, f: (value: A) => A): STM.STM<void>; }\n```\n\n----------------------------------------\n\nTITLE: Context.pick Type Definition\nDESCRIPTION: Type signature for the Context.pick function, showing it accepts an array of tags and returns a function that transforms a Context to include only the specified tagged services.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Context-pick.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const pick: <Tags extends ReadonlyArray<Tag<any, any>>>(...tags: Tags) => <Services>(self: Context<Services>) => Context<Services & Tag.Identifier<Tags[number]>>\n```\n\n----------------------------------------\n\nTITLE: NodeHttpServer.layerContext Layer Declaration\nDESCRIPTION: This code declares a constant `layerContext` of type `Layer.Layer`. It combines `HttpPlatform`, `Etag.Generator`, and `NodeContext.NodeContext` to provide a unified layer for HTTP server operations within a Node.js environment. The layer provides `HttpPlatform`, `FileSystem`, `Etag.Generator`, and `Path` services.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/NodeHttpServer-layerContext.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const layerContext: Layer.Layer<Platform.HttpPlatform | Etag.Generator | NodeContext.NodeContext, never, never>\n```\n\n----------------------------------------\n\nTITLE: Flattening Nested Micro Effects in TypeScript\nDESCRIPTION: Function signature for flattening nested Micro effects. It takes a nested Micro structure and returns a flattened version where error types (E, E2) and requirement types (R, R2) are merged using union types.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Micro-flatten.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const flatten: <A, E, R, E2, R2>(self: Micro<Micro<A, E, R>, E2, R2>) => Micro<A, E | E2, R | R2>\n```\n\n----------------------------------------\n\nTITLE: Constructing Text Documents with Doc.string in TypeScript\nDESCRIPTION: The `string` function creates a document containing text. Note that newline characters (\\n) in the provided string will be disregarded in the output document.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Doc-string.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const string: (str: string) => Doc<never>\n```\n\n----------------------------------------\n\nTITLE: TypeScript Signature for interleaveWith Function\nDESCRIPTION: Provides the TypeScript type signature for the `interleaveWith` function. It shows the function's polymorphic nature, accepting streams of different types and a boolean stream for control.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-interleaveWith.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const interleaveWith: { <A2, E2, R2, E3, R3>(that: Stream<A2, E2, R2>, decider: Stream<boolean, E3, R3>): <A, E, R>(self: Stream<A, E, R>) => Stream<A2 | A, E2 | E3 | E, R2 | R3 | R>; <A, E, R, A2, E2, R2, E3, R3>(self: Stream<A, E, R>, that: Stream<A2, E2, R2>, decider: Stream<boolean, E3, R3>): Stream<A | A2, E | E2 | E3, R | R2 | R3>; }\n```\n\n----------------------------------------\n\nTITLE: Defining Channel.write Function in TypeScript\nDESCRIPTION: Declares a function 'write' that takes a single value of type OutElem and returns a Channel of OutElem. This function is used to write a single value to the channel.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Channel-write.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const write: <OutElem>(out: OutElem) => Channel<OutElem>\n```\n\n----------------------------------------\n\nTITLE: Constructing Differ for RuntimeFlags - TypeScript\nDESCRIPTION: This code snippet defines a constant 'differ' that is a generic Differ interface for comparing RuntimeFlags values. This differ is used to determine the changes between different RuntimeFlags objects, creating RuntimeFlagsPatch instances representing the differences. The implementation relies on the Differ library and the module it is part of is RuntimeFlags.ts.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/RuntimeFlags-differ.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const differ: Differ.Differ<RuntimeFlags, RuntimeFlagsPatch.RuntimeFlagsPatch>\n```\n\n----------------------------------------\n\nTITLE: TypeScript Signature for concatWith Function\nDESCRIPTION: Provides the TypeScript signature for the `concatWith` function. It shows two overloads: one that takes a function first and returns a function, and another that takes the documents and function together.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Doc-concatWith.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const concatWith: { <A>(f: (left: Doc<A>, right: Doc<A>) => Doc<A>): (docs: Iterable<Doc<A>>) => Doc<A>; <A>(docs: Iterable<Doc<A>>, f: (left: Doc<A>, right: Doc<A>) => Doc<A>): Doc<A>; }\n```\n\n----------------------------------------\n\nTITLE: Creating Primitive Config Parser in TypeScript\nDESCRIPTION: Defines a function that constructs a new primitive configuration parser. Takes a description string and a parsing function that converts text input to Either<A, ConfigError>.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Config-primitive.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const primitive: <A>(description: string, parse: (text: string) => Either.Either<A, ConfigError.ConfigError>) => Config<A>\n```\n\n----------------------------------------\n\nTITLE: Defining a No-op Logger in TypeScript\nDESCRIPTION: Declares a constant 'none' as a Logger that does nothing in response to logging events. It is of type Logger<unknown, void>, indicating it can handle any type of input but produces no output.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Logger-none.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const none: Logger<unknown, void>\n```\n\n----------------------------------------\n\nTITLE: Converting STM Error Options with TypeScript\nDESCRIPTION: The code snippet provides a TypeScript declaration for transforming an STM instance that has an option on errors into one that has an option on values. It leverages generics to maintain flexibility across different data types and requires the `Option` and `STM` classes to be in scope. This operation is crucial for handling cases where you might have optional errors that need to be processed or converted.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/STM-unsome.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const unsome: <A, E, R>(self: STM<A, Option.Option<E>, R>) => STM<Option.Option<A>, E, R>;\n```\n\n----------------------------------------\n\nTITLE: Retrieving Values from RedBlackTree in TypeScript\nDESCRIPTION: Declares a function that returns an iterator of all values in a Red-Black Tree. The function takes a Red-Black Tree as input and generates an iterable sequence of its values in order.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/RedBlackTree-values.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const values: <K, V>(self: RedBlackTree<K, V>) => IterableIterator<V>\n```\n\n----------------------------------------\n\nTITLE: Creating Frequency Metric Keys in TypeScript\nDESCRIPTION: Function signature for creating a metric key that represents a categorical frequency table. Takes a name parameter and optional configuration including description and preregistered words array.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/MetricKey-frequency.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const frequency: (name: string, options?: { readonly description?: string | undefined; readonly preregisteredWords?: ReadonlyArray<string> | undefined; } | undefined) => MetricKey.Frequency\n```\n\n----------------------------------------\n\nTITLE: Defining tapRequest Function in TypeScript for HttpClient Module\nDESCRIPTION: This code snippet defines the tapRequest function for the HttpClient module. It allows performing an additional effect on the request before sending it. The function is overloaded to accept either the HttpClient instance first or the effect function first.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/HttpClient-tapRequest.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const tapRequest: {\n  <_, E2, R2>(f: (a: ClientRequest.HttpClientRequest) => Effect.Effect<_, E2, R2>): <E, R>(self: HttpClient.With<E, R>) => HttpClient.With<E | E2, R | R2>;\n  <E, R, _, E2, R2>(self: HttpClient.With<E, R>, f: (a: ClientRequest.HttpClientRequest) => Effect.Effect<_, E2, R2>): HttpClient.With<E | E2, R | R2>;\n}\n```\n\n----------------------------------------\n\nTITLE: Running for Each Chunk Scoped in TypeScript using Effect-TS\nDESCRIPTION: This function, `runForEachChunkScoped`, allows the user to process each chunk of a stream with control over the finalization order of effects. Its signature supports generics for flexibility in the types of stream elements, errors, and results. Expected inputs include a function that processes chunks, and the output is an effect that returns a scoped resource and handles errors accordingly.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-runForEachChunkScoped.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const runForEachChunkScoped: { <A, X, E2, R2>(f: (a: Chunk.Chunk<A>) => Effect.Effect<X, E2, R2>): <E, R>(self: Stream<A, E, R>) => Effect.Effect<void, E2 | E, Scope.Scope | R2 | R>; <A, E, R, X, E2, R2>(self: Stream<A, E, R>, f: (a: Chunk.Chunk<A>) => Effect.Effect<X, E2, R2>): Effect.Effect<void, E | E2, Scope.Scope | R | R2>; }\n```\n\n----------------------------------------\n\nTITLE: Defining Sliding Size Function in TypeScript\nDESCRIPTION: This snippet declares the slidingSize function which enables configuring chunk size and step size for processing streams. It returns a function that takes a Stream object as input and returns a modified Stream object with specified chunk sizes.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-slidingSize.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const slidingSize: { (chunkSize: number, stepSize: number): <A, E, R>(self: Stream<A, E, R>) => Stream<Chunk.Chunk<A>, E, R>; <A, E, R>(self: Stream<A, E, R>, chunkSize: number, stepSize: number): Stream<Chunk.Chunk<A>, E, R>; }\n```\n\n----------------------------------------\n\nTITLE: Declaring ConfigProvider.unnested Function in TypeScript\nDESCRIPTION: Defines a function that creates a new config provider by un-nesting all configuration under a specified property name. The function supports both curried and uncurried calling styles.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/ConfigProvider-unnested.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const unnested: { (name: string): (self: ConfigProvider) => ConfigProvider; (self: ConfigProvider, name: string): ConfigProvider; }\n```\n\n----------------------------------------\n\nTITLE: Signature for schemaStruct Function in TypeScript\nDESCRIPTION: This signature defines the `schemaStruct` function, a critical component for extracting schemas in TypeScript using the `@effect/platform` library. It requires a schema definition and optionally accepts parse options. It returns a function that operates on `UrlParams`, yielding an `Effect` that captures the schema extraction result or a parse error.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/UrlParams-schemaStruct.md#2025-04-11_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const schemaStruct: <A, I extends Record<string, string | ReadonlyArray<string> | undefined>, R>(schema: Schema.Schema<A, I, R>, options?: ParseOptions | undefined) => (self: UrlParams) => Effect.Effect<A, ParseResult.ParseError, R>\n```\n\n----------------------------------------\n\nTITLE: Channel PipeTo Function Signature in TypeScript\nDESCRIPTION: Type definition for the pipeTo function that creates a new channel by piping the output of one channel into another. The function supports two overloads - one for curried usage and another for direct piping between channels.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Channel-pipeTo.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const pipeTo: { <OutElem2, OutElem, OutErr2, OutErr, OutDone2, OutDone, Env2>(that: Channel<OutElem2, OutElem, OutErr2, OutErr, OutDone2, OutDone, Env2>): <InElem, InErr, InDone, Env>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>) => Channel<OutElem2, InElem, OutErr2, InErr, OutDone2, InDone, Env2 | Env>; <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutElem2, OutErr2, OutDone2, Env2>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>, that: Channel<OutElem2, OutElem, OutErr2, OutErr, OutDone2, OutDone, Env2>): Channel<OutElem2, InElem, OutErr2, InErr, OutDone2, InDone, Env | Env2>; }\n```\n\n----------------------------------------\n\nTITLE: Creating Unbounded PubSub in TypeScript\nDESCRIPTION: The unbounded function creates an unbounded PubSub instance. It accepts an optional options object with a replay property. The function returns an Effect that resolves to a PubSub<A> instance.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/PubSub-unbounded.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const unbounded: <A>(options?: { readonly replay?: number | undefined; }) => Effect.Effect<PubSub<A>>\n```\n\n----------------------------------------\n\nTITLE: Transforming Differ Types in TypeScript using Effect's Differ.transform\nDESCRIPTION: The transform function allows converting a Differ that works with one type to work with another type by providing bidirectional conversion functions. It requires toNew and toOld mapping functions to convert between the original and target value types.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Differ-transform.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const transform: { <Value, Value2>(options: { readonly toNew: (value: Value) => Value2; readonly toOld: (value: Value2) => Value; }): <Patch>(self: Differ<Value, Patch>) => Differ<Value2, Patch>; <Value, Patch, Value2>(self: Differ<Value, Patch>, options: { readonly toNew: (value: Value) => Value2; readonly toOld: (value: Value2) => Value; }): Differ<Value2, Patch>; }\n```\n\n----------------------------------------\n\nTITLE: Defining Parallel ExecutionStrategy Interface in TypeScript\nDESCRIPTION: Defines the Parallel execution strategy interface which is used to execute effects in parallel. The interface includes a _tag property with the value \"Parallel\" to identify this strategy type.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/ExecutionStrategy-Parallel.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface Parallel {\n  readonly _tag: \"Parallel\"\n}\n```\n\n----------------------------------------\n\nTITLE: Defining zipRight Function in TypeScript for Schedule Module\nDESCRIPTION: Declares the zipRight function, which is similar to intersect but ignores the left output. It takes two Schedule objects and returns a new Schedule that combines their inputs and effects.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Schedule-zipRight.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const zipRight: { <Out2, In2, R2>(that: Schedule<Out2, In2, R2>): <Out, In, R>(self: Schedule<Out, In, R>) => Schedule<Out2, In & In2, R2 | R>; <Out, In, R, Out2, In2, R2>(self: Schedule<Out, In, R>, that: Schedule<Out2, In2, R2>): Schedule<Out2, In & In2, R | R2>; }\n```\n\n----------------------------------------\n\nTITLE: Creating Integer Configurations with Config.integer in TypeScript\nDESCRIPTION: The integer function constructs a configuration for integer values. It optionally accepts a name parameter for the configuration and returns a Config object that handles number values.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Config-integer.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const integer: (name?: string) => Config<number>\n```\n\n----------------------------------------\n\nTITLE: Defining Effect.logWarning Function Signature in TypeScript\nDESCRIPTION: The function signature for logWarning in the Effect module, which logs messages at the WARNING level. It accepts any number of arguments and returns an Effect that resolves to void, with never types for error and environment dependencies.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-logWarning.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const logWarning: (...message: ReadonlyArray<any>) => Effect<void, never, never>\n```\n\n----------------------------------------\n\nTITLE: Calculating Next Power of 2 in TypeScript\nDESCRIPTION: This snippet demonstrates how to use the `nextPow2` function from the Effect library to compute the next power of 2 for given integers. It includes test assertions to validate its correctness. The function takes a number as input and returns the next power of 2, which is an integer greater than or equal to the input number.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Number-nextPow2.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { nextPow2 } from \"effect/Number\"\n\nassert.deepStrictEqual(nextPow2(5), 8)\nassert.deepStrictEqual(nextPow2(17), 32)\n```\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const nextPow2: (n: number) => number\n```\n\n----------------------------------------\n\nTITLE: Declaring List Size Function in TypeScript\nDESCRIPTION: Defines a function 'size' that takes a List of type A and returns the number of elements in the list. This function is part of the List module in the Effect package.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/List-size.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const size: <A>(self: List<A>) => number\n```\n\n----------------------------------------\n\nTITLE: Creating FiberMap-backed Effect Run Function in TypeScript\nDESCRIPTION: The makeRuntimePromise function creates an Effect run function that is backed by a FiberMap. It returns an Effect that, when run, produces a function to execute effects with specified keys and options, returning promises.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/FiberMap-makeRuntimePromise.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const makeRuntimePromise: <R, K, A = unknown, E = unknown>() => Effect.Effect<(<XE extends E, XA extends A>(key: K, effect: Effect.Effect<XA, XE, R>, options?: (Runtime.RunForkOptions & { readonly onlyIfMissing?: boolean | undefined; }) | undefined) => Promise<XA>), never, Scope.Scope | R>\n```\n\n----------------------------------------\n\nTITLE: Creating a Stream from a Channel in Effect\nDESCRIPTION: This code snippet demonstrates the `fromChannel` function, which creates a stream from a `Channel`. The function takes a `Channel` as input, which yields chunks of type `A`, and returns a `Stream` that emits elements of type `A`. The channel can potentially fail with an error of type `E` and requires an environment of type `R`.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-fromChannel.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const fromChannel: <A, E, R>(channel: Channel.Channel<Chunk.Chunk<A>, unknown, E, unknown, unknown, unknown, R>) => Stream<A, E, R>\n```\n\n----------------------------------------\n\nTITLE: Running Effect Stream for Effects (runDrain) in TypeScript\nDESCRIPTION: This code snippet showcases the `runDrain` function from the Effect library. The function takes a `Stream` as input and returns an `Effect` that, when executed, runs the stream to completion, discarding all emitted values. It's useful for scenarios where only the side effects of the stream are relevant.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-runDrain.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const runDrain: <A, E, R>(self: Stream<A, E, R>) => Effect.Effect<void, E, R>\n```\n\n----------------------------------------\n\nTITLE: Type Signature for Array.splitNonEmptyAt in TypeScript\nDESCRIPTION: Provides the type signature for the Array.splitNonEmptyAt function. It shows two overloads: one that takes the number of elements first, and another that takes the array first. Both return a tuple of two arrays.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Array-splitNonEmptyAt.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const splitNonEmptyAt: { (n: number): <A>(self: NonEmptyReadonlyArray<A>) => [beforeIndex: NonEmptyArray<A>, fromIndex: Array<A>]; <A>(self: NonEmptyReadonlyArray<A>, n: number): [beforeIndex: NonEmptyArray<A>, fromIndex: Array<A>]; }\n```\n\n----------------------------------------\n\nTITLE: Defining forkWithErrorHandler Function in Effect Module (TypeScript)\nDESCRIPTION: Type signature for the forkWithErrorHandler function which allows forking an Effect with a custom error handler. It supports two invocation patterns: curried and uncurried, both returning a Fiber.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-forkWithErrorHandler.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const forkWithErrorHandler: { <E, X>(handler: (e: E) => Effect<X>): <A, R>(self: Effect<A, E, R>) => Effect<Fiber.RuntimeFiber<A, E>, never, R>; <A, E, R, X>(self: Effect<A, E, R>, handler: (e: E) => Effect<X>): Effect<Fiber.RuntimeFiber<A, E>, never, R>; }\n```\n\n----------------------------------------\n\nTITLE: Implementing Omit Utility Function in TypeScript for SchemaAST\nDESCRIPTION: Defines an omit function that removes specified properties from an AST type structure at runtime. Similar to TypeScript's Omit utility type, it takes an AST object and an array of property keys to exclude, returning either a TypeLiteral or Transformation.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/SchemaAST-omit.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const omit: (ast: AST, keys: ReadonlyArray<PropertyKey>) => TypeLiteral | Transformation\n```\n\n----------------------------------------\n\nTITLE: Implementing takeSome Function for Transactional Maps in TypeScript\nDESCRIPTION: The takeSome function takes a partial function that maps key-value pairs to an optional value. It processes all entries in a TMap, collects matching values, and returns a non-empty array of results. If no matches are found, the transaction retries.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TMap-takeSome.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const takeSome: { <K, V, A>(pf: (key: K, value: V) => Option.Option<A>): (self: TMap<K, V>) => STM.STM<[A, ...Array<A>]>; <K, V, A>(self: TMap<K, V>, pf: (key: K, value: V) => Option.Option<A>): STM.STM<[A, ...Array<A>]>; }\n```\n\n----------------------------------------\n\nTITLE: Defining Stream Debounce Type Signature in TypeScript\nDESCRIPTION: Provides the type definition for the Stream.debounce method, showing its flexible usage with different parameter orders and duration input types\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-debounce.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const debounce: { (duration: Duration.DurationInput): <A, E, R>(self: Stream<A, E, R>) => Stream<A, E, R>; <A, E, R>(self: Stream<A, E, R>, duration: Duration.DurationInput): Stream<A, E, R>; }\n```\n\n----------------------------------------\n\nTITLE: Signature of Tuple.map Function in TypeScript\nDESCRIPTION: The provided signature declares the map function from the Effect library, allowing transformation operations over tuples. The function supports two forms where the mapping function can be applied directly or piped. The signature emphasizes generic types for maximal flexibility and type safety.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Tuple-map.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const map: { <T extends ReadonlyArray<any> | [], B>(fn: (element: T[number]) => B): (self: T) => TupleOf<T[\"length\"], B>; <B, T extends ReadonlyArray<any> | []>(self: T, fn: (element: T[number]) => B): TupleOf<T[\"length\"], B>; }\n```\n\n----------------------------------------\n\nTITLE: Splitting NonEmptyReadonlyArray using Array.splitNonEmptyAt in TypeScript\nDESCRIPTION: Demonstrates how to use the Array.splitNonEmptyAt function to split a NonEmptyReadonlyArray into two segments. The function takes an array and a number n, returning two arrays where the first contains a maximum of n elements.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Array-splitNonEmptyAt.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Array } from \"effect\"\n\nconst result = Array.splitNonEmptyAt([\"a\", \"b\", \"c\", \"d\", \"e\"], 3)\nconsole.log(result) // [[\"a\", \"b\", \"c\"], [\"d\", \"e\"]]\n```\n\n----------------------------------------\n\nTITLE: Collecting Elements using TSet in TypeScript\nDESCRIPTION: The function `toChunk` collects all elements of a TSet and returns them in a Chunk structure. This transformation is performed in the context of the STM monad. No specific dependencies other than the `effect` package are noted, and it returns an STM of a Chunk containing the elements of the TSet.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TSet-toChunk.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const toChunk: <A>(self: TSet<A>) => STM.STM<Chunk.Chunk<A>>\n```\n\n----------------------------------------\n\nTITLE: Finding Key/Value Pairs with Effect Function in TMap (TypeScript)\nDESCRIPTION: The `findAllSTM` function allows for finding all key/value pairs in a `TMap` that match a given predicate. It uses an effectful function to apply transformations or extract values from matching pairs using STM transactions. The function supports two overloads for its type signature. It requires the `STM.STM` and `Option.Option` modules from the Effect library. Key parameters include a predicate function `pf` that takes a key and value and returns an STM effect, as well as the `TMap` instance `self`. The output is an STM effect that resolves to an array of transformed values, if successful.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TMap-findAllSTM.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const findAllSTM: { <K, V, A, E, R>(pf: (key: K, value: V) => STM.STM<A, Option.Option<E>, R>): (self: TMap<K, V>) => STM.STM<Array<A>, E, R>; <K, V, A, E, R>(self: TMap<K, V>, pf: (key: K, value: V) => STM.STM<A, Option.Option<E>, R>): STM.STM<Array<A>, E, R>; }\n```\n\n----------------------------------------\n\nTITLE: Defining Retries Constant for Flaky Tests in TypeScript\nDESCRIPTION: Declares a constant 'retries' that represents the number of times to retry flaky tests. It returns an Effect that resolves to a number, with no error or environment dependencies.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TestServices-retries.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const retries: Effect.Effect<number, never, never>\n```\n\n----------------------------------------\n\nTITLE: Repeating Elements in a Stream using Schedule in TypeScript\nDESCRIPTION: The `repeatElements` function allows elements of a stream to be repeated based on a specified schedule. It uses the `Schedule` module from the Effect library to manage the repetitions, ensuring that each element is repeated according to the defined schedule parameters. The function's signature supports flexible type parameters for adaptability across various stream and schedule configurations.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-repeatElements.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const repeatElements: { <B, R2>(schedule: Schedule.Schedule<B, unknown, R2>): <A, E, R>(self: Stream<A, E, R>) => Stream<A, E, R2 | R>; <A, E, R, B, R2>(self: Stream<A, E, R>, schedule: Schedule.Schedule<B, unknown, R2>): Stream<A, E, R | R2>; }\n```\n\n----------------------------------------\n\nTITLE: TypeScript Signature for Trie.remove Function\nDESCRIPTION: The TypeScript signature for the Trie.remove function, which allows for removing entries from a Trie data structure. It supports both curried and non-curried function calls.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Trie-remove.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const remove: { (key: string): <V>(self: Trie<V>) => Trie<V>; <V>(self: Trie<V>, key: string): Trie<V>; }\n```\n\n----------------------------------------\n\nTITLE: TypeScript Function Signature for Chunk.appendAll\nDESCRIPTION: The type signature for the appendAll function in the Chunk module, showing its polymorphic nature and ability to preserve non-emptiness when concatenating chunks.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Chunk-appendAll.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const appendAll: { <S extends Chunk<any>, T extends Chunk<any>>(that: T): (self: S) => Chunk.OrNonEmpty<S, T, Chunk.Infer<S> | Chunk.Infer<T>>; <A, B>(self: Chunk<A>, that: NonEmptyChunk<B>): NonEmptyChunk<A | B>; <A, B>(self: NonEmptyChunk<A>, that: Chunk<B>): NonEmptyChunk<A | B>; <A, B>(self: Chunk<A>, that: Chunk<B>): Chunk<A | B>; }\n```\n\n----------------------------------------\n\nTITLE: Comparing Intervals in TypeScript using Effect ScheduleInterval\nDESCRIPTION: Defines a function 'lessThan' that compares two Interval objects. It returns true if the first interval is less than the second, false otherwise. The function is curried, allowing for both point-free and traditional usage.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/ScheduleInterval-lessThan.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const lessThan: { (that: Interval): (self: Interval) => boolean; (self: Interval, that: Interval): boolean; }\n```\n\n----------------------------------------\n\nTITLE: Checking if a value is a BigDecimal in TypeScript\nDESCRIPTION: A type guard function that determines whether a given unknown value is a BigDecimal. Returns a boolean with type narrowing to BigDecimal when true.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/BigDecimal-isBigDecimal.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const isBigDecimal: (u: unknown) => u is BigDecimal\n```\n\n----------------------------------------\n\nTITLE: Array.findLastIndex TypeScript Function Signature\nDESCRIPTION: The type signature for the Array.findLastIndex function, showing both the curried and non-curried versions. It accepts a predicate function that takes an element and its index, and returns a boolean. The function returns an Option containing the index if found.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Array-findLastIndex.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const findLastIndex: { <A>(predicate: (a: NoInfer<A>, i: number) => boolean): (self: Iterable<A>) => Option.Option<number>; <A>(self: Iterable<A>, predicate: (a: A, i: number) => boolean): Option.Option<number>; }\n```\n\n----------------------------------------\n\nTITLE: Implementing Effect Sink.forEach function in TypeScript\nDESCRIPTION: A sink implementation that executes a provided effectful function for each input element fed to it. The function returns a void value and never emits any output other than potential errors.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Sink-forEach.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const forEach: <In, X, E, R>(f: (input: In) => Effect.Effect<X, E, R>) => Sink<void, In, never, E, R>\n```\n\n----------------------------------------\n\nTITLE: Creating a Layer from System's Local Time Zone in effect's DateTime Module\nDESCRIPTION: This function creates a Layer from the system's local time zone. It can be used to provide the CurrentTimeZone dependency in an Effect application.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/DateTime-layerCurrentZoneLocal.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const layerCurrentZoneLocal: Layer.Layer<CurrentTimeZone, never, never>\n```\n\n----------------------------------------\n\nTITLE: Defining resetAfter Function in TypeScript\nDESCRIPTION: The resetAfter function creates a new schedule that resets to its initial state after a defined period of inactivity (duration). It accepts a Schedule instance and a duration parameter, ensuring that the schedule behaves as if it's new if no inputs are received during the specified duration.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Schedule-resetAfter.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const resetAfter: { (duration: Duration.DurationInput): <Out, In, R>(self: Schedule<Out, In, R>) => Schedule<Out, In, R>; <Out, In, R>(self: Schedule<Out, In, R>, duration: Duration.DurationInput): Schedule<Out, In, R>; }\n```\n\n----------------------------------------\n\nTITLE: Defining mapInputContext Function for Stream Transformation in TypeScript\nDESCRIPTION: This code snippet defines the mapInputContext function, which transforms the context provided to a stream. It takes a function that converts one context type to another and applies it to the stream, potentially changing its type parameters.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-mapInputContext.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const mapInputContext: {\n  <R0, R>(f: (env: Context.Context<R0>) => Context.Context<R>): <A, E>(self: Stream<A, E, R>) => Stream<A, E, R0>;\n  <A, E, R0, R>(self: Stream<A, E, R>, f: (env: Context.Context<R0>) => Context.Context<R>): Stream<A, E, R0>;\n}\n```\n\n----------------------------------------\n\nTITLE: DateTime.distance Function Signature in TypeScript\nDESCRIPTION: The type signature of the DateTime.distance function showing its dual interface. It can be called with curried parameters (other)(self) or with both parameters at once (self, other).\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/DateTime-distance.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const distance: { (other: DateTime): (self: DateTime) => number; (self: DateTime, other: DateTime): number; }\n```\n\n----------------------------------------\n\nTITLE: Checking for UnknownException in TypeScript with Effect.ts\nDESCRIPTION: Defines the isUnknownException function which checks if a given unknown value is an UnknownException. This utility function provides type narrowing from unknown to UnknownException when used in conditional blocks.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Cause-isUnknownException.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const isUnknownException: (u: unknown) => u is UnknownException\n```\n\n----------------------------------------\n\nTITLE: Defining traverseTap Function for Traversable Structures in TypeScript\nDESCRIPTION: Declares the traverseTap function, which takes a Traversable<T> and an Applicative<F>, and returns a function that applies an effect to each element of a traversable structure. It threads the effect through all values, returning the original structure in the effect context while ignoring the values returned by the provided function.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Traversable-traverseTap.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const traverseTap: <T extends TypeLambda>(T: Traversable<T>) => <F extends TypeLambda>(F: Applicative<F>) => { <A, R, O, E, B>(f: (a: A) => Kind<F, R, O, E, B>): <TR, TO, TE>(self: Kind<T, TR, TO, TE, A>) => Kind<F, R, O, E, Kind<T, TR, TO, TE, A>>; <TR, TO, TE, A, R, O, E, B>(self: Kind<T, TR, TO, TE, A>, f: (a: A) => Kind<F, R, O, E, B>): Kind<F, R, O, E, Kind<T, TR, TO, TE, A>>; }\n```\n\n----------------------------------------\n\nTITLE: Type Signature for Array.setNonEmptyHead Function in TypeScript\nDESCRIPTION: The type signature for the Array.setNonEmptyHead function, showing its polymorphic implementation. It supports both curried and non-curried calling styles, and preserves the non-empty array guarantee in the return type.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Array-setNonEmptyHead.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const setNonEmptyHead: { <B>(b: B): <A>(self: NonEmptyReadonlyArray<A>) => NonEmptyArray<A | B>; <A, B>(self: NonEmptyReadonlyArray<A>, b: B): NonEmptyArray<A | B>; }\n```\n\n----------------------------------------\n\nTITLE: Converting Layer to Runtime with MemoMap in TypeScript\nDESCRIPTION: Function signature for converting a layer requiring no services into a scoped runtime. Takes a MemoMap parameter and returns an Effect that produces a Runtime. Supports both curried and uncurried calling styles.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Layer-toRuntimeWithMemoMap.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const toRuntimeWithMemoMap: { \n  (memoMap: MemoMap): <RIn, E, ROut>(self: Layer<ROut, E, RIn>) => Effect.Effect<Runtime.Runtime<ROut>, E, Scope.Scope | RIn>; \n  <RIn, E, ROut>(self: Layer<ROut, E, RIn>, memoMap: MemoMap): Effect.Effect<Runtime.Runtime<ROut>, E, Scope.Scope | RIn>; \n}\n```\n\n----------------------------------------\n\nTITLE: Defining Effectful Recurrence Schedule in TypeScript\nDESCRIPTION: Creates a schedule that continues executing as long as an effectful predicate returns true. Allows dynamic condition evaluation during schedule execution.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Schedule-recurWhileEffect.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const recurWhileEffect: <A, R>(f: (a: A) => Effect.Effect<boolean, never, R>) => Schedule<A, A, R>\n```\n\n----------------------------------------\n\nTITLE: BigInt MonoidSum Type Declaration\nDESCRIPTION: This snippet declares the MonoidSum constant, which is of type monoid.Monoid<bigint>. It specifies the structure of the MonoidSum object that facilitates the combination of BigInt values using the monoid pattern.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/data-BigInt-MonoidSum.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const MonoidSum: monoid.Monoid<bigint>\n```\n\n----------------------------------------\n\nTITLE: Function signature for withEarlyRelease in Effect module\nDESCRIPTION: This snippet shows the TypeScript type signature of the withEarlyRelease function. It takes an Effect and returns a new Effect that yields both a finalizer Effect and the original result, with an additional dependency on Scope.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-withEarlyRelease.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const withEarlyRelease: <A, E, R>(self: Effect<A, E, R>) => Effect<[finalizer: Effect<void>, result: A], E, R | Scope.Scope>\n```\n\n----------------------------------------\n\nTITLE: Setting the port of a URL in Effect Platform\nDESCRIPTION: The `setPort` function allows updating the port of a given URL object. It accepts either the port and URL as separate arguments or the port as a single argument to create a curried function that accepts the URL. The function returns a new URL object with the updated port.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Url-setPort.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const setPort: { (port: string | number): (url: URL) => URL; (url: URL, port: string | number): URL; }\n```\n\n----------------------------------------\n\nTITLE: Retrieving Cookie Values in Effect Platform\nDESCRIPTION: The getValue function retrieves a cookie value by name from a Cookies object. It returns an Option type that may contain the string value of the cookie if it exists.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Cookies-getValue.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const getValue: { (name: string): (self: Cookies) => Option.Option<string>; (self: Cookies, name: string): Option.Option<string>; }\n```\n\n----------------------------------------\n\nTITLE: TypeScript signature for Trie.make function\nDESCRIPTION: Provides the TypeScript type signature for the Trie.make function. It shows that the function accepts a variable number of tuple entries and returns a Trie with the appropriate value type.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Trie-make.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const make: <Entries extends Array<readonly [string, any]>>(...entries: Entries) => Trie<Entries[number] extends readonly [any, infer V] ? V : never>\n```\n\n----------------------------------------\n\nTITLE: Declaring Empty Layer in Effect.ts\nDESCRIPTION: Defines a Layer constant that constructs an empty Context. This layer has no requirements (never), no errors (never), and provides no services (never) to the context.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Layer-empty.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const empty: Layer<never, never, never>\n```\n\n----------------------------------------\n\nTITLE: Effect Schema pickLiteral Signature\nDESCRIPTION: This code shows the Typescript signature of the `pickLiteral` function. It takes a variadic number of literal values (L) and a Schema of type A, I, and R, and returns a `Literal` Schema composed of the provided literals.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Schema-pickLiteral.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const pickLiteral: <A extends AST.LiteralValue, L extends array_.NonEmptyReadonlyArray<A>>(...literals: L) => <I, R>(_schema: Schema<A, I, R>) => Literal<[...L]>\n```\n\n----------------------------------------\n\nTITLE: Effect.zipWith Function Signature in TypeScript\nDESCRIPTION: Type signature for the zipWith function showing its polymorphic nature and support for various type parameters and options including concurrent execution and batching.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-zipWith.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const zipWith: { <A2, E2, R2, A, B>(that: Effect<A2, E2, R2>, f: (a: A, b: A2) => B, options?: { readonly concurrent?: boolean | undefined; readonly batching?: boolean | \"inherit\" | undefined; readonly concurrentFinalizers?: boolean | undefined; }): <E, R>(self: Effect<A, E, R>) => Effect<B, E2 | E, R2 | R>; <A, E, R, A2, E2, R2, B>(self: Effect<A, E, R>, that: Effect<A2, E2, R2>, f: (a: A, b: A2) => B, options?: { readonly concurrent?: boolean | undefined; readonly batching?: boolean | \"inherit\" | undefined; readonly concurrentFinalizers?: boolean | undefined; }): Effect<B, E2 | E, R2 | R>; }\n```\n\n----------------------------------------\n\nTITLE: Declaring the modifyHash Function in HashMap Module\nDESCRIPTION: This function alters the value of a specified key in a HashMap using a provided update function and hash. It takes a key, hash value, and update function, and either updates an existing entry or inserts a new one. The update function receives the current value or None if the key doesn't exist.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/HashMap-modifyHash.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const modifyHash: { <K, V>(key: K, hash: number, f: HashMap.UpdateFn<V>): (self: HashMap<K, V>) => HashMap<K, V>; <K, V>(self: HashMap<K, V>, key: K, hash: number, f: HashMap.UpdateFn<V>): HashMap<K, V>; }\n```\n\n----------------------------------------\n\nTITLE: Defining a semicolon document constant in TypeScript\nDESCRIPTION: Declaration of a constant named 'semi' which represents a document containing a single semicolon character. It has a type parameter of 'never' indicating it doesn't contain any specific annotation type.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Doc-semi.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const semi: Doc<never>\n```\n\n----------------------------------------\n\nTITLE: Defining Schema.DateTimeUtc Class in TypeScript\nDESCRIPTION: Declares the DateTimeUtc class within the Schema module. This class is used to convert string representations to DateTime.Utc instances using the DateTime.unsafeMake constructor.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Schema-DateTimeUtc.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare class DateTimeUtc\n```\n\n----------------------------------------\n\nTITLE: Creating Difference Patches Between FiberRefs Collections in TypeScript\nDESCRIPTION: The diff function constructs a patch that describes the changes between two collections of FiberRef. This is used to track and apply changes across different fibers in the Effect system.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/FiberRefsPatch-diff.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const diff: (oldValue: FiberRefs.FiberRefs, newValue: FiberRefs.FiberRefs) => FiberRefsPatch\n```\n\n----------------------------------------\n\nTITLE: Converting Duration to Time Components in TypeScript\nDESCRIPTION: Function signature for converting a Duration input into an object containing days, hours, minutes, seconds, milliseconds, and nanoseconds. Takes a DurationInput parameter and returns an object with numeric time components.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Duration-parts.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const parts: (self: DurationInput) => { days: number; hours: number; minutes: number; seconds: number; millis: number; nanos: number; }\n```\n\n----------------------------------------\n\nTITLE: Checking CooperativeYielding RuntimeFlag Status in TypeScript\nDESCRIPTION: Function that checks whether the CooperativeYielding RuntimeFlag is enabled. Returns true if the flag is enabled, false otherwise. This function helps control runtime behavior in the Effect library.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/RuntimeFlags-cooperativeYielding.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const cooperativeYielding: (self: RuntimeFlags) => boolean\n```\n\n----------------------------------------\n\nTITLE: Declaring labelMetricsScoped Function in TypeScript\nDESCRIPTION: Function declaration for labelMetricsScoped that applies MetricLabel objects to metrics within a scoped context. The function returns an Effect that requires a Scope and produces void with no error type. The labels are automatically removed when the scope closes.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-labelMetricsScoped.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const labelMetricsScoped: (labels: ReadonlyArray<MetricLabel.MetricLabel>) => Effect<void, never, Scope.Scope>\n```\n\n----------------------------------------\n\nTITLE: Declaring Number Predicate Signature in TypeScript\nDESCRIPTION: This snippet provides the TypeScript declaration of the isNumber function. The function takes an input of unknown type and returns a boolean indicating whether the input is a number, facilitating type checks using TypeScript's type predicates.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Predicate-isNumber.md#2025-04-11_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const isNumber: (input: unknown) => input is number\n```\n\n----------------------------------------\n\nTITLE: Concatenating Documents with Custom Function in TypeScript\nDESCRIPTION: Demonstrates how to use the `concatWith` function to concatenate documents with a custom binary function. It creates a document by combining characters with spaces between them.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Doc-concatWith.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport * as Doc from \"@effect/printer/Doc\"\nimport { pipe } from \"effect/Function\"\n\nconst doc: Doc.Doc<never> = pipe(\n  [Doc.char(\"a\"), Doc.char(\"b\")],\n  Doc.concatWith((x, y) => Doc.catWithSpace(y)(x))\n)\n\nassert.strictEqual(\n  Doc.render(doc, { style: \"pretty\" }),\n  \"a b\"\n)\n```\n\n----------------------------------------\n\nTITLE: Implementing Unsafe List Tail Operation in TypeScript\nDESCRIPTION: Function declaration for unsafely retrieving the tail of a List data structure. This operation returns all elements except the first one without performing safety checks.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/List-unsafeTail.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const unsafeTail: <A>(self: List<A>) => List<A>\n```\n\n----------------------------------------\n\nTITLE: Getting Order from RedBlackTree - TypeScript\nDESCRIPTION: This snippet declares the getOrder function, which takes a RedBlackTree instance and returns its Order. This function is generic and works with any key and value types represented by K and V. It is essential for users needing to understand the structure's ordering mechanism.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/RedBlackTree-getOrder.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const getOrder: <K, V>(self: RedBlackTree<K, V>) => Order<K>\n```\n\n----------------------------------------\n\nTITLE: RedBlackTree valuesReversed Declaration\nDESCRIPTION: This code snippet shows the TypeScript declaration of the `valuesReversed` function. It takes a `RedBlackTree` as input and returns an `IterableIterator` of the tree's values. The function provides access to the values in reverse insertion order.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/RedBlackTree-valuesReversed.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const valuesReversed: <K, V>(self: RedBlackTree<K, V>) => IterableIterator<V>\n```\n\n----------------------------------------\n\nTITLE: Creating File Parameter with Content Reading in TypeScript\nDESCRIPTION: This code snippet declares a function `fileText` which takes a string parameter `name` representing the file path. It returns an Options type that encapsulates a tuple containing the file path and its content. This enables easy integration of file inputs into CLI commands.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Options-fileText.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const fileText: (name: string) => Options<readonly [path: string, content: string]>;\n```\n\n----------------------------------------\n\nTITLE: Running Sum on Stream with TypeScript\nDESCRIPTION: This snippet declares a function `runSum` that takes a Stream of numeric values and returns an Effect that sums those values. It is a generic function that operates on streams while ensuring type safety for the provided elements. The method leverages the Effect-TS framework, specifically intended for use in functional programming scenarios where handling streams and side effects is crucial. The function is suitable for numeric inputs and returns an Effect which can handle potential errors.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-runSum.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const runSum: <E, R>(self: Stream<number, E, R>) => Effect.Effect<number, E, R>\n```\n\n----------------------------------------\n\nTITLE: Timing Sink Execution with withDuration in TypeScript\nDESCRIPTION: This function takes a sink and returns a new sink that executes the original one while measuring its execution time. The resulting sink returns a tuple containing both the original result and the duration of execution.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Sink-withDuration.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const withDuration: <A, In, L, E, R>(self: Sink<A, In, L, E, R>) => Sink<[A, Duration.Duration], In, L, E, R>\n```\n\n----------------------------------------\n\nTITLE: Stream Suspend Function Definition in TypeScript\nDESCRIPTION: This snippet presents the TypeScript definition of the `Stream.suspend` function. The function takes a `LazyArg` of a `Stream` as input, which allows for the stream to be constructed only when needed. The type parameters `A`, `E`, and `R` represent the stream's element type, error type, and environment type, respectively.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-suspend.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const suspend: <A, E, R>(stream: LazyArg<Stream<A, E, R>>) => Stream<A, E, R>\n```\n\n----------------------------------------\n\nTITLE: Demonstrating BigDecimal Division in TypeScript\nDESCRIPTION: This code snippet demonstrates the usage of the unsafeDivide function from the BigDecimal module. It shows how to perform division operations on BigDecimal values, including cases where the result is an integer and where it's a decimal.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/BigDecimal-unsafeDivide.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { unsafeDivide, unsafeFromString } from \"effect/BigDecimal\"\n\nassert.deepStrictEqual(unsafeDivide(unsafeFromString(\"6\"), unsafeFromString(\"3\")), unsafeFromString(\"2\"))\nassert.deepStrictEqual(unsafeDivide(unsafeFromString(\"6\"), unsafeFromString(\"4\")), unsafeFromString(\"1.5\"))\n```\n\n----------------------------------------\n\nTITLE: Defining Schedule Jittered Interval with Custom Range\nDESCRIPTION: Creates a schedule with customizable randomized delay intervals between min and max multipliers. Allows fine-tuned control over execution timing with optional min and max parameters.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Schedule-jitteredWith.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const jitteredWith: { (options: { min?: number | undefined; max?: number | undefined; }): <Out, In, R>(self: Schedule<Out, In, R>) => Schedule<Out, In, R>; <Out, In, R>(self: Schedule<Out, In, R>, options: { min?: number | undefined; max?: number | undefined; }): Schedule<Out, In, R>; }\n```\n\n----------------------------------------\n\nTITLE: Implementing Auto-Reloading Service in TypeScript using Effect\nDESCRIPTION: Function signature for creating a reloadable service that automatically reloads based on a provided schedule. Takes a context tag and options containing a layer and schedule configuration. Returns a Layer that wraps the service in a Reloadable interface.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Reloadable-auto.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const auto: <I, S, E, In, R>(tag: Context.Tag<I, S>, options: { readonly layer: Layer.Layer<I, E, In>; readonly schedule: Schedule.Schedule<unknown, unknown, R>; }) => Layer.Layer<Reloadable<I>, E, R | In>\n```\n\n----------------------------------------\n\nTITLE: zipWithPrevious Function Signature\nDESCRIPTION: Type declaration for the zipWithPrevious function showing its input and output types. It takes a Stream of type A and returns a Stream of tuples containing Option<A> and A.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-zipWithPrevious.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const zipWithPrevious: <A, E, R>(self: Stream<A, E, R>) => Stream<[Option.Option<A>, A], E, R>\n```\n\n----------------------------------------\n\nTITLE: Defining Metric Interface in TypeScript\nDESCRIPTION: Defines a generic Metric interface for concurrent metrics that can be updated with input type In and produce output type Out. The interface includes methods for unsafe updates, value retrieval, modification, registration, and effect transformation.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Metric-Metric.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface Metric<in out Type, in In, out Out> extends Metric.Variance<Type, In, Out>, Pipeable {\n  /**\n   * The type of the underlying primitive metric. For example, this could be\n   * `MetricKeyType.Counter` or `MetricKeyType.Gauge`.\n   */\n  readonly keyType: Type\n  unsafeUpdate(input: In, extraTags: ReadonlyArray<MetricLabel.MetricLabel>): void\n  unsafeValue(extraTags: ReadonlyArray<MetricLabel.MetricLabel>): Out\n  unsafeModify(input: In, extraTags: ReadonlyArray<MetricLabel.MetricLabel>): void\n  register(): this\n  <A extends In, E, R>(effect: Effect.Effect<A, E, R>): Effect.Effect<A, E, R>\n}\n```\n\n----------------------------------------\n\nTITLE: Signature of isEmptyRecord Function in TypeScript\nDESCRIPTION: The signature declaration for the `isEmptyRecord` function specifies it as a generic function which takes a Record and returns a type predicate indicating if the Record is empty. This helps in leveraging TypeScript's type inference features, allowing for safer type checks within the codebase.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Record-isEmptyRecord.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const isEmptyRecord: <K extends string, A>(self: Record<K, A>) => self is Record<K, never>;\n```\n\n----------------------------------------\n\nTITLE: String.length Function Type Signature\nDESCRIPTION: Type definition for the String.length function showing it accepts a string parameter and returns a number representing the character count.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/String-length.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const length: (self: string) => number\n```\n\n----------------------------------------\n\nTITLE: Implementing Scoped Metrics Tagging in TypeScript with Effect\nDESCRIPTION: A function that enables temporary tagging of metrics within a specific scope. The tags are automatically applied to all metrics within the scope and removed when the scope closes. Takes a key-value pair as parameters and returns an Effect type that requires a Scope.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-tagMetricsScoped.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const tagMetricsScoped: (key: string, value: string) => Effect<void, never, Scope.Scope>\n```\n\n----------------------------------------\n\nTITLE: Function.dual Type Declaration in TypeScript\nDESCRIPTION: The type declaration of the dual function, showing its overloaded signatures. It accepts either an arity number or a predicate function that determines if the function is being used in data-first style, along with the implementation body.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Function-dual.md#2025-04-11_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const dual: { <DataLast extends (...args: Array<any>) => any, DataFirst extends (...args: Array<any>) => any>(arity: Parameters<DataFirst>[\"length\"], body: DataFirst): DataLast & DataFirst; <DataLast extends (...args: Array<any>) => any, DataFirst extends (...args: Array<any>) => any>(isDataFirst: (args: IArguments) => boolean, body: DataFirst): DataLast & DataFirst; }\n```\n\n----------------------------------------\n\nTITLE: Declaration of getOrder Function for Option Type\nDESCRIPTION: This declaration defines the generic function `getOrder` which takes an Order instance for an inner type and returns an Order instance specifically for the Option type. It is a crucial part of the Option module that enables type-safe comparisons of Option values.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Option-getOrder.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const getOrder: <A>(O: Order<A>) => Order<Option<A>>\n```\n\n----------------------------------------\n\nTITLE: STM Loop Implementation in Typescript\nDESCRIPTION: The STM.loop function allows looping with a transactional function, accumulating the results. It takes an initial value and an options object defining the loop's continuation condition, increment step, and the body function to execute within each iteration. The 'discard' option controls whether to collect the results or not.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/STM-loop.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const loop: { <Z, A, E, R>(initial: Z, options: { readonly while: (z: Z) => boolean; readonly step: (z: Z) => Z; readonly body: (z: Z) => STM<A, E, R>; readonly discard?: false | undefined; }): STM<Array<A>, E, R>; <Z, A, E, R>(initial: Z, options: { readonly while: (z: Z) => boolean; readonly step: (z: Z) => Z; readonly body: (z: Z) => STM<A, E, R>; readonly discard: true; }): STM<void, E, R>; }\n```\n\n----------------------------------------\n\nTITLE: Declaring cursorShow Function in TypeScript\nDESCRIPTION: This code snippet declares a constant cursorShow of type Ansi. The function is used to show the cursor in ANSI-compatible terminals. It's part of the @effect/printer-ansi package and has been available since version 1.0.0.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Ansi-cursorShow.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const cursorShow: Ansi\n```\n\n----------------------------------------\n\nTITLE: Stream.zipAllWith Type Signature\nDESCRIPTION: TypeScript type signature for the zipAllWith function showing its polymorphic nature and type parameters. The signature includes overloads for different usage patterns and preserves type safety across stream combinations.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-zipAllWith.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const zipAllWith: { <A2, E2, R2, A, A3>(options: { readonly other: Stream<A2, E2, R2>; readonly onSelf: (a: A) => A3; readonly onOther: (a2: A2) => A3; readonly onBoth: (a: A, a2: A2) => A3; }): <E, R>(self: Stream<A, E, R>) => Stream<A3, E2 | E, R2 | R>; <A, E, R, A2, E2, R2, A3>(self: Stream<A, E, R>, options: { readonly other: Stream<A2, E2, R2>; readonly onSelf: (a: A) => A3; readonly onOther: (a2: A2) => A3; readonly onBoth: (a: A, a2: A2) => A3; }): Stream<A3, E | E2, R | R2>; }\n```\n\n----------------------------------------\n\nTITLE: Writing Chunk to Channel in TypeScript\nDESCRIPTION: The writeChunk function is used to write a Chunk of values to a channel. It takes a Chunk of OutElem type and returns a Channel of OutElem type. This function is part of the Channel module in the effect package.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Channel-writeChunk.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const writeChunk: <OutElem>(outs: Chunk.Chunk<OutElem>) => Channel<OutElem>\n```\n\n----------------------------------------\n\nTITLE: Retrieving First Entry from RedBlackTree in TypeScript\nDESCRIPTION: A method that returns the first (leftmost) key-value pair in a Red-Black Tree data structure. Returns an Option type containing a tuple of key and value if the tree is not empty.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/RedBlackTree-first.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const first: <K, V>(self: RedBlackTree<K, V>) => Option<[K, V]>\n```\n\n----------------------------------------\n\nTITLE: Declaring Stream.onDone Function in TypeScript\nDESCRIPTION: Defines the onDone function for the Stream module. This function runs a specified effect when the stream ends. It takes a cleanup effect as an argument and returns a new stream that includes the cleanup operation.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-onDone.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const onDone: { <X, R2>(cleanup: () => Effect.Effect<X, never, R2>): <A, E, R>(self: Stream<A, E, R>) => Stream<A, E, R2 | R>; <A, E, R, X, R2>(self: Stream<A, E, R>, cleanup: () => Effect.Effect<X, never, R2>): Stream<A, E, R | R2>; }\n```\n\n----------------------------------------\n\nTITLE: Filter Signature for Option in TypeScript\nDESCRIPTION: The signature for the filter function is defined to specify various overloads available, showcasing how it can handle different predicates and types of Option, enhancing type safety and utility for refinement of values.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Option-filter.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const filter: { <A, B extends A>(refinement: Refinement<NoInfer<A>, B>): (self: Option<A>) => Option<B>; <A>(predicate: Predicate<NoInfer<A>>): (self: Option<A>) => Option<A>; <A, B extends A>(self: Option<A>, refinement: Refinement<A, B>): Option<B>; <A>(self: Option<A>, predicate: Predicate<A>): Option<A>; }\n```\n\n----------------------------------------\n\nTITLE: Declaring isNever predicate in Effect\nDESCRIPTION: This snippet shows the type signature declaration for the `isNever` predicate within the Effect library. It defines `isNever` as a function that takes an `unknown` input and returns a boolean, indicating whether the input is of type `never`. However, the function always returns `false` in its implementation.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Predicate-isNever.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const isNever: (input: unknown) => input is never\n```\n\n----------------------------------------\n\nTITLE: Creating Failed Fiber with Cause in TypeScript\nDESCRIPTION: The failCause function creates a Fiber that has already failed with the specified cause. It takes a Cause<E> as an argument and returns a Fiber<never, E>. This function is useful for creating pre-failed Fibers in effect-based systems.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Fiber-failCause.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const failCause: <E>(cause: Cause.Cause<E>) => Fiber<never, E>\n```\n\n----------------------------------------\n\nTITLE: Implementing Boolean NOR Operation in TypeScript\nDESCRIPTION: The nor function combines two boolean values using the logical NOR operation (!(self || that)). It returns true only when both input values are false.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Boolean-nor.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { nor } from \"effect/Boolean\"\n\nassert.deepStrictEqual(nor(true, true), false)\nassert.deepStrictEqual(nor(true, false), false)\nassert.deepStrictEqual(nor(false, true), false)\nassert.deepStrictEqual(nor(false, false), true)\n```\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const nor: { (that: boolean): (self: boolean) => boolean; (self: boolean, that: boolean): boolean; }\n```\n\n----------------------------------------\n\nTITLE: Checking if a TPubSub is Empty using STM in TypeScript\nDESCRIPTION: A function that returns true if the TPubSub contains zero elements, false otherwise. It operates within the STM (Software Transactional Memory) context to ensure transactional safety.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TPubSub-isEmpty.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const isEmpty: <A>(self: TPubSub<A>) => STM.STM<boolean>\n```\n\n----------------------------------------\n\nTITLE: Running a Channel with Scope Management in TypeScript\nDESCRIPTION: Function signature for running a channel until it finishes or fails. The function ensures that closing the channel (including finalizers) is added to the current scope as a finalizer. The channel must not require input or produce output.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Channel-runScoped.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const runScoped: <OutErr, InErr, OutDone, InDone, Env>(self: Channel<never, unknown, OutErr, InErr, OutDone, InDone, Env>) => Effect.Effect<OutDone, OutErr, Env | Scope.Scope>\n```\n\n----------------------------------------\n\nTITLE: Defining Pool Type Guard in TypeScript\nDESCRIPTION: The 'isPool' function is a type guard that checks if a given value is an instance of the Pool type. It accepts an unknown type parameter 'u' and returns a boolean indicating whether 'u' is a Pool. This function is primarily used for type checking in TypeScript and helps to enforce type safety during runtime.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Pool-isPool.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const isPool: (u: unknown) => u is Pool<unknown, unknown>\n```\n\n----------------------------------------\n\nTITLE: Declaring BooleanFromUnknown Class in TypeScript\nDESCRIPTION: Defines the BooleanFromUnknown class which converts arbitrary values to booleans using truthy coercion. It uses the !!val syntax to perform the conversion.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Schema-BooleanFromUnknown.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare class BooleanFromUnknown\n```\n\n----------------------------------------\n\nTITLE: Signature of fromEffect Method - TypeScript\nDESCRIPTION: This snippet provides the TypeScript type declaration for the fromEffect method in the Effect-TS library. It outlines the generic types A, E, and R, representing the success type, failure type, and the execution environment, respectively. This signature is crucial for understanding how to utilize the fromEffect method within TypeScript.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-fromEffect.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const fromEffect: <A, E, R>(effect: Effect.Effect<A, E, R>) => Stream<A, E, R>\n```\n\n----------------------------------------\n\nTITLE: Creating FiberSet-backed Runtime Function in TypeScript\nDESCRIPTION: This function creates an Effect run function that is backed by a FiberSet. It allows for running effects and managing their execution as fibers, returning a RuntimeFiber that can be used for fiber management operations.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/FiberSet-makeRuntime.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const makeRuntime: <R = never, A = unknown, E = unknown>() => Effect.Effect<(<XE extends E, XA extends A>(effect: Effect.Effect<XA, XE, R>, options?: Runtime.RunForkOptions | undefined) => Fiber.RuntimeFiber<XA, XE>), never, Scope.Scope | R>\n```\n\n----------------------------------------\n\nTITLE: Combining Differs with zip Function in TypeScript\nDESCRIPTION: The zip function combines two differs to produce a new differ that can process the product of their values. It supports both curried and uncurried calling styles, taking either one or two differ parameters.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Differ-zip.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const zip: { <Value2, Patch2>(that: Differ<Value2, Patch2>): <Value, Patch>(self: Differ<Value, Patch>) => Differ<readonly [Value, Value2], readonly [Patch, Patch2]>; <Value, Patch, Value2, Patch2>(self: Differ<Value, Patch>, that: Differ<Value2, Patch2>): Differ<readonly [Value, Value2], readonly [Patch, Patch2]>; }\n```\n\n----------------------------------------\n\nTITLE: Testing the isMap Functionality with Assertions\nDESCRIPTION: This code snippet demonstrates how to use the 'isMap' function to assert different values against expected boolean outcomes. It requires the 'assert' module from Node.js and the 'isMap' function from the effect package. The expected input includes various types of data, such as a Map instance, an object, and null/undefined, which should yield true or false based on whether they are Maps.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Predicate-isMap.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { isMap } from \"effect/Predicate\"\n\nassert.deepStrictEqual(isMap(new Map()), true)\nassert.deepStrictEqual(isMap({}), false)\nassert.deepStrictEqual(isMap(null), false)\nassert.deepStrictEqual(isMap(undefined), false)\n```\n\n----------------------------------------\n\nTITLE: Converting Fiber to Scoped Effect in TypeScript\nDESCRIPTION: The 'scoped' function converts a fiber into a scoped effect. The fiber is interrupted when the scope is closed. It takes a Fiber<A, E> as input and returns an Effect that produces a Fiber<A, E> and requires a Scope.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Fiber-scoped.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const scoped: <A, E>(self: Fiber<A, E>) => Effect.Effect<Fiber<A, E>, never, Scope.Scope>\n```\n\n----------------------------------------\n\nTITLE: Constructing Interval in TypeScript using Effect\nDESCRIPTION: The `after` function constructs an Interval that includes all times equal to and after the specified start milliseconds. It is part of the `ScheduleInterval` module within the `effect` package, introduced since version 2.0.0. The function requires a single parameter, `startMilliseconds`, which specifies the starting point of the interval. The expected output is an Interval object.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/ScheduleInterval-after.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const after: (startMilliseconds: number) => Interval\n```\n\n----------------------------------------\n\nTITLE: Implementing Error Ignore Function in Effect IO Micro Module\nDESCRIPTION: Function signature for ignore method that takes a Micro effect and returns a new Micro effect with void output and no error channel. Used to ignore expected errors from Micro effects.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Micro-ignore.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const ignore: <A, E, R>(self: Micro<A, E, R>) => Micro<void, never, R>\n```\n\n----------------------------------------\n\nTITLE: Implementing List.map Function in TypeScript\nDESCRIPTION: Defines a 'map' function that applies a mapping function to each element of a list. It supports both curried and non-curried versions, allowing for flexible usage in functional programming paradigms.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/List-map.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const map: { <S extends List<any>, B>(f: (a: List.Infer<S>, i: number) => B): (self: S) => List.With<S, B>; <S extends List<any>, B>(self: S, f: (a: List.Infer<S>, i: number) => B): List.With<S, B>; }\n```\n\n----------------------------------------\n\nTITLE: Defining Boolean Primitive in TypeScript for @effect/cli\nDESCRIPTION: This code snippet defines a boolean primitive type for the @effect/cli package. It accepts an optional default value and returns a Primitive<boolean>. The function supports various string inputs for true and false values.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Primitive-boolean.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const boolean: (defaultValue: Option<boolean>) => Primitive<boolean>\n```\n\n----------------------------------------\n\nTITLE: Creating a Minimum-based Monoid from a Bounded Order in TypeScript\nDESCRIPTION: The min function creates a monoid where the combine operation returns the minimum of two values based on a provided bounded order. The empty value defaults to the maxBound value of the bounded order.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Monoid-min.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const min: <A>(B: Bounded<A>) => Monoid<A>\n```\n\n----------------------------------------\n\nTITLE: Demonstrating List.prependAll Usage in TypeScript\nDESCRIPTION: Example showing how to prepend one list to another using the List.prependAll function. The example demonstrates combining a list of strings with a list of numbers.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/List-prependAll.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { List } from \"effect\"\n\nassert.deepStrictEqual(\n  List.make(1, 2).pipe(List.prependAll(List.make(\"a\", \"b\")), List.toArray),\n  [\"a\", \"b\", 1, 2]\n)\n```\n\n----------------------------------------\n\nTITLE: Declaring Schema Equivalence - Effect-TS - TypeScript\nDESCRIPTION: This TypeScript snippet declares a function 'equivalence' that returns an 'Equivalence' instance for a given 'Schema'. It highlights how a schema in the Effect-TS framework can be used to establish equality logic between values of type 'A'. Requires 'Schema' and 'Equivalence' as dependencies. The function accepts a schema of generic type parameters A, I, and R, and it outputs an equivalence relation for type A.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Schema-equivalence.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const equivalence: <A, I, R>(schema: Schema<A, I, R>) => Equivalence.Equivalence<A>\n```\n\n----------------------------------------\n\nTITLE: Creating a Monoid for struct values in TypeScript\nDESCRIPTION: This function creates a new Monoid for a struct by combining individual Monoid instances for each property. It allows combining two structs by applying the corresponding Monoid to each property. The empty value is a struct with each property set to the empty value of its Monoid.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Monoid-struct.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const struct: <R extends { readonly [x: string]: Monoid<any>; }>(fields: R) => Monoid<{ readonly [K in keyof R]: [R[K]] extends [Monoid<infer A>] ? A : never; }>\n```\n\n----------------------------------------\n\nTITLE: Transforming Exit Success Values to Void in TypeScript\nDESCRIPTION: A utility function that takes an Exit instance with success type A and error type E, and returns a new Exit instance where successful values are mapped to void while preserving the error type. Used for cases where the success value needs to be discarded while maintaining error handling.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Exit-asVoid.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const asVoid: <A, E>(self: Exit<A, E>) => Exit<void, E>\n```\n\n----------------------------------------\n\nTITLE: Take.fromPull Function Definition\nDESCRIPTION: This TypeScript code defines the `fromPull` function, which transforms an `Effect` that potentially yields chunks of data or an optional error into an `Effect` that yields `Take` values.  The input `Effect` is expected to produce `Chunk<A>` on success or `Option<E>` on failure. The function returns an `Effect` that resolves to `Take<A, E>`. Errors are converted to `Take.failCause`, and end of stream is mapped to `Take.end`.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Take-fromPull.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const fromPull: <A, E, R>(pull: Effect.Effect<Chunk.Chunk<A>, Option.Option<E>, R>) => Effect.Effect<Take<A, E>, never, R>\n```\n\n----------------------------------------\n\nTITLE: Implementing unsafeGet Function for Array Access in TypeScript\nDESCRIPTION: Defines an unsafeGet function that retrieves an element from an array at a specified index without bounds checking. This function will throw an error if the index is out of bounds. It provides two calling patterns: curried and uncurried versions.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Array-unsafeGet.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const unsafeGet: { (index: number): <A>(self: ReadonlyArray<A>) => A; <A>(self: ReadonlyArray<A>, index: number): A; }\n```\n\n----------------------------------------\n\nTITLE: Converting TMap to Array in Software Transactional Memory (TypeScript)\nDESCRIPTION: The `toArray` function collects all key-value bindings from a `TMap` into an `Array`. It operates within the STM (Software Transactional Memory) context, returning an STM effect that resolves to an array of key-value tuples.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TMap-toArray.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const toArray: <K, V>(self: TMap<K, V>) => STM.STM<Array<[K, V]>>\n```\n\n----------------------------------------\n\nTITLE: Implementing Sink.as Method in TypeScript\nDESCRIPTION: Defines a type-safe method for replacing a sink's result value with a new value. The method supports both curried and uncurried forms, maintaining type safety across transformations.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Sink-as.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const as: {\n  <A2>(a: A2): <A, In, L, E, R>(self: Sink<A, In, L, E, R>) => Sink<A2, In, L, E, R>;\n  <A, In, L, E, R, A2>(self: Sink<A, In, L, E, R>, a: A2): Sink<A2, In, L, E, R>;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing a folding sink for chunk processing in TypeScript\nDESCRIPTION: Creates a sink that folds input chunks using a provided function, termination predicate, and initial state. The continuation function is checked at the initial value and after processing each chunk. Both functions must preserve chunking-invariance.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Sink-foldChunks.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const foldChunks: <S, In>(s: S, contFn: Predicate<S>, f: (s: S, chunk: Chunk.Chunk<In>) => S) => Sink<S, In>\n```\n\n----------------------------------------\n\nTITLE: Creating NonEmptyArray in TypeScript using Array.of\nDESCRIPTION: TypeScript function signature for creating a NonEmptyArray from a single value. The function takes a value of type A and returns a NonEmptyArray containing that value as its sole element.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Array-of.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const of: <A>(a: A) => NonEmptyArray<A>\n```\n\n----------------------------------------\n\nTITLE: Creating Iterable from Single Value in TypeScript\nDESCRIPTION: Function signature for creating a new Iterable<A> from a single value. Takes a value of type A and returns an Iterable containing that value.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Iterable-of.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const of: <A>(a: A) => Iterable<A>\n```\n\n----------------------------------------\n\nTITLE: BigDecimal greaterThanOrEqualTo Function Signature\nDESCRIPTION: TypeScript type declaration for the greaterThanOrEqualTo function. Supports both curried and non-curried function calls, accepting BigDecimal parameters and returning a boolean result.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/BigDecimal-greaterThanOrEqualTo.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const greaterThanOrEqualTo: { (that: BigDecimal): (self: BigDecimal) => boolean; (self: BigDecimal, that: BigDecimal): boolean; }\n```\n\n----------------------------------------\n\nTITLE: Converting DateTime to Nearest Time Unit in TypeScript\nDESCRIPTION: Demonstrates how to use DateTime.nearest to convert a DateTime object to the nearest given time unit. In this example, a DateTime is rounded to the nearest day, resulting in a date-time at midnight.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/DateTime-nearest.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { DateTime } from \"effect\"\n\n// returns \"2024-01-02T00:00:00Z\"\nDateTime.unsafeMake(\"2024-01-01T12:01:00Z\").pipe(\n  DateTime.nearest(\"day\"),\n  DateTime.formatIso\n)\n```\n\n----------------------------------------\n\nTITLE: Doc.list Function Signature in TypeScript\nDESCRIPTION: This code snippet shows the TypeScript signature for the Doc.list function. It takes an iterable of Doc<A> and returns a Doc<A>.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Doc-list.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const list: <A>(docs: Iterable<Doc<A>>) => Doc<A>\n```\n\n----------------------------------------\n\nTITLE: Creating a Micro Effect that Succeeds - TypeScript\nDESCRIPTION: This snippet defines a function `succeed` which creates a Micro effect that returns a constant value provided as an argument. The function is a generic type which can accept any value type. It is crucial for defining constant results in asynchronous systems.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Micro-succeed.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const succeed: <A>(value: A) => Micro<A>\n```\n\n----------------------------------------\n\nTITLE: Getting Values from ScopedRef in TypeScript\nDESCRIPTION: Function signature for retrieving the current value from a scoped reference. The function takes a ScopedRef<A> parameter and returns an Effect containing the value of type A.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/ScopedRef-get.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const get: <A>(self: ScopedRef<A>) => Effect.Effect<A>\n```\n\n----------------------------------------\n\nTITLE: Checking Key Existence in FiberMap with unsafeHas Function in TypeScript\nDESCRIPTION: The unsafeHas function checks if a given key exists in a FiberMap. It provides two call signatures: one for curried usage and another for direct application with both arguments. This function allows for checking the presence of keys without necessarily retrieving the associated fiber.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/FiberMap-unsafeHas.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const unsafeHas: { <K>(key: K): <A, E>(self: FiberMap<K, A, E>) => boolean; <K, A, E>(self: FiberMap<K, A, E>, key: K): boolean; }\n```\n\n----------------------------------------\n\nTITLE: Array.dedupeWith Type Definition\nDESCRIPTION: TypeScript type signature for the dedupeWith function, supporting both regular arrays and non-empty arrays with custom equivalence comparison.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Array-dedupeWith.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const dedupeWith: { <S extends Iterable<any>>(isEquivalent: (self: ReadonlyArray.Infer<S>, that: ReadonlyArray.Infer<S>) => boolean): (self: S) => ReadonlyArray.With<S, ReadonlyArray.Infer<S>>; <A>(self: NonEmptyReadonlyArray<A>, isEquivalent: (self: A, that: A) => boolean): NonEmptyArray<A>; <A>(self: Iterable<A>, isEquivalent: (self: A, that: A) => boolean): Array<A>; }\n```\n\n----------------------------------------\n\nTITLE: Checking if RuntimeFlag is Enabled in TypeScript\nDESCRIPTION: The isEnabled function accepts a RuntimeFlag and returns a function that checks if that flag is enabled in a RuntimeFlags instance. It also supports a curried version that takes both parameters at once.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/RuntimeFlags-isEnabled.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const isEnabled: { (flag: RuntimeFlag): (self: RuntimeFlags) => boolean; (self: RuntimeFlags, flag: RuntimeFlag): boolean; }\n```\n\n----------------------------------------\n\nTITLE: Array Copy Example Usage in TypeScript\nDESCRIPTION: Demonstrates how to use Array.copy to create a copy of an array. The function returns a new array with the same elements as the input array.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Array-copy.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Array } from \"effect\"\n\nconst result = Array.copy([1, 2, 3])\nconsole.log(result) // [1, 2, 3]\n```\n\n----------------------------------------\n\nTITLE: Implementing Chunk.takeRight in TypeScript\nDESCRIPTION: Function signature for taking the last n elements from a Chunk. Supports both curried and non-curried function calls, operating on Chunk<A> type and returning a new Chunk with only the last n elements.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Chunk-takeRight.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const takeRight: { (n: number): <A>(self: Chunk<A>) => Chunk<A>; <A>(self: Chunk<A>, n: number): Chunk<A>; }\n```\n\n----------------------------------------\n\nTITLE: Initializing an Empty MutableHashSet in TypeScript\nDESCRIPTION: Creates an empty mutable hash set with specified element type. This function initializes a MutableHashSet instance that allows for efficient storage and manipulation of unique elements with O(1) time complexity.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/MutableHashSet-empty.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { MutableHashSet } from \"effect\"\n\ntype T = unknown // replace with your type\n\n// in places where the type can't be inferred, replace with your type\nconst set: MutableHashSet.MutableHashSet<T> = MutableHashSet.empty<T>()\n```\n\n----------------------------------------\n\nTITLE: Defining Never-Completing Fiber in TypeScript\nDESCRIPTION: Defines a constant 'never' that represents a Fiber that neither fails nor succeeds. This is useful for representing computations that run indefinitely or for testing scenarios where you need a permanently pending fiber.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Fiber-never.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const never: Fiber<never, never>\n```\n\n----------------------------------------\n\nTITLE: Checking if a value is a RequestResolver in TypeScript\nDESCRIPTION: The isRequestResolver function returns true if the specified value is a RequestResolver, false otherwise. It performs a type check and provides type narrowing in TypeScript.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/RequestResolver-isRequestResolver.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const isRequestResolver: (u: unknown) => u is RequestResolver<unknown, unknown>\n```\n\n----------------------------------------\n\nTITLE: Declaring Greater Than or Equal To Filter in TypeScript\nDESCRIPTION: This TypeScript declaration creates a filter function to check if a number is greater than or equal to a specified minimum. The function uses generics to provide flexibility for different schema types and supports optional annotations for enhanced type safety.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Schema-greaterThanOrEqualTo.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const greaterThanOrEqualTo: <S extends Schema.Any>(minimum: number, annotations?: Annotations.Filter<Schema.Type<S>>) => <A extends number>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>) => filter<S>\n```\n\n----------------------------------------\n\nTITLE: Accessing Sink Context with Effect in TypeScript\nDESCRIPTION: The `contextWithEffect` function allows you to access the context of a sink and use it within an Effect. It takes a function `f` that receives the context of type `Context.Context<R0>` and returns an `Effect.Effect<A, E, R>`. This allows you to perform operations within an Effect that depend on the context of the sink.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Sink-contextWithEffect.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const contextWithEffect: <R0, A, E, R>(f: (context: Context.Context<R0>) => Effect.Effect<A, E, R>) => Sink<A, unknown, never, E, R0 | R>\n```\n\n----------------------------------------\n\nTITLE: Declaring BigInt Clamping Function in Schema - TypeScript\nDESCRIPTION: This TypeScript snippet declares a function 'clampBigInt' which limits a BigInt value between defined minimum and maximum bounds. It utilizes a schema transformation logic to apply these constraints. The function is part of the 'effect' package, and is designed to be used within Schema transformations, depending on the existence of a Schema of type BigInt.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Schema-clampBigInt.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const clampBigInt: (minimum: bigint, maximum: bigint) => <S extends Schema.Any, A extends bigint>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>) => transform<S, filter<SchemaClass<A>>>\n```\n\n----------------------------------------\n\nTITLE: Either.isEither Function Signature in TypeScript\nDESCRIPTION: Provides the TypeScript type signature for the Either.isEither function. It takes an unknown input and returns a boolean indicating whether the input is an Either of unknown types.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Either-isEither.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const isEither: (input: unknown) => input is Either<unknown, unknown>\n```\n\n----------------------------------------\n\nTITLE: Using cartesianWith to Create Cartesian Products of Arrays in TypeScript\nDESCRIPTION: This snippet demonstrates how to use the Array.cartesianWith function to combine elements from two arrays. The function applies a specified combiner function to each pair of elements from the two arrays, creating all possible combinations.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Array-cartesianWith.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Array } from \"effect\"\n\nconst result = Array.cartesianWith([1, 2], [\"a\", \"b\"], (a, b) => `${a}-${b}`)\nconsole.log(result) // [\"1-a\", \"1-b\", \"2-a\", \"2-b\"]\n```\n\n----------------------------------------\n\nTITLE: Accessing Current Time in Milliseconds with TestClock in TypeScript\nDESCRIPTION: This code snippet defines a constant 'currentTimeMillis' that represents an Effect for accessing the current time of a TestClock instance in milliseconds. It returns a number and has no requirements or errors.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TestClock-currentTimeMillis.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const currentTimeMillis: Effect.Effect<number, never, never>\n```\n\n----------------------------------------\n\nTITLE: Type Signature for DateTime.mapEpochMillis in TypeScript\nDESCRIPTION: The type signature for the mapEpochMillis function shows it can be used with either parameter order (curried or method style). It accepts a function that transforms milliseconds and returns a new DateTime of the same type.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/DateTime-mapEpochMillis.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const mapEpochMillis: { (f: (millis: number) => number): <A extends DateTime>(self: A) => A; <A extends DateTime>(self: A, f: (millis: number) => number): A; }\n```\n\n----------------------------------------\n\nTITLE: Constructing a Dying Layer in TypeScript\nDESCRIPTION: The 'die' function creates a layer that dies with a specified defect. It takes an unknown type as the defect parameter and returns a Layer of unknown type.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Layer-die.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const die: (defect: unknown) => Layer<unknown>\n```\n\n----------------------------------------\n\nTITLE: Defining BigIntFromNumber Schema in TypeScript\nDESCRIPTION: This schema transforms a number into a bigint by parsing the number using the BigInt function. It returns an error if the value can't be safely encoded as a number due to being out of range.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Schema-BigIntFromNumber.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare class BigIntFromNumber\n```\n\n----------------------------------------\n\nTITLE: Implementing Document Annotation in TypeScript\nDESCRIPTION: Function signature for annotate method that adds annotations to a Doc object. The function is overloaded to support both curried and standard parameter passing styles. Annotations can be used by rendering algorithms for custom formatting like adding colors.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Doc-annotate.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const annotate: { <A>(annotation: A): (self: Doc<A>) => Doc<A>; <A>(self: Doc<A>, annotation: A): Doc<A>; }\n```\n\n----------------------------------------\n\nTITLE: Defining Sink.count Functionality in TypeScript\nDESCRIPTION: This code snippet declares a constant 'count', which represents a Sink capable of counting the number of elements that are fed into it. It is typed to accept numbers as input and does not produce any output or error handling. This functionality is part of the Effect-TS library since version 2.0.0.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Sink-count.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const count: Sink<number, unknown, never, never, never>\n```\n\n----------------------------------------\n\nTITLE: Type Signature for Doc.surround Function in TypeScript\nDESCRIPTION: The type signature for the 'surround' combinator function, showing its polymorphic nature and how it can be used both in pipeline style and with direct application.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Doc-surround.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const surround: { <A, B, C>(left: Doc<A>, right: Doc<B>): (self: Doc<C>) => Doc<A | B | C>; <A, B, C>(self: Doc<C>, left: Doc<A>, right: Doc<B>): Doc<A | B | C>; }\n```\n\n----------------------------------------\n\nTITLE: Effect.makeSemaphore Function Signature\nDESCRIPTION: Type declaration for the makeSemaphore function, showing it takes a number parameter for permits and returns an Effect of Semaphore.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-makeSemaphore.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const makeSemaphore: (permits: number) => Effect<Semaphore>\n```\n\n----------------------------------------\n\nTITLE: Function Signature for Effect.dropWhile in TypeScript\nDESCRIPTION: The TypeScript signature for the dropWhile function, showing both the curried and uncurried overloads. It takes a predicate function that returns an Effect of boolean, and operates on an Iterable.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-dropWhile.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const dropWhile: { <A, E, R>(predicate: (a: NoInfer<A>, i: number) => Effect<boolean, E, R>): (elements: Iterable<A>) => Effect<Array<A>, E, R>; <A, E, R>(elements: Iterable<A>, predicate: (a: A, i: number) => Effect<boolean, E, R>): Effect<Array<A>, E, R>; }\n```\n\n----------------------------------------\n\nTITLE: SemiProduct.productManyComposition in Effect TS\nDESCRIPTION: Defines a default `productMany` composition using `SemiApplicative` and `SemiProduct`. This function combines a `SemiApplicative` instance `F` and a `SemiProduct` instance `G` to produce a new function that can apply the `productMany` operation to kinds constructed with `F` and `G`.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/SemiProduct-productManyComposition.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const productManyComposition: <F extends TypeLambda, G extends TypeLambda>(F: SemiApplicative<F>, G: SemiProduct<G>) => <FR, FO, FE, GR, GO, GE, A>(self: Kind<F, FR, FO, FE, Kind<G, GR, GO, GE, A>>, collection: Iterable<Kind<F, FR, FO, FE, Kind<G, GR, GO, GE, A>>>) => Kind<F, FR, FO, FE, Kind<G, GR, GO, GE, [A, ...Array<A>]>>\n```\n\n----------------------------------------\n\nTITLE: Array.unprepend Function Signature in TypeScript\nDESCRIPTION: The type signature for the unprepend function, which takes a non-empty array and returns a tuple containing the first element and an array of the remaining elements.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Array-unprepend.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const unprepend: <A>(self: NonEmptyReadonlyArray<A>) => [firstElement: A, remainingElements: Array<A>]\n```\n\n----------------------------------------\n\nTITLE: Using Doc.empty with vsep in TypeScript\nDESCRIPTION: Demonstrates how Doc.empty behaves inside a vertical separation layout. The empty document is visible (with parentheses for clarity) and creates its own line in the output, showing that empty documents have a height of 1.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Doc-empty.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport * as Doc from \"@effect/printer/Doc\"\nimport * as String from \"effect/String\"\n\nconst doc = Doc.vsep([\n  Doc.text(\"hello\"),\n  // `parentheses` for visibility purposes only\n  Doc.parenthesized(Doc.empty),\n  Doc.text(\"world\")\n])\n\nconst expected = `|hello\n                  |()\n                  |world`\n\nassert.strictEqual(\n  Doc.render(doc, { style: \"pretty\" }),\n  String.stripMargin(expected)\n)\n```\n\n----------------------------------------\n\nTITLE: Defining CommandOutput Type in TypeScript\nDESCRIPTION: Defines a type that configures how stdout and stderr streams are handled between parent and child processes. Options include inheriting from parent process, using a pipe, or using a custom Sink for Uint8Array data.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Command-CommandOutput.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ntype CommandOutput = \"inherit\" | \"pipe\" | Sink<Uint8Array, Uint8Array>\n```\n\n----------------------------------------\n\nTITLE: Creating a Stream from a Chunk PubSub in TypeScript\nDESCRIPTION: The `fromChunkPubSub` function creates a stream from a `PubSub` that emits chunks. It accepts a `PubSub` instance and optional settings. The `scoped` option (if set to `true`) integrates the stream's lifecycle with a `Scope`, automatically managing resources.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-fromChunkPubSub.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const fromChunkPubSub: { <A>(pubsub: PubSub.PubSub<Chunk.Chunk<A>>, options: { readonly scoped: true; readonly shutdown?: boolean | undefined; }): Effect.Effect<Stream<A>, never, Scope.Scope>; <A>(pubsub: PubSub.PubSub<Chunk.Chunk<A>>, options?: { readonly scoped?: false | undefined; readonly shutdown?: boolean | undefined; } | undefined): Stream<A>; }\n```\n\n----------------------------------------\n\nTITLE: Defining Chunk.every Function Signature in TypeScript\nDESCRIPTION: This code snippet defines the signature for the Chunk.every function. It allows checking if a predicate or refinement holds true for every element in a Chunk. The function is overloaded to handle different use cases and parameter orders.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Chunk-every.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const every: {\n  <A, B extends A>(refinement: Refinement<NoInfer<A>, B>): (self: Chunk<A>) => self is Chunk<B>;\n  <A>(predicate: Predicate<A>): (self: Chunk<A>) => boolean;\n  <A, B extends A>(self: Chunk<A>, refinement: Refinement<A, B>): self is Chunk<B>;\n  <A>(self: Chunk<A>, predicate: Predicate<A>): boolean;\n}\n```\n\n----------------------------------------\n\nTITLE: Constructing a Differ Instance in TypeScript\nDESCRIPTION: The make function creates a new Differ instance with custom behavior for diffing, combining, and patching values. It takes an object with four properties: empty (initial patch), diff (compares old and new values), combine (merges patches), and patch (applies a patch to a value).\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Differ-make.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const make: <Value, Patch>(params: { readonly empty: Patch; readonly diff: (oldValue: Value, newValue: Value) => Patch; readonly combine: (first: Patch, second: Patch) => Patch; readonly patch: (patch: Patch, oldValue: Value) => Value; }) => Differ<Value, Patch>\n```\n\n----------------------------------------\n\nTITLE: Incrementing BigInt Values Example\nDESCRIPTION: Demonstrates how to use the increment function from effect/BigInt module to add 1n to a BigInt value. The example shows importing the function and basic usage with assertion.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/BigInt-increment.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { increment } from \"effect/BigInt\"\n\nassert.deepStrictEqual(increment(2n), 3n)\n```\n\n----------------------------------------\n\nTITLE: Defining Schedule.mapInputEffect TypeScript Function\nDESCRIPTION: Allows transforming schedule input types through an effectful function that converts inputs asynchronously or with side effects. Supports scenarios requiring complex input preprocessing before schedule execution.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Schedule-mapInputEffect.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const mapInputEffect: { <In2, In, R2>(f: (in2: In2) => Effect.Effect<In, never, R2>): <Out, R>(self: Schedule<Out, In, R>) => Schedule<Out, In2, R2 | R>; <Out, In, R, In2, R2>(self: Schedule<Out, In, R>, f: (in2: In2) => Effect.Effect<In, never, R2>): Schedule<Out, In2, R | R2>; }\n```\n\n----------------------------------------\n\nTITLE: Creating Integer Arguments in Effect CLI\nDESCRIPTION: The integer function creates an integer argument in a command-line interface. It accepts an optional configuration object and returns an Args type with number as the value type. By default, the argument name is 'integer' but can be customized through the config parameter.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Args-integer.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const integer: (config?: Args.BaseArgsConfig) => Args<number>\n```\n\n----------------------------------------\n\nTITLE: Stream.onEnd Function Signature in TypeScript\nDESCRIPTION: The type signature of the Stream.onEnd function, showing its polymorphic nature and how it can be used with different stream and effect types.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-onEnd.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const onEnd: { <_, E2, R2>(effect: Effect.Effect<_, E2, R2>): <A, E, R>(self: Stream<A, E, R>) => Stream<A, E2 | E, R2 | R>; <A, E, R, _, E2, R2>(self: Stream<A, E, R>, effect: Effect.Effect<_, E2, R2>): Stream<A, E | E2, R | R2>; }\n```\n\n----------------------------------------\n\nTITLE: Stream.intersperse Function Signature in TypeScript\nDESCRIPTION: This code snippet shows the TypeScript signature for the Stream.intersperse function. It defines two overloads for the function, allowing it to be used with different parameter orders.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-intersperse.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const intersperse: { <A2>(element: A2): <A, E, R>(self: Stream<A, E, R>) => Stream<A2 | A, E, R>; <A, E, R, A2>(self: Stream<A, E, R>, element: A2): Stream<A | A2, E, R>; }\n```\n\n----------------------------------------\n\nTITLE: Creating Service Function Effect in TypeScript\nDESCRIPTION: TypeScript function signature for creating a service function that produces effects. Takes a service and a function that uses the service's success type to create an effect-producing function. Returns a function that takes arguments and produces an effect combining the original effect's error and context types.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-serviceFunctionEffect.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const serviceFunctionEffect: <T extends Effect<any, any, any>, Args extends Array<any>, A, E, R>(\n  getService: T,\n  f: (_: Effect.Success<T>) => (...args: Args) => Effect<A, E, R>\n) => (...args: Args) => Effect<A, E | Effect.Error<T>, R | Effect.Context<T>>\n```\n\n----------------------------------------\n\nTITLE: Implementing Chunk.dropWhile Function in TypeScript\nDESCRIPTION: Defines the dropWhile function for the Chunk module. This function drops all elements from a Chunk as long as a given predicate returns true. It supports both curried and non-curried usage.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Chunk-dropWhile.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const dropWhile: { <A>(predicate: Predicate<NoInfer<A>>): (self: Chunk<A>) => Chunk<A>; <A>(self: Chunk<A>, predicate: Predicate<A>): Chunk<A>; }\n```\n\n----------------------------------------\n\nTITLE: Either.transposeOption Type Signature\nDESCRIPTION: Type declaration for the Either.transposeOption function showing its generic parameters and return type.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Either-transposeOption.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const transposeOption: <A = never, E = never>(self: Option<Either<A, E>>) => Either<Option<A>, E>\n```\n\n----------------------------------------\n\nTITLE: Adding Duration to DateTime - Effect Library Example\nDESCRIPTION: Demonstrates how to add a duration (5 minutes) to a DateTime object using the Effect library's DateTime module.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/DateTime-addDuration.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { DateTime } from \"effect\"\n\n// add 5 minutes\nDateTime.unsafeMake(0).pipe(\n  DateTime.addDuration(\"5 minutes\")\n)\n```\n\n----------------------------------------\n\nTITLE: Creating an Equivalence Instance for Option Values using TypeScript\nDESCRIPTION: This code snippet demonstrates the implementation of Option.getEquivalence which returns an Equivalence instance for comparing Option types based on a provided Equivalence for the inner type. It also includes examples of how to use this function with optional numbers.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Option-getEquivalence.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Number, Option } from \"effect\"\n\nconst isEquivalent = Option.getEquivalence(Number.Equivalence)\n\nconsole.log(isEquivalent(Option.none(), Option.none()))\n// Output: true\n\nconsole.log(isEquivalent(Option.none(), Option.some(1)))\n// Output: false\n\nconsole.log(isEquivalent(Option.some(1), Option.none()))\n// Output: false\n\nconsole.log(isEquivalent(Option.some(1), Option.some(2)))\n// Output: false\n\nconsole.log(isEquivalent(Option.some(1), Option.some(1)))\n// Output: true\n```\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const getEquivalence: <A>(isEquivalent: Equivalence.Equivalence<A>) => Equivalence.Equivalence<Option<A>>\n```\n\n----------------------------------------\n\nTITLE: Schedule.as Transformation in Typescript\nDESCRIPTION: Transforms a schedule to always produce a constant output, regardless of the original schedule's output. This is useful when you only need the timing aspect of a schedule and not its computed values. The function can be used with or without explicitly providing the schedule instance.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Schedule-as.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const as: { <Out2>(out: Out2): <Out, In, R>(self: Schedule<Out, In, R>) => Schedule<Out2, In, R>; <Out, In, R, Out2>(self: Schedule<Out, In, R>, out: Out2): Schedule<Out2, In, R>; }\n```\n\n----------------------------------------\n\nTITLE: Defining Scope Finalizer Type in TypeScript\nDESCRIPTION: Defines a type for finalizer functions that handle cleanup operations. The finalizer takes an Exit value containing success/failure information and returns an Effect that performs the cleanup, returning void.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Scope-Scope.Finalizer.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ntype Finalizer = (exit: Exit.Exit<unknown, unknown>) => Effect.Effect<void>\n```\n\n----------------------------------------\n\nTITLE: Implementing isAnnotated Function in TypeScript for Effect Printer Doc Module\nDESCRIPTION: A type guard function that checks if a given Doc instance is of the Annotated variant. It returns true if the document is annotated, false otherwise. This is useful for conditional logic that depends on document type.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Doc-isAnnotated.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const isAnnotated: <A>(self: Doc<A>) => self is Annotated<A>\n```\n\n----------------------------------------\n\nTITLE: Implementing Parameter Swapping in Effect Types with TypeScript\nDESCRIPTION: Function signature for flipWith that takes a transformation function and an Effect instance. It swaps error/value parameters, applies the transformation, and flips them back. The function supports both curried and uncurried forms.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-flipWith.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const flipWith: { <E, A, R, E2, A2, R2>(f: (effect: Effect<E, A, R>) => Effect<E2, A2, R2>): (self: Effect<A, E, R>) => Effect<A2, E2, R2>; <A, E, R, E2, A2, R2>(self: Effect<A, E, R>, f: (effect: Effect<E, A, R>) => Effect<E2, A2, R2>): Effect<A2, E2, R2>; }\n```\n\n----------------------------------------\n\nTITLE: Effect.intoDeferred Type Signature\nDESCRIPTION: Type signature for the intoDeferred function showing its polymorphic nature and type parameters. Defines two overloads for different parameter orderings.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-intoDeferred.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const intoDeferred: { <A, E>(deferred: Deferred.Deferred<A, E>): <R>(self: Effect<A, E, R>) => Effect<boolean, never, R>; <A, E, R>(self: Effect<A, E, R>, deferred: Deferred.Deferred<A, E>): Effect<boolean, never, R>; }\n```\n\n----------------------------------------\n\nTITLE: Accessing Micro Exit State in TypeScript\nDESCRIPTION: The code snippet defines a constant `exit` that allows accessing the `MicroExit` of a `Micro` effect. This function is generic and works with types `A`, `E`, and `R`. It takes a `Micro` instance and returns a new `Micro` instance representing the exit state. No additional dependencies are required apart from the TypeScript language and any necessary Micro effect library definitions. The input is a `Micro` effect, and the output is another `Micro` effect representing its exit state.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Micro-exit.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const exit: <A, E, R>(self: Micro<A, E, R>) => Micro<MicroExit<A, E>, never, R>\n```\n\n----------------------------------------\n\nTITLE: Implementing Channel Failure in TypeScript Effect-IO\nDESCRIPTION: Function signature for constructing a Channel that fails immediately with a specified error. The function takes an error parameter of generic type E and returns a Channel type with appropriate type parameters for error handling.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Channel-fail.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const fail: <E>(error: E) => Channel<never, unknown, E, unknown, never, unknown>\n```\n\n----------------------------------------\n\nTITLE: Transforming Required Properties to Optional with Effect Schema in Typescript\nDESCRIPTION: The `requiredToOptional` function converts a required schema property to an optional one.  The `decode` function transforms a value `FA` to an `Option<TI>`, and `none` indicates a missing value in the output. The `encode` function transforms an `Option<TI>` to `FA`, where `none` means the value is missing in the input.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Schema-requiredToOptional.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const requiredToOptional: <FA, FI, FR, TA, TI, TR>(from: Schema<FA, FI, FR>, to: Schema<TA, TI, TR>, options: { readonly decode: (fa: FA) => option_.Option<TI>; readonly encode: (o: option_.Option<TI>) => FA; }) => PropertySignature<\"?:\", TA, never, \":\", FI, false, FR | TR>\n```\n\n----------------------------------------\n\nTITLE: Implementing HashSet Differ in TypeScript\nDESCRIPTION: Defines a function that constructs a differ specifically for HashSet data structures. The differ is capable of computing differences between HashSet values and generating patches.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Differ-hashSet.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const hashSet: <Value>() => Differ<HashSet<Value>, Differ.HashSet.Patch<Value>>\n```\n\n----------------------------------------\n\nTITLE: Joining FiberRefs Collections in TypeScript\nDESCRIPTION: Function signature for joining fiber references between collections using a specified fiber ID. The function supports both curried and uncurried forms, allowing flexible usage patterns for merging fiber references while maintaining information integrity.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/FiberRefs-joinAs.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const joinAs: { \n  (fiberId: FiberId.Single, that: FiberRefs): (self: FiberRefs) => FiberRefs; \n  (self: FiberRefs, fiberId: FiberId.Single, that: FiberRefs): FiberRefs; \n}\n```\n\n----------------------------------------\n\nTITLE: TArray.findFirstIndexWhere Signature\nDESCRIPTION: The `findFirstIndexWhere` function takes a predicate as input, which is a function that tests an element and returns a boolean. It returns an STM effect that, when executed, will produce an `Option<number>` representing the index of the first matching element, or `None` if no such element exists.  The function can be called with the predicate as the sole argument, returning a curried function awaiting the `TArray`, or with both the `TArray` and predicate.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TArray-findFirstIndexWhere.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const findFirstIndexWhere: { <A>(predicate: Predicate<A>): (self: TArray<A>) => STM.STM<Option.Option<number>>; <A>(self: TArray<A>, predicate: Predicate<A>): STM.STM<Option.Option<number>>; }\n```\n\n----------------------------------------\n\nTITLE: Using OptionFromNonEmptyTrimmedString Schema in TypeScript\nDESCRIPTION: Demonstrates how to use the OptionFromNonEmptyTrimmedString schema to decode strings into Option types. It handles empty strings, strings with only whitespace, and non-empty strings.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Schema-OptionFromNonEmptyTrimmedString.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Schema } from \"effect\"\n\nconsole.log(Schema.decodeSync(Schema.OptionFromNonEmptyTrimmedString)(\"\")) // Option.none()\nconsole.log(Schema.decodeSync(Schema.OptionFromNonEmptyTrimmedString)(\" a \")) // Option.some(\"a\")\nconsole.log(Schema.decodeSync(Schema.OptionFromNonEmptyTrimmedString)(\"a\")) // Option.some(\"a\")\n```\n\n----------------------------------------\n\nTITLE: Checking RuntimeException Type in TypeScript\nDESCRIPTION: Type guard function that determines if an unknown value is an instance of RuntimeException. Used for runtime type checking and error handling in the Effect framework.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Cause-isRuntimeException.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const isRuntimeException: (u: unknown) => u is RuntimeException\n```\n\n----------------------------------------\n\nTITLE: Checking Shutdown Status with TPubSub.isShutdown in TypeScript\nDESCRIPTION: A function that returns a boolean indicating whether a TPubSub instance has been shut down. It returns true if shutdown has been called on the TPubSub instance, otherwise returns false. The function operates within an STM transaction.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TPubSub-isShutdown.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const isShutdown: <A>(self: TPubSub<A>) => STM.STM<boolean>\n```\n\n----------------------------------------\n\nTITLE: Using Boolean.some() with Arrays in TypeScript\nDESCRIPTION: Example demonstrating how to use the some() function to check if any boolean value in an array is true. The function returns true if at least one element is true, false otherwise.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Boolean-some.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { some } from \"effect/Boolean\"\n\nassert.deepStrictEqual(some([true, false, true]), true)\nassert.deepStrictEqual(some([false, false, false]), false)\n```\n\n----------------------------------------\n\nTITLE: Adding a Finalizer to an Effect Scope (TypeScript)\nDESCRIPTION: Adds a finalizer to a given scope. The provided `Effect` will be executed when the scope is closed, irrespective of how the scope was closed (success or failure). The finalizer does not receive information about the exit condition of the scope.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Scope-addFinalizer.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const addFinalizer: (self: Scope, finalizer: Effect.Effect<unknown>) => Effect.Effect<void>\n```\n\n----------------------------------------\n\nTITLE: Declaring unionWith Function in TypeScript for Schedule Module\nDESCRIPTION: Declares the unionWith function which combines two schedules using a custom merge function for their intervals. It allows continuation as long as at least one schedule wants to continue, and returns a tuple of both schedules' outputs.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Schedule-unionWith.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const unionWith: { <Out2, In2, R2>(that: Schedule<Out2, In2, R2>, f: (x: Intervals.Intervals, y: Intervals.Intervals) => Intervals.Intervals): <Out, In, R>(self: Schedule<Out, In, R>) => Schedule<[Out, Out2], In & In2, R2 | R>; <Out, In, R, Out2, In2, R2>(self: Schedule<Out, In, R>, that: Schedule<Out2, In2, R2>, f: (x: Intervals.Intervals, y: Intervals.Intervals) => Intervals.Intervals): Schedule<[Out, Out2], In & In2, R | R2>; }\n```\n\n----------------------------------------\n\nTITLE: Type Checking Boolean Values in TypeScript\nDESCRIPTION: Validates whether an input is a boolean value using a type predicate. Returns true for boolean values and false for non-boolean inputs.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Predicate-isBoolean.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { isBoolean } from \"effect/Predicate\"\n\nassert.deepStrictEqual(isBoolean(true), true)\n\nassert.deepStrictEqual(isBoolean(\"true\"), false)\n```\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const isBoolean: (input: unknown) => input is boolean\n```\n\n----------------------------------------\n\nTITLE: Effect.timeoutTo Method Signature in TypeScript\nDESCRIPTION: The TypeScript signature for the Effect.timeoutTo method, showing its function parameters and return types. It can be used with both fluent and pipe syntax patterns.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-timeoutTo.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const timeoutTo: { <A, B, B1>(options: { readonly onTimeout: LazyArg<B1>; readonly onSuccess: (a: A) => B; readonly duration: Duration.DurationInput; }): <E, R>(self: Effect<A, E, R>) => Effect<B | B1, E, R>; <A, E, R, B1, B>(self: Effect<A, E, R>, options: { readonly onTimeout: LazyArg<B1>; readonly onSuccess: (a: A) => B; readonly duration: Duration.DurationInput; }): Effect<B1 | B, E, R>; }\n```\n\n----------------------------------------\n\nTITLE: Traversing RedBlackTree in Reverse Order - TypeScript\nDESCRIPTION: This function allows for the traversal of a RedBlackTree in reverse order, returning an iterable of key-value pairs. It is crucial for situations where descending order is required in data processing or retrieval operations. The function leverages TypeScript generics to maintain type safety while traversing the elements.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/RedBlackTree-reversed.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const reversed: <K, V>(self: RedBlackTree<K, V>) => Iterable<[K, V]>\\n\n```\n\n----------------------------------------\n\nTITLE: Declaration of liftThrowable in Effect.ts\nDESCRIPTION: This is the type declaration of the `liftThrowable` function. It defines how a function `f` that accepts arguments of type `A` and returns type `B` is transformed into a function that accepts the same arguments `A` but returns `Option<B>`.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Option-liftThrowable.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const liftThrowable: <A extends ReadonlyArray<unknown>, B>(f: (...a: A) => B) => (...a: A) => Option<B>\n```\n\n----------------------------------------\n\nTITLE: Filtering None Values from Trie of Options in TypeScript\nDESCRIPTION: Demonstrates how to use Trie.compact to filter out None values from a Trie of Options. The example creates a Trie with some Option values, applies the compact function, and compares the result with an expected Trie.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Trie-compact.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { Trie, Equal, Option } from \"effect\"\n\nconst trie = Trie.empty<Option.Option<number>>().pipe(\n  Trie.insert(\"shells\", Option.some(0)),\n  Trie.insert(\"sells\", Option.none()),\n  Trie.insert(\"she\", Option.some(2))\n)\n\nconst trieMapV = Trie.empty<number>().pipe(\n  Trie.insert(\"shells\", 0),\n  Trie.insert(\"she\", 2)\n)\n\nassert.equal(Equal.equals(Trie.compact(trie), trieMapV), true)\n```\n\n----------------------------------------\n\nTITLE: Either.fromNullable Type Signature Definition\nDESCRIPTION: Type signature for the Either.fromNullable function showing its polymorphic nature. It can be used either with curried or non-curried parameter passing styles.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Either-fromNullable.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const fromNullable: { <R, L>(onNullable: (right: R) => L): (self: R) => Either<NonNullable<R>, L>; <R, L>(self: R, onNullable: (right: R) => L): Either<NonNullable<R>, L>; }\n```\n\n----------------------------------------\n\nTITLE: Creating Bounded PubSub with Dropping Strategy in TypeScript\nDESCRIPTION: The 'dropping' function creates a bounded PubSub that drops new messages when at capacity. It accepts either a number for capacity or an object with capacity and optional replay properties. For optimal performance, capacities should be powers of two.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/PubSub-dropping.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const dropping: <A>(capacity: number | { readonly capacity: number; readonly replay?: number | undefined; }) => Effect.Effect<PubSub<A>>\n```\n\n----------------------------------------\n\nTITLE: FiberMap.join Type Signature\nDESCRIPTION: Type declaration for the FiberMap.join function. Takes a FiberMap with generic types for key, value, and error, and returns an Effect that may fail with the error type.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/FiberMap-join.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const join: <K, A, E>(self: FiberMap<K, A, E>) => Effect.Effect<void, E>\n```\n\n----------------------------------------\n\nTITLE: TypeScript Function Signature for HashSet.remove\nDESCRIPTION: Defines the TypeScript function signature for the HashSet.remove operation. It supports both data-first and data-last calling styles for removing an element from a HashSet.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/HashSet-remove.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const remove: { <A>(value: A): (self: HashSet<A>) => HashSet<A>; <A>(self: HashSet<A>, value: A): HashSet<A>; }\n```\n\n----------------------------------------\n\nTITLE: Converting Property Names to Lowercase in ConfigProvider (TypeScript)\nDESCRIPTION: A utility function that transforms a ConfigProvider to automatically convert all property names to lowercase. This helps adapt from camel case naming convention to other naming conventions used by configuration providers.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/ConfigProvider-lowerCase.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const lowerCase: (self: ConfigProvider) => ConfigProvider\n```\n\n----------------------------------------\n\nTITLE: Defining PersistenceError Class in TypeScript for @effect/cluster\nDESCRIPTION: This code snippet defines the PersistenceError class, which is used to represent errors that occur when a message fails to be persisted into the cluster's mailbox storage. It is part of the ClusterError module in the @effect/cluster package.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/ClusterError-PersistenceError.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare class PersistenceError\n```\n\n----------------------------------------\n\nTITLE: Applying a Function to an Option in TypeScript\nDESCRIPTION: The code snippet demonstrates how to use the 'tap' function to apply a function to an 'Option' type. If the 'Option' is 'Some', the function is executed, and the original 'Option' is returned if the function's result is also 'Some'. Required dependencies include the 'effect' module and the 'Option' type from it. The examples show the function use with integer checking. Inputs are Option types, and outputs are also Option types, depending on the function result.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Option-tap.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { Option } from \"effect\"\n\nconst getInteger = (n: number) => Number.isInteger(n) ? Option.some(n) : Option.none()\n\nconsole.log(Option.tap(Option.none(), getInteger))\n// Output: { _id: 'Option', _tag: 'None' }\n\nconsole.log(Option.tap(Option.some(1), getInteger))\n// Output: { _id: 'Option', _tag: 'Some', value: 1 }\n\nconsole.log(Option.tap(Option.some(1.14), getInteger))\n// Output: { _id: 'Option', _tag: 'None' }\n```\n\n----------------------------------------\n\nTITLE: Constructing String Config in TypeScript using Effect-TS\nDESCRIPTION: This function creates a configuration for a string value. It optionally takes a name parameter and returns a Config<string> object. This is useful for defining string-based configuration settings in Effect-TS applications.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Config-string.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const string: (name?: string) => Config<string>\n```\n\n----------------------------------------\n\nTITLE: Using lessThanOrEqualTo Function for BigInt Comparison in TypeScript\nDESCRIPTION: Demonstrates how to use the lessThanOrEqualTo function to compare BigInt values. The function can be used both in curried and binary form to check if one BigInt is less than or equal to another.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/BigInt-lessThanOrEqualTo.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { lessThanOrEqualTo } from \"effect/BigInt\"\n\nassert.deepStrictEqual(lessThanOrEqualTo(2n, 3n), true)\nassert.deepStrictEqual(lessThanOrEqualTo(3n, 3n), true)\nassert.deepStrictEqual(lessThanOrEqualTo(4n, 3n), false)\n```\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const lessThanOrEqualTo: { (that: bigint): (self: bigint) => boolean; (self: bigint, that: bigint): boolean; }\n```\n\n----------------------------------------\n\nTITLE: Declaring Forever Function in TypeScript\nDESCRIPTION: TypeScript type declaration for the forever function that takes an Effect<A, E, R> as input and returns Effect<never, E, R>. The function executes the input effect repeatedly in an infinite loop until an error occurs.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-forever.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const forever: <A, E, R>(self: Effect<A, E, R>) => Effect<never, E, R>\n```\n\n----------------------------------------\n\nTITLE: Effect.bindTo Type Signature\nDESCRIPTION: Type definition for the bindTo function showing its polymorphic nature and type constraints. The function can be used both in curried and uncurried forms.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-bindTo.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const bindTo: { <N extends string>(name: N): <A, E, R>(self: Effect<A, E, R>) => Effect<{ [K in N]: A; }, E, R>; <A, E, R, N extends string>(self: Effect<A, E, R>, name: N): Effect<{ [K in N]: A; }, E, R>; }\n```\n\n----------------------------------------\n\nTITLE: Implementing Parallel Result Zipping in TypeScript with Effect.io\nDESCRIPTION: Function declaration for zipParLeft that combines two Exit results in parallel, keeping only the first value while combining error types. The function accepts two Exit instances and returns a new Exit instance containing only the first value but potentially both error types.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Exit-zipParLeft.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const zipParLeft: { <A2, E2>(that: Exit<A2, E2>): <A, E>(self: Exit<A, E>) => Exit<A, E2 | E>; <A, E, A2, E2>(self: Exit<A, E>, that: Exit<A2, E2>): Exit<A, E | E2>; }\n```\n\n----------------------------------------\n\nTITLE: Defining tapError Function for Side Effects on Errors in Micro Module\nDESCRIPTION: Declaration of the tapError function which allows performing side effects when errors occur in a Micro instance. The function takes an error handler that produces a Micro effect and returns a new Micro that maintains the original error type but may include additional error types from the side effect.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Micro-tapError.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const tapError: { <E, B, E2, R2>(f: (e: NoInfer<E>) => Micro<B, E2, R2>): <A, R>(self: Micro<A, E, R>) => Micro<A, E | E2, R | R2>; <A, E, R, B, E2, R2>(self: Micro<A, E, R>, f: (e: NoInfer<E>) => Micro<B, E2, R2>): Micro<A, E | E2, R | R2>; }\n```\n\n----------------------------------------\n\nTITLE: mapSecond Function Signature in TypeScript\nDESCRIPTION: This section provides the TypeScript declaration for the mapSecond function that outlines its types and usage. It indicates the function's generic nature, allowing for transformation of tuple components with specified types.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Tuple-mapSecond.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const mapSecond: { <R1, R2>(f: (right: R1) => R2): <L>(self: readonly [L, R1]) => [L, R2]; <L, R1, R2>(self: readonly [L, R1], f: (right: R1) => R2): [L, R2]; }\n```\n\n----------------------------------------\n\nTITLE: FilterMap Function Type Signature\nDESCRIPTION: Type signature for the filterMap function showing its polymorphic nature and support for both curried and uncurried forms with index parameter support.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Array-filterMap.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const filterMap: { <A, B>(f: (a: A, i: number) => Option.Option<B>): (self: Iterable<A>) => Array<B>; <A, B>(self: Iterable<A>, f: (a: A, i: number) => Option.Option<B>): Array<B>; }\n```\n\n----------------------------------------\n\nTITLE: Creating a Stream from a PubSub (Effect)\nDESCRIPTION: This code snippet shows the declaration of the `fromPubSub` function in the Effect library. It creates a stream from a PubSub subscription. The function accepts a PubSub instance and optional configuration, including a `scoped` flag and a `shutdown` option to manage the PubSub lifecycle.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-fromPubSub.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const fromPubSub: { <A>(pubsub: PubSub.PubSub<A>, options: { readonly scoped: true; readonly maxChunkSize?: number | undefined; readonly shutdown?: boolean | undefined; }): Effect.Effect<Stream<A>, never, Scope.Scope>; <A>(pubsub: PubSub.PubSub<A>, options?: { readonly scoped?: false | undefined; readonly maxChunkSize?: number | undefined; readonly shutdown?: boolean | undefined; } | undefined): Stream<A>; }\n```\n\n----------------------------------------\n\nTITLE: Declaring Between Function Signature in TypeScript\nDESCRIPTION: This snippet declares a generic TypeScript function 'between' which takes an 'Order<A>' and returns a function that can check if a given value 'self' is within a specified range defined by 'minimum' and 'maximum'. The function supports both curried and direct invocation as shown in its signature.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Order-between.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const between: <A>(O: Order<A>) => { (options: { minimum: A; maximum: A; }): (self: A) => boolean; (self: A, options: { minimum: A; maximum: A; }): boolean; };\n```\n\n----------------------------------------\n\nTITLE: Capturing Runtime and Forking Effects with FiberMap in TypeScript\nDESCRIPTION: The runtimePromise function captures a Runtime and uses it to fork Effect instances, adding the forked fibers to the FiberMap. It returns a function that accepts a key, effect, and optional runtime options, and returns a Promise of the effect's result.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/FiberMap-runtimePromise.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const runtimePromise: <K, A, E>(self: FiberMap<K, A, E>) => <R = never>() => Effect.Effect<(<XE extends E, XA extends A>(key: K, effect: Effect.Effect<XA, XE, R>, options?: (Runtime.RunForkOptions & { readonly onlyIfMissing?: boolean | undefined; readonly propagateInterruption?: boolean | undefined; }) | undefined) => Promise<XA>), never, R>\n```\n\n----------------------------------------\n\nTITLE: Implementing tapErrorCauseIf for Conditional Error Handling in Effect's Micro Module\nDESCRIPTION: This function allows for conditional execution of side effects when a MicroCause object meets specific criteria. It supports both refinement-based and predicate-based filtering of error causes, enabling targeted error handling within Micro effects.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Micro-tapErrorCauseIf.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const tapErrorCauseIf: { <E, B, E2, R2, EB extends MicroCause<E>>(refinement: Refinement<MicroCause<E>, EB>, f: (a: EB) => Micro<B, E2, R2>): <A, R>(self: Micro<A, E, R>) => Micro<A, E | E2, R | R2>; <E, B, E2, R2>(predicate: (cause: NoInfer<MicroCause<E>>) => boolean, f: (a: NoInfer<MicroCause<E>>) => Micro<B, E2, R2>): <A, R>(self: Micro<A, E, R>) => Micro<A, E | E2, R | R2>; <A, E, R, B, E2, R2, EB extends MicroCause<E>>(self: Micro<A, E, R>, refinement: Refinement<MicroCause<E>, EB>, f: (a: EB) => Micro<B, E2, R2>): Micro<A, E | E2, R | R2>; <A, E, R, B, E2, R2>(self: Micro<A, E, R>, predicate: (cause: NoInfer<MicroCause<E>>) => boolean, f: (a: NoInfer<MicroCause<E>>) => Micro<B, E2, R2>): Micro<A, E | E2, R | R2>; }\n```\n\n----------------------------------------\n\nTITLE: Array.pad function signature in TypeScript\nDESCRIPTION: The type definition for the Array.pad function, showing its overloaded nature. It can be used either with parameters (array, n, fill) or can be partially applied with (n, fill) returning a function that takes an array.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Array-pad.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const pad: { <A, T>(n: number, fill: T): (self: Array<A>) => Array<A | T>; <A, T>(self: Array<A>, n: number, fill: T): Array<A | T>; }\n```\n\n----------------------------------------\n\nTITLE: Implementing Iterable.intersperse Function in TypeScript\nDESCRIPTION: Defines the `intersperse` function that places an element between members of an Iterable. It works with non-empty arrays, ensuring the result is also a non-empty array. The function is overloaded to accept arguments in different orders.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Iterable-intersperse.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const intersperse: { <B>(middle: B): <A>(self: Iterable<A>) => Iterable<A | B>; <A, B>(self: Iterable<A>, middle: B): Iterable<A | B>; }\n```\n\n----------------------------------------\n\nTITLE: Implementing Default Pretty Logger in TypeScript\nDESCRIPTION: Defines a default implementation of a pretty logger using the Logger type. This constant provides a basic logging functionality that accepts unknown input and returns void.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Logger-prettyLoggerDefault.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const prettyLoggerDefault: Logger<unknown, void>\n```\n\n----------------------------------------\n\nTITLE: Array.tail Function Type Definition in TypeScript\nDESCRIPTION: Type definition for the tail function that takes an Iterable and returns an Option containing an Array of all elements except the first. Returns None if the Iterable is empty.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Array-tail.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const tail: <A>(self: Iterable<A>) => Option.Option<Array<A>>\n```\n\n----------------------------------------\n\nTITLE: Defining LineStream Interface in TypeScript for @effect/printer\nDESCRIPTION: TypeScript interface definition for LineStream, which represents a Doc containing a single line. The indentation parameter indicates the indentation level for the subsequent line in the Doc.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/DocStream-LineStream.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface LineStream<A> extends DocStream.Variance<A> {\n  readonly _tag: \"LineStream\"\n  readonly indentation: number\n  readonly stream: DocStream<A>\n}\n```\n\n----------------------------------------\n\nTITLE: Using Array.liftPredicate with Type Predicates in TypeScript\nDESCRIPTION: Demonstrates how to use the Array.liftPredicate function to transform a predicate into a function that returns either an empty array or a single-element array based on the predicate result.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Array-liftPredicate.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Array } from \"effect\"\n\nconst isEven = (n: number) => n % 2 === 0\nconst to = Array.liftPredicate(isEven)\nconsole.log(to(1)) // []\nconsole.log(to(2)) // [2]\n```\n\n----------------------------------------\n\nTITLE: Declaring STM.fail in TypeScript\nDESCRIPTION: The `fail` function is declared to fail a transactional effect with a specified error, allowing for better error handling in functional programming contexts using STM.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/STM-fail.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const fail: <E>(error: E) => STM<never, E>\n```\n\n----------------------------------------\n\nTITLE: Signature of Map Function from Effect TS in TypeScript\nDESCRIPTION: The signature demonstrates the generic declaration of the 'map' function in TypeScript within the Effect TS library. It shows how the function accepts either a single-curried function or a two-argument version, where it accepts a ReadonlyRecord and a transformation function, returning a new Record with transformed values. The 'map' function operates on string keys and allows transformation of both the values and keys, depending on the function passed as an argument.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Record-map.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const map: { <K extends string, A, B>(f: (a: A, key: NoInfer<K>) => B): (self: ReadonlyRecord<K, A>) => Record<K, B>; <K extends string, A, B>(self: ReadonlyRecord<K, A>, f: (a: A, key: NoInfer<K>) => B): Record<K, B>; }\n```\n\n----------------------------------------\n\nTITLE: Converting Stream to PubSub - TypeScript Function Signature\nDESCRIPTION: Function signature for toPubSub that converts a Stream to a PubSub. The function takes a capacity parameter that can be a number or an object specifying capacity settings including strategy and replay options. Returns an Effect that produces a PubSub of Takes.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-toPubSub.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const toPubSub: { (capacity: number | { readonly capacity: \"unbounded\"; readonly replay?: number | undefined; } | { readonly capacity: number; readonly strategy?: \"sliding\" | \"dropping\" | \"suspend\" | undefined; readonly replay?: number | undefined; }): <A, E, R>(self: Stream<A, E, R>) => Effect.Effect<PubSub.PubSub<Take.Take<A, E>>, never, Scope.Scope | R>; <A, E, R>(self: Stream<A, E, R>, capacity: number | { readonly capacity: \"unbounded\"; readonly replay?: number | undefined; } | { readonly capacity: number; readonly strategy?: \"sliding\" | \"dropping\" | \"suspend\" | undefined; readonly replay?: number | undefined; }): Effect.Effect<PubSub.PubSub<Take.Take<A, E>>, never, Scope.Scope | R>; }\n```\n\n----------------------------------------\n\nTITLE: Context.make Type Definition\nDESCRIPTION: Type signature for the Context.make function, showing it accepts a tag and service parameter and returns a Context instance.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Context-make.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const make: <T extends Tag<any, any>>(tag: T, service: Tag.Service<T>) => Context<Tag.Identifier<T>>\n```\n\n----------------------------------------\n\nTITLE: Array.min Type Definition\nDESCRIPTION: Type signature for the Array.min function showing its polymorphic nature. It can be called with either order first or array first, working with any type A that has an Order instance.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Array-min.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const min: { <A>(O: Order.Order<A>): (self: NonEmptyReadonlyArray<A>) => A; <A>(self: NonEmptyReadonlyArray<A>, O: Order.Order<A>): A; }\n```\n\n----------------------------------------\n\nTITLE: Defining DocTree Type in TypeScript\nDESCRIPTION: Defines the DocTree type as a union of various tree node types including EmptyTree, CharTree, TextTree, LineTree, AnnotationTree, and ConcatTree. This structure is designed for rendering documents to structured formats like HTML.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/DocTree-DocTree.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ntype DocTree<A> = | EmptyTree<A>\n  | CharTree<A>\n  | TextTree<A>\n  | LineTree<A>\n  | AnnotationTree<A>\n  | ConcatTree<A>\n```\n\n----------------------------------------\n\nTITLE: Implementing Never-resolving Micro Effect in TypeScript\nDESCRIPTION: Defines a Micro type that never succeeds or fails, implemented using setInterval to keep the JavaScript runtime active. This is useful for scenarios where you want to prevent program termination.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Micro-never.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const never: Micro<never, never, never>\n```\n\n----------------------------------------\n\nTITLE: Retrieving Tail Elements from NonEmptyChunk in TypeScript\nDESCRIPTION: The tailNonEmpty function returns every element after the first in a NonEmptyChunk. It takes a NonEmptyChunk<A> as input and returns a Chunk<A>. This function is useful for processing non-empty chunks while preserving type safety.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Chunk-tailNonEmpty.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const tailNonEmpty: <A>(self: NonEmptyChunk<A>) => Chunk<A>\n```\n\n----------------------------------------\n\nTITLE: Retrieving Queue Size using PubSub in TypeScript\nDESCRIPTION: This TypeScript snippet demonstrates the use of the `size` function to retrieve the number of elements in a PubSub queue. The function returns an `Effect` with the queue's size, which could be negative if there are pending fibers waiting for new elements. It requires the `Effect` and `PubSub` modules from the Effect library.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/PubSub-size.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const size: <A>(self: PubSub<A>) => Effect.Effect<number>\n```\n\n----------------------------------------\n\nTITLE: Defining the WindDown RuntimeFlag constant in TypeScript\nDESCRIPTION: Declaration of the WindDown constant which is a RuntimeFlag. This flag determines whether the Effect runtime system will execute effects in wind-down mode, allowing fibers to continue execution even when interruption is enabled.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/RuntimeFlags-WindDown.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const WindDown: RuntimeFlag\n```\n\n----------------------------------------\n\nTITLE: Defining trackDuration Function in TypeScript for Effect Package\nDESCRIPTION: Declares the trackDuration function, which returns an aspect to update a metric with the duration of effect execution. The metric's input type must be Duration. It supports both curried and uncurried calling styles.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Metric-trackDuration.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const trackDuration: { <Type, Out>(metric: Metric<Type, Duration.Duration, Out>): <A, E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>; <A, E, R, Type, Out>(self: Effect.Effect<A, E, R>, metric: Metric<Type, Duration.Duration, Out>): Effect.Effect<A, E, R>; }\n```\n\n----------------------------------------\n\nTITLE: Accumulating Chunks in a Stream using TypeScript\nDESCRIPTION: This function collects each underlying Chunk of the stream into a new chunk, and emits it on each pull. It transforms a Stream of elements into a Stream of Chunks of elements.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-accumulate.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const accumulate: <A, E, R>(self: Stream<A, E, R>) => Stream<Chunk.Chunk<A>, E, R>\n```\n\n----------------------------------------\n\nTITLE: Declaring Maximum Value Function Effect Order TypeScript\nDESCRIPTION: The `max` function determines the maximum between two values using an `Order<A>` instance to define the comparison. If the two values are considered equal, the function returns the first value. It supports both curried and uncurried forms, allowing flexible usage patterns. This requires an `Order<A>` dependency to define the ordering behavior.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Order-max.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const max: <A>(O: Order<A>) => { (that: A): (self: A) => A; (self: A, that: A): A; }\n```\n\n----------------------------------------\n\nTITLE: Defining DateFromString Schema in TypeScript\nDESCRIPTION: Declares a class named DateFromString that defines a schema for converting strings to Date objects using the 'new Date' constructor. This conversion is lenient and does not reject invalid date strings.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Schema-DateFromString.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare class DateFromString\n```\n\n----------------------------------------\n\nTITLE: Defining Strict Equality Equivalence Function in TypeScript\nDESCRIPTION: This code snippet defines a function that returns an Equivalence using strict equality (===) for comparing values. It's a generic function that can work with any type A.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Equivalence-strict.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const strict: <A>() => Equivalence<A>\n```\n\n----------------------------------------\n\nTITLE: Implementing Iterable.scan Function in TypeScript\nDESCRIPTION: Defines the scan function for Iterables. It reduces an Iterable from the left, keeping all intermediate results instead of only the final result. The function has two overloads to support different usage patterns.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Iterable-scan.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const scan: { <B, A>(b: B, f: (b: B, a: A) => B): (self: Iterable<A>) => Iterable<B>; <A, B>(self: Iterable<A>, b: B, f: (b: B, a: A) => B): Iterable<B>; }\n```\n\n----------------------------------------\n\nTITLE: Declaring Option.zipLeft in Typescript\nDESCRIPTION: This code snippet declares the `zipLeft` function within the `Option` module of the Effect library. It takes two `Option` types as input and returns an `Option` of the same type as the first input `Option`. If both input `Option`s are `Some`, the function returns the first `Option`; otherwise, it returns `None`.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Option-zipLeft.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const zipLeft: { <_>(that: Option<_>): <A>(self: Option<A>) => Option<A>; <A, X>(self: Option<A>, that: Option<X>): Option<A>; }\n```\n\n----------------------------------------\n\nTITLE: Creating a Sink from PubSub in TypeScript\nDESCRIPTION: This function creates a sink which publishes each element to the specified PubSub. The optional shutdown parameter controls whether the PubSub will be shutdown after the sink is evaluated, defaulting to false.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Sink-fromPubSub.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const fromPubSub: <In>(pubsub: PubSub.PubSub<In>, options?: { readonly shutdown?: boolean | undefined; }) => Sink<void, In>\n```\n\n----------------------------------------\n\nTITLE: Defining Empty Document Interface in TypeScript\nDESCRIPTION: Defines the Empty interface type that extends Doc.Variance<A> to represent an empty document. The interface includes a discriminator tag '_tag' set to \"Empty\" for type discrimination.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Doc-Empty.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface Empty<A> extends Doc.Variance<A> {\n  readonly _tag: \"Empty\"\n}\n```\n\n----------------------------------------\n\nTITLE: Splitting Arrays with a Predicate in TypeScript using Effect\nDESCRIPTION: Demonstrates how to use Array.splitWhere to split an array at the first element that satisfies a condition. The example splits an array of numbers at the first element greater than 3.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Array-splitWhere.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Array } from \"effect\"\n\nconst result = Array.splitWhere([1, 2, 3, 4, 5], n => n > 3)\nconsole.log(result) // [[1, 2, 3], [4, 5]]\n```\n\n----------------------------------------\n\nTITLE: Doc.reflow Function Signature in Effect TS\nDESCRIPTION: The type signature for the Doc.reflow function which takes a string to be reflowed and an optional character to split on (defaults to space). It returns a Doc that never produces an annotation.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Doc-reflow.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const reflow: (s: string, char?: string) => Doc<never>\n```\n\n----------------------------------------\n\nTITLE: Checking Array Type in TypeScript using Effect\nDESCRIPTION: The isArray function determines if a given value is an Array. It can be used with unknown types and also provides type narrowing for generic types.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Array-isArray.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Array } from \"effect\"\n\nconsole.log(Array.isArray(null)) // false\nconsole.log(Array.isArray([1, 2, 3])) // true\n```\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const isArray: { (self: unknown): self is Array<unknown>; <T>(self: T): self is Extract<T, ReadonlyArray<any>>; }\n```\n\n----------------------------------------\n\nTITLE: Doc.softLineBreak Type Signature in TypeScript\nDESCRIPTION: The type declaration for the softLineBreak constant in the @effect/printer library. It defines a Doc that never produces an error value.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Doc-softLineBreak.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const softLineBreak: Doc<never>\n```\n\n----------------------------------------\n\nTITLE: Creating Semaphore Using unsafeMakeSemaphore in Effect-TS\nDESCRIPTION: Function signature for unsafely creating a new Semaphore instance with a specified number of permits. This is part of the Effect module in the effect package. Note that this is an unsafe operation.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-unsafeMakeSemaphore.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const unsafeMakeSemaphore: (permits: number) => Semaphore\n```\n\n----------------------------------------\n\nTITLE: Calculating Remaining Width in `@effect/printer` TypeScript\nDESCRIPTION: This function calculates the remaining width in a document line. It requires the total line length, ribbon fraction, line indentation, and current column position as parameters. The function returns the available width as a number. It is used primarily for document formatting tasks where line width calculations are necessary. It's a part of the PageWidth module from the @effect/printer package, starting from version 1.0.0.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/PageWidth-remainingWidth.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const remainingWidth: (lineLength: number, ribbonFraction: number, lineIndent: number, currentColumn: number) => number\n```\n\n----------------------------------------\n\nTITLE: Using Doc.hsep for Horizontal Document Concatenation in TypeScript\nDESCRIPTION: Demonstrates how to use the hsep combinator to horizontally join documents with spaces. Shows behavior with different line widths and illustrates that hsep does not automatically break lines regardless of page width.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Doc-hsep.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport * as Doc from \"@effect/printer/Doc\"\n\nconst doc: Doc.Doc<never> = Doc.hsep(Doc.words(\"lorem ipsum dolor sit amet\"))\n\nassert.strictEqual(\n  Doc.render(doc, {\n    style: \"pretty\",\n    options: { lineWidth: 80 }\n  }),\n  \"lorem ipsum dolor sit amet\"\n)\n\n// The `hsep` combinator will not introduce line breaks on its own, even when\n// the page is too narrow\nassert.strictEqual(\n  Doc.render(doc, {\n    style: \"pretty\",\n    options: { lineWidth: 5 }\n  }),\n  \"lorem ipsum dolor sit amet\"\n)\n```\n\n----------------------------------------\n\nTITLE: Defining Document Concatenation Interface in TypeScript\nDESCRIPTION: Defines the Cat interface that represents the concatenation of two documents. The interface extends Doc.Variance<A> and includes properties for the left and right documents being concatenated, along with a type tag.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Doc-Cat.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface Cat<A> extends Doc.Variance<A> {\n  readonly _tag: \"Cat\"\n  readonly left: Doc<A>\n  readonly right: Doc<A>\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Struct Order in TypeScript\nDESCRIPTION: Creates a custom order for a struct by specifying orders for each field, allowing complex and flexible value comparisons across structured data types\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Struct-getOrder.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const getOrder: <R extends { readonly [x: string]: order.Order<any>; }>(fields: R) => order.Order<{ [K in keyof R]: [R[K]] extends [order.Order<infer A>] ? A : never; }>\n```\n\n----------------------------------------\n\nTITLE: Type Signature for Array.flatMapNullable Function\nDESCRIPTION: The type signature for the flatMapNullable function in Effect's Array module. It supports both curried and uncurried calling styles, taking a mapping function that can return nullable values and an array to transform.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Array-flatMapNullable.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const flatMapNullable: { <A, B>(f: (a: A) => B | null | undefined): (self: ReadonlyArray<A>) => Array<NonNullable<B>>; <A, B>(self: ReadonlyArray<A>, f: (a: A) => B | null | undefined): Array<NonNullable<B>>; }\n```\n\n----------------------------------------\n\nTITLE: Defining Request Result Type Extraction in TypeScript\nDESCRIPTION: A TypeScript utility type that extracts the result type from a Request object using conditional types. It returns an Exit type containing either the success value A or error value E from the original Request type.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Request-Request.Result.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ntype Result<T> = T extends Request<infer A, infer E> ? Exit.Exit<A, E> : never\n```\n\n----------------------------------------\n\nTITLE: Using unsafeFormatIso to Convert Duration to ISO8601 Strings in TypeScript\nDESCRIPTION: This function formats a Duration into an ISO8601 duration string. It assumes months are 30 days and years are 365 days. Milliseconds and nanoseconds are expressed as fractional seconds. The function throws a RangeError if the duration is not finite.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Duration-unsafeFormatIso.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Duration } from \"effect\"\n\nDuration.unsafeFormatIso(Duration.days(1)) // => \"P1D\"\nDuration.unsafeFormatIso(Duration.minutes(90)) // => \"PT1H30M\"\nDuration.unsafeFormatIso(Duration.millis(1500)) // => \"PT1.5S\"\n```\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const unsafeFormatIso: (self: DurationInput) => string\n```\n\n----------------------------------------\n\nTITLE: Order.clamp Signature in Typescript\nDESCRIPTION: This code snippet presents the type signature of the `Order.clamp` function. It highlights the function's generic nature, allowing it to work with various types (`A`) given an appropriate `Order` implementation. The signature shows that the `clamp` function accepts an `Order` and returns a function that takes a value and an object containing the minimum and maximum values, or just the value and then the option object, returning the clamped value.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Order-clamp.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const clamp: <A>(O: Order<A>) => { (options: { minimum: A; maximum: A; }): (self: A) => A; (self: A, options: { minimum: A; maximum: A; }): A; }\n```\n\n----------------------------------------\n\nTITLE: Defining acquireReleaseInterruptible Function in TypeScript\nDESCRIPTION: This code snippet defines the acquireReleaseInterruptible function in TypeScript. It creates a scoped resource with an interruptible acquire action, allowing the acquisition process to be interrupted if necessary. The function has two overloads to handle different parameter orders.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-acquireReleaseInterruptible.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const acquireReleaseInterruptible: { <X, R2>(release: (exit: Exit.Exit<unknown, unknown>) => Effect<X, never, R2>): <A, E, R>(acquire: Effect<A, E, R>) => Effect<A, E, Scope.Scope | R2 | R>; <A, E, R, X, R2>(acquire: Effect<A, E, R>, release: (exit: Exit.Exit<unknown, unknown>) => Effect<X, never, R2>): Effect<A, E, Scope.Scope | R | R2>; }\n```\n\n----------------------------------------\n\nTITLE: Implementing Cursor Forward Movement in AnsiDoc TypeScript Module\nDESCRIPTION: The `cursorForward` function moves the cursor forward by a specified number of columns (defaulting to 1) from its current position. If the cursor is already at the edge of the screen, the function has no effect.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/AnsiDoc-cursorForward.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const cursorForward: (columns?: number) => AnsiDoc\n```\n\n----------------------------------------\n\nTITLE: Implementing tapErrorCause Function for Error Handling in Micro Module\nDESCRIPTION: The tapErrorCause function performs a side effect using the full MicroCause object of a given Micro. It provides overloaded implementations for both pipeable and direct function application patterns.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Micro-tapErrorCause.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const tapErrorCause: { <E, B, E2, R2>(f: (cause: NoInfer<MicroCause<E>>) => Micro<B, E2, R2>): <A, R>(self: Micro<A, E, R>) => Micro<A, E | E2, R | R2>; <A, E, R, B, E2, R2>(self: Micro<A, E, R>, f: (cause: NoInfer<MicroCause<E>>) => Micro<B, E2, R2>): Micro<A, E | E2, R | R2>; }\n```\n\n----------------------------------------\n\nTITLE: Creating Lazy Arbitrary from Schema in TypeScript\nDESCRIPTION: Function signature for makeLazy that creates a LazyArbitrary instance for a given schema type. It takes a Schema parameter with generic types A, I, and R, and returns a LazyArbitrary of type A.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Arbitrary-makeLazy.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const makeLazy: <A, I, R>(schema: Schema.Schema<A, I, R>) => LazyArbitrary<A>\n```\n\n----------------------------------------\n\nTITLE: Using HashSet.toValues to Convert a HashSet to an Array in TypeScript\nDESCRIPTION: This example demonstrates how to use the HashSet.toValues function to convert a HashSet containing numbers into an Array. The function handles duplicate values automatically, as shown with the duplicate value of 1 in the example.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/HashSet-toValues.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { HashSet, pipe } from \"effect\"\nimport { deepStrictEqual } from \"node:assert/strict\"\n\ndeepStrictEqual(\n  pipe(\n    HashSet.make(0, 1, 1, 2), // HashSet<number>\n    HashSet.toValues // takes an HashSet<A> and returns an Array<A>\n  ),\n  Array.of(0, 1, 2)\n)\n```\n\n----------------------------------------\n\nTITLE: Stream Drain Type Signature\nDESCRIPTION: Provides the TypeScript type signature for the drain method, indicating it transforms a stream with elements to a stream with no elements\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-drain.md#2025-04-11_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const drain: <A, E, R>(self: Stream<A, E, R>) => Stream<never, E, R>\n```\n\n----------------------------------------\n\nTITLE: Defining Sink.mkString Function in TypeScript\nDESCRIPTION: Signature for the mkString function that creates a sink which transforms its inputs into a string. This function has been available since version 2.0.0 of the effect package.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Sink-mkString.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const mkString: Sink<string, unknown, never, never, never>\n```\n\n----------------------------------------\n\nTITLE: Type Equality Signature Implementation\nDESCRIPTION: Complex type-level implementation of type equality comparison using conditional type inference and extended function type comparison.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Types-Equals.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ntype Equals<X, Y> = (<T>() => T extends X ? 1 : 2) extends <T>() => T extends Y ? 1 : 2 ? true : false\n```\n\n----------------------------------------\n\nTITLE: Declaring interruptibleMask Function in TypeScript\nDESCRIPTION: The interruptibleMask function behaves like interruptible, but provides a restore function that can be used to selectively restore the interruptibility of specific regions of code within the effect. It takes a function that receives the restore capability and returns an Effect.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-interruptibleMask.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const interruptibleMask: <A, E, R>(f: (restore: <AX, EX, RX>(effect: Effect<AX, EX, RX>) => Effect<AX, EX, RX>) => Effect<A, E, R>) => Effect<A, E, R>\n```\n\n----------------------------------------\n\nTITLE: Defining RedBlackTree Interface in TypeScript\nDESCRIPTION: TypeScript interface definition for a Red-Black Tree that includes generic Key and Value types. The interface extends Iterable, Equal, Pipeable, and Inspectable interfaces. It includes type metadata for key invariance and value covariance.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/RedBlackTree-RedBlackTree.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface RedBlackTree<in out Key, out Value> extends Iterable<[Key, Value]>, Equal, Pipeable, Inspectable {\n  readonly [TypeId]: {\n    readonly _Key: Types.Invariant<Key>\n    readonly _Value: Types.Covariant<Value>\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Checking for Nest Type in Doc Module\nDESCRIPTION: The isNest function is a type guard that checks if a given Doc is of type Nest. It returns true if the Doc is a Nest, false otherwise. This function is useful for type narrowing in TypeScript.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Doc-isNest.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const isNest: <A>(self: Doc<A>) => self is Nest<A>\n```\n\n----------------------------------------\n\nTITLE: Defining Schedule.succeed Function in TypeScript\nDESCRIPTION: This code snippet defines the 'succeed' function in the Schedule module. It creates a schedule that recurs indefinitely, always producing the specified constant value. The function takes a generic type A and returns a Schedule of type A.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Schedule-succeed.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const succeed: <A>(value: A) => Schedule<A>\n```\n\n----------------------------------------\n\nTITLE: DateTime.setZone Type Definition\nDESCRIPTION: Type signature for the setZone function showing its overloaded variants. Accepts a TimeZone and optional adjustment options, returning a Zoned DateTime instance.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/DateTime-setZone.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const setZone: { (zone: TimeZone, options?: { readonly adjustForTimeZone?: boolean | undefined; }): (self: DateTime) => Zoned; (self: DateTime, zone: TimeZone, options?: { readonly adjustForTimeZone?: boolean | undefined; }): Zoned; }\n```\n\n----------------------------------------\n\nTITLE: Implementing FiberSet.awaitEmpty in TypeScript\nDESCRIPTION: Function signature for awaitEmpty that takes a FiberSet as input and returns an Effect that resolves when the fiber set becomes empty. The function is generic over the success type A and error type E of the fibers in the set.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/FiberSet-awaitEmpty.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const awaitEmpty: <A, E>(self: FiberSet<A, E>) => Effect.Effect<void>\n```\n\n----------------------------------------\n\nTITLE: Implementing Layer Failure Handler in TypeScript\nDESCRIPTION: Function that constructs a Layer that fails with a specified cause. It takes a lazy argument that evaluates to a Cause<E> and returns a Layer that will fail with that cause when evaluated.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Layer-failCauseSync.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const failCauseSync: <E>(evaluate: LazyArg<Cause.Cause<E>>) => Layer<unknown, E>\n```\n\n----------------------------------------\n\nTITLE: Implementing Conditional Exit Handling in TypeScript Effect Micro Module\nDESCRIPTION: Defines the onExitIf function that executes a finalizer effect when a Micro effect completes and matches specified predicates. The function supports both refinement and predicate-based conditional execution with type-safe implementations.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Micro-onExitIf.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const onExitIf: { <A, E, XE, XR, B extends MicroExit<A, E>>(refinement: Refinement<MicroExit<A, E>, B>, f: (exit: B) => Micro<void, XE, XR>): <R>(self: Micro<A, E, R>) => Micro<A, E | XE, R | XR>; <A, E, XE, XR>(predicate: Predicate<MicroExit<NoInfer<A>, NoInfer<E>>>, f: (exit: MicroExit<NoInfer<A>, NoInfer<E>>) => Micro<void, XE, XR>): <R>(self: Micro<A, E, R>) => Micro<A, E | XE, R | XR>; <A, E, R, XE, XR, B extends MicroExit<A, E>>(self: Micro<A, E, R>, refinement: Refinement<MicroExit<A, E>, B>, f: (exit: B) => Micro<void, XE, XR>): Micro<A, E | XE, R | XR>; <A, E, R, XE, XR>(self: Micro<A, E, R>, predicate: Predicate<MicroExit<NoInfer<A>, NoInfer<E>>>, f: (exit: MicroExit<NoInfer<A>, NoInfer<E>>) => Micro<void, XE, XR>): Micro<A, E | XE, R | XR>; }\n```\n\n----------------------------------------\n\nTITLE: Defining FlatAlt Interface in TypeScript\nDESCRIPTION: Defines a TypeScript interface for FlatAlt that extends Doc.Variance<A>. It contains a discriminator tag and two Doc<A> properties representing alternative document layouts. The first alternative is assumed to be less wide than the flattened second alternative when used by layout algorithms.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Doc-FlatAlt.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface FlatAlt<A> extends Doc.Variance<A> {\n  readonly _tag: \"FlatAlt\"\n  readonly left: Doc<A>\n  readonly right: Doc<A>\n}\n```\n\n----------------------------------------\n\nTITLE: Checking if a value is an STM in Effect TS\nDESCRIPTION: This TypeScript code snippet defines the `isSTM` function. The `isSTM` function takes an unknown value `u` as input and returns `true` if `u` is an instance of `STM`, and `false` otherwise. This function is crucial for type checking and ensuring type safety when working with STM within the Effect TS ecosystem.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/STM-isSTM.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const isSTM: (u: unknown) => u is STM<unknown, unknown, unknown>\n```\n\n----------------------------------------\n\nTITLE: Lifting a Semigroup with getSemigroup in Effect-TS\nDESCRIPTION: The `getSemigroup` function allows you to lift a standard `Semigroup<A>` into the context of a `SemiApplicative<F>`. This means that if you have a `Semigroup` that defines how to combine values of type `A`, you can use `getSemigroup` to create a new `Semigroup` that defines how to combine values of type `Kind<F, R, O, E, A>`, where `F` is a type constructor with a `SemiApplicative` instance.  The resulting `Semigroup` combines the inner `A` values using the provided `Semigroup<A>`. This function requires a `SemiApplicative` instance for `F` and a `Semigroup` instance for `A`.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/SemiApplicative-getSemigroup.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const getSemigroup: <F extends TypeLambda>(F: SemiApplicative<F>) => <A, R, O, E>(S: Semigroup<A>) => Semigroup<Kind<F, R, O, E, A>>\n```\n\n----------------------------------------\n\nTITLE: Implementing ConfigError.isInvalidData Type Guard in TypeScript\nDESCRIPTION: This function is a type guard that checks if a given ConfigError is specifically an InvalidData error. It returns true if the error is of type InvalidData, and false otherwise. This is useful for narrowing down error types in conditional statements or error handling.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/ConfigError-isInvalidData.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const isInvalidData: (self: ConfigError) => self is InvalidData\n```\n\n----------------------------------------\n\nTITLE: Removing Values from MutableHashSet in TypeScript\nDESCRIPTION: Demonstrates three different ways to remove a value from a MutableHashSet: using the data-last (pipeable) API, piping with the pipe function, and using the data-first API. All approaches remove the value 0 from a set containing 0, 1, and 2.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/MutableHashSet-remove.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { MutableHashSet, pipe } from \"effect\"\nimport assert from \"node:assert/strict\"\n\nassert.equal(\n  // with `data-last`, a.k.a. `pipeable` API\n  pipe(\n    MutableHashSet.make(0, 1, 2),\n    MutableHashSet.remove(0),\n    MutableHashSet.has(0)\n  ),\n  false\n)\n\nassert.equal(\n  // or piped with the pipe function\n  MutableHashSet.make(0, 1, 2).pipe(\n    MutableHashSet.remove(0),\n    MutableHashSet.has(0)\n  ),\n  false\n)\n\nassert.equal(\n  // or with `data-first` API\n  MutableHashSet.remove(MutableHashSet.make(0, 1, 2), 0).pipe(\n    MutableHashSet.has(0)\n  ),\n  false\n)\n```\n\n----------------------------------------\n\nTITLE: Stream.tick Type Signature\nDESCRIPTION: Type declaration for the Stream.tick function that takes a DurationInput parameter and returns a Stream of void values.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-tick.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const tick: (interval: Duration.DurationInput) => Stream<void>\n```\n\n----------------------------------------\n\nTITLE: Implementing List.drop Function in TypeScript\nDESCRIPTION: Defines the drop function for the List module. This function drops the first n elements from a given list. It supports both curried and non-curried usage.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/List-drop.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const drop: { (n: number): <A>(self: List<A>) => List<A>; <A>(self: List<A>, n: number): List<A>; }\n```\n\n----------------------------------------\n\nTITLE: Incrementing a number using Effect's Number module in Typescript\nDESCRIPTION: This code demonstrates how to increment a number using the `increment` function from the `effect/Number` module.  It imports the `increment` function and uses `node:assert` to verify that incrementing 2 results in 3. The function takes a number as input and returns the number incremented by 1.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Number-increment.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { increment } from \"effect/Number\"\n\nassert.deepStrictEqual(increment(2), 3)\n```\n\n----------------------------------------\n\nTITLE: Defining the Tuple Function for Order\nDESCRIPTION: This snippet declares a TypeScript function 'tuple' that takes a variable number of 'Order' instances and returns a new 'Order' for a tuple of values. It ensures that the comparison of two tuples of the same type is conducted according to the specified order for each element.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Order-tuple.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const tuple: <T extends ReadonlyArray<Order<any>>>(...elements: T) => Order<Readonly<{ [I in keyof T]: [T[I]] extends [Order<infer A>] ? A : never; }>>\n```\n\n----------------------------------------\n\nTITLE: Using unsafeParse to Create a Cron Instance in TypeScript\nDESCRIPTION: This example demonstrates how to use the Cron.unsafeParse function to parse a cron expression string into a Cron instance. The example shows parsing \"0 4 8-14 * *\" which represents a schedule that runs at 04:00 on every day-of-month from 8 through 14.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Cron-unsafeParse.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Cron } from \"effect\"\n\n// At 04:00 on every day-of-month from 8 through 14.\nconsole.log(Cron.unsafeParse(\"0 4 8-14 * *\"))\n// Output:\n// {\n//   _id: 'Cron',\n//   tz: { _id: 'Option', _tag: 'None' },\n//   seconds: [ 0 ],\n//   minutes: [ 0 ],\n//   hours: [ 4 ],\n//   days: [\n//      8,  9, 10, 11,\n//     12, 13, 14\n//   ],\n//   months: [],\n//   weekdays: []\n// }\n```\n\n----------------------------------------\n\nTITLE: Converting List to Chunk in TypeScript using Effect.ts\nDESCRIPTION: A function that transforms a List data structure into a Chunk data structure. The function takes a List of type A as input and returns a Chunk containing elements of the same type.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/List-toChunk.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const toChunk: <A>(self: List<A>) => Chunk.Chunk<A>\n```\n\n----------------------------------------\n\nTITLE: Defining orElseEither Function in TypeScript for Fiber Module\nDESCRIPTION: Defines the orElseEither function for the Fiber module. This function returns a new fiber that prefers the current fiber but falls back to another fiber if the current one fails. Interrupting the returned fiber will interrupt both fibers sequentially from left to right.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Fiber-orElseEither.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const orElseEither: { <A2, E2>(that: Fiber<A2, E2>): <A, E>(self: Fiber<A, E>) => Fiber<Either.Either<A2, A>, E2 | E>; <A, E, A2, E2>(self: Fiber<A, E>, that: Fiber<A2, E2>): Fiber<Either.Either<A2, A>, E | E2>; }\n```\n\n----------------------------------------\n\nTITLE: HashSet.mutate Function Signature\nDESCRIPTION: TypeScript type declaration for the HashSet.mutate function, showing both data-first and data-last overloads. The function accepts a HashSet and a mutation function, returning the modified HashSet.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/HashSet-mutate.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const mutate: { <A>(f: (set: HashSet<A>) => void): (self: HashSet<A>) => HashSet<A>; <A>(self: HashSet<A>, f: (set: HashSet<A>) => void): HashSet<A>; }\n```\n\n----------------------------------------\n\nTITLE: Creating Weekly Schedule Recurrences - TypeScript\nDESCRIPTION: The `dayOfWeek` function creates a schedule that recurs on a specified day of the week, where the day parameter adheres to standard conventions (1 for Monday to 7 for Sunday). The function returns a Schedule instance which will count executions starting from 0. Note that the validation for the day parameter is done lazily during execution of the schedule.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Schedule-dayOfWeek.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const dayOfWeek: (day: number) => Schedule<number>\n```\n\n----------------------------------------\n\nTITLE: Declaring isNone Function in TypeScript\nDESCRIPTION: This TypeScript code declares the `isNone` function within the `Option` module.  The function takes an `Option<A>` as input and returns a boolean indicating whether the option is `None<A>`.  It utilizes a type predicate (`self is None<A>`) to narrow the type of the input if it returns `true`.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Option-isNone.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const isNone: <A>(self: Option<A>) => self is None<A>\n```\n\n----------------------------------------\n\nTITLE: Array.replicate Type Signature in TypeScript\nDESCRIPTION: Type declaration for the Array.replicate function showing its polymorphic implementation. The function can be called with arguments in either order (value, count) or (count)(value).\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Array-replicate.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const replicate: { (n: number): <A>(a: A) => NonEmptyArray<A>; <A>(a: A, n: number): NonEmptyArray<A>; }\n```\n\n----------------------------------------\n\nTITLE: Converting Duration to Nanoseconds in TypeScript\nDESCRIPTION: The toNanos function converts a DurationInput to nanoseconds as a bigint. It returns Option.none() if the duration is infinite. This function is part of the Duration module in the Effect package.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Duration-toNanos.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const toNanos: (self: DurationInput) => Option.Option<bigint>\n```\n\n----------------------------------------\n\nTITLE: Collecting Outputs with Schedule in TypeScript\nDESCRIPTION: The `collectAllOutputs` function takes a `Schedule` and returns a modified version that collects all outputs into a `Chunk`. This is beneficial for scenarios requiring data aggregation or tracking results over time. Key parameters include `Out` for output type, `In` for input type, and `R` for environment type. The function does not modify inputs or the environment. As a dependency, `Chunk` from the Effect library is required. Inputs are schedules, and outputs are schedules producing a `Chunk` of results.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Schedule-collectAllOutputs.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const collectAllOutputs: <Out, In, R>(self: Schedule<Out, In, R>) => Schedule<Chunk.Chunk<Out>, In, R>\n```\n\n----------------------------------------\n\nTITLE: Updating FiberRef Values with FiberId in TypeScript\nDESCRIPTION: Function signature for updating the value of a FiberRef using a specific FiberId. The function accepts options containing the fiberId, fiberRef, and new value, and can be used either as a standalone function or method on a FiberRefs instance.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/FiberRefs-updateAs.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const updateAs: { <A>(options: { readonly fiberId: FiberId.Single; readonly fiberRef: FiberRef.FiberRef<A>; readonly value: A; }): (self: FiberRefs) => FiberRefs; <A>(self: FiberRefs, options: { readonly fiberId: FiberId.Single; readonly fiberRef: FiberRef.FiberRef<A>; readonly value: A; }): FiberRefs; }\n```\n\n----------------------------------------\n\nTITLE: Checking for Failures in Cause Objects in TypeScript\nDESCRIPTION: This function determines if a Cause contains a failure. It returns true if the Cause includes any Fail error, helping to distinguish between anticipated errors versus defects or interruptions in a workflow.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Cause-isFailure.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const isFailure: <E>(self: Cause<E>) => boolean\n```\n\n----------------------------------------\n\nTITLE: RequestResolver.aroundRequests Method Signature in TypeScript\nDESCRIPTION: The type signature for the aroundRequests method showing its polymorphic nature. It takes a RequestResolver and two effect functions - one to run before request processing and one to run after with access to the before function's result.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/RequestResolver-aroundRequests.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const aroundRequests: { <A, A2, R2, X, R3>(before: (requests: ReadonlyArray<Types.NoInfer<A>>) => Effect.Effect<A2, never, R2>, after: (requests: ReadonlyArray<Types.NoInfer<A>>, _: A2) => Effect.Effect<X, never, R3>): <R>(self: RequestResolver<A, R>) => RequestResolver<A, R2 | R3 | R>; <A, R, A2, R2, X, R3>(self: RequestResolver<A, R>, before: (requests: ReadonlyArray<Types.NoInfer<A>>) => Effect.Effect<A2, never, R2>, after: (requests: ReadonlyArray<Types.NoInfer<A>>, _: A2) => Effect.Effect<X, never, R3>): RequestResolver<A, R | R2 | R3>; }\n```\n\n----------------------------------------\n\nTITLE: Defining failureOrCause Function in TypeScript\nDESCRIPTION: Declares the failureOrCause function that splits a Cause into either its first Fail error or the rest of the cause. It returns an Either type containing either a Cause<never> or the error E.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Cause-failureOrCause.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const failureOrCause: <E>(self: Cause<E>) => Either.Either<Cause<never>, E>\n```\n\n----------------------------------------\n\nTITLE: Signature of takeRight Function\nDESCRIPTION: This code snippet outlines the TypeScript declaration for the 'takeRight' function. It describes its signature, indicating it can take in a number 'n' and a stream, or be partially applied returning a function that expects the stream as a subsequent argument.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-takeRight.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const takeRight: { (n: number): <A, E, R>(self: Stream<A, E, R>) => Stream<A, E, R>; <A, E, R>(self: Stream<A, E, R>, n: number): Stream<A, E, R>; }\n```\n\n----------------------------------------\n\nTITLE: Creating a HashSet from Effect's Chunk Data Structure in TypeScript\nDESCRIPTION: Demonstrates creating a HashSet from Effect's Chunk data structure. This example shows interoperability between different data structures in the Effect library.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/HashSet-fromIterable.md#2025-04-11_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\n// Creating a HashSet from other Effect's data structures like Chunk\nimport { Chunk, HashSet, pipe } from \"effect\"\n\nconsole.log(\n  pipe(\n    Chunk.make(1, 2, 3, 4), // Iterable<number>\n    HashSet.fromIterable,\n    HashSet.toValues // turns the HashSet back into an array\n  )\n) // Outputs: [1, 2, 3, 4]\n```\n\n----------------------------------------\n\nTITLE: Implementing Foldable Composition Reduction in TypeScript\nDESCRIPTION: Defines a function that creates a ternary reduce composition for two Foldable instances. This enables folding over nested container structures where both containers implement the Foldable interface.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Foldable-reduceComposition.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const reduceComposition: <F extends TypeLambda, G extends TypeLambda>(F: Foldable<F>, G: Foldable<G>) => <FR, FO, FE, GR, GO, GE, A, B>(self: Kind<F, FR, FO, FE, Kind<G, GR, GO, GE, A>>, b: B, f: (b: B, a: A) => B) => B\n```\n\n----------------------------------------\n\nTITLE: Implementing Array Order Function in TypeScript\nDESCRIPTION: Creates a new Order for arrays by comparing elements using a provided Order instance. The comparison is done element-by-element, with array length being the tiebreaker if all elements are equal. This function is part of the Effect-TS library's Array module.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Array-getOrder.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const getOrder: <A>(O: Order.Order<A>) => Order.Order<ReadonlyArray<A>>\n```\n\n----------------------------------------\n\nTITLE: Creating and Using a Tagged Struct Schema in TypeScript\nDESCRIPTION: This example demonstrates how to create a tagged struct schema for a User object and use it to create an instance. The schema includes a name and age field, and automatically adds a '_tag' property.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Schema-TaggedStruct.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { Schema } from \"effect\"\n\nconst User = Schema.TaggedStruct(\"User\", {\n  name: Schema.String,\n  age: Schema.Number\n})\n\nassert.deepStrictEqual(User.make({ name: \"John\", age: 44 }), { _tag: \"User\", name: \"John\", age: 44 })\n```\n\n----------------------------------------\n\nTITLE: Declaring MergeAll Function for STM in TypeScript\nDESCRIPTION: The mergeAll constant in TypeScript is used to merge an iterable of STM instances into a single STM by applying a defined function sequentially. Dependencies include the Effect-TS library. Key parameters include an initial accumulator value (zero) and a combining function f. The function processes STM instances sequentially and returns a consolidated STM. It requires valid STM objects and a compatible combining function to operate.\n\nThe primary limitation is its reliance on sequential processing, which could impact performance for large datasets.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/STM-mergeAll.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const mergeAll: { <A2, A>(zero: A2, f: (a2: A2, a: A) => A2): <E, R>(iterable: Iterable<STM<A, E, R>>) => STM<A2, E, R>; <A, E, R, A2>(iterable: Iterable<STM<A, E, R>>, zero: A2, f: (a2: A2, a: A) => A2): STM<A2, E, R>; }\n```\n\n----------------------------------------\n\nTITLE: Collecting Inputs While Condition Holds - Effect-TS - TypeScript\nDESCRIPTION: This TypeScript snippet defines a function, 'collectWhile', which is part of the Effect-TS library. The function takes a predicate function 'f' and returns a Schedule that collects inputs into a 'Chunk'. The schedule continues while the predicate returns true and stops as soon as it evaluates to false. Key dependencies include the 'Chunk' and 'Schedule' from Effect-TS.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Schedule-collectWhile.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const collectWhile: <A>(f: Predicate<A>) => Schedule<Chunk.Chunk<A>, A>\n```\n\n----------------------------------------\n\nTITLE: BigDecimal.greaterThan Function Signature in TypeScript\nDESCRIPTION: The type signature for the greaterThan function from the BigDecimal module. It supports both curried and non-curried calling styles for comparing BigDecimal values.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/BigDecimal-greaterThan.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const greaterThan: { (that: BigDecimal): (self: BigDecimal) => boolean; (self: BigDecimal, that: BigDecimal): boolean; }\n```\n\n----------------------------------------\n\nTITLE: Array.splitWhere Function Signature in Effect Library\nDESCRIPTION: The TypeScript type signature for the Array.splitWhere function, showing its polymorphic interface that supports both curried and uncurried calling styles with proper type inference.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Array-splitWhere.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const splitWhere: { <A>(predicate: (a: NoInfer<A>, i: number) => boolean): (self: Iterable<A>) => [beforeMatch: Array<A>, fromMatch: Array<A>]; <A>(self: Iterable<A>, predicate: (a: A, i: number) => boolean): [beforeMatch: Array<A>, fromMatch: Array<A>]; }\n```\n\n----------------------------------------\n\nTITLE: Declaring OpSupervision Runtime Flag in TypeScript\nDESCRIPTION: Defines the OpSupervision constant as a RuntimeFlag type. This flag controls whether the Effect runtime system supervises all operations, which impacts performance but is necessary for features like profiling.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/RuntimeFlags-OpSupervision.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const OpSupervision: RuntimeFlag\n```\n\n----------------------------------------\n\nTITLE: Merging Cookies Objects in TypeScript\nDESCRIPTION: Function signature for combining two Cookies objects while handling duplicates. The function provides two overloads: a curried version taking 'that' first, and a standard version taking both parameters at once.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Cookies-merge.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const merge: { (that: Cookies): (self: Cookies) => Cookies; (self: Cookies, that: Cookies): Cookies; }\n```\n\n----------------------------------------\n\nTITLE: Random.choice Function Signature in TypeScript\nDESCRIPTION: This code snippet shows the TypeScript signature of the Random.choice function. It defines the function's type constraints and return types based on the input iterable type.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Random-choice.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const choice: <Self extends Iterable<unknown>>(elements: Self) => Self extends NonEmptyIterable.NonEmptyIterable<infer A> ? Effect.Effect<A> : Self extends Array.NonEmptyReadonlyArray<infer A> ? Effect.Effect<A> : Self extends Iterable<infer A> ? Effect.Effect<A, Cause.NoSuchElementException> : never\n```\n\n----------------------------------------\n\nTITLE: Defining Layer.flatten Function in TypeScript\nDESCRIPTION: Declares the flatten function for flattening layers nested in the context of an effect. It has two overloads to handle different parameter orders.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Layer-flatten.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const flatten: { <I, A, E2, R2>(tag: Context.Tag<I, Layer<A, E2, R2>>): <E, R>(self: Layer<I, E, R>) => Layer<A, E2 | E, R2 | R>; <I, E, R, A, E2, R2>(self: Layer<I, E, R>, tag: Context.Tag<I, Layer<A, E2, R2>>): Layer<A, E | E2, R | R2>; }\n```\n\n----------------------------------------\n\nTITLE: Defining the DeepMutable Utility in TypeScript\nDESCRIPTION: This code snippet provides the type definition for the DeepMutable utility, which recursively transforms all readonly properties of a given type to mutable ones in TypeScript. It handles various data structures like ReadonlyMap and ReadonlySet. There are no specific parameter constraints, and the utility is designed for use in TypeScript projects requiring mutable transformations.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Types-DeepMutable.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ntype DeepMutable<T> = T extends ReadonlyMap<infer K, infer V> ? Map<DeepMutable<K>, DeepMutable<V>>\n  : T extends ReadonlySet<infer V> ? Set<DeepMutable<V>>\n  : T extends string | number | boolean | bigint | symbol ? T\n  : { -readonly [K in keyof T]: DeepMutable<T[K]> }\n```\n\n----------------------------------------\n\nTITLE: Type Signature of Stream.repeatValue in TypeScript\nDESCRIPTION: This code snippet provides the TypeScript type signature for the 'Stream.repeatValue' function. It describes 'repeatValue' as a function that takes a value of any type 'A' and returns a 'Stream' of that type. No additional dependencies are specified.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-repeatValue.md#2025-04-11_snippet_1\n\nLANGUAGE: ts\nCODE:\n```\ndeclare const repeatValue: <A>(value: A) => Stream<A>\n```\n\n----------------------------------------\n\nTITLE: Match.whenOr Function Signature in TypeScript\nDESCRIPTION: This code snippet shows the TypeScript signature of the Match.whenOr function. It defines the function's type parameters and return type, illustrating its flexibility in handling various pattern matching scenarios.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Match-whenOr.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const whenOr: <R, const P extends ReadonlyArray<Types.PatternPrimitive<R> | Types.PatternBase<R>>, Ret, Fn extends (_: Types.WhenMatch<R, P[number]>) => Ret>(...args: [...patterns: P, f: Fn]) => <I, F, A, Pr>(self: Matcher<I, F, R, A, Pr, Ret>) => Matcher<I, Types.AddWithout<F, Types.PForExclude<P[number]>>, Types.ApplyFilters<I, Types.AddWithout<F, Types.PForExclude<P[number]>>>, A | ReturnType<Fn>, Pr, Ret>\n```\n\n----------------------------------------\n\nTITLE: Checking Inclusion of RuntimeFlags in RuntimeFlagsPatch in TypeScript\nDESCRIPTION: The includes function checks if a RuntimeFlagsPatch contains a specified RuntimeFlag. It returns a boolean indicating whether the flag is included in the patch. This function supports both curried and non-curried calling styles.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/RuntimeFlagsPatch-includes.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const includes: { (flag: RuntimeFlagsPatch): (self: RuntimeFlagsPatch) => boolean; (self: RuntimeFlagsPatch, flag: RuntimeFlagsPatch): boolean; }\n```\n\n----------------------------------------\n\nTITLE: Converting Either to Micro Effect in TypeScript\nDESCRIPTION: Function signature for converting an Either type to a Micro effect. The function takes an Either containing right (R) and left (L) types and returns a Micro effect that will fail with L or succeed with R.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Micro-fromEither.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const fromEither: <R, L>(either: Either.Either<R, L>) => Micro<R, L>\n```\n\n----------------------------------------\n\nTITLE: Testing String Non-Emptiness in TypeScript\nDESCRIPTION: Function that checks whether a given string is non-empty. Takes a string parameter and returns a boolean indicating if the string has any content.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/String-isNonEmpty.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const isNonEmpty: (self: string) => boolean\n```\n\n----------------------------------------\n\nTITLE: Type Signature for Array.groupWith Function\nDESCRIPTION: Provides the TypeScript type signature for the Array.groupWith function. Shows both the curried and uncurried versions of the function that operate on NonEmptyReadonlyArray types.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Array-groupWith.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const groupWith: { <A>(isEquivalent: (self: A, that: A) => boolean): (self: NonEmptyReadonlyArray<A>) => NonEmptyArray<NonEmptyArray<A>>; <A>(self: NonEmptyReadonlyArray<A>, isEquivalent: (self: A, that: A) => boolean): NonEmptyArray<NonEmptyArray<A>>; }\n```\n\n----------------------------------------\n\nTITLE: Creating Dual Monoid by Reversing Combine Operation in TypeScript\nDESCRIPTION: The reverse function creates the dual of a Monoid by swapping the arguments of the combine operation. It takes a Monoid instance and returns a new Monoid with the same type but with reversed combination logic.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Monoid-reverse.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const reverse: <A>(M: Monoid<A>) => Monoid<A>\n```\n\n----------------------------------------\n\nTITLE: TaggedClass Type Signature\nDESCRIPTION: Type signature for the TaggedClass constructor showing its generic parameters and return type structure.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Data-TaggedClass.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const TaggedClass: <Tag extends string>(tag: Tag) => new <A extends Record<string, any> = {}>(args: Types.Equals<A, {}> extends true ? void : { readonly [P in keyof A as P extends \"_tag\" ? never : P]: A[P]; }) => Readonly<A> & { readonly _tag: Tag; }\n```\n\n----------------------------------------\n\nTITLE: TypeScript Signature for Match.tags Function\nDESCRIPTION: Provides the TypeScript type signature for the Match.tags function. It shows the complex generic types used to ensure type safety when matching on discriminated unions.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Match-tags.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const tags: <R, Ret, P extends { readonly [Tag in Types.Tags<\"_tag\", R> & string]?: ((_: Extract<R, Record<\"_tag\", Tag>>) => Ret) | undefined; } & { readonly [Tag in Exclude<keyof P, Types.Tags<\"_tag\", R>>]: never; }>(fields: P) => <I, F, A, Pr>(self: Matcher<I, F, R, A, Pr, Ret>) => Matcher<I, Types.AddWithout<F, Extract<R, Record<\"_tag\", keyof P>>>, Types.ApplyFilters<I, Types.AddWithout<F, Extract<R, Record<\"_tag\", keyof P>>>>, A | ReturnType<P[keyof P] & {}>, Pr, Ret>\n```\n\n----------------------------------------\n\nTITLE: Binding Micro Effect with bindTo Function in TypeScript\nDESCRIPTION: The `bindTo` function binds the success value of a `Micro` effect to a specified name of type string. It returns a new `Micro` effect with the success value mapped to the provided name. This function requires no external dependencies and accepts a `Micro` effect and a name as parameters, returning a mapped effect. There are no explicit constraints beyond the type requirements.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Micro-bindTo.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const bindTo: { <N extends string>(name: N): <A, E, R>(self: Micro<A, E, R>) => Micro<{ [K in N]: A; }, E, R>; <A, E, R, N extends string>(self: Micro<A, E, R>, name: N): Micro<{ [K in N]: A; }, E, R>; }\n```\n\n----------------------------------------\n\nTITLE: Prepending Elements to a Chunk in TypeScript\nDESCRIPTION: This example demonstrates how to use the Chunk.prependAll function to prepend elements to the beginning of a Chunk. It creates two Chunks, prepends one to the other, and converts the result to an array.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Chunk-prependAll.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Chunk } from \"effect\"\n\nconst result = Chunk.make(1, 2).pipe(Chunk.prependAll(Chunk.make(\"a\", \"b\")), Chunk.toArray)\n\nconsole.log(result)\n// [ \"a\", \"b\", 1, 2 ]\n```\n\n----------------------------------------\n\nTITLE: Declaring DateTimeUpdateFromNumber Field Type in TypeScript\nDESCRIPTION: Declaration of a constant that represents a date-time field that is automatically updated with the current UTC datetime. This field is serialized as a number and is set to the current DateTime.Utc value when records are inserted or updated.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Model-DateTimeUpdateFromNumber.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const DateTimeUpdateFromNumber: DateTimeUpdateFromNumber\n```\n\n----------------------------------------\n\nTITLE: Creating Micro Effect with None Option\nDESCRIPTION: Declares a Micro effect that always succeeds with None, useful for scenarios requiring an empty optional result. Part of the Effect-TS library's Micro module.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Micro-succeedNone.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const succeedNone: Micro<Option.Option<never>, never, never>\n```\n\n----------------------------------------\n\nTITLE: Defining Intervals Interface in TypeScript\nDESCRIPTION: Defines the `Intervals` interface in TypeScript, representing a collection of `Interval` objects. It includes a type identifier (`IntervalsTypeId`) and a `Chunk` of `Interval` objects. This interface is used within the Effect library for scheduling tasks.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/ScheduleIntervals-Intervals.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface Intervals {\n  readonly [IntervalsTypeId]: IntervalsTypeId\n  readonly intervals: Check.Chunk<Interval.Interval>\n}\n```\n\n----------------------------------------\n\nTITLE: TypeScript Function Signature for Array.dedupeAdjacentWith\nDESCRIPTION: Provides the TypeScript function signature for the Array.dedupeAdjacentWith function. It shows that the function can be used in two ways: as a higher-order function returning another function, or directly with both arguments.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Array-dedupeAdjacentWith.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const dedupeAdjacentWith: { <A>(isEquivalent: (self: A, that: A) => boolean): (self: Iterable<A>) => Array<A>; <A>(self: Iterable<A>, isEquivalent: (self: A, that: A) => boolean): Array<A>; }\n```\n\n----------------------------------------\n\nTITLE: Defining Text Document Interface in TypeScript\nDESCRIPTION: TypeScript interface definition for the Text document type within the Doc namespace. This interface represents a document containing a string of text with invariants that the text cannot be less than two characters and cannot contain newline characters.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Doc-Text.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface Text<A> extends Doc.Variance<A> {\n  readonly _tag: \"Text\"\n  readonly text: string\n}\n```\n\n----------------------------------------\n\nTITLE: Checking if one number is greater than another in TypeScript\nDESCRIPTION: The `greaterThan` function checks if the first number is greater than the second. It returns a boolean value indicating the result. The function supports two calling conventions; it can be called with both arguments at once or curried with one argument followed by another. This functionality is essential for conditional logic where numeric comparisons are needed.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Number-greaterThan.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { greaterThan } from \"effect/Number\"\n\nassert.deepStrictEqual(greaterThan(2, 3), false)\nassert.deepStrictEqual(greaterThan(3, 3), false)\nassert.deepStrictEqual(greaterThan(4, 3), true)\n```\n\n----------------------------------------\n\nTITLE: Type Guard Function for Doc Failure State in TypeScript\nDESCRIPTION: A type guard function that checks if a Doc<A> instance is specifically a Fail<A> variant. Returns true if the Doc is a Fail, false otherwise. This is useful for type narrowing and conditional logic based on Doc state.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Doc-isFail.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const isFail: <A>(self: Doc<A>) => self is Fail<A>\n```\n\n----------------------------------------\n\nTITLE: Declaring the timedWith Function in TypeScript\nDESCRIPTION: TypeScript signature of the timedWith function that measures effect execution time using a custom clock. The function can be called with either effect-first or clock-first parameter order, returning a tuple containing the execution duration and the original effect's result.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-timedWith.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const timedWith: { <E1, R1>(nanoseconds: Effect<bigint, E1, R1>): <A, E, R>(self: Effect<A, E, R>) => Effect<[Duration.Duration, A], E1 | E, R1 | R>; <A, E, R, E1, R1>(self: Effect<A, E, R>, nanoseconds: Effect<bigint, E1, R1>): Effect<[Duration.Duration, A], E | E1, R | R1>; }\n```\n\n----------------------------------------\n\nTITLE: Using Array.dropWhile to Remove Elements While Condition is True in TypeScript\nDESCRIPTION: This example demonstrates how to use the Array.dropWhile function to remove elements from the beginning of an array as long as they satisfy a given predicate. In this case, it removes all numbers less than 4.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Array-dropWhile.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Array } from \"effect\"\n\nconst result = Array.dropWhile([1, 2, 3, 4, 5], x => x < 4)\nconsole.log(result) // [4, 5]\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Array Cartesian Product in TypeScript\nDESCRIPTION: This example shows how to use the Array.cartesian function to create a cartesian product of two arrays. It combines each element of the first array with each element of the second array.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Array-cartesian.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Array } from \"effect\"\n\nconst result = Array.cartesian([1, 2], [\"a\", \"b\"])\nconsole.log(result) // [[1, \"a\"], [1, \"b\"], [2, \"a\"], [2, \"b\"]]\n```\n\n----------------------------------------\n\nTITLE: TSet retainIf Signature (TypeScript)\nDESCRIPTION: This snippet presents the TypeScript signature of the `retainIf` function, demonstrating its type parameters and overloads. It shows how the function can be used to filter elements in a `TSet` based on a predicate, with options for discarding or returning removed elements.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TSet-retainIf.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const retainIf: { <A>(predicate: Predicate<A>, options: { readonly discard: true; }): (self: TSet<A>) => STM.STM<void>; <A>(predicate: Predicate<A>, options?: { readonly discard: false; }): (self: TSet<A>) => STM.STM<Array<A>>; <A>(self: TSet<A>, predicate: Predicate<A>, options: { readonly discard: true; }): STM.STM<void>; <A>(self: TSet<A>, predicate: Predicate<A>, options?: { readonly discard: false; }): STM.STM<Array<A>>; }\n```\n\n----------------------------------------\n\nTITLE: Creating BigDecimal from bigint and scale in TypeScript\nDESCRIPTION: Creates a BigDecimal instance from a bigint value and a scale. The scale represents the number of decimal places.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/BigDecimal-make.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const make: (value: bigint, scale: number) => BigDecimal\n```\n\n----------------------------------------\n\nTITLE: TypeScript Signature of prettyLogger Function in Effect Library\nDESCRIPTION: This code snippet shows the TypeScript signature of the prettyLogger function from the Effect library. It defines the function's parameters and return type, indicating its configuration options for colors, output stream, date formatting, and mode.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Logger-prettyLogger.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const prettyLogger: (options?: { readonly colors?: \"auto\" | boolean | undefined; readonly stderr?: boolean | undefined; readonly formatDate?: ((date: Date) => string) | undefined; readonly mode?: \"browser\" | \"tty\" | \"auto\" | undefined; }) => Logger<unknown, void>\n```\n\n----------------------------------------\n\nTITLE: Using unsafeDivide in Effect's Number Module with TypeScript\nDESCRIPTION: This TypeScript code snippet demonstrates the use of the `unsafeDivide` function from the `effect/Number` module. It performs division and handles errors when the divisor is zero. The example requires Node.js assert module for validation. The main parameters are the dividend and divisor, with output being the result of the division or an error if divisor is zero.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Number-unsafeDivide.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { unsafeDivide } from \"effect/Number\"\n\nassert.deepStrictEqual(unsafeDivide(6, 3), 2)\n```\n\n----------------------------------------\n\nTITLE: Extracting Left Values from Either Records using Effect TypeScript\nDESCRIPTION: The `Record.getLefts` function takes a record containing Either values and returns a new record that includes only the Left values, keeping the original keys intact. This functionality is useful for filtering results when working with Either types in TypeScript applications that utilize the Effect framework.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Record-getLefts.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { Record, Either } from \"effect\"\n\nassert.deepStrictEqual(\n  Record.getLefts({ a: Either.right(1), b: Either.left(\"err\"), c: Either.right(2) }),\n  { b: \"err\" }\n)\n```\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const getLefts: <K extends string, R, L>(self: ReadonlyRecord<K, Either<R, L>>) => Record<ReadonlyRecord.NonLiteralKey<K>, L>\n```\n\n----------------------------------------\n\nTITLE: Defining mapConcatChunkEffect Function in TypeScript\nDESCRIPTION: This code snippet defines the mapConcatChunkEffect function, which effectfully maps each element of a stream to a chunk and flattens the chunks into the output stream. It supports both curried and uncurried versions of the function.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-mapConcatChunkEffect.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const mapConcatChunkEffect: { <A, A2, E2, R2>(f: (a: A) => Effect.Effect<Chunk.Chunk<A2>, E2, R2>): <E, R>(self: Stream<A, E, R>) => Stream<A2, E2 | E, R2 | R>; <A, E, R, A2, E2, R2>(self: Stream<A, E, R>, f: (a: A) => Effect.Effect<Chunk.Chunk<A2>, E2, R2>): Stream<A2, E | E2, R | R2>; }\n```\n\n----------------------------------------\n\nTITLE: Converting RuntimeFlags to ReadonlySet in TypeScript\nDESCRIPTION: The toSet function converts a RuntimeFlags object into a ReadonlySet of RuntimeFlag values. This allows for different operations on the flags using the Set API.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/RuntimeFlags-toSet.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const toSet: (self: RuntimeFlags) => ReadonlySet<RuntimeFlag>\n```\n\n----------------------------------------\n\nTITLE: Implementing Request Completion in TypeScript using Effect-TS\nDESCRIPTION: Function signature for completing a Request with a specified result. The function can be called either with the result first followed by the request, or with the request first followed by the result. Returns an Effect of void.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Request-complete.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const complete: { \n  <A extends Request<any, any>>(result: Request.Result<A>): (self: A) => Effect.Effect<void>; \n  <A extends Request<any, any>>(self: A, result: Request.Result<A>): Effect.Effect<void>; \n}\n```\n\n----------------------------------------\n\nTITLE: Declaring DurationFromNanos Class in TypeScript\nDESCRIPTION: This code snippet declares the DurationFromNanos class, which is a schema that transforms a non-negative bigint representing nanoseconds into a Duration object. It's part of the Schema module in the effect package.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Schema-DurationFromNanos.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare class DurationFromNanos\n```\n\n----------------------------------------\n\nTITLE: HashSet.reduce Type Definition\nDESCRIPTION: Type signature for the HashSet.reduce function showing both data-first and data-last overloads. Takes a zero value, a reducer function, and returns either a function that takes a HashSet or the reduced value directly.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/HashSet-reduce.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const reduce: { <A, Z>(zero: Z, f: (accumulator: Z, value: A) => Z): (self: HashSet<A>) => Z; <A, Z>(self: HashSet<A>, zero: Z, f: (accumulator: Z, value: A) => Z): Z; }\n```\n\n----------------------------------------\n\nTITLE: Creating a failing Take with a Cause in Effect (TypeScript)\nDESCRIPTION: The `failCause` function constructs a `Take` that immediately fails with the given `Cause`. This is useful for representing situations where data consumption has failed due to a specific error or interruption. The function is generic over the error type `E`.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Take-failCause.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const failCause: <E>(cause: Cause.Cause<E>) => Take<never, E>\n```\n\n----------------------------------------\n\nTITLE: Implementing Semigroup.struct Type Definition in TypeScript\nDESCRIPTION: Type definition for the struct function that creates a Semigroup for structured data. It accepts an object containing Semigroup implementations for each field and returns a new Semigroup that can combine objects with matching structure.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Semigroup-struct.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const struct: <R extends { readonly [x: string]: Semigroup<any>; }>(fields: R) => Semigroup<{ readonly [K in keyof R]: [R[K]] extends [Semigroup<infer A>] ? A : never; }>\n```\n\n----------------------------------------\n\nTITLE: Finding Maximum Element in Array using Effect Library in TypeScript\nDESCRIPTION: This snippet demonstrates how to use the Array.max function from the Effect library to find the maximum element in an array of numbers. It uses the Order.number comparator to determine the maximum value.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Array-max.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Array, Order } from \"effect\"\n\nconst result = Array.max([3, 1, 2], Order.number)\nconsole.log(result) // 3\n```\n\n----------------------------------------\n\nTITLE: Defining Bigint Matcher in TypeScript\nDESCRIPTION: Declares a constant 'bigint' that refines unknown values to bigint type. This function is part of the Match module in the Effect library and is used for type-safe matching of bigint values.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Match-bigint.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const bigint: Predicate.Refinement<unknown, bigint>\n```\n\n----------------------------------------\n\nTITLE: Performing Safe Number Division with Effect Option\nDESCRIPTION: Demonstrates division operation that returns an Option type, handling both successful division and division by zero scenarios\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Number-divide.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { Number, Option }\n\nassert.deepStrictEqual(Number.divide(6, 3), Option.some(2))\nassert.deepStrictEqual(Number.divide(6, 0), Option.none())\n```\n\n----------------------------------------\n\nTITLE: Mapping STM Effect with Exception Handling in TypeScript\nDESCRIPTION: A function that maps the value of an STM effect using a transformation function that might throw exceptions. It safely translates any thrown exceptions into typed failed effects, preserving the effect's transactional nature.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/STM-mapAttempt.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const mapAttempt: { <A, B>(f: (a: A) => B): <E, R>(self: STM<A, E, R>) => STM<B, unknown, R>; <A, E, R, B>(self: STM<A, E, R>, f: (a: A) => B): STM<B, unknown, R>; }\n```\n\n----------------------------------------\n\nTITLE: Creating Lazy Micro Effects in TypeScript with Micro.sync\nDESCRIPTION: Creates a Micro effect that succeeds with a lazily evaluated value. If the evaluation of the value throws an error, the effect will fail with a Die variant of the MicroCause type.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Micro-sync.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const sync: <A>(evaluate: LazyArg<A>) => Micro<A>\n```\n\n----------------------------------------\n\nTITLE: Defining Order Structure Using TypeScript Generics\nDESCRIPTION: This snippet defines a function that creates a new Order based on an input struct. It uses TypeScript generics to allow for flexible property definitions while ensuring type correctness.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Order-struct.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const struct: <R extends { readonly [x: string]: Order<any>; }>(fields: R) => Order<{ [K in keyof R]: [R[K]] extends [Order<infer A>] ? A : never; }>\n```\n\n----------------------------------------\n\nTITLE: Composing Contravariant Functors in TypeScript\nDESCRIPTION: The contramapComposition function takes two contravariant functors F and G and returns a function that composes them. It allows mapping over the composed structure with a function f that transforms A to B. This composition results in a covariant functor.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Contravariant-contramapComposition.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const contramapComposition: <F extends TypeLambda, G extends TypeLambda>(F: Contravariant<F>, G: Contravariant<G>) => <FR, FO, FE, GR, GO, GE, A, B>(self: Kind<F, FR, FO, FE, Kind<G, GR, GO, GE, A>>, f: (a: A) => B) => Kind<F, FR, FO, FE, Kind<G, GR, GO, GE, B>>\n```\n\n----------------------------------------\n\nTITLE: Extracting Values from ReadonlyRecord in TypeScript\nDESCRIPTION: Function signature for retrieving all values from a ReadonlyRecord and returning them as an array. Takes a ReadonlyRecord with string keys and generic type values as input and returns an array of those values.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Record-values.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const values: <K extends string, A>(self: ReadonlyRecord<K, A>) => Array<A>\n```\n\n----------------------------------------\n\nTITLE: Using constTrue Function in TypeScript with effect/Function\nDESCRIPTION: Example demonstrating how to use the constTrue function from effect/Function module. It imports the function and demonstrates that it always returns true when called.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Function-constTrue.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { constTrue } from \"effect/Function\"\n\nassert.deepStrictEqual(constTrue(), true)\n```\n\n----------------------------------------\n\nTITLE: Defining Bearer Token Security Scheme in TypeScript\nDESCRIPTION: Creates a Bearer token security scheme. This can be implemented in API middleware using HttpApiBuilder.middlewareSecurity. The constant 'bearer' is of type Bearer.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/HttpApiSecurity-bearer.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const bearer: Bearer\n```\n\n----------------------------------------\n\nTITLE: Implementing Covariant Map Composition in TypeScript\nDESCRIPTION: Defines a mapComposition function that enables composing two Covariant typeclasses F and G to create a new mapping operation. The function handles nested type transformations while preserving the structure of both type constructors.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Covariant-mapComposition.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const mapComposition: <F extends TypeLambda, G extends TypeLambda>(F: Covariant<F>, G: Covariant<G>) => <FR, FO, FE, GR, GO, GE, A, B>(self: Kind<F, FR, FO, FE, Kind<G, GR, GO, GE, A>>, f: (a: A) => B) => Kind<F, FR, FO, FE, Kind<G, GR, GO, GE, B>>\n```\n\n----------------------------------------\n\nTITLE: Erasing Sensitive Data using Redacted Module in TypeScript\nDESCRIPTION: This code snippet demonstrates how to use the 'unsafeWipe' function from the 'Redacted' module to securely erase a sensitive value from memory. Dependencies include the 'effect' package. The 'unsafeWipe' function takes a 'Redacted' instance as input and returns a boolean indicating whether the operation was successful. It ensures that sensitive data does not remain in memory by making it unrecoverable.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Redacted-unsafeWipe.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { Redacted } from \"effect\"\n\nconst API_KEY = Redacted.make(\"1234567890\")\n\nassert.equal(Redacted.value(API_KEY), \"1234567890\")\n\nRedacted.unsafeWipe(API_KEY)\n\nassert.throws(() => Redacted.value(API_KEY), new Error(\"Unable to get redacted value\"))\n```\n\n----------------------------------------\n\nTITLE: Defining ShardingRegistrationEvent Union Type in TypeScript\nDESCRIPTION: Defines a union type that represents two possible registration events in a sharding system: EntityRegistered and SingletonRegistered. This type is used to handle registration events for both entities and singletons in the Effect cluster package.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/ShardingRegistrationEvent-ShardingRegistrationEvent.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ntype ShardingRegistrationEvent = | EntityRegistered\n  | SingletonRegistered\n```\n\n----------------------------------------\n\nTITLE: Declaration of attachPropertySignature in Effect Schema\nDESCRIPTION: This code snippet shows the TypeScript declaration of the `attachPropertySignature` function within the Effect Schema module.  It outlines the function's type signatures, including how it accepts a key, value, and optional annotations to add a property signature to a schema, refining the schema's type.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Schema-attachPropertySignature.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const attachPropertySignature: { <K extends PropertyKey, V extends AST.LiteralValue | symbol, A>(key: K, value: V, annotations?: Annotations.Schema<Simplify<A & { readonly [k in K]: V; }>>): <I, R>(schema: SchemaClass<A, I, R>) => SchemaClass<Simplify<A & { readonly [k in K]: V; }>, I, R>; <A, I, R, K extends PropertyKey, V extends AST.LiteralValue | symbol>(schema: Schema<A, I, R>, key: K, value: V, annotations?: Annotations.Schema<Simplify<A & { readonly [k in K]: V; }>>): SchemaClass<Simplify<A & { readonly [k in K]: V; }>, I, R>; }\n```\n\n----------------------------------------\n\nTITLE: RegExp.escape Function Signature\nDESCRIPTION: Type declaration for the RegExp.escape function, showing it takes a string parameter and returns a string with escaped special characters.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/RegExp-escape.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const escape: (string: string) => string\n```\n\n----------------------------------------\n\nTITLE: Declaring TimeZoneOffset Class in TypeScript\nDESCRIPTION: This snippet declares the TimeZoneOffset class, which is designed to convert a number into a TimeZone.Offset instance. It provides a structured way to handle timezone offsets within the Effect-TS framework, leveraging the DateTime.zoneMakeOffset constructor. Ensure to use this class in conjunction with the DateTime functionalities provided by Effect-TS.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Schema-TimeZoneOffset.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare class TimeZoneOffset\n```\n\n----------------------------------------\n\nTITLE: Stream fromSchedule Type Signature in TypeScript\nDESCRIPTION: Provides the type declaration for the Stream.fromSchedule method, showing its generic type parameters and return type\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-fromSchedule.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const fromSchedule: <A, R>(schedule: Schedule.Schedule<A, unknown, R>) => Stream<A, never, R>\n```\n\n----------------------------------------\n\nTITLE: Creating Default imap Implementation for Contravariant Functors in TypeScript\nDESCRIPTION: This function returns a default implementation of the 'imap' operation for Contravariant functors. It takes a 'contramap' function and uses it to create an implementation that satisfies the Invariant typeclass requirements.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Contravariant-imap.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const imap: <F extends TypeLambda>(contramap: <R, O, E, A, B>(self: Kind<F, R, O, E, A>, f: (b: B) => A) => Kind<F, R, O, E, B>) => Invariant<F>[\"imap\"]\n```\n\n----------------------------------------\n\nTITLE: Implementing Stream.zipRight in TypeScript\nDESCRIPTION: Function signature for zipRight operation that combines two streams point-wise while keeping only the right stream's outputs. The operation terminates when either stream ends. Supports both curried and non-curried function calls.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-zipRight.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const zipRight: { <AR, ER, RR>(right: Stream<AR, ER, RR>): <AL, EL, RL>(left: Stream<AL, EL, RL>) => Stream<AR, ER | EL, RR | RL>; <AL, EL, RL, AR, ER, RR>(left: Stream<AL, EL, RL>, right: Stream<AR, ER, RR>): Stream<AR, EL | ER, RL | RR>; }\n```\n\n----------------------------------------\n\nTITLE: Constructing Layer from Effect Context in TypeScript\nDESCRIPTION: Function signature for effectContext, which creates a Layer from an Effect that returns a Context containing one or more services. The function is generic over the service type A, error type E, and requirement type R.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Layer-effectContext.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const effectContext: <A, E, R>(effect: Effect.Effect<Context.Context<A>, E, R>) => Layer<A, E, R>\n```\n\n----------------------------------------\n\nTITLE: Updating URL Search Parameters in TypeScript\nDESCRIPTION: A utility function that allows updating the query string of a URL with two method signatures for flexible usage. Can be used with function currying or direct application.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Url-setSearch.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const setSearch: { (search: string): (url: URL) => URL; (url: URL, search: string): URL; }\n```\n\n----------------------------------------\n\nTITLE: Retrieving Right Values from Iterable of Eithers in TypeScript\nDESCRIPTION: This snippet demonstrates how to use the Iterable.getRights function to extract Right values from an Iterable of Either types. It imports necessary modules, creates an array of Either values, and uses getRights to filter out the Right values.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Iterable-getRights.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { Iterable, Either } from \"effect\"\n\nassert.deepStrictEqual(\n  Array.from(Iterable.getRights([Either.right(1), Either.left(\"err\"), Either.right(2)])),\n  [1, 2]\n)\n```\n\n----------------------------------------\n\nTITLE: Declaring flattenChunks Function Using TypeScript\nDESCRIPTION: This function declaration specifies that flattenChunks takes a Stream of Chunk type and returns a Stream of the flattened type. It is part of the Stream module in the Effect library, intended for simplifying the handling of chunks within streams.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-flattenChunks.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const flattenChunks: <A, E, R>(self: Stream<Chunk.Chunk<A>, E, R>) => Stream<A, E, R>\n```\n\n----------------------------------------\n\nTITLE: Implementing Exit.zipWith Function in TypeScript\nDESCRIPTION: Defines a function that combines two Exit instances using provided success and failure handlers. It supports both curried and direct invocation patterns, allowing flexible combination of exit states with custom error and success transformations.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Exit-zipWith.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const zipWith: { \n  <B, E2, A, C, E>(\n    that: Exit<B, E2>, \n    options: { \n      readonly onSuccess: (a: A, b: B) => C; \n      readonly onFailure: (cause: Cause.Cause<E>, cause2: Cause.Cause<E2>) => Cause.Cause<any>; \n    }\n  ): (self: Exit<A, E>) => Exit<C, any>; \n  <A, E, B, E2, C>(\n    self: Exit<A, E>, \n    that: Exit<B, E2>, \n    options: { \n      readonly onSuccess: (a: A, b: B) => C; \n      readonly onFailure: (cause: Cause.Cause<E>, cause2: Cause.Cause<E2>) => Cause.Cause<E | E2>; \n    }\n  ): Exit<C, E | E2>; \n}\n```\n\n----------------------------------------\n\nTITLE: Checking for Empty List in TypeScript\nDESCRIPTION: The isNil function determines if a given List is empty (Nil). It returns true for an empty List and false otherwise. This function is type-safe, narrowing the type to Nil<A> when true.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/List-isNil.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const isNil: <A>(self: List<A>) => self is Nil<A>\n```\n\n----------------------------------------\n\nTITLE: Adding Multiple Cookies to a Cookies Object in TypeScript\nDESCRIPTION: The `setAll` function allows adding multiple cookies to a Cookies object. It accepts an iterable of cookie entries (name, value, and optional settings) and returns either a new Cookies object or a CookiesError.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Cookies-setAll.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const setAll: { (cookies: Iterable<readonly [name: string, value: string, options?: Cookie[\"options\"]]>): (self: Cookies) => Either.Either<Cookies, CookiesError>; (self: Cookies, cookies: Iterable<readonly [name: string, value: string, options?: Cookie[\"options\"]]>): Either.Either<Cookies, CookiesError>; }\n```\n\n----------------------------------------\n\nTITLE: Defining Fusion Depth for Document Optimizer in TypeScript\nDESCRIPTION: This TypeScript snippet defines a type named 'FusionDepth', representing the depth to which a document optimizer should traverse a document tree. It can either be 'Shallow' or 'Deep', determining the level of optimization applied. No external dependencies are required. This type serves as a guide for document optimization processes.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Optimize-FusionDepth.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ntype FusionDepth = Shallow | Deep\n```\n\n----------------------------------------\n\nTITLE: Prompt.all Function Signature in TypeScript\nDESCRIPTION: This code snippet shows the TypeScript signature for the Prompt.all function. It accepts either an Iterable of Prompts or a Record of Prompts as an argument and returns a type that corresponds to the input structure.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Prompt-all.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const all: <const Arg extends Iterable<Prompt<any>> | Record<string, Prompt<any>>>(arg: Arg) => All.Return<Arg>\n```\n\n----------------------------------------\n\nTITLE: Type Signature of isUnknown Function in TypeScript\nDESCRIPTION: This code snippet shows the type signature of the isUnknown function. It takes an input of type unknown and returns a boolean indicating whether the input is of type unknown.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Predicate-isUnknown.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const isUnknown: (input: unknown) => input is unknown\n```\n\n----------------------------------------\n\nTITLE: Using Trie.toEntries to Convert Trie to Array in TypeScript\nDESCRIPTION: This example demonstrates how to use the Trie.toEntries function to convert a Trie data structure into an array of key-value pairs. It creates a Trie with two entries and then converts it to an array.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Trie-toEntries.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { Trie } from \"effect\"\n\nconst trie = Trie.empty<number>().pipe(\n  Trie.insert(\"call\", 0),\n  Trie.insert(\"me\", 1)\n)\nconst result = Trie.toEntries(trie)\n\nassert.deepStrictEqual(result, [[\"call\", 0], [\"me\", 1]])\n```\n\n----------------------------------------\n\nTITLE: Type Signature for vsep Combinator in @effect/printer (TypeScript)\nDESCRIPTION: Shows the TypeScript function signature for the `vsep` combinator that concatenates all documents in a collection vertically.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Doc-vsep.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const vsep: <A>(docs: Iterable<Doc<A>>) => Doc<A>\n```\n\n----------------------------------------\n\nTITLE: Stream.crossLeft Signature\nDESCRIPTION: This code snippet displays the TypeScript signature for the `Stream.crossLeft` function in the Effect library. It shows how two streams (`left` and `right`) are combined, with the resulting stream containing elements from the `left` stream and handling potential errors and runtime requirements from both.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-crossLeft.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const crossLeft: { <AR, ER, RR>(right: Stream<AR, ER, RR>): <AL, EL, RL>(left: Stream<AL, EL, RL>) => Stream<AL, EL | ER, RL | RR>; <AL, EL, RL, AR, ER, RR>(left: Stream<AL, EL, RL>, right: Stream<AR, ER, RR>): Stream<AL, EL | ER, RL | RR>; }\n```\n\n----------------------------------------\n\nTITLE: Transforming Error Causes in Stream - TypeScript\nDESCRIPTION: The `mapErrorCause` function allows developers to transform the errors emitted by a Stream into different error types, providing flexibility in error handling. The function accepts either a function to transform the cause or operates on a given stream directly. It requires the `Effect` library to be properly installed and configured. Key parameters include `f` which is the transformation function and `self` which is the Stream instance to operate on.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-mapErrorCause.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const mapErrorCause: { <E, E2>(f: (cause: Cause.Cause<E>) => Cause.Cause<E2>): <A, R>(self: Stream<A, E, R>) => Stream<A, E2, R>; <A, E, R, E2>(self: Stream<A, E, R>, f: (cause: Cause.Cause<E>) => Cause.Cause<E2>): Stream<A, E2, R>; }\n```\n\n----------------------------------------\n\nTITLE: Creating and Using a Mailbox in TypeScript with Effect Library\nDESCRIPTION: This code demonstrates how to create a Mailbox, add messages to it, take messages from it, and signal its completion or failure. It uses the Effect and Mailbox modules from the Effect library.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Mailbox-make.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { Effect, Mailbox } from \"effect\"\n\nEffect.gen(function*() {\n  const mailbox = yield* Mailbox.make<number, string>()\n\n  // add messages to the mailbox\n  yield* mailbox.offer(1)\n  yield* mailbox.offer(2)\n  yield* mailbox.offerAll([3, 4, 5])\n\n  // take messages from the mailbox\n  const [messages, done] = yield* mailbox.takeAll\n  assert.deepStrictEqual(messages, [1, 2, 3, 4, 5])\n  assert.strictEqual(done, false)\n\n  // signal that the mailbox is done\n  yield* mailbox.end\n  const [messages2, done2] = yield* mailbox.takeAll\n  assert.deepStrictEqual(messages2, [])\n  assert.strictEqual(done2, true)\n\n  // signal that the mailbox has failed\n  yield* mailbox.fail(\"boom\")\n})\n```\n\n----------------------------------------\n\nTITLE: Type signature for Doc.hang function in TypeScript\nDESCRIPTION: The type signature of the 'hang' combinator, showing it can be used either with curried parameter application or with both parameters at once. It takes an indent value and a Doc instance, returning a new Doc with adjusted indentation.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Doc-hang.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const hang: { (indent: number): <A>(self: Doc<A>) => Doc<A>; <A>(self: Doc<A>, indent: number): Doc<A>; }\n```\n\n----------------------------------------\n\nTITLE: Defining FileSystem.Size Type in TypeScript\nDESCRIPTION: Defines a Size type that represents file sizes in bytes. The type is implemented as a branded bigint with the 'Size' brand to provide type safety and prevent mixing with regular bigint values.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/FileSystem-Size.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ntype Size = Brand.Branded<bigint, \"Size\">\n```\n\n----------------------------------------\n\nTITLE: TypeScript Function Signature for DateTime.endOf\nDESCRIPTION: The type declaration for the endOf function in the DateTime module. It supports both pipeline and function call syntax and allows specifying a time unit and options for week start day.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/DateTime-endOf.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const endOf: { (part: DateTime.UnitSingular, options?: { readonly weekStartsOn?: 0 | 1 | 2 | 3 | 4 | 5 | 6 | undefined; }): <A extends DateTime>(self: A) => A; <A extends DateTime>(self: A, part: DateTime.UnitSingular, options?: { readonly weekStartsOn?: 0 | 1 | 2 | 3 | 4 | 5 | 6 | undefined; }): A; }\n```\n\n----------------------------------------\n\nTITLE: Checking Take Success in Effect TypeScript\nDESCRIPTION: This TypeScript function 'isSuccess' checks if a 'Take' instance, representing an operation in the 'Effect' package, is successful. No additional dependencies are required. The key parameter is 'self', a 'Take' instance with type parameters 'A' for success type and 'E' for error type. The output is a boolean indicating the success status of the 'Take' instance. This is used in contexts where it's necessary to differentiate between successful and non-successful 'Take' instances.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Take-isSuccess.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const isSuccess: <A, E>(self: Take<A, E>) => boolean\n```\n\n----------------------------------------\n\nTITLE: Logger.make Function Signature in TypeScript\nDESCRIPTION: This snippet shows the type signature of the Logger.make function. It takes a function that formats log messages and returns a Logger instance.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Logger-make.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const make: <Message, Output>(log: (options: Logger.Options<Message>) => Output) => Logger<Message, Output>\n```\n\n----------------------------------------\n\nTITLE: Retrieving Keys with Prefix from Trie in TypeScript\nDESCRIPTION: This snippet demonstrates how to use the keysWithPrefix function from the Effect-TS Trie module. It creates a Trie with multiple string keys, then retrieves and asserts the keys that have 'she' as a prefix.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Trie-keysWithPrefix.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { Trie } from \"effect\"\n\nconst trie = Trie.empty<number>().pipe(\n  Trie.insert(\"she\", 0),\n  Trie.insert(\"shells\", 1),\n  Trie.insert(\"sea\", 2),\n  Trie.insert(\"shore\", 3)\n)\n\nconst result = Array.from(Trie.keysWithPrefix(trie, \"she\"))\nassert.deepStrictEqual(result, [\"she\", \"shells\"])\n```\n\n----------------------------------------\n\nTITLE: Iterating HashSet Values in TypeScript using Effect Library\nDESCRIPTION: Demonstrates how to use the HashSet.values function to create an IterableIterator of the values in a HashSet. The example shows creating a HashSet, converting it to an iterable, and then logging each value.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/HashSet-values.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { HashSet, pipe } from \"effect\"\n\nconst numberIterable = pipe(\n  HashSet.make(0, 1, 1, 2), // HashSet.HashSet<number>\n  HashSet.values // takes an HashSet<A> and returns an IterableIterator<A>\n)\n\nfor (const number of numberIterable) {\n  console.log(number) // it will logs: 0, 1, 2\n}\n```\n\n----------------------------------------\n\nTITLE: Encoding UTF-8 Strings into URI Components in TypeScript\nDESCRIPTION: Function signature for encodeUriComponent which takes a string and returns either an encoded URI component string or an EncodeException. This function is part of the Encoding module in the effect package and has been available since version 3.12.0.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Encoding-encodeUriComponent.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const encodeUriComponent: (str: string) => Either.Either<string, EncodeException>\n```\n\n----------------------------------------\n\nTITLE: Implementing flatMap Operation on Chunks in TypeScript\nDESCRIPTION: The flatMap function applies a function to each element in a chunk and concatenates the results. It supports both regular and non-empty chunks, preserving non-emptiness when appropriate. The function includes an index parameter for each element.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Chunk-flatMap.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const flatMap: { <S extends Chunk<any>, T extends Chunk<any>>(f: (a: Chunk.Infer<S>, i: number) => T): (self: S) => Chunk.AndNonEmpty<S, T, Chunk.Infer<T>>; <A, B>(self: NonEmptyChunk<A>, f: (a: A, i: number) => NonEmptyChunk<B>): NonEmptyChunk<B>; <A, B>(self: Chunk<A>, f: (a: A, i: number) => Chunk<B>): Chunk<B>; }\n```\n\n----------------------------------------\n\nTITLE: Declaring lessThan Filter in TypeScript\nDESCRIPTION: The snippet declares a 'lessThan' filter function which checks if a number is less than a given exclusive maximum. It is part of the 'Schema' module, and can be applied to schemas of any subtype. Key parameters include 'exclusiveMaximum', which sets the upper bound, and optional 'annotations' for thorough validation.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Schema-lessThan.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const lessThan: <S extends Schema.Any>(exclusiveMaximum: number, annotations?: Annotations.Filter<Schema.Type<S>>) => <A extends number>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>) => filter<S>\n```\n\n----------------------------------------\n\nTITLE: Defining Layer.provide Function in TypeScript\nDESCRIPTION: Declares the provide function for the Layer module. This function combines layer builders, feeding the output services of one builder into the input of another, resulting in a new composite layer.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Layer-provide.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const provide: { <RIn, E, ROut>(that: Layer<ROut, E, RIn>): <RIn2, E2, ROut2>(self: Layer<ROut2, E2, RIn2>) => Layer<ROut2, E | E2, RIn | Exclude<RIn2, ROut>>; <const Layers extends [Layer.Any, ...Array<Layer.Any>]>(that: Layers): <A, E, R>(self: Layer<A, E, R>) => Layer<A, E | { [k in keyof Layers]: Layer.Error<Layers[k]>; }[number], { [k in keyof Layers]: Layer.Context<Layers[k]>; }[number] | Exclude<R, { [k in keyof Layers]: Layer.Success<Layers[k]>; }[number]>>; <RIn2, E2, ROut2, RIn, E, ROut>(self: Layer<ROut2, E2, RIn2>, that: Layer<ROut, E, RIn>): Layer<ROut2, E | E2, RIn | Exclude<RIn2, ROut>>; <A, E, R, const Layers extends [Layer.Any, ...Array<Layer.Any>]>(self: Layer<A, E, R>, that: Layers): Layer<A, E | { [k in keyof Layers]: Layer.Error<Layers[k]>; }[number], { [k in keyof Layers]: Layer.Context<Layers[k]>; }[number] | Exclude<R, { [k in keyof Layers]: Layer.Success<Layers[k]>; }[number]>>; }\n```\n\n----------------------------------------\n\nTITLE: Creating Failing Configurations with Config.fail in TypeScript\nDESCRIPTION: The fail function constructs a Config instance that always fails with the specified message. This is useful for representing configuration errors or impossible configurations. It returns a Config with a type parameter of never, indicating it never successfully resolves to a value.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Config-fail.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const fail: (message: string) => Config<never>\n```\n\n----------------------------------------\n\nTITLE: Schedule Resetting with Predicate in Effect\nDESCRIPTION: Resets the Effect Schedule when the specified predicate on the schedule output evaluates to `true`. It modifies the schedule to reset to its initial state whenever the provided predicate `f` returns `true` for an output value.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Schedule-resetWhen.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const resetWhen: { <Out>(f: Predicate<Out>): <In, R>(self: Schedule<Out, In, R>) => Schedule<Out, In, R>; <Out, In, R>(self: Schedule<Out, In, R>, f: Predicate<Out>): Schedule<Out, In, R>; }\n```\n\n----------------------------------------\n\nTITLE: Defining embedInput Function in Channel Module (TypeScript)\nDESCRIPTION: This snippet defines the embedInput function, which returns a new channel that connects a given AsyncInputProducer as the channel's input. It supports both curried and uncurried versions of the function.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Channel-embedInput.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const embedInput: {\n  <InErr, InElem, InDone>(input: SingleProducerAsyncInput.AsyncInputProducer<InErr, InElem, InDone>):\n    <OutElem, OutErr, OutDone, Env>(self: Channel<OutElem, unknown, OutErr, unknown, OutDone, unknown, Env>) =>\n      Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>;\n  <OutElem, OutErr, OutDone, Env, InErr, InElem, InDone>(\n    self: Channel<OutElem, unknown, OutErr, unknown, OutDone, unknown, Env>,\n    input: SingleProducerAsyncInput.AsyncInputProducer<InErr, InElem, InDone>\n  ): Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Array Comprehension with Do Simulation in TypeScript\nDESCRIPTION: This example demonstrates how to use the Array.Do pattern with bind and filter/map operations to create a concise array comprehension. It shows both the Do simulation approach and the equivalent traditional nested loop implementation.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Array-bindTo.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Array, pipe } from \"effect\"\n\nconst doResult = pipe(\n  Array.Do,\n  Array.bind(\"x\", () => [1, 3, 5]),\n  Array.bind(\"y\", () => [2, 4, 6]),\n  Array.filter(({ x, y }) => x < y), // condition\n  Array.map(({ x, y }) => [x, y] as const) // transformation\n)\nconsole.log(doResult) // [[1, 2], [1, 4], [1, 6], [3, 4], [3, 6], [5, 6]]\n\n// equivalent\nconst x = [1, 3, 5],\n      y = [2, 4, 6],\n      result = [];\nfor(let i = 0; i < x.length; i++) {\n  for(let j = 0; j < y.length; j++) {\n    const _x = x[i], _y = y[j];\n    if(_x < _y) result.push([_x, _y] as const)\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Checking if a RuntimeFlag is Disabled in TypeScript\nDESCRIPTION: This function checks whether a specified RuntimeFlag is disabled within a RuntimeFlags object. It can be used in two ways: curried (passing the flag first, then the RuntimeFlags) or with both parameters at once.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/RuntimeFlags-isDisabled.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const isDisabled: { (flag: RuntimeFlag): (self: RuntimeFlags) => boolean; (self: RuntimeFlags, flag: RuntimeFlag): boolean; }\n```\n\n----------------------------------------\n\nTITLE: Finding Elements in HashMap with Predicate Function in TypeScript\nDESCRIPTION: The findFirst function searches for the first element in a HashMap that satisfies the given predicate. It returns an Option containing a tuple of the key and value if found, or None if no element matches the predicate. The function supports type narrowing through type predicates.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/HashMap-findFirst.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const findFirst: { <K, A, B extends A>(predicate: (a: NoInfer<A>, k: K) => a is B): (self: HashMap<K, A>) => Option<[K, B]>; <K, A>(predicate: (a: NoInfer<A>, k: K) => boolean): (self: HashMap<K, A>) => Option<[K, A]>; <K, A, B extends A>(self: HashMap<K, A>, predicate: (a: A, k: K) => a is B): Option<[K, B]>; <K, A>(self: HashMap<K, A>, predicate: (a: A, k: K) => boolean): Option<[K, A]>; }\n```\n\n----------------------------------------\n\nTITLE: HashMap.getHash Implementation in TypeScript\nDESCRIPTION: Function definition for looking up values in a HashMap using a custom hash. Provides both curried and uncurried versions of the function that accept a key and hash value to retrieve an optional value from the HashMap.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/HashMap-getHash.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const getHash: { <K1>(key: K1, hash: number): <K, V>(self: HashMap<K, V>) => Option<V>; <K, V, K1>(self: HashMap<K, V>, key: K1, hash: number): Option<V>; }\n```\n\n----------------------------------------\n\nTITLE: Implementing Deferred.failSync in TypeScript\nDESCRIPTION: The failSync function fails a Deferred with a specified error. It propagates the error to all fibers waiting on the value of the Deferred. The function is overloaded to accept arguments in different orders.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Deferred-failSync.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const failSync: {\n  <E>(evaluate: LazyArg<E>): <A>(self: Deferred<A, E>) => Effect.Effect<boolean>;\n  <A, E>(self: Deferred<A, E>, evaluate: LazyArg<E>): Effect.Effect<boolean>;\n}\n```\n\n----------------------------------------\n\nTITLE: Reducing a Record in Effect\nDESCRIPTION: The `reduce` function iterates over a `ReadonlyRecord` and applies a reducer function `f` to each key-value pair, accumulating a result of type `Z`, starting with an initial value `zero`.  The function accepts either curried or uncurried arguments for flexibility in use. It is available since v2.0.0.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Record-reduce.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const reduce: { <Z, V, K extends string>(zero: Z, f: (accumulator: Z, value: V, key: K) => Z): (self: ReadonlyRecord<K, V>) => Z; <K extends string, V, Z>(self: ReadonlyRecord<K, V>, zero: Z, f: (accumulator: Z, value: V, key: K) => Z): Z; }\n```\n\n----------------------------------------\n\nTITLE: Returning an Effect with Empty Value Using TypeScript\nDESCRIPTION: The `succeedNone` constant is declared as an effect that represents an empty value in the STM module. This function is intended to facilitate the creation of effects that do not yield a result. This snippet requires the `Option` type from the `effect` library to handle optional values, and it is part of the STM functionality since version 2.0.0.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/STM-succeedNone.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const succeedNone: STM<Option.Option<never>, never, never>\n```\n\n----------------------------------------\n\nTITLE: Defining CauseTypeId Symbol in TypeScript\nDESCRIPTION: Declares a unique symbol that identifies the Cause data type. This symbol is used for type refinement and checking if a value is a Cause instance. It helps with advanced type operations and building internal utilities.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Cause-CauseTypeId.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const CauseTypeId: unique symbol\n```\n\n----------------------------------------\n\nTITLE: Checking for None FiberId in TypeScript\nDESCRIPTION: A utility function that returns true if the provided FiberId is a None type, false otherwise. This function serves as a type guard in TypeScript.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/FiberId-isNone.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const isNone: (self: FiberId) => self is None\n```\n\n----------------------------------------\n\nTITLE: isNull Function Declaration in TypeScript\nDESCRIPTION: The `isNull` function is declared in TypeScript to determine whether a given input is `null`. It uses TypeScript's type guards to ensure that the return type reflects the nature of the check, specifically returning a type predicate. This function is a part of the Effect library, specifically within the Predicate module.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Predicate-isNull.md#2025-04-11_snippet_1\n\nLANGUAGE: ts\nCODE:\n```\ndeclare const isNull: (input: unknown) => input is null\n```\n\n----------------------------------------\n\nTITLE: Defining PushAnnotationStream Interface in TypeScript\nDESCRIPTION: This code snippet defines the PushAnnotationStream interface, which extends DocStream.Variance<A>. It represents the addition of an annotation of type A to a Doc. The interface includes properties for the tag, annotation, and stream.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/DocStream-PushAnnotationStream.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface PushAnnotationStream<A> extends DocStream.Variance<A> {\n  readonly _tag: \"PushAnnotationStream\"\n  readonly annotation: A\n  readonly stream: DocStream<A>\n}\n```\n\n----------------------------------------\n\nTITLE: HashMap.HashMap.Entry Type Signature in TypeScript\nDESCRIPTION: This snippet shows the type signature for the HashMap.HashMap.Entry utility. It defines the Entry type as a tuple of the Key and Value types extracted from the input HashMap type T.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/HashMap-HashMap.Entry.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ntype Entry<T> = [Key<T>, Value<T>]\n```\n\n----------------------------------------\n\nTITLE: Declaration of SemigroupSome in TypeScript\nDESCRIPTION: This snippet declares the SemigroupSome constant, as a semigroup for Boolean types. Part of the semigroup framework, it enables logical OR operations on Boolean data types. It serves as a core component within the Boolean module of the @effect/typeclass package. No external inputs, but outputs a semigroup object configured for Boolean disjunction.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/data-Boolean-SemigroupSome.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const SemigroupSome: semigroup.Semigroup<boolean>\n```\n\n----------------------------------------\n\nTITLE: Typescript MergeRight Type Definition\nDESCRIPTION: This code snippet defines the `MergeRight` utility type using conditional types and mapped types. It creates a new type that is the intersection of `Source` and a filtered `Target`. Keys present in both `Target` and `Source` are taken from `Source`, while keys only in `Target` are included in the final merged type. The `Simplify` utility type is used to simplify the resulting type.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Types-MergeRight.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ntype MergeRight<Target, Source> = Simplify<\n  & Source\n  & {\n    [Key in keyof Target as Key extends keyof Source ? never : Key]: Target[Key]\n  }\n>\n```\n\n----------------------------------------\n\nTITLE: Using Doc.nesting with indentation in TypeScript\nDESCRIPTION: Demonstrates how to use the Doc.nesting function to create documents that adapt to different indentation levels. The example creates a document with a prefix and nested content that displays the current nesting level, then shows this document at three different indentation levels (0, 4, and 8).\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Doc-nesting.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport * as Doc from \"@effect/printer/Doc\"\nimport * as String from \"effect/String\"\n\nconst doc = Doc.hsep([\n  Doc.text(\"prefix\"),\n  Doc.nesting((l) => Doc.squareBracketed(Doc.text(`Nested: ${l}`)))\n])\n\nconst example = Doc.vsep([0, 4, 8].map((n) => Doc.indent(n)(doc)))\n\nassert.strictEqual(\n  Doc.render(example, { style: \"pretty\" }),\n  String.stripMargin(\n    `|prefix [Nested: 0]\n     |    prefix [Nested: 4]\n     |        prefix [Nested: 8]`\n  )\n)\n```\n\n----------------------------------------\n\nTITLE: Implementing List Filter Function in TypeScript\nDESCRIPTION: Defines a type-safe filter function for Lists that accepts either a refinement or predicate function. The function can be used both in curried and non-curried forms, supporting type narrowing through refinements.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/List-filter.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const filter: { <A, B extends A>(refinement: Refinement<NoInfer<A>, B>): (self: List<A>) => List<B>; <A>(predicate: Predicate<NoInfer<A>>): (self: List<A>) => List<A>; <A, B extends A>(self: List<A>, refinement: Refinement<A, B>): List<B>; <A>(self: List<A>, predicate: Predicate<A>): List<A>; }\n```\n\n----------------------------------------\n\nTITLE: Declaring the multiply function signature\nDESCRIPTION: This code snippet shows the TypeScript declaration of the `multiply` function. It defines the function's signature, which allows for both curried and non-curried usage. The function takes two numbers as input and returns their product.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Number-multiply.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const multiply: { (that: number): (self: number) => number; (self: number, that: number): number; }\n```\n\n----------------------------------------\n\nTITLE: Transforming Tuple Elements with Effect in TypeScript\nDESCRIPTION: The code demonstrates how to use the Tuple.map function from the Effect library to transform each element of a tuple. The function is called homomorphically and the transformation logic is applied using a mapping function that can convert each element to its string representation. Dependencies include the 'effect' package. The example illustrates transforming a tuple consisting of mixed types into their uppercase string equivalents.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Tuple-map.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { pipe, Tuple } from \"effect\"\n\nconst result = pipe(\n  [\"a\", 1, false] as const,\n  Tuple.map((el) => el.toString().toUpperCase())\n)\nassert.deepStrictEqual(result, ['A', '1', 'FALSE'])\n```\n\n----------------------------------------\n\nTITLE: Determining Availability Per Line in Effect Printer using TypeScript\nDESCRIPTION: The provided TypeScript snippet declares a constant function `isAvailablePerLine` that returns a boolean indicating whether a given `PageWidth` instance is of type `AvailablePerLine`. There are no additional dependencies mentioned. The function takes a `PageWidth` object as an input and checks its type, returning true or false accordingly. It is available since version 1.0.0.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/PageWidth-isAvailablePerLine.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const isAvailablePerLine: (self: PageWidth) => self is AvailablePerLine\n```\n\n----------------------------------------\n\nTITLE: Capturing Metric Snapshots in Effect TypeScript\nDESCRIPTION: Function signature for unsafely capturing a snapshot of all metrics recorded by the application. Returns an array of untyped MetricPair objects. This is marked as unsafe as it likely performs side effects outside of the Effect system.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Metric-unsafeSnapshot.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const unsafeSnapshot: (_: void) => ReadonlyArray<MetricPair.MetricPair.Untyped>\n```\n\n----------------------------------------\n\nTITLE: Testing BigInt Type in TypeScript\nDESCRIPTION: Demonstrates how to use the isBigInt function to check if a value is of type bigint. The example shows true for a bigint value and false for a regular number.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/BigInt-isBigInt.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { isBigInt } from \"effect/BigInt\"\n\nassert.deepStrictEqual(isBigInt(1n), true)\nassert.deepStrictEqual(isBigInt(1), false)\n```\n\n----------------------------------------\n\nTITLE: Retrieving Optional Services in Effect TypeScript\nDESCRIPTION: Function signature for retrieving a service from the context. Returns an Effect that either contains the service or throws a NoSuchElementException if the service is missing. This is used for handling critical services where absence should be treated as an error.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-serviceOptional.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const serviceOptional: <I, S>(tag: Context.Tag<I, S>) => Effect<S, Cause.NoSuchElementException>\n```\n\n----------------------------------------\n\nTITLE: Defining Tuple.getEquivalence Function in TypeScript\nDESCRIPTION: This function returns a new Equivalence that compares values of a tuple by applying each specified Equivalence to the corresponding elements of that tuple. It takes any number of Equivalence instances as arguments, thereby enabling versatile tuple element comparisons. The output is a new Equivalence tailored to the structure of the input tuple.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Tuple-getEquivalence.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const getEquivalence: <T extends ReadonlyArray<Equivalence.Equivalence<any>>>(...isEquivalents: T) => Equivalence.Equivalence<Readonly<{ [I in keyof T]: [T[I]] extends [Equivalence.Equivalence<infer A>] ? A : never; }>>\n```\n\n----------------------------------------\n\nTITLE: Declaring cursor show function in AnsiDoc module\nDESCRIPTION: Defines a constant function cursorShow that shows the cursor in an ANSI terminal. It's part of the AnsiDoc module in the @effect/printer-ansi package.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/AnsiDoc-cursorShow.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const cursorShow: AnsiDoc\n```\n\n----------------------------------------\n\nTITLE: Removing Elements from TSet in TypeScript\nDESCRIPTION: This TypeScript snippet provides functionality to remove a single element from a TSet. It uses STM (Software Transactional Memory) to ensure safe concurrent transactions. The remove function can be called with the element first followed by the TSet, or vice versa. The constraints require an STM environment. Input parameters are the element to remove and the TSet from which to remove it. There are no direct outputs, but the TSet is modified in-place.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TSet-remove.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const remove: { <A>(value: A): (self: TSet<A>) => STM.STM<void>; <A>(self: TSet<A>, value: A): STM.STM<void>; }\n```\n\n----------------------------------------\n\nTITLE: Type Guard for Exit Values in TypeScript\nDESCRIPTION: The isExit function is a type guard that checks if a given value is an Exit object. It returns true if the value is an Exit and false otherwise. This function is useful for runtime type checking when working with the Effect system.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Exit-isExit.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const isExit: (u: unknown) => u is Exit<unknown, unknown>\n```\n\n----------------------------------------\n\nTITLE: Type Signature for Effect.using in TypeScript\nDESCRIPTION: This code snippet shows the type signature for the Effect.using function. It demonstrates how the function is overloaded to handle different parameter orders and types.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-using.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const using: { <A, A2, E2, R2>(use: (a: A) => Effect<A2, E2, R2>): <E, R>(self: Effect<A, E, R>) => Effect<A2, E2 | E, R2 | Exclude<R, Scope.Scope>>; <A, E, R, A2, E2, R2>(self: Effect<A, E, R>, use: (a: A) => Effect<A2, E2, R2>): Effect<A2, E | E2, R2 | Exclude<R, Scope.Scope>>; }\n```\n\n----------------------------------------\n\nTITLE: Using Array.takeWhile in TypeScript to extract elements while a condition is true\nDESCRIPTION: This example demonstrates how to use the Array.takeWhile function to extract elements from an array as long as they satisfy a condition. It takes elements until it encounters one that doesn't meet the predicate (x < 4), then stops processing and returns the accumulated result.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Array-takeWhile.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Array } from \"effect\"\n\nconst result = Array.takeWhile([1, 3, 2, 4, 1, 2], x => x < 4)\nconsole.log(result) // [1, 3, 2]\n\n// Explanation:\n// - The function starts with the first element (`1`), which is less than `4`, so it adds `1` to the result.\n// - The next element (`3`) is also less than `4`, so it adds `3`.\n// - The next element (`2`) is again less than `4`, so it adds `2`.\n// - The function then encounters `4`, which is not less than `4`. At this point, it stops checking further elements and finalizes the result.\n```\n\n----------------------------------------\n\nTITLE: Array.modify Function Signature in TypeScript\nDESCRIPTION: Provides the TypeScript function signature for the Array.modify function. It shows the function's polymorphic nature, allowing for different input types and return values based on the provided iterable and transformation function.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Array-modify.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const modify: { <A, B, S extends Iterable<A> = Iterable<A>>(i: number, f: (a: ReadonlyArray.Infer<S>) => B): (self: S) => ReadonlyArray.With<S, ReadonlyArray.Infer<S> | B>; <A, B, S extends Iterable<A> = Iterable<A>>(self: S, i: number, f: (a: ReadonlyArray.Infer<S>) => B): ReadonlyArray.With<S, ReadonlyArray.Infer<S> | B>; }\n```\n\n----------------------------------------\n\nTITLE: Parsing Strings into BigDecimal with unsafeFromString in TypeScript\nDESCRIPTION: The unsafeFromString function parses a numerical string into a BigDecimal object. It handles both integer and decimal values, converting them to the appropriate internal representation with BigInt. The function throws an error if the input string is not a valid numerical value.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/BigDecimal-unsafeFromString.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { unsafeFromString, make } from \"effect/BigDecimal\"\n\nassert.deepStrictEqual(unsafeFromString(\"123\"), make(123n, 0))\nassert.deepStrictEqual(unsafeFromString(\"123.456\"), make(123456n, 3))\nassert.throws(() => unsafeFromString(\"123.abc\"))\n```\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const unsafeFromString: (s: string) => BigDecimal\n```\n\n----------------------------------------\n\nTITLE: Declaring Stream.toQueueOfElements Function Type in TypeScript\nDESCRIPTION: Type declaration for a function that converts a Stream to a scoped queue of elements. The function accepts optional capacity configuration and returns an Effect containing a Queue.Dequeue of Exit values. The queue stops producing values after the scope is closed.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-toQueueOfElements.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const toQueueOfElements: { \n  (options?: { readonly capacity?: number | undefined; } | undefined): <A, E, R>\n    (self: Stream<A, E, R>) => Effect.Effect<Queue.Dequeue<Exit.Exit<A, Option.Option<E>>>, never, Scope.Scope | R>; \n  <A, E, R>(self: Stream<A, E, R>, options?: { readonly capacity?: number | undefined; } | undefined): \n    Effect.Effect<Queue.Dequeue<Exit.Exit<A, Option.Option<E>>>, never, Scope.Scope | R>; \n}\n```\n\n----------------------------------------\n\nTITLE: Schedule Add Delay Signature (TypeScript)\nDESCRIPTION: This code snippet presents the TypeScript signature of the `addDelay` function within the `Schedule` module of the Effect library. It shows the function's type definition, including its generic parameters for output, input, and environment types.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Schedule-addDelay.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const addDelay: { <Out>(f: (out: Out) => Duration.DurationInput): <In, R>(self: Schedule<Out, In, R>) => Schedule<Out, In, R>; <Out, In, R>(self: Schedule<Out, In, R>, f: (out: Out) => Duration.DurationInput): Schedule<Out, In, R>; }\n```\n\n----------------------------------------\n\nTITLE: Updating an Element in TArray using STM in TypeScript\nDESCRIPTION: Defines the updateSTM function which atomically updates an element in a TArray, taking an index and a function that applies a transactional effect to the element. The function can be called with a self parameter or in a curried fashion. It requires Effect-TS along with its STM module for functioning.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TArray-updateSTM.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const updateSTM: { <A, R, E>(index: number, f: (value: A) => STM.STM<A, E, R>): (self: TArray<A>) => STM.STM<void, E, R>; <A, R, E>(self: TArray<A>, index: number, f: (value: A) => STM.STM<A, E, R>): STM.STM<void, E, R>; };\n```\n\n----------------------------------------\n\nTITLE: Declaring the Interruption RuntimeFlag in TypeScript\nDESCRIPTION: This code declares a constant named Interruption that represents a RuntimeFlag. This flag determines whether or not the Effect runtime system will interrupt a fiber during execution.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/RuntimeFlags-Interruption.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const Interruption: RuntimeFlag\n```\n\n----------------------------------------\n\nTITLE: Micro.runFork Type Definition in TypeScript\nDESCRIPTION: Type definition for the runFork function that executes Micro effects. Takes a Micro effect and optional configuration including abort signal and scheduler, returns a MicroFiberImpl instance.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Micro-runFork.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const runFork: <A, E>(effect: Micro<A, E>, options?: { readonly signal?: AbortSignal | undefined; readonly scheduler?: MicroScheduler | undefined; } | undefined) => MicroFiberImpl<A, E>\n```\n\n----------------------------------------\n\nTITLE: Pausing Micro Effect Execution with yieldNowWith in TypeScript\nDESCRIPTION: Defines the yieldNowWith function that pauses the current Micro effect execution and resumes it on the next scheduler tick. It accepts an optional priority parameter which likely affects scheduling order.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Micro-yieldNowWith.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const yieldNowWith: (priority?: number) => Micro<void>\n```\n\n----------------------------------------\n\nTITLE: Implementing Error Transformation with Cause.flatMap in TypeScript\nDESCRIPTION: Function signature for flatMap that transforms errors in a Cause type. It provides two overloads: a curried version taking a transformation function first, and a direct version taking both the Cause and transformation function. The function transforms each Fail error of type E into a new Cause of type E2.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Cause-flatMap.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const flatMap: { <E, E2>(f: (e: E) => Cause<E2>): (self: Cause<E>) => Cause<E2>; <E, E2>(self: Cause<E>, f: (e: E) => Cause<E2>): Cause<E2>; }\n```\n\n----------------------------------------\n\nTITLE: Defining FiberRefs Interface in TypeScript\nDESCRIPTION: This snippet defines the TypeScript interface for the FiberRefs data type which represents a collection of FiberRef values. It extends Pipeable and contains a locals property that maps FiberRef values to arrays of FiberId.Single and value pairs.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/FiberRefs-FiberRefs.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface FiberRefs extends Pipeable {\n  readonly [FiberRefsSym]: FiberRefsSym\n  readonly locals: Map<FiberRef.FiberRef<any>, Arr.NonEmptyReadonlyArray<readonly [FiberId.Single, any]>>\n}\n```\n\n----------------------------------------\n\nTITLE: Using BigDecimal.toExponential in TypeScript\nDESCRIPTION: Demonstrates how to import and use the toExponential function from the BigDecimal module to format a BigDecimal value in scientific notation format.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/BigDecimal-toExponential.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { toExponential, make } from \"effect/BigDecimal\"\n\nassert.deepStrictEqual(toExponential(make(123456n, -5)), \"1.23456e+10\")\n```\n\n----------------------------------------\n\nTITLE: Declaration of greaterThanOrEqualTo Function in TypeScript\nDESCRIPTION: This snippet provides the TypeScript signature for the greaterThanOrEqualTo function. It describes the function being overloaded to accept different combinations of its two arguments. Each variation returns a boolean value, indicating the result of the comparison. This declaration helps developers understand available usages of the function and ensures correct implementation in different contexts.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Number-greaterThanOrEqualTo.md#2025-04-11_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const greaterThanOrEqualTo: { (that: number): (self: number) => boolean; (self: number, that: number): boolean; }\n```\n\n----------------------------------------\n\nTITLE: TypeScript Stream Succeed Function Signature\nDESCRIPTION: This snippet provides the signature for the Stream.succeed function, which creates a Stream containing a single value of type 'A'. It specifies the input parameter and the return type.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-succeed.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const succeed: <A>(value: A) => Stream<A>\n```\n\n----------------------------------------\n\nTITLE: Signature of the Partition Function in Effect-TS\nDESCRIPTION: This snippet documents the TypeScript signature of the 'partition' function, defining its various overloads that accept different predicates or refinement functions to yield appropriate record partitions. Understanding these signatures is essential for implementing type-safe data processing.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Record-partition.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const partition: { <K extends string, A, B extends A>(refinement: (a: NoInfer<A>, key: K) => a is B): (self: ReadonlyRecord<K, A>) => [excluded: Record<ReadonlyRecord.NonLiteralKey<K>, Exclude<A, B>>, satisfying: Record<ReadonlyRecord.NonLiteralKey<K>, B>]; <K extends string, A>(predicate: (a: NoInfer<A>, key: K) => boolean): (self: ReadonlyRecord<K, A>) => [excluded: Record<ReadonlyRecord.NonLiteralKey<K>, A>, satisfying: Record<ReadonlyRecord.NonLiteralKey<K>, A>]; <K extends string, A, B extends A>(self: ReadonlyRecord<K, A>, refinement: (a: A, key: K) => a is B): [excluded: Record<ReadonlyRecord.NonLiteralKey<K>, Exclude<A, B>>, satisfying: Record<ReadonlyRecord.NonLiteralKey<K>, B>]; <K extends string, A>(self: ReadonlyRecord<K, A>, predicate: (a: A, key: K) => boolean): [excluded: Record<ReadonlyRecord.NonLiteralKey<K>, A>, satisfying: Record<ReadonlyRecord.NonLiteralKey<K>, A>]; }\n```\n\n----------------------------------------\n\nTITLE: Implementing HashMap Filter Method in TypeScript\nDESCRIPTION: Type declaration for a HashMap filter method that supports filtering entries using a predicate function. The method is overloaded to handle both type predicates and boolean predicates, allowing for type narrowing and general filtering operations.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/HashMap-filter.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const filter: {\n  <K, A, B extends A>(f: (a: NoInfer<A>, k: K) => a is B): (self: HashMap<K, A>) => HashMap<K, B>;\n  <K, A>(f: (a: NoInfer<A>, k: K) => boolean): (self: HashMap<K, A>) => HashMap<K, A>;\n  <K, A, B extends A>(self: HashMap<K, A>, f: (a: A, k: K) => a is B): HashMap<K, B>;\n  <K, A>(self: HashMap<K, A>, f: (a: A, k: K) => boolean): HashMap<K, A>;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining updateService Function in TypeScript for Channel Module\nDESCRIPTION: Declares the updateService function, which updates a service in the context of a channel. It has two overloads: one for updating a service with a given tag and transformation function, and another that takes the channel as the first argument.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Channel-updateService.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const updateService: { <I, S>(tag: Context.Tag<I, S>, f: (resource: Types.NoInfer<S>) => Types.NoInfer<S>): <OutElem, OutErr, InErr, OutDone, InDone, R>(self: Channel<OutElem, unknown, OutErr, InErr, OutDone, InDone, R>) => Channel<OutElem, unknown, OutErr, InErr, OutDone, InDone, I | R>; <OutElem, OutErr, InErr, OutDone, InDone, R, I, S>(self: Channel<OutElem, unknown, OutErr, InErr, OutDone, InDone, R>, tag: Context.Tag<I, S>, f: (resource: Types.NoInfer<S>) => Types.NoInfer<S>): Channel<OutElem, unknown, OutErr, InErr, OutDone, InDone, I | R>; }\n```\n\n----------------------------------------\n\nTITLE: Defining EntityNotManagedByRunner Error Class in TypeScript\nDESCRIPTION: This code snippet defines the EntityNotManagedByRunner class, which represents an error that occurs when a Runner receives a message for an entity it is not responsible for managing. It is part of the ClusterError module in the @effect/cluster package.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/ClusterError-EntityNotManagedByRunner.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare class EntityNotManagedByRunner\n```\n\n----------------------------------------\n\nTITLE: Creating BigDecimal from Number in TypeScript\nDESCRIPTION: Function signature for creating a BigDecimal from a number value. The function throws a RangeError if the number is not finite (NaN, +Infinity or -Infinity). The documentation warns that converting floating point numbers directly to decimals may produce unexpected results.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/BigDecimal-fromNumber.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const fromNumber: (n: number) => BigDecimal\n```\n\n----------------------------------------\n\nTITLE: Defining Cause.contains Function Signature in TypeScript\nDESCRIPTION: This code snippet defines the type signature for the Cause.contains function. It's a curried function that takes two Cause objects and returns a boolean indicating if one contains the other.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Cause-contains.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const contains: { <E2>(that: Cause<E2>): <E>(self: Cause<E>) => boolean; <E, E2>(self: Cause<E>, that: Cause<E2>): boolean; }\n```\n\n----------------------------------------\n\nTITLE: Type Guard for LineStream in DocStream Module\nDESCRIPTION: A type guard function that checks if a DocStream is specifically a LineStream. Returns true if the provided DocStream is a LineStream, false otherwise.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/DocStream-isLineStream.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const isLineStream: <A>(self: DocStream<A>) => self is LineStream<A>\n```\n\n----------------------------------------\n\nTITLE: Signature of Record.modify\nDESCRIPTION: This snippet provides the TypeScript signature for the Record.modify function. It outlines the types for the key and the function used to transform the value, indicating the expected input and output types, thereby facilitating type-safe modifications of records.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Record-modify.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const modify: { <K extends string | symbol, A, B>(key: NoInfer<K>, f: (a: A) => B): (self: ReadonlyRecord<K, A>) => Record<K, A | B>; <K extends string | symbol, A, B>(self: ReadonlyRecord<K, A>, key: NoInfer<K>, f: (a: A) => B): Record<K, A | B>; }\n```\n\n----------------------------------------\n\nTITLE: Implementing Cartesian Product with Custom Combiner in TypeScript\nDESCRIPTION: Function signature for cartesianWith that takes two Iterables and a combining function to produce a new Iterable. Supports both curried and non-curried versions of the function call. The function combines elements from two Iterables using a custom combining function to produce a new Iterable of combined elements.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Iterable-cartesianWith.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const cartesianWith: { <A, B, C>(that: Iterable<B>, f: (a: A, b: B) => C): (self: Iterable<A>) => Iterable<C>; <A, B, C>(self: Iterable<A>, that: Iterable<B>, f: (a: A, b: B) => C): Iterable<C>; }\n```\n\n----------------------------------------\n\nTITLE: Creating Semigroup for ReadonlyArray in TypeScript\nDESCRIPTION: The purpose of this function is to provide a Semigroup for ReadonlyArray<A> for any type A, allowing two arrays to be combined through concatenation. There are no additional dependencies required aside from the @effect/typeclass package. No parameters need to be passed explicitly to the function; instead, it uses generics. The function returns a Semigroup instance capable of array concatenation. This is subject to TypeScript’s type-checking constraints.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Semigroup-array.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const array: <A>() => Semigroup<ReadonlyArray<A>>\n```\n\n----------------------------------------\n\nTITLE: Retrieving Typed Object Keys with Struct in TypeScript\nDESCRIPTION: This TypeScript code snippet demonstrates the use of Struct.keys to retrieve string-based keys from an object, ignoring symbol-based keys. The main dependencies are the 'assert' module from Node.js for assertions and the 'Struct' module from Effect for key retrieval. It inputs an object with string and symbol keys and outputs an array of string keys, demonstrating its usage with a TypeScript type system.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Struct-keys.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { Struct } from \"effect\"\n\nconst symbol: unique symbol = Symbol()\n\nconst value = {\n  a: 1,\n  b: 2,\n  [symbol]: 3\n}\n\nconst keys: Array<\"a\" | \"b\"> = Struct.keys(value)\n\nassert.deepStrictEqual(keys, [\"a\", \"b\"])\n```\n\n----------------------------------------\n\nTITLE: Defining Reloadable Service Fork Operation in TypeScript\nDESCRIPTION: Defines a function that forks the reload operation of a service into the background, ignoring any errors that occur during the reload process. It takes a Context.Tag parameter and returns an Effect that operates on a Reloadable interface.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Reloadable-reloadFork.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const reloadFork: <I, S>(tag: Context.Tag<I, S>) => Effect.Effect<void, unknown, Reloadable<I>>\n```\n\n----------------------------------------\n\nTITLE: Declaring Size Method for TSet in TypeScript\nDESCRIPTION: This snippet declares the size method for the TSet module, which computes the cardinality of the set as an STM operation returning a numerical value. It requires TypeScript and STM as dependencies. The method takes one parameter, `self`, which is the TSet instance and outputs a number representing its size.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TSet-size.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const size: <A>(self: TSet<A>) => STM.STM<number>\n```\n\n----------------------------------------\n\nTITLE: Retrieving Metric Values with Effect-TS Metric.value\nDESCRIPTION: Function signature for retrieving a snapshot value from a metric. Takes a Metric instance with generic type parameters and returns an Effect containing the output value. Part of the Effect-TS library's metrics system.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Metric-value.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const value: <Type, In, Out>(self: Metric<Type, In, Out>) => Effect.Effect<Out>\n```\n\n----------------------------------------\n\nTITLE: Extracting Tag Literals from Union Types in TypeScript\nDESCRIPTION: A type-level utility function that extracts the '_tag' literal from types in a union, returning a union of those tag values. It helps in working with discriminated unions by isolating their tag identifiers.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Types-Tags.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ntype Res = Types.Tags<string | { _tag: \"a\" } | { _tag: \"b\" } > // \"a\" | \"b\"\n```\n\nLANGUAGE: typescript\nCODE:\n```\ntype Tags<E> = E extends { _tag: string } ? E[\"_tag\"] : never\n```\n\n----------------------------------------\n\nTITLE: Implementing RedBlackTree greaterThan Iterator in TypeScript\nDESCRIPTION: Defines a function that creates an iterator to traverse RedBlackTree entries with keys greater than a specified value. The function supports both curried and uncurried calling styles and works with generic key and value types.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/RedBlackTree-greaterThan.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const greaterThan: { <K>(key: K): <V>(self: RedBlackTree<K, V>) => Iterable<[K, V]>; <K, V>(self: RedBlackTree<K, V>, key: K): Iterable<[K, V]>; }\n```\n\n----------------------------------------\n\nTITLE: Combining Schedules with Effect Library in TypeScript\nDESCRIPTION: The 'either' function in the Schedule module allows for the combination of two schedules within the Effect library, acting as an alias for a union operation. This function accepts two schedule objects, returning a new schedule that handles combinations of the input and output types, as well as any required resources. It requires the Effect-TS library as a dependency.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Schedule-either.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const either: { <Out2, In2, R2>(that: Schedule<Out2, In2, R2>): <Out, In, R>(self: Schedule<Out, In, R>) => Schedule<[Out, Out2], In & In2, R2 | R>; <Out, In, R, Out2, In2, R2>(self: Schedule<Out, In, R>, that: Schedule<Out2, In2, R2>): Schedule<[Out, Out2], In & In2, R | R2>; }\n```\n\n----------------------------------------\n\nTITLE: Converting Effect success to Option.Some in TypeScript\nDESCRIPTION: This function maps the success value of an Effect to a Some variant in an Option. If the original Effect fails, the returned Effect will also fail with the same error.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-asSome.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const asSome: <A, E, R>(self: Effect<A, E, R>) => Effect<Option.Option<A>, E, R>\n```\n\n----------------------------------------\n\nTITLE: HashSet.isSubset TypeScript Function Signature\nDESCRIPTION: The type signature for the isSubset function, showing its overloaded nature supporting both data-first and data-last calling styles for checking if one HashSet is a subset of another.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/HashSet-isSubset.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const isSubset: { <A>(that: HashSet<A>): (self: HashSet<A>) => boolean; <A>(self: HashSet<A>, that: HashSet<A>): boolean; }\n```\n\n----------------------------------------\n\nTITLE: Declaring STM.zipLeft TypeScript Function Signature\nDESCRIPTION: Defines a function for sequentially zipping STM transactions, which preserves the left-side value and combines potential error and environment types. Supports both curried and direct application styles.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/STM-zipLeft.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const zipLeft: { <A1, E1, R1>(that: STM<A1, E1, R1>): <A, E, R>(self: STM<A, E, R>) => STM<A, E1 | E, R1 | R>; <A, E, R, A1, E1, R1>(self: STM<A, E, R>, that: STM<A1, E1, R1>): STM<A, E | E1, R | R1>; }\n```\n\n----------------------------------------\n\nTITLE: Type Signature of modifyOption - TypeScript\nDESCRIPTION: This snippet defines the type signature for the `modifyOption` function in TypeScript. It describes the types of its parameters and return type, providing insight into how the function is intended to be used within the Effect framework.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Record-modifyOption.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const modifyOption: { <K extends string | symbol, A, B>(key: NoInfer<K>, f: (a: A) => B): (self: ReadonlyRecord<K, A>) => Option.Option<Record<K, A | B>>; <K extends string | symbol, A, B>(self: ReadonlyRecord<K, A>, key: NoInfer<K>, f: (a: A) => B): Option.Option<Record<K, A | B>>; }\n```\n\n----------------------------------------\n\nTITLE: Options.repeated in @effect/cli\nDESCRIPTION: This TypeScript code snippet defines the `repeated` function within the `@effect/cli` package.  It takes an `Options<A>` as input and returns `Options<Array<A>>`, indicating that the option can be repeated multiple times, resulting in an array of values.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Options-repeated.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const repeated: <A>(self: Options<A>) => Options<Array<A>>\n```\n\n----------------------------------------\n\nTITLE: Defining Layer.passthrough Function in TypeScript\nDESCRIPTION: Declares a function that creates a new layer producing outputs of the original layer while also passing through inputs. It takes a Layer as input and returns a new Layer with modified type parameters.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Layer-passthrough.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const passthrough: <RIn, E, ROut>(self: Layer<ROut, E, RIn>) => Layer<RIn | ROut, E, RIn>\n```\n\n----------------------------------------\n\nTITLE: Retrieving Keys from a Trie in TypeScript\nDESCRIPTION: This example demonstrates how to use the Trie.keys function to retrieve an array of keys from a Trie data structure. The keys are returned in alphabetical order, regardless of insertion order.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Trie-keys.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { Trie } from \"effect\"\n\nconst trie = Trie.empty<number>().pipe(\n  Trie.insert(\"cab\", 0),\n  Trie.insert(\"abc\", 1),\n  Trie.insert(\"bca\", 2)\n)\n\nconst result = Array.from(Trie.keys(trie))\nassert.deepStrictEqual(result, [\"abc\", \"bca\", \"cab\"])\n```\n\n----------------------------------------\n\nTITLE: Creating a failing Take with a defect (Effect TS)\nDESCRIPTION: The `Take.die` function constructs a `Take` representing a failed computation with the provided defect. This is useful for explicitly signaling an error condition within an Effect stream or process. The function returns a `Take<never>`, indicating that no value will be emitted.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Take-die.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const die: (defect: unknown) => Take<never>\n```\n\n----------------------------------------\n\nTITLE: Transforming First Component of Tuple using Effect Library in TypeScript\nDESCRIPTION: This code snippet demonstrates the use of the `mapFirst` function from the Effect library to transform the first element of a tuple. The function takes a tuple and a mapping function as parameters. It returns a new tuple where the first element is the result of applying the mapping function, and it supports various generic types for flexibility.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Tuple-mapFirst.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { mapFirst } from \"effect/Tuple\"\n\nassert.deepStrictEqual(\n  mapFirst([\"hello\", 42], s => s.toUpperCase()),\n  [\"HELLO\", 42]\n)\n```\n\n----------------------------------------\n\nTITLE: Setting ConfigProvider in Layer Module (TypeScript)\nDESCRIPTION: This function sets the current ConfigProvider for the Layer. It takes a ConfigProvider as an argument and returns a Layer that never produces an error.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Layer-setConfigProvider.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const setConfigProvider: (configProvider: ConfigProvider) => Layer<never>\n```\n\n----------------------------------------\n\nTITLE: Using Doc.surround to Enclose Content Between Documents in TypeScript\nDESCRIPTION: Example demonstrating how to use the 'surround' combinator to place a document between left and right documents. In this case, a hyphen character is surrounded by 'A' and 'Z' characters.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Doc-surround.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport * as Doc from \"@effect/printer/Doc\"\nimport { pipe } from \"effect/Function\"\n\nconst doc = pipe(\n  Doc.char(\"-\"),\n  Doc.surround(Doc.char(\"A\"), Doc.char(\"Z\"))\n)\n\nassert.strictEqual(\n  Doc.render(doc, { style: \"pretty\" }),\n  \"A-Z\"\n)\n```\n\n----------------------------------------\n\nTITLE: Declaring logAnnotations Function in TypeScript\nDESCRIPTION: Defines the logAnnotations function which retrieves the current log annotations for the current scope. It returns an Effect that resolves to a HashMap of string keys and unknown values, representing the log annotations.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-logAnnotations.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const logAnnotations: Effect<HashMap.HashMap<string, unknown>, never, never>\n```\n\n----------------------------------------\n\nTITLE: Transforming Schedule to Output Delays - TypeScript\nDESCRIPTION: The 'delays' function takes an existing 'Schedule' and transforms its output to provide the duration between each scheduled execution instead of the original output. It is part of the 'Schedule' module in the 'effect' package and requires the 'Duration' type to represent the output delays.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Schedule-delays.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const delays: <Out, In, R>(self: Schedule<Out, In, R>) => Schedule<Duration.Duration, In, R>\n```\n\n----------------------------------------\n\nTITLE: Creating Mutable Schema AST in TypeScript\nDESCRIPTION: Function that creates a new AST with shallow mutability applied to its properties. Takes an existing AST as input and returns a modified version with mutable properties.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/SchemaAST-mutable.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const mutable: (ast: AST) => AST\n```\n\n----------------------------------------\n\nTITLE: Trie.has Function Signature in Effect Library\nDESCRIPTION: This code block shows the TypeScript type signature for the Trie.has function. It demonstrates that the function can be called with either the key first or the Trie first, providing flexibility in usage.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Trie-has.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const has: { (key: string): <V>(self: Trie<V>) => boolean; <V>(self: Trie<V>, key: string): boolean; }\n```\n\n----------------------------------------\n\nTITLE: Type Checking with Fiber.isFiber in TypeScript\nDESCRIPTION: The isFiber function checks if an unknown value is a Fiber instance. It returns true if the value is a Fiber, false otherwise. This type guard function helps with safe type checking when working with values that might be Fibers.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Fiber-isFiber.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const isFiber: (u: unknown) => u is Fiber<unknown, unknown>\n```\n\n----------------------------------------\n\nTITLE: Creating Intervals from Iterable in Effect TS\nDESCRIPTION: The `fromIterable` function creates an `Intervals` object from a given iterable of `Interval` objects. It takes an `Iterable<Interval.Interval>` as input and returns an `Intervals` object. This function is part of the `effect` library.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/ScheduleIntervals-fromIterable.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const fromIterable: (intervals: Iterable<Interval.Interval>) => Intervals\n```\n\n----------------------------------------\n\nTITLE: Forking a Fiber in a Specific Scope with Effect.IO\nDESCRIPTION: Demonstrates how to fork a child fiber into a specific scope using Effect.forkIn. The example shows a child fiber that logs messages every second, forked into an outer scope that survives the inner scope's termination but gets cleaned up when the outer scope closes.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-forkIn.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Console, Effect, Schedule } from \"effect\"\n\n// Child fiber that logs a message repeatedly every second\nconst child = Effect.repeat(\n  Console.log(\"child: still running!\"),\n  Schedule.fixed(\"1 second\")\n)\n\nconst program = Effect.scoped(\n  Effect.gen(function* () {\n    yield* Effect.addFinalizer(() =>\n      Console.log(\"The outer scope is about to be closed!\")\n    )\n\n    // Capture the outer scope\n    const outerScope = yield* Effect.scope\n\n    // Create an inner scope\n    yield* Effect.scoped(\n      Effect.gen(function* () {\n        yield* Effect.addFinalizer(() =>\n          Console.log(\"The inner scope is about to be closed!\")\n        )\n        // Fork the child fiber in the outer scope\n        yield* Effect.forkIn(child, outerScope)\n        yield* Effect.sleep(\"3 seconds\")\n      })\n    )\n\n    yield* Effect.sleep(\"5 seconds\")\n  })\n)\n```\n\n----------------------------------------\n\nTITLE: Implementing Error Replacement in Cause Module with TypeScript\nDESCRIPTION: The 'as' function allows replacing any errors in a Cause with a provided constant error. It preserves the structure of the Cause while transforming all Fail errors into the specified error value, useful when original error details are no longer needed.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Cause-as.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const as: { <E2>(error: E2): <E>(self: Cause<E>) => Cause<E2>; <E, E2>(self: Cause<E>, error: E2): Cause<E2>; }\n```\n\n----------------------------------------\n\nTITLE: Defining TestLive Interface in TypeScript\nDESCRIPTION: The TestLive interface exposes live default Effect services for testing workflows that require real service implementations. It includes a method to provide effects with specified types. This snippet is implemented in TypeScript, with no explicit external dependencies. The provide method takes an effect as input and returns an effect of the same type.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TestLive-TestLive.md#2025-04-11_snippet_0\n\nLANGUAGE: ts\nCODE:\n```\nexport interface TestLive {\n  readonly [TestLiveTypeId]: TestLiveTypeId\n  provide<A, E, R>(effect: Effect.Effect<A, E, R>): Effect.Effect<A, E, R>\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing a Simple Value Differ in TypeScript\nDESCRIPTION: Constructs a differ that diffs two values by returning a function that sets the value to the new value. This differ doesn't support combining multiple updates compositionally and should only be used when there is no compositional way to update values.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Differ-update.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const update: <A>() => Differ<A, (a: A) => A>\n```\n\n----------------------------------------\n\nTITLE: Checking if a Cause is a Fail Type in TypeScript\nDESCRIPTION: This function checks if a Cause<E> is specifically of the Fail<E> type. It can be used to determine if an error cause is a direct failure rather than other cause types. Related to the 'fail' function which creates new Fail causes.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Cause-isFailType.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const isFailType: <E>(self: Cause<E>) => self is Fail<E>\n```\n\n----------------------------------------\n\nTITLE: Creating a RuntimeFlagsPatch to disable a RuntimeFlag in Effect\nDESCRIPTION: Creates a RuntimeFlagsPatch that describes disabling a specific RuntimeFlag. This function takes a RuntimeFlag as input and returns a patch that can be applied to modify runtime behavior.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/RuntimeFlagsPatch-disable.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const disable: (flag: RuntimeFlags.RuntimeFlag) => RuntimeFlagsPatch\n```\n\n----------------------------------------\n\nTITLE: Feeding Input to Standard Input in TypeScript\nDESCRIPTION: The feed function is used to provide a string as input to standard input for a Command. It supports UTF-8 encoding by default and can be used in two ways: as a standalone function or as a method on a Command object.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Command-feed.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const feed: { (input: string): (self: Command) => Command; (self: Command, input: string): Command; }\n```\n\n----------------------------------------\n\nTITLE: Running a Channel in TypeScript\nDESCRIPTION: The 'run' function executes a channel until it receives the end signal. It takes a Channel as input and returns an Effect. The function handles various generic types for error handling, input/output, and environment.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Channel-run.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const run: <OutErr, InErr, OutDone, InDone, Env>(self: Channel<never, unknown, OutErr, InErr, OutDone, InDone, Env>) => Effect.Effect<OutDone, OutErr, Env>\n```\n\n----------------------------------------\n\nTITLE: Stream.tap Signature in TypeScript\nDESCRIPTION: This code snippet shows the TypeScript declaration for the `Stream.tap` function. It has two overloaded signatures that allow you to either provide the stream as the first argument or use a curried function. The function takes an effectful function as input and returns a new stream with the effect applied to each element.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-tap.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const tap: { <A, X, E2, R2>(f: (a: NoInfer<A>) => Effect.Effect<X, E2, R2>): <E, R>(self: Stream<A, E, R>) => Stream<A, E2 | E, R2 | R>; <A, E, R, X, E2, R2>(self: Stream<A, E, R>, f: (a: NoInfer<A>) => Effect.Effect<X, E2, R2>): Stream<A, E | E2, R | R2>; }\n```\n\n----------------------------------------\n\nTITLE: Type Checking for AlreadyFlat in Typescript\nDESCRIPTION: Type guard function that checks if a given Flatten<A> value is specifically an AlreadyFlat<A> instance. This is used for type narrowing in the printer's flattening system.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Flatten-isAlreadyFlat.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const isAlreadyFlat: <A>(a: Flatten<A>) => a is AlreadyFlat<A>\n```\n\n----------------------------------------\n\nTITLE: Schema.uncapitalized in Effect TS\nDESCRIPTION: The `uncapitalized` function takes optional annotations and returns a function that accepts a schema. This function filters the schema to ensure that the string is uncapitalized, leveraging annotations for further customization and filtering capabilities within the Effect TS ecosystem.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Schema-uncapitalized.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const uncapitalized: <S extends Schema.Any>(annotations?: Annotations.Filter<Schema.Type<S>>) => <A extends string>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>) => filter<S>\n```\n\n----------------------------------------\n\nTITLE: Querying RedBlackTree with greaterThanEqual in TypeScript\nDESCRIPTION: The purpose of this snippet is to return an iterator that traverses entries in a Red-Black Tree with keys greater than or equal to a specified key. This is essential for operations that require sorted data retrieval. It requires the `RedBlackTree` data structure from the `effect` package. There are two overloads, one where the key is provided first and the other where the tree is provided first. The resulting iterator yields key-value pairs as tuples.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/RedBlackTree-greaterThanEqual.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const greaterThanEqual: { <K>(key: K): <V>(self: RedBlackTree<K, V>) => Iterable<[K, V]>; <K, V>(self: RedBlackTree<K, V>, key: K): Iterable<[K, V]>; }\n```\n\n----------------------------------------\n\nTITLE: Checking if a RuntimeFlagsPatch is Empty in TypeScript\nDESCRIPTION: Function that determines whether a RuntimeFlagsPatch is empty. It takes a patch object as input and returns a boolean value indicating if the patch contains no modifications.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/RuntimeFlagsPatch-isEmpty.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const isEmpty: (patch: RuntimeFlagsPatch) => boolean\n```\n\n----------------------------------------\n\nTITLE: Defining Exit.Success Interface in TypeScript\nDESCRIPTION: TypeScript interface definition for the Success type, which represents a successfully completed Effect workflow containing a returned value of type A. It includes type parameters, tag information, and utility symbols for type unification.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Exit-Success.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface Success<out A, out E> extends Effect.Effect<A, E>, Pipeable, Inspectable {\n  readonly _tag: \"Success\"\n  readonly _op: \"Success\"\n  readonly value: A\n  [Unify.typeSymbol]?: unknown\n  [Unify.unifySymbol]?: ExitUnify<this>\n  [Unify.ignoreSymbol]?: ExitUnifyIgnore\n  /** @internal */\n  readonly effect_instruction_i0: A\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Second of Minute Schedule in TypeScript\nDESCRIPTION: Creates a schedule that triggers at a specific second of each minute, starting from zero nanoseconds. The function returns a Schedule that produces an incrementing count of executions.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Schedule-secondOfMinute.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const secondOfMinute: (second: number) => Schedule<number>\n```\n\n----------------------------------------\n\nTITLE: Declaring linkSpans Function in TypeScript\nDESCRIPTION: Declares the linkSpans function which adds a link with the provided span for all spans in an effect. It can be called with either the span first or the effect first, and optionally includes attributes.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-linkSpans.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const linkSpans: { (span: Tracer.AnySpan, attributes?: Record<string, unknown>): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R>; <A, E, R>(self: Effect<A, E, R>, span: Tracer.AnySpan, attributes?: Record<string, unknown>): Effect<A, E, R>; }\n```\n\n----------------------------------------\n\nTITLE: Effect Option Map Signature\nDESCRIPTION: Shows the type signature of the `Option.map` function in TypeScript. This signature defines how the function transforms an Option<A> to an Option<B> given a mapping function f: (a: A) => B.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Option-map.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const map: { <A, B>(f: (a: A) => B): (self: Option<A>) => Option<B>; <A, B>(self: Option<A>, f: (a: A) => B): Option<B>; }\n```\n\n----------------------------------------\n\nTITLE: Using lineBreak with Text in Effect Printer Module\nDESCRIPTION: Example demonstrating how to use Doc.lineBreak in composition with other Doc elements. Shows how lineBreak behaves normally (as a line break) and how it collapses to empty space when used within a Doc.group().\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Doc-lineBreak.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport * as Doc from \"@effect/printer/Doc\"\nimport * as String from \"effect/String\"\n\nconst doc: Doc.Doc<never> = Doc.hcat([\n  Doc.text(\"lorem ipsum\"),\n  Doc.lineBreak,\n  Doc.text(\"dolor sit amet\")\n])\n\nassert.strictEqual(\n  Doc.render(doc, { style: \"pretty\" }),\n  String.stripMargin(\n    `|lorem ipsum\n     |dolor sit amet`\n  )\n)\nassert.strictEqual(\n  Doc.render(Doc.group(doc), { style: \"pretty\" }),\n  \"lorem ipsumdolor sit amet\"\n)\n```\n\n----------------------------------------\n\nTITLE: List.some Predicate Function Signature - TypeScript\nDESCRIPTION: Type declaration for the List.some function that provides two overloads: one for curried usage with predicate first, and another for direct usage with list and predicate. Returns a type predicate indicating if the list is a Cons (non-empty list) when condition is met.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/List-some.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const some: { <A>(predicate: Predicate<NoInfer<A>>): (self: List<A>) => self is Cons<A>; <A>(self: List<A>, predicate: Predicate<A>): self is Cons<A>; }\n```\n\n----------------------------------------\n\nTITLE: Creating Empty Intervals list in Effect\nDESCRIPTION: This code snippet shows the declaration of the `empty` constant, which represents an empty list of `Interval`s. It is part of the `ScheduleIntervals` module in the `effect` package and is used to initialize an empty set of intervals for scheduling purposes.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/ScheduleIntervals-empty.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const empty: Intervals\n```\n\n----------------------------------------\n\nTITLE: Implementing effectful folding sink in TypeScript using Effect\nDESCRIPTION: Creates a sink that effectfully folds inputs with a provided function and termination predicate. It takes an initial state, a continuation function that determines when to stop folding, and a fold function that processes each input.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Sink-foldEffect.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const foldEffect: <S, In, E, R>(s: S, contFn: Predicate<S>, f: (s: S, input: In) => Effect.Effect<S, E, R>) => Sink<S, In, In, E, R>\n```\n\n----------------------------------------\n\nTITLE: Declaring Failure Stream in TypeScript\nDESCRIPTION: The 'failCauseSync' function is a TypeScript declaration that creates a stream which always fails with a lazily evaluated cause. It requires a parameter 'evaluate' of type LazyArg<Cause.Cause<E>>, which determines the reason for the failure. The output is a Stream that never emits values but instead fails with the specified error type E.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-failCauseSync.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const failCauseSync: <E>(evaluate: LazyArg<Cause.Cause<E>>) => Stream<never, E>\n```\n\n----------------------------------------\n\nTITLE: Intersecting Intervals in TypeScript using Effect Package\nDESCRIPTION: Defines a function 'intersect' that computes the intersection of two Intervals. It can be used in two ways: as a curried function or with both arguments provided at once. The function returns a new Interval representing the intersection.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/ScheduleInterval-intersect.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const intersect: { (that: Interval): (self: Interval) => Interval; (self: Interval, that: Interval): Interval; }\n```\n\n----------------------------------------\n\nTITLE: Defining alterAnnotations function in TypeScript for DocStream\nDESCRIPTION: This function changes the annotation of a document to a different annotation or removes it entirely. It takes a function that transforms annotations and applies it to a DocStream.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/DocStream-alterAnnotations.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const alterAnnotations: {\n  <A, B>(f: (a: A) => Option<B>): (self: DocStream<A>) => DocStream<B>;\n  <A, B>(self: DocStream<A>, f: (a: A) => Option<B>): DocStream<B>;\n}\n```\n\n----------------------------------------\n\nTITLE: Declaring Retried Test Annotation in TypeScript\nDESCRIPTION: This code snippet declares a constant 'retried' of type TestAnnotation<number>. It is used to annotate and count the number of times a test has been retried.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TestAnnotation-retried.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const retried: TestAnnotation<number>\n```\n\n----------------------------------------\n\nTITLE: Stream.concat Signature in TypeScript\nDESCRIPTION: This snippet shows the type signature of the `Stream.concat` function in TypeScript, using generics to define the types of the input and output streams.  It illustrates the overloaded nature of the function, allowing it to be called either with the first stream as an argument to a curried function or with both streams as direct arguments.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-concat.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const concat: { <A2, E2, R2>(that: Stream<A2, E2, R2>): <A, E, R>(self: Stream<A, E, R>) => Stream<A2 | A, E2 | E, R2 | R>; <A, E, R, A2, E2, R2>(self: Stream<A, E, R>, that: Stream<A2, E2, R2>): Stream<A | A2, E | E2, R | R2>; }\n```\n\n----------------------------------------\n\nTITLE: Creating Intervals from List of Interval Objects in TypeScript\nDESCRIPTION: The 'make' function creates a new Intervals instance from a Chunk of Interval objects. It takes a Chunk<Interval.Interval> as input and returns an Intervals object.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/ScheduleIntervals-make.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const make: (intervals: Check.Chunk<Interval.Interval>) => Intervals\n```\n\n----------------------------------------\n\nTITLE: Checking for Cron ParseError in TypeScript\nDESCRIPTION: The isParseError function is a type guard that determines if a given unknown value is a ParseError object specific to cron expression parsing. This is useful for error handling when working with cron expressions in the effect package.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Cron-isParseError.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const isParseError: (u: unknown) => u is ParseError\n```\n\n----------------------------------------\n\nTITLE: Declaring Spaced Schedule in TypeScript\nDESCRIPTION: Creates a continuous schedule that maintains a fixed duration between repetitions, measuring from the end of the last execution. Useful for implementing consistent interval-based tasks or periodic operations.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Schedule-spaced.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const spaced: (duration: Duration.DurationInput) => Schedule<number>\n```\n\n----------------------------------------\n\nTITLE: Defining Schema.Data Type in TypeScript\nDESCRIPTION: Declares a constant Data that defines a schema with specific constraints on Type and Encoded properties. It requires that Type and Encoded extend Readonly<Record<string, any>> or ReadonlyArray<any>.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Schema-Data.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const Data: <S extends Schema.Any, A extends Readonly<Record<string, unknown>> | ReadonlyArray<unknown>, I extends Readonly<Record<string, unknown>> | ReadonlyArray<unknown>>(value: S & Schema<A & Schema.Type<S>, I & Schema.Encoded<S>, Schema.Context<S>>) => Data<S>\n```\n\n----------------------------------------\n\nTITLE: Testing readonly record with Effect Predicate in Typescript\nDESCRIPTION: This code demonstrates how to use the `isReadonlyRecord` function from the `effect/Predicate` module to check if an object is a readonly record. It uses `node:assert` for testing the function's output with various inputs, including empty objects, objects with properties, arrays, null, and undefined.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Predicate-isReadonlyRecord.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { isReadonlyRecord } from \"effect/Predicate\"\n\nassert.deepStrictEqual(isReadonlyRecord({}), true)\nassert.deepStrictEqual(isReadonlyRecord({ a: 1 }), true)\n\nassert.deepStrictEqual(isReadonlyRecord([]), false)\nassert.deepStrictEqual(isReadonlyRecord([1, 2, 3]), false)\nassert.deepStrictEqual(isReadonlyRecord(null), false)\nassert.deepStrictEqual(isReadonlyRecord(undefined), false)\n```\n\n----------------------------------------\n\nTITLE: Converting FiberId to Option in TypeScript\nDESCRIPTION: A utility function that converts a FiberId instance into an Option<FiberId>. This allows for safe handling of FiberId values by wrapping them in an Option type.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/FiberId-toOption.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const toOption: (self: FiberId) => Option.Option<FiberId>\n```\n\n----------------------------------------\n\nTITLE: BooleanFromNumber Class Declaration\nDESCRIPTION: This code snippet declares the `BooleanFromNumber` class in TypeScript. It is designed to handle boolean values that are represented as numbers (0 or 1).\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Model-BooleanFromNumber.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\ndeclare class BooleanFromNumber\n```\n```\n\n----------------------------------------\n\nTITLE: Checking Deferred Completion Status using Deferred.poll in TypeScript\nDESCRIPTION: The poll function checks if a Deferred has been completed. It returns Some<Effect<A, E, R>> if the Deferred has been completed, or None if it hasn't been completed yet. This allows for non-blocking inspection of a Deferred's state.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Deferred-poll.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const poll: <A, E>(self: Deferred<A, E>) => Effect.Effect<Option.Option<Effect.Effect<A, E>>>\n```\n\n----------------------------------------\n\nTITLE: Declaring STM.orTry Function Signature\nDESCRIPTION: Defines a complex generic function that allows composing STM effects with fallback retry behavior. It supports two calling conventions and provides type-safe composition of alternative computations.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/STM-orTry.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const orTry: { <A1, E1, R1>(that: LazyArg<STM<A1, E1, R1>>): <A, E, R>(self: STM<A, E, R>) => STM<A1 | A, E1 | E, R1 | R>; <A, E, R, A1, E1, R1>(self: STM<A, E, R>, that: LazyArg<STM<A1, E1, R1>>): STM<A | A1, E | E1, R | R1>; }\n```\n\n----------------------------------------\n\nTITLE: Retrieving Fiber Status in Effect TypeScript\nDESCRIPTION: This function returns the FiberStatus of a RuntimeFiber. It allows checking the current state of a fiber in the Effect ecosystem.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Fiber-status.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const status: <A, E>(self: RuntimeFiber<A, E>) => Effect.Effect<FiberStatus.FiberStatus>\n```\n\n----------------------------------------\n\nTITLE: TypeScript Function Signature for Context.unsafeGet\nDESCRIPTION: The type declaration for the Context.unsafeGet function, showing its overloaded versions. It accepts either a tag first and then a context, or a context first and then a tag, returning the service of type S associated with the tag.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Context-unsafeGet.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const unsafeGet: { <S, I>(tag: Tag<I, S>): <Services>(self: Context<Services>) => S; <Services, S, I>(self: Context<Services>, tag: Tag<I, S>): S; }\n```\n\n----------------------------------------\n\nTITLE: Type Checking TQueue Objects in TypeScript\nDESCRIPTION: The isTQueue function checks if a given value is a TQueue object. It returns true if the value is a TQueue instance, otherwise false. This function is useful for type guarding and validation in TypeScript.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TQueue-isTQueue.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const isTQueue: (u: unknown) => u is TQueue<unknown>\n```\n\n----------------------------------------\n\nTITLE: Implementing Partial Type Utility in SchemaAST\nDESCRIPTION: Function declaration for creating a partial version of an AST schema, equivalent to TypeScript's built-in Partial utility type. Takes an AST parameter and optional configuration object that can specify exact matching.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/SchemaAST-partial.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const partial: (ast: AST, options?: { readonly exact: true; }) => AST\n```\n\n----------------------------------------\n\nTITLE: Creating No-op FileSystem in TypeScript - Effect Platform\nDESCRIPTION: Function signature for creating a no-op file system implementation that can be used for testing purposes. The function takes a partial FileSystem object and returns a complete FileSystem implementation.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/FileSystem-makeNoop.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const makeNoop: (fileSystem: Partial<FileSystem>) => FileSystem\n```\n\n----------------------------------------\n\nTITLE: Defining intercalate API for Semigroup in TypeScript\nDESCRIPTION: The intercalate API is designed to return a function that can take a Semigroup instance along with a separator value to create a new Semigroup. This function can either be partially applied with the separator and then take a Semigroup instance, or supplied with both at once. It is key for combining strings with a specific separator, showcasing the flexibility of Semigroup, unlike Monoid.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Semigroup-intercalate.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const intercalate: { <A>(separator: A): (S: Semigroup<A>) => Semigroup<A>; <A>(S: Semigroup<A>, separator: A): Semigroup<A>; }\n```\n\n----------------------------------------\n\nTITLE: HashSet.every Function Signature in TypeScript\nDESCRIPTION: The type signature for the HashSet.every function, showing its polymorphic nature. It supports both refinement functions (which narrow types) and predicate functions (which return boolean), with both data-first and data-last variants.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/HashSet-every.md#2025-04-11_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const every: { <A, B extends A>(refinement: Refinement<NoInfer<A>, B>): (self: HashSet<A>) => self is HashSet<B>; <A>(predicate: Predicate<A>): (self: HashSet<A>) => boolean; <A, B extends A>(self: HashSet<A>, refinement: Refinement<A, B>): self is HashSet<B>; <A>(self: HashSet<A>, predicate: Predicate<A>): boolean; }\n```\n\n----------------------------------------\n\nTITLE: Type Signature for List.appendAll in TypeScript\nDESCRIPTION: Provides the TypeScript type signature for the List.appendAll function. It shows various overloads to handle different combinations of List and Cons types.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/List-appendAll.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const appendAll: { <S extends List<any>, T extends List<any>>(that: T): (self: S) => List.OrNonEmpty<S, T, List.Infer<S> | List.Infer<T>>; <A, B>(self: List<A>, that: Cons<B>): Cons<A | B>; <A, B>(self: Cons<A>, that: List<B>): Cons<A | B>; <A, B>(self: List<A>, that: List<B>): List<A | B>; }\n```\n\n----------------------------------------\n\nTITLE: Either.Do Type Signature in TypeScript\nDESCRIPTION: The type signature for the Either.Do constant, which serves as the starting point for do simulation. It represents an Either with an empty object as the right type and never as the left type.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Either-Do.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const Do: Either<{}, never>\n```\n\n----------------------------------------\n\nTITLE: Calculating Square Roots of BigInt Values in TypeScript\nDESCRIPTION: The unsafeSqrt function calculates the square root of a given bigint value. It throws an error if the input is negative. The function returns the integer square root as a bigint value.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/BigInt-unsafeSqrt.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { unsafeSqrt } from \"effect/BigInt\"\n\nassert.deepStrictEqual(unsafeSqrt(4n), 2n)\nassert.deepStrictEqual(unsafeSqrt(9n), 3n)\nassert.deepStrictEqual(unsafeSqrt(16n), 4n)\n```\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const unsafeSqrt: (n: bigint) => bigint\n```\n\n----------------------------------------\n\nTITLE: Defining HashMap Union Operation in TypeScript\nDESCRIPTION: Declares a constant 'union' that performs a union operation between two HashMaps. It can be called with one or two arguments, allowing for both curried and non-curried usage. The function combines the key-value pairs from both HashMaps, resulting in a new HashMap with combined types.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/HashMap-union.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const union: { <K1, V1>(that: HashMap<K1, V1>): <K0, V0>(self: HashMap<K0, V0>) => HashMap<K1 | K0, V1 | V0>; <K0, V0, K1, V1>(self: HashMap<K0, V0>, that: HashMap<K1, V1>): HashMap<K0 | K1, V0 | V1>; }\n```\n\n----------------------------------------\n\nTITLE: Peeking at the First Value in TPriorityQueue (Effect/TS)\nDESCRIPTION: The `peek` function allows retrieval of the highest priority element from the `TPriorityQueue` without removing it. It retries the operation using `STM.STM` if the queue is empty, ensuring that a value is eventually returned. This function requires the `TPriorityQueue` and `STM` modules from the Effect library.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TPriorityQueue-peek.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const peek: <A>(self: TPriorityQueue<A>) => STM.STM<A>\n```\n\n----------------------------------------\n\nTITLE: Creating MutableList with Effect in TypeScript\nDESCRIPTION: The `make` function constructs a `MutableList` from a variable number of elements.  It takes a spread of arguments, each representing an element to be included in the new list. The function is part of the `MutableList` module in the Effect library.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/MutableList-make.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const make: <A>(...elements: ReadonlyArray<A>) => MutableList<A>\n```\n\n----------------------------------------\n\nTITLE: Type Signature for globalValue Function in TypeScript\nDESCRIPTION: The type signature of the globalValue function, which takes an id of any type and a compute function that returns a value of type A, and returns the computed value or retrieves it if already calculated.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/GlobalValue-globalValue.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const globalValue: <A>(id: unknown, compute: () => A) => A\n```\n\n----------------------------------------\n\nTITLE: Declaring MonoidMultiply Type - TypeScript\nDESCRIPTION: This snippet provides the TypeScript declaration for the MonoidMultiply constant as a monoid.Monoid type specialized for bigint. It ensures type correctness when using the MonoidMultiply in operations.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/data-BigInt-MonoidMultiply.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const MonoidMultiply: monoid.Monoid<bigint>\n```\n\n----------------------------------------\n\nTITLE: Implementing Micro Effect Finalization in TypeScript\nDESCRIPTION: Defines a function signature for ensuring finalization of Micro effects. The finalizer runs regardless of whether the main effect succeeds or fails. The function supports both curried and uncurried calling styles.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Micro-ensuring.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const ensuring: { <XE, XR>(finalizer: Micro<void, XE, XR>): <A, E, R>(self: Micro<A, E, R>) => Micro<A, E | XE, R | XR>; <A, E, R, XE, XR>(self: Micro<A, E, R>, finalizer: Micro<void, XE, XR>): Micro<A, E | XE, R | XR>; }\n```\n\n----------------------------------------\n\nTITLE: Implementing Config Description in TypeScript using Effect-TS\nDESCRIPTION: Function signature for adding human-readable descriptions to configuration objects. The function supports both curried and non-curried calling styles, allowing flexible usage patterns when annotating configs.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Config-withDescription.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const withDescription: { (description: string): <A>(self: Config<A>) => Config<A>; <A>(self: Config<A>, description: string): Config<A>; }\n```\n\n----------------------------------------\n\nTITLE: Removing and Interrupting Fibers from FiberMap in TypeScript\nDESCRIPTION: The remove function is used to delete a fiber from a FiberMap while also interrupting it if it exists. It accepts a key parameter to identify which fiber to remove and returns an Effect that completes when the operation is done.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/FiberMap-remove.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const remove: { <K>(key: K): <A, E>(self: FiberMap<K, A, E>) => Effect.Effect<void>; <K, A, E>(self: FiberMap<K, A, E>, key: K): Effect.Effect<void>; }\n```\n\n----------------------------------------\n\nTITLE: Type Checking IllegalArgumentException in TypeScript\nDESCRIPTION: Type guard function that validates if an unknown value is an IllegalArgumentException. Used for runtime type checking and type narrowing in TypeScript.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Cause-isIllegalArgumentException.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const isIllegalArgumentException: (u: unknown) => u is IllegalArgumentException\n```\n\n----------------------------------------\n\nTITLE: Effect.withUnhandledErrorLogLevel Type Signature\nDESCRIPTION: Type declaration for the withUnhandledErrorLogLevel function, showing its polymorphic nature and type parameters. The function can be used in both pipeable and standard function call styles.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-withUnhandledErrorLogLevel.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const withUnhandledErrorLogLevel: { (level: Option.Option<LogLevel.LogLevel>): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R>; <A, E, R>(self: Effect<A, E, R>, level: Option.Option<LogLevel.LogLevel>): Effect<A, E, R>; }\n```\n\n----------------------------------------\n\nTITLE: TypeScript Function Signature for removeTime in DateTime Module\nDESCRIPTION: This code block shows the TypeScript function signature for the removeTime function in the DateTime module. It takes a DateTime object as input and returns a Utc object.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/DateTime-removeTime.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const removeTime: (self: DateTime) => Utc\n```\n\n----------------------------------------\n\nTITLE: HashSet.union Type Declaration in TypeScript\nDESCRIPTION: The type signature for the HashSet.union function, which supports both data-first and data-last calling styles. It returns a new HashSet containing all elements from both collections.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/HashSet-union.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const union: { <A>(that: Iterable<A>): (self: HashSet<A>) => HashSet<A>; <A>(self: HashSet<A>, that: Iterable<A>): HashSet<A>; }\n```\n\n----------------------------------------\n\nTITLE: Creating a Bounded Queue with Dropping Strategy in TypeScript\nDESCRIPTION: Creates a bounded queue with the dropping strategy. When the queue reaches capacity, new values will be dropped. For optimal performance, it's recommended to use capacities that are powers of two.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TQueue-dropping.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const dropping: <A>(requestedCapacity: number) => STM.STM<TQueue<A>>\n```\n\n----------------------------------------\n\nTITLE: Defining SafeRefinement for Matching Any Value in TypeScript\nDESCRIPTION: Declares a constant 'any' of type SafeRefinement that matches any value without restrictions. This can be used for type refinement where no specific type checking is needed.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Match-any.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const any: SafeRefinement<unknown, any>\n```\n\n----------------------------------------\n\nTITLE: Concatenating Documents with Soft Line Breaks in TypeScript\nDESCRIPTION: Demonstrates using the catWithSoftLineBreak combinator to join two documents with a soft line break. Shows behavior with different line width settings, where text can either appear on one line or wrap based on available width.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Doc-catWithSoftLineBreak.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport * as Doc from \"@effect/printer/Doc\"\nimport { pipe } from \"effect/Function\"\nimport * as String from \"effect/String\"\n\nconst doc: Doc.Doc<never> = pipe(\n  Doc.char(\"a\"),\n  Doc.catWithSoftLineBreak(Doc.char(\"b\"))\n)\n\nassert.strictEqual(\n  Doc.render(doc, { style: \"pretty\" }),\n  \"ab\"\n)\n\nassert.strictEqual(\n  Doc.render(doc, {\n    style: \"pretty\",\n    options: { lineWidth: 1 }\n  }),\n  String.stripMargin(\n    `|a\n     |b`\n  )\n)\n```\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const catWithSoftLineBreak: { <B>(that: Doc<B>): <A>(self: Doc<A>) => Doc<B | A>; <A, B>(self: Doc<A>, that: Doc<B>): Doc<A | B>; }\n```\n\n----------------------------------------\n\nTITLE: Checking RuntimeMetrics Flag Status in Effect's RuntimeFlags\nDESCRIPTION: This function checks whether the RuntimeMetrics flag is enabled in the provided RuntimeFlags object. It returns true if the flag is enabled and false otherwise.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/RuntimeFlags-runtimeMetrics.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const runtimeMetrics: (self: RuntimeFlags) => boolean\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Boolean OR Operation in TypeScript\nDESCRIPTION: This code snippet shows examples of using the 'or' function from the Effect-TS library to combine boolean values. It demonstrates various combinations of true and false values.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Boolean-or.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { or } from \"effect/Boolean\"\n\nassert.deepStrictEqual(or(true, true), true)\nassert.deepStrictEqual(or(true, false), true)\nassert.deepStrictEqual(or(false, true), true)\nassert.deepStrictEqual(or(false, false), false)\n```\n\n----------------------------------------\n\nTITLE: Using withCurrentZoneLocal for Local Time Zone in Effect (TypeScript)\nDESCRIPTION: This snippet demonstrates how to use the withCurrentZoneLocal function to provide the CurrentTimeZone to an effect using the system's local time zone. It shows an example of getting the current time in the local zone.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/DateTime-withCurrentZoneLocal.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { DateTime, Effect } from \"effect\"\n\nEffect.gen(function* () {\n  // will use the system's local time zone\n  const now = yield* DateTime.nowInCurrentZone\n}).pipe(DateTime.withCurrentZoneLocal)\n```\n\n----------------------------------------\n\nTITLE: TypeScript function signature for Context.getOption\nDESCRIPTION: The type declaration for Context.getOption, showing its polymorphic nature. It can be called with either (tag, context) or (context, tag) parameter orders, and returns an Option of the service type.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Context-getOption.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const getOption: { <S, I>(tag: Tag<I, S>): <Services>(self: Context<Services>) => Option<S>; <Services, S, I>(self: Context<Services>, tag: Tag<I, S>): Option<S>; }\n```\n\n----------------------------------------\n\nTITLE: MutableList.forEach Declaration in Typescript\nDESCRIPTION: The `forEach` function in the Effect MutableList module executes a given function for each element in a mutable list.  It has two possible call signatures, allowing for curried or direct application of the function to the list. The function accepts a function `f` that takes an element of the list as input and returns `void`.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/MutableList-forEach.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const forEach: { <A>(f: (element: A) => void): (self: MutableList<A>) => void; <A>(self: MutableList<A>, f: (element: A) => void): void; }\n```\n\n----------------------------------------\n\nTITLE: Array.extend Function Signature in TypeScript\nDESCRIPTION: Shows the TypeScript signature for the Array.extend function. The function has two overloads: one for curried usage and one for direct application, both taking a function that maps subarrays to values.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Array-extend.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const extend: { <A, B>(f: (as: ReadonlyArray<A>) => B): (self: ReadonlyArray<A>) => Array<B>; <A, B>(self: ReadonlyArray<A>, f: (as: ReadonlyArray<A>) => B): Array<B>; }\n```\n\n----------------------------------------\n\nTITLE: Implementing Duration Range Check in TypeScript\nDESCRIPTION: Function definition for checking if a Duration value falls between minimum and maximum bounds. Supports both curried and direct parameter passing styles.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Duration-between.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const between: { \n  (options: { minimum: DurationInput; maximum: DurationInput; }): (self: DurationInput) => boolean; \n  (self: DurationInput, options: { minimum: DurationInput; maximum: DurationInput; }): boolean; \n}\n```\n\n----------------------------------------\n\nTITLE: Type Signature for cartesianWith Function in TypeScript\nDESCRIPTION: This snippet shows the type signature of the cartesianWith function. The function provides two overloads: a curried version that takes the second array and combiner function first, and a direct version that takes all arguments at once.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Array-cartesianWith.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const cartesianWith: { <A, B, C>(that: ReadonlyArray<B>, f: (a: A, b: B) => C): (self: ReadonlyArray<A>) => Array<C>; <A, B, C>(self: ReadonlyArray<A>, that: ReadonlyArray<B>, f: (a: A, b: B) => C): Array<C>; }\n```\n\n----------------------------------------\n\nTITLE: Converting HashMap Values to Array in TypeScript\nDESCRIPTION: A function that takes a HashMap and returns an Array containing all values stored in it. The function preserves the type parameter V for values while discarding the key type K.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/HashMap-toValues.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const toValues: <K, V>(self: HashMap<K, V>) => Array<V>\n```\n\n----------------------------------------\n\nTITLE: BigDecimal.sign Type Signature\nDESCRIPTION: The type signature for the sign function, which takes a BigDecimal value and returns an Ordering value (typically -1, 0, or 1).\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/BigDecimal-sign.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const sign: (n: BigDecimal) => Ordering\n```\n\n----------------------------------------\n\nTITLE: StringFromUriComponent Schema Signature in TypeScript\nDESCRIPTION: This code snippet shows the TypeScript signature of the StringFromUriComponent schema. It is defined as a transformOrFail type that operates on string schemas.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Schema-StringFromUriComponent.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const StringFromUriComponent: transformOrFail<SchemaClass<string, string, never>, typeof String$, never>\n```\n\n----------------------------------------\n\nTITLE: Retrieving Supervised Fibers in Effect Tests\nDESCRIPTION: The supervisedFibers function returns a set of all fibers in the current test. It returns an Effect that resolves to a SortedSet of RuntimeFibers. This can be useful for inspecting or manipulating the state of concurrent operations during testing.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TestServices-supervisedFibers.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const supervisedFibers: () => Effect.Effect<SortedSet.SortedSet<Fiber.RuntimeFiber<unknown, unknown>>>\n```\n\n----------------------------------------\n\nTITLE: Setting FiberRef Values in Effect Module (TypeScript)\nDESCRIPTION: Defines the setFiberRefs function which sets the FiberRef values for the fiber running an effect. It takes a collection of FiberRef values as input and returns an Effect of void.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-setFiberRefs.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const setFiberRefs: (fiberRefs: FiberRefs.FiberRefs) => Effect<void>\n```\n\n----------------------------------------\n\nTITLE: Random.make Function Signature in TypeScript\nDESCRIPTION: This snippet shows the type signature of the Random.make function. It takes a generic seed of type A and returns a Random instance.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Random-make.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const make: <A>(seed: A) => Random\n```\n\n----------------------------------------\n\nTITLE: Checking if a Flatten is a Flattened Type in TypeScript\nDESCRIPTION: The `isFlattened` function is a type guard that checks if a given Flatten<A> instance is specifically a Flattened<A> variant. Returns true if the instance is a Flattened type, false otherwise. This helps with type-safe operations on the Flatten type union.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Flatten-isFlattened.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const isFlattened: <A>(a: Flatten<A>) => a is Flattened<A>\n```\n\n----------------------------------------\n\nTITLE: Fiber.zipRight Function Signature in TypeScript\nDESCRIPTION: The zipRight function combines two fibers, discarding the output of the first fiber and keeping only the output of the second fiber. It merges the error types from both fibers.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Fiber-zipRight.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const zipRight: { <A2, E2>(that: Fiber<A2, E2>): <A, E>(self: Fiber<A, E>) => Fiber<A2, E2 | E>; <A, E, A2, E2>(self: Fiber<A, E>, that: Fiber<A2, E2>): Fiber<A2, E | E2>; }\n```\n\n----------------------------------------\n\nTITLE: Declaring PropertySignature Function in TypeScript\nDESCRIPTION: This TypeScript snippet declares a function, `propertySignature`, which lifts a Schema into a PropertySignature. It is typed to accept an object of type Schema.All and returns a PropertySignature of the same type. This function is a part of the 'effect' package and resides in the Schema module.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Schema-propertySignature.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const propertySignature: <S extends Schema.All>(self: S) => propertySignature<S>\n```\n\n----------------------------------------\n\nTITLE: Determining If Write Lock Is Held in TReentrantLock - TypeScript\nDESCRIPTION: The `writeLocked` function checks if a write lock is currently held by any fiber in a `TReentrantLock` instance. This function is part of the `effect` package and uses the STM (Software Transactional Memory) framework. It returns an STM computation yielding a boolean, indicating the presence of a write lock.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TReentrantLock-writeLocked.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const writeLocked: (self: TReentrantLock) => STM.STM<boolean>\n```\n\n----------------------------------------\n\nTITLE: Mapping Either Values in TypeScript\nDESCRIPTION: Function signature for mapping the Right side of an Either value to a new Either value. The function provides two overloads: a curried version taking the mapping function first, and a direct version taking both the Either value and mapping function.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Either-map.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const map: { <R, R2>(f: (right: R) => R2): <L>(self: Either<R, L>) => Either<R2, L>; <R, L, R2>(self: Either<R, L>, f: (right: R) => R2): Either<R2, L>; }\n```\n\n----------------------------------------\n\nTITLE: Chunk.map Function Signature in TypeScript\nDESCRIPTION: Type signature for the Chunk.map function showing its polymorphic nature. It supports mapping over regular Chunks and NonEmptyChunks while preserving their type characteristics.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Chunk-map.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const map: { <S extends Chunk<any>, B>(f: (a: Chunk.Infer<S>, i: number) => B): (self: S) => Chunk.With<S, B>; <A, B>(self: NonEmptyChunk<A>, f: (a: A, i: number) => B): NonEmptyChunk<B>; <A, B>(self: Chunk<A>, f: (a: A, i: number) => B): Chunk<B>; }\n```\n\n----------------------------------------\n\nTITLE: Implementing Schedule Repetitions Tracking in TypeScript\nDESCRIPTION: Creates a new schedule that monitors and returns the count of schedule executions instead of original values. Starts counting from 0 and increments with each recurrence.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Schedule-repetitions.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const repetitions: <Out, In, R>(self: Schedule<Out, In, R>) => Schedule<number, In, R>\n```\n\n----------------------------------------\n\nTITLE: Implementing isColumn Function in TypeScript for Effect-TS Printer\nDESCRIPTION: This code snippet defines the isColumn function in the Doc module. It checks if a given Doc is of type Column. The function takes a Doc<A> as input and returns a boolean indicating whether it's a Column<A>.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Doc-isColumn.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const isColumn: <A>(self: Doc<A>) => self is Column<A>\n```\n\n----------------------------------------\n\nTITLE: Retrieving Last Element from List in TypeScript\nDESCRIPTION: A function that unsafely returns the last element of a List. This operation is unsafe as it may throw an error if the list is empty. The function accepts a List of type A and returns a single element of type A.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/List-unsafeLast.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const unsafeLast: <A>(self: List<A>) => A\n```\n\n----------------------------------------\n\nTITLE: Implementing isChar function in TypeScript for @effect/printer Doc module\nDESCRIPTION: This function checks if a given Doc is of type Char. It takes a Doc<A> as input and returns a boolean indicating whether the Doc is a Char or not. The function uses a type predicate to narrow the type if it returns true.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Doc-isChar.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const isChar: <A>(self: Doc<A>) => self is Char<A>\n```\n\n----------------------------------------\n\nTITLE: Creating ConfigProvider from Map in TypeScript\nDESCRIPTION: Function signature for creating a ConfigProvider instance from a Map data structure. Takes a string-to-string map and optional configuration parameters to determine how keys are split into path segments.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/ConfigProvider-fromMap.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const fromMap: (map: Map<string, string>, config?: Partial<ConfigProvider.FromMapConfig>) => ConfigProvider\n```\n\n----------------------------------------\n\nTITLE: Checking Empty Readonly Record in TypeScript\nDESCRIPTION: This function checks if the provided readonly record is empty (contains no entries). It leverages TypeScript's type definitions for enhanced type safety. The function returns a boolean indicating whether the record has no properties. This can be useful in scenarios where empty state handling is required.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Record-isEmptyReadonlyRecord.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { isEmptyReadonlyRecord } from \"effect/Record\"\n\nassert.deepStrictEqual(isEmptyReadonlyRecord({}), true);\nassert.deepStrictEqual(isEmptyReadonlyRecord({ a: 3 }), false);\n```\n\n----------------------------------------\n\nTITLE: Checking Key Existence with Types.Has\nDESCRIPTION: A TypeScript type utility that determines whether a record type contains any of the specified keys. Returns true if at least one key exists, otherwise false.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Types-Has.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport type { Types } from \"effect\"\n\ntype Res1 = Types.Has<{ a: number }, \"a\" | \"b\"> // true\ntype Res2 = Types.Has<{ c: number }, \"a\" | \"b\"> // false\n```\n\nLANGUAGE: typescript\nCODE:\n```\ntype Has<A, Key> = (Key extends infer K ? K extends keyof A ? true : never : never) extends never\n  ? false\n  : true\n```\n\n----------------------------------------\n\nTITLE: Creating Failing Effect with Specified Cause in TypeScript\nDESCRIPTION: The failCause function creates an Effect that fails with the specified Cause. It takes a Cause<E> as input and returns an Effect<never, E>.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-failCause.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const failCause: <E>(cause: Cause.Cause<E>) => Effect<never, E>\n```\n\n----------------------------------------\n\nTITLE: Waiting for Queue Shutdown in STM with TQueue.awaitShutdown\nDESCRIPTION: This function creates an STM transaction that waits until a queue is shutdown. The transaction will not resume until the queue has been shutdown, but if the queue is already shutdown, it will resume immediately.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TQueue-awaitShutdown.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const awaitShutdown: <A>(self: TDequeue<A> | TEnqueue<A>) => STM.STM<void>\n```\n\n----------------------------------------\n\nTITLE: Creating a Take from an Exit in TypeScript\nDESCRIPTION: The 'fromExit' function constructs a 'Take' from an 'Exit'. This utility is part of the Effect library's Take module. It requires the 'Exit' type and returns a 'Take' object encapsulating the exit result. The method is essential for handling effectful computations encapsulated as an 'Exit'.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Take-fromExit.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const fromExit: <A, E>(exit: Exit.Exit<A, E>) => Take<A, E>\n```\n\n----------------------------------------\n\nTITLE: Array.Do Type Definition in TypeScript\nDESCRIPTION: The type definition for the Array.Do function in the effect package. It serves as the starting point for the 'do simulation' pattern and returns a readonly array with an empty object.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Array-Do.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const Do: ReadonlyArray<{}>\n```\n\n----------------------------------------\n\nTITLE: Declaring reduceWithContext Function in TypeScript\nDESCRIPTION: Defines the reduceWithContext function, which combines all parts of a Cause into a single value using a custom reducer and a context. It supports two overloads: one taking context and reducer as separate arguments, and another taking the Cause as the first argument.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Cause-reduceWithContext.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const reduceWithContext: { <C, E, Z>(context: C, reducer: CauseReducer<C, E, Z>): (self: Cause<E>) => Z; <C, E, Z>(self: Cause<E>, context: C, reducer: CauseReducer<C, E, Z>): Z; }\n```\n\n----------------------------------------\n\nTITLE: Defining AsyncInputProducer Interface in TypeScript\nDESCRIPTION: Defines an interface for producer-side operations in SingleProducerAsyncInput. Includes methods for awaiting reads, handling completion, emitting elements, and error handling. Uses generic types for error (Err), elements (Elem), and completion (Done) values.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/SingleProducerAsyncInput-AsyncInputProducer.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface AsyncInputProducer<in Err, in Elem, in Done> {\n  awaitRead(): Effect.Effect<unknown>\n  done(value: Done): Effect.Effect<unknown>\n  emit(element: Elem): Effect.Effect<unknown>\n  error(cause: Cause.Cause<Err>): Effect.Effect<unknown>\n}\n```\n\n----------------------------------------\n\nTITLE: Taking Multiple Values from a Transactional Queue in Effect-TS\nDESCRIPTION: The takeUpTo function allows retrieving up to a maximum number of values from a transactional queue (TDequeue). It returns an STM (Software Transactional Memory) effect that produces an array of the retrieved values.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TQueue-takeUpTo.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const takeUpTo: { (max: number): <A>(self: TDequeue<A>) => STM.STM<Array<A>>; <A>(self: TDequeue<A>, max: number): STM.STM<Array<A>>; }\n```\n\n----------------------------------------\n\nTITLE: Testing for Set objects using Effect-TS TypeScript\nDESCRIPTION: This snippet demonstrates how to use the isSet function from the Effect-TS library to check if a given value is a Set. It uses Node's assert module to test various cases, confirming whether different inputs qualify as a Set object. The snippet is expected to return true for Set objects and false for other data types. Its main dependency is the Effect-TS library.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Predicate-isSet.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { isSet } from \"effect/Predicate\"\n\nassert.deepStrictEqual(isSet(new Set([1, 2])), true)\nassert.deepStrictEqual(isSet(new Set()), true)\nassert.deepStrictEqual(isSet({}), false)\nassert.deepStrictEqual(isSet(null), false)\nassert.deepStrictEqual(isSet(undefined), false)\n```\n\n----------------------------------------\n\nTITLE: Creating Entity from RpcGroup in TypeScript\nDESCRIPTION: The fromRpcGroup function creates a new Entity of a specified type that accepts messages adhering to the provided RpcGroup. It takes a string type and an RpcGroup protocol as parameters and returns an Entity.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Entity-fromRpcGroup.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const fromRpcGroup: <Rpcs extends Rpc.Any>(type: string, protocol: RpcGroup.RpcGroup<Rpcs>) => Entity<Rpcs>\n```\n\n----------------------------------------\n\nTITLE: Defining Layer.map Function in TypeScript\nDESCRIPTION: Declares the map function for the Layer module. This function takes a mapping function and a Layer, returning a new Layer with the output mapped by the specified function. It supports both curried and uncurried versions.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Layer-map.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const map: { <A, B>(f: (context: Context.Context<A>) => Context.Context<B>): <E, R>(self: Layer<A, E, R>) => Layer<B, E, R>; <A, E, R, B>(self: Layer<A, E, R>, f: (context: Context.Context<A>) => Context.Context<B>): Layer<B, E, R>; }\n```\n\n----------------------------------------\n\nTITLE: HttpApiBuilder.toWebHandler Type Definition in TypeScript\nDESCRIPTION: The type signature for the HttpApiBuilder.toWebHandler function. It accepts a Layer and optional configuration parameters including middleware and memoMap. It returns an object containing a handler function for HTTP requests and a dispose function for cleanup.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/HttpApiBuilder-toWebHandler.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const toWebHandler: <LA, LE>(layer: Layer.Layer<LA | HttpApi.Api | HttpRouter.HttpRouter.DefaultServices, LE>, options?: { readonly middleware?: (httpApp: HttpApp.Default) => HttpApp.Default<never, HttpApi.Api | Router | HttpRouter.HttpRouter.DefaultServices>; readonly memoMap?: Layer.MemoMap; }) => { readonly handler: (request: Request, context?: Context.Context<never> | undefined) => Promise<Response>; readonly dispose: () => Promise<void>; }\n```\n\n----------------------------------------\n\nTITLE: Enabling RuntimeFlags in Effect\nDESCRIPTION: The `enable` function allows enabling a specific RuntimeFlag within a RuntimeFlags instance. It supports both curried and uncurried usage patterns, making it flexible for different coding styles.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/RuntimeFlags-enable.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const enable: { (flag: RuntimeFlag): (self: RuntimeFlags) => RuntimeFlags; (self: RuntimeFlags, flag: RuntimeFlag): RuntimeFlags; }\n```\n\n----------------------------------------\n\nTITLE: TypeScript Function Signature for Histogram Metric Creation\nDESCRIPTION: This code block shows the TypeScript function signature for the Metric.histogram function. It specifies the parameters and return type for creating a histogram metric.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Metric-histogram.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const histogram: (name: string, boundaries: MetricBoundaries.MetricBoundaries, description?: string) => Metric<MetricKeyType.MetricKeyType.Histogram, number, MetricState.MetricState.Histogram>\n```\n\n----------------------------------------\n\nTITLE: Checking Fiber Interruptibility with RuntimeFlags in TypeScript\nDESCRIPTION: This function determines if a fiber is in an interruptible state by checking if the Interruption flag is enabled while the WindDown flag is disabled. A fiber can only be interrupted when it's not in its wind-down phase, where it handles cleanup activities related to shutdown.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/RuntimeFlags-interruptible.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const interruptible: (self: RuntimeFlags) => boolean\n```\n\n----------------------------------------\n\nTITLE: DateTime.format Function Signature in TypeScript\nDESCRIPTION: Defines the function signature for DateTime.format which formats a DateTime object as a string using the DateTimeFormat API. It handles time zones by setting the timeZone option to the offset, with special behavior for Node versions < 22 where fixed \"Offset\" zones will set the time zone to \"UTC\" and use the adjusted Date.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/DateTime-format.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const format: { (options?: (Intl.DateTimeFormatOptions & { readonly locale?: string | undefined; }) | undefined): (self: DateTime) => string; (self: DateTime, options?: (Intl.DateTimeFormatOptions & { readonly locale?: string | undefined; }) | undefined): string; }\n```\n\n----------------------------------------\n\nTITLE: Defining a Recurring Schedule with Duration Limit - TypeScript\nDESCRIPTION: The `recurUpTo` function defines a schedule that continues executing until a specified duration has elapsed. It is designed to limit the execution time of operations, ensuring they do not run indefinitely. The function takes a `duration` parameter of type `Duration.DurationInput` and returns a `Schedule<Duration.Duration>` instance.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Schedule-recurUpTo.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const recurUpTo: (duration: Duration.DurationInput) => Schedule<Duration.Duration>\n```\n\n----------------------------------------\n\nTITLE: isIterable Signature\nDESCRIPTION: This code shows the type signature of the `isIterable` predicate. It takes an unknown input and returns a boolean indicating whether the input is an Iterable.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Predicate-isIterable.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const isIterable: (input: unknown) => input is Iterable<unknown>\n```\n\n----------------------------------------\n\nTITLE: Adding Labels to MetricKey in TypeScript\nDESCRIPTION: Function definition for taggedWithLabels that allows appending additional metric labels to an existing MetricKey. Supports both curried and standard function call syntax.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/MetricKey-taggedWithLabels.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const taggedWithLabels: { \n  (extraTags: ReadonlyArray<MetricLabel.MetricLabel>): \n    <Type extends MetricKeyType.MetricKeyType<any, any>>(self: MetricKey<Type>) => MetricKey<Type>; \n  <Type extends MetricKeyType.MetricKeyType<any, any>>(self: MetricKey<Type>, \n    extraTags: ReadonlyArray<MetricLabel.MetricLabel>): MetricKey<Type>; \n}\n```\n\n----------------------------------------\n\nTITLE: Using Doc.nest for Document Indentation in TypeScript\nDESCRIPTION: Demonstrates how to use Doc.nest to control indentation levels in a document. The example shows nesting 'lorem ipsum dolor' text with 4 spaces of indentation while leaving 'sit' and 'amet' at the base level.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Doc-nest.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport * as Doc from \"@effect/printer/Doc\"\nimport { pipe } from \"effect/Function\"\nimport * as String from \"effect/String\"\n\nconst doc = Doc.vsep([\n  pipe(Doc.vsep(Doc.words(\"lorem ipsum dolor\")), Doc.nest(4)),\n  Doc.text(\"sit\"),\n  Doc.text(\"amet\")\n])\n\nassert.strictEqual(\n  Doc.render(doc, { style: \"pretty\" }),\n  String.stripMargin(\n    `|lorem\n     |    ipsum\n     |    dolor\n     |sit\n     |amet`\n  )\n)\n```\n\n----------------------------------------\n\nTITLE: HashSet.some Function Signature in TypeScript\nDESCRIPTION: Type declaration for the HashSet.some function, showing its overloaded implementations. The function supports both data-first and data-last calling styles and takes a predicate function as an argument, returning a boolean result.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/HashSet-some.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const some: { <A>(f: Predicate<A>): (self: HashSet<A>) => boolean; <A>(self: HashSet<A>, f: Predicate<A>): boolean; }\n```\n\n----------------------------------------\n\nTITLE: Defining CooperativeYielding RuntimeFlag in TypeScript\nDESCRIPTION: Declaration of the CooperativeYielding constant which represents a RuntimeFlag that determines whether the Effect runtime will yield to another fiber during execution.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/RuntimeFlags-CooperativeYielding.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const CooperativeYielding: RuntimeFlag\n```\n\n----------------------------------------\n\nTITLE: Defining interruptWhen Function in TypeScript\nDESCRIPTION: TypeScript signature for the interruptWhen function, which takes an Effect and a Channel and returns a new Channel that will be interrupted when the specified effect completes. The function handles both the case where the effect completes before the channel and vice versa.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Channel-interruptWhen.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const interruptWhen: { <OutDone1, OutErr1, Env1>(effect: Effect.Effect<OutDone1, OutErr1, Env1>): <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>) => Channel<OutElem, InElem, OutErr1 | OutErr, InErr, OutDone1 | OutDone, InDone, Env1 | Env>; <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutDone1, OutErr1, Env1>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>, effect: Effect.Effect<OutDone1, OutErr1, Env1>): Channel<OutElem, InElem, OutErr | OutErr1, InErr, OutDone | OutDone1, InDone, Env | Env1>; }\n```\n\n----------------------------------------\n\nTITLE: Declaring reAnnotate Function for DocStream Annotation Modification\nDESCRIPTION: Defines a function that modifies annotations of a document stream. The function is overloaded to support both curried and non-curried calling styles, transforming annotations from type A to type B.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/DocStream-reAnnotate.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const reAnnotate: { <A, B>(f: (a: A) => B): (self: DocStream<A>) => DocStream<B>; <A, B>(self: DocStream<A>, f: (a: A) => B): DocStream<B>; }\n```\n\n----------------------------------------\n\nTITLE: Defining ChannelException Interface in TypeScript\nDESCRIPTION: TypeScript interface definition for ChannelException, which represents a generic checked exception occurring during Channel execution. The interface includes a type tag, a TypeId symbol, and an error field of generic type E.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Channel-ChannelException.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface ChannelException<out E> {\n  readonly _tag: \"ChannelException\"\n  readonly [ChannelExceptionTypeId]: ChannelExceptionTypeId\n  readonly error: E\n}\n```\n\n----------------------------------------\n\nTITLE: STM orElseOptional Definition in Effect TS\nDESCRIPTION: Defines the `orElseOptional` function in the `STM` module of the Effect TS library. This function takes two STM effects as input: `self` and `that`. If `self` fails with a `None` value, `that` is executed instead. It returns a new STM effect that combines the results and errors of both input effects.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/STM-orElseOptional.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const orElseOptional: { <A2, E2, R2>(that: LazyArg<STM<A2, Option.Option<E2>, R2>>): <A, E, R>(self: STM<A, Option.Option<E>, R>) => STM<A2 | A, Option.Option<E2 | E>, R2 | R>; <A, E, R, A2, E2, R2>(self: STM<A, Option.Option<E>, R>, that: LazyArg<STM<A2, Option.Option<E2>, R2>>): STM<A | A2, Option.Option<E | E2>, R | R2>; }\n```\n\n----------------------------------------\n\nTITLE: DateTime.distanceDuration Function Signature\nDESCRIPTION: TypeScript type declaration for the distanceDuration function, showing both curried and uncurried versions of the function that accept DateTime parameters and return a Duration object.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/DateTime-distanceDuration.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const distanceDuration: { (other: DateTime): (self: DateTime) => Duration.Duration; (self: DateTime, other: DateTime): Duration.Duration; }\n```\n\n----------------------------------------\n\nTITLE: Collecting Elements into a Readonly Set - TypeScript\nDESCRIPTION: The toReadonlySet function collects all elements from a TSet and returns them as a ReadonlySet. It ensures immutability of the set's contents, which can be beneficial for state management and concurrency control. The function signature indicates that it operates within an STM context, meaning it works with Software Transactional Memory for safe concurrent modifications.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TSet-toReadonlySet.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const toReadonlySet: <A>(self: TSet<A>) => STM.STM<ReadonlySet<A>>\n```\n\n----------------------------------------\n\nTITLE: Declaring Dropping Sink Effect TypeScript\nDESCRIPTION: The TypeScript snippet declares a function `drop` that creates a Sink which will ignore a specified number of elements. This is part of the Effect library's utilities for handling data streams. The function uses generics for the input type and introduces a dependency on the Effect library for Sinks. It inputs a number `n` indicating how many elements to drop and outputs a Sink that does not forward the dropped elements.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Sink-drop.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const drop: <In>(n: number) => Sink<unknown, In, In>\n```\n\n----------------------------------------\n\nTITLE: Checking MutableQueue Fullness in TypeScript\nDESCRIPTION: This snippet declares a TypeScript function that takes a MutableQueue instance and returns a boolean indicating whether the queue is full. It requires the MutableQueue type from the effect library.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/MutableQueue-isFull.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const isFull: <A>(self: MutableQueue<A>) => boolean\n```\n\n----------------------------------------\n\nTITLE: Guarding Inputs from Null Values using Effect Predicate in TypeScript\nDESCRIPTION: The code snippet provides an example and signature of a TypeScript predicate function, isNotNullable, sourced from the Effect library. The function is designed to check whether a given input is not null or undefined, returning true for non-nullable inputs and false otherwise. This utility is useful in scenarios where type safety and null checks are necessary.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Predicate-isNotNullable.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { isNotNullable } from \"effect/Predicate\"\n\nassert.deepStrictEqual(isNotNullable({}), true)\nassert.deepStrictEqual(isNotNullable([]), true)\n\nassert.deepStrictEqual(isNotNullable(null), false)\nassert.deepStrictEqual(isNotNullable(undefined), false)\n```\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const isNotNullable: <A>(input: A) => input is NonNullable<A>\n```\n\n----------------------------------------\n\nTITLE: Defining Empty Interval Constant in TypeScript\nDESCRIPTION: Declares a constant named 'empty' of type 'Interval'. This constant represents an interval with zero width, effectively an empty interval in the ScheduleInterval module.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/ScheduleInterval-empty.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const empty: Interval\n```\n\n----------------------------------------\n\nTITLE: Ordering Semigroup Example in Effect TS\nDESCRIPTION: This code snippet demonstrates how to use the Semigroup instance for the Ordering type in Effect TS.  It shows how the `combine` method of the Semigroup returns the leftmost non-zero `Ordering` value when combining two `Ordering` values. The `Ordering` type can be -1, 0, or 1.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/data-Ordering-Semigroup.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Semigroup } from \"@effect/typeclass/data/Ordering\"\n\nconsole.log(Semigroup.combine(0, -1))\n// -1\nconsole.log(Semigroup.combine(0, 1))\n// 1\nconsole.log(Semigroup.combine(1, -1))\n// 1\n```\n\n----------------------------------------\n\nTITLE: Declaring taggedWithLabelsInput Function in TypeScript\nDESCRIPTION: Defines the taggedWithLabelsInput function which returns a new metric with dynamically added tags based on input values. The function can be used in two ways: with the metric as the first argument or as a curried function.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Metric-taggedWithLabelsInput.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const taggedWithLabelsInput: { <In>(f: (input: In) => Iterable<MetricLabel.MetricLabel>): <Type, Out>(self: Metric<Type, In, Out>) => Metric<Type, In, void>; <Type, In, Out>(self: Metric<Type, In, Out>, f: (input: In) => Iterable<MetricLabel.MetricLabel>): Metric<Type, In, void>; }\n```\n\n----------------------------------------\n\nTITLE: Declaring Reverse Ordering Function in Effect\nDESCRIPTION: This code snippet declares the type signature for the `reverse` function in the `effect/Ordering` module. The `reverse` function takes an `Ordering` type (likely a numeric value representing order) as input and returns an `Ordering` type as output. It is used to invert the ordering of a given value.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Ordering-reverse.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const reverse: (o: Ordering) => Ordering\n```\n\n----------------------------------------\n\nTITLE: Using renderSimplyDecorated to Apply Formatting in DocTree\nDESCRIPTION: This example demonstrates how to use renderSimplyDecorated to apply custom formatting to annotated regions in a document. It creates a document with some text annotated with 'void', then uses renderSimplyDecorated to surround those annotated regions with '>>>' and '<<<' markers.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/DocTree-renderSimplyDecorated.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport * as Doc from \"@effect/printer/Doc\"\nimport * as DocTree from \"@effect/printer/DocTree\"\nimport * as Layout from \"@effect/printer/Layout\"\nimport { identity, pipe } from \"effect/Function\"\nimport * as String from \"@effect/typeclass/data/String\"\n\nconst doc: Doc.Doc<void> = Doc.hsep([\n  Doc.text(\"hello\"),\n  pipe(\n    Doc.text(\"world\"),\n    Doc.annotate(undefined),\n    Doc.cat(Doc.char(\"!\"))\n  )\n])\n\nconst tree = DocTree.treeForm(Layout.pretty(Layout.defaultOptions)(doc))\n\nconst rendered = pipe(\n  tree,\n  DocTree.renderSimplyDecorated(String.Monoid, identity, (_, x) => `>>>${x}<<<`)\n)\n\nassert.strictEqual(\n  rendered,\n  \"hello >>>world<<<!\"\n)\n```\n\n----------------------------------------\n\nTITLE: Defining MicroExit Union Type in TypeScript\nDESCRIPTION: Defines MicroExit as a union type that represents either a successful computation with value A or a failed computation with error E wrapped in MicroCause. This type is used as the result type for Micro computations in the Effect.io library.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Micro-MicroExit.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ntype MicroExit<A, E> = | MicroExit.Success<A, E>\n  | MicroExit.Failure<A, E>\n```\n\n----------------------------------------\n\nTITLE: Flattening Take Stream in Effect-TS\nDESCRIPTION: A utility function that unwraps Exit values and flattens chunks, handling stream termination by potentially failing with None. Used for transforming streams with complex exit conditions.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-flattenTake.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const flattenTake: <A, E2, E, R>(self: Stream<Take.Take<A, E2>, E, R>) => Stream<A, E | E2, R>\n```\n\n----------------------------------------\n\nTITLE: Determining if a Record is Empty with TypeScript and Effect\nDESCRIPTION: The `isEmptyRecord` function checks whether a given record (object) has no properties. This function utilizes TypeScript generics to ensure type safety and is an essential utility for developers using the Effect library. It can be used to validate objects before performing operations that require property existence, enhancing code reliability.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Record-isEmptyRecord.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { isEmptyRecord } from \"effect/Record\"\n\nassert.deepStrictEqual(isEmptyRecord({}), true);\nassert.deepStrictEqual(isEmptyRecord({ a: 3 }), false);\n```\n\n----------------------------------------\n\nTITLE: Declaring File Parameter Option in Effect-TS TypeScript\nDESCRIPTION: This TypeScript snippet declares a function 'file' which creates a command line option expecting a file path. It takes a 'name' parameter as a string and an optional 'config' parameter of type 'Options.PathOptionsConfig'. It returns an option specific to file paths. This function is part of the Effect-TS CLI module and requires the Options module. This functionality was introduced in version 1.0.0.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Options-file.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const file: (name: string, config?: Options.PathOptionsConfig) => Options<string>\n```\n\n----------------------------------------\n\nTITLE: Transforming Option Values in TypeScript with Effect TS\nDESCRIPTION: This snippet demonstrates how to use the `Option.as` function from the Effect TS library to replace the value within a `Some` without altering `None`. The function is useful to retain the presence of an optional value while updating its content to a constant value. Dependencies include the Effect TS library.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Option-as.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Option } from \"effect\"\n\n// Replacing the value of a `Some`\nconst someValue = Option.some(42)\n\nconsole.log(Option.as(someValue, \"new value\"))\n// Output: { _id: 'Option', _tag: 'Some', value: 'new value' }\n\n// Replacing a `None` (no effect)\nconst noneValue = Option.none<number>()\n\nconsole.log(Option.as(noneValue, \"new value\"))\n// Output: { _id: 'Option', _tag: 'None' }\n```\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const as: { <B>(b: B): <X>(self: Option<X>) => Option<B>; <X, B>(self: Option<X>, b: B): Option<B>; }\n```\n\n----------------------------------------\n\nTITLE: Multiplying Numbers in an Iterable with TypeScript\nDESCRIPTION: This example demonstrates how to use the `multiplyAll` function from the `effect/Number` module to multiply all numbers within an array. It imports the necessary module, calls `multiplyAll` with an array of numbers, and then uses `assert.deepStrictEqual` to verify the result is correct.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Number-multiplyAll.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { multiplyAll } from \"effect/Number\"\n\nassert.deepStrictEqual(multiplyAll([2, 3, 4]), 24)\n```\n\n----------------------------------------\n\nTITLE: Taking Elements Between Min and Max from Transactional Queue in TypeScript\nDESCRIPTION: The takeBetween function takes a number of elements from a transactional queue between the specified minimum and maximum. If fewer than the minimum elements are available, it retries until at least the minimum number of elements have been collected.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TQueue-takeBetween.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const takeBetween: { (min: number, max: number): <A>(self: TDequeue<A>) => STM.STM<Array<A>>; <A>(self: TDequeue<A>, min: number, max: number): STM.STM<Array<A>>; }\n```\n\n----------------------------------------\n\nTITLE: Declaring Key Retrieval for Red-Black Tree in TypeScript\nDESCRIPTION: This TypeScript snippet declares a function named `keysReversed` for retrieving all keys of a Red-Black Tree in reverse order. The function accepts a `RedBlackTree` instance as a parameter and returns an `IterableIterator` of keys. This implementation is part of the Red-Black Tree module in the `effect` package, starting from version 2.0.0.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/RedBlackTree-keysReversed.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const keysReversed: <K, V>(self: RedBlackTree<K, V>) => IterableIterator<K>\n```\n\n----------------------------------------\n\nTITLE: Closing a Scope Using Effect in TypeScript\nDESCRIPTION: This TypeScript snippet defines a method to close a scope while running all finalizers in the `effect` module. The `close` function requires a `CloseableScope` instance and an exit value of type `Exit.Exit<unknown, unknown>`. It returns an `Effect.Effect<void>`, indicating an effectful computation that performs closure operations. The method is introduced in version 2.0.0 and is located in the 'Scope.ts' file.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Scope-close.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const close: (self: CloseableScope, exit: Exit.Exit<unknown, unknown>) => Effect.Effect<void>\n```\n\n----------------------------------------\n\nTITLE: Checking Schedule Instance in TypeScript\nDESCRIPTION: This TypeScript function `isSchedule` checks if the input value is an instance of `Schedule`. It is useful for type assertions and is defined in the Schedule module of the `effect` package. The function returns a boolean indicating the type compliance of the input.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Schedule-isSchedule.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const isSchedule: (u: unknown) => u is Schedule<unknown, never, unknown>\n```\n\n----------------------------------------\n\nTITLE: Declaring Screen Erasing Function in TypeScript for ANSI Terminal Control\nDESCRIPTION: Defines a constant 'eraseScreen' of type 'Ansi' that clears the entire terminal screen and moves the cursor to the upper left position. This function is part of the @effect/printer-ansi module.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Ansi-eraseScreen.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const eraseScreen: Ansi\n```\n\n----------------------------------------\n\nTITLE: Implementing keyof Operator for Schema AST in TypeScript\nDESCRIPTION: Function declaration for keyof operation that takes an AST parameter and returns a new AST. This provides runtime functionality equivalent to TypeScript's keyof type operator.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/SchemaAST-keyof.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const keyof: (ast: AST) => AST\n```\n\n----------------------------------------\n\nTITLE: Defining Iterable.drop Function in TypeScript\nDESCRIPTION: Declares the drop function for Iterable objects. It allows dropping a specified number of elements from the start of an Iterable. The function can be used in two ways: by passing the number of elements to drop first, or by passing the Iterable first and then the number of elements to drop.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Iterable-drop.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const drop: { (n: number): <A>(self: Iterable<A>) => Iterable<A>; <A>(self: Iterable<A>, n: number): Iterable<A>; }\n```\n\n----------------------------------------\n\nTITLE: Mutating DateTime Objects using Date Instance in TypeScript\nDESCRIPTION: Function signature for mutating a DateTime object by applying modifications to a cloned Date instance. The function handles timezone conversions and preserves the original timezone when converting back to DateTime.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/DateTime-mutate.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const mutate: { (f: (date: Date) => void): <A extends DateTime>(self: A) => A; <A extends DateTime>(self: A, f: (date: Date) => void): A; }\n```\n\n----------------------------------------\n\nTITLE: Mapping Exit Error States in TypeScript\nDESCRIPTION: Function signature for mapError, which transforms the error type E to E2 in an Exit<A, E> type. It supports both curried and uncurried forms of invocation for mapping over error states.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Exit-mapError.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const mapError: { <E, E2>(f: (e: E) => E2): <A>(self: Exit<A, E>) => Exit<A, E2>; <A, E, E2>(self: Exit<A, E>, f: (e: E) => E2): Exit<A, E2>; }\n```\n\n----------------------------------------\n\nTITLE: Implementing RedBlackTree.at Iterator Function in TypeScript\nDESCRIPTION: Function signature for creating an iterator that returns elements at a specified index in a Red-Black Tree. The iterator traverses elements in order and supports both curried and non-curried calling styles.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/RedBlackTree-at.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const at: { \n  (index: number): <K, V>(self: RedBlackTree<K, V>) => Iterable<[K, V]>; \n  <K, V>(self: RedBlackTree<K, V>, index: number): Iterable<[K, V]>; \n}\n```\n\n----------------------------------------\n\nTITLE: Doc.nesting Function Signature in TypeScript\nDESCRIPTION: The type signature for the Doc.nesting function, which takes a callback function that receives the current nesting level as a number and returns a Doc<A>.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Doc-nesting.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const nesting: <A>(react: (level: number) => Doc<A>) => Doc<A>\n```\n\n----------------------------------------\n\nTITLE: Checking if a MutableList is Empty in Typescript\nDESCRIPTION: The `isEmpty` function checks if a `MutableList` contains zero elements. It takes a `MutableList` of type `A` as input and returns a boolean value indicating whether the list is empty or not. The function is part of the Effect library's `MutableList` module and is available since version 2.0.0.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/MutableList-isEmpty.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const isEmpty: <A>(self: MutableList<A>) => boolean\n```\n\n----------------------------------------\n\nTITLE: Creating a Layer for Runner Health Checking in TypeScript\nDESCRIPTION: Declares a layer that can ping a Runner directly to check if it is healthy. This layer depends on the Runners.Runners service and provides the RunnerHealth service.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/RunnerHealth-layer.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const layer: Layer.Layer<RunnerHealth, never, Runners.Runners>\n```\n\n----------------------------------------\n\nTITLE: Effect.flip TypeScript Function Signature\nDESCRIPTION: The type signature for the Effect.flip function, which takes an Effect with type parameters A (success), E (error), and R (environment) and returns an Effect with swapped A and E types.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-flip.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const flip: <A, E, R>(self: Effect<A, E, R>) => Effect<E, A, R>\n```\n\n----------------------------------------\n\nTITLE: Constructing Empty List in TypeScript using Effect Package\nDESCRIPTION: The nil function constructs a new empty List<A>. It takes no arguments and returns an empty list of type A, where A defaults to never if not specified.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/List-nil.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const nil: <A = never>() => List<A>\n```\n\n----------------------------------------\n\nTITLE: Testing String.isEmpty Function in TypeScript\nDESCRIPTION: Example demonstrating how to use the String.isEmpty function to check if a string is empty. Shows both positive and negative test cases using Node's assert module.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/String-isEmpty.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { String } from \"effect\"\n\nassert.deepStrictEqual(String.isEmpty(''), true)\nassert.deepStrictEqual(String.isEmpty('a'), false)\n```\n\n----------------------------------------\n\nTITLE: Defining Schedule.collectUntil TypeScript Type Declaration\nDESCRIPTION: Declares a generic Schedule function that collects inputs into a Chunk, continuing collection until a predicate function returns false. Useful for conditional input aggregation.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Schedule-collectUntil.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const collectUntil: <A>(f: Predicate<A>) => Schedule<Chunk.Chunk<A>, A>\n```\n\n----------------------------------------\n\nTITLE: Providing Context to RequestResolver in Effect TypeScript\nDESCRIPTION: Defines the provideContext function which provides a data source with its required context. This function has two overloads: one for providing context to a resolver, and another for providing context to a resolver with the arguments in reverse order.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/RequestResolver-provideContext.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const provideContext: { <R>(context: Context.Context<R>): <A extends Request.Request<any, any>>(self: RequestResolver<A, R>) => RequestResolver<A>; <R, A extends Request.Request<any, any>>(self: RequestResolver<A, R>, context: Context.Context<R>): RequestResolver<A>; }\n```\n\n----------------------------------------\n\nTITLE: Implementing Config.withDefault in TypeScript\nDESCRIPTION: A function that returns a modified config with a specified default value that will be used when the requested configuration information cannot be found.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Config-withDefault.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const withDefault: { <const A2>(def: A2): <A>(self: Config<A>) => Config<A2 | A>; <A, const A2>(self: Config<A>, def: A2): Config<A | A2>; }\n```\n\n----------------------------------------\n\nTITLE: Defining EntryStats Interface for Cache Entries in TypeScript\nDESCRIPTION: Defines the EntryStats interface representing a snapshot of statistics for an entry in the cache. It includes a single readonly property 'loadedMillis' of type number, which likely represents the time when the entry was loaded into the cache.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Cache-EntryStats.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface EntryStats {\n  readonly loadedMillis: number\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a failing Sink in Effect\nDESCRIPTION: The `Sink.fail` function creates a `Sink` that immediately fails with the provided error `e`. It's useful for representing error conditions or invalid states within a stream processing pipeline. The function takes a single generic type parameter `E` representing the error type.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Sink-fail.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const fail: <E>(e: E) => Sink<never, unknown, never, E>\n```\n\n----------------------------------------\n\nTITLE: Defining Effect.asVoid Type Signature in TypeScript\nDESCRIPTION: Type signature for the asVoid function that takes an Effect<A, E, R> and returns Effect<void, E, R>. The function preserves the error type E and environment type R while converting any success value to void.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-asVoid.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const asVoid: <A, E, R>(self: Effect<A, E, R>) => Effect<void, E, R>\n```\n\n----------------------------------------\n\nTITLE: Defining zipWith Function in TypeScript for Effect.io Schedule Module\nDESCRIPTION: The zipWith function combines two schedules using intersect and then applies a mapping function. It has two overloads to allow for different parameter orders. The function works with generic types for input, output, and environment.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Schedule-zipWith.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const zipWith: { <Out2, In2, R2, Out, Out3>(that: Schedule<Out2, In2, R2>, f: (out: Out, out2: Out2) => Out3): <In, R>(self: Schedule<Out, In, R>) => Schedule<Out3, In & In2, R2 | R>; <Out, In, R, Out2, In2, R2, Out3>(self: Schedule<Out, In, R>, that: Schedule<Out2, In2, R2>, f: (out: Out, out2: Out2) => Out3): Schedule<Out3, In & In2, R | R2>; }\n```\n\n----------------------------------------\n\nTITLE: Transforming Second Tuple Component in TypeScript\nDESCRIPTION: This snippet demonstrates how to use the mapSecond function to transform the second component of a tuple from a number to a string. The mapSecond function takes a function as an argument that processes the second element of the tuple.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Tuple-mapSecond.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { mapSecond } from \"effect/Tuple\"\n\nassert.deepStrictEqual(\n  mapSecond([\"hello\", 42], n => n.toString()),\n  [\"hello\", \"42\"]\n)\n```\n\n----------------------------------------\n\nTITLE: Converting Mailbox to Channel in TypeScript\nDESCRIPTION: Function that creates a Channel from a Mailbox instance. The channel processes data of type A and can handle errors of type E, outputting chunks of data.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Mailbox-toChannel.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const toChannel: <A, E>(self: ReadonlyMailbox<A, E>) => Channel<Chunk<A>, unknown, E>\n```\n\n----------------------------------------\n\nTITLE: Getting Primitive Type Name in TypeScript\nDESCRIPTION: This function returns a string representation of the primitive type. It takes a Primitive<A> as input and returns a string.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Primitive-getTypeName.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const getTypeName: <A>(self: Primitive<A>) => string\n```\n\n----------------------------------------\n\nTITLE: Retrieving Values from Redacted Type in TypeScript\nDESCRIPTION: Shows how to retrieve the original value from a Redacted instance using Redacted.value. Demonstrates creating a redacted API key and accessing its value. This operation should be used carefully as it exposes sensitive data.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Redacted-value.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { Redacted } from \"effect\"\n\nconst API_KEY = Redacted.make(\"1234567890\")\n\nassert.equal(Redacted.value(API_KEY), \"1234567890\")\n```\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const value: <A>(self: Redacted<A>) => A\n```\n\n----------------------------------------\n\nTITLE: MutableQueue.poll signature in TypeScript\nDESCRIPTION: This TypeScript code snippet shows the signature of the `poll` function in the `MutableQueue` module. It allows dequeuing an element from the queue or returning a default value if the queue is empty. The function has two possible call signatures.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/MutableQueue-poll.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const poll: { <D>(def: D): <A>(self: MutableQueue<A>) => D | A; <A, D>(self: MutableQueue<A>, def: D): A | D; }\n```\n\n----------------------------------------\n\nTITLE: Checking for Empty Doc in TypeScript\nDESCRIPTION: This function returns true if the specified Doc is an Empty, false otherwise. It takes a Doc<A> as input and returns a boolean, with a type guard indicating that the Doc is Empty<A> if true.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Doc-isEmpty.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const isEmpty: <A>(self: Doc<A>) => self is Empty<A>\n```\n\n----------------------------------------\n\nTITLE: Calculating Size of a Cause Structure in TypeScript\nDESCRIPTION: This function calculates the total number of nodes in a Cause semiring structure, reflecting how many individual error elements are recorded. It takes a Cause object and returns a number.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Cause-size.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const size: <E>(self: Cause<E>) => number\n```\n\n----------------------------------------\n\nTITLE: Implementing tapInput Function for Schedule Modification in TypeScript\nDESCRIPTION: Defines a tapInput function that returns a new schedule running an effectful function for each input before continuing execution. It allows side effects to be performed on each input processed by the schedule without modifying its core behavior.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Schedule-tapInput.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const tapInput: { <In2, X, R2>(f: (input: In2) => Effect.Effect<X, never, R2>): <Out, In, R>(self: Schedule<Out, In, R>) => Schedule<Out, In & In2, R2 | R>; <Out, In, R, In2, X, R2>(self: Schedule<Out, In, R>, f: (input: In2) => Effect.Effect<X, never, R2>): Schedule<Out, In & In2, R | R2>; }\n```\n\n----------------------------------------\n\nTITLE: Creating BrandErrors with Brand.error in TypeScript\nDESCRIPTION: This function returns a BrandErrors object containing a single RefinementError. It accepts a message string and an optional meta parameter for additional data.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Brand-error.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const error: (message: string, meta?: unknown) => Brand.BrandErrors\n```\n\n----------------------------------------\n\nTITLE: Testing for Null with Node.js Assertions in TypeScript\nDESCRIPTION: This TypeScript code snippet tests if various values are `null` using the Predicate module from the Effect library. The example showcases how to import necessary modules and perform deep strict equality assertions to validate the functionality of `isNull`. This requires the `assert` module from Node.js and the `isNull` function from the Effect library.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Predicate-isNull.md#2025-04-11_snippet_0\n\nLANGUAGE: ts\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { isNull } from \"effect/Predicate\"\n\nassert.deepStrictEqual(isNull(null), true)\n\nassert.deepStrictEqual(isNull(undefined), false)\nassert.deepStrictEqual(isNull(\"null\"), false)\n```\n\n----------------------------------------\n\nTITLE: Type Checking List.Cons in TypeScript\nDESCRIPTION: Type guard function that determines if a List value is specifically a Cons type. Returns true for Cons instances and provides type narrowing in TypeScript.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/List-isCons.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const isCons: <A>(self: List<A>) => self is Cons<A>\n```\n\n----------------------------------------\n\nTITLE: Defining Order lessThanOrEqualTo Comparison Function\nDESCRIPTION: A type declaration for a comparative function that checks if one value is less than or equal to another, supporting both curried and direct function call styles\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Order-lessThanOrEqualTo.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const lessThanOrEqualTo: <A>(O: Order<A>) => { (that: A): (self: A) => boolean; (self: A, that: A): boolean; }\n```\n\n----------------------------------------\n\nTITLE: Declaring the isPromise function in Effect Predicate\nDESCRIPTION: This code snippet shows the type declaration of the `isPromise` function. It takes an unknown input and returns a boolean, indicating whether the input is a Promise or not.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Predicate-isPromise.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const isPromise: (input: unknown) => input is Promise<unknown>\n```\n\n----------------------------------------\n\nTITLE: Implementing Document Parenthesization in @effect/printer Module\nDESCRIPTION: This function encloses the input document in parentheses. It takes a document of type Doc<A> and returns a new document of the same type but surrounded by parentheses.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Doc-parenthesized.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const parenthesized: <A>(self: Doc<A>) => Doc<A>\n```\n\n----------------------------------------\n\nTITLE: Checking Deferred Completion Status with isDone in Effect-TS (TypeScript)\nDESCRIPTION: The isDone function returns a boolean Effect indicating whether a Deferred has been completed with a value or an error. It takes a Deferred instance as input and returns an Effect that resolves to true if completed, false otherwise.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Deferred-isDone.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const isDone: <A, E>(self: Deferred<A, E>) => Effect.Effect<boolean>\n```\n\n----------------------------------------\n\nTITLE: Type Signature for Boolean.not Function\nDESCRIPTION: Provides the TypeScript type signature for the not function, indicating it takes a boolean parameter and returns a boolean result.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Boolean-not.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const not: (self: boolean) => boolean\n```\n\n----------------------------------------\n\nTITLE: Declaring Effect.filterOrDie Function in TypeScript\nDESCRIPTION: This code snippet shows the type declaration for the Effect.filterOrDie function. It defines multiple overloads to handle different use cases, including refinement and predicate-based filtering with custom error handling.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-filterOrDie.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const filterOrDie: { <A, B extends A>(refinement: Refinement<NoInfer<A>, B>, orDieWith: (a: NoInfer<A>) => unknown): <E, R>(self: Effect<A, E, R>) => Effect<B, E, R>; <A>(predicate: Predicate<NoInfer<A>>, orDieWith: (a: NoInfer<A>) => unknown): <E, R>(self: Effect<A, E, R>) => Effect<A, E, R>; <A, E, R, B extends A>(self: Effect<A, E, R>, refinement: Refinement<A, B>, orDieWith: (a: A) => unknown): Effect<B, E, R>; <A, E, R>(self: Effect<A, E, R>, predicate: Predicate<A>, orDieWith: (a: A) => unknown): Effect<A, E, R>; }\n```\n\n----------------------------------------\n\nTITLE: Implementing orDie Function in TypeScript for Micro Effects\nDESCRIPTION: Function signature for orDie that converts a Micro effect with error type E to one with error type never, effectively treating all errors as unexpected. Used for error handling elevation in Effect-IO's Micro module.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Micro-orDie.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const orDie: <A, E, R>(self: Micro<A, E, R>) => Micro<A, never, R>\n```\n\n----------------------------------------\n\nTITLE: Converting TPriorityQueue to Array in TypeScript using STM\nDESCRIPTION: This function collects all values from a transactional priority queue into an array. It operates within the STM transactional context, meaning it can be composed with other STM operations atomically.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TPriorityQueue-toArray.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const toArray: <A>(self: TPriorityQueue<A>) => STM.STM<Array<A>>\n```\n\n----------------------------------------\n\nTITLE: Implementing Exhaustive Pattern Matching in TypeScript using Effect's Match Module\nDESCRIPTION: This snippet demonstrates how to use Match.exhaustive to ensure all cases are covered when pattern matching on a union type. It creates a matcher for string or number values and shows how TypeScript will produce an error if any case is missing.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Match-exhaustive.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Match } from \"effect\"\n\n// Create a matcher for string or number values\nconst match = Match.type<string | number>().pipe(\n  // Match when the value is a number\n  Match.when(Match.number, (n) => `number: ${n}`),\n  // Mark the match as exhaustive, ensuring all cases are handled\n  // TypeScript will throw an error if any case is missing\n  // @ts-expect-error Type 'string' is not assignable to type 'never'\n  Match.exhaustive\n)\n```\n\n----------------------------------------\n\nTITLE: Creating Order for Tuple Values in TypeScript\nDESCRIPTION: This function, `getOrder`, creates and returns a new Order for a tuple of values using the provided Orders for each one. It enables the comparison of tuples of the same type through the application of their respective element Orders.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Tuple-getOrder.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const getOrder: <T extends ReadonlyArray<order.Order<any>>>(...elements: T) => order.Order<{ [I in keyof T]: [T[I]] extends [order.Order<infer A>] ? A : never; }>;\\n\n```\n\n----------------------------------------\n\nTITLE: Retrieving Annotations Service in Effect\nDESCRIPTION: This code snippet shows how to retrieve the `Annotations` service for tests within the Effect framework using the `annotations` function. The function returns an `Effect` that, when executed, provides access to `Annotations.TestAnnotations`.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TestServices-annotations.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const annotations: () => Effect.Effect<Annotations.TestAnnotations>\n```\n\n----------------------------------------\n\nTITLE: Checking Disabled RuntimeFlags in Effect.ts\nDESCRIPTION: This function checks if a specific RuntimeFlag is described as disabled within a RuntimeFlagsPatch instance. It supports both curried and uncurried calling styles for flexibility.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/RuntimeFlagsPatch-isDisabled.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const isDisabled: { (flag: RuntimeFlags.RuntimeFlag): (self: RuntimeFlagsPatch) => boolean; (self: RuntimeFlagsPatch, flag: RuntimeFlags.RuntimeFlag): boolean; }\n```\n\n----------------------------------------\n\nTITLE: Typing STM.orElseFail Function in TypeScript\nDESCRIPTION: Defines a type signature for an STM transformation that replaces potential errors with a specified error. Supports both curried and direct function application styles.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/STM-orElseFail.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const orElseFail: { <E2>(error: LazyArg<E2>): <A, E, R>(self: STM<A, E, R>) => STM<A, E2, R>; <A, E, R, E2>(self: STM<A, E, R>, error: LazyArg<E2>): STM<A, E2, R>; }\n```\n\n----------------------------------------\n\nTITLE: Defining withSpan Function for Channel Tracing in TypeScript\nDESCRIPTION: Declares the withSpan function which wraps a channel with a new span for tracing. It can be called with either the name and options first, followed by the channel, or with the channel first, followed by the name and options.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Channel-withSpan.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const withSpan: { (name: string, options?: Tracer.SpanOptions | undefined): <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>) => Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Exclude<Env, Tracer.ParentSpan>>; <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>, name: string, options?: Tracer.SpanOptions | undefined): Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Exclude<Env, Tracer.ParentSpan>>; }\n```\n\n----------------------------------------\n\nTITLE: Stream decodeText Signature (Typescript)\nDESCRIPTION: Defines the signature of the `decodeText` function in the Effect Stream module. It shows that the function accepts an optional encoding string and a stream of Uint8Array, returning a stream of strings.  It allows for specifying the encoding to use when decoding the Uint8Array chunks into text.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-decodeText.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const decodeText: { (encoding?: string | undefined): <E, R>(self: Stream<Uint8Array, E, R>) => Stream<string, E, R>; <E, R>(self: Stream<Uint8Array, E, R>, encoding?: string | undefined): Stream<string, E, R>; }\n```\n\n----------------------------------------\n\nTITLE: Constructing Take in TypeScript\nDESCRIPTION: The function 'make' constructs a 'Take' by taking an 'exit' of type 'Exit<Chunk<A>, Option<E>>' as a parameter. This method is essential for managing complex chaining and handling of asynchronous effects, which return data chunks or optional errors. Ensure that you have the 'effect' module from Effect-TS for usage.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Take-make.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const make: <A, E>(exit: Exit.Exit<Chunk.Chunk<A>, Option.Option<E>>) => Take<A, E>\n```\n\n----------------------------------------\n\nTITLE: Using zipWithPrevious with Effect Stream\nDESCRIPTION: Example showing how to use zipWithPrevious to create a stream where each element is paired with its previous value. The first element is paired with None since it has no previous value.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-zipWithPrevious.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Chunk, Effect, Stream } from \"effect\"\n\nconst stream = Stream.zipWithPrevious(Stream.make(1, 2, 3, 4))\n\nEffect.runPromise(Stream.runCollect(stream)).then((chunk) => console.log(Chunk.toArray(chunk)))\n// [\n//   [ { _id: 'Option', _tag: 'None' }, 1 ],\n//   [ { _id: 'Option', _tag: 'Some', value: 1 }, 2 ],\n//   [ { _id: 'Option', _tag: 'Some', value: 2 }, 3 ],\n//   [ { _id: 'Option', _tag: 'Some', value: 3 }, 4 ]\n// ]\n```\n\n----------------------------------------\n\nTITLE: Checking Success State in Effect.io Exit Type\nDESCRIPTION: Type predicate function that determines if an Exit instance represents a successful completion. Takes an Exit<A, E> parameter and returns a boolean indicating whether it is specifically a Success<A, E> type.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Exit-isSuccess.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const isSuccess: <A, E>(self: Exit<A, E>) => self is Success<A, E>\n```\n\n----------------------------------------\n\nTITLE: Declaring DateFromSelf Class in TypeScript\nDESCRIPTION: Defines the DateFromSelf class which describes a schema that accommodates potentially invalid Date instances, such as new Date(\"Invalid Date\"), without rejection.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Schema-DateFromSelf.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare class DateFromSelf\n```\n\n----------------------------------------\n\nTITLE: Implementing Stream.zipWithChunks Function Signature in TypeScript\nDESCRIPTION: Type declaration for zipWithChunks function that combines two streams by applying a custom function to paired chunks of elements. The function handles both curried and uncurried forms, allowing for flexible stream combination with custom chunk handling logic.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-zipWithChunks.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const zipWithChunks: { <A2, E2, R2, A, A3>(that: Stream<A2, E2, R2>, f: (left: Chunk.Chunk<A>, right: Chunk.Chunk<A2>) => readonly [Chunk.Chunk<A3>, Either.Either<Chunk.Chunk<A2>, Chunk.Chunk<A>>]): <E, R>(self: Stream<A, E, R>) => Stream<A3, E2 | E, R2 | R>; <A, E, R, A2, E2, R2, A3>(self: Stream<A, E, R>, that: Stream<A2, E2, R2>, f: (left: Chunk.Chunk<A>, right: Chunk.Chunk<A2>) => readonly [Chunk.Chunk<A3>, Either.Either<Chunk.Chunk<A2>, Chunk.Chunk<A>>]): Stream<A3, E | E2, R | R2>; }\n```\n\n----------------------------------------\n\nTITLE: Defining Number Type Predicate in TypeScript\nDESCRIPTION: Declares a type predicate refinement that checks if an unknown value is a number. This is a type-safe way to narrow unknown values to numbers in TypeScript's type system.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Match-number.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const number: Predicate.Refinement<unknown, number>\n```\n\n----------------------------------------\n\nTITLE: Retrieving FiberRef Values with FiberRefs.getOrDefault in TypeScript\nDESCRIPTION: Gets the value of a specified FiberRef from a collection of FiberRef values. If the specified FiberRef doesn't exist in the collection, it returns the initial value of the FiberRef. The function supports both pipeable and data-first calling styles.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/FiberRefs-getOrDefault.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const getOrDefault: { <A>(fiberRef: FiberRef.FiberRef<A>): (self: FiberRefs) => A; <A>(self: FiberRefs, fiberRef: FiberRef.FiberRef<A>): A; }\n```\n\n----------------------------------------\n\nTITLE: Doc.nest Function Signature in TypeScript\nDESCRIPTION: Type declaration for the Doc.nest function showing its polymorphic implementation. The function can be called with either curried or uncurried parameter order.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Doc-nest.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const nest: { (indent: number): <A>(self: Doc<A>) => Doc<A>; <A>(self: Doc<A>, indent: number): Doc<A>; }\n```\n\n----------------------------------------\n\nTITLE: Filtering Option Values from HashMap in TypeScript\nDESCRIPTION: A utility function that takes a HashMap containing Option values and returns a new HashMap with only the Some values, filtering out all None values. The function preserves the key type K while transforming Option<A> values to A.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/HashMap-compact.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const compact: <K, A>(self: HashMap<K, Option<A>>) => HashMap<K, A>\n```\n\n----------------------------------------\n\nTITLE: Defining TextStream Interface in TypeScript for @effect/printer Package\nDESCRIPTION: This code snippet defines the TextStream interface, which represents a Doc containing a string of text. It extends DocStream.Variance<A> and includes properties for the tag, text content, and the associated DocStream.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/DocStream-TextStream.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface TextStream<A> extends DocStream.Variance<A> {\n  readonly _tag: \"TextStream\"\n  readonly text: string\n  readonly stream: DocStream<A>\n}\n```\n\n----------------------------------------\n\nTITLE: Decoding Hex Strings to Uint8Array in Effect TypeScript\nDESCRIPTION: Function signature for decoding hexadecimal encoded strings into Uint8Array. Returns an Either type that contains either the successfully decoded Uint8Array or a DecodeException in case of failure.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Encoding-decodeHex.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const decodeHex: (str: string) => Either.Either<Uint8Array, DecodeException>\n```\n\n----------------------------------------\n\nTITLE: Declaring Doc.vbar Constant in TypeScript\nDESCRIPTION: Defines a constant named 'vbar' of type Doc<never> representing a document with a single '|' character. This constant is part of the @effect/printer package's Doc module.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Doc-vbar.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const vbar: Doc<never>\n```\n\n----------------------------------------\n\nTITLE: SemigroupMin Example in Typescript\nDESCRIPTION: This code snippet demonstrates how to use the `SemigroupMin` constant from the `@effect/typeclass/data/Number` module. It imports the `SemigroupMin` and then combines the numbers 2 and 3, logging the result to the console. The expected output is 2 because `SemigroupMin` returns the minimum of the two input numbers.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/data-Number-SemigroupMin.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { SemigroupMin } from \"@effect/typeclass/data/Number\"\n\nconsole.log(SemigroupMin.combine(2, 3))\n// 2\n```\n\n----------------------------------------\n\nTITLE: Validating Primitive Types in TypeScript\nDESCRIPTION: The `validate` function ensures the specified value matches the defined primitive type within a CLI configuration. It requires `Option<string>` for the value and `CliConfig` for configuration settings. The function returns an `Effect` that encapsulates the validation result or an error string, interfacing with the file system. It is suitable for CLI application setups where type validation is necessary.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Primitive-validate.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const validate: { (value: Option<string>, config: CliConfig): <A>(self: Primitive<A>) => Effect<A, string, FileSystem>; <A>(self: Primitive<A>, value: Option<string>, config: CliConfig): Effect<A, string, FileSystem>; }\n```\n\n----------------------------------------\n\nTITLE: Computing Union of Intervals in TypeScript\nDESCRIPTION: Defines a function 'union' that computes the union of two Intervals. It can be called with either curried or uncurried syntax. The function is part of the ScheduleIntervals module in the effect package.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/ScheduleIntervals-union.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const union: { (that: Intervals): (self: Intervals) => Intervals; (self: Intervals, that: Intervals): Intervals; }\n```\n\n----------------------------------------\n\nTITLE: Configuring Shell Execution in Effect Platform Commands\nDESCRIPTION: Function signature for runInShell that enables configuring whether a Command should be executed within a shell and optionally specifying the shell to use. It supports both curried and non-curried calling styles.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Command-runInShell.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const runInShell: { (shell: string | boolean): (self: Command) => Command; (self: Command, shell: string | boolean): Command; }\n```\n\n----------------------------------------\n\nTITLE: Creating a Deferred instance with unsafeMake in Effect\nDESCRIPTION: Unsafely creates a new Deferred object from the specified FiberId. This function is part of the Deferred module in the effect package and allows for the creation of a Deferred that can be completed with either a value or an error.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Deferred-unsafeMake.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const unsafeMake: <A, E = never>(fiberId: FiberId.FiberId) => Deferred<A, E>\n```\n\n----------------------------------------\n\nTITLE: TypeScript signature for Array.containsWith function\nDESCRIPTION: The type declaration of the containsWith function, which takes an equivalence function and returns a curried function for checking if an array contains a specific value.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Array-containsWith.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const containsWith: <A>(isEquivalent: (self: A, that: A) => boolean) => { (a: A): (self: Iterable<A>) => boolean; (self: Iterable<A>, a: A): boolean; }\n```\n\n----------------------------------------\n\nTITLE: Calculating Interval Size with Effect in TypeScript\nDESCRIPTION: This code snippet defines the `size` function, which calculates the duration of an `Interval` as the `Duration` from the start to the end of the interval. It takes an `Interval` as input and returns a `Duration`.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/ScheduleInterval-size.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const size: (self: Interval) => Duration.Duration\n```\n\n----------------------------------------\n\nTITLE: Defining eraseScreen ANSI Terminal Control in TypeScript\nDESCRIPTION: Declares a constant eraseScreen of type AnsiDoc that clears the entire screen and moves the cursor to the upper left corner. This is part of the @effect/printer-ansi package's ANSI terminal control functionality.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/AnsiDoc-eraseScreen.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const eraseScreen: AnsiDoc\n```\n\n----------------------------------------\n\nTITLE: Moving Cursor Up in Terminal with AnsiDoc in TypeScript\nDESCRIPTION: This function moves the cursor up by a specified number of lines (defaulting to 1) relative to the current cursor position. It has no effect if the cursor is already at the edge of the screen.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/AnsiDoc-cursorUp.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const cursorUp: (lines?: number) => AnsiDoc\n```\n\n----------------------------------------\n\nTITLE: Using Doc.punctuate with horizontal and vertical separators in TypeScript\nDESCRIPTION: This example demonstrates how to use the `punctuate` function to add commas between words in a sentence, displaying the result both horizontally and vertically. It shows how the punctuation is placed after each item except the last.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Doc-punctuate.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport * as Doc from \"@effect/printer/Doc\"\nimport { pipe } from \"effect/Function\"\nimport * as String from \"effect/String\"\n\nconst docs = pipe(\n  Doc.words(\"lorem ipsum dolor sit amet\"),\n  Doc.punctuate(Doc.comma)\n)\n\nassert.strictEqual(\n  Doc.render(Doc.hsep(docs), { style: \"pretty\" }),\n  \"lorem, ipsum, dolor, sit, amet\"\n)\n\n// The separators are put at the end of the entries, which can be better\n// visualzied if the documents are rendered vertically\nassert.strictEqual(\n  Doc.render(Doc.vsep(docs), { style: \"pretty\" }),\n  String.stripMargin(\n    `|lorem,\n     |ipsum,\n     |dolor,\n     |sit,\n     |amet`\n  )\n)\n```\n\n----------------------------------------\n\nTITLE: Stream.dropUntil Signature in Effect (TypeScript)\nDESCRIPTION: This snippet shows the TypeScript signature for the `Stream.dropUntil` function in the Effect library.  It defines two overloaded function types, one accepting a predicate and returning a function that transforms a stream, and the other directly accepting a stream and a predicate. The function returns a new stream with elements dropped until the predicate is true.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-dropUntil.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const dropUntil: { <A>(predicate: Predicate<NoInfer<A>>): <E, R>(self: Stream<A, E, R>) => Stream<A, E, R>; <A, E, R>(self: Stream<A, E, R>, predicate: Predicate<A>): Stream<A, E, R>; }\n```\n\n----------------------------------------\n\nTITLE: Creating a Sink from a Scoped Effect using unwrapScoped in TypeScript\nDESCRIPTION: The `unwrapScoped` function creates a sink produced from a scoped effect. It takes an Effect that produces a Sink and returns a new Sink with the Scope type excluded from the resource type parameter.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Sink-unwrapScoped.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const unwrapScoped: <A, In, L, E, R>(effect: Effect.Effect<Sink<A, In, L, E, R>, E, R>) => Sink<A, In, L, E, Exclude<R, Scope.Scope>>\n```\n\n----------------------------------------\n\nTITLE: GenericTag Function Type Definition\nDESCRIPTION: TypeScript type signature for the GenericTag function showing its generic parameters and return type. Takes a string key parameter and returns a Tag with optional Service type.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Context-GenericTag.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const GenericTag: <Identifier, Service = Identifier>(key: string) => Tag<Identifier, Service>\n```\n\n----------------------------------------\n\nTITLE: Converting Channel to PubSub in TypeScript\nDESCRIPTION: The `toPubSub` function converts a `Channel` to a `PubSub`. It takes a PubSub of Either<Elem, Exit<Done, Err>> and returns a Channel with specific type parameters. This transformation enables publishing Channel events to a PubSub system.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Channel-toPubSub.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const toPubSub: <Done, Err, Elem>(pubsub: PubSub.PubSub<Either.Either<Elem, Exit.Exit<Done, Err>>>) => Channel<never, Elem, never, Err, unknown, Done>\n```\n\n----------------------------------------\n\nTITLE: Declaring Effect.fnUntraced Function in TypeScript\nDESCRIPTION: This code snippet declares the Effect.fnUntraced constant, which is of type fn.Untraced. It creates a function that is not traced, intended for use in performance-critical situations. It is similar to the `fn` function but without tracing overhead.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-fnUntraced.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const fnUntraced: fn.Untraced\n```\n\n----------------------------------------\n\nTITLE: Creating a Take with a Chunk in Effect-TS\nDESCRIPTION: This code snippet shows the declaration of the `Take.chunk` function in TypeScript. It takes a Chunk of type `A` as input and returns a `Take` of type `A`. This function is used to encapsulate a chunk of data for asynchronous processing or streaming within the Effect-TS ecosystem.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Take-chunk.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const chunk: <A>(chunk: Chunk.Chunk<A>) => Take<A>\n```\n\n----------------------------------------\n\nTITLE: Retrieving Capacity from TPubSub in TypeScript\nDESCRIPTION: Function that returns the number of elements a TPubSub instance can hold. This function takes a TPubSub instance as input and returns a number representing its capacity.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TPubSub-capacity.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const capacity: <A>(self: TPubSub<A>) => number\n```\n\n----------------------------------------\n\nTITLE: Defining Micro.map Function Signature in TypeScript\nDESCRIPTION: Type definition for the Micro.map function that transforms success values of Micro effects. The function provides two overloads: one for curried usage and another for direct application, allowing flexible transformation of values within the Micro effect context.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Micro-map.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const map: { <A, B>(f: (a: A) => B): <E, R>(self: Micro<A, E, R>) => Micro<B, E, R>; <A, E, R, B>(self: Micro<A, E, R>, f: (a: A) => B): Micro<B, E, R>; }\n```\n\n----------------------------------------\n\nTITLE: Doc.column Function Signature in TypeScript\nDESCRIPTION: This code snippet shows the type signature of the Doc.column function in TypeScript. It takes a function that receives the current column position and returns a Doc<A>.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Doc-column.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const column: <A>(react: (position: number) => Doc<A>) => Doc<A>\n```\n\n----------------------------------------\n\nTITLE: Defining HttpServer.layerContext Layer in TypeScript\nDESCRIPTION: Declares a constant `layerContext` that provides a Layer for HttpPlatform, FileSystem, Etag.Generator, and Path services. The FileSystem service is a no-op implementation, making this layer suitable for platforms without a file system.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/HttpServer-layerContext.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const layerContext: Layer.Layer<FileSystem | Path | HttpPlatform | Generator, never, never>\n```\n\n----------------------------------------\n\nTITLE: Trie.longestPrefixOf Function Signature in TypeScript\nDESCRIPTION: This code block defines the TypeScript signature for the Trie.longestPrefixOf function. It shows that the function can be used in two ways: either by passing the key first, or by passing the Trie first.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Trie-longestPrefixOf.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const longestPrefixOf: { (key: string): <V>(self: Trie<V>) => Option<[string, V]>; <V>(self: Trie<V>, key: string): Option<[string, V]>; }\n```\n\n----------------------------------------\n\nTITLE: Defining annotationsWith Function in TestServices Module\nDESCRIPTION: This function retrieves the Annotations service for a test and uses it to run a specified workflow. It takes a function that accepts TestAnnotations as an argument and returns an Effect.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TestServices-annotationsWith.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const annotationsWith: <A, E, R>(f: (annotations: Annotations.TestAnnotations) => Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>\n```\n\n----------------------------------------\n\nTITLE: Counting Elements with TArray in TypeScript\nDESCRIPTION: The `countSTM` function provides a mechanism to count elements in a `TArray` that satisfy a transactional predicate within the Effect-TS framework. The function can be invoked either by supplying the predicate and the array together, or by using currying. It requires an `STM` (Software Transactional Memory) predicate, and the return value is an `STM` that yields the count. It depends on the `effect` package for transactional memory operations.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TArray-countSTM.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const countSTM: { <A, R, E>(predicate: (value: A) => STM.STM<boolean, E, R>): (self: TArray<A>) => STM.STM<number, E, R>; <A, R, E>(self: TArray<A>, predicate: (value: A) => STM.STM<boolean, E, R>): STM.STM<number, E, R>; }\n```\n\n----------------------------------------\n\nTITLE: Signature for Struct.keys Function in TypeScript\nDESCRIPTION: This code snippet provides the TypeScript type signature for the Struct.keys function. It defines the function as taking an object and returning an array of keys that are strings. This signature ensures type safety by restricting the return type to only include keys that extend the string type.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Struct-keys.md#2025-04-11_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const keys: <T extends {}>(o: T) => Array<(keyof T) & string>\n```\n\n----------------------------------------\n\nTITLE: Defining OptionalResult Type for Request Module\nDESCRIPTION: A TypeScript type utility that extracts the optional result type from a Request. It uses conditional types to determine if the input extends Request<A, E> and returns an Exit type containing an Option of the result type A and error type E.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Request-Request.OptionalResult.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ntype OptionalResult<T> = T extends Request<infer A, infer E>\n    ? Exit.Exit<Option.Option<A>, E>\n    : never\n```\n\n----------------------------------------\n\nTITLE: Declare Uppercase Class - Typescript\nDESCRIPTION: This snippet declares the `Uppercase` class in Typescript. The class, part of the Effect TS library, is designed to convert strings to uppercase when used within a schema.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Schema-Uppercase.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare class Uppercase\n```\n\n----------------------------------------\n\nTITLE: Declaring RedBlackTree ForEachGreaterThanEqual Function Type in TypeScript\nDESCRIPTION: TypeScript type declaration for a function that iterates through RedBlackTree nodes with keys greater than or equal to a minimum value. The function can be called with either curried or uncurried parameter order.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/RedBlackTree-forEachGreaterThanEqual.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const forEachGreaterThanEqual: { <K, V>(min: K, f: (key: K, value: V) => void): (self: RedBlackTree<K, V>) => void; <K, V>(self: RedBlackTree<K, V>, min: K, f: (key: K, value: V) => void): void; }\n```\n\n----------------------------------------\n\nTITLE: Creating KeyValueStore Layer from Storage API - TypeScript\nDESCRIPTION: Function signature for creating a KeyValueStore Layer implementation using browser's Storage API (like localStorage or sessionStorage). Takes a lazy evaluation function that returns a Storage instance and produces a Layer containing KeyValueStore functionality.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/KeyValueStore-layerStorage.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const layerStorage: (evaluate: LazyArg<Storage>) => Layer.Layer<KeyValueStore>\n```\n\n----------------------------------------\n\nTITLE: Extracting Branded Types from Brand.Constructor in TypeScript\nDESCRIPTION: A utility type that extracts the branded type B from a Brand.Constructor<B>. This type helper uses conditional types to determine if the input type A extends Brand.Constructor with some branded type, then extracts that branded type.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Brand-Brand.FromConstructor.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ntype FromConstructor<A> = A extends Brand.Constructor<infer B> ? B : never\n```\n\n----------------------------------------\n\nTITLE: Defining TimeoutException Interface in TypeScript\nDESCRIPTION: Defines the TimeoutException interface that extends YieldableError. It includes a _tag property set to \"TimeoutException\" and a symbol property for the TimeoutExceptionTypeId.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Cause-TimeoutException.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface TimeoutException extends YieldableError {\n  readonly _tag: \"TimeoutException\"\n  readonly [TimeoutExceptionTypeId]: TimeoutExceptionTypeId\n}\n```\n\n----------------------------------------\n\nTITLE: Effect.checkInterruptible Type Definition\nDESCRIPTION: TypeScript type declaration for the checkInterruptible function, showing its signature for handling effect operations with interruption checking.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-checkInterruptible.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const checkInterruptible: <A, E, R>(f: (isInterruptible: boolean) => Effect<A, E, R>) => Effect<A, E, R>\n```\n\n----------------------------------------\n\nTITLE: Using Iterable.replicate in TypeScript\nDESCRIPTION: Example demonstrating how to use the replicate function to create an iterable that repeats a value multiple times. The example shows creating an array from an iterable that contains the string 'a' repeated 3 times.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Iterable-replicate.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { replicate } from \"effect/Iterable\"\n\nassert.deepStrictEqual(Array.from(replicate(\"a\", 3)), [\"a\", \"a\", \"a\"])\n```\n\n----------------------------------------\n\nTITLE: Returning Head of List in STM Module - TypeScript\nDESCRIPTION: The head function is designed to return the first element of a provided iterable list encapsulated in an STM context. If the list is empty, it produces an error represented by None. This function requires the Effect library and particularly operates on STM for managing stateful computations.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/STM-head.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const head: <A, E, R>(self: STM<Iterable<A>, E, R>) => STM<A, Option.Option<E>, R>\n```\n\n----------------------------------------\n\nTITLE: Declaring headOption Function in TypeScript\nDESCRIPTION: This snippet declares the 'headOption' function, which takes a TArray and returns an STM option of its first element. It is useful for safely accessing the first element of an array without risking a runtime error from an empty array.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TArray-headOption.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const headOption: <A>(self: TArray<A>) => STM.STM<Option.Option<A>>\n```\n\n----------------------------------------\n\nTITLE: Multiplying Numbers with effect/Number\nDESCRIPTION: This code snippet demonstrates how to use the `multiply` function from the `effect/Number` module to multiply two numbers. It imports the `multiply` function and uses `assert.deepStrictEqual` to verify the result of the multiplication. This requires the `effect` and `node:assert` packages.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Number-multiply.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { multiply } from \"effect/Number\"\n\nassert.deepStrictEqual(multiply(2, 3), 6)\n```\n\n----------------------------------------\n\nTITLE: Defining TestServices.provideWithLive Function in TypeScript\nDESCRIPTION: Defines a function that runs a transformation with live default Effect services while ensuring the workflow uses test services. It supports both curried and uncurried usage patterns.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TestServices-provideWithLive.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const provideWithLive: (<A, E, R, A2, E2, R2>(f: (effect: Effect.Effect<A, E, R>) => Effect.Effect<A2, E2, R2>) => (self: Effect.Effect<A, E, R>) => Effect.Effect<A2, E | E2, R | R2>) & (<A, E, R, A2, E2, R2>(self: Effect.Effect<A, E, R>, f: (effect: Effect.Effect<A, E, R>) => Effect.Effect<A2, E2, R2>) => Effect.Effect<A2, E | E2, R | R2>)\n```\n\n----------------------------------------\n\nTITLE: Setting DateTime Parts in TypeScript\nDESCRIPTION: The setParts function allows setting different parts of a DateTime object using a partial object of DateTime parts. It can be used in both curried and uncurried forms. The function adjusts the date for the time zone.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/DateTime-setParts.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const setParts: { (parts: Partial<DateTime.PartsWithWeekday>): <A extends DateTime>(self: A) => A; <A extends DateTime>(self: A, parts: Partial<DateTime.PartsWithWeekday>): A; }\n```\n\n----------------------------------------\n\nTITLE: Using String.takeLeft in Effect-TS\nDESCRIPTION: Demonstrates how to use the takeLeft function to extract a specified number of characters from the beginning of a string. The function takes a number parameter and returns the first n characters, handling edge cases like large numbers and floats.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/String-takeLeft.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { String } from \"effect\"\n\nassert.deepStrictEqual(String.takeLeft(\"Hello World\", 5), \"Hello\")\n```\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const takeLeft: { (n: number): (self: string) => string; (self: string, n: number): string; }\n```\n\n----------------------------------------\n\nTITLE: Converting ConfigProvider Property Names to Constant Case in TypeScript\nDESCRIPTION: A utility function that takes a ConfigProvider and returns a new provider that automatically converts all property names to constant case (UPPER_SNAKE_CASE). This enables adapting configuration property names from camel case to other naming conventions required by specific configuration systems.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/ConfigProvider-constantCase.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const constantCase: (self: ConfigProvider) => ConfigProvider\n```\n\n----------------------------------------\n\nTITLE: Using Boolean.not Function in TypeScript\nDESCRIPTION: Demonstrates how to use the not function from the effect/Boolean module to negate boolean values. The function takes a boolean value and returns its negation.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Boolean-not.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { not } from \"effect/Boolean\"\n\nassert.deepStrictEqual(not(true), false)\nassert.deepStrictEqual(not(false), true)\n```\n\n----------------------------------------\n\nTITLE: Providing Live Default Effect Services in TypeScript\nDESCRIPTION: The provideLive function is used to provide a workflow with the \"live\" default Effect services. It takes an Effect as input and returns an Effect with the same type parameters.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TestServices-provideLive.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const provideLive: <A, E, R>(effect: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>\n```\n\n----------------------------------------\n\nTITLE: Declaring Uint8ArrayFromBase64 Schema in Typescript\nDESCRIPTION: This code snippet declares the `Uint8ArrayFromBase64` schema constant, which is a `Schema` that transforms a base64 encoded string into a `Uint8Array`. It has no dependencies other than the `Schema` type from the Effect library. It is introduced in v3.10.0\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Schema-Uint8ArrayFromBase64.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const Uint8ArrayFromBase64: Schema<Uint8Array<ArrayBufferLike>, string, never>\n```\n\n----------------------------------------\n\nTITLE: Determining BigInt Sign in TypeScript\nDESCRIPTION: The sign function returns the sign of a given bigint value. It returns -1 for negative values, 0 for zero, and 1 for positive values, representing the Ordering result.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/BigInt-sign.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { sign } from \"effect/BigInt\"\n\nassert.deepStrictEqual(sign(-5n), -1)\nassert.deepStrictEqual(sign(0n), 0)\nassert.deepStrictEqual(sign(5n), 1)\n```\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const sign: (n: bigint) => Ordering\n```\n\n----------------------------------------\n\nTITLE: Tuple.at Method Signature - TypeScript\nDESCRIPTION: The provided signature defines the Tuple.at method from the Effect library, which allows accessing an element at a specified index from a tuple. It requires that the tuple and the index are properly specified for the retrieval operation.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Tuple-at.md#2025-04-11_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const at: { <N extends number>(index: N): <A extends ReadonlyArray<unknown>>(self: A) => A[N]; <A extends ReadonlyArray<unknown>, N extends number>(self: A, index: N): A[N]; }\n```\n\n----------------------------------------\n\nTITLE: Declaring allowInterrupt Function in TypeScript\nDESCRIPTION: This code snippet declares the `allowInterrupt` function in the Effect module. It is a constant that returns an Effect with void return type and no requirements or errors.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-allowInterrupt.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const allowInterrupt: Effect<void, never, never>\n```\n\n----------------------------------------\n\nTITLE: Defining RedBlackTree.forEachLessThan Function in TypeScript\nDESCRIPTION: Function declaration for traversing Red-Black Tree nodes with keys less than a maximum value. Provides two overloads: a curried version and a direct version. The function takes a maximum key value and a callback function to execute on each qualifying node.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/RedBlackTree-forEachLessThan.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const forEachLessThan: {\n  <K, V>(max: K, f: (key: K, value: V) => void): (self: RedBlackTree<K, V>) => void;\n  <K, V>(self: RedBlackTree<K, V>, max: K, f: (key: K, value: V) => void): void;\n}\n```\n\n----------------------------------------\n\nTITLE: Function Signature for Record.getRights\nDESCRIPTION: The snippet provides a TypeScript declaration for the getRights function, specifying the input type as a ReadonlyRecord with Either values, and the output type as a Record containing only the Right values.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Record-getRights.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const getRights: <K extends string, R, L>(self: ReadonlyRecord<K, Either<R, L>>) => Record<string, R>\n```\n\n----------------------------------------\n\nTITLE: Using constNull Function from Effect-TS in TypeScript\nDESCRIPTION: The constNull function is a thunk that always returns null. It can be imported from the effect/Function module and called without any arguments.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Function-constNull.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { constNull } from \"effect/Function\"\n\nassert.deepStrictEqual(constNull(), null)\n```\n\n----------------------------------------\n\nTITLE: Formatting DateTime to ISO Date String in TypeScript\nDESCRIPTION: Function declaration for formatIsoDate that takes a DateTime object and returns a timezone-adjusted ISO date string format. Part of the Effect.ts library's DateTime module functionality.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/DateTime-formatIsoDate.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const formatIsoDate: (self: DateTime) => string\n```\n\n----------------------------------------\n\nTITLE: Retrieving Last Entry from RedBlackTree in TypeScript\nDESCRIPTION: A function that returns the last entry (key-value pair) in a Red-Black Tree as an Option type. If the tree is empty, it returns None.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/RedBlackTree-last.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const last: <K, V>(self: RedBlackTree<K, V>) => Option<[K, V]>\n```\n\n----------------------------------------\n\nTITLE: TypeScript Signature for constTrue Function\nDESCRIPTION: The type signature for the constTrue function, showing it's defined as a LazyArg that returns a boolean value.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Function-constTrue.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const constTrue: LazyArg<boolean>\n```\n\n----------------------------------------\n\nTITLE: Extracting Option Values with getOrUndefined TypeScript Function\nDESCRIPTION: A method to retrieve the value from an Option, returning undefined if no value is present. Useful for handling optional values in a type-safe manner.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Option-getOrUndefined.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Option } from \"effect\"\n\nconsole.log(Option.getOrUndefined(Option.some(1)))\n// Output: 1\n\nconsole.log(Option.getOrUndefined(Option.none()))\n// Output: undefined\n```\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const getOrUndefined: <A>(self: Option<A>) => A | undefined\n```\n\n----------------------------------------\n\nTITLE: TypeScript Signature for BigInt.subtract Function\nDESCRIPTION: The type signature for the subtract function, showing it can be used in both curried and non-curried forms. It takes two bigint parameters and returns a bigint result.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/BigInt-subtract.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const subtract: { (that: bigint): (self: bigint) => bigint; (self: bigint, that: bigint): bigint; }\n```\n\n----------------------------------------\n\nTITLE: Creating Failure Effects with Micro.failSync in TypeScript\nDESCRIPTION: Defines a function that creates a Micro effect representing a failure case. It takes a lazy error argument and returns a Micro effect that will fail with the evaluated error. The error type is tracked at the type level using the MicroCause type's Fail variant.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Micro-failSync.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const failSync: <E>(error: LazyArg<E>) => Micro<never, E>\n```\n\n----------------------------------------\n\nTITLE: Checking for FailedStream in DocStream - TypeScript\nDESCRIPTION: The isFailedStream function is a type guard that checks if a given DocStream is specifically a FailedStream. It returns true if the stream is a FailedStream, false otherwise. This function is useful for type narrowing in conditional statements.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/DocStream-isFailedStream.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const isFailedStream: <A>(self: DocStream<A>) => self is FailedStream<A>\n```\n\n----------------------------------------\n\nTITLE: Combining RuntimeFlagsPatch Instances with either Function in TypeScript\nDESCRIPTION: The 'either' function creates a RuntimeFlagsPatch that represents the application of either the 'self' patch or 'that' patch. It supports both curried and uncurried calling styles.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/RuntimeFlagsPatch-either.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const either: { (that: RuntimeFlagsPatch): (self: RuntimeFlagsPatch) => RuntimeFlagsPatch; (self: RuntimeFlagsPatch, that: RuntimeFlagsPatch): RuntimeFlagsPatch; }\n```\n\n----------------------------------------\n\nTITLE: BigInt Multiplication Example in TypeScript\nDESCRIPTION: Demonstrates how to use the multiply function from Effect/BigInt to perform multiplication operations on bigint values. Returns the product of two bigint numbers.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/BigInt-multiply.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { multiply } from \"effect/BigInt\"\n\nassert.deepStrictEqual(multiply(2n, 3n), 6n)\n```\n\n----------------------------------------\n\nTITLE: Declaring Layer.span Function in TypeScript\nDESCRIPTION: TypeScript declaration for Layer.span function that creates and adds a span to the current span stack. The span is automatically ended when the Layer is released. Accepts a name parameter and optional configuration including span options and an onEnd callback.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Layer-span.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const span: (name: string, options?: Tracer.SpanOptions & { readonly onEnd?: ((span: Tracer.Span, exit: Exit.Exit<unknown, unknown>) => Effect.Effect<void>) | undefined; }) => Layer<Tracer.ParentSpan>\n```\n\n----------------------------------------\n\nTITLE: Type Signature of withCurrentZoneNamed Function\nDESCRIPTION: This code block shows the TypeScript type signature for the `withCurrentZoneNamed` function. It defines two overloads: one that takes the zone as the first argument and returns a function, and another that takes both the effect and zone as arguments.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/DateTime-withCurrentZoneNamed.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const withCurrentZoneNamed: { (zone: string): <A, E, R>(effect: Effect.Effect<A, E, R>) => Effect.Effect<A, E | IllegalArgumentException, Exclude<R, CurrentTimeZone>>; <A, E, R>(effect: Effect.Effect<A, E, R>, zone: string): Effect.Effect<A, E | IllegalArgumentException, Exclude<R, CurrentTimeZone>>; }\n```\n\n----------------------------------------\n\nTITLE: Doc.width Function Signature in TypeScript\nDESCRIPTION: The signature of the Doc.width function, which is an overloaded function that takes a reaction function and returns a new document with width information.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Doc-width.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const width: { <A, B>(react: (width: number) => Doc<B>): (self: Doc<A>) => Doc<A | B>; <A, B>(self: Doc<A>, react: (width: number) => Doc<B>): Doc<A | B>; }\n```\n\n----------------------------------------\n\nTITLE: Checking for Composite FiberId in TypeScript\nDESCRIPTION: This function determines if a given FiberId is of the Composite type. It returns true if the FiberId is a Composite, and false otherwise. The function uses a type predicate to narrow the type of 'self' to Composite when it returns true.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/FiberId-isComposite.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const isComposite: (self: FiberId) => self is Composite\n```\n\n----------------------------------------\n\nTITLE: Defining UnknownExceptionTypeId Symbol in TypeScript\nDESCRIPTION: Declaration of a unique symbol that identifies the `UnknownException` type. This symbol is used for generic or unexpected errors that do not fit other specific exception categories.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Cause-UnknownExceptionTypeId.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const UnknownExceptionTypeId: unique symbol\n```\n\n----------------------------------------\n\nTITLE: Using Array.union to combine arrays in TypeScript\nDESCRIPTION: This example demonstrates how to use the Array.union function from the Effect library to create a union of two arrays while removing duplicates. The function takes two arrays and returns a new array containing all unique elements from both input arrays.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Array-union.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Array } from \"effect\"\n\nconst result = Array.union([1, 2], [2, 3])\nconsole.log(result) // [1, 2, 3]\n```\n\n----------------------------------------\n\nTITLE: Effect.sandbox Function Signature in TypeScript\nDESCRIPTION: The TypeScript signature for the Effect.sandbox function, which transforms an Effect<A, E, R> into an Effect<A, Cause.Cause<E>, R> to expose detailed error causes.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-sandbox.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const sandbox: <A, E, R>(self: Effect<A, E, R>) => Effect<A, Cause.Cause<E>, R>\n```\n\n----------------------------------------\n\nTITLE: Converting FiberId to HashSet in TypeScript\nDESCRIPTION: Function signature for converting a FiberId instance into a HashSet of FiberIds. This utility helps when needing to work with collections of fiber identifiers in the Effect runtime.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/FiberId-toSet.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const toSet: (self: FiberId) => HashSet.HashSet<Runtime>\n```\n\n----------------------------------------\n\nTITLE: Trie.toEntries Function Signature in TypeScript\nDESCRIPTION: This code snippet shows the TypeScript signature for the Trie.toEntries function. It takes a Trie<V> as input and returns an array of string-value pairs.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Trie-toEntries.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const toEntries: <V>(self: Trie<V>) => Array<[string, V]>\n```\n\n----------------------------------------\n\nTITLE: Implementing Boolean Implication in TypeScript\nDESCRIPTION: Demonstrates the use of boolean implication operation that returns true if either the first value is false or the second value is true. The function follows the logical implication truth table.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Boolean-implies.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { implies } from \"effect/Boolean\"\n\nassert.deepStrictEqual(implies(true, true), true)\nassert.deepStrictEqual(implies(true, false), false)\nassert.deepStrictEqual(implies(false, true), true)\nassert.deepStrictEqual(implies(false, false), true)\n```\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const implies: { (that: boolean): (self: boolean) => boolean; (self: boolean, that: boolean): boolean; }\n```\n\n----------------------------------------\n\nTITLE: TupleOf Example Usage\nDESCRIPTION: Demonstrates how to use the `TupleOf` type to create tuples with a fixed number of elements of a specific type. The example includes valid and invalid tuple assignments, highlighting the type's ability to enforce tuple length.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Types-TupleOf.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { TupleOf } from \"effect/Types\"\n\n// A tuple with exactly 3 numbers\nconst example1: TupleOf<3, number> = [1, 2, 3]; // valid\n// @ts-expect-error\nconst example2: TupleOf<3, number> = [1, 2]; // invalid\n// @ts-expect-error\nconst example3: TupleOf<3, number> = [1, 2, 3, 4]; // invalid\n```\n\n----------------------------------------\n\nTITLE: Declaring Monoid in TypeScript\nDESCRIPTION: This TypeScript snippet declares a boolean monoid under disjunction using the Effect-TS library. The empty value is `false`, indicating that disjunction operations with 'MonoidSome' start from false. Dependencies may include standard monoid structures provided by Effect-TS, and this snippet is intended for operations involving boolean disjunction.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/data-Boolean-MonoidSome.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const MonoidSome: monoid.Monoid<boolean>\n```\n\n----------------------------------------\n\nTITLE: Retrieving Size of a TMap in Effect-TS STM Transaction\nDESCRIPTION: The size function returns the number of key-value bindings in a TMap within an STM transaction. It accepts a TMap instance and returns an STM effect that resolves to a number representing the map's size.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TMap-size.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const size: <K, V>(self: TMap<K, V>) => STM.STM<number>\n```\n\n----------------------------------------\n\nTITLE: Defining Parallel Cause Interface in TypeScript\nDESCRIPTION: Interface definition for Parallel composition of two Causes that captures failures happening simultaneously in concurrent operations. It extends Cause.Variance, Equal.Equal, Pipeable, and Inspectable interfaces.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Cause-Parallel.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface Parallel<out E> extends Cause.Variance<E>, Equal.Equal, Pipeable, Inspectable {\n  readonly _tag: \"Parallel\"\n  readonly left: Cause<E>\n  readonly right: Cause<E>\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Non-Terminating Sink in TypeScript\nDESCRIPTION: Creates a sink that never terminates. This function returns a Sink instance with 'never' types for input, error, and output parameters, indicating it doesn't accept input, produce errors, or complete with a value.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Sink-never.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const never: Sink<never, unknown, never, never, never>\n```\n\n----------------------------------------\n\nTITLE: Creating a Test Layer for HTTP Servers in Bun Environment\nDESCRIPTION: The layerTest function creates a Layer that starts an HTTP server on a random port and provides an HttpClient configured with the server's URL. This is useful for integration testing of HTTP servers in Bun environment.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/BunHttpServer-layerTest.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const layerTest: Layer.Layer<Server.HttpServer | Platform.HttpPlatform | Etag.Generator | BunContext.BunContext | HttpClient.HttpClient, HttpServerError.ServeError, never>\n```\n\n----------------------------------------\n\nTITLE: TypeScript Declaration for Doc.spaces Function\nDESCRIPTION: This code snippet shows the TypeScript declaration for the `spaces` function in the `Doc` module. It takes a number as an argument and returns a `Doc` type with a `never` type parameter.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Doc-spaces.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const spaces: (n: number) => Doc<never>\n```\n\n----------------------------------------\n\nTITLE: Checking Boolean Flag in Effect-TS Options using TypeScript\nDESCRIPTION: The function 'isBool' in TypeScript checks whether a given 'Options' instance is a boolean flag. The dependency for this functionality is the 'Options' type from the Effect-TS CLI package. It accepts an 'Options' instance parameter and returns a boolean indicating if it is a boolean flag.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Options-isBool.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const isBool: <A>(self: Options<A>) => boolean\n```\n\n----------------------------------------\n\nTITLE: Declaring serviceOption in Effect-TS with TypeScript\nDESCRIPTION: The 'serviceOption' function retrieves an 'Option' of a service from the environment using a given 'Context.Tag'. It does not require tracking the dependency at the type level, which simplifies dependency management. The function has been available since version 3.4.0 of Effect-TS.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Micro-serviceOption.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const serviceOption: <I, S>(tag: Context.Tag<I, S>) => Micro<Option.Option<S>>\n```\n\n----------------------------------------\n\nTITLE: Path.layer implementation in TypeScript\nDESCRIPTION: This code snippet presents the declaration of the `Path.layer` constant in TypeScript. It is a `Layer` that provides the `Path` interface, with no dependencies or requirements. It's designed to be used in any environment, including browsers.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Path-layer.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const layer: Layer<Path, never, never>\n```\n\n----------------------------------------\n\nTITLE: Defining STM Transaction Ensuring Method in TypeScript\nDESCRIPTION: Provides a type declaration for the ensuring method which allows attaching a finalizer transaction to an STM transaction. The finalizer will execute whether the main transaction succeeds or fails, with automatic rollback if the transaction fails.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/STM-ensuring.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const ensuring: { <R1, B>(finalizer: STM<B, never, R1>): <A, E, R>(self: STM<A, E, R>) => STM<A, E, R1 | R>; <A, E, R, R1, B>(self: STM<A, E, R>, finalizer: STM<B, never, R1>): STM<A, E, R | R1>; }\n```\n\n----------------------------------------\n\nTITLE: Defining MetricPolling Interface in TypeScript\nDESCRIPTION: Defines a TypeScript interface that represents a combination of a metric and an effect for polling metric updates. It includes generic type parameters for the metric type, input type, environment type, error type, and output type.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/MetricPolling-MetricPolling.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface MetricPolling<in out Type, in out In, out R, out E, out Out> extends Pipeable {\n  readonly [MetricPollingTypeId]: MetricPollingTypeId\n  /**\n   * The metric that this `MetricPolling` polls to update.\n   */\n  readonly metric: Metric.Metric<Type, In, Out>\n  /**\n   * An effect that polls a value that may be fed to the metric.\n   */\n  readonly poll: Effect.Effect<In, E, R>\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Effect.contextWith Function in TypeScript\nDESCRIPTION: This snippet defines the contextWith function in the Effect module. It takes a transformation function that operates on the context and returns a new Effect. The function allows accessing and modifying the context within an effect.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-contextWith.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const contextWith: <R, A>(f: (context: Context.Context<R>) => A) => Effect<A, never, R>\n```\n\n----------------------------------------\n\nTITLE: Creating Intervals with ScheduleInterval.make in TypeScript\nDESCRIPTION: The 'make' function constructs a new interval from two specified endpoints (start and end) in milliseconds. If the start endpoint is greater than the end endpoint, a zero-size interval is returned.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/ScheduleInterval-make.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const make: (startMillis: number, endMillis: number) => Interval\n```\n\n----------------------------------------\n\nTITLE: Defining kebabCase Function for ConfigProvider in TypeScript\nDESCRIPTION: Declares a constant function kebabCase that takes a ConfigProvider and returns a new ConfigProvider with property names converted to kebab case. This function is useful for adapting configuration property names from camel case to kebab case.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/ConfigProvider-kebabCase.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const kebabCase: (self: ConfigProvider) => ConfigProvider\n```\n\n----------------------------------------\n\nTITLE: Ending Mutation on HashMap in TypeScript\nDESCRIPTION: This function marks a HashMap as immutable after mutation operations. It takes a HashMap as input and returns the same HashMap with its mutability state changed. This allows for efficient batch operations followed by immutable usage.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/HashMap-endMutation.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const endMutation: <K, V>(self: HashMap<K, V>) => HashMap<K, V>\n```\n\n----------------------------------------\n\nTITLE: Setting Scoped Test Config Implementation in TypeScript\nDESCRIPTION: This function sets the implementation of the config service to a specified value and restores it to its original value when the scope is closed. It's useful for isolating test configurations within specific scopes.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TestServices-withTestConfigScoped.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const withTestConfigScoped: (config: TestConfig.TestConfig) => Effect.Effect<void, never, Scope.Scope>\n```\n\n----------------------------------------\n\nTITLE: Implementing Channel Concatenation in TypeScript\nDESCRIPTION: Defines a type signature for the concatOut function that concatenates channels written out by another channel. This operation is specifically for channels that output other channels, combining their outputs into a single channel.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Channel-concatOut.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const concatOut: <OutElem, InElem, OutErr, InErr, InDone, Env, OutDone>(self: Channel<Channel<OutElem, InElem, OutErr, InErr, unknown, InDone, Env>, InElem, OutErr, InErr, OutDone, InDone, Env>) => Channel<OutElem, InElem, OutErr, InErr, unknown, InDone, Env>\n```\n\n----------------------------------------\n\nTITLE: Constructing MemoMap for Layer Building in TypeScript\nDESCRIPTION: The makeMemoMap function constructs a MemoMap that can be used to build additional layers. It returns an Effect that produces a MemoMap with no error channel.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Layer-makeMemoMap.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const makeMemoMap: Effect.Effect<MemoMap, never, never>\n```\n\n----------------------------------------\n\nTITLE: FiberHandle.runtime Function Signature in TypeScript\nDESCRIPTION: This code snippet shows the type signature of the FiberHandle.runtime function. It describes the function's parameters, return type, and generic type constraints.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/FiberHandle-runtime.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const runtime: <A, E>(self: FiberHandle<A, E>) => <R = never>() => Effect.Effect<(<XE extends E, XA extends A>(effect: Effect.Effect<XA, XE, R>, options?: (Runtime.RunForkOptions & { readonly onlyIfMissing?: boolean | undefined; readonly propagateInterruption?: boolean | undefined; }) | undefined) => Fiber.RuntimeFiber<XA, XE>), never, R>\n```\n\n----------------------------------------\n\nTITLE: Using uninterruptibleMask to Control Effect Interruptibility in TypeScript\nDESCRIPTION: This example demonstrates how to use the uninterruptibleMask function to create an uninterruptible region for a Micro effect, while allowing specific portions to be interruptible using the restore function.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Micro-uninterruptibleMask.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as Micro from \"effect/Micro\"\n\nMicro.uninterruptibleMask((restore) =>\n  Micro.sleep(1000).pipe( // uninterruptible\n    Micro.andThen(restore(Micro.sleep(1000))) // interruptible\n  )\n)\n```\n\n----------------------------------------\n\nTITLE: Type Signature for Array.zip Function\nDESCRIPTION: Type declaration for the Array.zip function showing its polymorphic nature. It supports both regular iterables and non-empty arrays with appropriate type narrowing.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Array-zip.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const zip: { <B>(that: NonEmptyReadonlyArray<B>): <A>(self: NonEmptyReadonlyArray<A>) => NonEmptyArray<[A, B]>; <B>(that: Iterable<B>): <A>(self: Iterable<A>) => Array<[A, B]>; <A, B>(self: NonEmptyReadonlyArray<A>, that: NonEmptyReadonlyArray<B>): NonEmptyArray<[A, B]>; <A, B>(self: Iterable<A>, that: Iterable<B>): Array<[A, B]>; }\n```\n\n----------------------------------------\n\nTITLE: Retrieving Start of Earliest Interval in TypeScript\nDESCRIPTION: This function, 'start', takes an Intervals object and returns the start time of the earliest interval as a number. It is part of the ScheduleIntervals module in the Effect package.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/ScheduleIntervals-start.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const start: (self: Intervals) => number\n```\n\n----------------------------------------\n\nTITLE: Defining HttpClient.filterStatus Function in TypeScript\nDESCRIPTION: Declares a function that filters HTTP responses based on their status codes. It can be used in two ways: as a higher-order function that takes a predicate and returns a function to modify an HttpClient, or as a method directly on an HttpClient instance.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/HttpClient-filterStatus.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const filterStatus: {\n  (f: (status: number) => boolean): <E, R>(self: HttpClient.With<E, R>) => HttpClient.With<E | Error.ResponseError, R>;\n  <E, R>(self: HttpClient.With<E, R>, f: (status: number) => boolean): HttpClient.With<E | Error.ResponseError, R>;\n}\n```\n\n----------------------------------------\n\nTITLE: Creating an Empty FiberRefs Collection in TypeScript\nDESCRIPTION: The empty function creates a new empty collection of FiberRef values. It takes no parameters and returns a new FiberRefs instance.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/FiberRefs-empty.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const empty: () => FiberRefs\n```\n\n----------------------------------------\n\nTITLE: Declaring the decrement function in Effect\nDESCRIPTION: This snippet shows the type declaration of the `decrement` function within the `effect/Number` module. It indicates that `decrement` is a function that accepts a number as input and returns a number as output. This declaration provides type safety and documentation for developers using the function.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Number-decrement.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const decrement: (n: number) => number\n```\n\n----------------------------------------\n\nTITLE: Declaring End Marker in Take Module\nDESCRIPTION: This snippet declares a constant called 'end' that signifies the end-of-stream marker. It is essential for working with streams in the Effect library. The type 'Take<never, never>' denotes that it represents a stream that has completed, thus, it cannot yield any more values.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Take-end.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const end: Take<never, never>\n```\n\n----------------------------------------\n\nTITLE: Using Either.filterOrLeft to Conditionally Convert Right to Left Values in TypeScript\nDESCRIPTION: This example demonstrates how to use Either.filterOrLeft to test if a right value satisfies a predicate. If the predicate passes, the original Either.right is returned; if it fails, an Either.left is returned with a value computed from the original right value.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Either-filterOrLeft.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { pipe, Either } from \"effect\"\n\nconst isPositive = (n: number): boolean => n > 0\n\nassert.deepStrictEqual(\n  pipe(\n    Either.right(1),\n    Either.filterOrLeft(isPositive, n => `${n} is not positive`)\n  ),\n  Either.right(1)\n)\nassert.deepStrictEqual(\n  pipe(\n    Either.right(0),\n    Either.filterOrLeft(isPositive, n => `${n} is not positive`)\n  ),\n  Either.left(\"0 is not positive\")\n)\n```\n\n----------------------------------------\n\nTITLE: Defining PathSegment Type for URL Path Segments in TypeScript\nDESCRIPTION: Defines the PathSegment type as a template literal type representing a segment of a URL path. It ensures that each path segment starts with a forward slash followed by a string.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/HttpApiEndpoint-PathSegment.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ntype PathSegment = `/${string}`\n```\n\n----------------------------------------\n\nTITLE: Deduplicating Adjacent Elements in TypeScript Iterable\nDESCRIPTION: The dedupeAdjacent function takes an Iterable<A> as input and returns a new Iterable<A> with adjacent duplicate elements removed. It preserves the order of elements while eliminating consecutive duplicates.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Iterable-dedupeAdjacent.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const dedupeAdjacent: <A>(self: Iterable<A>) => Iterable<A>\n```\n\n----------------------------------------\n\nTITLE: Declaring Stream Forever Function in TypeScript\nDESCRIPTION: The forever function is declared to repeat a given stream indefinitely. It is part of the Effect-TS library, specifically the Stream module. The function accepts a Stream of generic type parameters A, E, and R as input and returns the same stream type, allowing for infinite repetition. No specific dependencies are mentioned, but it operates within the TypeScript environment and assumes the presence of the Stream class.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-forever.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const forever: <A, E, R>(self: Stream<A, E, R>) => Stream<A, E, R>\n```\n\n----------------------------------------\n\nTITLE: Defining Schema.TimeZone Class in TypeScript\nDESCRIPTION: Declares the TimeZone class within the Schema namespace. This class is used to create a schema that converts strings to TimeZone objects using the DateTime.zoneFromString constructor.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Schema-TimeZone.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare class TimeZone\n```\n\n----------------------------------------\n\nTITLE: Implementing Channel.failSync Function in TypeScript\nDESCRIPTION: The failSync function constructs a channel that succeeds immediately with a specified lazily evaluated value. It takes a LazyArg function that produces a value of type E which represents the error to fail with.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Channel-failSync.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const failSync: <E>(evaluate: LazyArg<E>) => Channel<never, unknown, E, unknown, never, unknown>\n```\n\n----------------------------------------\n\nTITLE: Creating KeyValueStore Layer Using Browser's sessionStorage in TypeScript\nDESCRIPTION: This code snippet defines a constant 'layerSessionStorage' that creates a KeyValueStore layer using the browser's sessionStorage API. The layer stores values only for the current session and has no requirements or errors.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/BrowserKeyValueStore-layerSessionStorage.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const layerSessionStorage: Layer.Layer<KeyValueStore.KeyValueStore, never, never>\n```\n\n----------------------------------------\n\nTITLE: TypeScript Function Signature for Match.exhaustive in Effect Package\nDESCRIPTION: This code snippet shows the TypeScript function signature for the Match.exhaustive method. It defines the method's type parameters and return type, which depends on whether all cases have been handled.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Match-exhaustive.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const exhaustive: <I, F, A, Pr, Ret>(self: Matcher<I, F, never, A, Pr, Ret>) => [Pr] extends [never] ? (u: I) => Unify<A> : Unify<A>\n```\n\n----------------------------------------\n\nTITLE: Getting the next integer from TRandom generator in TypeScript\nDESCRIPTION: The nextInt function returns the next integer from the pseudo-random number generator using STM (Software Transactional Memory). It returns an STM effect that produces a number with no error channel and requires a TRandom context.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TRandom-nextInt.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const nextInt: STM.STM<number, never, TRandom>\n```\n\n----------------------------------------\n\nTITLE: Using isEmpty Function with TypeScript in Effect Package\nDESCRIPTION: Demonstrates how to use the isEmpty function from the Iterable module to check if an array is empty. The function returns true for an empty array and false for a non-empty array.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Iterable-isEmpty.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { isEmpty } from \"effect/Iterable\"\n\nassert.deepStrictEqual(isEmpty([]), true);\nassert.deepStrictEqual(isEmpty([1, 2, 3]), false);\n```\n\n----------------------------------------\n\nTITLE: Function Signature for DateTime.unsafeMakeZoned in TypeScript\nDESCRIPTION: The function signature for DateTime.unsafeMakeZoned, which takes a DateTime.Input and optional configuration for timezone and adjustment. Returns a Zoned DateTime object.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/DateTime-unsafeMakeZoned.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const unsafeMakeZoned: (input: DateTime.Input, options?: { readonly timeZone?: number | string | TimeZone | undefined; readonly adjustForTimeZone?: boolean | undefined; }) => Zoned\n```\n\n----------------------------------------\n\nTITLE: Implementing Type Guard for Enqueue in TypeScript\nDESCRIPTION: This function is a type guard that checks if the given unknown value is of type Enqueue. It returns true if the value is an Enqueue, false otherwise. This is useful for type narrowing in TypeScript.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Queue-isEnqueue.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const isEnqueue: (u: unknown) => u is Enqueue<unknown>\n```\n\n----------------------------------------\n\nTITLE: Defining TimeoutException Type Identifier in TypeScript\nDESCRIPTION: Declares a unique symbol constant that serves as an identifier for TimeoutException types. This symbol is used internally by the Effect framework to recognize and handle timeout-related errors.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Cause-TimeoutExceptionTypeId.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const TimeoutExceptionTypeId: unique symbol\n```\n\n----------------------------------------\n\nTITLE: Extracting Brands from Branded Types in TypeScript\nDESCRIPTION: A type utility that extracts brand information from a branded type using conditional types and union-to-intersection conversion. It maps through the brand type ID properties and creates a union of individual brands.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Brand-Brand.Brands.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ntype Brands<P> = P extends Brand<any> ? Types.UnionToIntersection<\n      {\n        [k in keyof P[BrandTypeId]]: k extends string | symbol ? Brand<k>\n          : never\n      }[keyof P[BrandTypeId]]\n    >\n    : never\n```\n\n----------------------------------------\n\nTITLE: Defining the Runner Class in TypeScript\nDESCRIPTION: Declaration of the Runner class that represents a physical application server. The Runner has a unique address for communication and version information used during rebalancing to prioritize newer servers and decommission older ones.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Runner-Runner.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare class Runner\n```\n\n----------------------------------------\n\nTITLE: FiberSet.runtime function signature in TypeScript\nDESCRIPTION: The TypeScript type signature for FiberSet.runtime function. It takes a FiberSet instance and returns a function that requires a runtime environment R, which then produces an Effect that can be used to fork effects with that environment, adding the resulting fibers to the original FiberSet.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/FiberSet-runtime.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const runtime: <A, E>(self: FiberSet<A, E>) => <R = never>() => Effect.Effect<(<XE extends E, XA extends A>(effect: Effect.Effect<XA, XE, R>, options?: (Runtime.RunForkOptions & { readonly propagateInterruption?: boolean | undefined; }) | undefined) => Fiber.RuntimeFiber<XA, XE>), never, R>\n```\n\n----------------------------------------\n\nTITLE: Effect.findFirst Function Signature in TypeScript\nDESCRIPTION: The type signature of the findFirst function, showing its polymorphic nature. It can be called with either the predicate first and elements second (curried form) or with elements first and predicate second.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-findFirst.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const findFirst: { <A, E, R>(predicate: (a: NoInfer<A>, i: number) => Effect<boolean, E, R>): (elements: Iterable<A>) => Effect<Option.Option<A>, E, R>; <A, E, R>(elements: Iterable<A>, predicate: (a: NoInfer<A>, i: number) => Effect<boolean, E, R>): Effect<Option.Option<A>, E, R>; }\n```\n\n----------------------------------------\n\nTITLE: Checking for Interrupted Exit in TypeScript\nDESCRIPTION: The isInterrupted function checks if a given Exit instance is a Failure and if the Cause of the failure was due to interruption. It returns a boolean value indicating the result.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Exit-isInterrupted.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const isInterrupted: <A, E>(self: Exit<A, E>) => boolean\n```\n\n----------------------------------------\n\nTITLE: Creating Arrays with Specified Length in Effect\nDESCRIPTION: The allocate function creates a new Array of the specified length. It returns an array with the given number of empty slots, where each element is undefined.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Array-allocate.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Array } from \"effect\"\n\nconst result = Array.allocate<number>(3)\nconsole.log(result) // [ <3 empty items> ]\n```\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const allocate: <A = never>(n: number) => Array<A | undefined>\n```\n\n----------------------------------------\n\nTITLE: Defining FileSystem.SizeInput Type in TypeScript\nDESCRIPTION: Type definition that represents file sizes in bytes. Accepts bigint, number, or Size type values for flexible size representation in file system operations.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/FileSystem-SizeInput.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ntype SizeInput = bigint | number | Size\n```\n\n----------------------------------------\n\nTITLE: Type Signature for Predicate.mapInput in TypeScript\nDESCRIPTION: Provides the type signature for the Predicate.mapInput function. It shows two overloads: one that takes the mapping function first and returns a function expecting the predicate, and another that takes both the predicate and mapping function together.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Predicate-mapInput.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const mapInput: { <B, A>(f: (b: B) => A): (self: Predicate<A>) => Predicate<B>; <A, B>(self: Predicate<A>, f: (b: B) => A): Predicate<B>; }\n```\n\n----------------------------------------\n\nTITLE: Implementing Fiber Combination with zipWith in TypeScript\nDESCRIPTION: Function signature for zipWith that combines two fibers using a combiner function. The operation performs joins and interruptions sequentially from left to right. The function supports both curried and uncurried forms of combining fibers.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Fiber-zipWith.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const zipWith: { <B, E2, A, C>(that: Fiber<B, E2>, f: (a: A, b: B) => C): <E>(self: Fiber<A, E>) => Fiber<C, E2 | E>; <A, E, B, E2, C>(self: Fiber<A, E>, that: Fiber<B, E2>, f: (a: A, b: B) => C): Fiber<C, E | E2>; }\n```\n\n----------------------------------------\n\nTITLE: Checking Suspended Fiber Status in TypeScript\nDESCRIPTION: Type guard function that determines if a FiberStatus is in the Suspended state. Returns true if the fiber status is Suspended, false otherwise.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/FiberStatus-isSuspended.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const isSuspended: (self: FiberStatus) => self is Suspended\n```\n\n----------------------------------------\n\nTITLE: Defining NoInfer type in Typescript\nDESCRIPTION: The `NoInfer` type definition prevents type inference on a given type `A`. This is achieved by creating a conditional type that leverages distributive conditional types to effectively block inference. The purpose is to ensure that the provided type is used as is, without being inferred or widened by the compiler.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Types-NoInfer.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ntype NoInfer<A> = [A][A extends any ? 0 : never]\n```\n\n----------------------------------------\n\nTITLE: Checking FiberId Type in TypeScript\nDESCRIPTION: The isRuntime function is a type guard that checks if a given FiberId is of type Runtime. It returns true if the FiberId is a Runtime, and false otherwise. This function is useful for type narrowing in TypeScript.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/FiberId-isRuntime.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const isRuntime: (self: FiberId) => self is Runtime\n```\n\n----------------------------------------\n\nTITLE: Implementing unsafeDone Function for Deferred in TypeScript\nDESCRIPTION: This function unsafely completes a Deferred with a specified Effect value. It propagates the Exit value to all fibers waiting on the Deferred. The function is part of the Deferred module in the effect package.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Deferred-unsafeDone.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const unsafeDone: <A, E>(self: Deferred<A, E>, effect: Effect.Effect<A, E>) => void\n```\n\n----------------------------------------\n\nTITLE: Determining Absolute Value of BigInt in TypeScript\nDESCRIPTION: The abs function calculates the absolute value of a given bigint. It takes a bigint as input and returns its absolute value. This function works for positive, negative, and zero bigint values.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/BigInt-abs.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { abs } from \"effect/BigInt\"\n\nassert.deepStrictEqual(abs(-5n), 5n)\nassert.deepStrictEqual(abs(0n), 0n)\nassert.deepStrictEqual(abs(5n), 5n)\n```\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const abs: (n: bigint) => bigint\n```\n\n----------------------------------------\n\nTITLE: Defining Date Matching Predicate in TypeScript using Effect\nDESCRIPTION: Declares a constant 'date' as a Predicate.Refinement that checks if an unknown value is an instance of Date. This function is part of the Match module in the Effect package.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Match-date.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const date: Predicate.Refinement<unknown, Date>\n```\n\n----------------------------------------\n\nTITLE: Comparing Intervals in TypeScript using ScheduleIntervals.lessThan\nDESCRIPTION: Defines a function that compares two Intervals objects to determine if one starts before the other. It returns true if the start of the first Intervals is before the start of the second Intervals, false otherwise. The function is overloaded to accept arguments in two different orders.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/ScheduleIntervals-lessThan.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const lessThan: { (that: Intervals): (self: Intervals) => boolean; (self: Intervals, that: Intervals): boolean; }\n```\n\n----------------------------------------\n\nTITLE: TypeScript Function Signature for Match.not in Effect Package\nDESCRIPTION: Provides the TypeScript function signature for the Match.not function. This signature shows the complex type system used to ensure type safety in pattern matching operations.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Match-not.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const not: <R, const P extends Types.PatternPrimitive<R> | Types.PatternBase<R>, Ret, Fn extends (_: Exclude<R, Types.ExtractMatch<R, Types.PForExclude<P>>>) => Ret>(pattern: P, f: Fn) => <I, F, A, Pr>(self: Matcher<I, F, R, A, Pr, Ret>) => Matcher<I, Types.AddOnly<F, Types.WhenMatch<R, P>>, Types.ApplyFilters<I, Types.AddOnly<F, Types.WhenMatch<R, P>>>, A | ReturnType<Fn>, Pr, Ret>\n```\n\n----------------------------------------\n\nTITLE: isIterable Example\nDESCRIPTION: This code snippet demonstrates how to use the `isIterable` predicate from the `effect/Predicate` module to check if various inputs are iterable. It uses `node:assert` for testing the results of the predicate.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Predicate-isIterable.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { isIterable } from \"effect/Predicate\"\n\nassert.deepStrictEqual(isIterable([]), true)\nassert.deepStrictEqual(isIterable(new Set()), true)\n\nassert.deepStrictEqual(isIterable(null), false)\nassert.deepStrictEqual(isIterable({}), false)\n```\n\n----------------------------------------\n\nTITLE: Defining unsafeAdd Function for FiberSet in TypeScript\nDESCRIPTION: Declares the unsafeAdd function for adding a fiber to the FiberSet. The function is overloaded to accept different parameter orders. It allows specifying options for interrupt behavior and propagation.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/FiberSet-unsafeAdd.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const unsafeAdd: { <A, E, XE extends E, XA extends A>(fiber: Fiber.RuntimeFiber<XA, XE>, options?: { readonly interruptAs?: FiberId.FiberId | undefined; readonly propagateInterruption?: boolean | undefined; } | undefined): (self: FiberSet<A, E>) => void; <A, E, XE extends E, XA extends A>(self: FiberSet<A, E>, fiber: Fiber.RuntimeFiber<XA, XE>, options?: { readonly interruptAs?: FiberId.FiberId | undefined; readonly propagateInterruption?: boolean | undefined; } | undefined): void; }\n```\n\n----------------------------------------\n\nTITLE: Checking PubSub Queue Emptiness in TypeScript\nDESCRIPTION: The isEmpty function returns a boolean Effect indicating whether a PubSub queue contains zero elements. It takes a PubSub<A> as input and returns an Effect that resolves to a boolean.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/PubSub-isEmpty.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const isEmpty: <A>(self: PubSub<A>) => Effect.Effect<boolean>\n```\n\n----------------------------------------\n\nTITLE: TypeScript Function Signature for Effect.reduce\nDESCRIPTION: The type signature for the Effect.reduce function, showing its polymorphic nature with support for both curried and non-curried forms. It takes an iterable, an initial value, and a reducer function that returns an Effect.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-reduce.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const reduce: { <Z, A, E, R>(zero: Z, f: (z: Z, a: A, i: number) => Effect<Z, E, R>): (elements: Iterable<A>) => Effect<Z, E, R>; <A, Z, E, R>(elements: Iterable<A>, zero: Z, f: (z: Z, a: A, i: number) => Effect<Z, E, R>): Effect<Z, E, R>; }\n```\n\n----------------------------------------\n\nTITLE: Semigroup Tuple Function Signature\nDESCRIPTION: TypeScript type declaration for the tuple function that creates a new Semigroup for tuples based on individual Semigroup instances for each tuple element.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Semigroup-tuple.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const tuple: <T extends ReadonlyArray<Semigroup<any>>>(...elements: T) => Semigroup<{ readonly [I in keyof T]: [T[I]] extends [Semigroup<infer A>] ? A : never; }>\n```\n\n----------------------------------------\n\nTITLE: Signature of reduceCompact function in TypeScript\nDESCRIPTION: This snippet provides the TypeScript signature for the `reduceCompact` function, which describes its type parameters and functionality. It allows for flexible use with different types while ensuring type safety.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Option-reduceCompact.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const reduceCompact: { <B, A>(b: B, f: (b: B, a: A) => B): (self: Iterable<Option<A>>) => B; <A, B>(self: Iterable<Option<A>>, b: B, f: (b: B, a: A) => B): B; }\n```\n\n----------------------------------------\n\nTITLE: Prepending Element to MutableList in TypeScript\nDESCRIPTION: A utility function that prepends a specified value to the beginning of a mutable list. Supports both curried and direct function call styles, allowing flexible usage in TypeScript applications.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/MutableList-prepend.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const prepend: { <A>(value: A): (self: MutableList<A>) => MutableList<A>; <A>(self: MutableList<A>, value: A): MutableList<A>; }\n```\n\n----------------------------------------\n\nTITLE: Defining Float Primitive in TypeScript for CLI Package\nDESCRIPTION: Defines a constant 'float' as a Primitive type representing a floating point number. This is part of the @effect/cli package and is used for handling float values in CLI applications.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Primitive-float.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const float: Primitive<number>\n```\n\n----------------------------------------\n\nTITLE: Declaring taggedWithLabels Function for Metric Tagging in TypeScript\nDESCRIPTION: Defines a function that returns a new metric with additional tags. It can be used in two ways: as a curried function or with the metric as the first argument. The function adds the specified tags to the existing tags of the metric.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Metric-taggedWithLabels.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const taggedWithLabels: { <Type, In, Out>(extraTags: Iterable<MetricLabel.MetricLabel>): (self: Metric<Type, In, Out>) => Metric<Type, In, Out>; <Type, In, Out>(self: Metric<Type, In, Out>, extraTags: Iterable<MetricLabel.MetricLabel>): Metric<Type, In, Out>; }\n```\n\n----------------------------------------\n\nTITLE: Declaring Missing Error Class\nDESCRIPTION: This TypeScript class, Missing, represents an error that occurs when a required key or index is absent. It includes an 'ast' parameter of type AST.Type and an optional 'message' parameter. The class was introduced in version 3.10.0.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/ParseResult-Missing.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare class Missing { constructor(\n    /**\n     * @since 3.10.0\n     */\n    readonly ast: AST.Type,\n    /**\n     * @since 3.10.0\n     */\n    readonly message?: string\n  ) }\n```\n\n----------------------------------------\n\nTITLE: List Tail Extraction Function Signature\nDESCRIPTION: TypeScript function signature for extracting the tail of a List, returning an Option that contains the tail List if non-empty or None if empty. The function is type-safe and works with any element type A.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/List-tail.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const tail: <A>(self: List<A>) => Option.Option<List<A>>\n```\n\n----------------------------------------\n\nTITLE: Using Function.satisfies for Type Checking in TypeScript\nDESCRIPTION: Demonstrates how to use the satisfies function to ensure type compatibility while preserving literal types. The function performs compile-time type checking without changing the resulting type of the expression.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Function-satisfies.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { satisfies } from \"effect/Function\"\n\nconst test1 = satisfies<number>()(5 as const)\n    //^? const test: 5\n    // @ts-expect-error\nconst test2 = satisfies<string>()(5)\n    //^? Argument of type 'number' is not assignable to parameter of type 'string'\n\nassert.deepStrictEqual(satisfies<number>()(5), 5)\n```\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const satisfies: <A>() => <B extends A>(b: B) => B\n```\n\n----------------------------------------\n\nTITLE: Combining BigInt Values Using SemigroupSum in TypeScript\nDESCRIPTION: This code snippet demonstrates how to use the SemigroupSum.combine function from the @effect/typeclass package to combine two bigint values under addition. It requires the @effect/typeclass package and outputs the result of combining 2n and 3n, which is 5n.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/data-BigInt-SemigroupSum.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { SemigroupSum } from \"@effect/typeclass/data/BigInt\"\n\nconsole.log(SemigroupSum.combine(2n, 3n))\n// 5n\n```\n\n----------------------------------------\n\nTITLE: Defining Effect.awaitAllChildren Function in TypeScript\nDESCRIPTION: This snippet defines the awaitAllChildren function signature in the Effect module. It creates a new effect that will not succeed with its value before waiting for the end of all child fibers forked by the effect.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-awaitAllChildren.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const awaitAllChildren: <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R>\n```\n\n----------------------------------------\n\nTITLE: Defining Layout Options Interface for Effect Printer in TypeScript\nDESCRIPTION: This code snippet defines the Options interface for Layout.Layout in the @effect/printer package. It specifies a single readonly property 'pageWidth' of type PageWidth, which is used to influence layout algorithms.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Layout-Layout.Options.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface Options {\n    readonly pageWidth: PageWidth\n  }\n```\n\n----------------------------------------\n\nTITLE: Checking Logger Type in TypeScript\nDESCRIPTION: The isLogger function is a type guard that determines if a given value is a Logger instance. It takes an unknown value as input and returns a boolean indicating whether the value is a Logger of unknown types.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Logger-isLogger.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const isLogger: (u: unknown) => u is Logger<unknown, unknown>\n```\n\n----------------------------------------\n\nTITLE: Decoding Base64 Strings in TypeScript using Effect-TS\nDESCRIPTION: Function signature for decoding base64 (RFC4648) encoded strings into UTF-8 strings. Returns an Either type that contains either the decoded string or a DecodeException if decoding fails.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Encoding-decodeBase64String.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const decodeBase64String: (str: string) => Either.Either<string, DecodeException>\n```\n\n----------------------------------------\n\nTITLE: Declaring CORS Middleware Function in TypeScript for HttpApiBuilder\nDESCRIPTION: A TypeScript declaration for a CORS middleware function that can be provided to the HttpApiBuilder.serve layer. It accepts configuration options for allowed origins, methods, headers, exposed headers, max age, and credentials support.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/HttpApiBuilder-middlewareCors.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const middlewareCors: (options?: { readonly allowedOrigins?: ReadonlyArray<string> | undefined; readonly allowedMethods?: ReadonlyArray<string> | undefined; readonly allowedHeaders?: ReadonlyArray<string> | undefined; readonly exposedHeaders?: ReadonlyArray<string> | undefined; readonly maxAge?: number | undefined; readonly credentials?: boolean | undefined; } | undefined) => Layer.Layer<never>\n```\n\n----------------------------------------\n\nTITLE: BigInt.between Function Signature in TypeScript\nDESCRIPTION: Provides the TypeScript type signature for the BigInt.between function. It shows two overloads: one that takes an options object and returns a function, and another that takes a bigint value and an options object directly.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/BigInt-between.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const between: { (options: { minimum: bigint; maximum: bigint; }): (self: bigint) => boolean; (self: bigint, options: { minimum: bigint; maximum: bigint; }): boolean; }\n```\n\n----------------------------------------\n\nTITLE: Defining haltWhenDeferred Function for Stream Module in TypeScript\nDESCRIPTION: Declares the haltWhenDeferred function, which halts the evaluation of a stream when a provided Deferred resolves. It handles both success and failure cases of the Deferred resolution.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-haltWhenDeferred.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const haltWhenDeferred: { <X, E2>(deferred: Deferred.Deferred<X, E2>): <A, E, R>(self: Stream<A, E, R>) => Stream<A, E2 | E, R>; <A, E, R, X, E2>(self: Stream<A, E, R>, deferred: Deferred.Deferred<X, E2>): Stream<A, E | E2, R>; }\n```\n\n----------------------------------------\n\nTITLE: Defining Schedule.count in Typescript\nDESCRIPTION: Defines a schedule that recurs indefinitely, counting the number of recurrences, starting from 0. It returns a `Schedule` with type parameters for environment `number`, input `unknown`, and error `never`.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Schedule-count.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const count: Schedule<number, unknown, never>\n```\n\n----------------------------------------\n\nTITLE: Defining Invariant Type\nDESCRIPTION: This snippet defines the Invariant type, a function type that takes a value of type A and returns the same value of type A, ensuring the integrity of type operations within the Effect framework.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Types-Invariant.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ntype Invariant<A> = (_: A) => A\n```\n\n----------------------------------------\n\nTITLE: Signature of Trie.filter in Effect\nDESCRIPTION: This snippet provides the TypeScript type signature for the `Trie.filter` function in the Effect library. It details the function's overloads and parameter types, showcasing how the filter function can be applied to a Trie to produce a new Trie with filtered entries.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Trie-filter.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const filter: { <A, B extends A>(f: (a: NoInfer<A>, k: string) => a is B): (self: Trie<A>) => Trie<B>; <A>(f: (a: NoInfer<A>, k: string) => boolean): (self: Trie<A>) => Trie<A>; <A, B extends A>(self: Trie<A>, f: (a: A, k: string) => a is B): Trie<B>; <A>(self: Trie<A>, f: (a: A, k: string) => boolean): Trie<A>; }\n```\n\n----------------------------------------\n\nTITLE: Converting Either to Exit in TypeScript\nDESCRIPTION: The fromEither function converts an Either<R, L> into an Exit<R, L>. It takes an Either as input and returns an Exit type. This function is part of the Exit module in the Effect library.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Exit-fromEither.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const fromEither: <R, L>(either: Either.Either<R, L>) => Exit<R, L>\n```\n\n----------------------------------------\n\nTITLE: Using Boolean.every to Check if All Values in a Collection are True\nDESCRIPTION: The 'every' function checks if all elements in an iterable collection of boolean values are true. It returns true only if all elements are true, and false otherwise.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Boolean-every.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { every } from \"effect/Boolean\"\n\nassert.deepStrictEqual(every([true, true, true]), true)\nassert.deepStrictEqual(every([true, false, true]), false)\n```\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const every: (collection: Iterable<boolean>) => boolean\n```\n\n----------------------------------------\n\nTITLE: Implementing Service Provider in Effect Channel - TypeScript\nDESCRIPTION: Provides a type signature for the provideService function that enables providing a single required service to an effect channel. The function can be used in two ways: either by passing the service and tag separately, or by providing them together with the channel.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Channel-provideService.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const provideService: { \n  <I, S>(tag: Context.Tag<I, S>, service: Types.NoInfer<S>): \n    <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>\n    (self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>) => \n    Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Exclude<Env, I>>; \n  <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, I, S>\n    (self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>, \n     tag: Context.Tag<I, S>, \n     service: Types.NoInfer<S>): \n    Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Exclude<Env, I>>; \n}\n```\n\n----------------------------------------\n\nTITLE: String.isEmpty Function Type Definition\nDESCRIPTION: TypeScript type signature for the isEmpty function, showing it takes a string parameter and returns a type predicate indicating if the string is empty.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/String-isEmpty.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const isEmpty: (self: string) => self is \"\"\n```\n\n----------------------------------------\n\nTITLE: Flattening Nested Cause Structures in TypeScript (Effect Library)\nDESCRIPTION: The `flatten` function takes a nested `Cause<Cause<E>>` structure and merges the layers into a single `Cause<E>`. This is useful for eliminating additional nesting that might be created through repeated transformations or compositions.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Cause-flatten.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const flatten: <E>(self: Cause<Cause<E>>) => Cause<E>\n```\n\n----------------------------------------\n\nTITLE: Converting BigInt to BigDecimal in TypeScript\nDESCRIPTION: Function signature for creating a BigDecimal value from a native JavaScript bigint type. This provides type-safe conversion from bigint to BigDecimal format.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/BigDecimal-fromBigInt.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const fromBigInt: (n: bigint) => BigDecimal\n```\n\n----------------------------------------\n\nTITLE: Defining Doc.Nest Interface in TypeScript\nDESCRIPTION: Defines an interface for nested documents with indentation. The interface extends Doc.Variance<A> and includes properties for indent level and the document itself.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Doc-Nest.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface Nest<A> extends Doc.Variance<A> {\n  readonly _tag: \"Nest\"\n  readonly indent: number\n  readonly doc: Doc<A>\n}\n```\n\n----------------------------------------\n\nTITLE: Extracting Option Value Type in TypeScript\nDESCRIPTION: A type-level utility that extracts the type of the value contained within an Option type. Useful for type inference and type manipulation in TypeScript.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Option-Option.Value.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Option } from \"effect\"\n\n// Declare an Option holding a string\ndeclare const myOption: Option.Option<string>\n\n// Extract the type of the value within the Option\n//\n//      ┌─── string\n//      ▼\ntype MyType = Option.Option.Value<typeof myOption>\n```\n\nLANGUAGE: typescript\nCODE:\n```\ntype Value<T> = [T] extends [Option<infer _A>] ? _A : never\n```\n\n----------------------------------------\n\nTITLE: Declaring MonoidSum Type Signature\nDESCRIPTION: This snippet provides the TypeScript type signature for the `MonoidSum`, declaring it as a monoid of numbers. This declaration indicates that `MonoidSum` implements the `Monoid<number>` interface, which defines the combination operation and identity element.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/data-Number-MonoidSum.md#2025-04-11_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const MonoidSum: monoid.Monoid<number>\n```\n\n----------------------------------------\n\nTITLE: Defining Contravariant Type in TypeScript\nDESCRIPTION: This snippet defines a contravariant type which represents a function that takes an argument of type A and returns void. This is useful in functional programming to denote functions that are contravariant in their input types.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Types-Contravariant.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ntype Contravariant<A> = (_: A) => void\n```\n\n----------------------------------------\n\nTITLE: Defining Clock Interface in TypeScript\nDESCRIPTION: Definition of the Clock interface which provides time-based functionality including methods for getting current time and asynchronous sleep operations.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Clock-Clock.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface Clock {\n  readonly [ClockTypeId]: ClockTypeId\n  /**\n   * Unsafely returns the current time in milliseconds.\n   */\n  unsafeCurrentTimeMillis(): number\n  /**\n   * Returns the current time in milliseconds.\n   */\n  readonly currentTimeMillis: Effect.Effect<number>\n  /**\n   * Unsafely returns the current time in nanoseconds.\n   */\n  unsafeCurrentTimeNanos(): bigint\n  /**\n   * Returns the current time in nanoseconds.\n   */\n  readonly currentTimeNanos: Effect.Effect<bigint>\n  /**\n   * Asynchronously sleeps for the specified duration.\n   */\n  sleep(duration: Duration.Duration): Effect.Effect<void>\n}\n```\n\n----------------------------------------\n\nTITLE: Appending Elements to Iterable in TypeScript\nDESCRIPTION: This function appends an element to the end of an Iterable, creating a new Iterable. It can be used with both curried and uncurried syntax.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Iterable-append.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const append: { <B>(last: B): <A>(self: Iterable<A>) => Iterable<A | B>; <A, B>(self: Iterable<A>, last: B): Iterable<A | B>; }\n```\n\n----------------------------------------\n\nTITLE: Implementing Array.appendAll Function in TypeScript\nDESCRIPTION: The appendAll function concatenates two arrays or iterables, combining their elements. It maintains type information about non-emptiness, ensuring that if either input is non-empty, the result is also typed as a non-empty array.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Array-appendAll.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const appendAll: { <S extends Iterable<any>, T extends Iterable<any>>(that: T): (self: S) => ReadonlyArray.OrNonEmpty<S, T, ReadonlyArray.Infer<S> | ReadonlyArray.Infer<T>>; <A, B>(self: Iterable<A>, that: NonEmptyReadonlyArray<B>): NonEmptyArray<A | B>; <A, B>(self: NonEmptyReadonlyArray<A>, that: Iterable<B>): NonEmptyArray<A | B>; <A, B>(self: Iterable<A>, that: Iterable<B>): Array<A | B>; }\n```\n\n----------------------------------------\n\nTITLE: Context.empty Function Signature\nDESCRIPTION: Type signature for the Context.empty function which returns an empty Context with never type parameter.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Context-empty.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const empty: () => Context<never>\n```\n\n----------------------------------------\n\nTITLE: Defining the retryUntil Function in TypeScript\nDESCRIPTION: This TypeScript function, 'retryUntil', retries an STM operation until a specified predicate returns true. It is part of the 'STM' module in the 'effect' package. The function supports refining the type of a transaction's output using a refinement and provides overloaded signatures to accommodate different scenarios. Required dependencies include the STM type from the Effect library, and it does not specify constraints on input or output types beyond the provided predicates or refinements.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/STM-retryUntil.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const retryUntil: { <A, B extends A>(refinement: Refinement<NoInfer<A>, B>): <E, R>(self: STM<A, E, R>) => STM<B, E, R>; <A>(predicate: Predicate<A>): <E, R>(self: STM<A, E, R>) => STM<A, E, R>; <A, E, R, B extends A>(self: STM<A, E, R>, refinement: Refinement<A, B>): STM<B, E, R>; <A, E, R>(self: STM<A, E, R>, predicate: Predicate<A>): STM<A, E, R>; }\n```\n\n----------------------------------------\n\nTITLE: Prepending Elements to Iterable in TypeScript\nDESCRIPTION: Function signature for prepending an element to the front of an Iterable to create a new Iterable. Supports both curried and uncurried versions of the function for flexibility in usage.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Iterable-prepend.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const prepend: { <B>(head: B): <A>(self: Iterable<A>) => Iterable<A | B>; <A, B>(self: Iterable<A>, head: B): Iterable<A | B>; }\n```\n\n----------------------------------------\n\nTITLE: Checking Sequential Type in Cause Module (TypeScript)\nDESCRIPTION: Defines a function isSequentialType that checks if a Cause is of Sequential type. This function is useful for determining the structure of a Cause object, particularly when dealing with sequential combinations of Causes.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Cause-isSequentialType.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const isSequentialType: <E>(self: Cause<E>) => self is Sequential<E>\n```\n\n----------------------------------------\n\nTITLE: Using DateTime.endOf to Get End of Day in TypeScript\nDESCRIPTION: This example demonstrates how to convert a DateTime object to the end of the day. The function takes a DateTime object and returns a new DateTime set to the last millisecond of the specified day (23:59:59.999).\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/DateTime-endOf.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { DateTime } from \"effect\"\n\n// returns \"2024-01-01T23:59:59.999Z\"\nDateTime.unsafeMake(\"2024-01-01T12:00:00Z\").pipe(\n  DateTime.endOf(\"day\"),\n  DateTime.formatIso\n)\n```\n\n----------------------------------------\n\nTITLE: Checking if Intervals is Non-Empty in Typescript\nDESCRIPTION: This code snippet defines the `isNonEmpty` function, which takes an `Intervals` object as input and returns a boolean indicating whether the interval is non-empty. The function is part of the `ScheduleIntervals` module in the `effect` package.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/ScheduleIntervals-isNonEmpty.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const isNonEmpty: (self: Intervals) => boolean\n```\n\n----------------------------------------\n\nTITLE: Constructing HTTP Web Handler from RPC Group in TypeScript\nDESCRIPTION: The `toWebHandler` function creates an HTTP web handler from an `RpcGroup`. It requires a layer for handling middleware, serialization, and default services. The options include parameters for disabling tracing, setting a span prefix, applying middleware, and using a memoization map. The function returns an object with a handler for HTTP requests and a dispose function. Requires prior knowledge of RPC, layer handling, and TypeScript.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/RpcServer-toWebHandler.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const toWebHandler: <Rpcs extends Rpc.Any, LE>(group: RpcGroup.RpcGroup<Rpcs>, options: { readonly layer: Layer.Layer<Rpc.ToHandler<Rpcs> | Rpc.Middleware<Rpcs> | RpcSerialization.RpcSerialization | HttpRouter.HttpRouter.DefaultServices, LE>; readonly disableTracing?: boolean | undefined; readonly spanPrefix?: string | undefined; readonly middleware?: (httpApp: HttpApp.Default) => HttpApp.Default<never, HttpRouter.HttpRouter.DefaultServices>; readonly memoMap?: Layer.MemoMap; }) => { readonly handler: (request: globalThis.Request, context?: Context.Context<never> | undefined) => Promise<Response>; readonly dispose: () => Promise<void>; }\n```\n\n----------------------------------------\n\nTITLE: Using Doc.softLine for adaptive layout in Effect Printer\nDESCRIPTION: Example demonstrating how Doc.softLine works in different page width scenarios. When there's enough space, softLine behaves like a space, but when the page width is narrowed, it introduces a line break.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Doc-softLine.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport * as Doc from \"@effect/printer/Doc\"\nimport * as String from \"effect/String\"\n\nconst doc: Doc.Doc<never> = Doc.hcat([\n  Doc.text(\"lorem ipsum\"),\n  Doc.softLine,\n  Doc.text(\"dolor sit amet\")\n])\n\n// Here we have enough space to put everything onto one line\nassert.strictEqual(\n  Doc.render(doc, {\n    style: \"pretty\",\n    options: { lineWidth: 80 }\n  }),\n  \"lorem ipsum dolor sit amet\"\n)\n\n// If the page width is narrowed to `10`, the layout algorithm will\n// introduce a line break\nassert.strictEqual(\n  Doc.render(Doc.group(doc), {\n    style: \"pretty\",\n    options: { lineWidth: 10 }\n  }),\n  String.stripMargin(\n    `|lorem ipsum\n     |dolor sit amet`\n  )\n)\n```\n\n----------------------------------------\n\nTITLE: Declaring File Content Parameter in Options Module - TypeScript\nDESCRIPTION: Defines the 'fileContent' parameter in the Options module of the Effect-TS CLI that reads the contents of a specified file path. This function takes a string parameter, 'name', representing the file path, and returns an Options object containing an array with the path and its content as a Uint8Array.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Options-fileContent.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const fileContent: (name: string) => Options<readonly [path: string, content: Uint8Array]>\n```\n\n----------------------------------------\n\nTITLE: Creating Micro Effect with an Error\nDESCRIPTION: This code snippet declares a constant `die`, which creates a `Micro` effect that terminates with a specified error. It generates a `Die` variant of the `MicroCause` type without tracking the error at the type level. The `defect` parameter represents the unknown error that will trigger the termination of the effect.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Micro-die.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const die: (defect: unknown) => Micro<never>\n```\n\n----------------------------------------\n\nTITLE: TypeScript Function Signature Declaration for isNumber\nDESCRIPTION: This snippet declares the function signature for isNumber, which takes an unknown input and checks if it is specifically a number type. This type guard enhances type safety in TypeScript by allowing type checks and inference based on the input type.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Number-isNumber.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const isNumber: (input: unknown) => input is number\n```\n\n----------------------------------------\n\nTITLE: TypeScript Signature for JSON Logger in Effect\nDESCRIPTION: Defines the TypeScript signature for the `json` logger, which is a Layer that doesn't require or provide any specific environment.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Logger-json.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const json: Layer.Layer<never, never, never>\n```\n\n----------------------------------------\n\nTITLE: Joining Fibers in a FiberSet with Error Handling in TypeScript\nDESCRIPTION: This example demonstrates how to create a FiberSet, add a failing fiber to it, and then join all fibers. It shows that if any fiber in the set fails, the parent fiber will fail with the first error that occurred.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/FiberSet-join.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Effect, FiberSet } from \"effect\";\n\nEffect.gen(function* (_) {\n  const set = yield* _(FiberSet.make());\n  yield* _(FiberSet.add(set, Effect.runFork(Effect.fail(\"error\"))));\n\n  // parent fiber will fail with \"error\"\n  yield* _(FiberSet.join(set));\n});\n```\n\n----------------------------------------\n\nTITLE: Checking if a Value is an Option in TypeScript\nDESCRIPTION: This function checks if the provided input is an instance of Option, returning true for valid Option types and false otherwise. It is particularly useful for maintaining type safety within the application. It is part of the 'effect' library's Option module.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Option-isOption.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Option } from \"effect\"\n\nconsole.log(Option.isOption(Option.some(1)))\n// Output: true\n\nconsole.log(Option.isOption(Option.none()))\n// Output: true\n\nconsole.log(Option.isOption({}))\n// Output: false\n```\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const isOption: (input: unknown) => input is Option<unknown>\n```\n\n----------------------------------------\n\nTITLE: Implementing Pick Operation for Schema AST in TypeScript\nDESCRIPTION: Function signature for picking specific properties from a schema AST. Takes an AST object and an array of property keys as input, returning either a TypeLiteral or Transformation. This provides runtime functionality equivalent to TypeScript's Pick utility type.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/SchemaAST-pick.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const pick: (ast: AST, keys: ReadonlyArray<PropertyKey>) => TypeLiteral | Transformation\n```\n\n----------------------------------------\n\nTITLE: Declaring NumberFromString Schema Class in TypeScript\nDESCRIPTION: This code snippet declares the NumberFromString class, which is a schema for transforming strings into numbers. It supports parsing numeric strings and special values like 'NaN' and 'Infinity'.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Schema-NumberFromString.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare class NumberFromString\n```\n\n----------------------------------------\n\nTITLE: Defining Variables and Operations Using Do Simulation - TypeScript\nDESCRIPTION: This code snippet shows how to utilize the 'do simulation' feature in the Effect library to bind Option values and perform operations in a declarative manner. It utilizes the pipe function to chain operations, and the assert function is used to validate the expected output. The key parameters include the bind and let functions which help in defining variables and performing calculations within the scope of the do simulation.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Option-Do.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { Option, pipe } from \"effect\"\n\nconst result = pipe(\n  Option.Do,\n  Option.bind(\"x\", () => Option.some(2)),\n  Option.bind(\"y\", () => Option.some(3)),\n  Option.let(\"sum\", ({ x, y }) => x + y),\n  Option.filter(({ x, y }) => x * y > 5)\n)\nassert.deepStrictEqual(result, Option.some({ x: 2, y: 3, sum: 5 }))\n```\n\n----------------------------------------\n\nTITLE: Creating a Synchronous Failure Sink in TypeScript\nDESCRIPTION: Defines a sink function that generates a failure with a lazily evaluated cause, useful for error handling and controlled sink termination\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Sink-failCauseSync.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const failCauseSync: <E>(evaluate: LazyArg<Cause.Cause<E>>) => Sink<never, unknown, never, E>\n```\n\n----------------------------------------\n\nTITLE: Retrieving Interrupt FiberId from Cause in TypeScript\nDESCRIPTION: A function that extracts the first fiber interruption from a Cause. It returns an Option containing the FiberId of the interrupted fiber if present. This is useful for analyzing concurrency issues or tracking cancellations.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Cause-interruptOption.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const interruptOption: <E>(self: Cause<E>) => Option.Option<FiberId.FiberId>\n```\n\n----------------------------------------\n\nTITLE: Defining Lowercased String Schema Filter in TypeScript\nDESCRIPTION: Creates a schema filter that verifies a string is entirely lowercase, with optional annotations. Part of the Effect-TS Schema module for type-safe runtime validation.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Schema-lowercased.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const lowercased: <S extends Schema.Any>(annotations?: Annotations.Filter<Schema.Type<S>>) => <A extends string>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>) => filter<S>\n```\n\n----------------------------------------\n\nTITLE: Declaring ULID Class in Effect Schema\nDESCRIPTION: This code snippet declares the `ULID` class in TypeScript. The class is intended to represent a Universally Unique Lexicographically Sortable Identifier (ULID) within the Effect Schema module. No dependencies are explicitly shown here, but it's implied that this class would be used within the larger Effect ecosystem.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Schema-ULID.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare class ULID\n```\n\n----------------------------------------\n\nTITLE: Defining Doc.group Function in TypeScript\nDESCRIPTION: Declares the group function that attempts to lay out a document onto a single line by removing contained line breaks. It adapts the layout based on available space and hardLine constraints.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Doc-group.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const group: <A>(self: Doc<A>) => Doc<A>\n```\n\n----------------------------------------\n\nTITLE: Binding Micro Effect Values - TypeScript\nDESCRIPTION: Function signature for binding success values from Micro effects to named properties. Supports both curried and uncurried forms. The operation combines the original record type with the newly bound value, omitting any existing property with the same name.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Micro-bind.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const bind: { \n  <N extends string, A extends Record<string, any>, B, E2, R2>(name: N, f: (a: NoInfer<A>) => Micro<B, E2, R2>): <E, R>(self: Micro<A, E, R>) => Micro<Simplify<Omit<A, N> & { [K in N]: B; }>, E | E2, R | R2>; \n  <A extends Record<string, any>, E, R, B, E2, R2, N extends string>(self: Micro<A, E, R>, name: N, f: (a: NoInfer<A>) => Micro<B, E2, R2>): Micro<Simplify<Omit<A, N> & { [K in N]: B; }>, E | E2, R | R2>; \n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Generic Brand Interface in TypeScript\nDESCRIPTION: Defines the Brand generic interface that creates branded types for type safety. It uses a special BrandTypeId symbol property with a mapped type to ensure uniqueness of the branded type. This pattern allows for creating nominal typing in TypeScript's structural type system.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Brand-Brand.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface Brand<in out K extends string | symbol> {\n  readonly [BrandTypeId]: {\n    readonly [k in K]: K\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Array.dedupeAdjacent Function Signature in TypeScript\nDESCRIPTION: The type signature for the dedupeAdjacent function. It takes an Iterable of type A and returns an Array of type A. The function has been available since version 2.0.0 of the effect package.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Array-dedupeAdjacent.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const dedupeAdjacent: <A>(self: Iterable<A>) => Array<A>\n```\n\n----------------------------------------\n\nTITLE: Extracting Optional Stream Values in TypeScript\nDESCRIPTION: This TypeScript snippet defines a function for extracting optional values from a stream, defaulting to a provided fallback if the value is not present. It requires the Effect-TS library and uses the Stream and Option types, with the function returning a new Stream instance. The key operation involves applying a fallback function if the main optional value is absent, useful in asynchronous data handling with streams.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-someOrElse.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const someOrElse: { <A2>(fallback: LazyArg<A2>): <A, E, R>(self: Stream<Option.Option<A>, E, R>) => Stream<A2 | A, E, R>; <A, E, R, A2>(self: Stream<Option.Option<A>, E, R>, fallback: LazyArg<A2>): Stream<A | A2, E, R>; }\n```\n\n----------------------------------------\n\nTITLE: Checking for ChannelException in TypeScript\nDESCRIPTION: This function determines if a given value is an instance of ChannelException. It takes an unknown input and returns a boolean indicating whether the input is a ChannelException. This is useful for type narrowing and error handling in Effect-based applications.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Channel-isChannelException.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const isChannelException: (u: unknown) => u is ChannelException<unknown>\n```\n\n----------------------------------------\n\nTITLE: Defining ArrayFormatterIssue Interface in Typescript\nDESCRIPTION: This code snippet defines the `ArrayFormatterIssue` interface in Typescript. It includes readonly properties for the tag identifying the type of parse issue (`_tag`), the path to the property where the issue occurred (`path`), and a descriptive message (`message`). This interface is part of the Effect library's `ParseResult` module.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/ParseResult-ArrayFormatterIssue.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface ArrayFormatterIssue {\n  /**\n   * The tag identifying the type of parse issue.\n   */\n  readonly _tag: ParseIssue[\"_tag\"]\n\n  /**\n   * The path to the property where the issue occurred.\n   */\n  readonly path: ReadonlyArray<PropertyKey>\n\n  /**\n   * A descriptive message explaining the issue.\n   */\n  readonly message: string\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing timeoutOption function in Effect.ts Micro module\nDESCRIPTION: Defines a function that applies a timeout to an effect. If the timeout elapses before the effect completes, it returns None; otherwise, it returns Some with the produced value. The running effect is safely interrupted if the timeout occurs.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Micro-timeoutOption.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const timeoutOption: { (millis: number): <A, E, R>(self: Micro<A, E, R>) => Micro<Option.Option<A>, E, R>; <A, E, R>(self: Micro<A, E, R>, millis: number): Micro<Option.Option<A>, E, R>; }\n```\n\n----------------------------------------\n\nTITLE: Retrieving Identifiers from FiberId in TypeScript\nDESCRIPTION: The `ids` function extracts the set of identifier numbers from a FiberId instance. It returns a HashSet containing all the numeric identifiers associated with the fiber.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/FiberId-ids.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const ids: (self: FiberId) => HashSet.HashSet<number>\n```\n\n----------------------------------------\n\nTITLE: Defining buildWithMemoMap Function in TypeScript\nDESCRIPTION: Declares the buildWithMemoMap function, which builds a layer into an Effect value using a specified MemoMap for memoization. It has two overloads: one taking memoMap and scope as separate arguments, and another taking the layer as the first argument.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Layer-buildWithMemoMap.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const buildWithMemoMap: { (memoMap: MemoMap, scope: Scope.Scope): <RIn, E, ROut>(self: Layer<ROut, E, RIn>) => Effect.Effect<Context.Context<ROut>, E, RIn>; <RIn, E, ROut>(self: Layer<ROut, E, RIn>, memoMap: MemoMap, scope: Scope.Scope): Effect.Effect<Context.Context<ROut>, E, RIn>; }\n```\n\n----------------------------------------\n\nTITLE: Creating DateTime Objects with unsafeMake in Effect\nDESCRIPTION: The unsafeMake function creates a DateTime object from various input types including existing DateTime objects, Date instances, milliseconds, object literals with date parts, or parsable strings. Invalid date inputs will throw an IllegalArgumentException.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/DateTime-unsafeMake.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { DateTime } from \"effect\"\n\n// from Date\nDateTime.unsafeMake(new Date())\n\n// from parts\nDateTime.unsafeMake({ year: 2024 })\n\n// from string\nDateTime.unsafeMake(\"2024-01-01\")\n```\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const unsafeMake: <A extends DateTime.Input>(input: A) => DateTime.PreserveZone<A>\n```\n\n----------------------------------------\n\nTITLE: Defining RuntimeExceptionTypeId Symbol in TypeScript\nDESCRIPTION: Declaration of a unique symbol identifier for the RuntimeException type. This symbol is used internally by the library to recognize checked exceptions that occur during runtime.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Cause-RuntimeExceptionTypeId.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const RuntimeExceptionTypeId: unique symbol\n```\n\n----------------------------------------\n\nTITLE: Defining unsafeFromNonEmptyArray Function in TypeScript\nDESCRIPTION: This function wraps a non-empty array into a chunk without copying. It is unsafe to use with mutable arrays. The function takes a NonEmptyReadonlyArray<A> as input and returns a NonEmptyChunk<A>.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Chunk-unsafeFromNonEmptyArray.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const unsafeFromNonEmptyArray: <A>(self: NonEmptyReadonlyArray<A>) => NonEmptyChunk<A>\n```\n\n----------------------------------------\n\nTITLE: Interrupting Fiber STM Function in TypeScript\nDESCRIPTION: This snippet declares an interrupt function within the STM module to handle fiber interruptions. It requires the Effect library and its STM module. The function signature specifies that it never produces or returns a value, indicating its focus on side-effect management. It directly impacts the running fiber with no parameters needed.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/STM-interrupt.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const interrupt: STM<never, never, never>\n```\n\n----------------------------------------\n\nTITLE: Collect While Effect Schedule in Typescript\nDESCRIPTION: Creates a schedule that collects all inputs into a `Chunk` as long as the provided effectful predicate `f` returns `true`. The predicate returns an effect, which allows depending on external state. The schedule stops when the condition returns `false`.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Schedule-collectWhileEffect.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const collectWhileEffect: <A, R>(f: (a: A) => Effect.Effect<boolean, never, R>) => Schedule<Chunk.Chunk<A>, A, R>\n```\n\n----------------------------------------\n\nTITLE: Executing Workflows with Custom Annotations in TypeScript\nDESCRIPTION: The withAnnotations function allows execution of a specified workflow with a custom implementation of the annotations service. It supports both curried and non-curried function calls.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TestServices-withAnnotations.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const withAnnotations: ((annotations: Annotations.TestAnnotations) => <A, E, R>(effect: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>) & (<A, E, R>(effect: Effect.Effect<A, E, R>, annotations: Annotations.TestAnnotations) => Effect.Effect<A, E, R>)\n```\n\n----------------------------------------\n\nTITLE: Defining eitherWith Function in Effect Schedule, TypeScript\nDESCRIPTION: The `eitherWith` function is an alias of `unionWith` in the `Schedule` module. It allows the merging of two schedules by using a custom function that operates on intervals, facilitating combined scheduling operations. This requires the `effect` package and defines type signatures that handle multiple input and output schedules.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Schedule-eitherWith.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const eitherWith: { <Out2, In2, R2>(that: Schedule<Out2, In2, R2>, f: (x: Intervals.Intervals, y: Intervals.Intervals) => Intervals.Intervals): <Out, In, R>(self: Schedule<Out, In, R>) => Schedule<[Out, Out2], In & In2, R2 | R>; <Out, In, R, Out2, In2, R2>(self: Schedule<Out, In, R>, that: Schedule<Out2, In2, R2>, f: (x: Intervals.Intervals, y: Intervals.Intervals) => Intervals.Intervals): Schedule<[Out, Out2], In & In2, R | R2>; }\n```\n\n----------------------------------------\n\nTITLE: Type Signature for lessThan Function in BigDecimal Module\nDESCRIPTION: The type signature for the lessThan function, which supports both curried and uncurried calling styles for comparing BigDecimal values.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/BigDecimal-lessThan.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const lessThan: { (that: BigDecimal): (self: BigDecimal) => boolean; (self: BigDecimal, that: BigDecimal): boolean; }\n```\n\n----------------------------------------\n\nTITLE: Creating Daily Recurring Schedule with Effect in TypeScript\nDESCRIPTION: The `hourOfDay` function creates a schedule that triggers once per day at a specified hour. It accepts a single parameter `hour`, which must be between 0 (midnight) and 23 (11 PM). The function returns a `Schedule` which counts the number of times it has been triggered. This is useful for scheduling daily recurring tasks, such as batch jobs. Note: `hour` is validated lazily, meaning errors due to invalid values are only caught during execution.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Schedule-hourOfDay.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const hourOfDay: (hour: number) => Schedule<number>\n```\n\n----------------------------------------\n\nTITLE: Transforming Leftovers with Sink.mapLeftover in TypeScript\nDESCRIPTION: The `mapLeftover` function transforms the leftovers emitted by a sink using a transformation function. It provides both a curried and an uncurried version for flexibility in function application.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Sink-mapLeftover.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const mapLeftover: { <L, L2>(f: (leftover: L) => L2): <A, In, E, R>(self: Sink<A, In, L, E, R>) => Sink<A, In, L2, E, R>; <A, In, L, E, R, L2>(self: Sink<A, In, L, E, R>, f: (leftover: L) => L2): Sink<A, In, L2, E, R>; }\n```\n\n----------------------------------------\n\nTITLE: BigInt.lcm Function Signature\nDESCRIPTION: The type signature for the lcm function which shows both curried and non-curried forms. It takes two bigint parameters and returns their least common multiple as a bigint.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/BigInt-lcm.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const lcm: { (that: bigint): (self: bigint) => bigint; (self: bigint, that: bigint): bigint; }\n```\n\n----------------------------------------\n\nTITLE: Determining Pull Request Status in TypeScript\nDESCRIPTION: The snippet defines a TypeScript utility that checks if a particular `UpstreamPullRequest` instance represents a `Pulled` state. It is part of the `effect` package and requires TypeScript to be installed. The function takes a parameter `self` of type `UpstreamPullRequest<A>` and returns a boolean indicating whether the `UpstreamPullRequest` is in the `Pulled` state.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/UpstreamPullRequest-isPulled.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const isPulled: <A>(self: UpstreamPullRequest<A>) => self is Pulled<A>\n```\n\n----------------------------------------\n\nTITLE: Executing Micro Effect with runPromiseExit\nDESCRIPTION: A TypeScript method that runs a Micro effect and returns a Promise resolving with the computation's exit status. Supports optional abort signal and custom scheduler configuration.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Micro-runPromiseExit.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const runPromiseExit: <A, E>(effect: Micro<A, E>, options?: { readonly signal?: AbortSignal | undefined; readonly scheduler?: MicroScheduler | undefined; } | undefined) => Promise<MicroExit<A, E>>\n```\n\n----------------------------------------\n\nTITLE: Defining unsafeOffer Function in TypeScript for Queue Module\nDESCRIPTION: Declares the unsafeOffer function which places one value in the queue. It can be called with either the value first and the queue second, or the queue first and the value second. The function returns a boolean indicating success or failure of the operation.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Queue-unsafeOffer.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const unsafeOffer: { <A>(value: A): (self: Enqueue<A>) => boolean; <A>(self: Enqueue<A>, value: A): boolean; }\n```\n\n----------------------------------------\n\nTITLE: Defining Reverse Iterator for Red-Black Tree\nDESCRIPTION: A function that returns an iterable of key-value pairs from a Red-Black Tree, traversed in reverse order and limited to entries less than or equal to a given key. Supports curried and direct function call styles.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/RedBlackTree-lessThanEqualReversed.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const lessThanEqualReversed: { <K>(key: K): <V>(self: RedBlackTree<K, V>) => Iterable<[K, V]>; <K, V>(self: RedBlackTree<K, V>, key: K): Iterable<[K, V]>; }\n```\n\n----------------------------------------\n\nTITLE: Executing a Workflow with Sized Service - TypeScript\nDESCRIPTION: The `withSized` function is a higher-order function that facilitates executing workflows by taking a Sized.TestSized implementation and an Effect.Effect instance. It is designed to enhance the functionality of the Effect library and streamline workflow execution. This function can be called in two different ways, either knowing the sized service beforehand or passing it along with the effect.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TestServices-withSized.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const withSized: ((sized: Sized.TestSized) => <A, E, R>(effect: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>) & (<A, E, R>(effect: Effect.Effect<A, E, R>, sized: Sized.TestSized) => Effect.Effect<A, E, R>)\n```\n\n----------------------------------------\n\nTITLE: Checking Chunk Emptiness in TypeScript\nDESCRIPTION: This function determines if a given Chunk is empty. It takes a Chunk of any type A as input and returns a boolean indicating whether the Chunk is empty or not.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Chunk-isEmpty.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const isEmpty: <A>(self: Chunk<A>) => boolean\n```\n\n----------------------------------------\n\nTITLE: Defining OpenAI Telemetry Attributes in TypeScript\nDESCRIPTION: This TypeScript type, `OpenAiTelemetryAttributes`, combines various telemetry attributes for Generative AI model requests and responses within OpenAI. It depends on the `AiTelemetry.GenAITelemetryAttributes` and uses generics to prefix attributes with the necessary request and response strings as per OpenTelemetry guidelines. This ensures consistent structure and naming conventions for telemetry data in GenAI operations.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/OpenAiTelemetry-OpenAiTelemetryAttributes.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ntype OpenAiTelemetryAttributes = Simplify<\n  & AiTelemetry.GenAITelemetryAttributes\n  & AiTelemetry.GenAI.AttributesWithPrefix<OpenAiTelemetry.RequestAttributes, \"gen_ai.openai.request\">\n  & AiTelemetry.GenAI.AttributesWithPrefix<OpenAiTelemetry.ResponseAttributes, \"gen_ai.openai.request\">\n>\n```\n\n----------------------------------------\n\nTITLE: Formatting DateTime Objects as ISO Strings in TypeScript\nDESCRIPTION: This function formats a DateTime object as a UTC ISO string. It takes a DateTime object as input and returns the formatted string representation.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/DateTime-formatIso.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const formatIso: (self: DateTime) => string\n```\n\n----------------------------------------\n\nTITLE: Decoding Hex Strings to UTF-8 in TypeScript\nDESCRIPTION: Function signature for decoding hex-encoded strings into UTF-8 strings. Returns an Either type that contains either the decoded string or a DecodeException if the decoding fails.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Encoding-decodeHexString.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const decodeHexString: (str: string) => Either.Either<string, DecodeException>\n```\n\n----------------------------------------\n\nTITLE: Using Array.liftEither for Error Handling in TypeScript\nDESCRIPTION: Demonstrates how to use Array.liftEither to convert a function returning Either into one returning an array. The example shows parsing numbers from strings, where successful parses return a single-element array and failures return an empty array.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Array-liftEither.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Array, Either } from \"effect\"\n\nconst parseNumber = (s: string): Either.Either<number, Error> =>\n  isNaN(Number(s)) ? Either.left(new Error(\"Not a number\")) : Either.right(Number(s))\n\nconst liftedParseNumber = Array.liftEither(parseNumber)\n\nconst result1 = liftedParseNumber(\"42\")\nconsole.log(result1) // [42]\n\nconst result2 = liftedParseNumber(\"not a number\")\nconsole.log(result2) // []\n\n// Explanation:\n// The function parseNumber is lifted to return an array.\n// When parsing \"42\", it returns an Either.left with the number 42, resulting in [42].\n// When parsing \"not a number\", it returns an Either.right with an error, resulting in an empty array [].\n```\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const liftEither: <A extends Array<unknown>, E, B>(f: (...a: A) => Either.Either<B, E>) => (...a: A) => Array<B>\n```\n\n----------------------------------------\n\nTITLE: Conditional Stream Operation Type Definition in TypeScript\nDESCRIPTION: Type definition for a function that takes an Effect containing a boolean condition and returns a function that filters a Stream based on that condition. The function has two overloads to support both curried and uncurried calling patterns.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-whenEffect.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const whenEffect: { <E2, R2>(effect: Effect.Effect<boolean, E2, R2>): <A, E, R>(self: Stream<A, E, R>) => Stream<A, E2 | E, R2 | R>; <A, E, R, E2, R2>(self: Stream<A, E, R>, effect: Effect.Effect<boolean, E2, R2>): Stream<A, E | E2, R | R2>; }\n```\n\n----------------------------------------\n\nTITLE: Checking Conditions in HashMaps with HashMap.some in TypeScript\nDESCRIPTION: The HashMap.some function checks if any entry in a hashmap meets a specific condition defined by a predicate function. It supports both curried and non-curried calling styles and returns a boolean indicating if any entry matches the predicate.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/HashMap-some.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const some: { <K, A>(predicate: (a: NoInfer<A>, k: K) => boolean): (self: HashMap<K, A>) => boolean; <K, A>(self: HashMap<K, A>, predicate: (a: A, k: K) => boolean): boolean; }\n```\n\n----------------------------------------\n\nTITLE: Setting URL Protocol - TypeScript\nDESCRIPTION: Defines a function that updates the protocol of a given URL. The function can be invoked either by passing the protocol followed by the URL or by passing the URL first followed by the protocol. It is part of the `@effect/platform` package and requires TypeScript to be utilized properly. The expected input is either a string representing the protocol and a URL object or vice versa, with an output being a modified URL object.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Url-setProtocol.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const setProtocol: { (protocol: string): (url: URL) => URL; (url: URL, protocol: string): URL; }\n```\n\n----------------------------------------\n\nTITLE: Defining isMergeState Function in TypeScript\nDESCRIPTION: Declares a constant function isMergeState that checks if a given unknown value is of type MergeState. It returns a boolean indicating whether the input is a MergeState or not.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/MergeState-isMergeState.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const isMergeState: (u: unknown) => u is MergeState<unknown, unknown, unknown, unknown, unknown, unknown, unknown, unknown>\n```\n\n----------------------------------------\n\nTITLE: Signature of fromEntries function in TypeScript\nDESCRIPTION: This code snippet describes the TypeScript signature of the 'fromEntries' function, which takes an iterable of key-value pairs and returns a record. It utilizes generics to enforce key and value types.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Record-fromEntries.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const fromEntries: <Entry extends readonly [string | symbol, any]>(entries: Iterable<Entry>) => Record<ReadonlyRecord.NonLiteralKey<Entry[0]>, Entry[1]>\n```\n\n----------------------------------------\n\nTITLE: Array.flatten Function Signature in TypeScript\nDESCRIPTION: Provides the TypeScript type signature for the Array.flatten function. It takes a readonly array of readonly arrays of any type and returns a flattened readonly array.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Array-flatten.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const flatten: <S extends ReadonlyArray<ReadonlyArray<any>>>(self: S) => ReadonlyArray.Flatten<S>\n```\n\n----------------------------------------\n\nTITLE: Defining Capitalize Schema Class in TypeScript for Effect-TS\nDESCRIPTION: This code snippet declares a Capitalize class within the Schema module of the effect package. It is designed to convert a string to a capitalized format. The class is part of the Effect-TS library and has been available since version 3.10.0.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Schema-Capitalize.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare class Capitalize\n```\n\n----------------------------------------\n\nTITLE: Signature of logfmtLogger in Effect Logger Module (TypeScript)\nDESCRIPTION: Defines the type signature of the logfmtLogger function in the Logger module. It is a Logger that takes an unknown input and produces a string output.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Logger-logfmtLogger.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const logfmtLogger: Logger<unknown, string>\n```\n\n----------------------------------------\n\nTITLE: Combining Schedules with Either in Typescript\nDESCRIPTION: Combines two schedules sequentially, collecting results in an `Either`. The `Either.Left` contains the output of the second schedule, and `Either.Right` contains the output of the first schedule. The resulting `Schedule` has an output type of `Either.Either<Out2, Out>`, and requires inputs that satisfy both input types `In & In2`.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Schedule-andThenEither.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const andThenEither: { <Out2, In2, R2>(that: Schedule<Out2, In2, R2>): <Out, In, R>(self: Schedule<Out, In, R>) => Schedule<Either.Either<Out2, Out>, In & In2, R2 | R>; <Out, In, R, Out2, In2, R2>(self: Schedule<Out, In, R>, that: Schedule<Out2, In2, R2>): Schedule<Either.Either<Out2, Out>, In & In2, R | R2>; }\n```\n\n----------------------------------------\n\nTITLE: Defining Ndjson Parsing Options Interface in TypeScript\nDESCRIPTION: Defines an interface for configuring newline delimited JSON parsing behavior, with an optional flag to ignore empty lines during parsing. Provides flexibility in handling different NDJSON input formats.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Ndjson-NdjsonOptions.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface NdjsonOptions {\n  /**\n   * Whether or not the newline delimited JSON parser should ignore empty lines.\n   *\n   * Defaults to `false`.\n   *\n   * From the [newline delimited JSON spec](https://github.com/ndjson/ndjson-spec):\n   * ```text\n   * The parser MAY silently ignore empty lines, e.g. \\n\\n. This behavior MUST\n   * be documented and SHOULD be configurable by the user of the parser.\n   * ```\n   *\n   * @since 1.0.0\n   */\n  readonly ignoreEmptyLines?: boolean\n}\n```\n\n----------------------------------------\n\nTITLE: Doc.seps Type Signature in TypeScript\nDESCRIPTION: Shows the type signature for the seps combinator function which accepts an Iterable of Doc<A> and returns a Doc<A>.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Doc-seps.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const seps: <A>(docs: Iterable<Doc<A>>) => Doc<A>\n```\n\n----------------------------------------\n\nTITLE: Zipping Sorted Streams with Key Functions - TypeScript\nDESCRIPTION: The 'zipAllSortedByKeyWith' function zips two distinct key-sorted streams, utilizing provided key functions to handle cases of matching keys and values across both streams. The caller must ensure that the input streams are properly sorted, as this implementation allows constant space usage for potentially unbounded data.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-zipAllSortedByKeyWith.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const zipAllSortedByKeyWith: { <K, A2, E2, R2, A, A3>(options: { readonly other: Stream<readonly [K, A2], E2, R2>; readonly onSelf: (a: A) => A3; readonly onOther: (a2: A2) => A3; readonly onBoth: (a: A, a2: A2) => A3; readonly order: Order.Order<K>; }): <E, R>(self: Stream<readonly [K, A], E, R>) => Stream<[K, A3], E2 | E, R2 | R>; <K, A, E, R, A2, E2, R2, A3>(self: Stream<readonly [K, A], E, R>, options: { readonly other: Stream<readonly [K, A2], E2, R2>; readonly onSelf: (a: A) => A3; readonly onOther: (a2: A2) => A3; readonly onBoth: (a: A, a2: A2) => A3; readonly order: Order.Order<K>; }): Stream<[K, A3], E | E2, R | R2>; }\n```\n\n----------------------------------------\n\nTITLE: Comparing Numbers using Effect/Number in TypeScript\nDESCRIPTION: This snippet demonstrates the use of the greaterThanOrEqualTo function from the Effect library's Number module. It checks if a given number is greater than or equal to another. The function can be used with either one or two arguments to facilitate comparisons. Dependencies include the 'effect/Number' module for the function and the 'node:assert' module for assertions. This function is especially useful for applications requiring numeric comparison logic.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Number-greaterThanOrEqualTo.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport * as assert from \"node:assert\"\\nimport { greaterThanOrEqualTo } from \"effect/Number\"\\n\\nassert.deepStrictEqual(greaterThanOrEqualTo(2, 3), false)\\nassert.deepStrictEqual(greaterThanOrEqualTo(3, 3), true)\\nassert.deepStrictEqual(greaterThanOrEqualTo(4, 3), true)\n```\n\n----------------------------------------\n\nTITLE: Checking if a value is a Doc type in TypeScript\nDESCRIPTION: A type guard function that determines whether an unknown value is a Doc instance. Returns true if the input is a valid Doc of any content type, false otherwise.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Doc-isDoc.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const isDoc: (u: unknown) => u is Doc<unknown>\n```\n\n----------------------------------------\n\nTITLE: Combining RuntimeFlagsPatch Instances in TypeScript\nDESCRIPTION: The 'both' function creates a RuntimeFlagsPatch by combining two existing patches. It allows for the composition of multiple runtime flag modifications, supporting both curried and uncurried calling styles.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/RuntimeFlagsPatch-both.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const both: { (that: RuntimeFlagsPatch): (self: RuntimeFlagsPatch) => RuntimeFlagsPatch; (self: RuntimeFlagsPatch, that: RuntimeFlagsPatch): RuntimeFlagsPatch; }\n```\n\n----------------------------------------\n\nTITLE: Mapping STM Error Values to Optional Type in TypeScript\nDESCRIPTION: This function maps the error value of an STM effect to an optional value. It transforms an STM that may produce an error of type E into an STM that produces an error of type Option<E>.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/STM-asSomeError.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const asSomeError: <A, E, R>(self: STM<A, E, R>) => STM<A, Option.Option<E>, R>\n```\n\n----------------------------------------\n\nTITLE: Defining a UuidV4Insert Field Generator for Binary UUID v4 in TypeScript\nDESCRIPTION: This function creates a field that represents a binary UUID v4 that is automatically generated when records are inserted into a database. It takes a schema parameter that defines the brand type for the UUID.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Model-UuidV4Insert.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const UuidV4Insert: <const B extends string | symbol>(schema: Schema.brand<typeof Schema.Uint8ArrayFromSelf, B>) => UuidV4Insert<B>\n```\n\n----------------------------------------\n\nTITLE: Unsafe Trie Value Retrieval with Error Handling\nDESCRIPTION: Demonstrates using unsafeGet method which throws an error when a key is not found in the Trie\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Trie-unsafeGet.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nassert.throws(() => Trie.unsafeGet(trie, \"mae\"))\n```\n\n----------------------------------------\n\nTITLE: Stream.grouped Function Signature in TypeScript\nDESCRIPTION: This code snippet shows the TypeScript signature for the Stream.grouped function. It can be called in two ways: with the chunk size as the first argument, or with the stream as the first argument and chunk size as the second.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-grouped.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const grouped: { (chunkSize: number): <A, E, R>(self: Stream<A, E, R>) => Stream<Chunk.Chunk<A>, E, R>; <A, E, R>(self: Stream<A, E, R>, chunkSize: number): Stream<Chunk.Chunk<A>, E, R>; }\n```\n\n----------------------------------------\n\nTITLE: Using catWithSpace to concatenate documents with space in TypeScript\nDESCRIPTION: This example demonstrates how to use the catWithSpace function from the @effect/printer library to concatenate two character documents with a space between them. The resulting document is then rendered using Doc.render with the 'pretty' style.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Doc-catWithSpace.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport * as Doc from \"@effect/printer/Doc\"\nimport { pipe } from \"effect/Function\"\n\nconst doc: Doc.Doc<never> = pipe(\n  Doc.char(\"a\"),\n  Doc.catWithSpace(Doc.char(\"b\"))\n)\n\nassert.strictEqual(\n  Doc.render(doc, { style: \"pretty\" }),\n  \"a b\"\n)\n```\n\n----------------------------------------\n\nTITLE: Using Array.intersectionWith with Custom Object Comparison\nDESCRIPTION: Example demonstrating how to find common elements between two arrays of objects using a custom equivalence function that compares object IDs.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Array-intersectionWith.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Array } from \"effect\"\n\nconst array1 = [{ id: 1 }, { id: 2 }, { id: 3 }]\nconst array2 = [{ id: 3 }, { id: 4 }, { id: 1 }]\nconst isEquivalent = (a: { id: number }, b: { id: number }) => a.id === b.id\nconst result = Array.intersectionWith(isEquivalent)(array2)(array1)\nconsole.log(result) // [{ id: 1 }, { id: 3 }]\n```\n\n----------------------------------------\n\nTITLE: Defining ShardingConfig Class in TypeScript\nDESCRIPTION: Declares the ShardingConfig class which represents the configuration for the Sharding service on a given runner. This is a foundational class for setting up distributed sharding in Effect applications.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/ShardingConfig-ShardingConfig.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare class ShardingConfig\n```\n\n----------------------------------------\n\nTITLE: Defining ShardManager RPC Class in TypeScript\nDESCRIPTION: Declares the Rpcs class that handles the messaging protocol for ShardManager. This class is responsible for managing communication between shards in the cluster system.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/ShardManager-Rpcs.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare class Rpcs\n```\n\n----------------------------------------\n\nTITLE: Declaring cursorLeft Function in AnsiDoc Module\nDESCRIPTION: Defines the cursorLeft constant which returns an AnsiDoc that moves the cursor to the first column of the current row in the terminal. This function is useful for terminal positioning operations.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/AnsiDoc-cursorLeft.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const cursorLeft: AnsiDoc\n```\n\n----------------------------------------\n\nTITLE: Signature of Doc.punctuate function in TypeScript\nDESCRIPTION: This code block shows the TypeScript signature of the `punctuate` function. It demonstrates that the function can be used in two ways: either by passing the punctuator first and then the documents, or by passing the documents first and then the punctuator.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Doc-punctuate.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const punctuate: { <A, B>(punctuator: Doc<A>): (docs: Iterable<Doc<B>>) => ReadonlyArray<Doc<A | B>>; <A, B>(docs: Iterable<Doc<B>>, punctuator: Doc<A>): ReadonlyArray<Doc<A | B>>; }\n```\n\n----------------------------------------\n\nTITLE: Checking Queue Shutdown Status with TQueue.isShutdown in TypeScript\nDESCRIPTION: Function that returns `true` if the `shutdown` method has been called on a queue, otherwise returns `false`. Works with both TDequeue and TEnqueue types within STM context.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TQueue-isShutdown.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const isShutdown: <A>(self: TDequeue<A> | TEnqueue<A>) => STM.STM<boolean>\n```\n\n----------------------------------------\n\nTITLE: Defining Micro.onExit Function Type in TypeScript\nDESCRIPTION: Type declaration for the onExit function that takes a finalizer effect and returns a new Micro effect. The function handles the execution exit state and allows running cleanup or finalization logic.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Micro-onExit.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const onExit: { <A, E, XE, XR>(f: (exit: MicroExit<A, E>) => Micro<void, XE, XR>): <R>(self: Micro<A, E, R>) => Micro<A, E | XE, R | XR>; <A, E, R, XE, XR>(self: Micro<A, E, R>, f: (exit: MicroExit<A, E>) => Micro<void, XE, XR>): Micro<A, E | XE, R | XR>; }\n```\n\n----------------------------------------\n\nTITLE: Effect.as Method Signature in TypeScript\nDESCRIPTION: This code snippet shows the TypeScript signature for the Effect.as method. It demonstrates that the method can be used in two ways: either by piping an effect into it with a new value, or by providing both the effect and the new value as arguments.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-as.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const as: { <B>(value: B): <A, E, R>(self: Effect<A, E, R>) => Effect<B, E, R>; <A, E, R, B>(self: Effect<A, E, R>, value: B): Effect<B, E, R>; }\n```\n\n----------------------------------------\n\nTITLE: Defining Config.Config.Wrap Type in TypeScript\nDESCRIPTION: A TypeScript type definition that wraps nested structures by converting primitives to Config types. It handles plain objects recursively while preserving the original structure, useful for creating typed configuration objects.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Config-Config.Wrap.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ntype Wrap<A> = [NonNullable<A>] extends [infer T] ? [IsPlainObject<T>] extends [true] ?\n        | { readonly [K in keyof A]: Wrap<A[K]> }\n        | Config<A>\n    : Config<A>\n    : Config<A>\n```\n\n----------------------------------------\n\nTITLE: Formatting DateTime as UTC ISO Date String in TypeScript\nDESCRIPTION: The formatIsoDateUtc function converts a DateTime object to a UTC ISO date string. It takes a DateTime object as input and returns a formatted string representation following the ISO format in UTC timezone.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/DateTime-formatIsoDateUtc.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const formatIsoDateUtc: (self: DateTime) => string\n```\n\n----------------------------------------\n\nTITLE: Defining Doc.Annotated Interface in TypeScript\nDESCRIPTION: Defines the Annotated interface that extends Doc.Variance<A> to represent a document with an associated annotation. It includes a tag for type identification, the annotation itself, and a reference to the annotated document.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Doc-Annotated.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface Annotated<A> extends Doc.Variance<A> {\n  readonly _tag: \"Annotated\"\n  readonly annotation: A\n  readonly doc: Doc<A>\n}\n```\n\n----------------------------------------\n\nTITLE: Extracting Values Using Option Module in TypeScript\nDESCRIPTION: The `getOrNull` function is used to retrieve the value from an `Option` object. If the `Option` is `Some`, it returns the contained value; otherwise, it returns `null`. This pattern is useful when interacting with systems that use `null` as a default placeholder for missing values. The function is part of the `Option` module in the Effect library, and it does not require additional dependencies aside from the module itself.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Option-getOrNull.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Option } from \"effect\"\n\nconsole.log(Option.getOrNull(Option.some(1)))\n// Output: 1\n\nconsole.log(Option.getOrNull(Option.none()))\n// Output: null\n```\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const getOrNull: <A>(self: Option<A>) => A | null\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Doc.catWithSoftLine Usage in TypeScript\nDESCRIPTION: This example shows how to use the catWithSoftLine combinator to concatenate two documents with a softLine between them. It demonstrates the function's behavior with different rendering options.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Doc-catWithSoftLine.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport * as Doc from \"@effect/printer/Doc\"\nimport { pipe } from \"effect/Function\"\nimport * as String from \"effect/String\"\n\nconst doc: Doc.Doc<never> = pipe(\n  Doc.char(\"a\"),\n  Doc.catWithSoftLine(Doc.char(\"b\"))\n)\n\nassert.strictEqual(\n  Doc.render(doc, { style: \"pretty\" }),\n  \"a b\"\n)\n\nassert.strictEqual(\n  Doc.render(doc, {\n    style: \"pretty\",\n    options: { lineWidth: 1 }\n  }),\n  String.stripMargin(\n    `|a\n     |b`\n  )\n)\n```\n\n----------------------------------------\n\nTITLE: Checking Effect Success Status in TypeScript\nDESCRIPTION: Function signature for isSuccess, which evaluates whether an effect has succeeded and returns a boolean wrapped in an effect. The resulting effect cannot fail (never in the error channel) but retains the context of the original effect.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-isSuccess.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const isSuccess: <A, E, R>(self: Effect<A, E, R>) => Effect<boolean, never, R>\n```\n\n----------------------------------------\n\nTITLE: Implementing Stream.unfoldChunk in TypeScript\nDESCRIPTION: Function signature for creating a stream by recursively processing a value of type S into chunks of type A. Takes an initial state S and a transformation function that returns an Option containing a tuple of a Chunk<A> and next state S.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-unfoldChunk.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const unfoldChunk: <S, A>(s: S, f: (s: S) => Option.Option<readonly [Chunk.Chunk<A>, S]>) => Stream<A>\n```\n\n----------------------------------------\n\nTITLE: Signature of Extend Function in Effect TS\nDESCRIPTION: This TypeScript declaration provides the signature for the extend function used to combine two schemas in the Effect TS library. It shows how the extend function can take two schemas and merge them, returning a new schema type.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Schema-extend.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const extend: { <That extends Schema.Any>(that: That): <Self extends Schema.Any>(self: Self) => extend<Self, That>; <Self extends Schema.Any, That extends Schema.Any>(self: Self, that: That): extend<Self, That>; }\n```\n\n----------------------------------------\n\nTITLE: Type Signature for Effect.orElse in TypeScript\nDESCRIPTION: This code block shows the type signature for the Effect.orElse function. It demonstrates the function's polymorphic nature, allowing it to work with different effect types and error types.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-orElse.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const orElse: { <A2, E2, R2>(that: LazyArg<Effect<A2, E2, R2>>): <A, E, R>(self: Effect<A, E, R>) => Effect<A2 | A, E2, R2 | R>; <A, E, R, A2, E2, R2>(self: Effect<A, E, R>, that: LazyArg<Effect<A2, E2, R2>>): Effect<A2 | A, E2, R2 | R>; }\n```\n\n----------------------------------------\n\nTITLE: Cron.match Function Signature in TypeScript\nDESCRIPTION: The TypeScript function signature for Cron.match, showing it accepts a Cron object and a DateTime input and returns a boolean indicating whether the date matches the cron pattern.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Cron-match.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const match: (cron: Cron, date: DateTime.DateTime.Input) => boolean\n```\n\n----------------------------------------\n\nTITLE: Checking if an Interval is Empty - TypeScript\nDESCRIPTION: The `isEmpty` function checks if a given `Interval` is empty. It takes an `Interval` object as input and returns a boolean indicating its emptiness. This function is part of the Effect-TS library and is essential for managing scheduling intervals in reactive programming.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/ScheduleInterval-isEmpty.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const isEmpty: (self: Interval) => boolean\n```\n\n----------------------------------------\n\nTITLE: Creating Layer from TimeZone in Effect Library (TypeScript)\nDESCRIPTION: This function creates a Layer from a given time zone. It takes a TimeZone object as input and returns a Layer<CurrentTimeZone>. This is useful for providing time zone context in Effect applications.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/DateTime-layerCurrentZone.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const layerCurrentZone: (zone: TimeZone) => Layer.Layer<CurrentTimeZone>\n```\n\n----------------------------------------\n\nTITLE: Implementing SingleQuoted Document Function in TypeScript\nDESCRIPTION: Function signature for a utility that wraps a document in single quotes. Takes a Doc<A> as input and returns a Doc<A> with single quotes around the content.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Doc-singleQuoted.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const singleQuoted: <A>(self: Doc<A>) => Doc<A>\n```\n\n----------------------------------------\n\nTITLE: Creating Unbounded Queues in Effect TQueue Module\nDESCRIPTION: Function for creating an unbounded queue in the TQueue module. Returns an STM effect that produces a TQueue of type A when executed.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TQueue-unbounded.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const unbounded: <A>() => STM.STM<TQueue<A>>\n```\n\n----------------------------------------\n\nTITLE: Declaring Greater Than Function Using TypeScript\nDESCRIPTION: The snippet declares a function `greaterThan` that tests if one value is strictly greater than another. It utilizes TypeScript generics and functional programming concepts, such as higher-order functions. The function requires an `Order` type as a dependency, which provides order-based utilities, and it supports both curried and uncurried invocations.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Order-greaterThan.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const greaterThan: <A>(O: Order<A>) => { (that: A): (self: A) => boolean; (self: A, that: A): boolean; }\n```\n\n----------------------------------------\n\nTITLE: Defining PrettyError Interface in Typescript for Effect-TS\nDESCRIPTION: Defines the PrettyError interface which extends the standard Error type with an optional span property. This is used for prettified errors that may include source location information.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Cause-PrettyError.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface PrettyError extends Error {\n  readonly span: Span | undefined\n}\n```\n\n----------------------------------------\n\nTITLE: Dropping Elements from Array using Effect Library\nDESCRIPTION: Example demonstrating how to use Array.drop to remove elements from the start of an array. The method takes an Iterable and number of elements to drop, returning a new Array with the remaining elements.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Array-drop.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Array } from \"effect\"\n\nconst result = Array.drop([1, 2, 3, 4, 5], 2)\nconsole.log(result) // [3, 4, 5]\n```\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const drop: { (n: number): <A>(self: Iterable<A>) => Array<A>; <A>(self: Iterable<A>, n: number): Array<A>; }\n```\n\n----------------------------------------\n\nTITLE: Defining Required Type Function in SchemaAST\nDESCRIPTION: Function declaration for implementing Required type functionality at runtime. Takes an AST parameter and returns a transformed AST representing required properties.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/SchemaAST-required.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const required: (ast: AST) => AST\n```\n\n----------------------------------------\n\nTITLE: Concatenating DocTrees in TypeScript\nDESCRIPTION: The concat function horizontally concatenates multiple DocTree instances. It takes an array of DocTree<A> as input and returns a single DocTree<A>.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/DocTree-concat.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const concat: <A>(trees: ReadonlyArray<DocTree<A>>) => DocTree<A>\n```\n\n----------------------------------------\n\nTITLE: Declaring the whenFiberRef Function in TypeScript\nDESCRIPTION: TypeScript signature for the `whenFiberRef` function that conditionally executes an effect based on a FiberRef value meeting a predicate condition. The function returns a tuple containing the FiberRef value and an Option that may contain the effect result.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-whenFiberRef.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const whenFiberRef: { <S>(fiberRef: FiberRef.FiberRef<S>, predicate: Predicate<S>): <A, E, R>(self: Effect<A, E, R>) => Effect<[S, Option.Option<A>], E, R>; <A, E, R, S>(self: Effect<A, E, R>, fiberRef: FiberRef.FiberRef<S>, predicate: Predicate<S>): Effect<[S, Option.Option<A>], E, R>; }\n```\n\n----------------------------------------\n\nTITLE: Implementing flatMap Operation for Iterables in TypeScript\nDESCRIPTION: Defines a flatMap function that transforms elements of an Iterable using a mapping function and concatenates the results. The function accepts both curried and uncurried forms, taking either a mapping function first or an Iterable and mapping function together.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Iterable-flatMap.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const flatMap: { <A, B>(f: (a: NoInfer<A>, i: number) => Iterable<B>): (self: Iterable<A>) => Iterable<B>; <A, B>(self: Iterable<A>, f: (a: NoInfer<A>, i: number) => Iterable<B>): Iterable<B>; }\n```\n\n----------------------------------------\n\nTITLE: TypeScript Function Signature for MutableHashSet.fromIterable\nDESCRIPTION: The TypeScript type definition for the MutableHashSet.fromIterable function, showing it accepts any iterable of type K and returns a MutableHashSet of the same type.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/MutableHashSet-fromIterable.md#2025-04-11_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const fromIterable: <K = never>(keys: Iterable<K>) => MutableHashSet<K>\n```\n\n----------------------------------------\n\nTITLE: Testing for Schema Object in TypeScript\nDESCRIPTION: This TypeScript function checks if a provided value is of type Schema. It is part of the Effect library's Schema package starting from version 3.10.0. The function takes a single parameter, of type unknown, and returns a boolean indicating whether the input is a Schema object.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Schema-isSchema.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const isSchema: (u: unknown) => u is Schema.Any\n```\n\n----------------------------------------\n\nTITLE: Defining PathPatch Type in TypeScript\nDESCRIPTION: Defines the PathPatch type as a union of different path modification strategies. This type represents various ways to modify the path to a configuration value in the effect library.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/ConfigProviderPathPatch-PathPatch.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ntype PathPatch = Empty | AndThen | MapName | Nested | Unnested\n```\n\n----------------------------------------\n\nTITLE: Defining Stream Identity Function in TypeScript\nDESCRIPTION: This code snippet defines the identity function for streams. It's a pipeline that doesn't modify streams in any way. The function is generic, accepting type parameters for the stream elements (A), error type (E), and environment type (R).\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-identity.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const identity: <A, E = never, R = never>() => Stream<A, E, R>\n```\n\n----------------------------------------\n\nTITLE: Defining Semigroup Max Function in TypeScript\nDESCRIPTION: Implementation of a Semigroup that returns the maximum element when combining two values. Takes an Order instance as a parameter to determine the ordering of elements.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Semigroup-max.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const max: <A>(O: Order<A>) => Semigroup<A>\n```\n\n----------------------------------------\n\nTITLE: Declaring a One-Time Execution Schedule in Effect Framework with TypeScript\nDESCRIPTION: This TypeScript code declares a constant `once` representing a schedule that triggers a single execution and then terminates without any repeats or additional logic. This is part of the Effect framework, introduced in version 2.0.0. There are no dependencies or external prerequisites needed for understanding this signature. The `once` schedule type is depicted as `Schedule<void, unknown, never>`, indicating no inputs or outputs are processed.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Schedule-once.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const once: Schedule<void, unknown, never>\n```\n\n----------------------------------------\n\nTITLE: Type Signature for Iterable.getRights Function in TypeScript\nDESCRIPTION: This code block shows the type signature of the getRights function in the Iterable module. It takes an Iterable of Either<R, L> and returns an Iterable of R, where R represents the Right type.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Iterable-getRights.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const getRights: <R, L>(self: Iterable<Either<R, L>>) => Iterable<R>\n```\n\n----------------------------------------\n\nTITLE: Declaring STM Replication Function in TypeScript\nDESCRIPTION: The function `replicateSTM` executes a given STM transaction a specified number of times and gathers the results into an array. This utility enhances the manipulation of transactions within the Effect library, a toolset for managing side-effects in functional programming. The function can be invoked either with the repeat count specified first or alongside the transaction. This is defined in the `STM.ts` module of the `effect` package.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/STM-replicateSTM.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const replicateSTM: { (n: number): <A, E, R>(self: STM<A, E, R>) => STM<Array<A>, E, R>; <A, E, R>(self: STM<A, E, R>, n: number): STM<Array<A>, E, R>; }\n```\n\n----------------------------------------\n\nTITLE: Array.matchRight Function Signature in TypeScript\nDESCRIPTION: The type signature for Array.matchRight function, showing its overloaded variants. It can be called either by creating a reusable matcher function or by directly passing both the array and options.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Array-matchRight.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const matchRight: { <B, A, C = B>(options: { readonly onEmpty: LazyArg<B>; readonly onNonEmpty: (init: Array<A>, last: A) => C; }): (self: ReadonlyArray<A>) => B | C; <A, B, C = B>(self: ReadonlyArray<A>, options: { readonly onEmpty: LazyArg<B>; readonly onNonEmpty: (init: Array<A>, last: A) => C; }): B | C; }\n```\n\n----------------------------------------\n\nTITLE: Type Definition for Effect.filterOrElse in TypeScript\nDESCRIPTION: Type signature for the filterOrElse function that filters an Effect based on a predicate or refinement, with an alternative effect if the filter fails. The function supports both curried and uncurried forms, handling predicates and refinements with appropriate type constraints.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-filterOrElse.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const filterOrElse: {\n  <A, B extends A, C, E2, R2>(\n    refinement: Refinement<NoInfer<A>, B>,\n    orElse: (a: NoInfer<A>) => Effect<C, E2, R2>\n  ): <E, R>(self: Effect<A, E, R>) => Effect<B | C, E2 | E, R2 | R>;\n  <A, B, E2, R2>(\n    predicate: Predicate<NoInfer<A>>,\n    orElse: (a: NoInfer<A>) => Effect<B, E2, R2>\n  ): <E, R>(self: Effect<A, E, R>) => Effect<A | B, E2 | E, R2 | R>;\n  <A, E, R, B extends A, C, E2, R2>(\n    self: Effect<A, E, R>,\n    refinement: Refinement<A, B>,\n    orElse: (a: A) => Effect<C, E2, R2>\n  ): Effect<B | C, E | E2, R | R2>;\n  <A, E, R, B, E2, R2>(\n    self: Effect<A, E, R>,\n    predicate: Predicate<A>,\n    orElse: (a: A) => Effect<B, E2, R2>\n  ): Effect<A | B, E | E2, R | R2>;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Stream.whenCase in Typescript\nDESCRIPTION: The `Stream.whenCase` function conditionally returns a stream. If the provided `PartialFunction` (`pf`) is defined for the evaluated value (`evaluate`), the resulting stream from `pf` is returned; otherwise, an empty stream is returned. It leverages `LazyArg` for lazy evaluation of the input `A` and `Option` to handle cases where the partial function is not defined.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-whenCase.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const whenCase: <A, A2, E, R>(evaluate: LazyArg<A>, pf: (a: A) => Option.Option<Stream<A2, E, R>>) => Stream<A2, E, R>\n```\n\n----------------------------------------\n\nTITLE: Declaring Channel.never Operation in TypeScript\nDESCRIPTION: TypeScript type declaration for a Channel.never operation that creates a channel which never completes. The channel type parameters indicate it accepts no input, produces no output, and never errors or completes.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Channel-never.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const never: Channel<never, unknown, never, unknown, never, unknown, never>\n```\n\n----------------------------------------\n\nTITLE: Effect.onError Function Signature in TypeScript\nDESCRIPTION: The type signature for the onError function, showing its polymorphic nature. It accepts a cleanup function that takes a Cause<E> as input and returns an Effect that never fails, and can be used both as a standalone function or through method chaining.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-onError.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const onError: { <E, X, R2>(cleanup: (cause: Cause.Cause<E>) => Effect<X, never, R2>): <A, R>(self: Effect<A, E, R>) => Effect<A, E, R2 | R>; <A, E, R, X, R2>(self: Effect<A, E, R>, cleanup: (cause: Cause.Cause<E>) => Effect<X, never, R2>): Effect<A, E, R2 | R>; }\n```\n\n----------------------------------------\n\nTITLE: TypeScript Function Signature for isTag in Effect Library\nDESCRIPTION: This snippet shows the TypeScript function signature for the isTag function in the Context module. It defines isTag as a function that takes an unknown input and returns a boolean indicating whether the input is a Tag of any type.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Context-isTag.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const isTag: (input: unknown) => input is Tag<any, any>\n```\n\n----------------------------------------\n\nTITLE: Defining Predicate.tuple Function in TypeScript\nDESCRIPTION: The Predicate.tuple function is similar to Promise.all but operates on Predicates. It takes an array of Refinements or Predicates and returns a new Predicate or Refinement that operates on tuples.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Predicate-tuple.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n[Refinement<A, B>, Refinement<C, D>, ...] -> Refinement<[A, C, ...], [B, D, ...]>\n[Predicate<A>, Predicate<B>, ...] -> Predicate<[A, B, ...]>\n[Refinement<A, B>, Predicate<C>, ...] -> Refinement<[A, C, ...], [B, C, ...]>\n```\n\n----------------------------------------\n\nTITLE: Implementing Chunk.contains Function in TypeScript\nDESCRIPTION: Defines a function that checks if a Chunk contains a given value using the default Equivalence. It can be used in two ways: either by passing the value first and then the Chunk, or by passing the Chunk first and then the value.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Chunk-contains.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const contains: { <A>(a: A): (self: Chunk<A>) => boolean; <A>(self: Chunk<A>, a: A): boolean; }\n```\n\n----------------------------------------\n\nTITLE: Creating Micro Effect with Current MicroFiber in TypeScript\nDESCRIPTION: The withMicroFiber function allows creation of a Micro effect using the current MicroFiber implementation. It takes an evaluation function that receives a MicroFiberImpl and returns a Micro effect.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Micro-withMicroFiber.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const withMicroFiber: <A, E = never, R = never>(evaluate: (fiber: MicroFiberImpl<A, E>) => Micro<A, E, R>) => Micro<A, E, R>\n```\n\n----------------------------------------\n\nTITLE: Configuring Environment Variables for Commands in TypeScript\nDESCRIPTION: The Command.env function provides a way to specify environment variables that will be used when running a command. It can be used both as a standalone function or as a method on a Command instance.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Command-env.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const env: { (environment: Record<string, string | undefined>): (self: Command) => Command; (self: Command, environment: Record<string, string | undefined>): Command; }\n```\n\n----------------------------------------\n\nTITLE: Schedule.fromFunction Definition in Typescript\nDESCRIPTION: Creates a schedule that always recurs, transforming input values using the specified function. It continuously executes and applies the given function `f` to each input value, producing a transformed output.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Schedule-fromFunction.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const fromFunction: <A, B>(f: (a: A) => B) => Schedule<B, A>\n```\n\n----------------------------------------\n\nTITLE: Testing Non-strict Greater Than in Order - TypeScript\nDESCRIPTION: This function, `greaterThanOrEqualTo`, determines if one value is non-strictly greater than another using an Order. It returns a boolean result for the comparison. The function depends on an Order instance for the type A, which provides the comparison logic. Key parameters include the Order instance `O`, and the two values `self` and `that` to be compared. No specific input constraints are denoted, and it returns a boolean indicating the comparison result.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Order-greaterThanOrEqualTo.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const greaterThanOrEqualTo: <A>(O: Order<A>) => { (that: A): (self: A) => boolean; (self: A, that: A): boolean; }\n```\n\n----------------------------------------\n\nTITLE: JsonNumber Class Signature in TypeScript\nDESCRIPTION: This code snippet shows the class signature for the JsonNumber schema. It defines the structure of the JsonNumber class used in the Effect library.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Schema-JsonNumber.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare class JsonNumber\n```\n\n----------------------------------------\n\nTITLE: Type Definition for Effect.dieMessage in TypeScript\nDESCRIPTION: Type signature for the Effect.dieMessage function showing it takes a string message parameter and returns an Effect with never type parameters.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-dieMessage.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const dieMessage: (message: string) => Effect<never>\n```\n\n----------------------------------------\n\nTITLE: Providing Context to a Sink in Effect Library (TypeScript)\nDESCRIPTION: A function that provides a Sink with its required context, eliminating its dependency on `R`. It can be used with both curried and uncurried forms.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Sink-provideContext.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const provideContext: { <R>(context: Context.Context<R>): <A, In, L, E>(self: Sink<A, In, L, E, R>) => Sink<A, In, L, E, never>; <A, In, L, E, R>(self: Sink<A, In, L, E, R>, context: Context.Context<R>): Sink<A, In, L, E, never>; }\n```\n\n----------------------------------------\n\nTITLE: RcMap.make Function Signature in TypeScript\nDESCRIPTION: The type signature for the RcMap.make function, showing its overloads for different configuration options. It includes options for lookup function, idle time to live, and capacity.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/RcMap-make.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const make: { <K, A, E, R>(options: { readonly lookup: (key: K) => Effect.Effect<A, E, R>; readonly idleTimeToLive?: Duration.DurationInput | undefined; readonly capacity?: undefined; }): Effect.Effect<RcMap<K, A, E>, never, Scope.Scope | R>; <K, A, E, R>(options: { readonly lookup: (key: K) => Effect.Effect<A, E, R>; readonly idleTimeToLive?: Duration.DurationInput | undefined; readonly capacity: number; }): Effect.Effect<RcMap<K, A, E | Cause.ExceededCapacityException>, never, Scope.Scope | R>; }\n```\n\n----------------------------------------\n\nTITLE: Declaring DateTimeUtcFromSelf Schema in TypeScript\nDESCRIPTION: Defines a schema class named DateTimeUtcFromSelf that represents a DateTime.Utc instance. This schema is part of the effect package's Schema module.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Schema-DateTimeUtcFromSelf.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare class DateTimeUtcFromSelf\n```\n\n----------------------------------------\n\nTITLE: Defining eraseEndLine ANSI Function in TypeScript\nDESCRIPTION: Declares a constant eraseEndLine of type Ansi, which represents an ANSI escape sequence to clear from the current cursor position to the end of the current line. This function does not change the current cursor position.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Ansi-eraseEndLine.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const eraseEndLine: Ansi\n```\n\n----------------------------------------\n\nTITLE: Creating Completed Fiber with Exit Value in TypeScript\nDESCRIPTION: Function signature for creating a fiber that has completed execution with a specified Exit value. Takes a generic Exit type parameter with success type A and error type E, and returns a Fiber instance of the same types.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Fiber-done.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const done: <A, E>(exit: Exit.Exit<A, E>) => Fiber<A, E>\n```\n\n----------------------------------------\n\nTITLE: Calculating Time Zone Offset in ISO Format with TypeScript\nDESCRIPTION: A function that calculates the time zone offset of a DateTime object and returns it formatted as \"±HH:MM\" in ISO standard. It takes a Zoned DateTime object as input and returns a string representation of its timezone offset.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/DateTime-zonedOffsetIso.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const zonedOffsetIso: (self: Zoned) => string\n```\n\n----------------------------------------\n\nTITLE: Checking if a value is PageWidth\nDESCRIPTION: The `isPageWidth` function checks if a given value is a `PageWidth` instance. It returns `true` if the value is a `PageWidth`, and `false` otherwise. It uses a type guard to narrow the type of the input value.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/PageWidth-isPageWidth.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const isPageWidth: (u: unknown) => u is PageWidth\n```\n\n----------------------------------------\n\nTITLE: Declaring Refinement Class in TypeScript\nDESCRIPTION: This TypeScript code declares the `Refinement` class, which is part of the `effect` library. It's used to represent errors that occur during refinement processes. The constructor takes the AST, actual value, refinement kind, and the parse issue as arguments.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/ParseResult-Refinement.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare class Refinement { constructor(\n    readonly ast: AST.Refinement,\n    readonly actual: unknown,\n    readonly kind: \"From\" | \"Predicate\",\n    readonly issue: ParseIssue\n  ) }\n```\n\n----------------------------------------\n\nTITLE: Defining Sequential ExecutionStrategy in TypeScript\nDESCRIPTION: Declares a constant 'sequential' of type ExecutionStrategy. This strategy is used to execute effects sequentially.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/ExecutionStrategy-sequential.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const sequential: ExecutionStrategy\n```\n\n----------------------------------------\n\nTITLE: Implementing Traversable Composition in TypeScript\nDESCRIPTION: This function returns a default binary traverse composition for Traversable instances. It takes two Traversable instances and an Applicative instance, and returns a function that performs a traversal over nested structures.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Traversable-traverseComposition.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const traverseComposition: <T extends TypeLambda, G extends TypeLambda>(T: Traversable<T>, G: Traversable<G>) => <F extends TypeLambda>(F: Applicative<F>) => <TR, TO, TE, GR, GO, GE, A, R, O, E, B>(self: Kind<T, TR, TO, TE, Kind<G, GR, GO, GE, A>>, f: (a: A) => Kind<F, R, O, E, B>) => Kind<F, R, O, E, Kind<T, TR, TO, TE, Kind<G, GR, GO, GE, B>>>\n```\n\n----------------------------------------\n\nTITLE: TypeScript Signature for Config.literal Function\nDESCRIPTION: This code block shows the TypeScript signature for the Config.literal function. It takes an array of literal values and optionally a name, returning a Config object that represents those literal values.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Config-literal.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const literal: <Literals extends ReadonlyArray<LiteralValue>>(...literals: Literals) => (name?: string) => Config<Literals[number]>\n```\n\n----------------------------------------\n\nTITLE: TypeScript Signature of BigDecimal max Function\nDESCRIPTION: This code block shows the TypeScript signature of the max function in the BigDecimal module. It defines two overloads: one for curried usage and another for direct two-argument usage.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/BigDecimal-max.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const max: { (that: BigDecimal): (self: BigDecimal) => BigDecimal; (self: BigDecimal, that: BigDecimal): BigDecimal; }\n```\n\n----------------------------------------\n\nTITLE: Declaring UrlParams.toRecord Function Signature in TypeScript\nDESCRIPTION: This snippet provides the TypeScript signature for the 'UrlParams.toRecord' function, which converts a 'UrlParams' object into a Record structure where each key maps to either a string or an Arr.NonEmptyArray<string>. This function is part of the '@effect/platform' package and requires the 'UrlParams' object as input.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/UrlParams-toRecord.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const toRecord: (self: UrlParams) => Record<string, string | Arr.NonEmptyArray<string>>\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Iterable.range Usage in TypeScript\nDESCRIPTION: This snippet demonstrates how to use the range function from the Iterable module to create a range of integers. It uses Node.js's assert module to verify the output.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Iterable-range.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { range } from \"effect/Iterable\"\n\nassert.deepStrictEqual(Array.from(range(1, 3)), [1, 2, 3])\n```\n\n----------------------------------------\n\nTITLE: Url.mutate Function Signature Declaration\nDESCRIPTION: Defines the TypeScript signature for the Url.mutate function, showing its overloaded nature with support for different method call styles.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Url-mutate.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const mutate: { (f: (url: URL) => void): (self: URL) => URL; (self: URL, f: (url: URL) => void): URL; }\n```\n\n----------------------------------------\n\nTITLE: Defining AlreadyProcessingMessage Error Class in TypeScript\nDESCRIPTION: Defines a class that represents an error condition when an entity is already processing a request in a cluster context. This error is used to handle concurrent processing scenarios.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/ClusterError-AlreadyProcessingMessage.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare class AlreadyProcessingMessage\n```\n\n----------------------------------------\n\nTITLE: Decoding Base64 URL with TypeScript Schema\nDESCRIPTION: This TypeScript snippet declares a constant `Uint8ArrayFromBase64Url` in the Schema module, which decodes base64 (URL) encoded strings into `Uint8Array` instances, beneficial for processing binary data encoded as base64 URL. It is available in v3.10.0 of the library, and uses schemas to define types, requiring TypeScript as a dependency. The function takes a string as input and returns a `Uint8Array` without any additional constraints.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Schema-Uint8ArrayFromBase64Url.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const Uint8ArrayFromBase64Url: Schema<Uint8Array<ArrayBufferLike>, string, never>;\n```\n\n----------------------------------------\n\nTITLE: Example Usage of TupleOfAtLeast Type\nDESCRIPTION: Demonstrates how to use the TupleOfAtLeast type to create tuples with a minimum number of elements, showing valid and invalid type declarations\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Types-TupleOfAtLeast.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { TupleOfAtLeast } from \"effect/Types\"\n\n// A tuple with at least 3 numbers\nconst example1: TupleOfAtLeast<3, number> = [1, 2, 3]; // valid\nconst example2: TupleOfAtLeast<3, number> = [1, 2, 3, 4, 5]; // valid\n// @ts-expect-error\nconst example3: TupleOfAtLeast<3, number> = [1, 2]; // invalid\n```\n\n----------------------------------------\n\nTITLE: Doc.line Function Signature in TypeScript\nDESCRIPTION: The TypeScript signature for the `Doc.line` constant in the `@effect/printer` package. It represents a document that advances to the next line with indentation by default, but can be influenced by grouping operations.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Doc-line.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const line: Doc<never>\n```\n\n----------------------------------------\n\nTITLE: Match.value Function Signature in TypeScript\nDESCRIPTION: Provides the TypeScript type signature for the Match.value function. This function creates a Matcher from a given value, allowing for structured pattern matching on various data types.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Match-value.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const value: <const I>(i: I) => Matcher<I, Types.Without<never>, I, never, I>\n```\n\n----------------------------------------\n\nTITLE: Declaring orElseEither Function in TypeScript\nDESCRIPTION: This snippet defines the `orElseEither` function, which provides a fallback Option. If the initial Option is `None`, it wraps the value from the fallback Option in an Either. The function ensures that users can distinguish whether the value originated from the original Option or the fallback Option using Either.left and Either.right. It requires LazyArg and Option types.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Option-orElseEither.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const orElseEither: { <B>(that: LazyArg\\u003COption\\u003CB\\u003E\\u003E): \\u003CA\\u003E(self: Option\\u003CA\\u003E) => Option\\u003CEither\\u003CB, A\\u003E\\u003E; \\u003CA, B\\u003E(self: Option\\u003CA\\u003E, that: LazyArg\\u003COption\\u003CB\\u003E\\u003E): Option\\u003CEither\\u003CB, A\\u003E\\u003E; }\n```\n\n----------------------------------------\n\nTITLE: Retrieving Fiber from FiberHandle in TypeScript\nDESCRIPTION: The unsafeGet function retrieves the fiber from a FiberHandle. It takes a FiberHandle as input and returns an Option of RuntimeFiber. This function is part of the FiberHandle module in the effect package.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/FiberHandle-unsafeGet.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const unsafeGet: <A, E>(self: FiberHandle<A, E>) => Option.Option<Fiber.RuntimeFiber<A, E>>\n```\n\n----------------------------------------\n\nTITLE: Constructing a Tagged Request in TypeScript\nDESCRIPTION: This function constructs a new `Request` object with a specified tag. It takes a tag parameter corresponding to the `_tag` property of the request type and returns a constructor for requests of that type.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Request-tagged.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const tagged: <R extends Request<any, any> & { _tag: string; }>(tag: R[\"_tag\"]) => Request.Constructor<R, \"_tag\">\n```\n\n----------------------------------------\n\nTITLE: Defining recurUntilEffect Schedule with Async Predicate in TypeScript\nDESCRIPTION: This code snippet declares the 'recurUntilEffect' function, which takes an effectful predicate as an argument and returns a Schedule. The function allows for the condition to be checked asynchronously, making it suitable for scenarios where the stopping condition relies on external computations or state checks.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Schedule-recurUntilEffect.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const recurUntilEffect: <A, R>(f: (a: A) => Effect.Effect<boolean, never, R>) => Schedule<A, A, R>\n```\n\n----------------------------------------\n\nTITLE: Retrieving Cookies with Cookies.get Function in TypeScript\nDESCRIPTION: The Cookies.get function retrieves a cookie from a Cookies object by its name. It returns an Option containing the Cookie if found. The function supports both curried and uncurried calling styles.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Cookies-get.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const get: { (name: string): (self: Cookies) => Option.Option<Cookie>; (self: Cookies, name: string): Option.Option<Cookie>; }\n```\n\n----------------------------------------\n\nTITLE: Zipping Fibers in TypeScript with Effect-TS\nDESCRIPTION: The `zip` function combines two fibers, producing a new fiber that yields a tuple of their outputs. It handles error propagation from both input fibers. This function is useful for parallel execution and combining results of independent computations.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Fiber-zip.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const zip: {\n  <A2, E2>(that: Fiber<A2, E2>): <A, E>(self: Fiber<A, E>) => Fiber<[A, A2], E2 | E>;\n  <A, E, A2, E2>(self: Fiber<A, E>, that: Fiber<A2, E2>): Fiber<[A, A2], E | E2>;\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Reentrant Read/Write Lock with TReentrantLock.make in TypeScript\nDESCRIPTION: The make function creates a new reentrant read/write lock using the STM (Software Transactional Memory) system. It returns an STM computation that, when executed, produces a new TReentrantLock instance.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TReentrantLock-make.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const make: STM.STM<TReentrantLock, never, never>\n```\n\n----------------------------------------\n\nTITLE: Checking if a TPubSub Contains Elements in TypeScript\nDESCRIPTION: Function that returns true if the TPubSub contains at least one element, false otherwise. It operates within an STM transactional context.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TPubSub-isFull.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const isFull: <A>(self: TPubSub<A>) => STM.STM<boolean>\n```\n\n----------------------------------------\n\nTITLE: Function Signature for modifyNonEmptyHead in TypeScript\nDESCRIPTION: The TypeScript type signature for the modifyNonEmptyHead function. It shows the function can be used in both curried and non-curried forms, accepting a non-empty array and a transformation function that converts elements of type A to type B.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Array-modifyNonEmptyHead.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const modifyNonEmptyHead: { <A, B>(f: (a: A) => B): (self: NonEmptyReadonlyArray<A>) => NonEmptyArray<A | B>; <A, B>(self: NonEmptyReadonlyArray<A>, f: (a: A) => B): NonEmptyArray<A | B>; }\n```\n\n----------------------------------------\n\nTITLE: TypeScript Function Signature for Match.withReturnType\nDESCRIPTION: This code snippet shows the TypeScript function signature for the Match.withReturnType function. It defines the function's type parameters and return type, which is used to enforce type consistency in pattern matching.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Match-withReturnType.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const withReturnType: <Ret>() => <I, F, R, A, Pr, _>(self: Matcher<I, F, R, A, Pr, _>) => [Ret] extends [[A] extends [never] ? any : A] ? Matcher<I, F, R, A, Pr, Ret> : \"withReturnType constraint does not extend Result type\"\n```\n\n----------------------------------------\n\nTITLE: Metric.frequency Function Signature in TypeScript\nDESCRIPTION: The signature of the Metric.frequency function, which creates a Frequency metric. It takes a name string and optional options including description and preregistered words.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Metric-frequency.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const frequency: (name: string, options?: { readonly description?: string | undefined; readonly preregisteredWords?: ReadonlyArray<string> | undefined; } | undefined) => Metric.Frequency<string>\n```\n\n----------------------------------------\n\nTITLE: Retrieving Random Service in Effect\nDESCRIPTION: Defines a constant that retrieves the Random service from the Effect context. Returns an Effect that requires Random.Random dependency with never as both error and success types.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-random.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const random: Effect<Random.Random, never, never>\n```\n\n----------------------------------------\n\nTITLE: Running Effects Synchronously with Exit Results in Effect-TS\nDESCRIPTION: The runSyncExit function executes an Effect synchronously and returns the Exit result. This function is effectful and should only be invoked at the edges of a program. It supports both curried and uncurried calling styles.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Runtime-runSyncExit.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const runSyncExit: { <A, E, R>(runtime: Runtime<R>, effect: Effect.Effect<A, E, R>): Exit.Exit<A, E>; <R>(runtime: Runtime<R>): <A, E>(effect: Effect.Effect<A, E, R>) => Exit.Exit<A, E>; }\n```\n\n----------------------------------------\n\nTITLE: Declaring Empty TSet Function in TypeScript\nDESCRIPTION: This code snippet declares a constant named 'empty' which is a function that takes a generic type parameter 'A' and returns an STM instance containing an empty TSet of type A. It allows users to create an empty TSet for any specified type.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TSet-empty.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const empty: <A>() => STM.STM<TSet<A>>\n```\n\n----------------------------------------\n\nTITLE: Creating a Take with Single Value in TypeScript\nDESCRIPTION: The 'of' function creates a Take with a single value chunk. It takes a generic type parameter A and returns a Take<A>.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Take-of.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const of: <A>(value: A) => Take<A>\n```\n\n----------------------------------------\n\nTITLE: Declaring None in STM Module TypeScript\nDESCRIPTION: This TypeScript snippet declares an STM operation that ensures the option produced is None. It is useful in cases where effect computations need to guarantee the absence of a value (None) without failing. Dependencies include the Option library from Effect-TS, and key parameters include the STM instance and its expected void output. The input is an STM effect with an optional return, and the output is an STM effect with a void return type. Since this feature appears in v2.0.0, users should ensure compatibility.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/STM-none.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const none: <A, E, R>(self: STM<Option.Option<A>, E, R>) => STM<void, Option.Option<E>, R>\n```\n\n----------------------------------------\n\nTITLE: Trie.modify Function Signature in TypeScript\nDESCRIPTION: The type signature for the Trie.modify function, which takes a key and a modification function to update values in a Trie. It supports both curried and uncurried forms for flexibility in usage.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Trie-modify.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const modify: { <V1, V>(key: string, f: (v: V) => V1): (self: Trie<V>) => Trie<V1 | V>; <V1, V>(self: Trie<V>, key: string, f: (v: V) => V1): Trie<V | V1>; }\n```\n\n----------------------------------------\n\nTITLE: Clamping a Number with Effect Order in Typescript\nDESCRIPTION: This code snippet demonstrates the usage of `Order.clamp` to limit a number between a minimum and maximum value. It utilizes the `Number.Order` to provide the necessary ordering for numbers and then clamps the input values accordingly, showing how values outside the range are adjusted to fit within the specified bounds.  The example uses `node:assert` to verify the clamp function.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Order-clamp.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { Order, Number } from \"effect\"\n\nconst clamp = Order.clamp(Number.Order)({ minimum: 1, maximum: 5 })\n\nassert.equal(clamp(3), 3)\nassert.equal(clamp(0), 1)\nassert.equal(clamp(6), 5)\n```\n\n----------------------------------------\n\nTITLE: Number SemigroupMultiply Declaration (TypeScript)\nDESCRIPTION: This code snippet declares the `SemigroupMultiply` constant as a semigroup for numbers. It utilizes the `semigroup.Semigroup<number>` type, indicating that it provides a binary operation for combining numbers within the context of a semigroup.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/data-Number-SemigroupMultiply.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const SemigroupMultiply: semigroup.Semigroup<number>\n```\n\n----------------------------------------\n\nTITLE: Combining FiberIds in Effect.ts\nDESCRIPTION: The combineAll function takes a HashSet of FiberId objects and combines them into a single FiberId. This is useful when you need to represent multiple fibers as a single logical unit.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/FiberId-combineAll.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const combineAll: (fiberIds: HashSet.HashSet<FiberId>) => FiberId\n```\n\n----------------------------------------\n\nTITLE: Mapping Error Cause in Exit Objects in TypeScript\nDESCRIPTION: This function maps over the Cause contained in the Failure of a specified exit using a provided transformation function. It allows transforming error types within exit values while preserving the success path.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Exit-mapErrorCause.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const mapErrorCause: { <E, E2>(f: (cause: Cause.Cause<E>) => Cause.Cause<E2>): <A>(self: Exit<A, E>) => Exit<A, E2>; <E, A, E2>(self: Exit<A, E>, f: (cause: Cause.Cause<E>) => Cause.Cause<E2>): Exit<A, E2>; }\n```\n\n----------------------------------------\n\nTITLE: Defining Logical Implication with Predicate.implies in TypeScript\nDESCRIPTION: This snippet defines the 'implies' function for managing logical implications within predicate conditions in TypeScript. It utilizes two predicates: an antecedent and a consequent, ensuring that if the antecedent holds true, the consequent must also hold. The function illustrates the principle of transitivity with a practical example.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Predicate-implies.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { Predicate } from \"effect\"\n\ntype Triple = {\n  readonly a: number\n  readonly b: number\n  readonly c: number\n}\n\nconst transitivity = Predicate.implies(\n  // antecedent\n  (input: Triple) => input.a <= input.b && input.b <= input.c,\n  // consequent\n  (input: Triple) => input.a <= input.c\n)\n\nassert.equal(transitivity({ a: 1, b: 2, c: 3 }), true)\n// antecedent is `false`, so the result is `true`\nassert.equal(transitivity({ a: 1, b: 0, c: 0 }), true)\n```\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const implies: { <A>(consequent: Predicate<A>): (antecedent: Predicate<A>) => Predicate<A>; <A>(antecedent: Predicate<A>, consequent: Predicate<A>): Predicate<A>; }\n```\n\n----------------------------------------\n\nTITLE: Removing Time from DateTime in TypeScript using Effect Package\nDESCRIPTION: This snippet demonstrates how to use the removeTime function from the DateTime module. It removes the time aspect of a DateTime object, adjusting for the time zone, and returns a DateTime.Utc containing only the date.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/DateTime-removeTime.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { DateTime } from \"effect\"\n\n// returns \"2024-01-01T00:00:00Z\"\nDateTime.unsafeMakeZoned(\"2024-01-01T05:00:00Z\", {\n  timeZone: \"Pacific/Auckland\",\n  adjustForTimeZone: true\n}).pipe(\n  DateTime.removeTime,\n  DateTime.formatIso\n)\n```\n\n----------------------------------------\n\nTITLE: Defining a Single Quote Document in Effect Printer\nDESCRIPTION: Defines a constant `squote` that represents a document containing a single quote character (`'`). This is a utility for including single quotes in formatted documents without needing to escape them.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Doc-squote.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const squote: Doc<never>\n```\n\n----------------------------------------\n\nTITLE: Constructing a new Request with Request.of in TypeScript\nDESCRIPTION: The Request.of function constructs a new Request object. It returns a constructor for the specified Request type parameter. This function is available since version 2.0.0 of the effect package.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Request-of.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const of: <R extends Request<any, any>>() => Request.Constructor<R>\n```\n\n----------------------------------------\n\nTITLE: Declaring Default Effect Test Services in TypeScript\nDESCRIPTION: This code snippet declares a constant named liveServices that represents the default Effect test services. It is of type Context.Context<TestServices>.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TestServices-liveServices.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const liveServices: Context.Context<TestServices>\n```\n\n----------------------------------------\n\nTITLE: Type Signature of Effect.dropUntil Function in TypeScript\nDESCRIPTION: This code snippet shows the type signature of the Effect.dropUntil function. It's an overloaded function that can either take a predicate and return a function that takes an iterable, or take both an iterable and a predicate directly.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-dropUntil.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const dropUntil: { <A, E, R>(predicate: (a: NoInfer<A>, i: number) => Effect<boolean, E, R>): (elements: Iterable<A>) => Effect<Array<A>, E, R>; <A, E, R>(elements: Iterable<A>, predicate: (a: A, i: number) => Effect<boolean, E, R>): Effect<Array<A>, E, R>; }\n```\n\n----------------------------------------\n\nTITLE: Defining Well-Known Response Formats in TypeScript\nDESCRIPTION: This TypeScript snippet defines a type named `WellKnownResponseFormat` for specifying well-known response formats used in OpenAI telemetry. It encompasses predefined options including \"json_object\", \"json_schema\", and \"text\". The intended use is to enforce standard response formats unless a custom format is necessary.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/OpenAiTelemetry-OpenAiTelemetry.WellKnownResponseFormat.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ntype WellKnownResponseFormat = \"json_object\" | \"json_schema\" | \"text\"\n```\n\n----------------------------------------\n\nTITLE: Implementing List.take Function in TypeScript\nDESCRIPTION: Function declaration for taking N elements from the beginning of a List. Supports both curried and uncurried calling styles, allowing either passing the number first or the list first.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/List-take.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const take: { (n: number): <A>(self: List<A>) => List<A>; <A>(self: List<A>, n: number): List<A>; }\n```\n\n----------------------------------------\n\nTITLE: Linearizing Causes in TypeScript using Effect Package\nDESCRIPTION: The linearize function takes a Cause<E> and returns a HashSet of Cause<E>. It reorganizes the cause structure into parallel causes, each containing a sequential chain of failures. This allows for separate analysis of each parallel branch, even with multiple sequential errors.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Cause-linearize.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const linearize: <E>(self: Cause<E>) => HashSet.HashSet<Cause<E>>\n```\n\n----------------------------------------\n\nTITLE: Defining Prompt Action Types in TypeScript for CLI Interactions\nDESCRIPTION: This code snippet defines a union type representing different actions a CLI prompt can take. It includes 'Beep' for alerting, 'NextFrame' for updating the prompt state, and 'Submit' for finalizing user input. The type uses a tagged enum structure for type discrimination.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Prompt-Prompt.Action.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ntype { readonly _tag: \"Beep\"; } | { readonly _tag: \"NextFrame\"; readonly state: State; } | { readonly _tag: \"Submit\"; readonly value: Output; } = TaggedEnum<{\n    readonly Beep: {}\n    readonly NextFrame: { readonly state: State }\n    readonly Submit: { readonly value: Output }\n  }>\n```\n\n----------------------------------------\n\nTITLE: Declaring Fail Sync Functionality in TypeScript\nDESCRIPTION: This snippet declares the 'failSync' constant which is a function that takes a lazily evaluated error and returns a Sink that never succeeds. This utility is useful for error handling within a functional programming paradigm, particularly in asynchronous contexts. The function is generic and uses type parameters to specify the error type.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Sink-failSync.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const failSync: <E>(evaluate: LazyArg<E>) => Sink<never, unknown, never, E>\n```\n\n----------------------------------------\n\nTITLE: Declaring awaitEmpty Function in FiberMap Module (TypeScript)\nDESCRIPTION: This code snippet defines the awaitEmpty function in the FiberMap module. The function waits for the FiberMap to be empty and returns an Effect. It takes a FiberMap as an argument and returns an Effect that resolves to void or an error of type E.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/FiberMap-awaitEmpty.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const awaitEmpty: <K, A, E>(self: FiberMap<K, A, E>) => Effect.Effect<void, E>\n```\n\n----------------------------------------\n\nTITLE: Checking for MissingData ConfigError in Effect.io\nDESCRIPTION: A utility function that checks if a ConfigError is specifically of type MissingData. Returns true if the error is a MissingData instance, false otherwise. Used for type narrowing in TypeScript.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/ConfigError-isMissingData.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const isMissingData: (self: ConfigError) => self is MissingData\n```\n\n----------------------------------------\n\nTITLE: TraversableFilterable.traverseFilterMap in TypeScript\nDESCRIPTION: Provides a default binary implementation for `traverseFilterMap` using `Traversable` and `Filterable` typeclasses. It takes a `Traversable` and `Filterable` type `T`, an `Applicative` type `F`, a traversable structure `self` of type `Kind<T, TR, TO, TE, A>`, and a function `f` that maps elements of type `A` to `Kind<F, R, O, E, Option<B>>`. The function returns a `Kind<F, R, O, E, Kind<T, TR, TO, TE, B>>`.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TraversableFilterable-traverseFilterMap.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const traverseFilterMap: <T extends TypeLambda>(T: Traversable<T> & Filterable<T>) => <F extends TypeLambda>(F: Applicative<F>) => <TR, TO, TE, A, R, O, E, B>(self: Kind<T, TR, TO, TE, A>, f: (a: A) => Kind<F, R, O, E, Option<B>>) => Kind<F, R, O, E, Kind<T, TR, TO, TE, B>>\n```\n\n----------------------------------------\n\nTITLE: Type Signature of isTupleOf Function in TypeScript\nDESCRIPTION: Provides the type signature for the isTupleOf function, showing its overloaded nature. It can be called with the length parameter first or second, and uses generics to maintain type information.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Predicate-isTupleOf.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const isTupleOf: { <N extends number>(n: N): <T>(self: ReadonlyArray<T>) => self is TupleOf<N, T>; <T, N extends number>(self: ReadonlyArray<T>, n: N): self is TupleOf<N, T>; }\n```\n\n----------------------------------------\n\nTITLE: Transforming MicroSchedule with Maximum Delay - TypeScript\nDESCRIPTION: The 'scheduleWithMaxDelay' function allows users to create a MicroSchedule that adheres to a specified maximum delay. It can be called with either the maximum delay first or the MicroSchedule first, demonstrating function overloading in TypeScript.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Micro-scheduleWithMaxDelay.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const scheduleWithMaxDelay: { (max: number): (self: MicroSchedule) => MicroSchedule; (self: MicroSchedule, max: number): MicroSchedule; }\n```\n\n----------------------------------------\n\nTITLE: Initializing ShardManager Layer without HTTP Server in TypeScript\nDESCRIPTION: Creates a Layer for the ShardManager service that provides only the Runners RPC client functionality without running a server. The layer can be combined with toHttpApp and toHttpAppWebsocket APIs for a complete ShardManager server implementation.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/HttpShardManager-layerNoServerHttp.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const layerNoServerHttp: (options: { readonly runnerPath: string; readonly runnerHttps?: boolean | undefined; }) => Layer.Layer<ShardManager.ShardManager, never, RpcSerialization.RpcSerialization | ShardStorage | RunnerHealth.RunnerHealth | HttpClient.HttpClient | ShardManager.Config | ShardingConfig>\n```\n\n----------------------------------------\n\nTITLE: Defining IllegalArgumentException Interface in TypeScript\nDESCRIPTION: Defines an interface for representing invalid argument errors. It extends YieldableError and includes a type tag and type ID for type safety and identification purposes.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Cause-IllegalArgumentException.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface IllegalArgumentException extends YieldableError {\n  readonly _tag: \"IllegalArgumentException\"\n  readonly [IllegalArgumentExceptionTypeId]: IllegalArgumentExceptionTypeId\n}\n```\n\n----------------------------------------\n\nTITLE: Function Signature for Array.filterMapWhile in TypeScript\nDESCRIPTION: The type signature for the filterMapWhile function in the Array module. It supports both curried and non-curried invocation patterns, taking a function that transforms elements to Option<B> and an iterable collection.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Array-filterMapWhile.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const filterMapWhile: { <A, B>(f: (a: A, i: number) => Option.Option<B>): (self: Iterable<A>) => Array<B>; <A, B>(self: Iterable<A>, f: (a: A, i: number) => Option.Option<B>): Array<B>; }\n```\n\n----------------------------------------\n\nTITLE: Declaring Generated Column Schema in TypeScript\nDESCRIPTION: Function for creating a field that represents a column that is generated by the database. This column type is available for selection and update operations, but cannot be used for insertion operations.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Model-Generated.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const Generated: <S extends Schema.Schema.All | Schema.PropertySignature.All>(schema: S) => Generated<S>\n```\n\n----------------------------------------\n\nTITLE: Defining All Schema Types in TypeScript for Effect Framework\nDESCRIPTION: This code snippet defines the 'All' type, which represents any possible schema in the Effect framework. It includes Any, Schema with any input and never output, Schema with never input and any output, and Schema with never input and never output.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Schema-Schema.All.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ntype All = | Any\n    | Schema<any, never, unknown>\n    | Schema<never, any, unknown>\n    | Schema<never, never, unknown>\n```\n\n----------------------------------------\n\nTITLE: Using Array.dedupeWith for Element Deduplication in TypeScript\nDESCRIPTION: Example showing how to remove duplicate elements from an array using a custom equivalence function. The function preserves the order of first occurrences of each element.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Array-dedupeWith.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Array } from \"effect\"\n\nconst result = Array.dedupeWith([1, 2, 2, 3, 3, 3], (a, b) => a === b)\nconsole.log(result) // [1, 2, 3]\n```\n\n----------------------------------------\n\nTITLE: Converting TPriorityQueue to Chunk in Effect-TS\nDESCRIPTION: This function collects all values from a TPriorityQueue into a Chunk data structure. It operates within the STM (Software Transactional Memory) context, allowing for composable transactional operations.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TPriorityQueue-toChunk.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const toChunk: <A>(self: TPriorityQueue<A>) => STM.STM<Chunk.Chunk<A>>\n```\n\n----------------------------------------\n\nTITLE: HashSet.has Type Definition\nDESCRIPTION: The TypeScript type definition for the HashSet.has method, showing its function signatures for both data-first and data-last (pipeable) styles.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/HashSet-has.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const has: { <A>(value: A): (self: HashSet<A>) => boolean; <A>(self: HashSet<A>, value: A): boolean; }\n```\n\n----------------------------------------\n\nTITLE: Type Signature for Array.contains Function in TypeScript\nDESCRIPTION: Provides the type signature for the Array.contains function. It shows that the function can be used in two ways: either by passing the value to check first, or by passing the array first followed by the value to check.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Array-contains.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const contains: { <A>(a: A): (self: Iterable<A>) => boolean; <A>(self: Iterable<A>, a: A): boolean; }\n```\n\n----------------------------------------\n\nTITLE: Declaring Conditional Schedule Execution with Effect-TS in TypeScript\nDESCRIPTION: The `checkEffect` function allows users to customize schedule execution by applying an effectful test function to each input-output pair. It decides whether the schedule should continue based on the test function returning `true` or halt if returning `false`. This is valuable in scenarios requiring decisions affected by asynchronous operations like API calls. It requires familiarity with the Effect-TS library and its `Effect` type.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Schedule-checkEffect.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const checkEffect: { <In, Out, R2>(test: (input: In, output: Out) => Effect.Effect<boolean, never, R2>): <R>(self: Schedule<Out, In, R>) => Schedule<Out, In, R2 | R>; <Out, In, R, R2>(self: Schedule<Out, In, R>, test: (input: In, output: Out) => Effect.Effect<boolean, never, R2>): Schedule<Out, In, R | R2>; }\n```\n\n----------------------------------------\n\nTITLE: TypeScript signature for Doc.catWithSpace function\nDESCRIPTION: The type signature for the catWithSpace function, showing it supports both curried and non-curried calling styles. It takes two Doc parameters and returns a new Doc that combines the type parameters of both input documents.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Doc-catWithSpace.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const catWithSpace: { <B>(that: Doc<B>): <A>(self: Doc<A>) => Doc<B | A>; <A, B>(self: Doc<A>, that: Doc<B>): Doc<A | B>; }\n```\n\n----------------------------------------\n\nTITLE: Defining refineOrDie Function - TypeScript\nDESCRIPTION: The 'refineOrDie' function is defined to handle errors within a stream. It allows for selective retention of certain errors while terminating the processing for others, thus controlling the flow of execution based on error types. The function supports both currying and direct parameter passing, accommodating various usage patterns in stream processing.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-refineOrDie.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const refineOrDie: { <E, E2>(pf: (error: E) => Option.Option<E2>): <A, R>(self: Stream<A, E, R>) => Stream<A, E2, R>; <A, E, R, E2>(self: Stream<A, E, R>, pf: (error: E) => Option.Option<E2>): Stream<A, E2, R>; };\n\n```\n\n----------------------------------------\n\nTITLE: Declaring the isFunction Predicate in TypeScript\nDESCRIPTION: This code snippet declares the `isFunction` predicate as a function that takes an unknown input and returns a boolean indicating whether the input is a function. The type guard `input is Function` is used to narrow the type of the input to `Function` if the predicate returns `true`.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Predicate-isFunction.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const isFunction: (input: unknown) => input is Function\n```\n\n----------------------------------------\n\nTITLE: Extracting Right Values from Record Using TypeScript\nDESCRIPTION: This code snippet demonstrates the usage of the Record.getRights function by filtering a record of Either values to return a new record containing only the Right values. It utilizes assertions to validate the output against the expected result.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Record-getRights.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { Record, Either } from \"effect\"\n\nassert.deepStrictEqual(\n  Record.getRights({ a: Either.right(1), b: Either.left(\"err\"), c: Either.right(2) }),\n  { a: 1, c: 2 }\n)\n```\n\n----------------------------------------\n\nTITLE: Extracting Value Type from HashMap in TypeScript\nDESCRIPTION: This code snippet demonstrates how to use the HashMap.HashMap.Value type-level utility to extract the value type V from a HashMap<K, V> type. It provides an example usage and the type signature.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/HashMap-HashMap.Value.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { HashMap } from \"effect\"\n\ndeclare const hm: HashMap.HashMap<string, number>\n\n// $ExpectType number\ntype V = HashMap.HashMap.Value<typeof hm>\n```\n\nLANGUAGE: typescript\nCODE:\n```\ntype Value<T> = [T] extends [HashMap<infer _K, infer _V>] ? _V : never\n```\n\n----------------------------------------\n\nTITLE: Trie.entries function signature in Typescript\nDESCRIPTION: This snippet shows the Typescript declaration of the `Trie.entries` function. It takes a `Trie` as input and returns an `IterableIterator` that yields key-value pairs (strings and the value type of the Trie).\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Trie-entries.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const entries: <V>(self: Trie<V>) => IterableIterator<[string, V]>\n```\n\n----------------------------------------\n\nTITLE: Declaring Unfold Function for Schedule Creation in TypeScript\nDESCRIPTION: Defines the unfold function that creates a schedule by repeatedly applying a transformation function to an initial state. The schedule continues indefinitely, producing a stream of values by unfolding the state over time.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Schedule-unfold.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const unfold: <A>(initial: A, f: (a: A) => A) => Schedule<A>\n```\n\n----------------------------------------\n\nTITLE: Declaring equalSign Document Constant in TypeScript\nDESCRIPTION: Defines a Doc constant named equalSign that represents a single = character. The constant has a type parameter of never, indicating it doesn't require any additional context.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Doc-equalSign.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const equalSign: Doc<never>\n```\n\n----------------------------------------\n\nTITLE: Configuring Schema Property Signature Default Decoding in TypeScript\nDESCRIPTION: Defines a function that enhances a property signature by providing a default decoding value. The function supports both curried and uncurried forms, allowing flexible usage patterns when setting default values for optional properties.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Schema-withDecodingDefault.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const withDecodingDefault: { <Type>(defaultValue: () => Types.NoInfer<Exclude<Type, undefined>>): <Key extends PropertyKey, Encoded, R>(self: PropertySignature<\"?:\", Type, Key, \"?:\", Encoded, false, R>) => PropertySignature<\":\", Exclude<Type, undefined>, Key, \"?:\", Encoded, false, R>; <Type, Key extends PropertyKey, Encoded, R>(self: PropertySignature<\"?:\", Type, Key, \"?:\", Encoded, false, R>, defaultValue: () => Types.NoInfer<Exclude<Type, undefined>>): PropertySignature<\":\", Exclude<Type, undefined>, Key, \"?:\", Encoded, false, R>; }\n```\n\n----------------------------------------\n\nTITLE: Accessing Sink Context in TypeScript\nDESCRIPTION: The 'contextWith' function takes a function 'f' that accepts a context parameter and returns a value of type 'Z'. This function returns a Sink instance parameterized with the output type 'Z' and input type reflecting any unknowns, with 'never' representing the failure cases. It is crucial for setting up the context-based operations in effectful programming using the Effect library.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Sink-contextWith.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const contextWith: <R, Z>(f: (context: Context.Context<R>) => Z) => Sink<Z, unknown, never, never, R>\n```\n\n----------------------------------------\n\nTITLE: TypeScript Function Signature for Array.replace in Effect Library\nDESCRIPTION: Provides the TypeScript function signature for the Array.replace function in the Effect library. It shows the function's type definition, including its parameters and return type.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Array-replace.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const replace: { <B>(i: number, b: B): <A, S extends Iterable<A> = Iterable<A>>(self: S) => ReadonlyArray.With<S, ReadonlyArray.Infer<S> | B>; <A, B, S extends Iterable<A> = Iterable<A>>(self: S, i: number, b: B): ReadonlyArray.With<S, ReadonlyArray.Infer<S> | B>; }\n```\n\n----------------------------------------\n\nTITLE: Type Signature for Array.getLefts Function in TypeScript\nDESCRIPTION: The type signature for the getLefts function, showing it accepts an Iterable of Either objects and returns an array containing only the Left values extracted from the iterable.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Array-getLefts.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const getLefts: <T extends Iterable<Either.Either<any, any>>>(self: T) => Array<Either.Either.Left<ReadonlyArray.Infer<T>>>\n```\n\n----------------------------------------\n\nTITLE: Effect.catchAll Function Signature in TypeScript\nDESCRIPTION: The TypeScript signature for the Effect.catchAll function. It shows the function's type definition, including its parameters and return type.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-catchAll.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const catchAll: { <E, A2, E2, R2>(f: (e: E) => Effect<A2, E2, R2>): <A, R>(self: Effect<A, E, R>) => Effect<A2 | A, E2, R2 | R>; <A, E, R, A2, E2, R2>(self: Effect<A, E, R>, f: (e: E) => Effect<A2, E2, R2>): Effect<A2 | A, E2, R2 | R>; }\n```\n\n----------------------------------------\n\nTITLE: Constructing Annotations Layer in TestServices Module\nDESCRIPTION: This function constructs a new `Annotations` service wrapped in a layer. It is part of the TestServices module in the Effect library and is used for handling test annotations.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TestServices-annotationsLayer.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const annotationsLayer: () => Layer.Layer<Annotations.TestAnnotations>\n```\n\n----------------------------------------\n\nTITLE: Stream.take Signature\nDESCRIPTION: This snippet shows the type signature of the `Stream.take` function in Effect. It highlights how the function can be called with the stream as the first argument or with the number of elements to take as the first argument and then curried with the stream. `Stream<A, E, R>` represents a stream of type A, potentially failing with error E, and requiring environment R.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-take.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const take: { (n: number): <A, E, R>(self: Stream<A, E, R>) => Stream<A, E, R>; <A, E, R>(self: Stream<A, E, R>, n: number): Stream<A, E, R>; }\n```\n\n----------------------------------------\n\nTITLE: Defining toPartsUtc Function in TypeScript for DateTime Conversion\nDESCRIPTION: This code snippet defines the toPartsUtc function, which takes a DateTime object and returns its parts as a DateTime.PartsWithWeekday object in UTC. The function is part of the DateTime module in the effect package.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/DateTime-toPartsUtc.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const toPartsUtc: (self: DateTime) => DateTime.PartsWithWeekday\n```\n\n----------------------------------------\n\nTITLE: Defining Stream.scopedWith in Effect (TypeScript)\nDESCRIPTION: Defines the `scopedWith` function which creates a stream using a function that receives a scope and returns an effect. The function's return type is `Stream<A, E, R>`, where `A` is the output type, `E` is the error type, and `R` is the environment type.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-scopedWith.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const scopedWith: <A, E, R>(f: (scope: Scope.Scope) => Effect.Effect<A, E, R>) => Stream<A, E, R>\n```\n\n----------------------------------------\n\nTITLE: Defining lparen Constant in TypeScript for @effect/printer Doc Module\nDESCRIPTION: Declares a constant named lparen of type Doc<never>, representing a document containing a single '(' character. This is part of the @effect/printer package's Doc module.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Doc-lparen.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const lparen: Doc<never>\n```\n\n----------------------------------------\n\nTITLE: Computing Interval Union in TypeScript\nDESCRIPTION: This TypeScript function, `union`, computes the union of two `Interval` objects, returning a `Some` of an `Interval` if a union is possible, or `None` otherwise. This is part of the Effect TS library and requires the `Interval` and `Option` types from the library. It can be invoked in curried form by providing the `that` Interval first and then the `self` Interval, or directly by providing both Intervals. The output is an `Option` containing the resulting `Interval`.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/ScheduleInterval-union.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const union: { (that: Interval): (self: Interval) => Option.Option<Interval>; (self: Interval, that: Interval): Option.Option<Interval>; }\n```\n\n----------------------------------------\n\nTITLE: BigInt.clamp Function Signature in TypeScript\nDESCRIPTION: The type signature for the BigInt.clamp function, showing it can be called in two ways: either by providing options first and then the BigInt value, or by providing the BigInt value first followed by the options object.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/BigInt-clamp.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const clamp: { (options: { minimum: bigint; maximum: bigint; }): (self: bigint) => bigint; (self: bigint, options: { minimum: bigint; maximum: bigint; }): bigint; }\n```\n\n----------------------------------------\n\nTITLE: Launching with WorkerRunner in TypeScript\nDESCRIPTION: This TypeScript snippet declares the function `launch`, which is used to initiate a specified layer and handles fiber interruptions when a CloseLatch condition is met. It is a part of the WorkerRunner module in the `@effect/platform` package. The function takes a layer as input and returns an effect, integrating with the Effect TS framework. Key dependencies include the Effect TS library and its Layer module. The snippet defines the signature and parameters for the `launch` function.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/WorkerRunner-launch.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const launch: <A, E, R>(layer: Layer.Layer<A, E, R>) => Effect.Effect<void, E | WorkerError, R>\n```\n\n----------------------------------------\n\nTITLE: Using Array.findLastIndex in TypeScript\nDESCRIPTION: This example demonstrates how to use the Array.findLastIndex function to locate the last index in an array where an element satisfies a given condition. The function returns an Option.some with the index if found, or Option.none if no element matches the predicate.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Array-findLastIndex.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Array } from \"effect\"\n\nconst result = Array.findLastIndex([1, 3, 8, 9], x => x < 5)\nconsole.log(result) // Option.some(1)\n```\n\n----------------------------------------\n\nTITLE: Retrieving Random Boolean Values with TRandom in TypeScript\nDESCRIPTION: Defines the nextBoolean function that returns the next boolean value from the pseudo-random number generator in an STM context. This function returns a value of type boolean, never produces an error, and requires a TRandom context.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TRandom-nextBoolean.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const nextBoolean: STM.STM<boolean, never, TRandom>\n```\n\n----------------------------------------\n\nTITLE: Declaring CurrentAddress Class in Entity Module\nDESCRIPTION: Defines the CurrentAddress class which serves as a Context.Tag to access the current entity address in Effect applications. This is a fundamental component for entity-based operations in the cluster module.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Entity-CurrentAddress.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare class CurrentAddress\n```\n\n----------------------------------------\n\nTITLE: Type Definition for decrement Function in TypeScript\nDESCRIPTION: Shows the TypeScript type signature for the decrement function. It takes a bigint parameter and returns a bigint value that is one less than the input.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/BigInt-decrement.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const decrement: (n: bigint) => bigint\n```\n\n----------------------------------------\n\nTITLE: Type Signature of Minimum Function in Effect-TS\nDESCRIPTION: This snippet provides the TypeScript signature for the `min` function, detailing its overloads. The function can be invoked in two ways: either providing the second number as a parameter to the returned function or passing both numbers directly. This flexibility is important for various use cases in TypeScript.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Number-min.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const min: { (that: number): (self: number) => number; (self: number, that: number): number; }\n```\n\n----------------------------------------\n\nTITLE: Updating Hostname in URL Using TypeScript\nDESCRIPTION: This snippet declares a function 'setHostname' that can be used to update the hostname of a URL object. It has a dual signature, allowing it to either take the hostname first followed by the URL or the URL first followed by the hostname. This provides flexibility in how developers can utilize the function in their TypeScript projects.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Url-setHostname.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const setHostname: { (hostname: string): (url: URL) => URL; (url: URL, hostname: string): URL; }\n```\n\n----------------------------------------\n\nTITLE: Declaration of Array.sort function in TypeScript\nDESCRIPTION: Defines the sort function signature that creates a new array with elements sorted in increasing order based on a specified comparator. If the input is a NonEmptyReadonlyArray, the output will also be a NonEmptyReadonlyArray.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Array-sort.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const sort: { <B>(O: Order.Order<B>): <A extends B, S extends Iterable<A>>(self: S) => ReadonlyArray.With<S, ReadonlyArray.Infer<S>>; <A extends B, B>(self: NonEmptyReadonlyArray<A>, O: Order.Order<B>): NonEmptyArray<A>; <A extends B, B>(self: Iterable<A>, O: Order.Order<B>): Array<A>; }\n```\n\n----------------------------------------\n\nTITLE: Declaring multiplyAll function in TypeScript\nDESCRIPTION: This code snippet presents the TypeScript declaration of the `multiplyAll` function. The function takes an `Iterable` of numbers as input and returns a single number, which is the product of all the numbers in the input iterable.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Number-multiplyAll.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const multiplyAll: (collection: Iterable<number>) => number\n```\n\n----------------------------------------\n\nTITLE: Updating Username for URL Authentication - TypeScript\nDESCRIPTION: This code snippet defines the `setUsername` function, which updates the username used for authentication in a URL context. It supports two signatures: one for providing the username first and then the URL, and another for the reverse order. The function returns the updated URL object.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Url-setUsername.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const setUsername: { (username: string): (url: URL) => URL; (url: URL, username: string): URL; }\n```\n\n----------------------------------------\n\nTITLE: Optimize Interface in Typescript\nDESCRIPTION: Defines the `Optimize` interface, a function type representing the optimization of a document tree. The function takes a depth parameter (`Optimize.Depth`) and returns a document (`Doc<A>`). This interface is central to the module's purpose of fusing redundant document nodes.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Optimize-Optimize.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface Optimize<A> {\n  (depth: Optimize.Depth): Doc<A>\n}\n```\n\n----------------------------------------\n\nTITLE: Defining RuntimeException Interface in TypeScript\nDESCRIPTION: Declares the RuntimeException interface that represents recoverable runtime errors. It extends YieldableError and contains a _tag property with the value \"RuntimeException\" and a RuntimeExceptionTypeId symbol property.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Cause-RuntimeException.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface RuntimeException extends YieldableError {\n  readonly _tag: \"RuntimeException\"\n  readonly [RuntimeExceptionTypeId]: RuntimeExceptionTypeId\n}\n```\n\n----------------------------------------\n\nTITLE: Checking PubSub Shutdown Status in TypeScript\nDESCRIPTION: The isShutdown function is used to determine if a PubSub instance has been shut down. It returns an Effect that resolves to a boolean value: true if shutdown has been called, false otherwise. This function is useful for managing the lifecycle of PubSub instances in an Effect-based application.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/PubSub-isShutdown.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const isShutdown: <A>(self: PubSub<A>) => Effect.Effect<boolean>\n```\n\n----------------------------------------\n\nTITLE: Declaring a Range Filter in TypeScript\nDESCRIPTION: This TypeScript snippet declares a function called 'between' within the Schema module of the 'effect' package. It is designed to check if a given number lies between specified minimum and maximum values. The function takes minimum, maximum, and optional annotations as parameters and returns a filter that operates on the Schema type, extending support for numbers. The 'between' function is part of the library since version 3.10.0.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Schema-between.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const between: <S extends Schema.Any>(minimum: number, maximum: number, annotations?: Annotations.Filter<Schema.Type<S>>) => <A extends number>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>) => filter<S>\n```\n\n----------------------------------------\n\nTITLE: Defining constant Doc.rangle in TypeScript\nDESCRIPTION: Declares a constant that represents a document containing a single right angle bracket (>) character. The Doc type parameter <never> indicates it has no dependencies or requirements.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Doc-rangle.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const rangle: Doc<never>\n```\n\n----------------------------------------\n\nTITLE: Checking if a FiberStatus is Done in TypeScript\nDESCRIPTION: A type guard function that determines if a FiberStatus is in the Done state. Returns true if the specified FiberStatus is Done, false otherwise. This function also serves as a type predicate, narrowing the type to Done when it returns true.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/FiberStatus-isDone.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const isDone: (self: FiberStatus) => self is Done\n```\n\n----------------------------------------\n\nTITLE: Offering all elements to TPriorityQueue in Typescript\nDESCRIPTION: The `offerAll` function in Typescript is used to atomically offer all elements from an iterable to a `TPriorityQueue` within an STM transaction. It accepts either a `TPriorityQueue` instance and an iterable, or an iterable and returns a function expecting the `TPriorityQueue` instance. The function returns an STM effect that, when executed, performs the offer operation.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TPriorityQueue-offerAll.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const offerAll: { <A>(values: Iterable<A>): (self: TPriorityQueue<A>) => STM.STM<void>; <A>(self: TPriorityQueue<A>, values: Iterable<A>): STM.STM<void>; }\n```\n\n----------------------------------------\n\nTITLE: Type Signature for Iterable.getLefts Function in TypeScript\nDESCRIPTION: This code snippet shows the type signature of the Iterable.getLefts function. It takes an Iterable of Either<R, L> and returns an Iterable of L, where L represents the Left type.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Iterable-getLefts.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const getLefts: <R, L>(self: Iterable<Either<R, L>>) => Iterable<L>\n```\n\n----------------------------------------\n\nTITLE: Defining forEach Function for Iterable in TypeScript\nDESCRIPTION: Declares a forEach function that iterates over an Iterable, applying a given function to each element. The function can be called with arguments in two different orders.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Iterable-forEach.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const forEach: { <A>(f: (a: A, i: number) => void): (self: Iterable<A>) => void; <A>(self: Iterable<A>, f: (a: A, i: number) => void): void; }\n```\n\n----------------------------------------\n\nTITLE: Converting TMap Key-Value Pairs to Chunk in TypeScript\nDESCRIPTION: The toChunk function collects all key-value bindings from a TMap into a Chunk data structure. It returns an STM (Software Transactional Memory) operation that, when executed, produces a Chunk containing tuples of keys and values from the map.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TMap-toChunk.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const toChunk: <K, V>(self: TMap<K, V>) => STM.STM<Chunk.Chunk<[K, V]>>\n```\n\n----------------------------------------\n\nTITLE: Obtaining Write Lock with TReentrantLock in TypeScript\nDESCRIPTION: This snippet declares the function \"writeLock\", which allows obtaining a write lock on a TReentrantLock object in a scoped context. It is part of the Effect-TS library and returns an Effect that requires a number as input and utilizes Scope without producing any failures. Dependencies include the Effect-TS library, and the function expects a TReentrantLock object as its main parameter. This functionality is available since version 2.0.0.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TReentrantLock-writeLock.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const writeLock: (self: TReentrantLock) => Effect.Effect<number, never, Scope.Scope>\n```\n\n----------------------------------------\n\nTITLE: Defining EntityRegistered Interface in TypeScript\nDESCRIPTION: Interface definition for EntityRegistered event that represents when a new entity is registered with a runner in the cluster system. The interface includes a discriminator tag and an entity property that can hold any type.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/ShardingRegistrationEvent-EntityRegistered.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface EntityRegistered {\n  readonly _tag: \"EntityRegistered\"\n  readonly entity: Entity<any>\n}\n```\n\n----------------------------------------\n\nTITLE: Match.discriminator Type Definition\nDESCRIPTION: Type signature for the Match.discriminator function showing its generic parameters and return type. Used for type-safe pattern matching on discriminated unions.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Match-discriminator.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const discriminator: <D extends string>(field: D) => <R, P extends Types.Tags<D, R> & string, Ret, Fn extends (_: Extract<R, Record<D, P>>) => Ret>(...pattern: [first: P, ...values: Array<P>, f: Fn]) => <I, F, A, Pr>(self: Matcher<I, F, R, A, Pr, Ret>) => Matcher<I, Types.AddWithout<F, Extract<R, Record<D, P>>>, Types.ApplyFilters<I, Types.AddWithout<F, Extract<R, Record<D, P>>>>, A | ReturnType<Fn>, Pr, Ret>\n```\n\n----------------------------------------\n\nTITLE: Either.getRight Function Signature in TypeScript\nDESCRIPTION: This code snippet shows the TypeScript signature of the Either.getRight function. It takes an Either<R, L> as input and returns an Option<R>.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Either-getRight.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const getRight: <R, L>(self: Either<R, L>) => Option<R>\n```\n\n----------------------------------------\n\nTITLE: Declaring STM Summarized Method TypeScript Type Signature\nDESCRIPTION: Defines a complex generic function that computes a summary value for an STM effect by comparing its state before and after execution. The method supports flexible composition and can transform summary values across different effect types.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/STM-summarized.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const summarized: { <A2, E2, R2, A3>(summary: STM<A2, E2, R2>, f: (before: A2, after: A2) => A3): <A, E, R>(self: STM<A, E, R>) => STM<[A3, A], E2 | E, R2 | R>; <A, E, R, A2, E2, R2, A3>(self: STM<A, E, R>, summary: STM<A2, E2, R2>, f: (before: A2, after: A2) => A3): STM<[A3, A], E | E2, R | R2>; }\n```\n\n----------------------------------------\n\nTITLE: Checking Defects in Cause Object - TypeScript\nDESCRIPTION: Function signature for isDie which determines if a Cause contains any defects (unexpected or unhandled errors). The function takes a Cause<E> parameter and returns a boolean indicating whether the Cause contains a Die error.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Cause-isDie.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const isDie: <E>(self: Cause<E>) => boolean\n```\n\n----------------------------------------\n\nTITLE: Checking Command Type with isCommand Function in TypeScript\nDESCRIPTION: This function checks if a given value is a Command object, returning true if it is and false otherwise. It provides type narrowing for TypeScript's type system through the type predicate pattern.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Command-isCommand.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const isCommand: (u: unknown) => u is Command\n```\n\n----------------------------------------\n\nTITLE: Defining Doc Type Union for Document Printing in TypeScript\nDESCRIPTION: Defines a union type Doc<A> that represents a prettified document with type parameter A for annotations. Includes various document components like Fail, Empty, Char, Text, Line, and formatting controls like Nest and Union.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Doc-Doc.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ntype Doc<A> = | Fail<A>\n  | Empty<A>\n  | Char<A>\n  | Text<A>\n  | Line<A>\n  | FlatAlt<A>\n  | Cat<A>\n  | Nest<A>\n  | Union<A>\n  | Column<A>\n  | WithPageWidth<A>\n  | Nesting<A>\n  | Annotated<A>\n```\n\n----------------------------------------\n\nTITLE: Creating Lists with List.make in TypeScript\nDESCRIPTION: Function signature for constructing a new List<A> from specified values. The function accepts a variable number of elements and returns a Cons (non-empty list) containing those elements.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/List-make.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const make: <Elements extends readonly [any, ...Array<any>]>(...elements: Elements) => Cons<Elements[number]>\n```\n\n----------------------------------------\n\nTITLE: Defining Stream.distributedWithDynamic - TypeScript\nDESCRIPTION: The 'distributedWithDynamic' function provides a robust way to handle stream distribution, allowing the user to specify maximum lag and decide the distribution logic via a provided function, returning new queues and managing shutdown procedures efficiently.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-distributedWithDynamic.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const distributedWithDynamic: { <A>(options: { readonly maximumLag: number; readonly decide: (a: A) => Effect.Effect<Predicate<number>, never, never>; }): <E, R>(self: Stream<A, E, R>) => Effect.Effect<Effect.Effect<[number, Queue.Dequeue<Exit.Exit<A, Option.Option<E>>>], never, never>, never, Scope.Scope | R>; <A, E, R>(self: Stream<A, E, R>, options: { readonly maximumLag: number; readonly decide: (a: A) => Effect.Effect<Predicate<number>, never, never>; }): Effect.Effect<Effect.Effect<[number, Queue.Dequeue<Exit.Exit<A, Option.Option<E>>>], never, never>, never, Scope.Scope | R>; }\n```\n\n----------------------------------------\n\nTITLE: Enabling Runtime Flags in Effect\nDESCRIPTION: Creates a RuntimeFlagsPatch that enables a specified RuntimeFlag. This function is used to modify runtime behavior by enabling specific flags in the Effect runtime system.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/RuntimeFlagsPatch-enable.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const enable: (flag: RuntimeFlags.RuntimeFlag) => RuntimeFlagsPatch\n```\n\n----------------------------------------\n\nTITLE: HashSet.toggle Function Signature in TypeScript\nDESCRIPTION: The TypeScript type signature for the HashSet.toggle function, showing it supports both data-first and data-last (pipeable) calling styles. The function toggles the presence of a value in a HashSet.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/HashSet-toggle.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const toggle: { <A>(value: A): (self: HashSet<A>) => HashSet<A>; <A>(self: HashSet<A>, value: A): HashSet<A>; }\n```\n\n----------------------------------------\n\nTITLE: Defining LogLevel Type in TypeScript\nDESCRIPTION: Defines the LogLevel type as a union of possible log levels ranging from All to None. Used to specify the granularity and importance of logging operations and control output verbosity.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/LogLevel-LogLevel.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ntype LogLevel = All | Fatal | Error | Warning | Info | Debug | Trace | None\n```\n\n----------------------------------------\n\nTITLE: Combining values using MonoidMax in TypeScript\nDESCRIPTION: This snippet demonstrates how to use the MonoidMax typeclass to combine numeric values, showcasing its ability to return the maximum value between two numbers and handle an 'empty' value case. It utilizes the combine method to achieve this functionality.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/data-Number-MonoidMax.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { MonoidMax } from \"@effect/typeclass/data/Number\"\n\nconsole.log(MonoidMax.combine(2, 3))\n// 3\nconsole.log(MonoidMax.combine(2, MonoidMax.empty))\n// 2\n```\n\n----------------------------------------\n\nTITLE: Implementing foldUntilEffect Function in TypeScript for Effect-IO-AI\nDESCRIPTION: This function creates a sink that effectfully folds elements of type 'In' into a structure of type 'S' until 'max' elements have been folded. It works like 'Sink.foldWeightedEffect' but with a constant cost function of '1'.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Sink-foldUntilEffect.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const foldUntilEffect: <S, In, E, R>(s: S, max: number, f: (s: S, input: In) => Effect.Effect<S, E, R>) => Sink<S, In, In, E, R>\n```\n\n----------------------------------------\n\nTITLE: Using String.length Function Example\nDESCRIPTION: Demonstrates how to use the String.length function from the Effect library to count characters in a string. The example shows importing the function and using it to calculate the length of 'abc'.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/String-length.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { String } from \"effect\"\n\nassert.deepStrictEqual(String.length('abc'), 3)\n```\n\n----------------------------------------\n\nTITLE: Defining MicroCause Union Type in TypeScript\nDESCRIPTION: Defines a union type MicroCause that represents three possible failure scenarios in a Micro context: Die for unforeseen defects, Fail for anticipated errors, and Interrupt for purposefully stopped operations.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Micro-MicroCause.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ntype MicroCause<E> = | MicroCause.Die\n  | MicroCause.Fail<E>\n  | MicroCause.Interrupt\n```\n\n----------------------------------------\n\nTITLE: Signature of Option.orElseSome in TypeScript\nDESCRIPTION: This code snippet shows the TypeScript declaration of the `Option.orElseSome` function. It defines two function signatures for `orElseSome`, offering flexibility in its usage. It uses generics to allow for different input and output types.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Option-orElseSome.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const orElseSome: { <B>(onNone: LazyArg<B>): <A>(self: Option<A>) => Option<B | A>; <A, B>(self: Option<A>, onNone: LazyArg<B>): Option<A | B>; }\n```\n\n----------------------------------------\n\nTITLE: Option.zipWith Signature\nDESCRIPTION: Shows the TypeScript signature of the `Option.zipWith` function, outlining its generic type parameters and function parameters. It highlights the curried and non-curried forms of the function.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Option-zipWith.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const zipWith: { <B, A, C>(that: Option<B>, f: (a: A, b: B) => C): (self: Option<A>) => Option<C>; <A, B, C>(self: Option<A>, that: Option<B>, f: (a: A, b: B) => C): Option<C>; }\n```\n\n----------------------------------------\n\nTITLE: makeWithTTL Function Signature\nDESCRIPTION: This snippet declares the TypeScript signature for the 'makeWithTTL' function used for creating a pool with specific options such as acquisition strategy and utilization parameters. It outlines the expected structure and types for each option provided to the pool creation method.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Pool-makeWithTTL.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const makeWithTTL: <A, E, R>(options: { readonly acquire: Effect.Effect<A, E, R>; readonly min: number; readonly max: number; readonly concurrency?: number | undefined; readonly targetUtilization?: number | undefined; readonly timeToLive: Duration.DurationInput; readonly timeToLiveStrategy?: \"creation\" | \"usage\" | undefined; }) => Effect.Effect<Pool<A, E>, never, Scope.Scope | R>\n```\n\n----------------------------------------\n\nTITLE: Cron.unsafeParse Function Signature\nDESCRIPTION: The type signature for the unsafeParse function in the Cron module. It takes a cron expression string and an optional time zone parameter, and returns a Cron instance. The time zone can be specified as either a DateTime.TimeZone object or a string.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Cron-unsafeParse.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const unsafeParse: (cron: string, tz?: DateTime.TimeZone | string) => Cron\n```\n\n----------------------------------------\n\nTITLE: Effect.disconnect Function Signature in TypeScript\nDESCRIPTION: This code snippet shows the TypeScript function signature for the Effect.disconnect function. It takes an Effect as input and returns a new Effect with the same type parameters.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-disconnect.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const disconnect: <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R>\n```\n\n----------------------------------------\n\nTITLE: Accessing Channel Context in TypeScript\nDESCRIPTION: This function allows access to the whole context of a channel. It returns a Channel that provides the Context<Env> as its output.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Channel-context.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const context: <Env>() => Channel<never, unknown, never, unknown, Context.Context<Env>, unknown, Env>\n```\n\n----------------------------------------\n\nTITLE: Declaring 'shrinks' Constant in TestServices Module (TypeScript)\nDESCRIPTION: Defines a constant 'shrinks' that represents the maximum number of shrinkings to minimize large failures in testing. It returns an Effect with a number value and no error or dependency requirements.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TestServices-shrinks.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const shrinks: Effect.Effect<number, never, never>\n```\n\n----------------------------------------\n\nTITLE: Implementing Parallel ExecutionStrategy in TypeScript\nDESCRIPTION: Defines a constant parallel execution strategy that enables parallel execution of effects in the Effect-TS library. This is a core component used for concurrent operation handling.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/ExecutionStrategy-parallel.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const parallel: ExecutionStrategy\n```\n\n----------------------------------------\n\nTITLE: Defining ScopedRef Interface in TypeScript\nDESCRIPTION: Interface definition for ScopedRef that extends Effect.Effect. It manages a reference whose value is associated with resources that require proper release. The interface includes internal synchronized reference storage and type system utilities.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/ScopedRef-ScopedRef.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface ScopedRef<in out A> extends Effect.Effect<A>, ScopedRef.Variance<A>, Pipeable {\n  /** @internal */\n  readonly ref: Synchronized.SynchronizedRef<readonly [Scope.Scope.Closeable, A]>\n\n  readonly [Unify.typeSymbol]?: unknown\n  readonly [Unify.unifySymbol]?: ScopedRefUnify<this>\n  readonly [Unify.ignoreSymbol]?: ScopedRefUnifyIgnore\n}\n```\n\n----------------------------------------\n\nTITLE: Using Match.discriminators in TypeScript\nDESCRIPTION: Demonstrates how to use the Match.discriminators function to match values based on a 'type' field in a discriminated union. The example shows matching three different types (A, B, and C) with different payload structures.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Match-discriminators.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Match, pipe } from \"effect\"\n\nconst match = pipe(\n  Match.type<{ type: \"A\"; a: string } | { type: \"B\"; b: number } | { type: \"C\"; c: boolean }>(),\n  Match.discriminators(\"type\")({\n    A: (a) => a.a,\n    B: (b) => b.b,\n    C: (c) => c.c\n  }),\n  Match.exhaustive\n)\n```\n\n----------------------------------------\n\nTITLE: Defining Minimum Interval Function in TypeScript\nDESCRIPTION: Declares a function 'min' that returns the minimum of two Interval objects. It supports both curried and non-curried calling styles.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/ScheduleInterval-min.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const min: { (that: Interval): (self: Interval) => Interval; (self: Interval, that: Interval): Interval; }\n```\n\n----------------------------------------\n\nTITLE: Using Doc.flatAlt for Flexible Document Layout in TypeScript\nDESCRIPTION: Demonstrates how to use Doc.flatAlt to create flexible document layouts that adapt based on available space. The example shows creating a pretty-printer for do-notation that renders either inline or multi-line based on width constraints.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Doc-flatAlt.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport * as Doc from \"@effect/printer/Doc\"\nimport { pipe } from \"effect/Function\"\nimport * as String from \"effect/String\"\n\nconst open = pipe(Doc.empty, Doc.flatAlt(Doc.text(\"{ \")))\nconst close = pipe(Doc.empty, Doc.flatAlt(Doc.text(\" }\")))\nconst separator = pipe(Doc.empty, Doc.flatAlt(Doc.text(\"; \")))\n\nconst prettyDo = <A>(documents: Array<Doc.Doc<A>>): Doc.Doc<A> => {\n  return pipe(\n    Doc.hsep([\n      Doc.text(\"do\"),\n      pipe(\n        documents,\n        Doc.encloseSep(open, close, separator),\n        Doc.align\n      )\n    ]),\n    Doc.group\n  )\n}\n\nconst statements = [\n  Doc.text(\"name:_ <- getArgs\"),\n  Doc.text(\"let greet = \\\"Hello, \\\" <> name\"),\n  Doc.text(\"putStrLn greet\")\n]\n\n// If it fits, then the content is put onto a single line with the `{;}` style\nassert.strictEqual(\n  pipe(\n    prettyDo(statements),\n    Doc.render({\n      style: \"pretty\",\n      options: { lineWidth: 80 }\n    })\n  ),\n  \"do { name:_ <- getArgs; let greet = \\\"Hello, \\\" <> name; putStrLn greet }\"\n)\n\n// When there is not enough space, the content is broken up onto multiple lines\nassert.strictEqual(\n  pipe(\n    prettyDo(statements),\n    Doc.render({\n      style: \"pretty\",\n      options: { lineWidth: 10 }\n    })\n  ),\n  String.stripMargin(\n    `|do name:_ <- getArgs\n     |   let greet = \"Hello, \" <> name\n     |   putStrLn greet`\n  )\n)\n```\n\n----------------------------------------\n\nTITLE: Implementing Effectful Chunk Folding in TypeScript\nDESCRIPTION: A sink function that effectfully folds input chunks with a provided function and initial state. The function preserves chunking-invariance and returns an Effect with the result of the folding operation.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Sink-foldLeftChunksEffect.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const foldLeftChunksEffect: <S, In, E, R>(s: S, f: (s: S, chunk: Chunk.Chunk<In>) => Effect.Effect<S, E, R>) => Sink<S, In, never, E, R>\n```\n\n----------------------------------------\n\nTITLE: Checking for MissingData Errors in ConfigError with isMissingDataOnly Function\nDESCRIPTION: A utility function that determines if a ConfigError instance contains only MissingData type errors. Returns true if all errors in the provided ConfigError are of MissingData type, and false otherwise.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/ConfigError-isMissingDataOnly.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const isMissingDataOnly: (self: ConfigError) => boolean\n```\n\n----------------------------------------\n\nTITLE: Implementing Reverse Iterator for RedBlackTree in TypeScript\nDESCRIPTION: Function signature for creating a reverse iterator that traverses RedBlackTree entries with keys greater than or equal to a specified key. The function supports both curried and non-curried calling styles.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/RedBlackTree-greaterThanEqualReversed.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const greaterThanEqualReversed: { \n  <K>(key: K): <V>(self: RedBlackTree<K, V>) => Iterable<[K, V]>; \n  <K, V>(self: RedBlackTree<K, V>, key: K): Iterable<[K, V]>; \n}\n```\n\n----------------------------------------\n\nTITLE: Defining a never-executing RequestResolver in TypeScript\nDESCRIPTION: Declaration of a constant 'never' that represents a data source which never executes requests. This is useful as a placeholder or fallback when request execution should be explicitly prevented.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/RequestResolver-never.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const never: RequestResolver<never, never>\n```\n\n----------------------------------------\n\nTITLE: Declaring Schedule Duration in TypeScript\nDESCRIPTION: This TypeScript snippet declares a constant 'duration' as an alias for 'fromDelay', facilitating the creation of schedules based on a specified duration input. It is part of the Schedule module in the Effect-TS library, used to manage time-based events. This function requires the 'Duration' input, mapping it to a Schedule object for asynchronous operations. Required since version 2.0.0 of the library.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Schedule-duration.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const duration: (duration: Duration.DurationInput) => Schedule<Duration.Duration>\n```\n\n----------------------------------------\n\nTITLE: Creating a Minimum Monoid from Bounded in TypeScript\nDESCRIPTION: Defines a function that creates a Monoid instance from a Bounded typeclass. The resulting Monoid will combine elements by returning the minimum value according to the Bounded instance's ordering.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Bounded-min.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const min: <A>(B: Bounded<A>) => Monoid<A>\n```\n\n----------------------------------------\n\nTITLE: Symbol.isSymbol Signature\nDESCRIPTION: This code snippet defines the type signature of the `isSymbol` function within the Effect TS library. It declares `isSymbol` as a function that takes an unknown value `u` as input and returns a boolean indicating whether `u` is a symbol.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Symbol-isSymbol.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const isSymbol: (u: unknown) => u is symbol\n```\n\n----------------------------------------\n\nTITLE: Checking Predicates for SortedSet Elements in TypeScript\nDESCRIPTION: The `every` function checks if a predicate holds true for every element in a SortedSet. It takes a predicate function and a SortedSet, and returns a boolean indicating whether all elements satisfy the predicate.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/SortedSet-every.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const every: { <A>(predicate: Predicate<A>): (self: SortedSet<A>) => boolean; <A>(self: SortedSet<A>, predicate: Predicate<A>): boolean; }\n```\n\n----------------------------------------\n\nTITLE: Initializing Empty List in Effect TS\nDESCRIPTION: Defines a type-safe function to create an empty List data structure. The function is generic and can be used with any type parameter A, defaulting to never if not specified. It's an alias for the 'nil' function.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/List-empty.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const empty: <A = never>() => List<A>\n```\n\n----------------------------------------\n\nTITLE: isTupleOfAtLeast Function Signature in TypeScript\nDESCRIPTION: This snippet shows the TypeScript signature of the isTupleOfAtLeast function. It defines the function as having two overloads, allowing for flexible usage patterns.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Predicate-isTupleOfAtLeast.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const isTupleOfAtLeast: { <N extends number>(n: N): <T>(self: ReadonlyArray<T>) => self is TupleOfAtLeast<N, T>; <T, N extends number>(self: ReadonlyArray<T>, n: N): self is TupleOfAtLeast<N, T>; }\n```\n\n----------------------------------------\n\nTITLE: Retrieving Items from KeyedPool in TypeScript\nDESCRIPTION: Function signature for retrieving items from a KeyedPool with scope management. Supports both curried and uncurried calling styles. The function handles resource acquisition with proper scoping and error propagation.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/KeyedPool-get.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const get: {\n  <K>(key: K): <A, E>(self: KeyedPool<K, A, E>) => Effect.Effect<A, E, Scope.Scope>;\n  <K, A, E>(self: KeyedPool<K, A, E>, key: K): Effect.Effect<A, E, Scope.Scope>;\n}\n```\n\n----------------------------------------\n\nTITLE: Transforming MicroSchedule Function with Max Time in TypeScript\nDESCRIPTION: This TypeScript function, `scheduleWithMaxElapsed`, transforms a `MicroSchedule` object to one that stops repeating after a specified maximum duration, defined by the `max` parameter. It supports partial application by accepting the `max` parameter first or both `MicroSchedule` and `max`. The function returns a transformed `MicroSchedule`. There are no additional dependencies outside the effect package needed, and the function expects positive numerical input for `max`. This utility has been available since v3.4.6.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Micro-scheduleWithMaxElapsed.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const scheduleWithMaxElapsed: { (max: number): (self: MicroSchedule) => MicroSchedule; (self: MicroSchedule, max: number): MicroSchedule; }\n```\n\n----------------------------------------\n\nTITLE: Defining toReadonlyArray Function in TypeScript\nDESCRIPTION: This function converts a Chunk into a ReadonlyArray. If the input is a NonEmptyChunk, it returns a NonEmptyReadonlyArray, preserving the non-empty property. It uses conditional types to ensure type safety.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Chunk-toReadonlyArray.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const toReadonlyArray: <S extends Chunk<any>>(self: S) => S extends NonEmptyChunk<any> ? RA.NonEmptyReadonlyArray<Chunk.Infer<S>> : ReadonlyArray<Chunk.Infer<S>>\n```\n\n----------------------------------------\n\nTITLE: Retrieving Current UTC Time with DateTime.unsafeNow in TypeScript\nDESCRIPTION: The unsafeNow function provides a lazy way to get the current UTC time using JavaScript's Date.now method. It returns a Utc timestamp when evaluated.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/DateTime-unsafeNow.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const unsafeNow: LazyArg<Utc>\n```\n\n----------------------------------------\n\nTITLE: TypeScript Signature for Predicate.tuple Function\nDESCRIPTION: This code snippet shows the TypeScript signature for the Predicate.tuple function. It defines a variadic function that takes any number of Predicates or Refinements and returns a new Predicate or Refinement based on the input types.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Predicate-tuple.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const tuple: <T extends ReadonlyArray<Predicate.Any>>(...elements: T) => [Extract<T[number], Refinement.Any>] extends [never] ? Predicate<{ readonly [I in keyof T]: Predicate.In<T[I]>; }> : Refinement<{ readonly [I in keyof T]: T[I] extends Refinement.Any ? Refinement.In<T[I]> : Predicate.In<T[I]>; }, { readonly [I in keyof T]: T[I] extends Refinement.Any ? Refinement.Out<T[I]> : Predicate.In<T[I]>; }>\n```\n\n----------------------------------------\n\nTITLE: Declaring TimeZone Offset Class in Effect\nDESCRIPTION: This TypeScript snippet declares a class called TimeZoneOffsetFromSelf, representing a schema for a TimeZone.Offset instance. It is part of the Effect framework's schema module, allowing for structured representation and manipulation of time zone offsets. This schema is Version 3.10.0 of the library and is designed to be adaptable within the provided framework structure.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Schema-TimeZoneOffsetFromSelf.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare class TimeZoneOffsetFromSelf\n```\n\n----------------------------------------\n\nTITLE: FiberMap.runtime Function Signature in TypeScript\nDESCRIPTION: This code snippet shows the TypeScript signature for the FiberMap.runtime function. It defines the function's type parameters, input parameters, and return type, including the complex nested Effect and Fiber types.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/FiberMap-runtime.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const runtime: <K, A, E>(self: FiberMap<K, A, E>) => <R = never>() => Effect.Effect<(<XE extends E, XA extends A>(key: K, effect: Effect.Effect<XA, XE, R>, options?: (Runtime.RunForkOptions & { readonly onlyIfMissing?: boolean | undefined; readonly propagateInterruption?: boolean | undefined; }) | undefined) => Fiber.RuntimeFiber<XA, XE>), never, R>\n```\n\n----------------------------------------\n\nTITLE: Retrieving Left Values from an Iterable of Eithers in TypeScript\nDESCRIPTION: The getLefts function extracts all Left values from an Iterable of Either objects and collects them into an array. This is useful for gathering error values when working with collections of Either results.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Array-getLefts.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Array, Either } from \"effect\"\n\nconst result = Array.getLefts([Either.right(1), Either.left(\"err\"), Either.right(2)])\nconsole.log(result) // [\"err\"]\n```\n\n----------------------------------------\n\nTITLE: Declaring Fiber Descriptor Effect in TypeScript\nDESCRIPTION: Constructs an effect with information about the current Fiber. This function returns an Effect that resolves with the descriptor of the current fiber, never fails, and requires no environment.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-descriptor.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const descriptor: Effect<Fiber.Fiber.Descriptor, never, never>\n```\n\n----------------------------------------\n\nTITLE: Using hardLine for forced line breaks in @effect/printer Doc module (TypeScript)\nDESCRIPTION: This example demonstrates how the hardLine document creates a forced line break in text layouts even when there's ample space available. The code creates a document that combines text elements with a hardLine, and then renders it with a large line width to show that the line break is still enforced.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Doc-hardLine.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport * as Doc from \"@effect/printer/Doc\"\nimport * as String from \"effect/String\"\n\nconst doc: Doc.Doc<never> = Doc.hcat([\n  Doc.text(\"lorem ipsum\"),\n  Doc.hardLine,\n  Doc.text(\"dolor sit amet\")\n])\n\n// Even with enough space, a line break is introduced\nassert.strictEqual(\n  Doc.render(doc, {\n    style: \"pretty\",\n    options: { lineWidth: 1000 }\n  }),\n  String.stripMargin(\n    `|lorem ipsum\n     |dolor sit amet`\n  )\n)\n```\n\n----------------------------------------\n\nTITLE: BigInt SemigroupMax Example in Typescript\nDESCRIPTION: This example demonstrates how to use the `SemigroupMax` from `@effect/typeclass/data/BigInt` to combine two `bigint` values, resulting in the maximum value.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/data-BigInt-SemigroupMax.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { SemigroupMax } from \"@effect/typeclass/data/BigInt\"\n\nconsole.log(SemigroupMax.combine(2n, 3n))\n// 3n\n```\n\n----------------------------------------\n\nTITLE: Moving Terminal Cursor to Specific Coordinates in TypeScript\nDESCRIPTION: The cursorTo function moves the cursor to specified column and optional row positions in a terminal. It takes zero-based coordinates and adjusts them to the 1-based values required by ANSI control sequences. The function returns an AnsiDoc for potential chaining with other commands.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/AnsiDoc-cursorTo.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const cursorTo: (column: number, row?: number) => AnsiDoc\n```\n\n----------------------------------------\n\nTITLE: Signature of Scoped Function - TypeScript\nDESCRIPTION: This is the TypeScript type declaration for the 'scoped' function. It specifies the function's generic parameters and outlines how it transforms an effect into a stream, excluding the scope from the result type.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-scoped.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const scoped: <A, E, R>(effect: Effect.Effect<A, E, R>) => Stream<A, E, Exclude<R, Scope.Scope>>\n```\n\n----------------------------------------\n\nTITLE: TypeScript Type Signature for constUndefined Function\nDESCRIPTION: Shows the type declaration for the constUndefined function, defined as a LazyArg that returns undefined. This signature helps in understanding the function's type constraints.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Function-constUndefined.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const constUndefined: LazyArg<undefined>\n```\n\n----------------------------------------\n\nTITLE: Defining MetricState Interface in TypeScript\nDESCRIPTION: Defines the MetricState interface that extends MetricState.Variance, Equal.Equal, and Pipeable. The interface uses a phantom type parameter A to tie metric keys to their expected states.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/MetricState-MetricState.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface MetricState<in A> extends MetricState.Variance<A>, Equal.Equal, Pipeable {}\n```\n\n----------------------------------------\n\nTITLE: Testing Number Identification in TypeScript\nDESCRIPTION: This snippet tests the isNumber function that determines if a given value is a number. It demonstrates the usage of assertions to verify the functionality of the isNumber function. The required dependencies include the 'assert' module from Node.js and the 'isNumber' function from the 'effect/Number' module.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Number-isNumber.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { isNumber } from \"effect/Number\"\n\nassert.deepStrictEqual(isNumber(2), true)\nassert.deepStrictEqual(isNumber(\"2\"), false)\n```\n\n----------------------------------------\n\nTITLE: Schedule collectUntilEffect Signature\nDESCRIPTION: Defines the type signature for the `collectUntilEffect` function. It takes an effectful predicate `f` as input, which determines when to stop collecting inputs into a `Chunk`. The function returns a `Schedule` that emits `Chunk`s of the collected inputs.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Schedule-collectUntilEffect.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const collectUntilEffect: <A, R>(f: (a: A) => Effect.Effect<boolean, never, R>) => Schedule<Chunk.Chunk<A>, A, R>\n```\n\n----------------------------------------\n\nTITLE: TypeScript Stream.bindEffect Type Declaration\nDESCRIPTION: Complex type signature for binding effectful values in stream processing, supporting concurrency and transformation of stream elements\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-bindEffect.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const bindEffect: { <N extends string, A, B, E2, R2>(tag: Exclude<N, keyof A>, f: (_: NoInfer<A>) => Effect.Effect<B, E2, R2>, options?: { readonly concurrency?: number | \"unbounded\" | undefined; readonly bufferSize?: number | undefined; }): <E, R>(self: Stream<A, E, R>) => Stream<{ [K in keyof A | N]: K extends keyof A ? A[K] : B; }, E | E2, R | R2>; <A, E, R, N extends string, B, E2, R2>(self: Stream<A, E, R>, tag: Exclude<N, keyof A>, f: (_: NoInfer<A>) => Effect.Effect<B, E2, R2>, options?: { readonly concurrency?: number | \"unbounded\" | undefined; readonly unordered?: boolean | undefined; }): Stream<{ [K in keyof A | N]: K extends keyof A ? A[K] : B; }, E | E2, R | R2>; }\n```\n\n----------------------------------------\n\nTITLE: Defining Column Interface for Reactive Documents in TypeScript\nDESCRIPTION: This code snippet defines the Column interface, which extends Doc.Variance<A>. It represents a document that reacts to the current cursor position. The interface includes a _tag property set to \"Column\" and a react method that takes a position number and returns a Doc<A>.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Doc-Column.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface Column<A> extends Doc.Variance<A> {\n  readonly _tag: \"Column\"\n  readonly react: (position: number) => Doc<A>\n}\n```\n\n----------------------------------------\n\nTITLE: Supervisor.none declaration\nDESCRIPTION: Declares a constant named `none` of type `Supervisor<void>`. This supervisor does not perform any action upon supervision events. It serves as a no-op supervisor.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Supervisor-none.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const none: Supervisor<void>\n```\n\n----------------------------------------\n\nTITLE: Creating an Identity Schedule in TypeScript\nDESCRIPTION: This TypeScript code snippet defines an identity schedule that continuously returns input values as outputs, without alteration. It serves as a perpetual pass-through mechanism, making it useful for scenarios where repeated input values are needed at each step. The function is part of the `Schedule` module in the `effect` package.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Schedule-identity.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const identity: <A>() => Schedule<A, A>\n```\n\n----------------------------------------\n\nTITLE: Setting URL Query Parameters with Url.setUrlParams\nDESCRIPTION: Demonstrates how to replace existing URL query parameters using the setUrlParams function from the @effect/platform library. Creates a new URL object with updated parameters while preserving the original URL's base structure.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Url-setUrlParams.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Url, UrlParams } from \"@effect/platform\"\n\nconst myUrl = new URL(\"https://example.com?foo=bar\")\n\n// Write parameters\nconst updatedUrl = Url.setUrlParams(\n  myUrl,\n  UrlParams.fromInput([\"key\", \"value\"])\n)\n\nconsole.log(updatedUrl.toString())\n// Output: https://example.com/?key=value\n```\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const setUrlParams: { (urlParams: UrlParams.UrlParams): (url: URL) => URL; (url: URL, urlParams: UrlParams.UrlParams): URL; }\n```\n\n----------------------------------------\n\nTITLE: Defining DateFromNumber Schema in TypeScript\nDESCRIPTION: Defines a schema that converts a number into a Date object using the new Date constructor. It allows potentially invalid values and encodes invalid Date objects to NaN during encoding.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Schema-DateFromNumber.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare class DateFromNumber\n```\n\n----------------------------------------\n\nTITLE: Implementing Cursor Backward Movement in TypeScript using ANSI Escape Codes\nDESCRIPTION: Function that generates ANSI escape sequence to move the cursor backward by a specified number of columns. If no column count is specified, defaults to moving back one column. The movement is constrained by the screen edge.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Ansi-cursorBackward.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const cursorBackward: (columns?: number) => Ansi\n```\n\n----------------------------------------\n\nTITLE: Array.rotate Function Signature in TypeScript\nDESCRIPTION: Type definition for the Array.rotate function showing its polymorphic nature. It can operate on Iterables, NonEmptyReadonlyArrays, and regular Arrays, maintaining type safety.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Array-rotate.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const rotate: { (n: number): <S extends Iterable<any>>(self: S) => ReadonlyArray.With<S, ReadonlyArray.Infer<S>>; <A>(self: NonEmptyReadonlyArray<A>, n: number): NonEmptyArray<A>; <A>(self: Iterable<A>, n: number): Array<A>; }\n```\n\n----------------------------------------\n\nTITLE: Using Doc.line for Line Breaks and Indentation in TypeScript\nDESCRIPTION: This example demonstrates how to use the `Doc.line` function. It shows how `line` normally creates a line break with indentation, but when wrapped in `Doc.group()`, it behaves like a space instead. The example creates a document, then renders it in both standard and grouped forms.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Doc-line.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport * as Doc from \"@effect/printer/Doc\"\nimport * as String from \"effect/String\"\n\nconst doc: Doc.Doc<never> = Doc.hcat([\n  Doc.text(\"lorem ipsum\"),\n  Doc.line,\n  Doc.text(\"dolor sit amet\")\n])\n\nassert.strictEqual(\n  Doc.render(doc, { style: \"pretty\" }),\n  String.stripMargin(\n    `|lorem ipsum\n     |dolor sit amet`\n  )\n)\nassert.strictEqual(\n  Doc.render(Doc.group(doc), { style: \"pretty\" }),\n  \"lorem ipsum dolor sit amet\"\n)\n```\n\n----------------------------------------\n\nTITLE: BigDecimal Negate Function Signature in TypeScript\nDESCRIPTION: Provides the TypeScript type signature for the negate function in the BigDecimal module. It takes a BigDecimal as input and returns a BigDecimal.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/BigDecimal-negate.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const negate: (n: BigDecimal) => BigDecimal\n```\n\n----------------------------------------\n\nTITLE: Predicate.not Function Signature in TypeScript\nDESCRIPTION: Shows the TypeScript signature for the Predicate.not function, which takes a predicate function and returns its negation.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Predicate-not.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const not: <A>(self: Predicate<A>) => Predicate<A>\n```\n\n----------------------------------------\n\nTITLE: Creating FiberId in TypeScript using Effect Library\nDESCRIPTION: The make function creates a new FiberId. It takes two parameters: id (a number) and startTimeSeconds (a number), and returns a FiberId instance. This function is part of the FiberId module in the Effect library.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/FiberId-make.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const make: (id: number, startTimeSeconds: number) => FiberId\n```\n\n----------------------------------------\n\nTITLE: Defining unsafeLast Function in Typescript for Chunk Module\nDESCRIPTION: This function returns the last element of a Chunk. It throws an error if the chunk is empty. The function takes a Chunk<A> as input and returns an element of type A.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Chunk-unsafeLast.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const unsafeLast: <A>(self: Chunk<A>) => A\n```\n\n----------------------------------------\n\nTITLE: Effect.logDebug Function Signature Definition\nDESCRIPTION: TypeScript type declaration for the logDebug function showing it accepts any number of arguments as a readonly array and returns an Effect with void return type and never for both error and dependencies.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-logDebug.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const logDebug: (...message: ReadonlyArray<any>) => Effect<void, never, never>\n```\n\n----------------------------------------\n\nTITLE: Defining QuitException Class in TypeScript\nDESCRIPTION: Declares the QuitException class, which represents an exception that occurs when a user attempts to quit out of a Terminal prompt for input, typically by pressing Ctrl+C.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Terminal-QuitException.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare class QuitException\n```\n\n----------------------------------------\n\nTITLE: Checking if ExecutionStrategy is ParallelN in TypeScript\nDESCRIPTION: This function determines whether the provided ExecutionStrategy instance is specifically a ParallelN type. It returns true if the strategy is a ParallelN instance, and false otherwise. This is a type guard function that helps with type narrowing in TypeScript.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/ExecutionStrategy-isParallelN.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const isParallelN: (self: ExecutionStrategy) => self is ParallelN\n```\n\n----------------------------------------\n\nTITLE: Partitioning Records using Effect in TypeScript\nDESCRIPTION: This code snippet demonstrates how to partition a record into two groups using a mapping function. The 'Record.partitionMap' function is invoked with a record and a function that returns an 'Either', effectively separating the records into two based on whether the function returns a 'Right' or 'Left'. This example requires the 'effect' library and uses TypeScript.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Record-partitionMap.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { Record, Either } from \"effect\"\n\nconst x = { a: 1, b: 2, c: 3 }\nconst f = (n: number) => (n % 2 === 0 ? Either.right(n) : Either.left(n))\nassert.deepStrictEqual(Record.partitionMap(x, f), [{ a: 1, c: 3 }, { b: 2}])\n```\n\n----------------------------------------\n\nTITLE: Stream Buffer Chunks Function Signature\nDESCRIPTION: Defines the `bufferChunks` function in the Effect library, which buffers chunks in a stream with a specified capacity and strategy. It accepts an options object with `capacity` (number) and an optional `strategy` (dropping, sliding, or suspend). The function returns a new stream with the buffered chunks.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-bufferChunks.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const bufferChunks: { (options: { readonly capacity: number; readonly strategy?: \"dropping\" | \"sliding\" | \"suspend\" | undefined; }): <A, E, R>(self: Stream<A, E, R>) => Stream<A, E, R>; <A, E, R>(self: Stream<A, E, R>, options: { readonly capacity: number; readonly strategy?: \"dropping\" | \"sliding\" | \"suspend\" | undefined; }): Stream<A, E, R>; }\n```\n\n----------------------------------------\n\nTITLE: Defining CloseLatch interface in TypeScript\nDESCRIPTION: This code snippet defines the `CloseLatch` interface in TypeScript.  It's used by platform runners to signal that a worker has been closed. The interface contains a unique symbol.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/WorkerRunner-CloseLatch.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nexport interface CloseLatch {\n  readonly _: unique symbol\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Defining DataFromSelf Type in TypeScript for Effect Library's Schema Module\nDESCRIPTION: This code snippet defines the DataFromSelf type in the Schema module. It specifies that Type and Encoded must extend Readonly<Record<string, any>> | ReadonlyArray<any> to be compatible with this API. The function takes a value of type S & Schema<A & Schema.Type<S>, I & Schema.Encoded<S>, Schema.Context<S>> and returns DataFromSelf<S>.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Schema-DataFromSelf.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const DataFromSelf: <S extends Schema.Any, A extends Readonly<Record<string, unknown>> | ReadonlyArray<unknown>, I extends Readonly<Record<string, unknown>> | ReadonlyArray<unknown>>(value: S & Schema<A & Schema.Type<S>, I & Schema.Encoded<S>, Schema.Context<S>>) => DataFromSelf<S>\n```\n\n----------------------------------------\n\nTITLE: Implementing Maximum Monoid for Bounded Type in TypeScript\nDESCRIPTION: Defines a Monoid implementation that returns the maximum of bounded elements. The function takes a Bounded<A> type parameter and returns a Monoid<A> that can combine elements by selecting the maximum value.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Bounded-max.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const max: <A>(B: Bounded<A>) => Monoid<A>\n```\n\n----------------------------------------\n\nTITLE: Converting TSet to HashSet in Effect (TypeScript)\nDESCRIPTION: This snippet showcases the `toHashSet` function from the Effect library's `TSet` module. The function takes a `TSet` as input and returns an STM action that, when executed, produces a `HashSet` containing all the elements from the original `TSet`. This operation is performed within a transactional context managed by STM.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TSet-toHashSet.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const toHashSet: <A>(self: TSet<A>) => STM.STM<HashSet.HashSet<A>>\n```\n\n----------------------------------------\n\nTITLE: Combining Error Causes in Parallel in Effect.io\nDESCRIPTION: The parallel function combines two Cause instances that occurred simultaneously, preserving both errors instead of discarding one. This enables richer error reporting and debugging capabilities in Effect applications.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Cause-parallel.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const parallel: <E, E2>(left: Cause<E>, right: Cause<E2>) => Cause<E | E2>\n```\n\n----------------------------------------\n\nTITLE: DateTime.withDate Function Signature\nDESCRIPTION: TypeScript type definition for the withDate function, showing its overloaded signatures for both piped and direct usage.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/DateTime-withDate.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const withDate: { <A>(f: (date: Date) => A): (self: DateTime) => A; <A>(self: DateTime, f: (date: Date) => A): A; }\n```\n\n----------------------------------------\n\nTITLE: Declaring Trim Class for Schema Module in TypeScript\nDESCRIPTION: This code snippet declares the Trim class within the Schema module. It is designed to handle whitespace removal from string inputs, ensuring that both leading and trailing whitespaces are removed efficiently. This class is a part of the effect package and becomes useful for schema validation purposes.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Schema-Trim.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare class Trim\n```\n\n----------------------------------------\n\nTITLE: Defining ANSI Erase Line Operation in TypeScript\nDESCRIPTION: Declares a constant 'eraseLine' of type 'Ansi' that represents the ANSI command to clear the current line in the terminal. This operation does not change the current cursor position.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Ansi-eraseLine.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const eraseLine: Ansi\n```\n\n----------------------------------------\n\nTITLE: Defining Primitive.wizard Function in TypeScript\nDESCRIPTION: Declares a 'wizard' function that creates a prompt for user input based on a specified primitive type. It takes a HelpDoc and a Primitive<A> as parameters and returns a Prompt<A>.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Primitive-wizard.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const wizard: { (help: HelpDoc): <A>(self: Primitive<A>) => Prompt<A>; <A>(self: Primitive<A>, help: HelpDoc): Prompt<A>; }\n```\n\n----------------------------------------\n\nTITLE: Defining record matching function in TypeScript\nDESCRIPTION: Declares a constant 'record' that refines unknown values to objects with string or symbol keys and unknown values. This function is part of the Predicate namespace and serves as a type refinement tool.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Match-record.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const record: Predicate.Refinement<unknown, { [x: string]: unknown; [x: symbol]: unknown; }>\n```\n\n----------------------------------------\n\nTITLE: Accessing STM Context with TypeScript\nDESCRIPTION: Accesses the environment of the transaction to perform a transaction. The `contextWith` function allows you to derive a value from the environment available within the STM transaction, providing access to contextual information.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/STM-contextWith.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const contextWith: <R0, R>(f: (environment: Context.Context<R0>) => R) => STM<R, never, R0>\n```\n\n----------------------------------------\n\nTITLE: Declaring Values Function Signature for Trie (TypeScript)\nDESCRIPTION: This snippet declares the function signature for retrieving values from a Trie. The function takes a Trie instance as a parameter and returns an IterableIterator of the stored values. This enables users to fetch values in an efficient manner.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Trie-values.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const values: <V>(self: Trie<V>) => IterableIterator<V>\n```\n\n----------------------------------------\n\nTITLE: DateTime.make Function Signature in Effect Library (TypeScript)\nDESCRIPTION: The type signature for the DateTime.make function, showing it accepts generic input of type DateTime.Input and returns an Option containing a DateTime with preserved timezone information from the input.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/DateTime-make.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const make: <A extends DateTime.Input>(input: A) => Option.Option<DateTime.PreserveZone<A>>\n```\n\n----------------------------------------\n\nTITLE: HashSet.values Function Signature in TypeScript\nDESCRIPTION: Provides the TypeScript type signature for the HashSet.values function. It takes a HashSet of type A and returns an IterableIterator of type A.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/HashSet-values.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const values: <A>(self: HashSet<A>) => IterableIterator<A>\n```\n\n----------------------------------------\n\nTITLE: Accessing Sink Context in Effect\nDESCRIPTION: The `context` function allows retrieving the entire contextual environment `R` associated with the `Sink`. It returns a `Sink` that emits the entire context. This is useful when the sink needs access to the environment to perform its operations.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Sink-context.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const context: <R>() => Sink<Context.Context<R>, unknown, never, never, R>\n```\n\n----------------------------------------\n\nTITLE: Checking Lock Status with TReentrantLock.locked in TypeScript\nDESCRIPTION: The 'locked' function determines if any fiber currently has a read or write lock on the reentrant lock. It returns an STM computation that resolves to a boolean value indicating the lock status.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TReentrantLock-locked.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const locked: (self: TReentrantLock) => STM.STM<boolean>\n```\n\n----------------------------------------\n\nTITLE: Declaring failCauseSync Function in TypeScript\nDESCRIPTION: The failCauseSync function is a TypeScript declaration within the Effect-TS library intended to create a Micro effect that lazily fails with a specified MicroCause. This function requires the Micro and MicroCause types, which represent the effect and its failure cause respectively. It takes a LazyArg of MicroCause as a parameter and returns a Micro effect that never succeeds with a defined error type. This allows for handling complex asynchronous failure scenarios in a lazy and efficient manner.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Micro-failCauseSync.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const failCauseSync: <E>(evaluate: LazyArg<MicroCause<E>>) => Micro<never, E>\n```\n\n----------------------------------------\n\nTITLE: Implementing Sequential RuntimeFlagsPatch Application in TypeScript\nDESCRIPTION: Creates a RuntimeFlagsPatch that describes the sequential application of two patches - first applying 'self' patch, followed by 'that' patch. This function supports both curried and uncurried calling styles.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/RuntimeFlagsPatch-andThen.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const andThen: { (that: RuntimeFlagsPatch): (self: RuntimeFlagsPatch) => RuntimeFlagsPatch; (self: RuntimeFlagsPatch, that: RuntimeFlagsPatch): RuntimeFlagsPatch; }\n```\n\n----------------------------------------\n\nTITLE: Ordering Semigroup Declaration in Effect TS\nDESCRIPTION: This code snippet declares the Semigroup constant for the Ordering type in Effect TS. The Semigroup instance allows combining two Ordering values.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/data-Ordering-Semigroup.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const Semigroup: semigroup.Semigroup<Ordering>\n```\n\n----------------------------------------\n\nTITLE: Implementing Error Cause Mapping in TypeScript Micro Effects\nDESCRIPTION: Function declaration for mapErrorCause that transforms the MicroCause object of a given Micro effect. It supports both curried and uncurried forms for flexible usage patterns.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Micro-mapErrorCause.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const mapErrorCause: { <E, E2>(f: (e: MicroCause<E>) => MicroCause<E2>): <A, R>(self: Micro<A, E, R>) => Micro<A, E2, R>; <A, E, R, E2>(self: Micro<A, E, R>, f: (e: MicroCause<E>) => MicroCause<E2>): Micro<A, E2, R>; }\n```\n\n----------------------------------------\n\nTITLE: Creating a Micro Schedule with Constant Delay in TypeScript\nDESCRIPTION: This TypeScript snippet declares a function named `scheduleSpaced` that generates a micro schedule expecting a constant delay in milliseconds. It is part of the 'Micro' module in the 'effect' package and is available since version 3.4.6. The function takes in a single parameter of type number and returns a `MicroSchedule` object.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Micro-scheduleSpaced.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const scheduleSpaced: (millis: number) => MicroSchedule\n```\n\n----------------------------------------\n\nTITLE: Creating a sleep effect with Effect Micro\nDESCRIPTION: This code snippet shows the declaration of the `sleep` function within the `Micro` module. The function takes a number representing milliseconds as input and returns a `Micro` effect that, when executed, will pause the program for that duration. It is part of the Effect-TS library.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Micro-sleep.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const sleep: (millis: number) => Micro<void>\n```\n\n----------------------------------------\n\nTITLE: Declaring failCause Function in TypeScript for Effect Channel Module\nDESCRIPTION: This code snippet declares the failCause function, which constructs a channel that fails immediately with a specified Cause. It takes a Cause<E> as an argument and returns a Channel that never succeeds and always fails with the given cause.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Channel-failCause.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const failCause: <E>(cause: Cause.Cause<E>) => Channel<never, unknown, E, unknown, never, unknown>\n```\n\n----------------------------------------\n\nTITLE: Declaring Layer File Tree ConfigProvider in TypeScript\nDESCRIPTION: The function `layerFileTree` declares a layer that adds a file tree ConfigProvider to the environment, effectively upgrading the current configuration mechanism. It optionally takes a configuration object with a root directory parameter. The function returns a Layer that integrates file and path management. This code assumes existing types such as `Layer`, `Path`, and `FileSystem`. This function is intended for environments that require file-based configuration management.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/PlatformConfigProvider-layerFileTree.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const layerFileTree: (options?: { readonly rootDirectory?: string; }) => Layer.Layer<never, never, Path.Path | FileSystem.FileSystem>\n```\n\n----------------------------------------\n\nTITLE: Implementing Race Operation in TypeScript using Micro.raceFirst\nDESCRIPTION: Defines a function that races two effects, returning the result of whichever effect completes (succeeds or fails) first. When one effect completes, the other effect is immediately interrupted. Function supports both curried and uncurried calling styles.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Micro-raceFirst.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const raceFirst: { \n  <A2, E2, R2>(that: Micro<A2, E2, R2>): <A, E, R>(self: Micro<A, E, R>) => Micro<A | A2, E | E2, R | R2>; \n  <A, E, R, A2, E2, R2>(self: Micro<A, E, R>, that: Micro<A2, E2, R2>): Micro<A | A2, E | E2, R | R2>; \n}\n```\n\n----------------------------------------\n\nTITLE: Declaring ExceededCapacityException Type Identifier in TypeScript\nDESCRIPTION: Defines a unique symbol constant that serves as a type identifier for ExceededCapacityException. This symbol is used to uniquely identify and type-check exceptions related to capacity overflow in resources.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Cause-ExceededCapacityExceptionTypeId.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const ExceededCapacityExceptionTypeId: unique symbol\n```\n\n----------------------------------------\n\nTITLE: Using negate to invert boolean Effect values in TypeScript\nDESCRIPTION: The `negate` function takes an Effect that resolves to a boolean value and returns a new Effect with the boolean value negated. It maintains the same error type and resource requirements of the original Effect.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-negate.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const negate: <E, R>(self: Effect<boolean, E, R>) => Effect<boolean, E, R>\n```\n\n----------------------------------------\n\nTITLE: Checking for Tag Type in TypeScript using Effect Library\nDESCRIPTION: This snippet demonstrates how to use the Context.isTag function to check if a given input is a Tag. It imports the necessary modules, creates a Tag using Context.GenericTag, and then asserts that the result of isTag is true for this input.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Context-isTag.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { Context } from \"effect\"\n\nassert.strictEqual(Context.isTag(Context.GenericTag(\"Tag\")), true)\n```\n\n----------------------------------------\n\nTITLE: Doc.flatAlt Type Signature in TypeScript\nDESCRIPTION: Type signature for the flatAlt function showing its polymorphic nature and ability to work with different Doc types.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Doc-flatAlt.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const flatAlt: { <B>(that: Doc<B>): <A>(self: Doc<A>) => Doc<B | A>; <A, B>(self: Doc<A>, that: Doc<B>): Doc<A | B>; }\n```\n\n----------------------------------------\n\nTITLE: Defining Single Character Document Type in TypeScript\nDESCRIPTION: Type declaration for the char function that creates a document containing a single character. The function accepts a string parameter and returns a Doc type with never as the type parameter. Important constraint: the input character cannot be a newline character.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Doc-char.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const char: (char: string) => Doc<never>\n```\n\n----------------------------------------\n\nTITLE: Declaring DateTimeInsert Field for UTC Date-Time Handling in Effect SQL (TypeScript)\nDESCRIPTION: This TypeScript snippet declares the DateTimeInsert constant, which represents a date-time value that is to be inserted as the current DateTime in UTC format. It specifies that this field will be serialized as a string for database operations and is excluded from update operations, ensuring it is only available for selection. The declaration is part of the larger model structure provided by the `@effect/sql` package.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Model-DateTimeInsert.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const DateTimeInsert: DateTimeInsert\n```\n\n----------------------------------------\n\nTITLE: Checking for Sequential ExecutionStrategy in TypeScript\nDESCRIPTION: This function determines if a given ExecutionStrategy is an instance of Sequential. It returns true if the strategy is Sequential, false otherwise. The function uses a type predicate to narrow the type of the input parameter.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/ExecutionStrategy-isSequential.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const isSequential: (self: ExecutionStrategy) => self is Sequential\n```\n\n----------------------------------------\n\nTITLE: Type Signature of isUint8Array Function in TypeScript\nDESCRIPTION: This snippet shows the TypeScript type signature for the isUint8Array function. It's a type predicate that narrows the input type to Uint8Array when it returns true.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Predicate-isUint8Array.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const isUint8Array: (input: unknown) => input is Uint8Array\n```\n\n----------------------------------------\n\nTITLE: Declaring a Double Quote Document Constant in TypeScript\nDESCRIPTION: This code snippet defines a constant named 'dquote' which represents a document containing a single double quote character. The type signature indicates it accepts never as a generic parameter, meaning it doesn't have specific context requirements.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Doc-dquote.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const dquote: Doc<never>\n```\n\n----------------------------------------\n\nTITLE: Checking for ExceededCapacityException in TypeScript\nDESCRIPTION: A type guard function that checks if an unknown value is an ExceededCapacityException. This utility helps with type narrowing and error handling in Effect.io applications.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Cause-isExceededCapacityException.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const isExceededCapacityException: (u: unknown) => u is ExceededCapacityException\n```\n\n----------------------------------------\n\nTITLE: Comparing BigDecimal Values with lessThan in TypeScript\nDESCRIPTION: Demonstrates how to use the lessThan function from effect/BigDecimal to compare two BigDecimal values. The function returns true if the first value is less than the second, and false otherwise.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/BigDecimal-lessThan.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { lessThan, unsafeFromString } from \"effect/BigDecimal\"\n\nassert.deepStrictEqual(lessThan(unsafeFromString(\"2\"), unsafeFromString(\"3\")), true)\nassert.deepStrictEqual(lessThan(unsafeFromString(\"3\"), unsafeFromString(\"3\")), false)\nassert.deepStrictEqual(lessThan(unsafeFromString(\"4\"), unsafeFromString(\"3\")), false)\n```\n\n----------------------------------------\n\nTITLE: Declaring AnsiDoc eraseEndLine Function in TypeScript\nDESCRIPTION: Defines the eraseEndLine constant which clears the terminal from current cursor position to the end of the current line without changing the cursor position. This is part of the @effect/printer-ansi package's AnsiDoc module.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/AnsiDoc-eraseEndLine.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const eraseEndLine: AnsiDoc\n```\n\n----------------------------------------\n\nTITLE: Stream.zipAllRight function definition in TypeScript\nDESCRIPTION: Defines the `zipAllRight` function for zipping two streams. It allows specifying a default value to use if the 'self' stream (left-hand side) terminates before the 'that' stream (right-hand side). The function returns a new stream containing only elements from the 'that' stream, with the specified default value when needed.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-zipAllRight.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const zipAllRight: { <A2, E2, R2>(that: Stream<A2, E2, R2>, defaultRight: A2): <A, E, R>(self: Stream<A, E, R>) => Stream<A2, E2 | E, R2 | R>; <A, E, R, A2, E2, R2>(self: Stream<A, E, R>, that: Stream<A2, E2, R2>, defaultRight: A2): Stream<A2, E | E2, R | R2>; }\n```\n\n----------------------------------------\n\nTITLE: Creating BigDecimal from Number in TypeScript\nDESCRIPTION: Demonstrates how to use BigDecimal.safeFromNumber to create BigDecimal values from various number inputs. It shows successful conversions and handling of invalid inputs like Infinity.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/BigDecimal-safeFromNumber.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { BigDecimal, Option } from \"effect\"\n\nassert.deepStrictEqual(BigDecimal.safeFromNumber(123), Option.some(BigDecimal.make(123n, 0)))\nassert.deepStrictEqual(BigDecimal.safeFromNumber(123.456), Option.some(BigDecimal.make(123456n, 3)))\nassert.deepStrictEqual(BigDecimal.safeFromNumber(Infinity), Option.none())\n```\n\n----------------------------------------\n\nTITLE: Transforming Micro Effect Type in TypeScript\nDESCRIPTION: Function signature for asVoid that transforms a Micro effect by replacing its success value type with void while preserving error and environment types. Used for cases where the success value is not needed in subsequent operations.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Micro-asVoid.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const asVoid: <A, E, R>(self: Micro<A, E, R>) => Micro<void, E, R>\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Function.flip Usage in TypeScript\nDESCRIPTION: This example demonstrates how to use the flip function to reverse the order of arguments for a curried function. It creates a function that subtracts the length of a string from a number, then uses flip to invert the argument order.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Function-flip.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { flip } from \"effect/Function\"\n\nconst f = (a: number) => (b: string) => a - b.length\n\nassert.deepStrictEqual(flip(f)('aaa')(2), -1)\n```\n\n----------------------------------------\n\nTITLE: Effect.timeoutOption Function Signature in TypeScript\nDESCRIPTION: The TypeScript signature for the Effect.timeoutOption function. It shows the function's type definition, including its parameters and return type.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-timeoutOption.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const timeoutOption: { (duration: Duration.DurationInput): <A, E, R>(self: Effect<A, E, R>) => Effect<Option.Option<A>, E, R>; <A, E, R>(self: Effect<A, E, R>, duration: Duration.DurationInput): Effect<Option.Option<A>, E, R>; }\n```\n\n----------------------------------------\n\nTITLE: Type declaration for hardLine in @effect/printer Doc module (TypeScript)\nDESCRIPTION: The type signature for the hardLine constant in the Doc module. It shows that hardLine is a Doc that never produces an error (represented by the never type parameter).\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Doc-hardLine.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const hardLine: Doc<never>\n```\n\n----------------------------------------\n\nTITLE: Type Definition for isFunction Predicate\nDESCRIPTION: TypeScript type declaration for the isFunction predicate. The function takes an unknown input and returns a type predicate indicating if the input is a Function type.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Function-isFunction.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const isFunction: (input: unknown) => input is Function\n```\n\n----------------------------------------\n\nTITLE: Constructing LogLevel Config in Effect.ts\nDESCRIPTION: This function constructs a config for a LogLevel value. It optionally accepts a name parameter to identify the configuration value.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Config-logLevel.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const logLevel: (name?: string) => Config<LogLevel.LogLevel>\n```\n\n----------------------------------------\n\nTITLE: Checking for PopAnnotationStream Type in Effect Printer\nDESCRIPTION: A type guard function that determines if a DocStream is specifically a PopAnnotationStream. It returns a boolean indicating whether the provided DocStream is of type PopAnnotationStream.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/DocStream-isPopAnnotationStream.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const isPopAnnotationStream: <A>(self: DocStream<A>) => self is PopAnnotationStream<A>\n```\n\n----------------------------------------\n\nTITLE: Stream Repeat Type Signature\nDESCRIPTION: TypeScript type definition for the Stream.repeat method, showing its flexible implementation with generics and schedule-based repetition\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-repeat.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const repeat: { <B, R2>(schedule: Schedule.Schedule<B, unknown, R2>): <A, E, R>(self: Stream<A, E, R>) => Stream<A, E, R2 | R>; <A, E, R, B, R2>(self: Stream<A, E, R>, schedule: Schedule.Schedule<B, unknown, R2>): Stream<A, E, R | R2>; }\n```\n\n----------------------------------------\n\nTITLE: Effect.matchCause TypeScript Function Signature\nDESCRIPTION: The type signature for the Effect.matchCause function, showing its polymorphic nature and the structure of its options parameter. Demonstrates type parameters for effect result, error, and environment types.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-matchCause.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const matchCause: { <E, A2, A, A3>(options: { readonly onFailure: (cause: Cause.Cause<E>) => A2; readonly onSuccess: (a: A) => A3; }): <R>(self: Effect<A, E, R>) => Effect<A2 | A3, never, R>; <A, E, R, A2, A3>(self: Effect<A, E, R>, options: { readonly onFailure: (cause: Cause.Cause<E>) => A2; readonly onSuccess: (a: A) => A3; }): Effect<A2 | A3, never, R>; }\n```\n\n----------------------------------------\n\nTITLE: Implementing Line Erasure in ANSI Terminal\nDESCRIPTION: Function that erases a specified number of lines from the current cursor position upward in an ANSI terminal. Takes a numeric parameter for the number of rows to erase and returns an Ansi control sequence.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Ansi-eraseLines.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const eraseLines: (rows: number) => Ansi\n```\n\n----------------------------------------\n\nTITLE: Effect.isFailure Type Signature\nDESCRIPTION: TypeScript type signature for the isFailure function, showing it takes an Effect<A,E,R> and returns an Effect<boolean,never,R>.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-isFailure.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const isFailure: <A, E, R>(self: Effect<A, E, R>) => Effect<boolean, never, R>\n```\n\n----------------------------------------\n\nTITLE: Defining Cause.Interrupt Interface in TypeScript\nDESCRIPTION: This code snippet defines the Cause.Interrupt interface, which represents fiber interruption within a Cause. It extends several other interfaces and includes properties for the interrupt tag and fiber ID.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Cause-Interrupt.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface Interrupt extends Cause.Variance<never>, Equal.Equal, Pipeable, Inspectable {\n  readonly _tag: \"Interrupt\"\n  readonly fiberId: FiberId.FiberId\n}\n```\n\n----------------------------------------\n\nTITLE: Effect Schema pickLiteral Example\nDESCRIPTION: This example demonstrates how to use `Schema.pickLiteral` to create a new schema from a literal schema, selecting the literals 'a' and 'b'. It uses `Schema.decodeSync` to decode valid literal values and `Schema.decodeUnknownEither` to verify invalid values result in a left Either.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Schema-pickLiteral.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { Either, Schema } from \"effect\"\n\nconst schema = Schema.Literal(\"a\", \"b\", \"c\").pipe(Schema.pickLiteral(\"a\", \"b\"))\n\nassert.deepStrictEqual(Schema.decodeSync(schema)(\"a\"), \"a\")\nassert.deepStrictEqual(Schema.decodeSync(schema)(\"b\"), \"b\")\nassert.strictEqual(Either.isLeft(Schema.decodeUnknownEither(schema)(\"c\")), true)\n```\n\n----------------------------------------\n\nTITLE: Implementing Type Guard for DocStream in TypeScript\nDESCRIPTION: The isDocStream function is a type guard that checks if the given value is a DocStream. It takes an unknown parameter and returns a boolean indicating whether the value is a DocStream of unknown type.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/DocStream-isDocStream.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const isDocStream: (u: unknown) => u is DocStream<unknown>\n```\n\n----------------------------------------\n\nTITLE: Using BigDecimal.abs Function in TypeScript\nDESCRIPTION: Demonstrates how to use the abs function to calculate absolute values of BigDecimal numbers. The example shows converting string representations of negative and positive numbers to their absolute values.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/BigDecimal-abs.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { abs, unsafeFromString } from \"effect/BigDecimal\"\n\nassert.deepStrictEqual(abs(unsafeFromString(\"-5\")), unsafeFromString(\"5\"))\nassert.deepStrictEqual(abs(unsafeFromString(\"0\")), unsafeFromString(\"0\"))\nassert.deepStrictEqual(abs(unsafeFromString(\"5\")), unsafeFromString(\"5\"))\n```\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const abs: (n: BigDecimal) => BigDecimal\n```\n\n----------------------------------------\n\nTITLE: Signature of Empty Stream - TypeScript\nDESCRIPTION: Presents the TypeScript signature for the empty stream, indicating that it can never produce any values or errors, reinforcing the concept of an empty stream in the Effect.js framework.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-empty.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const empty: Stream<never, never, never>\n```\n\n----------------------------------------\n\nTITLE: Creating an Option with No Value - TypeScript\nDESCRIPTION: This snippet demonstrates how to create an Option representing no value using the Option.none method. It imports the Option module from Effect and uses the none function to instantiate an Option<never> type. This allows developers to represent absence clearly in their type-safe applications.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Option-none.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Option } from \"effect\"\n\n// An Option holding no value\n//\n//      ┌─── Option<never>\n//      ▼\nconst noValue = Option.none()\n\nconsole.log(noValue)\n// Output: { _id: 'Option', _tag: 'None' }\n```\n\n----------------------------------------\n\nTITLE: Defining CloseableScope Interface in TypeScript\nDESCRIPTION: The CloseableScope interface extends Scope and Pipeable, providing a method to close the scope with a specified exit value, ensuring that all finalizers are executed. It is designed for managing resources effectively within a structured scope.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Scope-CloseableScope.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface CloseableScope extends Scope, Pipeable {\n  readonly [CloseableScopeTypeId]: CloseableScopeTypeId\n\n  /**\n   * Closes this scope with the given exit value, running all finalizers.\n   *\n   * @internal\n   */\n  close(exit: Exit.Exit<unknown, unknown>): Effect.Effect<void>\n}\n```\n\n----------------------------------------\n\nTITLE: Defining FunctionWithSpanOptions Interface in TypeScript for Effect Tracing\nDESCRIPTION: This interface defines the options for creating a new span when wrapping a function that returns an effect. It specifies parameters like span name, attributes, links, parent span, root flag, context, and span kind for tracing purposes.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-FunctionWithSpanOptions.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface FunctionWithSpanOptions {\n  readonly name: string\n  readonly attributes?: Record<string, unknown> | undefined\n  readonly links?: ReadonlyArray<Tracer.SpanLink> | undefined\n  readonly parent?: Tracer.AnySpan | undefined\n  readonly root?: boolean | undefined\n  readonly context?: Context.Context<never> | undefined\n  readonly kind?: Tracer.SpanKind | undefined\n}\n```\n\n----------------------------------------\n\nTITLE: Defining RuntimeFlag Type in TypeScript\nDESCRIPTION: Defines a TypeScript type for representing runtime feature flags in the Effect runtime. This type combines a numeric value with a unique symbol to ensure type safety through nominal typing.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/RuntimeFlags-RuntimeFlag.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ntype RuntimeFlag = number & {\n  readonly RuntimeFlag: unique symbol\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Bounded.clamp Function in TypeScript\nDESCRIPTION: The clamp function takes a Bounded typeclass instance for type A and returns a function that constrains any value of type A to be within the bounds defined by the typeclass. This is useful for ensuring values stay within a valid range.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Bounded-clamp.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const clamp: <A>(B: Bounded<A>) => (a: A) => A\n```\n\n----------------------------------------\n\nTITLE: TypeScript Function Signature for BigDecimal.safeFromNumber\nDESCRIPTION: Provides the TypeScript function signature for the BigDecimal.safeFromNumber function. It takes a number as input and returns an Option of BigDecimal.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/BigDecimal-safeFromNumber.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const safeFromNumber: (n: number) => Option.Option<BigDecimal>\n```\n\n----------------------------------------\n\nTITLE: Implementing Fatal Error Effect with Effect.dieSync in TypeScript\nDESCRIPTION: Defines a function that creates an effect which terminates with a fatal error. The error evaluation is lazy, meaning it only occurs when the effect is executed. Takes a LazyArg<unknown> parameter and returns an Effect<never>.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-dieSync.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const dieSync: (evaluate: LazyArg<unknown>) => Effect<never>\n```\n\n----------------------------------------\n\nTITLE: Declaring 'ofComposition' Function in TypeScript\nDESCRIPTION: This snippet declares the 'ofComposition' function, which composes two type classes of type 'Of'. It facilitates the creation of a composition for values of type 'A' in the context of the Effect-TS framework. The function takes two parameters, each of which is an instance of the 'Of' type and returns a function that takes a value of type 'A'.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Of-ofComposition.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const ofComposition: <F extends TypeLambda, G extends TypeLambda>(F: Of<F>, G: Of<G>) => <A>(a: A) => Kind<F, unknown, never, never, Kind<G, unknown, never, never, A>>\n```\n\n----------------------------------------\n\nTITLE: Implementing Iterable.flatten in TypeScript\nDESCRIPTION: Function signature for flattening an Iterable of Iterables into a single Iterable. Takes a nested Iterable structure as input and returns a flattened single-level Iterable.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Iterable-flatten.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const flatten: <A>(self: Iterable<Iterable<A>>) => Iterable<A>\n```\n\n----------------------------------------\n\nTITLE: Summing numbers with sumAll in Effect\nDESCRIPTION: Demonstrates the usage of `sumAll` function from the `effect/Number` module to calculate the sum of an array of numbers.  It imports `assert` and `sumAll`, then asserts that the sum of `[2, 3, 4]` is equal to `9`.  This snippet showcases a basic use case within a testing environment.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Number-sumAll.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { sumAll } from \"effect/Number\"\n\nassert.deepStrictEqual(sumAll([2, 3, 4]), 9)\n```\n\n----------------------------------------\n\nTITLE: Retrieving Enabled RuntimeFlags from RuntimeFlagsPatch in TypeScript\nDESCRIPTION: The enabledSet function returns a ReadonlySet containing the RuntimeFlags that are enabled by the specified RuntimeFlagsPatch. This allows for inspection of which flags are enabled in a given patch configuration.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/RuntimeFlagsPatch-enabledSet.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const enabledSet: (self: RuntimeFlagsPatch) => ReadonlySet<RuntimeFlags.RuntimeFlag>\n```\n\n----------------------------------------\n\nTITLE: Getting Last Element from ReadonlyArray in TypeScript\nDESCRIPTION: A utility function that safely retrieves the last element from a ReadonlyArray. Returns an Option type containing the last element if the array is non-empty, or None if the array is empty.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Array-last.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const last: <A>(self: ReadonlyArray<A>) => Option.Option<A>\n```\n\n----------------------------------------\n\nTITLE: Creating RedBlackTree from Iterable - TypeScript Type Definition\nDESCRIPTION: Type definition for the fromIterable function that creates a new RedBlackTree from an iterable collection of key/value pairs. It provides two overloads: one that takes an Order instance first, and another that takes the entries first followed by the Order instance.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/RedBlackTree-fromIterable.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const fromIterable: { <B>(ord: Order<B>): <K extends B, V>(entries: Iterable<readonly [K, V]>) => RedBlackTree<K, V>; <K extends B, V, B>(entries: Iterable<readonly [K, V]>, ord: Order<B>): RedBlackTree<K, V>; }\n```\n\n----------------------------------------\n\nTITLE: Boolean.some() Function Signature\nDESCRIPTION: TypeScript type definition for the some() function. Takes an Iterable of boolean values and returns a single boolean value.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Boolean-some.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const some: (collection: Iterable<boolean>) => boolean\n```\n\n----------------------------------------\n\nTITLE: Initializing TArray FindFirstIndexWhereFrom TypeScript Function\nDESCRIPTION: A transactional array method that searches for the first index matching a predicate, starting from a specified index. Returns an Optional number representing the found index within an STM (Software Transactional Memory) context.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TArray-findFirstIndexWhereFrom.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const findFirstIndexWhereFrom: { <A>(predicate: Predicate<A>, from: number): (self: TArray<A>) => STM.STM<Option.Option<number>>; <A>(self: TArray<A>, predicate: Predicate<A>, from: number): STM.STM<Option.Option<number>>; }\n```\n\n----------------------------------------\n\nTITLE: Creating Inverse RuntimeFlagsPatch in TypeScript\nDESCRIPTION: Function that creates a RuntimeFlagsPatch which describes the inverse of a specified RuntimeFlagsPatch. This allows for reversing the effects of a runtime flag patch.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/RuntimeFlagsPatch-inverse.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const inverse: (patch: RuntimeFlagsPatch) => RuntimeFlagsPatch\n```\n\n----------------------------------------\n\nTITLE: Checking if a Doc is a Cat Type in TypeScript\nDESCRIPTION: This function checks if a specified Doc is of type Cat. It takes a Doc<A> as input and returns a boolean indicating whether the Doc is a Cat<A>. The function includes a type predicate for TypeScript type narrowing.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Doc-isCat.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const isCat: <A>(self: Doc<A>) => self is Cat<A>\n```\n\n----------------------------------------\n\nTITLE: Trie.size Function Signature in TypeScript\nDESCRIPTION: This code snippet shows the TypeScript type signature for the Trie.size function. It takes a Trie<V> as input and returns a number representing the size of the Trie.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Trie-size.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const size: <V>(self: Trie<V>) => number\n```\n\n----------------------------------------\n\nTITLE: Type Signature for Boolean NAND Function\nDESCRIPTION: Shows the TypeScript type signature for the 'nand' function. The function supports both curried and non-curried invocation patterns for combining two boolean values.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Boolean-nand.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const nand: { (that: boolean): (self: boolean) => boolean; (self: boolean, that: boolean): boolean; }\n```\n\n----------------------------------------\n\nTITLE: Implementing Live Service Scoping in TypeScript for Effect Testing\nDESCRIPTION: The withLiveScoped function sets the implementation of a live service to a specified value and restores it to its original value when the scope is closed. It takes a TestLive object as input and returns an Effect that requires a Scope and never fails.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TestServices-withLiveScoped.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const withLiveScoped: (live: Live.TestLive) => Effect.Effect<void, never, Scope.Scope>\n```\n\n----------------------------------------\n\nTITLE: Demonstrating isUnknown Function Usage in TypeScript\nDESCRIPTION: This example shows how to use the isUnknown function from the Predicate module. It demonstrates that the function always returns true for any input, including null, undefined, objects, and arrays.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Predicate-isUnknown.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { isUnknown } from \"effect/Predicate\"\n\nassert.deepStrictEqual(isUnknown(null), true)\nassert.deepStrictEqual(isUnknown(undefined), true)\n\nassert.deepStrictEqual(isUnknown({}), true)\nassert.deepStrictEqual(isUnknown([]), true)\n```\n\n----------------------------------------\n\nTITLE: Using Logger.withLeveledConsole in Effect.io\nDESCRIPTION: Demonstrates how to create a logger that routes log messages to appropriate console methods based on log levels. The example shows replacing the default logger with a leveled console logger using Effect's logging system.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Logger-withLeveledConsole.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Logger, Effect } from \"effect\"\n\nconst loggerLayer = Logger.replace(\n  Logger.defaultLogger,\n  Logger.withLeveledConsole(Logger.stringLogger),\n)\n\nEffect.gen(function* () {\n  yield* Effect.logError(\"an error\")\n  yield* Effect.logInfo(\"an info\")\n}).pipe(Effect.provide(loggerLayer))\n```\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const withLeveledConsole: <M, O>(self: Logger<M, O>) => Logger<M, void>\n```\n\n----------------------------------------\n\nTITLE: Configuring Unhandled Error Logging in Effect\nDESCRIPTION: Demonstrates how to configure the logging level for unhandled errors in child fibers using Effect.withUnhandledErrorLogLevel. The example shows creating a fiber that fails with an error and setting its log level to Error.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-withUnhandledErrorLogLevel.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Effect, Fiber, LogLevel, Option } from \"effect\"\n\nconst program = Effect.gen(function*() {\n  const fiber = yield* Effect.fork(Effect.fail(\"Unhandled error!\"))\n  yield* Fiber.join(fiber)\n})\n\nEffect.runFork(program.pipe(Effect.withUnhandledErrorLogLevel(Option.some(LogLevel.Error))))\n// Output:\n// timestamp=... level=ERROR fiber=#1 message=\"Fiber terminated with an unhandled error\" cause=\"Error: Unhandled error!\"\n```\n\n----------------------------------------\n\nTITLE: Declaring Sink.zipLeft in TypeScript\nDESCRIPTION: This snippet defines the zipLeft function that allows combining two Sink instances while only preserving the result from the first one. It supports optional concurrency management through the options parameter. This function is useful in contexts where results from multiple sinks are needed but only the first sink's result is of interest, thus optimizing data handling.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Sink-zipLeft.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const zipLeft: { <A2, In, In2 extends In, L2, E2, R2>(that: Sink<A2, In2, L2, E2, R2>, options?: { readonly concurrent?: boolean | undefined; } | undefined): <A, L, E, R>(self: Sink<A, In, L, E, R>) => Sink<A, In & In2, L2 | L, E2 | E, R2 | R>; <A, In, L, E, R, A2, In2 extends In, L2, E2, R2>(self: Sink<A, In, L, E, R>, that: Sink<A2, In2, L2, E2, R2>, options?: { readonly concurrent?: boolean | undefined; } | undefined): Sink<A, In & In2, L | L2, E | E2, R | R2>; }\n```\n\n----------------------------------------\n\nTITLE: Logging TRACE Messages with Effect in TypeScript\nDESCRIPTION: Demonstrates how to use the Effect.logTrace function to log messages at the TRACE level. The example shows how to adjust the minimum log level to display TRACE messages.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-logTrace.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Effect, Logger, LogLevel } from \"effect\"\n\nconst program = Effect.logTrace(\"message1\").pipe(Logger.withMinimumLogLevel(LogLevel.Trace))\n\nEffect.runFork(program)\n// timestamp=... level=TRACE fiber=#0 message=message1\n```\n\n----------------------------------------\n\nTITLE: Creating Effect Stream from ReadableStreamBYOBReader\nDESCRIPTION: This TypeScript code snippet shows the signature of the `fromReadableStreamByob` function, used to create an Effect Stream from a `ReadableStreamBYOBReader`. It takes options including a lazy evaluator for the stream, an error handler, a buffer size, and a flag to release the lock on end, or simpler arguments for the stream evaluator, error handler, and an allocation size.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-fromReadableStreamByob.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const fromReadableStreamByob: { <E>(options: { readonly evaluate: LazyArg<ReadableStream<Uint8Array>>; readonly onError: (error: unknown) => E; readonly bufferSize?: number | undefined; readonly releaseLockOnEnd?: boolean | undefined; }): Stream<Uint8Array, E>; <E>(evaluate: LazyArg<ReadableStream<Uint8Array>>, onError: (error: unknown) => E, allocSize?: number): Stream<Uint8Array, E>; }\n```\n\n----------------------------------------\n\nTITLE: Implementing TQueue.offer for Transactional Queue in TypeScript\nDESCRIPTION: The offer function places one value in a transactional queue. It can be used in two ways: either by passing the value first and then the queue, or by passing the queue first and then the value. Returns an STM transaction that completes with void.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TQueue-offer.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const offer: { <A>(value: A): (self: TEnqueue<A>) => STM.STM<void>; <A>(self: TEnqueue<A>, value: A): STM.STM<void>; }\n```\n\n----------------------------------------\n\nTITLE: Enqueue Multiple Values into MutableQueue (TypeScript)\nDESCRIPTION: This code snippet demonstrates the `offerAll` function, which enqueues a collection of values into a `MutableQueue`. It returns a `Chunk` of values that were not able to be enqueued due to capacity constraints. The function can be used either by currying the queue or passing it as the first argument.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/MutableQueue-offerAll.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const offerAll: { <A>(values: Iterable<A>): (self: MutableQueue<A>) => Chunk.Chunk<A>; <A>(self: MutableQueue<A>, values: Iterable<A>): Chunk.Chunk<A>; }\n```\n\n----------------------------------------\n\nTITLE: Defining ParallelN Interface in ExecutionStrategy Module\nDESCRIPTION: Defines the ParallelN interface that represents a strategy to execute effects in parallel with a specified concurrency limit. It contains a tag for type identification and a parallelism property to control the maximum number of concurrent fibers.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/ExecutionStrategy-ParallelN.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface ParallelN {\n  readonly _tag: \"ParallelN\"\n  readonly parallelism: number\n}\n```\n\n----------------------------------------\n\nTITLE: Checking OpSupervision RuntimeFlag in TypeScript\nDESCRIPTION: This function checks if the OpSupervision RuntimeFlag is enabled for a given RuntimeFlags instance. It returns true if the flag is enabled and false otherwise.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/RuntimeFlags-opSupervision.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const opSupervision: (self: RuntimeFlags) => boolean\n```\n\n----------------------------------------\n\nTITLE: Doc.align Function Signature in TypeScript\nDESCRIPTION: This code snippet shows the TypeScript type signature for the Doc.align function. It takes a Doc<A> as input and returns a Doc<A>.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Doc-align.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const align: <A>(self: Doc<A>) => Doc<A>\n```\n\n----------------------------------------\n\nTITLE: Implementing a Predicate-Based Sink in TypeScript using Effect\nDESCRIPTION: Defines a sink that returns whether any element in the stream satisfies the specified predicate. The sink takes a predicate function as input and returns a boolean result indicating if any element matches the condition.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Sink-some.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const some: <In>(predicate: Predicate<In>) => Sink<boolean, In, In>\n```\n\n----------------------------------------\n\nTITLE: Declaring STM Fiber Termination Function\nDESCRIPTION: A function that creates an STM effect which terminates the current fiber by raising a runtime exception with a provided message. This is useful for controlled failure scenarios within transactional contexts.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/STM-dieMessage.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const dieMessage: (message: string) => STM<never>\n```\n\n----------------------------------------\n\nTITLE: Creating ConfigProvider in TypeScript\nDESCRIPTION: This function creates a new config provider with options for loading configurations and handling errors. It takes an object with 'load' and 'flattened' properties, where 'load' is a function to load config values and 'flattened' is a flat config provider.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/ConfigProvider-make.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const make: (options: { readonly load: <A>(config: Config.Config<A>) => Effect.Effect<A, ConfigError.ConfigError>; readonly flattened: ConfigProvider.Flat; }) => ConfigProvider\n```\n\n----------------------------------------\n\nTITLE: Creating a Zoned DateTime with European Timezone in TypeScript\nDESCRIPTION: This example demonstrates how to create a DateTime.Zoned object using DateTime.unsafeMakeZoned with the current date and the Europe/London timezone. The input is treated as UTC by default with the timezone attached.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/DateTime-unsafeMakeZoned.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { DateTime } from \"effect\"\n\nDateTime.unsafeMakeZoned(new Date(), { timeZone: \"Europe/London\" })\n```\n\n----------------------------------------\n\nTITLE: Checking if a Fiber is a RuntimeFiber in TypeScript\nDESCRIPTION: This function determines whether a specified Fiber instance is specifically a RuntimeFiber. It returns true if the fiber is a RuntimeFiber, and false otherwise. This type guard is useful when working with fiber implementations in the Effect ecosystem.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Fiber-isRuntimeFiber.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const isRuntimeFiber: <A, E>(self: Fiber<A, E>) => self is RuntimeFiber<A, E>\n```\n\n----------------------------------------\n\nTITLE: Defining Struct-based Equivalence in TypeScript\nDESCRIPTION: Type signature for creating an Equivalence comparison for structured data. Takes a record of Equivalence functions and returns a new Equivalence that compares corresponding properties of structs using those functions.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Equivalence-struct.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const struct: <R extends Record<string, Equivalence<any>>>(fields: R) => Equivalence<{ readonly [K in keyof R]: [R[K]] extends [Equivalence<infer A>] ? A : never; }>\n```\n\n----------------------------------------\n\nTITLE: Defining Empty Interface for Cause Module in TypeScript\nDESCRIPTION: This code snippet defines the Empty interface for the Cause module. It represents a lack of errors and extends various utility types. The interface includes a _tag property set to \"Empty\" for type discrimination.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Cause-Empty.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface Empty extends Cause.Variance<never>, Equal.Equal, Pipeable, Inspectable {\n  readonly _tag: \"Empty\"\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Pre-succeeded Fiber in Effect-TS\nDESCRIPTION: Creates a fiber that is already in a successful state with a provided value. This is useful for creating fibers that represent completed computations without actually executing any asynchronous work.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Fiber-succeed.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const succeed: <A>(value: A) => Fiber<A>\n```\n\n----------------------------------------\n\nTITLE: Checking for Non-Empty ReadonlyArray in TypeScript using Effect Library\nDESCRIPTION: This function determines if a ReadonlyArray is non-empty, narrowing its type to NonEmptyReadonlyArray. It returns true if the array contains at least one element, and false otherwise.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Array-isNonEmptyReadonlyArray.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Array } from \"effect\"\n\nconsole.log(Array.isNonEmptyReadonlyArray([])) // false\nconsole.log(Array.isNonEmptyReadonlyArray([1, 2, 3])) // true\n```\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const isNonEmptyReadonlyArray: <A>(self: ReadonlyArray<A>) => self is NonEmptyReadonlyArray<A>\n```\n\n----------------------------------------\n\nTITLE: DateTime.addDuration Function Signature\nDESCRIPTION: Type declaration for the addDuration function, showing its overloaded signatures for adding Duration to DateTime objects.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/DateTime-addDuration.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const addDuration: { (duration: Duration.DurationInput): <A extends DateTime>(self: A) => A; <A extends DateTime>(self: A, duration: Duration.DurationInput): A; }\n```\n\n----------------------------------------\n\nTITLE: Defining LazyArg Interface in TypeScript\nDESCRIPTION: This snippet shows the TypeScript interface definition for LazyArg. It defines a function that takes no arguments and returns a value of type A.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Function-LazyArg.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface LazyArg<A> {\n  (): A\n}\n```\n\n----------------------------------------\n\nTITLE: Declaring Fork Function in TypeScript for Effect RPC\nDESCRIPTION: Function signature for `fork` that wraps a response Effect or Stream to ensure concurrent execution regardless of the RpcServer concurrency setting. It takes a value of type A and returns a Fork<A>.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Rpc-fork.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const fork: <A>(value: A) => Fork<A>\n```\n\n----------------------------------------\n\nTITLE: Defining cursorNextLine Function for ANSI Cursor Movement in TypeScript\nDESCRIPTION: This function moves the cursor to the beginning of the line a specified number of rows down (default 1). It returns an AnsiDoc object, allowing for chaining of ANSI operations.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/AnsiDoc-cursorNextLine.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const cursorNextLine: (rows?: number) => AnsiDoc\n```\n\n----------------------------------------\n\nTITLE: Creating an Empty MutableList in Effect\nDESCRIPTION: This code snippet shows the TypeScript signature of the `empty` function within the `MutableList` module of the Effect library. This function is used to create an empty mutable list.  It takes no arguments and returns a `MutableList` of type `A`.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/MutableList-empty.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const empty: <A>() => MutableList<A>\n```\n\n----------------------------------------\n\nTITLE: Creating TSet from Iterable in Effect TS\nDESCRIPTION: This code snippet shows the type signature of the `fromIterable` function.  It takes an `Iterable<A>` as input and returns an `STM.STM<TSet<A>>`.  This allows creating a transactional set from any iterable data structure.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TSet-fromIterable.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const fromIterable: <A>(iterable: Iterable<A>) => STM.STM<TSet<A>>\n```\n\n----------------------------------------\n\nTITLE: Implementing a Chunk Folding Sink in TypeScript with Effect.io\nDESCRIPTION: Creates a sink that processes chunks of input data by folding them with a provided function and initial state. The function must preserve chunking-invariance when processing the input chunks.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Sink-foldLeftChunks.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const foldLeftChunks: <S, In>(s: S, f: (s: S, chunk: Chunk.Chunk<In>) => S) => Sink<S, In>\n```\n\n----------------------------------------\n\nTITLE: BigInt Predicate Declaration in TypeScript\nDESCRIPTION: This TypeScript snippet provides the function signature for the 'isBigInt' function, which determines if the input value is of type bigint. This declaration is part of the Predicate module in Effect, and it is crucial for type safety and implementing type predicates for bigint.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Predicate-isBigInt.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const isBigInt: (input: unknown) => input is bigint\n```\n\n----------------------------------------\n\nTITLE: Type Signature for Effect.transposeMapOption\nDESCRIPTION: The type declaration for the transposeMapOption function, which can be used in two ways: either with pipe syntax where the Option is provided first, or with direct function call where both Option and mapping function are provided together.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-transposeMapOption.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const transposeMapOption: (<A, B, E = never, R = never>(f: (self: A) => Effect<B, E, R>) => (self: Option.Option<A>) => Effect<Option.Option<B>, E, R>) & (<A, B, E = never, R = never>(self: Option.Option<A>, f: (self: A) => Effect<B, E, R>) => Effect<Option.Option<B>, E, R>)\n```\n\n----------------------------------------\n\nTITLE: Defining provideScope Function Type in TypeScript\nDESCRIPTION: Type definition for the provideScope function that enables providing a MicroScope to an effect. The function supports both curried and non-curried calling styles, taking a MicroScope and returning a function that transforms a Micro effect by providing the scope.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Micro-provideScope.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const provideScope: {\n  (scope: MicroScope): <A, E, R>(self: Micro<A, E, R>) => Micro<A, E, Exclude<R, MicroScope>>;\n  <A, E, R>(self: Micro<A, E, R>, scope: MicroScope): Micro<A, E, Exclude<R, MicroScope>>;\n}\n```\n\n----------------------------------------\n\nTITLE: Declaring DurationFromMillis Class in TypeScript\nDESCRIPTION: Defines a schema class that transforms a non-negative number (including Infinity) into a Duration object. The input value is treated as the number of milliseconds.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Schema-DurationFromMillis.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare class DurationFromMillis\n```\n\n----------------------------------------\n\nTITLE: Defining Stream Interface in TypeScript\nDESCRIPTION: TypeScript interface definition for Stream, which is a pull-based stream that can emit multiple values of type A, may fail with errors of type E, and uses a context of type R. The interface extends Stream.Variance and Pipeable, and includes Unify-related type definitions.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-Stream.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface Stream<out A, out E = never, out R = never> extends Stream.Variance<A, E, R>, Pipeable {\n  [Unify.typeSymbol]?: unknown\n  [Unify.unifySymbol]?: StreamUnify<this>\n  [Unify.ignoreSymbol]?: StreamUnifyIgnore\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Layer for File Tree Configuration - TypeScript\nDESCRIPTION: This snippet defines the 'layerFileTreeAdd' function signature for the PlatformConfigProvider in TypeScript. It specifies an optional configuration object that can contain a root directory, returning a Layer that deals with either Path or FileSystem types.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/PlatformConfigProvider-layerFileTreeAdd.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const layerFileTreeAdd: (options?: { readonly rootDirectory?: string; }) => Layer.Layer<never, never, Path.Path | FileSystem.FileSystem>\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Array.zip Function in Effect Library\nDESCRIPTION: Example showing how to use the Array.zip function to combine two arrays into pairs. When arrays have different lengths, excess elements from the longer array are discarded.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Array-zip.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Array } from \"effect\"\n\nconst result = Array.zip([1, 2, 3], ['a', 'b'])\nconsole.log(result) // [[1, 'a'], [2, 'b']]\n```\n\n----------------------------------------\n\nTITLE: Implementing Type Flip Operation in TypeScript Effect System\nDESCRIPTION: Function signature for flipping error and success types in a Micro effect. Takes a Micro effect with success type A and error type E, and returns a new Micro effect with these types swapped while preserving the environment type R.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Micro-flip.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const flip: <A, E, R>(self: Micro<A, E, R>) => Micro<E, A, R>\n```\n\n----------------------------------------\n\nTITLE: Config.unwrap Type Signature\nDESCRIPTION: Type declaration for the unwrap function showing its signature for converting wrapped config types to their unwrapped form.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Config-unwrap.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const unwrap: <A>(wrapped: Config.Wrap<A>) => Config<A>\n```\n\n----------------------------------------\n\nTITLE: Enclosing Documents in Double Quotes with @effect/printer's Doc.doubleQuoted\nDESCRIPTION: The doubleQuoted function takes a document of type Doc<A> and returns a new document of the same type that is enclosed in double quotes. This is useful for formatting strings or other content that needs to be represented as a quoted value.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Doc-doubleQuoted.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const doubleQuoted: <A>(self: Doc<A>) => Doc<A>\n```\n\n----------------------------------------\n\nTITLE: Type Signature for HttpApiBuilder.securitySetCookie Function\nDESCRIPTION: Function signature for the securitySetCookie method which takes an ApiKey security instance, a string or Redacted value, and optional cookie options to create a cookie-based authentication effect.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/HttpApiBuilder-securitySetCookie.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const securitySetCookie: (self: HttpApiSecurity.ApiKey, value: string | Redacted.Redacted, options?: Cookie[\"options\"]) => Effect.Effect<void>\n```\n\n----------------------------------------\n\nTITLE: Retrieving HashSet of FiberRefs in TypeScript\nDESCRIPTION: The fiberRefs function accepts a FiberRefs collection and returns a HashSet containing each FiberRef in the collection. This is useful for inspecting or operating on all fiber references at once.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/FiberRefs-fiberRefs.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const fiberRefs: (self: FiberRefs) => HashSet.HashSet<FiberRef.FiberRef<any>>\n```\n\n----------------------------------------\n\nTITLE: Options.choiceWithValue Signature\nDESCRIPTION: Presents the type signature of the `choiceWithValue` function, which takes a name (string) and an array of choices (tuples of string and any value) as input. It returns an `Options` type parameterized with the type of the values associated with the choices. This signature defines the function's input parameters and return type.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Options-choiceWithValue.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const choiceWithValue: <C extends ReadonlyArray<[string, any]>>(name: string, choices: C) => Options<C[number][1]>\n```\n\n----------------------------------------\n\nTITLE: Implementing Single Dot Character Document in Effect Printer\nDESCRIPTION: Defines a constant Doc instance that represents a single dot character (.) with no error type. This is a basic building block used in the Effect printer library for document composition.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Doc-dot.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const dot: Doc<never>\n```\n\n----------------------------------------\n\nTITLE: Implementing Cursor Down Movement in TypeScript for ANSI Terminals\nDESCRIPTION: Defines a function 'cursorDown' that moves the cursor down by a specified number of lines (default 1) in ANSI-compatible terminals. This function has no effect if the cursor is already at the bottom edge of the screen.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/AnsiDoc-cursorDown.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const cursorDown: (lines?: number) => AnsiDoc\n```\n\n----------------------------------------\n\nTITLE: Declaring Unexpected Error Class in TypeScript\nDESCRIPTION: This snippet defines the Unexpected error class used to capture and represent errors when unexpected keys or indices are encountered in the application logic. It includes properties for the actual value causing the error and an optional message for further context. The class is introduced in version 3.10.0 of the effect package.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/ParseResult-Unexpected.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare class Unexpected { constructor(\n    readonly actual: unknown,\n    /**\n     * @since 3.10.0\n     */\n    readonly message?: string\n  ) }\n```\n\n----------------------------------------\n\nTITLE: Defining Chunk.toArray Function in TypeScript\nDESCRIPTION: Declares the toArray function that converts a Chunk into an Array. It preserves the non-empty property by returning a NonEmptyArray if the input is a NonEmptyChunk.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Chunk-toArray.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const toArray: <S extends Chunk<any>>(self: S) => S extends NonEmptyChunk<any> ? RA.NonEmptyArray<Chunk.Infer<S>> : Array<Chunk.Infer<S>>\n```\n\n----------------------------------------\n\nTITLE: Either.getOrThrow Function Signature in TypeScript\nDESCRIPTION: The type signature for the getOrThrow function, showing it accepts an Either<R, L> and returns the right value R if successful.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Either-getOrThrow.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const getOrThrow: <R, L>(self: Either<R, L>) => R\n```\n\n----------------------------------------\n\nTITLE: Executing a Controlled Fold Over a Stream in TypeScript\nDESCRIPTION: This snippet defines the signature for the 'runFoldWhileScoped' function which executes a pure fold over a stream of values and returns a scoped effect. It supports two different usages: one that takes the stream as a parameter and another that supports currying. This functionality is particularly useful for processing streams with early exit conditions.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-runFoldWhileScoped.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const runFoldWhileScoped: { <S, A>(s: S, cont: Predicate<S>, f: (s: S, a: A) => S): <E, R>(self: Stream<A, E, R>) => Effect.Effect<S, E, Scope.Scope | R>; <A, E, R, S>(self: Stream<A, E, R>, s: S, cont: Predicate<S>, f: (s: S, a: A) => S): Effect.Effect<S, E, Scope.Scope | R>; }\n```\n\n----------------------------------------\n\nTITLE: Type Signature for lessThanOrEqualTo Function in TypeScript\nDESCRIPTION: Function signature for the lessThanOrEqualTo function showing its two possible calling patterns - either in curried form taking the second parameter first, or in standard form taking both parameters at once.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/BigDecimal-lessThanOrEqualTo.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const lessThanOrEqualTo: { (that: BigDecimal): (self: BigDecimal) => boolean; (self: BigDecimal, that: BigDecimal): boolean; }\n```\n\n----------------------------------------\n\nTITLE: Implementing Invariant.tupled Function in TypeScript\nDESCRIPTION: This function converts a value in a singleton array within a given effect. It takes an Invariant instance and returns a function that transforms the input effect into an effect containing a single-element array.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Invariant-tupled.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const tupled: <F extends TypeLambda>(F: Invariant<F>) => <R, O, E, A>(self: Kind<F, R, O, E, A>) => Kind<F, R, O, E, [A]>\n```\n\n----------------------------------------\n\nTITLE: Defining failCause Function for Deferred in TypeScript\nDESCRIPTION: Declares the failCause function, which fails a Deferred with a specified Cause. It propagates the failure to all fibers waiting on the Deferred's value. The function has two overloads to support different parameter orders.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Deferred-failCause.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const failCause: { <E>(cause: Cause.Cause<E>): <A>(self: Deferred<A, E>) => Effect.Effect<boolean>; <A, E>(self: Deferred<A, E>, cause: Cause.Cause<E>): Effect.Effect<boolean>; }\n```\n\n----------------------------------------\n\nTITLE: Checking for Empty Type in Cause Module (TypeScript)\nDESCRIPTION: A function that checks if a Cause is an Empty type. It returns a boolean indicating whether the provided Cause is of the Empty type. This can be used in conjunction with the empty function that creates a new Empty cause.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Cause-isEmptyType.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const isEmptyType: <E>(self: Cause<E>) => self is Empty\n```\n\n----------------------------------------\n\nTITLE: Declaring the eraseLine Function in TypeScript\nDESCRIPTION: Defines the eraseLine constant, which is an AnsiDoc that clears the current line in the terminal. When used, it erases the entire line at the current cursor position while maintaining the cursor's position.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/AnsiDoc-eraseLine.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const eraseLine: AnsiDoc\n```\n\n----------------------------------------\n\nTITLE: Retrieving Size of TPriorityQueue in TypeScript\nDESCRIPTION: Function that returns the size of a TPriorityQueue within an STM transaction. It allows checking the number of elements in the queue as part of a transactional operation.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TPriorityQueue-size.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const size: <A>(self: TPriorityQueue<A>) => STM.STM<number>\n```\n\n----------------------------------------\n\nTITLE: Declaring Queue Capacity Function in TypeScript\nDESCRIPTION: Defines a function named 'capacity' that returns the number of elements a queue can hold. It works for both Dequeue and Enqueue types.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Queue-capacity.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const capacity: <A>(self: Dequeue<A> | Enqueue<A>) => number\n```\n\n----------------------------------------\n\nTITLE: Signature of Filter Function in Effect Library\nDESCRIPTION: The signature provides a detailed type definition for the filter function which can accept either a predicate or a refinement function and applies to a ReadonlyRecord. This includes multiple overloads for different type scenarios. Key parameters are the record input and a predicate or refinement condition.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Record-filter.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const filter: { <K extends string, A, B extends A>(refinement: (a: NoInfer<A>, key: K) => a is B): (self: ReadonlyRecord<K, A>) => Record<ReadonlyRecord.NonLiteralKey<K>, B>; <K extends string, A>(predicate: (A: NoInfer<A>, key: K) => boolean): (self: ReadonlyRecord<K, A>) => Record<ReadonlyRecord.NonLiteralKey<K>, A>; <K extends string, A, B extends A>(self: ReadonlyRecord<K, A>, refinement: (a: A, key: K) => a is B): Record<ReadonlyRecord.NonLiteralKey<K>, B>; <K extends string, A>(self: ReadonlyRecord<K, A>, predicate: (a: A, key: K) => boolean): Record<ReadonlyRecord.NonLiteralKey<K>, A>; }\n```\n\n----------------------------------------\n\nTITLE: Defining GenAI Telemetry Attributes Type Structure in TypeScript\nDESCRIPTION: Defines a composite type that combines various GenAI-related telemetry attributes including base attributes, operation attributes, token attributes, usage attributes, request attributes, and response attributes. Each attribute set is prefixed with appropriate namespace identifiers.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/AiTelemetry-GenAITelemetryAttributes.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ntype GenAITelemetryAttributes = Simplify<\n  & GenAI.AttributesWithPrefix<GenAI.BaseAttributes, \"gen_ai\">\n  & GenAI.AttributesWithPrefix<GenAI.OperationAttributes, \"gen_ai.operation\">\n  & GenAI.AttributesWithPrefix<GenAI.TokenAttributes, \"gen_ai.token\">\n  & GenAI.AttributesWithPrefix<GenAI.UsageAttributes, \"gen_ai.usage\">\n  & GenAI.AttributesWithPrefix<GenAI.RequestAttributes, \"gen_ai.request\">\n  & GenAI.AttributesWithPrefix<GenAI.ResponseAttributes, \"gen_ai.response\">\n>\n```\n\n----------------------------------------\n\nTITLE: Implementing Micro.repeatExit Function in TypeScript\nDESCRIPTION: Function signature for repeating a Micro effect with configurable conditions. Accepts options for controlling repetition including a while predicate, optional number of times to repeat, and an optional schedule. The while predicate evaluates the MicroExit after each iteration to determine if repetition should continue.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Micro-repeatExit.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const repeatExit: { <A, E>(options: { while: Predicate<MicroExit<A, E>>; times?: number | undefined; schedule?: MicroSchedule | undefined; }): <R>(self: Micro<A, E, R>) => Micro<A, E, R>; <A, E, R>(self: Micro<A, E, R>, options: { while: Predicate<MicroExit<A, E>>; times?: number | undefined; schedule?: MicroSchedule | undefined; }): Micro<A, E, R>; }\n```\n\n----------------------------------------\n\nTITLE: Checking Close Type in ChildExecutorDecision - TypeScript\nDESCRIPTION: A type guard function that determines if a ChildExecutorDecision instance is of the Close variant. Returns a boolean indicating whether the provided decision is a Close type.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/ChildExecutorDecision-isClose.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const isClose: (self: ChildExecutorDecision) => self is Close\n```\n\n----------------------------------------\n\nTITLE: ManagedRuntime.make Function Signature in TypeScript\nDESCRIPTION: The type signature for the ManagedRuntime.make function, which takes a Layer and an optional MemoMap to create a ManagedRuntime.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/ManagedRuntime-make.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const make: <R, E>(layer: Layer.Layer<R, E, never>, memoMap?: Layer.MemoMap | undefined) => ManagedRuntime<R, E>\n```\n\n----------------------------------------\n\nTITLE: Type Definition for DateTime.now in TypeScript\nDESCRIPTION: Shows the type signature for the DateTime.now function. It returns an Effect that produces a UTC datetime with no required input or possible error types.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/DateTime-now.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const now: Effect.Effect<Utc, never, never>\n```\n\n----------------------------------------\n\nTITLE: Defining Symbol Type Predicate in TypeScript\nDESCRIPTION: Declares a type refinement predicate that checks if a value is of type symbol. The predicate takes an unknown value and refines it to the symbol type when matched.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Match-symbol.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const symbol: Predicate.Refinement<unknown, symbol>\n```\n\n----------------------------------------\n\nTITLE: Defining finalizersMask Function Signature in TypeScript\nDESCRIPTION: The TypeScript signature for the finalizersMask function, which takes an ExecutionStrategy and returns a higher-order function for applying that strategy to finalizers within a scoped workflow. It also provides a restore operation to revert to the default execution strategy.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-finalizersMask.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const finalizersMask: (strategy: ExecutionStrategy) => <A, E, R>(self: (restore: <A1, E1, R1>(self: Effect<A1, E1, R1>) => Effect<A1, E1, R1>) => Effect<A, E, R>) => Effect<A, E, R>\n```\n\n----------------------------------------\n\nTITLE: Implementing Weighted Fold with Decomposition Effects in TypeScript\nDESCRIPTION: Creates a sink that effectfully folds elements with weight constraints and decomposition capabilities. The function accepts options including initial state, maximum cost, cost function, decompose function, and body function to process elements until a specified weight limit is reached.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Sink-foldWeightedDecomposeEffect.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const foldWeightedDecomposeEffect: <S, In, E, R, E2, R2, E3, R3>(options: { readonly initial: S; readonly maxCost: number; readonly cost: (s: S, input: In) => Effect.Effect<number, E, R>; readonly decompose: (input: In) => Effect.Effect<Chunk.Chunk<In>, E2, R2>; readonly body: (s: S, input: In) => Effect.Effect<S, E3, R3>; }) => Sink<S, In, In, E | E2 | E3, R | R2 | R3>\n```\n\n----------------------------------------\n\nTITLE: Collecting All Inputs in Schedule Module - TypeScript\nDESCRIPTION: The `collectAllInputs` function creates a schedule that runs indefinitely, collecting incoming inputs and aggregating them into a `Chunk`. This is particularly useful for scenarios where tracking all received inputs over time is necessary, such as logging user actions or accumulating data for future processing. The function returns a schedule that has the type `Schedule<Chunk.Chunk<A>, A>`.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Schedule-collectAllInputs.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const collectAllInputs: <A>() => Schedule<Chunk.Chunk<A>, A>\n```\n\n----------------------------------------\n\nTITLE: RedBlackTree has function in Typescript\nDESCRIPTION: This code snippet defines the `has` function for the `RedBlackTree` data structure in the Effect library.  It checks if a given key exists within the RedBlackTree. The function is overloaded to support both curried and direct invocation.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/RedBlackTree-has.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const has: { <K>(key: K): <V>(self: RedBlackTree<K, V>) => boolean; <K, V>(self: RedBlackTree<K, V>, key: K): boolean; }\n```\n\n----------------------------------------\n\nTITLE: Combining Brand Validators in TypeScript using Effect's Brand.all\nDESCRIPTION: Demonstrates how to use Brand.all to combine multiple brand validators (Int and Positive) to create a new validator for PositiveInt. It shows the creation of refined brands and their combination.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Brand-all.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { Brand } from \"effect\"\n\ntype Int = number & Brand.Brand<\"Int\">\nconst Int = Brand.refined<Int>(\n  (n) => Number.isInteger(n),\n  (n) => Brand.error(`Expected ${n} to be an integer`)\n)\ntype Positive = number & Brand.Brand<\"Positive\">\nconst Positive = Brand.refined<Positive>(\n  (n) => n > 0,\n  (n) => Brand.error(`Expected ${n} to be positive`)\n)\n\nconst PositiveInt = Brand.all(Int, Positive)\n\nconsole.log(PositiveInt(1))\n// 1\n\nassert.throws(() => PositiveInt(1.1))\n```\n\n----------------------------------------\n\nTITLE: Implementing Error Transformation in Micro Module\nDESCRIPTION: Defines a mapError function that transforms error types from E to E2 in a Micro effect. The function supports both curried and uncurried versions for flexible usage patterns.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Micro-mapError.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const mapError: { <E, E2>(f: (e: E) => E2): <A, R>(self: Micro<A, E, R>) => Micro<A, E2, R>; <A, E, R, E2>(self: Micro<A, E, R>, f: (e: E) => E2): Micro<A, E2, R>; }\n```\n\n----------------------------------------\n\nTITLE: Checking Key Existence in TypeScript Record\nDESCRIPTION: Demonstrates how to use the `has` function to check if a key exists in a record. Supports both curried and direct invocation styles with type-safe key checking.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Record-has.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { empty, has } from \"effect/Record\"\n\nassert.deepStrictEqual(has({ a: 1, b: 2 }, \"a\"), true);\nassert.deepStrictEqual(has(empty<string>(), \"c\"), false);\n```\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const has: { \n  <K extends string | symbol>(key: NoInfer<K>): \n    <A>(self: ReadonlyRecord<K, A>) => boolean; \n  <K extends string | symbol, A>(self: ReadonlyRecord<K, A>, key: NoInfer<K>): boolean; \n}\n```\n\n----------------------------------------\n\nTITLE: Creating Generic Tags in Effect Context Module\nDESCRIPTION: Example demonstrating how to create and compare GenericTag instances. Shows that tags created with the same key parameter have referential equality.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Context-GenericTag.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { Context } from \"effect\"\n\nassert.strictEqual(Context.GenericTag(\"PORT\").key === Context.GenericTag(\"PORT\").key, true)\n```\n\n----------------------------------------\n\nTITLE: Generating Date Sequences from Cron Patterns in TypeScript\nDESCRIPTION: Function declaration for generating an IterableIterator of Date objects that match a given Cron pattern. Takes a Cron instance and optional start datetime as input parameters. Returns an iterator yielding matching dates in sequence.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Cron-sequence.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const sequence: (cron: Cron, startFrom?: DateTime.DateTime.Input) => IterableIterator<Date>\n```\n\n----------------------------------------\n\nTITLE: Signature of Option.none Method - TypeScript\nDESCRIPTION: This snippet provides the TypeScript signature for the Option.none method, indicating that it returns an Option<A> where A defaults to never. This signature clarifies the expected return type when using the none function, ensuring type safety in TypeScript applications.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Option-none.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const none: <A = never>() => Option<A>\n```\n\n----------------------------------------\n\nTITLE: Mapping Channel Output in TypeScript - Effect-TS\nDESCRIPTION: Function signature for mapping the output of a channel using a transformation function. Supports both curried and uncurried versions of the operation, allowing transformation of the output element type while preserving other channel type parameters.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Channel-mapOut.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const mapOut: { <OutElem, OutElem2>(f: (o: OutElem) => OutElem2): <InElem, OutErr, InErr, OutDone, InDone, Env>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>) => Channel<OutElem2, InElem, OutErr, InErr, OutDone, InDone, Env>; <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutElem2>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>, f: (o: OutElem) => OutElem2): Channel<OutElem2, InElem, OutErr, InErr, OutDone, InDone, Env>; }\n```\n\n----------------------------------------\n\nTITLE: Checking RightDone State in MergeState - TypeScript\nDESCRIPTION: The isRightDone function checks if a given MergeState is in the RightDone state. It takes a MergeState as input and returns a boolean indicating whether it's a RightDone state. This function uses TypeScript's type predicate feature for type narrowing.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/MergeState-isRightDone.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const isRightDone: <Env, Err, Err1, Err2, Elem, Done, Done1, Done2>(self: MergeState<Env, Err, Err1, Err2, Elem, Done, Done1, Done2>) => self is RightDone<Env, Err, Err1, Err2, Elem, Done, Done1, Done2>\n```\n\n----------------------------------------\n\nTITLE: Creating a Secret Text Argument in Effect CLI\nDESCRIPTION: This function creates a text argument for handling secret values. It can optionally take a custom argument name configuration, defaulting to \"secret\" if not provided. Returns an Args instance with Secret type.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Args-secret.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const secret: (config?: Args.BaseArgsConfig) => Args<Secret>\n```\n\n----------------------------------------\n\nTITLE: Defining isHttpMethod Function Signature in TypeScript\nDESCRIPTION: Provides the TypeScript type signature for the isHttpMethod function. It takes an unknown value as input and returns a boolean indicating if the value is of type HttpMethod.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/HttpMethod-isHttpMethod.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const isHttpMethod: (u: unknown) => u is HttpMethod\n```\n\n----------------------------------------\n\nTITLE: Combining Boolean Values Using SemigroupEvery in TypeScript\nDESCRIPTION: This code snippet demonstrates the usage of the SemigroupEvery type class from the '@effect/typeclass/data/Boolean' module for combining boolean values using the conjunction operation. The combine method takes two boolean values and returns true only if both are true. The expected inputs are two boolean values, and the output is a single boolean value representing their conjunction.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/data-Boolean-SemigroupEvery.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { SemigroupEvery } from \"@effect/typeclass/data/Boolean\"\n\nconsole.log(SemigroupEvery.combine(true, true))\n// true\nconsole.log(SemigroupEvery.combine(true, false))\n// false\nconsole.log(SemigroupEvery.combine(false, true))\n// false\nconsole.log(SemigroupEvery.combine(false, false))\n// false\n```\n\n----------------------------------------\n\nTITLE: Defining Unbranded Utility Type in TypeScript\nDESCRIPTION: This code snippet defines the Unbranded utility type, which is used to extract the underlying value type from a branded type. It uses conditional types to remove the brand information if present.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Brand-Brand.Unbranded.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ntype Unbranded<P> = P extends infer Q & Brands<P> ? Q : P\n```\n\n----------------------------------------\n\nTITLE: Checking if a HashMap is Empty in TypeScript\nDESCRIPTION: A utility function that checks whether a HashMap contains any entries. It takes a HashMap as input and returns a boolean value indicating if the HashMap is empty.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/HashMap-isEmpty.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const isEmpty: <K, V>(self: HashMap<K, V>) => boolean\n```\n\n----------------------------------------\n\nTITLE: Semigroup Tuple Type Operation\nDESCRIPTION: Type-level representation showing how Semigroup tuple operation transforms input types to output types.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Semigroup-tuple.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n[Semigroup<A>, Semigroup<B>, ...] -> Semigroup<[A, B, ...]>\n```\n\n----------------------------------------\n\nTITLE: String Type Refinement Predicate in TypeScript\nDESCRIPTION: Defines a type refinement predicate that checks if an unknown value is a string. This predicate can be used for type narrowing in TypeScript, ensuring type safety when working with unknown values.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Match-string.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const string: Predicate.Refinement<unknown, string>\n```\n\n----------------------------------------\n\nTITLE: Completing a Deferred with a lazily evaluated value using Deferred.sync in TypeScript\nDESCRIPTION: The sync function completes a Deferred with a lazily evaluated value. It provides two call signatures: one where the Deferred is the second parameter, and another where it's passed as the first parameter to a returned function. Returns an Effect that resolves to a boolean indicating success.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Deferred-sync.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const sync: { <A>(evaluate: LazyArg<A>): <E>(self: Deferred<A, E>) => Effect.Effect<boolean>; <A, E>(self: Deferred<A, E>, evaluate: LazyArg<A>): Effect.Effect<boolean>; }\n```\n\n----------------------------------------\n\nTITLE: Extracting User Roles with Match.option in TypeScript\nDESCRIPTION: This example demonstrates how to use Match.option to create a matcher that extracts user roles and wraps the result in an Option. It handles cases where a role might not match any defined patterns.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Match-option.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Match } from \"effect\"\n\ntype User = { readonly role: \"admin\" | \"editor\" | \"viewer\" }\n\n// Create a matcher to extract user roles\nconst getRole = Match.type<User>().pipe(\n  Match.when({ role: \"admin\" }, () => \"Has full access\"),\n  Match.when({ role: \"editor\" }, () => \"Can edit content\"),\n  Match.option // Wrap the result in an Option\n)\n\nconsole.log(getRole({ role: \"admin\" }))\n// Output: { _id: 'Option', _tag: 'Some', value: 'Has full access' }\n\nconsole.log(getRole({ role: \"viewer\" }))\n// Output: { _id: 'Option', _tag: 'None' }\n```\n\n----------------------------------------\n\nTITLE: Defining KeyedPool Interface in TypeScript\nDESCRIPTION: Defines the KeyedPool interface that manages pools of items. The interface includes methods for retrieving items using a key within a scoped effect and invalidating specific items. The pool handles generic types for keys (K), items (A), and errors (E).\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/KeyedPool-KeyedPool.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface KeyedPool<in K, in out A, out E = never> extends KeyedPool.Variance<K, A, E>, Pipeable {\n  /**\n   * Retrieves an item from the pool belonging to the given key in a scoped\n   * effect. Note that if acquisition fails, then the returned effect will fail\n   * for that same reason. Retrying a failed acquisition attempt will repeat the\n   * acquisition attempt.\n   */\n  get(key: K): Effect.Effect<A, E, Scope.Scope>\n\n  /**\n   * Invalidates the specified item. This will cause the pool to eventually\n   * reallocate the item, although this reallocation may occur lazily rather\n   * than eagerly.\n   */\n  invalidate(item: A): Effect.Effect<void>\n}\n```\n\n----------------------------------------\n\nTITLE: Defining STM Partition Type Signature in TypeScript\nDESCRIPTION: Provides a flexible type definition for partitioning elements through a transactional effect. Supports different parameter ordering and returns a tuple of excluded errors and satisfying results.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/STM-partition.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const partition: { <A, A2, E, R>(f: (a: A) => STM<A2, E, R>): (elements: Iterable<A>) => STM<[excluded: Array<E>, satisfying: Array<A2>], never, R>; <A, A2, E, R>(elements: Iterable<A>, f: (a: A) => STM<A2, E, R>): STM<[excluded: Array<E>, satisfying: Array<A2>], never, R>; }\n```\n\n----------------------------------------\n\nTITLE: Defining Primitive Interface for Effect CLI in TypeScript\nDESCRIPTION: This code snippet defines the Primitive interface, which represents primitive types supported by Effect CLI. It extends Primitive.Variance<A> and includes functionality for parsing and validating from strings.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Primitive-Primitive.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface Primitive<A> extends Primitive.Variance<A> {}\n```\n\n----------------------------------------\n\nTITLE: Defining ScopedCache.Lookup Type in TypeScript\nDESCRIPTION: Type definition for a function that performs cache lookups within a Scope context. The lookup function takes a key parameter and returns an Effect that resolves to a value, may produce an error, and requires both the specified environment and a Scope.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/ScopedCache-Lookup.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ntype Lookup<Key, Value, Error, Environment> = (\n  key: Key\n) => Effect.Effect<Value, Error, Environment | Scope.Scope>\n```\n\n----------------------------------------\n\nTITLE: Type Guard for MergeStrategy in TypeScript\nDESCRIPTION: A type predicate function that checks if an unknown value is of type MergeStrategy. Used for runtime type checking and type narrowing in TypeScript.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/MergeStrategy-isMergeStrategy.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const isMergeStrategy: (u: unknown) => u is MergeStrategy\n```\n\n----------------------------------------\n\nTITLE: Testing BigInt Predicate in TypeScript\nDESCRIPTION: This TypeScript snippet demonstrates how to test if a value is a bigint using the 'isBigInt' function imported from the 'effect/Predicate' module. The assertions check whether specific inputs are identified as bigint or not. 'node:assert' is used for strict assertion checks.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Predicate-isBigInt.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { isBigInt } from \"effect/Predicate\"\n\nassert.deepStrictEqual(isBigInt(1n), true)\n\nassert.deepStrictEqual(isBigInt(1), false)\n```\n\n----------------------------------------\n\nTITLE: Creating Async Micro Effects in TypeScript\nDESCRIPTION: Function signature for creating a Micro effect from an asynchronous computation. Allows specifying a cleanup effect that runs on abort and provides an AbortSignal for abort detection. The function takes a register callback that receives a resume function and abort signal.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Micro-async.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const async: <A, E = never, R = never>(register: (resume: (effect: Micro<A, E, R>) => void, signal: AbortSignal) => void | Micro<void, never, R>) => Micro<A, E, R>\n```\n\n----------------------------------------\n\nTITLE: Declaring structuralRegion function in Typescript\nDESCRIPTION: This code snippet declares the `structuralRegion` function in Typescript. This function accepts a body (a function returning a value of type A) and an optional tester function. It returns a value of type A and is intended for use in custom matchers within tests.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Utils-structuralRegion.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const structuralRegion: <A>(body: () => A, tester?: (a: unknown, b: unknown) => boolean) => A\n```\n\n----------------------------------------\n\nTITLE: Defining alterAnnotations Function in TypeScript for Effect-TS Printer Library\nDESCRIPTION: Declaration of the `alterAnnotations` function which allows transforming document annotations. It takes a transformation function and a document, and returns a new document with modified annotations. The function supports both curried and uncurried calling styles.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Doc-alterAnnotations.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const alterAnnotations: { <A, B>(f: (a: A) => Iterable<B>): (self: Doc<A>) => Doc<B>; <A, B>(self: Doc<A>, f: (a: A) => Iterable<B>): Doc<B>; }\n```\n\n----------------------------------------\n\nTITLE: Function Signature for Greater Than in TypeScript\nDESCRIPTION: The signature for the `greaterThan` function defines its callable forms, allowing for both curried and standard invocation. This enables flexibility in usage depending on how the function is applied within different contexts. Understanding the function's signature is crucial when implementing type-safe comparisons.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Number-greaterThan.md#2025-04-11_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const greaterThan: { (that: number): (self: number) => boolean; (self: number, that: number): boolean; }\n```\n\n----------------------------------------\n\nTITLE: Creating a New Deferred Object in TypeScript\nDESCRIPTION: The make function creates a new Deferred object. It takes no arguments and returns an Effect that produces a Deferred<A, E>. The function allows for optional type parameters A and E, with E defaulting to never.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Deferred-make.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const make: <A, E = never>() => Effect.Effect<Deferred<A, E>>\n```\n\n----------------------------------------\n\nTITLE: Recovering from Tagged Errors in STM with TypeScript\nDESCRIPTION: The `catchTags` function facilitates error handling by allowing recovery actions for specific tagged errors occurring within STM transactions. It requires a mapping of tags to their respective recovery functions. This utility ensures continuity in transactional processes by executing predefined actions when particular errors are encountered. It expects a dictionary of error tags and functions, returning a new STM with enhanced error recovery capabilities.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/STM-catchTags.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const catchTags: { <E extends { _tag: string; }, Cases extends { [K in E[\"_tag\"]]+?: ((error: Extract<E, { _tag: K; }>) => STM<any, any, any>); }>(cases: Cases): <A, R>(self: STM<A, E, R>) => STM<A | { [K in keyof Cases]: Cases[K] extends (...args: Array<any>) => STM<infer A, any, any> ? A : never; }[keyof Cases], Exclude<E, { _tag: keyof Cases; }> | { [K in keyof Cases]: Cases[K] extends (...args: Array<any>) => STM<any, infer E, any> ? E : never; }[keyof Cases], R | { [K in keyof Cases]: Cases[K] extends (...args: Array<any>) => STM<any, any, infer R> ? R : never; }[keyof Cases]>; <R, E extends { _tag: string; }, A, Cases extends { [K in E[\"_tag\"]]+?: ((error: Extract<E, { _tag: K; }>) => STM<any, any, any>); }>(self: STM<A, E, R>, cases: Cases): STM<A | { [K in keyof Cases]: Cases[K] extends (...args: Array<any>) => STM<infer A, any, any> ? A : never; }[keyof Cases], Exclude<E, { _tag: keyof Cases; }> | { [K in keyof Cases]: Cases[K] extends (...args: Array<any>) => STM<any, infer E, any> ? E : never; }[keyof Cases], R | { [K in keyof Cases]: Cases[K] extends (...args: Array<any>) => STM<any, any, infer R> ? R : never; }[keyof Cases]>; }\n```\n\n----------------------------------------\n\nTITLE: Using setNonEmptyLast Function in TypeScript\nDESCRIPTION: Demonstrates how to change the last element of a non-empty array using the setNonEmptyLast function. Returns a new array with the modified last element while preserving type safety.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Array-setNonEmptyLast.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Array } from \"effect\"\n\nconst result = Array.setNonEmptyLast([1, 2, 3], 4)\nconsole.log(result) // [1, 2, 4]\n```\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const setNonEmptyLast: { <B>(b: B): <A>(self: NonEmptyReadonlyArray<A>) => NonEmptyArray<A | B>; <A, B>(self: NonEmptyReadonlyArray<A>, b: B): NonEmptyArray<A | B>; }\n```\n\n----------------------------------------\n\nTITLE: DateTime distanceDurationEither Type Signature\nDESCRIPTION: Type signature for the distanceDurationEither function showing both curried and uncurried versions of the function that return Either<Duration, Duration>.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/DateTime-distanceDurationEither.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const distanceDurationEither: { (other: DateTime): (self: DateTime) => Either.Either<Duration.Duration, Duration.Duration>; (self: DateTime, other: DateTime): Either.Either<Duration.Duration, Duration.Duration>; }\n```\n\n----------------------------------------\n\nTITLE: Swapping Tuple Elements in TypeScript\nDESCRIPTION: A utility function that reverses the order of elements in a two-element tuple. It takes a readonly tuple with two generic types and returns a new tuple with the elements swapped.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Tuple-swap.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { swap } from \"effect/Tuple\"\n\nassert.deepStrictEqual(swap([\"hello\", 42]), [42, \"hello\"])\n```\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const swap: <L, R>(self: readonly [L, R]) => [R, L]\n```\n\n----------------------------------------\n\nTITLE: Stream repeatWith signature in Typescript\nDESCRIPTION: Defines the signature of the `repeatWith` function in the Effect `Stream` module. This function allows repeating a stream based on a schedule. It takes a schedule and options for unifying stream elements and schedule outputs into a single stream of type `C`.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-repeatWith.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const repeatWith: { <B, R2, A, C>(schedule: Schedule.Schedule<B, unknown, R2>, options: { readonly onElement: (a: A) => C; readonly onSchedule: (b: B) => C; }): <E, R>(self: Stream<A, E, R>) => Stream<C, E, R2 | R>; <A, E, R, B, R2, C>(self: Stream<A, E, R>, schedule: Schedule.Schedule<B, unknown, R2>, options: { readonly onElement: (a: A) => C; readonly onSchedule: (b: B) => C; }): Stream<C, E, R | R2>; }\n```\n\n----------------------------------------\n\nTITLE: Using catWithLineBreak to Concatenate Documents with Line Breaks in TypeScript\nDESCRIPTION: This example demonstrates how to use the catWithLineBreak function to concatenate two documents with a line break between them. It also shows how grouping affects the output.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Doc-catWithLineBreak.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport * as Doc from \"@effect/printer/Doc\"\nimport { pipe } from \"effect/Function\"\nimport * as String from \"effect/String\"\n\nconst doc: Doc.Doc<never> = pipe(\n  Doc.char(\"a\"),\n  Doc.catWithLineBreak(Doc.char(\"b\"))\n)\n\nassert.strictEqual(\n  Doc.render(doc, { style: \"pretty\" }),\n  String.stripMargin(\n    `|a\n     |b`\n  )\n)\n\nassert.strictEqual(\n  Doc.render(Doc.group(doc), { style: \"pretty\" }),\n  \"ab\"\n)\n```\n\n----------------------------------------\n\nTITLE: Formatting DateTime.Zoned as ISO String in TypeScript\nDESCRIPTION: Defines a function formatIsoZoned that formats a DateTime.Zoned object as a string using the format YYYY-MM-DDTHH:mm:ss.sss+HH:MM[Time/Zone]. This function is part of the DateTime module in the effect package.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/DateTime-formatIsoZoned.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const formatIsoZoned: (self: Zoned) => string\n```\n\n----------------------------------------\n\nTITLE: Removing Annotations from Documents in TypeScript\nDESCRIPTION: The unAnnotate function removes all annotations from a document tree. Note that this operation traverses the entire document tree with each invocation, so using unAnnotateS after producing the layout is preferable when possible.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Doc-unAnnotate.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const unAnnotate: <A>(self: Doc<A>) => Doc<never>\n```\n\n----------------------------------------\n\nTITLE: Implementing Stream zipAllLeft Operation in TypeScript\nDESCRIPTION: Defines a function that zips two streams together point-wise, keeping only elements from the first stream. If the second stream ends before the first, a provided default value is used to complete the operation.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-zipAllLeft.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const zipAllLeft: { \n  <A2, E2, R2, A>(that: Stream<A2, E2, R2>, defaultLeft: A): <E, R>(self: Stream<A, E, R>) => Stream<A, E2 | E, R2 | R>; \n  <A, E, R, A2, E2, R2>(self: Stream<A, E, R>, that: Stream<A2, E2, R2>, defaultLeft: A): Stream<A, E | E2, R | R2>; \n}\n```\n\n----------------------------------------\n\nTITLE: Combining Records with Semigroup Intersection in TypeScript\nDESCRIPTION: This code snippet demonstrates the use of the `getSemigroupIntersection` function to combine two records with the `MonoidSum` Semigroup instance from the Number type class. It takes in two records, merging their matching keys' values using the specified Semigroup logic.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/data-Record-getSemigroupIntersection.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as NumberInstances from \"@effect/typeclass/data/Number\"\nimport { getSemigroupIntersection } from \"@effect/typeclass/data/Record\"\n\nconsole.log(getSemigroupIntersection(NumberInstances.MonoidSum).combine({ a: 1 }, { a: 1, b: 3 }))\n// { a: 2 }\n```\n\n----------------------------------------\n\nTITLE: Defining DateTimeZoned Schema in TypeScript\nDESCRIPTION: Declares a class DateTimeZoned that defines a schema for converting strings to DateTime.Zoned instances. This schema is part of the Schema module in the Effect package.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Schema-DateTimeZoned.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare class DateTimeZoned\n```\n\n----------------------------------------\n\nTITLE: Creating JSON Serialization Layer for RPC in TypeScript\nDESCRIPTION: A function that creates an RPC serialization layer using JSON for message serialization. This is recommended for protocols that support message framing, otherwise layerNdjson should be used instead.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/RpcSerialization-layerJson.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const layerJson: Layer.Layer<RpcSerialization, never, never>\n```\n\n----------------------------------------\n\nTITLE: Defining SingletonRegistered Interface for Sharding Events\nDESCRIPTION: TypeScript interface definition for representing singleton registration events in a distributed system. It includes a discriminator tag and address property to track singleton registrations.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/ShardingRegistrationEvent-SingletonRegistered.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface SingletonRegistered {\n  readonly _tag: \"SingletonRegistered\"\n  readonly address: SingletonAddress\n}\n```\n\n----------------------------------------\n\nTITLE: Defining GenAI AllAttributes Type in TypeScript\nDESCRIPTION: This snippet defines the AllAttributes type for the GenAI specification. It combines various attribute types including BaseAttributes, OperationAttributes, TokenAttributes, UsageAttributes, RequestAttributes, and ResponseAttributes.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/AiTelemetry-GenAI.AllAttributes.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ntype AllAttributes = & BaseAttributes\n    & OperationAttributes\n    & TokenAttributes\n    & UsageAttributes\n    & RequestAttributes\n    & ResponseAttributes\n```\n\n----------------------------------------\n\nTITLE: Retrieving Test Annotations in TypeScript using Effect\nDESCRIPTION: The 'get' function accesses an Annotations instance in the context and retrieves the annotation of the specified type, or its default value if none exists. It takes a TestAnnotation key as input and returns an Effect containing the annotation value.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TestServices-get.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const get: <A>(key: TestAnnotation.TestAnnotation<A>) => Effect.Effect<A>\n```\n\n----------------------------------------\n\nTITLE: Type Checking for And ConfigError in TypeScript\nDESCRIPTION: A type guard function that checks if a given ConfigError is specifically an And type error. Returns a boolean indicating whether the error is of And type, with type narrowing support for TypeScript.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/ConfigError-isAnd.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const isAnd: (self: ConfigError) => self is And\n```\n\n----------------------------------------\n\nTITLE: Array.modifyOption Function Signature\nDESCRIPTION: Type definition for the modifyOption function, showing its polymorphic nature and support for different array-like structures through Iterable.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Array-modifyOption.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const modifyOption: { <A, B, S extends Iterable<A> = Iterable<A>>(i: number, f: (a: ReadonlyArray.Infer<S>) => B): (self: S) => Option.Option<ReadonlyArray.With<S, ReadonlyArray.Infer<S> | B>>; <A, B, S extends Iterable<A> = Iterable<A>>(self: S, i: number, f: (a: ReadonlyArray.Infer<S>) => B): Option.Option<ReadonlyArray.With<S, ReadonlyArray.Infer<S> | B>>; }\n```\n\n----------------------------------------\n\nTITLE: TypeScript Declaration for unsafeCoerce Function\nDESCRIPTION: The type signature for the `unsafeCoerce` function, which takes a value of type A and returns it as type B without any runtime checks. This is a potentially unsafe operation and should be used with caution.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Function-unsafeCoerce.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const unsafeCoerce: <A, B>(a: A) => B\n```\n\n----------------------------------------\n\nTITLE: Creating a Supervisor Tracking in TypeScript\nDESCRIPTION: The 'track' function is a declaration that allows for the creation of a supervisor responsible for tracking an array of child fibers. It returns an Effect that represents the supervisor, with no expected errors or failures (never, never). This function requires the Effect library and TypeScript for correct usage. The function signature defines the generic types for the supervisor, ensuring type safety when handling fibers.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Supervisor-track.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const track: Effect.Effect<Supervisor<Array<Fiber.RuntimeFiber<any, any>>>, never, never>\n```\n\n----------------------------------------\n\nTITLE: Declaring Uncapitalize Schema in Effect (TypeScript)\nDESCRIPTION: This snippet shows the declaration of the `Uncapitalize` schema class within the Effect library. The `Uncapitalize` schema transforms a string value into its uncapitalized equivalent. It is available from version 3.10.0 onwards.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Schema-Uncapitalize.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare class Uncapitalize\n```\n\n----------------------------------------\n\nTITLE: Defining SerializableWithResult Interface in TypeScript\nDESCRIPTION: This code snippet defines the SerializableWithResult interface, which extends both Serializable and WithResult interfaces. It is designed for remote procedures requiring input/output serialization and handling of success/failure outcomes.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Schema-SerializableWithResult.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface SerializableWithResult<\n  A,\n  I,\n  R,\n  Success,\n  SuccessEncoded,\n  Failure,\n  FailureEncoded,\n  ResultR\n> extends Serializable<A, I, R>, WithResult<Success, SuccessEncoded, Failure, FailureEncoded, ResultR> {}\n```\n\n----------------------------------------\n\nTITLE: Defining Iterable.range Function Signature in TypeScript\nDESCRIPTION: This snippet shows the TypeScript signature for the range function in the Iterable module. It takes a start number and an optional end number, returning an Iterable of numbers.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Iterable-range.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const range: (start: number, end?: number) => Iterable<number>\n```\n\n----------------------------------------\n\nTITLE: Converting RuntimeFlags to String in TypeScript\nDESCRIPTION: A function that converts RuntimeFlags objects into string representation. This is useful for debugging and displaying runtime configuration flags in a human-readable format.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/RuntimeFlags-render.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const render: (self: RuntimeFlags) => string\n```\n\n----------------------------------------\n\nTITLE: Executing Prompts with Prompt.run in TypeScript\nDESCRIPTION: The Prompt.run function executes a specified Prompt and returns an Effect. It takes a Prompt<Output> as input and returns an Effect that resolves to the Output type, may throw a QuitException, and requires a Prompt.Environment.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Prompt-run.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const run: <Output>(self: Prompt<Output>) => Effect<Output, QuitException, Prompt.Environment>\n```\n\n----------------------------------------\n\nTITLE: Example Usage of Function.tupled in TypeScript\nDESCRIPTION: Demonstrates how to use the tupled utility to convert a two-argument sum function into one that accepts a tuple of numbers. Shows practical usage with assertion testing.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Function-tupled.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { tupled } from \"effect/Function\"\n\nconst sumTupled = tupled((x: number, y: number): number => x + y)\n\nassert.deepStrictEqual(sumTupled([1, 2]), 3)\n```\n\n----------------------------------------\n\nTITLE: Type Predicate for ConcatTree in TypeScript\nDESCRIPTION: A function that checks if a DocTree instance is specifically a ConcatTree. It returns a boolean value that also serves as a type guard in TypeScript.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/DocTree-isConcatTree.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const isConcatTree: <A>(self: DocTree<A>) => self is ConcatTree<A>\n```\n\n----------------------------------------\n\nTITLE: Creating Named Time Zones from IANA Identifiers in TypeScript\nDESCRIPTION: This function creates a named time zone from an IANA time zone identifier. If the provided zone ID is invalid, it returns None (Option.None). The function helps in safely creating time zone objects for date/time operations.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/DateTime-zoneMakeNamed.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const zoneMakeNamed: (zoneId: string) => Option.Option<TimeZone.Named>\n```\n\n----------------------------------------\n\nTITLE: Exporting Test Configuration Interface in TypeScript\nDESCRIPTION: Defines the `TestConfig` interface in TypeScript, which specifies various test configuration parameters such as the number of repeats, retries, samples, and shrinks. This interface is essential for settings related to test stability and execution. It has no additional dependencies and expects numerical values for configuration parameters.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TestConfig-TestConfig.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport interface TestConfig {\n  /**\n   * The number of times to repeat tests to ensure they are stable.\n   */\n  readonly repeats: number\n  /**\n   * The number of times to retry flaky tests.\n   */\n  readonly retries: number\n  /**\n   * The number of sufficient samples to check for a random variable.\n   */\n  readonly samples: number\n  /**\n   * The maximum number of shrinkings to minimize large failures\n   */\n  readonly shrinks: number\n}\n```\n\n----------------------------------------\n\nTITLE: Defining EventLog.Handlers Interface in TypeScript\nDESCRIPTION: Defines a generic interface for handling events with type parameters for return type R and Events. Includes methods for handling specific event tags and managing context. The interface extends Pipeable and includes type metadata for events handling.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/EventLog-Handlers.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface Handlers<\n  R,\n  Events extends Event.Any = never\n> extends Pipeable {\n  readonly [HandlersTypeId]: {\n    _Endpoints: Covariant<Events>\n  }\n  readonly group: EventGroup.AnyWithProps\n  readonly handlers: Record.ReadonlyRecord<string, Handlers.Item<R>>\n  readonly context: Context.Context<any>\n\n  /**\n   * Add the implementation for an `Event` to a `Handlers` group.\n   */\n  handle<Tag extends Events[\"tag\"], R1>(\n    name: Tag,\n    handler: (\n      options: {\n        readonly payload: Event.PayloadWithTag<Events, Tag>\n        readonly entry: Entry\n        readonly conflicts: Array<{\n          readonly entry: Entry\n          readonly payload: Event.PayloadWithTag<Events, Tag>\n        }>\n      }\n    ) => Effect.Effect<Event.SuccessWithTag<Events, Tag>, Event.ErrorWithTag<Events, Tag>, R1>\n  ): Handlers<\n    R | R1,\n    Event.ExcludeTag<Events, Tag>\n  >\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Immediately Succeeding Prompt in TypeScript\nDESCRIPTION: The succeed function creates a Prompt that immediately succeeds with the specified value. It does not attempt to obtain user input or render anything to the screen. The function takes a generic type A and returns a Prompt of type A.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Prompt-succeed.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const succeed: <A>(value: A) => Prompt<A>\n```\n\n----------------------------------------\n\nTITLE: Creating a RunnerServer Layer in TypeScript for Effect-TS\nDESCRIPTION: The RunnerServer.layer creates a service layer that receives messages from other Runners and forwards them to the Sharding layer. It also handles Ping requests. This layer has no requirements and provides MessageStorage, Sharding, and RpcServer Protocol implementations.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/RunnerServer-layer.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const layer: Layer.Layer<never, never, MessageStorage.MessageStorage | Sharding.Sharding | RpcServer.Protocol>\n```\n\n----------------------------------------\n\nTITLE: BigInt lessThan Function Signature\nDESCRIPTION: Type declaration for the lessThan function showing both its curried and uncurried forms. Takes two bigint parameters and returns a boolean.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/BigInt-lessThan.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const lessThan: { (that: bigint): (self: bigint) => boolean; (self: bigint, that: bigint): boolean; }\n```\n\n----------------------------------------\n\nTITLE: Channel.writeAll Function Definition in TypeScript\nDESCRIPTION: Function signature for writeAll which takes a variable number of output elements and returns a Channel that writes these elements. This function allows writing multiple values to a channel in a single operation.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Channel-writeAll.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const writeAll: <OutElems extends Array<any>>(...outs: OutElems) => Channel<OutElems[number]>\n```\n\n----------------------------------------\n\nTITLE: Using unsafeDivide Function for BigInt Division in TypeScript\nDESCRIPTION: Demonstrates how to use the unsafeDivide function to perform division operations on bigint values. This function handles division where the result is rounded down to the nearest integer when not evenly divisible, and throws a RangeError if dividing by zero.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/BigInt-unsafeDivide.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { unsafeDivide } from \"effect/BigInt\"\n\nassert.deepStrictEqual(unsafeDivide(6n, 3n), 2n)\nassert.deepStrictEqual(unsafeDivide(6n, 4n), 1n)\n```\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const unsafeDivide: { (that: bigint): (self: bigint) => bigint; (self: bigint, that: bigint): bigint; }\n```\n\n----------------------------------------\n\nTITLE: Defining ChildExecutorDecision.Yield Interface in TypeScript\nDESCRIPTION: Defines the Yield interface that extends ChildExecutorDecision.Proto. This decision type passes execution to the next substream, either pulling a new element from upstream or yielding to an already created active substream.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/ChildExecutorDecision-Yield.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface Yield extends ChildExecutorDecision.Proto {\n  readonly _tag: \"Yield\"\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Tagged Enum with Generic Types in TypeScript\nDESCRIPTION: An example showing how to create a tagged enum constructor with generic type parameters for a result type that can represent either success or failure cases.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Data-taggedEnum.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Data } from \"effect\"\n\ntype MyResult<E, A> = Data.TaggedEnum<{\n  Failure: { readonly error: E }\n  Success: { readonly value: A }\n}>\ninterface MyResultDefinition extends Data.TaggedEnum.WithGenerics<2> {\n  readonly taggedEnum: MyResult<this[\"A\"], this[\"B\"]>\n}\nconst { Failure, Success } = Data.taggedEnum<MyResultDefinition>()\n\nconst success = Success({ value: 1 })\n```\n\n----------------------------------------\n\nTITLE: Effect.exit Function Signature in TypeScript\nDESCRIPTION: This code snippet shows the TypeScript signature of the Effect.exit function. It takes an Effect as input and returns a new Effect that always succeeds, wrapping its outcome in the Exit type.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-exit.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const exit: <A, E, R>(self: Effect<A, E, R>) => Effect<Exit.Exit<A, E>, never, R>\n```\n\n----------------------------------------\n\nTITLE: Checking BackPressure MergeStrategy in TypeScript\nDESCRIPTION: Type guard function that determines if a given MergeStrategy is specifically a BackPressure strategy. Returns a boolean and provides type narrowing for TypeScript type system.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/MergeStrategy-isBackPressure.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const isBackPressure: (self: MergeStrategy) => self is BackPressure\n```\n\n----------------------------------------\n\nTITLE: Initializing Unsafe Supervisor Tracking in TypeScript\nDESCRIPTION: Creates a supervisor that tracks runtime fibers without guaranteed safety. Returns a supervisor capable of managing an array of runtime fibers with potentially unknown success and error types.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Supervisor-unsafeTrack.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const unsafeTrack: () => Supervisor<Array<Fiber.RuntimeFiber<any, any>>>\n```\n\n----------------------------------------\n\nTITLE: Defining MailboxFull Error Class in TypeScript\nDESCRIPTION: This code snippet defines the MailboxFull class, which represents an error that occurs when an entity's mailbox is full in a cluster. It is part of the ClusterError module in the @effect/cluster package.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/ClusterError-MailboxFull.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare class MailboxFull\n```\n\n----------------------------------------\n\nTITLE: Implementing Pretty Layout Algorithm in TypeScript\nDESCRIPTION: Defines the pretty layout algorithm function that renders documents based on layout constraints with one DocStream element lookahead. This is the default algorithm but may produce results that run to the right before breaking lines.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Layout-pretty.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const pretty: { (options: Layout.Options): <A>(self: Doc<A>) => DocStream<A>; <A>(self: Doc<A>, options: Layout.Options): DocStream<A>; }\n```\n\n----------------------------------------\n\nTITLE: Implementing Cursor Up Movement in TypeScript using ANSI Escape Codes\nDESCRIPTION: Function declaration for moving the cursor up in a terminal by a specified number of lines using ANSI escape sequences. The function accepts an optional lines parameter (defaults to 1) and returns an Ansi type. This operation has no effect if the cursor is already at the screen edge.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Ansi-cursorUp.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const cursorUp: (lines?: number) => Ansi\n```\n\n----------------------------------------\n\nTITLE: Initializing Number Comparison with Effect Library\nDESCRIPTION: Demonstrates the usage of the lessThan function to compare numeric values, returning a boolean indicating whether the first number is less than the second\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Number-lessThan.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { lessThan } from \"effect/Number\"\n\nassert.deepStrictEqual(lessThan(2, 3), true)\nassert.deepStrictEqual(lessThan(3, 3), false)\nassert.deepStrictEqual(lessThan(4, 3), false)\n```\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const lessThan: { (that: number): (self: number) => boolean; (self: number, that: number): boolean; }\n```\n\n----------------------------------------\n\nTITLE: Brand.all Function Signature in TypeScript\nDESCRIPTION: The type signature of the Brand.all function, which combines two or more brand constructors to create a new brand constructor that applies all the provided brand validations.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Brand-all.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const all: <Brands extends readonly [Brand.Constructor<any>, ...Array<Brand.Constructor<any>>]>(...brands: Brand.EnsureCommonBase<Brands>) => Brand.Constructor<Types.UnionToIntersection<{ [B in keyof Brands]: Brand.FromConstructor<Brands[B]>; }[number]> extends infer X extends Brand<any> ? X : Brand<any>>\n```\n\n----------------------------------------\n\nTITLE: TArray collectFirstSTM signature\nDESCRIPTION: Defines the type signature for the `collectFirstSTM` function. It takes a transactional partial function `pf` and a `TArray<A>` as input, returning an `STM.STM` computation that yields an `Option.Option<B>` representing the result of applying `pf` to the first suitable element in the array.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TArray-collectFirstSTM.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const collectFirstSTM: { <A, B, E, R>(pf: (a: A) => Option.Option<STM.STM<B, E, R>>): (self: TArray<A>) => STM.STM<Option.Option<B>, E, R>; <A, B, E, R>(self: TArray<A>, pf: (a: A) => Option.Option<STM.STM<B, E, R>>): STM.STM<Option.Option<B>, E, R>; }\n```\n\n----------------------------------------\n\nTITLE: Retrieving Multiple Values from RedBlackTree in TypeScript\nDESCRIPTION: Function signature for findAll operation that retrieves all values associated with a specific key from a RedBlackTree data structure. Supports both curried and uncurried calling styles.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/RedBlackTree-findAll.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const findAll: { <K>(key: K): <V>(self: RedBlackTree<K, V>) => Chunk<V>; <K, V>(self: RedBlackTree<K, V>, key: K): Chunk<V>; }\n```\n\n----------------------------------------\n\nTITLE: Signature: Effect Record Replace Function\nDESCRIPTION: This code snippet shows the TypeScript signature of the `Record.replace` function.  It defines the function's generic types and expected input/output types, allowing to understand how the function interacts with different type of records.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Record-replace.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const replace: { <K extends string | symbol, B>(key: NoInfer<K>, value: B): <A>(self: ReadonlyRecord<K, A>) => Record<K, A | B>; <K extends string | symbol, A, B>(self: ReadonlyRecord<K, A>, key: NoInfer<K>, value: B): Record<K, A | B>; }\n```\n\n----------------------------------------\n\nTITLE: Type Definition for HashMap.HashMap.Key Utility in TypeScript\nDESCRIPTION: This code shows the type signature for the HashMap.HashMap.Key utility. It uses conditional types to extract the key type K from a HashMap<K, V> type parameter, returning 'never' if the provided type is not a HashMap.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/HashMap-HashMap.Key.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ntype Key<T> = [T] extends [HashMap<infer _K, infer _V>] ? _K : never\n```\n\n----------------------------------------\n\nTITLE: Type Checking for Cause Objects in TypeScript\nDESCRIPTION: A utility function that checks if a provided unknown value is a Cause object. This is useful for type narrowing and validation in TypeScript applications using the effect library.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Cause-isCause.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const isCause: (u: unknown) => u is Cause<unknown>\n```\n\n----------------------------------------\n\nTITLE: Implementing cursor forward movement in ANSI terminals with TypeScript\nDESCRIPTION: Function that creates an ANSI escape sequence to move the cursor forward by a specified number of columns (defaults to 1) from the current position. Has no effect if the cursor is already at the edge of the screen.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Ansi-cursorForward.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const cursorForward: (columns?: number) => Ansi\n```\n\n----------------------------------------\n\nTITLE: DateTime.withCurrentZoneOffset TypeScript Function Signature\nDESCRIPTION: The type signature for the withCurrentZoneOffset function in the DateTime module. It shows that the function can be used in two ways: either by passing the offset first or by passing the effect first followed by the offset.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/DateTime-withCurrentZoneOffset.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const withCurrentZoneOffset: { (offset: number): <A, E, R>(effect: Effect.Effect<A, E, R>) => Effect.Effect<A, E, Exclude<R, CurrentTimeZone>>; <A, E, R>(effect: Effect.Effect<A, E, R>, offset: number): Effect.Effect<A, E, Exclude<R, CurrentTimeZone>>; }\n```\n\n----------------------------------------\n\nTITLE: Declaring Channel.scopedWith Function in TypeScript\nDESCRIPTION: Defines the scopedWith function in the Channel module. It takes a function that receives a Scope and returns an Effect, which is used to emit an output element. The output element will be the result of the returned effect if successful.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Channel-scopedWith.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const scopedWith: <A, E, R>(f: (scope: Scope.Scope) => Effect.Effect<A, E, R>) => Channel<A, unknown, E, unknown, unknown, unknown, R>\n```\n\n----------------------------------------\n\nTITLE: BigDecimal.toExponential Function Signature\nDESCRIPTION: The type signature for the toExponential function which takes a BigDecimal value and returns a string representation in scientific notation.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/BigDecimal-toExponential.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const toExponential: (n: BigDecimal) => string\n```\n\n----------------------------------------\n\nTITLE: Stream.make Function Signature in TypeScript\nDESCRIPTION: This snippet shows the TypeScript signature for the Stream.make function. It accepts a variable number of arguments and returns a Stream of the argument type.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-make.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const make: <As extends Array<any>>(...as: As) => Stream<As[number]>\n```\n\n----------------------------------------\n\nTITLE: Array.join Function Signature in TypeScript\nDESCRIPTION: Provides the TypeScript function signature for the Array.join function. It shows two overloads: one that takes a separator first and returns a function, and another that takes the iterable and separator directly.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Array-join.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const join: { (sep: string): (self: Iterable<string>) => string; (self: Iterable<string>, sep: string): string; }\n```\n\n----------------------------------------\n\nTITLE: HashSet.filter Function Signature in TypeScript\nDESCRIPTION: The type signature for the HashSet.filter function, supporting both refinement and predicate operations. The function is overloaded to handle both data-first and data-last (pipeable) calling styles.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/HashSet-filter.md#2025-04-11_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const filter: { <A, B extends A>(refinement: Refinement<NoInfer<A>, B>): (self: HashSet<A>) => HashSet<B>; <A>(predicate: Predicate<NoInfer<A>>): (self: HashSet<A>) => HashSet<A>; <A, B extends A>(self: HashSet<A>, refinement: Refinement<A, B>): HashSet<B>; <A>(self: HashSet<A>, predicate: Predicate<A>): HashSet<A>; }\n```\n\n----------------------------------------\n\nTITLE: Defining keepDefects Function in Typescript for Cause Module\nDESCRIPTION: This function removes all Fail and Interrupt nodes from a Cause, keeping only Die nodes (defects). It returns an Option of Cause<never> if defects remain, or None if no defects are present. This is useful for focusing on unexpected failures when both known errors and defects could occur.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Cause-keepDefects.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const keepDefects: <E>(self: Cause<E>) => Option.Option<Cause<never>>\n```\n\n----------------------------------------\n\nTITLE: Defining Interval Interface in TypeScript\nDESCRIPTION: This code snippet defines the Interval interface, which represents a time interval. It includes a unique identifier and properties for the start and end times in milliseconds. The interface is part of the ScheduleInterval module in the effect package.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/ScheduleInterval-Interval.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface Interval {\n  readonly [IntervalTypeId]: IntervalTypeId\n  readonly startMillis: number\n  readonly endMillis: number\n}\n```\n\n----------------------------------------\n\nTITLE: Defining the Micro.tap Function in TypeScript\nDESCRIPTION: TypeScript declaration for the Micro.tap function which executes a side effect from the success value of a Micro effect. This function is similar to andThen but ignores the success value of the side effect, returning the original success value.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Micro-tap.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const tap: { <A, X>(f: (a: NoInfer<A>) => X): <E, R>(self: Micro<A, E, R>) => [X] extends [Micro<infer _A1, infer E1, infer R1>] ? Micro<A, E | E1, R | R1> : Micro<A, E, R>; <X>(f: NotFunction<X>): <A, E, R>(self: Micro<A, E, R>) => [X] extends [Micro<infer _A1, infer E1, infer R1>] ? Micro<A, E | E1, R | R1> : Micro<A, E, R>; <A, E, R, X>(self: Micro<A, E, R>, f: (a: NoInfer<A>) => X): [X] extends [Micro<infer _A1, infer E1, infer R1>] ? Micro<A, E | E1, R | R1> : Micro<A, E, R>; <A, E, R, X>(self: Micro<A, E, R>, f: NotFunction<X>): [X] extends [Micro<infer _A1, infer E1, infer R1>] ? Micro<A, E | E1, R | R1> : Micro<A, E, R>; }\n```\n\n----------------------------------------\n\nTITLE: Defining OpenAI Request Telemetry Interface in TypeScript\nDESCRIPTION: Provides a type-safe interface for capturing OpenAI request attributes with optional properties for response format and service tier. Supports specific string formats and well-known predefined types.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/OpenAiTelemetry-OpenAiTelemetry.RequestAttributes.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface RequestAttributes {\n    readonly responseFormat?: (string & {}) | WellKnownResponseFormat | null | undefined\n    readonly serviceTier?: (string & {}) | WellKnownServiceTier | null | undefined\n  }\n```\n\n----------------------------------------\n\nTITLE: Defining ConfigError Union Type in TypeScript\nDESCRIPTION: Defines the ConfigError type as a union of possible configuration error types including And, Or, InvalidData, MissingData, SourceUnavailable, and Unsupported. This represents all possible ways configuration loading can fail in the effect library.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/ConfigError-ConfigError.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ntype ConfigError = | And\n  | Or\n  | InvalidData\n  | MissingData\n  | SourceUnavailable\n  | Unsupported\n```\n\n----------------------------------------\n\nTITLE: Type Predicate for WithPageWidth Doc in TypeScript\nDESCRIPTION: A function that checks if a Doc instance is specifically a WithPageWidth type. Returns true if the passed Doc is a WithPageWidth, false otherwise. This function acts as a type guard in TypeScript.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Doc-isWithPageWidth.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const isWithPageWidth: <A>(self: Doc<A>) => self is WithPageWidth<A>\n```\n\n----------------------------------------\n\nTITLE: Setting Scheduler for Effect Execution in TypeScript\nDESCRIPTION: The withScheduler function sets the provided scheduler for usage in the wrapped effect. It can be used in both curried and non-curried forms.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-withScheduler.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const withScheduler: { (scheduler: Scheduler.Scheduler): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R>; <A, E, R>(self: Effect<A, E, R>, scheduler: Scheduler.Scheduler): Effect<A, E, R>; }\n```\n\n----------------------------------------\n\nTITLE: Adding GenAI Annotations to Telemetry Spans in TypeScript\nDESCRIPTION: A function that applies GenAI telemetry attributes to a provided Span object. This function supports two call signatures - either providing options first followed by the span, or providing the span first followed by options. Note that this function mutates the Span in-place.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/AiTelemetry-addGenAIAnnotations.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const addGenAIAnnotations: { (options: GenAITelemetryAttributeOptions): (span: Span) => void; (span: Span, options: GenAITelemetryAttributeOptions): void; }\n```\n\n----------------------------------------\n\nTITLE: Initializing Empty Cookies Object in TypeScript\nDESCRIPTION: Declaration of the empty constant that represents an empty Cookies object. This can be used as a starting point for building cookie collections.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Cookies-empty.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const empty: Cookies\n```\n\n----------------------------------------\n\nTITLE: Function Signature for getSomes - TypeScript\nDESCRIPTION: This code snippet defines the TypeScript signature for the `getSomes` function, outlining its type constraints and expected input-output structure. It specifies that `getSomes` accepts a read-only record with keys of type string and values of type `Option`, and returns a record with the same keys, but only where the values are the unwrapped 'Some' type.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Record-getSomes.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const getSomes: <K extends string, A>(self: ReadonlyRecord<K, Option.Option<A>>) => Record<ReadonlyRecord.NonLiteralKey<K>, A>\n```\n\n----------------------------------------\n\nTITLE: Defining Schema.Schema.Any Type in TypeScript\nDESCRIPTION: Defines the Schema.Schema.Any type, which represents any schema except for 'never'. This type is generic and can handle any input, output, and unknown types.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Schema-Schema.Any.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ntype Any = Schema<any, any, unknown>\n```\n\n----------------------------------------\n\nTITLE: Defining Layer.sync Function in TypeScript\nDESCRIPTION: Declares the sync function in the Layer module. This function lazily constructs a layer from a specified value. It can be called with either a tag and an evaluation function, or just a tag that returns a function accepting the evaluation function.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Layer-sync.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const sync: { <I, S>(tag: Context.Tag<I, S>): (evaluate: LazyArg<Types.NoInfer<S>>) => Layer<I>; <I, S>(tag: Context.Tag<I, S>, evaluate: LazyArg<Types.NoInfer<S>>): Layer<I>; }\n```\n\n----------------------------------------\n\nTITLE: Formatting TimeZones as Strings in Effect DateTime Module\nDESCRIPTION: This example demonstrates how to convert TimeZone objects to their string representation using the zoneToString function. It shows formatting both an offset-based timezone (+03:00) and a named timezone (Europe/London).\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/DateTime-zoneToString.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { DateTime, Effect } from \"effect\"\n\n// Outputs \"+03:00\"\nDateTime.zoneToString(DateTime.zoneMakeOffset(3 * 60 * 60 * 1000))\n\n// Outputs \"Europe/London\"\nDateTime.zoneToString(DateTime.zoneUnsafeMakeNamed(\"Europe/London\"))\n```\n\n----------------------------------------\n\nTITLE: TypeScript Function Signature for Array.prependAll\nDESCRIPTION: The TypeScript type signature for the prependAll function, showing its polymorphic nature with support for different combinations of regular arrays, non-empty arrays, and iterables. The function preserves type information about non-emptiness.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Array-prependAll.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const prependAll: { <S extends Iterable<any>, T extends Iterable<any>>(that: T): (self: S) => ReadonlyArray.OrNonEmpty<S, T, ReadonlyArray.Infer<S> | ReadonlyArray.Infer<T>>; <A, B>(self: Iterable<A>, that: NonEmptyReadonlyArray<B>): NonEmptyArray<A | B>; <A, B>(self: NonEmptyReadonlyArray<A>, that: Iterable<B>): NonEmptyArray<A | B>; <A, B>(self: Iterable<A>, that: Iterable<B>): Array<A | B>; }\n```\n\n----------------------------------------\n\nTITLE: Declaring releaseRead Function in Effect-TS TypeScript\nDESCRIPTION: This TypeScript function, releaseRead, is part of the TReentrantLock module within the Effect-TS library. It is used to release a read lock held by a fiber and returns the current number of read locks held. It requires the TReentrantLock object as a parameter and is built on the STM (Software Transactional Memory) model. No dependencies aside from the Effect-TS library are required.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TReentrantLock-releaseRead.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const releaseRead: (self: TReentrantLock) => STM.STM<number>\n```\n\n----------------------------------------\n\nTITLE: Effect.filterEffectOrFail Type Signature\nDESCRIPTION: Type signature for the filterEffectOrFail function showing its polymorphic nature and type constraints. The signature supports both curried and uncurried calling styles with generic type parameters.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-filterEffectOrFail.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const filterEffectOrFail: { <A, E2, R2, E3>(options: { readonly predicate: (a: NoInfer<A>) => Effect<boolean, E2, R2>; readonly orFailWith: (a: NoInfer<A>) => E3; }): <E, R>(self: Effect<A, E, R>) => Effect<A, E | E2 | E3, R | R2>; <A, E, R, E2, R2, E3>(self: Effect<A, E, R>, options: { readonly predicate: (a: A) => Effect<boolean, E2, R2>; readonly orFailWith: (a: A) => E3; }): Effect<A, E | E2 | E3, R | R2>; }\n```\n\n----------------------------------------\n\nTITLE: Defining Stream Error Cause Tap in TypeScript\nDESCRIPTION: A type declaration for a function that allows effectful inspection of stream error causes. It enables developers to perform side effects or logging when a stream encounters an error without stopping the stream's execution.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-tapErrorCause.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const tapErrorCause: { <E, X, E2, R2>(f: (cause: Cause.Cause<NoInfer<E>>) => Effect.Effect<X, E2, R2>): <A, R>(self: Stream<A, E, R>) => Stream<A, E | E2, R2 | R>; <A, E, R, X, E2, R2>(self: Stream<A, E, R>, f: (cause: Cause.Cause<E>) => Effect.Effect<X, E2, R2>): Stream<A, E | E2, R | R2>; }\n```\n\n----------------------------------------\n\nTITLE: Retrieving Last Element from NonEmptyChunk in TypeScript\nDESCRIPTION: The 'lastNonEmpty' function returns the last element of a non-empty chunk. It takes a NonEmptyChunk<A> as input and returns a value of type A. This function is available since version 3.4.0 of the effect package.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Chunk-lastNonEmpty.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const lastNonEmpty: <A>(self: NonEmptyChunk<A>) => A\n```\n\n----------------------------------------\n\nTITLE: Retrieving Metric Labels in Effect\nDESCRIPTION: Function signature for retrieving an array of metric labels from the current scope. Returns an Effect that resolves to a readonly array of MetricLabel.MetricLabel with no error or dependency requirements.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-metricLabels.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const metricLabels: Effect<ReadonlyArray<MetricLabel.MetricLabel>, never, never>\n```\n\n----------------------------------------\n\nTITLE: Accessing Stream Context with TypeScript\nDESCRIPTION: The `contextWith` function allows developers to access the context of a stream using a function that operates on the provided environment context. It is part of the Effect library's stream module and returns a Stream type. The signature specifies generic parameters R and A, where R is the context type and A is the return type of the function `f`. This utility has been available since version 2.0.0.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-contextWith.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const contextWith: <R, A>(f: (env: Context.Context<R>) => A) => Stream<A, never, R>\n```\n\n----------------------------------------\n\nTITLE: Retrieving Item from Pool with Effect-TS\nDESCRIPTION: This code snippet demonstrates how to retrieve an item from a pool using the `Pool.get` function within the Effect-TS library. The function returns an `Effect` that represents the acquisition of an item from the pool within a given scope. If the acquisition fails, the effect will fail with the corresponding error.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Pool-get.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const get: <A, E>(self: Pool<A, E>) => Effect.Effect<A, E, Scope.Scope>\n```\n\n----------------------------------------\n\nTITLE: Setting All Fiber References in Effect TypeScript Library\nDESCRIPTION: The `setAll` function takes a FiberRefs object and returns an Effect that sets each reference to either its value or its default. This is useful for initializing or resetting the state of fiber-local references.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/FiberRefs-setAll.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const setAll: (self: FiberRefs) => Effect.Effect<void>\n```\n\n----------------------------------------\n\nTITLE: Defining ExecutionStrategy Union Type in TypeScript\nDESCRIPTION: Defines a union type ExecutionStrategy that represents different strategies for evaluating multiple effects. The type can be Sequential for sequential execution, Parallel for fully parallel execution, or ParallelN for controlled parallel execution with a specific number of concurrent operations.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/ExecutionStrategy-ExecutionStrategy.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ntype ExecutionStrategy = Sequential | Parallel | ParallelN\n```\n\n----------------------------------------\n\nTITLE: Implementing Bimap Composition in TypeScript Effect-IO\nDESCRIPTION: Defines a default ternary bimap composition function that combines a Covariant and Bicovariant type to create a new mapping operation. This function allows for transformation of both the error and success types in a functional context.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Bicovariant-bimapComposition.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const bimapComposition: <F extends TypeLambda, G extends TypeLambda>(CovariantF: Covariant<F>, BicovariantG: Bicovariant<G>) => <FR, FO, FE, GR, GO, E1, A, E2, B>(self: Kind<F, FR, FO, FE, Kind<G, GR, GO, E1, A>>, f: (e: E1) => E2, g: (a: A) => B) => Kind<F, FR, FO, FE, Kind<G, GR, GO, E2, B>>\n```\n\n----------------------------------------\n\nTITLE: Function Signature for isSymbol - TypeScript\nDESCRIPTION: This snippet declares the type signature for the `isSymbol` function, which takes an unknown input and narrows it down to the symbol type if the input is indeed a symbol. This is crucial for TypeScript's type inference and safety.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Predicate-isSymbol.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const isSymbol: (input: unknown) => input is symbol\n```\n\n----------------------------------------\n\nTITLE: Implementing Sequential Result Zipping in TypeScript\nDESCRIPTION: Defines a zipLeft function that combines two Exit results, keeping only the first value while preserving error handling. The function handles both success and failure cases, combining error types from both inputs.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Exit-zipLeft.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const zipLeft: { <A2, E2>(that: Exit<A2, E2>): <A, E>(self: Exit<A, E>) => Exit<A, E2 | E>; <A, E, A2, E2>(self: Exit<A, E>, that: Exit<A2, E2>): Exit<A, E | E2>; }\n```\n\n----------------------------------------\n\nTITLE: Interrupting Child Effects in TypeScript\nDESCRIPTION: Defines the 'interruptWhenPossible' function for managing interruptions of child effects in requests. It can take either a single Effect instance or an iterable of Request instances to perform the interruption. This is essential for handling cleanup in asynchronous scenarios when requests are no longer required, particularly in versions starting from v2.0.0 of the Effect library.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Request-interruptWhenPossible.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const interruptWhenPossible: { (all: Iterable<Request<any, any>>): <A, E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<void, E, R>; <A, E, R>(self: Effect.Effect<A, E, R>, all: Iterable<Request<any, any>>): Effect.Effect<void, E, R>; }\n```\n\n----------------------------------------\n\nTITLE: Array.remove Function Signature in TypeScript\nDESCRIPTION: Provides the TypeScript signature for the Array.remove function. It shows the function's polymorphic nature, allowing for both curried and uncurried usage with different parameter orders.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Array-remove.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const remove: { (i: number): <A>(self: Iterable<A>) => Array<A>; <A>(self: Iterable<A>, i: number): Array<A>; }\n```\n\n----------------------------------------\n\nTITLE: Type signature for Tuple.make in TypeScript\nDESCRIPTION: This signature defines the type for the `make` function in Tuple, which takes a variable number of elements and returns them as a tuple. It uses TypeScript's generics to allow flexibility in the types of elements.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Tuple-make.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const make: <A extends ReadonlyArray<any>>(...elements: A) => A\n```\n\n----------------------------------------\n\nTITLE: Retrieving the Second Element from a Tuple using Effect-TS in TypeScript\nDESCRIPTION: This code snippet demonstrates how to use the `getSecond` function from the Effect-TS library to obtain the second element from a tuple. It requires importing the `assert` module from Node.js and the `getSecond` function from `effect/Tuple`. The function signature indicates a generic implementation, accepting a tuple of two elements and returning the second. Inputs must be tuples, and the output will be the second element, with type consistency ensured by generics.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Tuple-getSecond.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { getSecond } from \"effect/Tuple\"\n\nassert.deepStrictEqual(getSecond([\"hello\", 42]), 42)\n```\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const getSecond: <L, R>(self: readonly [L, R]) => R\n```\n\n----------------------------------------\n\nTITLE: BigDecimal Sum Function Type Signature\nDESCRIPTION: Type declaration for the sum function showing its overloaded signatures. It can be called either with two parameters or in a curried form with single parameters.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/BigDecimal-sum.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const sum: { (that: BigDecimal): (self: BigDecimal) => BigDecimal; (self: BigDecimal, that: BigDecimal): BigDecimal; }\n```\n\n----------------------------------------\n\nTITLE: Declaring DateTimeUpdateFromDate field type in Effect SQL\nDESCRIPTION: Declaration of the DateTimeUpdateFromDate field type, which represents a date-time value that is automatically updated to the current DateTime.Utc on inserts and updates. It's serialized as a Date for database storage and is available for selection.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Model-DateTimeUpdateFromDate.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const DateTimeUpdateFromDate: DateTimeUpdateFromDate\n```\n\n----------------------------------------\n\nTITLE: Implementing Type Checking for Config Values in TypeScript\nDESCRIPTION: The isConfig function is a type guard that checks if a given value is of type Config<unknown>. It's useful for validating inputs before performing operations that require Config values.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Config-isConfig.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const isConfig: (u: unknown) => u is Config<unknown>\n```\n\n----------------------------------------\n\nTITLE: Constructing a HashMap Config in TypeScript\nDESCRIPTION: The Config.hashMap function creates a configuration for a sequence of values. It takes a config parameter for the value type and an optional name parameter, returning a Config for a HashMap with string keys and values of the specified type.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Config-hashMap.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const hashMap: <A>(config: Config<A>, name?: string) => Config<HashMap.HashMap<string, A>>\n```\n\n----------------------------------------\n\nTITLE: Implementing Stream Transducer in TypeScript\nDESCRIPTION: Function signature for a Stream transducer that takes a Sink and applies it to transform stream elements. The function is overloaded to support both curried and direct parameter passing styles. It handles error types E and E2, and resource types R and R2.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-transduce.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const transduce: { <A2, A, E2, R2>(sink: Sink.Sink<A2, A, A, E2, R2>): <E, R>(self: Stream<A, E, R>) => Stream<A2, E2 | E, R2 | R>; <A, E, R, A2, E2, R2>(self: Stream<A, E, R>, sink: Sink.Sink<A2, A, A, E2, R2>): Stream<A2, E | E2, R | R2>; }\n```\n\n----------------------------------------\n\nTITLE: Transforming Sinks using dimap in Effect-TS TypeScript\nDESCRIPTION: The `dimap` function is used to transform both the inputs and the result of a sink by applying specified functions. It allows for two different usages: by passing in options directly, or by partially applying options to an existing sink. The function relies on transformation functions `onInput` and `onDone` provided in the options to alter the input and output types. No external dependencies are required apart from the `Sink` type. Constraints include adherence to the input-output types defined by the transformation functions.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Sink-dimap.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const dimap: { <In0, In, A, A2>(options: { readonly onInput: (input: In0) => In; readonly onDone: (a: A) => A2; }): <L, E, R>(self: Sink<A, In, L, E, R>) => Sink<A2, In0, L, E, R>; <A, In, L, E, R, In0, A2>(self: Sink<A, In, L, E, R>, options: { readonly onInput: (input: In0) => In; readonly onDone: (a: A) => A2; }): Sink<A2, In0, L, E, R>; }\n```\n\n----------------------------------------\n\nTITLE: Defining SemigroupSum Type Signature in TypeScript\nDESCRIPTION: This snippet declares the type signature of SemigroupSum, defining it as a semigroup for numbers according to the TypeScript type system. This ensures that the SemigroupSum is recognized as a valid semigroup under addition.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/data-Number-SemigroupSum.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const SemigroupSum: semigroup.Semigroup<number>\n```\n\n----------------------------------------\n\nTITLE: Declaring JSONSchema.fromAST Function in TypeScript\nDESCRIPTION: Function signature for converting an AST to JSON Schema with various configuration options including definitions, path specifications, target schema version, reference handling, and additional properties behavior.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/JSONSchema-fromAST.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const fromAST: (ast: AST.AST, options: { readonly definitions: Record<string, JsonSchema7>; readonly definitionPath?: string | undefined; readonly target?: Target | undefined; readonly topLevelReferenceStrategy?: TopLevelReferenceStrategy | undefined; readonly additionalPropertiesStrategy?: AdditionalPropertiesStrategy | undefined; }) => JsonSchema7\n```\n\n----------------------------------------\n\nTITLE: Defining String Semigroup in TypeScript\nDESCRIPTION: Implements a semigroup instance for strings that enables concatenation operations. This is part of the @effect/typeclass package's String module and provides the algebraic structure for combining strings.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/data-String-Semigroup.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const Semigroup: semigroup.Semigroup<string>\n```\n\n----------------------------------------\n\nTITLE: Defining MergeLeft Type in TypeScript\nDESCRIPTION: Defines a TypeScript type 'MergeLeft' which merges two objects, prioritizing the left object's keys in case of conflicts. The implementation makes use of TypeScript's advanced type features, necessitating the effect framework as a dependency. The expected input is two object types, and the output is a merged object with the left type's keys taking precedence.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Types-MergeLeft.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport type { Types } from \"effect\"\ntype MergeLeft = Types.MergeLeft<{ a: number, b: number; }, { a: string }> // { a: number; b: number; }\n```\n\n----------------------------------------\n\nTITLE: Type Checking for EncodeException in TypeScript\nDESCRIPTION: A type guard function that checks if a given unknown value is an EncodeException type. Returns true if the value is an EncodeException, false otherwise.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Encoding-isEncodeException.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const isEncodeException: (u: unknown) => u is EncodeException\n```\n\n----------------------------------------\n\nTITLE: Using Effect.dropUntil to Filter an Array in TypeScript\nDESCRIPTION: This example demonstrates how to use Effect.dropUntil to filter an array of numbers, dropping elements until a number greater than 3 is encountered. The function returns an effect that, when run, produces the remaining elements of the array.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-dropUntil.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Effect } from \"effect\"\n\nconst numbers = [1, 2, 3, 4, 5, 6]\nconst predicate = (n: number, i: number) => Effect.succeed(n > 3)\n\nconst program = Effect.gen(function*() {\n  const result = yield* Effect.dropUntil(numbers, predicate)\n  console.log(result)\n})\n\nEffect.runFork(program)\n// Output: [5, 6]\n```\n\n----------------------------------------\n\nTITLE: Defining changesUponFlattening Function in TypeScript\nDESCRIPTION: Declares the `changesUponFlattening` function that takes a `Doc<A>` and returns a `Flatten<Doc<A>>`. This function analyzes the document structure and determines how it might change when flattened, categorizing the result as 'Flattened', 'AlreadyFlat', or 'NeverFlat'.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Doc-changesUponFlattening.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const changesUponFlattening: <A>(self: Doc<A>) => Flatten<Doc<A>>\n```\n\n----------------------------------------\n\nTITLE: makeBy Function Type Definition - TypeScript\nDESCRIPTION: Type signature for the makeBy function showing it takes a function parameter of type (i: number) => A and an optional options object with length property, returning an Iterable<A>.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Iterable-makeBy.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const makeBy: <A>(f: (i: number) => A, options?: { readonly length?: number; }) => Iterable<A>\n```\n\n----------------------------------------\n\nTITLE: renderSimplyDecorated Function Signature\nDESCRIPTION: The type signature for the renderSimplyDecorated function, which supports both curried and uncurried calling styles. It requires a Monoid instance, a text rendering function, and an annotation rendering function to transform DocTree nodes.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/DocTree-renderSimplyDecorated.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const renderSimplyDecorated: { <A, M>(M: monoid.Monoid<M>, renderText: (text: string) => M, renderAnnotation: (annotation: A, out: M) => M): (self: DocTree<A>) => M; <A, M>(self: DocTree<A>, M: monoid.Monoid<M>, renderText: (text: string) => M, renderAnnotation: (annotation: A, out: M) => M): M; }\n```\n\n----------------------------------------\n\nTITLE: Implementing TextTree Type Check in TypeScript\nDESCRIPTION: Type guard function that determines if a given DocTree instance is specifically a TextTree. Takes a DocTree parameter and returns a boolean indicating if it's a TextTree instance using type narrowing.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/DocTree-isTextTree.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const isTextTree: <A>(self: DocTree<A>) => self is TextTree<A>\n```\n\n----------------------------------------\n\nTITLE: Layout.compact Function Signature in TypeScript\nDESCRIPTION: Type declaration for the Layout.compact function that transforms a Doc<A> into a DocStream<A>.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Layout-compact.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const compact: <A>(self: Doc<A>) => DocStream<A>\n```\n\n----------------------------------------\n\nTITLE: DateTimeInsertFromDate Declaration\nDESCRIPTION: This code snippet declares the `DateTimeInsertFromDate` constant. This constant represents a date-time value that is inserted as the current `DateTime.Utc`. It is serialized as a `Date` for the database, omitted from updates, and available for selection.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Model-DateTimeInsertFromDate.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const DateTimeInsertFromDate: DateTimeInsertFromDate\n```\n\n----------------------------------------\n\nTITLE: Type Declaration for unsafeFromNumber in BigDecimal Module\nDESCRIPTION: Provides the TypeScript type signature for the unsafeFromNumber function, which takes a number parameter and returns a BigDecimal object. This is the formal interface declaration for the function documented above.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/BigDecimal-unsafeFromNumber.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const unsafeFromNumber: (n: number) => BigDecimal\n```\n\n----------------------------------------\n\nTITLE: Defining NonNegativeInt Schema in TypeScript\nDESCRIPTION: Declares a constant NonNegativeInt as a refined schema type for non-negative integers. It extends the NonNegative type and excludes positive infinity. This schema can be used for data validation and type-safe operations.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Schema-NonNegativeInt.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const NonNegativeInt: refine<number, typeof NonNegative>\n```\n\n----------------------------------------\n\nTITLE: Trie.reduce Function Signature in TypeScript\nDESCRIPTION: The type signature of the Trie.reduce function, which allows reducing a state over the entries of the Trie. It can be used in both curried and uncurried forms.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Trie-reduce.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const reduce: { <Z, V>(zero: Z, f: (accumulator: Z, value: V, key: string) => Z): (self: Trie<V>) => Z; <Z, V>(self: Trie<V>, zero: Z, f: (accumulator: Z, value: V, key: string) => Z): Z; }\n```\n\n----------------------------------------\n\nTITLE: Defining InterruptedException Interface in TypeScript\nDESCRIPTION: TypeScript interface definition for InterruptedException which extends YieldableError. This interface represents errors that occur when a fiber is forcefully interrupted during cancellations or system directives.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Cause-InterruptedException.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface InterruptedException extends YieldableError {\n  readonly _tag: \"InterruptedException\"\n  readonly [InterruptedExceptionTypeId]: InterruptedExceptionTypeId\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing stripMarginWith Function in TypeScript\nDESCRIPTION: A function that strips leading whitespace and a specified margin character from each line of a string. It can be used in two ways: either by providing the margin character first and string second, or vice versa through function currying.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/String-stripMarginWith.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const stripMarginWith: { (marginChar: string): (self: string) => string; (self: string, marginChar: string): string; }\n```\n\n----------------------------------------\n\nTITLE: Declaring a Sink for Summing Numbers in TypeScript\nDESCRIPTION: Defines a constant `sum` of type Sink that accumulates incoming numeric values by adding them together. This sink takes number inputs and produces a number output with no error channels.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Sink-sum.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const sum: Sink<number, number, never, never, never>\n```\n\n----------------------------------------\n\nTITLE: Mailbox.make Function Signature in TypeScript\nDESCRIPTION: This code snippet shows the TypeScript signature for the Mailbox.make function. It creates a Mailbox with optional capacity and strategy parameters.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Mailbox-make.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const make: <A, E = never>(capacity?: number | { readonly capacity?: number; readonly strategy?: \"suspend\" | \"dropping\" | \"sliding\"; } | undefined) => Effect<Mailbox<A, E>>\n```\n\n----------------------------------------\n\nTITLE: Moving cursor to previous line in ANSI terminal with TypeScript\nDESCRIPTION: The cursorPrevLine function moves the cursor to the beginning of the line a specified number of rows up, with a default of 1 row. It returns an Ansi object that can be used in ANSI terminal output.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Ansi-cursorPrevLine.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const cursorPrevLine: (rows?: number) => Ansi\n```\n\n----------------------------------------\n\nTITLE: Defining PubSub.isFull in TypeScript\nDESCRIPTION: This snippet declares the isFull function, which checks if the PubSub queue contains at least one element. It is generic, accepting any type A. This function returns an Effect that resolves to a boolean indicating whether the queue is full or not.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/PubSub-isFull.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const isFull: <A>(self: PubSub<A>) => Effect.Effect<boolean>\n```\n\n----------------------------------------\n\nTITLE: Implementing isLineTree Type Guard for DocTree in TypeScript\nDESCRIPTION: Defines a function that checks if a given DocTree instance is specifically a LineTree. It returns true for LineTree instances and false for all other DocTree types. This function is useful for type narrowing in conditional logic.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/DocTree-isLineTree.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const isLineTree: <A>(self: DocTree<A>) => self is LineTree<A>\n```\n\n----------------------------------------\n\nTITLE: OptionFromNonEmptyTrimmedString Class Declaration in TypeScript\nDESCRIPTION: Declares the OptionFromNonEmptyTrimmedString class, which is used to create a schema for transforming strings into Option types. This class is part of the Schema module in the Effect package.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Schema-OptionFromNonEmptyTrimmedString.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare class OptionFromNonEmptyTrimmedString\n```\n\n----------------------------------------\n\nTITLE: Effect.fail Function Signature in TypeScript\nDESCRIPTION: This snippet shows the TypeScript signature for the Effect.fail function. It takes an error of type E and returns an Effect with never as its success type and E as its error type.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-fail.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const fail: <E>(error: E) => Effect<never, E>\n```\n\n----------------------------------------\n\nTITLE: Implementing Type Hole Simulation in TypeScript\nDESCRIPTION: The 'hole' function simulates a type hole in TypeScript. It's a generic function that takes no arguments and returns a value of type T. This can be useful for placeholder implementations or type-level programming.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Function-hole.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const hole: <T>() => T\n```\n\n----------------------------------------\n\nTITLE: Retrieving Values from Transactional Queue with TQueue.take in TypeScript\nDESCRIPTION: The take function removes and returns the oldest value in a transactional queue. If the queue is empty, it returns a computation that resumes when an item has been added to the queue. It operates within STM (Software Transactional Memory) context.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TQueue-take.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const take: <A>(self: TDequeue<A>) => STM.STM<A>\n```\n\n----------------------------------------\n\nTITLE: Declaring Schedule Recursion in TypeScript\nDESCRIPTION: This TypeScript code snippet declares the `scheduleRecurs` function, which returns a `MicroSchedule` object. This function is designed to perform recursive operations that halt after `n` attempts, therefore managing recursion depth. The exact value for `n` must be provided as an argument, allowing the user to define the maximum number of recursions.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Micro-scheduleRecurs.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const scheduleRecurs: (n: number) => MicroSchedule\n```\n\n----------------------------------------\n\nTITLE: Defining TestAnnotations Interface in TypeScript\nDESCRIPTION: This code snippet defines the TestAnnotations interface, which includes methods for managing test annotations and accessing supervised fibers. It provides functionality for getting and setting annotations, as well as retrieving the set of all fibers in the test.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TestAnnotations-TestAnnotations.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface TestAnnotations {\n  readonly [TestAnnotationsTypeId]: TestAnnotationsTypeId\n\n  /**\n   * A ref containing the bacnking map for all annotations\n   */\n  readonly ref: Ref.Ref<TestAnnotationMap.TestAnnotationMap>\n\n  /**\n   * Accesses an `Annotations` instance in the context and retrieves the\n   * annotation of the specified type, or its default value if there is none.\n   */\n  get<A>(key: TestAnnotation.TestAnnotation<A>): Effect.Effect<A>\n\n  /**\n   * Accesses an `Annotations` instance in the context and appends the\n   * specified annotation to the annotation map.\n   */\n  annotate<A>(key: TestAnnotation.TestAnnotation<A>, value: A): Effect.Effect<void>\n\n  /**\n   * Returns the set of all fibers in this test.\n   */\n  readonly supervisedFibers: Effect.Effect<\n    SortedSet.SortedSet<Fiber.RuntimeFiber<unknown, unknown>>\n  >\n}\n```\n\n----------------------------------------\n\nTITLE: Declaring angleBracketed Function in TypeScript\nDESCRIPTION: This function takes a Doc<A> as input and returns a new Doc<A> with the content enclosed in angle brackets (<>). It's available since version 1.0.0 of the package.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Doc-angleBracketed.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const angleBracketed: <A>(self: Doc<A>) => Doc<A>\n```\n\n----------------------------------------\n\nTITLE: Defining PopAnnotationStream Interface in TypeScript\nDESCRIPTION: Interface definition for PopAnnotationStream which represents the removal of a previously pushed annotation from a Doc. It extends DocStream.Variance and contains a _tag identifier and a reference to the underlying stream.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/DocStream-PopAnnotationStream.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface PopAnnotationStream<A> extends DocStream.Variance<A> {\n  readonly _tag: \"PopAnnotationStream\"\n  readonly stream: DocStream<A>\n}\n```\n\n----------------------------------------\n\nTITLE: Schema.NonEmptyTrimmedString Class Signature in TypeScript\nDESCRIPTION: This code snippet shows the type signature for the Schema.NonEmptyTrimmedString class. It is declared as a class without any explicit methods or properties.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Schema-NonEmptyTrimmedString.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare class NonEmptyTrimmedString\n```\n\n----------------------------------------\n\nTITLE: Converting TemplateLiteral AST to RegExp in TypeScript\nDESCRIPTION: Function signature for generating a regular expression from a TemplateLiteral AST node. This is the non-capturing variant of the pattern generation functionality, with a related capturing version available via getTemplateLiteralCapturingRegExp.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/SchemaAST-getTemplateLiteralRegExp.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const getTemplateLiteralRegExp: (ast: TemplateLiteral) => RegExp\n```\n\n----------------------------------------\n\nTITLE: Defining Schedule Combination with bothInOut\nDESCRIPTION: A type-safe function that merges two schedules, maintaining their individual input and output characteristics. It enables concurrent schedule execution with combined result tracking.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Schedule-bothInOut.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const bothInOut: { <Out2, In2, R2>(that: Schedule<Out2, In2, R2>): <Out, In, R>(self: Schedule<Out, In, R>) => Schedule<[Out, Out2], readonly [In, In2], R2 | R>; <Out, In, R, Out2, In2, R2>(self: Schedule<Out, In, R>, that: Schedule<Out2, In2, R2>): Schedule<[Out, Out2], readonly [In, In2], R | R2>; }\n```\n\n----------------------------------------\n\nTITLE: Declaring Boolean Monoid for Equivalence in TypeScript\nDESCRIPTION: This TypeScript snippet declares a monoid structure for boolean values under equivalence using the Effect-TS library. The monoid utilizes 'true' as the empty value, enabling monoidal operations based on equivalence. There are no external dependencies required beyond the Effect-TS library. The snippet expects boolean inputs and performs operations specific to the monoid structure defined by equivalence.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/data-Boolean-MonoidEqv.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const MonoidEqv: monoid.Monoid<boolean>\n```\n\n----------------------------------------\n\nTITLE: Mapping the Left Side of an Either in TypeScript\nDESCRIPTION: The mapLeft function transforms the Left value of an Either type while preserving the Right value. It can be used in both curried and uncurried forms for flexibility in functional programming patterns.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Either-mapLeft.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const mapLeft: { <L, L2>(f: (left: L) => L2): <R>(self: Either<R, L>) => Either<R, L2>; <R, L, L2>(self: Either<R, L>, f: (left: L) => L2): Either<R, L2>; }\n```\n\n----------------------------------------\n\nTITLE: Option.exists Signature in TypeScript\nDESCRIPTION: This snippet provides the TypeScript signature of the `Option.exists` function, outlining its overloads for both predicates and refinements. It demonstrates how the function can be used to either check if a value satisfies a condition or to refine the type of the value within the `Option`.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Option-exists.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const exists: { <A, B extends A>(refinement: Refinement<NoInfer<A>, B>): (self: Option<A>) => self is Option<B>; <A>(predicate: Predicate<NoInfer<A>>): (self: Option<A>) => boolean; <A, B extends A>(self: Option<A>, refinement: Refinement<A, B>): self is Option<B>; <A>(self: Option<A>, predicate: Predicate<A>): boolean; }\n```\n\n----------------------------------------\n\nTITLE: Implementing Base64 URL Encoding in TypeScript\nDESCRIPTION: Function signature for encoding a Uint8Array or string into a base64 URL-safe string. This utility is part of the effect package's Encoding module, allowing for URL-safe base64 encoding of binary data or text.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Encoding-encodeBase64Url.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const encodeBase64Url: (input: Uint8Array | string) => string\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Iterable.getSomes Function Usage in TypeScript\nDESCRIPTION: This example shows how to use the Iterable.getSomes function to retrieve Some values from an Iterable of Options. It imports necessary modules, creates an array of Options, and uses getSomes to filter out the Some values.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Iterable-getSomes.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { Iterable, Option } from \"effect\"\n\nassert.deepStrictEqual(\n  Array.from(Iterable.getSomes([Option.some(1), Option.none(), Option.some(2)])),\n  [1, 2]\n)\n```\n\n----------------------------------------\n\nTITLE: Defining Interface for Transactional Set in TypeScript\nDESCRIPTION: The code snippet declares an interface 'TSet', utilized for creating a transactional set that operates on top of a 'TMap'. It is an essential component from version 2.0.0 onwards, indicating its use for safe, transactional data operations. No specific methods or properties are detailed within the snippet, implying further exploration in other parts of the module.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TSet-TSet.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport interface TSet<in out A> extends TSet.Variance<A> {}\n```\n\n----------------------------------------\n\nTITLE: Defining ResponseAttributes Interface for GenAI in TypeScript\nDESCRIPTION: This code snippet defines the ResponseAttributes interface for the GenAI specification. It includes optional properties for the response id, the model name, and an array of finish reasons. These attributes are used for telemetry in AI-generated responses.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/AiTelemetry-GenAI.ResponseAttributes.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport interface ResponseAttributes {\n    /**\n     * The unique identifier for the completion.\n     */\n    readonly id?: string | null | undefined\n    /**\n     * The name of the model that generated the response.\n     */\n    readonly model?: string | null | undefined\n    /**\n     * Array of reasons the model stopped generating tokens, corresponding to\n     * each generation received.\n     */\n    readonly finishReasons?: ReadonlyArray<string> | null | undefined\n  }\n```\n\n----------------------------------------\n\nTITLE: Retrieving FiberRef Values in TypeScript\nDESCRIPTION: The get function retrieves the value of a specified FiberRef from a collection of FiberRef values. It returns an Option containing the value if it exists, or None otherwise. This function supports both curried and uncurried calling styles.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/FiberRefs-get.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const get: { <A>(fiberRef: FiberRef.FiberRef<A>): (self: FiberRefs) => Option.Option<A>; <A>(self: FiberRefs, fiberRef: FiberRef.FiberRef<A>): Option.Option<A>; }\n```\n\n----------------------------------------\n\nTITLE: Declaring TRandom.live Layer in TypeScript\nDESCRIPTION: Declares a constant 'live' that represents the live implementation of the TRandom service wrapped in a Layer. This allows for dependency injection of the random number generation service throughout an Effect application.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TRandom-live.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const live: Layer.Layer<TRandom, never, never>\n```\n\n----------------------------------------\n\nTITLE: Defining MicroSchedule Type in TypeScript\nDESCRIPTION: Defines a type representing a function that calculates delays between retry attempts. The function takes attempt number and elapsed time as parameters and returns an Option of number representing the delay duration. Returns None to stop repetition.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Micro-MicroSchedule.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ntype MicroSchedule = (attempt: number, elapsed: number) => Option.Option<number>\n```\n\n----------------------------------------\n\nTITLE: Defining Sequential ExecutionStrategy Interface in TypeScript\nDESCRIPTION: Defines the Sequential interface for executing effects sequentially in the ExecutionStrategy module. This interface has a _tag property with value \"Sequential\" to identify this execution strategy.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/ExecutionStrategy-Sequential.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface Sequential {\n  readonly _tag: \"Sequential\"\n}\n```\n\n----------------------------------------\n\nTITLE: Using isNever predicate in Effect\nDESCRIPTION: This example demonstrates how to use the `isNever` predicate from the `effect/Predicate` module.  The `isNever` function always returns `false` regardless of the input. It showcases how the predicate consistently returns `false` for various input types such as `null`, `undefined`, objects, and arrays.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Predicate-isNever.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { isNever } from \"effect/Predicate\"\n\nassert.deepStrictEqual(isNever(null), false)\nassert.deepStrictEqual(isNever(undefined), false)\nassert.deepStrictEqual(isNever({}), false)\nassert.deepStrictEqual(isNever([]), false)\n```\n\n----------------------------------------\n\nTITLE: List.prependAll Type Definition\nDESCRIPTION: Type signature for the prependAll function showing supported list type combinations and their return types. Handles both regular Lists and Cons (non-empty lists).\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/List-prependAll.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const prependAll: { <S extends List<any>, T extends List<any>>(that: T): (self: S) => List.OrNonEmpty<S, T, List.Infer<S> | List.Infer<T>>; <A, B>(self: List<A>, that: Cons<B>): Cons<A | B>; <A, B>(self: Cons<A>, that: List<B>): Cons<A | B>; <A, B>(self: List<A>, that: List<B>): List<A | B>; }\n```\n\n----------------------------------------\n\nTITLE: Defining isNoSuchElementException Type Guard in TypeScript\nDESCRIPTION: This function checks if a given unknown value is a NoSuchElementException. It serves as a type guard, narrowing the type of the input to NoSuchElementException if the check passes.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Cause-isNoSuchElementException.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const isNoSuchElementException: (u: unknown) => u is NoSuchElementException\n```\n\n----------------------------------------\n\nTITLE: Creating Date Arguments in Effect CLI\nDESCRIPTION: Creates a date argument with optional custom configuration. By default, the argument name is 'date'. Returns an Args instance that parses input into a JavaScript Date object.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Args-date.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const date: (config?: Args.BaseArgsConfig) => Args<globalThis.Date>\n```\n\n----------------------------------------\n\nTITLE: Defining CloseableScopeTypeId Type in TypeScript\nDESCRIPTION: Defines a type alias for CloseableScopeTypeId that represents the unique identifier type for CloseableScope. This type is used since version 2.0.0 of the Effect library for type-safe scope management.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Scope-CloseableScopeTypeId.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ntype CloseableScopeTypeId = typeof CloseableScopeTypeId\n```\n\n----------------------------------------\n\nTITLE: Lifting throwable function to Option in Effect.ts\nDESCRIPTION: This code snippet demonstrates the usage of `Option.liftThrowable` to transform a potentially throwing function (`JSON.parse`) into a safer function that returns an `Option`. If `JSON.parse` succeeds, the result is wrapped in `Some`; otherwise, `None` is returned.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Option-liftThrowable.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Option } from \"effect\"\n\nconst parse = Option.liftThrowable(JSON.parse)\n\nconsole.log(parse(\"1\"))\n// Output: { _id: 'Option', _tag: 'Some', value: 1 }\n\nconsole.log(parse(\"\"))\n// Output: { _id: 'Option', _tag: 'None' }\n```\n\n----------------------------------------\n\nTITLE: Implementing Property Signature Default Constructor in TypeScript\nDESCRIPTION: Defines a function that enhances a property signature by adding a default constructor value. The function supports both curried and non-curried forms, allowing flexible usage with property signatures of various types and encodings.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Schema-withConstructorDefault.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const withConstructorDefault: { <Type>(defaultValue: () => Types.NoInfer<Type>): <TypeToken extends PropertySignature.Token, Key extends PropertyKey, EncodedToken extends PropertySignature.Token, Encoded, R>(self: PropertySignature<TypeToken, Type, Key, EncodedToken, Encoded, boolean, R>) => PropertySignature<TypeToken, Type, Key, EncodedToken, Encoded, true, R>; <TypeToken extends PropertySignature.Token, Type, Key extends PropertyKey, EncodedToken extends PropertySignature.Token, Encoded, R>(self: PropertySignature<TypeToken, Type, Key, EncodedToken, Encoded, boolean, R>, defaultValue: () => Types.NoInfer<Type>): PropertySignature<TypeToken, Type, Key, EncodedToken, Encoded, true, R>; }\n```\n\n----------------------------------------\n\nTITLE: Using Cron.next Function in TypeScript\nDESCRIPTION: Demonstrates how to use the Cron.next function to get the next run date for a given Cron instance. It includes error handling and date parsing.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Cron-next.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { Cron, Either } from \"effect\"\n\nconst after = new Date(\"2021-01-01 00:00:00\")\nconst cron = Either.getOrThrow(Cron.parse(\"0 4 8-14 * *\"))\nassert.deepStrictEqual(Cron.next(cron, after), new Date(\"2021-01-08 04:00:00\"))\n```\n\n----------------------------------------\n\nTITLE: Array.liftPredicate TypeScript Type Signature\nDESCRIPTION: The type signature for the Array.liftPredicate function, showing its polymorphic nature and support for both regular predicates and type refinements.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Array-liftPredicate.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const liftPredicate: { <A, B extends A>(refinement: Predicate.Refinement<A, B>): (a: A) => Array<B>; <A>(predicate: Predicate.Predicate<A>): <B extends A>(b: B) => Array<B>; }\n```\n\n----------------------------------------\n\nTITLE: Rendering RuntimeFlagsPatch to String in TypeScript\nDESCRIPTION: Function that converts a RuntimeFlagsPatch object to its string representation. This is part of the effect package and has been available since version 2.0.0.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/RuntimeFlagsPatch-render.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const render: (self: RuntimeFlagsPatch) => string\n```\n\n----------------------------------------\n\nTITLE: Implementing Stack Trace Addition to Effect Failures in TypeScript\nDESCRIPTION: The `withTrace` function adds a stack trace to failures that occur in an effect. The trace is added to the `traces` field of the `MicroCause` object, providing better debugging information when errors occur. This function is available since version 3.4.0.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Micro-withTrace.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const withTrace: { (name: string): <A, E, R>(self: Micro<A, E, R>) => Micro<A, E, R>; <A, E, R>(self: Micro<A, E, R>, name: string): Micro<A, E, R>; }\n```\n\n----------------------------------------\n\nTITLE: TypeScript Function Signature for isEmptyReadonlyArray\nDESCRIPTION: Provides the TypeScript function signature for the isEmptyReadonlyArray function. It takes a ReadonlyArray<A> as input and returns a boolean with type narrowing.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Array-isEmptyReadonlyArray.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const isEmptyReadonlyArray: <A>(self: ReadonlyArray<A>) => self is readonly []\n```\n\n----------------------------------------\n\nTITLE: Defining Schema.Redacted Transformation in TypeScript\nDESCRIPTION: This code snippet defines the Redacted function in the Schema module. It takes a Schema of any type and transforms it into a RedactedFromSelf type. This function is available since version 3.10.0 of the package.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Schema-Redacted.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const Redacted: <Value extends Schema.Any>(value: Value) => Redacted<Value>\n```\n\n----------------------------------------\n\nTITLE: Implementing Layer Memoization in TypeScript\nDESCRIPTION: Function signature for memoizing layer computation results. Takes a Layer as input and returns a scoped Effect that lazily computes and caches the layer result. Requires a Scope for proper resource management.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Layer-memoize.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const memoize: <RIn, E, ROut>(self: Layer<ROut, E, RIn>) => Effect.Effect<Layer<ROut, E, RIn>, never, Scope.Scope>\n```\n\n----------------------------------------\n\nTITLE: Brand.refined Function Type Signature in TypeScript\nDESCRIPTION: Type signature for the Brand.refined function showing its polymorphic nature. It can accept either a predicate function returning an Option of brand errors, or a combination of refinement predicate and error handler function.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Brand-refined.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const refined: { <A extends Brand<any>>(f: (unbranded: Brand.Unbranded<A>) => Option.Option<Brand.BrandErrors>): Brand.Constructor<A>; <A extends Brand<any>>(refinement: Predicate<Brand.Unbranded<A>>, onFailure: (unbranded: Brand.Unbranded<A>) => Brand.BrandErrors): Brand.Constructor<A>; }\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Doc.align Usage in TypeScript\nDESCRIPTION: This code snippet compares the layout of documents with and without the align combinator. It shows how align affects the positioning of vsep'd documents relative to the current column.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Doc-align.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport * as Doc from \"@effect/printer/Doc\"\nimport * as String from \"effect/String\"\n\n// As an example, the documents below will be placed one above the other\n// regardless of the current nesting level\n\n// Without `align`ment, the second line is simply placed below everything\n// that has been laid out so far\nconst unaligned = Doc.hsep([\n  Doc.text(\"lorem\"),\n  Doc.vsep([Doc.text(\"ipsum\"), Doc.text(\"dolor\")])\n])\n\nassert.strictEqual(\n  Doc.render(unaligned, { style: \"pretty\" }),\n  String.stripMargin(\n    `|lorem ipsum\n     |dolor`\n  )\n)\n\n// With `align`ment, the `vsep`ed documents all start at the same column\nconst aligned = Doc.hsep([\n  Doc.text(\"lorem\"),\n  Doc.align(Doc.vsep([Doc.text(\"ipsum\"), Doc.text(\"dolor\")]))\n])\n\nassert.strictEqual(\n  Doc.render(aligned, { style: \"pretty\" }),\n  String.stripMargin(\n    `|lorem ipsum\n     |      dolor`\n  )\n)\n```\n\n----------------------------------------\n\nTITLE: Creating Time Zone Layer from IANA Identifier in TypeScript\nDESCRIPTION: Function signature for creating a Layer from an IANA time zone identifier. Returns a Layer that provides CurrentTimeZone functionality and may throw IllegalArgumentException if the zone identifier is invalid.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/DateTime-layerCurrentZoneNamed.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const layerCurrentZoneNamed: (zoneId: string) => Layer.Layer<CurrentTimeZone, IllegalArgumentException>\n```\n\n----------------------------------------\n\nTITLE: Defining SingletonAddress Class in TypeScript\nDESCRIPTION: Declares the SingletonAddress class which represents a unique identifier for singletons within a cluster. This class is part of the @effect/cluster package and is used for singleton instance addressing.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/SingletonAddress-SingletonAddress.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare class SingletonAddress\n```\n\n----------------------------------------\n\nTITLE: Transforming Config Values with Exception Handling in TypeScript\nDESCRIPTION: TypeScript function signature for mapAttempt, which takes a config of type A and a transformation function from A to B that may throw exceptions. The exceptions are converted into validation errors. The function can be used in both curried and uncurried forms.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Config-mapAttempt.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const mapAttempt: { <A, B>(f: (a: A) => B): (self: Config<A>) => Config<B>; <A, B>(self: Config<A>, f: (a: A) => B): Config<B>; }\n```\n\n----------------------------------------\n\nTITLE: Creating MutableHashSet from Chunk in TypeScript using Effect\nDESCRIPTION: Shows how to create a MutableHashSet from Effect's Chunk data structure. This example demonstrates that various Effect data structures are compatible with MutableHashSet.fromIterable as they implement the Iterable interface.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/MutableHashSet-fromIterable.md#2025-04-11_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Chunk, MutableHashSet, pipe } from \"effect\"\n\nconsole.log(\n  pipe(\n    Chunk.make(1, 2, 3, 4), //  Chunk is also an Iterable<T>\n    MutableHashSet.fromIterable,\n    Array.from\n  )\n) // Outputs: [1, 2, 3, 4]\n```\n\n----------------------------------------\n\nTITLE: Retrieving Console Service from Context in Effect Module\nDESCRIPTION: The console function retrieves the Console service from the context. It returns an Effect that requires the Console service with no error or value output. This allows accessing console capabilities in Effect applications.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-console.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const console: Effect<Console, never, never>\n```\n\n----------------------------------------\n\nTITLE: Function Signature for Array.replaceOption in TypeScript\nDESCRIPTION: Provides the TypeScript signature for the Array.replaceOption function. It shows the function's overloads and generic type parameters, indicating its flexibility in handling different array types.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Array-replaceOption.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const replaceOption: { <B>(i: number, b: B): <A, S extends Iterable<A> = Iterable<A>>(self: S) => Option.Option<ReadonlyArray.With<S, ReadonlyArray.Infer<S> | B>>; <A, B, S extends Iterable<A> = Iterable<A>>(self: S, i: number, b: B): Option.Option<ReadonlyArray.With<S, ReadonlyArray.Infer<S> | B>>; }\n```\n\n----------------------------------------\n\nTITLE: flatMapNullable Signature (Effect, Typescript)\nDESCRIPTION: This is the type signature for `flatMapNullable` function within the `Option` module. It shows how the function takes an `Option<A>` and a function `f` that transforms `A` into `B | null | undefined`, returning an `Option<NonNullable<B>>`.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Option-flatMapNullable.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\ndeclare const flatMapNullable: { <A, B>(f: (a: A) => B | null | undefined): (self: Option<A>) => Option<NonNullable<B>>; <A, B>(self: Option<A>, f: (a: A) => B | null | undefined): Option<NonNullable<B>>; }\n```\n```\n\n----------------------------------------\n\nTITLE: Importing and Using DeepMutable in TypeScript\nDESCRIPTION: This snippet demonstrates how to import and utilize the DeepMutable type from the Effect library. It shows an example where a deeply nested readonly structure is transformed into a mutable structure. There are no external dependencies aside from the Effect library. Inputs are TypeScript types, and the output is a transformed type with all properties mutable.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Types-DeepMutable.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport type { Types } from \"effect\"\n\ntype DeepMutableStruct = Types.DeepMutable<{\n  readonly a: string;\n  readonly b: readonly string[]\n}>\n// { a: string; b: string[] }\n```\n\n----------------------------------------\n\nTITLE: Creating Runner and Sharding Clients Layer in Effect/Cluster\nDESCRIPTION: A Layer that provides both Runners and Sharding clients for Effect cluster implementation. It requires ShardStorage, MessageStorage, ShardingConfig, Runners.RpcClientProtocol, and RpcServer.Protocol as dependencies.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/RunnerServer-layerWithClients.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const layerWithClients: Layer.Layer<Sharding.Sharding | Runners.Runners, never, ShardStorage.ShardStorage | MessageStorage.MessageStorage | ShardingConfig | Runners.RpcClientProtocol | RpcServer.Protocol>\n```\n\n----------------------------------------\n\nTITLE: Effect.ignore Type Signature\nDESCRIPTION: Type signature for the Effect.ignore function, showing it takes an Effect<A, E, R> and returns an Effect<void, never, R>.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-ignore.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const ignore: <A, E, R>(self: Effect<A, E, R>) => Effect<void, never, R>\n```\n\n----------------------------------------\n\nTITLE: Polling Elements from a Transactional Queue in TypeScript\nDESCRIPTION: The `poll` function takes a single element from a transactional queue, returning `None` if the queue is empty. It operates in the STM (Software Transactional Memory) context.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TQueue-poll.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const poll: <A>(self: TDequeue<A>) => STM.STM<Option.Option<A>>\n```\n\n----------------------------------------\n\nTITLE: Combining Ordering Values Using Monoid in TypeScript\nDESCRIPTION: This code snippet demonstrates how to use the Monoid instance for Ordering to combine values. It shows the expected outputs when combining the empty value with different Ordering values.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/data-Ordering-Monoid.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { Monoid } from \"@effect/typeclass/data/Ordering\"\n\nconsole.log(Monoid.combine(Monoid.empty, -1))\n// -1\nconsole.log(Monoid.combine(Monoid.empty, 1))\n// 1\nconsole.log(Monoid.combine(1, -1))\n// 1\n```\n\n----------------------------------------\n\nTITLE: Creating a Runner Instance with address and version in TypeScript\nDESCRIPTION: The Runner.make function creates a Runner object that represents a physical application server. It requires an address property for communication with the server and a version number used during rebalancing to prioritize newer servers and decommission older ones.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Runner-make.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const make: (props: { readonly address: RunnerAddress; readonly version: number; }) => Runner\n```\n\n----------------------------------------\n\nTITLE: MonoidMultiply Type Declaration\nDESCRIPTION: This snippet declares the MonoidMultiply constant as a monoid for numbers, indicating the type it represents. It's essential for ensuring type safety within the TypeScript application utilizing this monoid.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/data-Number-MonoidMultiply.md#2025-04-11_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const MonoidMultiply: monoid.Monoid<number>\n```\n\n----------------------------------------\n\nTITLE: Declare Type Class for Parse Issues in TypeScript\nDESCRIPTION: The Type class is part of the ParseResult module and represents a type error occurring when a value does not match the expected type. The class constructor takes three parameters: 'ast' which is the expected type, 'actual' which is the value that caused the error, and an optional 'message' for error description. This class is used in the TypeScript language and requires the AST module as a dependency to specify expected types.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/ParseResult-Type.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare class Type { constructor(\n    readonly ast: AST.AST,\n    readonly actual: unknown,\n    readonly message?: string\n  ) }\n```\n\n----------------------------------------\n\nTITLE: Type Declaration for getSemigroupIntersection in TypeScript\nDESCRIPTION: This snippet provides the type declaration for the `getSemigroupIntersection` function, specifying that it accepts a Semigroup for type `A` and returns a Semigroup for records with keys of type string and values of type A.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/data-Record-getSemigroupIntersection.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const getSemigroupIntersection: <A>(value: semigroup.Semigroup<A>) => semigroup.Semigroup<Record.ReadonlyRecord<string, A>>\n```\n\n----------------------------------------\n\nTITLE: Defining Covariant Type\nDESCRIPTION: This snippet defines a Covariant type in TypeScript, which is a higher-order type that takes a type parameter A and produces a function type that accepts a 'never' type and returns A. The purpose is to support type manipulations in functional programming.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Types-Covariant.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ntype Covariant<A> = (_: never) => A\n```\n\n----------------------------------------\n\nTITLE: TypeScript Signature for tapErrorCause Function\nDESCRIPTION: The type signature for the tapErrorCause function, showing its polymorphic implementation with support for both curried and uncurried calling styles. It preserves the original effect's type while potentially adding error types from the handler function.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-tapErrorCause.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const tapErrorCause: { <E, X, E2, R2>(f: (cause: Cause.Cause<NoInfer<E>>) => Effect<X, E2, R2>): <A, R>(self: Effect<A, E, R>) => Effect<A, E | E2, R2 | R>; <A, E, R, X, E2, R2>(self: Effect<A, E, R>, f: (cause: Cause.Cause<E>) => Effect<X, E2, R2>): Effect<A, E | E2, R | R2>; }\n```\n\n----------------------------------------\n\nTITLE: Reducing an Array with Early Termination in TypeScript\nDESCRIPTION: This example demonstrates how to use Effect.reduceWhile to process orders sequentially, stopping when the accumulated total exceeds 500. It showcases the function's ability to reduce a collection with a condition for early termination.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-reduceWhile.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Console, Effect } from \"effect\"\n\nconst processOrder = (id: number) =>\n  Effect.succeed({ id, price: 100 * id })\n    .pipe(Effect.tap(() => Console.log(`Order ${id} processed`)), Effect.delay(500 - (id * 100)))\n\nconst program = Effect.reduceWhile(\n  [1, 2, 3, 4],\n  0,\n  {\n    body: (acc, id, i) =>\n      processOrder(id)\n        .pipe(Effect.map((order) => acc + order.price)),\n    while: (acc) => acc < 500\n  }\n)\n\nEffect.runPromise(program).then(console.log)\n// Output:\n// Order 1 processed\n// Order 2 processed\n// Order 3 processed\n// 600\n```\n\n----------------------------------------\n\nTITLE: Typescript Option.ap Function Signature\nDESCRIPTION: A higher-order function that applies a function wrapped in an Option to another Option, enabling safe functional composition with optional values. Returns a new Option containing the result or None if either input is None.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Option-ap.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const ap: { <A>(that: Option<A>): <B>(self: Option<(a: A) => B>) => Option<B>; <A, B>(self: Option<(a: A) => B>, that: Option<A>): Option<B>; }\n```\n\n----------------------------------------\n\nTITLE: Signature of Stream.groupBy Function\nDESCRIPTION: This is the TypeScript signature for the Stream.groupBy function. It supports grouping of stream elements by applying a function that maps elements to an Effect resulting in a tuple of key and value. It also takes options for buffer size. The return type is a GroupBy object which can be evaluated to process grouped streams. Proper understanding of Effects and Streams in Effect-TS library is required to utilize this function.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-groupBy.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const groupBy: { <A, K, V, E2, R2>(f: (a: A) => Effect.Effect<readonly [K, V], E2, R2>, options?: { readonly bufferSize?: number | undefined; } | undefined): <E, R>(self: Stream<A, E, R>) => GroupBy.GroupBy<K, V, E2 | E, R2 | R>; <A, E, R, K, V, E2, R2>(self: Stream<A, E, R>, f: (a: A) => Effect.Effect<readonly [K, V], E2, R2>, options?: { readonly bufferSize?: number | undefined; } | undefined): GroupBy.GroupBy<K, V, E | E2, R | R2>; }\n\n```\n\n----------------------------------------\n\nTITLE: Declaring DateTimeZonedFromSelf Schema Class in TypeScript\nDESCRIPTION: Defines the DateTimeZonedFromSelf class that describes a schema representing a DateTime.Zoned instance. This class is part of the Schema module in the Effect package.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Schema-DateTimeZonedFromSelf.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare class DateTimeZonedFromSelf\n```\n\n----------------------------------------\n\nTITLE: Creating Literal Config in TypeScript using Effect Library\nDESCRIPTION: This snippet demonstrates how to use the Config.literal function to create a configuration for literal values. It constructs a config that accepts either 'http' or 'https' as valid values for a 'PROTOCOL' configuration.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Config-literal.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Config } from \"effect\"\n\nconst config = Config.literal(\"http\", \"https\")(\"PROTOCOL\")\n```\n\n----------------------------------------\n\nTITLE: Defining ConfigProvider.Flat Interface in TypeScript\nDESCRIPTION: Interface definition for a simplified config provider that handles flat key/value properties. It includes methods for loading configurations and enumerating children paths, with support for path patching.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/ConfigProvider-ConfigProvider.Flat.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface Flat {\n    readonly [FlatConfigProviderTypeId]: FlatConfigProviderTypeId\n    readonly patch: PathPatch.PathPatch\n    load<A>(\n      path: ReadonlyArray<string>,\n      config: Config.Config.Primitive<A>,\n      split?: boolean\n    ): Effect.Effect<Array<A>, ConfigError.ConfigError>\n    enumerateChildren(\n      path: ReadonlyArray<string>\n    ): Effect.Effect<HashSet.HashSet<string>, ConfigError.ConfigError>\n  }\n```\n\n----------------------------------------\n\nTITLE: HashSet.toValues Function Signature in TypeScript\nDESCRIPTION: The type signature of the HashSet.toValues function. It takes a HashSet of type A and returns an Array of type A. This function has O(n) time complexity where n is the number of elements in the set.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/HashSet-toValues.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const toValues: <A>(self: HashSet<A>) => Array<A>\n```\n\n----------------------------------------\n\nTITLE: Importing Stream and Effect Modules\nDESCRIPTION: Demonstrates importing the necessary modules from the effect library for stream operations\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-drain.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Effect, Stream } from \"effect\"\n```\n\n----------------------------------------\n\nTITLE: Declaring DateTimeUpdate Constant in TypeScript\nDESCRIPTION: Declaration of the DateTimeUpdate constant, which represents a date-time field that automatically updates to the current UTC time on database inserts and updates. It is serialized as a string for database storage.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Model-DateTimeUpdate.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const DateTimeUpdate: DateTimeUpdate\n```\n\n----------------------------------------\n\nTITLE: Initializing Choice Options in TypeScript with Effect CLI\nDESCRIPTION: Creates a command-line option that restricts input to a predefined set of string values. Allows selection between specific choices with automatic type inference and validation.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Options-choice.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as Options from \"@effect/cli/Options\"\n\nexport const animal: Options.Options<\"dog\" | \"cat\"> = Options.choice(\n  \"animal\",\n  [\"dog\", \"cat\"]\n)\n```\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const choice: <A extends string, C extends ReadonlyArray<A>>(name: string, choices: C) => Options<C[number]>\n```\n\n----------------------------------------\n\nTITLE: Defining the Empty Cause in Effect-TS\nDESCRIPTION: Declaration of the 'empty' constant which represents a Cause that signifies no error. This constant is used to represent an absence of failure conditions in Effect-TS applications.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Cause-empty.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const empty: Cause<never>\n```\n\n----------------------------------------\n\nTITLE: Defining DateTimeUtcFromNumber Schema Class in TypeScript\nDESCRIPTION: Declares a class named DateTimeUtcFromNumber that defines a schema for converting number values to DateTime.Utc instances using the DateTime.unsafeMake constructor.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Schema-DateTimeUtcFromNumber.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare class DateTimeUtcFromNumber\n```\n\n----------------------------------------\n\nTITLE: Stream Broadcast TypeScript Type Signature\nDESCRIPTION: Detailed type definition for the Stream.broadcast method with multiple configuration options for stream replication and backpressure handling\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-broadcast.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const broadcast: { <N extends number>(n: N, maximumLag: number | { readonly capacity: \"unbounded\"; readonly replay?: number | undefined; } | { readonly capacity: number; readonly strategy?: \"sliding\" | \"dropping\" | \"suspend\" | undefined; readonly replay?: number | undefined; }): <A, E, R>(self: Stream<A, E, R>) => Effect.Effect<TupleOf<N, Stream<A, E>>, never, Scope.Scope | R>; <A, E, R, N extends number>(self: Stream<A, E, R>, n: N, maximumLag: number | { readonly capacity: \"unbounded\"; readonly replay?: number | undefined; } | { readonly capacity: number; readonly strategy?: \"sliding\" | \"dropping\" | \"suspend\" | undefined; readonly replay?: number | undefined; }): Effect.Effect<TupleOf<N, Stream<A, E>>, never, Scope.Scope | R>; }\n```\n\n----------------------------------------\n\nTITLE: Signature Definition for Less Than or Equal Function\nDESCRIPTION: This snippet declares the TypeScript type definition for the 'lessThanOrEqualTo' function, supporting both curried and uncurried usage patterns. It returns a boolean indicating whether one number is less than or equal to another. This function is part of the 'effect' package.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Number-lessThanOrEqualTo.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const lessThanOrEqualTo: { (that: number): (self: number) => boolean; (self: number, that: number): boolean; }\n```\n\n----------------------------------------\n\nTITLE: Defining RefinementError Interface in TypeScript\nDESCRIPTION: Interface definition for errors that occur when a branded type fails its refinement predicate validation. Contains a meta field for additional error data and a message string describing the error.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Brand-Brand.RefinementError.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface RefinementError {\n    readonly meta: unknown\n    readonly message: string\n  }\n```\n\n----------------------------------------\n\nTITLE: RcRef.make Function Signature in TypeScript\nDESCRIPTION: The type signature for the RcRef.make function. It takes options including an acquire effect and an optional idle time to live. It returns an Effect that produces an RcRef.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/RcRef-make.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const make: <A, E, R>(options: { readonly acquire: Effect.Effect<A, E, R>; readonly idleTimeToLive?: Duration.DurationInput | undefined; }) => Effect.Effect<RcRef<A, E>, never, R | Scope.Scope>\n```\n\n----------------------------------------\n\nTITLE: Function Signature for constNull in TypeScript\nDESCRIPTION: The type signature for the constNull function, showing it's a LazyArg that returns null. This indicates it's a function that takes no arguments and returns null.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Function-constNull.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const constNull: LazyArg<null>\n```\n\n----------------------------------------\n\nTITLE: Converting DocStream to DocTree Type Definition\nDESCRIPTION: TypeScript type definition for the treeForm function that transforms a DocStream<A> into a DocTree<A>. This is a core utility function in the printer package for document tree manipulation.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/DocTree-treeForm.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const treeForm: <A>(stream: DocStream.DocStream<A>) => DocTree<A>\n```\n\n----------------------------------------\n\nTITLE: Type Guard for Continue Decision in TypeScript\nDESCRIPTION: A type guard function that checks if a given ChildExecutorDecision is specifically a Continue decision. Returns true if the decision is Continue, false otherwise.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/ChildExecutorDecision-isContinue.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const isContinue: (self: ChildExecutorDecision) => self is Continue\n```\n\n----------------------------------------\n\nTITLE: Type Guard for SourceUnavailable in ConfigError Module\nDESCRIPTION: This function checks if a ConfigError instance is specifically of type SourceUnavailable. It returns true if the error is a SourceUnavailable error, false otherwise. The function uses a type predicate to narrow the type in TypeScript.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/ConfigError-isSourceUnavailable.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const isSourceUnavailable: (self: ConfigError) => self is SourceUnavailable\n```\n\n----------------------------------------\n\nTITLE: Implementing Default imap Function for Covariant Typeclass in TypeScript\nDESCRIPTION: This code snippet defines the `imap` function for the Covariant typeclass. It takes a `map` function as an argument and returns an implementation of the Invariant's `imap` method. The function uses higher-kinded types and is part of the Effect ecosystem's typeclass system.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Covariant-imap.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const imap: <F extends TypeLambda>(map: <R, O, E, A, B>(self: Kind<F, R, O, E, A>, f: (a: A) => B) => Kind<F, R, O, E, B>) => Invariant<F>[\"imap\"]\n```\n\n----------------------------------------\n\nTITLE: Defining FailedStream Interface in TypeScript\nDESCRIPTION: Defines a TypeScript interface for FailedStream that extends DocStream.Variance<A>. This interface represents a document that failed during layout processing, containing a discriminator tag property.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/DocStream-FailedStream.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface FailedStream<A> extends DocStream.Variance<A> {\n  readonly _tag: \"FailedStream\"\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Cause.andThen Function in TypeScript\nDESCRIPTION: Defines a function for sequencing two Causes where the second Cause can depend on the result of the first. The function provides multiple overloads for handling different input combinations of Cause types and transformation functions.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Cause-andThen.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const andThen: { \n  <E, E2>(f: (e: E) => Cause<E2>): (self: Cause<E>) => Cause<E2>; \n  <E2>(f: Cause<E2>): <E>(self: Cause<E>) => Cause<E2>; \n  <E, E2>(self: Cause<E>, f: (e: E) => Cause<E2>): Cause<E2>; \n  <E, E2>(self: Cause<E>, f: Cause<E2>): Cause<E2>; \n}\n```\n\n----------------------------------------\n\nTITLE: Declaring InvalidPubSubCapacityExceptionTypeId Symbol in TypeScript\nDESCRIPTION: Declares a constant unique symbol 'InvalidPubSubCapacityExceptionTypeId' to identify the InvalidPubSubCapacityException type. This symbol is used in the context of PubSub structures to indicate errors related to invalid capacity.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Cause-InvalidPubSubCapacityExceptionTypeId.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const InvalidPubSubCapacityExceptionTypeId: unique symbol\n```\n\n----------------------------------------\n\nTITLE: getLeft Signature Declaration in TypeScript\nDESCRIPTION: This snippet provides the signature declaration for the getLeft function, which specifies its type parameters and return type. It takes an Either type as an argument and returns an Option of the left type, ensuring type safety in TypeScript.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Option-getLeft.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const getLeft: <R, L>(self: Either<R, L>) => Option<L>\n```\n\n----------------------------------------\n\nTITLE: Signature of catWithLineBreak Function in TypeScript\nDESCRIPTION: This code snippet shows the TypeScript signature of the catWithLineBreak function, which is an overloaded function that can be used in two ways to concatenate documents with a line break.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Doc-catWithLineBreak.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const catWithLineBreak: { <B>(that: Doc<B>): <A>(self: Doc<A>) => Doc<B | A>; <A, B>(self: Doc<A>, that: Doc<B>): Doc<A | B>; }\n```\n\n----------------------------------------\n\nTITLE: Implementing Pipe-able String Match Function in TypeScript\nDESCRIPTION: Defines a curried function that wraps the native string match operation, returning an Option type containing RegExpMatchArray. The function accepts either a RegExp or string pattern and returns a function that takes a string to match against.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/String-match.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const match: (regexp: RegExp | string) => (self: string) => Option.Option<RegExpMatchArray>\n```\n\n----------------------------------------\n\nTITLE: Implementing getMonoid for Applicative in TypeScript\nDESCRIPTION: This function lifts a Monoid into a higher-kinded type F, combining inner values using the provided Monoid. It uses semiApplicative.getSemigroup for combine and F.of(M.empty) for empty.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Applicative-getMonoid.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const getMonoid: <F extends TypeLambda>(F: Applicative<F>) => <A, R, O, E>(M: Monoid<A>) => Monoid<Kind<F, R, O, E, A>>\n```\n\n----------------------------------------\n\nTITLE: Creating Histogram Metric Key in TypeScript Effect Package\nDESCRIPTION: Function signature for creating a histogram metric key with specified name and boundaries. The function accepts a name string, MetricBoundaries object, and an optional description parameter to create a histogram metric key.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/MetricKey-histogram.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const histogram: (name: string, boundaries: MetricBoundaries.MetricBoundaries, description?: string) => MetricKey.Histogram\n```\n\n----------------------------------------\n\nTITLE: Defining NonEmptyString SafeRefinement in TypeScript\nDESCRIPTION: Declares a type refinement for ensuring strings are non-empty. This utility provides type-safe validation that a string contains at least one character.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Match-nonEmptyString.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const nonEmptyString: SafeRefinement<string, never>\n```\n\n----------------------------------------\n\nTITLE: Defining WellKnownServiceTier Type in TypeScript\nDESCRIPTION: This snippet defines a TypeScript type named 'WellKnownServiceTier' which can take on predefined string values representing known service tiers for OpenAI API requests. The predefined values are 'auto' and 'default', while users can also supply custom values as needed. This type helps ensure that the requests made to OpenAI API are using valid service tiers.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/OpenAiTelemetry-OpenAiTelemetry.WellKnownServiceTier.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ntype WellKnownServiceTier = \"auto\" | \"default\"\n```\n\n----------------------------------------\n\nTITLE: Defining Boolean Monoid XOR in TypeScript\nDESCRIPTION: Creates a monoid for boolean values using exclusive OR (XOR) operation with false as the empty value. Useful for boolean algebra and functional programming patterns.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/data-Boolean-MonoidXor.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const MonoidXor: monoid.Monoid<boolean>\n```\n\n----------------------------------------\n\nTITLE: Checking if a Cause is a Parallel Type in Effect\nDESCRIPTION: This function determines whether a Cause is of the Parallel type. It's used to identify causes that were combined in parallel using the 'parallel' combinator. The function returns a type predicate that can be used for type narrowing.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Cause-isParallelType.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const isParallelType: <E>(self: Cause<E>) => self is Parallel<E>\n```\n\n----------------------------------------\n\nTITLE: Accessing Elements by Index in RedBlackTree - TypeScript\nDESCRIPTION: Function signature for retrieving elements at a specific index from a RedBlackTree data structure. Returns an Option containing a key-value tuple if the index exists, or None if it doesn't. Supports both curried and uncurried calling styles.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/RedBlackTree-getAt.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const getAt: { \n  (index: number): <K, V>(self: RedBlackTree<K, V>) => Option<[K, V]>; \n  <K, V>(self: RedBlackTree<K, V>, index: number): Option<[K, V]>; \n}\n```\n\n----------------------------------------\n\nTITLE: Defining GenAI Request Telemetry Interface in TypeScript\nDESCRIPTION: Interface definition specifying the telemetry attributes for GenAI requests, including model name, temperature, sampling parameters, token limits, and other generation control settings. Each attribute is optional and can be null or undefined.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/AiTelemetry-GenAI.RequestAttributes.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface RequestAttributes {\n    /**\n     * The name of the GenAI model a request is being made to.\n     */\n    readonly model?: string | null | undefined\n    /**\n     * The temperature setting for the GenAI request.\n     */\n    readonly temperature?: number | null | undefined\n    /**\n     * The temperature setting for the GenAI request.\n     */\n    readonly topK?: number | null | undefined\n    /**\n     * The top_k sampling setting for the GenAI request.\n     */\n    readonly topP?: number | null | undefined\n    /**\n     * The top_p sampling setting for the GenAI request.\n     */\n    readonly maxTokens?: number | null | undefined\n    /**\n     * The encoding formats requested in an embeddings operation, if specified.\n     */\n    readonly encodingFormats?: ReadonlyArray<string> | null | undefined\n    /**\n     * List of sequences that the model will use to stop generating further\n     * tokens.\n     */\n    readonly stopSequences?: ReadonlyArray<string> | null | undefined\n    /**\n     * The frequency penalty setting for the GenAI request.\n     */\n    readonly frequencyPenalty?: number | null | undefined\n    /**\n     * The presence penalty setting for the GenAI request.\n     */\n    readonly presencePenalty?: number | null | undefined\n    /**\n     * The seed setting for the GenAI request. Requests with same seed value\n     * are more likely to return same result.\n     */\n    readonly seed?: number | null | undefined\n  }\n```\n\n----------------------------------------\n\nTITLE: Patching RuntimeFlags with RuntimeFlagsPatch in TypeScript\nDESCRIPTION: This function patches a set of RuntimeFlags with a RuntimeFlagsPatch, returning the modified set of RuntimeFlags. It supports both curried and uncurried calling styles.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/RuntimeFlags-patch.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const patch: { (patch: RuntimeFlagsPatch.RuntimeFlagsPatch): (self: RuntimeFlags) => RuntimeFlags; (self: RuntimeFlags, patch: RuntimeFlagsPatch.RuntimeFlagsPatch): RuntimeFlags; }\n```\n\n----------------------------------------\n\nTITLE: Getting MutableQueue Length - Effect TS\nDESCRIPTION: This TypeScript code declares a `length` function that takes a `MutableQueue` of type `A` as input and returns a number representing the current number of elements in the queue. The function signature specifies that it accepts a mutable queue instance and returns its size.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/MutableQueue-length.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const length: <A>(self: MutableQueue<A>) => number\n```\n\n----------------------------------------\n\nTITLE: Configuring Command stdout in TypeScript\nDESCRIPTION: This function allows specifying the standard output stream for a command. It can be used either as a method that takes a Command and returns a new Command, or as a function that takes an output specification and returns a function that configures a Command.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Command-stdout.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const stdout: { (stdout: Command.Output): (self: Command) => Command; (self: Command, stdout: Command.Output): Command; }\n```\n\n----------------------------------------\n\nTITLE: Defining PageWidth type in Typescript\nDESCRIPTION: This code snippet defines the `PageWidth` type, which can either be `AvailablePerLine` or `Unbounded`. It represents the maximum width available for a line in a printable document. The layout algorithms use this value to insert line breaks appropriately, aiming to keep lines within the specified width.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/PageWidth-PageWidth.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\ntype PageWidth = AvailablePerLine | Unbounded\n```\n```\n\n----------------------------------------\n\nTITLE: Checking Key Existence in HashMap in TypeScript\nDESCRIPTION: The `has` function checks whether a specified key exists in a HashMap. It returns a boolean indicating whether the key has an entry in the data structure.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/HashMap-has.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const has: { <K1>(key: K1): <K, V>(self: HashMap<K, V>) => boolean; <K, V, K1>(self: HashMap<K, V>, key: K1): boolean; }\n```\n\n----------------------------------------\n\nTITLE: Disabling RuntimeFlags in Effect\nDESCRIPTION: The disableAll function allows turning off all RuntimeFlags in a specified set. It can be used with data-first or data-last invocation styles, taking a source RuntimeFlags object and the flags to disable.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/RuntimeFlags-disableAll.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const disableAll: { (flags: RuntimeFlags): (self: RuntimeFlags) => RuntimeFlags; (self: RuntimeFlags, flags: RuntimeFlags): RuntimeFlags; }\n```\n\n----------------------------------------\n\nTITLE: Defining ScopeTypeId Type in TypeScript\nDESCRIPTION: Defines the type of unique identifier used for Scope objects. The type is defined as the typeof the ScopeTypeId constant.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Scope-ScopeTypeId.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ntype ScopeTypeId = typeof ScopeTypeId\n```\n\n----------------------------------------\n\nTITLE: FiberHandle.make Type Signature\nDESCRIPTION: Type signature for the FiberHandle.make function showing it creates a scoped Effect that produces a FiberHandle for managing fibers of type A with potential error type E.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/FiberHandle-make.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const make: <A = unknown, E = unknown>() => Effect.Effect<FiberHandle<A, E>, never, Scope.Scope>\n```\n\n----------------------------------------\n\nTITLE: Defining ChildExecutorDecision Close Interface in TypeScript\nDESCRIPTION: Interface definition for the Close variant of ChildExecutorDecision that handles closing a substream with a value and transitioning to the next substream. The interface extends ChildExecutorDecision.Proto and includes a discriminant _tag and a value property.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/ChildExecutorDecision-Close.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface Close extends ChildExecutorDecision.Proto {\n  readonly _tag: \"Close\"\n  readonly value: unknown\n}\n```\n\n----------------------------------------\n\nTITLE: Defining AsyncInputConsumer Interface in TypeScript\nDESCRIPTION: Defines an interface for consuming asynchronous input with error, element, and completion handling. The interface provides a takeWith method that accepts callbacks for handling errors, elements, and completion states.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/SingleProducerAsyncInput-AsyncInputConsumer.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface AsyncInputConsumer<out Err, out Elem, out Done> {\n  takeWith<A>(\n    onError: (cause: Cause.Cause<Err>) => A,\n    onElement: (element: Elem) => A,\n    onDone: (value: Done) => A\n  ): Effect.Effect<A>\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Synchronous Micro Effect Execution\nDESCRIPTION: A function that attempts to run a Micro effect synchronously, returning a MicroExit that captures the result or potential errors. If async effects are encountered, it returns a CauseDie with the MicroFiber.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Micro-runSyncExit.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const runSyncExit: <A, E>(effect: Micro<A, E>) => MicroExit<A, E>\n```\n\n----------------------------------------\n\nTITLE: Type Signature for Match.either in TypeScript\nDESCRIPTION: This code snippet shows the type signature for the Match.either function. It defines the function's input and output types, including generic type parameters for flexibility in usage across different matcher configurations.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Match-either.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const either: <I, F, R, A, Pr, Ret>(self: Matcher<I, F, R, A, Pr, Ret>) => [Pr] extends [never] ? (input: I) => Either.Either<Unify<A>, R> : Either.Either<Unify<A>, R>\n```\n\n----------------------------------------\n\nTITLE: Appending Annotations to TestAnnotationMap in TypeScript\nDESCRIPTION: The 'annotate' function is used to append a specified annotation to the TestAnnotationMap. It can be called in two ways: as a curried function or with all parameters at once. The function takes a TestAnnotation key, a value of type A, and the TestAnnotationMap itself, returning an updated TestAnnotationMap.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TestAnnotationMap-annotate.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const annotate: (<A>(key: TestAnnotation.TestAnnotation<A>, value: A) => (self: TestAnnotationMap) => TestAnnotationMap) & (<A>(self: TestAnnotationMap, key: TestAnnotation.TestAnnotation<A>, value: A) => TestAnnotationMap)\n```\n\n----------------------------------------\n\nTITLE: Checking Equality Between Cron Objects in TypeScript\nDESCRIPTION: This function checks if two Cron objects are equal. It provides two call signatures: one for curried usage and one for direct comparison with two arguments.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Cron-equals.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const equals: { (that: Cron): (self: Cron) => boolean; (self: Cron, that: Cron): boolean; }\n```\n\n----------------------------------------\n\nTITLE: Accessing Current Scope in Effect Workflows with TypeScript\nDESCRIPTION: This function provides access to the current scope in a scoped workflow. It returns an Effect that requires a Scope, has no error channel, and produces a Scope.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-scope.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const scope: Effect<Scope.Scope, never, Scope.Scope>\n```\n\n----------------------------------------\n\nTITLE: Testing Either Values in TypeScript\nDESCRIPTION: Demonstrates how to use the Either.isEither function to check if a value is an Either. It shows examples of checking both right and left Either values, as well as a non-Either object.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Either-isEither.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { Either } from \"effect\"\n\nassert.deepStrictEqual(Either.isEither(Either.right(1)), true)\nassert.deepStrictEqual(Either.isEither(Either.left(\"a\")), true)\nassert.deepStrictEqual(Either.isEither({ right: 1 }), false)\n```\n\n----------------------------------------\n\nTITLE: Declaring ANSI Terminal Line Erase Function in TypeScript\nDESCRIPTION: Defines a constant eraseStartLine of type AnsiDoc that clears text from the current cursor position to the start of the current line. The cursor position remains unchanged after the operation.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/AnsiDoc-eraseStartLine.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const eraseStartLine: AnsiDoc\n```\n\n----------------------------------------\n\nTITLE: Defining Command.stdin Function in TypeScript\nDESCRIPTION: Declaration of the stdin function that specifies the standard input stream for a command. It supports two calling patterns: curried style with stdin first, or a direct application with command and stdin parameters.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Command-stdin.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const stdin: { (stdin: Command.Input): (self: Command) => Command; (self: Command, stdin: Command.Input): Command; }\n```\n\n----------------------------------------\n\nTITLE: Mapping STM Success Value to Option Type in TypeScript\nDESCRIPTION: Defines the `asSome` function that maps the success value of an STM effect to an optional value by wrapping it in the Some variant of an Option type. This is useful for cases where you want to convert a standard effect result into an optional representation.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/STM-asSome.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const asSome: <A, E, R>(self: STM<A, E, R>) => STM<Option.Option<A>, E, R>\n```\n\n----------------------------------------\n\nTITLE: Implementing isActive Function for RuntimeFlagsPatch in TypeScript\nDESCRIPTION: This function determines whether a specified RuntimeFlag is marked as active within a RuntimeFlagsPatch. It provides two overloaded signatures - one takes the flag first and returns a function accepting the patch, and the other accepts both the patch and flag directly.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/RuntimeFlagsPatch-isActive.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const isActive: { (flag: RuntimeFlagsPatch): (self: RuntimeFlagsPatch) => boolean; (self: RuntimeFlagsPatch, flag: RuntimeFlagsPatch): boolean; }\n```\n\n----------------------------------------\n\nTITLE: Creating Iterable with makeBy Function - TypeScript Example\nDESCRIPTION: Demonstrates how to create an Iterable where each element is calculated using a function that multiplies the index by 2. Shows creation of a finite Iterable with 5 elements.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Iterable-makeBy.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { makeBy } from \"effect/Iterable\"\n\nassert.deepStrictEqual(Array.from(makeBy(n => n * 2, { length: 5 })), [0, 2, 4, 6, 8])\n```\n\n----------------------------------------\n\nTITLE: Defining recurWhile schedule in Effect TS\nDESCRIPTION: Defines a schedule that recurs as long as the given predicate `f` evaluates to `true`. The schedule stops recurring when `f` evaluates to `false`. This function is part of the `Schedule` module in the `effect` package.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Schedule-recurWhile.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const recurWhile: <A>(f: Predicate<A>) => Schedule<A, A>\n```\n\n----------------------------------------\n\nTITLE: Filtering and Mapping Trie Entries in TypeScript\nDESCRIPTION: Demonstrates how to use the Trie.filterMap function to map over entries of a Trie and filter out None values. It shows examples of filtering based on value and key length.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Trie-filterMap.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { Trie, Equal, Option } from \"effect\"\n\nconst trie = Trie.empty<number>().pipe(\n  Trie.insert(\"shells\", 0),\n  Trie.insert(\"sells\", 1),\n  Trie.insert(\"she\", 2)\n)\n\nconst trieMapV = Trie.empty<number>().pipe(\n  Trie.insert(\"she\", 2)\n)\n\nconst trieMapK = Trie.empty<number>().pipe(\n  Trie.insert(\"shells\", 0),\n  Trie.insert(\"sells\", 1)\n)\n\nassert.equal(Equal.equals(Trie.filterMap(trie, (v) => v > 1 ? Option.some(v) : Option.none()), trieMapV), true)\nassert.equal(\n  Equal.equals(Trie.filterMap(trie, (v, k) => k.length > 3 ? Option.some(v) : Option.none()), trieMapK),\n  true\n)\n```\n\n----------------------------------------\n\nTITLE: ExcludeTag Type Definition in Effect\nDESCRIPTION: This code snippet shows the type definition of `ExcludeTag` in TypeScript. It uses the `Exclude` utility type to remove any type from `E` that matches `{ _tag: K }`.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Types-ExcludeTag.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ntype ExcludeTag<E, K> = Exclude<E, { _tag: K }>\n```\n\n----------------------------------------\n\nTITLE: Trie.keys Function Signature in TypeScript\nDESCRIPTION: This code snippet shows the TypeScript signature for the Trie.keys function. It takes a Trie<V> as input and returns an IterableIterator of strings.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Trie-keys.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const keys: <V>(self: Trie<V>) => IterableIterator<string>\n```\n\n----------------------------------------\n\nTITLE: Using BigDecimal.isZero Function in TypeScript\nDESCRIPTION: Example demonstrating how to use the isZero function from the BigDecimal module to check if a BigDecimal value is equal to zero. The function returns true if the value is zero and false otherwise.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/BigDecimal-isZero.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { isZero, unsafeFromString } from \"effect/BigDecimal\"\n\nassert.deepStrictEqual(isZero(unsafeFromString(\"0\")), true)\nassert.deepStrictEqual(isZero(unsafeFromString(\"1\")), false)\n```\n\n----------------------------------------\n\nTITLE: Using unsafeRemainder with BigDecimal in TypeScript\nDESCRIPTION: Demonstrates how to calculate the remainder when dividing BigDecimal numbers. The function accepts two BigDecimal operands and returns the remainder after division. Throws RangeError if divisor is 0.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/BigDecimal-unsafeRemainder.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { unsafeRemainder, unsafeFromString } from \"effect/BigDecimal\"\n\nassert.deepStrictEqual(unsafeRemainder(unsafeFromString(\"2\"), unsafeFromString(\"2\")), unsafeFromString(\"0\"))\nassert.deepStrictEqual(unsafeRemainder(unsafeFromString(\"3\"), unsafeFromString(\"2\")), unsafeFromString(\"1\"))\nassert.deepStrictEqual(unsafeRemainder(unsafeFromString(\"-4\"), unsafeFromString(\"2\")), unsafeFromString(\"0\"))\n```\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const unsafeRemainder: { (divisor: BigDecimal): (self: BigDecimal) => BigDecimal; (self: BigDecimal, divisor: BigDecimal): BigDecimal; }\n```\n\n----------------------------------------\n\nTITLE: Constructing HashSet Config in TypeScript\nDESCRIPTION: The hashSet function creates a Config for a HashSet of values. It takes a Config<A> and an optional name parameter, returning a Config<HashSet.HashSet<A>>. This function is available since version 2.0.0 of the package.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Config-hashSet.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const hashSet: <A>(config: Config<A>, name?: string) => Config<HashSet.HashSet<A>>\n```\n\n----------------------------------------\n\nTITLE: Creating Text Arguments in Effect CLI using TypeScript\nDESCRIPTION: Function signature for creating a text argument with optional configuration. The function accepts an optional BaseArgsConfig parameter and returns an Args instance of type string. By default, the argument name is 'text' if not specified in the config.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Args-text.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const text: (config?: Args.BaseArgsConfig) => Args<string>\n```\n\n----------------------------------------\n\nTITLE: Merging Schema AST Annotations in TypeScript\nDESCRIPTION: Function that combines existing AST annotations with new overrides, handling duplicate cases by allowing overrides to take precedence. Used within the Effect framework for schema manipulation.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/SchemaAST-annotations.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const annotations: (ast: AST, overrides: Annotations) => AST\n```\n\n----------------------------------------\n\nTITLE: BigDecimal.multiply Type Signature\nDESCRIPTION: The TypeScript type signature for the multiply function, showing both curried and uncurried usage patterns. The function can be used either with two parameters or by passing the second parameter to the function returned from the first call.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/BigDecimal-multiply.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const multiply: { (that: BigDecimal): (self: BigDecimal) => BigDecimal; (self: BigDecimal, that: BigDecimal): BigDecimal; }\n```\n\n----------------------------------------\n\nTITLE: Effect.either Function Signature in TypeScript\nDESCRIPTION: The type signature for the Effect.either function, which takes an Effect that might produce a value of type A, fail with an error of type E, and requires an environment R. It returns an Effect that always succeeds with an Either.Either<A, E> and still requires environment R.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-either.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const either: <A, E, R>(self: Effect<A, E, R>) => Effect<Either.Either<A, E>, never, R>\n```\n\n----------------------------------------\n\nTITLE: Checking for Unsupported ConfigError in TypeScript\nDESCRIPTION: This function determines if a given ConfigError is of type Unsupported. It takes a ConfigError as input and returns a boolean, with true indicating the error is Unsupported. The function also serves as a type guard, narrowing the type to Unsupported if true.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/ConfigError-isUnsupported.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const isUnsupported: (self: ConfigError) => self is Unsupported\n```\n\n----------------------------------------\n\nTITLE: Checking if a Doc is a FlatAlt in TypeScript\nDESCRIPTION: The isFlatAlt function is a type predicate that determines whether a Doc object is specifically a FlatAlt variant. It returns true if the provided Doc is a FlatAlt, and false otherwise.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Doc-isFlatAlt.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const isFlatAlt: <A>(self: Doc<A>) => self is FlatAlt<A>\n```\n\n----------------------------------------\n\nTITLE: Combining Minimum Values with MonoidMin in TypeScript\nDESCRIPTION: This code snippet demonstrates the usage of the MonoidMin from the Effect-TS library, which combines two numbers by selecting the minimum value. It includes two examples showing the behavior when comparing two values and when one of the values is the Monoid's empty value. The Monoid's empty value is defined as -Infinity.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/data-Number-MonoidMin.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { MonoidMin } from \"@effect/typeclass/data/Number\"\n\nconsole.log(MonoidMin.combine(2, 3))\n// 2\nconsole.log(MonoidMin.combine(2, MonoidMin.empty))\n// 2\n```\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const MonoidMin: monoid.Monoid<number>\n```\n\n----------------------------------------\n\nTITLE: Effect.optionFromOptional Function Signature in TypeScript\nDESCRIPTION: The type signature for the optionFromOptional function, showing how it transforms an Effect<A, E, R> into an Effect<Option<A>, Exclude<E, NoSuchElementException>, R>.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-optionFromOptional.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const optionFromOptional: <A, E, R>(self: Effect<A, E, R>) => Effect<Option.Option<A>, Exclude<E, Cause.NoSuchElementException>, R>\n```\n\n----------------------------------------\n\nTITLE: lineBreak Type Definition in Effect Printer\nDESCRIPTION: Type signature for the lineBreak constant in the @effect/printer/Doc module. It defines lineBreak as a Doc that never produces an error.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Doc-lineBreak.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const lineBreak: Doc<never>\n```\n\n----------------------------------------\n\nTITLE: Declaring scoped function in Typescript\nDESCRIPTION: This code snippet declares the `scoped` function, which accepts a `Micro` effect and returns a new `Micro` effect. The `MicroScope` is provided to the effect and closed after execution. The type signature indicates that the `MicroScope` is excluded from the resulting effect's environment.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Micro-scoped.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const scoped: <A, E, R>(self: Micro<A, E, R>) => Micro<A, E, Exclude<R, MicroScope>>\n```\n\n----------------------------------------\n\nTITLE: Defining 'as' Function in Exit Module (TypeScript)\nDESCRIPTION: Declares the 'as' function which maps the Success value of an Exit to a provided constant value. It has two overloads: one for curried usage and another for direct application.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Exit-as.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const as: { <A2>(value: A2): <A, E>(self: Exit<A, E>) => Exit<A2, E>; <A, E, A2>(self: Exit<A, E>, value: A2): Exit<A2, E>; }\n```\n\n----------------------------------------\n\nTITLE: Implementing Document Concatenation with Doc.cat in TypeScript\nDESCRIPTION: Type definition for the cat combinator that takes two Doc objects and combines them into a single Doc without any separator. The function is overloaded to support both curried and non-curried calling styles.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Doc-cat.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const cat: { <B>(that: Doc<B>): <A>(self: Doc<A>) => Doc<B | A>; <A, B>(self: Doc<A>, that: Doc<B>): Doc<A | B>; }\n```\n\n----------------------------------------\n\nTITLE: Conceptual JavaScript While Loop Equivalent of Effect.iterate\nDESCRIPTION: A JavaScript while loop that conceptually demonstrates how the Effect.iterate function works. It starts with an initial state, checks a condition, and executes a body operation until the condition is no longer met.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-iterate.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nlet result = initial\n\nwhile (options.while(result)) {\n  result = options.body(result)\n}\n\nreturn result\n```\n\n----------------------------------------\n\nTITLE: MonoidMax Type Declaration in TypeScript\nDESCRIPTION: This snippet provides a type declaration for the MonoidMax constant, which represents a monoid for numbers. It is crucial for ensuring type safety and proper integration within TypeScript projects.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/data-Number-MonoidMax.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const MonoidMax: monoid.Monoid<number>\n```\n\n----------------------------------------\n\nTITLE: Typescript MergeRight Example\nDESCRIPTION: This example demonstrates how to use the `MergeRight` utility type to merge two object types. The type `MergeRight` is assigned the result of merging `{ a: number, b: number; }` with `{ a: string }`. The resulting type is `{ a: string; b: number; }` because the `a` property from the second type overrides the `a` property from the first type.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Types-MergeRight.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport type { Types } from \"effect\"\ntype MergeRight = Types.MergeRight<{ a: number, b: number; }, { a: string }> // { a: string; b: number; }\n```\n\n----------------------------------------\n\nTITLE: Monoid Type Signature for Ordering in TypeScript\nDESCRIPTION: This code snippet declares the type signature for the Monoid instance of Ordering, which is a required dependency for the previous examples to work.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/data-Ordering-Monoid.md#2025-04-11_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const Monoid: monoid.Monoid<Ordering>\n```\n\n----------------------------------------\n\nTITLE: Defining Cause.Cause.Variance Interface in TypeScript\nDESCRIPTION: This code snippet defines the Variance interface used internally to manage the type variance of Cause. It includes a readonly property CauseTypeId with a nested _E property of type Covariant<E>.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Cause-Cause.Variance.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface Variance<out E> {\n    readonly [CauseTypeId]: {\n      readonly _E: Covariant<E>\n    }\n  }\n```\n\n----------------------------------------\n\nTITLE: Function Signature for Array.dropWhile in TypeScript\nDESCRIPTION: The type signature for the dropWhile function, supporting both curried and non-curried calling styles. It takes a predicate function that tests each element and returns a new array containing only elements after the predicate stops returning true.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Array-dropWhile.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const dropWhile: { <A>(predicate: (a: NoInfer<A>, i: number) => boolean): (self: Iterable<A>) => Array<A>; <A>(self: Iterable<A>, predicate: (a: A, i: number) => boolean): Array<A>; }\n```\n\n----------------------------------------\n\nTITLE: Defining untilOutputEffect Function in TypeScript\nDESCRIPTION: Declares the untilOutputEffect function, which returns a new schedule that stops execution when a given effectful predicate on the output evaluates to true. It can be used with both curried and uncurried forms.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Schedule-untilOutputEffect.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const untilOutputEffect: { <Out, R2>(f: (out: Out) => Effect.Effect<boolean, never, R2>): <In, R>(self: Schedule<Out, In, R>) => Schedule<Out, In, R2 | R>; <Out, In, R, R2>(self: Schedule<Out, In, R>, f: (out: Out) => Effect.Effect<boolean, never, R2>): Schedule<Out, In, R | R2>; }\n```\n\n----------------------------------------\n\nTITLE: Defining SubscriptionRef Interface in TypeScript\nDESCRIPTION: This code snippet defines the `SubscriptionRef` interface in TypeScript, implementing several related interfaces and providing a structure for subscribing to and managing changes to a reference value. Dependencies include `Ref`, `PubSub`, and `Stream`, which facilitate management and dissemination of changes. The key properties include `ref`, `pubsub`, `semaphore`, and `changes`, which collectively support reference tracking, publication of changes, concurrency control, and access to a stream of updates, respectively.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/SubscriptionRef-SubscriptionRef.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface SubscriptionRef<in out A>\n  extends SubscriptionRef.Variance<A>, Synchronized.SynchronizedRef<A>, Subscribable<A>\n{\n  /** @internal */\n  readonly ref: Ref.Ref<A>\n  /** @internal */\n  readonly pubsub: PubSub.PubSub<A>\n  /** @internal */\n  readonly semaphore: Effect.Semaphore\n  /**\n   * A stream containing the current value of the `Ref` as well as all changes\n   * to that value.\n   */\n  readonly changes: Stream.Stream<A>\n  readonly [Unify.typeSymbol]?: unknown\n  readonly [Unify.unifySymbol]?: SubscriptionRefUnify<this>\n  readonly [Unify.ignoreSymbol]?: SubscriptionRefUnifyIgnore\n}\n```\n\n----------------------------------------\n\nTITLE: Declaring productMany Function in TypeScript\nDESCRIPTION: Defines the 'productMany' function signature within a SemiProduct type class. It uses generic TypeScript to enforce constraints and relationships between 'map', 'product', and 'productMany' functions. The implementation relies on Covariant and SemiProduct dependencies, intending to combine multiple function instances under the SemiProduct type.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/SemiProduct-productMany.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const productMany: <F extends TypeLambda>(map: Covariant<F>[\"map\"], product: SemiProduct<F>[\"product\"]) => SemiProduct<F>[\"productMany\"]\n```\n\n----------------------------------------\n\nTITLE: Defining ANSI Beep Sound in TypeScript for Effect-TS Printer\nDESCRIPTION: Declares a constant 'beep' of type Ansi, which represents the ANSI control sequence for playing a beeping sound in the terminal. This is part of the @effect/printer-ansi package in the Ansi module.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Ansi-beep.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const beep: Ansi\n```\n\n----------------------------------------\n\nTITLE: Defining ParseError Class in Effect.ts Cron Module\nDESCRIPTION: Declaration of the ParseError class which represents a checked exception that occurs when decoding cron expressions fails. This class is part of the Cron module in the effect package.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Cron-ParseError.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare class ParseError\n```\n\n----------------------------------------\n\nTITLE: Defining NoSuchElementException Interface in TypeScript\nDESCRIPTION: This code snippet defines the NoSuchElementException interface, which extends YieldableError. It includes a _tag property set to \"NoSuchElementException\" and a symbol property for the NoSuchElementExceptionTypeId. This interface is used to represent errors when an expected element is not found.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Cause-NoSuchElementException.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface NoSuchElementException extends YieldableError {\n  readonly _tag: \"NoSuchElementException\"\n  readonly [NoSuchElementExceptionTypeId]: NoSuchElementExceptionTypeId\n}\n```\n\n----------------------------------------\n\nTITLE: Type Checking for ChildExecutorDecision in TypeScript\nDESCRIPTION: This function checks if a given unknown value is a ChildExecutorDecision. It returns true if the value is a ChildExecutorDecision, false otherwise. Available since version 2.0.0.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/ChildExecutorDecision-isChildExecutorDecision.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const isChildExecutorDecision: (u: unknown) => u is ChildExecutorDecision\n```\n\n----------------------------------------\n\nTITLE: Initializing HashMap Mutation in TypeScript\nDESCRIPTION: Function signature for marking a HashMap as mutable. Takes a HashMap with generic key and value types and returns the same HashMap type, enabling mutable operations on the data structure.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/HashMap-beginMutation.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const beginMutation: <K, V>(self: HashMap<K, V>) => HashMap<K, V>\n```\n\n----------------------------------------\n\nTITLE: Defining TSubscriptionRef Interface in TypeScript\nDESCRIPTION: This code snippet defines the TSubscriptionRef interface, which allows subscribing to a TRef value and receiving updates through a TDequeue of current and committed changes. The interface extends both TSubscriptionRef.Variance and TRef, providing methods to modify the reference and access change events.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TSubscriptionRef-TSubscriptionRef.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface TSubscriptionRef<in out A> extends TSubscriptionRef.Variance<A>, TRef.TRef<A> {\n  /** @internal */\n  readonly ref: TRef.TRef<A>\n  /** @internal */\n  readonly pubsub: TPubSub.TPubSub<A>\n  /** @internal */\n  modify<B>(f: (a: A) => readonly [B, A]): STM.STM<B>\n\n  /**\n   * A TDequeue containing the current value of the `Ref` as well as all changes\n   * to that value.\n   */\n  readonly changes: STM.STM<TQueue.TDequeue<A>>\n}\n```\n\n----------------------------------------\n\nTITLE: Defining GeneratedByApp Field for SQL Schemas in TypeScript\nDESCRIPTION: A utility function that designates a schema field as one that is generated by the application rather than the database. These fields are required by the database but not by JSON variants, allowing for more flexible schema handling.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Model-GeneratedByApp.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const GeneratedByApp: <S extends Schema.Schema.All | Schema.PropertySignature.All>(schema: S) => GeneratedByApp<S>\n```\n\n----------------------------------------\n\nTITLE: Declaring TimeZoneNamedFromSelf Schema Class\nDESCRIPTION: Defines a schema class for representing named time zones in the Effect library, providing type-level validation and transformation for time zone data\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Schema-TimeZoneNamedFromSelf.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare class TimeZoneNamedFromSelf\n```\n\n----------------------------------------\n\nTITLE: Checking BigInt Range with between Function in TypeScript\nDESCRIPTION: Demonstrates how to use the BigInt.between function to check if a bigint value is within a specified range. The function returns a boolean indicating whether the value is between the minimum and maximum (inclusive).\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/BigInt-between.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { BigInt } from \"effect\"\n\nconst between = BigInt.between({ minimum: 0n, maximum: 5n })\n\nassert.deepStrictEqual(between(3n), true)\nassert.deepStrictEqual(between(-1n), false)\nassert.deepStrictEqual(between(6n), false)\n```\n\n----------------------------------------\n\nTITLE: Creating Linear Histogram Boundaries in TypeScript\nDESCRIPTION: Function that generates linear histogram bucket boundaries based on start value, width between buckets, and total count of buckets. Used for creating evenly spaced histogram bucket divisions.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/MetricBoundaries-linear.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const linear: (options: { readonly start: number; readonly width: number; readonly count: number; }) => MetricBoundaries\n```\n\n----------------------------------------\n\nTITLE: Implementing Layer.dieSync in TypeScript\nDESCRIPTION: Defines a function that constructs a layer which terminates with a specified defect. The function takes a lazy argument that evaluates to the defect value and returns a Layer of unknown type.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Layer-dieSync.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const dieSync: (evaluate: LazyArg<unknown>) => Layer<unknown>\n```\n\n----------------------------------------\n\nTITLE: Declaring Drop While Function in TypeScript\nDESCRIPTION: This snippet declares the 'dropWhile' function, which accepts a predicate and returns a Sink that drops elements as long as the predicate evaluates to true. The input type is generic, allowing flexibility in the element types processed by the Sink.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Sink-dropWhile.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const dropWhile: <In>(predicate: Predicate<In>) => Sink<unknown, In, In>\n```\n\n----------------------------------------\n\nTITLE: Defining GenAI UsageAttributes Interface in TypeScript\nDESCRIPTION: Defines an interface for telemetry attributes that are part of the GenAI specification. These attributes track the number of input and output tokens used in AI operations and are namespaced by 'gen_ai.usage'.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/AiTelemetry-GenAI.UsageAttributes.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface UsageAttributes {\n    readonly inputTokens?: number | null | undefined\n    readonly outputTokens?: number | null | undefined\n  }\n```\n\n----------------------------------------\n\nTITLE: Defining InterruptedExceptionTypeId Unique Symbol in TypeScript\nDESCRIPTION: Declaration of a unique symbol that identifies the InterruptedException type. This symbol is used internally to recognize when a fiber has been interrupted, helping the framework handle interruption logic correctly.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Cause-InterruptedExceptionTypeId.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const InterruptedExceptionTypeId: unique symbol\n```\n\n----------------------------------------\n\nTITLE: Defining unsafeHead Function for Iterable in TypeScript\nDESCRIPTION: This code snippet defines the unsafeHead function, which retrieves the first element of an Iterable. It throws an error if the Iterable is empty. The function takes an Iterable<A> as input and returns an element of type A.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Iterable-unsafeHead.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const unsafeHead: <A>(self: Iterable<A>) => A\n```\n\n----------------------------------------\n\nTITLE: Checking LeftDone State in MergeState - TypeScript\nDESCRIPTION: The isLeftDone function checks if a given MergeState is of type LeftDone. It takes a MergeState object as input and returns a boolean indicating whether it's a LeftDone state. This function is useful for determining the current state in merge operations.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/MergeState-isLeftDone.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const isLeftDone: <Env, Err, Err1, Err2, Elem, Done, Done1, Done2>(self: MergeState<Env, Err, Err1, Err2, Elem, Done, Done1, Done2>) => self is LeftDone<Env, Err, Err1, Err2, Elem, Done, Done1, Done2>\n```\n\n----------------------------------------\n\nTITLE: Defining Error Constructor in TypeScript for Effect Package\nDESCRIPTION: Declares a constructor for a Case Class that extends YieldableError. It accepts an optional record of properties that will be included in the error instance. The constructor returns a combination of Cause.YieldableError and the provided properties.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Data-Error.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const Error: new <A extends Record<string, any> = {}>(args: Types.Equals<A, {}> extends true ? void : { readonly [P in keyof A]: A[P]; }) => Cause.YieldableError & Readonly<A>\n```\n\n----------------------------------------\n\nTITLE: Checking for Yield in ChildExecutorDecision in TypeScript\nDESCRIPTION: This function determines if a given ChildExecutorDecision is of type Yield. It takes a ChildExecutorDecision as input and returns a boolean indicating whether it is a Yield or not. This function uses a type predicate to narrow the type if it returns true.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/ChildExecutorDecision-isYield.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const isYield: (self: ChildExecutorDecision) => self is Yield\n```\n\n----------------------------------------\n\nTITLE: Signature Definition for unsafeDivide in TypeScript\nDESCRIPTION: This code block provides the TypeScript signature of the `unsafeDivide` function. The function supports currying and can be invoked with one or two arguments. The output is a number representing the quotient. The function may throw a RangeError if the divisor is zero.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Number-unsafeDivide.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const unsafeDivide: { (that: number): (self: number) => number; (self: number, that: number): number; }\n```\n\n----------------------------------------\n\nTITLE: Removing Annotations from DocStream in TypeScript\nDESCRIPTION: Function signature for unAnnotate, which removes all annotations from a DocStream document. Takes a DocStream<A> as input and returns a DocStream with no annotations (DocStream<never>).\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/DocStream-unAnnotate.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const unAnnotate: <A>(self: DocStream<A>) => DocStream<never>\n```\n\n----------------------------------------\n\nTITLE: TypeScript Signature for Doc.catWithLine Function\nDESCRIPTION: The function signature for `catWithLine` shows it has two overloaded forms: one that works with piping and one that takes both arguments directly. Both forms combine two documents and return a new document that includes both input types.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Doc-catWithLine.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const catWithLine: { <B>(that: Doc<B>): <A>(self: Doc<A>) => Doc<B | A>; <A, B>(self: Doc<A>, that: Doc<B>): Doc<A | B>; }\n```\n\n----------------------------------------\n\nTITLE: Checking Upstream Pull Strategy Type with TypeScript\nDESCRIPTION: The function 'isPullAfterNext' determines if an 'UpstreamPullStrategy' instance is of the type 'PullAfterNext'. It returns a boolean value. The function relies solely on TypeScript's type system to ascertain the strategy type with no additional dependencies required. It takes one parameter, a strategy instance, and returns a boolean indicating its specific type.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/UpstreamPullStrategy-isPullAfterNext.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const isPullAfterNext: <A>(self: UpstreamPullStrategy<A>) => self is PullAfterNext<A>\n```\n\n----------------------------------------\n\nTITLE: Matcher Type Definition in Effect-TS\nDESCRIPTION: Type definition for the Matcher interface, showing the possible variants of TypeMatcher and ValueMatcher with their respective generic parameters.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Match-Matcher.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ntype Matcher<Input, Filters, RemainingApplied, Result, Provided, Return> = | TypeMatcher<Input, Filters, RemainingApplied, Result, Return>\n  | ValueMatcher<Input, Filters, RemainingApplied, Result, Provided, Return>\n```\n\n----------------------------------------\n\nTITLE: Defining TypeScript Sink Drain Utility\nDESCRIPTION: Creates a sink that receives inputs but does not process or retain any of them. Useful for scenarios where input consumption is required without further processing.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Sink-drain.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const drain: Sink<void, unknown, never, never, never>\n```\n\n----------------------------------------\n\nTITLE: Defining BigInt MonoidSum in TypeScript\nDESCRIPTION: This snippet imports the MonoidSum from the Effect library and demonstrates the combination of BigInt values using the provided MonoidSum functionality. It shows how to combine two BigInt values as well as how to use the empty value defined for this monoid.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/data-BigInt-MonoidSum.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { MonoidSum } from \"@effect/typeclass/data/BigInt\"\n\nconsole.log(MonoidSum.combine(2n, 3n))\n// 5n\nconsole.log(MonoidSum.combine(2n, MonoidSum.empty))\n// 2n\n```\n\n----------------------------------------\n\nTITLE: Retrieving a Fiber from FiberMap in TypeScript\nDESCRIPTION: The get function retrieves a fiber from a FiberMap using a key. It returns an Effect that resolves to the RuntimeFiber if found, or a NoSuchElementException if the key doesn't exist in the map.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/FiberMap-get.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const get: { <K>(key: K): <A, E>(self: FiberMap<K, A, E>) => Effect.Effect<Fiber.RuntimeFiber<A, E>, NoSuchElementException>; <K, A, E>(self: FiberMap<K, A, E>, key: K): Effect.Effect<Fiber.RuntimeFiber<A, E>, NoSuchElementException>; }\n```\n\n----------------------------------------\n\nTITLE: Declaring ANSI Screen Erasing Operation in TypeScript\nDESCRIPTION: Defines a constant 'eraseDown' that clears the screen from the current cursor position to the end of the screen. This operation maintains the cursor at its current position while clearing all content below it.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Ansi-eraseDown.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const eraseDown: Ansi\n```\n\n----------------------------------------\n\nTITLE: Initializing Stream with Defect in TypeScript\nDESCRIPTION: Creates a stream that immediately terminates with the provided defect. This function is useful for generating streams that fail immediately with a specific error condition.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-die.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const die: (defect: unknown) => Stream<never>\n```\n\n----------------------------------------\n\nTITLE: Declaring the RunnerHealth Class in TypeScript\nDESCRIPTION: Declaration of the RunnerHealth class which is used to check if a Runner is healthy. The health status determines whether shards should be reassigned to different Runners.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/RunnerHealth-RunnerHealth.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare class RunnerHealth\n```\n\n----------------------------------------\n\nTITLE: Stream.zipLatestAll Type Signature Definition\nDESCRIPTION: TypeScript type signature for the zipLatestAll function, showing its generic type parameters and return type for combining multiple streams.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-zipLatestAll.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const zipLatestAll: <T extends ReadonlyArray<Stream<any, any, any>>>(...streams: T) => Stream<[T[number]] extends [never] ? never : { [K in keyof T]: T[K] extends Stream<infer A, infer _E, infer _R> ? A : never; }, [T[number]] extends [never] ? never : T[number] extends Stream<infer _A, infer _E, infer _R> ? _E : never, [T[number]] extends [never] ? never : T[number] extends Stream<infer _A, infer _E, infer _R> ? _R : never>\n```\n\n----------------------------------------\n\nTITLE: SK Combinator Function Signature in TypeScript\nDESCRIPTION: Provides the type signature for the SK combinator function. It takes two generic type parameters A and B, and returns a value of type B.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Function-SK.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const SK: <A, B>(_: A, b: B) => B\n```\n\n----------------------------------------\n\nTITLE: Executing SQL Query with Schema Validation for Single Result in TypeScript\nDESCRIPTION: The `single` function runs a SQL query with request and result schemas, returning only the first result. It handles schema validation for both input and output, and raises appropriate errors if parsing fails or no results are found.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/SqlSchema-single.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const single: <IR, II, IA, AR, AI, A, R, E>(options: { readonly Request: Schema.Schema<IA, II, IR>; readonly Result: Schema.Schema<A, AI, AR>; readonly execute: (request: II) => Effect.Effect<ReadonlyArray<unknown>, E, R>; }) => (request: IA) => Effect.Effect<A, E | ParseError | Cause.NoSuchElementException, R | IR | AR>\n```\n\n----------------------------------------\n\nTITLE: Defining Doc.Nesting Interface in TypeScript\nDESCRIPTION: This code snippet defines the `Nesting` interface within the `Doc` namespace. It represents a document that can react to the current nesting level, containing a `_tag` property and a `react` function that takes a nesting level and returns a `Doc<A>`.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Doc-Nesting.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface Nesting<A> extends Doc.Variance<A> {\n  readonly _tag: \"Nesting\"\n  readonly react: (level: number) => Doc<A>\n}\n```\n\n----------------------------------------\n\nTITLE: Either.getLeft Function Signature in TypeScript\nDESCRIPTION: This code snippet shows the TypeScript type signature for the Either.getLeft function. It takes an Either<R, L> as input and returns an Option<L>.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Either-getLeft.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const getLeft: <R, L>(self: Either<R, L>) => Option<L>\n```\n\n----------------------------------------\n\nTITLE: Checking Interruption State in Effect Cause Module\nDESCRIPTION: A utility function that examines a Cause object to determine if it contains any fiber interruptions. Takes a generic Cause<E> parameter and returns a boolean indicating the presence of interruptions.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Cause-isInterrupted.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const isInterrupted: <E>(self: Cause<E>) => boolean\n```\n\n----------------------------------------\n\nTITLE: Using distanceDurationEither with Effect DateTime\nDESCRIPTION: Example showing how to calculate time differences between two DateTime values, demonstrating both positive and negative duration scenarios using the Effect library.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/DateTime-distanceDurationEither.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { DateTime, Effect } from \"effect\"\n\nEffect.gen(function* () {\n  const now = yield* DateTime.now\n  const other = DateTime.add(now, { minutes: 1 })\n\n  // returns Either.right(Duration.minutes(1))\n  DateTime.distanceDurationEither(now, other)\n\n  // returns Either.left(Duration.minutes(1))\n  DateTime.distanceDurationEither(other, now)\n})\n```\n\n----------------------------------------\n\nTITLE: Configuring HTTP Layer Options for ShardManager in TypeScript\nDESCRIPTION: Defines a type declaration for creating an HTTP layer for the ShardManager server. The layer adds a route to the specified HttpRouter.Tag with configurable options including path, router tag, runner path, HTTPS settings, and address logging.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/HttpShardManager-layerHttpOptions.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const layerHttpOptions: <I = HttpRouter.Default>(options: { readonly path: HttpRouter.PathInput; readonly routerTag?: HttpRouter.HttpRouter.TagClass<I, string, any, any>; readonly runnerPath: string; readonly runnerHttps?: boolean | undefined; readonly logAddress?: boolean | undefined; }) => Layer.Layer<ShardManager.ShardManager, never, RpcSerialization.RpcSerialization | ShardStorage | RunnerHealth.RunnerHealth | HttpClient.HttpClient | HttpServer.HttpServer | ShardManager.Config | ShardingConfig>\n```\n\n----------------------------------------\n\nTITLE: Creating Constant Output Metric in TypeScript\nDESCRIPTION: The sync function creates a metric that ignores input and produces constant output. It takes a lazy argument function that evaluates to the output type and returns a Metric type with void input, unknown error, and the specified output type.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Metric-sync.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const sync: <Out>(evaluate: LazyArg<Out>) => Metric<void, unknown, Out>\n```\n\n----------------------------------------\n\nTITLE: Retrieving Struct Values with Effect-TS Struct.get\nDESCRIPTION: Demonstrates how to retrieve a value from a struct using the Struct.get function from the Effect library. The example shows accessing a property 'a' from an object containing multiple properties.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Struct-get.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { pipe, Struct } from \"effect\"\n\nconst value = pipe({ a: 1, b: 2 }, Struct.get(\"a\"))\n\nassert.deepStrictEqual(value, 1)\n```\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const get: <K extends PropertyKey>(key: K) => <S extends { [P in K]?: any; }>(s: S) => MatchRecord<S, S[K] | undefined, S[K]>\n```\n\n----------------------------------------\n\nTITLE: Declaring a Comma Character Document in TypeScript\nDESCRIPTION: Defines a constant 'comma' that represents a document containing a single comma character. The type signature indicates it's a Doc with a 'never' type parameter, suggesting it doesn't contain any specific value type.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Doc-comma.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const comma: Doc<never>\n```\n\n----------------------------------------\n\nTITLE: Using Match.discriminatorsExhaustive for Type Discrimination in TypeScript\nDESCRIPTION: Demonstrates how to use Match.discriminatorsExhaustive to handle discriminated unions with compile-time exhaustiveness checking. The example shows pattern matching on objects with a 'type' discriminator field, ensuring all possible cases are handled.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Match-discriminatorsExhaustive.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Match, pipe } from \"effect\"\n\nconst match = pipe(\n  Match.type<{ type: \"A\"; a: string } | { type: \"B\"; b: number } | { type: \"C\"; c: boolean }>(),\n  Match.discriminatorsExhaustive(\"type\")({\n    A: (a) => a.a,\n    B: (b) => b.b,\n    C: (c) => c.c\n  })\n)\n```\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const discriminatorsExhaustive: <D extends string>(field: D) => <R, Ret, P extends { readonly [Tag in Types.Tags<D, R> & string]: (_: Extract<R, Record<D, Tag>>) => Ret; } & { readonly [Tag in Exclude<keyof P, Types.Tags<D, R>>]: never; }>(fields: P) => <I, F, A, Pr>(self: Matcher<I, F, R, A, Pr, Ret>) => [Pr] extends [never] ? (u: I) => Unify<A | ReturnType<P[keyof P]>> : Unify<A | ReturnType<P[keyof P]>>\n```\n\n----------------------------------------\n\nTITLE: TypeScript Function Signature for keysWithPrefix in Trie\nDESCRIPTION: This code block presents the TypeScript function signature for the keysWithPrefix function in the Trie module. It shows two overloads of the function, allowing for different parameter orders when calling the function.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Trie-keysWithPrefix.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const keysWithPrefix: { (prefix: string): <V>(self: Trie<V>) => IterableIterator<string>; <V>(self: Trie<V>, prefix: string): IterableIterator<string>; }\n```\n\n----------------------------------------\n\nTITLE: Declaring IllegalArgumentExceptionTypeId Symbol in TypeScript\nDESCRIPTION: Declares a unique symbol constant that identifies the IllegalArgumentException type. This symbol is used as a type identifier for exceptions that occur when invalid arguments are supplied to methods that expect specific input.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Cause-IllegalArgumentExceptionTypeId.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const IllegalArgumentExceptionTypeId: unique symbol\n```\n\n----------------------------------------\n\nTITLE: Creating Entity Instances with Entity.make in TypeScript\nDESCRIPTION: This function creates a new Entity of the specified type that accepts messages conforming to the provided schemas. It takes a type string and protocol schemas as parameters and returns an Entity instance.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Entity-make.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const make: <Rpcs extends ReadonlyArray<Rpc.Any>>(type: string, protocol: Rpcs) => Entity<Rpcs[number]>\n```\n\n----------------------------------------\n\nTITLE: Implementing RequestResolver.race in TypeScript\nDESCRIPTION: A function that combines two request resolvers, executing requests on both and returning the result from whichever completes first while safely interrupting the slower one.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/RequestResolver-race.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const race: { <A2 extends Request.Request<any, any>, R2>(that: RequestResolver<A2, R2>): <A extends Request.Request<any, any>, R>(self: RequestResolver<A, R>) => RequestResolver<A2 | A, R2 | R>; <A extends Request.Request<any, any>, R, A2 extends Request.Request<any, any>, R2>(self: RequestResolver<A, R>, that: RequestResolver<A2, R2>): RequestResolver<A | A2, R | R2>; }\n```\n\n----------------------------------------\n\nTITLE: Declaring Conditional Stream Handling in TypeScript\nDESCRIPTION: The 'whenCaseEffect' function is part of a module dedicated to handling streams in the 'effect' library. It conditionally returns a stream if the provided partial function is applicable to the given effectful value, otherwise, it produces an empty stream. The function is designed for environments utilizing the 'effect' package and requires TypeScript for proper implementation. It accepts an effect and a partial function and returns a stream based on the specified conditions.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-whenCaseEffect.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const whenCaseEffect: { <A, A2, E2, R2>(pf: (a: A) => Option.Option<Stream<A2, E2, R2>>): <E, R>(self: Effect.Effect<A, E, R>) => Stream<A2, E2 | E, R2 | R>; <A, E, R, A2, E2, R2>(self: Effect.Effect<A, E, R>, pf: (a: A) => Option.Option<Stream<A2, E2, R2>>): Stream<A2, E | E2, R | R2>; }\n```\n\n----------------------------------------\n\nTITLE: Declaring SemigroupEvery Signature in TypeScript\nDESCRIPTION: This snippet declares the type signature for the SemigroupEvery constant, defining its type as a semigroup for boolean values. It specifies that SemigroupEvery is a structure that supports the semigroup operation for combining boolean values.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/data-Boolean-SemigroupEvery.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const SemigroupEvery: semigroup.Semigroup<boolean>\n```\n\n----------------------------------------\n\nTITLE: Defining Lowercase Schema Class in TypeScript\nDESCRIPTION: Declares the Lowercase class, which represents a schema for converting strings to lowercase. This schema can be used to ensure string values are in lowercase format.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Schema-Lowercase.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare class Lowercase\n```\n\n----------------------------------------\n\nTITLE: Setting Cookies in TypeScript using @effect/platform\nDESCRIPTION: Defines a function 'setCookie' that adds a cookie to a Cookies object. It can be called with either the cookie first and self second, or self first and cookie second.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Cookies-setCookie.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const setCookie: { (cookie: Cookie): (self: Cookies) => Cookies; (self: Cookies, cookie: Cookie): Cookies; }\n```\n\n----------------------------------------\n\nTITLE: Creating FiberRefs Instance with unsafeMake in TypeScript\nDESCRIPTION: A function that creates a FiberRefs instance from a provided Map of FiberRef values. The function does not copy the provided Map, so it's important to provide a fresh Map instance. Takes a Map of FiberRef to an array of FiberId and value pairs.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/FiberRefs-unsafeMake.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const unsafeMake: (fiberRefLocals: Map<FiberRef.FiberRef<any>, Arr.NonEmptyReadonlyArray<readonly [FiberId.Single, any]>>) => FiberRefs\n```\n\n----------------------------------------\n\nTITLE: Converting a Sink to a Channel in TypeScript\nDESCRIPTION: The toChannel function creates a Channel from a Sink. This allows Sink-based data processing to be integrated into Channel-based workflows in the Effect-TS ecosystem.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Sink-toChannel.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const toChannel: <A, In, L, E, R>(self: Sink<A, In, L, E, R>) => Channel.Channel<Chunk.Chunk<L>, Chunk.Chunk<In>, E, never, A, unknown, R>\n```\n\n----------------------------------------\n\nTITLE: Updating Password for URL in TypeScript\nDESCRIPTION: The setPassword function updates the password associated with a URL. It can be called in two ways: providing the password first or the URL first. The function takes a password of type string and returns an updated URL object. Dependencies include the TypeScript language type definitions for URL.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Url-setPassword.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const setPassword: { (password: string): (url: URL) => URL; (url: URL, password: string): URL; }\n```\n\n----------------------------------------\n\nTITLE: Trie.toEntriesWithPrefix Function Signature in TypeScript\nDESCRIPTION: Shows the TypeScript function signature for Trie.toEntriesWithPrefix. The function can be called with either the prefix first and trie second, or trie first and prefix second, returning an array of key-value pairs.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Trie-toEntriesWithPrefix.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const toEntriesWithPrefix: { (prefix: string): <V>(self: Trie<V>) => Array<[string, V]>; <V>(self: Trie<V>, prefix: string): Array<[string, V]>; }\n```\n\n----------------------------------------\n\nTITLE: Defining MalformedMessage Error Class in TypeScript\nDESCRIPTION: Declares the MalformedMessage class, which represents an error that occurs when a message fails to be properly deserialized by an entity in a cluster. This class is part of the ClusterError module in the @effect/cluster package.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/ClusterError-MalformedMessage.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare class MalformedMessage\n```\n\n----------------------------------------\n\nTITLE: Creating Context Layer in TypeScript using Effect Layer Module\nDESCRIPTION: Function signature for succeedContext that constructs a layer from a specified context value. The function accepts a Context parameter of type A and returns a Layer of type A. Used for creating service layers in the Effect ecosystem.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Layer-succeedContext.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const succeedContext: <A>(context: Context.Context<A>) => Layer<A>\n```\n\n----------------------------------------\n\nTITLE: Implementing Chunk.unsafeGet in TypeScript\nDESCRIPTION: Function signature for unsafeGet that retrieves an element from a Chunk at a specified index. The function is overloaded to support both curried and uncurried parameter orders. Will throw an error if index is out of bounds.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Chunk-unsafeGet.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const unsafeGet: { (index: number): <A>(self: Chunk<A>) => A; <A>(self: Chunk<A>, index: number): A; }\n```\n\n----------------------------------------\n\nTITLE: Declaring eraseDown ANSI Terminal Control Function in TypeScript\nDESCRIPTION: Defines the eraseDown constant as an AnsiDoc type, which clears the screen from the current cursor position to the end without changing the cursor position.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/AnsiDoc-eraseDown.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const eraseDown: AnsiDoc\n```\n\n----------------------------------------\n\nTITLE: Checking ConfigError Type in TypeScript\nDESCRIPTION: The isOr function checks if a given ConfigError is of type Or. It returns true if the error is an Or type, and false otherwise. This function is useful for type narrowing in conditional statements.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/ConfigError-isOr.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const isOr: (self: ConfigError) => self is Or\n```\n\n----------------------------------------\n\nTITLE: Converting Duration to Nanoseconds in TypeScript\nDESCRIPTION: Function to convert a duration to nanoseconds as a bigint. This function throws an error if the provided duration is infinite, making it unsafe for such inputs.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Duration-unsafeToNanos.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const unsafeToNanos: (self: DurationInput) => bigint\n```\n\n----------------------------------------\n\nTITLE: Implementing filterOrFail Function in TypeScript Effect Module\nDESCRIPTION: Type declaration for filterOrFail function that enables filtering of Effect values with custom error handling. The function supports both refinement-based and predicate-based filtering, allowing for type narrowing and custom error generation when the filter condition fails.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Micro-filterOrFail.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const filterOrFail: {\n  <A, B extends A, E2>(refinement: Refinement<A, B>, orFailWith: (a: NoInfer<A>) => E2): <E, R>(self: Micro<A, E, R>) => Micro<B, E2 | E, R>;\n  <A, E2>(predicate: Predicate<NoInfer<A>>, orFailWith: (a: NoInfer<A>) => E2): <E, R>(self: Micro<A, E, R>) => Micro<A, E2 | E, R>;\n  <A, E, R, B extends A, E2>(self: Micro<A, E, R>, refinement: Refinement<A, B>, orFailWith: (a: A) => E2): Micro<B, E | E2, R>;\n  <A, E, R, E2>(self: Micro<A, E, R>, predicate: Predicate<A>, orFailWith: (a: A) => E2): Micro<A, E | E2, R>;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining MonoidMultiply in TypeScript\nDESCRIPTION: This code snippet imports the MonoidMultiply from the Effect framework's typeclass for numbers and demonstrates its usage by combining two numbers and a number with the empty value. The expected output showcases the multiplication functionality of the monoid.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/data-Number-MonoidMultiply.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { MonoidMultiply } from \"@effect/typeclass/data/Number\"\n\nconsole.log(MonoidMultiply.combine(2, 3))\n// 6\nconsole.log(MonoidMultiply.combine(2, MonoidMultiply.empty))\n// 2\n```\n\n----------------------------------------\n\nTITLE: Defining zipLeft Function in Channel Module (TypeScript)\nDESCRIPTION: Declares the zipLeft function, which performs sequential composition of two channels. It returns a new channel that terminates with the terminal value of the first channel. The function supports optional concurrent execution.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Channel-zipLeft.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const zipLeft: { <OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>(that: Channel<OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>, options?: { readonly concurrent?: boolean | undefined; } | undefined): <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>) => Channel<OutElem1 | OutElem, InElem & InElem1, OutErr1 | OutErr, InErr & InErr1, OutDone, InDone & InDone1, Env1 | Env>; <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>, that: Channel<OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>, options?: { readonly concurrent?: boolean | undefined; } | undefined): Channel<OutElem | OutElem1, InElem & InElem1, OutErr | OutErr1, InErr & InErr1, OutDone, InDone & InDone1, Env | Env1>; }\n```\n\n----------------------------------------\n\nTITLE: Accessing Sink Context in TypeScript\nDESCRIPTION: The `contextWithSink` function allows users to access the context of the sink by taking a function that provides the context as an input. This function returns a Sink that can work with both the original and new contexts. It is essential for scenarios where context propagation is needed within the Effect framework, especially in version 2.0.0 or later.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Sink-contextWithSink.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const contextWithSink: <R0, A, In, L, E, R>(f: (context: Context.Context<R0>) => Sink<A, In, L, E, R>) => Sink<A, In, L, E, R0 | R>\n```\n\n----------------------------------------\n\nTITLE: Repeating Values with Stream and Effect in TypeScript\nDESCRIPTION: This code snippet demonstrates the use of the 'Stream.repeatValue' function from the 'effect' package to create a stream that repeats a specified value indefinitely. The snippet shows importing 'Effect' and 'Stream', initializing an infinite stream of the value '0', and then collecting the first five values from it using 'Stream.take'. Running the stream with 'Effect.runPromise' collects the values and prints them to the console. Dependencies include the 'effect' package, and the key parameters include the value to be repeated. The expected output is a 'Chunk' containing five repeated values of '0'.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-repeatValue.md#2025-04-11_snippet_0\n\nLANGUAGE: ts\nCODE:\n```\nimport { Effect, Stream } from \"effect\"\n\nconst stream = Stream.repeatValue(0)\n\nEffect.runPromise(Stream.runCollect(stream.pipe(Stream.take(5)))).then(console.log)\n// { _id: 'Chunk', values: [ 0, 0, 0, 0, 0 ] }\n```\n\n----------------------------------------\n\nTITLE: String Monoid Definition\nDESCRIPTION: Defines a `Monoid` constant for strings using the `monoid.Monoid<string>` type from the Effect TS library. The monoid represents string concatenation with the empty string as the identity element.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/data-String-Monoid.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const Monoid: monoid.Monoid<string>\n```\n\n----------------------------------------\n\nTITLE: Trie.get Function Signature in TypeScript\nDESCRIPTION: This code snippet shows the TypeScript signature for the Trie.get function. It demonstrates that the function can be called with either the key first or the Trie first, providing flexibility in usage.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Trie-get.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const get: { (key: string): <V>(self: Trie<V>) => Option<V>; <V>(self: Trie<V>, key: string): Option<V>; }\n```\n\n----------------------------------------\n\nTITLE: Defining layerContext Layer in BunHttpServer Module\nDESCRIPTION: Declares a constant layerContext that provides a Layer for HttpPlatform, FileSystem, Etag.Generator, and Path services. The FileSystem service is a no-op implementation, making this layer suitable for platforms without a file system.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/BunHttpServer-layerContext.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const layerContext: Layer.Layer<Platform.HttpPlatform | Etag.Generator | BunContext.BunContext, never, never>\n```\n\n----------------------------------------\n\nTITLE: Array.takeWhile function signature in TypeScript\nDESCRIPTION: The type signature for the Array.takeWhile function, showing its polymorphic implementation. It supports both predicate and refinement functions, and can be used in both data-first and data-last (curried) styles.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Array-takeWhile.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const takeWhile: { <A, B extends A>(refinement: (a: NoInfer<A>, i: number) => a is B): (self: Iterable<A>) => Array<B>; <A>(predicate: (a: NoInfer<A>, i: number) => boolean): (self: Iterable<A>) => Array<A>; <A, B extends A>(self: Iterable<A>, refinement: (a: A, i: number) => a is B): Array<B>; <A>(self: Iterable<A>, predicate: (a: A, i: number) => boolean): Array<A>; }\n```\n\n----------------------------------------\n\nTITLE: Defining GenAI OperationAttributes Interface in TypeScript\nDESCRIPTION: This code snippet defines the OperationAttributes interface for GenAI operations. It includes an optional 'name' property that can be a string, WellKnownOperationName, null, or undefined. This interface is part of the AiTelemetry module in the @effect/ai package.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/AiTelemetry-GenAI.OperationAttributes.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface OperationAttributes {\n    readonly name?: (string & {}) | WellKnownOperationName | null | undefined\n  }\n```\n\n----------------------------------------\n\nTITLE: TMap Find Function Signature (Typescript)\nDESCRIPTION: The `find` function searches a `TMap` for a key/value pair matching a specified predicate. It takes a predicate function `pf` that receives the key and value of each entry and returns an `Option<A>`. If a match is found (i.e., `pf` returns `Some<A>`), the extracted value `A` is returned wrapped in another `Option`. The function returns an `STM` effect that resolves to an `Option<Option<A>>`.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TMap-find.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const find: { <K, V, A>(pf: (key: K, value: V) => Option.Option<A>): (self: TMap<K, V>) => STM.STM<Option.Option<A>>; <K, V, A>(self: TMap<K, V>, pf: (key: K, value: V) => Option.Option<A>): STM.STM<Option.Option<A>>; }\n```\n\n----------------------------------------\n\nTITLE: Type Signature of untupled Function in TypeScript\nDESCRIPTION: This code block shows the TypeScript type signature for the untupled function. It takes a function that accepts a tuple and returns a new function that accepts the tuple elements as separate arguments.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Function-untupled.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const untupled: <A extends ReadonlyArray<unknown>, B>(f: (a: A) => B) => (...a: A) => B\n```\n\n----------------------------------------\n\nTITLE: Declaration of reAnnotate Function in TypeScript\nDESCRIPTION: The reAnnotate function changes the annotation of a document tree. It takes a mapping function from annotation type A to type B and a document with annotations of type A, returning a document with annotations of type B. Note that this traverses the entire document tree with each invocation.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Doc-reAnnotate.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const reAnnotate: { <A, B>(f: (a: A) => B): (self: Doc<A>) => Doc<B>; <A, B>(self: Doc<A>, f: (a: A) => B): Doc<B>; }\n```\n\n----------------------------------------\n\nTITLE: Defining EncodeException Interface in TypeScript\nDESCRIPTION: Defines a TypeScript interface for encoding exceptions that includes a type tag, unique type ID, input string that failed encoding, and an optional error message. This interface is used to create structured error objects when encoding operations fail.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Encoding-EncodeException.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface EncodeException {\n  readonly _tag: \"EncodeException\"\n  readonly [EncodeExceptionTypeId]: EncodeExceptionTypeId\n  readonly input: string\n  readonly message?: string\n}\n```\n\n----------------------------------------\n\nTITLE: Defining AlreadyFlat Interface in Typescript\nDESCRIPTION: Defines the AlreadyFlat interface which represents a FlattenResult case where the input was already flat. It includes a discriminated union tag and extends the Flatten.Variance generic type.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Flatten-AlreadyFlat.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface AlreadyFlat<A> extends Flatten.Variance<A> {\n  readonly _tag: \"AlreadyFlat\"\n}\n```\n\n----------------------------------------\n\nTITLE: Doc.hsep Type Signature in TypeScript\nDESCRIPTION: Type declaration for the hsep function showing it accepts an Iterable of Doc<A> and returns a Doc<A>.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Doc-hsep.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const hsep: <A>(docs: Iterable<Doc<A>>) => Doc<A>\n```\n\n----------------------------------------\n\nTITLE: Testing for PushAnnotationStream Type in TypeScript\nDESCRIPTION: This function checks if a given DocStream is specifically a PushAnnotationStream. It returns a boolean value that also serves as a type guard in TypeScript.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/DocStream-isPushAnnotationStream.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const isPushAnnotationStream: <A>(self: DocStream<A>) => self is PushAnnotationStream<A>\n```\n\n----------------------------------------\n\nTITLE: Iterable.replicate Type Signature\nDESCRIPTION: Type signature for the replicate function showing its polymorphic implementation. It can be called either with the count first and value second, or with value first and count second.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Iterable-replicate.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const replicate: { (n: number): <A>(a: A) => Iterable<A>; <A>(a: A, n: number): Iterable<A>; }\n```\n\n----------------------------------------\n\nTITLE: Duration.format Function Signature in TypeScript\nDESCRIPTION: Provides the TypeScript signature for the Duration.format function. It takes a DurationInput parameter and returns a string representation of the duration.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Duration-format.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const format: (self: DurationInput) => string\n```\n\n----------------------------------------\n\nTITLE: Defining Action Interface in TypeScript\nDESCRIPTION: This snippet defines the ActionDefinition interface that extends a TaggedEnum with generics. It represents the structure necessary to create a correctly typed action in the Effect framework. The key parameters are 'A' and 'B', which are utilized in the tagged enum.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Prompt-Prompt.ActionDefinition.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport interface ActionDefinition extends TaggedEnum.WithGenerics<2> {\n    readonly taggedEnum: Action<this[\"A\"], this[\"B\"]>\n  }\n```\n\n----------------------------------------\n\nTITLE: Creating a Micro Effect - succeedSome in TypeScript\nDESCRIPTION: The 'succeedSome' function creates a Micro effect that successfully wraps a value in an Option's Some. It can be used to handle optional values in functional programming contexts, relying on the Effect framework's capabilities.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Micro-succeedSome.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const succeedSome: <A>(a: A) => Micro<Option.Option<A>>\n```\n\n----------------------------------------\n\nTITLE: Checking for AnnotationTree in TypeScript\nDESCRIPTION: A type guard function that checks if a DocTree is specifically an AnnotationTree. Returns true if the provided DocTree is an AnnotationTree, false otherwise.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/DocTree-isAnnotationTree.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const isAnnotationTree: <A>(self: DocTree<A>) => self is AnnotationTree<A>\n```\n\n----------------------------------------\n\nTITLE: Using BigDecimal.clamp in TypeScript\nDESCRIPTION: Demonstrates how to use BigDecimal.clamp to restrict a number within a specified range. The function takes minimum and maximum values as parameters and returns a new value that is guaranteed to be within that range.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/BigDecimal-clamp.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { BigDecimal } from \"effect\"\n\nconst clamp = BigDecimal.clamp({\n  minimum: BigDecimal.unsafeFromString(\"1\"),\n  maximum: BigDecimal.unsafeFromString(\"5\") }\n)\n\nassert.deepStrictEqual(clamp(BigDecimal.unsafeFromString(\"3\")), BigDecimal.unsafeFromString(\"3\"))\nassert.deepStrictEqual(clamp(BigDecimal.unsafeFromString(\"0\")), BigDecimal.unsafeFromString(\"1\"))\nassert.deepStrictEqual(clamp(BigDecimal.unsafeFromString(\"6\")), BigDecimal.unsafeFromString(\"5\"))\n```\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const clamp: { (options: { minimum: BigDecimal; maximum: BigDecimal; }): (self: BigDecimal) => BigDecimal; (self: BigDecimal, options: { minimum: BigDecimal; maximum: BigDecimal; }): BigDecimal; }\n```\n\n----------------------------------------\n\nTITLE: Type Guard Function for ManagedRuntime in TypeScript\nDESCRIPTION: A type guard function that checks if the provided input is a ManagedRuntime instance. Takes an unknown value as input and narrows the type to ManagedRuntime<unknown, unknown> if the check passes.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/ManagedRuntime-isManagedRuntime.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const isManagedRuntime: (input: unknown) => input is ManagedRuntime<unknown, unknown>\n```\n\n----------------------------------------\n\nTITLE: Retrieving Fiber ID in TypeScript using Effect-TS\nDESCRIPTION: A function that returns the unique identifier (FiberId) of a given Fiber instance. Takes a Fiber<A, E> as input and returns its associated FiberId.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Fiber-id.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const id: <A, E>(self: Fiber<A, E>) => FiberId.FiberId\n```\n\n----------------------------------------\n\nTITLE: Creating Environment Differ in TypeScript\nDESCRIPTION: Constructs a differ that knows how to diff `Env` values (Context objects). This function returns a Differ that can be used to efficiently update Context instances by identifying differences between them.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Differ-environment.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const environment: <A>() => Differ<Context<A>, Differ.Context.Patch<A, A>>\n```\n\n----------------------------------------\n\nTITLE: Defining Die Interface in TypeScript for Effect.io\nDESCRIPTION: Defines the Die interface that represents unexpected defects within a Cause. It extends Cause.Variance, Equal.Equal, Pipeable, and Inspectable interfaces, containing a _tag identifier and a defect property of unknown type.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Cause-Die.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface Die extends Cause.Variance<never>, Equal.Equal, Pipeable, Inspectable {\n  readonly _tag: \"Die\"\n  readonly defect: unknown\n}\n```\n\n----------------------------------------\n\nTITLE: Defining GenAI WellKnownSystem Type in TypeScript\nDESCRIPTION: Defines a TypeScript type that enumerates all the well-known AI system providers that should be used for the gen_ai.system attribute in telemetry. This ensures consistent system identification across the Effect.ts AI framework.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/AiTelemetry-GenAI.WellKnownSystem.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ntype WellKnownSystem = | \"anthropic\"\n    | \"aws.bedrock\"\n    | \"az.ai.inference\"\n    | \"az.ai.openai\"\n    | \"cohere\"\n    | \"deepseek\"\n    | \"gemini\"\n    | \"groq\"\n    | \"ibm.watsonx.ai\"\n    | \"mistral_ai\"\n    | \"openai\"\n    | \"perplexity\"\n    | \"vertex_ai\"\n    | \"xai\"\n```\n\n----------------------------------------\n\nTITLE: Checking Unbounded Page Width in TypeScript\nDESCRIPTION: Defines a function that checks if a specified PageWidth is classified as Unbounded. This is useful for validating page width conditions in rendering or layout management.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/PageWidth-isUnbounded.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const isUnbounded: (self: PageWidth) => self is Unbounded\n```\n\n----------------------------------------\n\nTITLE: BigInt Multiply Function Type Signature\nDESCRIPTION: Type declaration for the multiply function showing its polymorphic nature. Supports both curried and uncurried calling styles for multiplying bigint values.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/BigInt-multiply.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const multiply: { (that: bigint): (self: bigint) => bigint; (self: bigint, that: bigint): bigint; }\n```\n\n----------------------------------------\n\nTITLE: Type Signature for Data.taggedEnum in TypeScript\nDESCRIPTION: The type signature of the Data.taggedEnum function, showing its polymorphic nature with support for various numbers of generic type parameters.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Data-taggedEnum.md#2025-04-11_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const taggedEnum: { <Z extends TaggedEnum.WithGenerics<1>>(): Types.Simplify<{ readonly [Tag in Z[\"taggedEnum\"][\"_tag\"]]: <A>(args: TaggedEnum.Args<TaggedEnum.Kind<Z, A>, Tag, Extract<TaggedEnum.Kind<Z, A>, { readonly _tag: Tag; }>>) => TaggedEnum.Value<TaggedEnum.Kind<Z, A>, Tag>; } & TaggedEnum.GenericMatchers<Z>>; <Z extends TaggedEnum.WithGenerics<2>>(): Types.Simplify<{ readonly [Tag in Z[\"taggedEnum\"][\"_tag\"]]: <A, B>(args: TaggedEnum.Args<TaggedEnum.Kind<Z, A, B>, Tag, Extract<TaggedEnum.Kind<Z, A, B>, { readonly _tag: Tag; }>>) => TaggedEnum.Value<TaggedEnum.Kind<Z, A, B>, Tag>; } & TaggedEnum.GenericMatchers<Z>>; <Z extends TaggedEnum.WithGenerics<3>>(): Types.Simplify<{ readonly [Tag in Z[\"taggedEnum\"][\"_tag\"]]: <A, B, C>(args: TaggedEnum.Args<TaggedEnum.Kind<Z, A, B, C>, Tag, Extract<TaggedEnum.Kind<Z, A, B, C>, { readonly _tag: Tag; }>>) => TaggedEnum.Value<TaggedEnum.Kind<Z, A, B, C>, Tag>; } & TaggedEnum.GenericMatchers<Z>>; <Z extends TaggedEnum.WithGenerics<4>>(): Types.Simplify<{ readonly [Tag in Z[\"taggedEnum\"][\"_tag\"]]: <A, B, C, D>(args: TaggedEnum.Args<TaggedEnum.Kind<Z, A, B, C, D>, Tag, Extract<TaggedEnum.Kind<Z, A, B, C, D>, { readonly _tag: Tag; }>>) => TaggedEnum.Value<TaggedEnum.Kind<Z, A, B, C, D>, Tag>; } & TaggedEnum.GenericMatchers<Z>>; <A extends { readonly _tag: string; }>(): TaggedEnum.Constructor<A>; }\n```\n\n----------------------------------------\n\nTITLE: Accessing Channel Context Within Effect Context in TypeScript\nDESCRIPTION: This function enables access to the channel's context within the context of an effect. It takes a function that receives the environment context and returns an Effect, producing a Channel that combines both environments.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Channel-contextWithEffect.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const contextWithEffect: <Env, OutDone, OutErr, Env1>(f: (env: Context.Context<Env>) => Effect.Effect<OutDone, OutErr, Env1>) => Channel<never, unknown, OutErr, unknown, OutDone, unknown, Env | Env1>\n```\n\n----------------------------------------\n\nTITLE: Using Array.unzip to Convert Array of Pairs into Two Separate Arrays in TypeScript\nDESCRIPTION: Demonstrates how to use the Array.unzip function to transform an array of pairs into two separate arrays. It takes an iterable of tuples and splits them into two arrays, with the first elements in one array and the second elements in another.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Array-unzip.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Array } from \"effect\"\n\nconst result = Array.unzip([[1, \"a\"], [2, \"b\"], [3, \"c\"]])\nconsole.log(result) // [[1, 2, 3], ['a', 'b', 'c']]\n```\n\n----------------------------------------\n\nTITLE: SemigroupXor Declaration in TypeScript\nDESCRIPTION: This code snippet declares the `SemigroupXor` constant as a semigroup of boolean values. It leverages the `semigroup` module, likely from within the same `@effect/typeclass` package, to define the semigroup structure for booleans, specifically using exclusive OR as the combine operation.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/data-Boolean-SemigroupXor.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const SemigroupXor: semigroup.Semigroup<boolean>\n```\n\n----------------------------------------\n\nTITLE: Type Guard for UpstreamPullStrategy\nDESCRIPTION: Checks if the provided UpstreamPullStrategy is specifically a PullAfterAllEnqueued strategy. Returns a boolean and performs type narrowing.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/UpstreamPullStrategy-isPullAfterAllEnqueued.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const isPullAfterAllEnqueued: <A>(self: UpstreamPullStrategy<A>) => self is PullAfterAllEnqueued<A>\n```\n\n----------------------------------------\n\nTITLE: Type Guard for Reference Type in TypeScript\nDESCRIPTION: A type guard function that checks if a given unknown value is a Reference type. Used for type-safe runtime checking of Reference objects in the Effect.io context system.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Context-isReference.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const isReference: (u: unknown) => u is Reference<any, any>\n```\n\n----------------------------------------\n\nTITLE: Implementing Channel Output Mapping with Effects in TypeScript\nDESCRIPTION: Defines a function that transforms a Channel by applying an effectful function to each output element. The function supports generic type parameters for input/output elements, errors, and environment requirements.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Channel-mapOutEffect.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const mapOutEffect: { <OutElem, OutElem1, OutErr1, Env1>(f: (o: OutElem) => Effect.Effect<OutElem1, OutErr1, Env1>): <InElem, OutErr, InErr, OutDone, InDone, Env>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>) => Channel<OutElem1, InElem, OutErr1 | OutErr, InErr, OutDone, InDone, Env1 | Env>; <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutElem1, OutErr1, Env1>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>, f: (o: OutElem) => Effect.Effect<OutElem1, OutErr1, Env1>): Channel<OutElem1, InElem, OutErr | OutErr1, InErr, OutDone, InDone, Env | Env1>; }\n```\n\n----------------------------------------\n\nTITLE: Defining AvailablePerLine Interface in TypeScript\nDESCRIPTION: This code snippet defines the AvailablePerLine interface which extends the PageWidth.Proto interface. It includes properties for lineWidth and ribbonFraction that help in determining the layout constraints for text printing on a page. The lineWidth is a number that sets the maximum characters per line, while ribbonFraction is a float between 0 and 1 determining the usable width of the page. This interface is crucial for layout algorithms to ensure text does not overflow.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/PageWidth-AvailablePerLine.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface AvailablePerLine extends PageWidth.Proto {\n  readonly _tag: \"AvailablePerLine\"\n  /**\n   * The number of characters, including whitespace, that can fit on a single\n   * line.\n   */\n  readonly lineWidth: number\n  /**\n   * The fraction of the total page width that can be printed on. This allows\n   * limiting the length of printable text per line. Values must be between\n   * `0` and `1` (`0.4` to `1` is typical).\n   */\n  readonly ribbonFraction: number\n}\n```\n\n----------------------------------------\n\nTITLE: Defining maxOption Function - TypeScript\nDESCRIPTION: The maxOption function is defined to compute the maximum element in a TArray. It provides overloads to accept either the order parameter or both order and the array. The function outputs a STM containing an Option with the maximum value if it exists.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TArray-maxOption.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const maxOption: { <A>(order: Order.Order<A>): (self: TArray<A>) => STM.STM<Option.Option<A>>; <A>(self: TArray<A>, order: Order.Order<A>): STM.STM<Option.Option<A>>; }\n```\n\n----------------------------------------\n\nTITLE: Defining HTTP Layer for Runners in TypeScript\nDESCRIPTION: Creates an HTTP layer for the Runners services. It adds a route to the provided HttpRouter.Tag, defaulting to HttpRouter.Default. The layer requires various dependencies including Sharding, RpcSerialization, and HttpServer.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/HttpRunner-layer.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const layer: <I = HttpRouter.Default>(options: { readonly path: HttpRouter.PathInput; readonly routerTag?: HttpRouter.HttpRouter.TagClass<I, string, any, any>; readonly logAddress?: boolean | undefined; }) => Layer.Layer<Sharding.Sharding | Runners.Runners, never, RpcSerialization.RpcSerialization | ShardingConfig.ShardingConfig | Runners.RpcClientProtocol | HttpServer.HttpServer | MessageStorage | ShardStorage>\n```\n\n----------------------------------------\n\nTITLE: Creating Empty EventGroup in TypeScript\nDESCRIPTION: Defines an empty EventGroup that contains no events. This can be used as a starting point for building an event collection that represents a portion of your domain model.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/EventGroup-empty.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const empty: EventGroup<never>\n```\n\n----------------------------------------\n\nTITLE: Defining OpenAPI Specification Interface in TypeScript\nDESCRIPTION: This TypeScript interface defines the structure of an OpenAPI 3.1.0 specification. It includes various properties such as info, paths, components, and security requirements which are essential for representing the API documentation. Key properties include version, info for metadata, paths for API endpoints, components for reusable elements, and security for requirement definitions.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/OpenApi-OpenAPISpec.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface OpenAPISpec {\n  openapi: \"3.1.0\"\n  info: OpenAPISpecInfo\n  paths: OpenAPISpecPaths\n  components: OpenAPIComponents\n  security: Array<OpenAPISecurityRequirement>\n  tags: Array<OpenAPISpecTag>\n  servers?: Array<OpenAPISpecServer>\n}\n```\n\n----------------------------------------\n\nTITLE: Using HashSet.union in Effect.js with Various APIs\nDESCRIPTION: Demonstrates multiple ways to compute the union of two HashSets using different API styles: data-last/pipeable API, piping with the pipe function, and data-first API. The function computes the set union ( self ∪ that ) with O(n) time complexity.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/HashSet-union.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// Syntax\nimport { HashSet, pipe } from \"effect\"\n\n// with data-last, a.k.a. pipeable API\npipe(HashSet.make(1, 2, 3), HashSet.union(HashSet.make(3, 4, 5)))\n\n// or piped with the pipe function\nHashSet.make(1, 2, 3).pipe(HashSet.union(HashSet.make(3, 4, 5)))\n\n// or with data-first API\nHashSet.union(HashSet.make(1, 2, 3), HashSet.make(3, 4, 5))\n```\n\n----------------------------------------\n\nTITLE: HashSet.intersection Function Signature in TypeScript\nDESCRIPTION: The TypeScript type signature for the HashSet.intersection function, showing both the data-first and data-last (pipeable) overloads for working with HashSet collections.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/HashSet-intersection.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const intersection: { <A>(that: Iterable<A>): (self: HashSet<A>) => HashSet<A>; <A>(self: HashSet<A>, that: Iterable<A>): HashSet<A>; }\n```\n\n----------------------------------------\n\nTITLE: Defining splitLines Function in TypeScript for Channel Module\nDESCRIPTION: Declares a constant splitLines function that splits strings on newlines. It handles both Windows (\\r\\n) and UNIX (\\n) newline characters. The function returns a Channel that processes chunks of strings and outputs chunks of split lines.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Channel-splitLines.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const splitLines: <Err, Done>() => Channel<Chunk.Chunk<string>, Chunk.Chunk<string>, Err, Err, Done, Done, never>\n```\n\n----------------------------------------\n\nTITLE: Defining TRandom.Tag Service Tag in TypeScript\nDESCRIPTION: Defines the service tag used to access the TRandom functionality in the environment of an effect. This tag serves as a key for dependency injection in the Effect.ts ecosystem.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TRandom-Tag.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const Tag: Context.Tag<TRandom, TRandom>\n```\n\n----------------------------------------\n\nTITLE: Defining Slash Document Constant in TypeScript\nDESCRIPTION: Declares a constant named 'slash' that represents a document containing a single '/' character. It has a type parameter of 'never' indicating it doesn't contain any specific annotation type.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Doc-slash.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const slash: Doc<never>\n```\n\n----------------------------------------\n\nTITLE: Checking for InterruptedException in TypeScript\nDESCRIPTION: A function that checks if a given unknown value is an InterruptedException. This is useful for error handling and type narrowing in Effect applications.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Cause-isInterruptedException.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const isInterruptedException: (u: unknown) => u is InterruptedException\n```\n\n----------------------------------------\n\nTITLE: Implementing Semigroup First Function in TypeScript\nDESCRIPTION: Creates a Semigroup instance that implements the 'first' combining behavior, which always returns the first argument regardless of the second argument. This is a generic implementation that works with any type A.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Semigroup-first.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const first: <A = never>() => Semigroup<A>\n```\n\n----------------------------------------\n\nTITLE: SemigroupMin Type Declaration\nDESCRIPTION: Official type signature for the BigInt Semigroup Minimum implementation, indicating it works with BigInt values\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/data-BigInt-SemigroupMin.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const SemigroupMin: semigroup.Semigroup<bigint>\n```\n\n----------------------------------------\n\nTITLE: Get MutableList Length in TypeScript\nDESCRIPTION: This code snippet shows the TypeScript declaration for the `length` function. It takes a `MutableList<A>` as input and returns a number representing the length of the list. The function is part of the `effect` package's `MutableList` module.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/MutableList-length.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const length: <A>(self: MutableList<A>) => number\n```\n\n----------------------------------------\n\nTITLE: Checking Die Type in Effect-TS Cause Module\nDESCRIPTION: TypeScript type guard function that checks if a given Cause instance is specifically of the Die type. Used for type-safe error handling in the Effect.ts ecosystem. Returns a boolean value indicating whether the cause is a Die instance.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Cause-isDieType.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const isDieType: <E>(self: Cause<E>) => self is Die\n```\n\n----------------------------------------\n\nTITLE: Defining orElseIfEmptyChunk Function in TypeScript for Stream Module\nDESCRIPTION: Declares a function that produces the specified chunk if the stream is empty. It takes a lazy argument for a Chunk and returns a function that operates on a Stream, potentially adding new elements to it.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-orElseIfEmptyChunk.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const orElseIfEmptyChunk: { <A2>(chunk: LazyArg<Chunk.Chunk<A2>>): <A, E, R>(self: Stream<A, E, R>) => Stream<A2 | A, E, R>; <A, E, R, A2>(self: Stream<A, E, R>, chunk: LazyArg<Chunk.Chunk<A2>>): Stream<A | A2, E, R>; }\n```\n\n----------------------------------------\n\nTITLE: Defining Channel.zipRight Function Signature in TypeScript\nDESCRIPTION: TypeScript signature for the zipRight function that enables sequential composition of channels. The function supports both curried and non-curried versions, with an optional concurrent parameter. The resulting channel combines both channels sequentially, preserving the terminal value of the second channel.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Channel-zipRight.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const zipRight: { <Env1, InErr1, InElem1, InDone1, OutErr1, OutElem1, OutDone1>(that: Channel<OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>, options?: { readonly concurrent?: boolean | undefined; }): <Env, InErr, InElem, InDone, OutErr, OutElem, OutDone>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>) => Channel<OutElem1 | OutElem, InElem & InElem1, OutErr1 | OutErr, InErr & InErr1, OutDone1, InDone & InDone1, Env1 | Env>; <Env, InErr, InElem, InDone, OutErr, OutElem, OutDone, Env1, InErr1, InElem1, InDone1, OutErr1, OutElem1, OutDone1>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>, that: Channel<OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>, options?: { readonly concurrent?: boolean | undefined; }): Channel<OutElem | OutElem1, InElem & InElem1, OutErr | OutErr1, InErr & InErr1, OutDone1, InDone & InDone1, Env | Env1>; }\n```\n\n----------------------------------------\n\nTITLE: TypeScript Declaration for liftPredicate Function\nDESCRIPTION: This TypeScript declaration outlines the 'liftPredicate' function signature, converting predicates and refinements into functions that yield an Option. It illustrates the generic design of 'liftPredicate', accommodating various types (A, B) with constraints ensuring proper usage. Outputs are Options of type B when conditions are met or not.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Option-liftPredicate.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const liftPredicate: { <A, B extends A>(refinement: Refinement<A, B>): (a: A) => Option<B>; <B extends A, A = B>(predicate: Predicate<A>): (b: B) => Option<B>; <A, B extends A>(self: A, refinement: Refinement<A, B>): Option<B>; <B extends A, A = B>(self: B, predicate: Predicate<A>): Option<B>; }\n```\n\n----------------------------------------\n\nTITLE: Excluding RuntimeFlags with RuntimeFlagsPatch.exclude in TypeScript\nDESCRIPTION: Creates a RuntimeFlagsPatch which describes exclusion of the specified RuntimeFlag from the set of RuntimeFlags. This function can be used in both curried and non-curried forms.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/RuntimeFlagsPatch-exclude.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const exclude: { (flag: RuntimeFlags.RuntimeFlag): (self: RuntimeFlagsPatch) => RuntimeFlagsPatch; (self: RuntimeFlagsPatch, flag: RuntimeFlags.RuntimeFlag): RuntimeFlagsPatch; }\n```\n\n----------------------------------------\n\nTITLE: Implementing Cursor Down Movement in TypeScript using ANSI Escape Sequences\nDESCRIPTION: This function moves the cursor down by a specified number of lines (default 1) relative to the current cursor position. It has no effect if the cursor is already at the edge of the screen. The function returns an Ansi type, likely representing an ANSI escape sequence.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Ansi-cursorDown.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const cursorDown: (lines?: number) => Ansi\n```\n\n----------------------------------------\n\nTITLE: Defining Right Brace Document Constant in TypeScript\nDESCRIPTION: Declares a constant Doc type that represents a single right brace character ('}') for document formatting. The type parameter <never> indicates this Doc has no dependencies or requirements.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Doc-rbrace.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const rbrace: Doc<never>\n```\n\n----------------------------------------\n\nTITLE: Declaring yieldFlush Function in Typescript for Micro Module\nDESCRIPTION: This code snippet declares the yieldFlush constant which is a Micro type that returns void and never throws errors. It's used to flush any yielded effects that are waiting to be executed.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Micro-yieldFlush.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const yieldFlush: Micro<void, never, never>\n```\n\n----------------------------------------\n\nTITLE: Predicate.isRegExp Signature\nDESCRIPTION: This code snippet shows the type signature of the `Predicate.isRegExp` function. It declares a constant `isRegExp` which is a function that takes an unknown input and returns a boolean indicating whether the input is a RegExp object. The input parameter is typed as `unknown` and the return type is a type predicate `input is RegExp`.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Predicate-isRegExp.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const isRegExp: (input: unknown) => input is RegExp\n```\n\n----------------------------------------\n\nTITLE: Declaring failCauseSync Function in TypeScript\nDESCRIPTION: Function signature for failCauseSync that creates an Effect which fails with a lazily evaluated Cause. Takes a LazyArg function that returns a Cause<E> and produces an Effect that never succeeds (never) and may fail with error type E.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-failCauseSync.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const failCauseSync: <E>(evaluate: LazyArg<Cause.Cause<E>>) => Effect<never, E>\n```\n\n----------------------------------------\n\nTITLE: isTruthy Function Signature in TypeScript\nDESCRIPTION: Provides the TypeScript signature for the isTruthy function. It takes an unknown input and returns a boolean.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Predicate-isTruthy.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const isTruthy: (input: unknown) => boolean\n```\n\n----------------------------------------\n\nTITLE: Defining Command.Output Type in TypeScript\nDESCRIPTION: Defines the Command.Output type which configures the pipes established between the parent and child processes' stderr and stdout streams. This type is an alias for CommandOutput.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Command-Command.Output.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ntype Output = CommandOutput\n```\n\n----------------------------------------\n\nTITLE: Implementing Cartesian Product for Iterables in TypeScript\nDESCRIPTION: This function zips two Iterables crosswise, producing a new Iterable of tuples. It supports both curried and uncurried calling styles.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Iterable-cartesian.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const cartesian: { <B>(that: Iterable<B>): <A>(self: Iterable<A>) => Iterable<[A, B]>; <A, B>(self: Iterable<A>, that: Iterable<B>): Iterable<[A, B]>; }\n```\n\n----------------------------------------\n\nTITLE: TimeZone String Conversion Function Signature\nDESCRIPTION: The signature for the zoneToString function that converts a TimeZone object to a string representation. This function is available since version 3.6.0 of the effect package.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/DateTime-zoneToString.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const zoneToString: (self: TimeZone) => string\n```\n\n----------------------------------------\n\nTITLE: Creating an Exponential Backoff Scheduler in TypeScript\nDESCRIPTION: This TypeScript snippet declares a function `scheduleExponential` that creates a `MicroSchedule` object. It generates delays with an exponential backoff mechanism, where the delay is calculated based on a base time in milliseconds and an optional growth factor. This function is part of the Micro module and depends on the `MicroSchedule` type. Parameters include `baseMillis` for base time and an optional multiplier `factor`. Primarily used in retry and delay scenarios where progressive backoff is required.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Micro-scheduleExponential.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const scheduleExponential: (baseMillis: number, factor?: number) => MicroSchedule\n```\n\n----------------------------------------\n\nTITLE: Option.zipRight Signature in Effect\nDESCRIPTION: Defines the `zipRight` function which combines two `Option` types, returning the second `Option` if the first is `Some`. If the first `Option` is `None`, the function returns `None`. The function has two forms, a curried and a non-curried version.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Option-zipRight.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const zipRight: { <B>(that: Option<B>): <_>(self: Option<_>) => Option<B>; <X, B>(self: Option<X>, that: Option<B>): Option<B>; }\n```\n\n----------------------------------------\n\nTITLE: Trie.forEach Function Signature in TypeScript\nDESCRIPTION: Defines the signature of the Trie.forEach function. It can be called with either the trie as the first argument and the callback as the second, or with the callback first and returning a function that takes the trie.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Trie-forEach.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const forEach: { <V>(f: (value: V, key: string) => void): (self: Trie<V>) => void; <V>(self: Trie<V>, f: (value: V, key: string) => void): void; }\n```\n\n----------------------------------------\n\nTITLE: Defining Effect.io Cause Type Structure in TypeScript\nDESCRIPTION: Type definition for the Cause data structure that captures comprehensive failure information in Effect operations. The type handles empty cases, direct failures, defects (Die), interruptions, and both sequential and parallel error combinations.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Cause-Cause.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ntype Cause<E> = | Empty\n  | Fail<E>\n  | Die\n  | Interrupt\n  | Sequential<E>\n  | Parallel<E>\n```\n\n----------------------------------------\n\nTITLE: Checking for TextStream in DocStream Module (TypeScript)\nDESCRIPTION: The isTextStream function is a type guard that determines if a given DocStream is specifically a TextStream. It takes a DocStream as input and returns a boolean indicating whether it is a TextStream.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/DocStream-isTextStream.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const isTextStream: <A>(self: DocStream<A>) => self is TextStream<A>\n```\n\n----------------------------------------\n\nTITLE: Implementing DocTree Annotation Modification in TypeScript\nDESCRIPTION: Function signature for reAnnotate, which takes a transformation function and a DocTree instance to modify its annotation type from A to B. The function is provided in both curried and uncurried forms.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/DocTree-reAnnotate.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const reAnnotate: { <A, B>(f: (a: A) => B): (self: DocTree<A>) => DocTree<B>; <A, B>(self: DocTree<A>, f: (a: A) => B): DocTree<B>; }\n```\n\n----------------------------------------\n\nTITLE: Defining Empty String Constant in TypeScript\nDESCRIPTION: Declares a constant representing an empty string literal type in TypeScript. This constant provides a type-safe way to reference an empty string with the literal type \"\".\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/String-empty.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const empty: \"\"\n```\n\n----------------------------------------\n\nTITLE: Determining NoUpstream Status in UpstreamPullRequest\nDESCRIPTION: This function, 'isNoUpstream', takes an UpstreamPullRequest of generic type A and checks if it is a NoUpstream. It uses TypeScript's type predicate to narrow the type to NoUpstream when the function returns true. This is part of the Effect library's upstream pull request handling functionality.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/UpstreamPullRequest-isNoUpstream.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const isNoUpstream: <A>(self: UpstreamPullRequest<A>) => self is NoUpstream\n```\n\n----------------------------------------\n\nTITLE: Duration.fromIso Function Signature in TypeScript\nDESCRIPTION: TypeScript type declaration for the Duration.fromIso function. It takes an ISO8601 formatted string as input and returns an Option containing a Duration object if parsing succeeds.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Duration-fromIso.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const fromIso: (iso: string) => Option.Option<Duration>\n```\n\n----------------------------------------\n\nTITLE: Filtering Groups in GroupBy Structure - TypeScript\nDESCRIPTION: The filter function allows filtering of groups to be processed in a GroupBy structure. It takes a predicate function and returns a new GroupBy with only the groups that satisfy the predicate.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/GroupBy-filter.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const filter: { <K>(predicate: Predicate<NoInfer<K>>): <V, E, R>(self: GroupBy<K, V, E, R>) => GroupBy<K, V, E, R>; <K, V, E, R>(self: GroupBy<K, V, E, R>, predicate: Predicate<K>): GroupBy<K, V, E, R>; }\n```\n\n----------------------------------------\n\nTITLE: Trie.compact Function Signature in TypeScript\nDESCRIPTION: Provides the TypeScript function signature for the Trie.compact function. It takes a Trie of Options and returns a Trie with the None values filtered out.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Trie-compact.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const compact: <A>(self: Trie<Option<A>>) => Trie<A>\n```\n\n----------------------------------------\n\nTITLE: Implementing zipWith Function for Iterables in TypeScript\nDESCRIPTION: Defines the zipWith function that applies a given operation to pairs of elements from two Iterables. It handles cases where Iterables have different lengths by discarding excess elements from the longer Iterable.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Iterable-zipWith.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const zipWith: { <B, A, C>(that: Iterable<B>, f: (a: A, b: B) => C): (self: Iterable<A>) => Iterable<C>; <A, B, C>(self: Iterable<A>, that: Iterable<B>, f: (a: A, b: B) => C): Iterable<C>; }\n```\n\n----------------------------------------\n\nTITLE: Creating Entry Statistics in Effect Cache Module\nDESCRIPTION: The makeEntryStats function constructs a new EntryStats object with the specified load time in milliseconds. This is used to track statistics about entries in a cache system.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Cache-makeEntryStats.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const makeEntryStats: (loadedMillis: number) => EntryStats\n```\n\n----------------------------------------\n\nTITLE: Implementing Pipeable String.matchAll in TypeScript\nDESCRIPTION: Defines a pipeable version of the native matchAll string method. Takes a RegExp pattern and returns a function that accepts a string and returns an IterableIterator of RegExpMatchArray results. This allows the function to be used in functional programming pipelines.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/String-matchAll.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const matchAll: (regexp: RegExp) => (self: string) => IterableIterator<RegExpMatchArray>\n```\n\n----------------------------------------\n\nTITLE: Retrieving Fiber Read Locks with TReentrantLock in TypeScript\nDESCRIPTION: This function retrieves the number of acquired read locks for the current fiber. It operates within the STM (Software Transactional Memory) context and returns a number representing the count of read locks.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TReentrantLock-fiberReadLocks.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const fiberReadLocks: (self: TReentrantLock) => STM.STM<number>\n```\n\n----------------------------------------\n\nTITLE: Creating Empty Argument in Effect CLI (TypeScript)\nDESCRIPTION: Defines a constant 'none' that creates an empty argument. It returns an Args object of type void, indicating no arguments are present.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Args-none.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const none: Args<void>\n```\n\n----------------------------------------\n\nTITLE: Executing Effects Synchronously with Runtime.runSync in TypeScript\nDESCRIPTION: Defines a function for synchronous execution of effects that throws in case of errors or async boundaries. This function is intended to be used at the edges of a program to execute effects in a synchronous context.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Runtime-runSync.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const runSync: { <A, E, R>(runtime: Runtime<R>, effect: Effect.Effect<A, E, R>): A; <R>(runtime: Runtime<R>): <A, E>(effect: Effect.Effect<A, E, R>) => A; }\n```\n\n----------------------------------------\n\nTITLE: BigDecimal Format Function Signature\nDESCRIPTION: Type declaration for the format function that converts a BigDecimal value to a string representation.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/BigDecimal-format.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const format: (n: BigDecimal) => string\n```\n\n----------------------------------------\n\nTITLE: BigInt.sqrt Function Signature in TypeScript\nDESCRIPTION: This code snippet shows the TypeScript type signature for the BigInt.sqrt function. It takes a bigint as input and returns an Option of bigint.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/BigInt-sqrt.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const sqrt: (n: bigint) => Option.Option<bigint>\n```\n\n----------------------------------------\n\nTITLE: Declaring TimeoutException Class in TypeScript\nDESCRIPTION: Defines a class called TimeoutException that represents a checked exception which occurs when a timeout occurs. This class is part of the Effect-TS library's Micro module.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Micro-TimeoutException.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare class TimeoutException\n```\n\n----------------------------------------\n\nTITLE: Forbidden Class Declaration in Typescript\nDESCRIPTION: This code snippet shows the declaration of the `Forbidden` class in Typescript. It's part of the `ParseResult` module in the Effect library.  The class constructor takes an `AST.AST` object, an `actual` value of unknown type, and an optional `message` string as parameters, all of which are read-only properties of the class.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/ParseResult-Forbidden.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare class Forbidden { constructor(\n    readonly ast: AST.AST,\n    readonly actual: unknown,\n    readonly message?: string\n  ) }\n```\n\n----------------------------------------\n\nTITLE: Defining InvalidPubSubCapacityException Interface in TypeScript\nDESCRIPTION: This code snippet defines the InvalidPubSubCapacityException interface, which extends YieldableError. It includes a readonly _tag property and a symbol-keyed property for type identification.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Cause-InvalidPubSubCapacityException.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface InvalidPubSubCapacityException extends YieldableError {\n  readonly _tag: \"InvalidPubSubCapacityException\"\n  readonly [InvalidPubSubCapacityExceptionTypeId]: InvalidPubSubCapacityExceptionTypeId\n}\n```\n\n----------------------------------------\n\nTITLE: Symbol.isSymbol Example\nDESCRIPTION: This example demonstrates the usage of `Predicate.isSymbol` to check if a value is a symbol. It imports the necessary modules and uses `assert.deepStrictEqual` to verify the results. It showcases both a symbol and a string being tested, demonstrating the function's ability to distinguish between them.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Symbol-isSymbol.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { Predicate } from \"effect\"\n\nassert.deepStrictEqual(Predicate.isSymbol(Symbol.for(\"a\")), true)\nassert.deepStrictEqual(Predicate.isSymbol(\"a\"), false)\n```\n\n----------------------------------------\n\nTITLE: Defining AsSchema Type in TypeScript\nDESCRIPTION: Defines the AsSchema type, which is a type-level representation of the Schema.asSchema function. It takes a type parameter S and constructs a Schema type with specific type parameters.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Schema-Schema.AsSchema.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ntype AsSchema<S> = Schema<Type<S>, Encoded<S>, Context<S>>\n```\n\n----------------------------------------\n\nTITLE: Type Definition for BigDecimal.isZero Function\nDESCRIPTION: Type signature for the isZero function in the BigDecimal module, which takes a BigDecimal parameter and returns a boolean indicating whether the value is zero.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/BigDecimal-isZero.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const isZero: (n: BigDecimal) => boolean\n```\n\n----------------------------------------\n\nTITLE: Declaring NoSuchElementException Class in TypeScript\nDESCRIPTION: Defines a checked exception class that represents scenarios where an expected element could not be found. This class is part of the Micro module in the effect package.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Micro-NoSuchElementException.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare class NoSuchElementException\n```\n\n----------------------------------------\n\nTITLE: Extracting Errors from Cause in Effect-TS\nDESCRIPTION: The failures function extracts all recoverable errors of type E from a Cause object and returns them as a Chunk. This is useful for collecting all known failures for logging or combined error handling.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Cause-failures.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const failures: <E>(self: Cause<E>) => Chunk.Chunk<E>\n```\n\n----------------------------------------\n\nTITLE: Defining a Colon Document in Effect Printer TypeScript\nDESCRIPTION: Defines a constant named 'colon' that represents a document containing a single ':' character. This is a utility for creating formatted output with colons in the Effect Printer library.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Doc-colon.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const colon: Doc<never>\n```\n\n----------------------------------------\n\nTITLE: Defining Default Layout Options in TypeScript\nDESCRIPTION: This code snippet declares a constant defaultOptions of type Layout.Options. It represents the default layout options suitable for obtaining output without specifying detailed configurations.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Layout-defaultOptions.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const defaultOptions: Layout.Options\n```\n\n----------------------------------------\n\nTITLE: Creating ConfigProvider from JSON in TypeScript\nDESCRIPTION: Function signature for constructing a new ConfigProvider instance from a JSON object. Takes an unknown JSON input and returns a ConfigProvider instance.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/ConfigProvider-fromJson.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const fromJson: (json: unknown) => ConfigProvider\n```\n\n----------------------------------------\n\nTITLE: Creating and Draining a Stream\nDESCRIPTION: Shows how to create a stream of numbers and immediately drain it, executing the stream's effects without emitting values\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-drain.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst stream = Stream.range(1, 6).pipe(Stream.drain)\n\nEffect.runPromise(Stream.runCollect(stream)).then(console.log)\n// { _id: 'Chunk', values: [] }\n```\n\n----------------------------------------\n\nTITLE: Defining SingleProducerAsyncInput Interface in TypeScript\nDESCRIPTION: Defines a TypeScript interface for managing asynchronous data transmission with a single producer and multiple consumers. Features a buffer size of 1, producer waiting for consumer pickup, single-consumer element reading, and persistent error/done signals.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/SingleProducerAsyncInput-SingleProducerAsyncInput.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface SingleProducerAsyncInput<in out Err, in out Elem, in out Done>\n  extends AsyncInputProducer<Err, Elem, Done>, AsyncInputConsumer<Err, Elem, Done>\n{\n  readonly close: Effect.Effect<unknown>\n  readonly take: Effect.Effect<Exit.Exit<Elem, Either.Either<Done, Err>>>\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Minimum Semigroup in TypeScript\nDESCRIPTION: Defines a Semigroup that returns the minimum element when combining two values based on a provided Order instance. The function takes an Order<A> parameter and returns a Semigroup<A> implementation.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Semigroup-min.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const min: <A>(O: Order<A>) => Semigroup<A>\n```\n\n----------------------------------------\n\nTITLE: Checking Negative Values with BigDecimal.isNegative in TypeScript\nDESCRIPTION: Demonstrates how to use the isNegative function to check if a BigDecimal value is negative. The function returns true for values less than zero and false for zero or positive values.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/BigDecimal-isNegative.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { isNegative, unsafeFromString } from \"effect/BigDecimal\"\n\nassert.deepStrictEqual(isNegative(unsafeFromString(\"-1\")), true)\nassert.deepStrictEqual(isNegative(unsafeFromString(\"0\")), false)\nassert.deepStrictEqual(isNegative(unsafeFromString(\"1\")), false)\n```\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const isNegative: (n: BigDecimal) => boolean\n```\n\n----------------------------------------\n\nTITLE: Type Signature for Effect.transposeOption in TypeScript\nDESCRIPTION: This code block shows the TypeScript type signature for the Effect.transposeOption function. It takes an Option of an Effect and returns an Effect of an Option, preserving the type parameters for the value, error, and environment.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-transposeOption.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const transposeOption: <A = never, E = never, R = never>(self: Option.Option<Effect<A, E, R>>) => Effect<Option.Option<A>, E, R>\n```\n\n----------------------------------------\n\nTITLE: Type Checking for DocTree in TypeScript\nDESCRIPTION: A function that checks if a value is a DocTree instance. It returns true if the provided unknown value is a DocTree, and false otherwise.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/DocTree-isDocTree.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const isDocTree: (u: unknown) => u is DocTree<unknown>\n```\n\n----------------------------------------\n\nTITLE: Creating No-op FileSystem Layer in TypeScript\nDESCRIPTION: Function signature for creating a test-oriented no-op file system implementation. Takes a partial FileSystem object and returns a Layer containing FileSystem capabilities.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/FileSystem-layerNoop.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const layerNoop: (fileSystem: Partial<FileSystem>) => Layer<FileSystem>\n```\n\n----------------------------------------\n\nTITLE: Creating MutableHashSet from another MutableHashSet in TypeScript\nDESCRIPTION: Shows how to create a new MutableHashSet from an existing MutableHashSet instance. This demonstrates that MutableHashSet instances themselves are valid iterables that can be used as input to MutableHashSet.fromIterable.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/MutableHashSet-fromIterable.md#2025-04-11_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { MutableHashSet, pipe } from \"effect\"\n\nconsole.log(\n  pipe(\n    MutableHashSet.make(1, 2, 3, 4),\n    MutableHashSet.fromIterable,\n    Array.from\n  )\n) // Output: [1, 2, 3, 4]\n```\n\n----------------------------------------\n\nTITLE: Creating NonEmptyChunk in TypeScript - Effect IO Library\nDESCRIPTION: Function signature for creating a NonEmptyChunk from a single element. The function takes a single argument of any type A and returns a NonEmptyChunk containing that element.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Chunk-of.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const of: <A>(a: A) => NonEmptyChunk<A>\n```\n\n----------------------------------------\n\nTITLE: Using Boolean AND Operation in Effect Library\nDESCRIPTION: Demonstrates how to use the AND operation from Effect's Boolean module. The function combines two boolean values using logical AND, supporting both curried and uncurried function calls.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Boolean-and.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { and } from \"effect/Boolean\"\n\nassert.deepStrictEqual(and(true, true), true)\nassert.deepStrictEqual(and(true, false), false)\nassert.deepStrictEqual(and(false, true), false)\nassert.deepStrictEqual(and(false, false), false)\n```\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const and: { (that: boolean): (self: boolean) => boolean; (self: boolean, that: boolean): boolean; }\n```\n\n----------------------------------------\n\nTITLE: Checking Upstream Pull Strategy in TypeScript\nDESCRIPTION: Provides a utility function to determine if a specified value can be classified as an UpstreamPullStrategy, ensuring type safety and correctness. Requires TypeScript's type-checking capabilities. It takes an unknown parameter and returns a boolean indicating if the value is an UpstreamPullStrategy. No additional dependencies are required.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/UpstreamPullStrategy-isUpstreamPullStrategy.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const isUpstreamPullStrategy: (u: unknown) => u is UpstreamPullStrategy<unknown>\n```\n\n----------------------------------------\n\nTITLE: Type Signature of isEmptyReadonlyRecord in TypeScript\nDESCRIPTION: This snippet declares the type signature for the isEmptyReadonlyRecord function, ensuring that it accurately handles readonly records and returns the correct type. It highlights the use of generics to maintain type safety across different key-value pair scenarios in readonly records.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Record-isEmptyReadonlyRecord.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const isEmptyReadonlyRecord: <K extends string, A>(self: ReadonlyRecord<K, A>) => self is ReadonlyRecord<K, never>\n```\n\n----------------------------------------\n\nTITLE: Creating Date Config in Effect TypeScript\nDESCRIPTION: Function signature for creating a date configuration with an optional name parameter. Returns a Config instance that handles Date values.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Config-date.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const date: (name?: string) => Config<Date>\n```\n\n----------------------------------------\n\nTITLE: Declaring dieSync Function in Effect Stream Module - TypeScript\nDESCRIPTION: The dieSync function is declared to take a lazily evaluated defect as input, resulting in a stream that represents an error state (never successful). This is particularly useful for error handling in a functional programming context where streams are utilized. Dependencies include the LazyArg type for type inference.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-dieSync.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const dieSync: (evaluate: LazyArg<unknown>) => Stream<never>\n```\n\n----------------------------------------\n\nTITLE: Using BigInt.greaterThan for Comparison in TypeScript\nDESCRIPTION: A function that checks if one BigInt is greater than another. It returns true when the first argument is greater than the second, and false otherwise. The function supports both curried and non-curried calling styles.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/BigInt-greaterThan.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { greaterThan } from \"effect/BigInt\"\n\nassert.deepStrictEqual(greaterThan(2n, 3n), false)\nassert.deepStrictEqual(greaterThan(3n, 3n), false)\nassert.deepStrictEqual(greaterThan(4n, 3n), true)\n```\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const greaterThan: { (that: bigint): (self: bigint) => boolean; (self: bigint, that: bigint): boolean; }\n```\n\n----------------------------------------\n\nTITLE: Shuffling Arrays with TRandom in TypeScript\nDESCRIPTION: Uses the pseudo-random number generator to shuffle the elements of an iterable. Returns an STM effect that produces a shuffled array of the input elements.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TRandom-shuffle.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const shuffle: <A>(elements: Iterable<A>) => STM.STM<Array<A>, never, TRandom>\n```\n\n----------------------------------------\n\nTITLE: Retrieving Disabled Runtime Flags from RuntimeFlagsPatch in TypeScript\nDESCRIPTION: The disabledSet function extracts a ReadonlySet of RuntimeFlag values that are marked as disabled by a RuntimeFlagsPatch. This is useful for inspecting which runtime features have been explicitly disabled in a patch configuration.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/RuntimeFlagsPatch-disabledSet.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const disabledSet: (self: RuntimeFlagsPatch) => ReadonlySet<RuntimeFlags.RuntimeFlag>\n```\n\n----------------------------------------\n\nTITLE: Retrieving Valid Choices for CLI Primitive Types in TypeScript\nDESCRIPTION: The getChoices function takes a Primitive<A> as input and returns an Option<string> representing the valid choices for that primitive type, if any exist. This function is useful for generating help text or validating user input in CLI applications.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Primitive-getChoices.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const getChoices: <A>(self: Primitive<A>) => Option<string>\n```\n\n----------------------------------------\n\nTITLE: Defining Semigroup Last Function in TypeScript\nDESCRIPTION: A type-level function that creates a Semigroup which always returns the last argument during combination. Useful for resolving conflicts by prioritizing the most recent value.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Semigroup-last.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const last: <A = never>() => Semigroup<A>\n```\n\n----------------------------------------\n\nTITLE: Implementing Deferred.dieSync in TypeScript - Effect-TS\nDESCRIPTION: Function signature for dieSync method that kills a Deferred instance with a specified defect. The defect is propagated to all fibers waiting on the Deferred's value. Returns an Effect containing a boolean result.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Deferred-dieSync.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const dieSync: { (evaluate: LazyArg<unknown>): <A, E>(self: Deferred<A, E>) => Effect.Effect<boolean>; <A, E>(self: Deferred<A, E>, evaluate: LazyArg<unknown>): Effect.Effect<boolean>; }\n```\n\n----------------------------------------\n\nTITLE: Moving Cursor to Next Line with ANSI Escape Sequences in TypeScript\nDESCRIPTION: Function that returns an ANSI escape sequence to move the cursor to the beginning of the line a specified number of rows down. The rows parameter is optional and defaults to 1.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Ansi-cursorNextLine.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const cursorNextLine: (rows?: number) => Ansi\n```\n\n----------------------------------------\n\nTITLE: Declaring a Non-Recurring Schedule in TypeScript\nDESCRIPTION: This snippet declares a constant 'stop' of type Schedule, indicating that it is a non-recurring schedule that terminates immediately. It is defined within the context of the Effect framework and requires the type definitions from the 'effect' package.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Schedule-stop.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const stop: Schedule<void, unknown, never>\n```\n\n----------------------------------------\n\nTITLE: RegExp.isRegExp Type Definition\nDESCRIPTION: Type declaration for the isRegExp function, showing it accepts any unknown input and returns a type predicate indicating if the input is a RegExp object.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/RegExp-isRegExp.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const isRegExp: (input: unknown) => input is RegExp\n```\n\n----------------------------------------\n\nTITLE: Declaring the trimmed combinator in TypeScript Schema Module\nDESCRIPTION: This snippet defines a combinator named 'trimmed' which validates that a string schema has no leading or trailing whitespaces. It checks strings based on specific schema types without altering them. Requirements include the 'Annotations.Filter' type and existing schemas to validate against. Inputs are schema specifications with annotations, and it outputs a filter type that confirms compliance with the condition. It does not modify the input string, only validates it.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Schema-trimmed.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const trimmed: <S extends Schema.Any>(annotations?: Annotations.Filter<Schema.Type<S>>) => <A extends string>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>) => filter<S>\n```\n\n----------------------------------------\n\nTITLE: Querying Write Lock Count in TReentrantLock with STM (TypeScript)\nDESCRIPTION: This code snippet showcases the declaration of the `writeLocks` function, which is part of the `TReentrantLock` module in the `effect` library. It's purpose is to compute and return the number of write locks currently held by fibers using STM (Software Transactional Memory). The function takes a `TReentrantLock` instance as input and returns an `STM.STM<number>` representing the transactional computation result.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TReentrantLock-writeLocks.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const writeLocks: (self: TReentrantLock) => STM.STM<number>\n```\n\n----------------------------------------\n\nTITLE: Defining syncContext Function in TypeScript for Layer Construction\nDESCRIPTION: This snippet defines the syncContext function, which lazily constructs a layer from a specified value. The function takes an evaluate parameter of type LazyArg<Context.Context<A>> and returns a Layer<A>. It's used for creating layers that return one or more services.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Layer-syncContext.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const syncContext: <A>(evaluate: LazyArg<Context.Context<A>>) => Layer<A>\n```\n\n----------------------------------------\n\nTITLE: Combining Multiple Polling Metrics in TypeScript using Effect\nDESCRIPTION: Defines a utility function that combines multiple individual polling metrics into a single polling metric. The combined metric polls for, updates, and produces outputs from all individual metrics as an array.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/MetricPolling-collectAll.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const collectAll: <R, E, Out>(iterable: Iterable<MetricPolling<any, any, R, E, Out>>) => MetricPolling<Array<any>, Array<any>, R, E, Array<Out>>\n```\n\n----------------------------------------\n\nTITLE: STM failSync Declaration (TypeScript)\nDESCRIPTION: Declares the `failSync` function which constructs an `STM` (Software Transactional Memory) effect that fails with an error. The error is lazily evaluated by the provided `evaluate` function, taking no arguments and returning a value of type `E`. The returned `STM` effect cannot succeed (`never`) and may result in an error of type `E`.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/STM-failSync.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const failSync: <E>(evaluate: LazyArg<E>) => STM<never, E>\n```\n\n----------------------------------------\n\nTITLE: Array.findLast Method Signature in TypeScript\nDESCRIPTION: The complete type signature for the Array.findLast method, showing its various overloads for working with predicates, refinements, and options. It can be used with both curried and non-curried calling styles.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Array-findLast.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const findLast: { <A, B>(f: (a: NoInfer<A>, i: number) => Option.Option<B>): (self: Iterable<A>) => Option.Option<B>; <A, B extends A>(refinement: (a: NoInfer<A>, i: number) => a is B): (self: Iterable<A>) => Option.Option<B>; <A>(predicate: (a: NoInfer<A>, i: number) => boolean): (self: Iterable<A>) => Option.Option<A>; <A, B>(self: Iterable<A>, f: (a: A, i: number) => Option.Option<B>): Option.Option<B>; <A, B extends A>(self: Iterable<A>, refinement: (a: A, i: number) => a is B): Option.Option<B>; <A>(self: Iterable<A>, predicate: (a: A, i: number) => boolean): Option.Option<A>; }\n```\n\n----------------------------------------\n\nTITLE: Chunk.reverse Function Signature in Effect.ts\nDESCRIPTION: TypeScript signature for the Chunk.reverse function, showing how it preserves the chunk type parameters while reversing the element order.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Chunk-reverse.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const reverse: <S extends Chunk<any>>(self: S) => Chunk.With<S, Chunk.Infer<S>>\n```\n\n----------------------------------------\n\nTITLE: Subtracting BigDecimal Values Example\nDESCRIPTION: Demonstrates how to use the subtract function to perform subtraction between two BigDecimal values created from strings.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/BigDecimal-subtract.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { subtract, unsafeFromString } from \"effect/BigDecimal\"\n\nassert.deepStrictEqual(subtract(unsafeFromString(\"2\"), unsafeFromString(\"3\")), unsafeFromString(\"-1\"))\n```\n\n----------------------------------------\n\nTITLE: Declaring Fiber.pretty Function in TypeScript\nDESCRIPTION: Function declaration for pretty-printing a RuntimeFiber object. Takes a RuntimeFiber with generic type parameters for the success value (A) and error type (E), and returns an Effect that resolves to a string representation.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Fiber-pretty.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const pretty: <A, E>(self: RuntimeFiber<A, E>) => Effect.Effect<string>\n```\n\n----------------------------------------\n\nTITLE: Using BigInt.max Function in TypeScript\nDESCRIPTION: Example demonstrating how to use the max function to find the maximum between two bigint values. The function accepts two bigint parameters and returns the larger value.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/BigInt-max.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { max } from \"effect/BigInt\"\n\nassert.deepStrictEqual(max(2n, 3n), 3n)\n```\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const max: { (that: bigint): (self: bigint) => bigint; (self: bigint, that: bigint): bigint; }\n```\n\n----------------------------------------\n\nTITLE: Removing Multiple Entries from a Transactional Map in Effect-TS\nDESCRIPTION: The removeAll function deletes all entries associated with the specified keys from a TMap. It provides both curried and uncurried versions for flexibility in usage patterns within STM transactions.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TMap-removeAll.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const removeAll: { <K>(keys: Iterable<K>): <V>(self: TMap<K, V>) => STM.STM<void>; <K, V>(self: TMap<K, V>, keys: Iterable<K>): STM.STM<void>; }\n```\n\n----------------------------------------\n\nTITLE: Creating FiberMap Runtime Function in TypeScript\nDESCRIPTION: Function signature for creating an Effect run function that is backed by a FiberMap. It returns an Effect that can fork effects with specific keys and options, producing RuntimeFibers. The function supports generic types for the environment (R), key (K), error (E), and success (A) values.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/FiberMap-makeRuntime.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const makeRuntime: <R, K, E = unknown, A = unknown>() => Effect.Effect<(<XE extends E, XA extends A>(key: K, effect: Effect.Effect<XA, XE, R>, options?: (Runtime.RunForkOptions & { readonly onlyIfMissing?: boolean | undefined; }) | undefined) => Fiber.RuntimeFiber<XA, XE>), never, Scope.Scope | R>\n```\n\n----------------------------------------\n\nTITLE: Running Effect with Read Lock in TypeScript\nDESCRIPTION: This TypeScript snippet defines a function 'withReadLock' to execute a provided workflow while holding a read lock on a TReentrantLock instance. It allows executing an effect of generic type with a TReentrantLock, providing concurrency control. There are no additional dependencies other than the surrounding Effect module and TReentrantLock itself. Inputs include a TReentrantLock instance and an Effect to be executed. The output is an Effect encapsulating the result of the execution.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TReentrantLock-withReadLock.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const withReadLock: { (self: TReentrantLock): <A, E, R>(effect: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>; <A, E, R>(effect: Effect.Effect<A, E, R>, self: TReentrantLock): Effect.Effect<A, E, R>; }\n```\n\n----------------------------------------\n\nTITLE: Defining cursorBackward Function for ANSI Cursor Control in TypeScript\nDESCRIPTION: This function moves the cursor backward by a specified number of columns (default 1) relative to the current cursor position. It has no effect if the cursor is already at the edge of the screen. The function returns an AnsiDoc object.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/AnsiDoc-cursorBackward.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const cursorBackward: (columns?: number) => AnsiDoc\n```\n\n----------------------------------------\n\nTITLE: Defining Schema.Struct.Field Type in TypeScript\nDESCRIPTION: This snippet shows the type definition for Schema.Struct.Field. It is a union type that includes Schema.All and PropertySignature.All, useful for creating custom field constraints in struct schemas.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Schema-Struct.Field.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ntype Field = | Schema.All\n    | PropertySignature.All\n```\n\n----------------------------------------\n\nTITLE: TypeScript Signature for Doc.indent Function\nDESCRIPTION: This code shows the TypeScript type signature for the Doc.indent function. It demonstrates that the function can be used in two ways: either through currying with indent(n)(doc) or direct application with indent(doc, n).\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Doc-indent.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const indent: { (indent: number): <A>(self: Doc<A>) => Doc<A>; <A>(self: Doc<A>, indent: number): Doc<A>; }\n```\n\n----------------------------------------\n\nTITLE: Creating Empty Record in TypeScript using Effect-TS\nDESCRIPTION: Defines a function 'empty' that creates a new, empty record. It uses generic types to allow flexibility in key and value types. The function returns a Record type with non-literal keys.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Record-empty.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const empty: <K extends string | symbol = never, V = never>() => Record<ReadonlyRecord.NonLiteralKey<K>, V>\n```\n\n----------------------------------------\n\nTITLE: Defining Event Interface in TypeScript\nDESCRIPTION: Generic interface definition for Event type that includes type parameters for tag, payload, success, and error handling. The interface includes properties for type identification, event tag, primary key generation, payload handling with MsgPack schema support, and success/error states.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Event-Event.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface Event<\n  out Tag extends string,\n  in out Payload extends Schema.Schema.Any = typeof Schema.Void,\n  in out Success extends Schema.Schema.Any = typeof Schema.Void,\n  in out Error extends Schema.Schema.All = typeof Schema.Never\n> {\n  readonly [TypeId]: TypeId\n  readonly tag: Tag\n  readonly primaryKey: (payload: Schema.Schema.Type<Payload>) => string\n  readonly payload: Payload\n  readonly payloadMsgPack: MsgPack.schema<Payload>\n  readonly success: Success\n  readonly error: Error\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Date Primitive in TypeScript for @effect/cli\nDESCRIPTION: Declares a constant 'date' of type Primitive<Date> to represent dates in ISO-8601 format. This primitive can be used for parsing and validating date inputs in CLI applications.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Primitive-date.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const date: Primitive<Date>\n```\n\n----------------------------------------\n\nTITLE: Declaring Repeated Test Annotation in TypeScript\nDESCRIPTION: Defines a constant 'repeated' of type TestAnnotation<number> used to count repeated tests in the Effect testing framework.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TestAnnotation-repeated.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const repeated: TestAnnotation<number>\n```\n\n----------------------------------------\n\nTITLE: Defining Flatten Type for Document Processing in TypeScript\nDESCRIPTION: Defines the Flatten type which represents documents that may or may not change after flattening operations. This type is used to optimize layout algorithms by avoiding unnecessary Union creation for documents that don't change when flattened.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Flatten-Flatten.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ntype Flatten<A> = Flattened<A> | AlreadyFlat<A> | NeverFlat<A>\n```\n\n----------------------------------------\n\nTITLE: Defining BaseAttributes Interface for GenAI Telemetry in TypeScript\nDESCRIPTION: This code snippet defines the BaseAttributes interface for GenAI telemetry. It includes a single optional property 'system' which identifies the Generative AI product used in the instrumentation.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/AiTelemetry-GenAI.BaseAttributes.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface BaseAttributes {\n    /**\n     * The Generative AI product as identified by the client or server\n     * instrumentation.\n     */\n    readonly system?: (string & {}) | WellKnownSystem | null | undefined\n  }\n```\n\n----------------------------------------\n\nTITLE: Creating Typed Micro Failure Effect in TypeScript\nDESCRIPTION: Generates a Micro effect that explicitly fails with a specified error, ensuring type-safe error handling at compile time. The function creates a Fail variant of MicroCause with the error tracked at the type level.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Micro-fail.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const fail: <E>(error: E) => Micro<never, E>\n```\n\n----------------------------------------\n\nTITLE: Defining Text Primitive in TypeScript for Effect CLI\nDESCRIPTION: Declares a constant 'text' of type Primitive<string> to represent user-defined text input in a CLI application. This primitive can be used to handle textual input from users in Effect-based CLI tools.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Primitive-text.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const text: Primitive<string>\n```\n\n----------------------------------------\n\nTITLE: Defining Schema.headOrElse TypeScript Function\nDESCRIPTION: A function that retrieves the first element of a ReadonlyArray schema. If the array is empty, it returns a fallback value or fails. Supports both curried and direct function call styles.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Schema-headOrElse.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const headOrElse: { <S extends Schema.Any, A extends ReadonlyArray<unknown>>(fallback?: LazyArg<A[number]>): (self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>) => transform<S, SchemaClass<A[number]>>; <S extends Schema.Any, A extends ReadonlyArray<unknown>>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>, fallback?: LazyArg<A[number]>): transform<S, SchemaClass<A[number]>>; }\n```\n\n----------------------------------------\n\nTITLE: MutableHashSet.remove Function Signature in TypeScript\nDESCRIPTION: The TypeScript type signature for the MutableHashSet.remove function. It shows that the function can be used in both data-first and data-last styles, accepting a key to remove and returning the updated MutableHashSet.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/MutableHashSet-remove.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const remove: { <V>(key: V): (self: MutableHashSet<V>) => MutableHashSet<V>; <V>(self: MutableHashSet<V>, key: V): MutableHashSet<V>; }\n```\n\n----------------------------------------\n\nTITLE: Declaring Scoped Stream Operation in TypeScript\nDESCRIPTION: The `runForEachWhileScoped` is a scoped stream operation that runs a function on each element of the stream, with the ability to control the order of finalization in the Effect-TS framework. It requires a function that returns an Effect, specifying the conditions for continuing iteration or stopping. It supports two variations: one where the stream is curried, and another where it is provided directly. Inputs include a function and a stream, while outputs are scoped effects.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-runForEachWhileScoped.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const runForEachWhileScoped: { <A, E2, R2>(f: (a: A) => Effect.Effect<boolean, E2, R2>): <E, R>(self: Stream<A, E, R>) => Effect.Effect<void, E2 | E, Scope.Scope | R2 | R>; <A, E, R, E2, R2>(self: Stream<A, E, R>, f: (a: A) => Effect.Effect<boolean, E2, R2>): Effect.Effect<void, E | E2, Scope.Scope | R | R2>; }\n```\n\n----------------------------------------\n\nTITLE: MutableHashSet.empty Function Signature in TypeScript\nDESCRIPTION: Type declaration for the empty function in the MutableHashSet module, showing it returns a new MutableHashSet instance of the specified generic type.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/MutableHashSet-empty.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const empty: <K = never>() => MutableHashSet<K>\n```\n\n----------------------------------------\n\nTITLE: Retrieving Live Service for Tests in Effect Library (TypeScript)\nDESCRIPTION: Defines a constant 'live' that retrieves the Live service for tests. It returns an Effect that provides the TestLive implementation of the Live service, with no requirements and no error type.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TestServices-live.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const live: Effect.Effect<Live.TestLive, never, never>\n```\n\n----------------------------------------\n\nTITLE: Creating Auto-Reloadable Service from Config in TypeScript\nDESCRIPTION: Defines a function that creates a reloadable service from a layer, with automatic reloading based on a schedule extracted from the configuration. The service is constructed using a context tag and options including the layer and schedule configuration.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Reloadable-autoFromConfig.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const autoFromConfig: <I, S, E, In, R>(\n  tag: Context.Tag<I, S>,\n  options: {\n    readonly layer: Layer.Layer<I, E, In>;\n    readonly scheduleFromConfig: (context: Context.Context<In>) => Schedule.Schedule<unknown, unknown, R>;\n  }\n) => Layer.Layer<Reloadable<I>, E, R | In>\n```\n\n----------------------------------------\n\nTITLE: Calculating MutableHashSet Size in Effect - TypeScript\nDESCRIPTION: The purpose of this snippet is to calculate the number of unique elements present in a `MutableHashSet` using the `size` method. It relies on the `effect` package's `MutableHashSet` module, specifically focusing on the `size` function, which provides this functionality with a constant time complexity of O(1). The example demonstrates assertions confirming the count of elements in both an empty set and a populated set, showcasing the method's accuracy.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/MutableHashSet-size.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { MutableHashSet } from \"effect\"\nimport assert from \"node:assert/strict\"\n\nassert.equal(MutableHashSet.size(MutableHashSet.empty()), 0)\n\nassert.equal(\n  MutableHashSet.size(MutableHashSet.make(1, 2, 2, 3, 4, 3)),\n  4\n)\n```\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const size: <V>(self: MutableHashSet<V>) => number\n```\n\n----------------------------------------\n\nTITLE: Implementing Chunk.containsWith Function in TypeScript\nDESCRIPTION: This function returns a curried function that checks if a Chunk contains a given value using a provided isEquivalent function for comparison. It supports both curried and uncurried calling styles.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Chunk-containsWith.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const containsWith: <A>(isEquivalent: (self: A, that: A) => boolean) => { (a: A): (self: Chunk<A>) => boolean; (self: Chunk<A>, a: A): boolean; }\n```\n\n----------------------------------------\n\nTITLE: Declaring Right Parenthesis Document - TypeScript\nDESCRIPTION: TypeScript declaration for a Doc constant that represents a right parenthesis character. The Doc never type parameter indicates this document doesn't contain any annotations.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Doc-rparen.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const rparen: Doc<never>\n```\n\n----------------------------------------\n\nTITLE: BigDecimal Subtract Function Signature\nDESCRIPTION: TypeScript type declaration for the subtract function, showing its supported function signatures for both curried and non-curried usage.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/BigDecimal-subtract.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const subtract: { (that: BigDecimal): (self: BigDecimal) => BigDecimal; (self: BigDecimal, that: BigDecimal): BigDecimal; }\n```\n\n----------------------------------------\n\nTITLE: Implementing Channel.doneCollect Function in TypeScript\nDESCRIPTION: This function returns a new channel that collects all outputs of the original channel into a Chunk, bundling it with the terminal value. It's not safe for channels with large or unbounded output.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Channel-doneCollect.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const doneCollect: <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>) => Channel<never, InElem, OutErr, InErr, [Chunk.Chunk<OutElem>, OutDone], InDone, Env>\n```\n\n----------------------------------------\n\nTITLE: Defining a Constant for '<' Character in Effect Printer Doc Module\nDESCRIPTION: Declares a constant named 'langle' that represents a document containing a single '<' character. It's typed as a Doc with a 'never' type parameter, indicating it doesn't require any additional context.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Doc-langle.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const langle: Doc<never>\n```\n\n----------------------------------------\n\nTITLE: Checking WindDown RuntimeFlag Status in Effect.ts\nDESCRIPTION: A function that checks if the WindDown RuntimeFlag is enabled in a given RuntimeFlags object. Returns true if the flag is enabled, false otherwise. This is part of the Effect.ts library's runtime system.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/RuntimeFlags-windDown.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const windDown: (self: RuntimeFlags) => boolean\n```\n\n----------------------------------------\n\nTITLE: Function Signature for HashSet.partition in TypeScript\nDESCRIPTION: The type declaration for the HashSet.partition function, showing its overloaded implementations for both predicate functions and refinement type guards. Returns a tuple with excluded and satisfying sets.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/HashSet-partition.md#2025-04-11_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const partition: { <A, B extends A>(refinement: Refinement<NoInfer<A>, B>): (self: HashSet<A>) => [excluded: HashSet<Exclude<A, B>>, satisfying: HashSet<B>]; <A>(predicate: Predicate<NoInfer<A>>): (self: HashSet<A>) => [excluded: HashSet<A>, satisfying: HashSet<A>]; <A, B extends A>(self: HashSet<A>, refinement: Refinement<A, B>): [excluded: HashSet<Exclude<A, B>>, satisfying: HashSet<B>]; <A>(self: HashSet<A>, predicate: Predicate<A>): [excluded: HashSet<A>, satisfying: HashSet<A>]; }\n```\n\n----------------------------------------\n\nTITLE: Implementing Error Recovery with orElseSucceed in TypeScript\nDESCRIPTION: Type definition for a function that recovers from errors in a Micro effect by succeeding with a provided fallback value. The function is overloaded to support both curried and non-curried usage patterns.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Micro-orElseSucceed.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const orElseSucceed: { <B>(f: LazyArg<B>): <A, E, R>(self: Micro<A, E, R>) => Micro<A | B, never, R>; <A, E, R, B>(self: Micro<A, E, R>, f: LazyArg<B>): Micro<A | B, never, R>; }\n```\n\n----------------------------------------\n\nTITLE: Defining absurd Function in TypeScript\nDESCRIPTION: The absurd function is a utility for handling cases where a value of type never is encountered, indicating an impossible execution path. It's useful for specifying impossible cases in TypeScript code.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Function-absurd.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const absurd: <A>(_: never) => A\n```\n\n----------------------------------------\n\nTITLE: Cron.next Function Signature in TypeScript\nDESCRIPTION: Provides the TypeScript type signature for the Cron.next function, showing its parameters and return type.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Cron-next.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const next: (cron: Cron, startFrom?: DateTime.DateTime.Input) => Date\n```\n\n----------------------------------------\n\nTITLE: Declaring Empty TArray Function in TypeScript\nDESCRIPTION: The function 'empty' is declared to create an empty TArray utilizing STM (Software Transactional Memory) in TypeScript. There are no parameters needed and it returns an STM instance of TArray for generic type A. This function requires the 'effect' package and the 'STM' framework to work. It does not take any inputs and outputs an initialized empty TArray.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TArray-empty.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const empty: <A>() => STM.STM<TArray<A>>\n```\n\n----------------------------------------\n\nTITLE: Deduplicating Adjacent Array Elements in TypeScript\nDESCRIPTION: Demonstrates how to use the Array.dedupeAdjacentWith function to remove adjacent duplicate elements from an array based on a custom equivalence function. The example shows deduplication of an array of numbers.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Array-dedupeAdjacentWith.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Array } from \"effect\"\n\nconst result = Array.dedupeAdjacentWith([1, 1, 2, 2, 3, 3], (a, b) => a === b)\nconsole.log(result) // [1, 2, 3]\n```\n\n----------------------------------------\n\nTITLE: Checking if a Doc is a Union Type in TypeScript\nDESCRIPTION: The isUnion function is a type predicate that checks if a given Doc instance is of the Union variant. It returns true if the doc is a Union, false otherwise. This function is useful for type narrowing when working with the Doc type.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Doc-isUnion.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const isUnion: <A>(self: Doc<A>) => self is Union<A>\n```\n\n----------------------------------------\n\nTITLE: Demonstrating HashMap.HashMap.Entry Usage in TypeScript\nDESCRIPTION: This example shows how to use the HashMap.HashMap.Entry utility to extract the entry type from a HashMap. It declares a HashMap of string keys and number values, then uses the utility to infer the entry type.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/HashMap-HashMap.Entry.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { HashMap } from \"effect\"\n\ndeclare const hm: HashMap.HashMap<string, number>\n\n// $ExpectType [string, number]\ntype V = HashMap.HashMap.Entry<typeof hm>\n```\n\n----------------------------------------\n\nTITLE: Defining EntityAddress Schema in TypeScript\nDESCRIPTION: Declares a Schema type for EntityAddress that represents an entity's unique address within a cluster. The schema handles both encoding and decoding of EntityAddress types with no additional parameters required.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/EntityAddress-EntityAddressFromSelf.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const EntityAddressFromSelf: Schema.Schema<EntityAddress, EntityAddress, never>\n```\n\n----------------------------------------\n\nTITLE: Signature Declaration for isNotUndefined Function in TypeScript\nDESCRIPTION: The function 'isNotUndefined' is declared with a generic type 'A', ensuring that when a value is verified to be not 'undefined', it is explicitly excluded from the type 'undefined'. This enhances type safety in TypeScript code, particularly when handling optional values.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Predicate-isNotUndefined.md#2025-04-11_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const isNotUndefined: <A>(input: A) => input is Exclude<A, undefined>\n```\n\n----------------------------------------\n\nTITLE: Implementing Stream.zipAllSortedByKey in TypeScript\nDESCRIPTION: Type definition for a function that zips two sorted streams by key, combining values into tuples. The function handles potentially unbounded streams in constant space, requiring the input streams to be pre-sorted by distinct keys. Default values are used for missing entries.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-zipAllSortedByKey.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const zipAllSortedByKey: { \n  <A2, E2, R2, A, K>(options: { \n    readonly other: Stream<readonly [K, A2], E2, R2>; \n    readonly defaultSelf: A; \n    readonly defaultOther: A2; \n    readonly order: Order.Order<K>; \n  }): <E, R>(self: Stream<readonly [K, A], E, R>) => Stream<[K, [A, A2]], E2 | E, R2 | R>; \n  <K, A, E, R, A2, E2, R2>(self: Stream<readonly [K, A], E, R>, options: { \n    readonly other: Stream<readonly [K, A2], E2, R2>; \n    readonly defaultSelf: A; \n    readonly defaultOther: A2; \n    readonly order: Order.Order<K>; \n  }): Stream<[K, [A, A2]], E | E2, R | R2>; \n}\n```\n\n----------------------------------------\n\nTITLE: Declaring Integer Primitive\nDESCRIPTION: This code snippet declares a constant `integer` that represents a primitive number type in TypeScript. It is part of the Primitive module in the Effect-TS CLI package. The `integer` is defined as a `Primitive<number>` and serves as a type definition for integer values.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Primitive-integer.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const integer: Primitive<number>\n```\n\n----------------------------------------\n\nTITLE: XOR Function Type Signature in TypeScript\nDESCRIPTION: Type declaration for the XOR function showing its polymorphic nature. The function can be called either with two boolean arguments or in a curried form with single boolean arguments.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Boolean-xor.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const xor: { (that: boolean): (self: boolean) => boolean; (self: boolean, that: boolean): boolean; }\n```\n\n----------------------------------------\n\nTITLE: Declare OpenApi Transform Class\nDESCRIPTION: Declares a class named `Transform`. This class is part of the `OpenApi` module within the `@effect/platform` package. It is intended to provide functionality for transforming OpenAPI specifications. The class declaration provides the structure for its potential methods and properties that will implement the transformation logic.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/OpenApi-Transform.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\ndeclare class Transform\n```\n```\n\n----------------------------------------\n\nTITLE: Creating a Sink from a Push Function in Effect-TS TypeScript\nDESCRIPTION: The `fromPush` function creates a sink from a chunk processing function in Effect-TS. Dependencies include the Effect-TS library, with the primary function taking a push parameter of type `Effect.Effect`, which defines the effectful chunk processing logic. It uses generics for flexibility with input and output types and returns a Sink. This function is available since version 2.0.0.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Sink-fromPush.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\n```ts\ndeclare const fromPush: <In, L0, R0, L, R>(push: Effect.Effect<(_: Option.Option<Chunk.Chunk<In>>) => Effect.Effect<void, readonly [Either.Either<R0, L0>, Chunk.Chunk<L>], R>, never, R>) => Sink<R0, In, L, L0, Exclude<R, Scope.Scope>>\n```\n```\n\n----------------------------------------\n\nTITLE: Trie.insertMany Function Signature in TypeScript\nDESCRIPTION: This code snippet shows the TypeScript type signature for the Trie.insertMany function. It allows inserting multiple key-value pairs into a Trie, supporting both curried and non-curried versions.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Trie-insertMany.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const insertMany: { <V1>(iter: Iterable<[string, V1]>): <V>(self: Trie<V>) => Trie<V | V1>; <V1, V>(self: Trie<V>, iter: Iterable<[string, V1]>): Trie<V | V1>; }\n```\n\n----------------------------------------\n\nTITLE: Retrieving Last Element from MutableList in TypeScript\nDESCRIPTION: The `tail` function is designed to return the last element of a `MutableList`. It takes a `MutableList<A>` as a parameter and returns an element of type `A` or `undefined` if the list is empty. This function is part of the `effect` package's `MutableList` module. It does not have any external dependencies aside from the Effect TS library and is invoked to safely retrieve the last list element while handling the potential of the list being empty.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/MutableList-tail.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const tail: <A>(self: MutableList<A>) => A | undefined\n```\n\n----------------------------------------\n\nTITLE: Checking for Interruption-Only Causes in TypeScript Effect Library\nDESCRIPTION: The isInterruptedOnly function checks if a Cause contains only interruptions without other failure types like Fail or Die. This is useful for identifying pure cancellation scenarios in Effect programs.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Cause-isInterruptedOnly.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const isInterruptedOnly: <E>(self: Cause<E>) => boolean\n```\n\n----------------------------------------\n\nTITLE: Retrieving Cached Values with Resource.get in TypeScript\nDESCRIPTION: The Resource.get function retrieves the current value stored in a resource cache. It returns an Effect that resolves to the cached value of type A or an error of type E. This is a core function for working with cached resources in the Effect-TS ecosystem.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Resource-get.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const get: <A, E>(self: Resource<A, E>) => Effect.Effect<A, E>\n```\n\n----------------------------------------\n\nTITLE: Defining ANSI Erase Start Line Function in TypeScript\nDESCRIPTION: Declares a constant eraseStartLine of type Ansi. This function clears the current line from the cursor position to the start of the line, without changing the cursor position.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Ansi-eraseStartLine.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const eraseStartLine: Ansi\n```\n\n----------------------------------------\n\nTITLE: Statefully Mapping Over Stream Elements - TypeScript\nDESCRIPTION: This code snippet demonstrates the use of the Stream.mapAccum function from the Effect library to maintain a running total of numbers emitted from a stream. The incremental sum is returned along with the current state, which allows for cumulative operations on stream data. The example showcases how to utilize the function seamlessly within a Promise-based execution context.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-mapAccum.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Effect, Stream } from \"effect\"\n\nconst runningTotal = (stream: Stream.Stream<number>): Stream.Stream<number> =>\n  stream.pipe(Stream.mapAccum(0, (s, a) => [s + a, s + a]))\n\n// input:  0, 1, 2, 3, 4, 5, 6\nEffect.runPromise(Stream.runCollect(runningTotal(Stream.range(0, 6)))).then(\n  console.log\n)\n// { _id: \"Chunk\", values: [ 0, 1, 3, 6, 10, 15, 21 ] }\n```\n\n----------------------------------------\n\nTITLE: Concatenating Streams in Effect - TypeScript\nDESCRIPTION: This snippet demonstrates the concatenation of multiple streams into a single stream using the Effect library in TypeScript. It imports necessary constructs from the 'effect' library and shows how to create multiple streams, concatenate them using the `Stream.concatAll` method, and execute the resulting stream with `Effect.runPromise`. Required dependencies include the 'effect' library and its Stream module. The main input is a chunk of streams, and the output is a single concatenated stream.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-concatAll.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { Chunk, Effect, Stream } from \"effect\"\n\nconst s1 = Stream.make(1, 2, 3)\nconst s2 = Stream.make(4, 5)\nconst s3 = Stream.make(6, 7, 8)\n\nconst stream = Stream.concatAll(Chunk.make(s1, s2, s3))\n\nEffect.runPromise(Stream.runCollect(stream)).then(console.log)\n// {\n//   _id: 'Chunk',\n//   values: [\n//     1, 2, 3, 4,\n//     5, 6, 7, 8\n//   ]\n// }\n```\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const concatAll: <A, E, R>(streams: Chunk.Chunk<Stream<A, E, R>>) => Stream<A, E, R>\n```\n\n----------------------------------------\n\nTITLE: Defining Document Curly Brace Wrapper in TypeScript\nDESCRIPTION: Function signature for curlyBraced, which takes a Doc<A> as input and returns a new Doc<A> wrapped in curly braces. Used for formatting document content with curly brace delimiters.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Doc-curlyBraced.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const curlyBraced: <A>(self: Doc<A>) => Doc<A>\n```\n\n----------------------------------------\n\nTITLE: Defining ResponseAttributes Interface in TypeScript\nDESCRIPTION: This code snippet defines the `ResponseAttributes` interface in TypeScript, used for specifying telemetry attributes related to OpenAI responses. It includes optional properties for `serviceTier` and `systemFingerprint`, allowing for tracking of the service tier used and any changes in the Generative AI environment. The interface is part of the `OpenAiTelemetry` module within the `@effect/ai-openai` package.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/OpenAiTelemetry-OpenAiTelemetry.ResponseAttributes.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface ResponseAttributes {\n    /**\n     * The service tier used for the response.\n     */\n    readonly serviceTier?: string | null | undefined\n    /**\n     * A fingerprint to track any eventual change in the Generative AI\n     * environment.\n     */\n    readonly systemFingerprint?: string | null | undefined\n  }\n```\n\n----------------------------------------\n\nTITLE: Declaring End Function for Schedule Intervals in TypeScript\nDESCRIPTION: This TypeScript code snippet declares a constant `end` function which, when given an `Intervals` object, returns the end value of the latest interval. This function is used within the `ScheduleIntervals` module and requires the `Intervals` type to operate.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/ScheduleIntervals-end.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const end: (self: Intervals) => number\n```\n\n----------------------------------------\n\nTITLE: Extracting Request Error Type in TypeScript\nDESCRIPTION: A type utility that extracts the error type E from a Request<A, E> type. This is used for type-level programming to access the error channel of Request types.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Request-Request.Error.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ntype Error<T> = [T] extends [Request<infer _A, infer _E>] ? _E : never\n```\n\n----------------------------------------\n\nTITLE: Converting List to Array in Effect-TS\nDESCRIPTION: Function signature for converting a List data structure to a native JavaScript Array. Takes a List of generic type A as input and returns an Array of the same type.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/List-toArray.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const toArray: <A>(self: List<A>) => Array<A>\n```\n\n----------------------------------------\n\nTITLE: Match.when Type Definition\nDESCRIPTION: Type signature for the Match.when function showing its generic parameters and return type. Used for defining pattern matching conditions with support for primitive types and complex patterns.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Match-when.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const when: <R, const P extends Types.PatternPrimitive<R> | Types.PatternBase<R>, Ret, Fn extends (_: Types.WhenMatch<R, P>) => Ret>(pattern: P, f: Fn) => <I, F, A, Pr>(self: Matcher<I, F, R, A, Pr, Ret>) => Matcher<I, Types.AddWithout<F, Types.PForExclude<P>>, Types.ApplyFilters<I, Types.AddWithout<F, Types.PForExclude<P>>>, A | ReturnType<Fn>, Pr, Ret>\n```\n\n----------------------------------------\n\nTITLE: Doc.tupled Type Definition in TypeScript\nDESCRIPTION: The type signature for the Doc.tupled function, which takes an iterable of Doc<A> objects and returns a new Doc<A> object. This function is used to format a collection of documents with commas and parentheses.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Doc-tupled.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const tupled: <A>(docs: Iterable<Doc<A>>) => Doc<A>\n```\n\n----------------------------------------\n\nTITLE: Defining StringFromBase64 Schema in TypeScript\nDESCRIPTION: Declares a constant StringFromBase64 of type Schema that decodes a base64 (RFC4648) encoded string into a UTF-8 string. It takes a string input and produces a string output, with no error type specified.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Schema-StringFromBase64.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const StringFromBase64: Schema<string, string, never>\n```\n\n----------------------------------------\n\nTITLE: Effect.die Function Signature in TypeScript\nDESCRIPTION: TypeScript type signature for the Effect.die function, showing it accepts an unknown type parameter and returns an Effect of never type.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-die.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const die: (defect: unknown) => Effect<never>\n```\n\n----------------------------------------\n\nTITLE: TypeScript Type Definition for constFalse\nDESCRIPTION: Type signature for the constFalse function, defining it as a LazyArg that returns a boolean value.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Function-constFalse.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const constFalse: LazyArg<boolean>\n```\n\n----------------------------------------\n\nTITLE: Defining cursorLeft Function in TypeScript for ANSI Terminal Control\nDESCRIPTION: Declares a constant 'cursorLeft' of type Ansi that moves the cursor to the first column of the current row. This is part of the @effect/printer-ansi package and is used for terminal cursor manipulation.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Ansi-cursorLeft.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const cursorLeft: Ansi\n```\n\n----------------------------------------\n\nTITLE: TSet.reduceSTM Signature in Typescript\nDESCRIPTION: This code snippet presents the Typescript signature of the `reduceSTM` function. It demonstrates the function's ability to atomically fold over a `TSet` using a transactional function, accepting an initial zero value and a folding function that returns an `STM` computation.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TSet-reduceSTM.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const reduceSTM: { <Z, A, R, E>(zero: Z, f: (accumulator: Z, value: A) => STM.STM<Z, E, R>): (self: TSet<A>) => STM.STM<Z, E, R>; <Z, A, R, E>(self: TSet<A>, zero: Z, f: (accumulator: Z, value: A) => STM.STM<Z, E, R>): STM.STM<Z, E, R>; }\n```\n\n----------------------------------------\n\nTITLE: Creating Cookies Object from ReadonlyRecord in TypeScript\nDESCRIPTION: Function signature for creating a Cookies object from a ReadonlyRecord mapping string keys to Cookie values. This function allows converting a record-based representation of cookies into a Cookies object for further manipulation.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Cookies-fromReadonlyRecord.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const fromReadonlyRecord: (cookies: Record.ReadonlyRecord<string, Cookie>) => Cookies\n```\n\n----------------------------------------\n\nTITLE: Number Division Function Type Signature\nDESCRIPTION: Defines the type signature for the divide function, supporting both curried and direct parameter invocation with Option return type\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Number-divide.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const divide: { (that: number): (self: number) => Option<number>; (self: number, that: number): Option<number>; }\n```\n\n----------------------------------------\n\nTITLE: Implementing Relative Cursor Movement in TypeScript\nDESCRIPTION: The cursorMove function moves the cursor position by the specified number of columns and rows relative to the current position. It handles edge cases where the cursor is already at the screen's edge.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Ansi-cursorMove.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const cursorMove: (column: number, row?: number) => Ansi\n```\n\n----------------------------------------\n\nTITLE: Filtering Trie entries in Effect using Trie.filter\nDESCRIPTION: This code demonstrates how to filter entries out of a `Trie` using the `Trie.filter` function from the Effect library. It showcases filtering based on both value and key using a predicate function and asserts the expected results using `Equal.equals` for deep comparison of Trie structures.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Trie-filter.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { Trie, Equal } from \"effect\"\n\nconst trie = Trie.empty<number>().pipe(\n  Trie.insert(\"shells\", 0),\n  Trie.insert(\"sells\", 1),\n  Trie.insert(\"she\", 2)\n)\n\nconst trieMapV = Trie.empty<number>().pipe(\n  Trie.insert(\"she\", 2)\n)\n\nconst trieMapK = Trie.empty<number>().pipe(\n  Trie.insert(\"shells\", 0),\n  Trie.insert(\"sells\", 1)\n)\n\nassert.equal(Equal.equals(Trie.filter(trie, (v) => v > 1), trieMapV), true)\nassert.equal(Equal.equals(Trie.filter(trie, (_, k) => k.length > 3), trieMapK), true)\n```\n\n----------------------------------------\n\nTITLE: STM.collectSTM Signature in TypeScript\nDESCRIPTION: Defines the signature of the `collectSTM` function in TypeScript. This function filters and maps the value produced by an `STM` effect based on a provided partial function.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/STM-collectSTM.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const collectSTM: { <A, A2, E2, R2>(pf: (a: A) => Option.Option<STM<A2, E2, R2>>): <E, R>(self: STM<A, E, R>) => STM<A2, E2 | E, R2 | R>; <A, E, R, A2, E2, R2>(self: STM<A, E, R>, pf: (a: A) => Option.Option<STM<A2, E2, R2>>): STM<A2, E | E2, R | R2>; }\n```\n\n----------------------------------------\n\nTITLE: Declaring getSemigroupUnion function in TypeScript\nDESCRIPTION: This code snippet shows the type declaration for the `getSemigroupUnion` function. It takes a `Semigroup<A>` as input and returns a `Semigroup<ReadonlyRecord<string, A>>`. This allows combining records where the values are of type `A` using the provided semigroup.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/data-Record-getSemigroupUnion.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const getSemigroupUnion: <A>(value: semigroup.Semigroup<A>) => semigroup.Semigroup<Record.ReadonlyRecord<string, A>>\n```\n\n----------------------------------------\n\nTITLE: Waiting for Fiber Completion in TypeScript using Effect\nDESCRIPTION: The awaitEmpty function waits for the fiber in the FiberHandle to complete. It returns an Effect that resolves to void if the fiber completes successfully, or rejects with the fiber's error if it fails.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/FiberHandle-awaitEmpty.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const awaitEmpty: <A, E>(self: FiberHandle<A, E>) => Effect.Effect<void, E>\n```\n\n----------------------------------------\n\nTITLE: Type Utility for Mutable Structures in TypeScript\nDESCRIPTION: This signature defines a type utility `Mutable` that transforms readonly properties of a given type `T` into mutable ones using TypeScript mapped types. There are no external dependencies other than TypeScript itself. The primary function is to iterate over all properties of a type `T` and remove any readonly modifiers, thereby making them mutable.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Types-Mutable.md#2025-04-11_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\ntype Mutable<T> = {\n  -readonly [P in keyof T]: T[P]\n}\n```\n\n----------------------------------------\n\nTITLE: Checking Completion Status in Take - TypeScript\nDESCRIPTION: Checks whether a given 'Take' instance is complete using the 'isDone' method. This function returns a boolean, indicating the completion status of a 'Take' object 'self'. There are no explicit dependencies, but it requires the 'Take' structure and assumes TypeScript is set up properly.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Take-isDone.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const isDone: <A, E>(self: Take<A, E>) => boolean\n```\n\n----------------------------------------\n\nTITLE: TypeScript Signature of Function.constant\nDESCRIPTION: Provides the TypeScript type signature for the constant function. It shows that the function takes a value of type A and returns a lazy argument of type A.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Function-constant.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const constant: <A>(value: A) => LazyArg<A>\n```\n\n----------------------------------------\n\nTITLE: Defining ReadonlyMailbox Interface in TypeScript\nDESCRIPTION: This code snippet defines the ReadonlyMailbox interface, which extends Effect and Inspectable. It includes methods for reading messages, clearing the mailbox, and checking its status.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Mailbox-ReadonlyMailbox.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface ReadonlyMailbox<out A, out E = never>\n  extends Effect<readonly [messages: Chunk<A>, done: boolean], E>, Inspectable\n{\n  readonly [ReadonlyTypeId]: ReadonlyTypeId\n  /**\n   * Take all messages from the mailbox, returning an empty Chunk if the mailbox\n   * is empty or done.\n   */\n  readonly clear: Effect<Chunk<A>, E>\n  /**\n   * Take all messages from the mailbox, or wait for messages to be available.\n   *\n   * If the mailbox is done, the `done` flag will be `true`. If the mailbox\n   * fails, the Effect will fail with the error.\n   */\n  readonly takeAll: Effect<readonly [messages: Chunk<A>, done: boolean], E>\n  /**\n   * Take a specified number of messages from the mailbox. It will only take\n   * up to the capacity of the mailbox.\n   *\n   * If the mailbox is done, the `done` flag will be `true`. If the mailbox\n   * fails, the Effect will fail with the error.\n   */\n  readonly takeN: (n: number) => Effect<readonly [messages: Chunk<A>, done: boolean], E>\n  /**\n   * Take a single message from the mailbox, or wait for a message to be\n   * available.\n   *\n   * If the mailbox is done, it will fail with `NoSuchElementException`. If the\n   * mailbox fails, the Effect will fail with the error.\n   */\n  readonly take: Effect<A, E | NoSuchElementException>\n  /** Wait for the mailbox to be done. */\n  readonly await: Effect<void, E>\n  /**\n   * Check the size of the mailbox.\n   *\n   * If the mailbox is complete, it will return `None`.\n   */\n  readonly size: Effect<Option<number>>\n  /**\n   * Check the size of the mailbox.\n   *\n   * If the mailbox is complete, it will return `None`.\n   */\n  readonly unsafeSize: () => Option<number>\n}\n```\n\n----------------------------------------\n\nTITLE: Option Bind Function Signature in Effect\nDESCRIPTION: This code snippet shows the TypeScript declaration of the `bind` function within Effect's `Option` module. It illustrates the function's type signature, highlighting how it takes a name, a function that produces an `Option` value, and returns a new `Option` with the new value bound to the specified name. The signature uses generics to ensure type safety.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Option-bind.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const bind: { <N extends string, A extends object, B>(name: Exclude<N, keyof A>, f: (a: NoInfer<A>) => Option<B>): (self: Option<A>) => Option<{ [K in N | keyof A]: K extends keyof A ? A[K] : B; }>; <A extends object, N extends string, B>(self: Option<A>, name: Exclude<N, keyof A>, f: (a: NoInfer<A>) => Option<B>): Option<{ [K in N | keyof A]: K extends keyof A ? A[K] : B; }>; }\n```\n\n----------------------------------------\n\nTITLE: Retrieving Chunk Size in TypeScript with Effect-TS\nDESCRIPTION: This function retrieves the number of elements in a Chunk data structure. It takes a Chunk as input and returns a number representing its size. Available since version 2.0.0 of the effect package.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Chunk-size.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const size: <A>(self: Chunk<A>) => number\n```\n\n----------------------------------------\n\nTITLE: Type Definition for isBufferSliding Function in TypeScript\nDESCRIPTION: Defines a type guard function that checks if a given MergeStrategy is specifically a BufferSliding strategy. Returns true if the strategy is BufferSliding, false otherwise.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/MergeStrategy-isBufferSliding.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const isBufferSliding: (self: MergeStrategy) => self is BufferSliding\n```\n\n----------------------------------------\n\nTITLE: Duration.formatIso Function Signature in TypeScript\nDESCRIPTION: The type signature for the formatIso function, which takes a DurationInput parameter and returns an Option containing a string representation of the duration in ISO8601 format.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Duration-formatIso.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const formatIso: (self: DurationInput) => Option.Option<string>\n```\n\n----------------------------------------\n\nTITLE: Defining Samples Constant in TestServices Module (TypeScript)\nDESCRIPTION: Declares a constant 'samples' as an Effect that produces a number. This constant represents the number of sufficient samples to check for a random variable. It has no error type and no environment dependencies.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TestServices-samples.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const samples: Effect.Effect<number, never, never>\n```\n\n----------------------------------------\n\nTITLE: Signature of RepeatEffect Function in TypeScript\nDESCRIPTION: This snippet provides the TypeScript type signature for the `repeatEffect` function, which takes an effect and returns a corresponding stream. The function is generic and can handle different value types, error types, and environment types.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-repeatEffect.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const repeatEffect: <A, E, R>(effect: Effect.Effect<A, E, R>) => Stream<A, E, R>\n```\n\n----------------------------------------\n\nTITLE: Implementing ANSI Screen Erase Up Function in TypeScript\nDESCRIPTION: Defines a constant 'eraseUp' of type Ansi that clears the screen content from the current cursor position to the beginning of the screen. The cursor position remains unchanged after the operation.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Ansi-eraseUp.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const eraseUp: Ansi\n```\n\n----------------------------------------\n\nTITLE: Declaring Valid Date Schema Class in TypeScript\nDESCRIPTION: The 'ValidDateFromSelf' class ensures that only Date objects representing valid dates are accepted within the schema validation process. This class, introduced in version v3.10.0, is a part of the Schema module under the 'effect' package and enforces strict validity checks to reject improperly formed dates.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Schema-ValidDateFromSelf.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare class ValidDateFromSelf\n```\n\n----------------------------------------\n\nTITLE: Defining a Shallow Interface in TypeScript\nDESCRIPTION: This TypeScript snippet defines an interface called `Shallow`, used for optimizing document processing. It represents a \"Shallow\" operation that focuses on the concise concatenation of text nodes. The `_tag` is a constant key that specifies the action type. This interface requires no dependencies and serves as a type identifier within the module.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Optimize-Shallow.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport interface Shallow {\\n  readonly _tag: \\\"Shallow\\\"\\n}\n```\n\n----------------------------------------\n\nTITLE: TypeScript Function Signature for HashSet.map\nDESCRIPTION: The type definition for the HashSet.map function, showing its polymorphic nature. It supports both data-first and data-last calling conventions, mapping from type A to type B.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/HashSet-map.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const map: { <A, B>(f: (a: A) => B): (self: HashSet<A>) => HashSet<B>; <A, B>(self: HashSet<A>, f: (a: A) => B): HashSet<B>; }\n```\n\n----------------------------------------\n\nTITLE: Creating Boolean Arguments in Effect CLI\nDESCRIPTION: Function signature for creating boolean arguments in the Effect CLI framework. The function accepts optional base argument configuration and returns an Args type containing a boolean value. The argument name defaults to 'boolean' if not specified.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Args-boolean.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const boolean: (options?: Args.BaseArgsConfig) => Args<boolean>\n```\n\n----------------------------------------\n\nTITLE: Negating BigDecimal Values in TypeScript\nDESCRIPTION: Demonstrates the usage of the negate function from the BigDecimal module. It shows how to negate positive and negative BigDecimal values using the negate and unsafeFromString functions.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/BigDecimal-negate.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { negate, unsafeFromString } from \"effect/BigDecimal\"\n\nassert.deepStrictEqual(negate(unsafeFromString(\"3\")), unsafeFromString(\"-3\"))\nassert.deepStrictEqual(negate(unsafeFromString(\"-6\")), unsafeFromString(\"6\"))\n```\n\n----------------------------------------\n\nTITLE: Array.window Function Type Definition\nDESCRIPTION: TypeScript type declaration for the Array.window function, showing its function signatures for both curried and non-curried usage with generic type support.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Array-window.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const window: { (n: number): <A>(self: Iterable<A>) => Array<Array<A>>; <A>(self: Iterable<A>, n: number): Array<Array<A>>; }\n```\n\n----------------------------------------\n\nTITLE: Defining empty RuntimeFlagsPatch constant in TypeScript\nDESCRIPTION: Declaration of the empty RuntimeFlagsPatch constant that represents a patch with no modifications to runtime flags. This is used as a starting point when building runtime flag patches.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/RuntimeFlagsPatch-empty.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const empty: RuntimeFlagsPatch\n```\n\n----------------------------------------\n\nTITLE: Implementing Fiber.zipLeft in TypeScript for the Effect Library\nDESCRIPTION: Function signature for zipLeft which combines two fibers, keeping the output of the first fiber but combining error types. It has two possible call signatures - curried and non-curried versions.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Fiber-zipLeft.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const zipLeft: { <A2, E2>(that: Fiber<A2, E2>): <A, E>(self: Fiber<A, E>) => Fiber<A, E2 | E>; <A, E, A2, E2>(self: Fiber<A, E>, that: Fiber<A2, E2>): Fiber<A, E | E2>; }\n```\n\n----------------------------------------\n\nTITLE: Using SK Combinator Function in TypeScript\nDESCRIPTION: Demonstrates how to use the SK combinator function from the effect/Function module. The function discards its first argument and returns the second.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Function-SK.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { SK } from \"effect/Function\";\n\nassert.deepStrictEqual(SK(0, \"hello\"), \"hello\")\n```\n\n----------------------------------------\n\nTITLE: Flipping Success and Failure Channels in STM - TypeScript\nDESCRIPTION: The function 'flip' inverts the success and failure channels of a transactional effect. Its primary use is to allow manipulation of the error channel with all available methods. The flip function's signature indicates it takes an `STM<A, E, R>` and returns an `STM<E, A, R>`. This transformation aids in error handling before potentially flipping back to the original structure.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/STM-flip.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const flip: <A, E, R>(self: STM<A, E, R>) => STM<E, A, R>\n```\n\n----------------------------------------\n\nTITLE: Retrieving Fibers from FiberMap in TypeScript\nDESCRIPTION: The unsafeGet function is used to retrieve a fiber from a FiberMap. It takes a key and returns an Option of a RuntimeFiber. This function can be called with either the key first or the FiberMap first.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/FiberMap-unsafeGet.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const unsafeGet: { <K>(key: K): <A, E>(self: FiberMap<K, A, E>) => Option.Option<Fiber.RuntimeFiber<A, E>>; <K, A, E>(self: FiberMap<K, A, E>, key: K): Option.Option<Fiber.RuntimeFiber<A, E>>; }\n```\n\n----------------------------------------\n\nTITLE: Implementing Stateful Mapping with mapAccum in TypeScript\nDESCRIPTION: The mapAccum function statefully maps over a chunk, producing new elements of type B. It takes an initial state, a transformation function, and the chunk to be mapped. The function returns a tuple containing the final state and the new chunk.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Chunk-mapAccum.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const mapAccum: {\n  <S, A, B>(s: S, f: (s: S, a: A) => readonly [S, B]): (self: Chunk<A>) => [S, Chunk<B>];\n  <S, A, B>(self: Chunk<A>, s: S, f: (s: S, a: A) => readonly [S, B]): [S, Chunk<B>];\n}\n```\n\n----------------------------------------\n\nTITLE: Trie.isEmpty Function Signature in TypeScript\nDESCRIPTION: This code snippet shows the TypeScript signature for the Trie.isEmpty function. It takes a Trie of any value type and returns a boolean indicating whether the Trie is empty.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Trie-isEmpty.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const isEmpty: <V>(self: Trie<V>) => boolean\n```\n\n----------------------------------------\n\nTITLE: Creating Streams from TPubSub in TypeScript\nDESCRIPTION: The `fromTPubSub` function constructs a stream from a given TPubSub object of type A within the Effect-TS library. The function signature indicates that it takes a TPubSub parameter and returns a Stream of the same type, facilitating the use of pub-sub patterns in reactive programming. It requires the Effect-TS package, specifically the Stream module, and operates since version 3.10.0. This function is useful in scenarios where reactive data flow is needed, with the input being a TPubSub instance and the output being the constructed Stream.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-fromTPubSub.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const fromTPubSub: <A>(pubsub: TPubSub<A>) => Stream<A>\n```\n\n----------------------------------------\n\nTITLE: Defining Layout.smart Function Signature in TypeScript\nDESCRIPTION: This code snippet provides the TypeScript function signature for the Layout.smart function. It shows that the function can be called with options and a document, or with a document and options, returning a DocStream.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Layout-smart.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const smart: { (options: Layout.Options): <A>(self: Doc<A>) => DocStream<A>; <A>(self: Doc<A>, options: Layout.Options): DocStream<A>; }\n```\n\n----------------------------------------\n\nTITLE: Take.fromEffect in Typescript\nDESCRIPTION: The `fromEffect` function converts an `Effect<A, E, R>` into an `Effect<Take<A, E>, never, R>`. This function is useful when you need to handle both successful and failed outcomes of an Effect within a stream or other context that requires a unified representation of results. Errors from the original effect are converted to `Take.failCause`.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Take-fromEffect.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const fromEffect: <A, E, R>(effect: Effect.Effect<A, E, R>) => Effect.Effect<Take<A, E>, never, R>\n```\n\n----------------------------------------\n\nTITLE: Declaring unsafeFromArray Function in TypeScript\nDESCRIPTION: This function wraps a readonly array into a Chunk without copying. It's important to note that this operation is unsafe for mutable arrays. The function takes a readonly array of type A and returns a Chunk of the same type.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Chunk-unsafeFromArray.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const unsafeFromArray: <A>(self: ReadonlyArray<A>) => Chunk<A>\n```\n\n----------------------------------------\n\nTITLE: Defining Stream.peel Function in TypeScript\nDESCRIPTION: Defines the peel function for the Stream module. This function peels off material from a stream to construct a value using a provided Sink, returning both the constructed value and the remaining stream in a scoped context.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-peel.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const peel: { <A2, A, E2, R2>(sink: Sink.Sink<A2, A, A, E2, R2>): <E, R>(self: Stream<A, E, R>) => Effect.Effect<[A2, Stream<A, E, never>], E2 | E, Scope.Scope | R2 | R>; <A, E, R, A2, E2, R2>(self: Stream<A, E, R>, sink: Sink.Sink<A2, A, A, E2, R2>): Effect.Effect<[A2, Stream<A, E, never>], E | E2, Scope.Scope | R | R2>; }\n```\n\n----------------------------------------\n\nTITLE: Initializing Cursor Hide Operation in TypeScript\nDESCRIPTION: Defines a constant for hiding the cursor in terminal applications using ANSI escape sequences. This is part of the Effect-TS printer-ansi package's AnsiDoc module.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/AnsiDoc-cursorHide.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const cursorHide: AnsiDoc\n```\n\n----------------------------------------\n\nTITLE: Erasing Lines with AnsiDoc in TypeScript\nDESCRIPTION: The eraseLines function is used to erase a specified number of rows from the current cursor position upwards in an ANSI-compatible terminal. It takes a number parameter and returns an AnsiDoc object.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/AnsiDoc-eraseLines.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const eraseLines: (rows: number) => AnsiDoc\n```\n\n----------------------------------------\n\nTITLE: TypeScript Signature for Effect.logTrace Function\nDESCRIPTION: Provides the TypeScript type signature for the Effect.logTrace function. It shows that the function accepts any number of arguments and returns an Effect with void result, never error, and never requirements.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-logTrace.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const logTrace: (...message: ReadonlyArray<any>) => Effect<void, never, never>\n```\n\n----------------------------------------\n\nTITLE: Filtering with Cause Failure in TypeScript Effect Module\nDESCRIPTION: Function signature for filterOrFailCause that allows filtering Effect values with custom failure handling through MicroCause. It supports both refinement and predicate-based filtering with type narrowing capabilities.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Micro-filterOrFailCause.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const filterOrFailCause: { <A, B extends A, E2>(refinement: Refinement<A, B>, orFailWith: (a: NoInfer<A>) => MicroCause<E2>): <E, R>(self: Micro<A, E, R>) => Micro<B, E2 | E, R>; <A, E2>(predicate: Predicate<NoInfer<A>>, orFailWith: (a: NoInfer<A>) => MicroCause<E2>): <E, R>(self: Micro<A, E, R>) => Micro<A, E2 | E, R>; <A, E, R, B extends A, E2>(self: Micro<A, E, R>, refinement: Refinement<A, B>, orFailWith: (a: A) => MicroCause<E2>): Micro<B, E | E2, R>; <A, E, R, E2>(self: Micro<A, E, R>, predicate: Predicate<A>, orFailWith: (a: A) => MicroCause<E2>): Micro<A, E | E2, R>; }\n```\n\n----------------------------------------\n\nTITLE: Defining DocStream.CharStream Interface in TypeScript\nDESCRIPTION: Defines a TypeScript interface for representing a document stream that contains a single character. The interface extends DocStream.Variance and includes properties for the stream type tag, the character value, and the next document stream.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/DocStream-CharStream.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface CharStream<A> extends DocStream.Variance<A> {\n  readonly _tag: \"CharStream\"\n  readonly char: string\n  readonly stream: DocStream<A>\n}\n```\n\n----------------------------------------\n\nTITLE: Declaring DateTime.Utc Schema for SQL Date Serialization in TypeScript\nDESCRIPTION: Defines a schema for DateTime.Utc values that are serialized as date strings in the YYYY-MM-DD format. This is part of the @effect/sql package's Model module.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Model-Date.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const Date: Date\n```\n\n----------------------------------------\n\nTITLE: Converting Numbers to BigDecimal with unsafeFromNumber in TypeScript\nDESCRIPTION: Demonstrates how to convert JavaScript numbers to BigDecimal objects using the unsafeFromNumber function. The example shows conversions of both integer and decimal numbers, highlighting how the function handles the decimal precision internally.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/BigDecimal-unsafeFromNumber.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { unsafeFromNumber, make } from \"effect/BigDecimal\"\n\nassert.deepStrictEqual(unsafeFromNumber(123), make(123n, 0))\nassert.deepStrictEqual(unsafeFromNumber(123.456), make(123456n, 3))\n```\n\n----------------------------------------\n\nTITLE: Checking Empty ReadonlyArray in TypeScript using Effect-TS\nDESCRIPTION: Demonstrates the usage of Array.isEmptyReadonlyArray function to determine if a ReadonlyArray is empty. The function narrows down the type to readonly [] when true.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Array-isEmptyReadonlyArray.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Array } from \"effect\"\n\nconsole.log(Array.isEmptyReadonlyArray([])) // true\nconsole.log(Array.isEmptyReadonlyArray([1, 2, 3])) // false\n```\n\n----------------------------------------\n\nTITLE: Creating a Chunk from an Iterable in TypeScript\nDESCRIPTION: The fromIterable function creates a new Chunk from an iterable collection of values. It accepts any object implementing the Iterable interface and returns a Chunk containing all the values from the iterable.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Chunk-fromIterable.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const fromIterable: <A>(self: Iterable<A>) => Chunk<A>\n```\n\n----------------------------------------\n\nTITLE: BigDecimal.unsafeToNumber Function Signature\nDESCRIPTION: Type declaration for the unsafeToNumber function that converts a BigDecimal type to a JavaScript number.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/BigDecimal-unsafeToNumber.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const unsafeToNumber: (n: BigDecimal) => number\n```\n\n----------------------------------------\n\nTITLE: Function Signature for isUndefined in TypeScript\nDESCRIPTION: This code snippet shows the TypeScript function signature for the isUndefined function. It takes an unknown input and returns a boolean indicating if the input is undefined.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Predicate-isUndefined.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const isUndefined: (input: unknown) => input is undefined\n```\n\n----------------------------------------\n\nTITLE: Creating Unshared Layer Copy in TypeScript using Effect\nDESCRIPTION: The fresh function creates a new version of a given layer that will not be shared. It takes a Layer<A, E, R> as input and returns a new Layer<A, E, R>. This function is useful when you need an isolated instance of a layer.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Layer-fresh.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const fresh: <A, E, R>(self: Layer<A, E, R>) => Layer<A, E, R>\n```\n\n----------------------------------------\n\nTITLE: Effect.head Type Definition in TypeScript\nDESCRIPTION: Type signature for the Effect.head function showing its generic parameters and return type. The function accepts an Effect containing an Iterable and returns an Effect that may fail with NoSuchElementException.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-head.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const head: <A, E, R>(self: Effect<Iterable<A>, E, R>) => Effect<A, Cause.NoSuchElementException | E, R>\n```\n\n----------------------------------------\n\nTITLE: Implementing Cursor Movement in TypeScript with AnsiDoc\nDESCRIPTION: Function that moves the cursor position by specified number of rows and columns relative to current position. If cursor is at screen edge, additional movement in that direction has no effect. Takes required column parameter and optional row parameter.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/AnsiDoc-cursorMove.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const cursorMove: (column: number, row?: number) => AnsiDoc\n```\n\n----------------------------------------\n\nTITLE: STM.repeatWhile Signature\nDESCRIPTION: This code snippet shows the type signature of the `repeatWhile` function in the `STM` module. It illustrates how to use the function with or without currying to repeat an STM effect based on a predicate.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/STM-repeatWhile.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const repeatWhile: { <A>(predicate: Predicate<A>): <E, R>(self: STM<A, E, R>) => STM<A, E, R>; <A, E, R>(self: STM<A, E, R>, predicate: Predicate<A>): STM<A, E, R>; }\n```\n\n----------------------------------------\n\nTITLE: Defining orElseAbsurd Function in TypeScript for Effect Library\nDESCRIPTION: This code snippet defines the orElseAbsurd function in the Match module. It finalizes a matcher by throwing an error if no pattern matches, ensuring all cases are covered or an error is thrown for unexpected inputs.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Match-orElseAbsurd.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const orElseAbsurd: <I, R, RA, A, Pr, Ret>(self: Matcher<I, R, RA, A, Pr, Ret>) => [Pr] extends [never] ? (input: I) => Unify<A> : Unify<A>\n```\n\n----------------------------------------\n\nTITLE: Creating MutableHashSet from HashSet in TypeScript using Effect\nDESCRIPTION: Demonstrates converting from Effect's immutable HashSet to a MutableHashSet. This shows the interoperability between Effect's mutable and immutable data structures.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/MutableHashSet-fromIterable.md#2025-04-11_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { HashSet, MutableHashSet, pipe } from \"effect\"\n\nconsole.log(\n  pipe(\n    HashSet.make(1, 2, 3, 4), // it works also with its immutable HashSet sibling\n    MutableHashSet.fromIterable,\n    Array.from\n  )\n) // Output: [1, 2, 3, 4]\n```\n\n----------------------------------------\n\nTITLE: Folding over Channel results with TypeScript function signature\nDESCRIPTION: TypeScript signature for foldCauseChannel function which handles both success and failure cases of a Channel. This function takes options for handling both success and error cases, allowing for comprehensive error handling and result processing.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Channel-foldCauseChannel.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const foldCauseChannel: { <OutErr, OutElem1, InElem1, OutErr2, InErr1, OutDone2, InDone1, Env1, OutDone, OutElem2, InElem2, OutErr3, InErr2, OutDone3, InDone2, Env2>(options: { readonly onFailure: (c: Cause.Cause<OutErr>) => Channel<OutElem1, InElem1, OutErr2, InErr1, OutDone2, InDone1, Env1>; readonly onSuccess: (o: OutDone) => Channel<OutElem2, InElem2, OutErr3, InErr2, OutDone3, InDone2, Env2>; }): <Env, InErr, InElem, InDone, OutElem>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>) => Channel<OutElem1 | OutElem2 | OutElem, InElem & InElem1 & InElem2, OutErr2 | OutErr3, InErr & InErr1 & InErr2, OutDone2 | OutDone3, InDone & InDone1 & InDone2, Env1 | Env2 | Env>; <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutElem1, InElem1, OutErr2, InErr1, OutDone2, InDone1, Env1, OutElem2, InElem2, OutErr3, InErr2, OutDone3, InDone2, Env2>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>, options: { readonly onFailure: (c: Cause.Cause<OutErr>) => Channel<OutElem1, InElem1, OutErr2, InErr1, OutDone2, InDone1, Env1>; readonly onSuccess: (o: OutDone) => Channel<OutElem2, InElem2, OutErr3, InErr2, OutDone3, InDone2, Env2>; }): Channel<OutElem | OutElem1 | OutElem2, InElem & InElem1 & InElem2, OutErr2 | OutErr3, InErr & InErr1 & InErr2, OutDone2 | OutDone3, InDone & InDone1 & InDone2, Env | Env1 | Env2>; }\n```\n\n----------------------------------------\n\nTITLE: Using tagStartsWith Pattern Matching in TypeScript Effect-IO\nDESCRIPTION: Demonstrates how to use Match.tagStartsWith to pattern match on discriminated unions based on _tag field prefixes. The example shows matching different tag patterns including nested tags like 'A.A'.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Match-tagStartsWith.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Match, pipe } from \"effect\"\n\nconst match = pipe(\n  Match.type<{ _tag: \"A\" } | { _tag: \"B\" } | { _tag: \"A.A\" } | {}>(),\n  Match.tagStartsWith(\"A\", (_) => 1 as const),\n  Match.tagStartsWith(\"B\", (_) => 2 as const),\n  Match.orElse((_) => 3 as const)\n)\n\nconsole.log(match({ _tag: \"A\" })) // 1\nconsole.log(match({ _tag: \"B\" })) // 2\nconsole.log(match({ _tag: \"A.A\" })) // 1\n```\n\n----------------------------------------\n\nTITLE: Defining provideSomeLayer in TypeScript for Effect Channel\nDESCRIPTION: Type signature for the provideSomeLayer function which splits the context into two parts, providing one part using the specified layer and leaving the remainder as Env0. This function can be used in both curried and uncurried forms.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Channel-provideSomeLayer.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const provideSomeLayer: { <R2, OutErr2, Env0>(layer: Layer.Layer<R2, OutErr2, Env0>): <OutElem, InElem, OutErr, InErr, OutDone, InDone, R>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, R>) => Channel<OutElem, InElem, OutErr2 | OutErr, InErr, OutDone, InDone, Env0 | Exclude<R, R2>>; <OutElem, InElem, OutErr, InErr, OutDone, InDone, R, R2, OutErr2, Env0>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, R>, layer: Layer.Layer<R2, OutErr2, Env0>): Channel<OutElem, InElem, OutErr | OutErr2, InErr, OutDone, InDone, Env0 | Exclude<R, R2>>; }\n```\n\n----------------------------------------\n\nTITLE: STM.every Signature in Effect (TypeScript)\nDESCRIPTION: This code snippet presents the TypeScript signature for the `STM.every` function in the Effect library. The function is used to determine if every element in an `Iterable` satisfies an effectual predicate within an STM (Software Transactional Memory) context. The predicate is a function that takes an element of type `A` and returns an `STM` effect that resolves to a boolean value, and the function returns an `STM` effect resolving to a boolean value indicating whether all elements satisfied the predicate.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/STM-every.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const every: { <A, R, E>(predicate: (a: NoInfer<A>) => STM<boolean, E, R>): (iterable: Iterable<A>) => STM<boolean, E, R>; <A, R, E>(iterable: Iterable<A>, predicate: (a: A) => STM<boolean, E, R>): STM<boolean, E, R>; }\n```\n\n----------------------------------------\n\nTITLE: Implementing SemiProduct.appendElement in TypeScript\nDESCRIPTION: A type-level function that appends an element to the end of a tuple using SemiProduct type class. It takes a SemiProduct instance and returns functions to combine tuples with additional elements while preserving type information about readonly arrays, effects, and error types.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/SemiProduct-appendElement.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const appendElement: <F extends TypeLambda>(F: SemiProduct<F>) => { <R2, O2, E2, B>(that: Kind<F, R2, O2, E2, B>): <R1, O1, E1, A extends ReadonlyArray<any>>(self: Kind<F, R1, O1, E1, A>) => Kind<F, R1 & R2, O2 | O1, E2 | E1, [...A, B]>; <R1, O1, E1, A extends ReadonlyArray<any>, R2, O2, E2, B>(self: Kind<F, R1, O1, E1, A>, that: Kind<F, R2, O2, E2, B>): Kind<F, R1 & R2, O1 | O2, E1 | E2, [...A, B]>; }\n```\n\n----------------------------------------\n\nTITLE: Combining Option Structures Using TypeScript and Effect-TS\nDESCRIPTION: The Option.all function combines multiple Option values from different structures into a single Option. It maintains the structure of the input, returning None if any input Option is None. Inputs can be tuples, structs, or iterables, and outputs will reflect the same structure as the input.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Option-all.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Option } from \"effect\"\n\nconst maybeName: Option.Option<string> = Option.some(\"John\")\nconst maybeAge: Option.Option<number> = Option.some(25)\n\n//      ┌─── Option<[string, number]>\n//      ▼\nconst tuple = Option.all([maybeName, maybeAge])\nconsole.log(tuple)\n// Output:\n// { _id: 'Option', _tag: 'Some', value: [ 'John', 25 ] }\n\n//      ┌─── Option<{ name: string; age: number; }>\n//      ▼\nconst struct = Option.all({ name: maybeName, age: maybeAge })\nconsole.log(struct)\n// Output:\n// { _id: 'Option', _tag: 'Some', value: { name: 'John', age: 25 } }\n```\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const all: <const I extends Iterable<Option<any>> | Record<string, Option<any>>>(input: I) => [I] extends [ReadonlyArray<Option<any>>] ? Option<{ -readonly [K in keyof I]: [I[K]] extends [Option<infer A>] ? A : never; }> : [I] extends [Iterable<Option<infer A>>] ? Option<Array<A>> : Option<{ -readonly [K in keyof I]: [I[K]] extends [Option<infer A>] ? A : never; }>\n```\n\n----------------------------------------\n\nTITLE: Demonstrating constVoid Function Usage in TypeScript\nDESCRIPTION: This example demonstrates how to use the `constVoid` function from the Effect package. It imports the function and uses an assertion to verify that it always returns `undefined`.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Function-constVoid.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { constVoid } from \"effect/Function\"\n\nassert.deepStrictEqual(constVoid(), undefined)\n```\n\n----------------------------------------\n\nTITLE: MutableHashSet.has TypeScript Function Signature\nDESCRIPTION: The type signature for the MutableHashSet.has function, showing it supports both data-first and data-last calling styles. It accepts a value to check and returns a boolean indicating whether the value is in the set.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/MutableHashSet-has.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const has: { <V>(key: V): (self: MutableHashSet<V>) => boolean; <V>(self: MutableHashSet<V>, key: V): boolean; }\n```\n\n----------------------------------------\n\nTITLE: Stream.unfoldEffect Type Definition\nDESCRIPTION: Type signature for the unfoldEffect function showing its generic parameters and return type. Takes an initial state S and a function that produces Effects containing Options of tuple pairs.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-unfoldEffect.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const unfoldEffect: <S, A, E, R>(s: S, f: (s: S) => Effect.Effect<Option.Option<readonly [A, S]>, E, R>) => Stream<A, E, R>\n```\n\n----------------------------------------\n\nTITLE: Effect.runFork Type Definition\nDESCRIPTION: Type signature for the runFork function showing its parameters and return type. Takes an Effect and optional runtime options, returns a RuntimeFiber.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-runFork.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const runFork: <A, E>(effect: Effect<A, E>, options?: Runtime.RunForkOptions) => Fiber.RuntimeFiber<A, E>\n```\n\n----------------------------------------\n\nTITLE: Defining Sink Interface in TypeScript\nDESCRIPTION: Defines a generic Sink interface that consumes stream elements. It takes type parameters A (output), In (input), L (leftovers), E (error), and R (requirements). The interface extends Sink.Variance and Pipeable.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Sink-Sink.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface Sink<out A, in In = unknown, out L = never, out E = never, out R = never>\n  extends Sink.Variance<A, In, L, E, R>, Pipeable\n{}\n```\n\n----------------------------------------\n\nTITLE: Creating a Maximum-Based Monoid in TypeScript\nDESCRIPTION: This function creates a monoid where the `combine` operation returns the maximum value based on a provided bounded order. The `empty` value is set to the minimum value from the bounded order.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Monoid-max.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const max: <A>(B: Bounded<A>) => Monoid<A>\n```\n\n----------------------------------------\n\nTITLE: Checking for ConfigError Type in TypeScript\nDESCRIPTION: A type predicate function that determines if a given unknown value is a ConfigError. Returns true if the specified value is a ConfigError, false otherwise.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/ConfigError-isConfigError.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const isConfigError: (u: unknown) => u is ConfigError\n```\n\n----------------------------------------\n\nTITLE: Lifting Functions with SemiApplicative in TypeScript\nDESCRIPTION: The `lift2` function takes a binary function and lifts it into a context `F` specified by `SemiApplicative`. It transforms a regular binary function into one that operates over wrapped types defined by the `Kind` interface. Required dependencies include `SemiApplicative` and the generic `Kind` interface. It takes in generic types `A` and `B` and returns a function that accepts wrapped types in a context `F`, then outputs a combined effect wrapped in `F`. Applicable constraints include the necessity for `F` to extend `TypeLambda`.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/SemiApplicative-lift2.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const lift2: <F extends TypeLambda>(F: SemiApplicative<F>) => <A, B, C>(f: (a: A, b: B) => C) => { <R2, O2, E2>(that: Kind<F, R2, O2, E2, B>): <R1, O1, E1>(self: Kind<F, R1, O1, E1, A>) => Kind<F, R1 & R2, O2 | O1, E2 | E1, C>; <R1, O1, E1, R2, O2, E2>(self: Kind<F, R1, O1, E1, A>, that: Kind<F, R2, O2, E2, B>): Kind<F, R1 & R2, O1 | O2, E1 | E2, C>; }\n```\n\n----------------------------------------\n\nTITLE: Defining Fail Interface for Document Rendering in TypeScript\nDESCRIPTION: This code snippet defines the 'Fail' interface, which extends Doc.Variance<A>. It represents a document that cannot be rendered, usually occurring when flattening a line. The interface includes a readonly '_tag' property set to \"Fail\".\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Doc-Fail.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface Fail<A> extends Doc.Variance<A> {\n  readonly _tag: \"Fail\"\n}\n```\n\n----------------------------------------\n\nTITLE: Defining WebSocket Layer for ShardManager in TypeScript\nDESCRIPTION: Declares a constant 'layerWebsocketOptions' that creates a WebSocket layer for the ShardManager server. It adds a route to the provided HttpRouter.Tag and uses HttpRouter.Default by default. The function takes options including path, router tag, runner details, and logging configuration.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/HttpShardManager-layerWebsocketOptions.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const layerWebsocketOptions: <I = HttpRouter.Default>(options: { readonly path: HttpRouter.PathInput; readonly routerTag?: HttpRouter.HttpRouter.TagClass<I, string, any, any>; readonly runnerPath: string; readonly runnerHttps?: boolean | undefined; readonly logAddress?: boolean | undefined; }) => Layer.Layer<ShardManager.ShardManager, never, RpcSerialization.RpcSerialization | ShardStorage | RunnerHealth.RunnerHealth | HttpServer.HttpServer | Socket.WebSocketConstructor | ShardManager.Config | ShardingConfig>\n```\n\n----------------------------------------\n\nTITLE: Checking if a DocTree is a CharTree in TypeScript\nDESCRIPTION: Type predicate function that determines if a given DocTree is specifically a CharTree. Returns true when the input is a CharTree, false otherwise.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/DocTree-isCharTree.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const isCharTree: <A>(self: DocTree<A>) => self is CharTree<A>\n```\n\n----------------------------------------\n\nTITLE: Stream.range Function Signature in TypeScript\nDESCRIPTION: The type declaration for the Stream.range function, showing its parameters and return type.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-range.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const range: (min: number, max: number, chunkSize?: number) => Stream<number>\n```\n\n----------------------------------------\n\nTITLE: Creating Batched Request Resolvers in TypeScript with Effect-TS\nDESCRIPTION: Creates a data source that can process multiple requests in batches. Takes a function that accepts a non-empty array of requests and returns an Effect that processes these requests without producing a direct return value.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/RequestResolver-makeBatched.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const makeBatched: <A extends Request.Request<any, any>, R>(run: (requests: NonEmptyArray<A>) => Effect.Effect<void, never, R>) => RequestResolver<A, R>\n```\n\n----------------------------------------\n\nTITLE: Using Identity Function in TypeScript with Effect\nDESCRIPTION: Demonstrates usage of the identity function that returns its input argument. The example shows how to import and use the identity function with a simple number value.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Function-identity.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { identity } from \"effect/Function\"\n\nassert.deepStrictEqual(identity(5), 5)\n```\n\n----------------------------------------\n\nTITLE: Creating Float Arguments in Effect CLI\nDESCRIPTION: Function signature for creating a floating point number argument in the Effect CLI library. Accepts optional base configuration and returns an Args instance of type number. The default argument name is 'float' if not specified in the config.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Args-float.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const float: (config?: Args.BaseArgsConfig) => Args<number>\n```\n\n----------------------------------------\n\nTITLE: Defining BigInt Semigroup Multiplication\nDESCRIPTION: Creates a semigroup for BigInt that supports multiplication operations. This allows combining BigInt values through multiplication in a functional programming context.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/data-BigInt-SemigroupMultiply.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const SemigroupMultiply: semigroup.Semigroup<bigint>\n```\n\n----------------------------------------\n\nTITLE: Matching Upstream Pull Strategy - TypeScript\nDESCRIPTION: The match function enables folding an UpstreamPullStrategy into a value of type Z. It provides flexibility by allowing configuration through onNext and onAllEnqueued options. The function can be invoked with different combinations of self and options. The function is part of the Effect-TS library and hinges on Option type utilities.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/UpstreamPullStrategy-match.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const match: { <A, Z>(options: { readonly onNext: (emitSeparator: Option.Option<A>) => Z; readonly onAllEnqueued: (emitSeparator: Option.Option<A>) => Z; }): (self: UpstreamPullStrategy<A>) => Z; <A, Z>(self: UpstreamPullStrategy<A>, options: { readonly onNext: (emitSeparator: Option.Option<A>) => Z; readonly onAllEnqueued: (emitSeparator: Option.Option<A>) => Z; }): Z; }\n```\n\n----------------------------------------\n\nTITLE: Using Doc.spaces in TypeScript with @effect/printer\nDESCRIPTION: This example demonstrates how to use the `spaces` combinator from the `Doc` module to create a document with 5 spaces, enclosed in double quotes and square brackets. The resulting document is then rendered using the 'pretty' style.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Doc-spaces.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport * as Doc from \"@effect/printer/Doc\"\n\nconst doc = Doc.squareBracketed(Doc.doubleQuoted(Doc.spaces(5)))\n\nassert.strictEqual(\n  Doc.render(doc, { style: \"pretty\" }),\n  \"[\\\"     \\\"]\"\n)\n```\n\n----------------------------------------\n\nTITLE: Defining Cause.find Function in TypeScript\nDESCRIPTION: This code snippet defines the signature of the Cause.find function. It's a higher-order function that takes a partial function as an argument and returns a function that searches a Cause for specific information.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Cause-find.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const find: { <E, Z>(pf: (cause: Cause<E>) => Option.Option<Z>): (self: Cause<E>) => Option.Option<Z>; <E, Z>(self: Cause<E>, pf: (cause: Cause<E>) => Option.Option<Z>): Option.Option<Z>; }\n```\n\n----------------------------------------\n\nTITLE: Defining snakeCase ConfigProvider Transformer in TypeScript\nDESCRIPTION: Defines a function that takes a ConfigProvider and returns a new one with all property names converted to snake case format. This helps adapt the naming convention from camel case (default) to snake case for configuration properties.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/ConfigProvider-snakeCase.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const snakeCase: (self: ConfigProvider) => ConfigProvider\n```\n\n----------------------------------------\n\nTITLE: Defining Layer Scope in TypeScript\nDESCRIPTION: Declares a constant that creates a layer which manages a scope's lifecycle, handling its creation and cleanup across success, failure or interruption scenarios. The layer takes a Scope type parameter and never produces errors or dependencies.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Layer-scope.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const scope: Layer<Scope.Scope, never, never>\n```\n\n----------------------------------------\n\nTITLE: Doc.softLine API Signature in Effect Printer\nDESCRIPTION: TypeScript signature for the softLine constant in the @effect/printer package. It is a Doc with a never type parameter, indicating it doesn't contain any specific value type.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Doc-softLine.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const softLine: Doc<never>\n```\n\n----------------------------------------\n\nTITLE: Type Signature for isPositive Function in TypeScript\nDESCRIPTION: This code snippet shows the type signature of the isPositive function from the BigDecimal module. It takes a BigDecimal as input and returns a boolean indicating whether the value is positive.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/BigDecimal-isPositive.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const isPositive: (n: BigDecimal) => boolean\n```\n\n----------------------------------------\n\nTITLE: Defining TestAnnotationMap Interface in TypeScript\nDESCRIPTION: Defines the TestAnnotationMap interface with a type identifier and an internal map property. The map uses HashMap to store TestAnnotation objects of any type.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TestAnnotationMap-TestAnnotationMap.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface TestAnnotationMap {\n  readonly [TestAnnotationMapTypeId]: TestAnnotationMapTypeId\n  /** @internal */\n  readonly map: HashMap.HashMap<TestAnnotation.TestAnnotation<any>, any>\n}\n```\n\n----------------------------------------\n\nTITLE: Using encloseSep to Create Bracketed Lists in TypeScript\nDESCRIPTION: This example demonstrates how to use the `encloseSep` combinator to create a bracketed list of items with comma separators. It shows how the layout adapts to available space, displaying horizontally when there's enough width and vertically with aligned separators when space is constrained.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Doc-encloseSep.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport * as Doc from \"@effect/printer/Doc\"\nimport { pipe } from \"effect/Function\"\nimport * as String from \"effect/String\"\n\nconst doc = Doc.hsep([\n  Doc.text(\"list\"),\n  Doc.align(\n    pipe(\n      [\"1\", \"20\", \"300\", \"4000\"].map(\n        (n) => n.length === 1 ? Doc.char(n) : Doc.text(n)\n      ),\n      Doc.encloseSep(Doc.lbracket, Doc.rbracket, Doc.comma)\n    )\n  )\n])\n\n// The documents are laid out horizontally if the document fits the page\nassert.strictEqual(\n  Doc.render(doc, { style: \"pretty\" }),\n  \"list [1,20,300,4000]\"\n)\n\n// Otherwise they are laid out vertically, with separators put in the front\nassert.strictEqual(\n  Doc.render(doc, {\n    style: \"pretty\",\n    options: { lineWidth: 10 }\n  }),\n  String.stripMargin(\n    `|list [1\n     |     ,20\n     |     ,300\n     |     ,4000]`\n  )\n)\n```\n\n----------------------------------------\n\nTITLE: Adding Multiple Cookies to a Cookies Object with setAllCookie in TypeScript\nDESCRIPTION: The setAllCookie function provides a way to add multiple cookies to a Cookies object. It supports both curried and uncurried calling styles, taking an iterable collection of Cookie objects and returning a new Cookies instance with the added cookies.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Cookies-setAllCookie.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const setAllCookie: { (cookies: Iterable<Cookie>): (self: Cookies) => Cookies; (self: Cookies, cookies: Iterable<Cookie>): Cookies; }\n```\n\n----------------------------------------\n\nTITLE: Using Effect.clockWith to Get Current Time in TypeScript\nDESCRIPTION: This example demonstrates how to use Effect.clockWith to retrieve the current time in milliseconds, format it as a string, and log it to the console.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-clockWith.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Console, Effect } from \"effect\"\n\nconst program = Effect.clockWith((clock) =>\n  clock.currentTimeMillis.pipe(\n    Effect.map((currentTime) => `Current time is: ${currentTime}`),\n    Effect.tap(Console.log)\n  )\n)\n\nEffect.runFork(program)\n// Example Output:\n// Current time is: 1735484929744\n```\n\n----------------------------------------\n\nTITLE: Declaring ShardStorage Base Class\nDESCRIPTION: Defines the ShardStorage abstract class that represents the interface for persistent storage operations in a cluster. This class serves as a contract for implementing concrete storage solutions for cluster data management.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/ShardStorage-ShardStorage.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare class ShardStorage\n```\n\n----------------------------------------\n\nTITLE: Defining Boolean Type Predicate in TypeScript\nDESCRIPTION: Declares a constant 'boolean' as a Predicate.Refinement that checks if an unknown value is of type boolean. This function can be used for type narrowing in TypeScript.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Match-boolean.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const boolean: Predicate.Refinement<unknown, boolean>\n```\n\n----------------------------------------\n\nTITLE: Checking Interrupt Type in Cause Module (TypeScript)\nDESCRIPTION: A utility function that checks if a given Cause is of the Interrupt type. This is useful for determining if an operation was interrupted rather than failing with an error.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Cause-isInterruptType.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const isInterruptType: <E>(self: Cause<E>) => self is Interrupt\n```\n\n----------------------------------------\n\nTITLE: Reversing Order in Bounded Typeclass (TypeScript)\nDESCRIPTION: The `reverse` function takes a `Bounded<A>` instance and returns a new `Bounded<A>` with reversed order. It flips the maxBound and minBound values, effectively inverting the ordering relationship.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Bounded-reverse.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const reverse: <A>(B: Bounded<A>) => Bounded<A>\n```\n\n----------------------------------------\n\nTITLE: Defining STM validateFirst Utility in TypeScript\nDESCRIPTION: A higher-order function that applies a validation function to an iterable, returning the first successful result or collecting all errors. Supports flexible function overloading with curried and direct invocation styles.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/STM-validateFirst.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const validateFirst: { <A, B, E, R>(f: (a: A) => STM<B, E, R>): (elements: Iterable<A>) => STM<B, Array<E>, R>; <A, B, E, R>(elements: Iterable<A>, f: (a: A) => STM<B, E, R>): STM<B, Array<E>, R>; }\n```\n\n----------------------------------------\n\nTITLE: Declaring Channel.scoped Function in TypeScript\nDESCRIPTION: Function signature for the `scoped` function that converts a scoped effect into a channel that emits an output element. It takes an effect as input and returns a channel that emits the effect's result.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Channel-scoped.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const scoped: <A, E, R>(effect: Effect.Effect<A, E, R>) => Channel<A, unknown, E, unknown, unknown, unknown, Exclude<R, Scope.Scope>>\n```\n\n----------------------------------------\n\nTITLE: Defining tapErrorCause Function in TypeScript for Layer Module\nDESCRIPTION: This code snippet defines the tapErrorCause function, which performs a specified effect if a layer fails. It takes a function that operates on the cause of the error and returns a new Layer with potentially modified error and input types.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Layer-tapErrorCause.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const tapErrorCause: {\n  <E, XE extends E, RIn2, E2, X>\n  (f: (cause: Cause.Cause<XE>) => Effect.Effect<X, E2, RIn2>):\n    <RIn, ROut>(self: Layer<ROut, E, RIn>) => Layer<ROut, E | E2, RIn2 | RIn>;\n  <RIn, E, XE extends E, ROut, RIn2, E2, X>\n  (self: Layer<ROut, E, RIn>,\n   f: (cause: Cause.Cause<XE>) => Effect.Effect<X, E2, RIn2>):\n    Layer<ROut, E | E2, RIn | RIn2>;\n}\n```\n\n----------------------------------------\n\nTITLE: TypeScript Function Signature for isBigInt\nDESCRIPTION: Provides the TypeScript type declaration for the isBigInt function. It takes an unknown type as input and returns a type predicate indicating if the input is a bigint.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/BigInt-isBigInt.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const isBigInt: (u: unknown) => u is bigint\n```\n\n----------------------------------------\n\nTITLE: Declaring a File Watching Layer with ParcelWatcher in TypeScript\nDESCRIPTION: The snippet declares a constant `layer` of type `Layer` offered by ParcelWatcher for file tracking purposes. It sets up `@parcel/watcher` as a backend. There are no prerequisites other than having `@parcel/watcher` installed. The declaration does not receive inputs or outputs, and it operates within the TypeScript type system.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/NodeFileSystem-ParcelWatcher-layer.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const layer: Layer<WatchBackend, never, never>\n```\n\n----------------------------------------\n\nTITLE: Creating Failing Take Function in TypeScript\nDESCRIPTION: This TypeScript snippet declares a `fail` function to create a Take object that immediately fails with a designated error. It requires no additional dependencies and the input is an error of generic type `E`, which will be used to instantiate the failing Take object. This is intended for use within the Effect library and has been available since version 2.0.0.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Take-fail.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const fail: <E>(error: E) => Take<never, E>\n```\n\n----------------------------------------\n\nTITLE: TypeScript Type Definition for Match.tagStartsWith\nDESCRIPTION: Type signature for the Match.tagStartsWith function showing its generic parameters and return type. Handles pattern matching on discriminated unions with tag prefixes.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Match-tagStartsWith.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const tagStartsWith: <R, P extends string, Ret, Fn extends (_: Extract<R, Record<\"_tag\", `${P}${string}`>>) => Ret>(pattern: P, f: Fn) => <I, F, A, Pr>(self: Matcher<I, F, R, A, Pr, Ret>) => Matcher<I, Types.AddWithout<F, Extract<R, Record<\"_tag\", `${P}${string}`>>>, Types.ApplyFilters<I, Types.AddWithout<F, Extract<R, Record<\"_tag\", `${P}${string}`>>>>, ReturnType<Fn> | A, Pr, Ret>\n```\n\n----------------------------------------\n\nTITLE: Effect.mapBoth Type Signature\nDESCRIPTION: TypeScript type declaration for the mapBoth function showing its polymorphic nature and type parameters. Defines two overloads - one taking options first and one taking the Effect first.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-mapBoth.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const mapBoth: { <E, E2, A, A2>(options: { readonly onFailure: (e: E) => E2; readonly onSuccess: (a: A) => A2; }): <R>(self: Effect<A, E, R>) => Effect<A2, E2, R>; <A, E, R, E2, A2>(self: Effect<A, E, R>, options: { readonly onFailure: (e: E) => E2; readonly onSuccess: (a: A) => A2; }): Effect<A2, E2, R>; }\n```\n\n----------------------------------------\n\nTITLE: Function Signature for Effect.logWithLevel (TypeScript)\nDESCRIPTION: This snippet shows the TypeScript function signature for the Effect.logWithLevel function. It defines the function as taking a LogLevel and a variable number of messages, returning an Effect of void.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-logWithLevel.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const logWithLevel: (level: LogLevel.LogLevel, ...message: ReadonlyArray<any>) => Effect<void>\n```\n\n----------------------------------------\n\nTITLE: Retrieving URL Parameters with Url.urlParams in Typescript\nDESCRIPTION: This example demonstrates how to use the `Url.urlParams` function to extract query parameters from a URL object. It creates a URL with a query parameter, extracts the parameters using `Url.urlParams`, and then logs the resulting `UrlParams` structure to the console. The output is an array of key-value pairs representing the query parameters.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Url-urlParams.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Url } from \"@effect/platform\"\n\nconst myUrl = new URL(\"https://example.com?foo=bar\")\n\n// Read parameters\nconst params = Url.urlParams(myUrl)\n\nconsole.log(params)\n// Output: [ [ 'foo', 'bar' ] ]\n```\n\n----------------------------------------\n\nTITLE: Creating Layer to Set Current Tracer in TypeScript\nDESCRIPTION: The setTracer function creates a Layer that sets the current Tracer. It takes a Tracer object as input and returns a Layer that never requires any dependencies.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Layer-setTracer.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const setTracer: (tracer: Tracer.Tracer) => Layer<never>\n```\n\n----------------------------------------\n\nTITLE: Defining haltWhen Function for Stream Halting in TypeScript\nDESCRIPTION: Defines the haltWhen function which halts the evaluation of a stream when a provided effect completes. The effect is forked as part of the returned stream, and its success is discarded. If the effect fails, the stream emits that failure. Note that an element being pulled when the effect completes will not be interrupted.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-haltWhen.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const haltWhen: { <X, E2, R2>(effect: Effect.Effect<X, E2, R2>): <A, E, R>(self: Stream<A, E, R>) => Stream<A, E2 | E, R2 | R>; <A, E, R, X, E2, R2>(self: Stream<A, E, R>, effect: Effect.Effect<X, E2, R2>): Stream<A, E | E2, R | R2>; }\n```\n\n----------------------------------------\n\nTITLE: Implementing a Conditional Chunk Processing Sink in TypeScript\nDESCRIPTION: Creates a sink that processes chunks of input data by executing a provided effectful function for each chunk until the function returns false. The sink preserves input data for downstream processing.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Sink-forEachChunkWhile.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const forEachChunkWhile: <In, E, R>(f: (input: Chunk.Chunk<In>) => Effect.Effect<boolean, E, R>) => Sink<void, In, In, E, R>\n```\n\n----------------------------------------\n\nTITLE: Retrieving FiberRef Values in Effect Module\nDESCRIPTION: Returns a collection of all FiberRef values for the fiber running this effect. This function allows access to the fiber-local state of the current computation.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-getFiberRefs.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const getFiberRefs: Effect<FiberRefs.FiberRefs, never, never>\n```\n\n----------------------------------------\n\nTITLE: String Concatenation Type Definition in TypeScript\nDESCRIPTION: Defines a type-level utility for concatenating two string literal types A and B at compile time using template literal syntax. This allows for static string composition that can be validated by the TypeScript compiler.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/String-Concat.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ntype `${A}${B}` = `${A}${B}`\n```\n\n----------------------------------------\n\nTITLE: Defining PCG Random Number Generator Class in TypeScript\nDESCRIPTION: This snippet defines the PCGRandom class constructor that accepts optional parameters for seeding the generator. The class aims to provide a fast and efficient random number generation method based on the PCG algorithm. It is notable for its performance and statistical qualities, which make it suitable for applications where predictability of output must be minimized.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Utils-PCGRandom.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare class PCGRandom { constructor(\n    seedHi?: OptionalNumber,\n    seedLo?: OptionalNumber,\n    incHi?: OptionalNumber,\n    incLo?: OptionalNumber\n  ) }\n```\n\n----------------------------------------\n\nTITLE: Declaring a Lazy Micro Effect in TypeScript\nDESCRIPTION: The function `suspend` in TypeScript creates a `Micro` effect lazily by evaluating a lazy argument (`evaluate`). It is used to defer evaluation of potentially expensive computations until they are needed. This function requires a `LazyArg` type parameter and produces a `Micro` effect with the types `A`, `E`, and `R` signifying the result, error, and environment types respectively.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Micro-suspend.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const suspend: <A, E, R>(evaluate: LazyArg<Micro<A, E, R>>) => Micro<A, E, R>\n```\n\n----------------------------------------\n\nTITLE: Retrieving Fiber Interruptors in Effect IO\nDESCRIPTION: The interruptors function collects all FiberId instances responsible for interrupting a fiber within a Cause object. It returns a HashSet of FiberIds, which is useful for debugging concurrency issues or tracing the source of fiber cancellations.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Cause-interruptors.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const interruptors: <E>(self: Cause<E>) => HashSet.HashSet<FiberId.FiberId>\n```\n\n----------------------------------------\n\nTITLE: MutableHashSet.clear Function Signature in TypeScript\nDESCRIPTION: The type signature for the MutableHashSet.clear function, which takes a MutableHashSet of any type V and returns the same MutableHashSet instance after clearing all its values.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/MutableHashSet-clear.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const clear: <V>(self: MutableHashSet<V>) => MutableHashSet<V>\n```\n\n----------------------------------------\n\nTITLE: Defining Stream.never Constant in TypeScript\nDESCRIPTION: Declares the Stream.never constant, which represents a stream that never produces any value or fails with any error. This is a fundamental concept in stream processing, useful for scenarios where you need a stream that doesn't emit anything.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-never.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const never: Stream<never, never, never>\n```\n\n----------------------------------------\n\nTITLE: Defining GenAI Well-Known Operation Names in TypeScript\nDESCRIPTION: TypeScript type definition specifying standardized values for the gen_ai.operation.name attribute in AI telemetry. The values include chat, embeddings, and text_completion which must be used when applicable.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/AiTelemetry-GenAI.WellKnownOperationName.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ntype WellKnownOperationName = \"chat\" | \"embeddings\" | \"text_completion\"\n```\n\n----------------------------------------\n\nTITLE: TypeScript Signature of Record.collect Function\nDESCRIPTION: Provides the TypeScript signature for the collect function, showing its overloaded nature and type parameters.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Record-collect.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const collect: { <K extends string, A, B>(f: (key: K, a: A) => B): (self: ReadonlyRecord<K, A>) => Array<B>; <K extends string, A, B>(self: ReadonlyRecord<K, A>, f: (key: K, a: A) => B): Array<B>; }\n```\n\n----------------------------------------\n\nTITLE: Stream.unfold Type Definition\nDESCRIPTION: Type signature for the Stream.unfold function, showing it takes an initial state S and a function that produces Option pairs of value and next state.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-unfold.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const unfold: <S, A>(s: S, f: (s: S) => Option.Option<readonly [A, S]>) => Stream<A>\n```\n\n----------------------------------------\n\nTITLE: Extracting Type Schema in Effect TypeScript\nDESCRIPTION: The `typeSchema` function allows users to extract the `Type` portion of a schema, resulting in a new schema that adheres to the properties defined without including initial encoding or transformation processes. This function requires the Effect library as a dependency and is typically used for scenarios where schema properties need to be replicated without original encoding considerations. It accepts a single schema parameter and returns a `SchemaClass` object focused solely on types.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Schema-typeSchema.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const typeSchema: <A, I, R>(schema: Schema<A, I, R>) => SchemaClass<A>\n```\n\n----------------------------------------\n\nTITLE: Creating Timer Metric in Effect\nDESCRIPTION: Function signature for creating a timer metric that tracks durations in milliseconds. The metric automatically includes a time unit tag and is based on a histogram implementation. Takes a name and optional description parameter.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Metric-timer.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const timer: (name: string, description?: string) => Metric<MetricKeyType.MetricKeyType.Histogram, Duration.Duration, MetricState.MetricState.Histogram>\n```\n\n----------------------------------------\n\nTITLE: Defining Micro Generic Interface in TypeScript\nDESCRIPTION: Defines the Micro interface that extends Effect type with generic parameters for output value (A), error (E), and requirements (R). Includes type variance, iterator functionality, and unification symbols.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Micro-Micro.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface Micro<out A, out E = never, out R = never> extends Effect<A, E, R> {\n  readonly [TypeId]: Micro.Variance<A, E, R>\n  [Symbol.iterator](): MicroIterator<Micro<A, E, R>>\n  [Unify.typeSymbol]?: unknown\n  [Unify.unifySymbol]?: MicroUnify<this>\n  [Unify.ignoreSymbol]?: MicroUnifyIgnore\n}\n```\n\n----------------------------------------\n\nTITLE: Signature of MergeLeft Type\nDESCRIPTION: The signature of the 'MergeLeft' type shows its structure and functioning within TypeScript, indicating it is designed to work with two generic types, Source and Target. This allows for flexible usage across various object shapes, provided they adhere to the object structure expected by the type merging functionality.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Types-MergeLeft.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ntype MergeLeft<Source, Target> = MergeRight<Target, Source>\n```\n\n----------------------------------------\n\nTITLE: Creating ReadonlyMailbox from Stream in TypeScript\nDESCRIPTION: The fromStream function creates a ReadonlyMailbox from a Stream. It accepts optional parameters for capacity and strategy, and returns an Effect that produces a ReadonlyMailbox. The function can be called with options first or with the stream first.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Mailbox-fromStream.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const fromStream: { (options?: { readonly capacity?: number | undefined; readonly strategy?: \"suspend\" | \"dropping\" | \"sliding\" | undefined; }): <A, E, R>(self: Stream<A, E, R>) => Effect<ReadonlyMailbox<A, E>, never, R | Scope>; <A, E, R>(self: Stream<A, E, R>, options?: { readonly capacity?: number | undefined; readonly strategy?: \"suspend\" | \"dropping\" | \"sliding\" | undefined; }): Effect<ReadonlyMailbox<A, E>, never, R | Scope>; }\n```\n\n----------------------------------------\n\nTITLE: Implementing Retryable Metric Polling in TypeScript\nDESCRIPTION: Defines a retry function that creates a new polling metric with retry capabilities. The function accepts a retry policy schedule and returns a modified MetricPolling instance that will retry failed poll operations according to the specified policy.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/MetricPolling-retry.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const retry: { \n  <X, E, R2>(policy: Schedule.Schedule<X, NoInfer<E>, R2>): \n    <Type, In, R, Out>(self: MetricPolling<Type, In, R, E, Out>) => MetricPolling<Type, In, R2 | R, E, Out>; \n  <Type, In, R, E, Out, X, R2>(self: MetricPolling<Type, In, R, E, Out>, policy: Schedule.Schedule<X, E, R2>): \n    MetricPolling<Type, In, R | R2, E, Out>; \n}\n```\n\n----------------------------------------\n\nTITLE: Combining an Option with a Collection in TypeScript\nDESCRIPTION: The `productMany` function combines a primary `Option` with a collection of `Option`s into a single `Option`. If all Options are `Some`, it returns an `Option` containing a tuple of their values. If any Option is `None`, the result will be `None`. This function is declared in TypeScript and adheres to the signature that specifies the types involved.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Option-productMany.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const productMany: <A>(self: Option<A>, collection: Iterable<Option<A>>) => Option<[A, ...Array<A>]>\n```\n\n----------------------------------------\n\nTITLE: Implementing collectAllWhileWith Function in TypeScript\nDESCRIPTION: Defines a TypeScript function that repeatedly runs a sink while results meet a predicate condition, accumulating results using a stepping function. The function supports both curried and direct parameter passing styles.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Sink-collectAllWhileWith.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const collectAllWhileWith: { <A, S>(options: { readonly initial: S; readonly while: Predicate<A>; readonly body: (s: S, a: A) => S; }): <In, L extends In, E, R>(self: Sink<A, In, L, E, R>) => Sink<S, In, L, E, R>; <A, In, L extends In, E, R, S>(self: Sink<A, In, L, E, R>, options: { readonly initial: S; readonly while: Predicate<A>; readonly body: (s: S, a: A) => S; }): Sink<S, In, L, E, R>; }\n```\n\n----------------------------------------\n\nTITLE: Creating Struct Equivalence in TypeScript using Effect\nDESCRIPTION: Demonstrates how to create and use a structural equivalence comparator for comparing objects with name and age properties. The example shows both matching and non-matching cases using String and Number equivalence.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Struct-getEquivalence.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { Struct, String, Number } from \"effect\"\n\nconst PersonEquivalence = Struct.getEquivalence({\n  name: String.Equivalence,\n  age: Number.Equivalence\n})\n\nassert.deepStrictEqual(\n  PersonEquivalence({ name: \"John\", age: 25 }, { name: \"John\", age: 25 }),\n  true\n)\nassert.deepStrictEqual(\n  PersonEquivalence({ name: \"John\", age: 25 }, { name: \"John\", age: 40 }),\n  false\n)\n```\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const getEquivalence: <R extends Record<string, Equivalence.Equivalence<any>>>(isEquivalents: R) => Equivalence.Equivalence<{ readonly [K in keyof R]: [R[K]] extends [Equivalence.Equivalence<infer A>] ? A : never; }>\n```\n\n----------------------------------------\n\nTITLE: Creating FiberHandle-backed Runtime Promise in TypeScript\nDESCRIPTION: Creates an Effect run function that is backed by a FiberHandle. This function returns an Effect that, when executed, provides a function capable of running effects and returning their results as Promises.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/FiberHandle-makeRuntimePromise.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const makeRuntimePromise: <R = never, A = unknown, E = unknown>() => Effect.Effect<(<XE extends E, XA extends A>(effect: Effect.Effect<XA, XE, R>, options?: Runtime.RunForkOptions | undefined) => Promise<XA>), never, Scope.Scope | R>\n```\n\n----------------------------------------\n\nTITLE: Declaring Type Guard Function in TypeScript\nDESCRIPTION: This snippet declares a type guard function `isComposite` that checks if the provided issue is a Composite. It enhances type safety by allowing TypeScript to infer the type of issue when this function returns true. The function requires an input of type ParseIssue and returns a boolean value indicating if the issue is a Composite.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/ParseResult-isComposite.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const isComposite: (issue: ParseIssue) => issue is Composite\n```\n\n----------------------------------------\n\nTITLE: Declaring greaterThan Filter in Effect Schema\nDESCRIPTION: This code snippet demonstrates the declaration of the `greaterThan` filter within the Effect Schema module. It defines the filter's type signature, specifying that it accepts an exclusive minimum (a number) and optional annotations. The filter transforms a Schema such that its values must be greater than the exclusive minimum. It returns a new filter.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Schema-greaterThan.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const greaterThan: <S extends Schema.Any>(exclusiveMinimum: number, annotations?: Annotations.Filter<Schema.Type<S>>) => <A extends number>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>) => filter<S>\n```\n\n----------------------------------------\n\nTITLE: Effect.tapErrorTag Function Signature in TypeScript\nDESCRIPTION: This code snippet shows the type signature of the Effect.tapErrorTag function. It defines the function's polymorphic nature and its ability to work with different error types and effects.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-tapErrorTag.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const tapErrorTag: { <K extends E extends { _tag: string; } ? E[\"_tag\"] : never, E, A1, E1, R1>(k: K, f: (e: NoInfer<Extract<E, { _tag: K; }>>) => Effect<A1, E1, R1>): <A, R>(self: Effect<A, E, R>) => Effect<A, E | E1, R1 | R>; <A, E, R, K extends E extends { _tag: string; } ? E[\"_tag\"] : never, A1, E1, R1>(self: Effect<A, E, R>, k: K, f: (e: Extract<E, { _tag: K; }>) => Effect<A1, E1, R1>): Effect<A, E | E1, R | R1>; }\n```\n\n----------------------------------------\n\nTITLE: Defining squareBracketed Function in TypeScript\nDESCRIPTION: This code snippet defines the squareBracketed function in the Doc module. It takes a Doc<A> as input and returns a new Doc<A> with the content enclosed in square brackets.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Doc-squareBracketed.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const squareBracketed: <A>(self: Doc<A>) => Doc<A>\n```\n\n----------------------------------------\n\nTITLE: Using Trie.size in TypeScript with Effect Library\nDESCRIPTION: This example demonstrates how to create a Trie, insert elements, and use the Trie.size function to get the number of entries. It uses the effect library and Node.js assert for verification.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Trie-size.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { Trie } from \"effect\"\n\nconst trie = Trie.empty<number>().pipe(\n  Trie.insert(\"a\", 0),\n  Trie.insert(\"b\", 1)\n)\n\nassert.equal(Trie.size(trie), 2)\n```\n\n----------------------------------------\n\nTITLE: Retrieving Annotations from TestAnnotationMap in TypeScript\nDESCRIPTION: This function retrieves the annotation of a specified type from a TestAnnotationMap. If the annotation is not present, it returns a default value. It supports both curried and non-curried function calls.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TestAnnotationMap-get.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const get: (<A>(key: TestAnnotation.TestAnnotation<A>) => (self: TestAnnotationMap) => A) & (<A>(self: TestAnnotationMap, key: TestAnnotation.TestAnnotation<A>) => A)\n```\n\n----------------------------------------\n\nTITLE: Declaring STM.unlessSTM in Typescript\nDESCRIPTION: This code snippet shows the declaration of the `unlessSTM` function within the `STM` module of the Effect library. The `unlessSTM` function takes two STM transactions: one to determine a boolean predicate and another to execute if the predicate is false. The function returns an STM transaction that yields `Option.Option<A>`.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/STM-unlessSTM.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const unlessSTM: { <E2, R2>(predicate: STM<boolean, E2, R2>): <A, E, R>(self: STM<A, E, R>) => STM<Option.Option<A>, E2 | E, R2 | R>; <A, E, R, E2, R2>(self: STM<A, E, R>, predicate: STM<boolean, E2, R2>): STM<Option.Option<A>, E | E2, R | R2>; }\n```\n\n----------------------------------------\n\nTITLE: Defining DecodeException Interface in TypeScript\nDESCRIPTION: Definition of the DecodeException interface which represents a checked exception that occurs when decoding fails. The interface includes a tag identifier, a type ID symbol, the input string that failed decoding, and an optional error message.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Encoding-DecodeException.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface DecodeException {\n  readonly _tag: \"DecodeException\"\n  readonly [DecodeExceptionTypeId]: DecodeExceptionTypeId\n  readonly input: string\n  readonly message?: string\n}\n```\n\n----------------------------------------\n\nTITLE: Defining RunnerUnavailable Error Class in TypeScript\nDESCRIPTION: Defines a class representing an error condition when a cluster Runner becomes unresponsive. This error class is used in the Effect cluster system to handle runner availability issues.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/ClusterError-RunnerUnavailable.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare class RunnerUnavailable\n```\n\n----------------------------------------\n\nTITLE: Defining TPriorityQueue Interface TypeScript\nDESCRIPTION: The snippet defines a TypeScript interface for TPriorityQueue, a component of the Effect-TS library that allows manipulation of elements in a queue based on priority. It requires the type parameter A, where an order is defined. The interface extends TPriorityQueue.Variance<A>, indicating variance support. Elements are retrieved based on their priority, and equal-priority order is not guaranteed.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TPriorityQueue-TPriorityQueue.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport interface TPriorityQueue<in out A> extends TPriorityQueue.Variance<A> {}\n```\n\n----------------------------------------\n\nTITLE: Creating Stream from Iterator in TypeScript\nDESCRIPTION: This snippet declares the 'fromIteratorSucceed' function, which generates a stream from a provided iterable iterator. It optionally accepts a 'maxChunkSize' parameter to specify the maximum size of chunks to be processed. Required types include 'IterableIterator' for the input, and the function returns a 'Stream' of the specified type 'A'.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-fromIteratorSucceed.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const fromIteratorSucceed: <A>(iterator: IterableIterator<A>, maxChunkSize?: number) => Stream<A>\n```\n\n----------------------------------------\n\nTITLE: Defining StreamEmit.Emit Interface in TypeScript\nDESCRIPTION: TypeScript interface definition for StreamEmit.Emit that represents an asynchronous callback handling multiple stream emissions. The interface takes generic type parameters for environment (R), error (E), value (A), and result (B) types. The callback processes Effect<Chunk<A>, Option<E>, R> and returns a Promise<B>.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/StreamEmit-Emit.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface Emit<in R, in E, in A, out B> extends EmitOps<R, E, A, B> {\n  (f: Effect.Effect<Chunk.Chunk<A>, Option.Option<E>, R>): Promise<B>\n}\n```\n\n----------------------------------------\n\nTITLE: Using zipWithNext Stream Operation - TypeScript Example\nDESCRIPTION: Example showing how to use zipWithNext to pair each element with the next element in a stream. Each element is paired with an Option containing the next element, with the last element paired with None.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-zipWithNext.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Chunk, Effect, Stream } from \"effect\"\n\nconst stream = Stream.zipWithNext(Stream.make(1, 2, 3, 4))\n\nEffect.runPromise(Stream.runCollect(stream)).then((chunk) => console.log(Chunk.toArray(chunk)))\n// [\n//   [ 1, { _id: 'Option', _tag: 'Some', value: 2 } ],\n//   [ 2, { _id: 'Option', _tag: 'Some', value: 3 } ],\n//   [ 3, { _id: 'Option', _tag: 'Some', value: 4 } ],\n//   [ 4, { _id: 'Option', _tag: 'None' } ]\n// ]\n```\n\n----------------------------------------\n\nTITLE: Creating a TSet with Initial Values in TypeScript\nDESCRIPTION: This code snippet defines the `make` function, which constructs a new `TSet` and initializes it with the provided elements. It operates within the context of an STM transaction, ensuring atomicity and consistency. The function returns an STM action that, when executed, produces the new `TSet`.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TSet-make.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const make: <Elements extends Array<any>>(...elements: Elements) => STM.STM<TSet<Elements[number]>>\n```\n\n----------------------------------------\n\nTITLE: Constructing GroupBy from Stream in TypeScript\nDESCRIPTION: The make function constructs a GroupBy instance from a Stream containing key-value pairs. It takes a Stream of tuples containing a key and a Queue.Dequeue of Take values and returns a GroupBy instance.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/GroupBy-make.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const make: <K, V, E, R>(grouped: Stream.Stream<readonly [K, Queue.Dequeue<Take.Take<V, E>>], E, R>) => GroupBy<K, V, E, R>\n```\n\n----------------------------------------\n\nTITLE: Declaring the Either Wrapper for Micro Effect in TypeScript\nDESCRIPTION: The purpose of this snippet is to transform a 'Micro' effect's success value into an 'Either' type. This is achieved by wrapping successful outcomes with 'Right' and associating potential errors with 'Left'. It relies on the presence of the 'Either' type and the 'Micro' effect to function correctly, and is utilized for ensuring robust error handling. The function does not explicitly require inputs and assumed to run within a context where 'Micro' effect is applicable.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Micro-either.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const either: <A, E, R>(self: Micro<A, E, R>) => Micro<Either.Either<A, E>, never, R>\n```\n\n----------------------------------------\n\nTITLE: Function Signature for Array.append in TypeScript\nDESCRIPTION: This code block shows the TypeScript function signature for the Array.append function. It illustrates the function's polymorphic nature, allowing it to work with different types of arrays and elements.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Array-append.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const append: { <B>(last: B): <A>(self: Iterable<A>) => NonEmptyArray<A | B>; <A, B>(self: Iterable<A>, last: B): NonEmptyArray<A | B>; }\n```\n\n----------------------------------------\n\nTITLE: RateLimiter.withCost Function Signature in TypeScript\nDESCRIPTION: The type signature of the RateLimiter.withCost function. It takes a cost as a number and returns a function that applies this cost to an Effect.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/RateLimiter-withCost.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const withCost: (cost: number) => <A, E, R>(effect: Effect<A, E, R>) => Effect<A, E, R>\n```\n\n----------------------------------------\n\nTITLE: Either.liftPredicate Function Signature in TypeScript\nDESCRIPTION: This code block provides the type signature for the Either.liftPredicate function. It shows various overloads to handle different use cases with refinements and predicates.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Either-liftPredicate.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const liftPredicate: { <A, B extends A, E>(refinement: Refinement<NoInfer<A>, B>, orLeftWith: (a: NoInfer<A>) => E): (a: A) => Either<B, E>; <A, E>(predicate: Predicate<NoInfer<A>>, orLeftWith: (a: NoInfer<A>) => E): (a: A) => Either<A, E>; <A, E, B extends A>(self: A, refinement: Refinement<A, B>, orLeftWith: (a: A) => E): Either<B, E>; <A, E>(self: A, predicate: Predicate<NoInfer<A>>, orLeftWith: (a: NoInfer<A>) => E): Either<A, E>; }\n```\n\n----------------------------------------\n\nTITLE: Iterating Trie entries with Trie.entries in Typescript\nDESCRIPTION: This example demonstrates how to use `Trie.entries` to obtain an iterable iterator of key-value pairs from a `Trie`. The entries are then converted into an array and asserted to be in alphabetical order.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Trie-entries.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { Trie } from \"effect\"\n\nconst trie = Trie.empty<number>().pipe(\n  Trie.insert(\"call\", 0),\n  Trie.insert(\"me\", 1)\n)\n\nconst result = Array.from(Trie.entries(trie))\nassert.deepStrictEqual(result, [[\"call\", 0], [\"me\", 1]])\n```\n\n----------------------------------------\n\nTITLE: Running Micro Effect in New MicroFiber - TypeScript\nDESCRIPTION: Function signature for forking a Micro effect into a new MicroFiber. The fork operation allows the Micro effect to be executed independently while maintaining the ability to await, join or abort it. The forked Micro will be automatically aborted when the parent Micro completes.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Micro-fork.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const fork: <A, E, R>(self: Micro<A, E, R>) => Micro<MicroFiber<A, E>, never, R>\n```\n\n----------------------------------------\n\nTITLE: Checking Layer Freshness in TypeScript\nDESCRIPTION: The isFresh function determines if a specified Layer is a fresh version that will not be shared. It takes a Layer as input and returns a boolean value. This function is part of the Layer module in the effect package.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Layer-isFresh.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const isFresh: <RIn, E, ROut>(self: Layer<ROut, E, RIn>) => boolean\n```\n\n----------------------------------------\n\nTITLE: Declaring the Difference Operation for TSet in TypeScript\nDESCRIPTION: This code snippet provides a declaration for the 'difference' operation on TSet instances, allowing atomic transformation of a set into the difference between itself and another given set. It leverages the STM.STM<void> type to ensure atomic execution. The usage of generic type <A> ensures type safety for elements contained within the TSet. No external dependencies beyond STM and TSet modules are required.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TSet-difference.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const difference: { <A>(other: TSet<A>): (self: TSet<A>) => STM.STM<void>; <A>(self: TSet<A>, other: TSet<A>): STM.STM<void>; }\n```\n\n----------------------------------------\n\nTITLE: Creating dotenv ConfigProvider using TypeScript\nDESCRIPTION: The 'fromDotEnv' function is declared to create a ConfigProvider from specified dotenv file paths. It returns an Effect wrapper of ConfigProvider that can handle platform errors related to filesystem operations. This function is part of the platform module and requires paths to dotenv files as parameters, aiding in the configuration setup of applications.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/PlatformConfigProvider-fromDotEnv.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const fromDotEnv: (paths: string) => Effect.Effect<ConfigProvider.ConfigProvider, PlatformError, FileSystem.FileSystem>\n```\n\n----------------------------------------\n\nTITLE: Declaring fromFiberEffect Function in TypeScript\nDESCRIPTION: Defines a function that creates an Effect value representing the exit value of a fiber obtained from an effect. It takes a fiber effect as input and returns an Effect.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-fromFiberEffect.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const fromFiberEffect: <A, E, R>(fiber: Effect<Fiber.Fiber<A, E>, E, R>) => Effect<A, E, R>\n```\n\n----------------------------------------\n\nTITLE: Checking BothRunning State in MergeState - TypeScript\nDESCRIPTION: The isBothRunning function is a type predicate that determines if a given MergeState is in the BothRunning state. It takes a MergeState object as input and returns a boolean indicating whether it's a BothRunning state. This function is useful for type narrowing in conditional branches.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/MergeState-isBothRunning.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const isBothRunning: <Env, Err, Err1, Err2, Elem, Done, Done1, Done2>(self: MergeState<Env, Err, Err1, Err2, Elem, Done, Done1, Done2>) => self is BothRunning<Env, Err, Err1, Err2, Elem, Done, Done1, Done2>\n```\n\n----------------------------------------\n\nTITLE: Implementing setIfAbsent Method for Transactional Maps in TypeScript\nDESCRIPTION: The setIfAbsent function stores a new key-value binding in the map only if the key does not already exist. It operates within the STM (Software Transactional Memory) context and returns an STM effect that resolves to void.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TMap-setIfAbsent.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const setIfAbsent: { <K, V>(key: K, value: V): (self: TMap<K, V>) => STM.STM<void>; <K, V>(self: TMap<K, V>, key: K, value: V): STM.STM<void>; }\n```\n\n----------------------------------------\n\nTITLE: Type Signature for whenLogLevel Function in TypeScript\nDESCRIPTION: Shows the type signature of the `whenLogLevel` function. The function supports both curried and uncurried forms, taking an effect and a log level, and returns an effect that yields an Option containing the result if the log level is enabled.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-whenLogLevel.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const whenLogLevel: { (level: LogLevel.LogLevel | LogLevel.Literal): <A, E, R>(self: Effect<A, E, R>) => Effect<Option.Option<A>, E, R>; <A, E, R>(self: Effect<A, E, R>, level: LogLevel.LogLevel | LogLevel.Literal): Effect<Option.Option<A>, E, R>; }\n```\n\n----------------------------------------\n\nTITLE: TArray.minOption Signature in TypeScript\nDESCRIPTION: The `minOption` function atomically computes the least element in a TArray. It takes an `Order` to define the comparison logic and the `TArray` itself. It returns an STM effect that resolves to an Option containing the minimum element, or None if the array is empty.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TArray-minOption.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const minOption: { <A>(order: Order.Order<A>): (self: TArray<A>) => STM.STM<Option.Option<A>>; <A>(self: TArray<A>, order: Order.Order<A>): STM.STM<Option.Option<A>>; }\n```\n\n----------------------------------------\n\nTITLE: Folding over ChildExecutorDecision in TypeScript\nDESCRIPTION: The match function is a higher-order function that takes options for handling different ChildExecutorDecision states (continue, close, yield) and returns a function that processes a ChildExecutorDecision to produce a value. It can also be used in a curried form where the decision and options are provided together.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/ChildExecutorDecision-match.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const match: { <A>(options: { readonly onContinue: () => A; readonly onClose: (value: unknown) => A; readonly onYield: () => A; }): (self: ChildExecutorDecision) => A; <A>(self: ChildExecutorDecision, options: { readonly onContinue: () => A; readonly onClose: (value: unknown) => A; readonly onYield: () => A; }): A; }\n```\n\n----------------------------------------\n\nTITLE: Adding Finalizer to MicroScope in TypeScript\nDESCRIPTION: Function signature for adding a finalizer to the current MicroScope. The finalizer takes a MicroExit parameter containing unknown error and value types, and returns a Micro<void>. This function is part of the Micro module available since version 3.4.0.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Micro-addFinalizer.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const addFinalizer: (finalizer: (exit: MicroExit<unknown, unknown>) => Micro<void>) => Micro<void, never, MicroScope>\n```\n\n----------------------------------------\n\nTITLE: Retrieving Total Read Locks in TReentrantLock using TypeScript\nDESCRIPTION: This code snippet declares a function that retrieves the total number of read locks acquired on a TReentrantLock instance. It uses STM, a part of Effect-TS for handling state transitions in a thread-safe manner. The function takes a TReentrantLock instance as a parameter and returns an STM operation that yields the number of read locks.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TReentrantLock-readLocks.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const readLocks: (self: TReentrantLock) => STM.STM<number>\n```\n\n----------------------------------------\n\nTITLE: Creating a HashSet from a JavaScript Set in TypeScript\nDESCRIPTION: Shows how to convert a JavaScript Set into an Effect HashSet. The example demonstrates how the HashSet preserves the unique nature of the original Set.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/HashSet-fromIterable.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n// Creating a HashSet from a Set\nimport { HashSet, pipe } from \"effect\"\n\nconsole.log(\n  pipe(\n    new Set([\"apple\", \"banana\", \"orange\", \"apple\"]), // Set<string> is an Iterable<string>\n    HashSet.fromIterable,\n    HashSet.toValues\n  )\n) // Output: [\"apple\", \"banana\", \"orange\"]\n```\n\n----------------------------------------\n\nTITLE: Doc.fillBreak Function Signature\nDESCRIPTION: Type declaration for the fillBreak function showing its polymorphic implementation that can be used either with curried or regular parameter passing styles.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Doc-fillBreak.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const fillBreak: { (w: number): <A>(self: Doc<A>) => Doc<A>; <A>(self: Doc<A>, w: number): Doc<A>; }\n```\n\n----------------------------------------\n\nTITLE: Creating List from Iterable in TypeScript\nDESCRIPTION: The fromIterable function creates a new List from an iterable collection of values. It takes an Iterable<A> as input and returns a List<A>.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/List-fromIterable.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const fromIterable: <A>(prefix: Iterable<A>) => List<A>\n```\n\n----------------------------------------\n\nTITLE: Checking if a Doc is a Line in TypeScript\nDESCRIPTION: A utility function that returns true if the provided Doc is a Line, false otherwise. The function uses a type predicate to narrow the type of the input in TypeScript's type system.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Doc-isLine.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const isLine: <A>(self: Doc<A>) => self is Line<A>\n```\n\n----------------------------------------\n\nTITLE: HashSet Difference Type Definition in TypeScript\nDESCRIPTION: Type definition for the HashSet.difference operation showing both data-first and data-last function signatures. The operation works with any type A that maintains consistent hash and equal implementations.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/HashSet-difference.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const difference: { <A>(that: Iterable<A>): (self: HashSet<A>) => HashSet<A>; <A>(self: HashSet<A>, that: Iterable<A>): HashSet<A>; }\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Trie.isEmpty Usage in TypeScript\nDESCRIPTION: This example demonstrates how to use the Trie.isEmpty function to check if a Trie contains any entries. It creates an empty Trie, inserts an entry, and then checks the isEmpty status of both Tries.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Trie-isEmpty.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { Trie } from \"effect\"\n\nconst trie = Trie.empty<number>()\nconst trie1 = trie.pipe(Trie.insert(\"ma\", 0))\n\nassert.equal(Trie.isEmpty(trie), true)\nassert.equal(Trie.isEmpty(trie1), false)\n```\n\n----------------------------------------\n\nTITLE: Combining FiberRefsPatch Objects in TypeScript\nDESCRIPTION: Function that combines two FiberRefsPatch objects to create a new patch that applies their changes sequentially. The function provides both curried and uncurried versions for flexibility.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/FiberRefsPatch-combine.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const combine: { (that: FiberRefsPatch): (self: FiberRefsPatch) => FiberRefsPatch; (self: FiberRefsPatch, that: FiberRefsPatch): FiberRefsPatch; }\n```\n\n----------------------------------------\n\nTITLE: Extracting Option value or throwing error in TypeScript\nDESCRIPTION: The `Option.getOrThrow` function extracts the value from an `Option` if it is `Some`. If the `Option` is `None`, it throws a default error. This function is suitable for scenarios where the absence of a value should be treated as an exceptional case and results in an error.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Option-getOrThrow.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { Option } from \"effect\"\n\nassert.deepStrictEqual(Option.getOrThrow(Option.some(1)), 1)\nassert.throws(() => Option.getOrThrow(Option.none()))\n```\n\n----------------------------------------\n\nTITLE: Controlling Concurrency with Micro.withConcurrency in TypeScript\nDESCRIPTION: Demonstrates how to use the `withConcurrency` function to set specific concurrency levels for a Micro instance that was created with 'inherit' concurrency. This allows dynamic control over how many operations can run simultaneously.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Micro-withConcurrency.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as Micro from \"effect/Micro\"\n\nMicro.forEach([1, 2, 3], (n) => Micro.succeed(n), {\n  concurrency: \"inherit\"\n}).pipe(\n  Micro.withConcurrency(2) // use a concurrency of 2\n)\n```\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const withConcurrency: { (concurrency: \"unbounded\" | number): <A, E, R>(self: Micro<A, E, R>) => Micro<A, E, R>; <A, E, R>(self: Micro<A, E, R>, concurrency: \"unbounded\" | number): Micro<A, E, R>; }\n```\n\n----------------------------------------\n\nTITLE: Defining Fiber Descriptor Interface in TypeScript\nDESCRIPTION: This code defines the Descriptor interface for the Fiber module, which contains information about a Fiber including its ID, status, and interruptors. The interface helps in tracking and managing fibers within the effect system.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Fiber-Fiber.Descriptor.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport interface Descriptor {\n    /**\n     * The fiber's unique identifier.\n     */\n    readonly id: FiberId.FiberId\n    /**\n     * The status of the fiber.\n     */\n    readonly status: FiberStatus.FiberStatus\n    /**\n     * The set of fibers attempting to interrupt the fiber or its ancestors.\n     */\n    readonly interruptors: HashSet.HashSet<FiberId.FiberId>\n  }\n```\n\n----------------------------------------\n\nTITLE: Creating Dual Function Using Call Signatures in TypeScript\nDESCRIPTION: Example demonstrating how to define a dual function using explicit call signatures for the overloads. This approach provides type definitions directly in the variable declaration rather than through generics.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Function-dual.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { dual, pipe } from \"effect/Function\"\n\nconst sum: {\n  (that: number): (self: number) => number\n  (self: number, that: number): number\n} = dual(2, (self: number, that: number): number => self + that)\n\nconsole.log(sum(2, 3)) // 5\nconsole.log(pipe(2, sum(3))) // 5\n```\n\n----------------------------------------\n\nTITLE: Retrieving Failure Cause in Effect using TypeScript\nDESCRIPTION: This snippet demonstrates how to use Effect.cause to retrieve and log the detailed cause of a failure in an effect. It creates a program that fails, then recovers by logging the cause of the failure.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-cause.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Effect, Console } from \"effect\"\n\n//      ┌─── Effect<number, string, never>\n//      ▼\nconst program = Effect.fail(\"Oh uh!\").pipe(Effect.as(2))\n\n//      ┌─── Effect<void, never, never>\n//      ▼\nconst recovered = Effect.gen(function* () {\n  const cause = yield* Effect.cause(program)\n  yield* Console.log(cause)\n})\n```\n\n----------------------------------------\n\nTITLE: Updating Metrics in Effect-TS\nDESCRIPTION: Defines a type-safe method for updating metrics with input values. The method is overloaded to support both curried and regular function call patterns. Returns an Effect that resolves to void after updating the metric.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Metric-update.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const update: {\n  <In>(input: In): <Type, Out>(self: Metric<Type, In, Out>) => Effect.Effect<void>;\n  <Type, In, Out>(self: Metric<Type, In, Out>, input: In): Effect.Effect<void>;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Union Interface for Document Union in TypeScript\nDESCRIPTION: This code snippet defines the Union interface, which extends Doc.Variance<A> and represents the union of two documents. It includes properties for the tag and the left and right documents. The interface is used to implement layout alternatives for the 'group' functionality in the Effect Printer library.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Doc-Union.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface Union<A> extends Doc.Variance<A> {\n  readonly _tag: \"Union\"\n  readonly left: Doc<A>\n  readonly right: Doc<A>\n}\n```\n\n----------------------------------------\n\nTITLE: Converting Channel to Stream in TypeScript\nDESCRIPTION: The `toStream` function converts a Channel that outputs chunks of elements to a Stream. This function allows for seamless transformation between the two effect data structures, making it easier to work with streaming data in the Effect ecosystem.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Channel-toStream.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const toStream: <OutElem, OutErr, OutDone, Env>(self: Channel<Chunk.Chunk<OutElem>, unknown, OutErr, unknown, OutDone, unknown, Env>) => Stream.Stream<OutElem, OutErr, Env>\n```\n\n----------------------------------------\n\nTITLE: Checking for Nullable Values in TypeScript using Effect-TS\nDESCRIPTION: This snippet demonstrates the use of the `isNullable` function from the Effect-TS library to assert that the inputs are either null or undefined. The function returns a boolean indicating the nullability of the input parameter.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Predicate-isNullable.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { isNullable } from \"effect/Predicate\"\n\nassert.deepStrictEqual(isNullable(null), true)\nassert.deepStrictEqual(isNullable(undefined), true)\n\nassert.deepStrictEqual(isNullable({}), false)\nassert.deepStrictEqual(isNullable([]), false)\n```\n\n----------------------------------------\n\nTITLE: Implementing Effect Logger with logFmt\nDESCRIPTION: Demonstrates how to use the logFmt logger to output human-readable logs with annotations and spans. The logger includes timestamps, log levels, fiber IDs, messages, and custom key-value pairs.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Logger-logFmt.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Effect, Logger } from \"effect\"\n\nconst program = Effect.log(\"message1\", \"message2\").pipe(\n  Effect.annotateLogs({ key1: \"value1\", key2: \"value2\" }),\n  Effect.withLogSpan(\"myspan\")\n)\n\nEffect.runFork(program.pipe(Effect.provide(Logger.logFmt)))\n// timestamp=... level=INFO fiber=#0 message=message1 message=message2 myspan=0ms key2=value2 key1=value1\n```\n\n----------------------------------------\n\nTITLE: Implementing Effect Replication in TypeScript\nDESCRIPTION: Function signature for replicating a Micro effect n times. The function can be called in two ways: either by passing the number first and then the effect, or by passing the effect first and then the number. Returns an array of replicated effects.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Micro-replicate.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const replicate: { (n: number): <A, E, R>(self: Micro<A, E, R>) => Array<Micro<A, E, R>>; <A, E, R>(self: Micro<A, E, R>, n: number): Array<Micro<A, E, R>>; }\n```\n\n----------------------------------------\n\nTITLE: Function Signature for DateTime.makeZoned in TypeScript\nDESCRIPTION: Shows the TypeScript function signature for the DateTime.makeZoned function. It takes an input of type DateTime.Input and an optional options object, returning an Option.Option<Zoned>.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/DateTime-makeZoned.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const makeZoned: (input: DateTime.Input, options?: { readonly timeZone?: number | string | TimeZone | undefined; readonly adjustForTimeZone?: boolean | undefined; }) => Option.Option<Zoned>\n```\n\n----------------------------------------\n\nTITLE: Extracting Thread Name from FiberId in TypeScript\nDESCRIPTION: A function that creates a string representation of the current thread of execution from a specified FiberId. This utility helps in identifying and tracking different execution threads in an Effect-based application.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/FiberId-threadName.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const threadName: (self: FiberId) => string\n```\n\n----------------------------------------\n\nTITLE: Defining Channel.mapInput Function in TypeScript\nDESCRIPTION: Function signature for Channel.mapInput which takes a transformation function and returns a new channel that applies this function to the input channel's done value. The function supports both curried and uncurried calling styles.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Channel-mapInput.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const mapInput: { <InDone0, InDone>(f: (a: InDone0) => InDone): <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>) => Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone0, Env>; <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, InDone0>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>, f: (a: InDone0) => InDone): Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone0, Env>; }\n```\n\n----------------------------------------\n\nTITLE: Retrieving Queue Size with TQueue.size in Typescript\nDESCRIPTION: The size function retrieves the number of elements in a transactional queue. It works with both TDequeue and TEnqueue types and may return negative values if fibers are suspended waiting for elements to be added to the queue.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TQueue-size.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const size: <A>(self: TDequeue<A> | TEnqueue<A>) => STM.STM<number>\n```\n\n----------------------------------------\n\nTITLE: RedBlackTree forEachBetween TypeScript Declaration\nDESCRIPTION: This snippet shows the TypeScript declaration for the `forEachBetween` function. It accepts options including min, max keys and a body function to execute for each node within the specified range. The function can be called either with options as the first argument and the RedBlackTree as the second, or vice-versa.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/RedBlackTree-forEachBetween.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const forEachBetween: { <K, V>(options: { readonly min: K; readonly max: K; readonly body: (key: K, value: V) => void; }): (self: RedBlackTree<K, V>) => void; <K, V>(self: RedBlackTree<K, V>, options: { readonly min: K; readonly max: K; readonly body: (key: K, value: V) => void; }): void; }\n```\n\n----------------------------------------\n\nTITLE: Function Signature for getOrThrowWith\nDESCRIPTION: Type declaration for the getOrThrowWith function, showing its polymorphic nature and type parameters. Supports both curried and non-curried usage patterns.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Either-getOrThrowWith.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const getOrThrowWith: { <L>(onLeft: (left: L) => unknown): <A>(self: Either<A, L>) => A; <R, L>(self: Either<R, L>, onLeft: (left: L) => unknown): R; }\n```\n\n----------------------------------------\n\nTITLE: Match.option Function Signature in TypeScript\nDESCRIPTION: This code snippet shows the TypeScript signature for the Match.option function. It defines the function's type parameters and return type, illustrating how it transforms a Matcher into an Option-wrapped result.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Match-option.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const option: <I, F, R, A, Pr, Ret>(self: Matcher<I, F, R, A, Pr, Ret>) => [Pr] extends [never] ? (input: I) => Option.Option<Unify<A>> : Option.Option<Unify<A>>\n```\n\n----------------------------------------\n\nTITLE: Trie.filterMap Function Signature in TypeScript\nDESCRIPTION: The type signature for the Trie.filterMap function, which takes a function that maps values and keys to Options and returns a new Trie with filtered and mapped entries.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Trie-filterMap.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const filterMap: { <A, B>(f: (value: A, key: string) => Option<B>): (self: Trie<A>) => Trie<B>; <A, B>(self: Trie<A>, f: (value: A, key: string) => Option<B>): Trie<B>; }\n```\n\n----------------------------------------\n\nTITLE: Constructing a Sink with Scope using unwrapScopedWith in TypeScript\nDESCRIPTION: The unwrapScopedWith function creates a Sink from a function that receives a Scope and returns an Effect that resolves to a Sink if successful. It's useful for creating Sinks that require scoped resources.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Sink-unwrapScopedWith.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const unwrapScopedWith: <A, In, L, E, R>(f: (scope: Scope.Scope) => Effect.Effect<Sink<A, In, L, E, R>, E, R>) => Sink<A, In, L, E, R>\n```\n\n----------------------------------------\n\nTITLE: Trie.fromIterable Function Signature in TypeScript\nDESCRIPTION: The type signature for the Trie.fromIterable function, which takes an iterable of key/value pairs and returns a new Trie.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Trie-fromIterable.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const fromIterable: <V>(entries: Iterable<readonly [string, V]>) => Trie<V>\n```\n\n----------------------------------------\n\nTITLE: Doc.fill Function Signature in TypeScript\nDESCRIPTION: The TypeScript type signature for the `fill` function from the @effect/printer module. It shows that `fill` can be used both in pipeable style and with direct application, taking a width parameter and a document object.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Doc-fill.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const fill: { (w: number): <A>(self: Doc<A>) => Doc<A>; <A>(self: Doc<A>, w: number): Doc<A>; }\n```\n\n----------------------------------------\n\nTITLE: Declaring Integer Validation in TypeScript\nDESCRIPTION: This snippet declares a constant `int` which is a function that ensures the provided value is an integer. It utilizes TypeScript's generic features to enforce type safety and leverage annotations for filtering schema types.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Schema-int.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const int: <S extends Schema.Any>(annotations?: Annotations.Filter<Schema.Type<S>>) => <A extends number>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>) => filter<S>\n```\n\n----------------------------------------\n\nTITLE: Using unsafeCoerce for Type Casting in TypeScript\nDESCRIPTION: Demonstrates how to use the `unsafeCoerce` function to cast a value from one type to another. The example shows that `unsafeCoerce` is functionally equivalent to the `identity` function, but with different type signatures.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Function-unsafeCoerce.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { unsafeCoerce, identity } from \"effect/Function\"\n\nassert.deepStrictEqual(unsafeCoerce, identity)\n```\n\n----------------------------------------\n\nTITLE: Request.Class Constructor Type Signature\nDESCRIPTION: Type signature for the Request.Class constructor, showing its generic type parameters and conditional argument type logic. Handles type checking for Success, Error and additional properties.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Request-Class.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const Class: new <Success, Error, A extends Record<string, any>>(args: Types.Equals<Omit<A, keyof Request<unknown, unknown>>, {}> extends true ? void : { readonly [P in keyof A as P extends keyof Request<unknown, unknown> ? never : P]: A[P]; }) => Request<Success, Error> & Readonly<A>\n```\n\n----------------------------------------\n\nTITLE: Defining JsonFromString Field Type for SQL Models in TypeScript\nDESCRIPTION: A function that creates a field representation for JSON values stored as text in a database. It takes a Schema object as input and returns a JsonFromString field type that will handle conversion between JSON and string formats.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Model-JsonFromString.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const JsonFromString: <S extends Schema.Schema.All | Schema.PropertySignature.All>(schema: S) => JsonFromString<S>\n```\n\n----------------------------------------\n\nTITLE: Enabling Multiple RuntimeFlags in Effect-TS (TypeScript)\nDESCRIPTION: This function enables all of the RuntimeFlag values contained in a specified set of RuntimeFlags. It can be used in either curried or uncurried form, accepting the flags to enable and the RuntimeFlags instance to modify.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/RuntimeFlags-enableAll.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const enableAll: { (flags: RuntimeFlags): (self: RuntimeFlags) => RuntimeFlags; (self: RuntimeFlags, flags: RuntimeFlags): RuntimeFlags; }\n```\n\n----------------------------------------\n\nTITLE: Type Signature for isNullable Function in TypeScript\nDESCRIPTION: This snippet provides the TypeScript declaration for the `isNullable` function, defining its input type and return type. It constrains the input to types that can be null or undefined and can be useful for ensuring type safety.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Predicate-isNullable.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const isNullable: <A>(input: A) => input is Extract<A, null | undefined>\n```\n\n----------------------------------------\n\nTITLE: Defining Continue Interface for Child Executor Decision in TypeScript\nDESCRIPTION: This code snippet defines the Continue interface, which extends ChildExecutorDecision.Proto. It represents a decision to continue executing the current substream in a child executor context. The interface has a readonly _tag property set to \"Continue\".\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/ChildExecutorDecision-Continue.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface Continue extends ChildExecutorDecision.Proto {\n  readonly _tag: \"Continue\"\n}\n```\n\n----------------------------------------\n\nTITLE: Disabling RuntimeFlags in Effect-IO TypeScript Library\nDESCRIPTION: The disable function allows turning off a specific RuntimeFlag in a RuntimeFlags instance. It can be used in two ways: either by passing the flag and then the flags object, or by passing the flags object and then the flag.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/RuntimeFlags-disable.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const disable: { (flag: RuntimeFlag): (self: RuntimeFlags) => RuntimeFlags; (self: RuntimeFlags, flag: RuntimeFlag): RuntimeFlags; }\n```\n\n----------------------------------------\n\nTITLE: Creating Data Sources from Effects in TypeScript\nDESCRIPTION: The fromEffect function constructs a data source from an effectual function. It takes a function that transforms a request into an Effect and returns a RequestResolver that can process that type of request.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/RequestResolver-fromEffect.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const fromEffect: <R, A extends Request.Request<any, any>>(f: (a: A) => Effect.Effect<Request.Request.Success<A>, Request.Request.Error<A>, R>) => RequestResolver<A, R>\n```\n\n----------------------------------------\n\nTITLE: Checking if a TQueue Contains Elements in TypeScript\nDESCRIPTION: The isFull function returns a boolean value indicating whether a transactional queue (TQueue) contains at least one element. It works with both TDequeue and TEnqueue types and returns an STM value.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TQueue-isFull.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const isFull: <A>(self: TDequeue<A> | TEnqueue<A>) => STM.STM<boolean>\n```\n\n----------------------------------------\n\nTITLE: TypeScript Signature for Predicate.or Function\nDESCRIPTION: This code snippet shows the TypeScript signature for the Predicate.or function. It defines various overloads for combining predicates and refinements.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Predicate-or.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const or: { <A, C extends A>(that: Refinement<A, C>): <B extends A>(self: Refinement<A, B>) => Refinement<A, B | C>; <A, B extends A, C extends A>(self: Refinement<A, B>, that: Refinement<A, C>): Refinement<A, B | C>; <A>(that: Predicate<A>): (self: Predicate<A>) => Predicate<A>; <A>(self: Predicate<A>, that: Predicate<A>): Predicate<A>; }\n```\n\n----------------------------------------\n\nTITLE: Defining constVoid Function Signature in TypeScript\nDESCRIPTION: This snippet shows the TypeScript signature of the `constVoid` function. It is defined as a constant of type `LazyArg<void>`, which represents a function that takes no arguments and returns void.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Function-constVoid.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const constVoid: LazyArg<void>\n```\n\n----------------------------------------\n\nTITLE: Converting BigDecimal to Number in TypeScript - Usage Example\nDESCRIPTION: Demonstrates how to convert a BigDecimal to a number using unsafeToNumber function with an example using string conversion. Note that this function may produce incorrect results if the BigDecimal exceeds the 64-bit range of a number.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/BigDecimal-unsafeToNumber.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { unsafeToNumber, unsafeFromString } from \"effect/BigDecimal\"\n\nassert.deepStrictEqual(unsafeToNumber(unsafeFromString(\"123.456\")), 123.456)\n```\n\n----------------------------------------\n\nTITLE: Finding Last Index in Transactional Arrays with Effect TS in TypeScript\nDESCRIPTION: The `findLastIndex` function retrieves the last index of a specific value within a transactional array, with an optional boundary index. This utility is part of the Effect TS library \\(`effect`\\), requiring it to be imported as a dependency. Its functionality is designed to work within STM transactions, ensuring thread-safe operations on shared data. The function is generically typed to accommodate any data type `A` and returns an STM-compliant result wrapped in an Option object, indicating the potential absence of the specified value in the array.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TArray-findLastIndex.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const findLastIndex: { <A>(value: A): (self: TArray<A>) => STM.STM<Option.Option<number>>; <A>(self: TArray<A>, value: A): STM.STM<Option.Option<number>>; }\n```\n\n----------------------------------------\n\nTITLE: Type Signature for Data.TaggedEnum in TypeScript\nDESCRIPTION: Provides the type signature for the Data.TaggedEnum type. It uses conditional types and mapped types to create a union of tagged structs based on the input type A.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Data-TaggedEnum.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ntype TaggedEnum<A> = keyof A extends infer Tag ?\n  Tag extends keyof A ? Types.Simplify<{ readonly _tag: Tag } & { readonly [K in keyof A[Tag]]: A[Tag][K] }>\n  : never\n  : never\n```\n\n----------------------------------------\n\nTITLE: Declaring transformLiteral Signature in TypeScript\nDESCRIPTION: This snippet defines the TypeScript signature for the 'transformLiteral' function, which specifies the types of the input and output parameters. It indicates that the function takes two parameters: 'from' of type 'Encoded' and 'to' of type 'Type', and returns a transformed type. This ensures type safety when using the function in TypeScript projects.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Schema-transformLiteral.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const transformLiteral: <Encoded extends AST.LiteralValue, Type extends AST.LiteralValue>(from: Encoded, to: Type) => transformLiteral<Type, Encoded>\n```\n\n----------------------------------------\n\nTITLE: Retrieving First Element from Chunk - TypeScript\nDESCRIPTION: Function signature for unsafeHead that returns the first element of a Chunk<A>. This function is unsafe as it will throw an error if the chunk is empty rather than handling the empty case safely.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Chunk-unsafeHead.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const unsafeHead: <A>(self: Chunk<A>) => A\n```\n\n----------------------------------------\n\nTITLE: Declaring productComposition Function in TypeScript\nDESCRIPTION: The `productComposition` function returns a default product composition using SemiApplicative and SemiProduct type classes. It requires two TypeLambda parameters and aids in merging two kinds into a new kind. The function highlights TypeScript's strong type system and generic capabilities, and outputs a new Kind based on the input kinds provided. Essential for developers using effect-ts to compose types with both applicative and product semantics.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/SemiProduct-productComposition.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const productComposition: <F extends TypeLambda, G extends TypeLambda>(F: SemiApplicative<F>, G: SemiProduct<G>) => <FR1, FO1, FE1, GR1, GO1, GE1, A, FR2, FO2, FE2, GR2, GO2, GE2, B>(self: Kind<F, FR1, FO1, FE1, Kind<G, GR1, GO1, GE1, A>>, that: Kind<F, FR2, FO2, FE2, Kind<G, GR2, GO2, GE2, B>>) => Kind<F, FR1 & FR2, FO1 | FO2, FE1 | FE2, Kind<G, GR1 & GR2, GO1 | GO2, GE1 | GE2, [A, B]>>\n```\n\n----------------------------------------\n\nTITLE: Declaring Schema for Base64 URL to UTF-8 String Conversion in TypeScript\nDESCRIPTION: This code snippet declares a constant 'StringFromBase64Url' of type Schema that decodes a base64 URL encoded string into a UTF-8 string. It takes a string input and produces a string output, with no error type specified.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Schema-StringFromBase64Url.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const StringFromBase64Url: Schema<string, string, never>\n```\n\n----------------------------------------\n\nTITLE: DateTime.startOf Function Signature in TypeScript\nDESCRIPTION: The type signature for the DateTime.startOf function, which can be used in two ways: as a curried function or with all parameters at once. It accepts a time unit part and optional configuration for specifying which day starts the week.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/DateTime-startOf.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const startOf: { (part: DateTime.UnitSingular, options?: { readonly weekStartsOn?: 0 | 1 | 2 | 3 | 4 | 5 | 6 | undefined; }): <A extends DateTime>(self: A) => A; <A extends DateTime>(self: A, part: DateTime.UnitSingular, options?: { readonly weekStartsOn?: 0 | 1 | 2 | 3 | 4 | 5 | 6 | undefined; }): A; }\n```\n\n----------------------------------------\n\nTITLE: Retrieving First Element from Tuple in TypeScript\nDESCRIPTION: This code illustrates how to retrieve the first element from a tuple using the getFirst function in the Effect-TS library. It requires the Effect-TS library and Node's assert module. The key parameter is a tuple, and the function returns the first element of the tuple. This utility is constrained to tuples with exactly two elements.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Tuple-getFirst.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { getFirst } from \"effect/Tuple\"\n\nassert.deepStrictEqual(getFirst([\"hello\", 42]), \"hello\")\n```\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const getFirst: <L, R>(self: readonly [L, R]) => L\n```\n\n----------------------------------------\n\nTITLE: Defining RequestBlock Type in TypeScript\nDESCRIPTION: Defines the RequestBlock type as a union of Empty, Par, Seq, and Single types. This structure preserves information about which requests must be performed sequentially and which can be performed in parallel.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/RequestBlock-RequestBlock.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ntype RequestBlock = Empty | Par | Seq | Single\n```\n\n----------------------------------------\n\nTITLE: Implementing Scoped Sized Service in TypeScript with Effect\nDESCRIPTION: The withSizedScoped function sets the implementation of the sized service to a specified value and restores it to its original value when the scope is closed. It returns an Effect that requires a Scope and produces no error or value.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TestServices-withSizedScoped.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const withSizedScoped: (sized: Sized.TestSized) => Effect.Effect<void, never, Scope.Scope>\n```\n\n----------------------------------------\n\nTITLE: Removing Annotations from a DocTree in TypeScript\nDESCRIPTION: The unAnnotate function removes all annotations from a DocTree document, effectively converting a DocTree<A> to a DocTree<never>. This is useful when you want to discard annotation metadata while preserving the document structure.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/DocTree-unAnnotate.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const unAnnotate: <A>(self: DocTree<A>) => DocTree<never>\n```\n\n----------------------------------------\n\nTITLE: Defining Deep Optimization Interface in TypeScript\nDESCRIPTION: This code snippet defines the `Deep` interface for deep document fusion optimization. It specifies the structure of the interface to be used in the optimization process, ensuring that the '_tag' property is set to 'Deep'. This interface is essential for indicating that the deep optimization strategy is being applied.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Optimize-Deep.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface Deep {\n  readonly _tag: \"Deep\"\n}\n```\n\n----------------------------------------\n\nTITLE: TypeScript Function Signature for BigDecimal Division\nDESCRIPTION: This code snippet shows the TypeScript function signature for the unsafeDivide function. It demonstrates that the function can be called with two separate arguments or with a curried version taking one argument at a time.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/BigDecimal-unsafeDivide.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const unsafeDivide: { (that: BigDecimal): (self: BigDecimal) => BigDecimal; (self: BigDecimal, that: BigDecimal): BigDecimal; }\n```\n\n----------------------------------------\n\nTITLE: Creating a Cache with make function in Effect.js\nDESCRIPTION: Constructs a new cache with the specified capacity, time to live, and lookup function. This function returns an Effect that creates the cache when executed.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Cache-make.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const make: <Key, Value, Error = never, Environment = never>(options: { readonly capacity: number; readonly timeToLive: Duration.DurationInput; readonly lookup: Lookup<Key, Value, Error, Environment>; }) => Effect.Effect<Cache<Key, Value, Error>, never, Environment>\n```\n\n----------------------------------------\n\nTITLE: Sum function example in Effect/Number\nDESCRIPTION: This example demonstrates how to use the `sum` function from the `effect/Number` module to add two numbers. It imports the `sum` function and uses `assert.deepStrictEqual` to verify the result of the addition.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Number-sum.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { sum } from \"effect/Number\"\n\nassert.deepStrictEqual(sum(2, 3), 5)\n```\n\n----------------------------------------\n\nTITLE: Defining a Right Bracket Document Constant in TypeScript\nDESCRIPTION: Declares a constant 'rbracket' that represents a document containing a single right bracket (']') character. This is part of the document primitives in the Effect printer library used for text layout and formatting.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Doc-rbracket.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const rbracket: Doc<never>\n```\n\n----------------------------------------\n\nTITLE: Creating Summary Metric Key in TypeScript\nDESCRIPTION: Function signature for creating a metric key for a summary. Takes an options object containing name, maxAge duration, maxSize, error margin, quantiles array, and optional description.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/MetricKey-summary.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const summary: (options: { readonly name: string; readonly maxAge: Duration.DurationInput; readonly maxSize: number; readonly error: number; readonly quantiles: ReadonlyArray<number>; readonly description?: string | undefined; }) => MetricKey.Summary\n```\n\n----------------------------------------\n\nTITLE: Schema.brand Function Signature\nDESCRIPTION: This snippet presents the TypeScript signature of the `Schema.brand` function.  It shows the generic types used for the schema and the brand, and the function's return type which is another schema with the brand applied. The annotations parameter allows for adding schema annotations.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Schema-brand.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const brand: <S extends Schema.AnyNoContext, B extends string | symbol>(brand: B, annotations?: Annotations.Schema<Schema.Type<S> & Brand<B>>) => (self: S) => brand<S, B>\n```\n\n----------------------------------------\n\nTITLE: Defining MetricLabel Interface for Metric Analysis in TypeScript\nDESCRIPTION: Interface definition for MetricLabel that extends Equal and Pipeable interfaces. It represents a key-value pair structure used for analyzing metrics with additional granularity, such as tracking response times for different clients.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/MetricLabel-MetricLabel.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface MetricLabel extends Equal.Equal, Pipeable {\n  readonly [MetricLabelTypeId]: MetricLabelTypeId\n  readonly key: string\n  readonly value: string\n}\n```\n\n----------------------------------------\n\nTITLE: Declaring the eraseUp ANSI Terminal Control Function in TypeScript\nDESCRIPTION: Defines the eraseUp constant of type AnsiDoc that clears from the current cursor position to the beginning of the screen without changing the cursor position.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/AnsiDoc-eraseUp.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const eraseUp: AnsiDoc\n```\n\n----------------------------------------\n\nTITLE: Declaring failCause in Effect Stream TypeScript\nDESCRIPTION: The failCause function in the Stream module of Effect always fails with a specified cause. It relies on the Cause type from the Effect library as a dependency. The function takes a cause of type Cause.Cause<E> as a parameter, indicating the error type. This function is useful in scenarios where consistent failure of streams is required based on a predetermined cause. It returns a stream that never emits any value but always errors out with the given cause.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-failCause.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const failCause: <E>(cause: Cause.Cause<E>) => Stream<never, E>\n```\n\n----------------------------------------\n\nTITLE: Generating Capturing RegExp from Template Literal AST in TypeScript\nDESCRIPTION: Function that takes a TemplateLiteral AST node and returns a RegExp that captures the pattern defined by the template literal. This is a variant that specifically includes capturing groups in the generated regular expression pattern.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/SchemaAST-getTemplateLiteralCapturingRegExp.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const getTemplateLiteralCapturingRegExp: (ast: TemplateLiteral) => RegExp\n```\n\n----------------------------------------\n\nTITLE: UnionToIntersection Type Transformation in TypeScript\nDESCRIPTION: This TypeScript code defines a utility type called `UnionToIntersection` which transforms a union type `T` into an intersection type. It achieves this by leveraging conditional types and type inference to extract the intersection of all types within the union.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Types-UnionToIntersection.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ntype UnionToIntersection<T> = (T extends any ? (x: T) => any : never) extends (x: infer R) => any ? R\n  : never\n```\n\n----------------------------------------\n\nTITLE: TypeScript Function Signature for Trie.removeMany\nDESCRIPTION: Provides the TypeScript function signature for the Trie.removeMany function. It shows that the function can be used in two ways: by passing the keys first, or by passing the Trie first.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Trie-removeMany.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const removeMany: { (keys: Iterable<string>): <V>(self: Trie<V>) => Trie<V>; <V>(self: Trie<V>, keys: Iterable<string>): Trie<V>; }\n```\n\n----------------------------------------\n\nTITLE: Retrieving First Element from Iterable in TypeScript\nDESCRIPTION: The head function gets the first element of an Iterable, or returns None if the Iterable is empty. It takes an Iterable<A> as input and returns an Option<A>.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Iterable-head.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const head: <A>(self: Iterable<A>) => Option<A>\n```\n\n----------------------------------------\n\nTITLE: Retrieving Failure Error from Cause Type in TypeScript\nDESCRIPTION: Function signature for failureOption that extracts the first Fail error from a Cause type. Returns an Option containing the first recoverable error if present. Used for error handling and display purposes in the Effect ecosystem.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Cause-failureOption.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const failureOption: <E>(self: Cause<E>) => Option.Option<E>\n```\n\n----------------------------------------\n\nTITLE: Implementing Default Map Function for Bicovariant Type in TypeScript\nDESCRIPTION: Defines a utility function that returns a default implementation of the `map` operation for types that implement the Bicovariant interface. This function takes a Bicovariant instance and returns a Covariant map function for that type.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Bicovariant-map.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const map: <F extends TypeLambda>(F: Bicovariant<F>) => Covariant<F>[\"map\"]\n```\n\n----------------------------------------\n\nTITLE: Creating Supervisor from Effect in Typescript\nDESCRIPTION: Creates a new supervisor instance that yields the provided effect on each poll. This is achieved using the `fromEffect` function. It takes an `Effect` as an argument and returns a `Supervisor` instance.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Supervisor-fromEffect.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const fromEffect: <A>(effect: Effect.Effect<A>) => Supervisor<A>\n```\n\n----------------------------------------\n\nTITLE: Creating Path Arguments in Effect CLI - TypeScript\nDESCRIPTION: Function signature for creating a path argument in the Effect CLI framework. The function accepts an optional PathArgsConfig configuration object and returns an Args<string> type. The default argument name is 'path' if not specified otherwise.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Args-path.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const path: (config?: Args.PathArgsConfig) => Args<string>\n```\n\n----------------------------------------\n\nTITLE: Transforming Schedule to Return Void - TypeScript\nDESCRIPTION: The asVoid function takes a Schedule instance and modifies it to always return void. This function is beneficial when the schedule's execution is solely for timing without the need for its output.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Schedule-asVoid.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const asVoid: <Out, In, R>(self: Schedule<Out, In, R>) => Schedule<void, In, R>\n```\n\n----------------------------------------\n\nTITLE: TypeScript Function Signature for Context.mergeAll\nDESCRIPTION: Provides the TypeScript function signature for Context.mergeAll. This function takes any number of Context objects as arguments and returns a new Context containing the services of all input contexts.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Context-mergeAll.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const mergeAll: <T extends Array<unknown>>(...ctxs: { [K in keyof T]: Context<T[K]>; }) => Context<T[number]>\n```\n\n----------------------------------------\n\nTITLE: Checking if a value is a Flatten object in TypeScript\nDESCRIPTION: The `isFlatten` function checks if a provided value is of type `Flatten`. It returns true if the value is a Flatten, false otherwise. This is useful for type guards in TypeScript code.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Flatten-isFlatten.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const isFlatten: (u: unknown) => u is Flatten<unknown>\n```\n\n----------------------------------------\n\nTITLE: Importing and Using LazyArg in TypeScript\nDESCRIPTION: This snippet demonstrates how to import and use the LazyArg interface and constant function from the effect/Function module. It creates a constant function that returns null.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Function-LazyArg.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { LazyArg, constant } from \"effect/Function\"\n\nconst constNull: LazyArg<null> = constant(null)\n```\n\n----------------------------------------\n\nTITLE: Defining ExceededCapacityException Interface in TypeScript\nDESCRIPTION: This code snippet defines the ExceededCapacityException interface, which extends YieldableError. It includes a _tag property and a symbol property for the ExceededCapacityExceptionTypeId.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Cause-ExceededCapacityException.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface ExceededCapacityException extends YieldableError {\n  readonly _tag: \"ExceededCapacityException\"\n  readonly [ExceededCapacityExceptionTypeId]: ExceededCapacityExceptionTypeId\n}\n```\n\n----------------------------------------\n\nTITLE: Constructing Interval Before End Time in TypeScript\nDESCRIPTION: The 'before' function creates an Interval that includes all time equal to and before the specified end time. It takes a single parameter 'endMilliseconds' representing the end time in milliseconds.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/ScheduleInterval-before.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const before: (endMilliseconds: number) => Interval\n```\n\n----------------------------------------\n\nTITLE: Implementing a Data Source Aspect with Around Pattern in TypeScript\nDESCRIPTION: The 'around' function creates a data source aspect that executes requests between two effects, 'before' and 'after', where the result of the first effect can be used by the second effect. This allows for pre- and post-processing of requests.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/RequestResolver-around.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const around: { <A2, R2, X, R3>(before: Effect.Effect<A2, never, R2>, after: (a: A2) => Effect.Effect<X, never, R3>): <A, R>(self: RequestResolver<A, R>) => RequestResolver<A, R2 | R3 | R>; <A, R, A2, R2, X, R3>(self: RequestResolver<A, R>, before: Effect.Effect<A2, never, R2>, after: (a: A2) => Effect.Effect<X, never, R3>): RequestResolver<A, R | R2 | R3>; }\n```\n\n----------------------------------------\n\nTITLE: Defining Flattened Interface in TypeScript\nDESCRIPTION: Defines a TypeScript interface 'Flattened' that represents a FlattenResult where the type parameter A is likely flatter than the input. It extends Flatten.Variance<A> and contains a _tag identifier and value property.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Flatten-Flattened.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface Flattened<A> extends Flatten.Variance<A> {\n  readonly _tag: \"Flattened\"\n  readonly value: A\n}\n```\n\n----------------------------------------\n\nTITLE: Mapping Channel Input with Effect Function in TypeScript\nDESCRIPTION: The mapInputInEffect method returns a new channel that applies an effectual function to the input channel's output elements. This allows for transformation of data flowing through the channel with potential side effects.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Channel-mapInputInEffect.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const mapInputInEffect: { <InElem0, InElem, InErr, Env1>(f: (a: InElem0) => Effect.Effect<InElem, InErr, Env1>): <OutElem, OutErr, OutDone, InDone, Env>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>) => Channel<OutElem, InElem0, OutErr, InErr, OutDone, InDone, Env1 | Env>; <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, InElem0, Env1>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>, f: (a: InElem0) => Effect.Effect<InElem, InErr, Env1>): Channel<OutElem, InElem0, OutErr, InErr, OutDone, InDone, Env | Env1>; }\n```\n\n----------------------------------------\n\nTITLE: Stream.splitOnChunk Signature\nDESCRIPTION: This snippet shows the type signature of the `splitOnChunk` function.  It takes a delimiter (Chunk of type A) and a stream (Stream of type A, E, R) as input, and returns a stream of chunks (Stream of Chunk of A, E, R).\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-splitOnChunk.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const splitOnChunk: { <A>(delimiter: Chunk.Chunk<A>): <E, R>(self: Stream<A, E, R>) => Stream<Chunk.Chunk<A>, E, R>; <A, E, R>(self: Stream<A, E, R>, delimiter: Chunk.Chunk<A>): Stream<Chunk.Chunk<A>, E, R>; }\n```\n\n----------------------------------------\n\nTITLE: Schema.headNonEmpty in Effect\nDESCRIPTION: The `headNonEmpty` function extracts the first element from a schema representing a `NonEmptyReadonlyArray`. It's a transformation function that takes a schema `S` representing a non-empty array `A` and returns a new schema representing the type of the first element `A[number]`. It requires the Effect Schema library and the `NonEmptyReadonlyArray` type.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Schema-headNonEmpty.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const headNonEmpty: <S extends Schema.Any, A extends array_.NonEmptyReadonlyArray<unknown>>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>) => transform<S, SchemaClass<A[number]>>\n```\n\n----------------------------------------\n\nTITLE: Implementing Type Guard for Queue in TypeScript\nDESCRIPTION: The isQueue function is a type guard that checks if the provided unknown value is an instance of Queue. It returns true if the value is a Queue, false otherwise. This function is useful for type narrowing in TypeScript.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Queue-isQueue.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const isQueue: (u: unknown) => u is Queue<unknown>\n```\n\n----------------------------------------\n\nTITLE: Declaration of isSet function\nDESCRIPTION: This is the signature declaration for the isSet function which indicates that it checks if the input is of type Set. The function accepts an unknown input and returns a boolean indicating whether the input is a Set object. It employs TypeScript's type guard to narrow down the type of the input.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Predicate-isSet.md#2025-04-11_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const isSet: (input: unknown) => input is Set<unknown>\n```\n\n----------------------------------------\n\nTITLE: Signature for Record Size Function in Effect TS - TypeScript\nDESCRIPTION: This snippet defines the TypeScript signature for the 'size' function from the 'effect/Record' module. It indicates that 'size' accepts a ReadonlyRecord with string keys and any value type, returning a number representing the number of key/value pairs.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Record-size.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const size: <K extends string, A>(self: ReadonlyRecord<K, A>) => number\n```\n\n----------------------------------------\n\nTITLE: Defining Cache Lookup Type in TypeScript\nDESCRIPTION: Defines a generic type representing a lookup function that takes a key and returns an Effect containing either a value or an error, with environment context. The lookup function is used for cache operations.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Cache-Lookup.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ntype Lookup<Key, Value, Error, Environment> = (\n  key: Key\n) => Effect.Effect<Value, Error, Environment>\n```\n\n----------------------------------------\n\nTITLE: Constructing Duration Config in Effect Package (TypeScript)\nDESCRIPTION: The `duration` function constructs a config for a duration value. It optionally takes a name parameter and returns a Config object of type Duration.Duration.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Config-duration.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const duration: (name?: string) => Config<Duration.Duration>\n```\n\n----------------------------------------\n\nTITLE: Array Copy Function Signature\nDESCRIPTION: Type definition for the Array.copy function. It handles both non-empty arrays and regular arrays, preserving their type information in the returned copy.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Array-copy.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const copy: { <A>(self: NonEmptyReadonlyArray<A>): NonEmptyArray<A>; <A>(self: ReadonlyArray<A>): Array<A>; }\n```\n\n----------------------------------------\n\nTITLE: Defining Pretty Logger Layer in Effect TypeScript\nDESCRIPTION: This code snippet shows the type signature for the pretty logger Layer in Effect. It's a Layer that doesn't require any input and doesn't produce any output or errors.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Logger-pretty.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const pretty: Layer.Layer<never, never, never>\n```\n\n----------------------------------------\n\nTITLE: Declaring ANSI Cursor Position Save Function in TypeScript\nDESCRIPTION: TypeScript declaration for saving cursor position, shift state, and formatting attributes in ANSI terminal contexts. This constant defines an AnsiDoc type that encapsulates cursor position saving functionality.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/AnsiDoc-cursorSavePosition.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const cursorSavePosition: AnsiDoc\n```\n\n----------------------------------------\n\nTITLE: Using Effect.flatMap for Chaining Operations in TypeScript\nDESCRIPTION: Demonstrates three different syntax options for using Effect.flatMap to chain operations together, allowing the result of one effect to be used in subsequent operations.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-flatMap.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst flatMappedEffect = pipe(myEffect, Effect.flatMap(transformation))\n// or\nconst flatMappedEffect = Effect.flatMap(myEffect, transformation)\n// or\nconst flatMappedEffect = myEffect.pipe(Effect.flatMap(transformation))\n```\n\n----------------------------------------\n\nTITLE: Effect.cause Function Signature in TypeScript\nDESCRIPTION: This code block shows the type signature for the Effect.cause function. It takes an Effect as input and returns a new Effect that contains the Cause of the failure.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-cause.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const cause: <A, E, R>(self: Effect<A, E, R>) => Effect<Cause.Cause<E>, never, R>\n```\n\n----------------------------------------\n\nTITLE: Function Signature for Logger.minimumLogLevel (TypeScript)\nDESCRIPTION: This code block shows the TypeScript signature for the Logger.minimumLogLevel function. It takes a LogLevel as an argument and returns a Layer that never produces an error.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Logger-minimumLogLevel.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const minimumLogLevel: (level: LogLevel.LogLevel) => Layer.Layer<never>\n```\n\n----------------------------------------\n\nTITLE: Defining BrandErrors Interface in TypeScript\nDESCRIPTION: Defines a TypeScript interface BrandErrors that extends the Array type to store refinement errors. This interface is used for type-safe error handling in the Effect framework's brand system.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Brand-Brand.BrandErrors.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface BrandErrors extends Array<RefinementError> {}\n```\n\n----------------------------------------\n\nTITLE: Defining BigDecimalFromNumber Schema in TypeScript\nDESCRIPTION: Declares a class representing a schema that transforms a number into a BigDecimal. This schema may produce incorrect results when encoding BigDecimal values that exceed the 64-bit range of a number.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Schema-BigDecimalFromNumber.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare class BigDecimalFromNumber\n```\n\n----------------------------------------\n\nTITLE: Declaring NoSuchElementExceptionTypeId Symbol in TypeScript\nDESCRIPTION: Declares a unique symbol identifier for the NoSuchElementException type. This symbol is used to differentiate cases where a required element is missing within a data structure.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Cause-NoSuchElementExceptionTypeId.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const NoSuchElementExceptionTypeId: unique symbol\n```\n\n----------------------------------------\n\nTITLE: TypeScript Declaration for isBoolean Function\nDESCRIPTION: The type declaration for the isBoolean function, showing it as a type guard that accepts any value and returns a boolean indicating whether the input is a boolean type.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Boolean-isBoolean.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const isBoolean: (input: unknown) => input is boolean\n```\n\n----------------------------------------\n\nTITLE: TypeScript Signature for Boolean OR Function\nDESCRIPTION: This code snippet shows the TypeScript signature for the 'or' function. It demonstrates that the function can be called with either one or two boolean arguments.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Boolean-or.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const or: { (that: boolean): (self: boolean) => boolean; (self: boolean, that: boolean): boolean; }\n```\n\n----------------------------------------\n\nTITLE: Declaring isEmpty Function in TypeScript\nDESCRIPTION: This snippet defines the isEmpty function for the MutableQueue module. The isEmpty function checks if a given MutableQueue is empty and returns a boolean value indicating the result. It requires a MutableQueue instance as a parameter.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/MutableQueue-isEmpty.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const isEmpty: <A>(self: MutableQueue<A>) => boolean\n```\n\n----------------------------------------\n\nTITLE: Using DateTime.withDate with Time Zone Adjustment\nDESCRIPTION: Demonstrates how to use DateTime.withDate to get the time zone adjusted date in milliseconds for Europe/London timezone.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/DateTime-withDate.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { DateTime } from \"effect\"\n\n// get the time zone adjusted date in milliseconds\nDateTime.unsafeMakeZoned(0, { timeZone: \"Europe/London\" }).pipe(\n  DateTime.withDate((date) => date.getTime())\n)\n```\n\n----------------------------------------\n\nTITLE: Implementing updateWith Function in Effect Differ Module - TypeScript\nDESCRIPTION: Defines a function that creates a Differ instance for combining values. The function takes a combining function f that specifies how to merge old and new values of type A, and returns a Differ that transforms values using this combining function.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Differ-updateWith.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const updateWith: <A>(f: (x: A, y: A) => A) => Differ<A, (a: A) => A>\n```\n\n----------------------------------------\n\nTITLE: DateTime.getPartUtc Function Signature\nDESCRIPTION: Type declaration for the getPartUtc function, showing its overloaded signatures. It can be called either with part first and DateTime second, or DateTime first and part second.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/DateTime-getPartUtc.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const getPartUtc: { (part: keyof DateTime.PartsWithWeekday): (self: DateTime) => number; (self: DateTime, part: keyof DateTime.PartsWithWeekday): number; }\n```\n\n----------------------------------------\n\nTITLE: Declaring Cursor Restore Position Function in TypeScript\nDESCRIPTION: Defines a constant 'cursorRestorePosition' of type AnsiDoc. This function restores the cursor position, encoding shift state, and formatting attributes from the previous save, or resets them to defaults if no previous save exists.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/AnsiDoc-cursorRestorePosition.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const cursorRestorePosition: AnsiDoc\n```\n\n----------------------------------------\n\nTITLE: Creating Empty Patch with Differ in TypeScript\nDESCRIPTION: A function that returns an empty patch describing no changes. It takes a Differ instance as input and returns a Patch of the appropriate type.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Differ-empty.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const empty: <Value, Patch>(self: Differ<Value, Patch>) => Patch\n```\n\n----------------------------------------\n\nTITLE: Defining Micro.zipWith Function in TypeScript\nDESCRIPTION: Type declaration for the Micro.zipWith function which combines two Micro effects and applies a transformation function to their results. It supports both curried and non-curried usage patterns with an optional concurrent execution parameter.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Micro-zipWith.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const zipWith: { <A2, E2, R2, A, B>(that: Micro<A2, E2, R2>, f: (a: A, b: A2) => B, options?: { readonly concurrent?: boolean | undefined; }): <E, R>(self: Micro<A, E, R>) => Micro<B, E2 | E, R2 | R>; <A, E, R, A2, E2, R2, B>(self: Micro<A, E, R>, that: Micro<A2, E2, R2>, f: (a: A, b: A2) => B, options?: { readonly concurrent?: boolean | undefined; }): Micro<B, E2 | E, R2 | R>; }\n```\n\n----------------------------------------\n\nTITLE: Defining TestClock Data Interface in TypeScript\nDESCRIPTION: This code snippet defines the Data interface for the TestClock module. It includes properties for the current instant (clock time) and a chunk of sleep operations with their associated deferreds.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TestClock-Data.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface Data {\n  readonly instant: number\n  readonly sleeps: Chunk.Chunk<readonly [number, Deferred.Deferred<void>]>\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Interrupt Cause in Effect-IO TypeScript\nDESCRIPTION: Function declaration for creating an Interrupt cause that takes a FiberId parameter and returns a Cause of never type. Used to represent an interrupted fiber and track concurrent cancellations.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Cause-interrupt.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const interrupt: (fiberId: FiberId.FiberId) => Cause<never>\n```\n\n----------------------------------------\n\nTITLE: Array.partitionMap Function Signature in TypeScript\nDESCRIPTION: Provides the TypeScript signature for the Array.partitionMap function, showing its polymorphic nature and the types it operates on.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Array-partitionMap.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const partitionMap: { <A, B, C>(f: (a: A, i: number) => Either.Either<C, B>): (self: Iterable<A>) => [left: Array<B>, right: Array<C>]; <A, B, C>(self: Iterable<A>, f: (a: A, i: number) => Either.Either<C, B>): [left: Array<B>, right: Array<C>]; }\n```\n\n----------------------------------------\n\nTITLE: Retrieving Entries from HashMap in TypeScript\nDESCRIPTION: The entries function returns an IterableIterator of key-value pairs from a HashMap. It allows iteration over all entries in the HashMap.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/HashMap-entries.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const entries: <K, V>(self: HashMap<K, V>) => IterableIterator<[K, V]>\n```\n\n----------------------------------------\n\nTITLE: Interrupting Suspended Fibers with TPubSub.shutdown in TypeScript\nDESCRIPTION: The shutdown function interrupts any fibers that are suspended on offer or take operations on a TPubSub instance. After shutdown, future calls to offer* and take* methods will be interrupted immediately.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TPubSub-shutdown.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const shutdown: <A>(self: TPubSub<A>) => STM.STM<void>\n```\n\n----------------------------------------\n\nTITLE: Type signature for DateTime.nowAsDate\nDESCRIPTION: The type signature for the nowAsDate function, showing it returns an Effect that resolves to a Date object with no error type and no required services.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/DateTime-nowAsDate.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const nowAsDate: Effect.Effect<Date, never, never>\n```\n\n----------------------------------------\n\nTITLE: TypeScript Function Signature for vcat Combinator\nDESCRIPTION: This code snippet shows the TypeScript function signature for the vcat combinator. It takes an Iterable of Doc<A> and returns a Doc<A>.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Doc-vcat.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const vcat: <A>(docs: Iterable<Doc<A>>) => Doc<A>\n```\n\n----------------------------------------\n\nTITLE: SemigroupSum Declaration in TypeScript\nDESCRIPTION: This snippet declares the SemigroupSum as a semigroup for the bigint type. It defines the SemigroupSum using the semigroup.Semigroup interface for bigint, ensuring proper combination functionality.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/data-BigInt-SemigroupSum.md#2025-04-11_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const SemigroupSum: semigroup.Semigroup<bigint>\n```\n\n----------------------------------------\n\nTITLE: Declaring AdditionalSchemas Class in HttpApi Module\nDESCRIPTION: Declaration of the AdditionalSchemas class used to add additional schemas to components/schemas. The schemas must include an 'identifier' annotation to be properly recognized.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/HttpApi-AdditionalSchemas.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare class AdditionalSchemas\n```\n\n----------------------------------------\n\nTITLE: Importing BigInt Semigroup Minimum\nDESCRIPTION: Demonstrates how to import and use the SemigroupMin utility from the @effect/typeclass package to find the minimum BigInt value\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/data-BigInt-SemigroupMin.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { SemigroupMin } from \"@effect/typeclass/data/BigInt\"\n\nconsole.log(SemigroupMin.combine(2n, 3n))\n// 2n\n```\n\n----------------------------------------\n\nTITLE: Creating Deferred from FiberId in TypeScript using Effect\nDESCRIPTION: The makeAs function creates a new Deferred from a specified FiberId. It takes a FiberId as an argument and returns an Effect that produces a Deferred. The Deferred can hold a value of type A or an error of type E (which defaults to never if not specified).\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Deferred-makeAs.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const makeAs: <A, E = never>(fiberId: FiberId.FiberId) => Effect.Effect<Deferred<A, E>>\n```\n\n----------------------------------------\n\nTITLE: Declaring the 'fail' Constant in TypeScript for @effect/printer Doc Module\nDESCRIPTION: This code snippet declares a constant named 'fail' of type Doc<never>. It represents a document that cannot be rendered, typically occurring when flattening a line. Layout algorithms will reject this document and choose a more suitable rendering.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Doc-fail.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const fail: Doc<never>\n```\n\n----------------------------------------\n\nTITLE: Creating Exit.Failure with Exit.fail in TypeScript\nDESCRIPTION: Constructs a new Exit.Failure from a specified recoverable error of type E. This function is part of the Exit module in the effect package and is used to represent failed computations in the Effect-TS ecosystem.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Exit-fail.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const fail: <E>(error: E) => Exit<never, E>\n```\n\n----------------------------------------\n\nTITLE: Implementing transformLiteral Functionality in TypeScript\nDESCRIPTION: This code snippet demonstrates how to import the required modules and use the 'transformLiteral' function from the Effect Schema to transform a literal value. It verifies the transformation using assertions. The snippet depends on the 'node:assert' module for testing and 'effect/Schema' for accessing schema functionality.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Schema-transformLiteral.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport * as S from \"effect/Schema\"\n\nconst schema = S.transformLiteral(0, \"a\")\n\nassert.deepStrictEqual(S.decodeSync(schema)(0), \"a\")\n```\n\n----------------------------------------\n\nTITLE: Doc.empty Type Signature in TypeScript\nDESCRIPTION: The type signature for the Doc.empty constant, showing it creates a Doc with no content requirements. This function creates an empty document that behaves like one containing an empty string.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Doc-empty.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const empty: Doc<never>\n```\n\n----------------------------------------\n\nTITLE: Implementing Request.failCause in TypeScript\nDESCRIPTION: Definition of the failCause function that completes a Request with a specified cause. The function can be used in two ways: either by passing the cause first followed by the request, or by passing the request first followed by the cause. Returns an Effect of void.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Request-failCause.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const failCause: {\n  <A extends Request<any, any>>(cause: Cause<Request.Error<A>>): (self: A) => Effect.Effect<void>;\n  <A extends Request<any, any>>(self: A, cause: Cause<Request.Error<A>>): Effect.Effect<void>;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining CurrentRunnerAddress Class in TypeScript\nDESCRIPTION: Defines a Context.Tag class for accessing the current Runner address in a clustered environment. This class is used to retrieve the address of the current runner within the Effect context system.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Entity-CurrentRunnerAddress.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare class CurrentRunnerAddress\n```\n\n----------------------------------------\n\nTITLE: Creating a Schedule from Delays in TypeScript\nDESCRIPTION: This snippet defines a function `fromDelays` that creates a schedule executing with specified delays. It accepts a duration input for the first delay and an array of additional delays. The function will call its executors sequentially based on the provided delays, stopping once all are utilized. This allows for customized delay sequences that are not limited to standard patterns.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Schedule-fromDelays.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const fromDelays: (delay: Duration.DurationInput, ...delays: Array<Duration.DurationInput>) => Schedule<Duration.Duration>\n```\n\n----------------------------------------\n\nTITLE: Configuring Command stderr Stream in TypeScript\nDESCRIPTION: Function definition for specifying the standard error stream output for a command. Supports both curried and uncurried calling styles for setting the stderr output configuration.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Command-stderr.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const stderr: { (stderr: Command.Output): (self: Command) => Command; (self: Command, stderr: Command.Output): Command; }\n```\n\n----------------------------------------\n\nTITLE: Clamping Duration Values - TypeScript\nDESCRIPTION: The 'clampDuration' function takes minimum and maximum Duration parameters and returns a transformation function that constrains a given Schema to these bounds. It accepts two Duration inputs and ensures that any resultant Duration adheres to the provided limits.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Schema-clampDuration.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const clampDuration: (minimum: duration_.DurationInput, maximum: duration_.DurationInput) => <S extends Schema.Any, A extends duration_.Duration>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>) => transform<S, filter<SchemaClass<A>>>\n```\n\n----------------------------------------\n\nTITLE: Defining TimeZoneNamed Schema in TypeScript\nDESCRIPTION: Declares a class named TimeZoneNamed that represents a schema for converting strings to TimeZone.Named instances using the DateTime.zoneUnsafeMakeNamed constructor.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Schema-TimeZoneNamed.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare class TimeZoneNamed\n```\n\n----------------------------------------\n\nTITLE: Type Signature for Brand.nominal in TypeScript\nDESCRIPTION: The type signature for the Brand.nominal function, which returns a Brand.Constructor for creating branded types without runtime checks.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Brand-nominal.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const nominal: <A extends Brand<any>>() => Brand.Constructor<A>\n```\n\n----------------------------------------\n\nTITLE: Retrieving Sized Service for Tests in TypeScript\nDESCRIPTION: This code snippet defines the 'sized' constant, which is an Effect that provides access to the TestSized service. It has no input requirements and doesn't produce any errors.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TestServices-sized.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const sized: Effect.Effect<Sized.TestSized, never, never>\n```\n\n----------------------------------------\n\nTITLE: Implementing Invariant Functor Composition in TypeScript\nDESCRIPTION: The imapComposition function returns a default ternary imap composition for two invariant functors F and G. It allows for mapping between types A and B within the nested structure of F and G.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Invariant-imapComposition.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const imapComposition: <F extends TypeLambda, G extends TypeLambda>(F: Invariant<F>, G: Invariant<G>) => <FR, FO, FE, GR, GO, GE, A, B>(self: Kind<F, FR, FO, FE, Kind<G, GR, GO, GE, A>>, to: (a: A) => B, from: (b: B) => A) => Kind<F, FR, FO, FE, Kind<G, GR, GO, GE, B>>\n```\n\n----------------------------------------\n\nTITLE: Defining PropertySignatureTransformation Class in TypeScript\nDESCRIPTION: Implements a class for transforming property signatures with decode and encode operations. The decode method handles presence/absence of key/value pairs where none() indicates absence and some(value) indicates presence. The encode method determines output behavior where none() skips output and some(value) includes the pair.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/SchemaAST-PropertySignatureTransformation.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare class PropertySignatureTransformation { constructor(\n    readonly from: PropertyKey,\n    readonly to: PropertyKey,\n    readonly decode: (o: Option.Option<any>) => Option.Option<any>,\n    readonly encode: (o: Option.Option<any>) => Option.Option<any>\n  ) }\n```\n\n----------------------------------------\n\nTITLE: Defining RuntimeFlags Type in TypeScript\nDESCRIPTION: Defines the RuntimeFlags type as a number with a unique symbol property that serves as a nominal type marker. This type represents a set of runtime flags that affect the behavior of the Effect runtime system.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/RuntimeFlags-RuntimeFlags.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ntype RuntimeFlags = number & {\n  readonly RuntimeFlags: unique symbol\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Micro Effect that Fails with a Cause\nDESCRIPTION: This function creates a Micro effect that fails with a specified MicroCause. It uses generics to allow the type of the cause to be defined dynamically. The key functionality is to enable better error handling and propagation within Micro effects. This function relies on the Micro and MicroCause types defined in the Effect library.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Micro-failCause.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const failCause: <E>(cause: MicroCause<E>) => Micro<never, E>\n```\n\n----------------------------------------\n\nTITLE: RedBlackTree greaterThanReversed Declaration\nDESCRIPTION: The `greaterThanReversed` function returns an iterator that traverses entries in reverse order with keys greater than the specified key within a RedBlackTree. It can be invoked either as a curried function or with both the RedBlackTree and the key provided as arguments.  This function is available since v2.0.0.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/RedBlackTree-greaterThanReversed.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const greaterThanReversed: { <K>(key: K): <V>(self: RedBlackTree<K, V>) => Iterable<[K, V]>; <K, V>(self: RedBlackTree<K, V>, key: K): Iterable<[K, V]>; }\n```\n\n----------------------------------------\n\nTITLE: Accessing Default Configuration Provider with Effect.configProviderWith in TypeScript\nDESCRIPTION: This function retrieves the default configuration provider and passes it to the provided function, which can use it to perform computations or retrieve configuration values. The function can return an effect that leverages the configuration provider for its operations.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-configProviderWith.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const configProviderWith: <A, E, R>(f: (provider: ConfigProvider) => Effect<A, E, R>) => Effect<A, E, R>\n```\n\n----------------------------------------\n\nTITLE: Checking Queue Emptiness with TQueue.isEmpty in TypeScript\nDESCRIPTION: Function to check if a TQueue contains zero elements. It works with both TDequeue and TEnqueue types and returns a boolean wrapped in an STM transaction.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TQueue-isEmpty.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const isEmpty: <A>(self: TDequeue<A> | TEnqueue<A>) => STM.STM<boolean>\n```\n\n----------------------------------------\n\nTITLE: Defining Prompt Environment Type in TypeScript\nDESCRIPTION: This code snippet defines the Environment type for custom Prompts in the Effect CLI system. It combines FileSystem, Path, and Terminal services.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Prompt-Prompt.Environment.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ntype Environment = FileSystem | Path | Terminal\n```\n\n----------------------------------------\n\nTITLE: Retrieving Help Documentation for Primitive Types in TypeScript\nDESCRIPTION: This function getHelp takes a Primitive<A> as input and returns a Span object containing help documentation for that primitive type. It is part of the @effect/cli package and is located in the Primitive module.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Primitive-getHelp.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const getHelp: <A>(self: Primitive<A>) => Span\n```\n\n----------------------------------------\n\nTITLE: Creating Local TimeZone in Effect.ts\nDESCRIPTION: Function that creates a named time zone instance based on the system's local time zone settings. Returns a TimeZone.Named type.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/DateTime-zoneMakeLocal.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const zoneMakeLocal: () => TimeZone.Named\n```\n\n----------------------------------------\n\nTITLE: Appending Elements with Effect-TS MutableList in TypeScript\nDESCRIPTION: This TypeScript snippet defines the `append` function for adding elements to a `MutableList` in the Effect-TS library. The function supports two forms: a curried version where a value is first specified, and then a `MutableList`, and a direct version where both parameters are supplied together. The function operates on `MutableList` objects, appending the specified element to the end of the list, and returns the modified list.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/MutableList-append.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const append: { <A>(value: A): (self: MutableList<A>) => MutableList<A>; <A>(self: MutableList<A>, value: A): MutableList<A>; }\n```\n\n----------------------------------------\n\nTITLE: Defining List.partition Function in TypeScript\nDESCRIPTION: Declares the partition function for List, which splits a list into two based on a predicate or refinement. It handles both curried and non-curried versions, and works with refinements that narrow types.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/List-partition.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const partition: { <A, B extends A>(refinement: Refinement<NoInfer<A>, B>): (self: List<A>) => [excluded: List<Exclude<A, B>>, satisfying: List<B>]; <A>(predicate: Predicate<NoInfer<A>>): (self: List<A>) => [excluded: List<A>, satisfying: List<A>]; <A, B extends A>(self: List<A>, refinement: Refinement<A, B>): [excluded: List<Exclude<A, B>>, satisfying: List<B>]; <A>(self: List<A>, predicate: Predicate<A>): [excluded: List<A>, satisfying: List<A>]; }\n```\n\n----------------------------------------\n\nTITLE: Function Signature for Iterable.prependAll in TypeScript\nDESCRIPTION: Provides the TypeScript function signature for Iterable.prependAll. The function is overloaded to allow for both curried and non-curried usage, accepting iterables of potentially different types and returning a new iterable with combined elements.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Iterable-prependAll.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const prependAll: { <B>(that: Iterable<B>): <A>(self: Iterable<A>) => Iterable<A | B>; <A, B>(self: Iterable<A>, that: Iterable<B>): Iterable<A | B>; }\n```\n\n----------------------------------------\n\nTITLE: Testing Function Type with isFunction in TypeScript\nDESCRIPTION: Example demonstrating how to use the isFunction predicate to check if values are functions. Shows both positive and negative test cases using Node's assert module.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Function-isFunction.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { isFunction } from \"effect/Predicate\"\n\nassert.deepStrictEqual(isFunction(isFunction), true)\nassert.deepStrictEqual(isFunction(\"function\"), false)\n```\n\n----------------------------------------\n\nTITLE: Defining MetricPolling Poll Function in TypeScript\nDESCRIPTION: Declaration of a poll function that takes a MetricPolling object and returns an Effect. The function is generic, accepting type parameters for the metric type, input, environment, error, and output types.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/MetricPolling-poll.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const poll: <Type, In, R, E, Out>(self: MetricPolling<Type, In, R, E, Out>) => Effect.Effect<In, E, R>\n```\n\n----------------------------------------\n\nTITLE: Initializing and Mutating URL with Callback\nDESCRIPTION: Demonstrates creating a new URL and applying multiple mutations using the Url.mutate function. This approach allows safe, immutable updates to URL properties like username and password.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Url-mutate.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Url } from \"@effect/platform\"\n\nconst myUrl = new URL(\"https://example.com\")\n\nconst mutatedUrl = Url.mutate(myUrl, (url) => {\n  url.username = \"user\"\n  url.password = \"pass\"\n})\n\nconsole.log(\"Mutated:\", mutatedUrl.toString())\n// Output: Mutated: https://user:pass@example.com/\n```\n\n----------------------------------------\n\nTITLE: Checking if RuntimeFlag is Enabled in TypeScript\nDESCRIPTION: The isEnabled function determines whether a RuntimeFlagsPatch describes a specific RuntimeFlag as enabled. It provides two call signatures - one curried and one with both parameters at once.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/RuntimeFlagsPatch-isEnabled.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const isEnabled: { (flag: RuntimeFlags.RuntimeFlag): (self: RuntimeFlagsPatch) => boolean; (self: RuntimeFlagsPatch, flag: RuntimeFlags.RuntimeFlag): boolean; }\n```\n\n----------------------------------------\n\nTITLE: Declaring Space Document Constant in TypeScript\nDESCRIPTION: Declares a constant 'space' of type Doc<never> that represents a document containing a single space character. This is a fundamental building block for document formatting.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Doc-space.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const space: Doc<never>\n```\n\n----------------------------------------\n\nTITLE: Micro.scheduleIntersect Signature\nDESCRIPTION: Describes the signature of the `scheduleIntersect` function. It takes two `MicroSchedule` instances and returns a new `MicroSchedule` that represents the intersection of the two.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Micro-scheduleIntersect.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const scheduleIntersect: { (that: MicroSchedule): (self: MicroSchedule) => MicroSchedule; (self: MicroSchedule, that: MicroSchedule): MicroSchedule; }\n```\n\n----------------------------------------\n\nTITLE: Declaring failSync Function in TypeScript\nDESCRIPTION: The failSync function in this TypeScript snippet is used to terminate a stream with a specified error, evaluated lazily. It is part of the Stream module and requires a LazyArg type parameter, which represents the error evaluator. This function returns a Stream object representing the termination result with the provided error. Applicable for use in scenarios where lazy evaluation and error handling are required within streams.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-failSync.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const failSync: <E>(evaluate: LazyArg<E>) => Stream<never, E>\n```\n\n----------------------------------------\n\nTITLE: Declaring sumAll function in Effect\nDESCRIPTION: Shows the type declaration of the `sumAll` function, defining it as a function that accepts an `Iterable<number>` and returns a `number`. This describes the function's signature and expected input/output types within the `effect/Number` module.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Number-sumAll.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const sumAll: (collection: Iterable<number>) => number\n```\n\n----------------------------------------\n\nTITLE: RegExp Type Checking Example in TypeScript\nDESCRIPTION: Demonstrates how to use the RegExp.isRegExp function to check if a value is a RegExp object. Shows both positive and negative test cases using node's assert module.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/RegExp-isRegExp.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { RegExp } from \"effect\"\n\nassert.deepStrictEqual(RegExp.isRegExp(/a/), true)\nassert.deepStrictEqual(RegExp.isRegExp(\"a\"), false)\n```\n\n----------------------------------------\n\nTITLE: Collecting Elements with STM in TypeScript\nDESCRIPTION: This TypeScript function `toArray` is used to collect all elements of a `TArray` into a standard array wrapped in an STM (Software Transactional Memory). It requires the `TArray` type from the Effect-TS library and returns an STM-wrapped array. The function captures asynchronous transactional computations, typically used in concurrent environments.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TArray-toArray.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const toArray: <A>(self: TArray<A>) => STM.STM<Array<A>>\n```\n\n----------------------------------------\n\nTITLE: TypeScript Function Signature for Function.flip\nDESCRIPTION: This code snippet shows the TypeScript type signature for the flip function. It takes a curried function with two sets of arguments and returns a new function with the argument order reversed.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Function-flip.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const flip: <A extends Array<unknown>, B extends Array<unknown>, C>(f: (...a: A) => (...b: B) => C) => (...b: B) => (...a: A) => C\n```\n\n----------------------------------------\n\nTITLE: Defining DateTimeUtcFromDate Schema Class in TypeScript\nDESCRIPTION: Declares a class named DateTimeUtcFromDate which defines a schema for converting Date objects to DateTime.Utc instances using the DateTime.unsafeMake constructor. This class is part of the Schema module in the effect package.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Schema-DateTimeUtcFromDate.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare class DateTimeUtcFromDate\n```\n\n----------------------------------------\n\nTITLE: Implementing filterMap Composition for Nested Higher-Kinded Types in TypeScript\nDESCRIPTION: This function provides a default binary filterMap composition for nested higher-kinded types. It takes Covariant and Filterable instances and returns a function that applies filterMap across the nested structure.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Filterable-filterMapComposition.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const filterMapComposition: <F extends TypeLambda, G extends TypeLambda>(F: Covariant<F>, G: Filterable<G>) => <FR, FO, FE, GR, GO, GE, A, B>(self: Kind<F, FR, FO, FE, Kind<G, GR, GO, GE, A>>, f: (a: A) => Option.Option<B>) => Kind<F, FR, FO, FE, Kind<G, GR, GO, GE, B>>\n```\n\n----------------------------------------\n\nTITLE: Define Unbounded PageWidth Interface in Effect TS\nDESCRIPTION: This code defines the `Unbounded` interface, which extends `PageWidth.Proto` and includes a `_tag` property set to \"Unbounded\". It represents a page width setting that prevents line breaks in the document layout.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/PageWidth-Unbounded.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nexport interface Unbounded extends PageWidth.Proto {\n  readonly _tag: \"Unbounded\"\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Declaring PubSub Capacity Function in TypeScript\nDESCRIPTION: This code snippet declares the capacity function for the PubSub module. It takes a PubSub instance as input and returns a number representing the queue's capacity.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/PubSub-capacity.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const capacity: <A>(self: PubSub<A>) => number\n```\n\n----------------------------------------\n\nTITLE: Array.difference Function Signature in TypeScript\nDESCRIPTION: The type definition for the Array.difference function, showing its polymorphic nature. It can be used either in a data-last style (with currying) or data-first style (with both arguments at once).\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Array-difference.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const difference: { <A>(that: Iterable<A>): (self: Iterable<A>) => Array<A>; <A>(self: Iterable<A>, that: Iterable<A>): Array<A>; }\n```\n\n----------------------------------------\n\nTITLE: Defining Encoded Bound Schema Function in TypeScript\nDESCRIPTION: A type-level function that transforms a schema while maintaining refinements up to the first transformation point. Used for advanced schema manipulation in the Effect-TS library.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Schema-encodedBoundSchema.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const encodedBoundSchema: <A, I, R>(schema: Schema<A, I, R>) => SchemaClass<I>\n```\n\n----------------------------------------\n\nTITLE: Defining BindTo Signature in Option\nDESCRIPTION: This snippet declares the signature for the 'bindTo' function in Effect's Option module. It specifies how to tie a name to an Option value, allowing for a type-safe way of handling Option bindings and returns a new Option with the bound variable.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Option-bindTo.md#2025-04-11_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const bindTo: { <N extends string>(name: N): <A>(self: Option<A>) => Option<{ [K in N]: A; }>; <A, N extends string>(self: Option<A>, name: N): Option<{ [K in N]: A; }>; }\n```\n\n----------------------------------------\n\nTITLE: Declaring TestClock.save Function in TypeScript\nDESCRIPTION: Declares the save function in the TestClock module. This function accesses a TestClock instance from the context and saves its state. It returns an Effect that, when executed, will restore the TestClock to the saved state.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TestClock-save.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const save: () => Effect.Effect<Effect.Effect<void>>\n```\n\n----------------------------------------\n\nTITLE: Using Doc.hcat in TypeScript with Effect Printer\nDESCRIPTION: Demonstrates how to use the hcat combinator to concatenate words horizontally without spaces. The example shows importing required modules, creating a Doc instance with some words, and rendering it to a string.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Doc-hcat.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport * as Doc from \"@effect/printer/Doc\"\nimport * as String from \"effect/String\"\n\nconst doc: Doc.Doc<never> = Doc.hcat(Doc.words(\"lorem ipsum dolor\"))\n\nassert.strictEqual(\n  Doc.render(doc, { style: \"pretty\" }),\n  \"loremipsumdolor\"\n)\n```\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const hcat: <A>(docs: Iterable<Doc<A>>) => Doc<A>\n```\n\n----------------------------------------\n\nTITLE: Defining AnyNoContext Schema Type in TypeScript\nDESCRIPTION: Defines a type alias for any schema with Context = never, except for never. This type is used to represent schemas that don't have any specific context requirements.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Schema-Schema.AnyNoContext.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ntype AnyNoContext = Schema<any, any, never>\n```\n\n----------------------------------------\n\nTITLE: Defining Request Success Type Extractor in TypeScript\nDESCRIPTION: A TypeScript utility type that extracts the success value type (A) from a Request<A, E> type. This conditional type uses type inference to extract the success type parameter from Request types while returning never for non-Request types.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Request-Request.Success.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ntype Success<T> = [T] extends [Request<infer _A, infer _E>] ? _A : never\n```\n\n----------------------------------------\n\nTITLE: Defining SemiApplicative zipWith TypeScript Function\nDESCRIPTION: A higher-order function that combines two computational values using a provided function, supporting complex type lambda transformations with flexible effect handling\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/SemiApplicative-zipWith.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const zipWith: <F extends TypeLambda>(F: SemiApplicative<F>) => { <R2, O2, E2, B, A, C>(that: Kind<F, R2, O2, E2, B>, f: (a: A, b: B) => C): <R1, O1, E1>(self: Kind<F, R1, O1, E1, A>) => Kind<F, R1 & R2, O2 | O1, E2 | E1, C>; <R1, O1, E1, A, R2, O2, E2, B, C>(self: Kind<F, R1, O1, E1, A>, that: Kind<F, R2, O2, E2, B>, f: (a: A, b: B) => C): Kind<F, R1 & R2, O1 | O2, E1 | E2, C>; }\n```\n\n----------------------------------------\n\nTITLE: Defining Structured Logger Type in TypeScript\nDESCRIPTION: This snippet shows the TypeScript type definition for the structured logger. It specifies the structure of the log output, including logLevel, fiberId, timestamp, message, cause, annotations, and spans.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Logger-structuredLogger.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const structuredLogger: Logger<unknown, { readonly logLevel: string; readonly fiberId: string; readonly timestamp: string; readonly message: unknown; readonly cause: string | undefined; readonly annotations: Record<string, unknown>; readonly spans: Record<string, number>; }>\n```\n\n----------------------------------------\n\nTITLE: Setting DateTime Parts in UTC - TypeScript Effect.io\nDESCRIPTION: Function signature for setPartsUtc method that allows setting multiple DateTime components simultaneously using a partial object containing date/time parts. Supports both curried and uncurried invocation patterns.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/DateTime-setPartsUtc.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const setPartsUtc: { (parts: Partial<DateTime.PartsWithWeekday>): <A extends DateTime>(self: A) => A; <A extends DateTime>(self: A, parts: Partial<DateTime.PartsWithWeekday>): A; }\n```\n\n----------------------------------------\n\nTITLE: Number SemigroupMultiply Example (TypeScript)\nDESCRIPTION: This code snippet demonstrates how to use the `SemigroupMultiply` semigroup from the `@effect/typeclass/data/Number` module to combine two numbers using multiplication. It imports the `SemigroupMultiply` constant and uses its `combine` method to multiply 2 and 3, logging the result (6) to the console.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/data-Number-SemigroupMultiply.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { SemigroupMultiply } from \"@effect/typeclass/data/Number\"\n\nconsole.log(SemigroupMultiply.combine(2, 3))\n// 6\n```\n\n----------------------------------------\n\nTITLE: Picking Object Properties with Struct.pick\nDESCRIPTION: Demonstrates how to extract specific properties from an object using the Struct.pick method with pipe and direct invocation\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Struct-pick.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { pipe, Struct } from \"effect\"\n\nassert.deepStrictEqual(pipe({ a: \"a\", b: 1, c: true }, Struct.pick(\"a\", \"b\")), { a: \"a\", b: 1 })\nassert.deepStrictEqual(Struct.pick({ a: \"a\", b: 1, c: true }, \"a\", \"b\"), { a: \"a\", b: 1 })\n```\n\n----------------------------------------\n\nTITLE: Using Do Simulation to Bind Variables in Option\nDESCRIPTION: This snippet demonstrates how to use do simulation with the Option module in Effect. It shows how to bind values to variables and perform operations within the Option context, ensuring the ability to use additional functions like 'map' and 'filter'. Additionally, it includes an assertion to ensure the correctness of the operation.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Option-bindTo.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { Option, pipe } from \"effect\"\n\nconst result = pipe(\n  Option.Do,\n  Option.bind(\"x\", () => Option.some(2)),\n  Option.bind(\"y\", () => Option.some(3)),\n  Option.let(\"sum\", ({ x, y }) => x + y),\n  Option.filter(({ x, y }) => x * y > 5)\n)\nassert.deepStrictEqual(result, Option.some({ x: 2, y: 3, sum: 5 }))\n```\n\n----------------------------------------\n\nTITLE: Creating Effect Run Function with FiberSet in TypeScript\nDESCRIPTION: The makeRuntimePromise function creates an Effect run function backed by a FiberSet. It returns an Effect that, when run, provides a function to execute effects and return promises. The function is generic, allowing for flexible use with different effect types.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/FiberSet-makeRuntimePromise.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const makeRuntimePromise: <R = never, A = unknown, E = unknown>() => Effect.Effect<(<XE extends E, XA extends A>(effect: Effect.Effect<XA, XE, R>, options?: Runtime.RunForkOptions | undefined) => Promise<XA>), never, Scope.Scope | R>\n```\n\n----------------------------------------\n\nTITLE: Creating Singleton Record in TypeScript\nDESCRIPTION: This code snippet defines a function `singleton` that creates a non-empty record from a single key-value pair. It employs TypeScript generics to allow any valid key type that extends from `string` or `symbol`, and accepts any value type, ensuring both flexibility and type safety. The output is a record with one key-value pair, adhering to the constraints defined by the TypeScript `Record` utility type.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Record-singleton.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const singleton: <K extends string | symbol, A>(key: K, value: A) => Record<K, A>\n```\n\n----------------------------------------\n\nTITLE: MutableHashSet.make Function Signature in TypeScript\nDESCRIPTION: The TypeScript type signature for the MutableHashSet.make function, which constructs a new MutableHashSet from a variable number of values with time complexity of O(n).\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/MutableHashSet-make.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const make: <Keys extends ReadonlyArray<unknown>>(...keys: Keys) => MutableHashSet<Keys[number]>\n```\n\n----------------------------------------\n\nTITLE: Implementing Error Handling in Micro Effects - TypeScript\nDESCRIPTION: Function signature for ignoreLogged, which takes a Micro effect and returns a new Micro effect that ignores any expected errors and returns void. This is useful for cases where error handling is not needed and errors can be safely ignored.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Micro-ignoreLogged.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const ignoreLogged: <A, E, R>(self: Micro<A, E, R>) => Micro<void, never, R>\n```\n\n----------------------------------------\n\nTITLE: Defining NeverFlat Interface in TypeScript\nDESCRIPTION: Defines the NeverFlat interface that extends Flatten.Variance<A> and represents a FlattenResult where the input document cannot be flattened to a single line.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Flatten-NeverFlat.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface NeverFlat<A> extends Flatten.Variance<A> {\n  readonly _tag: \"NeverFlat\"\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Fixed Offset TimeZones in TypeScript\nDESCRIPTION: The zoneMakeOffset function creates a fixed offset time zone. It takes a numeric offset parameter and returns a TimeZone.Offset object. This is useful when working with time zones that have a known, fixed offset from UTC.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/DateTime-zoneMakeOffset.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const zoneMakeOffset: (offset: number) => TimeZone.Offset\n```\n\n----------------------------------------\n\nTITLE: Implementing isDequeue Type Guard in TypeScript\nDESCRIPTION: This function is a type guard that checks if the given value is a Dequeue instance. It returns true if the value is a Dequeue, false otherwise. This is useful for type narrowing in TypeScript.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Queue-isDequeue.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const isDequeue: (u: unknown) => u is Dequeue<unknown>\n```\n\n----------------------------------------\n\nTITLE: Using StringFromUriComponent Schema for URI Encoding in TypeScript\nDESCRIPTION: This example demonstrates how to use the StringFromUriComponent schema in combination with other schemas to encode pagination data into a URL-safe string. It showcases the composition of schemas and the encoding process.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Schema-StringFromUriComponent.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Schema } from \"effect\"\n\nconst PaginationSchema = Schema.Struct({\n  maxItemPerPage: Schema.Number,\n  page: Schema.Number\n})\n\nconst UrlSchema = Schema.compose(Schema.StringFromUriComponent, Schema.parseJson(PaginationSchema))\n\nconsole.log(Schema.encodeSync(UrlSchema)({ maxItemPerPage: 10, page: 1 }))\n// Output: %7B%22maxItemPerPage%22%3A10%2C%22page%22%3A1%7D\n```\n\n----------------------------------------\n\nTITLE: Number.remainder Signature\nDESCRIPTION: This snippet displays the signature of the `remainder` function. It defines the function as a curried function that takes either one (divisor) or two (self, divisor) number arguments and returns the remainder of the division. The function uses Typescript declaration syntax.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Number-remainder.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const remainder: { (divisor: number): (self: number) => number; (self: number, divisor: number): number; }\n```\n\n----------------------------------------\n\nTITLE: Retrieving TestConfig Service in TypeScript using Effect\nDESCRIPTION: This code snippet defines the testConfig constant, which is an Effect that retrieves the TestConfig service for a test. It has no input requirements and always succeeds, returning a TestConfig.TestConfig object.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TestServices-testConfig.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const testConfig: Effect.Effect<TestConfig.TestConfig, never, never>\n```\n\n----------------------------------------\n\nTITLE: Providing Service in STM using TypeScript\nDESCRIPTION: This snippet defines the `provideServiceSTM` function for handling service provision within the STM (Software Transactional Memory) context. It enables the user to provide a specific service required by a transactional effect. The function accommodates different tags and service types, ensuring type safety through TypeScript generics.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/STM-provideServiceSTM.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const provideServiceSTM: { <I, S, E1, R1>(tag: Context.Tag<I, S>, stm: STM<NoInfer<S>, E1, R1>): <A, E, R>(self: STM<A, E, R>) => STM<A, E1 | E, R1 | Exclude<R, I>>; <A, E, R, I, S, E1, R1>(self: STM<A, E, R>, tag: Context.Tag<I, S>, stm: STM<NoInfer<S>, E1, R1>): STM<A, E1 | E, R1 | Exclude<R, I>>; }\n```\n\n----------------------------------------\n\nTITLE: Defining Closeable Scope Type in TypeScript\nDESCRIPTION: Defines a type alias for CloseableScope, representing a scope that can be explicitly closed. Part of the Effect-TS package's Scope module.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Scope-Scope.Closeable.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ntype Closeable = CloseableScope\n```\n\n----------------------------------------\n\nTITLE: Creating Directory Arguments in Effect CLI\nDESCRIPTION: Function signature for creating a directory argument in the Effect CLI library. Takes an optional PathArgsConfig parameter and returns an Args<string> type. The function allows customization of the argument name, defaulting to 'directory' if not specified.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Args-directory.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const directory: (config?: Args.PathArgsConfig) => Args<string>\n```\n\n----------------------------------------\n\nTITLE: Creating Array Difference with Custom Equivalence Function in TypeScript\nDESCRIPTION: The differenceWith function creates an array containing values from the first iterable that are not included in the second iterable, using a custom equivalence function. The order and references of result values are determined by the first iterable.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Array-differenceWith.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Array } from \"effect\"\n\nconst array1 = [1, 2, 3]\nconst array2 = [2, 3, 4]\nconst difference = Array.differenceWith<number>((a, b) => a === b)(array1, array2)\nconsole.log(difference) // [1]\n```\n\n----------------------------------------\n\nTITLE: Creating Named TimeZone from IANA Identifier in TypeScript\nDESCRIPTION: Function that creates a Named TimeZone instance from an IANA time zone identifier string. Throws an IllegalArgumentException if the provided zone ID is invalid.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/DateTime-zoneUnsafeMakeNamed.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const zoneUnsafeMakeNamed: (zoneId: string) => TimeZone.Named\n```\n\n----------------------------------------\n\nTITLE: Type Guard Implementation for EmptyStream in TypeScript\nDESCRIPTION: A type guard function that determines if a given DocStream instance is specifically an EmptyStream. Returns true if the stream is empty, false otherwise. Used for type narrowing in TypeScript.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/DocStream-isEmptyStream.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const isEmptyStream: <A>(self: DocStream<A>) => self is EmptyStream<A>\n```\n\n----------------------------------------\n\nTITLE: Defining Doc.Char Interface in TypeScript\nDESCRIPTION: TypeScript interface definition for Doc.Char, which represents a document containing a single character. The interface ensures the character cannot be a newline and includes type variance, a tag for type identification, and the character itself.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Doc-Char.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface Char<A> extends Doc.Variance<A> {\n  readonly _tag: \"Char\"\n  readonly char: string\n}\n```\n\n----------------------------------------\n\nTITLE: Flattening a Document in TypeScript using @effect/printer\nDESCRIPTION: The flatten function takes a Doc<A> and returns a flattened version of it. This operation flattens the document structure but does not report any changes made during the process.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Doc-flatten.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const flatten: <A>(self: Doc<A>) => Doc<A>\n```\n\n----------------------------------------\n\nTITLE: Defining EntityAddress Class in TypeScript\nDESCRIPTION: Declaration of the EntityAddress class that represents the unique address of an entity within the cluster. This class serves as an identifier for entities in a clustered environment.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/EntityAddress-EntityAddress.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare class EntityAddress\n```\n\n----------------------------------------\n\nTITLE: Implementing Pool Item Invalidation in Effect-TS\nDESCRIPTION: Defines an invalidate function that marks a specified item in a KeyedPool as invalid, triggering eventual reallocation. The function is overloaded to support both curried and standard parameter passing styles.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/KeyedPool-invalidate.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const invalidate: { <A>(item: A): <K, E>(self: KeyedPool<K, A, E>) => Effect.Effect<void>; <K, A, E>(self: KeyedPool<K, A, E>, item: A): Effect.Effect<void>; }\n```\n\n----------------------------------------\n\nTITLE: Checking for EmptyTree Type in DocTree Module\nDESCRIPTION: A utility function that determines if a DocTree instance is specifically an EmptyTree type. It performs a type check and narrows the type using a type predicate, making it useful for conditional logic involving DocTree nodes.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/DocTree-isEmptyTree.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const isEmptyTree: <A>(self: DocTree<A>) => self is EmptyTree<A>\n```\n\n----------------------------------------\n\nTITLE: Defining RunnerNotRegistered Error Class in TypeScript\nDESCRIPTION: Declaration of the RunnerNotRegistered class which represents an error that occurs when a Runner is not registered with the shard manager in the Effect.io cluster system.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/ClusterError-RunnerNotRegistered.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare class RunnerNotRegistered\n```\n\n----------------------------------------\n\nTITLE: Defining whileInputEffect Function in TypeScript for Schedule Module\nDESCRIPTION: Declares a function that modifies a schedule to continue execution while an effectful predicate holds true for its input. It takes a predicate function and returns a new schedule that stops when the predicate evaluates to false.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Schedule-whileInputEffect.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const whileInputEffect: { <In, R2>(f: (input: In) => Effect.Effect<boolean, never, R2>): <Out, R>(self: Schedule<Out, In, R>) => Schedule<Out, In, R2 | R>; <Out, In, R, R2>(self: Schedule<Out, In, R>, f: (input: In) => Effect.Effect<boolean, never, R2>): Schedule<Out, In, R | R2>; }\n```\n\n----------------------------------------\n\nTITLE: Implementing Filterable partitionMapComposition in TypeScript\nDESCRIPTION: Returns a default binary `partitionMap` composition that works with nested type constructors. It combines a Covariant for the outer type F with a Filterable for the inner type G to partition elements of the nested structure using the provided function.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Filterable-partitionMapComposition.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const partitionMapComposition: <F extends TypeLambda, G extends TypeLambda>(F: Covariant<F>, G: Filterable<G>) => <FR, FO, FE, GR, GO, GE, A, B, C>(self: Kind<F, FR, FO, FE, Kind<G, GR, GO, GE, A>>, f: (a: A) => Either.Either<C, B>) => [Kind<F, FR, FO, FE, Kind<G, GR, GO, GE, B>>, Kind<F, FR, FO, FE, Kind<G, GR, GO, GE, C>>]\n```\n\n----------------------------------------\n\nTITLE: Declaring a Single Left Bracket Document Constant in TypeScript\nDESCRIPTION: Declaration of the lbracket constant that represents a document containing a single '[' character. It has a return type of Doc<never>, indicating it doesn't require any specific capability.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Doc-lbracket.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const lbracket: Doc<never>\n```\n\n----------------------------------------\n\nTITLE: Defining EmptyStream Interface in TypeScript for @effect/printer\nDESCRIPTION: Defines the EmptyStream interface that extends DocStream.Variance<A>. It represents an empty Doc and includes a readonly _tag property set to \"EmptyStream\".\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/DocStream-EmptyStream.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface EmptyStream<A> extends DocStream.Variance<A> {\n  readonly _tag: \"EmptyStream\"\n}\n```\n\n----------------------------------------\n\nTITLE: Defining traversePartitionMap Signature in TypeScript\nDESCRIPTION: This snippet declares the function signature for 'traversePartitionMap', which takes a Traversable, Covariant, and Filterable type as input, and returns a function that operates on an Applicative. The function applies a given mapping function returning an Either type, splitting the results into two collections based on the mapping outcome.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TraversableFilterable-traversePartitionMap.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const traversePartitionMap: <T extends TypeLambda>(T: Traversable<T> & Covariant<T> & Filterable<T>) => <F extends TypeLambda>(F: Applicative<F>) => <TR, TO, TE, A, R, O, E, B, C>(self: Kind<T, TR, TO, TE, A>, f: (a: A) => Kind<F, R, O, E, Either<C, B>>) => Kind<F, R, O, E, [Kind<T, TR, TO, TE, B>, Kind<T, TR, TO, TE, C>]>\n```\n\n----------------------------------------\n\nTITLE: Declaring Backslash Constant in TypeScript for Effect-IO-AI Printer\nDESCRIPTION: Defines a constant 'backslash' of type Doc<never> representing a document containing a single backslash character. This is part of the @effect/printer package's Doc module.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Doc-backslash.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const backslash: Doc<never>\n```\n\n----------------------------------------\n\nTITLE: Remainder Example in Effect/Number\nDESCRIPTION: This example demonstrates the usage of the `remainder` function from the `effect/Number` module. It showcases different input values and their corresponding remainders after division, verifying that the sign of the dividend is preserved. The example utilizes `node:assert` for making assertions about the results.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Number-remainder.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { remainder } from \"effect/Number\"\n\nassert.deepStrictEqual(remainder(2, 2), 0)\nassert.deepStrictEqual(remainder(3, 2), 1)\nassert.deepStrictEqual(remainder(-4, 2), -0)\n```\n\n----------------------------------------\n\nTITLE: Transforming DateTime Using mapEpochMillis in TypeScript\nDESCRIPTION: The mapEpochMillis function transforms a DateTime object by applying a function to its epoch milliseconds value. In this example, it adds 10 milliseconds to a DateTime created at Unix epoch 0.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/DateTime-mapEpochMillis.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { DateTime } from \"effect\"\n\n// add 10 milliseconds\nDateTime.unsafeMake(0).pipe(\n  DateTime.mapEpochMillis((millis) => millis + 10)\n)\n```\n\n----------------------------------------\n\nTITLE: Creating Polling Metrics in Effect.ts\nDESCRIPTION: Defines a function to create a new polling metric by combining a metric definition with a polling effect. The function is generic, accepting type parameters for the metric type, input type, output type, environment type, and error type.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/MetricPolling-make.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const make: <Type, In, Out, R, E>(metric: Metric.Metric<Type, In, Out>, poll: Effect.Effect<In, E, R>) => MetricPolling<Type, In, R, E, Out>\n```\n\n----------------------------------------\n\nTITLE: Implementing ANSI Terminal Beep Command in TypeScript\nDESCRIPTION: Defines a constant 'beep' of type AnsiDoc that triggers the terminal bell sound when rendered. This is a simple ANSI control sequence that produces an audible beep through the terminal speaker.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/AnsiDoc-beep.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const beep: AnsiDoc\n```\n\n----------------------------------------\n\nTITLE: Composing Option-returning Functions with Effect in TypeScript\nDESCRIPTION: This snippet demonstrates the `Option.composeK` function, which allows composing two functions that return Options. The first function is invoked, and if it returns `Some`, its result is passed to the second function. If it returns `None`, the composition returns `None` immediately. Dependencies include the Effect library. Inputs are strings for parsing and numbers for doubling, and the output is an Option with the final result of the composed operations.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Option-composeK.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { Option } from \"effect\"\n\nconst parse = (s: string): Option.Option<number> => isNaN(Number(s)) ? Option.none() : Option.some(Number(s))\n\nconst double = (n: number): Option.Option<number> => n > 0 ? Option.some(n * 2) : Option.none()\n\nconst parseAndDouble = Option.composeK(parse, double)\n\nconsole.log(parseAndDouble(\"42\"))\n// Output: { _id: 'Option', _tag: 'Some', value: 84 }\n\nconsole.log(parseAndDouble(\"not a number\"))\n// Output: { _id: 'Option', _tag: 'None' }\n```\n\n----------------------------------------\n\nTITLE: STM.zipRight Signature\nDESCRIPTION: This code snippet presents the TypeScript signature of the STM.zipRight function. It demonstrates how to use the function to sequentially zip two STM values, discarding the first element of the resulting tuple. The signature highlights the generic types involved, including A, E, R, A1, E1, and R1, representing the success type, error type, and environment type for each STM.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/STM-zipRight.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const zipRight: { <A1, E1, R1>(that: STM<A1, E1, R1>): <A, E, R>(self: STM<A, E, R>) => STM<A1, E1 | E, R1 | R>; <A, E, R, A1, E1, R1>(self: STM<A, E, R>, that: STM<A1, E1, R1>): STM<A1, E | E1, R | R1>; }\n```\n\n----------------------------------------\n\nTITLE: Trie unsafeGet Method Type Signature\nDESCRIPTION: Defines the type signature for the unsafeGet method with function overloading\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Trie-unsafeGet.md#2025-04-11_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const unsafeGet: { (key: string): <V>(self: Trie<V>) => V; <V>(self: Trie<V>, key: string): V; }\n```\n\n----------------------------------------\n\nTITLE: STM.firstSuccessOf signature\nDESCRIPTION: Defines the type signature for the `firstSuccessOf` function in the `STM` module of the Effect TS library. This function takes an iterable of `STM` actions and returns an `STM` action that results in the value of the first successful STM in the iterable, or fails if all STMs fail.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/STM-firstSuccessOf.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const firstSuccessOf: <A, E, R>(effects: Iterable<STM<A, E, R>>) => STM<A, E, R>\n```\n\n----------------------------------------\n\nTITLE: Removing Multiple Entries from a Trie in TypeScript\nDESCRIPTION: Demonstrates how to use the Trie.removeMany function to remove multiple entries from a Trie data structure. The example creates a Trie with three entries, then removes two of them using removeMany.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Trie-removeMany.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { Trie, Equal } from \"effect\"\n\nconst trie = Trie.empty<number>().pipe(\n  Trie.insert(\"shells\", 0),\n  Trie.insert(\"sells\", 1),\n  Trie.insert(\"she\", 2)\n)\n\nassert.equal(\n  Equal.equals(trie.pipe(Trie.removeMany([\"she\", \"sells\"])), Trie.empty<number>().pipe(Trie.insert(\"shells\", 0))),\n  true\n)\n```\n\n----------------------------------------\n\nTITLE: Signature of unsafeWipe Function in TypeScript\nDESCRIPTION: The 'unsafeWipe' function signature declares a method to erase a sensitive 'Redacted' value. It takes a 'Redacted' instance as its parameter, returning a boolean. This method is crucial in memory management of sensitive data.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Redacted-unsafeWipe.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const unsafeWipe: <A>(self: Redacted<A>) => boolean\n```\n\n----------------------------------------\n\nTITLE: Match.discriminators TypeScript Function Signature\nDESCRIPTION: The TypeScript type signature for the Match.discriminators function. It shows the complex generic types used to ensure type safety when matching discriminated unions.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Match-discriminators.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const discriminators: <D extends string>(field: D) => <R, Ret, P extends { readonly [Tag in Types.Tags<D, R> & string]?: ((_: Extract<R, Record<D, Tag>>) => Ret) | undefined; } & { readonly [Tag in Exclude<keyof P, Types.Tags<D, R>>]: never; }>(fields: P) => <I, F, A, Pr>(self: Matcher<I, F, R, A, Pr, Ret>) => Matcher<I, Types.AddWithout<F, Extract<R, Record<D, keyof P>>>, Types.ApplyFilters<I, Types.AddWithout<F, Extract<R, Record<D, keyof P>>>>, A | ReturnType<P[keyof P] & {}>, Pr, Ret>\n```\n\n----------------------------------------\n\nTITLE: Retrieving Queue Capacity in TypeScript\nDESCRIPTION: The capacity function returns the number of elements a queue can hold. It accepts either a TDequeue or TEnqueue generic type parameter A and returns a number.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TQueue-capacity.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const capacity: <A>(self: TDequeue<A> | TEnqueue<A>) => number\n```\n\n----------------------------------------\n\nTITLE: Implementing ensuringChild Method in TypeScript for Effect Module\nDESCRIPTION: This code defines the ensuringChild method which acts on the children of a fiber, ensuring a callback is invoked whether or not the effect succeeds. The signature shows both curried and non-curried forms of the function.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Effect-ensuringChild.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const ensuringChild: { <X, R2>(f: (fiber: Fiber.Fiber<ReadonlyArray<unknown>, any>) => Effect<X, never, R2>): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R2 | R>; <A, E, R, X, R2>(self: Effect<A, E, R>, f: (fiber: Fiber.Fiber<ReadonlyArray<unknown>, any>) => Effect<X, never, R2>): Effect<A, E, R | R2>; }\n```\n\n----------------------------------------\n\nTITLE: Using constFalse Function in TypeScript\nDESCRIPTION: Example demonstrating how to use the constFalse function, which is a thunk that always returns false when called. The example shows assertion testing to verify the function's behavior.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Function-constFalse.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assert from \"node:assert\"\nimport { constFalse } from \"effect/Function\"\n\nassert.deepStrictEqual(constFalse(), false)\n```\n\n----------------------------------------\n\nTITLE: TupleOf Type Definition\nDESCRIPTION: Defines the `TupleOf` type, which is used to represent tuples with a fixed length `N` and element type `T`. It uses conditional types to handle the length constraint.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Types-TupleOf.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ntype TupleOf<N, T> = N extends N ? number extends N ? Array<T> : _TupleOf<T, N, []> : never\n```\n\n----------------------------------------\n\nTITLE: isSome Method Signature\nDESCRIPTION: This snippet defines the TypeScript signature for the `isSome` function, indicating it checks if an `Option<A>` is of type `Some<A>`.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Option-isSome.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const isSome: <A>(self: Option<A>) => self is Some<A>\n```\n\n----------------------------------------\n\nTITLE: Stream.toPull Type Signature - TypeScript\nDESCRIPTION: Type signature for the Stream.toPull function showing its generic parameters and return type. Takes a Stream<A, E, R> and returns an Effect that produces another Effect for pulling chunks.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-toPull.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const toPull: <A, E, R>(self: Stream<A, E, R>) => Effect.Effect<Effect.Effect<Chunk.Chunk<A>, Option.Option<E>, R>, never, Scope.Scope | R>\n```\n\n----------------------------------------\n\nTITLE: Declaring mutateUtc Function for DateTime Modification in TypeScript\nDESCRIPTION: Defines the mutateUtc function which allows modification of a DateTime object by applying a function to a cloned UTC Date instance. It supports both curried and uncurried function calls.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/DateTime-mutateUtc.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const mutateUtc: { (f: (date: Date) => void): <A extends DateTime>(self: A) => A; <A extends DateTime>(self: A, f: (date: Date) => void): A; }\n```\n\n----------------------------------------\n\nTITLE: Defining DefaultChunkSize Constant in Stream Module\nDESCRIPTION: Declaration of the DefaultChunkSize constant used by various combinators and constructors of the Stream type in the effect package. This constant defines the default size for chunks in stream operations.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Stream-DefaultChunkSize.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const DefaultChunkSize: number\n```\n\n----------------------------------------\n\nTITLE: Defining Tuple Equivalence Function in TypeScript\nDESCRIPTION: Declares a function 'tuple' that takes multiple Equivalence instances and returns a new Equivalence for comparing tuples. It applies each input Equivalence to the corresponding element of the tuple.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Equivalence-tuple.md#2025-04-11_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const tuple: <T extends ReadonlyArray<Equivalence<any>>>(...elements: T) => Equivalence<Readonly<{ [I in keyof T]: [T[I]] extends [Equivalence<infer A>] ? A : never; }>>\n```\n\n----------------------------------------\n\nTITLE: Defining Test Repetition Count in Effect Framework (TypeScript)\nDESCRIPTION: Declares a constant 'repeats' that represents the number of times to repeat tests to ensure stability. It is defined as an Effect with a number output and no input or error types.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TestServices-repeats.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const repeats: Effect.Effect<number, never, never>\n```\n\n----------------------------------------\n\nTITLE: Creating an Empty TPriorityQueue in Effect TS\nDESCRIPTION: This snippet shows how to create an empty `TPriorityQueue` in Effect TS using the `empty` constructor. It requires an `Order` to specify the ordering of elements within the queue. The function returns an `STM` effect that, when executed, produces the new `TPriorityQueue`.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/TPriorityQueue-empty.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const empty: <A>(order: Order.Order<A>) => STM.STM<TPriorityQueue<A>>\n```\n\n----------------------------------------\n\nTITLE: Logger.logFmt Type Definition\nDESCRIPTION: Type signature for the logFmt logger showing it as a Layer that requires no dependencies and produces no errors.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Logger-logFmt.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const logFmt: Layer.Layer<never, never, never>\n```\n\n----------------------------------------\n\nTITLE: Implementing withConstantInput Method for Metric Class in TypeScript\nDESCRIPTION: Defines a function that creates a new metric from an existing one by setting a constant input value. This allows the metric to accept any type of updates while using a fixed update value internally. The function supports both curried and uncurried calling patterns.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Metric-withConstantInput.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const withConstantInput: {\n  <In>(input: In): <Type, Out>(self: Metric<Type, In, Out>) => Metric<Type, unknown, Out>;\n  <Type, In, Out>(self: Metric<Type, In, Out>, input: In): Metric<Type, unknown, Out>;\n}\n```\n\n----------------------------------------\n\nTITLE: Signature Definition for fromIterableWith in TypeScript\nDESCRIPTION: The signature shows overloaded definitions of 'fromIterableWith', indicating it accommodates different parameter orders. It transforms an iterable with a mapping function that provides key-value pairs, producing a record. The signature requires TypeScript knowledge to understand generic types and TypeScript specific syntax.\nSOURCE: https://github.com/tim-smart/effect-io-ai/blob/main/effect/Record-fromIterableWith.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const fromIterableWith: { <A, K extends string | symbol, B>(f: (a: A) => readonly [K, B]): (self: Iterable<A>) => Record<ReadonlyRecord.NonLiteralKey<K>, B>; <A, K extends string | symbol, B>(self: Iterable<A>, f: (a: A) => readonly [K, B]): Record<ReadonlyRecord.NonLiteralKey<K>, B>; }\n```"
  }
]