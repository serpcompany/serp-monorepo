[
  {
    "owner": "tokio-rs",
    "repo": "axum",
    "content": "TITLE: Building and Running an Axum Web Server in Rust\nDESCRIPTION: This Rust code initializes a web application using the Axum framework, sets up routing for GET and POST endpoints, and starts an HTTP server on port 3000 using Tokio. It includes handlers for the root path (returning a static string) and for creating users via a POST endpoint that accepts and returns JSON. Dependencies include axum for routing and handlers, serde for (de)serialization, tokio as an async runtime, and tracing for logging. Important structures are defined for parsing and serializing user-related data. The code requires Rust 1.75+ and assumes a properly configured Cargo.toml with the listed dependencies. Expected inputs include HTTP requests at '/' (GET) and '/users' (POST with JSON payload), while outputs are plain text or JSON HTTP responses as appropriate.\nSOURCE: https://github.com/tokio-rs/axum/blob/main/axum/README.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse axum::{\n    routing::{get, post},\n    http::StatusCode,\n    Json, Router,\n};\nuse serde::{Deserialize, Serialize};\n\n#[tokio::main]\nasync fn main() {\n    // initialize tracing\n    tracing_subscriber::fmt::init();\n\n    // build our application with a route\n    let app = Router::new()\n        // `GET /` goes to `root`\n        .route(\"/\", get(root))\n        // `POST /users` goes to `create_user`\n        .route(\"/users\", post(create_user));\n\n    // run our app with hyper, listening globally on port 3000\n    let listener = tokio::net::TcpListener::bind(\"0.0.0.0:3000\").await.unwrap();\n    axum::serve(listener, app).await.unwrap();\n}\n\n// basic handler that responds with a static string\nasync fn root() -> &'static str {\n    \"Hello, World!\"\n}\n\nasync fn create_user(\n    // this argument tells axum to parse the request body\n    // as JSON into a `CreateUser` type\n    Json(payload): Json<CreateUser>,\n) -> (StatusCode, Json<User>) {\n    // insert your application logic here\n    let user = User {\n        id: 1337,\n        username: payload.username,\n    };\n\n    // this will be converted into a JSON response\n    // with a status code of `201 Created`\n    (StatusCode::CREATED, Json(user))\n}\n\n// the input to our `create_user` handler\n#[derive(Deserialize)]\nstruct CreateUser {\n    username: String,\n}\n\n// the output to our `create_user` handler\n#[derive(Serialize)]\nstruct User {\n    id: u64,\n    username: String,\n}\n\n```\n\n----------------------------------------\n\nTITLE: Building a Basic Axum Web Application in Rust\nDESCRIPTION: A complete example demonstrating how to build a web application with axum, including routing, handling HTTP methods, parsing JSON requests, and returning structured responses.\nSOURCE: https://github.com/tokio-rs/axum/blob/main/README.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse axum:{\n    routing::{get, post},\n    http::StatusCode,\n    Json, Router,\n};\nuse serde::{Deserialize, Serialize};\n\n#[tokio::main]\nasync fn main() {\n    // initialize tracing\n    tracing_subscriber::fmt::init();\n\n    // build our application with a route\n    let app = Router::new()\n        // `GET /` goes to `root`\n        .route(\"/\", get(root))\n        // `POST /users` goes to `create_user`\n        .route(\"/users\", post(create_user));\n\n    // run our app with hyper, listening globally on port 3000\n    let listener = tokio::net::TcpListener::bind(\"0.0.0.0:3000\").await.unwrap();\n    axum::serve(listener, app).await.unwrap();\n}\n\n// basic handler that responds with a static string\nasync fn root() -> &'static str {\n    \"Hello, World!\"\n}\n\nasync fn create_user(\n    // this argument tells axum to parse the request body\n    // as JSON into a `CreateUser` type\n    Json(payload): Json<CreateUser>,\n) -> (StatusCode, Json<User>) {\n    // insert your application logic here\n    let user = User {\n        id: 1337,\n        username: payload.username,\n    };\n\n    // this will be converted into a JSON response\n    // with a status code of `201 Created`\n    (StatusCode::CREATED, Json(user))\n}\n\n// the input to our `create_user` handler\n#[derive(Deserialize)]\nstruct CreateUser {\n    username: String,\n}\n\n// the output to our `create_user` handler\n#[derive(Serialize)]\nstruct User {\n    id: u64,\n    username: String,\n}\n```\n\n----------------------------------------\n\nTITLE: Handler returning a Result with StatusCode\nDESCRIPTION: Shows how to create a handler function that returns a Result where the error type implements IntoResponse, allowing errors to be converted to HTTP responses.\nSOURCE: https://github.com/tokio-rs/axum/blob/main/axum/src/docs/error_handling.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse axum::http::StatusCode;\n\nasync fn handler() -> Result<String, StatusCode> {\n    # todo!()\n    // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Various Route Types in Axum (Rust)\nDESCRIPTION: Provides a comprehensive example showcasing different routing patterns in Axum: static paths (`/`), paths with single captures (`/users/{id}`), paths with multiple captures (`/api/{version}/users/{id}/action`), and wildcard paths (`/assets/{*path}`). It demonstrates extracting path parameters using `Path` with different types (`u64`, tuple `(String, u64)`, `String`). Requires the `axum` crate and corresponding handler functions for each route.\nSOURCE: https://github.com/tokio-rs/axum/blob/main/axum/src/docs/routing/route.md#_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nuse axum::{Router, routing::{get, delete}, extract::Path};\n\nlet app = Router::new()\n    .route(\"/\", get(root))\n    .route(\"/users\", get(list_users).post(create_user))\n    .route(\"/users/{id}\", get(show_user))\n    .route(\"/api/{version}/users/{id}/action\", delete(do_users_action))\n    .route(\"/assets/{*path}\", get(serve_asset));\n\nasync fn root() {}\n\nasync fn list_users() {}\n\nasync fn create_user() {}\n\nasync fn show_user(Path(id): Path<u64>) {}\n\nasync fn do_users_action(Path((version, id)): Path<(String, u64)>) {}\n\nasync fn serve_asset(Path(path): Path<String>) {}\n# let _: Router = app;\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Common Axum Extractors - Rust\nDESCRIPTION: Illustrates how to use various built-in Axum extractors such as `Path`, `Query`, `HeaderMap`, `String`, `Bytes`, `Json`, `Request`, and `Extension` as arguments in handler functions to access different parts of an HTTP request. Includes an example of routing multiple paths to handlers using these extractors.\nSOURCE: https://github.com/tokio-rs/axum/blob/main/axum/src/docs/extract.md#_snippet_1\n\nLANGUAGE: Rust\nCODE:\n```\nuse axum::{\n    extract::{Request, Json, Path, Extension, Query},\n    routing::post,\n    http::header::HeaderMap,\n    body::{Bytes, Body},\n    Router,\n};\nuse serde_json::Value;\nuse std::collections::HashMap;\n\n// `Path` gives you the path parameters and deserializes them. See its docs for\n// more details\nasync fn path(Path(user_id): Path<u32>) {}\n\n// `Query` gives you the query parameters and deserializes them.\nasync fn query(Query(params): Query<HashMap<String, String>>) {}\n\n// `HeaderMap` gives you all the headers\nasync fn headers(headers: HeaderMap) {}\n\n// `String` consumes the request body and ensures it is valid utf-8\nasync fn string(body: String) {}\n\n// `Bytes` gives you the raw request body\nasync fn bytes(body: Bytes) {}\n\n// We've already seen `Json` for parsing the request body as json\nasync fn json(Json(payload): Json<Value>) {}\n\n// `Request` gives you the whole request for maximum control\nasync fn request(request: Request) {}\n\n// `Extension` extracts data from \"request extensions\"\n// This is commonly used to share state with handlers\nasync fn extension(Extension(state): Extension<State>) {}\n\n#[derive(Clone)]\nstruct State { /* ... */ }\n\nlet app = Router::new()\n    .route(\"/path/{user_id}\", post(path))\n    .route(\"/query\", post(query))\n    .route(\"/string\", post(string))\n    .route(\"/bytes\", post(bytes))\n    .route(\"/json\", post(json))\n    .route(\"/request\", post(request))\n    .route(\"/extension\", post(extension));\n# let _: Router = app;\n```\n\n----------------------------------------\n\nTITLE: Implementing Basic Response Types in Rust with Axum\nDESCRIPTION: Examples of common response types in Axum, including empty responses, plain text, bytes, JSON, HTML, status codes, and headers. Each function demonstrates a different way to return data from an Axum handler.\nSOURCE: https://github.com/tokio-rs/axum/blob/main/axum/src/docs/response.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse axum:{\n    Json,\n    response::{Html, IntoResponse},\n    http::{StatusCode, Uri, header::{self, HeaderMap, HeaderName}},\n};\n\n// `()` gives an empty response\nasync fn empty() {}\n\n// String will get a `text/plain; charset=utf-8` content-type\nasync fn plain_text(uri: Uri) -> String {\n    format!(\"Hi from {}\", uri.path())\n}\n\n// Bytes will get a `application/octet-stream` content-type\nasync fn bytes() -> Vec<u8> {\n    vec![1, 2, 3, 4]\n}\n\n// `Json` will get a `application/json` content-type and work with anything that\n// implements `serde::Serialize`\nasync fn json() -> Json<Vec<String>> {\n    Json(vec![\"foo\".to_owned(), \"bar\".to_owned()])\n}\n\n// `Html` will get a `text/html` content-type\nasync fn html() -> Html<&'static str> {\n    Html(\"<p>Hello, World!</p>\")\n}\n\n// `StatusCode` gives an empty response with that status code\nasync fn status() -> StatusCode {\n    StatusCode::NOT_FOUND\n}\n\n// `HeaderMap` gives an empty response with some headers\nasync fn headers() -> HeaderMap {\n    let mut headers = HeaderMap::new();\n    headers.insert(header::SERVER, \"axum\".parse().unwrap());\n    headers\n}\n\n// An array of tuples also gives headers\nasync fn array_headers() -> [(HeaderName, &'static str); 2] {\n    [\n        (header::SERVER, \"axum\"),\n        (header::CONTENT_TYPE, \"text/plain\")\n    ]\n}\n\n// Use `impl IntoResponse` to avoid writing the whole type\nasync fn impl_trait() -> impl IntoResponse {\n    [\n        (header::SERVER, \"axum\"),\n        (header::CONTENT_TYPE, \"text/plain\")\n    ]\n}\n```\n\n----------------------------------------\n\nTITLE: Understanding `Router<S>` and Its State Handling in Rust\nDESCRIPTION: This snippet clarifies that `Router<S>` indicates a router missing a state of type `S` needed for request handling, not that it contains such state. It demonstrates transforming a `Router<AppState>` into a `Router<()>` by calling `with_state()`, which supplies the state and resolves the missing state type. It emphasizes that only `Router<()>` supports `into_make_service()`, a prerequisite for serving.\nSOURCE: https://github.com/tokio-rs/axum/blob/main/axum/src/docs/routing/with_state.md#_snippet_4\n\nLANGUAGE: Rust\nCODE:\n```\nuse axum::{Router, routing::get, extract::State};\n\n#[derive(Clone)]\nstruct AppState {}\n\n// A router that needs an `AppState` to handle requests\nlet router: Router<AppState> = Router::new()\n    .route(\"/\", get(|_: State<AppState>| async {}));\n\n// After calling `with_state`, the router's type indicates it's no longer missing state\nlet router: Router<()> = router.with_state(AppState {});\n\n// Only `Router<()>` supports `into_make_service()`\n# async {\nlet listener = tokio::net::TcpListener::bind(\"0.0.0.0:3000\").await.unwrap();\naxum::serve(listener, router).await.unwrap();\n# };\n\n```\n\n----------------------------------------\n\nTITLE: Using 'impl IntoResponse' as Return Type in Axum\nDESCRIPTION: Examples showing how to use 'impl IntoResponse' to simplify return type annotations in handler functions. Includes both a basic example and a correct usage with Result.\nSOURCE: https://github.com/tokio-rs/axum/blob/main/axum/src/docs/response.md#_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nuse axum::{http::StatusCode, response::IntoResponse};\n\nasync fn impl_into_response() -> impl IntoResponse {\n    (StatusCode::OK, [(\"x-foo\", \"bar\")], \"Hello, World!\")\n}\n```\n\nLANGUAGE: rust\nCODE:\n```\nuse axum::{http::StatusCode, response::IntoResponse};\n\nasync fn handler() -> Result<impl IntoResponse, StatusCode> {\n    create_thing()?;\n    Ok(StatusCode::CREATED)\n}\n\nfn create_thing() -> Result<(), StatusCode> {\n    # Ok(())\n    // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Example Compiler Error for Handler Trait Non-Compliance in Rust\nDESCRIPTION: An example Rust compiler error demonstrating a function not implementing the Handler trait required by axum. The snippet illustrates a common error message when a function signature does not conform to axum's handler requirements, specifically when used with Router's get routing method. This helps developers recognize the type issue in their asynchronous handler functions.\nSOURCE: https://github.com/tokio-rs/axum/blob/main/axum/src/docs/debugging_handler_type_errors.md#_snippet_0\n\nLANGUAGE: not_rust\nCODE:\n```\nerror[E0277]: the trait bound `fn(bool) -> impl Future {handler}: Handler<_, _>` is not satisfied\n   --> src/main.rs:13:44\n    |\n13  |     let app = Router::new().route(\"/\", get(handler));\n    |                                            ^^^^^^^ the trait `Handler<_, _>` is not implemented for `fn(bool) -> impl Future {handler}`\n    |\n   ::: axum/src/handler/mod.rs:116:8\n    |\n116 |     H: Handler<T, B>,\n    |        ------------- required by this bound in `axum::routing::get`\n```\n\n----------------------------------------\n\nTITLE: Using Json Extractor in Axum Handler - Rust\nDESCRIPTION: Demonstrates a basic Axum handler function that utilizes the `Json` extractor to deserialize the request body into a custom struct. It also shows how to define a route that uses this handler with `axum::Router`.\nSOURCE: https://github.com/tokio-rs/axum/blob/main/axum/src/docs/extract.md#_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\nuse axum::{\n    extract::Json,\n    routing::post,\n    handler::Handler,\n    Router,\n};\nuse serde::Deserialize;\n\n#[derive(Deserialize)]\nstruct CreateUser {\n    email: String,\n    password: String,\n}\n\nasync fn create_user(Json(payload): Json<CreateUser>) {\n    // ...\n}\n\nlet app = Router::new().route(\"/users\", post(create_user));\n# let _: Router = app;\n```\n\n----------------------------------------\n\nTITLE: Initializing Axum Router with State (Axum 0.6) - Rust\nDESCRIPTION: This Rust code shows the recommended approach in Axum 0.6 for sharing application state (`AppState`). It uses the `.with_state(AppState {})` method on the `Router` and extracts the state in the handler using `State<AppState>`. This method is more type-safe and faster than the older `Extension` approach, catching missing states at compile time.\nSOURCE: https://github.com/tokio-rs/axum/blob/main/axum/CHANGELOG.md#_snippet_1\n\nLANGUAGE: Rust\nCODE:\n```\nuse axum::{routing::get, extract::State, Router};\n\nlet app = Router::new()\n    .route(\"/\", get(handler))\n    .with_state(AppState {});\n\nasync fn handler(State(app_state): State<AppState>) {}\n\n#[derive(Clone)]\nstruct AppState {}\n```\n\n----------------------------------------\n\nTITLE: Applying fallible middleware with HandleErrorLayer\nDESCRIPTION: Shows how to handle errors from middleware using HandleErrorLayer. This example adds a timeout middleware and handles its errors.\nSOURCE: https://github.com/tokio-rs/axum/blob/main/axum/src/docs/error_handling.md#_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse axum:{\n    Router,\n    BoxError,\n    routing::get,\n    http::StatusCode,\n    error_handling::HandleErrorLayer,\n};\nuse std::time::Duration;\nuse tower::ServiceBuilder;\n\nlet app = Router::new()\n    .route(\"/\", get(|| async {}))\n    .layer(\n        ServiceBuilder::new()\n            // `timeout` will produce an error if the handler takes\n            // too long so we must handle those\n            .layer(HandleErrorLayer::new(handle_timeout_error))\n            .timeout(Duration::from_secs(30))\n    );\n\nasync fn handle_timeout_error(err: BoxError) -> (StatusCode, String) {\n    if err.is::<tower::timeout::error::Elapsed>() {\n        (\n            StatusCode::REQUEST_TIMEOUT,\n            \"Request took too long\".to_string(),\n        )\n    } else {\n        (\n            StatusCode::INTERNAL_SERVER_ERROR,\n            format!(\"Unhandled internal error: {err}\"),\n        )\n    }\n}\n# let _: Router = app;\n```\n\n----------------------------------------\n\nTITLE: Creating and Returning `Router` with State from Functions in Rust\nDESCRIPTION: This snippet demonstrates the best practice of returning a `Router` without setting state directly inside the function, instead attaching state afterward with `with_state()` before serving. It emphasizes pre-binding the state to avoid type signature issues and highlights the importance of avoiding `Router<AppState>` if the server requires `into_make_service()`. The example sets up the server to listen on a TCP socket and serve the router.\nSOURCE: https://github.com/tokio-rs/axum/blob/main/axum/src/docs/routing/with_state.md#_snippet_1\n\nLANGUAGE: Rust\nCODE:\n```\nuse axum::{Router, routing::get, extract::State};\n\n#[derive(Clone)]\nstruct AppState {}\n\n// Don't call `Router::with_state` here\nfn routes() -> Router {\n    Router::new()\n        .route(\"/\", get(|_: State<AppState>| async {}))\n}\n\n// Attach the state before serving\nlet routes = routes().with_state(AppState {});\n\n# async {\nlet listener = tokio::net::TcpListener::bind(\"0.0.0.0:3000\").await.unwrap();\naxum::serve(listener, routes).await.unwrap();\n# };\n\n```\n\n----------------------------------------\n\nTITLE: Defining and Using Global State in Axum Router with `with_state` Method (Rust)\nDESCRIPTION: This snippet defines a simple application state struct, creates an Axum router, and attaches the state using `with_state()`. It demonstrates how to inject shared, global state into request handlers, with a focus on the relevant dependencies (`axum`, `tokio`) and the request handling pattern. The example shows the setup for listening on a TCP socket and serving the app.\nSOURCE: https://github.com/tokio-rs/axum/blob/main/axum/src/docs/routing/with_state.md#_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\nuse axum::{Router, routing::get, extract::State};\n\n#[derive(Clone)]\nstruct AppState {}\n\nlet routes = Router::new()\n    .route(\"/\", get(|State(state): State<AppState>| async {\n        // use state\n    }))\n    .with_state(AppState {});\n\n# async {\nlet listener = tokio::net::TcpListener::bind(\"0.0.0.0:3000\").await.unwrap();\naxum::serve(listener, routes).await.unwrap();\n# };\n\n```\n\n----------------------------------------\n\nTITLE: Applying Multiple Middleware with ServiceBuilder in Rust\nDESCRIPTION: This code snippet demonstrates how to apply multiple middleware to an axum router using `tower::ServiceBuilder`. It showcases the use of `TraceLayer` for HTTP tracing and `Extension` for adding state to the request context. This approach is recommended for managing middleware composition and ordering.\nSOURCE: https://github.com/tokio-rs/axum/blob/main/axum/src/docs/middleware.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse axum::{\n    routing::get,\n    Extension,\n    Router,\n};\nuse tower_http::{trace::TraceLayer};\nuse tower::ServiceBuilder;\n\nasync fn handler() {}\n\n#[derive(Clone)]\nstruct State {}\n\nlet app = Router::new()\n    .route(\"/\", get(handler))\n    .layer(\n        ServiceBuilder::new()\n            .layer(TraceLayer::new_for_http())\n            .layer(Extension(State {}))\n    );\n# let _: Router = app;\n```\n\n----------------------------------------\n\nTITLE: Applying Route-Specific Middleware in Axum Using Rust\nDESCRIPTION: This Rust snippet demonstrates how to use `route_layer` on an Axum Router to apply the `ValidateRequestHeaderLayer` middleware only to requests matching a specific route ('/foo'). It requires the `axum` and `tower_http` crates. The middleware validates the Authorization header against a bearer token ('password'). The route middleware only executes for matching requests, allowing proper HTTP status code behavior: returning 401 Unauthorized for invalid tokens on GET /foo, while preserving 405 Method Not Allowed for unsupported methods like POST /foo. It assumes prior route addition before applying middleware to ensure correct behavior.\nSOURCE: https://github.com/tokio-rs/axum/blob/main/axum/src/docs/method_routing/route_layer.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse axum::{\n    routing::get,\n    Router,\n};\nuse tower_http::validate_request::ValidateRequestHeaderLayer;\n\nlet app = Router::new().route(\n    \"/foo\",\n    get(|| async {})\n        .route_layer(ValidateRequestHeaderLayer::bearer(\"password\"))\n);\n\n// `GET /foo` with a valid token will receive `200 OK`\n// `GET /foo` with a invalid token will receive `401 Unauthorized`\n// `POST /FOO` with a invalid token will receive `405 Method Not Allowed`\n# let _: Router = app;\n```\n\n----------------------------------------\n\nTITLE: Applying Route-Specific Middleware with `route_layer` in Axum\nDESCRIPTION: This Rust example demonstrates how to use `route_layer` in Axum to apply middleware (specifically `ValidateRequestHeaderLayer` for bearer token authentication) only to requests matching a defined route (`/foo`). Requests to undefined paths (`/not-found`) will not trigger this middleware, resulting in a standard 404 Not Found error, even with invalid tokens. This requires the `axum` and `tower-http` crates.\nSOURCE: https://github.com/tokio-rs/axum/blob/main/axum/src/docs/routing/route_layer.md#_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\nuse axum::{\n    routing::get,\n    Router,\n};\nuse tower_http::validate_request::ValidateRequestHeaderLayer;\n\nlet app = Router::new()\n    .route(\"/foo\", get(|| async {}))\n    .route_layer(ValidateRequestHeaderLayer::bearer(\"password\"));\n\n// `GET /foo` with a valid token will receive `200 OK`\n// `GET /foo` with a invalid token will receive `401 Unauthorized`\n// `GET /not-found` with a invalid token will receive `404 Not Found`\n# let _: Router = app;\n```\n\n----------------------------------------\n\nTITLE: Middleware Ordering Example in Rust\nDESCRIPTION: This example illustrates the default middleware ordering in axum when using `Router::layer` repeatedly. Middleware is applied in the order it's added, effectively creating an 'onion-like' layering where each new layer wraps the previous ones. The request flows through the layers from bottom to top, and the response flows back from top to bottom.\nSOURCE: https://github.com/tokio-rs/axum/blob/main/axum/src/docs/middleware.md#_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse axum::{routing::get, Router};\n\nasync fn handler() {}\n\n# let layer_one = axum::Extension(());\n# let layer_two = axum::Extension(());\n# let layer_three = axum::Extension(());\n#\nlet app = Router::new()\n    .route(\"/\", get(handler))\n    .layer(layer_one)\n    .layer(layer_two)\n    .layer(layer_three);\n# let _: Router = app;\n```\n\n----------------------------------------\n\nTITLE: Defining Axum Handlers and Setting Up Router (Rust)\nDESCRIPTION: This Rust snippet defines the handlers for the Axum web application. It sets up a route for the root path (\"/\") using the `get` method and associates it with the `hello_world` handler.  It also defines two fallback handlers: `default_fallback` for routes not found, and `handle_405` for method not allowed errors. The `fallback` and `method_not_allowed_fallback` methods on the router are used to set these handlers. This example uses the `axum` and `tokio` crates. The expected input is a web request and the output is a string.\nSOURCE: https://github.com/tokio-rs/axum/blob/main/axum/src/docs/routing/method_not_allowed_fallback.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse axum::{response::IntoResponse, routing::get, Router};\n\nasync fn hello_world() -> impl IntoResponse {\n    \"Hello, world!\\n\"\n}\n\nasync fn default_fallback() -> impl IntoResponse {\n    \"Default fallback\\n\"\n}\n\nasync fn handle_405() -> impl IntoResponse {\n    \"Method not allowed fallback\"\n}\n\n#[tokio::main]\nasync fn main() {\n    let router = Router::new()\n        .route(\"/\", get(hello_world))\n        .fallback(default_fallback)\n        .method_not_allowed_fallback(handle_405);\n\n    let listener = tokio::net::TcpListener::bind(\"0.0.0.0:3000\").await.unwrap();\n\n    axum::serve(listener, router).await.unwrap();\n}\n```\n\n----------------------------------------\n\nTITLE: Applying Different Middleware to Specific Route Groups with Router::merge\nDESCRIPTION: Shows how to apply different middleware to specific groups of routes by creating separate routers and merging them. This approach allows TraceLayer to be applied only to /foo and CompressionLayer only to /bar.\nSOURCE: https://github.com/tokio-rs/axum/blob/main/axum/src/docs/routing/layer.md#_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse axum::{routing::get, Router};\nuse tower_http::{trace::TraceLayer, compression::CompressionLayer};\n\nlet with_tracing = Router::new()\n    .route(\"/foo\", get(|| async {}))\n    .layer(TraceLayer::new_for_http());\n\nlet with_compression = Router::new()\n    .route(\"/bar\", get(|| async {}))\n    .layer(CompressionLayer::new());\n\n// Merge everything into one `Router`\nlet app = Router::new()\n    .merge(with_tracing)\n    .merge(with_compression);\n# let _: Router = app;\n```\n\n----------------------------------------\n\nTITLE: Using Multiple Axum Extractors in Handler - Rust\nDESCRIPTION: Shows how a single Axum handler function can accept multiple extractor arguments, specifically combining `Path` to extract a URL parameter and `Query` to extract query string parameters into a struct. Includes routing configuration.\nSOURCE: https://github.com/tokio-rs/axum/blob/main/axum/src/docs/extract.md#_snippet_2\n\nLANGUAGE: Rust\nCODE:\n```\nuse axum::{\n    extract::{Path, Query},\n    routing::get,\n    Router,\n};\nuse uuid::Uuid;\nuse serde::Deserialize;\n\nlet app = Router::new().route(\"/users/{id}/things\", get(get_user_things));\n\n#[derive(Deserialize)]\nstruct Pagination {\n    page: usize,\n    per_page: usize,\n}\n\nasync fn get_user_things(\n    Path(user_id): Path<Uuid>,\n    Query(pagination): Query<Pagination>,\n) {\n    // ...\n}\n# let _: Router = app;\n```\n\n----------------------------------------\n\nTITLE: Passing State from Middleware to Handlers via Request Extensions (Rust)\nDESCRIPTION: Shows how to pass state from middleware to handlers using request extensions. The middleware (`auth` function) extracts authentication information, authorizes a user, and then inserts the `CurrentUser` object into the request's extensions. The handler then extracts the `CurrentUser` using `axum::extract::Extension`. The dependencies are `axum` and `http`.\nSOURCE: https://github.com/tokio-rs/axum/blob/main/axum/src/docs/middleware.md#_snippet_8\n\nLANGUAGE: Rust\nCODE:\n```\nuse axum::{\n    Router,\n    http::StatusCode,\n    routing::get,\n    response::{IntoResponse, Response},\n    middleware::{self, Next},\n    extract::{Request, Extension},\n};\n\n#[derive(Clone)]\nstruct CurrentUser { /* ... */ }\n\nasync fn auth(mut req: Request, next: Next) -> Result<Response, StatusCode> {\n    let auth_header = req.headers()\n        .get(http::header::AUTHORIZATION)\n        .and_then(|header| header.to_str().ok());\n\n    let auth_header = if let Some(auth_header) = auth_header {\n        auth_header\n    } else {\n        return Err(StatusCode::UNAUTHORIZED);\n    };\n\n    if let Some(current_user) = authorize_current_user(auth_header).await {\n        // insert the current user into a request extension so the handler can\n        // extract it\n        req.extensions_mut().insert(current_user);\n        Ok(next.run(req).await)\n    } else {\n        Err(StatusCode::UNAUTHORIZED)\n    }\n}\n\nasync fn authorize_current_user(auth_token: &str) -> Option<CurrentUser> {\n    // ...\n    # unimplemented!()\n}\n\nasync fn handler(\n    // extract the current user, set by the middleware\n    Extension(current_user): Extension<CurrentUser>,\n) {\n    // ...\n}\n\nlet app = Router::new()\n    .route(\"/\", get(handler))\n    .route_layer(middleware::from_fn(auth));\n# let _: Router = app;\n```\n\n----------------------------------------\n\nTITLE: Creating a Router with Provided State Parameter (Rust)\nDESCRIPTION: This snippet shows how to create a Router with an explicit application state passed as a parameter. It does not set state directly inside the route configuration but uses `with_state()` method. It highlights that the router is returned without a fixed generic state type, which is appropriate when nesting or merging routers, and notes that only `Router<()>` can call `into_make_service`. The example concludes with setting up the TCP listener and serving the router.\nSOURCE: https://github.com/tokio-rs/axum/blob/main/axum/src/docs/routing/with_state.md#_snippet_2\n\nLANGUAGE: Rust\nCODE:\n```\nuse axum::{Router, routing::get, extract::State};\n\n#[derive(Clone)]\nstruct AppState {}\n\n// Don't return `Router<AppState>`\nfn routes(state: AppState) -> Router {\n    Router::new()\n        .route(\"/\", get(|_: State<AppState>| async {}))\n        .with_state(state)\n}\n\nlet routes = routes(AppState {});\n\n# async {\nlet listener = tokio::net::TcpListener::bind(\"0.0.0.0:3000\").await.unwrap();\naxum::serve(listener, routes).await.unwrap();\n# };\n\n```\n\n----------------------------------------\n\nTITLE: Creating and Nesting Axum Routers in Rust\nDESCRIPTION: This snippet demonstrates how to nest multiple axum routers together to create a structured application. It defines routes for users and teams, and then nests them under a central `/api` route. This demonstrates a common pattern for organizing API endpoints.\nSOURCE: https://github.com/tokio-rs/axum/blob/main/axum/src/docs/routing/nest.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse axum::{\n    routing::{get, post},\n    Router,\n};\n\nlet user_routes = Router::new().route(\"/{id}\", get(|| async {}));\n\nlet team_routes = Router::new().route(\"/\", post(|| async {}));\n\nlet api_routes = Router::new()\n    .nest(\"/users\", user_routes)\n    .nest(\"/teams\", team_routes);\n\nlet app = Router::new().nest(\"/api\", api_routes);\n\n// Our app now accepts\n// - GET /api/users/{id}\n// - POST /api/teams\n```\n\n----------------------------------------\n\nTITLE: Handling Axum Json Extractor Rejections - Rust\nDESCRIPTION: Explains and demonstrates how to explicitly handle potential errors (rejections) from a `Json` extractor within a specific handler function by wrapping the extractor type in `Result<T, T::Rejection>`. It shows matching against different `JsonRejection` variants.\nSOURCE: https://github.com/tokio-rs/axum/blob/main/axum/src/docs/extract.md#_snippet_6\n\nLANGUAGE: Rust\nCODE:\n```\nuse axum::{\n    extract::{Json, rejection::JsonRejection},\n    routing::post,\n    Router,\n};\nuse serde_json::Value;\n\nasync fn create_user(payload: Result<Json<Value>, JsonRejection>) {\n    match payload {\n        Ok(payload) => {\n            // We got a valid JSON payload\n        }\n        Err(JsonRejection::MissingJsonContentType(_)) => {\n            // Request didn't have `Content-Type: application/json`\n            // header\n        }\n        Err(JsonRejection::JsonDataError(_)) => {\n            // Couldn't deserialize the body into the target type\n        }\n        Err(JsonRejection::JsonSyntaxError(_)) => {\n            // Syntax error in the body\n        }\n        Err(JsonRejection::BytesRejection(_)) => {\n            // Failed to extract the request body\n        }\n        Err(_) => {\n            // `JsonRejection` is marked `#[non_exhaustive]` so match must\n            // include a catch-all case.\n        }\n    }\n}\n\nlet app = Router::new().route(\"/users\", post(create_user));\n# let _: Router = app;\n```\n\n----------------------------------------\n\nTITLE: Correct Order of Axum Extractors (Body Last) - Rust\nDESCRIPTION: Illustrates the correct ordering of extractors in an Axum handler function. Extractors that consume the request body (like `String` or `Json`) must appear as the last argument, while extractors that only read request parts (like `Method`, `HeaderMap`, `State`) can appear earlier.\nSOURCE: https://github.com/tokio-rs/axum/blob/main/axum/src/docs/extract.md#_snippet_3\n\nLANGUAGE: Rust\nCODE:\n```\nuse axum::{extract::State, http::{Method, HeaderMap}};\n#\n# #[derive(Clone)]\n# struct AppState {\n# }\n\nasync fn handler(\n    // `Method` and `HeaderMap` don't consume the request body so they can\n    // put anywhere in the argument list (but before `body`)\n    method: Method,\n    headers: HeaderMap,\n    // `State` is also an extractor so it needs to be before `body`\n    State(state): State<AppState>,\n    // `String` consumes the request body and thus must be the last extractor\n    body: String,\n) {\n    // ...\n}\n#\n# let _: axum::routing::MethodRouter<AppState> = axum::routing::get(handler);\n```\n\n----------------------------------------\n\nTITLE: Applying TraceLayer Middleware to All Routes in Axum Router\nDESCRIPTION: Demonstrates how to add tower_http::trace::TraceLayer middleware to all routes in an Axum Router. The middleware is applied after defining routes using the layer method, which will affect all previously defined routes.\nSOURCE: https://github.com/tokio-rs/axum/blob/main/axum/src/docs/routing/layer.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse axum::{routing::get, Router};\nuse tower_http::trace::TraceLayer;\n\nlet app = Router::new()\n    .route(\"/foo\", get(|| async {}))\n    .route(\"/bar\", get(|| async {}))\n    .layer(TraceLayer::new_for_http());\n# let _: Router = app;\n```\n\n----------------------------------------\n\nTITLE: Tower Service Middleware Template in Rust\nDESCRIPTION: This code provides a template for writing middleware using `tower::Service` with `Pin<Box<dyn Future>>`. It defines a `MyLayer` that implements `tower::Layer` and a `MyMiddleware` that implements `tower::Service`. This approach allows for configurable middleware and is suitable for publishing middleware as a crate. The error type defaults to `S::Error` indicating that the middleware should generally return a response and not bail out with a custom error.\nSOURCE: https://github.com/tokio-rs/axum/blob/main/axum/src/docs/middleware.md#_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nuse axum::{\n    response::Response,\n    body::Body,\n    extract::Request,\n};\nuse futures_util::future::BoxFuture;\nuse tower::{Service, Layer};\nuse std::task::{Context, Poll};\n\n#[derive(Clone)]\nstruct MyLayer;\n\nimpl<S> Layer<S> for MyLayer {\n    type Service = MyMiddleware<S>;\n\n    fn layer(&self, inner: S) -> Self::Service {\n        MyMiddleware { inner }\n    }\n}\n\n#[derive(Clone)]\nstruct MyMiddleware<S> {\n    inner: S,\n}\n\nimpl<S> Service<Request> for MyMiddleware<S>\nwhere\n    S: Service<Request, Response = Response> + Send + 'static,\n    S::Future: Send + 'static,\n{\n    type Response = S::Response;\n    type Error = S::Error;\n    // `BoxFuture` is a type alias for `Pin<Box<dyn Future + Send + 'a>>`\n    type Future = BoxFuture<'static, Result<Self::Response, Self::Error>>;\n\n    fn poll_ready(&mut self, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {\n        self.inner.poll_ready(cx)\n    }\n\n    fn call(&mut self, request: Request) -> Self::Future {\n        let future = self.inner.call(request);\n        Box::pin(async move {\n            let response: Response = future.await?;\n            Ok(response)\n        })\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Merging Axum Routers with State - Rust\nDESCRIPTION: This example illustrates merging Axum `Router`s when dealing with different state types. It shows how to apply `with_state` to an inner router *before* merging it into an outer router, ensuring state type compatibility for the merge operation.\nSOURCE: https://github.com/tokio-rs/axum/blob/main/axum/src/docs/routing/merge.md#_snippet_1\n\nLANGUAGE: Rust\nCODE:\n```\nuse axum::{\n    Router,\n    routing::get,\n    extract::State,\n};\n\n#[derive(Clone)]\nstruct InnerState {}\n\n#[derive(Clone)]\nstruct OuterState {}\n\nasync fn inner_handler(state: State<InnerState>) {}\n\nlet inner_router = Router::new()\n    .route(\"/bar\", get(inner_handler))\n    .with_state(InnerState {});\n\nasync fn outer_handler(state: State<OuterState>) {}\n\nlet app = Router::new()\n    .route(\"/\", get(outer_handler))\n    .merge(inner_router)\n    .with_state(OuterState {});\n# let _: axum::Router = app;\n\n```\n\n----------------------------------------\n\nTITLE: Using Multiple State Extractors with FromRef Trait in Axum Using Rust\nDESCRIPTION: Demonstrates how to use multiple extensions as fields in an application state struct and access them individually in handlers by implementing the `FromRef` trait. This enables type-safe extraction of individual components like HttpClient and Database from a shared AppState. Requires axum crate with extract, routing, and derive features.\nSOURCE: https://github.com/tokio-rs/axum/blob/main/axum/CHANGELOG.md#_snippet_14\n\nLANGUAGE: rust\nCODE:\n```\nuse axum::{extract::{State, FromRef}, routing::get, Router};\n\nlet state = AppState {\n    client: HttpClient {},\n    database: Database {},\n};\n\nlet app = Router::with_state(state).route(\"/\", get(handler));\n\nasync fn handler(\n    State(client): State<HttpClient>,\n    State(database): State<Database>,\n) {}\n\n#[derive(Clone)]\nstruct AppState {\n    client: HttpClient,\n    database: Database,\n}\n\n#[derive(Clone)]\nstruct HttpClient {}\n\nimpl FromRef<AppState> for HttpClient {\n    fn from_ref(state: &AppState) -> Self {\n        state.client.clone()\n    }\n}\n\n#[derive(Clone)]\nstruct Database {}\n\nimpl FromRef<AppState> for Database {\n    fn from_ref(state: &AppState) -> Self {\n        state.database.clone()\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Building Complex Responses with Tuples in Axum\nDESCRIPTION: Examples showing how to build complex responses by combining multiple components using tuples. Demonstrates combining status codes, headers, and bodies to create comprehensive HTTP responses.\nSOURCE: https://github.com/tokio-rs/axum/blob/main/axum/src/docs/response.md#_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse axum:{\n    Json,\n    response::IntoResponse,\n    http::{StatusCode, HeaderMap, Uri, header},\n    extract::Extension,\n};\n\n// `(StatusCode, impl IntoResponse)` will override the status code of the response\nasync fn with_status(uri: Uri) -> (StatusCode, String) {\n    (StatusCode::NOT_FOUND, format!(\"Not Found: {}\", uri.path()))\n}\n\n// Use `impl IntoResponse` to avoid having to type the whole type\nasync fn impl_trait(uri: Uri) -> impl IntoResponse {\n    (StatusCode::NOT_FOUND, format!(\"Not Found: {}\", uri.path()))\n}\n\n// `(HeaderMap, impl IntoResponse)` to add additional headers\nasync fn with_headers() -> impl IntoResponse {\n    let mut headers = HeaderMap::new();\n    headers.insert(header::CONTENT_TYPE, \"text/plain\".parse().unwrap());\n    (headers, \"foo\")\n}\n\n// Or an array of tuples to more easily build the headers\nasync fn with_array_headers() -> impl IntoResponse {\n    ([(header::CONTENT_TYPE, \"text/plain\")], \"foo\")\n}\n\n// Use string keys for custom headers\nasync fn with_array_headers_custom() -> impl IntoResponse {\n    ([(\"x-custom\", \"custom\")], \"foo\")\n}\n\n// `(StatusCode, headers, impl IntoResponse)` to set status and add headers\n// `headers` can be either a `HeaderMap` or an array of tuples\nasync fn with_status_and_array_headers() -> impl IntoResponse {\n    (\n        StatusCode::NOT_FOUND,\n        [(header::CONTENT_TYPE, \"text/plain\")],\n        \"foo\",\n    )\n}\n\n// `(Extension<_>, impl IntoResponse)` to set response extensions\nasync fn with_status_extensions() -> impl IntoResponse {\n    (\n        Extension(Foo(\"foo\")),\n        \"foo\",\n    )\n}\n\n#[derive(Clone)]\nstruct Foo(&'static str);\n\n// Or mix and match all the things\nasync fn all_the_things(uri: Uri) -> impl IntoResponse {\n    let mut header_map = HeaderMap::new();\n    if uri.path() == \"/\" {\n        header_map.insert(header::SERVER, \"axum\".parse().unwrap());\n    }\n\n    (\n        // set status code\n        StatusCode::NOT_FOUND,\n        // headers with an array\n        [(\"x-custom\", \"custom\")],\n        // some extensions\n        Extension(Foo(\"foo\")),\n        Extension(Foo(\"bar\")),\n        // more headers, built dynamically\n        header_map,\n        // and finally the body\n        \"foo\",\n    )\n}\n```\n\n----------------------------------------\n\nTITLE: Extracting Nested State Fields using State and FromRef (Axum 0.6) - Rust\nDESCRIPTION: This Rust example demonstrates extracting multiple fields (`HttpClient`, `Database`) from a single application state struct (`AppState`) when using Axum's `State` extractor. It requires implementing `FromRef` for the `AppState` struct (often via a derive macro with the \"macros\" feature) to allow extracting individual components directly in the handler.\nSOURCE: https://github.com/tokio-rs/axum/blob/main/axum/CHANGELOG.md#_snippet_2\n\nLANGUAGE: Rust\nCODE:\n```\nuse axum::{extract::{State, FromRef}, routing::get, Router};\n\nlet state = AppState {\n    client: HttpClient {},\n    database: Database {},\n};\n\nlet app = Router::new().route(\"/\", get(handler)).with_state(state);\n\nasync fn handler(\n    State(client): State<HttpClient>,\n    State(database): State<Database>,\n) {}\n\n// the derive requires enabling the \"macros\" feature\n#[derive(Clone, FromRef)]\nstruct AppState {\n    client: HttpClient,\n    database: Database,\n}\n\n#[derive(Clone)]\nstruct HttpClient {}\n\n#[derive(Clone)]\nstruct Database {}\n```\n\n----------------------------------------\n\nTITLE: Handling Errors from Middleware in axum Using HandleErrorLayer (Rust)\nDESCRIPTION: This example creates a middleware stack using tower::ServiceBuilder and axum::error_handling::HandleErrorLayer to process errors from fallible middleware, such as timeouts. The stack applies error handling before a timeout layer set to 30 seconds. The resulting stack is layered onto a Router serving the root path. Dependencies: axum (with routing, error_handling, and response modules), tower, and std::time. The error handler, `handle_error`, converts BoxError into a 408 Request Timeout response. Inputs: incoming HTTP requests. Outputs: standard HTTP responses, returning timeout status on errors. Requires correct ordering of middleware; error handlers must process all failure cases.\nSOURCE: https://github.com/tokio-rs/axum/blob/main/axum/CHANGELOG.md#_snippet_18\n\nLANGUAGE: rust\nCODE:\n```\nuse axum::{\n    routing::get,\n    http::StatusCode,\n    error_handling::HandleErrorLayer,\n    response::IntoResponse,\n    Router, BoxError,\n};\nuse tower::ServiceBuilder;\nuse std::time::Duration;\n\nlet middleware_stack = ServiceBuilder::new()\n    // Handle errors from middleware\n    //\n    // This middleware most be added above any fallible\n    // ones if you're using `ServiceBuilder`, due to how ordering works\n    .layer(HandleErrorLayer::new(handle_error))\n    // Return an error after 30 seconds\n    .timeout(Duration::from_secs(30));\n\nlet app = Router::new()\n    .route(\"/\", get(|| async { /* ... */ }))\n    .layer(middleware_stack);\n\nfn handle_error(_error: BoxError) -> impl IntoResponse {\n    StatusCode::REQUEST_TIMEOUT\n}\n```\n\n----------------------------------------\n\nTITLE: Error Handling with HandleErrorLayer in Axum Middleware (Rust)\nDESCRIPTION: Demonstrates how to use `HandleErrorLayer` to handle errors thrown by middleware such as `TimeoutLayer` and return a `StatusCode` in the response. This example sets up a simple route with a timeout layer and error handling to gracefully return a `REQUEST_TIMEOUT` status code if the handler takes too long. It requires the `axum`, `tower`, and `std::time::Duration` dependencies.\nSOURCE: https://github.com/tokio-rs/axum/blob/main/axum/src/docs/middleware.md#_snippet_5\n\nLANGUAGE: Rust\nCODE:\n```\nuse axum::{\n    routing::get,\n    error_handling::HandleErrorLayer,\n    http::StatusCode,\n    BoxError,\n    Router,\n};\nuse tower::{ServiceBuilder, timeout::TimeoutLayer};\nuse std::time::Duration;\n\nasync fn handler() {}\n\nlet app = Router::new()\n    .route(\"/\", get(handler))\n    .layer(\n        ServiceBuilder::new()\n            // this middleware goes above `TimeoutLayer` because it will receive\n            // errors returned by `TimeoutLayer`\n            .layer(HandleErrorLayer::new(|_: BoxError| async {\n                StatusCode::REQUEST_TIMEOUT\n            }))\n            .layer(TimeoutLayer::new(Duration::from_secs(10)))\n    );\n# let _: Router = app;\n```\n\n----------------------------------------\n\nTITLE: Error Handling with HandleErrorLayer in Rust\nDESCRIPTION: This example demonstrates how to handle custom error types in axum middleware using `HandleErrorLayer`. If your middleware returns a custom error type (e.g., `BoxError`) that is not `Infallible`, you must use `HandleErrorLayer` to convert it to a response. This example shows how to integrate it with the ServiceBuilder.\nSOURCE: https://github.com/tokio-rs/axum/blob/main/axum/src/docs/middleware.md#_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nServiceBuilder::new()\n        .layer(HandleErrorLayer::new(|_: BoxError| async {\n            // because axum uses infallible errors, you must handle your custom error type from your middleware here\n            StatusCode::BAD_REQUEST\n        }))\n        .layer(\n             // <your actual layer which DOES return an error>\n        );\n```\n\n----------------------------------------\n\nTITLE: Routing to a fallible service with error handling\nDESCRIPTION: Demonstrates how to route to a service that might fail by using HandleError to convert errors into responses. This example uses anyhow::Error as the error type.\nSOURCE: https://github.com/tokio-rs/axum/blob/main/axum/src/docs/error_handling.md#_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse axum:{\n    Router,\n    body::Body,\n    http::{Request, Response, StatusCode},\n    error_handling::HandleError,\n};\n\nasync fn thing_that_might_fail() -> Result<(), anyhow::Error> {\n    # Ok(())\n    // ...\n}\n\n// this service might fail with `anyhow::Error`\nlet some_fallible_service = tower::service_fn(|_req| async {\n    thing_that_might_fail().await?;\n    Ok::<_, anyhow::Error>(Response::new(Body::empty()))\n});\n\nlet app = Router::new().route_service(\n    \"/\",\n    // we cannot route to `some_fallible_service` directly since it might fail.\n    // we have to use `handle_error` which converts its errors into responses\n    // and changes its error type from `anyhow::Error` to `Infallible`.\n    HandleError::new(some_fallible_service, handle_anyhow_error),\n);\n\n// handle errors by converting them into something that implements\n// `IntoResponse`\nasync fn handle_anyhow_error(err: anyhow::Error) -> (StatusCode, String) {\n    (\n        StatusCode::INTERNAL_SERVER_ERROR,\n        format!(\"Something went wrong: {err}\"),\n    )\n}\n# let _: Router = app;\n```\n\n----------------------------------------\n\nTITLE: Nesting Routers with Generic State Type (Rust)\nDESCRIPTION: This example illustrates nesting routers with a generic state type, allowing a parent router to include child routers with specific state types. It demonstrates defining a function that creates a nested router with a particular state, and then nesting it under a specific path, passing the necessary state. This approach supports flexible and composable route hierarchies in larger applications.\nSOURCE: https://github.com/tokio-rs/axum/blob/main/axum/src/docs/routing/with_state.md#_snippet_3\n\nLANGUAGE: Rust\nCODE:\n```\nuse axum::{Router, routing::get, extract::State};\n\n#[derive(Clone)]\nstruct AppState {}\n\n// Define a route builder with a generic state type\nfn routes<S>(state: AppState) -> Router<S> {\n    Router::new()\n        .route(\"/\", get(|_: State<AppState>| async {}))\n        .with_state(state)\n}\n\n// Nest the routes with specific AppState under a path\nlet routes = Router::new().nest(\"/api\", routes(AppState {}));\n\n# async {\nlet listener = tokio::net::TcpListener::bind(\"0.0.0.0:3000\").await.unwrap();\naxum::serve(listener, routes).await.unwrap();\n# };\n\n```\n\n----------------------------------------\n\nTITLE: Returning Different Response Types in Axum\nDESCRIPTION: Example demonstrating how to handle multiple possible response types in a single handler function. Shows how to use into_response() to convert different types into a unified Response type.\nSOURCE: https://github.com/tokio-rs/axum/blob/main/axum/src/docs/response.md#_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nuse axum:{\n    response::{IntoResponse, Redirect, Response},\n    http::StatusCode,\n};\n\nasync fn handle() -> Response {\n    if something() {\n        \"All good!\".into_response()\n    } else if something_else() {\n        (\n            StatusCode::INTERNAL_SERVER_ERROR,\n            \"Something went wrong...\",\n        ).into_response()\n    } else {\n        Redirect::to(\"/\").into_response()\n    }\n}\n\nfn something() -> bool {\n    // ...\n    # true\n}\n\nfn something_else() -> bool {\n    // ...\n    # true\n}\n```\n\n----------------------------------------\n\nTITLE: Returning `Router<()>` After Providing Complete State (Rust)\nDESCRIPTION: This snippet demonstrates the correct pattern where, after providing all necessary state to a router, it is returned as `Router<()>`, which supports `into_make_service()` needed for serving. It shows how to create such a router with all required state bound, making it ready for the server setup, including binding to a TCP socket.\nSOURCE: https://github.com/tokio-rs/axum/blob/main/axum/src/docs/routing/with_state.md#_snippet_7\n\nLANGUAGE: Rust\nCODE:\n```\nuse axum::{Router, routing::get, extract::State};\n\n#[derive(Clone)]\nstruct AppState {}\n\n// Properly return `Router<()>` after providing complete state\nfn routes(state: AppState) -> Router<()> {\n    Router::new()\n        .route(\"/\", get(|_: State<AppState>| async {}))\n        .with_state(state)\n}\n\nlet app = routes(AppState {});\n\n# async {\nlet listener = tokio::net::TcpListener::bind(\"0.0.0.0:3000\").await.unwrap();\naxum::serve(listener, app).await.unwrap();\n# };\n\n```\n\n----------------------------------------\n\nTITLE: Performance Optimization with `with_state()` in Axum Router (Rust)\nDESCRIPTION: This snippet underlines that invoking `with_state(())` or with no state is recommended before starting to serve requests. Doing so enables Axum to optimize internal router internals for performance and resource utilization. It also references that `into_make_service()` will automatically perform similar optimization when converting the router into a service.\nSOURCE: https://github.com/tokio-rs/axum/blob/main/axum/src/docs/routing/with_state.md#_snippet_8\n\nLANGUAGE: Rust\nCODE:\n```\nuse axum::{Router, routing::get};\n\nlet app = Router::new()\n    .route(\"/\", get(|| async { /* ... */ }))\n    // even if no state needed, call `with_state(())` to optimize\n    .with_state(());\n# let _: Router = app;\n```\n\n----------------------------------------\n\nTITLE: Merging axum Routes in Rust\nDESCRIPTION: This code snippet demonstrates how to merge two `axum` routes, a GET and a POST route, into a single route using the `merge` function. The merged route is then added to an `axum` Router. The Router now accepts both GET and POST requests to the root path '/'.\nSOURCE: https://github.com/tokio-rs/axum/blob/main/axum/src/docs/method_routing/merge.md#_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\nuse axum::{\n    routing::{get, post},\n    Router,\n};\n\nlet get = get(|| async {});\nlet post = post(|| async {});\n\nlet merged = get.merge(post);\n\nlet app = Router::new().route(\"/\", merged);\n\n// Our app now accepts\n// - GET /\n// - POST /\n# let _: Router = app;\n```\n\n----------------------------------------\n\nTITLE: Merging Basic Axum Routers - Rust\nDESCRIPTION: This snippet shows how to combine two simple Axum `Router`s by using the `.merge()` method. It defines separate route sets for users and teams and merges them into a single application router, demonstrating route consolidation.\nSOURCE: https://github.com/tokio-rs/axum/blob/main/axum/src/docs/routing/merge.md#_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\nuse axum::{\n    routing::get,\n    Router,\n};\n#\n# async fn users_list() {}\n# async fn users_show() {}\n# async fn teams_list() {}\n\n// define some routes separately\nlet user_routes = Router::new()\n    .route(\"/users\", get(users_list))\n    .route(\"/users/{id}\", get(users_show));\n\nlet team_routes = Router::new()\n    .route(\"/teams\", get(teams_list));\n\n// combine them into one\nlet app = Router::new()\n    .merge(user_routes)\n    .merge(team_routes);\n\n// could also do `user_routes.merge(team_routes)`\n\n// Our app now accepts\n// - GET /users\n// - GET /users/{id}\n// - GET /teams\n# let _: Router = app;\n\n```\n\n----------------------------------------\n\nTITLE: Handling Multiple Extractors Consuming Body (Axum 0.6) - Rust\nDESCRIPTION: This Rust code demonstrates Axum 0.6's behavior regarding extractors that consume the request body (like `Json` and `String`). It shows that multiple body-consuming extractors are not allowed in the same handler, and if one is used, it *must* be the last extractor listed. Handlers `handler_1` and `handler_2` will cause compile errors, while `handler_3` is valid.\nSOURCE: https://github.com/tokio-rs/axum/blob/main/axum/CHANGELOG.md#_snippet_3\n\nLANGUAGE: Rust\nCODE:\n```\nuse axum::{Json, http::HeaderMap};\n\n// This won't compile on 0.6 because both `Json` and `String` need to consume\n// the request body. You can use either `Json` or `String`, but not both.\nasync fn handler_1(\n    json: Json<serde_json::Value>,\n    string: String,\n) {}\n\n// This won't work either since `Json` is not the last extractor.\nasync fn handler_2(\n    json: Json<serde_json::Value>,\n    headers: HeaderMap,\n) {}\n\n// This works!\nasync fn handler_3(\n    headers: HeaderMap,\n    json: Json<serde_json::Value>,\n) {}\n```\n\n----------------------------------------\n\nTITLE: Unsupported Return of `Router<AppState>` for `into_make_service()` in Rust\nDESCRIPTION: This snippet shows an example of incorrect usage where returning `Router<AppState>` after calling `with_state()` prevents using `into_make_service()`, because only `Router<()>` types are supported. It emphasizes the importance of returning `Router<()>` once all state has been provided, so the router can be converted into a service for server binding.\nSOURCE: https://github.com/tokio-rs/axum/blob/main/axum/src/docs/routing/with_state.md#_snippet_6\n\nLANGUAGE: Rust\nCODE:\n```\nuse axum::{Router, routing::get, extract::State};\n\n#[derive(Clone)]\nstruct AppState {}\n\n// Function returning a router that still needs `AppState`\n// and thus cannot call `into_make_service()` directly\n// because it returns `Router<AppState>`\nfn routes(state: AppState) -> Router<AppState> {\n    Router::new()\n        .route(\"/\", get(|_: State<AppState>| async {}))\n        .with_state(state)\n}\n\nlet app = routes(AppState {});\n\n// This won't work because `app` is `Router<AppState>`\n// and not supported by `into_make_service()`\n# async {\nlet listener = tokio::net::TcpListener::bind(\"0.0.0.0:3000\").await.unwrap();\naxum::serve(listener, app).await.unwrap();\n# };\n\n```\n\n----------------------------------------\n\nTITLE: Defining a Simple axum Router in Rust\nDESCRIPTION: This snippet defines a function returning a named axum Router configured with a single route for HTTP POST requests to \"/users\". The endpoint handler responds asynchronously with a greeting message. Requires the axum crate; ensure the `Router` type, `route` method, and `post` routing are in scope. Inputs: none. Output: an instance of Router with one POST route. This pattern relies on axum v0.3.0 or later, where routers are always nameable and typable.\nSOURCE: https://github.com/tokio-rs/axum/blob/main/axum/CHANGELOG.md#_snippet_17\n\nLANGUAGE: rust\nCODE:\n```\nfn my_routes() -> Router {\n    Router::new().route(\n        \"/users\",\n        post(|| async { \"Hello, World!\" }),\n    )\n}\n```\n\n----------------------------------------\n\nTITLE: Incorrect Order of Axum Extractors (Body Not Last) - Rust\nDESCRIPTION: Demonstrates an incorrect ordering of extractors in an Axum handler. Placing a body-consuming extractor (`String`) before a non-body extractor (`Method`) violates Axum's rules because the body can only be consumed once, resulting in a compile-time error.\nSOURCE: https://github.com/tokio-rs/axum/blob/main/axum/src/docs/extract.md#_snippet_4\n\nLANGUAGE: Rust\nCODE:\n```\nuse axum::http::Method;\n\nasync fn handler(\n    // this doesn't work since `String` must be the last argument\n    body: String,\n    method: Method,\n) {\n    // ...\n}\n#\n# let _: axum::routing::MethodRouter = axum::routing::get(handler);\n```\n\n----------------------------------------\n\nTITLE: Migrating from Extension to State Extractor in Axum Using Rust\nDESCRIPTION: Shows the recommended migration from using `Extension` extractor in Axum 0.5 to the new `State` extractor in 0.6 for more type-safe and compile-time state management. Also demonstrates using `Router::with_state` and how to structure the application state accordingly. Requires axum crate with routing, extract, and derive macros.\nSOURCE: https://github.com/tokio-rs/axum/blob/main/axum/CHANGELOG.md#_snippet_13\n\nLANGUAGE: rust\nCODE:\n```\nuse axum::{routing::get, Extension, Router};\n\nlet app = Router::new()\n    .route(\"/\", get(handler))\n    .layer(Extension(AppState {}));\n\nasync fn handler(Extension(app_state): Extension<AppState>) {}\n\n#[derive(Clone)]\nstruct AppState {}\n```\n\nLANGUAGE: rust\nCODE:\n```\nuse axum::{routing::get, extract::State, Router};\n\nlet app = Router::with_state(AppState {})\n    .route(\"/\", get(handler));\n\nasync fn handler(State(app_state): State<AppState>) {}\n\n#[derive(Clone)]\nstruct AppState {}\n```\n\n----------------------------------------\n\nTITLE: Middleware Ordering with ServiceBuilder in Rust\nDESCRIPTION: This snippet shows how `tower::ServiceBuilder` affects middleware ordering. When used with `Router::layer`, `ServiceBuilder` composes all layers into a single layer, causing them to execute from top to bottom. The request flows through the layers in the order they are defined in the `ServiceBuilder`, and the response flows back in reverse order.\nSOURCE: https://github.com/tokio-rs/axum/blob/main/axum/src/docs/middleware.md#_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse tower::ServiceBuilder;\nuse axum::{routing::get, Router};\n\nasync fn handler() {}\n\n# let layer_one = axum::Extension(());\n# let layer_two = axum::Extension(());\n# let layer_three = axum::Extension(());\n#\nlet app = Router::new()\n    .route(\"/\", get(handler))\n    .layer(\n        ServiceBuilder::new()\n            .layer(layer_one)\n            .layer(layer_two)\n            .layer(layer_three),\n    );\n# let _: Router = app;\n```\n\n----------------------------------------\n\nTITLE: Applying ConcurrencyLimitLayer Middleware to Axum GET Route in Rust\nDESCRIPTION: This Rust code snippet demonstrates how to apply the ConcurrencyLimitLayer from the Tower library to a GET route in an Axum router, limiting the maximum concurrent requests to 64. It depends on the Axum crate for routing and Tower for middleware layers. The 'handler' async function processes incoming requests to the '/' route. The snippet shows the use of the 'layer' method on a specific route, applying middleware only to that route. The input is HTTP GET requests at the root path, and the output is processed requests subjected to concurrency limiting.\nSOURCE: https://github.com/tokio-rs/axum/blob/main/axum/src/docs/method_routing/layer.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse axum::{routing::get, Router};\nuse tower::limit::ConcurrencyLimitLayer;\n\nasync fn handler() {}\n\nlet app = Router::new().route(\n    \"/\",\n    // All requests to `GET /` will be sent through `ConcurrencyLimitLayer`\n    get(handler).layer(ConcurrencyLimitLayer::new(64)),\n);\n# let _: Router = app;\n```\n\n----------------------------------------\n\nTITLE: Implementing Custom Fallback in Nested Route in Rust\nDESCRIPTION: This code demonstrates a scenario where a nested router has its own fallback, overriding the outer router's fallback. The example defines `api_fallback` to handle requests that aren't found within `/api` path. The outer `fallback` is not inherited.\nSOURCE: https://github.com/tokio-rs/axum/blob/main/axum/src/docs/routing/nest.md#_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nuse axum::{\n    routing::get,\n    http::StatusCode,\n    handler::Handler,\n    Json,\n    Router,\n};\n\nasync fn fallback() -> (StatusCode, &'static str) {\n    (StatusCode::NOT_FOUND, \"Not Found\")\n}\n\nasync fn api_fallback() -> (StatusCode, Json<serde_json::Value>) {\n    (\n        StatusCode::NOT_FOUND,\n        Json(serde_json::json!({ \"status\": \"Not Found\" })),\n    )\n}\n\nlet api_routes = Router::new()\n    .route(\"/users\", get(|| async {}))\n    .fallback(api_fallback);\n\nlet app = Router::new()\n    .nest(\"/api\", api_routes)\n    .fallback(fallback);\n```\n\n----------------------------------------\n\nTITLE: Using extractors with HandleErrorLayer\nDESCRIPTION: Demonstrates how to run extractors in error handlers with HandleErrorLayer, allowing access to request information for generating more detailed error responses.\nSOURCE: https://github.com/tokio-rs/axum/blob/main/axum/src/docs/error_handling.md#_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nuse axum:{\n    Router,\n    BoxError,\n    routing::get,\n    http::{StatusCode, Method, Uri},\n    error_handling::HandleErrorLayer,\n};\nuse std::time::Duration;\nuse tower::ServiceBuilder;\n\nlet app = Router::new()\n    .route(\"/\", get(|| async {}))\n    .layer(\n        ServiceBuilder::new()\n            // `timeout` will produce an error if the handler takes\n            // too long so we must handle those\n            .layer(HandleErrorLayer::new(handle_timeout_error))\n            .timeout(Duration::from_secs(30))\n    );\n\nasync fn handle_timeout_error(\n    // `Method` and `Uri` are extractors so they can be used here\n    method: Method,\n    uri: Uri,\n    // the last argument must be the error itself\n    err: BoxError,\n) -> (StatusCode, String) {\n    (\n        StatusCode::INTERNAL_SERVER_ERROR,\n        format!(\"`{method} {uri}` failed with {err}\"),\n    )\n}\n# let _: Router = app;\n```\n\n----------------------------------------\n\nTITLE: Implementing Fallback for Nested Routes in Rust\nDESCRIPTION: This code shows how fallbacks work with nested routers. If a nested router doesn't have its own fallback, it inherits the outer router's fallback. The example demonstrates this behavior with a basic fallback function. If nested router does have its own fallback, the outer fallback will not be inherited.\nSOURCE: https://github.com/tokio-rs/axum/blob/main/axum/src/docs/routing/nest.md#_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nuse axum::{routing::get, http::StatusCode, handler::Handler, Router};\n\nasync fn fallback() -> (StatusCode, &'static str) {\n    (StatusCode::NOT_FOUND, \"Not Found\")\n}\n\nlet api_routes = Router::new().route(\"/users\", get(|| async {}));\n\nlet app = Router::new()\n    .nest(\"/api\", api_routes)\n    .fallback(fallback);\n```\n\n----------------------------------------\n\nTITLE: Handling State when Nesting Routers in Rust\nDESCRIPTION: This snippet explains how to manage state when combining `Router`s using `nest`. It highlights the requirement for routers to have the same state type. If the routers have different types, `Router::with_state` is recommended to provide a consistent state type. The inner router will still inherit fallback from outer router.\nSOURCE: https://github.com/tokio-rs/axum/blob/main/axum/src/docs/routing/nest.md#_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\nuse axum::{\n    Router,\n    routing::get,\n    extract::State,\n};\n\n#[derive(Clone)]\nstruct InnerState {}\n\n#[derive(Clone)]\nstruct OuterState {}\n\nasync fn inner_handler(state: State<InnerState>) {}\n\nlet inner_router = Router::new()\n    .route(\"/bar\", get(inner_handler))\n    .with_state(InnerState {});\n\nasync fn outer_handler(state: State<OuterState>) {}\n\nlet app = Router::new()\n    .route(\"/\", get(outer_handler))\n    .nest(\"/foo\", inner_router)\n    .with_state(OuterState {});\n```\n\n----------------------------------------\n\nTITLE: Using Optional Header Extractor in Axum - Rust\nDESCRIPTION: Demonstrates how to use extractors that implement `OptionalFromRequestParts` (like `TypedHeader` from `axum_extra`) by wrapping them in `Option`. This allows checking for the presence of a header without causing a rejection if the header is simply missing.\nSOURCE: https://github.com/tokio-rs/axum/blob/main/axum/src/docs/extract.md#_snippet_7\n\nLANGUAGE: Rust\nCODE:\n```\nuse axum::{routing::post, Router};\nuse axum_extra::{headers::UserAgent, TypedHeader};\nuse serde_json::Value;\n\nasync fn foo(user_agent: Option<TypedHeader<UserAgent>>) {\n    if let Some(TypedHeader(user_agent)) = user_agent {\n        // The client sent a user agent\n    } else {\n        // No user agent header\n    }\n}\n\nlet app = Router::new().route(\"/foo\", post(foo));\n# let _: Router = app;\n```\n\n----------------------------------------\n\nTITLE: Implementing Custom Connection Info with Connected Trait in Axum\nDESCRIPTION: Shows how to implement a custom connection information extractor by implementing the Connected trait. This example defines a custom MyConnectInfo struct and demonstrates how to extract it in a handler function when serving the application.\nSOURCE: https://github.com/tokio-rs/axum/blob/main/axum/src/docs/routing/into_make_service_with_connect_info.md#_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse axum:{\n    extract::connect_info::{ConnectInfo, Connected},\n    routing::get,\n    serve::IncomingStream,\n    Router,\n};\nuse tokio::net::TcpListener;\n\nlet app = Router::new().route(\"/\", get(handler));\n\nasync fn handler(\n    ConnectInfo(my_connect_info): ConnectInfo<MyConnectInfo>,\n) -> String {\n    format!(\"Hello {my_connect_info:?}\")\n}\n\n#[derive(Clone, Debug)]\nstruct MyConnectInfo {\n    // ...\n}\n\nimpl Connected<IncomingStream<'_, TcpListener>> for MyConnectInfo {\n    fn connect_info(target: IncomingStream<'_, TcpListener>) -> Self {\n        MyConnectInfo {\n            // ...\n        }\n    }\n}\n\n# async {\nlet listener = tokio::net::TcpListener::bind(\"0.0.0.0:3000\").await.unwrap();\naxum::serve(listener, app.into_make_service_with_connect_info::<MyConnectInfo>()).await.unwrap();\n# };\n```\n\n----------------------------------------\n\nTITLE: Wrapping Extractor Implementation in Axum (Rust)\nDESCRIPTION: This code defines a `Timing` struct that wraps another extractor and measures the time it takes to execute. It implements both `FromRequestParts` and `FromRequest` traits, allowing the `Timing` extractor to be used with extractors that consume the request body and those that don't. It requires the `axum` crate and the standard library's `std::time` module.\nSOURCE: https://github.com/tokio-rs/axum/blob/main/axum/src/docs/extract.md#_snippet_8\n\nLANGUAGE: rust\nCODE:\n```\nuse axum::{\n    Router,\n    body::Body,\n    routing::get,\n    extract::{Request, FromRequest, FromRequestParts},\n    http::{HeaderMap, request::Parts},\n};\nuse std::time::{Instant, Duration};\n\n// an extractor that wraps another and measures how long time it takes to run\nstruct Timing<E> {\n    extractor: E,\n    duration: Duration,\n}\n\n// we must implement both `FromRequestParts`\nimpl<S, T> FromRequestParts<S> for Timing<T>\nwhere\n    S: Send + Sync,\n    T: FromRequestParts<S>,\n{\n    type Rejection = T::Rejection;\n\n    async fn from_request_parts(parts: &mut Parts, state: &S) -> Result<Self, Self::Rejection> {\n        let start = Instant::now();\n        let extractor = T::from_request_parts(parts, state).await?;\n        let duration = start.elapsed();\n        Ok(Timing {\n            extractor,\n            duration,\n        })\n    }\n}\n\n// and `FromRequest`\nimpl<S, T> FromRequest<S> for Timing<T>\nwhere\n    S: Send + Sync,\n    T: FromRequest<S>,\n{\n    type Rejection = T::Rejection;\n\n    async fn from_request(req: Request, state: &S) -> Result<Self, Self::Rejection> {\n        let start = Instant::now();\n        let extractor = T::from_request(req, state).await?;\n        let duration = start.elapsed();\n        Ok(Timing {\n            extractor,\n            duration,\n        })\n    }\n}\n\nasync fn handler(\n    // this uses the `FromRequestParts` impl\n    _: Timing<HeaderMap>,\n    // this uses the `FromRequest` impl\n    _: Timing<String>,\n) {}\n# let _: axum::routing::MethodRouter = axum::routing::get(handler);\n```\n\n----------------------------------------\n\nTITLE: Handling Errors from Fallible Leaf Services in axum Using handle_error (Rust)\nDESCRIPTION: This example demonstrates attaching per-route error handlers to fallible leaf services in axum using the .handle_error method. The Router is configured to serve \"/\" by wrapping an async handler with axum::routing::service_method_routing::get and tower::service_fn, which attempts to read a file asynchronously from disk. If reading fails with an io::Error, the configured error handler `handle_io_error` constructs an appropriate HTTP response. Dependencies: axum and tower crates, std::io, and async runtime (e.g., tokio). Inputs: HTTP requests to \"/\". Outputs: file contents in body if successful, custom error response otherwise. Leaf service error handlers must return types convertible into axum responses.\nSOURCE: https://github.com/tokio-rs/axum/blob/main/axum/CHANGELOG.md#_snippet_19\n\nLANGUAGE: rust\nCODE:\n```\nuse axum::{\n    Router, service,\n    body::Body,\n    routing::service_method_routing::get,\n    response::IntoResponse,\n    http::{Request, Response},\n    error_handling::HandleErrorExt, // for `.handle_error`\n};\nuse std::{io, convert::Infallible};\nuse tower::service_fn;\n\nlet app = Router::new()\n    .route(\n        \"/\",\n        get(service_fn(|_req: Request<Body>| async {\n            let contents = tokio::fs::read_to_string(\"some_file\").await?;\n            Ok::<_, io::Error>(Response::new(Body::from(contents)))\n        }))\n        .handle_error(handle_io_error),\n    );\n\nfn handle_io_error(error: io::Error) -> impl IntoResponse {\n    // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Adding ErrorResponse and Result for Error Handling in Axum Rust\nDESCRIPTION: Introduces the `response::ErrorResponse` type and a custom `response::Result` alias. These facilitate `IntoResponse`-based error handling, allowing errors to be easily converted into appropriate HTTP responses.\nSOURCE: https://github.com/tokio-rs/axum/blob/main/axum-core/CHANGELOG.md#_snippet_29\n\nLANGUAGE: Rust\nCODE:\n```\nstruct response::ErrorResponse\n```\n\nLANGUAGE: Rust\nCODE:\n```\ntype response::Result<T, E> = std::result::Result<T, E> where E: IntoResponse;\n```\n\n----------------------------------------\n\nTITLE: Incorrect Usage of Multiple Body Extractors - Rust\nDESCRIPTION: Shows an incorrect attempt to use two different body-consuming extractors (`String` and `Json`) within the same Axum handler function. This is not allowed as the request body can only be consumed once, leading to a compile-time error.\nSOURCE: https://github.com/tokio-rs/axum/blob/main/axum/src/docs/extract.md#_snippet_5\n\nLANGUAGE: Rust\nCODE:\n```\nuse axum::Json;\nuse serde::Deserialize;\n\n#[derive(Deserialize)]\nstruct Payload {}\n\nasync fn handler(\n    // `String` and `Json` both consume the request body\n    // so they cannot both be used\n    string_body: String,\n    json_body: Json<Payload>,\n) {\n    // ...\n}\n#\n# let _: axum::routing::MethodRouter = axum::routing::get(handler);\n```\n\n----------------------------------------\n\nTITLE: Routing Path Matching and Wildcard Behavior in Axum Using Rust\nDESCRIPTION: Illustrates explicit route definition for matching trailing slashes in URLs due to breaking changes where `/foo/` no longer matches `/foo/*rest`. It also shows use of optional path params to handle routes with or without parameters. Requires the axum crate with routing and extract Path.\nSOURCE: https://github.com/tokio-rs/axum/blob/main/axum/CHANGELOG.md#_snippet_8\n\nLANGUAGE: rust\nCODE:\n```\nuse axum::{Router, routing::get, extract::Path};\n\nlet app = Router::new()\n    // this will match `/foo/bar/baz`\n    .route(\"/foo/*rest\", get(handler))\n    // this will match `/foo/`\n    .route(\"/foo/\", get(handler))\n    // if you want `/foo` to match you must also add an explicit route for it\n    .route(\"/foo\", get(handler));\n\nasync fn handler(\n    // use an `Option` because `/foo/` and `/foo` don't have any path params\n    params: Option<Path<String>>,\n) {}\n```\n\n----------------------------------------\n\nTITLE: Accessing State in Custom Tower Layers (Rust)\nDESCRIPTION: Demonstrates how to access application state within custom Tower layers. The example defines a custom layer `MyLayer` and service `MyService` that clone and hold the application state. The `Service::call` method then shows how to access the state. The example requires `axum` and `tower` dependencies and defines the state struct `AppState`.\nSOURCE: https://github.com/tokio-rs/axum/blob/main/axum/src/docs/middleware.md#_snippet_7\n\nLANGUAGE: Rust\nCODE:\n```\nuse axum::{\n    Router,\n    routing::get,\n    middleware::{self, Next},\n    response::Response,\n    extract::{State, Request},\n};\nuse tower::{Layer, Service};\nuse std::task::{Context, Poll};\n\n#[derive(Clone)]\nstruct AppState {}\n\n#[derive(Clone)]\nstruct MyLayer {\n    state: AppState,\n}\n\nimpl<S> Layer<S> for MyLayer {\n    type Service = MyService<S>;\n\n    fn layer(&self, inner: S) -> Self::Service {\n        MyService {\n            inner,\n            state: self.state.clone(),\n        }\n    }\n}\n\n#[derive(Clone)]\nstruct MyService<S> {\n    inner: S,\n    state: AppState,\n}\n\nimpl<S, B> Service<Request<B>> for MyService<S>\nwhere\n    S: Service<Request<B>>,\n{\n    type Response = S::Response;\n    type Error = S::Error;\n    type Future = S::Future;\n\n    fn poll_ready(&mut self, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {\n        self.inner.poll_ready(cx)\n    }\n\n    fn call(&mut self, req: Request<B>) -> Self::Future {\n        // Do something with `self.state`.\n        //\n        // See `axum::RequestExt` for how to run extractors directly from\n        // a `Request`.\n\n        self.inner.call(req)\n    }\n}\n\nasync fn handler(_: State<AppState>) {}\n\nlet state = AppState {};\n\nlet app = Router::new()\n    .route(\"/\", get(handler))\n    .layer(MyLayer { state: state.clone() })\n    .with_state(state);\n# let _: axum::Router = app;\n```\n\n----------------------------------------\n\nTITLE: Defining a Route with Wildcard Capture in Axum (Rust)\nDESCRIPTION: Demonstrates defining an Axum route that captures multiple path segments using a wildcard (`{*key}`). The captured value (excluding the leading slash) is extracted as a `String` within the handler using the `Path` extractor. This requires the `axum` crate.\nSOURCE: https://github.com/tokio-rs/axum/blob/main/axum/src/docs/routing/route.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse axum::{\n    Router,\n    routing::get,\n    extract::Path,\n};\n\nlet app: Router = Router::new().route(\"/{*key}\", get(handler));\n\nasync fn handler(Path(path): Path<String>) -> String {\n    path\n}\n```\n\n----------------------------------------\n\nTITLE: Rewriting Request URI in Middleware (Rust)\nDESCRIPTION: Demonstrates how to rewrite the request URI in middleware that runs before routing. This is achieved by wrapping the middleware around the entire `Router` using `tower::util::MapRequestLayer`. It requires `axum` and `tower` dependencies. The `rewrite_request_uri` function shows where the URI rewriting logic would be placed.\nSOURCE: https://github.com/tokio-rs/axum/blob/main/axum/src/docs/middleware.md#_snippet_9\n\nLANGUAGE: Rust\nCODE:\n```\nuse tower::Layer;\nuse axum::{\n    Router,\n    ServiceExt, // for `into_make_service`\n    response::Response,\n    middleware::Next,\n    extract::Request,\n};\n\nfn rewrite_request_uri<B>(req: Request<B>) -> Request<B> {\n    // ...\n    # req\n}\n\n// this can be any `tower::Layer`\nlet middleware = tower::util::MapRequestLayer::new(rewrite_request_uri);\n\nlet app = Router::new();\n\n// apply the layer around the whole `Router`\n// this way the middleware will run before `Router` receives the request\nlet app_with_middleware = middleware.layer(app);\n\n# async {\nlet listener = tokio::net::TcpListener::bind(\"0.0.0.0:3000\").await.unwrap();\naxum::serve(listener, app_with_middleware.into_make_service()).await.unwrap();\n# };\n```\n\n----------------------------------------\n\nTITLE: Configuring Axum Router without v0.7 Checks in Rust\nDESCRIPTION: Demonstrates how to configure an Axum router using `without_v07_checks` to disable compatibility checks, allowing the definition of routes whose paths start with a colon (`:`) or an asterisk (`*`). This method must be called before defining such routes.\nSOURCE: https://github.com/tokio-rs/axum/blob/main/axum/src/docs/routing/without_v07_checks.md#_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\nuse axum::{\n    routing::get,\n    Router,\n};\n\nlet app = Router::<()>::new()\n    .without_v07_checks()\n    .route(\"/:colon\", get(|| async {}))\n    .route(\"/*asterisk\", get(|| async {}));\n\n// Our app now accepts\n// - GET /:colon\n// - GET /*asterisk\n# let _: Router = app;\n\n```\n\n----------------------------------------\n\nTITLE: Router State Management Update (Rust)\nDESCRIPTION: Demonstrates the breaking change in Axum 0.6.0-rc.5 regarding how router state is managed.  `Router::with_state` is no longer a constructor, but a method to convert the router into a `RouterService`. The code showcases the old and new ways of initializing a router with state.\nSOURCE: https://github.com/tokio-rs/axum/blob/main/axum/CHANGELOG.md#_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\nRouter::with_state(state).route(...);\n```\n\nLANGUAGE: rust\nCODE:\n```\nRouter::new().route(...).with_state(state);\n```\n\n----------------------------------------\n\nTITLE: Implementing Custom Extractors with FromRequest/FromRequestParts (Axum 0.6) - Rust\nDESCRIPTION: This Rust code illustrates how to implement custom extractors (`MyExtractor`) in Axum 0.6 using the new `FromRequestParts<S>` and `FromRequest<S, B>` traits. `FromRequestParts` is used for extractors that *don't* consume the body, receiving `Parts` and state `S`. `FromRequest` is used for extractors that *do* consume the body, receiving the full `Request<B>` and state `S`. This distinction enforces the one-body-consumer-per-handler rule at compile time.\nSOURCE: https://github.com/tokio-rs/axum/blob/main/axum/CHANGELOG.md#_snippet_5\n\nLANGUAGE: Rust\nCODE:\n```\nuse axum::{\n    extract::{FromRequest, FromRequestParts},\n    http::{StatusCode, Request, request::Parts},\n};\n\nstruct MyExtractor { /* ... */ }\n\n// implement `FromRequestParts` if you don't need to consume the request body\nimpl<S> FromRequestParts<S> for MyExtractor\nwhere\n    S: Send + Sync,\n{\n    type Rejection = StatusCode;\n\n    async fn from_request_parts(parts: &mut Parts, state: &S) -> Result<Self, Self::Rejection> {\n        // ...\n    }\n}\n\n// implement `FromRequest` if you do need to consume the request body\nimpl<S, B> FromRequest<S, B> for MyExtractor\nwhere\n    S: Send + Sync,\n    B: Send + 'static,\n{\n    type Rejection = StatusCode;\n\n    async fn from_request(req: Request<B>, state: &S) -> Result<Self, Self::Rejection> {\n        // ...\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing FromRequest and FromRequestParts Traits for Custom Axum Extractors Using Rust\nDESCRIPTION: Illustrates the new pattern for implementing custom extractors in Axum 0.6 by using the `FromRequestParts` trait if the extractor does not consume the request body and `FromRequest` if it does. Shows the required trait bounds and method signatures with async functions. Requires axum crate with extract and http features.\nSOURCE: https://github.com/tokio-rs/axum/blob/main/axum/CHANGELOG.md#_snippet_16\n\nLANGUAGE: rust\nCODE:\n```\nuse axum::{\n    extract::{FromRequest, FromRequestParts},\n    http::{StatusCode, Request, request::Parts},\n};\n\nstruct MyExtractor { /* ... */ }\n\n// implement `FromRequestParts` if you don't need to consume the request body\nimpl<S> FromRequestParts<S> for MyExtractor\nwhere\n    S: Send + Sync,\n{\n    type Rejection = StatusCode;\n\n    async fn from_request_parts(parts: &mut Parts, state: &S) -> Result<Self, Self::Rejection> {\n        // ...\n    }\n}\n\n// implement `FromRequest` if you do need to consume the request body\nimpl<S, B> FromRequest<S, B> for MyExtractor\nwhere\n    S: Send + Sync,\n    B: Send + 'static,\n{\n    type Rejection = StatusCode;\n\n    async fn from_request(req: Request<B>, state: &S) -> Result<Self, Self::Rejection> {\n        // ...\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Enforcing Single Request Body Consumer per Handler in Axum Extractors Using Rust\nDESCRIPTION: Describes Axum 0.6 compile-time enforcement that only one extractor per handler can consume the request body, preventing runtime errors present in 0.5. Illustrates sample handler signatures demonstrating correct and incorrect usage. Depends on axum crate with Json and http HeaderMap types.\nSOURCE: https://github.com/tokio-rs/axum/blob/main/axum/CHANGELOG.md#_snippet_15\n\nLANGUAGE: rust\nCODE:\n```\nuse axum::{Json, http::HeaderMap};\n\n// This won't compile on 0.6 because both `Json` and `String` need to consume\n// the request body. You can use either `Json` or `String`, but not both.\nasync fn handler_1(\n    json: Json<serde_json::Value>,\n    string: String,\n) {}\n\n// This won't work either since `Json` is not the last extractor.\nasync fn handler_2(\n    json: Json<serde_json::Value>,\n    headers: HeaderMap,\n) {}\n\n// This works!\nasync fn handler_3(\n    headers: HeaderMap,\n    json: Json<serde_json::Value>,\n) {}\n```\n\n----------------------------------------\n\nTITLE: Attempting Special Axum Routes Without Disabling Checks in Rust\nDESCRIPTION: Illustrates that attempting to define an Axum route with a path starting with a colon (`:`) or an asterisk (`*`) without first calling the `without_v07_checks` method on the router will result in a panic.\nSOURCE: https://github.com/tokio-rs/axum/blob/main/axum/src/docs/routing/without_v07_checks.md#_snippet_1\n\nLANGUAGE: Rust\nCODE:\n```\nuse axum::{\n    routing::get,\n    Router,\n};\n\n// This panics...\nlet app = Router::<()>::new()\n    .route(\"/:colon\", get(|| async {}));\n\n```\n\n----------------------------------------\n\nTITLE: Introducing FromRequestParts Trait in Axum Rust\nDESCRIPTION: Adds a new trait, `FromRequestParts`, designed for extractors that only need access to the request's parts (headers, URI, extensions) without consuming the request body. This is part of a larger rework of the extraction system.\nSOURCE: https://github.com/tokio-rs/axum/blob/main/axum-core/CHANGELOG.md#_snippet_17\n\nLANGUAGE: Rust\nCODE:\n```\ntrait FromRequestParts<S>\n```\n\n----------------------------------------\n\nTITLE: Chaining `with_state()` to Change Router's Missing State Type (Rust)\nDESCRIPTION: This example demonstrates how calling `with_state()` can modify the router's missing state type `S` to a specific type, enabling the addition of routes that require that state. It also illustrates how calling `with_state()` with a concrete value concludes the missing state, resulting in `Router<()>` ideal for serving, because `into_make_service()` requires a fully specified router type.\nSOURCE: https://github.com/tokio-rs/axum/blob/main/axum/src/docs/routing/with_state.md#_snippet_5\n\nLANGUAGE: Rust\nCODE:\n```\nuse axum::{Router, routing::get, extract::State};\n\n#[derive(Clone)]\nstruct AppState {}\n\n// Starting with a router needing `AppState`\nlet router: Router<AppState> = Router::new()\n    .route(\"/\", get(|_: State<AppState>| async {}));\n\n// Change the missing state to `String`\nlet string_router: Router<String> = router.with_state(AppState {});\n\n// Add route that uses `String` as the state\nlet string_router = string_router\n    .route(\"/needs-string\", get(|_: State<String>| async {}));\n\n// When all state is provided, produce a `Router<()>`\nlet final_router: Router<()> = string_router.with_state(\"foo\".to_owned());\n\n# async {\nlet listener = tokio::net::TcpListener::bind(\"0.0.0.0:3000\").await.unwrap();\naxum::serve(listener, final_router).await.unwrap();\n# };\n\n```\n\n----------------------------------------\n\nTITLE: Backpressure Handling Around Entire Axum App (Rust)\nDESCRIPTION: Illustrates how to apply backpressure-sensitive middleware around an entire Axum application by wrapping the router in a Tower `ServiceBuilder`. This approach ensures that backpressure is handled at the application level. This example highlights the importance of error handling when applying middleware around the entire application. Requires `axum` and `tower` dependencies.\nSOURCE: https://github.com/tokio-rs/axum/blob/main/axum/src/docs/middleware.md#_snippet_6\n\nLANGUAGE: Rust\nCODE:\n```\nuse axum::{\n    routing::get,\n    Router,\n};\nuse tower::ServiceBuilder;\n# let some_backpressure_sensitive_middleware =\n#     tower::layer::util::Identity::new();\n\nasync fn handler() { /* ... */ }\n\nlet app = Router::new().route(\"/\", get(handler));\n\nlet app = ServiceBuilder::new()\n    .layer(some_backpressure_sensitive_middleware)\n    .service(app);\n# let _: Router = app;\n```\n\n----------------------------------------\n\nTITLE: Extracting SocketAddr with ConnectInfo in Axum\nDESCRIPTION: Demonstrates how to extract a client's socket address using the ConnectInfo extractor with Axum's router. The example shows setting up a router, defining a handler that extracts the socket address, and binding the server to listen for connections.\nSOURCE: https://github.com/tokio-rs/axum/blob/main/axum/src/docs/routing/into_make_service_with_connect_info.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse axum:{\n    extract::ConnectInfo,\n    routing::get,\n    Router,\n};\nuse std::net::SocketAddr;\n\nlet app = Router::new().route(\"/\", get(handler));\n\nasync fn handler(ConnectInfo(addr): ConnectInfo<SocketAddr>) -> String {\n    format!(\"Hello {addr}\")\n}\n\n# async {\nlet listener = tokio::net::TcpListener::bind(\"0.0.0.0:3000\").await.unwrap();\naxum::serve(listener, app.into_make_service_with_connect_info::<SocketAddr>()).await.unwrap();\n# };\n```\n\n----------------------------------------\n\nTITLE: Adding AppendHeaders Type for Appending Headers in Axum Rust\nDESCRIPTION: Introduces the `AppendHeaders` type, designed specifically for appending headers to a response rather than replacing existing ones. This provides fine-grained control over response headers.\nSOURCE: https://github.com/tokio-rs/axum/blob/main/axum-core/CHANGELOG.md#_snippet_30\n\nLANGUAGE: Rust\nCODE:\n```\nstruct AppendHeaders\n```\n\n----------------------------------------\n\nTITLE: Defining Multiple HTTP Methods for a Route in Axum (Rust)\nDESCRIPTION: Shows how to associate multiple HTTP methods (GET, POST, DELETE) with the same path (`/`) by chaining method routing functions (`get`, `post`, `delete`) within a single `route` call on the `Router`. This requires the `axum` crate and handler functions (`get_root`, `post_root`, `delete_root`) for each method.\nSOURCE: https://github.com/tokio-rs/axum/blob/main/axum/src/docs/routing/route.md#_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse axum::{Router, routing::{get, delete}, extract::Path};\n\nlet app = Router::new().route(\n    \"/\",\n    get(get_root).post(post_root).delete(delete_root),\n);\n\nasync fn get_root() {}\n\nasync fn post_root() {}\n\nasync fn delete_root() {}\n# let _: Router = app;\n```\n\n----------------------------------------\n\nTITLE: Creating Low-Level Responses with Response Builder in Axum\nDESCRIPTION: Example showing how to create responses with more low-level control using the Response builder API. This approach allows for fine-grained control over response construction.\nSOURCE: https://github.com/tokio-rs/axum/blob/main/axum/src/docs/response.md#_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse axum:{\n    Json,\n    response::{IntoResponse, Response},\n    body::Body,\n    http::StatusCode,\n};\n\nasync fn response() -> Response {\n    Response::builder()\n        .status(StatusCode::NOT_FOUND)\n        .header(\"x-foo\", \"custom header\")\n        .body(Body::from(\"not found\"))\n        .unwrap()\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing IntoResponse for Response Tuple Combinations in Axum Rust\nDESCRIPTION: Adds implementations for the `IntoResponse` trait for various tuple combinations involving `http::response::Parts`, `http::response::Response<()>`, `impl IntoResponseParts`, and `impl IntoResponse`. This enhances the flexibility of composing responses using tuples.\nSOURCE: https://github.com/tokio-rs/axum/blob/main/axum-core/CHANGELOG.md#_snippet_28\n\nLANGUAGE: Rust\nCODE:\n```\nimpl IntoResponse for (http::response::Parts, impl IntoResponse)\n```\n\nLANGUAGE: Rust\nCODE:\n```\nimpl IntoResponse for (http::response::Response<()>, impl IntoResponse)\n```\n\nLANGUAGE: Rust\nCODE:\n```\nimpl IntoResponse for (Parts | Request<()>, $(impl IntoResponseParts)+, impl IntoResponse)\n```\n\n----------------------------------------\n\nTITLE: Adding Multiple HTTP Methods Sequentially in Axum (Rust)\nDESCRIPTION: Illustrates an alternative way to define multiple HTTP methods for the same path (`/`) by making separate, chained `route` calls for each method (GET, POST, DELETE) on the `Router`. Requires the `axum` crate and corresponding handler functions (`get_root`, `post_root`, `delete_root`).\nSOURCE: https://github.com/tokio-rs/axum/blob/main/axum/src/docs/routing/route.md#_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n# use axum::Router;\n# use axum::routing::{get, post, delete};\n#\nlet app = Router::new()\n    .route(\"/\", get(get_root))\n    .route(\"/\", post(post_root))\n    .route(\"/\", delete(delete_root));\n#\n# let _: Router = app;\n# async fn get_root() {}\n# async fn post_root() {}\n# async fn delete_root() {}\n```\n\n----------------------------------------\n\nTITLE: Implementing IntoResponse for Byte Array Types in Axum Rust\nDESCRIPTION: Adds implementations of the `IntoResponse` trait for static byte array slices (`&'static [u8; N]`) and owned byte arrays (`[u8; N]`). This allows these types to be directly returned as response bodies.\nSOURCE: https://github.com/tokio-rs/axum/blob/main/axum-core/CHANGELOG.md#_snippet_15\n\nLANGUAGE: Rust\nCODE:\n```\nimpl IntoResponse for &'static [u8; N]\n```\n\nLANGUAGE: Rust\nCODE:\n```\nimpl IntoResponse for [u8; N]\n```\n\n----------------------------------------\n\nTITLE: Running Axum Service with Auto-Reload using systemfd and cargo watch - Shell\nDESCRIPTION: This command initiates the auto-reloading development setup for the Axum service. `systemfd` listens on HTTP port 3000 and executes `cargo watch -x run`. `cargo watch` monitors the project directory for changes and reruns `cargo run`, while `systemfd` maintains the listening socket, allowing `listenfd` in the application to reuse it during restarts.\nSOURCE: https://github.com/tokio-rs/axum/blob/main/examples/auto-reload/README.md#_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\nsystemfd --no-pid -s http::3000 -- cargo watch -x run\n```\n\n----------------------------------------\n\nTITLE: Adding Default Body Limit to Bytes and String Extractors in Axum Rust\nDESCRIPTION: A breaking change introducing a default limit (2 MB) on the amount of data consumed by `Bytes::from_request` and implicitly by `String::from_request`. This mitigates potential out-of-memory attacks by preventing consumption of excessively large request bodies.\nSOURCE: https://github.com/tokio-rs/axum/blob/main/axum-core/CHANGELOG.md#_snippet_21\n\nLANGUAGE: Rust\nCODE:\n```\nimpl FromRequest<S, B> for Bytes\n```\n\nLANGUAGE: Rust\nCODE:\n```\nimpl FromRequest<S, B> for String\n```\n\n----------------------------------------\n\nTITLE: Comparing Nested and Wildcard Routes in Rust\nDESCRIPTION: This snippet demonstrates the difference in URI handling between nested routes and wildcard routes in axum. It shows how nested routes strip the prefix, while wildcard routes retain the entire URI. It also shows the differences in matching paths like `/foo` and `/foo/`.\nSOURCE: https://github.com/tokio-rs/axum/blob/main/axum/src/docs/routing/nest.md#_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse axum::{routing::get, http::Uri, Router};\n\nlet nested_router = Router::new()\n    .route(\"/\", get(|uri: Uri| async {\n        // `uri` will _not_ contain `/bar`\n    }));\n\nlet app = Router::new()\n    .route(\"/foo/{*rest}\", get(|uri: Uri| async {\n        // `uri` will contain `/foo`\n    }))\n    .nest(\"/bar\", nested_router);\n```\n\n----------------------------------------\n\nTITLE: Capturing Parameters from Nested Routes in Rust\nDESCRIPTION: This code illustrates how nested routes capture parameters from outer routes. It defines a route `/version/api/users/{id}` where the `users_api` router captures the 'id' parameter, while the outer route captures the 'version' parameter. This shows how both parameters are accessible within the handler.\nSOURCE: https://github.com/tokio-rs/axum/blob/main/axum/src/docs/routing/nest.md#_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse axum::{\n    extract::Path,\n    routing::get,\n    Router,\n};\nuse std::collections::HashMap;\n\nasync fn users_get(Path(params): Path<HashMap<String, String>>) {\n    // Both `version` and `id` were captured even though `users_api` only\n    // explicitly captures `id`.\n    let version = params.get(\"version\");\n    let id = params.get(\"id\");\n}\n\nlet users_api = Router::new().route(\"/users/{id}\", get(users_get));\n\nlet app = Router::new().nest(\"/{version}/api\", users_api);\n```\n\n----------------------------------------\n\nTITLE: Setting Router Fallback Handlers Accepting Only Handlers in Axum Using Rust\nDESCRIPTION: Shows migration for setting fallback handlers in Axum 0.6 where `Router::fallback` only accepts `Handler`s, unlike 0.5 which accepted any `Service`. The fallback service method `fallback_service` is introduced for arbitrary services. Requires axum crate and async fallback handler.\nSOURCE: https://github.com/tokio-rs/axum/blob/main/axum/CHANGELOG.md#_snippet_12\n\nLANGUAGE: rust\nCODE:\n```\nuse axum::{Router, handler::Handler};\n\nlet app = Router::new().fallback(fallback.into_service());\n\nasync fn fallback() {}\n```\n\nLANGUAGE: rust\nCODE:\n```\nuse axum::Router;\n\nlet app = Router::new().fallback(fallback);\n\nasync fn fallback() {}\n```\n\n----------------------------------------\n\nTITLE: Removing Generic Body Parameter from Traits in Axum Rust\nDESCRIPTION: A breaking change that removes the generic request body parameter `B` from the `FromRequestParts`, `FromRequest`, and `RequestExt` types/traits. This simplifies trait definitions by making them independent of the specific request body type.\nSOURCE: https://github.com/tokio-rs/axum/blob/main/axum-core/CHANGELOG.md#_snippet_13\n\nLANGUAGE: Rust\nCODE:\n```\ntrait FromRequestParts<B>\n```\n\nLANGUAGE: Rust\nCODE:\n```\ntrait FromRequest<B>\n```\n\nLANGUAGE: Rust\nCODE:\n```\ntrait RequestExt<B>\n```\n\n----------------------------------------\n\nTITLE: Handling Trailing Slash Redirects Removal in Axum Routing Using Rust\nDESCRIPTION: Demonstrates that Axum 0.6 removes automatic trailing slash redirects; requests to `/foo/` won't redirect to `/foo` and vice versa. Developers must handle these routes explicitly or use alternative crates like `axum_extra::routing::RouterExt::route_with_tsr`. Requires Router and routing::get from Axum.\nSOURCE: https://github.com/tokio-rs/axum/blob/main/axum/CHANGELOG.md#_snippet_11\n\nLANGUAGE: rust\nCODE:\n```\nuse axum::{Router, routing::get};\n\nlet app = Router::new()\n    // a request to `GET /foo/` will now get `404 Not Found`\n    // whereas in 0.5 axum would redirect to `/foo`\n    //\n    // same goes the other way if you had the route `/foo/`\n    // axum will no longer redirect from `/foo` to `/foo/`\n    .route(\"/foo\", get(handler));\n\nasync fn handler() {}\n```\n\n----------------------------------------\n\nTITLE: Removing BodyAlreadyExtracted Rejection in Axum Rust\nDESCRIPTION: A breaking change removing the `BodyAlreadyExtracted` rejection type. This removal is a consequence of the rework of the `FromRequest` and `RequestParts` system.\nSOURCE: https://github.com/tokio-rs/axum/blob/main/axum-core/CHANGELOG.md#_snippet_19\n\nLANGUAGE: Rust\nCODE:\n```\nBodyAlreadyExtracted\n```\n\n----------------------------------------\n\nTITLE: Sending Compressed Request with cURL (Bash)\nDESCRIPTION: Uses `curl` to send an HTTP POST request (implied by `--data-binary`) to the running server on `localhost:3000`. It explicitly sets `Content-Encoding: gzip` and sends data from a gzipped file (`products.json.gz`), demonstrating how the server automatically decompresses the request body. Requires `curl` and the running server.\nSOURCE: https://github.com/tokio-rs/axum/blob/main/examples/compression/README.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ncurl -v -g 'http://localhost:3000/' \\\n    -H \"Content-Type: application/json\" \\\n    -H \"Content-Encoding: gzip\" \\\n    --compressed \\\n    --data-binary @data/products.json.gz\n```\n\n----------------------------------------\n\nTITLE: Handling LengthLimitError and Mapping to 413 in Axum Rust\nDESCRIPTION: Adds automatic handling for `http_body::LengthLimitError` within axum. These errors, typically occurring when a body limit is exceeded, are now automatically mapped to an `HTTP 413 Payload Too Large` response.\nSOURCE: https://github.com/tokio-rs/axum/blob/main/axum-core/CHANGELOG.md#_snippet_25\n\nLANGUAGE: Rust\nCODE:\n```\nhttp_body::LengthLimitError\n```\n\nLANGUAGE: Rust\nCODE:\n```\nHTTP status 413\n```\n\n----------------------------------------\n\nTITLE: Accessing Wildcard Path Params Without Prefix Slash in Axum Routing Using Rust\nDESCRIPTION: Shows that path parameters for wildcard routes no longer include the leading slash in Axum 0.6. For example, a request to `/foo/bar/baz` matched by `/foo/*rest` sets the `params` as `bar/baz` instead of `/bar/baz`. This snippet uses Router, routing::get, and extract::Path from Axum.\nSOURCE: https://github.com/tokio-rs/axum/blob/main/axum/CHANGELOG.md#_snippet_9\n\nLANGUAGE: rust\nCODE:\n```\nuse axum::{Router, routing::get, extract::Path};\n\nlet app = Router::new().route(\"/foo/*rest\", get(handler));\n\nasync fn handler(\n    Path(params): Path<String>,\n) {\n    // for the request `/foo/bar/baz` the value of `params` will be `bar/baz`\n    //\n    // on 0.5 it would be `/bar/baz`\n}\n```\n\n----------------------------------------\n\nTITLE: Running the Axum Custom Extractor Error Example (Shell)\nDESCRIPTION: This command uses Cargo, the Rust build tool and package manager, to compile and run the specific Axum example named `example-customize-extractor-error`. This example showcases different techniques for customizing rejection responses from Axum extractors.\nSOURCE: https://github.com/tokio-rs/axum/blob/main/examples/customize-extractor-error/README.md#_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\ncargo run -p example-customize-extractor-error\n```\n\n----------------------------------------\n\nTITLE: Routing Overlapping Routes Priority Handling in Axum Using Rust\nDESCRIPTION: Illustrates that Axum 0.6 no longer considers routes like `/foo` and `/*rest` as overlapping and `/foo` takes priority. Routes can now coexist where previously this wasn't allowed. Uses the basic Router with routing::get and async route handlers.\nSOURCE: https://github.com/tokio-rs/axum/blob/main/axum/CHANGELOG.md#_snippet_10\n\nLANGUAGE: rust\nCODE:\n```\nuse axum::{Router, routing::get};\n\nlet app = Router::new()\n    // this used to not be allowed but now just works\n    .route(\"/foo/*rest\", get(foo))\n    .route(\"/foo/bar\", get(bar));\n\nasync fn foo() {}\n\nasync fn bar() {}\n```\n\n----------------------------------------\n\nTITLE: Migrating Router Implementation from Axum 0.1 to 0.2 in Rust\nDESCRIPTION: Example showing how to migrate from the old route-based API in Axum 0.1 to the new Router API in Axum 0.2. The new API uses a more explicit Router object and removes the prelude.\nSOURCE: https://github.com/tokio-rs/axum/blob/main/axum/CHANGELOG.md#_snippet_20\n\nLANGUAGE: rust\nCODE:\n```\nuse axum::{extract::Extension, prelude::*, routing::BoxRoute, AddExtensionLayer};\n\nlet app = route(\"/\", get(|| async { \"hi\" }))\n    .nest(\"/api\", api_routes())\n    .layer(AddExtensionLayer::new(state));\n\nfn api_routes() -> BoxRoute<Body> {\n    route(\n        \"/users\",\n        post(|Extension(state): Extension<State>| async { \"hi from nested\" }),\n    )\n    .boxed()\n}\n```\n\nLANGUAGE: rust\nCODE:\n```\nuse axum:{\n    extract::Extension,\n    handler::{get, post},\n    routing::BoxRoute,\n    Router,\n};\n\nlet app = Router::new()\n    .route(\"/\", get(|| async { \"hi\" }))\n    .nest(\"/api\", api_routes());\n\nfn api_routes() -> Router<BoxRoute> {\n    Router::new()\n        .route(\n            \"/users\",\n            post(|Extension(state): Extension<State>| async { \"hi from nested\" }),\n        )\n        .boxed()\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Custom Extractors with FromRequest (Axum 0.5) - Rust\nDESCRIPTION: This Rust code snippet shows the structure for implementing a custom extractor (`MyExtractor`) in Axum 0.5 using the `FromRequest<B>` trait. This trait was used for extractors that might or might not consume the request body. The `from_request` method received a mutable `RequestParts<B>`.\nSOURCE: https://github.com/tokio-rs/axum/blob/main/axum/CHANGELOG.md#_snippet_4\n\nLANGUAGE: Rust\nCODE:\n```\nstruct MyExtractor { /* ... */ }\n\nimpl<B> FromRequest<B> for MyExtractor\nwhere\n    B: Send,\n{\n    type Rejection = StatusCode;\n\n    async fn from_request(req: &mut RequestParts<B>) -> Result<Self, Self::Rejection> {\n        // ...\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Adding DefaultBodyLimit::disable Middleware in Axum Rust\nDESCRIPTION: Introduces the `DefaultBodyLimit::disable()` middleware (also available as a method) which can be used to disable the default 2 MB body consumption limit for extractors like `Bytes` and `String` where needed.\nSOURCE: https://github.com/tokio-rs/axum/blob/main/axum-core/CHANGELOG.md#_snippet_22\n\nLANGUAGE: Rust\nCODE:\n```\nDefaultBodyLimit::disable()\n```\n\n----------------------------------------\n\nTITLE: Illustrating Route Overlap Panic in Axum (Rust)\nDESCRIPTION: Demonstrates a scenario that causes Axum to panic: defining the exact same route (`/`) with the same method (`GET`) twice using separate `route` calls. This highlights Axum's requirement for unique route definitions (path and method combination). The `should_panic` attribute indicates this code intentionally triggers a panic.\nSOURCE: https://github.com/tokio-rs/axum/blob/main/axum/src/docs/routing/route.md#_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nuse axum::{routing::get, Router};\n\nlet app = Router::new()\n    .route(\"/\", get(|| async {}))\n    .route(\"/\", get(|| async {}));\n# let _: Router = app;\n```\n\n----------------------------------------\n\nTITLE: Reworking FromRequest and Removing RequestParts in Axum Rust\nDESCRIPTION: A breaking change involving a significant rework of the `FromRequest` trait and the removal of the `RequestParts` type. This alters how custom extractors are implemented in axum.\nSOURCE: https://github.com/tokio-rs/axum/blob/main/axum-core/CHANGELOG.md#_snippet_18\n\nLANGUAGE: Rust\nCODE:\n```\ntrait FromRequest<S, B>\n```\n\nLANGUAGE: Rust\nCODE:\n```\nstruct RequestParts\n```\n\n----------------------------------------\n\nTITLE: Migrating Nested Router Fallbacks in Axum Routing Using Rust\nDESCRIPTION: Demonstrates the migration from Axum version 0.5 to 0.6 showing how nested routers no longer inherit fallback behavior from the outer router. The fallback service must be explicitly set on each nested router. This snippet uses basic Router setup and an asynchronous fallback handler. It requires the axum crate and Rust async runtime.\nSOURCE: https://github.com/tokio-rs/axum/blob/main/axum/CHANGELOG.md#_snippet_7\n\nLANGUAGE: rust\nCODE:\n```\nuse axum::{Router, handler::Handler};\n\nlet api_routes = Router::new();\n\nlet app = Router::new()\n    .nest(\"/api\", api_routes)\n    .fallback(fallback.into_service());\n\nasync fn fallback() {}\n```\n\nLANGUAGE: rust\nCODE:\n```\nuse axum::Router;\n\nlet api_routes = Router::new()\n    // we have to explicitly set the fallback here\n    // since nested routers no longer delegate to the outer\n    // router's fallback\n    .fallback(fallback);\n\nlet app = Router::new()\n    .nest(\"/api\", api_routes)\n    .fallback(fallback);\n\nasync fn fallback() {}\n```\n\n----------------------------------------\n\nTITLE: Adding must_use Attribute to Axum Types and Methods in Rust\nDESCRIPTION: Adds the `#[must_use]` attribute to `AppendHeaders`, `ErrorResponse`, `IntoResponse::into_response`, and `IntoResponseParts` trait methods. This attribute generates compiler warnings if the return value of these items is ignored, encouraging correct usage.\nSOURCE: https://github.com/tokio-rs/axum/blob/main/axum-core/CHANGELOG.md#_snippet_7\n\nLANGUAGE: Rust\nCODE:\n```\n#[must_use]\n```\n\nLANGUAGE: Rust\nCODE:\n```\nstruct AppendHeaders;\n```\n\nLANGUAGE: Rust\nCODE:\n```\nstruct ErrorResponse;\n```\n\nLANGUAGE: Rust\nCODE:\n```\ntrait IntoResponse { #[must_use] fn into_response(...); }\n```\n\nLANGUAGE: Rust\nCODE:\n```\ntrait IntoResponseParts { #[must_use] fn ...(...); }\n```\n\n----------------------------------------\n\nTITLE: Replacing async_trait with RPITIT in Axum Rust\nDESCRIPTION: A breaking change replacing the use of the `#[async_trait]` attribute with return-position `impl Trait` in traits (RPITIT). This change impacts trait definitions that previously used `#[async_trait]` for async methods.\nSOURCE: https://github.com/tokio-rs/axum/blob/main/axum-core/CHANGELOG.md#_snippet_2\n\nLANGUAGE: Rust\nCODE:\n```\n#[async_trait]\n```\n\nLANGUAGE: Rust\nCODE:\n```\nimpl Trait\n```\n\n----------------------------------------\n\nTITLE: Adjusting Documentation Usage of impl IntoResponse in Axum Rust\nDESCRIPTION: Refines the documentation by reducing the frequent use of `impl IntoResponse` in examples or explanations. This change likely aims for clearer or more idiomatic representation in documentation.\nSOURCE: https://github.com/tokio-rs/axum/blob/main/axum-core/CHANGELOG.md#_snippet_26\n\nLANGUAGE: Rust\nCODE:\n```\nimpl IntoResponse\n```\n\n----------------------------------------\n\nTITLE: Implementing IntoResponse for Tuple in Axum Rust\nDESCRIPTION: Implements the `IntoResponse` trait for a tuple containing a single element `(R,)` where `R` itself implements `IntoResponse`. This allows single-element tuples implementing `IntoResponse` to also be treated as responses.\nSOURCE: https://github.com/tokio-rs/axum/blob/main/axum-core/CHANGELOG.md#_snippet_12\n\nLANGUAGE: Rust\nCODE:\n```\nimpl IntoResponse for (R,) where R: IntoResponse\n```\n\n----------------------------------------\n\nTITLE: Adding body_text and status Methods to Built-in Rejections in Axum Rust\nDESCRIPTION: Introduces `body_text` and `status` methods to axum's built-in rejection types. These methods provide convenient access to the rejection's response body text and HTTP status code.\nSOURCE: https://github.com/tokio-rs/axum/blob/main/axum-core/CHANGELOG.md#_snippet_16\n\nLANGUAGE: Rust\nCODE:\n```\nrejection.body_text()\n```\n\nLANGUAGE: Rust\nCODE:\n```\nrejection.status()\n```\n\n----------------------------------------\n\nTITLE: Fixing Compile Errors in __log_rejection Macro in Axum Rust\nDESCRIPTION: Resolves compilation issues that occurred with the internal `__log_rejection` macro under specific combinations of Cargo features configured for axum crates. This fix improves build reliability.\nSOURCE: https://github.com/tokio-rs/axum/blob/main/axum-core/CHANGELOG.md#_snippet_5\n\nLANGUAGE: Rust\nCODE:\n```\n__log_rejection\n```\n\n----------------------------------------\n\nTITLE: Adding RequestParts::extract Method in Axum Rust\nDESCRIPTION: Adds an `extract` method to the `RequestParts` type. This allows applying an extractor as a method call directly on the request parts, providing a more fluent API for extracting data.\nSOURCE: https://github.com/tokio-rs/axum/blob/main/axum-core/CHANGELOG.md#_snippet_31\n\nLANGUAGE: Rust\nCODE:\n```\nrequest_parts.extract::<MyExtractor>()\n```\n\n----------------------------------------\n\nTITLE: Implementing IntoResponse and IntoResponseParts for http::Extensions in Axum Rust\nDESCRIPTION: Provides implementations for the `IntoResponse` and `IntoResponseParts` traits for the `http::Extensions` type. This allows directly returning extensions as part of a response or its parts.\nSOURCE: https://github.com/tokio-rs/axum/blob/main/axum-core/CHANGELOG.md#_snippet_27\n\nLANGUAGE: Rust\nCODE:\n```\nimpl IntoResponse for http::Extensions\n```\n\nLANGUAGE: Rust\nCODE:\n```\nimpl IntoResponseParts for http::Extensions\n```\n\n----------------------------------------\n\nTITLE: Implementing From<()> for Body in Axum Rust\nDESCRIPTION: Provides an implementation of the `From<()>` trait for axum's `Body` type. This enables creating an empty `Body` from the unit type `()`, useful for responses with no body content.\nSOURCE: https://github.com/tokio-rs/axum/blob/main/axum-core/CHANGELOG.md#_snippet_11\n\nLANGUAGE: Rust\nCODE:\n```\nimpl From<()> for Body\n```\n\n----------------------------------------\n\nTITLE: Changing AppendHeaders to Work on IntoIterator in Axum Rust\nDESCRIPTION: A breaking change that updates the `AppendHeaders` type to work with any type implementing `impl IntoIterator`. Previously, it might have been restricted to specific collection types.\nSOURCE: https://github.com/tokio-rs/axum/blob/main/axum-core/CHANGELOG.md#_snippet_20\n\nLANGUAGE: Rust\nCODE:\n```\nimpl IntoIterator<Item = Header>\n```\n\nLANGUAGE: Rust\nCODE:\n```\nstruct AppendHeaders<I: IntoIterator>(...);\n```\n\n----------------------------------------\n\nTITLE: Implementing IntoResponseParts for Unit Type in Axum Rust\nDESCRIPTION: Adds an implementation of the `IntoResponseParts` trait for the unit type `()`. This allows `()` to be used in contexts expecting `IntoResponseParts`, facilitating composition.\nSOURCE: https://github.com/tokio-rs/axum/blob/main/axum-core/CHANGELOG.md#_snippet_10\n\nLANGUAGE: Rust\nCODE:\n```\nimpl IntoResponseParts for ()\n```\n\n----------------------------------------\n\nTITLE: Changing Display Output for Rejections in Axum Rust\nDESCRIPTION: Modifies the `Display` implementation for rejections generated by the `define_rejection!()` macro. The output now includes the `Display` output of the inner error, matching the behavior of the `body_text()` function.\nSOURCE: https://github.com/tokio-rs/axum/blob/main/axum-core/CHANGELOG.md#_snippet_1\n\nLANGUAGE: Rust\nCODE:\n```\ndefine_rejection!()\n```\n\n----------------------------------------\n\nTITLE: Initializing Axum Router with Extension (Axum 0.5) - Rust\nDESCRIPTION: This Rust code demonstrates how application state (`AppState`) was attached to an Axum router in version 0.5 using the `.layer(Extension(...))` method. The state is extracted in the handler using `Extension<AppState>`. This pattern was less type-safe and slower compared to the newer `State` extractor.\nSOURCE: https://github.com/tokio-rs/axum/blob/main/axum/CHANGELOG.md#_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\nuse axum::{routing::get, Extension, Router};\n\nlet app = Router::new()\n    .route(\"/\", get(handler))\n    .layer(Extension(AppState {}));\n\nasync fn handler(Extension(app_state): Extension<AppState>) {}\n\n#[derive(Clone)]\nstruct AppState {}\n```\n\n----------------------------------------\n\nTITLE: Adding Clone and Copy Derives for AppendHeaders in Axum Rust\nDESCRIPTION: Derives the `Clone` and `Copy` traits for the `AppendHeaders` type. This allows `AppendHeaders` instances to be duplicated or copied more conveniently.\nSOURCE: https://github.com/tokio-rs/axum/blob/main/axum-core/CHANGELOG.md#_snippet_6\n\nLANGUAGE: Rust\nCODE:\n```\n#[derive(Clone, Copy)]\nstruct AppendHeaders;\n```\n\n----------------------------------------\n\nTITLE: Implementing Copy for DefaultBodyLimit in Axum Rust\nDESCRIPTION: Implements the `Copy` trait for the `DefaultBodyLimit` type. This allows instances of `DefaultBodyLimit` to be copied trivially, potentially improving ergonomics.\nSOURCE: https://github.com/tokio-rs/axum/blob/main/axum-core/CHANGELOG.md#_snippet_8\n\nLANGUAGE: Rust\nCODE:\n```\nimpl Copy for DefaultBodyLimit\n```\n\n----------------------------------------\n\nTITLE: Fixing Typos in RequestParts Documentation in Axum Rust\nDESCRIPTION: Corrects typographical errors found within the documentation for the `RequestParts` type. This improves the clarity and accuracy of the documentation.\nSOURCE: https://github.com/tokio-rs/axum/blob/main/axum-core/CHANGELOG.md#_snippet_23\n\nLANGUAGE: Rust\nCODE:\n```\nstruct RequestParts\n```\n\n----------------------------------------\n\nTITLE: Migrating WebSocket Implementation from Axum 0.1 to 0.2 in Rust\nDESCRIPTION: Example showing how to migrate WebSocket implementation from Axum 0.1 to 0.2. The new API uses an extractor plus a response pattern instead of a service-based approach.\nSOURCE: https://github.com/tokio-rs/axum/blob/main/axum/CHANGELOG.md#_snippet_23\n\nLANGUAGE: rust\nCODE:\n```\nuse axum:{\n    prelude::*,\n    ws::{ws, WebSocket},\n};\n\nlet app = route(\n    \"/\",\n    ws(|socket: WebSocket| async move {\n        // do stuff with socket\n    }),\n);\n```\n\nLANGUAGE: rust\nCODE:\n```\nuse axum:{\n    extract::ws::{WebSocket, WebSocketUpgrade},\n    handler::get,\n    Router,\n};\n\nlet app = Router::new().route(\n    \"/\",\n    get(|ws: WebSocketUpgrade| async move {\n        ws.on_upgrade(|socket: WebSocket| async move {\n            // do stuff with socket\n        })\n    }),\n);\n```\n\n----------------------------------------\n\nTITLE: Implementing Stream::size_hint for BodyDataStream in Axum Rust\nDESCRIPTION: Adds the `size_hint` method implementation from the `Stream` trait to the `BodyDataStream` type in axum-core. This provides consumers with an estimate of the number of elements that the stream will yield.\nSOURCE: https://github.com/tokio-rs/axum/blob/main/axum-core/CHANGELOG.md#_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\nimpl Stream::size_hint for BodyDataStream\n```\n\n----------------------------------------\n\nTITLE: Implementing IntoResponse Trait in Axum 0.2 in Rust\nDESCRIPTION: Example showing how to migrate an IntoResponse implementation from Axum 0.1 to 0.2. The new implementation requires specifying associated Body and BodyError types.\nSOURCE: https://github.com/tokio-rs/axum/blob/main/axum/CHANGELOG.md#_snippet_21\n\nLANGUAGE: rust\nCODE:\n```\nuse axum::{http::Response, prelude::*, response::IntoResponse};\n\nstruct MyResponse;\n\nimpl IntoResponse for MyResponse {\n    fn into_response(self) -> Response<Body> {\n        Response::new(Body::empty())\n    }\n}\n```\n\nLANGUAGE: rust\nCODE:\n```\nuse axum::{body::Body, http::Response, response::IntoResponse};\n\nstruct MyResponse;\n\nimpl IntoResponse for MyResponse {\n    type Body = Body;\n    type BodyError = <Self::Body as axum::body::HttpBody>::Error;\n\n    fn into_response(self) -> Response<Self::Body> {\n        Response::new(Body::empty())\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Migrating SSE Implementation from Axum 0.1 to 0.2 in Rust\nDESCRIPTION: Example showing how to migrate server-sent events (SSE) implementation from Axum 0.1 to 0.2. The new API uses a response-based approach instead of a service-based one.\nSOURCE: https://github.com/tokio-rs/axum/blob/main/axum/CHANGELOG.md#_snippet_22\n\nLANGUAGE: rust\nCODE:\n```\nuse axum:{\n    prelude::*,\n    sse::{sse, Event},\n};\nuse std::convert::Infallible;\n\nlet app = route(\n    \"/\",\n    sse(|| async {\n        let stream = futures::stream::iter(vec![Ok::<_, Infallible>(\n            Event::default().data(\"hi there!\"),\n        )]);\n        Ok::<_, Infallible>(stream)\n    }),\n);\n```\n\nLANGUAGE: rust\nCODE:\n```\nuse axum:{\n    handler::get,\n    response::sse::{Event, Sse},\n    Router,\n};\nuse std::convert::Infallible;\n\nlet app = Router::new().route(\n    \"/\",\n    get(|| async {\n        let stream = futures::stream::iter(vec![Ok::<_, Infallible>(\n            Event::default().data(\"hi there!\"),\n        )]);\n        Sse::new(stream)\n    }),\n);\n```\n\n----------------------------------------\n\nTITLE: Updating axum-core Minimum Supported Rust Version\nDESCRIPTION: Increases the Minimum Supported Rust Version (MSRV) specifically for the `axum-core` crate to 1.56. This aligns the core library with a more recent Rust version.\nSOURCE: https://github.com/tokio-rs/axum/blob/main/axum-core/CHANGELOG.md#_snippet_24\n\nLANGUAGE: Rust\nCODE:\n```\nrustc version 1.56\n```\n\n----------------------------------------\n\nTITLE: Allowing DefaultBodyLimit Methods in Const Context in Axum Rust\nDESCRIPTION: Enables the `DefaultBodyLimit::max` and `DefaultBodyLimit::disable` methods to be used within a `const` context. This allows configuring body limits at compile time.\nSOURCE: https://github.com/tokio-rs/axum/blob/main/axum-core/CHANGELOG.md#_snippet_9\n\nLANGUAGE: Rust\nCODE:\n```\nconst LIMIT: DefaultBodyLimit = DefaultBodyLimit::max(1024);\n```\n\nLANGUAGE: Rust\nCODE:\n```\nconst NO_LIMIT: DefaultBodyLimit = DefaultBodyLimit::disable();\n```\n\n----------------------------------------\n\nTITLE: Installing Auto-Reload Tools with Cargo - Shell\nDESCRIPTION: This command installs the necessary command-line tools, `cargo-watch` and `systemfd`, using the Rust package manager `cargo`. `cargo-watch` monitors source files for changes, and `systemfd` provides socket activation capabilities needed for graceful restarts with `listenfd`.\nSOURCE: https://github.com/tokio-rs/axum/blob/main/examples/auto-reload/README.md#_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\ncargo install cargo-watch systemfd\n```\n\n----------------------------------------\n\nTITLE: Sending Uncompressed Request with cURL (Bash)\nDESCRIPTION: Uses `curl` to send an HTTP POST request to the running server on `localhost:3000` with `Content-Type: application/json`. It sends data from an uncompressed file (`products.json`). The `--compressed` flag tells `curl` to handle the server's response compression based on the `Accept-Encoding` header. Requires `curl` and the running server.\nSOURCE: https://github.com/tokio-rs/axum/blob/main/examples/compression/README.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ncurl -v -g 'http://localhost:3000/' \\\n    -H \"Content-Type: application/json\" \\\n    --compressed \\\n    --data-binary @data/products.json\n```\n\n----------------------------------------\n\nTITLE: Running Axum Example with Cargo (Bash)\nDESCRIPTION: Command to compile and run the specific `example-compression` binary within the Tokio/Axum project. This starts the example HTTP server that handles compression and decompression. Requires `cargo` and the project source code.\nSOURCE: https://github.com/tokio-rs/axum/blob/main/examples/compression/README.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ncargo run -p example-compression\n```\n\n----------------------------------------\n\nTITLE: Requiring New Traits for Option Extractor in Axum Rust\nDESCRIPTION: A breaking change where using `Option<T>` as an extractor now requires `T` to implement either `OptionalFromRequest` (if the last extractor) or `OptionalFromRequestParts` (for other extractors). This introduces new trait requirements for flexible optional extraction.\nSOURCE: https://github.com/tokio-rs/axum/blob/main/axum-core/CHANGELOG.md#_snippet_3\n\nLANGUAGE: Rust\nCODE:\n```\nOption<T>\n```\n\nLANGUAGE: Rust\nCODE:\n```\ntrait OptionalFromRequest\n```\n\nLANGUAGE: Rust\nCODE:\n```\ntrait OptionalFromRequestParts\n```\n\n----------------------------------------\n\nTITLE: Changing Body Type Reference in Axum Rust\nDESCRIPTION: A breaking change due to hyper 1.0. Axum no longer re-exports `hyper::Body`. Instead, users should now reference axum's own body type located at `axum_core::body::Body`.\nSOURCE: https://github.com/tokio-rs/axum/blob/main/axum-core/CHANGELOG.md#_snippet_14\n\nLANGUAGE: Rust\nCODE:\n```\nhyper::Body\n```\n\nLANGUAGE: Rust\nCODE:\n```\naxum_core::body::Body\n```\n\n----------------------------------------\n\nTITLE: Updating Minimum Rust Version for Axum\nDESCRIPTION: Changes the minimum supported Rust version (MSRV) for the axum crate to 1.75. Users must ensure their Rust toolchain is at least this version to build or use this version of axum.\nSOURCE: https://github.com/tokio-rs/axum/blob/main/axum-core/CHANGELOG.md#_snippet_4\n\nLANGUAGE: Rust\nCODE:\n```\nrustc version 1.75\n```"
  }
]