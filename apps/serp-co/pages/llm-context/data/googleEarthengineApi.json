[
  {
    "owner": "google",
    "repo": "earthengine-api",
    "content": "TITLE: Identifying Potential Flooded Areas from Radar Imagery in Earth Engine (Python)\nDESCRIPTION: Calculates the difference in smoothed radar backscatter between the 'after' and 'before' flood periods (`after.subtract(before)`). It then applies a threshold (`diff_upper_threshold = -3`) to this difference image (`diff_smoothed`). Pixels where the 'after' backscatter is significantly lower than the 'before' (indicating potential water presence) are identified (`diff_thresholded`).\nSOURCE: https://github.com/google/earthengine-api/blob/master/demos/flooded-roads/ExportToBigQuery.ipynb#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\n# @title Identify Flooded Areas\n# Threshold smoothed radar intensities to identify areas with standing water.\ndiff_upper_threshold = -3  # dB\ndiff_smoothed = after.subtract(before);\ndiff_thresholded = diff_smoothed.lt(diff_upper_threshold)\n```\n\n----------------------------------------\n\nTITLE: Fetching and Preprocessing Sentinel-1 Radar Data in Earth Engine (Python)\nDESCRIPTION: Loads the Copernicus Sentinel-1 GRD image collection, filters it by the defined AOI and selects images with 'VV' polarization. It then separates the collection into 'before' and 'after' flood periods based on date filters, creates a temporal mosaic for each period, and applies a focal median smoothing filter with a 100-meter radius to reduce noise in the radar data.\nSOURCE: https://github.com/google/earthengine-api/blob/master/demos/flooded-roads/ExportToBigQuery.ipynb#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n# @title Data Collections\n# Load Sentinel-1 C-band SAR Ground Range collection (log scaling, VV co-polar).\ncollection = ee.ImageCollection('COPERNICUS/S1_GRD') \\\n    .filterBounds(aoi) \\\n    .filter(ee.Filter.listContains('transmitterReceiverPolarisation', 'VV')) \\\n    .select('VV')\n# Smooth the data to remove noise.\nsmoothing_radius = 100  # meters\n# Filter by date.\nbefore = collection.filterDate('2017-11-01', '2017-11-17') \\\n    .mosaic() \\\n    .focal_median(smoothing_radius, 'circle', 'meters')  # before floods\nafter = collection.filterDate('2017-11-18', '2017-11-23') \\\n    .mosaic() \\\n    .focal_median(smoothing_radius, 'circle', 'meters')  # after floods\n```\n\n----------------------------------------\n\nTITLE: Masking Permanent Water Bodies from Flood Data in Earth Engine (Python)\nDESCRIPTION: Loads the JRC Global Surface Water dataset ('occurrence' and 'Metadata'). It creates a mask (`water_occ`) to identify areas that are not permanent or seasonal water bodies (occurrence < 10% and sufficient observations). This mask is applied to the previously thresholded flood difference image (`diff_thresholded`) using `updateMask` to remove pre-existing water bodies and isolate areas likely flooded during the event.\nSOURCE: https://github.com/google/earthengine-api/blob/master/demos/flooded-roads/ExportToBigQuery.ipynb#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\n# @title Remove Water Areas(other than floods)\n# Remove global surface water (oceans, lakes, etc.).\njrc_data0 = ee.Image(\"JRC/GSW1_0/Metadata\") \\\n    .select('total_obs') \\\n    .lte(0)\nwater_occ = ee.Image(\"JRC/GSW1_0/GlobalSurfaceWater\") \\\n    .select('occurrence') \\\n    .unmask(0) \\\n    .max(jrc_data0) \\\n    .lt(10)\ndiff_thresholded = diff_thresholded.updateMask(water_occ)\n```\n\n----------------------------------------\n\nTITLE: Converting Raster Flood Data to Vector Polygons in Earth Engine (Python)\nDESCRIPTION: Uses the `reduceToVectors` method on the final `diff_thresholded` Earth Engine image (representing the identified flooded areas). This converts the raster pixels identified as flooded into vector polygons. The conversion is performed within the specified `aoi`, at a `scale` of 10 meters, generating polygon geometries, and using non-eight-connected pixel grouping. The result is an `ee.FeatureCollection` named `vectors`.\nSOURCE: https://github.com/google/earthengine-api/blob/master/demos/flooded-roads/ExportToBigQuery.ipynb#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\n# @title Extract Vectors from the Flooded areas\n# Extract vectors from the diff threshold to load to BigQuery.\nvectors = diff_thresholded.reduceToVectors(\n    geometry = aoi,\n    scale = 10,\n    geometryType = 'polygon',\n    eightConnected = False)\n```\n\n----------------------------------------\n\nTITLE: Exporting Earth Engine Feature Collection to BigQuery Table in Python\nDESCRIPTION: Configures and initiates an asynchronous task to export the `vectors` FeatureCollection (containing flood polygons) from Earth Engine to a Google BigQuery table. The `task_config` dictionary specifies the collection to export, a description for the task, and the destination BigQuery table path (`table_path`). The `ee.batch.Export.table.toBigQuery` function creates the export task, and `task.start()` begins the export process.\nSOURCE: https://github.com/google/earthengine-api/blob/master/demos/flooded-roads/ExportToBigQuery.ipynb#_snippet_11\n\nLANGUAGE: python\nCODE:\n```\n# @title Export to BigQuery\ntask_config = {\n  'collection': vectors,\n  'description':'ee2bq_export_polygons',\n  'table': table_path\n}\ntask = ee.batch.Export.table.toBigQuery(**task_config)\ntask.start()\n# The task should run for about a minute. Check task.status() to see the result.\n```\n\n----------------------------------------\n\nTITLE: Joining Flood Polygons and OpenStreetMap Roads in BigQuery\nDESCRIPTION: Executes a BigQuery SQL query using the `%%bigquery` magic, saving the results to a Pandas DataFrame named `regions_by_country`. The query first selects flood polygons (`geo` renamed to `flood_poly`) and their areas from the previously exported table (`ee_export.ee_test`), filtering out very large polygons likely representing administrative areas. It then joins these flood polygons with road geometries (`geometry` renamed to `road_geometry`) from the public OpenStreetMap dataset (`bigquery-public-data.geo_openstreetmap.planet_ways`) where the road has a 'highway' tag and the road geometry intersects (`ST_INTERSECTS`) with a flood polygon. Selected geometries are returned as GeoJSON strings.\nSOURCE: https://github.com/google/earthengine-api/blob/master/demos/flooded-roads/ExportToBigQuery.ipynb#_snippet_14\n\nLANGUAGE: sql\nCODE:\n```\n# @title BQ Result set to display flooded highways\n%%bigquery regions_by_country --project $project_id\nSELECT\n id, area,version,changeset,osm_timestamp,ST_ASGEOJSON(flood_poly) as flood_poly,\n ST_ASGEOJSON(road_geometry) as road_geometry\nFROM (\n -- query 1 - find all the flooding areas\n SELECT\n   geo AS flood_poly,\n   ST_AREA(geo) AS area\n FROM\n   ee_export.ee_test\n WHERE\n   ST_AREA(geo) < 500000 ) t1 -- eliminate admin areas in the dataset\nJOIN (\n SELECT\n   id,\n   version,\n   changeset,\n   osm_timestamp,\n   geometry as road_geometry\n FROM\n   `bigquery-public-data.geo_openstreetmap.planet_ways` planet_ways,\n   planet_ways.all_tags AS all_tags\n WHERE\n   all_tags.key = 'highway' )\nON\n ST_INTERSECTS(flood_poly, road_geometry)\n```\n\n----------------------------------------\n\nTITLE: Visualizing Flooded Areas and Highways using Geemap in Python\nDESCRIPTION: Imports necessary libraries (`geemap`, `ipyleaflet.GeoJSON`, `json`). It parses the previously created GeoJSON strings (`floods`, `highways`) into Python objects using `json.loads`. It then creates `ipyleaflet.GeoJSON` layers for both the flooded areas (`flooded_areas`) and the flooded highways (`flooded_highways`), applying red styling to the highways. Finally, it creates a `geemap` map, centers it on the AOI, adds both GeoJSON layers, and displays the map, visually highlighting the roads intersected by floodwaters.\nSOURCE: https://github.com/google/earthengine-api/blob/master/demos/flooded-roads/ExportToBigQuery.ipynb#_snippet_17\n\nLANGUAGE: python\nCODE:\n```\n# @title Display Flooded Areas and Highways using geemap\nimport geemap\nfrom ipyleaflet import GeoJSON\nimport json\n\nstyling = {\"color\": \"red\", \"fillcolor\": \"red\"}\n\nflooded_areas = GeoJSON(\n    data=json.loads(floods),\n    name='Flooded areas'\n)\n\nflooded_highways = GeoJSON(\n    data=json.loads(highways),\n    name='Flooded roads',\n    style=styling\n)\nMap=geemap.Map()\nMap.setOptions(mapTypeId = 'HYBRID', styles = {}, types = [])\nMap.centerObject(aoi, 12)\nMap.add_layer(flooded_areas)\nMap.add_layer(flooded_highways)\nMap\n```\n\n----------------------------------------\n\nTITLE: Visualizing Identified Flooded Areas using Geemap in Python\nDESCRIPTION: Imports `geemap` and defines visualization parameters (`vis_params`) for displaying flooded areas in blue. It creates a `geemap` map instance, sets the map type to 'HYBRID', centers it on the AOI, and adds the final `diff_thresholded` image (masked to show only flooded pixels) as a layer. Finally, it displays the map.\nSOURCE: https://github.com/google/earthengine-api/blob/master/demos/flooded-roads/ExportToBigQuery.ipynb#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\n# @title Visualize the Map with Flooded Area\n# Display flooded areas on the map.\nimport geemap\nvis_params = {\n    \"palette\": [\"blue\"],\n}\nMap = geemap.Map()\nMap.setOptions(mapTypeId='HYBRID', styles={}, types=[])\nMap.centerObject(aoi, 12);\nMap.addLayer(\n    diff_thresholded.updateMask(diff_thresholded),\n    vis_params,\n    'flooded areas - blue',\n    True)\nMap\n```\n\n----------------------------------------\n\nTITLE: Formatting BigQuery Flood Polygons into GeoJSON in Python\nDESCRIPTION: Constructs a GeoJSON FeatureCollection string named `floods`. It accesses the `flood_poly` column (containing individual GeoJSON geometry strings) from the `regions_by_country` Pandas DataFrame (created by the previous BigQuery step). It uses `str.cat(sep=\", \")` to concatenate all these geometry strings, separated by commas, and wraps them within the standard GeoJSON FeatureCollection structure.\nSOURCE: https://github.com/google/earthengine-api/blob/master/demos/flooded-roads/ExportToBigQuery.ipynb#_snippet_15\n\nLANGUAGE: python\nCODE:\n```\n# @title Extract the Features from flood_poly\nfloods = '{\"type\": \"FeatureCollection\", \"features\":['\nfloods += regions_by_country.flood_poly.str.cat(sep=\", \")\nfloods += ']}' \n```\n\n----------------------------------------\n\nTITLE: Formatting BigQuery Road Geometries into GeoJSON in Python\nDESCRIPTION: Constructs a GeoJSON FeatureCollection string named `highways`. Similar to the previous step, it accesses the `road_geometry` column from the `regions_by_country` DataFrame, concatenates the individual road GeoJSON strings using `str.cat(sep=\", \")`, and wraps them in the GeoJSON FeatureCollection format. This prepares the geometries of the identified flooded roads for visualization.\nSOURCE: https://github.com/google/earthengine-api/blob/master/demos/flooded-roads/ExportToBigQuery.ipynb#_snippet_16\n\nLANGUAGE: python\nCODE:\n```\n# @title Extract the features from road_geometry\nhighways = '{\"type\": \"FeatureCollection\", \"features\":['\nhighways += regions_by_country.road_geometry.str.cat(sep=\", \")\nhighways += ']}'\n```\n\n----------------------------------------\n\nTITLE: Visualizing the Area of Interest (AOI) using Geemap in Python\nDESCRIPTION: Imports the `geemap` library, creates an interactive map instance (`Map`), centers the view on the previously defined `aoi` geometry with a zoom level of 12, sets the map type to 'HYBRID', adds the `aoi` polygon as a blue layer to the map, and displays the interactive map output.\nSOURCE: https://github.com/google/earthengine-api/blob/master/demos/flooded-roads/ExportToBigQuery.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n# @title Display AOI and point\nimport geemap\nMap = geemap.Map()\nMap.centerObject(aoi, 12);\nMap.setOptions(mapTypeId='HYBRID', styles={}, types=[])\nMap.addLayer(aoi, {\"color\":\"blue\"});\nMap\n```\n\n----------------------------------------\n\nTITLE: Defining Area of Interest (AOI) as an Earth Engine Polygon in Python\nDESCRIPTION: Uses the Earth Engine Python API (`ee.Geometry.Polygon`) to define a rectangular geographical area of interest (AOI) using longitude and latitude coordinates for its vertices. This AOI polygon (`aoi`) will be used to filter satellite data and limit the scope of analysis.\nSOURCE: https://github.com/google/earthengine-api/blob/master/demos/flooded-roads/ExportToBigQuery.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n# @title Define point and Area of Interest(aoi)\n# Define AOI (Area of Interest) polygon\naoi = ee.Geometry.Polygon([[-2.92, 54.10],\n          [-2.92, 53.99],\n          [-2.67, 53.99],\n          [-2.67, 54.10]])\n```\n\n----------------------------------------\n\nTITLE: Authenticating and Initializing Earth Engine and BigQuery Clients in Python\nDESCRIPTION: Imports necessary libraries (`google`, `ee`, `google.cloud.bigquery`, `google.colab.auth`). It initializes a BigQuery client, authenticates the Colab user, retrieves default Google Cloud credentials, and initializes the Earth Engine API using these credentials and the previously defined `project_id`. This establishes the connection to both services.\nSOURCE: https://github.com/google/earthengine-api/blob/master/demos/flooded-roads/ExportToBigQuery.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n# @title Authenticate and initialize the Session\nimport google\nimport ee\nfrom google.cloud import bigquery\nfrom google.colab import auth as google_auth\nclient= bigquery.Client()\ngoogle_auth.authenticate_user()\ncredentials, auth_project_id = google.auth.default()\nee.Initialize(credentials, project=project_id)\n```\n\n----------------------------------------\n\nTITLE: Querying Exported Flood Data in BigQuery\nDESCRIPTION: Uses the `%%bigquery` cell magic in Colab to execute a simple SQL query against the target BigQuery table (`ee_export.ee_test`). It selects all columns (`SELECT *`) from the table specified by the `project_id` variable. This query serves to verify that the data exported from Earth Engine has successfully arrived in the BigQuery table.\nSOURCE: https://github.com/google/earthengine-api/blob/master/demos/flooded-roads/ExportToBigQuery.ipynb#_snippet_13\n\nLANGUAGE: sql\nCODE:\n```\n# @title Check BigQuery Results\n%%bigquery --project $project_id\nSELECT * from ee_export.ee_test\n# If you get a \"table not found\" error then check the step above to see if your\n# job has completed.\n```\n\n----------------------------------------\n\nTITLE: Checking Earth Engine Export Task Status in Python\nDESCRIPTION: Calls the `status()` method on the previously initiated Earth Engine export task object (`task`). This retrieves and displays the current status of the BigQuery export job (e.g., 'RUNNING', 'COMPLETED', 'FAILED'). It's used to monitor the progress and confirm completion before querying the results in BigQuery.\nSOURCE: https://github.com/google/earthengine-api/blob/master/demos/flooded-roads/ExportToBigQuery.ipynb#_snippet_12\n\nLANGUAGE: python\nCODE:\n```\n# @title Check Export Job Status\n# Check the results and make sure the status is COMPLETED before checking the\n# results in BigQuery.\ntask.status()\n```\n\n----------------------------------------\n\nTITLE: Creating a BigQuery Dataset using bq Command-Line Tool\nDESCRIPTION: Executes the `bq mk` command via the shell (`!`) to create a new BigQuery dataset. It uses f-string formatting to insert the `region`, `project_id`, and `dataset_id` variables (defined in a previous Python snippet) into the command, specifying the location and name for the new dataset.\nSOURCE: https://github.com/google/earthengine-api/blob/master/demos/flooded-roads/ExportToBigQuery.ipynb#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n# @title Create BQ Dataset\n# Create a BQ dataset.\n!bq --location={region} mk --dataset {project_id}:{dataset_id}\n```\n\n----------------------------------------\n\nTITLE: Configuring GCP Project and BigQuery Parameters in Python\nDESCRIPTION: Sets up essential string variables for the Google Cloud project ID, BigQuery dataset ID, table ID, and region. It constructs the full BigQuery table path and prints the region and table path for verification. Requires the user to replace 'example-project' with their actual GCP project ID.\nSOURCE: https://github.com/google/earthengine-api/blob/master/demos/flooded-roads/ExportToBigQuery.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n# @title Parameter Setup\n# Replace the project id with your project.\nproject_id = \"example-project\"  # @param {type:\"string\"}\ndataset_id = \"ee_export\"\ntable_id = \"ee_test\"\ntable =  dataset_id + \".\" + table_id\nregion = 'us'\ntable_path = project_id + \".\" + dataset_id + \".\" + table_id\nprint(\"Region:      \",region)\nprint(\"Table Path:  \",table_path)\n```\n\n----------------------------------------\n\nTITLE: Installing Python Dependencies for Earth Engine and Geemap\nDESCRIPTION: Installs the 'geemap' library for map visualization and upgrades the 'earthengine-api' library using pip. These are necessary prerequisites for running the subsequent Python code in the Colab environment.\nSOURCE: https://github.com/google/earthengine-api/blob/master/demos/flooded-roads/ExportToBigQuery.ipynb#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n# @title Prerequisites\n# Install 'geemap' library to display the map.\n!pip install geemap\n!pip install earthengine-api --upgrade\n```\n\n----------------------------------------\n\nTITLE: Specifying Python Package Dependencies for Earth Engine API\nDESCRIPTION: This snippet lists the required Python packages and their specific or minimum versions needed for the `/google/earthengine-api` project. It includes essential libraries for Google Cloud Storage interaction (`google-cloud-storage`), Google API access (`google-api-python-client`), authentication (`google-auth`, `google-auth-httplib2`), and HTTP requests (`httplib2`, `requests`). These are typically installed using a package manager like pip.\nSOURCE: https://github.com/google/earthengine-api/blob/master/python/requirements.txt#_snippet_0\n\nLANGUAGE: requirements.txt\nCODE:\n```\ngoogle-cloud-storage\ngoogle-api-python-client>=1.12.1\ngoogle-auth>=1.4.1\ngoogle-auth-httplib2>=0.0.3\nhttplib2>=0.9.2,<1dev\nrequests\n```\n\n----------------------------------------\n\nTITLE: Computing Night-time Lights Trend - Google Earth Engine API - JavaScript\nDESCRIPTION: This JavaScript snippet demonstrates how to process satellite image time series in the Google Earth Engine Code Editor: it adds a temporal band to images, computes a linear fit over pixel values, and visualizes the trend with custom color mapping. Dependencies include the Earth Engine JavaScript API and access to the NOAA DMSP-OLS NIGHTTIME_LIGHTS dataset. The key parameters are the image collection selection, date band creation, and visualization settings; outputs are rendered as a map layer showing per-pixel trend information. Limitations include the need for registered API access, and code is suitable for direct use in the Earth Engine Code Editor.\nSOURCE: https://github.com/google/earthengine-api/blob/master/README.md#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\n// Compute the trend of night-time lights.\n\n// Adds a band containing image date as years since 1991.\nfunction createTimeBand(img) {\n  var year = ee.Date(img.get('system:time_start')).get('year').subtract(1991);\n  return ee.Image(year).byte().addBands(img);\n}\n\n// Map the time band creation helper over the night-time lights collection.\n// https://developers.google.com/earth-engine/datasets/catalog/NOAA_DMSP-OLS_NIGHTTIME_LIGHTS\nvar collection = ee.ImageCollection('NOAA/DMSP-OLS/NIGHTTIME_LIGHTS')\n    .select('stable_lights')\n    .map(createTimeBand);\n\n// Compute a linear fit over the series of values at each pixel, visualizing\n// the y-intercept in green, and positive/negative slopes as red/blue.\nMap.addLayer(\n    collection.reduce(ee.Reducer.linearFit()),\n    {min: 0, max: [0.18, 20, -0.18], bands: ['scale', 'offset', 'scale']},\n    'stable lights trend');\n```\n\n----------------------------------------\n\nTITLE: Authenticating with Google Cloud using gcloud (Shell)\nDESCRIPTION: Initiates the Google Cloud Platform authentication flow for the user via the command line using the 'gcloud' tool. This command typically opens a browser window for login and is a prerequisite for interacting with GCP services using 'gcloud'. Requires the Google Cloud SDK to be installed.\nSOURCE: https://github.com/google/earthengine-api/blob/master/demos/export-to-drive/README.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\ngcloud auth login\n```\n\n----------------------------------------\n\nTITLE: Configuring Default Google Cloud Project with gcloud (Shell)\nDESCRIPTION: Sets the active Google Cloud project for subsequent 'gcloud' commands. Requires the Google Cloud SDK to be installed and the user to be authenticated via 'gcloud auth login'. Replace '<project-id>' with your specific Google Cloud project identifier.\nSOURCE: https://github.com/google/earthengine-api/blob/master/demos/export-to-drive/README.md#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\ngcloud config set project <project-id>\n```\n\n----------------------------------------\n\nTITLE: Navigating to Demo Directory (Shell)\nDESCRIPTION: Changes the current working directory in the shell to the 'export-to-drive' demo folder located within the cloned 'earthengine-api' repository. This step is necessary before running commands specific to this demo.\nSOURCE: https://github.com/google/earthengine-api/blob/master/demos/export-to-drive/README.md#_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\ncd ./earthengine-api/demos/export-to-drive/\n```\n\n----------------------------------------\n\nTITLE: Cloning Earth Engine API Repository using Git (Shell)\nDESCRIPTION: Downloads the 'earthengine-api' repository, containing the Earth Engine API and demos, from GitHub to the local machine using the Git command-line tool. Requires Git to be installed.\nSOURCE: https://github.com/google/earthengine-api/blob/master/demos/export-to-drive/README.md#_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\ngit clone https://github.com/google/earthengine-api.git\n```\n\n----------------------------------------\n\nTITLE: Cloning Earth Engine API Repository using Git (Shell)\nDESCRIPTION: This shell command uses Git to clone the `earthengine-api` repository hosted on GitHub. This step is necessary to obtain the source code and demo files, including the server-side authentication example described in the document. Requires Git to be installed and accessible in the system's PATH.\nSOURCE: https://github.com/google/earthengine-api/blob/master/demos/server-auth-python/README.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\ngit clone https://github.com/google/earthengine-api.git\n```\n\n----------------------------------------\n\nTITLE: Navigating to Server Auth Demo Directory using cd (Shell)\nDESCRIPTION: This shell command changes the current directory to `demos/server-auth-python` inside the recently cloned `earthengine-api` repository. This positions the user within the correct folder to proceed with the setup and deployment steps for the Earth Engine server-side authentication demo. Assumes the previous `git clone` command was successful and executed in the parent directory.\nSOURCE: https://github.com/google/earthengine-api/blob/master/demos/server-auth-python/README.md#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\ncd ./earthengine-api/demos/server-auth-python\n```\n\n----------------------------------------\n\nTITLE: Navigating to Node.js Server Auth Demo Directory\nDESCRIPTION: This shell command changes the current working directory to the specific folder containing the Node.js server-side authentication demo (`server-auth-nodejs`) within the previously cloned `earthengine-api` repository. This step is necessary to access the demo's files for further setup and deployment.\nSOURCE: https://github.com/google/earthengine-api/blob/master/demos/server-auth-nodejs/README.md#_snippet_1\n\nLANGUAGE: Shell\nCODE:\n```\ncd ./earthengine-api/demos/server-auth-nodejs\n```\n\n----------------------------------------\n\nTITLE: Cloning Earth Engine API Repository using Git\nDESCRIPTION: This shell command clones the official Google Earth Engine API repository from GitHub using the `git clone` command. This is the initial step required to obtain the source code for the demos, including the Node.js server-side authentication example.\nSOURCE: https://github.com/google/earthengine-api/blob/master/demos/server-auth-nodejs/README.md#_snippet_0\n\nLANGUAGE: Shell\nCODE:\n```\ngit clone https://github.com/google/earthengine-api.git\n```\n\n----------------------------------------\n\nTITLE: Cloning Earth Engine API Repository with Git - Shell\nDESCRIPTION: This snippet provides the command to clone the Google Earth Engine API GitHub repository using git. This is a prerequisite for accessing the interactive classifier demo source code and related assets. It requires Git to be installed and assumes access to GitHub; executed in a shell terminal, it creates a local copy of the remote repository.\nSOURCE: https://github.com/google/earthengine-api/blob/master/demos/interactive-classifier/README.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\ngit clone https://github.com/google/earthengine-api.git\n```\n\n----------------------------------------\n\nTITLE: Navigating to Interactive Classifier Demo Directory - Shell\nDESCRIPTION: This shell command changes the current directory to the location of the interactive-classifier demo within the cloned Earth Engine API repository. It assumes the repository has been cloned as per the previous step and should be executed from the shell in the repository's root directory. This prepares the environment for running or modifying the demo web application code.\nSOURCE: https://github.com/google/earthengine-api/blob/master/demos/interactive-classifier/README.md#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\ncd ./earthengine-api/demos/interactive-classifier\n```\n\n----------------------------------------\n\nTITLE: Cloning the Earth Engine API Repository Using Git - Shell\nDESCRIPTION: This shell command clones the Earth Engine API repository from GitHub to the user's local machine using git. It is essential for obtaining the full source code and examples required for the Trendy Lights App Engine demo setup. The user must have git installed; the output is the 'earthengine-api' directory in the current working directory. This is a preliminary setup step required before proceeding with further configuration.\nSOURCE: https://github.com/google/earthengine-api/blob/master/demos/trendy-lights/README.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\ngit clone https://github.com/google/earthengine-api.git\n```\n\n----------------------------------------\n\nTITLE: Navigating to the Trendy Lights Demo Directory - Shell\nDESCRIPTION: This shell command changes the current working directory to the Trendy Lights demo folder within the previously cloned Earth Engine API repository. It is required to access the source files and related resources for the Trendy Lights example. Input: the 'earthengine-api' directory must exist at the specified relative path. Output: the user's shell context switches to the demo directory. Prerequisite: successful repository cloning.\nSOURCE: https://github.com/google/earthengine-api/blob/master/demos/trendy-lights/README.md#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\ncd ./earthengine-api/demos/trendy-lights/\n```\n\n----------------------------------------\n\nTITLE: Deploying Earth Engine WMTS Proxy on App Engine - Shell\nDESCRIPTION: This shell snippet demonstrates how to set execute permissions on a deployment script and run it with a specified App Engine project ID to deploy the WMTS proxy application. Dependencies include a Unix-like shell environment and the Google Cloud SDK (gcloud). The first command modifies the 'deploy.sh' script permissions, and the second initiates deployment; '<your app engine project id>' is a placeholder for the user's GCP project identifier. No input/output is produced other than deployment status/errors. Users must ensure Google App Engine and required APIs are already set up.\nSOURCE: https://github.com/google/earthengine-api/blob/master/demos/wmts/README.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n$ chmod +x deploy.sh\\n$ ./deploy.sh <your app engine project id>\n```\n\n----------------------------------------\n\nTITLE: Defining Python Package Requirements (requirements.txt format)\nDESCRIPTION: This text lists Python package dependencies and their minimum required versions, conforming to the format commonly used in `requirements.txt` files. It ensures essential libraries like `earthengine-api`, `flask`, and `google-cloud-storage` are installed correctly via tools like pip for the project.\nSOURCE: https://github.com/google/earthengine-api/blob/master/demos/wmts/requirements.txt#_snippet_0\n\nLANGUAGE: text\nCODE:\n```\nabsl-py>=0.7.1\ncachetools>=1.1.6\nearthengine-api>=0.1.182\nflask>=0.12.4\nFlask-WTF>=0.14.2\ngoogle-cloud-storage>=1.16.1\nGoogleAppEngineCloudStorageClient>=1.9.22.1\nrequests>=2.22.0\n```"
  }
]