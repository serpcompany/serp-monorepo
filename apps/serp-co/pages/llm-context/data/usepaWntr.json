[
  {
    "owner": "usepa",
    "repo": "wntr",
    "content": "TITLE: Reading EPANET INP File using WNTR in Python\nDESCRIPTION: Demonstrates reading an EPANET INP file ('networks/Net3.inp') to create a `WaterNetworkModel` object using the `wntr.network.read_inpfile` function. Requires the WNTR library. The snippet is marked with `# doctest: +SKIP`, indicating it might not be executed during automated testing but serves as an illustrative example.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/model_io.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n>>> import wntr\n\t\n>>> wn = wntr.network.read_inpfile('networks/Net3.inp') # doctest: +SKIP\n```\n\n----------------------------------------\n\nTITLE: Creating WNTR WaterNetworkModel from INP file in Python\nDESCRIPTION: This snippet demonstrates how to create a WNTR WaterNetworkModel object from an EPANET input file (.inp). It first specifies the path to the INP file and then instantiates the `WaterNetworkModel` class with this path, loading the network's structure and properties into the `wn` object. Requires a valid EPANET INP file at the specified path.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/getting_started_tutorial.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ninp_file = 'networks/Net3.inp'\nwn = wntr.network.WaterNetworkModel(inp_file)\n```\n\n----------------------------------------\n\nTITLE: Creating WaterNetworkModel from EPANET INP - Python\nDESCRIPTION: Constructs a WaterNetworkModel object by reading an EPANET INP file, essential for all subsequent analysis with WNTR. The INP file path is provided as a string. This is the foundational step for building and analyzing water distribution systems. Requires the wntr Python package.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/basics_tutorial.ipynb#_snippet_63\n\nLANGUAGE: python\nCODE:\n```\n# Create a WaterNetworkModel from an EPANET INP file\\nwn = wntr.network.WaterNetworkModel('networks/Net3.inp')\n```\n\n----------------------------------------\n\nTITLE: Importing and Initializing WaterNetworkModel with WNTR - Python\nDESCRIPTION: This snippet demonstrates importing the wntr package and initializing the WaterNetworkModel using the path to a sample INP file, handling alternate paths for test fixtures. No dependencies are required beyond the wntr Python package. The code creates a 'wn' object representing the water network, used throughout subsequent simulation code; expected input is an INP file path, output is a WaterNetworkModel object.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/hydraulics.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n>>> import wntr\n>>> try:\n...    wn = wntr.network.model.WaterNetworkModel('../examples/networks/Net3.inp')\n... except:\n...    wn = wntr.network.model.WaterNetworkModel('examples/networks/Net3.inp')\n```\n\n----------------------------------------\n\nTITLE: Running EpanetSimulator for Water Quality Simulation - WNTR/EPANET - Python\nDESCRIPTION: This code performs a full water quality simulation using EpanetSimulator from WNTR. It imports wntr, creates a WaterNetworkModel from an input file, initializes the simulator, and runs the simulation, storing outputs in results. It requires wntr and a valid .inp file. Key parameters include the path to the network file. The output contains node quality results among others. The simulation can only be run with EpanetSimulator, and assumes water quality options have been set.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/waterquality.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n>>> import wntr # doctest: +SKIP\n>>> wn = wntr.network.WaterNetworkModel('networks/Net3.inp') # doctest: +SKIP\n>>> sim = wntr.sim.EpanetSimulator(wn)\n>>> results = sim.run_sim()\n```\n\n----------------------------------------\n\nTITLE: Creating Water Network Model in WNTR using Python\nDESCRIPTION: This snippet demonstrates how to instantiate a WaterNetworkModel from an EPANET INP file using WNTR. The file path ('networks/Net3.inp') must be valid and accessible. This object serves as the foundation for all subsequent model manipulation and analysis.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/basics_tutorial.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n# Create a WaterNetworkModel from an EPANET INP file\\nwn = wntr.network.WaterNetworkModel('networks/Net3.inp')\n```\n\n----------------------------------------\n\nTITLE: Initializing WNTR Environment and Loading Network Model in Python\nDESCRIPTION: Imports necessary libraries (wntr, pandas, geopandas if available) and loads the 'Net3.inp' example network into a `WaterNetworkModel` object (`wn`). This setup, marked as hidden (`:hide:`), provides the necessary context and objects for subsequent code examples demonstrating WNTR I/O functionalities.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/model_io.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n>>> import wntr\n>>> import pandas as pd\n>>> try:\n...    import geopandas as gpd\n... except ModuleNotFoundError:\n...    gpd = None\n\t\n>>> try:\n...    wn = wntr.network.model.WaterNetworkModel('../examples/networks/Net3.inp')\n... except:\n...    wn = wntr.network.model.WaterNetworkModel('examples/networks/Net3.inp')\n```\n\n----------------------------------------\n\nTITLE: Running Hydraulic Simulation with WNTRSimulator - Python\nDESCRIPTION: This snippet runs a hydraulic simulation using the WNTRSimulator. After configuring the WaterNetworkModel and demand mode, it creates a WNTRSimulator instance and executes the simulation via run_sim, which returns a results object. Required before running: prior creation and configuration of the WaterNetworkModel. No version selection is needed as only one WNTRSimulator implementation is available.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/hydraulics.rst#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n>>> sim = wntr.sim.WNTRSimulator(wn)\n>>> results = sim.run_sim()\n```\n\n----------------------------------------\n\nTITLE: Simulating Hydraulics Using EpanetSimulator - Python\nDESCRIPTION: Performs a hydraulic simulation using the EpanetSimulator with the configured WaterNetworkModel. Stores results in a simulation results object containing node and link DataFrames. Requires an EPANET-compatible model and WNTR installation.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/basics_tutorial.ipynb#_snippet_53\n\nLANGUAGE: python\nCODE:\n```\n# Simulate hydraulics using EPANET\\nsim = wntr.sim.EpanetSimulator(wn)\\nresults_EPANET = sim.run_sim()\n```\n\n----------------------------------------\n\nTITLE: Switching EPANET Toolkit Versions for Simulation - Python\nDESCRIPTION: This code snippet illustrates how to run hydraulic simulations using specific versions (2.00.12 and 2.2.0) of the EPANET Programmer's Toolkit. The 'run_sim' method of EpanetSimulator accepts a 'version' argument (2.0 or 2.2). The snippet demonstrates creating two results objects, one for each version. Input is a configured EpanetSimulator; output is a results object corresponding to the chosen version.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/hydraulics.rst#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n>>> results1 = sim.run_sim(version=2.0) # runs EPANET 2.00.12\n>>> results2 = sim.run_sim(version=2.2) # runs EPANET 2.2.0\n```\n\n----------------------------------------\n\nTITLE: Creating a WNTR Water Network Model from INP File in Python\nDESCRIPTION: Specifies the path to the EPANET INP file ('networks/Net3.inp') and uses WNTR to create a water network model object. It also calculates the population associated with each junction in the network using WNTR metrics.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/pipe_break_tutorial.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n# Identify file path to inp file\ninp_file = 'networks/Net3.inp'\n\n# Create water network model \nwn = wntr.network.WaterNetworkModel(inp_file)\n\n# Calculate population per junction\npopulation = wntr.metrics.population(wn)\n```\n\n----------------------------------------\n\nTITLE: Simulating Hydraulics with WNTR EpanetSimulator in Python\nDESCRIPTION: This snippet shows how to perform a hydraulic simulation using WNTR's interface to the EPANET simulator. It initializes the `EpanetSimulator` with the previously created `WaterNetworkModel` object (`wn`) and then calls the `run_sim()` method to execute the simulation. The simulation results are stored in the `results` object. Depends on a valid `WaterNetworkModel` object.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/getting_started_tutorial.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nsim = wntr.sim.EpanetSimulator(wn)\nresults = sim.run_sim()\n```\n\n----------------------------------------\n\nTITLE: Importing and Initializing WaterNetworkModel - WNTR - Python\nDESCRIPTION: This snippet imports the wntr library and attempts to instantiate a WaterNetworkModel object from an EPANET INP file using two possible relative paths. It is intended for initializing the water network for subsequent analysis. The required dependency is wntr. The parameter to WaterNetworkModel is the path to the .inp file; the object wn is produced as output. It demonstrates how to flexibly load network files depending on file location.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/waterquality.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n>>> import wntr\n>>> try:\n...    wn = wntr.network.model.WaterNetworkModel('../examples/networks/Net3.inp')\n... except:\n...    wn = wntr.network.model.WaterNetworkModel('examples/networks/Net3.inp')\n```\n\n----------------------------------------\n\nTITLE: Running Multiple EPANET Simulations with Threading in Python\nDESCRIPTION: This snippet outlines the use of Python's threading library to parallelize multiple hydraulic simulations with WNTR's EpanetSimulator. All dependencies must be installed: threading, copy, numpy, and wntr. Each thread copies the base water network model, alters its simulation duration, runs the EpanetSimulator, and stores results in a shared dictionary. Simulation differences are configured per thread. The example highlights the importance of thread safety (using EPANET 2.2), and that mutable containers should be used for result aggregation. Inputs include the number of threads; outputs are simulation results keyed by thread. Avoid sharing the same model instance across threads to prevent data conflicts.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/advancedsim.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n>>> import threading\\n>>> import copy\\n>>> import numpy as np\\n>>> import wntr # doctest: +SKIP\\n\\n>>> wn = wntr.network.model.WaterNetworkModel('networks/Net3.inp') # doctest: +SKIP\n```\n\nLANGUAGE: python\nCODE:\n```\n>>> def run_epanet(wn, name, results):\\n...     \"\"\"Run the EPANET simulator on a water network and store results.\"\"\"\\n...     sim = wntr.sim.EpanetSimulator(wn)\\n...     res = sim.run_sim(name, version=2.2)\\n...     results[name] = res\n```\n\nLANGUAGE: python\nCODE:\n```\n>>> num_threads = 5\\n>>> results = dict()\\n>>> threads = list()\\n>>> for i in range(num_threads):\\n...     wn_thread = copy.deepcopy(wn)\\n...     wn_thread.options.time.duration = 86400 + i * 86400\\n...     t = threading.Thread(target=run_epanet, args=(wn_thread, str(i), results))\\n...     threads.append(t)\\n>>> for t in threads:\\n...     t.start()\\n>>> for t in threads:\\n...     t.join()\n```\n\n----------------------------------------\n\nTITLE: Simulating Earthquake Impact and Sampling Damage States with WNTR in Python\nDESCRIPTION: This snippet constructs a WaterNetworkModel, scales its coordinates, defines an earthquake scenario with parameters for epicenter, magnitude, and depth, then calculates distance to epicenter for each pipe and computes the corresponding peak ground acceleration (PGA). Using the previously defined fragility curve, it computes the probability of failure (using the curve's cumulative distribution function) for each element and samples a damage state accordingly. Key dependencies are wntr, numpy, and a defined FragilityCurve FC. Inputs include network model, earthquake parameters, and outputs are probability and damage-state arrays for network elements.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/fragility.rst#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n>>> wn = wntr.network.WaterNetworkModel('networks/Net3.inp') # doctest: +SKIP\\n>>> wn = wntr.morph.scale_node_coordinates(wn, 1000)\\n>>> epicenter = (32000,15000) # x,y location\\n>>> magnitude = 6.5 # Richter scale\\n>>> depth = 10000 # m, shallow depth\\n>>> earthquake = wntr.scenario.Earthquake(epicenter, magnitude, depth)\\n>>> distance = earthquake.distance_to_epicenter(wn, element_type=wntr.network.Pipe)\\n>>> pga = earthquake.pga_attenuation_model(distance)  \\n\\n>>> failure_probability = FC.cdf_probability(pga)\\n>>> damage_state = FC.sample_damage_state(failure_probability)\n```\n\n----------------------------------------\n\nTITLE: Running a Simulation with EpanetSimulator - WNTR - Python\nDESCRIPTION: This snippet demonstrates how to initialize a water network model and run a simulation using the EpanetSimulator class in the wntr.sim module. It loads the INP file into the WaterNetworkModel, creates an EpanetSimulator with that model, and executes the simulation with sim.run_sim(). This requires the wntr Python package and a network input file. Input: file path to INP network file. Output: results object containing simulation outputs.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/resultsobject.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n>>> import wntr # doctest: +SKIP\n\n>>> wn = wntr.network.WaterNetworkModel('networks/Net3.inp') # doctest: +SKIP\n>>> sim = wntr.sim.EpanetSimulator(wn)\n>>> results = sim.run_sim()\n```\n\n----------------------------------------\n\nTITLE: Running Hydraulic Simulation and Computing Metrics for Base Model - Python\nDESCRIPTION: Runs an EPANET-based hydraulic simulation on the base model to obtain node pressures and calculates average expected demand, preparing baseline metrics for later comparison. Negative pressures are replaced with zero to avoid unphysical values. Requires the simulated network instance (wn0), with outputs structured as pandas Series. Dependency: wntr.sim.EpanetSimulator, wntr.metrics.average_expected_demand.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/model_development_tutorial.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n# Run simulation and extract pressure and expected demand\\nsim = wntr.sim.EpanetSimulator(wn0)\\nresults0 = sim.run_sim()\\npressure0 = results0.node[\"pressure\"].loc[0, :]\\npressure0[pressure0<0] = 0 # remove negative pressure\\naed0 = wntr.metrics.average_expected_demand(wn0)\\n\n```\n\n----------------------------------------\n\nTITLE: Running Hydraulic Simulation and Computing Metrics with WNTR - Python\nDESCRIPTION: Runs an EPANet hydraulic simulation on the built network using wntr.sim.EpanetSimulator, retrieves pressure at time zero, removes any negative values, and calculates average expected demand across the network. Outputs simulation results in the results2 object and summary pressure/demand arrays. Requires a fully constructed WNTR model and the wntr.metrics module.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/model_development_tutorial.ipynb#_snippet_35\n\nLANGUAGE: python\nCODE:\n```\nsim = wntr.sim.EpanetSimulator(wn2)\\nresults2 = sim.run_sim()\\npressure2 = results2.node[\\\"pressure\\\"].loc[0, :]\\npressure2[pressure2<0] = 0 # remove negative pressure\\naed2 = wntr.metrics.average_expected_demand(wn2)\n```\n\n----------------------------------------\n\nTITLE: Simulating with PDD and Subsequent Quality Analysis - WNTR/EPANET - Python\nDESCRIPTION: This advanced example shows how to run a hydraulic simulation in pressure dependent demand (PDD) mode using WNTRSimulator, update network demands based on simulation output, and then perform a water quality simulation (TRACE) using EpanetSimulator. It requires an existing wn object and wntr library. The snippet configures PDD mode, runs two simulations (hydraulic and quality), assigns new demands, and retrieves results. Key parameters include the demand_model, node demand results, and quality options. Input is a populated water network model; output is water quality simulation results reflecting PDD effects.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/waterquality.rst#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\n>>> wn.options.hydraulic.demand_model = 'PDD'\n>>> sim = wntr.sim.WNTRSimulator(wn)\n>>> results = sim.run_sim()\n\n>>> wn.assign_demand(results.node['demand'].loc[:,wn.junction_name_list])\n\n>>> sim = wntr.sim.EpanetSimulator(wn)\n>>> wn.options.quality.parameter = 'TRACE'\n>>> wn.options.quality.trace_node = '111'\n>>> results_withPDD = sim.run_sim()\n```\n\n----------------------------------------\n\nTITLE: Importing WNTR and Creating a Control Action (Python)\nDESCRIPTION: This snippet demonstrates importing the WNTR library and its controls module. It then loads a water network model from an INP file, retrieves a specific pipe link ('330'), and defines a `ControlAction` to set the status of that pipe to 1 (open). Finally, it prints the string representation of the created action. This requires the WNTR library and a valid EPANET INP file ('networks/Net3.inp').\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/controls.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n>>> import wntr # doctest: +SKIP\n>>> import wntr.network.controls as controls\n\n>>> wn = wntr.network.WaterNetworkModel('networks/Net3.inp') # doctest: +SKIP\n>>> pipe = wn.get_link('330')\n>>> act1 = controls.ControlAction(pipe, 'status', 1)\n>>> print(act1)\nPIPE 330 STATUS IS OPEN\n```\n\n----------------------------------------\n\nTITLE: Initializing WaterNetworkModel and Importing Required Libraries - WNTR, pandas, matplotlib - Python\nDESCRIPTION: This snippet imports pandas, matplotlib, and wntr, and initializes a WaterNetworkModel by loading a network input file. It wraps file loading in a try/except block to handle relative path differences, and sets pandas display precision to 2 decimal places. Required dependencies: pandas, matplotlib, and wntr installed. Expected output: an initialized wntr.network.model.WaterNetworkModel instance.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/resultsobject.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n>>> import pandas as pd\n>>> import matplotlib.pylab as plt\n>>> import wntr\n>>> pd.set_option('display.precision', 2)\n>>> try:\n...    wn = wntr.network.model.WaterNetworkModel('../examples/networks/Net3.inp')\n... except:\n...    wn = wntr.network.model.WaterNetworkModel('examples/networks/Net3.inp')\n```\n\n----------------------------------------\n\nTITLE: Modifying Attributes of Existing WNTR Elements\nDESCRIPTION: This snippet demonstrates how to modify attributes of specific network elements (nodes and links) in a `WaterNetworkModel`. It retrieves a junction ('121'), a pipe ('122'), and a tank ('1') using `get_node` and `get_link` methods, and then directly modifies their respective `elevation`, `diameter`, and `diameter` attributes.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/waternetworkmodel.rst#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\n>>> junction = wn.get_node('121')\n>>> junction.elevation = 5\n>>> pipe = wn.get_link('122')\n>>> pipe.diameter = pipe.diameter*0.5\n>>> tank = wn.get_node('1')\n>>> tank.diameter = tank.diameter*1.1\n```\n\n----------------------------------------\n\nTITLE: Creating WNTR Water Network Model from INP File in Python\nDESCRIPTION: Specifies the path to the water network input file (`.inp`), creates a WNTR `WaterNetworkModel` object representing the network, and then uses WNTR's metrics module to calculate the population associated with each junction in the model. This model object (`wn`) is used in subsequent analysis steps.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/pipe_segments_tutorial.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n# Identify file path to inp file\ninp_file = \"networks/Net3.inp\"\n\n# Create water network model\nwn = wntr.network.WaterNetworkModel(inp_file)\n\n# Calculate population per junction\npopulation = wntr.metrics.population(wn)\n```\n\n----------------------------------------\n\nTITLE: Setting Demand Model and Simulating Hydraulics - WNTR - Python\nDESCRIPTION: Configures the hydraulic demand model for theWNTR network, runs a hydraulic simulation, and computes a pressure matrix for all nodes over time. Requires the wntr Python library and a loaded WaterNetworkModel object (wn). The resulting 'pressure' DataFrame contains pressure values for all node/time pairs and is used in subsequent metric calculations.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/resilience.rst#_snippet_13\n\nLANGUAGE: python\nCODE:\n```\n>>> import numpy as np\n\n>>> wn.options.hydraulic.demand_model = 'PDD'\n>>> sim = wntr.sim.WNTRSimulator(wn)\n>>> results = sim.run_sim()\n\n>>> pressure = results.node['pressure']\n>>> threshold = 21.09 # 30 psi\n>>> pressure_above_threshold = wntr.metrics.query(pressure, np.greater, \n...     threshold)\n```\n\n----------------------------------------\n\nTITLE: Converting Water Network Model to GeoPandas GeoDataFrames - Python\nDESCRIPTION: This snippet calls the WNTR function to_gis to convert a WaterNetworkModel instance into a WaterNetworkGIS object, which contains GeoDataFrames for each component of the model. This enables geospatial analysis and export to GIS formats. Inputs: WaterNetworkModel object. Outputs: WaterNetworkGIS object with geospatial datasets for junctions, tanks, reservoirs, pipes, pumps, and valves (if present). Dependency: wntr, geopandas.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/gis.rst#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n>>> wn_gis = wntr.network.to_gis(wn)\n```\n\n----------------------------------------\n\nTITLE: Accessing Node Pressure Across All Nodes and Times - pandas DataFrame - Python\nDESCRIPTION: This snippet retrieves the complete pressure results for all nodes and time steps from the node results dictionary of the simulation output, storing them in a pandas DataFrame. The input required is a valid results object. The output, 'pressure', is a DataFrame indexed by time (seconds) with columns for each node name. No additional dependencies other than pandas and a populated results object.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/resultsobject.rst#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n>>> pressure = results.node['pressure']\n```\n\n----------------------------------------\n\nTITLE: Adding Simulation Result Attributes to GIS Nodes - Python\nDESCRIPTION: This snippet runs a network simulation (using EpanetSimulator) and adds the resulting pressure values at 1 hour as an attribute ('Pressure_1hr') to all node GeoDataFrames (junctions, tanks, reservoirs) using the add_node_attributes method. Required dependencies include wntr and geopandas, and a valid network model must be provided. Inputs: simulation results (Pandas Series or DataFrame) and attribute name; output: updated GeoDataFrames with new column.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/gis.rst#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\n>>> sim = wntr.sim.EpanetSimulator(wn)\n>>> results = sim.run_sim()\n>>> wn_gis.add_node_attributes(results.node['pressure'].loc[3600,:], \n...     'Pressure_1hr')\n```\n\n----------------------------------------\n\nTITLE: Modifying Specific WNTR Option Values in Python\nDESCRIPTION: Illustrates how to modify specific simulation parameters within the WNTR options. This example sets the simulation duration in the 'time' options and the demand model and required pressure in the 'hydraulic' options. Note that duration is specified in seconds and required pressure in meters.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/options.rst#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n>>> wn.options.time.duration = 86400\n>>> wn.options.hydraulic.demand_model = 'PDD'\n>>> wn.options.hydraulic.required_pressure = 21.097 # 30 psi = 21.097 m\n```\n\n----------------------------------------\n\nTITLE: Comparing Pressure Results from EpanetSimulator and WNTRSimulator - Python\nDESCRIPTION: Calculates and plots the maximum difference in pressure between EpanetSimulator and WNTRSimulator at each time step. Requires matplotlib and both simulation results; outputs a plot for visual analysis.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/basics_tutorial.ipynb#_snippet_58\n\nLANGUAGE: python\nCODE:\n```\n# Compare EpanetSimulator and WNTRSimulator pressure results\\ndiff = results_EPANET.node['pressure'] - results_WNTR.node['pressure']\\nax = diff.max(axis=1).plot(title='Max difference in pressure')\\nax.set_xlabel('Time (s)')\\nax.set_ylabel('Pressure difference (m)')\n```\n\n----------------------------------------\n\nTITLE: Converting WaterNetworkModel to NetworkX MultiDiGraph - Python\nDESCRIPTION: Converts a WaterNetworkModel to a NetworkX MultiDiGraph for advanced network analysis or visualization. Uses wntr.network.to_graph; output is the graph object printed to standard output. Requires NetworkX and a valid WaterNetworkModel.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/basics_tutorial.ipynb#_snippet_44\n\nLANGUAGE: python\nCODE:\n```\n# Convert the WaterNetworkModel to a MultiDiGraph\\nG = wntr.network.to_graph(wn)\\nprint(G)\n```\n\n----------------------------------------\n\nTITLE: Exporting and Importing WaterNetworkModel as GeoPandas GeoDataFrames - Python\nDESCRIPTION: Exports a WaterNetworkModel as a collection of GeoPandas GeoDataFrames (one for each network component), and recreates a model from this GIS data. Uses wntr.network.to_gis and wntr.network.from_gis. Shows how to access the head of each DataFrame. Requires GeoPandas installed and valid input model.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/basics_tutorial.ipynb#_snippet_45\n\nLANGUAGE: python\nCODE:\n```\n# Convert the WaterNetworkModel to a collection of GeoDataFrames\\nwn_gis = wntr.network.to_gis(wn)\\nprint(wn_gis.junctions.head())\\n#print(wn_gis.tanks.head())\\n#print(wn_gis.reservoirs.head())\\n#print(wn_gis.pipes.head())\\n#print(wn_gis.pumps.head())\\n#print(wn_gis.valves.head())\\n\\n# Create a WaterNetworkModel from a collection of GeoDataFrames\\nwn2 = wntr.network.from_gis(wn_gis)\n```\n\n----------------------------------------\n\nTITLE: Iterating Over Pipes and Modifying Diameter\nDESCRIPTION: This snippet demonstrates iterating over specific element types in the model. It uses the `wn.pipes()` iterator, which yields the name and object for each pipe. Inside the loop, it modifies the `diameter` attribute of each pipe object, reducing it by 10%.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/waternetworkmodel.rst#_snippet_18\n\nLANGUAGE: python\nCODE:\n```\n>>> for pipe_name, pipe in wn.pipes():\n...     pipe.diameter = pipe.diameter*0.9\n```\n\n----------------------------------------\n\nTITLE: Running an EPANET Simulation with WNTR (Python)\nDESCRIPTION: Shows how to initialize an EPANET simulator (`wntr.sim.EpanetSimulator`) with a WNTR water network model (`wn`) and execute a simulation using the `run_sim()` method. This snippet implies that the model `wn` has been previously defined or loaded. The results of the simulation are stored in the `results` variable. Requires the `wntr` library.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/waternetworkmodel.rst#_snippet_25\n\nLANGUAGE: python\nCODE:\n```\n>>> sim = wntr.sim.EpanetSimulator(wn) # make sure it's a valid model\n>>> results = sim.run_sim()\n```\n\n----------------------------------------\n\nTITLE: Plotting Spatial Node Attributes on Network - wntr.graphics + matplotlib - Python\nDESCRIPTION: This snippet visualizes node attributes (e.g., pressure at 1 hour) on the water network diagram using wntr.graphics.plot_network. Nodes are color-mapped according to the attribute, with value range and colorbar label specified. Dependencies: wntr, matplotlib, and a pandas Series with node attributes. Inputs: network model 'wn', node attribute Series, range, and colorbar label. Output: matplotlib Axes instance representing the network plot.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/resultsobject.rst#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\n>>> ax = wntr.graphics.plot_network(wn, node_attribute=pressure_at_1hr, \n...    node_range=[30,55], node_colorbar_label='Pressure (m)')\n```\n\n----------------------------------------\n\nTITLE: Slicing Node Pressure DataFrame for a Specific Time - pandas Series - Python\nDESCRIPTION: This snippet extracts pressures for all nodes at simulation time 3600 seconds, printing the first five entries. Uses DataFrame.loc with a specific index value for row slicing. Input: pressure DataFrame indexed by time. Output: pandas Series mapping node names to pressures at the specified time.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/resultsobject.rst#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n>>> pressure_at_1hr = pressure.loc[3600,:]\n>>> print(pressure_at_1hr.head())\nname\n10    28.25\n15    28.89\n20     9.10\n35    41.51\n40     4.19\nName: 3600, dtype: float32\n```\n\n----------------------------------------\n\nTITLE: Population Impacted by Water Age Above Threshold - WNTR - Python\nDESCRIPTION: Uses computed population data with node-level water age to determine how many people are exposed to water aged above 24 hours. This depends on average_age and population values derived from prior steps, and requires NumPy for logical operations. Output is a scalar or array quantifying the impacted population.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/resilience.rst#_snippet_18\n\nLANGUAGE: python\nCODE:\n```\n>>> pop = wntr.metrics.population(wn)\n>>> threshold = 24\n>>> pop_impacted = wntr.metrics.population_impacted(pop, average_age, np.greater, \n...     threshold)\n```\n\n----------------------------------------\n\nTITLE: Creating Complex Rule with AndCondition in Python\nDESCRIPTION: Shows how to define a complex control rule using the `controls.AndCondition` class to combine multiple conditions (`cond1`, `cond2`). The rule (`rule3`) triggers `act1` if the combined condition is true and `act2` otherwise, setting a priority.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/controls.rst#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n>>> cond3 = controls.AndCondition(cond1, cond2)\n>>> print(cond3)\n TANK 1 LEVEL ABOVE 46.0248 AND SYSTEM TIME >= 121:00:00 \n\n>>> rule3 = controls.Rule(cond3, [act1], [act2], priority=3, name='complex_rule')\n>>> print(rule3)\nIF  TANK 1 LEVEL ABOVE 46.0248 AND SYSTEM TIME >= 121:00:00  THEN PIPE 330 STATUS IS OPEN ELSE PUMP 10 STATUS IS OPEN PRIORITY 3\n```\n\n----------------------------------------\n\nTITLE: Adding EPANET Controls to a Water Network Model - Python\nDESCRIPTION: Demonstrates adding operational controls in EPANET string format to the WNTR WaterNetworkModel. Controls are applied to a specific pump, setting open/close logic based on tank water levels (SI units). Each control is registered with a unique name. Inputs are string-formatted controls; model must already be loaded.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/model_development_tutorial.ipynb#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nline = \"LINK ~@Pump-1 OPEN IF NODE T-3 BELOW  27.6606\"  # 90.75 ft\\nwn1.add_control(\"Pump1_open\", line)\\n\\nline = \"LINK ~@Pump-1 CLOSED IF NODE T-3 ABOVE  32.2326\"  # 105.75 ft\\nwn1.add_control(\"Pump1_closed\", line)\\n\n```\n\n----------------------------------------\n\nTITLE: Adding a Time-Varying Leak to a Node in WNTR (Python)\nDESCRIPTION: This snippet illustrates how to add a leak to a specific node ('123') in a WNTR water network model. The `add_leak` method is called on the node object, specifying the leak area (in m^2), the simulation time at which the leak starts (2 hours), and the time at which it ends (12 hours). This functionality is specific to the WNTRSimulator and uses a built-in leak model.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/hydraulics.rst#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\n>>> node = wn.get_node('123')           \n>>> node.add_leak(wn, area=0.05, start_time=2*3600, end_time=12*3600)\n```\n\n----------------------------------------\n\nTITLE: Creating WaterNetworkModel Directly from INP File in Python\nDESCRIPTION: Shows an alternative method to create a `WaterNetworkModel` directly by passing the EPANET INP file path ('networks/Net3.inp') to the class constructor. This approach is noted as being equivalent to using the `wntr.network.read_inpfile` function. Requires the WNTR library. Marked with `# doctest: +SKIP`.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/model_io.rst#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n>>> wn = wntr.network.WaterNetworkModel('networks/Net3.inp') # doctest: +SKIP\n```\n\n----------------------------------------\n\nTITLE: Calculating Junction and Population Impacts from Pipe Break Results in Python\nDESCRIPTION: Processes the `analysis_results` dictionary generated by the pipe break simulations. For each pipe break that resulted in impacted junctions (i.e., not None), it calculates the total number of impacted junctions and the sum of the population associated with those junctions. Results are stored in `num_junctions_impacted` and `num_people_impacted` dictionaries.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/pipe_break_tutorial.ipynb#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n# Save junction and population impact results to dictionary\nnum_junctions_impacted = {}\nnum_people_impacted = {}\nfor pipe_name, impacted_junctions in analysis_results.items():\n    if impacted_junctions is not None:\n        num_junctions_impacted[pipe_name] = len(impacted_junctions)\n        num_people_impacted[pipe_name] = population[impacted_junctions].sum()\n```\n\n----------------------------------------\n\nTITLE: Identifying Controls Requiring Specific Pipe in Python\nDESCRIPTION: Provides an example of iterating through all controls in a WNTR `WaterNetworkModel` using `wn.controls()`. It identifies and prints controls that depend on a specific network link (pipe '330'), retrieved using `wn.get_link()`. Assumes `wn` is a WaterNetworkModel instance containing controls and a link named '330'.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/controls.rst#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\n>>> pipe = wn.get_link('330')\n>>> for name, control in wn.controls():\n...     if pipe in control.requires():\n...         print(name, control)\ncontrol 17 IF TANK 1 LEVEL BELOW 5.21208 THEN PIPE 330 STATUS IS CLOSED PRIORITY 3\ncontrol 18 IF TANK 1 LEVEL ABOVE 5.821680000000001 THEN PIPE 330 STATUS IS OPEN PRIORITY 3\n```\n\n----------------------------------------\n\nTITLE: Computing Reservoir Proximity for Pump Flow Direction with NetworkX and WNTR - Python\nDESCRIPTION: Calculates the shortest undirected network distance from nodes to the reservoir using multi_source_dijkstra_path_length, facilitating pump direction assignment based on proximity. Requires a WNTR network model, length attributes, and NetworkX; expects single or multiple reservoirs. Outputs node-to-reservoir path lengths for use in later topology edits.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/model_development_tutorial.ipynb#_snippet_29\n\nLANGUAGE: python\nCODE:\n```\n# Compute distance to the nearest reservoirs (there is only 1 reservoir in ky4)\\nlength = wn2.query_link_attribute('length')\\nG = wn2.to_graph(link_weight = length)\\nuG = G.to_undirected()\\ndistance_to_reservoir = nx.multi_source_dijkstra_path_length(uG, wn2.reservoir_name_list, weight='weight')\n```\n\n----------------------------------------\n\nTITLE: Adding Controls to the WNTR Network via EPANET String Syntax - Python\nDESCRIPTION: Adds operational controls to the water network model in EPANET text format, specifying actions (open/close) on pumps when certain nodal conditions (e.g., tank level) are met. Requires a valid node/link name and model loaded in wntr. Values and strings must comply with EPANET's control syntax.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/model_development_tutorial.ipynb#_snippet_32\n\nLANGUAGE: python\nCODE:\n```\nline = \\\"LINK ~@Pump-1 OPEN IF NODE T-3 BELOW  27.6606\\\"  # 90.75 ft\\nwn2.add_control(\\\"Pump1_open\\\", line)\\n\\nline = \\\"LINK ~@Pump-1 CLOSED IF NODE T-3 ABOVE  32.2326\\\"  # 105.75 ft\\nwn2.add_control(\\\"Pump1_closed\\\", line)\n```\n\n----------------------------------------\n\nTITLE: Modifying Demand Base Value and Assigning New Pattern (Python)\nDESCRIPTION: Updates the base demand value and changes its pattern for a junction demand. The new pattern 'New' is created and assigned. The demand_timeseries_list is printed to confirm modifications.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/basics_tutorial.ipynb#_snippet_25\n\nLANGUAGE: python\nCODE:\n```\n# Modify the base value of the demand\\njunction.demand_timeseries_list[0].base_value = 0.005\\n\\n# Add a new pattern to the model\\nwn.add_pattern('New', [1,1,1,0,0,0,1,0,0.5,0.5,0.5,1])\\n\\n# Use the new pattern to modify the junction demand\\njunction.demand_timeseries_list[0].pattern_name = \"New\"\\nprint(junction.demand_timeseries_list)\n```\n\n----------------------------------------\n\nTITLE: Exporting and Importing WaterNetworkModel as GeoJSON - Python\nDESCRIPTION: Demonstrates writing WaterNetworkModel network components as GeoJSON files and reconstructing the model from them using wntr.network.write_geojson and wntr.network.read_geojson. A dictionary maps network elements to their respective file paths. Useful for GIS interoperability; some model attributes such as controls may need manual restoration after import.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/basics_tutorial.ipynb#_snippet_46\n\nLANGUAGE: python\nCODE:\n```\n# Create GeoJSON files from the WaterNetworkModel\\nwntr.network.write_geojson(wn, 'Net3')\\n\\n# Create a WaterNetworkModel from GeoJSON files\\ngeojson_files = {'junctions': 'Net3_junctions.geojson',\\n                 'tanks': 'Net3_tanks.geojson',\\n                 'reservoirs': 'Net3_reservoirs.geojson',\\n                 'pipes': 'Net3_pipes.geojson',\\n                 'pumps': 'Net3_pumps.geojson'}\\nwn2 = wntr.network.read_geojson(geojson_files)\n```\n\n----------------------------------------\n\nTITLE: Assigning Elevation to Junctions using a Raster with WNTR - Python\nDESCRIPTION: Assigns elevation values to water network junctions by sampling elevations from raster data using wntr.gis.sample_raster. This integrates topographical data (from elevation_data_file) into the network model, a step requiring rasterio or similar for raster support and geo-enabled junction data. Output is a junctions dataframe with added 'elevation' values.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/model_development_tutorial.ipynb#_snippet_23\n\nLANGUAGE: python\nCODE:\n```\njunction_elevations = wntr.gis.sample_raster(junctions, elevation_data_file)\\njunctions[\\\"elevation\\\"] = junction_elevations\\nprint(junctions.head())\n```\n\n----------------------------------------\n\nTITLE: Loading and Accessing Reaction Models Using WNTR MsxLibrary (Python)\nDESCRIPTION: This example demonstrates how to use the WNTR Python package to load water quality reaction models from its MsxLibrary. It covers importing the relevant library, initializing the MsxLibrary object, listing the available reaction models, retrieving the 'lead_ppm' model, and displaying it. Dependencies include the WNTR package with access to the 'wntr.library.msx' module. The main parameters involve the library path (default or user-specified) and model name. The input is the desired model name; the output is an MsxModel object representing the specified model. This code must be run in an environment with WNTR installed.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/libraries.rst#_snippet_14\n\nLANGUAGE: python\nCODE:\n```\n>>> import wntr.library.msx\n>>> reaction_library = wntr.library.msx.MsxLibrary()\n\n>>> print(reaction_library.model_name_list())  # doctest: +SKIP\n['arsenic_chloramine', 'batch_chloramine_decay', 'lead_ppm', 'nicotine', 'nicotine_ri']\n\n>>> lead_ppm = reaction_library.get_model(\"lead_ppm\")\n>>> print(lead_ppm)\nMsxModel(name='lead_ppm')\n```\n\n----------------------------------------\n\nTITLE: Accessing and Modifying WNTR Model Options\nDESCRIPTION: This snippet shows how to access and modify simulation options within a `WaterNetworkModel`. It first accesses the `options` attribute (output skipped by `doctest: +SKIP`) which contains categories like time, hydraulics, etc., and then modifies the simulation duration under the time options.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/waternetworkmodel.rst#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n>>> wn.options # doctest: +SKIP\nTime options:\n  duration            : 604800              \n  hydraulic_timestep  : 900                 \n  quality_timestep    : 900                 \n  rule_timestep       : 360.0               \n  pattern_timestep    : 3600\n...\n>>> wn.options.time.duration = 10*3600\n```\n\n----------------------------------------\n\nTITLE: Creating a Water Network Model from an INP File using WNTR in Python\nDESCRIPTION: Specifies the file path to the EPANET INP file ('networks/Net3.inp') representing the water distribution network. It then uses WNTR's `WaterNetworkModel` class to load and create a network model object (`wn`). Finally, it calculates the population associated with each junction in the network using the `wntr.metrics.population` function.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/fire_flow_tutorial.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n# Identify file path to inp file\ninp_file = \"networks/Net3.inp\"\n\n# Create water network model \nwn = wntr.network.WaterNetworkModel(inp_file)\n\n# Calculate population per junction\npopulation = wntr.metrics.population(wn)\n```\n\n----------------------------------------\n\nTITLE: Plotting Time Series of Tank Levels from Simulation Results - Python\nDESCRIPTION: Extracts pressure results at tank nodes and plots them as a time series, using the tank_name_list from the WaterNetworkModel. The resulting figure visualizes tank levels (in meters) over time.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/basics_tutorial.ipynb#_snippet_59\n\nLANGUAGE: python\nCODE:\n```\n# Plot timeseries of tank levels\\ntank_levels = results_EPANET.node['pressure'].loc[:,wn.tank_name_list]\\nax = tank_levels.plot(title='Tank level')\\nax.set_xlabel('Time (s)')\\nax.set_ylabel('Tank Level (m)')\n```\n\n----------------------------------------\n\nTITLE: Setting Global Hydraulic Options for PDD in WNTR (Python)\nDESCRIPTION: This snippet demonstrates how to set global hydraulic options for a Pressure Dependent Demand (PDD) simulation using the WNTR library. It configures the required pressure (Pf), minimum pressure (P0), and the pressure exponent (gamma) that govern the relationship between pressure and actual demand delivered. These values apply network-wide unless overridden at specific junctions.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/hydraulics.rst#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n>>> wn.options.hydraulic.required_pressure = 21.097 # 30 psi = 21.097 m\n>>> wn.options.hydraulic.minimum_pressure  = 3.516 # 5 psi = 3.516 m\n>>> wn.options.hydraulic.pressure_exponent = 0.55\n```\n\n----------------------------------------\n\nTITLE: Adding a Pipe Leak via Split and Leak Node with WNTR in Python\nDESCRIPTION: This snippet illustrates how to model a pipe leak by splitting a pipe and adding a leak node in the WNTR WaterNetworkModel. It assumes a pre-existing network model loaded into memory. The 'split_pipe' function divides the specified pipe, and a leak is then added at the new node with parameters for area and time window. Dependencies include the wntr library and an initialized network. The method modifies the network in-place, allowing for time-controlled leaks to be included in simulations.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/disaster_models.rst#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n>>> wn = wntr.morph.split_pipe(wn, '123', '123_B', '123_leak_node')\\n>>> leak_node = wn.get_node('123_leak_node')           \\n>>> leak_node.add_leak(wn, area=0.05, start_time=2*3600, end_time=12*3600)\n```\n\n----------------------------------------\n\nTITLE: Simulating Individual Pipe Breaks and Identifying Impacted Junctions in Python\nDESCRIPTION: Iterates through the selected pipes of interest. For each pipe, it reloads the network model, sets PDD hydraulic options, defines a control to close the pipe at `start_time`, and runs a WNTR simulation. It uses a try-except block to handle potential simulation failures. If successful, it identifies junctions experiencing pressure below the minimum threshold (`minimum_pressure`) during the break, excluding those already below minimum pressure under normal conditions. Results (list of impacted junctions or None if failed) are stored in `analysis_results`.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/pipe_break_tutorial.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n# Create dictionary to save results\nanalysis_results = {} \n\n# Simulate pipe break (simulated as pipe closures) for each pipe\nfor pipe_name in pipes_of_interest.index: \n    wn = wntr.network.WaterNetworkModel(inp_file)\n    wn.options.hydraulic.demand_model = 'PDD'    \n    wn.options.time.duration = total_duration\n    wn.options.hydraulic.minimum_pressure = minimum_pressure\n    wn.options.hydraulic.required_pressure = required_pressure\n    \n    # Create pipe closure control and apply to pipe of interest\n    pipe = wn.get_link(pipe_name)\n    act = wntr.network.controls.ControlAction(pipe, 'status', 0)\n    cond = wntr.network.controls.SimTimeCondition(wn, 'Above', start_time)\n    ctrl = wntr.network.controls.Control(cond, act)\n    wn.add_control('close pipe ' + pipe_name, ctrl)\n    \n    try:\n        # Simulate hydraulics\n        sim = wntr.sim.WNTRSimulator(wn) \n        sim_results = sim.run_sim()\n \n        # Using pressure results, identify impacted junctions\n        sim_pressure = sim_results.node['pressure'].loc[start_time::, nzd_junct]\n        sim_pressure_below_pmin = sim_pressure.columns[(sim_pressure < minimum_pressure).any()]\n        impacted_junctions = set(sim_pressure_below_pmin) - set(normal_pressure_below_pmin)\n        impacted_junctions = list(impacted_junctions)\n        \n    except Exception as e:\n        # Identify failed simulations and the reason\n        impacted_junctions = None\n        print(pipe_name, ' Failed:', e)\n\n    finally:\n        # Save simulation results\n        analysis_results[pipe_name] = impacted_junctions\n```\n\n----------------------------------------\n\nTITLE: Changing the Diameter of a Pipe in WNTR (Python)\nDESCRIPTION: Reads and sets the diameter of the selected pipe object, printing both original and changed values. Pipe diameter must be specified in meters and affects simulation hydraulics.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/basics_tutorial.ipynb#_snippet_17\n\nLANGUAGE: python\nCODE:\n```\n# Change the diameter of a pipe\\nprint(\"Original diameter\", pipe.diameter)\\npipe.diameter = 10\\nprint(\"New diameter\", pipe.diameter)\n```\n\n----------------------------------------\n\nTITLE: Resetting Initial Conditions in a WNTR Model (Python)\nDESCRIPTION: This snippet shows how to reset the initial conditions of an existing WNTR water network model (`wn`) back to their original state as defined in the input file or at creation. This includes resetting simulation time, tank heads, reservoir heads, and the status of pipes, pumps, and valves. It's useful for running multiple simulations from the same starting point without reloading the entire model, especially when only initial conditions need changing.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/hydraulics.rst#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\n>>> wn.reset_initial_values()\n```\n\n----------------------------------------\n\nTITLE: Plotting Water Network Components from GeoDataFrames using Matplotlib\nDESCRIPTION: Creates a plot of the water network using `matplotlib` and the GeoDataFrames stored in `wn_gis`. It plots pipes colored by diameter, reservoirs (black squares), tanks (red circles), pumps (blue markers on centroids), and valves (cyan markers on centroids). The code also includes options to turn off axis display and potentially set custom zoom limits using `zoom_coords`.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/landslide_tutorial.ipynb#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\n# Use the GIS data to create a figure of the network\nfig, ax = plt.subplots(figsize=(5,5))\nax = wn_gis.pipes.plot(column='diameter', linewidth=1, label='pipes', alpha=0.8, ax=ax, zorder=1)\nax = wn_gis.reservoirs.plot(color='k', marker='s', markersize=60, label='reservoirs', ax=ax)\nax = wn_gis.tanks.plot(color='r', markersize=20, label='tanks', ax=ax)\nax = wn_gis.pumps.centroid.plot(color='b', markersize=20, label='pumps', ax=ax)\nax = wn_gis.valves.centroid.plot(color='c', markersize=20, label='valves', ax=ax)\ntmp = ax.axis('off')\n# Comment/uncomment the following 2 lines to change the zoom on the network graphic\n#tmp = ax.set_xlim(zoom_coords[0])\n#tmp = ax.set_ylim(zoom_coords[1])\ntmp = plt.legend()\n```\n\n----------------------------------------\n\nTITLE: Plotting Water Service Availability of Impacted Junctions in Python\nDESCRIPTION: This code uses `matplotlib` and `geopandas` (implied by `.plot` on `wn_gis`) to visualize Water Service Availability (WSA) for impacted junctions across multiple scenarios. It generates a 2x3 grid of subplots using `plt.subplots`. For each scenario, it plots the pipe network in gray as a background layer, and if impacted junctions exist for that scenario (identified in the previous step), it plots those junctions, coloring them based on their WSA values using a Red-Yellow-Green colormap (`cmap='RdYlGn'`) with values ranging from 0 to 1 (`vmin=0, vmax=1`). Each subplot receives a title indicating the scenario, and its axes are turned off. Depends on `matplotlib.pyplot` (as `plt`), `geopandas`, the previously calculated `impacted_junctions` dictionary, the `wsa_results` DataFrame, and a `wn_gis` object containing network geometry (pipes and junctions).\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/landslide_tutorial.ipynb#_snippet_42\n\nLANGUAGE: python\nCODE:\n```\n# Plot WSA of impacted junctions for each scenario\nfig, axes = plt.subplots(2,3, figsize=(15,10))\naxes = axes.flatten()\n\nfor i, scenario in enumerate(wsa_results.columns):\n    j = impacted_junctions[scenario]\n    wn_gis.pipes.plot(color='gray', linewidth=1, alpha=0.5, ax=axes[i]) # pipes\n    if len(j) > 0:\n        wn_gis.junctions.loc[j,:].plot(column=scenario, cmap='RdYlGn', vmin=0, vmax=1, legend=True, ax=axes[i]) # junction wsa\n    tmp = axes[i].set_title('WSA '+scenario)\n    tmp = axes[i].axis('off')\n    if i >= 6: # axes is defined to have 6 subplots\n        break\n```\n\n----------------------------------------\n\nTITLE: Adding a Pipe to WaterNetworkModel in WNTR (Python)\nDESCRIPTION: Creates a new pipe named 'new_pipe' with specified endpoints, geometry, and hydraulic properties, then prints the updated pipe name list. All referenced nodes must exist prior to running.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/basics_tutorial.ipynb#_snippet_18\n\nLANGUAGE: python\nCODE:\n```\n# Add a pipe to the WaterNetworkModel\\nwn.add_pipe(name=\"new_pipe\", start_node_name=\"10\", end_node_name=\"123\", length=304.8, diameter=0.3048, roughness=100, minor_loss=0.0, initial_status='OPEN', check_valve=False)\\nprint(wn.pipe_name_list)\n```\n\n----------------------------------------\n\nTITLE: Intersecting Landslide Scenarios with Pipes using WNTR GIS Tools\nDESCRIPTION: Uses the `wntr.gis.intersect()` function to perform a spatial intersection between the buffered landslide scenario polygons (`A = landslide_scenarios`) and the water network pipes (`B = wn_gis.pipes`). The `B_value = 'length'` argument indicates that the 'length' attribute of the pipes should be included in the intersection results, potentially allowing calculation of the length of pipe intersecting each landslide zone. The result (`landslide_intersect`) likely contains information linking each landslide scenario to the pipes it intersects.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/landslide_tutorial.ipynb#_snippet_18\n\nLANGUAGE: python\nCODE:\n```\n# Use the intersect function to determine pipes and pipe length that intersects each landslide\nA = landslide_scenarios\nB = wn_gis.pipes\nB_value = 'length'\nlandslide_intersect = wntr.gis.intersect(A, B, B_value)\n```\n\n----------------------------------------\n\nTITLE: Sampling Raster Values at Junction Locations using WNTR GIS in Python\nDESCRIPTION: This snippet associates storm surge inundation levels from the raster file (`raster_path`) with the network junctions. It uses the `wntr.gis.sample_raster` function, passing the junctions GeoDataFrame (`wn_gis.junctions`) and the raster path. The sampled inundation values are added as a new column named 'inundation_level' to the `junctions` GeoDataFrame. The head of this new column is printed.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/salt_water_intrusion_tutorial.ipynb#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\njunctions = wn_gis.junctions\njunctions['inundation_level'] = wntr.gis.sample_raster(junctions, raster_path, bands=1)\nprint(junctions['inundation_level'].head())\n```\n\n----------------------------------------\n\nTITLE: Animating Water Network Attributes Over Time - Python\nDESCRIPTION: Creates an animated visualization of water age in the network using pandas DataFrames for node attributes over time, setting node_range to map values as color. Relies on setting network quality options, executing a simulation, and transforming output to hours. Produces animation output that can be saved or displayed. This requires WNTR, pandas, and matplotlib, as well as a configured network model.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/graphics.rst#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n>>> wn.options.quality.parameter = 'AGE'\n>>> sim = wntr.sim.EpanetSimulator(wn)\n>>> results = sim.run_sim()\n>>> water_age = results.node['quality']/3600 # convert seconds to hours\n>>> anim = wntr.graphics.network_animation(wn, node_attribute=water_age, \n...     node_range=[0,24]) # doctest: +SKIP\n```\n\n----------------------------------------\n\nTITLE: Adding a Junction to WaterNetworkModel in WNTR (Python)\nDESCRIPTION: Adds a new junction named 'new_junction' to the water network model with default demand and elevation parameters. The snippet then prints the updated list of junctions. Additional parameters can be tailored for specific network requirements.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/basics_tutorial.ipynb#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\n# Add a junction to the WaterNetworkModel\\nwn.add_junction('new_junction', base_demand=0.0, demand_pattern=None, elevation=0.0, coordinates=None, demand_category=None)\\nprint(wn.junction_name_list)\n```\n\n----------------------------------------\n\nTITLE: Plotting WNTR Simulation Results on Network Map in Python\nDESCRIPTION: This snippet demonstrates how to visualize simulation results on the network graph. It first extracts the pressure results for all nodes at a specific time step (5 hours, converted to seconds) from the `results` object. Then, it uses `wntr.graphics.plot_network` to display the network, coloring the nodes based on the extracted pressure values, adjusting node size, and adding a title. Depends on a `WaterNetworkModel` object (`wn`) and a simulation `results` object.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/getting_started_tutorial.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\npressure_at_5hr = results.node['pressure'].loc[5*3600, :]\nax = wntr.graphics.plot_network(wn, node_attribute=pressure_at_5hr, node_size=30, title='Pressure at 5 hours')\n```\n\n----------------------------------------\n\nTITLE: Initializing WaterNetworkModel from EPANET INP File - Python\nDESCRIPTION: Creates a WaterNetworkModel by loading an EPANET INP file using wntr.network.WaterNetworkModel. Requires WNTR and a valid .inp file path. The created object includes the full network ready for further manipulation or simulation.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/basics_tutorial.ipynb#_snippet_40\n\nLANGUAGE: python\nCODE:\n```\n# Create a WaterNetworkModel from an EPANET INP file\\nwn = wntr.network.WaterNetworkModel('networks/Net3.inp')\n```\n\n----------------------------------------\n\nTITLE: Initializing WaterNetworkModel from EPANET INP File - Python\nDESCRIPTION: Creates a WNTR WaterNetworkModel instance by reading an EPANET .inp file that describes network topology and properties. This forms the ground-truth or 'base' model for subsequent comparisons. Dependency: wntr.network.WaterNetworkModel; requires a valid INP file path as input.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/model_development_tutorial.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nwn0 = wntr.network.WaterNetworkModel(\"networks/ky4.inp\")\\n\n```\n\n----------------------------------------\n\nTITLE: Calculating and Visualizing Population Impact using WNTR - Python\nDESCRIPTION: This snippet computes the number of people impacted by water service outages using WNTR's metrics functions, replacing missing values in input data with zeros for population impacted calculation, then visualizes results using Matplotlib. It requires WNTR, Numpy, and Matplotlib as dependencies. 'population', 'wsa', and 'wsa_wrepair' are core inputs, with the results shown both with and without repair scenarios; outputs are time series plots with shared y-axis constraints, and x-axis labeled by time.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/earthquake_tutorial.ipynb#_snippet_15\n\nLANGUAGE: python\nCODE:\n```\n# Note that water service availability of NaN is replaced with 0 for the population impacted calculation\npopulation = wntr.metrics.population(wn)\npeople_impacted = wntr.metrics.population_impacted(population, wsa.fillna(0), np.less, 0.8)\npeople_impacted_wrepair = wntr.metrics.population_impacted(population, wsa_wrepair.fillna(0), np.less, 0.8)\n\n# Plot population impacted\nfig, axarr = plt.subplots(1,2,figsize=(14,4))\nax = axarr[0]\npeople_impacted.plot(ax=ax, legend=False)\nax.set_ylim(ymax=35000)\nax.set_xlabel('Time (hr)')\nax.set_ylabel('Population impacted')\nax.set_title('Without Repair')\nax = axarr[1]\npeople_impacted_wrepair.plot(ax=ax, legend=False)\nax.set_ylim(ymax=35000)\nax.set_xlabel('Time (hr)')\nax.set_ylabel('Population impacted')\nax.set_title('With Repair')\n```\n\n----------------------------------------\n\nTITLE: Running a Baseline Hydraulic Simulation with WNTR - Python\nDESCRIPTION: Runs a hydraulic simulation of the water network using default (undamaged) conditions, storing the results for analysis. Depends on an initialized network model and WNTR installed. Output is a results object suitable for querying simulated pressures, flows, etc.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/landslide_tutorial.ipynb#_snippet_26\n\nLANGUAGE: python\nCODE:\n```\n# Run a baseline simulation, with no landslide or damage.  \nwn = model_setup(inp_file)\nsim = wntr.sim.EpanetSimulator(wn)\nbaseline_results = sim.run_sim()\n```\n\n----------------------------------------\n\nTITLE: Adding Time-Varying Demand Patterns and Assigning Demands in WNTR - Python\nDESCRIPTION: Defines a demand pattern using a list of multipliers and adds it to the model with wn2.add_pattern, then iterates through buildings to assign base demand and pattern to the snapped junctions. Essential for representing consumer demand variability over a typical day. Depends on buildings dataframe with demand assignments and the WNTR model.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/model_development_tutorial.ipynb#_snippet_33\n\nLANGUAGE: python\nCODE:\n```\nmultipliers = [\\n    0.33, 0.25, 0.209, 0.209, 0.259, 0.36,\\n    0.529, 0.91, 1.2, 1.299, 1.34, 1.34,\\n    1.32, 1.269, 1.25, 1.25, 1.279, 1.37,\\n    1.519, 1.7, 1.75, 1.669, 0.899, 0.479,\\n]\\ndefault_pattern_name = wn2.options.hydraulic.pattern\\nwn2.add_pattern(default_pattern_name, multipliers)\\n\\n# Add building demands to snapped junction\\ncategory = None\\nfor i, row in buildings.iterrows():\\n    junction_name = buildings.loc[i, \\\"junction\\\"]\\n    if junction_name is None:\\n        continue\\n    base_demand = buildings.loc[i, \\\"base_demand\\\"]\\n    junction = wn2.get_node(junction_name)\\n    junction.demand_timeseries_list.append((base_demand, default_pattern_name, category))\n```\n\n----------------------------------------\n\nTITLE: Selecting Demand Model for WNTRSimulator Hydraulics - Python\nDESCRIPTION: This snippet repeats the process of demand model selection but in the context of the WNTRSimulator. Setting the 'demand_model' attribute to 'DD' or 'PDD' configures the simulator for demand-driven or pressure dependent mode. This is required before running simulations with WNTRSimulator and uses the WaterNetworkModel's options API.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/hydraulics.rst#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n>>> wn.options.hydraulic.demand_model = 'DD'  \n>>> wn.options.hydraulic.demand_model = 'PDD'\n```\n\n----------------------------------------\n\nTITLE: Defining and Plotting Fragility Curves Using Log-Normal States - Python\nDESCRIPTION: Creates a FragilityCurve instance, adds two damage states (Minor and Major) using log-normal distributions, and visualizes the probability curves. Requires wntr.scenario.FragilityCurve and scipy.stats.lognorm. Output is a plot showing probability of damage state exceedance as a function of ground motion or other hazard. Used for risk assessment.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/basics_tutorial.ipynb#_snippet_73\n\nLANGUAGE: python\nCODE:\n```\nFC = wntr.scenario.FragilityCurve()\\nFC.add_state('Minor', 1, {'Default': lognorm(0.5,scale=0.3)})\\nFC.add_state('Major', 2, {'Default': lognorm(0.5,scale=0.7)})\\nax = wntr.graphics.plot_fragility_curve(FC, xlabel='Peak Ground Acceleration (g)')\n```\n\n----------------------------------------\n\nTITLE: Selecting Demand Model for Simulation with WNTR - Python\nDESCRIPTION: This snippet shows how to specify either a demand-driven (DD) or pressure dependent demand (PDD) hydraulic simulation by setting the demand_model option via the WaterNetworkModel's options attribute. This configuration step is necessary before running simulations and is consistent for both simulators. It operates on the WaterNetworkModel object ('wn') previously initialized, and does not return a value.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/hydraulics.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n>>> import wntr # doctest: +SKIP\n>>> wn = wntr.network.WaterNetworkModel('networks/Net3.inp') # doctest: +SKIP\n>>> wn.options.hydraulic.demand_model = 'DD'  \n>>> wn.options.hydraulic.demand_model = 'PDD'\n```\n\n----------------------------------------\n\nTITLE: Adding a Source Pattern and Source - WNTR - Python\nDESCRIPTION: This snippet demonstrates how to add a source pattern and a chemical source to the WaterNetworkModel using WNTR. It defines a binary pattern for injection timing, registers the pattern in the model, and adds a source ('Source') at node '121' of type 'SETPOINT' with strength 1000 and references the pattern. Dependencies include the wntr library and a model with defined options. Key parameters are pattern timing and source attributes. This configures the network for subsequent chemical quality analysis.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/waterquality.rst#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n>>> source_pattern = wntr.network.elements.Pattern.binary_pattern('SourcePattern', \n...       start_time=2*3600, end_time=15*3600, duration=wn.options.time.duration,\n...       step_size=wn.options.time.pattern_timestep)\n>>> wn.add_pattern('SourcePattern', source_pattern)\n>>> wn.add_source('Source', '121', 'SETPOINT', 1000, 'SourcePattern')\n```\n\n----------------------------------------\n\nTITLE: Simulating Hydraulics with Partial Leak Repairs using WNTR (Python)\nDESCRIPTION: Resets the water network model (`wn`) to its initial conditions using `reset_initial_values()`. Re-identifies the largest leaks based on total volume (this repeats the logic from a previous step). Specifies the number of leaks to fix. Iterates through the selected leak nodes (`leaks_to_fix`), retrieves the existing leak area, removes the original continuous leak using `remove_leak`, and adds a new leak using `add_leak` that has the same area but now includes an `end_time` corresponding to `leak_repair_time`. Finally, it runs the hydraulic simulation again using the same `WNTRSimulator` object (`sim`) to obtain results reflecting the partial repairs.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/earthquake_tutorial.ipynb#_snippet_12\n\nLANGUAGE: python\nCODE:\n```\n# Reset to initial conditions\nwn.reset_initial_values()\n\n# Identify largest leaks\nleaked_demand = results.node['leak_demand']\nleaked_sum = leaked_demand.sum()\nleaked_sum.sort_values(ascending=False, inplace=True)\n\nnumber_of_pipes_to_repair = 4\nleaks_to_fix = leaked_sum[0:number_of_pipes_to_repair]\n\n# Model a partial fixed leak\nfor leak_name in leaks_to_fix.index:\n    node = wn.get_node(leak_name)\n    leak_area = node.leak_area\n    node.remove_leak(wn)\n    node.add_leak(wn, area=leak_area, start_time=leak_start_time, end_time=leak_repair_time)\n\n# Simulate partial repairs\nresults_wrepair = sim.run_sim()\n```\n\n----------------------------------------\n\nTITLE: Removing a Pipe from WaterNetworkModel in WNTR (Python)\nDESCRIPTION: Removes a pipe ('new_pipe') from the water network and prints the updated pipe list. Ensure the pipe exists and is not in use elsewhere in the model.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/basics_tutorial.ipynb#_snippet_19\n\nLANGUAGE: python\nCODE:\n```\n# Remove a pipe from the WaterNetworkModel\\nwn.remove_link(\"new_pipe\")\\nprint(wn.pipe_name_list)\n```\n\n----------------------------------------\n\nTITLE: Sampling Raster Elevations for Junctions using WNTR in Python\nDESCRIPTION: This snippet demonstrates how to sample elevation data for network junctions from a GeoTIFF raster file using the `wntr.gis.sample_raster` function. It assumes a WNTR GIS object `wn_gis` exists and contains junction data. Requires `geopandas` and `rasterio` libraries. The output is a pandas Series containing elevation values indexed by junction names.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/gis.rst#_snippet_36\n\nLANGUAGE: python\nCODE:\n```\n>>> elevation_data_path = 'data/Net1_elevation_data.tif' # doctest: +SKIP\n>>> junctions = wn_gis.junctions\n>>> junction_elevations = wntr.gis.sample_raster(junctions, elevation_data_path)\n>>> print(junction_elevations)\nname\n10    1400.0\n11    2100.0\n12    3500.0\n13    4900.0\n21    1200.0\n22    2000.0\n23    2800.0\n31     300.0\n32     500.0\ndtype: float64\n```\n\n----------------------------------------\n\nTITLE: Computing Network Entropy - WNTR - Python\nDESCRIPTION: Measures network redundancy and reliability by calculating entropy metrics from a time-slice of flowrate data using a graph representation of the network. Requires flowrate data for a specific time (in seconds), and transforms it into a NetworkX graph for entropy analysis. Output is a tuple with entropy value for nodes and system-wide entropy.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/resilience.rst#_snippet_16\n\nLANGUAGE: python\nCODE:\n```\n>>> flowrate = results.link['flowrate'].loc[12*3600,:]\n>>> G = wn.to_graph(link_weight=flowrate)\n>>> entropy, system_entropy = wntr.metrics.entropy(G)\n```\n\n----------------------------------------\n\nTITLE: Calculating Volume of Contaminant Consumed - WNTR - Python\nDESCRIPTION: Determines the total volume of water containing contaminant above a detection limit consumed at each node and time. Requires previous calculation of demand, quality, and a pre-defined detection threshold (e.g., 750). Outputs a DataFrame or series indicating volumes exceeding the limit.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/resilience.rst#_snippet_21\n\nLANGUAGE: python\nCODE:\n```\n>>> detection_limit = 750\n>>> VC = wntr.metrics.volume_contaminant_consumed(demand, quality, \n...     detection_limit)\n```\n\n----------------------------------------\n\nTITLE: Intersecting Landslides with Pipes and Extracting Confidence - Python\nDESCRIPTION: This snippet computes the intersection between water pipes and landslide polygons, also attaching a 'Confidence_Ranking' attribute to each intersection. Uses WNTR's GIS support and expects GIS layers and an attribute string, returning a DataFrame suitable for statistical summary. Outputs are sorted by number of intersections for inspection.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/landslide_tutorial.ipynb#_snippet_22\n\nLANGUAGE: python\nCODE:\n```\n# Use the intersect function to determine landslides and landslide confidence ranking that intersects each pipe\nA = wn_gis.pipes\nB = landslide_scenarios\nB_value = 'Confidence_Ranking'\npipe_intersect = wntr.gis.intersect(A, B, B_value)\n\n# Print results in order of descending number of intersections.\npipe_intersect.sort_values('n', ascending=False).head()\n```\n\n----------------------------------------\n\nTITLE: Initializing WNTR MSX Model for Arsenic/Chloramine Reactions in Python\nDESCRIPTION: This Python code snippet demonstrates the creation and configuration of a WNTR Multi-Species eXtension (MSX) model named 'arsenic_chloramine'. It defines bulk and wall species (AS3, AS5, AStot, AS5s, NH2CL), reaction constants (Ka, Kb, K1, K2, Smax), a derived term (Ks), and reaction expressions (rate, equilibrium, formula) for both pipe and tank components, implementing the arsenic oxidation and adsorption model described previously. Finally, it configures MSX solver options like area units, rate units, and tolerances.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/advancedsim.rst#_snippet_11\n\nLANGUAGE: python\nCODE:\n```\n>>> msx = wntr.msx.MsxModel()\n>>> msx.name = \"arsenic_chloramine\"\n>>> msx.title = \"Arsenic Oxidation/Adsorption Example\"\n\n>>> AS3 = msx.add_species(name=\"AS3\", species_type=\"BULK\", units=\"UG\", note=\"Dissolved arsenite\")\n>>> AS5 = msx.add_species(name=\"AS5\", species_type=\"BULK\", units=\"UG\", note=\"Dissolved arsenate\")\n>>> AStot = msx.add_species(name=\"AStot\", species_type=\"BULK\", units=\"UG\", \n...     note=\"Total dissolved arsenic\")\n>>> AS5s = msx.add_species(name=\"AS5s\", species_type=\"WALL\", units=\"UG\", note=\"Adsorbed arsenate\")\n>>> NH2CL = msx.add_species(name=\"NH2CL\", species_type=\"BULK\", units=\"MG\", note=\"Monochloramine\")\n\n>>> Ka = msx.add_constant(\"Ka\", 10.0, units=\"1 / (MG * HR)\", note=\"Arsenite oxidation rate coeff\")\n>>> Kb = msx.add_constant(\"Kb\", 0.1, units=\"1 / HR\", note=\"Monochloramine decay rate coeff\")\n>>> K1 = msx.add_constant(\"K1\", 5.0, units=\"M^3 / (UG * HR)\", note=\"Arsenate adsorption coeff\")\n>>> K2 = msx.add_constant(\"K2\", 1.0, units=\"1 / HR\", note=\"Arsenate desorption coeff\")\n>>> Smax = msx.add_constant(\"Smax\", 50.0, units=\"UG / M^2\", note=\"Arsenate adsorption limit\")\n\n>>> Ks = msx.add_term(name=\"Ks\", expression=\"K1/K2\", note=\"Equil. adsorption coeff\")\n\n>>> _ = msx.add_reaction(species_name=\"AS3\", reaction_type=\"pipes\", expression_type=\"rate\", \n...     expression=\"-Ka*AS3*NH2CL\", note=\"Arsenite oxidation\")\n>>> _ = msx.add_reaction(\"AS5\", \"pipes\", \"rate\", \"Ka*AS3*NH2CL - Av*(K1*(Smax-AS5s)*AS5 - K2*AS5s)\", \n...     note=\"Arsenate production less adsorption\")\n>>> _ = msx.add_reaction(\n...     species_name=\"NH2CL\", reaction_type=\"pipes\", expression_type=\"rate\", expression=\"-Kb*NH2CL\", \n...     note=\"Monochloramine decay\")\n>>> _ = msx.add_reaction(\"AS5s\", \"pipe\", \"equil\", \"Ks*Smax*AS5/(1+Ks*AS5) - AS5s\", \n...     note=\"Arsenate adsorption\")\n>>> _ = msx.add_reaction(species_name=\"AStot\", reaction_type=\"pipes\", expression_type=\"formula\", \n...     expression=\"AS3 + AS5\", note=\"Total arsenic\")\n>>> _ = msx.add_reaction(species_name=\"AS3\", reaction_type=\"tank\", expression_type=\"rate\", \n...     expression=\"-Ka*AS3*NH2CL\", note=\"Arsenite oxidation\")\n>>> _ = msx.add_reaction(species_name=\"AS5\", reaction_type=\"tank\", expression_type=\"rate\", \n...     expression=\"Ka*AS3*NH2CL\", note=\"Arsenate production\")\n>>> _ = msx.add_reaction(species_name=\"NH2CL\", reaction_type=\"tank\", expression_type=\"rate\", \n...     expression=\"-Kb*NH2CL\", note=\"Monochloramine decay\")\n>>> _ = msx.add_reaction(species_name=\"AStot\", reaction_type=\"tanks\", expression_type=\"formula\", \n...     expression=\"AS3 + AS5\", note=\"Total arsenic\")\n\n>>> msx.options.area_units = \"M2\"\n>>> msx.options.rate_units = \"HR\"\n>>> msx.options.rtol = 0.001\n>>> msx.options.atol = 0.0001\n```\n\n----------------------------------------\n\nTITLE: Setting Pump Initial Status in WNTR Model - Python\nDESCRIPTION: Retrieves the pump link by name and sets its initial status to Closed. Useful for defining startup conditions for transient or steady-state simulation runs. Requires a valid pump name and model loaded in WNTR, and influences system hydraulics at simulation begin.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/model_development_tutorial.ipynb#_snippet_34\n\nLANGUAGE: python\nCODE:\n```\npump = wn2.get_link(\\\"~@Pump-1\\\")\\npump.initial_status = \\\"Closed\\\"\n```\n\n----------------------------------------\n\nTITLE: Plotting Valve Segmentation Results - Python\nDESCRIPTION: Visualizes link segmentation results using a randomly assigned color map for each segment group. Output plot colors pipes by segment ID to show spatial clustering based on valve isolation. Relies on wntr.graphics.random_colormap for visual clarity.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/basics_tutorial.ipynb#_snippet_85\n\nLANGUAGE: python\nCODE:\n```\n# Plot segments\\nN = seg_sizes.shape[0] # number of segments\\ncmap = wntr.graphics.random_colormap(N) # random color map helps visualize segments\\nax = wntr.graphics.plot_network(wn, link_attribute=link_segments, node_size=0, link_width=2, link_range=[0,N],  link_cmap=cmap, title='Valve segment ID')\n```\n\n----------------------------------------\n\nTITLE: Creating and Plotting a Fragility Curve with SciPy and WNTR - Python\nDESCRIPTION: This snippet demonstrates constructing a FragilityCurve object in WNTR, adding states with lognormal probability distributions using SciPy's lognorm, and plotting the fragility curve with custom x-axis labeling. It requires WNTR and SciPy's stats module. Key parameters are the state names, damage levels, and lognormal distribution scales. Inputs include the curve specification and output is a plotted Matplotlib axis of the fragility curve.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/graphics.rst#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\n>>> from scipy.stats import lognorm\n\n>>> FC = wntr.scenario.FragilityCurve()\n>>> FC.add_state('Minor', 1, {'Default': lognorm(0.5,scale=0.3)})\n>>> FC.add_state('Major', 2, {'Default': lognorm(0.5,scale=0.7)}) \n>>> ax = wntr.graphics.plot_fragility_curve(FC, xlabel='Peak Ground Acceleration (g)')\n```\n\n----------------------------------------\n\nTITLE: Intersecting Landslide Zones with Pipes for Diameters using WNTR GIS (Python)\nDESCRIPTION: This snippet shows how to reverse the GIS overlay: by querying which pipes intersect each landslide zone and extracting their diameters. The wntr.gis.intersect function is used with the landslide polygons as the primary layer and pipe features as secondary, targeting the 'diameter' attribute. The result is a summary DataFrame showing intersections and statistics per landslide zone.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/gis.rst#_snippet_29\n\nLANGUAGE: python\nCODE:\n```\n>>> pipes_that_intersect_each_landslide = wntr.gis.intersect(landslide_data, \n...     wn_gis.pipes, 'diameter')\n>>> print(pipes_that_intersect_each_landslide)\n    intersections                                             values  n    sum    min    max   mean\n0  [111, 121, 21]                             [0.254, 0.2032, 0.254]  3  0.711  0.203  0.254  0.237\n1    [11, 21, 31]  [0.35559999999999997, 0.254, 0.15239999999999998]  3  0.762  0.152  0.356  0.254\n2            [22]                              [0.30479999999999996]  1  0.305  0.305  0.305  0.305\n```\n\n----------------------------------------\n\nTITLE: Adding and Retrieving Controls in WaterNetworkModel using Python\nDESCRIPTION: Demonstrates adding a control object (`ctrl2`) to a WNTR `WaterNetworkModel` (`wn`) using the `add_control` method with a unique name ('NewTimeControl') and subsequently retrieving the added control using `get_control`. Assumes `wn` is a WaterNetworkModel instance and `ctrl2` is a pre-defined control object.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/controls.rst#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n>>> wn.add_control('NewTimeControl', ctrl2)\n>>> wn.get_control('NewTimeControl')\n<Control: 'control2', <SimTimeCondition: model, 'Is', '5-01:00:00', False, 0>, [<ControlAction: 10, status, OPEN>], [], priority=3>\n```\n\n----------------------------------------\n\nTITLE: Loading a Water Network Model from EPANET INP File using WNTR\nDESCRIPTION: Initializes a WNTR `WaterNetworkModel` object by reading network data from a specified EPANET INP file (`networks/ky10.inp`). This object (`wn`) will represent the water distribution system for subsequent analysis.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/landslide_tutorial.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n# Create a WaterNetworkModel from an EPANET INP file\ninp_file = 'networks/ky10.inp'\nwn = wntr.network.WaterNetworkModel(inp_file)\n```\n\n----------------------------------------\n\nTITLE: Adding Pumps to the WNTR Model using Geospatial Data - Python\nDESCRIPTION: Integrates prepared pump data into the water network model by updating the GIS object and re-importing into the WNTR network, with append=True so existing network elements are preserved. Requires updated pumps dataframe and the modified wn2 network object.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/model_development_tutorial.ipynb#_snippet_31\n\nLANGUAGE: python\nCODE:\n```\n# Add pumps (note that this could be done in the loop above with add_pump)\\ngis_data = wntr.gis.WaterNetworkGIS({\\\"pumps\\\": pumps})\\nwn2 = wntr.network.from_gis(gis_data, append=wn2)\n```\n\n----------------------------------------\n\nTITLE: Estimating Building Demand and Distributing to Junctions using WNTR - Python\nDESCRIPTION: Calculates total network demand and proportionally allocates it to each building by area. Updates the 'base_demand' column in the buildings dataframe, and plots demand distribution alongside pipes using matplotlib. Requires pre-existing 'aed0' (total demand), buildings and pipes GeoDataFrames, and a plotting context.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/model_development_tutorial.ipynb#_snippet_26\n\nLANGUAGE: python\nCODE:\n```\n# Assume that total network demand is known\\ntotal_demand = aed0.sum()\n```\n\nLANGUAGE: python\nCODE:\n```\n# Proportionally distribute total demand to buildings by area\\nbuildings[\\\"area\\\"] = buildings.area\\ntotal_building_area = buildings[\\\"area\\\"].sum()\\nbuildings[\\\"base_demand\\\"] = (buildings[\\\"area\\\"] / total_building_area)*total_demand\\n\\nfig, ax = plt.subplots(figsize=(12,5))\\nax = buildings.plot(column='base_demand', vmin=0, vmax=0.0002, legend=True, zorder=1, ax=ax)\\nax = pipes.plot(zorder=0, ax=ax)\\ntmp = ax.set_xlim(zoom_coords[0])\\ntmp = ax.set_ylim(zoom_coords[1])\n```\n\nLANGUAGE: python\nCODE:\n```\ndistance_threshold = 1000.0 # ft, used to snap buildings to junctions\\n\\nbuilding_centroid = buildings.copy()\\nbuilding_centroid.geometry = buildings.geometry.centroid\\nsnap_buildings = wntr.gis.snap(building_centroid, junctions, distance_threshold)\\nbuildings[\\\"junction\\\"] = None\\nbuildings.loc[snap_buildings.index, \\\"junction\\\"] = snap_buildings.loc[:, \\\"node\\\"]\\n\\nprint(buildings.head())\\nprint(snap_buildings.head())\n```\n\n----------------------------------------\n\nTITLE: Accessing Pressure Results from EpanetSimulator - Python\nDESCRIPTION: Displays the first several rows of node pressure results from the EpanetSimulator simulation by accessing the 'pressure' DataFrame. Useful for quick inspection or debugging.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/basics_tutorial.ipynb#_snippet_57\n\nLANGUAGE: python\nCODE:\n```\n# View EpanetSimulator pressure results\\nresults_EPANET.node['pressure'].head()\n```\n\n----------------------------------------\n\nTITLE: Calculating Mean Difference in AED and Pressure using Python\nDESCRIPTION: Calculates the absolute difference between the mean average expected demand (AED) and mean pressure values obtained from two different water network simulations (represented by variables like `aed0`, `pressure0`, `aed2`, `pressure2`). Requires pre-calculated pandas Series or similar objects representing simulation results. The results (`aed_diff2`, `pressure_diff2`) quantify the overall difference.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/model_development_tutorial.ipynb#_snippet_38\n\nLANGUAGE: python\nCODE:\n```\n# Compute absolute difference in mean average expected demand and mean pressure\naed_diff2 = abs(aed0.mean() - aed2.mean())\npressure_diff2 = abs(pressure0.mean() - pressure2.mean())\n```\n\n----------------------------------------\n\nTITLE: Importing and Loading a Water Network Model using WNTR - Python\nDESCRIPTION: This code snippet demonstrates how to import the wntr library and load a water network model from an EPANET input file using the WaterNetworkModel class. It supports two possible file paths for example networks and uses a try-except block to provide fallback in cases where the primary path is unavailable. The loaded model 'wn' serves as the basis for subsequent analysis and must reference an existing INP file.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/resilience.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n>>> import wntr\n>>> try:\n...    wn = wntr.network.model.WaterNetworkModel('../examples/networks/Net3.inp')\n... except:\n...    wn = wntr.network.model.WaterNetworkModel('examples/networks/Net3.inp')\n```\n\n----------------------------------------\n\nTITLE: Identifying Articulation Points and Bridges (Python)\nDESCRIPTION: This snippet finds articulation points (nodes whose removal disconnects the graph) using NetworkX and bridges (edges whose removal increases the number of connected components) using WNTR. Inputs are the undirected graph `uG` and the original graph `G`. Outputs are lists of critical nodes and bridges, valuable for network vulnerability analysis.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/resilience.rst#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\n>>> articulation_points = list(nx.articulation_points(uG))\n>>> bridges = wntr.metrics.bridges(G)\n```\n\n----------------------------------------\n\nTITLE: Initializing WaterNetworkModel with WNTR in Python\nDESCRIPTION: This snippet demonstrates robustly importing the Net3 water network model using WNTR. It tries to load the file from two relative paths to improve compatibility across different execution contexts. Dependencies: wntr. It returns a WaterNetworkModel instance loaded from the specified input file. Assumes the input file exists at one of the provided locations.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/morph.rst#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\n>>> import wntr\n>>> try:\n...    wn = wntr.network.model.WaterNetworkModel('../examples/networks/Net3.inp')\n... except:\n...    wn = wntr.network.model.WaterNetworkModel('examples/networks/Net3.inp')\n```\n\n----------------------------------------\n\nTITLE: Initializing WNTR Demo Environment - Python\nDESCRIPTION: Imports core dependencies (wntr, numpy, matplotlib, pandas) for WNTR demonstrations, and sets up pandas display precision. It attempts to load the Net3 EPANET example network file for further examples. This environment setup is required before running subsequent plotting or simulation code in this documentation.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/graphics.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n>>> import wntr\n>>> import numpy as np\n>>> import matplotlib.pylab as plt\n>>> import pandas as pd\n>>> pd.set_option(\"display.precision\", 3)\n>>> try:\n...    wn = wntr.network.model.WaterNetworkModel('../examples/networks/Net3.inp')\n... except:\n...    wn = wntr.network.model.WaterNetworkModel('examples/networks/Net3.inp')\n```\n\n----------------------------------------\n\nTITLE: Plotting Intersections of Pipes and Landslide Zones using WNTR & Matplotlib (Python)\nDESCRIPTION: This snippet visualizes the intersection results by coloring pipes according to their weighted mean landslide probability. It plots both the landslide polygons and the network, requiring GeoPandas, WNTR, and Matplotlib. Input attributes and pipe properties are managed via DataFrame columns, displayed using custom color ranges.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/gis.rst#_snippet_27\n\nLANGUAGE: python\nCODE:\n```\n>>> ax = landslide_data.plot(column='Pr', alpha=0.5, cmap='bone', vmin=0, vmax=1)\n>>> ax = wntr.graphics.plot_network(wn, link_attribute=pipe_Pr['weighted_mean'], \n...     link_width=1.5, node_range=[0,1], link_range=[0,1], ax=ax, \n...     link_colorbar_label='Landslide Probability')\n```\n\n----------------------------------------\n\nTITLE: Running Hydraulic Simulation with EpanetSimulator - Python\nDESCRIPTION: This example runs a hydraulic simulation using the EpanetSimulator with a specified WaterNetworkModel. It initializes the EpanetSimulator object and calls run_sim, which executes the simulation, returning a results object. By default, EPANET 2.2.0 is executed but the user can select the version as shown in another snippet. The required input is a configured WaterNetworkModel; output is a simulation results object.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/hydraulics.rst#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n>>> sim = wntr.sim.EpanetSimulator(wn)\n>>> results = sim.run_sim() # by default, this runs EPANET 2.2.0\n```\n\n----------------------------------------\n\nTITLE: Running Baseline EPANET Simulation using WNTR in Python\nDESCRIPTION: This snippet runs the hydraulic and water quality simulation for the baseline scenario (storm surge intrusion without mitigation) using the modified WNTR model (`wn`). It creates an `EpanetSimulator` instance and calls `run_sim()`. The results are stored in `baseline_results`, and the nodal water quality ('NaCl' concentration) is extracted into `baseline_quality`. The head of the quality results DataFrame is printed.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/salt_water_intrusion_tutorial.ipynb#_snippet_14\n\nLANGUAGE: python\nCODE:\n```\nsim = wntr.sim.EpanetSimulator(wn)\nbaseline_results = sim.run_sim()\nbaseline_quality = baseline_results.node['quality']\nprint(baseline_quality.head())\n```\n\n----------------------------------------\n\nTITLE: Inspecting Node Results Dictionary Keys - WNTR Results - Python\nDESCRIPTION: This snippet retrieves the keys from the node results dictionary of a simulation results object and prints them. This allows users to see the available result attributes (such as demand, head, pressure, and quality) for nodes in the network. Dependencies: a results object produced by a WNTR simulation. Output: printed list of keys, e.g., dict_keys(['demand', 'head', 'pressure', 'quality']).\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/resultsobject.rst#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n>>> node_keys = results.node.keys()\n>>> print(node_keys) # doctest: +SKIP\ndict_keys(['demand', 'head', 'pressure', 'quality']) \n```\n\n----------------------------------------\n\nTITLE: Calculating and Plotting Water Service Availability (WSA) With and Without Repairs (Python)\nDESCRIPTION: Calculates the expected demand profile for the network using `wntr.metrics.expected_demand`. Extracts the actual demand supplied from both simulation results (`results` and `results_wrepair`) for junction nodes. Converts time indices from seconds to hours. Calculates the Water Service Availability (WSA) metric for both scenarios using `wntr.metrics.water_service_availability`, which compares actual supplied demand to expected demand. Finally, it generates two subplots showing the WSA time series for all junctions, one for the 'Without Repair' scenario and one for the 'With Repair' scenario.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/earthquake_tutorial.ipynb#_snippet_14\n\nLANGUAGE: python\nCODE:\n```\nexpected_demand = wntr.metrics.expected_demand(wn)\ndemand = results.node['demand'].loc[:,wn.junction_name_list]\ndemand_wrepair = results_wrepair.node['demand'].loc[:,wn.junction_name_list]\nexpected_demand.index = expected_demand.index/3600\ndemand.index = demand.index/3600\ndemand_wrepair.index = demand_wrepair.index/3600\n\n# Calculate water service availability (WSA)\nwsa = wntr.metrics.water_service_availability(expected_demand, demand)\nwsa_wrepair = wntr.metrics.water_service_availability(expected_demand, demand_wrepair)\n\n# Plot WSA\nfig, axarr = plt.subplots(1,2,figsize=(14,4))\nax = axarr[0]\nwsa.plot(ax=ax, legend=False)\nax.set_ylim(ymin=-0.05, ymax=1.05)\nax.set_xlabel('Time (hr)')\nax.set_ylabel('Water service availability')\nax.set_title('Without Repair')\nax = axarr[1]\nwsa_wrepair.plot(ax=ax, legend=False)\nax.set_ylim(ymin=-0.05, ymax=1.05)\nax.set_xlabel('Time (hr)')\nax.set_ylabel('Water service availability')\nax.set_title('With Repair')\n```\n\n----------------------------------------\n\nTITLE: Adding Junction and Pipe Elements to WNTR Model\nDESCRIPTION: This snippet shows how to add new network elements to an existing `WaterNetworkModel` object (`wn`). It demonstrates adding a junction named 'new_junction' with specified properties (base demand, pattern, elevation, coordinates) and a pipe named 'new_pipe' connecting the new junction to an existing node ('101') with defined physical characteristics.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/waternetworkmodel.rst#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n>>> wn.add_junction('new_junction', base_demand=10, demand_pattern='1', elevation=10, \n...     coordinates=(6, 25))\n>>> wn.add_pipe('new_pipe', start_node_name='new_junction', end_node_name='101', \n...     length=10, diameter=0.5, roughness=100, minor_loss=0)\n```\n\n----------------------------------------\n\nTITLE: Connecting Disconnected Pipe Lines using WNTR GIS in Python\nDESCRIPTION: Uses the `wntr.gis.connect_lines` function to process a GeoDataFrame of potentially disconnected pipe LineStrings (`disconnected_pipes`). It connects line endpoints that are within a specified `distance_threshold` (in CRS units) and returns two GeoDataFrames: one for the connected pipes (`pipes`) with updated geometries and inferred node names, and one for the generated junction points (`junctions`). Requires `geopandas`.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/gis.rst#_snippet_44\n\nLANGUAGE: python\nCODE:\n```\n>>> distance_threshold = 5 # ft\n>>> pipes, junctions = wntr.gis.connect_lines(disconnected_pipes, distance_threshold)\n```\n\n----------------------------------------\n\nTITLE: Creating WNTR Model from Connected GIS Data in Python\nDESCRIPTION: This snippet demonstrates how to create a basic `wntr.network.WaterNetworkModel` from GeoDataFrames containing junction and pipe data that were previously generated (e.g., by `connect_lines`). It first creates a `wntr.gis.WaterNetworkGIS` object from the dictionaries of junctions and pipes, and then uses `wntr.network.from_gis` to build the network model (`wn`). Requires `geopandas`.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/gis.rst#_snippet_47\n\nLANGUAGE: python\nCODE:\n```\n>>> gis_data = wntr.gis.WaterNetworkGIS({\"junctions\": junctions, \"pipes\": pipes})\n>>> wn = wntr.network.from_gis(gis_data)\n```\n\n----------------------------------------\n\nTITLE: Simulating Water Age and Calculating Average - WNTR - Python\nDESCRIPTION: Performs a water quality simulation to calculate water age throughout the network, extracting the average water age for the last 48 hours. Requires a loaded WaterNetworkModel ('wn') and assumes the simulation period is at least 48 hours. Outputs mean age in hours, suitable for subsequent threshold analysis.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/resilience.rst#_snippet_17\n\nLANGUAGE: python\nCODE:\n```\n>>> wn.options.quality.parameter = 'AGE'\n>>> sim = wntr.sim.EpanetSimulator(wn)\n>>> results = sim.run_sim()\n\n>>> age = results.node['quality']\n>>> age_last_48h = age.loc[age.index[-1]-48*3600:age.index[-1]]\n>>> average_age = age_last_48h.mean()/3600 # convert to hours\n```\n\n----------------------------------------\n\nTITLE: Executing Pressure-Dependent Hydraulic Simulation Using EPANET - Python\nDESCRIPTION: Configures the hydraulic simulation for pressure-dependent demand (PDD), sets a required minimum pressure, and runs the simulation using WNTR's EpanetSimulator API. Results object contains pressures, demands, and other node/link outputs. Dependencies: wntr, proper initialization of WaterNetworkModel wn, and wntr.sim.EpanetSimulator. Outputs a comprehensive results object for post-processing.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/basics_tutorial.ipynb#_snippet_68\n\nLANGUAGE: python\nCODE:\n```\n# Run a pressure dependent hydraulic simulation\\nwn.options.hydraulic.demand_model = 'PDD'\\nwn.options.hydraulic.required_pressure = 50 # m, The required pressure is set to create a scenario where not all demands are met\\n\\nsim = wntr.sim.EpanetSimulator(wn)\\nresults = sim.run_sim()\n```\n\n----------------------------------------\n\nTITLE: Visualizing Fire Flow Simulation Impacts using WNTR Graphics in Python\nDESCRIPTION: Uses the `wntr.graphics.plot_network` function to visualize the simulation results on network maps. The first plot shows the number of junctions impacted by a fire at each potential hydrant location, using `num_junctions_impacted` as the node attribute, with specified node size, color range, colormap, and colorbar label. The second plot similarly visualizes the total population impacted, using `num_people_impacted` as the node attribute and adjusting the color range accordingly. Links (pipes) are drawn minimally (`link_width=0`) to emphasize the node attributes.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/fire_flow_tutorial.ipynb#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\n#Plot junctions impacted due to increased fire flow\nwntr.graphics.plot_network(wn, node_attribute=num_junctions_impacted, node_size=20, link_width=0, \n                           node_range=[0,5], node_cmap = cmap, node_colorbar_label='Junctions Impacted', \n                           title='Number of junctions impacted by each fire flow demand')\n\n#Plot population impacted due to increased fire flow\nwntr.graphics.plot_network(wn, node_attribute=num_people_impacted, node_size=20, link_width=0, \n                           node_range=[0,2500], node_cmap = cmap, node_colorbar_label='Population Impacted',\n                           title='Number of people impacted by each fire flow demand')                    \n```\n\n----------------------------------------\n\nTITLE: Defining MSX Species (Tracer and Chlorine) in WNTR (Python)\nDESCRIPTION: Defines two bulk species within the MSX model: 'T1' (Source 1 Tracer) and 'CL2' (Free Chlorine), both with units 'MG'. The `repr` of the 'CL2' species object is printed for inspection. These species are used to track the origin of water and the concentration of free chlorine.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/multispecies_tutorial.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nT1 = wn.msx.add_species(\"T1\", \"bulk\", units=\"MG\", note=\"Source 1 Tracer\")\nCl2 = wn.msx.add_species(\"CL2\", \"bulk\", units=\"MG\", note=\"Free Chlorine\")\nprint(repr(Cl2))\n```\n\n----------------------------------------\n\nTITLE: Saving Demographic Intersection Plot as PNG using Matplotlib (Python)\nDESCRIPTION: This hidden snippet saves the demographic and network figure to a PNG file after plotting. It ensures the axis display is set to equal, applies a tight layout, and closes the figure. Requires Matplotlib and the plotting axes object.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/gis.rst#_snippet_34\n\nLANGUAGE: python\nCODE:\n```\n>>> bounds = ax.axis('equal')\n>>> plt.tight_layout()\n>>> plt.savefig('intersect_demographics.png', dpi=300)\n>>> plt.close()\n```\n\n----------------------------------------\n\nTITLE: Sample JSON Entry for Demand Pattern Library\nDESCRIPTION: This snippet provides a sample entry (as a JSON object) from a demand pattern library with all key attributes, such as name, category, description, citation, timing, repetition flag, and value multipliers. It is used for illustration/documentation and is not executable code. It is useful for understanding the structure required when creating or editing custom pattern library JSON files.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/libraries.rst#_snippet_13\n\nLANGUAGE: json\nCODE:\n```\n{\n\t\"name\": \"Micropolis_2\",\n\t\"category\": \"Residential\",\n\t\"description\": \"Residential\",\n\t\"citation\": \"Brumbelow, Kelly, 02 Micropolis (2021). Synthetic Systems. 4. https://uknowledge.uky.edu/wdst_synthetic/4\",\n\t\"start_clocktime\": 0,\n\t\"pattern_timestep\": 3600,\n\t\"wrap\": true,\n\t\"multipliers\": [\n\t\t0.55, 0.55, 0.58, 0.67, 0.85, 1.05,\n\t\t1.16, 1.12, 1.15, 1.1, 1.02, 1.0,\n\t\t1.02, 1.1, 1.2, 1.35, 1.45, 1.5,\n\t\t1.5, 1.35, 1.0, 0.8, 0.7, 0.6]\n}\n```\n\n----------------------------------------\n\nTITLE: Converting WaterNetworkModel to GeoDataFrames with EPSG:4326 - Python\nDESCRIPTION: Transforms the WaterNetworkModel into a set of GeoDataFrames, with geometry referenced in CRS EPSG:4326 (lat/long). Provides spatial data for nodes and pipes for use in geopandas and mapping. Output contains pipes, junctions as GeoDataFrames. CRS assumption may trigger UserWarnings.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/basics_tutorial.ipynb#_snippet_87\n\nLANGUAGE: python\nCODE:\n```\n# Convert a WaterNetworkModel to a collection of GeoDataFrames in EPSG:4326 coordinates\\nwn_gis = wntr.network.to_gis(wn, crs='EPSG:4326')\\nwn_gis.pipes.head()\n```\n\n----------------------------------------\n\nTITLE: Running Hydraulic Simulation and Adding Flowrate to WNTR GIS Object in Python\nDESCRIPTION: This snippet performs a hydraulic simulation on the water network model (`wn`) using the WNTR EpanetSimulator. It runs the simulation (`sim.run_sim()`) to get results, calculates the mean flowrate for each link over the simulation period, and then adds these mean flowrates as a new attribute named 'flowrate' to the pipes layer within the `WaterNetworkGIS` object (`wn_gis`) using `add_link_attributes`. The `.head()` method displays the updated pipe attributes.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/basics_tutorial.ipynb#_snippet_96\n\nLANGUAGE: python\nCODE:\n```\n# Run a hydraulic simulation and store average flowrate to the WaterNetworkGIS object\nsim = wntr.sim.EpanetSimulator(wn)\nresults = sim.run_sim()\nflowrate = results.link['flowrate'].mean()\n\nwn_gis.add_link_attributes(flowrate, 'flowrate')\nwn_gis.pipes.head()\n```\n\n----------------------------------------\n\nTITLE: Defining MSX Decay Constants in WNTR (Python)\nDESCRIPTION: Defines two constants within the MSX model: 'k1' with a value of 1.3 (units '1/day') and 'k2' with a value of 17.7 (units '1/day'). These represent different chlorine decay rates associated with the two water sources. The `repr` of the 'k2' constant object is printed.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/multispecies_tutorial.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nk1 = wn.msx.add_constant(\"k1\", 1.3, units=\"1/day\")\nk2 = wn.msx.add_constant(\"k2\", 17.7, units=\"1/day\")\nprint(repr(k2))\n```\n\n----------------------------------------\n\nTITLE: Computing and Plotting Water Service Availability - Python\nDESCRIPTION: Calculates the ratio of delivered to expected demand across all nodes and visualizes it on the network. Requires simulation results, junction name list, expected demand, and uses wntr.metrics and wntr.graphics. Output is a plot showing spatial variability in service availability. Suitable for identifying under-served areas post-simulation.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/basics_tutorial.ipynb#_snippet_69\n\nLANGUAGE: python\nCODE:\n```\n# Compute water service availability, defined as the ratio of delivered demand to the expected demand. \\nexpected_demand = wntr.metrics.expected_demand(wn)\\ndemand = results.node['demand'].loc[:,wn.junction_name_list]\\nwsa = wntr.metrics.water_service_availability(expected_demand.sum(axis=0), demand.sum(axis=0))\\nax = wntr.graphics.plot_network(wn, node_attribute=wsa, title='Water service availability')\n```\n\n----------------------------------------\n\nTITLE: Assigning Demographic Data to Junctions using WNTR GIS Intersect (Python)\nDESCRIPTION: This snippet assigns the mean_income field from demographic polygons to water network junctions using wntr.gis.intersect. The result is a DataFrame indexed by junction with intersection details and statistical summaries. Requires previously loaded junction and demographic GeoDataFrames, and WNTR/GeoPandas as dependencies.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/gis.rst#_snippet_31\n\nLANGUAGE: python\nCODE:\n```\n>>> junction_demographics = wntr.gis.intersect(wn_gis.junctions, demographic_data, \n...     'mean_income')\n>>> print(junction_demographics)\n   intersections     values  n      sum      min      max     mean\n10           [0]  [63326.0]  1  63326.0  63326.0  63326.0  63326.0\n11           [0]  [63326.0]  1  63326.0  63326.0  63326.0  63326.0\n12           [5]  [57620.0]  1  57620.0  57620.0  57620.0  57620.0\n13           [5]  [57620.0]  1  57620.0  57620.0  57620.0  57620.0\n21           [3]  [54040.0]  1  54040.0  54040.0  54040.0  54040.0\n22           [3]  [54040.0]  1  54040.0  54040.0  54040.0  54040.0\n23           [6]  [44871.0]  1  44871.0  44871.0  44871.0  44871.0\n31           [2]  [91452.0]  1  91452.0  91452.0  91452.0  91452.0\n32           [2]  [91452.0]  1  91452.0  91452.0  91452.0  91452.0\n```\n\n----------------------------------------\n\nTITLE: Calculating Pump Energy and Cost from Simulation Results using wntr in Python\nDESCRIPTION: This snippet demonstrates simulating a water network using `wntr.sim.EpanetSimulator`, extracting pump flow rates and node heads from the simulation results, and then calculating the total pump energy and cost using `wntr.metrics.pump_energy` and `wntr.metrics.pump_cost`. It requires a `wntr` water network model (`wn`) and simulation results.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/resilience.rst#_snippet_26\n\nLANGUAGE: python\nCODE:\n```\n>>> sim = wntr.sim.EpanetSimulator(wn)\n>>> results = sim.run_sim()\n\n>>> pump_flowrate = results.link['flowrate'].loc[:,wn.pump_name_list]\n>>> head = results.node['head']\n>>> pump_energy = wntr.metrics.pump_energy(pump_flowrate, head, wn)\n>>> pump_cost = wntr.metrics.pump_cost(pump_energy, wn)\n```\n\n----------------------------------------\n\nTITLE: Running EPANET Simulations with Specific Versions in WNTR Python\nDESCRIPTION: Demonstrates initializing an `EpanetSimulator` with a WaterNetworkModel (`wn`) and running simulations using either EPANET version 2.00.12 or 2.2.0. The desired version is specified using the `version` parameter (2.0 or 2.2 respectively) in the `run_sim` method. Note that EPANET 2.00.12 only supports demand-driven analysis.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/whatsnew/v0.3.0.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nsim = wntr.sim.EpanetSimulator(wn)\nresults1 = sim.run_sim(version=2.0) # results using EPANET 2.00.12\nresults2 = sim.run_sim(version=2.2) # results using EPANET 2.2.0\n```\n\n----------------------------------------\n\nTITLE: Simulating Hydraulics with Earthquake-Induced Leaks (No Repair) using WNTR (Python)\nDESCRIPTION: Configures the WNTR simulation options for pressure-driven demand (PDD), sets the total duration, and defines minimum and required pressure thresholds. It then iterates through the previously determined pipe damage states. For pipes identified with 'Minor Leak' or 'Major Leak', it calculates a corresponding leak area based on the pipe diameter, splits the original pipe into two segments with a new node in between using `wntr.morph.split_pipe`, and adds a leak emitter to the new node using `add_leak` with the calculated area and specified start time. Finally, it initializes a `WNTRSimulator` and runs the hydraulic simulation without any repairs.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/earthquake_tutorial.ipynb#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\n# Set network parameters\nwn.options.hydraulic.demand_model = 'PDD'    \nwn.options.time.duration = total_duration\nwn.options.hydraulic.minimum_pressure = minimum_pressure\nwn.options.hydraulic.required_pressure = required_pressure \n\n# The simulation uses pressure driven hydraulics and leak models to account for loss.\nfor pipe_name, damage_state in pipe_damage_state.items():\n    pipe_diameter = wn.get_link(pipe_name).diameter\n    if damage_state is not None:\n        if damage_state == 'Major Leak':\n            leak_diameter = 0.25*pipe_diameter \n            leak_area = np.pi/4.0*leak_diameter**2\n        elif damage_state == 'Minor Leak':\n            leak_diameter = 0.1*pipe_diameter \n            leak_area = np.pi/4.0*leak_diameter**2\n        else:\n            leak_area = 0\n\n        # Add pipe leak to network\n        wn = wntr.morph.split_pipe(wn,pipe_name, pipe_name+'A', 'Leak'+pipe_name)\n        n = wn.get_node('Leak'+pipe_name)\n        n.add_leak(wn, area=leak_area, start_time=leak_start_time)\n    \nsim = wntr.sim.WNTRSimulator(wn)\nresults = sim.run_sim()\n```\n\n----------------------------------------\n\nTITLE: Importing the WNTR library in Python (Python)\nDESCRIPTION: Imports the installed WNTR library into the current Python session or script. Executing this command successfully (i.e., without raising an `ImportError`) confirms that WNTR is properly installed and accessible within the Python environment. This is the first step in testing the installation.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/installation.rst#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nimport wntr\n```\n\n----------------------------------------\n\nTITLE: Using Start Clocktime Option in WNTRSimulator (Python)\nDESCRIPTION: Updates the WNTRSimulator to utilize the `wn.options.time.start_clocktime` option defined in the water network model. This allows simulations to correctly begin at the specified clock time, aligning simulation time with the model's time options.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/whatsnew/v0.4.0.rst#_snippet_8\n\nLANGUAGE: Python\nCODE:\n```\nwn.options.time.start_clocktime\n```\n\n----------------------------------------\n\nTITLE: Describing Water Network Model Details using WNTR\nDESCRIPTION: Uses the `describe` method of the `WaterNetworkModel` object (`wn`) to print a summary of the network's components and properties. The `level=1` argument specifies a moderate level of detail for the description.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/landslide_tutorial.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n# Print a basic description of the model. \n# The level can be 0, 1, or 2 and defines the level of detail included in the description.\nwn.describe(level=1)\n```\n\n----------------------------------------\n\nTITLE: Preparing WNTR Model and GIS Data for Snapping in Python\nDESCRIPTION: This snippet loads a WNTR WaterNetworkModel from an EPANET INP file ('networks/Net1.inp') and converts it into a WNTR WaterNetworkGIS object using `wntr.network.to_gis`. It explicitly sets the Coordinate Reference System (CRS) to 'EPSG:4326' during the conversion. This prepares the network data in a GIS-compatible format for subsequent spatial operations like snapping.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/gis.rst#_snippet_17\n\nLANGUAGE: python\nCODE:\n```\n>>> wn = wntr.network.WaterNetworkModel('networks/Net1.inp') # doctest: +SKIP\n>>> wn_gis = wntr.network.to_gis(wn, crs='EPSG:4326')\n```\n\n----------------------------------------\n\nTITLE: Visualizing Pipe Break Impacts on Network Map using WNTR in Python\nDESCRIPTION: Uses WNTR's `plot_network` function to visualize the results of the pipe break analysis. Two plots are generated: one showing the number of junctions impacted by each pipe closure, and another showing the number of people impacted. The impact values are mapped to the link colors/widths on the network diagram.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/pipe_break_tutorial.ipynb#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\n#Plot junctions impacted due to pipe breaks\nwntr.graphics.plot_network(wn, link_attribute=num_junctions_impacted, node_size=0, link_width=2, \n                           link_range=[0,10], link_cmap = cmap, link_colorbar_label='Junctions Impacted', \n                           title='Number of junctions impacted by each pipe closure')\n\n#Plot population impacted due to pipe breaks\nwntr.graphics.plot_network(wn, link_attribute=num_people_impacted, node_size=0, link_width=2, \n                           link_range=[0,5000], link_cmap = cmap, link_colorbar_label='Population Impacted',\n                           title='Number of people impacted by each pipe closure')\n```\n\n----------------------------------------\n\nTITLE: Simulating Chemical Water Quality and Detecting Nodes Above Threshold - WNTR - Python\nDESCRIPTION: Defines time-varying injection patterns, adds chemical sources, runs a water quality simulation, and queries which nodes exceed a concentration threshold. Requires water quality parameter to be set to 'CHEMICAL', and custom patterns for contaminant injection ('SourcePattern'). Outputs Boolean masks indicating the nodes exceeding regulation limits.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/resilience.rst#_snippet_19\n\nLANGUAGE: python\nCODE:\n```\n>>> wn.options.quality.parameter = 'CHEMICAL'\n>>> source_pattern = wntr.network.elements.Pattern.binary_pattern('SourcePattern', \n...     step_size=3600, start_time=2*3600, end_time=15*3600, duration=7*24*3600)\n>>> wn.add_pattern('SourcePattern', source_pattern)\n>>> wn.add_source('Source1', '121', 'SETPOINT', 1000, 'SourcePattern')\n>>> wn.add_source('Source2', '123', 'SETPOINT', 1000, 'SourcePattern')\n>>> sim = wntr.sim.EpanetSimulator(wn)\n>>> results = sim.run_sim()\n\n>>> chem = results.node['quality']\n>>> threshold = 750\n>>> mask = wntr.metrics.query(chem, np.greater, threshold)\n>>> chem_above_regulation = mask.any(axis=0) # True/False for each node\n```\n\n----------------------------------------\n\nTITLE: Calculating Baseline Water Service Availability (WSA) - Python\nDESCRIPTION: Calculates the baseline Water Service Availability (WSA) for each junction, using the ratio of actual delivered to expected demand. Requires node demand results from a prior simulation and the expected demand vector, and uses WNTR metric utilities. Output is a vector of WSA per junction, used for performance assessment.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/landslide_tutorial.ipynb#_snippet_34\n\nLANGUAGE: python\nCODE:\n```\n# Compute baseline WSA for each junction\ndemand_baseline = baseline_results.node['demand'].loc[:,wn.junction_name_list]\ndemand_baseline_j = demand_baseline.sum(axis=0) # total demand at each junction\nwsa_baseline_j = wntr.metrics.water_service_availability(expected_demand_j, demand_baseline_j)\n\nwsa_baseline_j.head()\n```\n\n----------------------------------------\n\nTITLE: Configuring Water Age Quality Analysis - WNTR - Python\nDESCRIPTION: This snippet demonstrates how to configure the WaterNetworkModel to compute water age at every node by setting the quality parameter to 'AGE'. This requires the wn object and sets up a subsequent simulation to report water age. No external dependencies except wntr and a pre-existing wn model instance.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/waterquality.rst#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n>>> wn.options.quality.parameter = 'AGE'\n```\n\n----------------------------------------\n\nTITLE: Simulating Normal Conditions and Identifying Low-Pressure Junctions in Python\nDESCRIPTION: Configures and runs a WNTR simulation under normal operating conditions using PDD. It first identifies junctions with non-zero average expected demand (AED). Then, it sets hydraulic options (PDD model, duration, pressure thresholds) and runs the simulation to find junctions where pressure drops below the minimum threshold during normal operation. This establishes a baseline for comparison with break scenarios.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/pipe_break_tutorial.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n# Calculate average expected demand and identify junctions with non-zero average expected demand (AED)\nAED = wntr.metrics.average_expected_demand(wn)\nnzd_junct = AED[AED > 0].index\n\n# Set hydraulic parameters\nwn.options.hydraulic.demand_model = 'PDD'    \nwn.options.time.duration = total_duration\nwn.options.hydraulic.minimum_pressure = minimum_pressure\nwn.options.hydraulic.required_pressure = required_pressure \n\n# Run simulation\nsim = wntr.sim.WNTRSimulator(wn)\nresults = sim.run_sim()\n\n# Save junction pressure results and identify junctions that fall below minimum pressure\npressure = results.node['pressure'].loc[start_time::, nzd_junct]\nnormal_pressure_below_pmin = pressure.columns[(pressure < minimum_pressure).any()]\n```\n\n----------------------------------------\n\nTITLE: Snapping Valve Points to Pipes using WNTR (Python)\nDESCRIPTION: This set of snippets shows how to load valve point data, snap each to the closest pipe within a defined spatial tolerance, and extract the resulting mapping for network segmentation. It relies on reading GeoJSON data into GeoDataFrames, applying wntr.gis.snap for spatial nearest-neighbor analysis, and then preparing a valve layer for graph segmentation and visualization. Dependencies include GeoPandas, WNTR, and optionally Matplotlib for plotting. Inputs are valve and pipe spatial datasets; outputs include snapped locations, valve layers, and plots.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/gis.rst#_snippet_23\n\nLANGUAGE: python\nCODE:\n```\n>>> valve_data = gpd.read_file('data/Net1_valve_data.geojson') # doctest: +SKIP\n>>> print(valve_data)\n            geometry\n0  POINT (56.5 41.5)\n1  POINT (32.1 67.6)\n2  POINT (52.7 86.3)\n```\n\nLANGUAGE: python\nCODE:\n```\n>>> snapped_to_pipes = wntr.gis.snap(valve_data, wn_gis.pipes, tolerance=5.0)\n>>> print(snapped_to_pipes)\n  link node  snap_distance  line_position         geometry\n0   22   22            1.5          0.325  POINT (56.5 40)\n1  111   11            2.1          0.080  POINT (30 67.6)\n2  110    2            2.7          0.185  POINT (50 86.3)\n```\n\nLANGUAGE: python\nCODE:\n```\n>>> valve_layer = snapped_to_pipes[['link', 'node']]\n>>> G = wn.to_graph()\n>>> node_segments, link_segments, segment_size = wntr.metrics.valve_segments(G, \n...     valve_layer)\n```\n\nLANGUAGE: python\nCODE:\n```\n>>> ax = valve_data.plot()\n>>> ax = wntr.graphics.plot_valve_layer(wn, valve_layer, add_colorbar=False, ax=ax)\n```\n\nLANGUAGE: python\nCODE:\n```\n>>> bounds = ax.axis('equal')\n>>> plt.tight_layout()\n>>> plt.savefig('snap_lines.png', dpi=300)\n>>> plt.close()\n```\n\n----------------------------------------\n\nTITLE: Intersecting Junctions with Demographic Data - Python\nDESCRIPTION: Uses wntr.gis.intersect to spatially join network junctions (from GeoDataFrame) with demographic polygons, extracting attributes such as mean income. Inputs: junction geometry, demographic data, target field. Output: DataFrame of node-to-demographic attribute associations.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/basics_tutorial.ipynb#_snippet_92\n\nLANGUAGE: python\nCODE:\n```\n# Intersect junctions with census block groups, extract mean income\\njunction_demographics = wntr.gis.intersect(wn_gis.junctions, demographic_data, 'mean_income')\\njunction_demographics.head()\n```\n\n----------------------------------------\n\nTITLE: Reading Esri Shapefile network data (directories) into WNTR in Python\nDESCRIPTION: This code constructs a dictionary mapping water network component names to their corresponding Shapefile directories, then loads the data as a WaterNetworkModel instance using wntr.network.read_shapefile. Each component must be placed in its own directory named according to WNTR conventions. The function adds both standard and custom field names found in the Shapefiles. It is suitable for initializing or updating water network models from spatial datasets and requires the directories and field names to be properly formatted.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/model_io.rst#_snippet_19\n\nLANGUAGE: python\nCODE:\n```\nshapefile_dirs = {'junctions': 'Net3_junctions',\n                   'tanks': 'Net3_tanks',\n                   'reservoirs': 'Net3_reservoirs',\n                   'pipes': 'Net3_pipes',\n                   'pumps': 'Net3_pumps'}\nwn2 = wntr.network.read_shapefile(shapefile_dirs)\n```\n\n----------------------------------------\n\nTITLE: Computing Water Service Availability - WNTR - Python\nDESCRIPTION: Calculates the fraction of time the delivered demand meets the expected demand at each node using the water_service_availability metric. Relies on previously calculated hydraulic results and the expected_demand from the WNTR metrics module. Outputs a DataFrame ('wsa') indexed by node and time; missing demand values result in NaN.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/resilience.rst#_snippet_14\n\nLANGUAGE: python\nCODE:\n```\n>>> expected_demand = wntr.metrics.expected_demand(wn)\n>>> demand = results.node['demand']\n>>> wsa = wntr.metrics.water_service_availability(expected_demand, demand)\n```\n\n----------------------------------------\n\nTITLE: Adding Geospatial Data to WNTR Model - Python\nDESCRIPTION: Aggregates geospatial dataframes for junctions, tanks, reservoirs, and pipes into a WaterNetworkGIS object and builds a WNTR water network model from it. Required for initializing the model structure from geospatial sources prior to including pumps and controls. Depends on the WNTR library and all major spatial dataframes.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/model_development_tutorial.ipynb#_snippet_27\n\nLANGUAGE: python\nCODE:\n```\ngis_data = wntr.gis.WaterNetworkGIS({\\\"junctions\\\": junctions,\\n                                     \\\"tanks\\\": tanks,\\n                                     \\\"reservoirs\\\": reservoirs,\\n                                     \\\"pipes\\\": pipes})\\nwn2 = wntr.network.from_gis(gis_data)\n```\n\n----------------------------------------\n\nTITLE: Converting WNTR Model to GIS and Transforming CRS in Python\nDESCRIPTION: This example demonstrates loading a WNTR WaterNetworkModel, converting it into a WNTR WaterNetworkGIS object (which contains GeoDataFrames for network components) while assigning an initial CRS ('EPSG:4326'), and then transforming the CRS of all component GeoDataFrames within the WaterNetworkGIS object to 'EPSG:3857' using its `to_crs` method. The head of the junctions GeoDataFrame is printed before and after the transformation to show the coordinate changes.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/gis.rst#_snippet_16\n\nLANGUAGE: python\nCODE:\n```\n>>> wn = wntr.network.WaterNetworkModel('networks/Net1.inp') # doctest: +SKIP\n\t\n>>> wn_gis = wntr.network.to_gis(wn, crs='EPSG:4326')\n>>> print(wn_gis.junctions.head())\n      base_demand demand_pattern  elevation  initial_quality demand_category       geometry\nname                                                                                       \n10          0.000              1    216.408        5.000e-04            None  POINT (20 70)\n11          0.009              1    216.408        5.000e-04            None  POINT (30 70)\n12          0.009              1    213.360        5.000e-04            None  POINT (50 70)\n13          0.006              1    211.836        5.000e-04            None  POINT (70 70)\n21          0.009              1    213.360        5.000e-04            None  POINT (30 40)\n\n>>> wn_gis.to_crs('EPSG:3857')\n>>> print(wn_gis.junctions.head())\n      base_demand demand_pattern  elevation  initial_quality demand_category                          geometry\nname                                                                                                          \n10          0.000              1    216.408        5.000e-04            None  POINT (2226389.816 11068715.659)\n11          0.009              1    216.408        5.000e-04            None  POINT (3339584.724 11068715.659)\n12          0.009              1    213.360        5.000e-04            None   POINT (5565974.54 11068715.659)\n13          0.006              1    211.836        5.000e-04            None  POINT (7792364.356 11068715.659)\n21          0.009              1    213.360        5.000e-04            None    POINT (3339584.724 4865942.28)\n```\n\n----------------------------------------\n\nTITLE: Comparing Network Model Attributes via Description Output - Python\nDESCRIPTION: Prints textual summaries of network-wide attributes using each WaterNetworkModel's describe() method, facilitating direct comparison of base and GeoJSON-based models. Outputs include component counts and configuration details. Input: model objects wn0, wn1.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/model_development_tutorial.ipynb#_snippet_12\n\nLANGUAGE: python\nCODE:\n```\nprint(f\"Base network attributes: {wn0.describe()}\")\\nprint(f\"Perfect network attributes: {wn1.describe()}\")\\n\n```\n\n----------------------------------------\n\nTITLE: Initializing WNTR Model and Accessing Options in Python\nDESCRIPTION: Creates an empty WNTR `WaterNetworkModel` and accesses its `options` attribute. When created this way, the options are set to their default values. Accessing `wn.options` returns the main options object containing all categories.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/options.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n>>> wn = wntr.network.model.WaterNetworkModel()\n>>> wn.options  # doctest: +SKIP\n```\n\n----------------------------------------\n\nTITLE: Creating a Time-Based Control in WNTR (Python)\nDESCRIPTION: This snippet demonstrates creating a time-based control. It retrieves a pump link ('10'), defines a `ControlAction` (`act2`) to open the pump (status 1), and creates a `SimTimeCondition` (`cond2`) that triggers exactly at 121 hours ('121:00:00') of simulation time. It then combines the condition and action into a `Control` named 'control2' and prints both the condition (showing time in seconds) and the control. This requires a WNTR `WaterNetworkModel` instance (`wn`).\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/controls.rst#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n>>> pump = wn.get_link('10')\n>>> act2 = controls.ControlAction(pump, 'status', 1)\n>>> cond2 = controls.SimTimeCondition(wn, '=', '121:00:00')\n>>> print(cond2)\nSYSTEM TIME IS 121:00:00\n\n>>> ctrl2 = controls.Control(cond2, act2, name='control2')\n>>> print(ctrl2)\nIF SYSTEM TIME IS 121:00:00 THEN PUMP 10 STATUS IS OPEN PRIORITY 3\n```\n\n----------------------------------------\n\nTITLE: Plotting Basic Water Network with Node Elevation - Matplotlib - Python\nDESCRIPTION: This snippet demonstrates how to plot a water network using WNTR and matplotlib, coloring nodes by their elevation attribute. It loads a WaterNetworkModel, then calls plot_network() with the node_attribute parameter, returning a matplotlib axes object for further customization. Requires 'wntr' and 'matplotlib' libraries and a valid network file (Net3.inp).\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/graphics.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n>>> import wntr # doctest: +SKIP\n\n>>> wn = wntr.network.WaterNetworkModel('networks/Net3.inp') # doctest: +SKIP\n>>> ax = wntr.graphics.plot_network(wn, node_attribute='elevation', \n...    node_colorbar_label='Elevation (m)')\n```\n\n----------------------------------------\n\nTITLE: Calculating Junction and Population Impacts from Fire Flow Simulations in Python\nDESCRIPTION: Processes the `analysis_results` dictionary obtained from the fire flow simulations. It iterates through each simulated hydrant location (key) and its corresponding list of impacted junctions (value). If the simulation was successful (impacted_junctions is not None), it calculates the total number of impacted junctions (`len(impacted_junctions)`) and the total population affected by summing the population values (pre-calculated in `population`) for those specific junctions. These counts are stored in `num_junctions_impacted` and `num_people_impacted` dictionaries, respectively, keyed by the hydrant location.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/fire_flow_tutorial.ipynb#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\n# Save junction and population impact results to dictionary\nnum_junctions_impacted = {}\nnum_people_impacted = {}\nfor pipe_name, impacted_junctions in analysis_results.items():\n    if impacted_junctions is not None:\n        num_junctions_impacted[pipe_name] = len(impacted_junctions)\n        num_people_impacted[pipe_name] = population[impacted_junctions].sum()\n```\n\n----------------------------------------\n\nTITLE: Initializing a Lead Plumbosolvency MSX Model in WNTR - Python\nDESCRIPTION: Demonstrates creating an MsxModel object for simulating lead plumbosolvency, setting descriptive model metadata like name, title, description, and references. Requires wntr.msx. Returns a model object ready for further configuration. Inputs: model metadata as string values; output: MsxModel instance.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/advancedsim.rst#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n>>> import wntr.msx\n>>> msx = wntr.msx.MsxModel()\n>>> msx.name = \"lead_ppm\"\n>>> msx.title = \"Lead Plumbosolvency Model (from Burkhardt et al 2020)\"\n>>> msx.desc = \"Parameters for EPA HPS Simulator Model\"\n>>> msx.references.append(\n... \"\"\"J. B. Burkhardt, et al. (2020) https://doi.org/10.1061/(asce)wr.1943-5452.0001304\"\"\"\n... )\n>>> msx\nMsxModel(name='lead_ppm')\n```\n\n----------------------------------------\n\nTITLE: Setting Hydraulic Demand Model in WNTR Python\nDESCRIPTION: Illustrates setting the `demand_model` attribute within `wn.options.hydraulic` to specify either 'DD' (demand-driven) or 'PDD' (pressure-dependent demand) analysis for hydraulic simulations. This option, compatible with EPANET 2.2.0, determines the simulation type. 'DD' or 'DDA' specify demand-driven, while 'PDD' or 'PDA' specify pressure-dependent demand.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/whatsnew/v0.3.0.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nwn.options.hydraulic.demand_model = 'DD' # specify demand-driven analysis \nwn.options.hydraulic.demand_model = 'PDD' # specify pressure dependent demand analysis\n```\n\n----------------------------------------\n\nTITLE: Randomly Selecting Hydrant Locations for Flushing in Python\nDESCRIPTION: This snippet selects a specified number (`number_of_hydrants`) of junctions randomly from the network's junction list (`wn.junction_name_list`) to serve as hydrant flushing locations. It uses `numpy.random.choice` for the selection and sets a random seed for reproducibility. The selected junction names are stored in the `hydrant_nodes` list.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/salt_water_intrusion_tutorial.ipynb#_snippet_17\n\nLANGUAGE: python\nCODE:\n```\nnp.random.seed(1234)\nnumber_of_hydrants = 5\n\nhydrant_nodes = list(np.random.choice(wn.junction_name_list, number_of_hydrants))\n```\n\n----------------------------------------\n\nTITLE: Cloning and Installing WNTR from GitHub - Shell\nDESCRIPTION: This snippet illustrates how to clone the WNTR repository from GitHub, change into its directory, install it in editable mode without building shared objects, and install required dependencies using pip. It is used when a developer does not want to build C++ extensions locally and prefers using prebuilt binaries. Requires: git, Python with pip, internet access, and a command-line environment. Expected input: terminal commands; Output: WNTR source tree set up for development, dependencies installed.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/installation.rst#_snippet_7\n\nLANGUAGE: shell\nCODE:\n```\ngit clone https://github.com/USEPA/WNTR\\ncd WNTR\\npython -m pip install -e . --no-build\\npip install -r requirements.txt\n```\n\n----------------------------------------\n\nTITLE: Instantiating WaterNetworkModel from GeoDataFrames - Python\nDESCRIPTION: This snippet demonstrates how to create a WNTR WaterNetworkModel object from an existing WaterNetworkGIS object containing GeoDataFrames, enabling conversion from GIS data back to a water network simulation model. Input: WaterNetworkGIS object; Output: WaterNetworkModel. Dependency: wntr, geopandas.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/gis.rst#_snippet_11\n\nLANGUAGE: python\nCODE:\n```\n>>> wn2 = wntr.network.from_gis(wn_gis)\n```\n\n----------------------------------------\n\nTITLE: Updating Pipe Check Valve Attributes in WNTR (Python)\nDESCRIPTION: Merges the previous `check_valve_flag` and `cv` attributes of Pipe components into a single new attribute named `check_valve`. This change simplifies the representation and configuration of check valves within the WNTR water network model.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/whatsnew/v0.4.0.rst#_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\ncheck_valve_flag\n```\n\nLANGUAGE: Python\nCODE:\n```\ncv\n```\n\nLANGUAGE: Python\nCODE:\n```\ncheck_valve\n```\n\n----------------------------------------\n\nTITLE: Snapping Hydrant Points to Network Junctions using WNTR in Python\nDESCRIPTION: This snippet utilizes the `wntr.gis.snap` function to associate hydrant locations (from `hydrant_data` GeoDataFrame) with the nearest network junctions (from `wn_gis.junctions` GeoDataFrame). A tolerance of 5.0 units (in the CRS units, EPSG:4326 degrees in this case) is specified, meaning hydrants further than this distance from any junction will not be snapped. The result, stored in `snapped_to_junctions`, is a GeoDataFrame containing the name of the nearest junction ('node'), the distance ('snap_distance'), and the geometry of the junction.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/gis.rst#_snippet_19\n\nLANGUAGE: python\nCODE:\n```\n>>> snapped_to_junctions = wntr.gis.snap(hydrant_data, wn_gis.junctions, tolerance=5.0)\n>>> print(snapped_to_junctions)\n  node  snap_distance       geometry\n0   22          3.329  POINT (50 40)\n1   13          2.476  POINT (70 70)\n2   12          1.628  POINT (50 70)\n```\n\n----------------------------------------\n\nTITLE: Identifying and Plotting Highest Leak Demands from Simulation Results (Python)\nDESCRIPTION: Extracts the 'leak_demand' time series for all nodes from the simulation results. Calculates the total leaked volume for each leak node by summing the demand over the simulation duration. Sorts these summed leak volumes in descending order to identify the largest leaks. Finally, it plots the leak demand time series for all leak nodes, converting the time index from seconds to hours.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/earthquake_tutorial.ipynb#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\n# Rank leaked demand\nleaked_demand = results.node['leak_demand']\nleaked_sum = leaked_demand.sum()\nleaked_sum.sort_values(ascending=False, inplace=True)\n\n# Plot leak demand\nleaked_demand.index = leaked_demand.index/3600\nax=leaked_demand.plot(legend=False)\nax.set_ylabel('Leak demand (m3/s)')\nax.set_xlabel('Time (hr)')\n```\n\n----------------------------------------\n\nTITLE: Modifying Junction Demand Time Series Base Value\nDESCRIPTION: This snippet demonstrates modifying the base demand value for an existing demand time series at a junction. It retrieves the junction node '121' and accesses the first demand time series in its list (`demand_timeseries_list[0]`). It then changes the `base_value` of this specific time series to 0.005.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/waternetworkmodel.rst#_snippet_11\n\nLANGUAGE: python\nCODE:\n```\n>>> junction = wn.get_node('121')\n>>> junction.demand_timeseries_list[0].base_value = 0.005\n```\n\n----------------------------------------\n\nTITLE: Plotting Node Pressure at a Specific Simulation Time - Python\nDESCRIPTION: Plots the pressure values at all nodes at hour 5 of the simulation on a network plot, mapping the attribute to node color/size. Uses wntr.graphics.plot_network; requires simulation results and correct time index.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/basics_tutorial.ipynb#_snippet_61\n\nLANGUAGE: python\nCODE:\n```\n# Plot pressure at hour 5 on the network\\npressure_at_5hr = results_EPANET.node['pressure'].loc[5*3600, :]\\nax = wntr.graphics.plot_network(wn, node_attribute=pressure_at_5hr, node_size=30, title='Pressure at 5 hours')\n```\n\n----------------------------------------\n\nTITLE: Simulating Hydraulics Using WNTRSimulator - Python\nDESCRIPTION: Runs the WNTRSimulator on the WaterNetworkModel to perform demand-driven or pressure-driven hydraulic analysis. Stores results in a structure similar to EpanetSimulator. Helps compare internal simulator with EPANET results.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/basics_tutorial.ipynb#_snippet_54\n\nLANGUAGE: python\nCODE:\n```\n# Simulate hydraulics using the WNTRSimulator\\nsim = wntr.sim.WNTRSimulator(wn)\\nresults_WNTR = sim.run_sim()\n```\n\n----------------------------------------\n\nTITLE: Initializing Water Network Model for Hydraulic Simulations - Python\nDESCRIPTION: Defines a reusable function to load and configure a WaterNetworkModel object for hydraulic simulations. Requires WNTR, path to an EPANET .inp file, and sets simulation options such as demand model, required/ minimum pressure, and duration. Outputs an initialized 'wn' object for downstream simulation.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/landslide_tutorial.ipynb#_snippet_25\n\nLANGUAGE: python\nCODE:\n```\n# Create a function to setup the WaterNetworkModel for hydraulic simulations\ndef model_setup(inp_file):\n    wn = wntr.network.WaterNetworkModel(inp_file)\n    wn.options.hydraulic.demand_model = 'PDD'\n    wn.options.hydraulic.required_pressure = 20 # m\n    wn.options.hydraulic.minimum_pressure  = 0 # m\n    wn.options.time.duration = 48*3600 # s (48 hour simulation)\n    return wn\n```\n\n----------------------------------------\n\nTITLE: Splitting Pipes and Adding Leaks in WaterNetworkModel - Python\nDESCRIPTION: Illustrates splitting a pipe (adding a new node and pipe) and creating a leak at the new node, specifying the area and start/end times in seconds. Depends on wntr.morph.split_pipe and the leak node's add_leak method. Input is original WaterNetworkModel and target pipe, outputs a new WaterNetworkModel with the modified topology and leak.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/basics_tutorial.ipynb#_snippet_38\n\nLANGUAGE: python\nCODE:\n```\n# Split pipe 123 and add a leak to the new node which starts at hour 2 and ends at hour 12\\nwn = wntr.morph.split_pipe(wn, pipe_name_to_split='123', new_pipe_name='123_B', new_junction_name='123_node')\\nleak_node = wn.get_node('123_node')\\nleak_node.add_leak(wn, area=0.05, start_time=2*3600, end_time=12*3600)\n```\n\n----------------------------------------\n\nTITLE: Splitting a Pipe and Adding a Leak using WNTR in Python\nDESCRIPTION: This example pipesplit creates a new junction and new pipe from an existing pipe, then retrieves the new node and adds a leak to it. It relies on the wntr.morph.split_pipe API, the model object, and that the target pipe exists. Inputs are the WaterNetworkModel, original pipe ID, new pipe ID, and new node name. After splitting, it uses add_leak to attach a leak to the new junction with specified area and timing parameters. The outputs are the modified WaterNetworkModel and an updated node with leak settings. Proper ID naming and node existence in the model are required.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/morph.rst#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\n>>> wn = wntr.morph.split_pipe(wn, '123', '123_B', '123_node')\n>>> leak_node = wn.get_node('123_node')           \n>>> leak_node.add_leak(wn, area=0.05, start_time=2*3600, end_time=12*3600)\n```\n\n----------------------------------------\n\nTITLE: Importing Core Dependencies and Loading Example Network - Python\nDESCRIPTION: This snippet imports the required Python libraries (WNTR, NumPy, Pandas, GeoPandas, Matplotlib), sets Pandas DataFrame display options, checks for optional GIS dependencies (GeoPandas), and loads the sample network model (Net1) using a relative or fallback examples directory. It highlights error handling for missing dependencies and shows preparation steps for further geospatial operations. Inputs are the location of the example network files, and outputs include a WaterNetworkModel instance ready for GIS operations. Dependencies: wntr, numpy, pandas, geopandas (optional), matplotlib, os.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/gis.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n>>> import wntr\n>>> import numpy as np\n>>> import pandas as pd\n>>> pd.options.display.expand_frame_repr = False\n>>> pd.options.display.precision = 3\n>>> try:\n...    import geopandas as gpd\n... except ModuleNotFoundError:\n...    gpd = None\n>>> import matplotlib.pylab as plt\n>>> from os.path import isdir\n>>> examples_dir = '../examples'\n>>> if not isdir(examples_dir):\n...    examples_dir = 'examples'\n>>> wn = wntr.network.model.WaterNetworkModel(examples_dir+'/networks/Net1.inp')\n```\n\n----------------------------------------\n\nTITLE: Creating WaterNetworkModel and GIS Conversion for Raster Sampling (Python)\nDESCRIPTION: This snippet illustrates loading an EPANET network file and converting its nodes and links into GIS-compatible GeoDataFrames for further spatial analysis such as raster sampling. It uses wntr.network.WaterNetworkModel to read the INP file and wntr.network.to_gis for conversion with a specified CRS. The file 'networks/Net1.inp' and 'EPSG:4326' CRS are required, along with WNTR and GeoPandas.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/gis.rst#_snippet_35\n\nLANGUAGE: python\nCODE:\n```\n>>> wn = wntr.network.WaterNetworkModel('networks/Net1.inp') # doctest: +SKIP\n>>> wn_gis = wntr.network.to_gis(wn, crs='EPSG:4326')\n```\n\n----------------------------------------\n\nTITLE: Visualizing Seismic Hazard Metrics on Network Map using WNTR (Python)\nDESCRIPTION: Generates three network plots using `wntr.graphics.plot_network`. The first plot visualizes the distance of each pipe to the earthquake epicenter. The second plot shows the calculated Peak Ground Acceleration (PGA) along each pipe. The third plot displays the Peak Ground Velocity (PGV) along each pipe. All plots use a specified colormap (`cmap`) to represent the intensity of the metric.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/earthquake_tutorial.ipynb#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n# Plot Distance to Epicenter\nwntr.graphics.plot_network(wn, link_attribute=R, node_size=0, link_cmap = cmap, title='Distance to Epicenter')\n\n# Plot PGA\nwntr.graphics.plot_network(wn, link_attribute=pga, node_size=0, link_cmap = cmap, link_width=1.5, title='Peak Ground Acceleration (PGA)')\n\n# Plot PGV\nwntr.graphics.plot_network(wn, link_attribute=pgv, node_size=0, link_cmap = cmap, link_width=1.5, title='Peak Ground Velocity (PVA)')\n```\n\n----------------------------------------\n\nTITLE: Mapping and Plotting Damage States on the Network with WNTR in Python\nDESCRIPTION: This snippet converts sampled damage states to priority values using the fragility curve's priority mapping and visualizes the results on the network. It uses WNTR's graphics module to create a custom colormap and plot the network with link attributes colored by damage state. Dependencies are wntr and matplotlib. Required inputs are the network object, the damage state or priority map, and color table. Output is a network damage state plot reflecting the assigned damage categories.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/fragility.rst#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n>>> priority_map = FC.get_priority_map()\\n>>> damage_value = damage_state.map(priority_map)\\n>>> custom_cmp = wntr.graphics.custom_colormap(3, ['grey', 'royalblue', 'darkorange'])\\n>>> ax = wntr.graphics.plot_network(wn, link_attribute=damage_value, \\n...     node_size=0, link_width=2, link_cmap=custom_cmp, \\n...     title='Damage state: 0=None, 1=Minor, 2=Major') \n```\n\n----------------------------------------\n\nTITLE: Writing WaterNetworkModel Components to Separate GeoJSON Files in Python\nDESCRIPTION: Uses the `wntr.network.write_geojson` function to export components (junctions, tanks, reservoirs, pipes, pumps) of a `WaterNetworkModel` (`wn`) into separate GeoJSON files. The base filename 'Net3' is provided, resulting in files like 'Net3_junctions.geojson'. Requires WNTR, GeoPandas, and an existing `WaterNetworkModel`. Excludes non-spatial data like patterns and controls. The snippet is skipped if GeoPandas (`gpd`) is not installed.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/model_io.rst#_snippet_14\n\nLANGUAGE: python\nCODE:\n```\n>>> wntr.network.write_geojson(wn, 'Net3')\n```\n\n----------------------------------------\n\nTITLE: Plotting Interactive Tank Head Time-Series with Plotly - Python\nDESCRIPTION: This snippet transforms a tank head DataFrame's time index from seconds to hours, plots it as a line chart using Plotly Express, customizes the layout with axis labels and dimensions, and writes the figure as an interactive HTML file. It requires the tankH DataFrame to be defined and the plotly.express package installed. The input DataFrame should have a numeric index representing time, and the output is an interactive line chart saved as 'tank_head.html'.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/graphics.rst#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\n>>> tankH.index /= 3600 # convert time to hours\n>>> fig = px.line(tankH)\n>>> fig = fig.update_layout(xaxis_title='Time (hr)', yaxis_title='Head (ft)', \n...                   template='simple_white', width=650, height=400) \n>>> fig.write_html('tank_head.html')\n```\n\n----------------------------------------\n\nTITLE: Visualizing Network Pressure With and Without Repairs (Python)\nDESCRIPTION: Extracts node pressure time series from both simulation results (without repair `results` and with repair `results_wrepair`). Converts the time index from seconds to hours for plotting. Generates network plots showing pressure distribution at 24 hours for both scenarios using `wntr.graphics.plot_network`. Creates a time series plot comparing the average system pressure (calculated across all junctions) over the simulation duration for the 'Without Repair' and 'With Repair' scenarios.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/earthquake_tutorial.ipynb#_snippet_13\n\nLANGUAGE: python\nCODE:\n```\npressure = results.node['pressure']\npressure_wrepair = results_wrepair.node['pressure']\npressure.index = pressure.index/3600\npressure_wrepair.index = pressure_wrepair.index/3600\n\n# Plot pressure 24hr into simulation without repair\npressure_at_24hr = pressure.loc[24,wn.junction_name_list]\nwntr.graphics.plot_network(wn, node_attribute=pressure_at_24hr, node_size=20, \n                           node_range=[0,90], node_cmap = cmap, node_colorbar_label='Pressure (m)', \n                           title='Pressure at 24 hours, Without Repair')\n\n# Plot pressure 24hr into simulation with partial repair\npressure_at_24hr_wrepair = pressure_wrepair.loc[24,wn.junction_name_list]\nwntr.graphics.plot_network(wn, node_attribute=pressure_at_24hr_wrepair, node_size=20, \n                           node_range=[0,90], node_cmap = cmap, node_colorbar_label='Pressure (m)', \n                           title='Pressure at 24 hours, With Repair')\n \n# Plot average system pressure with and without partial repairs\nplt.figure()\nax = plt.gca()\npressure.loc[:,wn.junction_name_list].mean(axis=1).plot(label='Without Repair', ax=ax)\npressure_wrepair.loc[:,wn.junction_name_list].mean(axis=1).plot(label='With Repair', ax=ax)\nax.set_xlabel('Time (hr)')\nax.set_ylabel('Average system pressure (m)')\nax.legend()\n```\n\n----------------------------------------\n\nTITLE: Visualizing Earthquake Epicenter on Water Network Map using WNTR (Python)\nDESCRIPTION: Uses the WNTR graphics module to plot the water network layout without displaying nodes initially. It then overlays a marker (a red star) at the defined epicenter coordinates to visually represent the earthquake's location relative to the network infrastructure.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/earthquake_tutorial.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nax = wntr.graphics.plot_network(wn, node_size=0)\nax.scatter(epicenter[0], epicenter[1], s=500, c='r', marker='*', zorder=2)\n```\n\n----------------------------------------\n\nTITLE: Generating Valve Segments and Segmenting by Valve Layer (Python)\nDESCRIPTION: This example shows how to randomly generate a valve layer and segment the network accordingly using WNTR metrics. Function inputs include the network model `wn`, a segmentation type ('random'), and number of valves. The outputs are node and link segment groupings and their sizes, facilitating analysis of isolation zones.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/resilience.rst#_snippet_11\n\nLANGUAGE: python\nCODE:\n```\n>>> valve_layer = wntr.network.generate_valve_layer(wn, 'random', 40)\n>>> node_segments, link_segments, segment_size = wntr.metrics.valve_segments(G, \n...     valve_layer)\n```\n\n----------------------------------------\n\nTITLE: Running Hydraulic Simulation and Computing Metrics for GeoJSON Model - Python\nDESCRIPTION: Executes hydraulic simulation on the model reconstructed from perfect GeoJSON files and extracts node pressures plus average expected demand. Like the base case, negative pressures are constrained to zero. Prepares model metrics for side-by-side comparison with original INP-derived results.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/model_development_tutorial.ipynb#_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nsim = wntr.sim.EpanetSimulator(wn1)\\nresults1 = sim.run_sim()\\n\\npressure1 = results1.node[\"pressure\"].loc[0, :]\\npressure1[pressure1<0] = 0 # remove negative pressure\\naed1 = wntr.metrics.average_expected_demand(wn1)\\n\n```\n\n----------------------------------------\n\nTITLE: Computing and Plotting Valve Segment Attributes in WNTR - Python\nDESCRIPTION: This snippet calculates attributes for each valve segment, such as the number of surrounding valves, using WNTR metrics. The results are visualized by coloring the valves on the network according to their attribute values. Dependencies are valve_layer, node_segments, link_segments, and wntr.graphics/metrics modules. Input is typically the generated valve segmentation on a network, output is an axis showing colored attribute mapping.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/graphics.rst#_snippet_15\n\nLANGUAGE: python\nCODE:\n```\n>>> valve_attributes = wntr.metrics.valve_segment_attributes(valve_layer, node_segments, \n...     link_segments)\n>>> ax = wntr.graphics.plot_valve_layer(wn, valve_layer, \n...     valve_attributes['num_surround'], colorbar_label='Surrounding valves')\n```\n\n----------------------------------------\n\nTITLE: Adding Demand Patterns to Water Network Model - Python\nDESCRIPTION: Assigns a time-varying demand pattern using a list of multipliers to the model's default demand pattern. This code injects diurnal usage variability into simulation results, crucial for realistic demand modeling. Inputs: list of multipliers, default pattern name from model options. Output is model state with new pattern added.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/model_development_tutorial.ipynb#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nmultipliers = [\\n    0.33, 0.25, 0.209, 0.209, 0.259, 0.36,\\n    0.529, 0.91, 1.2, 1.299, 1.34, 1.34,\\n    1.32, 1.269, 1.25, 1.25, 1.279, 1.37,\\n    1.519, 1.7, 1.75, 1.669, 0.899, 0.479,\\n]\\ndefault_pattern_name = wn1.options.hydraulic.pattern\\nwn1.add_pattern(default_pattern_name, multipliers)\\n\n```\n\n----------------------------------------\n\nTITLE: Generating Interactive Plotly Network Visualization - Python\nDESCRIPTION: Creates an interactive HTML visualization of the water network using plotly, coloring network nodes by population. The function accepts node attributes and range settings, saves the output to a file, and suppresses auto-opening. Requires the 'plotly' Python package (optional dependency), as well as access to population metrics and the water network model.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/graphics.rst#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n>>> pop = wntr.metrics.population(wn)\n>>> wntr.graphics.plot_interactive_network(wn, node_attribute=pop, \n...    node_range=[0,500], filename='population.html', auto_open=False)\n```\n\n----------------------------------------\n\nTITLE: Computing Water Age and Plotting Average over 48 Hours - Python\nDESCRIPTION: Configures and executes a water quality simulation with the age parameter, extracts the last 48 hours of results, computes average age (in hours), and visualizes it. Inputs: WaterNetworkModel wn. Outputs: plot of average water age, highlighting possible stagnation. Must use wntr.sim.EpanetSimulator, wntr.graphics, and assumes simulation period exceeds 48 hours.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/basics_tutorial.ipynb#_snippet_70\n\nLANGUAGE: python\nCODE:\n```\n# Compute water age using the last 48 hours of a water quality simulation\\nwn.options.quality.parameter = 'AGE'\\nsim = wntr.sim.EpanetSimulator(wn)\\nresults = sim.run_sim()\\n\\nage = results.node['quality']\\nage_last_48h = age.loc[age.index[-1]-48*3600:age.index[-1]]\\naverage_age = age_last_48h.mean()/3600 # convert to hours for the plot\\nax = wntr.graphics.plot_network(wn, node_attribute=average_age, title=\\\"Average water age (hr)\\\")\n```\n\n----------------------------------------\n\nTITLE: Looping Over Tanks Using Generators in WaterNetworkModel - Python\nDESCRIPTION: Demonstrates iterating over tank names and objects using the wn.tanks() generator, printing the maximum level for each tank. Requires a WaterNetworkModel instance (wn). Useful for quickly accessing and operating on tank objects; outputs tank names and their max_level attributes to standard output.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/basics_tutorial.ipynb#_snippet_36\n\nLANGUAGE: python\nCODE:\n```\n# Loop over tank names and objects with a generator\\nfor name, tank in wn.tanks():\\n    print(\\\"Max level for tank\\\", name, \\\"=\\\", tank.max_level)\n```\n\n----------------------------------------\n\nTITLE: Importing WNTR and Creating a WaterNetworkModel from INP File\nDESCRIPTION: This snippet demonstrates the basic steps to start using WNTR. It imports the WNTR library and then creates a `WaterNetworkModel` object by loading network data from an EPANET INP file ('networks/Net3.inp'). The `doctest: +SKIP` flag indicates this line might be skipped during automated testing, potentially due to file path dependencies.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/waternetworkmodel.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n>>> import wntr\n\t\n>>> wn = wntr.network.WaterNetworkModel('networks/Net3.inp') # doctest: +SKIP\n```\n\n----------------------------------------\n\nTITLE: Querying Node Attributes in WNTR (Python)\nDESCRIPTION: Demonstrates querying specific attributes of nodes within a WNTR water network model (`wn`). The first example retrieves the 'elevation' attribute for all nodes of type Junction. The second example filters the query, retrieving elevations only for junctions where the elevation is greater than or equal to 10, using `numpy.greater_equal`. Requires the `wntr` and `numpy` libraries.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/waternetworkmodel.rst#_snippet_21\n\nLANGUAGE: python\nCODE:\n```\n>>> junction_elevation = wn.query_node_attribute('elevation', \n...     node_type=wntr.network.model.Junction)\n>>> junction_elevation_10 = wn.query_node_attribute('elevation', np.greater_equal, \n...     10, node_type=wntr.network.model.Junction)\n```\n\n----------------------------------------\n\nTITLE: Reading Demographic GeoDataFrame for Census Tracts using GeoPandas (Python)\nDESCRIPTION: This snippet demonstrates loading demographic polygon data (mean income, mean age, population) as a GeoPandas GeoDataFrame. The geometries are polygons (shapely), representing census tracts. The file 'Net1_demographic_data.geojson' must exist, and GeoPandas is required. This input is necessary for subsequent intersection and attribute assignment operations.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/gis.rst#_snippet_30\n\nLANGUAGE: python\nCODE:\n```\n>>> demographic_data = gpd.read_file('data/Net1_demographic_data.geojson') # doctest: +SKIP\n>>> print(demographic_data)\n   mean_income  mean_age  population                                           geometry\n0      63326.0      35.0      3362.0  POLYGON ((41.67813 82.75023, 41.98596 60.85779...\n1      78245.0      31.0      5618.0  POLYGON ((23.21084 40.1916, 22.99063 27.71777,...\n2      91452.0      40.0      5650.0  POLYGON ((22.99063 27.71777, 61.9372 16.36165,...\n3      54040.0      39.0      5546.0  POLYGON ((61.9372 16.36165, 22.99063 27.71777,...\n4      26135.0      38.0      5968.0  POLYGON ((61.9372 16.36165, 64.04456 22.10119,...\n5      57620.0      31.0      4315.0  POLYGON ((44.48497 87.21487, 79.81144 71.92669...\n6      44871.0      54.0      4547.0  POLYGON ((64.04456 22.10119, 51.72994 45.92347...\n7      69067.0      55.0      2541.0  POLYGON ((46.01047 99.15725, 46.40654 99.33204...\n```\n\n----------------------------------------\n\nTITLE: Removing a Specific Demand Time Series from a Junction\nDESCRIPTION: This snippet demonstrates how to remove a specific demand time series from a junction's demand list. It uses the Python `del` keyword with list indexing to remove the second demand time series (index 1) previously added to the `junction` object (junction '121'). It then prints the remaining demand time series list.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/waternetworkmodel.rst#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\n>>> del junction.demand_timeseries_list[1]\n>>> print(junction.demand_timeseries_list)\n<Demands: [<TimeSeries: base_value=0.002626444876132, pattern_name='1', category='None'>]>\n```\n\n----------------------------------------\n\nTITLE: Initializing Water Network Model and Graph Structures (Python)\nDESCRIPTION: This snippet demonstrates how to initialize a WaterNetworkModel from an input file using WNTR, and then convert it to a directed multigraph and its undirected representations. Dependencies include the WNTR and NetworkX libraries. Inputs include the path to an EPANET .inp file; outputs are the corresponding graph objects for further analysis.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/resilience.rst#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n>>> wn = wntr.network.WaterNetworkModel('networks/Net3.inp') # doctest: +SKIP\n>>> G = wn.to_graph() # directed multigraph\n>>> uG = G.to_undirected() # undirected multigraph\n>>> sG = nx.Graph(uG) # undirected simple graph (single edge between two nodes)\n```\n\n----------------------------------------\n\nTITLE: Loading External GIS Datasets with GeoPandas - Python\nDESCRIPTION: This snippet demonstrates reading multiple GIS datasets in GeoJSON format with GeoPandas. It loads demographic, landslide, earthquake, hydrant, and valve data for use in network analysis, conditioned on the presence of GeoPandas. The code assumes all files are located under the examples/data directory, and the resulting variables are GeoDataFrames for each dataset. Dependency: geopandas.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/gis.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n>>> demographic_data = gpd.read_file(examples_dir+'/data/Net1_demographic_data.geojson')\n>>> landslide_data = gpd.read_file(examples_dir+'/data/Net1_landslide_data.geojson')\n>>> earthquake_data = gpd.read_file(examples_dir+'/data/Net1_earthquake_data.geojson')\n>>> hydrant_data = gpd.read_file(examples_dir+'/data/Net1_hydrant_data.geojson')\n>>> valve_data = gpd.read_file(examples_dir+'/data/Net1_valve_data.geojson')\n```\n\n----------------------------------------\n\nTITLE: Accessing Component GeoDataFrames from WaterNetworkGIS - Python\nDESCRIPTION: This snippet shows how to individually access GeoDataFrames for junctions, tanks, reservoirs, pipes, pumps, and valves from a WaterNetworkGIS object created by WNTR. Each component is accessed as an attribute. Example comments indicate that the sample network Net1 has no valves, so the valves frame is empty. Dependency: wntr, geopandas.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/gis.rst#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n>>> wn_gis.junctions # doctest: +SKIP\n>>> wn_gis.tanks # doctest: +SKIP\n>>> wn_gis.reservoirs # doctest: +SKIP\n>>> wn_gis.pipes # doctest: +SKIP\n>>> wn_gis.pumps # doctest: +SKIP\n>>> wn_gis.valves # doctest: +SKIP\n```\n\n----------------------------------------\n\nTITLE: Converting WNTR Model to GeoDataFrames using to_gis in Python\nDESCRIPTION: This snippet converts the WNTR `WaterNetworkModel` object (`wn`) into GeoDataFrames using the `to_gis` method. It specifies the Coordinate Reference System (CRS) as EPSG:4269. The resulting `wn_gis` object contains spatially referenced data for network components (like junctions), enabling geospatial operations.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/salt_water_intrusion_tutorial.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nwn_gis = wn.to_gis(crs=\"EPSG:4269\")\n```\n\n----------------------------------------\n\nTITLE: Appending a New Demand Time Series to a Junction\nDESCRIPTION: This snippet demonstrates adding a new demand time series to a junction using a pattern object. It first retrieves a pattern object named '3' from the model using `get_pattern`. Then, it appends a tuple containing the new base demand (0.001) and the retrieved pattern object (`pat`) to the junction's `demand_timeseries_list`.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/waternetworkmodel.rst#_snippet_12\n\nLANGUAGE: python\nCODE:\n```\n>>> pat = wn.get_pattern('3')\n>>> junction.demand_timeseries_list.append((0.001, pat))\n```\n\n----------------------------------------\n\nTITLE: Plotting Fragility-Based Damage States over the Network - Python\nDESCRIPTION: Maps numeric damage states from sample results, applies a custom colormap, and visualizes pipe damage state over the network. Shows 3 classes (None, Minor, Major), and uses wntr.graphics.custom_colormap for color mapping. Output is a link-colored network plot annotated by damage class. Useful for rapid risk communication.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/basics_tutorial.ipynb#_snippet_76\n\nLANGUAGE: python\nCODE:\n```\n# Plot damage state (converted to numeric values) on the network\\npriority_map = FC.get_priority_map()\\ndamage_value = damage_state.map(priority_map)\\ncustom_cmp = wntr.graphics.custom_colormap(3, ['grey', 'royalblue', 'darkorange'])\\nax = wntr.graphics.plot_network(wn, link_attribute=damage_value,\\n    node_size=0, link_width=2, link_cmap=custom_cmp,\\n    title='Damage state: 0=None, 1=Minor, 2=Major')\n```\n\n----------------------------------------\n\nTITLE: Creating Rules with Conditions and Priority in WNTR (Python)\nDESCRIPTION: This snippet illustrates the creation of `Rule` objects in WNTR. It first defines a `SimTimeCondition` (`cond2`) that triggers when simulation time is greater than or equal to 121 hours. It then creates `rule1` using a previously defined condition (`cond1`) and action (`act1`). Subsequently, it defines `rule2` using the new time condition (`cond2`) and another action (`act2`), explicitly setting its priority to high (5). Both rules are printed. This requires a WNTR `WaterNetworkModel` instance (`wn`) and pre-defined conditions (`cond1`) and actions (`act1`, `act2`).\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/controls.rst#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n>>> cond2 = controls.SimTimeCondition(wn, controls.Comparison.ge, '121:00:00')\n\n>>> rule1 = controls.Rule(cond1, [act1], name='rule1')\n>>> print(rule1)\nIF TANK 1 LEVEL ABOVE 46.0248 THEN PIPE 330 STATUS IS OPEN PRIORITY 3\n\n>>> pri5 = controls.ControlPriority.high\n>>> rule2 = controls.Rule(cond2, [act2], name='rule2', priority=pri5)\n>>> print(rule2)\nIF SYSTEM TIME >= 121:00:00 THEN PUMP 10 STATUS IS OPEN PRIORITY 5\n```\n\n----------------------------------------\n\nTITLE: Adding Attributes Directly to a GeoDataFrame - Python\nDESCRIPTION: This snippet demonstrates how to add a custom attribute ('new attribute') with the value 10 to the junctions GeoDataFrame directly, enhancing node data for analysis or map-based display. Input: GeoDataFrame and new column values; Output: Modified GeoDataFrame with the additional column. Dependency: geopandas.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/gis.rst#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\n>>> wn_gis.junctions['new attribute'] = 10\n```\n\n----------------------------------------\n\nTITLE: Reading GeoJSON water network files with WNTR in Python\nDESCRIPTION: This code demonstrates how to read a set of GeoJSON files representing different water network components (junctions, tanks, reservoirs, pipes, pumps) into a WaterNetworkModel using WNTR's network.read_geojson function. It assumes all referenced GeoJSON files exist and are formatted according to WNTR's standards. The geojson_files dictionary must correctly map each component (e.g., 'junctions') to the appropriate path, and WNTR and its dependencies (like GeoPandas for geometry support) must be installed. The output is a WaterNetworkModel object instantiated from the provided GIS data.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/model_io.rst#_snippet_16\n\nLANGUAGE: python\nCODE:\n```\nwn2 = wntr.network.read_geojson(geojson_files)\n```\n\n----------------------------------------\n\nTITLE: Reading Hydrant GeoJSON Data with GeoPandas in Python\nDESCRIPTION: This code reads geospatial data for hydrants from a GeoJSON file ('data/Net1_hydrant_data.geojson') into a GeoPandas GeoDataFrame using the `gpd.read_file` function. The resulting GeoDataFrame contains columns for hydrant attributes (like 'demand') and a 'geometry' column holding the Point geometries for each hydrant. The content of the loaded GeoDataFrame is then printed.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/gis.rst#_snippet_18\n\nLANGUAGE: python\nCODE:\n```\n>>> import geopandas as gpd\n\t\n>>> hydrant_data = gpd.read_file('data/Net1_hydrant_data.geojson') # doctest: +SKIP\n>>> print(hydrant_data)\n   demand           geometry\n0    5000  POINT (48.2 37.2)\n1    1500  POINT (71.8 68.3)\n2    8000  POINT (51.2 71.1)\n```\n\n----------------------------------------\n\nTITLE: Breaking Pipes in WaterNetworkModel - Python\nDESCRIPTION: Breaks a pipe by splitting it into two with distinct junctions, disconnecting flow across the break. Uses wntr.morph.break_pipe with specified pipe and new junction/pipe names; returns a modified WaterNetworkModel. Input is the pipe to break; outputs a model with updated topology.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/basics_tutorial.ipynb#_snippet_39\n\nLANGUAGE: python\nCODE:\n```\n# Break pipe 121\\nwn = wntr.morph.break_pipe(wn, pipe_name_to_split='121', new_pipe_name='121_B', \\n                           new_junction_name_old_pipe='121_node', new_junction_name_new_pipe='121B_node')\n```\n\n----------------------------------------\n\nTITLE: Loading WNTR Model and Converting to GIS Representation in Python\nDESCRIPTION: Loads a water network model from an EPANET INP file using `wntr.network.WaterNetworkModel` and then converts it into a WNTR GIS object using `wntr.network.to_gis`, assigning a specific Coordinate Reference System (CRS). Requires `geopandas`.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/gis.rst#_snippet_42\n\nLANGUAGE: python\nCODE:\n```\n>>> wn = wntr.network.WaterNetworkModel('networks/Net1.inp') # doctest: +SKIP\n>>> wn_gis = wntr.network.to_gis(wn, crs='EPSG:2236')\n>>> original_pipes = wn_gis.pipes\n```\n\n----------------------------------------\n\nTITLE: Simulating Segment Breaks and Identifying Impacts in Python\nDESCRIPTION: Iterates through each unique segment identified by `link_segments.unique()`. In each iteration, it reloads the network model, sets PDD simulation options, identifies pipes belonging to the current segment, and adds controls to close these pipes at `start_time`. A WNTR simulation is run within a try-except block to handle potential convergence errors. If successful, it calculates impacted junctions (those falling below minimum pressure, excluding those identified during normal conditions). Results (list of impacted junctions or None on failure) are stored in `analysis_results` keyed by segment ID.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/pipe_segments_tutorial.ipynb#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\n# Create dictionary to save results\nanalysis_results = {}\n\n# Simulate segment break (simulated as multiple pipe closures) for each segment\nfor segment in link_segments.unique():\n    wn = wntr.network.WaterNetworkModel(inp_file)\n    wn.options.hydraulic.demand_model = 'PDD'    \n    wn.options.time.duration = total_duration\n    wn.options.hydraulic.minimum_pressure = minimum_pressure\n    wn.options.hydraulic.required_pressure = required_pressure\n\n    # Identify pipes within the segment\n    pipes_in_seg = link_segments[link_segments == segment]\n    \n    for pipe_name in pipes_in_seg.index:\n        # Create pipe closure control and apply to pipe of interest\n        pipe = wn.get_link(pipe_name) \n        act = wntr.network.controls.ControlAction(pipe, 'status', 0)\n        cond = wntr.network.controls.SimTimeCondition(wn, 'Above', start_time)\n        ctrl = wntr.network.controls.Control(cond, act)\n        wn.add_control('close pipe ' + pipe_name, ctrl)\n        \n    try:\n        # Simulate hydraulics\n        sim = wntr.sim.WNTRSimulator(wn)\n        sim_results = sim.run_sim()\n \n        # Using pressure results, identify impacted junctions\n        sim_pressure = sim_results.node['pressure'].loc[start_time::, nzd_junct]\n        sim_pressure_below_pmin = sim_pressure.columns[(sim_pressure < minimum_pressure).any()]\n        impacted_junctions = set(sim_pressure_below_pmin) - set(normal_pressure_below_pmin)\n        impacted_junctions = list(impacted_junctions)\n        \n    except Exception as e:\n        # Identify failed simulations and the reason\n        impacted_junctions = None\n        print(segment, ' Failed:', e)\n\n    finally:\n        # Save simulation results\n        analysis_results[segment] = impacted_junctions\n```\n\n----------------------------------------\n\nTITLE: Building a WNTR Water Network Model from Scratch (Python)\nDESCRIPTION: Demonstrates creating a new, empty `WaterNetworkModel` using `wntr.network.WaterNetworkModel()` and programmatically adding network components. It shows adding demand patterns (`add_pattern`), junctions (`add_junction`) with specific properties like base demand and coordinates, pipes (`add_pipe`) connecting nodes, and a reservoir (`add_reservoir`). Finally, it plots the constructed network using `wntr.graphics.plot_network`. Requires the `wntr` library.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/waternetworkmodel.rst#_snippet_24\n\nLANGUAGE: python\nCODE:\n```\n>>> wn = wntr.network.WaterNetworkModel()\n>>> wn.add_pattern('pat1', [1])\n>>> wn.add_pattern('pat2', [1,2,3,4,5,6,7,8,9,10])\n>>> wn.add_junction('node1', base_demand=0.01, demand_pattern='pat1', elevation=100, \n...     coordinates=(1,2))\n>>> wn.add_junction('node2', base_demand=0.02, demand_pattern='pat2', elevation=50, \n...     coordinates=(1,3))\n>>> wn.add_pipe('pipe1', 'node1', 'node2', length=304.8, diameter=0.3048, \n...    roughness=100, minor_loss=0.0, initial_status='OPEN')\n>>> wn.add_reservoir('res', base_head=125, head_pattern='pat1', coordinates=(0,2))\n>>> wn.add_pipe('pipe2', 'node1', 'res', length=100, diameter=0.3048, roughness=100, \n...     minor_loss=0.0, initial_status='OPEN')\n>>> ax = wntr.graphics.plot_network(wn)\n```\n\n----------------------------------------\n\nTITLE: Listing and Managing Controls in WNTR Water Networks (Python)\nDESCRIPTION: These code blocks retrieve the list of control names, print all controls, access and modify individual controls, add a time-based pump control, and remove a control. They all rely on the WNTR controls API to automate network behavior in simulation.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/basics_tutorial.ipynb#_snippet_29\n\nLANGUAGE: python\nCODE:\n```\n# Get a list of control names\\nwn.control_name_list\n```\n\nLANGUAGE: python\nCODE:\n```\n# Print all controls\\nfor name, controls in wn.controls():\\n    print(name, controls)\n```\n\nLANGUAGE: python\nCODE:\n```\n# Get a specific control object\\ncontrol = wn.get_control('control 18')\\nprint(control)\n```\n\nLANGUAGE: python\nCODE:\n```\n# Modify the control priority\\ncontrol.update_priority(1)\\nprint(control)\n```\n\nLANGUAGE: python\nCODE:\n```\n# Add a time based pump control\\npump = wn.get_link('10')\\naction = wntr.network.controls.ControlAction(pump, 'status', 1)\\ncondition = wntr.network.controls.SimTimeCondition(wn, '=', '121:00:00')\\ncontrol = wntr.network.controls.Control(condition, action, name='new_control')\\nwn.add_control('NewControl', control)\\nprint(wn.control_name_list)\n```\n\nLANGUAGE: python\nCODE:\n```\n# Remove a control\\nwn.remove_control('NewControl')\\nprint(wn.control_name_list)\n```\n\n----------------------------------------\n\nTITLE: Resampling a Pattern with New Time Parameters in WNTR Python\nDESCRIPTION: This code demonstrates copying an existing demand pattern ('Net2_1'), renaming it ('Net2_1_resampled'), and resampling its multipliers with a new duration, timestep, and start time. It then plots both the original and resampled patterns for comparison. This is useful for adapting patterns to different simulation requirements. Dependencies are wntr, pandas, and matplotlib. Key parameters include original and desired timestep, duration, and start clocktime.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/libraries.rst#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\n>>> demand_library.copy_pattern('Net2_1', 'Net2_1_resampled')\n>>> series = demand_library.resample_multipliers('Net2_1_resampled', duration=3*24*3600,\n...     pattern_timestep=7200, start_clocktime=0)\n>>> ax = demand_library.plot_patterns(names=['Net2_1', 'Net2_1_resampled'])\n```\n\n----------------------------------------\n\nTITLE: Adding Demand to Junction in WNTR (Python)\nDESCRIPTION: Adds an additional demand to a specified junction ('15') by calling 'add_demand' with defined base flow and pattern name. The updated demand_timeseries_list is printed for verification.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/basics_tutorial.ipynb#_snippet_26\n\nLANGUAGE: python\nCODE:\n```\n# Add a demand to Junction 15\\njunction.add_demand(base=0.015, pattern_name='1')\\nprint(junction.demand_timeseries_list)\n```\n\n----------------------------------------\n\nTITLE: Exporting WNTR Network and Analysis Results to GeoJSON in Python\nDESCRIPTION: This snippet uses the `write_geojson` method of the `WaterNetworkGIS` object (`wn_gis`) to export the water network model, including any associated geospatial data and added analysis attributes (like centrality or flowrate), into GeoJSON files. The base name for the output files is specified as 'Net3_analysis'. This allows the enhanced network data to be easily loaded and visualized in standard GIS software.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/basics_tutorial.ipynb#_snippet_97\n\nLANGUAGE: python\nCODE:\n```\n# Write the model and analysis results to GIS compatible files.  These files can be loaded into GIS platforms for further analysis.\nwn_gis.write_geojson('Net3_analysis')\n```\n\n----------------------------------------\n\nTITLE: Modifying Source Strength - WNTR - Python\nDESCRIPTION: This code retrieves a previously-added source ('Source'), prints its current configuration, changes its strength from 1000 to 1500, and prints the updated source object. It requires the existence of a source named 'Source' in the model. Outputs are Source string representations before and after updating the strength_timeseries base value.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/waterquality.rst#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\n>>> source = wn.get_source('Source')\n>>> print(source)                                                                                        \n<Source: 'Source', '121', 'SETPOINT', 1000, SourcePattern, None>\n\n>>> source.strength_timeseries.base_value = 1500\n>>> print(source)\n<Source: 'Source', '121', 'SETPOINT', 1500, SourcePattern, None>\n```\n\n----------------------------------------\n\nTITLE: Skeletonizing a WNTR Network and Plotting Comparison in Python\nDESCRIPTION: This snippet demonstrates loading a water network model ('Net6.inp') using `wntr.network.WaterNetworkModel`, displaying its initial component count with `wn.describe()`, performing network skeletonization using `wntr.morph.skeletonize` with a diameter threshold of 12 inches (converted to meters), displaying the component count of the skeletonized network, and finally plotting both the original and skeletonized networks side-by-side using `wntr.graphics.plot_network` and Matplotlib for visual comparison. It depends on the WNTR and Matplotlib libraries. The hidden setup code ensures the `wn` object is created correctly regardless of the execution path.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/morph.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n>>> import matplotlib.pylab as plt\n>>> import wntr  # doctest: +SKIP\n\t\n>>> wn = wntr.network.WaterNetworkModel('networks/Net6.inp') # doctest: +SKIP\n>>> wn.describe()\n{'Nodes': 3356, 'Links': 3892, 'Patterns': 3, 'Curves': 60, 'Sources': 0, 'Controls': 124}\n\n>>> skel_wn = wntr.morph.skeletonize(wn, 12*0.0254)\n>>> skel_wn.describe()\n{'Nodes': 1154, 'Links': 1610, 'Patterns': 3, 'Curves': 60, 'Sources': 0, 'Controls': 124}\n\n>>> fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(10,5))\n>>> ax = wntr.graphics.plot_network(wn, node_size=10, title='Original', \n...     ax=ax1) \n>>> ax = wntr.graphics.plot_network(skel_wn, node_size=10, \n...     title='Skeletonized', ax=ax2)\n```\n\n----------------------------------------\n\nTITLE: Running Hydraulic Simulation on Skeletonized and Original Models - Python\nDESCRIPTION: Executes hydraulic simulations on both original and skeletonized networks using EPANetSimulator, capturing full results each time. Simulations are run sequentially, with separate results objects for comparison. Used to quantify changes in pressure and flow distribution due to skeletonization.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/basics_tutorial.ipynb#_snippet_80\n\nLANGUAGE: python\nCODE:\n```\n# Simulate hydraulics on the original and skeletonized models and plot average pressure\\nsim = wntr.sim.EpanetSimulator(wn)\\nresults_original = sim.run_sim()\\n\\nsim = wntr.sim.EpanetSimulator(skel_wn)\\nresults_skel = sim.run_sim()\n```\n\n----------------------------------------\n\nTITLE: Calculating and Plotting Average Expected Demand using WNTR (Python)\nDESCRIPTION: Calculates and plots the average expected demand over a 24-hour period with 'average_expected_demand'. The resulting plot visualizes demand distribution, and requires Matplotlib for rendering.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/basics_tutorial.ipynb#_snippet_21\n\nLANGUAGE: python\nCODE:\n```\n# Compute and plot average expected demand \\nAED = wntr.metrics.average_expected_demand(wn)\\nprint(AED.head())\\nax = wntr.graphics.plot_network(wn, node_attribute=AED, node_range=(0,0.025), title='Average expected demand (m$^3$/s)')\n```\n\n----------------------------------------\n\nTITLE: Reading Elevation and Building GeoJSON Data - Python\nDESCRIPTION: Prepares additional geospatial layers (elevation raster and building footprints) necessary to augment incomplete water network datasets. Elevation file path is stored as a string, and building footprints loaded, reprojected, and used for spatial context. These are external sources, required for resolving incomplete/inaccurate inputs.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/model_development_tutorial.ipynb#_snippet_17\n\nLANGUAGE: python\nCODE:\n```\n# Additional datasets include elevation data and building data\\nelevation_data_file = 'data/ky4_elevation.tif' \\n\\nbuildings = gpd.read_file(\"data/ky4_buildings.geojson\", crs=crs)\\nbuildings.to_crs(crs, inplace=True)\\n\n```\n\n----------------------------------------\n\nTITLE: Scaling Node Coordinates using WNTR in Python\nDESCRIPTION: This code loads a water network model from an EPANET INP file and creates a copy with all node coordinates scaled by a factor (here, 100 meters). Dependencies are wntr and an accessible INP file. Parameters: path to INP file (as string), scale factor (as numeric). Outputs a new WaterNetworkModel with scaled node coordinates. The operation does not modify the original model and cannot be applied if the file is missing.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/morph.rst#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\n>>> wn = wntr.network.WaterNetworkModel('networks/Net3.inp') # doctest: +SKIP\n>>> wn_scaled_coord = wntr.morph.scale_node_coordinates(wn, 100)\n```\n\n----------------------------------------\n\nTITLE: Modeling Earthquake Impact and Mapping PGA to Network Pipes - Python\nDESCRIPTION: Simulates spatial distribution of peak ground acceleration (PGA) from a specified earthquake scenario (epicenter, magnitude, depth), computes the distance from epicenter to each pipe, and maps PGA values. Visualization overlays PGA on the network links. Requires wntr.morph, wntr.scenario, wntr.graphics, and numpy. Intended for vulnerability assessment.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/basics_tutorial.ipynb#_snippet_74\n\nLANGUAGE: python\nCODE:\n```\n# Model peak ground acceleration from a magnitude 6.5 earthquake, assigning values to pipes.\\nwn = wntr.morph.scale_node_coordinates(wn, 1000)\\nepicenter = (32000,15000) # x,y location\\nmagnitude = 6.5 # Richter scale\\ndepth = 10000 # m, shallow depth\\nearthquake = wntr.scenario.Earthquake(epicenter, magnitude, depth)\\ndistance = earthquake.distance_to_epicenter(wn, element_type=wntr.network.Pipe)\\npga = earthquake.pga_attenuation_model(distance)\\nax = wntr.graphics.plot_network(wn, link_attribute=pga, node_size=0, link_width=2)\n```\n\n----------------------------------------\n\nTITLE: Inspecting Link Results Dictionary Keys - WNTR Results - Python\nDESCRIPTION: This snippet retrieves and prints the keys from the link results dictionary of a simulation output, revealing which link attributes are available (such as flowrate, friction_factor, headloss, quality, reaction_rate, setting, status, velocity). Requires a results object from running a WNTR simulation, ideally with EpanetSimulator. Output is a printed list of link result keys.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/resultsobject.rst#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n>>> link_keys = results.link.keys()\n>>> print(link_keys) # doctest: +SKIP\ndict_keys(['flowrate', 'friction_factor', 'headloss', 'quality', 'reaction_rate', 'setting', 'status', 'velocity']) \n```\n\n----------------------------------------\n\nTITLE: Accessing and Inspecting Tank Objects in WNTR (Python)\nDESCRIPTION: Retrieves a tank object by name from the water network and prints its type. The returned object can be used for further attribute modification or analysis.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/basics_tutorial.ipynb#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\n# Get a tank object\\ntank = wn.get_node('1')\\nprint(type(tank))\\ntank\n```\n\n----------------------------------------\n\nTITLE: Configuring Chemical Concentration Quality Analysis - WNTR - Python\nDESCRIPTION: This snippet configures the quality options for chemical concentration simulation by setting the parameter to 'CHEMICAL'. Used to analyze chemical concentrations given a set of sources. It requires the wn object; further options such as initial_quality and sources can be configured. Output will include nodewise chemical concentrations.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/waterquality.rst#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n>>> wn.options.quality.parameter = 'CHEMICAL'\n```\n\n----------------------------------------\n\nTITLE: Running Multi-Species Simulation with EpanetSimulator in Python\nDESCRIPTION: This code demonstrates how to load a water network and an attached multi-species MSX model and then execute a simulation using WNTR. Dependencies include the 'wntr' package, and the required input files are an EPANET .inp network file and a .msx multi-species definition file. The key steps are instantiating the WaterNetworkModel, assigning an MsxModel, executing an EpanetSimulator, and retrieving simulation results. Outputs are stored in the results object, which holds quality values for each network node, link, and species.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/waterquality_msx.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n>>> import wntr # doctest: +SKIP\n  \n>>> wn = wntr.network.WaterNetworkModel('networks/Net3.inp') # doctest: +SKIP\n>>> wn.msx = wntr.msx.MsxModel('data/Net3_arsenic.msx') # doctest: +SKIP\n  \n>>> sim = wntr.sim.EpanetSimulator(wn)\n>>> results = sim.run_sim()\n```\n\n----------------------------------------\n\nTITLE: Plotting Pressure at a Node as Time Series - matplotlib - Python\nDESCRIPTION: This snippet plots the pressure over time at a specific node using the pandas plot() method, and labels the axes for time (seconds) and pressure (meters) using matplotlib. Dependencies: pandas, matplotlib, and a pressure_at_node123 pandas Series. Input: time-indexed Series of node pressures. Output: a time series plot with labeled axes. Can be customized further using matplotlib functions.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/resultsobject.rst#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\n>>> ax = pressure_at_node123.plot()\n>>> text = ax.set_xlabel(\"Time (s)\")\n>>> text = ax.set_ylabel(\"Pressure (m)\") \n```\n\n----------------------------------------\n\nTITLE: Calculating Junction and Population Impacts per Segment in Python\nDESCRIPTION: Processes the `analysis_results` dictionary from the segment break simulations. For each segment where the simulation was successful (impacted_junctions is not None), it calculates the total number of impacted junctions and the sum of the population associated with those junctions (using the previously calculated `population` series). These segment-level impact metrics are then mapped back to the individual pipes using the `link_segments` mapping, creating Series where each pipe is associated with the impact caused by breaking its segment.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/pipe_segments_tutorial.ipynb#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\n# Save junction and population impact results to dictionary\nnum_junctions_impacted_per_segment = {}\nnum_people_impacted_per_segment = {}\nfor segment, impacted_junctions in analysis_results.items():\n    if impacted_junctions is not None:\n        num_junctions_impacted_per_segment[segment] = len(impacted_junctions)\n        num_people_impacted_per_segment[segment] = population[impacted_junctions].sum()\n\n# Map segment junction and population impacts to each pipe within the segment\nnum_junctions_impacted = link_segments.map(num_junctions_impacted_per_segment)\nnum_people_impacted = link_segments.map(num_people_impacted_per_segment)\n```\n\n----------------------------------------\n\nTITLE: Simulating Normal Conditions and Identifying Low Pressure Junctions in Python\nDESCRIPTION: Checks the network's behavior under normal operating conditions before simulating breaks. It calculates Average Expected Demand (AED), identifies junctions with non-zero demand (NZD), configures the model for a PDD simulation with specified duration and pressure thresholds, runs the simulation, and identifies NZD junctions whose pressure drops below the minimum required pressure at any point during the normal simulation period.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/pipe_segments_tutorial.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n# Calculate average expected demand and identify junctions with non-zero average expected demand (AED)\nAED = wntr.metrics.average_expected_demand(wn)\nnzd_junct = AED[AED > 0].index\n\n# Set hydraulic parameters\nwn.options.hydraulic.demand_model = 'PDD'    \nwn.options.time.duration = total_duration\nwn.options.hydraulic.minimum_pressure = minimum_pressure\nwn.options.hydraulic.required_pressure = required_pressure \n\n# Run simulation\nsim = wntr.sim.WNTRSimulator(wn)\nresults = sim.run_sim()\n\n# Save junction pressure results and identify junctions that fall below minimum pressure\npressure = results.node['pressure'].loc[start_time::, nzd_junct]\nnormal_pressure_below_pmin = pressure.columns[(pressure < minimum_pressure).any()]\n```\n\n----------------------------------------\n\nTITLE: Converting WaterNetworkModel to GeoDataFrame Collection (WaterNetworkGIS) in Python\nDESCRIPTION: Converts a `WaterNetworkModel` object (`wn`) into a `WaterNetworkGIS` object (`wn_gis`) using `wntr.network.to_gis`. The `WaterNetworkGIS` object contains GeoDataFrames for various network components (junctions, pipes, etc.). Requires WNTR, GeoPandas, and an existing `WaterNetworkModel`. Note that non-spatial data like patterns and controls are excluded. The snippet is skipped if GeoPandas (`gpd`) is not installed.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/model_io.rst#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n>>> wn_gis = wntr.network.to_gis(wn)\n```\n\n----------------------------------------\n\nTITLE: Writing and Reading EPANET INP Files with WaterNetworkModel - Python\nDESCRIPTION: Writes the current WaterNetworkModel to an EPANET INP file (with units conversion if specified), and reads it back to create a new WaterNetworkModel instance. Uses wntr.network.write_inpfile and wntr.network.read_inpfile. The code demonstrates both exporting and round-trip validation; requires EPANET-compatible model attributes.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/basics_tutorial.ipynb#_snippet_41\n\nLANGUAGE: python\nCODE:\n```\n# Create an EPANET INP file from a WaterNetworkModel\\nwntr.network.write_inpfile(wn, 'Net3_LPS.inp', units='LPS')\\n\\n# Create a WaterNetworkModel from an EPANET INP file.  Note, this is equivalent to running `wn = wntr.network.WaterNetworkModel('Net3_LPS.inp')`\\nwn2 = wntr.network.read_inpfile('Net3_LPS.inp') \n```\n\n----------------------------------------\n\nTITLE: Plotting Time Series Data for Node Pressure - Matplotlib/Pandas - Python\nDESCRIPTION: Shows how to extract pressure data for a specific node and plot its time history using pandas plotting and matplotlib. Prepares a figure, accesses result DataFrames, and sets axis labels for clarity. Assumes simulation results are already available. Requires WNTR, pandas, and matplotlib.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/graphics.rst#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n>>> pressure_at_node123 = results.node['pressure'].loc[:,'123']\n>>> ax = pressure_at_node123.plot()\n>>> text = ax.set_xlabel(\"Time (s)\")\n>>> text = ax.set_ylabel(\"Pressure (m)\") \n```\n\n----------------------------------------\n\nTITLE: Generating Leaflet-Based Interactive Network Map - Python\nDESCRIPTION: Converts node coordinates to longitude/latitude and generates an interactive HTML Leaflet map of the water network, coloring links by pipe length and overlaying on geographic basemaps. Demonstrates use of a coordinate mapping, loading and transforming a network, then plotting with attribute mapping and adjustable link width/range. Requires 'folium' for plotting and 'utm' for coordinate conversion (both are optional dependencies), and valid longitude/latitude reference points.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/graphics.rst#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n>>> longlat_map = {'Lake':(-106.6851, 35.1344), '219': (-106.5073, 35.0713)}\n>>> wn2 = wntr.morph.convert_node_coordinates_to_longlat(wn, longlat_map)\n>>> length = wn2.query_link_attribute('length')\n>>> wntr.graphics.plot_leaflet_network(wn2, link_attribute=length, link_width=3, \n...                                    link_range=[0,1000], filename='length.html')\n```\n\n----------------------------------------\n\nTITLE: Writing WaterNetworkModel to JSON File in Python\nDESCRIPTION: Writes the content of a `WaterNetworkModel` object (`wn`) to a JSON file named 'Net3.json' using the `wntr.network.write_json` function. The structure of the JSON file is based on the dictionary representation obtained via `to_dict`. Requires the WNTR library and an existing `WaterNetworkModel`.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/model_io.rst#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\n>>> wntr.network.write_json(wn, 'Net3.json')\n```\n\n----------------------------------------\n\nTITLE: Visualizing Earthquake Network Properties with WNTR Graphics in Python\nDESCRIPTION: This snippet visualizes computed earthquake property data (e.g., peak ground acceleration) on the water network using WNTR's graphics module. It requires pre-computed network property mappings (such as 'pga'), a WaterNetworkModel object, and the wntr.graphics module. Method parameters include link attributes for coloring, node size, link width, and colorbar labels. The output is a matplotlib Axes object representing the rendered network property map. Limitations include dependency on correct data formatting and the need for a graphical backend for visualization.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/disaster_models.rst#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n>>> ax = wntr.graphics.plot_network(wn, link_attribute=pga, node_size=4,\\n...     link_width=2, link_colorbar_label='PGA (g)')\n```\n\n----------------------------------------\n\nTITLE: Calculating Expected Demand using WNTR Metrics (Python)\nDESCRIPTION: Calls 'expected_demand' to calculate time-varying anticipated demand at each node, incorporating base values and patterns. The resulting DataFrame's head is printed for previewing values in m^3/s.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/basics_tutorial.ipynb#_snippet_20\n\nLANGUAGE: python\nCODE:\n```\n# Compute expected demand\\nexpected_demand = wntr.metrics.expected_demand(wn)\\nexpected_demand.head()\n```\n\n----------------------------------------\n\nTITLE: Plotting Pipe Fragility Curve using WNTR Graphics (Python)\nDESCRIPTION: Utilizes the `wntr.graphics.plot_fragility_curve` function to visualize the previously defined pipe fragility curve (`pipe_FC`). The plot shows the probability of exceeding different damage states (Minor Leak, Major Leak) as a function of the input metric (Rate of repair * pipe length).\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/earthquake_tutorial.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nplt.figure()\nwntr.graphics.plot_fragility_curve(pipe_FC, title = 'Fragility Curve', xlabel='Rate of repair * pipe length')\n```\n\n----------------------------------------\n\nTITLE: Loading and Plotting Demand Patterns in WNTR Python\nDESCRIPTION: This Python snippet imports DemandPatternLibrary from wntr, loads the default demand pattern library, prints the names of included patterns, and plots them. No parameters are required beyond the default library, and it is useful for quick inspection and visualization of available demand patterns with matplotlib. Dependencies are wntr and matplotlib.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/libraries.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n>>> from wntr.library import DemandPatternLibrary\n\n>>> demand_library = DemandPatternLibrary()\n>>> print(demand_library.pattern_name_list)\n['Null', 'Constant', 'Net1_1', 'Net2_1', 'Net3_1', 'KY_1', 'Micropolis_1', 'Micropolis_2', 'Micropolis_3', 'Micropolis_4', 'Micropolis_5']\n>>> ax = demand_library.plot_patterns()\n```\n\n----------------------------------------\n\nTITLE: Sampling Pipe Failure Probabilities and Damage States - Python\nDESCRIPTION: Samples the probability of failure for each pipe given PGA and the fragility curve FC, and draws random damage state samples. Outputs arrays/lists of failure probabilities and damage state assignments. Prerequisites: previously computed pga, fragility curve object FC.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/basics_tutorial.ipynb#_snippet_75\n\nLANGUAGE: python\nCODE:\n```\n# Sample the failure probability and damage states for each pipe\\nfailure_probability = FC.cdf_probability(pga)\\ndamage_state = FC.sample_damage_state(failure_probability)\n```\n\n----------------------------------------\n\nTITLE: Adding a Bulk Species to MSX Model in WNTR - Python\nDESCRIPTION: Adds a dissolved lead species (bulk type) to the MSX model using add_species. Parameters include name, type, units, and descriptive note. Returns a Species object which is also stored in the model. Requires: MsxModel instance. Returns: new species instance.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/advancedsim.rst#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n>>> msx.add_species(name=\"PB2\", species_type='bulk', units=\"ug\", note=\"dissolved lead (Pb)\")\nSpecies(name='PB2', species_type='BULK', units='ug', atol=None, rtol=None, note='dissolved lead (Pb)')\n```\n\n----------------------------------------\n\nTITLE: Setting Initial Node Quality for MSX Species in WNTR (Python)\nDESCRIPTION: Sets the initial quality conditions for the MSX species at specific network nodes. It assigns an initial concentration of 1.0 for the tracer 'T1' at the 'River' node (source 1) and 1.2 mg/L for 'CL2' at both the 'River' and 'Lake' nodes using `InitialQuality` objects. The resulting initial quality dictionary is pretty-printed.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/multispecies_tutorial.ipynb#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nnet_data = wn.msx.network_data\nnet_data.initial_quality[\"T1\"] = InitialQuality(node_values={\"River\": 1.0})\nnet_data.initial_quality[\"CL2\"] = InitialQuality(node_values={\"River\": 1.2, \"Lake\": 1.2})\npprint(net_data.initial_quality)\n```\n\n----------------------------------------\n\nTITLE: Querying Pipe Diameters with WNTR (Python)\nDESCRIPTION: Retrieves all pipe diameters using 'query_link_attribute' and displays the first few values. Enables inspection of network-wide diameter settings.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/basics_tutorial.ipynb#_snippet_31\n\nLANGUAGE: python\nCODE:\n```\n# Return all pipe diameters (no comparison operator used in the query) \\nall_pipe_diameters = wn.query_link_attribute('diameter')\\nall_pipe_diameters.head()\n```\n\n----------------------------------------\n\nTITLE: Setting Coordinate Reference System for Geospatial Data - Python\nDESCRIPTION: Defines the spatial reference system (CRS) used for all geospatial datasets in the tutorial. The selected CRS (EPSG:3547) ensures that spatial functions operate with consistent distance units (feet), a necessary configuration for network construction and spatial corrections. Use this variable when loading and transforming geospatial files; expected input is a valid EPSG string.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/model_development_tutorial.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ncrs = \"EPSG:3547\"  # ft\\n\n```\n\n----------------------------------------\n\nTITLE: Querying Tank Names in Water Network Model (Python)\nDESCRIPTION: This code prints the names of all tanks in the WaterNetworkModel by accessing 'tank_name_list'. It helps distinguish tank nodes from other node types.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/basics_tutorial.ipynb#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n# Print the names of just tanks\\nprint(\"Tank names\", wn.tank_name_list)\n```\n\n----------------------------------------\n\nTITLE: Configuring Simulation Time and Water Quality Options in WNTR (Python)\nDESCRIPTION: This snippet configures simulation parameters for the WNTR model (`wn`). It sets the hydraulic and quality timesteps to 3600 seconds (1 hour) and the total simulation duration to 192 hours (8 days). It also specifies the water quality simulation type as 'CHEMICAL' and names the chemical being tracked as 'NaCl' (Sodium Chloride).\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/salt_water_intrusion_tutorial.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n# set time options to run at hourly time steps for eight days\nwn.options.time.hydraulic_timestep = 3600\nwn.options.time.quality_timestep = 3600\nwn.options.time.duration = 3600 * 192\n\n# Set parameter type for quality simulation and add a name for the chemical\nwn.options.quality.parameter = \"CHEMICAL\"\nwn.options.quality.chemical_name = \"NaCl\"\n```\n\n----------------------------------------\n\nTITLE: Plotting WNTR Network with Node Elevations using Matplotlib in Python\nDESCRIPTION: This code uses `wntr.graphics.plot_network` to generate a plot of the water network model (`wn`), visualizing the node elevations using a color map. It sets node size, link width, and adds a color bar label. Requires `matplotlib`, `geopandas`, and `rasterio`.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/gis.rst#_snippet_40\n\nLANGUAGE: python\nCODE:\n```\n>>> ax = wntr.graphics.plot_network(wn, node_attribute=\"elevation\", link_width=1.5, \\\n...     node_size=40, node_colorbar_label='Raster Elevation')\n```\n\n----------------------------------------\n\nTITLE: Visualizing the Water Network in WNTR using Python\nDESCRIPTION: This code creates and displays a graphical layout of the water network using WNTR's plotting utilities. The function requires Matplotlib and a WaterNetworkModel instance. The resulting figure helps visualize network structure.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/basics_tutorial.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n# Plot a basic network graphic\\nax = wntr.graphics.plot_network(wn)\n```\n\n----------------------------------------\n\nTITLE: Simulating Normal Conditions and Identifying Low-Pressure Junctions with WNTR in Python\nDESCRIPTION: Checks the network's behavior under normal operating conditions before simulating fire events. It calculates the Average Expected Demand (AED) and identifies junctions with non-zero demand (NZD). It configures the simulation to use Pressure-Dependent Demand (PDD) with specified minimum and required pressures, sets the total duration, runs a baseline simulation using `WNTRSimulator`, and identifies NZD junctions that experience pressure below the minimum threshold during normal operation. This helps isolate impacts caused specifically by fire flow later.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/fire_flow_tutorial.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n# Calculate average expected demand and identify junctions with non-zero average expected demand (AED)\nAED = wntr.metrics.average_expected_demand(wn)\nnzd_junct = AED[AED > 0].index\n\n# Set hydraulic parameters\nwn.options.hydraulic.demand_model = 'PDD'    \nwn.options.time.duration = total_duration\nwn.options.hydraulic.minimum_pressure = minimum_pressure\nwn.options.hydraulic.required_pressure = required_pressure \n\n# Run simulation\nsim = wntr.sim.WNTRSimulator(wn)\nresults = sim.run_sim()\n\n# Save junction pressure results and identify junctions that fall below minimum pressure\npressure = results.node['pressure'].loc[start_time::, nzd_junct]\nnormal_pressure_below_pmin = pressure.columns[(pressure < minimum_pressure).any()]\n```\n\n----------------------------------------\n\nTITLE: Calculating Average Expected Demand in a WNTR Model (Python)\nDESCRIPTION: Computes the average expected water demand for the network using `wntr.metrics.average_expected_demand(wn)`, which returns the demand in cubic meters per second (m^3/s). It then converts this rate to a total daily volume (m^3/day) and calculates the sum across all demand nodes, printing the total daily water use in cubic meters and million gallons.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/landslide_tutorial.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n# Compute average expected demand per day \naverage_expected_demand = wntr.metrics.average_expected_demand(wn) # m^3/s\naverage_volume_per_day = average_expected_demand*(24*3600) # m^3\ntotal_water_use = average_volume_per_day.sum() # m^3\nprint('Total water use =', total_water_use, 'm^3, =', total_water_use*264.172/1e6, 'million gallons')\n```\n\n----------------------------------------\n\nTITLE: Serializing and Deserializing WaterNetworkModel with Dictionaries - Python\nDESCRIPTION: Converts a WaterNetworkModel to a Python dictionary (via to_dict) for inspection or serialization (e.g., to JSON), and rebuilds a model from a dictionary using wntr.network.from_dict. This is useful for storing custom attributes beyond EPANET INP capabilities; outputs keys of the dictionary and a round-tripped model object.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/basics_tutorial.ipynb#_snippet_42\n\nLANGUAGE: python\nCODE:\n```\n# Convert the WaterNetworkModel to a dictionary\\nwn_dict = wn.to_dict()\\nprint(wn_dict.keys())\\n\\n# Create a WaterNetworkModel from a dictionary\\nwn2 = wntr.network.from_dict(wn_dict)\n```\n\n----------------------------------------\n\nTITLE: Adding Pipe and Tank Reactions to MSX Model in WNTR - Python\nDESCRIPTION: Adds kinetic reaction expressions for both pipe and tank contexts to the model using add_reaction. This snippet sets a rate law for lead transformation in pipes and a zero-rate in tanks. Inputs include the species name or object, reaction type, dynamic type, and a mathematical string expression; returns the constructed Reaction object(s).\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/advancedsim.rst#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\n>>> msx.add_reaction(\"PB2\", \"pipe\", \"RATE\", expression=\"F * Av * M * (E - PB2) / E\")\nReaction(species_name='PB2', expression_type='RATE', expression='F * Av * M * (E - PB2) / E')\n```\n\nLANGUAGE: python\nCODE:\n```\n>>> msx.add_reaction(PB2, \"tank\", \"rate\", expression=\"0\")\nReaction(species_name='PB2', expression_type='RATE', expression='0')\n```\n\n----------------------------------------\n\nTITLE: Running a WNTR Simulation in Segments (Python)\nDESCRIPTION: This code demonstrates how to run a WNTR simulation in two sequential parts, effectively pausing and restarting. First, the simulation duration is set to 10 hours, a WNTRSimulator is instantiated, and the simulation is run. Then, the duration is extended to 24 hours (covering the remaining 14 hours), a new WNTRSimulator instance is created (using the potentially updated state of the 'wn' object), and the simulation continues. This allows for analysis of separate time segments or modification of network operations between segments.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/hydraulics.rst#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\n>>> wn.options.time.duration = 10*3600\n>>> sim = wntr.sim.WNTRSimulator(wn)\n>>> first_10_hours_results = sim.run_sim()\n>>> wn.options.time.duration = 24*3600\n>>> sim = wntr.sim.WNTRSimulator(wn)\n>>> last_14_hours_results = sim.run_sim()\n```\n\n----------------------------------------\n\nTITLE: Defining and Plotting a Fragility Curve with WNTR and SciPy in Python\nDESCRIPTION: This snippet demonstrates how to create a fragility curve object with two damage states ('Minor' and 'Major') using lognormal distributions from SciPy and WNTR's scenario module. It shows how to add these states for the default set of elements and then visualize the curve using wntr.graphics. Dependencies include wntr and scipy.stats. Key parameters include state names, priorities, and distribution objects. The output is a plotted fragility curve, with inputs being the state definitions and associated distributions.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/fragility.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n>>> from scipy.stats import lognorm\\n>>> import wntr # doctest: +SKIP\\n\\n>>> FC = wntr.scenario.FragilityCurve()\\n>>> FC.add_state('Minor', 1, {'Default': lognorm(0.5,scale=0.2)})\\n>>> FC.add_state('Major', 2, {'Default': lognorm(0.5,scale=0.5)}) \\n>>> ax = wntr.graphics.plot_fragility_curve(FC, xlabel='Peak Ground Acceleration (g)')\n```\n\n----------------------------------------\n\nTITLE: Plotting Time Series of Pump Flowrates from Simulation Results - Python\nDESCRIPTION: Selects flowrate results at pump links and plots their time series, using the model's pump_name_list. Useful for visualizing operational behavior of pumps over the simulation.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/basics_tutorial.ipynb#_snippet_60\n\nLANGUAGE: python\nCODE:\n```\n# Plot timeseries of pump flowrates\\npump_flowrates = results_EPANET.link['flowrate'].loc[:,wn.pump_name_list]\\nax = pump_flowrates.plot(title='Pump flowrate')\\nax.set_xlabel('Time (s)')\\nax.set_ylabel('Pump flowrate (m$^3$/s)')\n```\n\n----------------------------------------\n\nTITLE: Implementing Type Checking for wn.add_* Methods in WNTR (Python)\nDESCRIPTION: Adds type checking to the input parameters of `wn.add_*` methods (e.g., `wn.add_pipe`, `wn.add_junction`). This enhances model creation robustness by ensuring that data provided when adding network components conforms to expected types.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/whatsnew/v0.4.0.rst#_snippet_6\n\nLANGUAGE: Python\nCODE:\n```\nwn.add_*\n```\n\n----------------------------------------\n\nTITLE: Identifying Articulation Points and Visualizing on Network - Python\nDESCRIPTION: Uses NetworkX to find articulation points (critical nodes whose removal increases the number of network components) in the undirected graph, and visualizes them using wntr's network plotting capabilities. Inputs are the undirected graph uG and the WaterNetworkModel instance. Output is a plot highlighting articulation points. Requires wntr.graphics and networkx.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/basics_tutorial.ipynb#_snippet_66\n\nLANGUAGE: python\nCODE:\n```\n# Articulation points\\narticulation_points = list(nx.articulation_points(uG))\\nax = wntr.graphics.plot_network(wn, node_attribute=articulation_points, title=\\\"Articulation points\\\")\n```\n\n----------------------------------------\n\nTITLE: Finding Links Connected to a Node in WNTR (Python)\nDESCRIPTION: Finds and prints link names connected to a specific node ('229') in the network, leveraging WNTR's link-querying methods. Useful for network topology analysis.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/basics_tutorial.ipynb#_snippet_14\n\nLANGUAGE: python\nCODE:\n```\n# Get the name of links connected to a specific node\\nconnected_links = wn.get_links_for_node('229')\\nprint('Links connected to node 229 =', connected_links)\n```\n\n----------------------------------------\n\nTITLE: Describing Water Network Model Structure using WNTR (Python)\nDESCRIPTION: This code prints a summary description of the water network model at a specified detail level (0, 1, or 2). It assumes the 'wn' object is an instance of WaterNetworkModel. Output detail can be adjusted with the 'level' parameter.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/basics_tutorial.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n# Print a basic description of the model.  The level can be 0, 1, or 2 and defines the level of detail included in the description.\\nwn.describe(level=1)\n```\n\n----------------------------------------\n\nTITLE: Defining Simulation Parameters for Pipe Break Analysis in Python\nDESCRIPTION: Sets key parameters for the pipe break simulation. This includes the start time of the break, the duration of the break, the total simulation duration, the minimum and required pressures for Pressure-Driven Demand (PDD) analysis, and the minimum diameter for pipes to be included in the break analysis.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/pipe_break_tutorial.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n# Define simulation parameters \nstart_time = 2*3600 # 2 hours\nbreak_duration = 12*3600 # 12 hours\ntotal_duration = start_time + break_duration # 14 hours\n\nminimum_pressure = 3.52 # 5 psi\nrequired_pressure = 14.06 # 20 psi \n\nmin_pipe_diam = 0.3048 # 12 inch\n```\n\n----------------------------------------\n\nTITLE: Saving Water Network Analysis Results to GeoJSON in Python\nDESCRIPTION: This snippet prepares and saves water network analysis results, stored within a `wn_gis` object (likely containing geopandas GeoDataFrames for pipes and junctions), to a GeoJSON file. It first removes the 'intersections' column from the `wn_gis.pipes` GeoDataFrame using `del`, as list-like data types within columns are often not serializable to standard formats like GeoJSON. Then, it exports the entire `wn_gis` object (containing geometry and associated analysis data like WSA) to a GeoJSON file named 'ky10_analysis_results.geojson' using the `write_geojson` method, presumably provided by geopandas or a related library integrated with `wn_gis`. Requires a `wn_gis` object containing analysis results and geometry, and the `geopandas` library (implied by `write_geojson`).\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/landslide_tutorial.ipynb#_snippet_43\n\nLANGUAGE: python\nCODE:\n```\ndel wn_gis.pipes['intersections']\nwn_gis.write_geojson('ky10_analysis_results')\n```\n\n----------------------------------------\n\nTITLE: Instantiating Water Network Model for GIS Analysis - Python\nDESCRIPTION: This snippet initializes the WNTR WaterNetworkModel from an input file for use in geospatial workflows. It conditionally imports WNTR and loads the model file, skipping execution if GeoPandas is not present. This demonstrates how to set up a model for downstream conversion to GIS formats and analysis. Dependency: wntr, geopandas.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/gis.rst#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n>>> import wntr # doctest: +SKIP\n\n>>> wn = wntr.network.WaterNetworkModel('networks/Net1.inp') # doctest: +SKIP\n```\n\n----------------------------------------\n\nTITLE: Slicing Node Pressure DataFrame for a Specific Node - pandas Series - Python\nDESCRIPTION: This snippet selects the time series of pressure for node '123' from the larger pressure DataFrame, then prints the first five rows. Uses DataFrame.loc for column slicing by node name, and .head() for previewing results. Input: pressure DataFrame containing all nodes and time steps. Output: a pandas Series with time as index and pressure values for node '123'.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/resultsobject.rst#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n>>> pressure_at_node123 = pressure.loc[:,'123']\n>>> print(pressure_at_node123.head()) \n0        47.08\n3600     47.95\n7200     48.75\n10800    49.13\n14400    50.38\nName: 123, dtype: float32\n```\n\n----------------------------------------\n\nTITLE: Computing Junction WSA for Each Landslide Scenario - Python\nDESCRIPTION: This code computes WSA for each junction under each landslide scenario, normalizing actual demand using the precomputed expected demand and saving the result in the junction DataFrame. Requires result sets from scenario simulations and GIS layers. Output is updated GIS data for comparison and aggregation.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/landslide_tutorial.ipynb#_snippet_37\n\nLANGUAGE: python\nCODE:\n```\n# Compute WSA associated with each landslide scenarios\nfor i, scenario in landslide_scenarios_downselect.iterrows():\n    demand = results[i].node['demand'].loc[:,wn.junction_name_list]\n    demand_j = demand.sum(axis=0) # total demand at each junction\n    wsa_j = wntr.metrics.water_service_availability(expected_demand_j, demand_j)\n    \n    # Add WSA to the junction GIS data\n    wn_gis.junctions[i] = wsa_j\n    print(i, len(scenario['intersections']), wsa_j.mean())\n```\n\n----------------------------------------\n\nTITLE: Loading a Custom Demand Pattern Library from JSON File in WNTR Python\nDESCRIPTION: This code imports a demand pattern library previously saved as a JSON file, then prints all available pattern names. The input is the filename string for the JSON library. Dependencies are wntr and standard file I/O.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/libraries.rst#_snippet_12\n\nLANGUAGE: python\nCODE:\n```\n>>> custom_demand_library = DemandPatternLibrary(\"Custom_demand_pattern_library.json\")\n>>> print(custom_demand_library.pattern_name_list)\n['Null', 'Constant', 'Net1_1', 'Net2_1', 'Net3_1', 'KY_1', 'Micropolis_1', 'Micropolis_2', 'Micropolis_3', 'Micropolis_4', 'Micropolis_5', 'Pulse', 'Gaussian', 'Gaussian_with_noise', 'Net2_1_resampled']\n```\n\n----------------------------------------\n\nTITLE: Saving a Custom Demand Pattern Library to JSON File in WNTR Python\nDESCRIPTION: This code serializes the current demand pattern library, writing it to a JSON file for external use or sharing. Useful for preserving custom libraries after modification. Only wntr is required and the specified file will be overwritten or created.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/libraries.rst#_snippet_11\n\nLANGUAGE: python\nCODE:\n```\n>>> demand_library.write_json(\"Custom_demand_pattern_library.json\")\n```\n\n----------------------------------------\n\nTITLE: Assigning Landslide Probability to Pipes via GIS Polygon Intersection using WNTR (Python)\nDESCRIPTION: This snippet covers loading landslide hazard zone polygons with probabilities and using wntr.gis.intersect to associate pipes with hazard probabilities found by spatial overlay. GeoDataFrame inputs must contain geometry and hazard columns; outputs enumerate intersecting polygons and probability statistics for each affected pipe. Requires WNTR, GeoPandas, and prepared input files.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/gis.rst#_snippet_25\n\nLANGUAGE: python\nCODE:\n```\n>>> landslide_data = gpd.read_file('data/Net1_landslide_data.geojson') # doctest: +SKIP\n>>> print(landslide_data)\n     Pr                                           geometry\n0  0.50  POLYGON ((28.84615 22.23077, 28.7604 22.05079,...\n1  0.75  POLYGON ((40.00708 1.83192, 33.00708 84.83192,...\n2  0.90  POLYGON ((58.05971 44.48507, 58.11776 44.67615...\n```\n\n----------------------------------------\n\nTITLE: Resetting Initial Conditions in WNTR Model (Python)\nDESCRIPTION: Illustrates the use of the `reset_initial_values` method on a WNTR water network model object (`wn`). This function resets simulation-related initial conditions like time, tank/reservoir heads, and component statuses (pipe, pump, valve), which is necessary when running multiple simulations with the `WNTRSimulator` using the same model instance.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/waternetworkmodel.rst#_snippet_23\n\nLANGUAGE: python\nCODE:\n```\n>>> wn.reset_initial_values()\n```\n\n----------------------------------------\n\nTITLE: Importing Libraries and Initializing WaterNetworkModel in Python\nDESCRIPTION: This snippet sets up the Python environment for working with fragility curves by importing key libraries (matplotlib, wntr, numpy) and instantiating a WaterNetworkModel object from an input file. It includes a try/except block to handle different possible file paths for the network example. Required dependencies are matplotlib, wntr, and numpy. The code prepares for downstream analysis by establishing the base water network model, with no inputs or outputs beyond the created 'wn' object.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/fragility.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n>>> import matplotlib.pylab as plt\\n>>> import wntr\\n>>> import numpy as np\\n>>> try:\\n...    wn = wntr.network.model.WaterNetworkModel('../examples/networks/Net3.inp')\\n... except:\\n...    wn = wntr.network.model.WaterNetworkModel('examples/networks/Net3.inp')\n```\n\n----------------------------------------\n\nTITLE: Including Setting in WNTRSimulator Link Results (Python)\nDESCRIPTION: Updates the WNTRSimulator's link results output to include the `setting` attribute. This provides more detailed simulation results, showing the operational setting (e.g., valve opening, pump speed) of links at each timestep.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/whatsnew/v0.4.0.rst#_snippet_7\n\nLANGUAGE: Python\nCODE:\n```\nsetting\n```\n\n----------------------------------------\n\nTITLE: Converting WNTR WaterNetworkModel to GeoDataFrames\nDESCRIPTION: Converts the WNTR `WaterNetworkModel` object (`wn`) into a collection of `geopandas` GeoDataFrames using the `wn.to_gis()` method. This facilitates geospatial analysis by representing network components (junctions, pipes, tanks, etc.) with associated geometries. The head of the junctions GeoDataFrame is displayed as an example.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/landslide_tutorial.ipynb#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\n# Convert the WaterNetworkModel to GIS data and set the CRS\nwn_gis = wn.to_gis()\nwn_gis.junctions.head()\n#wn_gis.tanks.head()\n#wn_gis.reservoirs.head()\n#wn_gis.pipes.head()\n#wn_gis.pumps.head()\n#wn_gis.tanks.head()\n\n```\n\n----------------------------------------\n\nTITLE: Snapping Disconnected Pumps to Pipes using WNTR - Python\nDESCRIPTION: Snaps pump locations to the nearest pipes using wntr.gis.snap within a distance threshold, then displays the result. Used to align pump locations to network links for subsequent integration. Requires GeoDataFrames for pumps and pipes and WNTR's GIS utilities.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/model_development_tutorial.ipynb#_snippet_28\n\nLANGUAGE: python\nCODE:\n```\n# Snap disconnected pumps to pipes\\ndistance_threshold = 100.0 # ft used to snap pumps to pipes\\n\\nsnap_pumps = wntr.gis.snap(disconnected_pumps, pipes, distance_threshold)\\nprint(disconnected_pumps.head())\\nprint(snap_pumps.head())\n```\n\n----------------------------------------\n\nTITLE: Resetting Initial Conditions with WNTRSimulator - Python\nDESCRIPTION: Resets simulation time, tank/reservoir head, and status for pipes, pumps, and valves using WNTR's WaterNetworkModel API. Required to ensure reproducible results when running WNTRSimulator repeatedly on the same model. No arguments are needed; all tracked states revert to their initial values. Intended for use before multiple or batch simulation runs. No output is produced; internal model states are set.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/basics_tutorial.ipynb#_snippet_62\n\nLANGUAGE: python\nCODE:\n```\nwn.reset_initial_values()\n```\n\n----------------------------------------\n\nTITLE: Configuring Pressure Dependent Demand in WaterNetworkModel - Python\nDESCRIPTION: Sets the hydraulic simulation mode to Pressure Dependent Demand (PDD), and specifies required and minimum pressure parameters (in meters). Prints the updated hydraulic options. This affects all subsequent hydraulic simulations of the WaterNetworkModel.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/basics_tutorial.ipynb#_snippet_52\n\nLANGUAGE: python\nCODE:\n```\n# Change the simulation to use pressure dependent hydraulic analysis\\nwn.options.hydraulic.demand_model = 'PDD'\\nwn.options.hydraulic.required_pressure = 20 # m\\nwn.options.hydraulic.minimum_pressure = 2 # m\\nprint(wn.options.hydraulic)\n```\n\n----------------------------------------\n\nTITLE: Retrieving Minimal Valid GeoJSON Column Names for WNTR Components in Python\nDESCRIPTION: Uses the `wntr.network.io.valid_gis_names` function with `complete_list=False` to retrieve a dictionary (`geojson_column_names`). This dictionary maps component types to lists containing only the minimal set of commonly used column names for GeoJSON representation (corresponding to basic `add_` method parameters). Requires WNTR and GeoPandas. The snippet is skipped if GeoPandas (`gpd`) is not installed.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/model_io.rst#_snippet_13\n\nLANGUAGE: python\nCODE:\n```\n>>> geojson_column_names = wntr.network.io.valid_gis_names(complete_list=False)\n>>> print(geojson_column_names['junctions'])\n['name', 'base_demand', 'demand_pattern', 'elevation', 'demand_category', 'geometry']\n```\n\n----------------------------------------\n\nTITLE: Setting LaTeX Section Numbering Depth and Clearing Page\nDESCRIPTION: This LaTeX snippet uses the `\\setcounter` command to set the depth for section numbering to 1 (only top-level sections like \\section will be numbered) and the `\\clearpage` command to force a page break, ensuring subsequent content starts on a new page. This is typically used in the preamble or at the beginning of chapters/sections for document structuring.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/overview.rst#_snippet_0\n\nLANGUAGE: latex\nCODE:\n```\n\\setcounter{secnumdepth}{1}\n\\clearpage\n```\n\n----------------------------------------\n\nTITLE: Extent of Pipe Contamination Calculation - WNTR - Python\nDESCRIPTION: Computes, for each node and time, the total length of pipes considered contaminated based on water quality and flowrate. Depends on 'quality' at nodes, 'flowrate' at pipes, and requires a detection limit value. Results can be used to assess the spatial extent of contamination events.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/resilience.rst#_snippet_22\n\nLANGUAGE: python\nCODE:\n```\n>>> quality = results.node['quality'] # quality at all nodes\n>>> flowrate = results.link['flowrate'].loc[:,wn.pipe_name_list] \n>>> EC = wntr.metrics.extent_contaminant(quality, flowrate, wn, detection_limit)\n```\n\n----------------------------------------\n\nTITLE: Intersecting Pipes and Landslide Zones using WNTR GIS (Python)\nDESCRIPTION: This snippet demonstrates the use of wntr.gis.intersect to calculate the intersection between water pipes and landslide zones, assigning a landslide probability to each pipe. The function is used with background conditions (assumed value zero) for areas of no overlap. Dependencies include WNTR and GeoPandas. The function returns a DataFrame with columns describing intersection details, statistics, and weighted means per pipe.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/gis.rst#_snippet_26\n\nLANGUAGE: python\nCODE:\n```\n>>> pipe_Pr = wntr.gis.intersect(wn_gis.pipes, landslide_data, 'Pr', \n...    include_background=True, background_value=0)\n>>> print(pipe_Pr)\n          intersections            values  n   sum  min   max   mean  weighted_mean\n10         [BACKGROUND]             [0.0]  1  0.00  0.0  0.00  0.000          0.000\n11      [BACKGROUND, 1]       [0.0, 0.75]  2  0.75  0.0  0.75  0.375          0.201\n12         [BACKGROUND]             [0.0]  1  0.00  0.0  0.00  0.000          0.000\n21   [BACKGROUND, 0, 1]  [0.0, 0.5, 0.75]  3  1.25  0.0  0.75  0.417          0.394\n22      [BACKGROUND, 2]        [0.0, 0.9]  2  0.90  0.0  0.90  0.450          0.246\n31      [BACKGROUND, 1]       [0.0, 0.75]  2  0.75  0.0  0.75  0.375          0.212\n110        [BACKGROUND]             [0.0]  1  0.00  0.0  0.00  0.000          0.000\n111     [BACKGROUND, 0]        [0.0, 0.5]  2  0.50  0.0  0.50  0.250          0.352\n112        [BACKGROUND]             [0.0]  1  0.00  0.0  0.00  0.000          0.000\n113        [BACKGROUND]             [0.0]  1  0.00  0.0  0.00  0.000          0.000\n121     [BACKGROUND, 0]        [0.0, 0.5]  2  0.50  0.0  0.50  0.250          0.250\n122        [BACKGROUND]             [0.0]  1  0.00  0.0  0.00  0.000          0.000\n```\n\n----------------------------------------\n\nTITLE: Computing Betweenness Centrality and Central Point Dominance (Python)\nDESCRIPTION: This snippet calculates betweenness centrality using NetworkX and central point dominance with WNTR. It requires the simple undirected graph `sG`, the original directed graph `G`, and both libraries. It outputs a centrality dictionary and a scalar, helping measure network flow control points and centralization.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/resilience.rst#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n>>> betweenness_centrality = nx.betweenness_centrality(sG)\n>>> central_point_dominance = wntr.metrics.central_point_dominance(G)\n```\n\n----------------------------------------\n\nTITLE: Adding Fire-Fighting Demand Scenario with WNTR in Python\nDESCRIPTION: This snippet shows how to increase node demand to simulate firefighting conditions in a WNTR network. It sets the fire flow in cubic meters/second and the start/end times in seconds. The 'add_fire_fighting_demand' method attaches the time-varying demand to the chosen node. Requires a loaded WaterNetworkModel and relevant node labels. Outputs a network model with event-based demands injected for hydraulic simulations.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/disaster_models.rst#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n>>> fire_flow_demand = 0.252 # 4000 gal/min = 0.252 m3/s\\n>>> fire_start = 10*3600\\n>>> fire_end = 14*3600\\n>>> node = wn.get_node('197')\\n>>> node.add_fire_fighting_demand(wn, fire_flow_demand, fire_start, fire_end)\n```\n\n----------------------------------------\n\nTITLE: Running EPANET Simulation with MSX Model using WNTR (Python)\nDESCRIPTION: Initializes an `EpanetSimulator` with the WNTR `WaterNetworkModel` containing the configured MSX model and runs the simulation using `sim.run_sim()`. It then prints the available node and link result keys from the simulation results object, which include the defined MSX species 'T1' and 'CL2'.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/multispecies_tutorial.ipynb#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nsim = wntr.sim.EpanetSimulator(wn)\nres = sim.run_sim()\nprint(\"Node results:\", \", \".join([k for k in res.node.keys()]))\nprint(\"Link results:\", \", \".join([k for k in res.link.keys()]))\n```\n\n----------------------------------------\n\nTITLE: Configuring MSX Model Options in WNTR - Python\nDESCRIPTION: Sets a structured dictionary of simulation options for the MSX model, such as reporting species and node/link coverage, numerical tolerances, time step, area/rate units, etc. These settings control simulation granularity and accuracy. Requires a configured MsxModel object. All key-value pairs must meet expected naming (report, species, nodes, links, rtol, atol, etc).\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/advancedsim.rst#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n>>> msx.options = {\n... \"report\": {\n...     \"species\": {\"PB2\": \"YES\"},\n...     \"species_precision\": {\"PB2\": 5},\n...     \"nodes\": \"all\",\n...     \"links\": \"all\",\n... },\n... \"timestep\": 1,\n... \"area_units\": \"M2\",\n... \"rate_units\": \"SEC\",\n... \"rtol\": 1e-08,\n... \"atol\": 1e-08,\n... }\n```\n\n----------------------------------------\n\nTITLE: Setting Junction-Specific PDD Parameters in WNTR (Python)\nDESCRIPTION: This snippet shows how to override the global Pressure Dependent Demand (PDD) settings for a specific junction in a WNTR water network model. It retrieves a junction node by its ID ('121') and then sets its individual required pressure, minimum pressure, and pressure exponent. These junction-specific values take precedence over the global options defined in `wn.options.hydraulic` for this particular junction when using the WNTRSimulator.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/hydraulics.rst#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\n>>> junction = wn.get_node('121')\n>>> junction.required_pressure = 14.065 # 20 psi = 14.065 m\n>>> junction.minimum_pressure = 0.352 # 0.5 psi = 0.352 m\t\t\t\t\t\t\t\t\t   \n>>> junction.pressure_exponent = 0.4\n```\n\n----------------------------------------\n\nTITLE: Defining Dictionary of GeoJSON Files for WNTR Model Creation in Python\nDESCRIPTION: Sets up a Python dictionary (`geojson_files`) that maps WNTR component type strings (e.g., 'junctions', 'tanks') to their corresponding GeoJSON filenames (e.g., 'Net3_junctions.geojson'). This dictionary structure is intended as input for the `wntr.network.read_geojson` function to load a network model from multiple GeoJSON files. Requires WNTR and GeoPandas for the subsequent read operation. The snippet is skipped if GeoPandas (`gpd`) is not installed.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/model_io.rst#_snippet_15\n\nLANGUAGE: python\nCODE:\n```\n>>> geojson_files = {'junctions': 'Net3_junctions.geojson',\n...                  'tanks': 'Net3_tanks.geojson',\n```\n\n----------------------------------------\n\nTITLE: Generating Strategic Valve Layer and Plotting It - Python\nDESCRIPTION: Generates a strategic isolation valve layer (N-2 strategy), visualizes its spatial distribution using wntr.graphics. User can swap in custom or real valve placements. Output: plot of valves, with colorbar omitted for clarity. Used to analyze segmentation and isolation strategies.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/basics_tutorial.ipynb#_snippet_83\n\nLANGUAGE: python\nCODE:\n```\n# Create a N-2 strategic valve layer.  Note that the user can create strategic or random valve placements, or use real valve data.\\nvalve_layer = wntr.network.generate_valve_layer(wn, 'strategic', 2)\\nax = wntr.graphics.plot_valve_layer(wn, valve_layer, add_colorbar=False)\n```\n\n----------------------------------------\n\nTITLE: Initializing WaterNetworkModel and Scaling Node Coordinates with WNTR in Python\nDESCRIPTION: This snippet demonstrates initializing a WaterNetworkModel with WNTR using a specific input file, then scales the node coordinates to ensure correct distance units (meters) for disaster modeling. Requires the wntr Python package and an EPANET input network file. The 'scale_node_coordinates' function takes the model and a scaling factor as parameters and outputs a model with appropriately scaled coordinates, which is crucial for subsequent earthquake simulation steps.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/disaster_models.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n>>> import wntr # doctest: +SKIP\\n\\t\\n>>> wn = wntr.network.WaterNetworkModel('networks/Net3.inp') # doctest: +SKIP\\n>>> wn = wntr.morph.scale_node_coordinates(wn, 1000)\n```\n\n----------------------------------------\n\nTITLE: Loading Water Network Model and Disabling Quality in WNTR (Python)\nDESCRIPTION: Loads the 'Net3.inp' EPANET network file into a WNTR `WaterNetworkModel` object. It then disables the default EPANET quality calculations by setting the `quality.parameter` option to 'NONE', preparing the model for MSX integration.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/multispecies_tutorial.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nwn = wntr.network.WaterNetworkModel(\"networks/Net3.inp\")\nwn.options.quality.parameter = \"NONE\"\n```\n\n----------------------------------------\n\nTITLE: Converting Raster Data Type and Handling NoData Values in Python\nDESCRIPTION: This snippet processes the loaded storm surge raster data (`inundation_raster`). It first converts the data type from integer to float to accommodate NaN values. Then, it replaces the specific no-data value (255) with NumPy's `NaN` (Not a Number) representation.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/salt_water_intrusion_tutorial.ipynb#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\ninundation_raster = inundation_raster.astype(float) # change dtype from int to float to allow for NaN value\ninundation_raster[inundation_raster==255] = np.nan # 255 indicates no data\n```\n\n----------------------------------------\n\nTITLE: Generating and Plotting a Random WNTR Valve Layer in Python\nDESCRIPTION: This snippet demonstrates creating a valve layer with random placement using `wntr.network.generate_valve_layer`. It generates 40 valves randomly within the specified network model ('networks/Net3.inp') using a fixed seed (123) for reproducibility. It then prints the head (first 5 rows) of the resulting DataFrame and uses `wntr.graphics.plot_valve_layer` to visualize the generated valve layer on the network map. The `doctest: +SKIP` indicates these lines might be skipped during automated testing, possibly due to file path dependencies.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/layers.rst#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n>>> import wntr # doctest: +SKIP\n\t\n>>> wn = wntr.network.WaterNetworkModel('networks/Net3.inp') # doctest: +SKIP\n>>> random_valve_layer = wntr.network.generate_valve_layer(wn, 'random', 40, seed=123)\n>>> print(random_valve_layer.head())\n  link node\n0  105  105\n1  161  149\n2  113  111\n3  295  249\n4  197  177\n>>> ax = wntr.graphics.plot_valve_layer(wn, random_valve_layer, add_colorbar=False)\n```\n\n----------------------------------------\n\nTITLE: Listing WaterNetworkModel Properties and Methods (Python)\nDESCRIPTION: This code lists all public properties and methods available on the WaterNetworkModel instance, omitting those starting with an underscore. This is useful for API exploration and introspection.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/basics_tutorial.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n# List properties and methods associated with the WaterNetworkModel (omitting private underscore names)\\n[name for name in dir(wn) if not name.startswith('_')]\n```\n\n----------------------------------------\n\nTITLE: Skeletonizing the Water Network by Pipe Diameter Threshold - Python\nDESCRIPTION: Reduces network size by removing/merging pipes based on a diameter threshold using wntr.morph.skeletonize. Keeps all significant infrastructure and pipes above the threshold. Input: threshold in meters (converted from inches). Output: Skeletonized WaterNetworkModel, and prints summary. Used for scenario reduction and computational speed-up.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/basics_tutorial.ipynb#_snippet_78\n\nLANGUAGE: python\nCODE:\n```\n# Skeletonize the network using a 12 inch pipe diameter threshold\\nskel_wn = wntr.morph.skeletonize(wn, 12*0.0254)\\nskel_wn.describe(level=1)\n```\n\n----------------------------------------\n\nTITLE: Saving Matplotlib Figures in PNG Format - Python\nDESCRIPTION: This hidden snippet arranges elements in the Matplotlib plot for optimal spacing, saves the figure as a PNG image with 300 DPI resolution to 'plot_pump_curve.png', and closes the plot. Requires matplotlib.pyplot as plt to be imported. No direct input/output beyond file creation; applicable as post-processing for plot exporting.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/graphics.rst#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\n>>> plt.tight_layout()\n>>> plt.savefig('plot_pump_curve.png', dpi=300)\n>>> plt.close()\n```\n\n----------------------------------------\n\nTITLE: Setting LaTeX Page Numbering Style and Counter\nDESCRIPTION: This LaTeX snippet sets the page numbering style to Arabic numerals using `\\pagenumbering{arabic}` and resets the page counter to 1 using `\\setcounter{page}{1}`. This is often used after title pages or front matter to start the main body of the document with page 1.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/overview.rst#_snippet_1\n\nLANGUAGE: latex\nCODE:\n```\n\\pagenumbering{arabic}\n\\setcounter{page}{1}\n```\n\n----------------------------------------\n\nTITLE: Calculating Todini Index - WNTR - Python\nDESCRIPTION: Computes the Todini index to assess network resilience based on hydraulic head, pressure, demand, pump flowrate, and a pressure threshold. Assumes prior simulation and relevant DataFrames for 'head', 'pressure', and 'demand'. The Todini index is widely used in network reliability studies and outputs a numerical value reflecting resilience.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/resilience.rst#_snippet_15\n\nLANGUAGE: python\nCODE:\n```\n>>> head = results.node['head']\n>>> pump_flowrate = results.link['flowrate'].loc[:,wn.pump_name_list]            \n>>> todini = wntr.metrics.todini_index(head, pressure, demand, pump_flowrate, wn, \n...     threshold)\n```\n\n----------------------------------------\n\nTITLE: Creating WaterNetworkModel from WaterNetworkGIS Object in Python\nDESCRIPTION: Creates a new `WaterNetworkModel` object (`wn2`) from a `WaterNetworkGIS` object (`wn_gis`) or a dictionary of GeoDataFrames using `wntr.network.from_gis`. Requires WNTR, GeoPandas, and an existing `WaterNetworkGIS` object (or equivalent dictionary). The resulting model primarily contains component attributes and topology, omitting patterns, controls, etc., which use default values. The snippet is skipped if GeoPandas (`gpd`) is not installed.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/model_io.rst#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\n>>> wn2 = wntr.network.from_gis(wn_gis)\n```\n\n----------------------------------------\n\nTITLE: Identifying Junctions Connected to Pipes of Interest with WNTR in Python\nDESCRIPTION: Determines the set of unique junctions connected to the pipes identified in the previous step. It iterates through the `pipes_of_interest` index (pipe names), retrieves each pipe object using `wn.get_link()`, and adds the names of its start and end nodes to a set (`junct_of_interest`), ensuring they are actual junctions (exist in `wn.junction_name_list`). Using a set automatically handles duplicates.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/fire_flow_tutorial.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n# Queries junctions connected to pipes of interest\njunct_of_interest = set()\nfor pipe_name in pipes_of_interest.index:\n    pipe = wn.get_link(pipe_name)\n    if pipe.start_node_name in wn.junction_name_list:\n        junct_of_interest.add(pipe.start_node_name)\n    if pipe.end_node_name in wn.junction_name_list:\n        junct_of_interest.add(pipe.end_node_name)\n```\n\n----------------------------------------\n\nTITLE: Calculating and Displaying Pipe Leak Probabilities and Damage States (Python)\nDESCRIPTION: Calculates the cumulative distribution function (CDF) probabilities for each damage state defined in the fragility curve (`pipe_FC`), using the product of Repair Rate (RR) and Pipe Length (L) as input. It then samples a specific damage state for each pipe based on these probabilities. Finally, it prints summary statistics (min, max, average) for the calculated PGA, PGV, RR, and the combined RR*L metric.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/earthquake_tutorial.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n# Uses RR and fragility curve to calculate leak probabilities \npipe_Pr = pipe_FC.cdf_probability(RR*L)\npipe_damage_state = pipe_FC.sample_damage_state(pipe_Pr)\n\nprint(\"Min, Max, Average PGA: \" + str(np.round(pga.min(),2)) + \", \" + str(np.round(pga.max(),2)) + \", \" + str(np.round(pga.mean(),2)) + \" g\")\nprint(\"Min, Max, Average PGV: \" + str(np.round(pgv.min(),2)) + \", \" + str(np.round(pgv.max(),2)) + \", \" + str(np.round(pgv.mean(),2)) + \" m/s\")\nprint(\"Min, Max, Average repair rate: \" + str(np.round(RR.min(),5)) + \", \" + str(np.round(RR.max(),5)) + \", \" + str(np.round(RR.mean(),5)) + \" per m\")\nprint(\"Min, Max, Average repair rate*pipe length: \" + str(np.round((RR*L).min(),5)) + \", \" + str(np.round((RR*L).max(),5)) + \", \" + str(np.round((RR*L).mean(),5)))\n```\n\n----------------------------------------\n\nTITLE: Writing WaterNetworkModel to EPANET INP File in Python\nDESCRIPTION: Illustrates how to write an existing `WaterNetworkModel` object (`wn`) to an EPANET INP file named 'filename.inp' using the `wntr.network.write_inpfile` function. It specifies the EPANET 2.2 format using the `version` parameter. Requires the WNTR library and a `WaterNetworkModel` instance.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/model_io.rst#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n>>> wntr.network.write_inpfile(wn, 'filename.inp', version=2.2)\n```\n\n----------------------------------------\n\nTITLE: Adding Pulse and Gaussian Demand Patterns to the Library in WNTR Python\nDESCRIPTION: This example demonstrates adding two new demand patterns ('Pulse' and 'Gaussian') to a DemandPatternLibrary using on/off sequences and a Gaussian distribution, respectively. The functions accept pattern definitions and distribution parameters such as mean, standard deviation, duration, pattern timestep, start_clocktime, and normalization. Required dependencies include wntr and pandas. Outputs are pandas Series representing the created demand patterns.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/libraries.rst#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n>>> on_off_sequence=[3*3600,6*3600,14*3600,20*3600]\n>>> series = demand_library.add_pulse_pattern('Pulse', on_off_sequence)\n>>> series = demand_library.add_gaussian_pattern('Gaussian', mean=12*3600, \n...     std=5*3600, duration=24*3600, pattern_timestep=3600, \n...     start_clocktime=0, normalize=True)\n```\n\n----------------------------------------\n\nTITLE: Calculating Betweenness Centrality and Visualizing on Network - Python\nDESCRIPTION: Computes the betweenness centrality metric (importance in shortest paths) for all nodes using NetworkX, and displays the scalar values over the network graph. Requires the original directed multigraph G and WaterNetworkModel instance. Output is a plot colored by centrality values. Needs wntr.graphics and networkx.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/basics_tutorial.ipynb#_snippet_67\n\nLANGUAGE: python\nCODE:\n```\n# Compute betweenness centrality\\nbetweenness_centrality = nx.betweenness_centrality(G)\\nax = wntr.graphics.plot_network(wn, node_attribute=betweenness_centrality, title=\\\"Betweenness centrality\\\")\n```\n\n----------------------------------------\n\nTITLE: Attaching WSA Results to Junction GIS Layer - Python\nDESCRIPTION: Adds the baseline WSA calculation to the GIS junction DataFrame for mapping and spatial analysis. Requires the existing GIS and computed results vectors. Output is an augmented GIS DataFrame.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/landslide_tutorial.ipynb#_snippet_35\n\nLANGUAGE: python\nCODE:\n```\n# Add WSA from the base simulation to the junction GIS data\nwn_gis.junctions['baseline'] = wsa_baseline_j\n```\n\n----------------------------------------\n\nTITLE: Snapping Hydrant Points to Nearest Junctions - Python\nDESCRIPTION: Uses wntr.gis.snap to associate each hydrant with its nearest junction within a specified tolerance, outputting a DataFrame of matches. Inputs are hydrant_data, GeoDataFrame of junctions, and a tolerance (meters or projected units). Output: snapped_to_junctions with corresponding node assignments.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/basics_tutorial.ipynb#_snippet_89\n\nLANGUAGE: python\nCODE:\n```\n# Snap hydrants to junctions\\nsnapped_to_junctions = wntr.gis.snap(hydrant_data, wn_gis.junctions, tolerance=5.0)\\nsnapped_to_junctions.head()\n```\n\n----------------------------------------\n\nTITLE: Configuring Tracer Quality Analysis - WNTR - Python\nDESCRIPTION: This code configures the quality options on the WaterNetworkModel for a tracer analysis, measuring the percent of flow originating from a specific node, by setting the quality parameter to 'TRACE' and specifying the trace_node ('111'). The snippet depends on a valid wn object. It prepares inputs for tracer tracking in water quality simulations.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/waterquality.rst#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n>>> wn.options.quality.parameter = 'TRACE'\n>>> wn.options.quality.trace_node = '111'\n```\n\n----------------------------------------\n\nTITLE: Loading and Indexing Imperfect Geospatial Datasets - Python\nDESCRIPTION: Reads in imperfect GeoJSON datasets for pipes, pumps, tanks, and reservoirs, assigning the CRS and setting the 'name' field as index for easier attribute access. Geopandas is used throughout. Handles non-perfect data structures for further network reconstruction. Requires existence of all specified files in the expected format.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/model_development_tutorial.ipynb#_snippet_16\n\nLANGUAGE: python\nCODE:\n```\ndisconnected_pipes = gpd.read_file(\"data/ky4_disconnected_pipes.geojson\", crs=crs)\\ndisconnected_pumps = gpd.read_file(\"data/ky4_disconnected_pumps.geojson\", crs=crs)\\ntanks = gpd.read_file(\"data/ky4_tanks.geojson\", crs=crs)\\nreservoirs = gpd.read_file(\"data/ky4_reservoirs.geojson\", crs=crs)\\n\\ndisconnected_pipes.set_index(\"name\", inplace=True)\\ndisconnected_pumps.set_index(\"name\", inplace=True)\\ntanks.set_index(\"name\", inplace=True)\\nreservoirs.set_index(\"name\", inplace=True)\\n\n```\n\n----------------------------------------\n\nTITLE: Loading Perfect Geospatial Data and Creating WaterNetworkModel - Python\nDESCRIPTION: Loads network components from GeoJSON files (with full attributes) into a new WaterNetworkModel object using wntr.network.read_geojson. The input is a dictionary mapping element types to file paths. This step reconstructs the network accurately when perfect data is available. Requires correct GeoJSON schema and attribute names.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/model_development_tutorial.ipynb#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\ngeojson_files = {\\n    \"junctions\": \"data/ky4_junctions.geojson\",\\n    \"tanks\": \"data/ky4_tanks.geojson\",\\n    \"reservoirs\": \"data/ky4_reservoirs.geojson\",\\n    \"pipes\": \"data/ky4_pipes.geojson\",\\n    \"pumps\": \"data/ky4_pumps.geojson\",\\n}\\n\\nwn1 = wntr.network.read_geojson(geojson_files)\\n\n```\n\n----------------------------------------\n\nTITLE: Querying Pipes by Diameter for Break Analysis in Python\nDESCRIPTION: Uses the WNTR `query_link_attribute` method to select pipes from the network model whose diameter is greater than or equal to a predefined minimum diameter (`min_pipe_diam`). This creates a list of pipes to be included in the subsequent break simulation loop.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/pipe_break_tutorial.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n# Queries all pipes with diameter greater than threshold set in 1c\npipes_of_interest = wn.query_link_attribute('diameter', np.greater_equal, min_pipe_diam)\n```\n\n----------------------------------------\n\nTITLE: Comparing Junction Pressures in Original and Skeletonized Networks - Python\nDESCRIPTION: Calculates and plots the time series of average pressure for shared junctions in both the original and skeletonized models. Uses the results objects to filter junction pressure data and plots them for direct comparison. Requires matplotlib (plt). Helps validate hydraulic equivalence after skeletonization.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/basics_tutorial.ipynb#_snippet_81\n\nLANGUAGE: python\nCODE:\n```\n# Plot average pressure at junctions that exist in both the original and skeletonized model\\nskel_junctions = skel_wn.junction_name_list\\npressure_orig = results_original.node['pressure'].loc[:,skel_junctions]\\npressure_skel = results_skel.node['pressure'].loc[:,skel_junctions]\\n\\nax = pressure_orig.mean(axis=1).plot(label='Original')\\nax = pressure_skel.mean(axis=1).plot(ax=ax, label='Skeletonized')\\nplt.title('Average pressure')\\nax.set_xlabel('Time (s)')\\nax.set_ylabel('Pressure (m)')\\nplt.legend()\n```\n\n----------------------------------------\n\nTITLE: Calculating Population Impacted by Excessive Water Age - Python\nDESCRIPTION: Determines the number of people impacted where average water age exceeds a given threshold (24 hours), using wntr.metrics. Input includes population vector, average_age, and threshold. Outputs a plot showing affected population by node. Useful for exposure and public health risk assessments.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/basics_tutorial.ipynb#_snippet_71\n\nLANGUAGE: python\nCODE:\n```\n# Compute the population that is impacted by water age greater than 24 hours\\npop = wntr.metrics.population(wn)\\nthreshold = 24 # hours\\npop_impacted = wntr.metrics.population_impacted(pop, average_age, np.greater, threshold)\\nax = wntr.graphics.plot_network(wn, node_attribute=pop_impacted, title=\\\"Population impacted by water age > 24 hours\\\")\n```\n\n----------------------------------------\n\nTITLE: Adding and Displaying Junction Demand Time Series\nDESCRIPTION: This snippet demonstrates managing multiple demands at a junction. It first prints the existing list of demand time series for junction '121' (output skipped). Then, it uses `add_demand` to append a new demand time series with a specified base value and pattern. Finally, it prints the updated list of demands (output skipped).\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/waternetworkmodel.rst#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\n>>> print(junction.demand_timeseries_list)  # doctest: +SKIP\n<Demands: [<TimeSeries: base_value=0.002626444876132, pattern_name='1', category='None'>]> \n    \n>>> junction.add_demand(base=1.0, pattern_name='1')\n>>> print(junction.demand_timeseries_list)  # doctest: +SKIP\n<Demands: [<TimeSeries: base_value=0.002626444876132, pattern_name='1', category='None'>, <TimeSeries: base_value=1.0, pattern_name='1', category='None'>]>\n```\n\n----------------------------------------\n\nTITLE: Importing WNTR library in Python\nDESCRIPTION: This snippet imports the WNTR library, making its classes and functions available for use in the script. This is the necessary first step for utilizing WNTR's capabilities for water network analysis.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/getting_started_tutorial.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport wntr\n```\n\n----------------------------------------\n\nTITLE: Calculating Closeness Centrality (Python)\nDESCRIPTION: This example computes closeness centrality using NetworkX, which assesses how close each node is to all other nodes via shortest paths. Requires the graph `G` and the NetworkX library. Returns a dictionary with nodes as keys and their closeness scores as values.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/resilience.rst#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\n>>> closeness_centrality = nx.closeness_centrality(G)\n```\n\n----------------------------------------\n\nTITLE: Simulating Fire Flow Scenarios for Each Hydrant Location with WNTR in Python\nDESCRIPTION: Iterates through each identified potential hydrant junction (`junct_of_interest`) to simulate a fire event. Inside the loop, it reloads the original network model, configures PDD simulation options, creates a binary demand pattern representing the fire flow (active between `start_time` and `total_duration`), adds this pattern to the network, and assigns the `fire_demand` magnitude with this pattern to the current junction. A `try/except/finally` block runs the simulation using `WNTRSimulator`, calculates impacted junctions (those falling below `minimum_pressure` during the fire, excluding those already below minimum pressure normally), and stores the list of impacted junctions in `analysis_results`. The `except` block catches simulation failures (e.g., convergence issues) and prints an error message, while the `finally` block ensures results (or None on failure) are saved for each junction.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/fire_flow_tutorial.ipynb#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n# Create dictionary to save results\nanalysis_results = {}\n\n# Simulate fire flow demand for each hydrant location\nfor junct in junct_of_interest:\n    wn = wntr.network.WaterNetworkModel(inp_file)\n    wn.options.hydraulic.demand_model = 'PDD'    \n    wn.options.time.duration = total_duration\n    wn.options.hydraulic.minimum_pressure = minimum_pressure\n    wn.options.hydraulic.required_pressure = required_pressure\n\n    # Create fire flow pattern\n    fire_flow_pattern = wntr.network.elements.Pattern.binary_pattern(\n        'fire_flow',\n        start_time=start_time,\n        end_time=total_duration,\n        step_size=wn.options.time.pattern_timestep,\n        duration=wn.options.time.duration\n        )\n    wn.add_pattern('fire_flow', fire_flow_pattern)\n\n    # Apply fire flow pattern to hydrant location\n    fire_junct = wn.get_node(junct)\n    fire_junct.demand_timeseries_list.append((fire_demand, fire_flow_pattern, 'Fire flow'))\n\n    try:\n        # Simulate hydraulics\n        sim = wntr.sim.WNTRSimulator(wn) \n        sim_results = sim.run_sim()\n \n        # Using pressure results, identify impacted junctions\n        sim_pressure = sim_results.node['pressure'].loc[start_time::, nzd_junct]\n        sim_pressure_below_pmin = sim_pressure.columns[(sim_pressure < minimum_pressure).any()]\n        impacted_junctions = set(sim_pressure_below_pmin) - set(normal_pressure_below_pmin)\n        impacted_junctions = list(impacted_junctions)\n        \n    except Exception as e:\n        # Identify failed simulations and the reason\n        impacted_junctions = None\n        print(junct, ' Failed:', e)\n\n    finally:\n        # Save simulation results\n        analysis_results[junct] = impacted_junctions\n```\n\n----------------------------------------\n\nTITLE: Saving and Loading WaterNetworkModel as JSON - Python\nDESCRIPTION: Saves the WaterNetworkModel to a JSON file and reloads it into a new model instance. Uses wntr.network.write_json and wntr.network.read_json. Useful for transferring models or persistent storage, supporting all attributes present in the dictionary form.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/basics_tutorial.ipynb#_snippet_43\n\nLANGUAGE: python\nCODE:\n```\n# Create a JSON file from the WaterNetworkModel\\nwntr.network.write_json(wn, 'Net3.json')\\n\\n# Create a WaterNetworkModel from a JSON file\\nwn2 = wntr.network.read_json('Net3.json')\n```\n\n----------------------------------------\n\nTITLE: Querying Link Names in Water Network Model (Python)\nDESCRIPTION: Prints the names of all pipes, pumps, and valves by accessing 'link_name_list'. This gives a quick summary of all link elements in the network.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/basics_tutorial.ipynb#_snippet_12\n\nLANGUAGE: python\nCODE:\n```\n# Print the names of all pipes, pumps, and valves\\nprint(\"Link names\", wn.link_name_list)\n```\n\n----------------------------------------\n\nTITLE: Adding Flushing Demands at Hydrant Locations in WNTR Model (Python)\nDESCRIPTION: This snippet modifies the WNTR model (`wn`) to simulate hydrant flushing. It iterates through the selected `hydrant_nodes`. For each hydrant node, it adds a fire flow demand using `junction.add_fire_fighting_demand`. This demand has a constant value (`fire_flow_demand`) and is active during a specified time window (`hydrant_start` to `hydrant_end`), which starts after the storm ends.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/salt_water_intrusion_tutorial.ipynb#_snippet_19\n\nLANGUAGE: python\nCODE:\n```\nfire_flow_demand = 0.126 # 2000 gal/min\nhydrant_start = storm_end\nhydrant_end = storm_end + 72 * 3600\n\nfor hydrant_node in hydrant_nodes:\n    junction = wn.get_node(hydrant_node)\n    junction.add_fire_fighting_demand(wn, fire_flow_demand, hydrant_start, hydrant_end)\n```\n\n----------------------------------------\n\nTITLE: Converting WaterNetworkModel to NetworkX MultiDiGraph - Python\nDESCRIPTION: Converts a WaterNetworkModel to a directed multigraph using NetworkX, enabling graph-theoretic metrics on the system. The resulting graph G can be used with NetworkX algorithms. Requires wntr, networkx, and a WaterNetworkModel instance. Output is a MultiDiGraph representing nodes and directional links (pipes, pumps, etc).\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/basics_tutorial.ipynb#_snippet_64\n\nLANGUAGE: python\nCODE:\n```\n# Convert the WaterNetworkModel to a MultiDiGraph\\nG = wn.to_graph() # directed multigraph\n```\n\n----------------------------------------\n\nTITLE: Adding Constants and Parameter to MSX Model in WNTR - Python\nDESCRIPTION: Shows how to add model constants and a parameter (for pipe material flag or reaction rates) to the MsxModel using add_constant and add_parameter. Each entry has a name, value, units (if applicable), and descriptive note. The constants/parameter are stored within the model's reaction system.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/advancedsim.rst#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\n>>> msx.add_constant(\"M\", value=0.117, note=\"Desorption rate (ug/m^2/s)\", units=\"ug * m^(-2) * s^(-1)\")\nConstant(name='M', value=0.117, units='ug * m^(-2) * s^(-1)', note='Desorption rate (ug/m^2/s)')\n>>> msx.add_constant(\"E\", value=140.0, note=\"saturation/plumbosolvency level (ug/L)\", units=\"ug/L\")\nConstant(name='E', value=140.0, units='ug/L', note='saturation/plumbosolvency level (ug/L)')\n>>> msx.add_parameter(\"F\", global_value=0, note=\"determines which pipes are made of lead\")\nParameter(name='F', global_value=0.0, note='determines which pipes are made of lead')\n```\n\n----------------------------------------\n\nTITLE: Running EPANET Simulation with Flushing Response using WNTR in Python\nDESCRIPTION: This snippet runs the hydraulic and water quality simulation for the scenario including the flushing response. It uses the WNTR model (`wn`) which now includes the added fire flow demands at hydrant locations. An `EpanetSimulator` is created, `run_sim()` is called, and the nodal water quality results are extracted into `response_quality`. The head of the quality results DataFrame is printed.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/salt_water_intrusion_tutorial.ipynb#_snippet_20\n\nLANGUAGE: python\nCODE:\n```\nsim = wntr.sim.EpanetSimulator(wn)\nresponse_results = sim.run_sim()\nresponse_quality = response_results.node['quality']\nprint(response_quality.head())\n```\n\n----------------------------------------\n\nTITLE: Querying Pipes by Diameter using WNTR in Python\nDESCRIPTION: Identifies pipes within a specific diameter range, potentially representing locations suitable for hydrants. It uses the `wn.query_link_attribute('diameter')` method to get the diameters of all pipes in the network model and then filters this Series to select only those pipes whose diameters fall between `min_pipe_diam` and `max_pipe_diam` (inclusive), as defined earlier.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/fire_flow_tutorial.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n# Queries pipes with diameters within diameter bounds set in 1b \npipe_diameter = wn.query_link_attribute('diameter')\npipes_of_interest = pipe_diameter[(pipe_diameter <= max_pipe_diam) & (pipe_diameter >= min_pipe_diam)]\n```\n\n----------------------------------------\n\nTITLE: Listing Pipe Properties and Methods (Python)\nDESCRIPTION: Lists all public properties and methods for the selected pipe object, omitting those starting with an underscore. Useful for exploring supported attributes and operations.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/basics_tutorial.ipynb#_snippet_16\n\nLANGUAGE: python\nCODE:\n```\n# List properties and methods associated with the pipe (omitting private underscore names)\\n[name for name in dir(pipe) if not name.startswith('_')]\n```\n\n----------------------------------------\n\nTITLE: Creating Undirected Graphs for Topographic Metrics - Python\nDESCRIPTION: Constructs an undirected MultiGraph and a simple undirected Graph (with single edges) from a directed multigraph, which are needed for certain topological analyses (e.g. articulation points). uG represents the undirected multigraph, sG is the simple undirected form. Requires NetworkX and an existing MultiDiGraph G.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/basics_tutorial.ipynb#_snippet_65\n\nLANGUAGE: python\nCODE:\n```\n# Some topographic metrics require an undirected graph or a graph with a single edge between two nodes\\nuG = G.to_undirected() # undirected multigraph\\nsG = nx.Graph(uG) # undirected simple graph (single edge between two nodes)\n```\n\n----------------------------------------\n\nTITLE: Writing WaterNetworkGIS to GeoJSON Files - Python\nDESCRIPTION: This snippet writes all components of the WaterNetworkGIS object to GeoJSON files prefixed with 'Net1', one for each component type (junctions, tanks, reservoirs, pipes, pumps). This allows for further analysis in GIS platforms (e.g., QGIS, GRASS). Input: file prefix string; Output: multiple GeoJSON files. Dependency: wntr, geopandas.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/gis.rst#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\n>>> wn_gis.write_geojson('Net1')\n```\n\n----------------------------------------\n\nTITLE: Visualizing Junction and Population Impacts from Segment Breaks in Python\nDESCRIPTION: Generates two network plots using `wntr.graphics.plot_network`. The first plot visualizes the number of junctions impacted by each segment closure, coloring links based on `num_junctions_impacted`. The second plot visualizes the population impacted, coloring links based on `num_people_impacted`. Both plots use specified ranges (`link_range`) and colormaps (`link_cmap`), hide nodes (`node_size=0`), set link width, and add descriptive titles and colorbar labels. The valve layer is overlaid on both plots using `wntr.graphics.plot_valve_layer` for context.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/pipe_segments_tutorial.ipynb#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\n#Plot junctions impacted due to segment breaks\nax = wntr.graphics.plot_network(wn, link_attribute=num_junctions_impacted, node_size=0, link_width=2, \n                           link_range=[0,10], link_cmap = cmap, link_colorbar_label='Junctions Impacted', \n                           title='Number of junctions impacted by each segment closure')\n# Graphs valve layer onto the same axes\nwntr.graphics.plot_valve_layer(wn, valve_layer, add_colorbar=False, include_network=False, ax=ax)\n\n#Plot population impacted due to segment breaks\nax = wntr.graphics.plot_network(wn, link_attribute=num_people_impacted, node_size=0, link_width=2, \n                           link_range=[0,5000], link_cmap = cmap, link_colorbar_label='Population Impacted', \n                           title='Number of people impacted by each segment closure')\n# Graphs valve layer onto the same axes\nwntr.graphics.plot_valve_layer(wn, valve_layer, add_colorbar=False, include_network=False, ax=ax)\n```\n\n----------------------------------------\n\nTITLE: Adjusting Supply and Demand for Environmental Change with WNTR in Python\nDESCRIPTION: This snippet alters reservoir head values and node base demands in the WaterNetworkModel to simulate environmental change effects, such as drought or increased usage. Reservoir heads are decreased by 10% and junction demands are increased by 15%. Requires a valid WaterNetworkModel object. The snippet iterates over reservoir and junction collections, modifying each in-place. Outputs a model with updated supply/demand, which can be used for scenario analysis.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/disaster_models.rst#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n>>> for res_name, res in wn.reservoirs():\\n...     res.head_timeseries.base_value = res.head_timeseries.base_value*0.9\\n\\t\\n>>> for junc_name, junc in wn.junctions():\\n...     for demand in junc.demand_timeseries_list:\\n...         demand.base_value = demand.base_value*1.15\n```\n\n----------------------------------------\n\nTITLE: Simulating a Power Outage for a Pump with WNTR in Python\nDESCRIPTION: This example demonstrates how to simulate a time-controlled power outage for a pump in the WNTR model by adjusting pump status. Requires a WaterNetworkModel with pump elements. The 'add_outage' method applies an outage starting and ending at specified seconds (after midnight), adding a Rule to the network. Compatible with models that have been converted to use Rules if existing Controls impact pumps. Outputs a modified model reflecting the scheduled outage.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/disaster_models.rst#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n>>> pump = wn.get_link('335')\\n>>> pump.add_outage(wn, 5*3600, 10*3600)\n```\n\n----------------------------------------\n\nTITLE: Snapping Reservoirs and Tanks to Nearest Junctions with WNTR - Python\nDESCRIPTION: Uses wntr.gis.snap to find and assign the nearest junctions to reservoirs and tanks within a specified distance threshold, updating their locations for subsequent network integration. Requires WNTR and preprocessed GeoDataFrames for reservoirs, tanks, and junctions. Outputs are snapped lookup tables for reservoirs and tanks.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/model_development_tutorial.ipynb#_snippet_24\n\nLANGUAGE: python\nCODE:\n```\ndistance_threshold = 100.0 # ft, used to connect tanks and reservoirs\\n\\nsnap_reservoirs = wntr.gis.snap(reservoirs, junctions, distance_threshold)\\nprint(reservoirs.head())\\nprint(snap_reservoirs)\\n\\nsnap_tanks = wntr.gis.snap(tanks, junctions, distance_threshold)\\nprint(tanks.head())\\nprint(snap_tanks)\n```\n\n----------------------------------------\n\nTITLE: Importing Necessary Libraries for WNTR Analysis in Python\nDESCRIPTION: Imports the required Python libraries: WNTR for water network analysis, Matplotlib for plotting, and NumPy for numerical operations. It also sets a default colormap ('viridis') from Matplotlib to be used later for network visualizations.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/fire_flow_tutorial.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport wntr\nimport matplotlib\nimport matplotlib.pylab as plt\nimport numpy as np\n\n# Set colormap for network maps\ncmap=matplotlib.colormaps['viridis']\n```\n\n----------------------------------------\n\nTITLE: Finding Weighted Paths Based on Simulation Flow (Python)\nDESCRIPTION: This snippet sets up a hydraulic simulation, extracts flow rates at the final simulation timestep, creates a graph weighted by flow direction and finds all simple paths between two nodes. Dependencies include WNTR, NetworkX, and a valid network model `wn`. Key parameters are the chosen source and target node IDs; outputs include a generator or list of node paths based on hydraulic conditions.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/resilience.rst#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\n>>> sim = wntr.sim.EpanetSimulator(wn)\n>>> results = sim.run_sim()\n\n>>> flowrate = results.link['flowrate'].iloc[-1,:] # flowrate from the last timestep\n>>> G = wn.to_graph(link_weight=flowrate, modify_direction=True)\n>>> all_paths = nx.all_simple_paths(G, '119', '193')\n```\n\n----------------------------------------\n\nTITLE: Accessing Demand Patterns Associated with a Junction (Python)\nDESCRIPTION: Finds the pattern object currently assigned to the first demand of a junction. This object can be queried for multiplier values and further edited as needed.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/basics_tutorial.ipynb#_snippet_24\n\nLANGUAGE: python\nCODE:\n```\n# Get the pattern associated with the demand\\npattern = wn.get_pattern(junction.demand_timeseries_list[0].pattern_name)\\npattern\n```\n\n----------------------------------------\n\nTITLE: Changing the Max Level of a Tank in WNTR (Python)\nDESCRIPTION: Reads and modifies the 'max_level' attribute of a tank object, printing the old and new values. This parameter controls the upper water level allowed in the tank during simulations.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/basics_tutorial.ipynb#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\n# Change the max level of a tank\\nprint(\"Original max level\", tank.max_level)\\ntank.max_level = 10\\nprint(\"New max level\", tank.max_level)\n```\n\n----------------------------------------\n\nTITLE: Reading WaterNetworkModel from JSON File in Python\nDESCRIPTION: Creates a new `WaterNetworkModel` object (`wn2`) by reading data from a JSON file ('Net3.json') using the `wntr.network.read_json` function. The JSON file should conform to the WNTR dictionary representation schema. Requires the WNTR library.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/model_io.rst#_snippet_11\n\nLANGUAGE: python\nCODE:\n```\n>>> wn2 = wntr.network.read_json('Net3.json')\n```\n\n----------------------------------------\n\nTITLE: Restructuring: Creating 'graphics' Package and Updating Plotting in Python\nDESCRIPTION: Details the creation of the `graphics` package for network visualization within WNTR. It includes renaming the `draw_graph` function to `plot_network` and adding a new function for network graphics using Plotly.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/whatsnew/v0.1.2.rst#_snippet_1\n\nLANGUAGE: text\nCODE:\n```\nAdded `graphics` package which contains functions to plot networks.  Renamed draw_graph to plot_network.  Added a function to create network graphics using Plotly.\n```\n\n----------------------------------------\n\nTITLE: Plotting Building Demand and Junction Demand on Water Network Model with Matplotlib - Python\nDESCRIPTION: Produces two visualizations: building-level demand densities with pipes, and junction-level expected demand with pipes, using matplotlib and geopandas. Suppresses axis ticks and sets axis limits, with custom titles for context. Useful for result communication and spatial demand verification.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/model_development_tutorial.ipynb#_snippet_36\n\nLANGUAGE: python\nCODE:\n```\n# Plot data and water network model\\nfig, ax = plt.subplots(figsize=(12,5))\\nax = buildings.plot(column='base_demand', vmin=0, vmax=0.0002, zorder=1, legend=True, legend_kwds={\\\"label\\\":\\\"Demand\\\"}, ax=ax)\\nax = disconnected_pipes.plot(zorder=0, ax=ax)\\nax.set_xticks([])\\nax.set_yticks([])\\ntmp = ax.set_xlim(zoom_coords[0])\\ntmp = ax.set_ylim(zoom_coords[1])\\ntmp = ax.set_title('Imperfect geospatial data\\nDisconencted pipes and building demand estimated from area')\\n\\nfig, ax = plt.subplots(figsize=(12,5))\\njunctions['aed2'] = aed2\\nax = junctions.plot(column='aed2', vmin=0, vmax=0.0002, zorder=1, legend=True, legend_kwds={\\\"label\\\":\\\"Demand\\\"}, ax=ax)\\nax = pipes.plot(zorder=0, ax=ax)\\nax.set_xticks([])\\nax.set_yticks([])\\ntmp = ax.set_xlim(zoom_coords[0])\\ntmp = ax.set_ylim(zoom_coords[1])\\ntmp = ax.set_title('Water network model\\nConencted pipes and junction demands')\n```\n\n----------------------------------------\n\nTITLE: Modifying Reservoir Head Time Series Base Value\nDESCRIPTION: This snippet shows how to modify the base value of a time series associated with a network element. It retrieves the reservoir node named 'River' using `get_node` and then updates the `base_value` of its `head_timeseries` attribute, setting it to 90% of its original value.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/waternetworkmodel.rst#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\n>>> reservoir = wn.get_node('River')\n>>> reservoir.head_timeseries.base_value = reservoir.head_timeseries.base_value*0.9\n```\n\n----------------------------------------\n\nTITLE: Asserting Equality of Simulation Keys with Test Data Keys in Python\nDESCRIPTION: Performs a simple comparison to check if the set of keys (hydrant locations) present in the calculated `num_junctions_impacted` dictionary is identical to the set of keys in the loaded `people_test` dictionary. This acts as a basic sanity check during data testing to ensure both results cover the same set of simulated fire locations.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/fire_flow_tutorial.ipynb#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nnum_junctions_impacted.keys() == people_test.keys()\n```\n\n----------------------------------------\n\nTITLE: Accessing Tanks by Name from WaterNetworkModel - Python\nDESCRIPTION: Loops over the list of tank names, retrieves the corresponding tank object via wn.get_node, and prints each tank's maximum level. Requires a WaterNetworkModel instance with populated tank_name_list. Outputs tank names and max_level attributes.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/basics_tutorial.ipynb#_snippet_37\n\nLANGUAGE: python\nCODE:\n```\n# Loop over tank names and then get the associated tank object\\nfor name in wn.tank_name_list:\\n    tank = wn.get_node(name)\\n    print(\\\"Max level for tank\\\", name, \\\"=\\\", tank.max_level)\n```\n\n----------------------------------------\n\nTITLE: Referencing WNTR Node Coordinate Conversion to UTM (Python)\nDESCRIPTION: References the `convert_node_coordinates_to_UTM` method in the `wntr.morph.node` module. This function converts node coordinates to the Universal Transverse Mercator (UTM) system, potentially from an assumed standard system if not Long/Lat.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/whatsnew/v0.1.7.rst#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\n~wntr.morph.node.convert_node_coordinates_to_UTM\n```\n\n----------------------------------------\n\nTITLE: Computing Node Degree and Terminal Nodes (Python)\nDESCRIPTION: This snippet shows how to compute node degrees using NetworkX and terminal nodes using WNTR's metrics. It requires a previously created graph object `G` and the WNTR/NetworkX libraries. Outputs are node-degree mappings and a list of terminal nodes, which are used to identify key structure in the network graph.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/resilience.rst#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n>>> node_degree = G.degree()\n>>> terminal_nodes = wntr.metrics.terminal_nodes(G)\n```\n\n----------------------------------------\n\nTITLE: Creating WaterNetworkModel from INP for Geospatial Analysis - Python\nDESCRIPTION: Reads a WaterNetworkModel from EPANET INP file, geared for integration with geospatial data. Serves as the required first step for further GIS data transformation or joining. Output is WaterNetworkModel initialized with spatial coordinates.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/basics_tutorial.ipynb#_snippet_86\n\nLANGUAGE: python\nCODE:\n```\n# Create a WaterNetworkModel from an EPANET INP file\\nwn = wntr.network.WaterNetworkModel('networks/Net1.inp')\n```\n\n----------------------------------------\n\nTITLE: Querying Node Coordinates in Water Network Model (Python)\nDESCRIPTION: Retrieves all node coordinates from the network, typically returning a mapping of node names to (x, y) tuples. Output can inform further geospatial analysis or mapping.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/basics_tutorial.ipynb#_snippet_34\n\nLANGUAGE: python\nCODE:\n```\n# Get node coordinates\\ncoords = wn.query_node_attribute('coordinates')\\ncoords\n```\n\n----------------------------------------\n\nTITLE: Defining MSX Reaction Rates in WNTR (Python)\nDESCRIPTION: Defines two pipe reactions within the MSX model. The first reaction ('rxn_T1') sets the rate for the tracer 'T1' to 0, indicating it's a conservative tracer. The second reaction ('rxn_Cl2') defines the decay rate for 'CL2' using the formula `-(k1*T1 + k2*(1-T1))*CL2`, implementing the differential decay based on the tracer concentration indicating the water source. The `repr` of the 'rxn_Cl2' reaction object is printed.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/multispecies_tutorial.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nrxn_T1 = wn.msx.add_reaction(\"T1\", \"pipe\", \"rate\", \"0\")\nrxn_Cl2 = wn.msx.add_reaction(\"CL2\", \"pipe\", \"rate\", \"-(k1*T1 + k2*(1-T1))*CL2\")\nprint(repr(rxn_Cl2))\n```\n\n----------------------------------------\n\nTITLE: Saving WNTR GIS Data to GeoJSON Files (Python)\nDESCRIPTION: Writes the geospatial representation of the water network model (`wn_gis`) to disk as a set of GeoJSON files. The `wn_gis.write_geojson('ky10')` command creates separate files for each component type (e.g., `ky10_junctions.geojson`, `ky10_pipes.geojson`) prefixed with 'ky10'. Note that non-geometric model data like controls and patterns are not included.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/landslide_tutorial.ipynb#_snippet_11\n\nLANGUAGE: python\nCODE:\n```\n# Store the WaterNetworkModel as a collection of GeoJSON files\nwn_gis.write_geojson('ky10')\n```\n\n----------------------------------------\n\nTITLE: Importing and Initializing WNTR Water Network and MSX Models in Python\nDESCRIPTION: This snippet demonstrates the process of importing required modules from WNTR and conditionally initializing WaterNetworkModel and MsxModel instances from example files, handling cases where file paths may differ between environments. Dependencies include the 'wntr' Python package, and the code checks two possible relative paths for both models. Expected inputs are network and MSX file paths, and the output is an initialized network object with an attached MSX model. This is typically used as a setup step for water quality simulations.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/waterquality_msx.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n>>> import wntr\n>>> try:\n...    wn = wntr.network.model.WaterNetworkModel('../examples/networks/Net3.inp')\n...    wn.msx = wntr.msx.MsxModel('../examples/data/Net3_arsenic.msx')\n... except:\n...    wn = wntr.network.model.WaterNetworkModel('examples/networks/Net3.inp')\n...    wn.msx = wntr.msx.MsxModel('examples/data/Net3_arsenic.msx')\n```\n\n----------------------------------------\n\nTITLE: Plotting Baseline WSA for Junctions with Color Map - Python\nDESCRIPTION: Plots baseline WSA at each junction using a color gradient, overlaying junctions on a gray pipe network. Requires baseline WSA attached to junctions and uses matplotlib plotting utilities. Output is a thematic map visualizing service performance across the network.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/landslide_tutorial.ipynb#_snippet_36\n\nLANGUAGE: python\nCODE:\n```\n# Plot WSA from the base simulation\nax = wn_gis.pipes.plot(color='black', linewidth=1)\nax = wn_gis.junctions.plot(column='baseline', cmap='RdYlGn', vmin=0, vmax=1, legend=True, ax=ax)\ntmp = ax.set_title('Baseline WSA')\ntmp = ax.axis('off')\n```\n\n----------------------------------------\n\nTITLE: Assigning Sampled Elevations to Junctions in WNTR Model in Python\nDESCRIPTION: This code iterates through all junctions in a WNTR `WaterNetworkModel` object (`wn`) and updates their `elevation` attribute using previously sampled elevation data stored in the `junction_elevations` Series. Requires `geopandas` and `rasterio` for prior sampling.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/gis.rst#_snippet_38\n\nLANGUAGE: python\nCODE:\n```\n>>> for junction_name in wn.junction_name_list:\n...     junction = wn.get_node(junction_name)\n...     junction.elevation = junction_elevations[junction_name]\n```\n\n----------------------------------------\n\nTITLE: Plotting WNTR Simulation Results (Network and Time Series) in Python\nDESCRIPTION: Generates plots using WNTR graphics and Matplotlib to visualize simulation results. It creates network plots showing the 'T1' (River Fraction) distribution at 12, 24, and 36 hours. It also plots the time series of 'CL2' and 'T1' concentrations at a specific node ('117') and adds a title indicating the node and decay constants (k1, k2) and a legend.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/multispecies_tutorial.ipynb#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\n_ = wntr.graphics.plot_network(\n    wn,\n    node_attribute=res.node[\"T1\"].loc[3600 * 12, :],\n    title=\"12 h\",\n    node_colorbar_label=\"River\\nFraction\",\n)\n_ = wntr.graphics.plot_network(\n    wn,\n    node_attribute=res.node[\"T1\"].loc[3600 * 24, :],\n    title=\"24 h\",\n    node_colorbar_label=\"River\\nFraction\",\n)\n_ = wntr.graphics.plot_network(\n    wn,\n    node_attribute=res.node[\"T1\"].loc[3600 * 36, :],\n    title=\"36 h\",\n    node_colorbar_label=\"River\\nFraction\",\n)\nquery = \"117\"  # '191', '269', '117'\nres.node[\"CL2\"][query].plot()\nres.node[\"T1\"][query].plot()\nplt.title(\"Node {}\\nk1 = {:.1f}, k2 = {:.1f}\".format(query, k1.value, k2.value))\n_ = plt.legend([\"Cl2\", \"T1\"])\n```\n\n----------------------------------------\n\nTITLE: Computing Expected Demand at Junctions Per Timestep - Python\nDESCRIPTION: Calculates expected water demand for each network junction at each timestep using WNTR metrics. Assumes initialized network model and time options. Outputs a DataFrame of demands suitable for further service metric computations.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/landslide_tutorial.ipynb#_snippet_32\n\nLANGUAGE: python\nCODE:\n```\n# Compute expected demand for each junction and timestep\nexpected_demand = wntr.metrics.expected_demand(wn)\n\nexpected_demand.head()\n```\n\n----------------------------------------\n\nTITLE: Calculating Annual Network Cost using wntr in Python\nDESCRIPTION: This snippet demonstrates how to compute the annual maintenance and operations cost for a water network using the `wntr.metrics.annual_network_cost` function. It requires a `wntr` water network model object (`wn`) as input and returns the calculated cost. The calculation is based on equations from the Battle of Water Networks II.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/resilience.rst#_snippet_24\n\nLANGUAGE: python\nCODE:\n```\n>>> network_cost = wntr.metrics.annual_network_cost(wn)\n```\n\n----------------------------------------\n\nTITLE: Building WaterNetworkModel from INP for Skeletonization - Python\nDESCRIPTION: Loads a WaterNetworkModel from an EPANET INP file and prints a summary. Used as the first step in skeletonization workflows. The file path and verbosity level are parameters. Output is a model description at level 1 to console.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/basics_tutorial.ipynb#_snippet_77\n\nLANGUAGE: python\nCODE:\n```\n# Create a WaterNetworkModel from an EPANET INP file\\nwn = wntr.network.WaterNetworkModel('networks/Net6.inp')\\nwn.describe(level=1)\n```\n\n----------------------------------------\n\nTITLE: Calculating Total Pipe Length in a WNTR Model (Python)\nDESCRIPTION: Queries the 'length' attribute for all links (pipes, pumps, valves) in the WNTR model using `wn.query_link_attribute('length')`. It then calculates the sum of these lengths and prints the total pipe length in both meters (m) and feet (ft).\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/landslide_tutorial.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n# Compute total pipe length\nlength = wn.query_link_attribute('length')\ntotal_length = length.sum() # m\nprint('Total pipe length =', total_length, 'm, =', total_length*3.28084, 'ft')\n```\n\n----------------------------------------\n\nTITLE: Loading EPANET INP File into WNTR WaterNetworkModel in Python\nDESCRIPTION: This snippet loads a water distribution network model from an EPANET INP file specified by `network_path` into a WNTR `WaterNetworkModel` object named `wn`. This object represents the network structure and properties for subsequent analysis.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/salt_water_intrusion_tutorial.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nnetwork_path = \"data/coastal_ky4.inp\"\nwn = wntr.network.WaterNetworkModel(network_path) \n```\n\n----------------------------------------\n\nTITLE: Exporting and Importing WaterNetworkModel as ESRI Shapefiles - Python\nDESCRIPTION: Writes geographic layers from WaterNetworkModel as Shapefiles with wntr.network.write_shapefile, and reads them into a new model. Warns about truncated column names. Input is the model and output directory prefix; output is a reconstructed model missing some attributes.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/basics_tutorial.ipynb#_snippet_48\n\nLANGUAGE: python\nCODE:\n```\n# Create Shapefiles from the WaterNetworkModel.  The following code will produce UserWarnings: \\\"Column names longer than 10 characters will be truncated when saved to ESRI Shapefile.\\\"\\nwntr.network.write_shapefile(wn, 'Net3')\\n\\n# Create a WaterNetworkModel from Shapefiles\\nshapefile_dirs = {'junctions': 'Net3_junctions',\\n                  'tanks': 'Net3_tanks',\\n                  'reservoirs': 'Net3_reservoirs',\\n                  'pipes': 'Net3_pipes',\\n                  'pumps': 'Net3_pumps'}\\nwn2 = wntr.network.read_shapefile(shapefile_dirs)\n```\n\n----------------------------------------\n\nTITLE: Converting WaterNetworkModel to NetworkX Graph in Python\nDESCRIPTION: Converts a `WaterNetworkModel` object (`wn`) into a NetworkX graph object (`G`) using the `wntr.network.to_graph` function (which can also be called as a method on the model object). This allows leveraging NetworkX library functionalities for graph analysis. Requires WNTR, NetworkX, and an existing `WaterNetworkModel`.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/model_io.rst#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\n>>> G = wntr.network.to_graph(wn)\n```\n\n----------------------------------------\n\nTITLE: Calculating Pressure Difference Between Original and Skeletonized Networks in Python\nDESCRIPTION: This snippet calculates the absolute percentage difference in pressure between the original and skeletonized network simulations. It first identifies the junctions present in the skeletonized network (`skel_wn.junction_name_list`). Then, it extracts the pressure results for these specific junctions from both simulation results (`results_original` and `results_skel`). Finally, it computes the absolute difference, normalizes it by the original pressure, multiplies by 100 to get a percentage, and converts the time index of the resulting DataFrame from seconds to hours.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/morph.rst#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n>>> skel_junctions = skel_wn.junction_name_list\n>>> pressure_orig = results_original.node['pressure'].loc[:,skel_junctions]\n>>> pressure_skel = results_skel.node['pressure'].loc[:,skel_junctions]\n>>> pressure_diff = (abs(pressure_orig - pressure_skel)/pressure_orig)*100\n>>> pressure_diff.index = pressure_diff.index/3600 # convert time to hours\n```\n\n----------------------------------------\n\nTITLE: Obtaining Valve Segment Attributes (Python)\nDESCRIPTION: This snippet calculates average expected node demand, link lengths, and then attributes these to valve segments using WNTR. Inputs are the valve layer and related segmentation/grouping variables, along with node demand and link length data. Outputs are dictionaries of valve segment attributes to aid in resilience and operational analysis.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/resilience.rst#_snippet_12\n\nLANGUAGE: python\nCODE:\n```\n>>> average_expected_demand = wntr.metrics.average_expected_demand(wn)\n>>> link_lengths = wn.query_link_attribute('length')\n>>> valve_attributes = wntr.metrics.valve_segment_attributes(valve_layer, \n...     node_segments, link_segments, average_expected_demand, link_lengths)\n```\n\n----------------------------------------\n\nTITLE: Visualizing WNTR Network Segments in Python\nDESCRIPTION: Uses `wntr.graphics.plot_network` to visualize the water network, where links (pipes) are colored based on the segment they belong to, as determined previously and stored in `link_segments`. The `link_cmap` parameter specifies the colormap, `node_size=0` hides nodes, `link_width=2` sets link thickness, and `add_colorbar=False` hides the colorbar.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/pipe_segments_tutorial.ipynb#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n# Graph segments within network\nwntr.graphics.plot_network(wn, link_attribute=link_segments, link_cmap = cmap, node_size=0, link_width=2, add_colorbar= False)\n```\n\n----------------------------------------\n\nTITLE: Referencing WNTR Node Coordinate Conversion Long/Lat to UTM (Python)\nDESCRIPTION: References the `convert_node_coordinates_longlat_to_UTM` method in the `wntr.morph.node` module. This function converts node coordinates from longitude and latitude to the Universal Transverse Mercator (UTM) system.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/whatsnew/v0.1.7.rst#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n~wntr.morph.node.convert_node_coordinates_longlat_to_UTM\n```\n\n----------------------------------------\n\nTITLE: Referencing WNTR Node Coordinate Scaling Method (Python)\nDESCRIPTION: References the `scale_node_coordinates` method in the `wntr.morph.node` module. This function scales the coordinates of all nodes in the network model by a specified factor.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/whatsnew/v0.1.7.rst#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n~wntr.morph.node.scale_node_coordinates\n```\n\n----------------------------------------\n\nTITLE: Bibliography Management Using Sphinx Directives - reStructuredText\nDESCRIPTION: This snippet applies Sphinx's dedicated bibliography directive to automatically include and format a bibliography section in the documentation. It requires the relevant bibliography plugin extension enabled in Sphinx. The references are rendered according to the Sphinx theme and can be combined with explicit entries elsewhere in the document.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/reference.rst#_snippet_3\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. bibliography::\n\n```\n\n----------------------------------------\n\nTITLE: Defining Named Cross-Reference Anchors and Section Titles (reStructuredText)\nDESCRIPTION: This snippet demonstrates the use of the '.. _name:' anchor followed by a section title underlining to define both a cross-reference target and a top-level heading. It lets other documentation files or sections link programmatically to this section as 'users'. The pattern '====...===' under a heading specifies overline/underline section levels in reST. No dependencies beyond a reStructuredText/Sphinx environment.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/users.rst#_snippet_1\n\nLANGUAGE: restructuredtext\nCODE:\n```\n.. _users:\\n\\nUser community\\t\\n================================\n```\n\n----------------------------------------\n\nTITLE: Adding a Pattern to WaterNetworkModel and Assigning to a Node in WNTR Python\nDESCRIPTION: This sequence establishes a WaterNetworkModel instance, retrieves a specific node ('11'), converts a library pattern to the Pattern class, retrieves its category, and adds this pattern as a new demand series for the node with a base value. It outputs a summary of the node's demand time series. Dependencies are wntr and pandas, and it requires the resampled pattern to exist in the library and the node to exist by name.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/libraries.rst#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\n>>> import wntr\n>>> wn = wntr.network.WaterNetworkModel('networks/Net1.inp') # doctest: +SKIP\n>>> junction = wn.get_node('11')\n\n>>> pattern = demand_library.to_Pattern('Net2_1_resampled')\n>>> category = demand_library.library['Net2_1_resampled']['category']\n\n>>> wn.add_pattern('from_Net2', pattern)\n>>> junction.add_demand(base=5e-5, pattern_name='from_Net2', category=category)\n>>> print(junction.demand_timeseries_list)\n<Demands: [<TimeSeries: base_value=0.00946352946, pattern_name='1', category='None'>, <TimeSeries: base_value=5e-05, pattern_name='from_Net2', category='None'>]>\n```\n\n----------------------------------------\n\nTITLE: Visualizing Repair Rate Metrics on Network Map using WNTR (Python)\nDESCRIPTION: Generates two network plots using `wntr.graphics.plot_network`. The first plot visualizes the calculated Repair Rate (RR, number of repairs needed per meter) for each pipe. The second plot shows the product of Repair Rate and Pipe Length (RR*L), which is used as input for the fragility curve, visualized across the network. Both plots use the specified colormap (`cmap`).\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/earthquake_tutorial.ipynb#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\n# Plot RR\nwntr.graphics.plot_network(wn, link_attribute=RR, node_size=0, link_cmap = cmap, link_width=1.5, title='Repair Rate')\n\n# Plot RR*Pipe Length\nwntr.graphics.plot_network(wn, link_attribute=(RR*L), node_size=0, link_cmap = cmap, link_width=1.5, title='Repair Rate*Pipe Length')\n```\n\n----------------------------------------\n\nTITLE: Adding Salt Water Sources and Demands to WNTR Model in Python\nDESCRIPTION: This snippet modifies the WNTR model (`wn`) to simulate salt water intrusion. It iterates through all junctions. If a junction is inundated (`inundated[junction_name]` is True, based on `salt_water_flowrate < 0`), it adds a concentration source ('CONCEN') with a fixed salt water density (`salt_water_density`) and the 'StormSurge' pattern. It also adds a negative demand (inflow) to the junction using the previously calculated `salt_water_flowrate` and the 'StormSurge' pattern.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/salt_water_intrusion_tutorial.ipynb#_snippet_13\n\nLANGUAGE: python\nCODE:\n```\ninundated = salt_water_flowrate < 0.0\nsalt_water_density = 35 # kg/m3 \nfor junction_name in wn.junction_name_list:\n    if inundated[junction_name]:\n        junction = wn.get_node(junction_name)\n        wn.add_source(f'Source_{junction_name}', junction_name, 'CONCEN', salt_water_density, 'StormSurge')\n        junction.add_demand(base=salt_water_flowrate[junction_name], pattern_name='StormSurge')\n```\n\n----------------------------------------\n\nTITLE: Writing Shapefiles from a WaterNetworkModel with WNTR in Python\nDESCRIPTION: This snippet exports a WaterNetworkModel (wn) to Esri-compatible Shapefiles using wntr.network.write_shapefile. It creates output directories for each primary network component (e.g., Net3_junctions, Net3_pipes), suitable for GIS workflows. All required and optional network attributes are considered for inclusion. The function requires the network model to be populated and can be used to share or further analyze the network in spatial platforms. GeoPandas should be installed to handle geometries.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/model_io.rst#_snippet_18\n\nLANGUAGE: python\nCODE:\n```\nwntr.network.write_shapefile(wn, 'Net3')\n```\n\n----------------------------------------\n\nTITLE: Plotting Original and Skeletonized Networks - Python\nDESCRIPTION: Draws side-by-side network plots for both the original and reduced (skeletonized) models, without node markers. Visual comparison uses wntr.graphics.plot_network; the title distinguishes each network. Useful for validating which structural elements remain after reduction.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/basics_tutorial.ipynb#_snippet_79\n\nLANGUAGE: python\nCODE:\n```\n# Plot the original and skeletonized networks\\nax = wntr.graphics.plot_network(wn, node_size=0, title='Original')\\nax = wntr.graphics.plot_network(skel_wn, node_size=0, title='Skeletonized')\n```\n\n----------------------------------------\n\nTITLE: Visualizing Network AED and Pressure using WNTR and Matplotlib in Python\nDESCRIPTION: Generates two figures using Matplotlib, each with two subplots, to visualize network characteristics. The first figure plots average expected demand (AED) and pressure for the `wn0` network, while the second figure does the same for the `wn2` network using `wntr.graphics.plot_network`. Requires WNTR network objects (`wn0`, `wn2`) and corresponding results (`aed0`, `pressure0`, `aed2`, `pressure2`). Dependencies include Matplotlib (`plt`) and WNTR.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/model_development_tutorial.ipynb#_snippet_39\n\nLANGUAGE: python\nCODE:\n```\nfig, axes = plt.subplots(1,2, figsize=(12,3.5))\nax = wntr.graphics.plot_network(wn0, node_attribute=aed0, node_size=30, title=\"wn0 Average Expected Demand\", show_plot=False, ax=axes[0])\nax = wntr.graphics.plot_network(wn0, node_attribute=pressure0, node_size=30, title=\"wn0 Pressure\", show_plot=False, ax=axes[1])\n\nfig, axes = plt.subplots(1,2, figsize=(12,3.5))\nax = wntr.graphics.plot_network(wn2, node_attribute=aed2, node_size=30, title=\"wn2 Average Expected Demand\", show_plot=False, ax=axes[0])\nax = wntr.graphics.plot_network(wn2, node_attribute=pressure2, node_size=30, title=\"wn2 Pressure\", show_plot=False, ax=axes[1])\n```\n\n----------------------------------------\n\nTITLE: Generating Interactive Time Series Charts with Plotly Express - Python\nDESCRIPTION: Demonstrates converting time series results for tank head into an interactive chart using plotly.express. Extracts and converts pressure data, using pandas to select tank nodes and apply unit conversion, then passes to plotly for visualization. Requires simulation output, the plotly package, and knowledge of WNTRs data structures.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/graphics.rst#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\n>>> import plotly.express as px\n\n>>> tankH = results.node['pressure'].loc[:,wn.tank_name_list]\n>>> tankH = tankH * 3.28084 # Convert tank head to ft\n```\n\n----------------------------------------\n\nTITLE: Modifying Pipe Status Based on Custom Attribute\nDESCRIPTION: This snippet demonstrates using a custom attribute in analysis or modification tasks. It iterates through all pipes in the model. For each pipe, it checks if its custom `material` attribute is 'Steel'. If it is, the pipe's `initial_status` is set to 'Closed'.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/waternetworkmodel.rst#_snippet_16\n\nLANGUAGE: python\nCODE:\n```\n    >>> for name, pipe in wn.pipes():\n    ...     if pipe.material == 'Steel':\n    ...         pipe.initial_status = 'Closed'\n```\n\n----------------------------------------\n\nTITLE: Plotting WNTR Network with Demographic and Analysis Attributes in Python\nDESCRIPTION: This snippet visualizes geospatial and network analysis data using matplotlib and WNTR's plotting capabilities. First, it plots the demographic data, coloring polygons based on 'mean_income'. Then, it overlays the water network using `wntr.graphics.plot_network`, coloring nodes by the 'mean' attribute from `junction_demographics` and links by the 'weighted_mean' attribute from `pipe_demographics`, likely representing income values. The plot aspect ratio is set to 'equal' for accurate spatial representation.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/basics_tutorial.ipynb#_snippet_94\n\nLANGUAGE: python\nCODE:\n```\n# Plot results\nax = demographic_data.plot(column='mean_income', alpha=0.5, cmap='bone', vmin=10000, vmax=100000)\nax.set_aspect('equal', adjustable='box')\nax = wntr.graphics.plot_network(wn, \n                                node_attribute=junction_demographics['mean'], \n                                link_attribute=pipe_demographics['weighted_mean'], \n                                link_width=1.5, ax=ax, title='Mean income ($)')\n```\n\n----------------------------------------\n\nTITLE: Identifying Nodes and Links in Each Valve Segment - Python\nDESCRIPTION: Converts the WaterNetworkModel to a graph and uses wntr.metrics to find node and link segments associated with each valve layer. Outputs series of segments, sizes, and prints head of segment sizes. Useful for resilience and network vulnerability analyses.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/basics_tutorial.ipynb#_snippet_84\n\nLANGUAGE: python\nCODE:\n```\n# Identify nodes and links that are in each valve segment\\nG = wn.to_graph()\\nnode_segments, link_segments, seg_sizes = wntr.metrics.topographic.valve_segments(G, valve_layer)\\nseg_sizes.head()\n```\n\n----------------------------------------\n\nTITLE: Identifying and Visualizing Zero Demand Junctions in WNTR (Python)\nDESCRIPTION: Finds junctions with zero average expected demand, prints their identifiers, and plots them on the network for quick identification. Output highlights potential data issues or inactive nodes.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/basics_tutorial.ipynb#_snippet_22\n\nLANGUAGE: python\nCODE:\n```\n# Identify junctions with zero demand\\nzero_demand = AED[AED == 0].index\\nprint(zero_demand)\\nax = wntr.graphics.plot_network(wn, node_attribute=list(zero_demand), title='Zero demand junctions')\n```\n\n----------------------------------------\n\nTITLE: Removing a Junction from WaterNetworkModel in WNTR (Python)\nDESCRIPTION: Removes the specified junction ('new_junction') from the water network model and prints the resulting list of junctions. Ensure the junction exists and is not referenced in other model elements.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/basics_tutorial.ipynb#_snippet_11\n\nLANGUAGE: python\nCODE:\n```\n# Remove a junction from the WaterNetworkModel\\nwn.remove_node('new_junction')\\nprint(wn.junction_name_list)\n```\n\n----------------------------------------\n\nTITLE: Creating a Value-Based Control in WNTR (Python)\nDESCRIPTION: This snippet shows how to create a control based on a node's attribute value. It retrieves a tank node ('1'), defines a `ValueCondition` that triggers when the tank's level is greater than 46.0248. It then creates a `Control` object named 'control1' using this condition and a previously defined action (`act1`). The example prints both the condition and the control object. This requires a WNTR `WaterNetworkModel` instance (`wn`) and a pre-defined `ControlAction` (`act1`).\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/controls.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n>>> tank = wn.get_node('1')\n>>> cond1 = controls.ValueCondition(tank, 'level', '>', 46.0248)\n>>> print(cond1)\nTANK 1 LEVEL ABOVE 46.0248\n\n>>> ctrl1 = controls.Control(cond1, act1, name='control1')\n>>> print(ctrl1)\nIF TANK 1 LEVEL ABOVE 46.0248 THEN PIPE 330 STATUS IS OPEN PRIORITY 3\n```\n\n----------------------------------------\n\nTITLE: Creating a Binary Time Pattern for Storm Surge in WNTR (Python)\nDESCRIPTION: This snippet defines a time pattern named 'StormSurge' in the WNTR model (`wn`) to represent the duration of the storm surge event. It uses `wntr.network.elements.Pattern.binary_pattern` to create a pattern that is 'on' (value 1) between `storm_start` (2 hours) and `storm_end` (22 hours) and 'off' (value 0) otherwise, matching the simulation duration and pattern timestep.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/salt_water_intrusion_tutorial.ipynb#_snippet_12\n\nLANGUAGE: python\nCODE:\n```\nstorm_start = 2*3600\nstorm_end = 22*3600\nsource_pattern = wntr.network.elements.Pattern.binary_pattern('StormSurge',\n    start_time=storm_start, end_time=storm_end, duration=wn.options.time.duration,\n    step_size=wn.options.time.pattern_timestep)\n\nwn.add_pattern('StormSurge', source_pattern)\n```\n\n----------------------------------------\n\nTITLE: Plotting Average Salt Concentration Map during Storm Surge in Python\nDESCRIPTION: This snippet visualizes the spatial distribution of salt water concentration during the storm. It calculates the time-averaged concentration at each node during the storm period (`storm_start` to `storm_end`) from `baseline_quality`. Then, it uses `wntr.graphics.plot_network` to display the network with nodes colored according to this average concentration.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/salt_water_intrusion_tutorial.ipynb#_snippet_16\n\nLANGUAGE: python\nCODE:\n```\navg_salt_water = baseline_quality.loc[storm_start:storm_end].mean(axis=0)\nax = wntr.graphics.plot_network(wn, node_attribute=avg_salt_water, node_colorbar_label=\"\", title=\"Average salt\")\n```\n\n----------------------------------------\n\nTITLE: Visualizing Pipe Leak Probabilities on Network Map using WNTR (Python)\nDESCRIPTION: Generates two network plots using `wntr.graphics.plot_network` to visualize the calculated leak probabilities. The first plot shows the probability of a 'Minor Leak' for each pipe, and the second plot shows the probability of a 'Major Leak'. Both plots use the specified colormap (`cmap`) and set the color range from 0 to 1.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/earthquake_tutorial.ipynb#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\n# Plot Probability of Minor Leak\nwntr.graphics.plot_network(wn, link_attribute=pipe_Pr['Minor Leak'], node_size=0, link_cmap = cmap, link_range=[0,1], link_width=1.5, title='Probability of a Minor Leak')\n\n# Plot Probability of Major Leak\nwntr.graphics.plot_network(wn, link_attribute=pipe_Pr['Major Leak'], node_size=0, link_cmap = cmap, link_range=[0,1], link_width=1.5, title='Probability of a Major Leak')\n```\n\n----------------------------------------\n\nTITLE: Viewing Hydraulic Simulation Results (Pressures) - Python\nDESCRIPTION: Displays a portion of the pressure node results from the baseline simulation. Assumes 'baseline_results' is a valid WNTR simulation result, and the table includes nodes labeled 'pressure'. Returns a DataFrame head for quick inspection.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/landslide_tutorial.ipynb#_snippet_27\n\nLANGUAGE: python\nCODE:\n```\n# View a subset of the simulation results\nbaseline_results.node['pressure'].head()\n```\n\n----------------------------------------\n\nTITLE: Exporting Water Network Model to GeoJSON - Python\nDESCRIPTION: Saves all network components from the base model into separate GeoJSON files using the specified CRS, producing a 'perfect' geospatial dataset for subsequent model reconstruction. This method is useful for external GIS workflows or sharing data. Requires the base WaterNetworkModel instance and a target directory path.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/model_development_tutorial.ipynb#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nwntr.network.io.write_geojson(wn0, \"data/ky4\", crs=crs)\\n\n```\n\n----------------------------------------\n\nTITLE: Returning a Pandas Series of a Demand Pattern in WNTR Python\nDESCRIPTION: This code retrieves a named pattern ('Gaussian_with_noise') as a Pandas Series, specifying a duration of 48 hours, and prints the first five values. It requires that the pattern already exists in the library. Outputs a pandas Series indexed by time in seconds.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/libraries.rst#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n>>> series = demand_library.to_Series('Gaussian_with_noise', duration=48*3600)\n>>> print(series.head())\n0        7.474e-04\n3600     2.676e-01\n7200     2.862e-01\n10800    2.302e-01\n14400    4.742e-01\ndtype: float64\n```\n\n----------------------------------------\n\nTITLE: Rotating and Visualizing Network Coordinates with WNTR and Matplotlib - Python\nDESCRIPTION: This snippet rotates node coordinates of a WaterNetworkModel by 30 degrees counterclockwise using wntr.morph.rotate_node_coordinates and plots the rotated network. Requires WNTR and Matplotlib for rendering the graphics. The 'wn' object must be a valid WaterNetworkModel. Input is the rotation angle, output is the plot on the axes object.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/basics_tutorial.ipynb#_snippet_35\n\nLANGUAGE: python\nCODE:\n```\n# Rotate node coordinates counterclockwise by 30 degrees\\nwn_rotated = wntr.morph.rotate_node_coordinates(wn, 30)\\nax = wntr.graphics.plot_network(wn_rotated)\n```\n\n----------------------------------------\n\nTITLE: Plotting Node-Level Hydraulic Metrics for Base Model - Python\nDESCRIPTION: Visualizes average expected demand and pressure for each node in the base water network using Matplotlib subplots. The code generates two side-by-side network plots with color-coded node attributes. Inputs are node-level metrics, network model, and Matplotlib axes. Outputs are rendered figures for comparative analysis.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/model_development_tutorial.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n# Plot metrics\\nfig, axes = plt.subplots(1,2, figsize=(12,3.5))\\nax = wntr.graphics.plot_network(wn0, node_attribute=aed0, node_size=30, title=\"wn0 Average Expected Demand\", show_plot=False, ax=axes[0])\\nax = wntr.graphics.plot_network(wn0, node_attribute=pressure0, node_size=30, title=\"wn0 Pressure\", show_plot=False, ax=axes[1])\\n\n```\n\n----------------------------------------\n\nTITLE: Plotting and Modifying Pump and Tank Curves in WNTR (Python)\nDESCRIPTION: This set of snippets covers getting a pump object, plotting head pump curves, accessing and modifying curve points, and adding a tank volume curve. Requires correct object names, and the ability to plot using Matplotlib.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/basics_tutorial.ipynb#_snippet_28\n\nLANGUAGE: python\nCODE:\n```\n# Get a head pump object and plot the head pump curve\\npump = wn.get_link('10')\\nprint(type(pump))\\nax = wntr.graphics.plot_pump_curve(pump)\n```\n\nLANGUAGE: python\nCODE:\n```\n# Get the head curve and print the points\\npump_curve_name = pump.pump_curve_name\\ncurve = wn.get_curve(pump_curve_name)\\ncurve.points\n```\n\nLANGUAGE: python\nCODE:\n```\n# Modify the curve points and re-plot the pump curve\\ncurve.points = [(0.10, 20)]\\nax = wntr.graphics.plot_pump_curve(pump)\n```\n\nLANGUAGE: python\nCODE:\n```\n# Add a tank volume curve to the model and assign it to a tank\\nwn.add_curve('new_tank_curve', 'VOLUME', [\\n   (1,  0),\\n   (2,  60),\\n   (3,  188),\\n   (4,  372),\\n   (5,  596),\\n   (6,  848),\\n   (7,  1114),\\n   (8,  1379),\\n   (9,  1631),\\n   (10, 1856),\\n   (11, 2039),\\n   (12, 2168),\\n   (13, 2228)])\\ntank = wn.get_node('2')\\ntank.vol_curve_name = 'new_tank_curve'\\nax = wntr.graphics.plot_tank_volume_curve(tank)\n```\n\n----------------------------------------\n\nTITLE: Opening Jupyter Notebooks with Jupyter Lab - Shell\nDESCRIPTION: This snippet demonstrates how to launch a specific Jupyter Notebook (in this example, getting_started_tutorial.ipynb) using the jupyter lab command from a shell or terminal prompt. Jupyter Lab is required, which can be installed via Anaconda or pip. The main parameter is the filename of the notebook, and executing this command will open it in a new browser window for interactive exploration. The output is a running Jupyter Lab session in your browser. No Python dependencies are needed beyond a working Jupyter environment.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/examples.rst#_snippet_0\n\nLANGUAGE: Shell\nCODE:\n```\njupyter lab getting_started_tutorial.ipynb\n```\n\n----------------------------------------\n\nTITLE: Creating a New Matplotlib Figure - Python\nDESCRIPTION: Creates and initializes a new Matplotlib figure as the drawing canvas for subsequent plotting. This is a setup step prior to plotting pump, tank, or valve segment graphics. Only requires matplotlib.pyplot as plt to be imported.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/graphics.rst#_snippet_11\n\nLANGUAGE: python\nCODE:\n```\n>>> fig = plt.figure()\n```\n\n----------------------------------------\n\nTITLE: Installing WNTR Using pip - Bash\nDESCRIPTION: Installs the latest release of the WNTR package from the Python Package Index (PyPI) using the pip command-line tool. Requires Python and pip to be pre-installed. Running this command downloads and installs all necessary Python dependencies for WNTR into the current environment. The primary input is the package name (wntr), and upon successful execution, WNTR will be ready to use within the environment. No elevated permissions are needed if installing into a user environment; administrative rights may be needed for system-wide installs.\nSOURCE: https://github.com/usepa/wntr/blob/main/README.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\npip install wntr\n```\n\n----------------------------------------\n\nTITLE: Including Release Note Files Using reStructuredText Directives - reStructuredText\nDESCRIPTION: This snippet demonstrates how to include an external release note file (v1.3.2.rst) into the documentation using the reStructuredText (RST) '.. include::' directive, preceded by a Sphinx reference anchor for cross-referencing. There are no external dependencies other than the existence of the referenced file. The input to this snippet is the relative path to the .rst file, and the output is the inclusion of its contents into the generated piece of documentation at this location.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/whatsnew.rst#_snippet_1\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. _whatsnew_132:\n\n.. include:: whatsnew/v1.3.2.rst\n```\n\n----------------------------------------\n\nTITLE: Assigning Earthquake Probability to Pipes via GIS Intersection using WNTR (Python)\nDESCRIPTION: This segment illustrates reading fault line data with earthquake probabilities, then intersecting the fault lines with network pipes using wntr.gis.intersect to attribute pipe segments with probabilities. Required libraries are GeoPandas, WNTR, and a compatible water network model. Inputs include pipe and fault line geometries as GeoDataFrames and the column to join on; outputs detail lists of intersection indices, counts, and value statistics for each pipe, facilitating hazard analysis.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/gis.rst#_snippet_24\n\nLANGUAGE: python\nCODE:\n```\n>>> wn = wntr.network.WaterNetworkModel('networks/Net1.inp') # doctest: +SKIP\n>>> wn_gis = wntr.network.to_gis(wn, crs='EPSG:4326')\n```\n\nLANGUAGE: python\nCODE:\n```\n>>> earthquake_data = gpd.read_file('data/Net1_earthquake_data.geojson') # doctest: +SKIP\n>>> print(earthquake_data)\n     Pr                                geometry\n0  0.50         LINESTRING (36 2, 44 44, 85 85)\n1  0.75  LINESTRING (42 2, 45 27, 38 56, 30 85)\n2  0.90         LINESTRING (40 2, 50 50, 60 85)\n3  0.25  LINESTRING (30 2, 35 30, 40 50, 60 80)\n```\n\nLANGUAGE: python\nCODE:\n```\n>>> pipe_Pr = wntr.gis.intersect(wn_gis.pipes, earthquake_data, 'Pr')\n>>> print(pipe_Pr)\n    intersections                  values  n   sum   min   max  mean\n10             []                      []  0   NaN   NaN   NaN   NaN\n11            [1]                  [0.75]  1  0.75  0.75  0.75  0.75\n12      [0, 2, 3]        [0.5, 0.9, 0.25]  3  1.65  0.25  0.90  0.55\n21   [0, 1, 2, 3]  [0.5, 0.75, 0.9, 0.25]  4  2.40  0.25  0.90  0.60\n22             []                      []  0   NaN   NaN   NaN   NaN\n31   [0, 1, 2, 3]  [0.5, 0.75, 0.9, 0.25]  4  2.40  0.25  0.90  0.60\n110            []                      []  0   NaN   NaN   NaN   NaN\n111            []                      []  0   NaN   NaN   NaN   NaN\n112     [0, 2, 3]        [0.5, 0.9, 0.25]  3  1.65  0.25  0.90  0.55\n113           [0]                   [0.5]  1  0.50  0.50  0.50  0.50\n121            []                      []  0   NaN   NaN   NaN   NaN\n122            []                      []  0   NaN   NaN   NaN   NaN\n```\n\nLANGUAGE: python\nCODE:\n```\n>>> ax = earthquake_data.plot(column='Pr', alpha=0.5, cmap='bone', vmin=0, vmax=1)\n>>> ax = wntr.graphics.plot_network(wn, link_attribute=pipe_Pr['max'], link_width=1.5, \n...     node_range=[0,1], link_range=[0,1], ax=ax, \n...     link_colorbar_label='Earthquake Probability')\n```\n\nLANGUAGE: python\nCODE:\n```\n>>> bounds = ax.axis('equal')\n>>> plt.tight_layout()\n>>> plt.savefig('intersect_earthquake.png', dpi=300)\n>>> plt.close()\n```\n\nLANGUAGE: python\nCODE:\n```\n>>> pipes_that_intersect_each_fault = wntr.gis.intersect(earthquake_data, wn_gis.pipes)\n>>> print(pipes_that_intersect_each_fault)\n            intersections  n\n0  [112, 113, 12, 21, 31]  5\n1            [11, 21, 31]  3\n2       [112, 12, 21, 31]  4\n3       [112, 12, 21, 31]  4\n```\n\n----------------------------------------\n\nTITLE: Adding and Configuring MSX Model in WNTR (Python)\nDESCRIPTION: Adds a new Multispecies Extension (MSX) model to the loaded WNTR `WaterNetworkModel`. It sets the title, adds a reference citation, and configures MSX options like area units ('FT2'), rate units ('DAY'), and the simulation timestep (300 seconds).\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/multispecies_tutorial.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nwn.add_msx_model()\nwn.msx.title = \"Multisource Chlorine Decay\"\nwn.msx.references.append(\n    \"\"\"(2023) Shang F, L Rossman, and J Uber. \n\"EPANET-MSX 2.0 User Manual\". EPA/600/R-22/199\"\"\"\n)\nwn.msx.options.area_units = \"FT2\"\nwn.msx.options.rate_units = \"DAY\"\nwn.msx.options.timestep = 300\n```\n\n----------------------------------------\n\nTITLE: Advanced Static Network Visualization with Attributes - Matplotlib/Pandas - Python\nDESCRIPTION: Combines multiple static network graphic visualizations using subplots, demonstrating use of simulation results and custom data for coloring and highlighting. It acquires pipe velocities from simulation, calculates the five longest pipes, and lists tank names, then generates side-by-side plots: velocity, pipe length, and tank locations. Required: wntr, pandas, matplotlib, and a network model with simulation results and associated attributes.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/graphics.rst#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n>>> sim = wntr.sim.EpanetSimulator(wn)\n>>> results = sim.run_sim()\n>>> velocity = results.link['velocity'].loc[3600,:]\n>>> print(velocity.head())\nname\n20     0.039\n40     0.013\n50     0.004\n60     2.824\n101    1.320\nName: 3600, dtype: float32\n\n>>> length = wn.query_link_attribute('length')\n>>> length_top5 = length.sort_values(ascending=False)[0:5]\n>>> length_top5 = length_top5.round(2).to_dict()\n>>> print(length_top5)\n{'329': 13868.4, '101': 4328.16, '137': 1975.1, '169': 1389.89, '204': 1380.74}\n\n>>> tank_names = wn.tank_name_list\n>>> print(tank_names)\n['1', '2', '3']\n\n>>> fig, axes = plt.subplots(1, 3, figsize=(15, 5))\n>>> ax = wntr.graphics.plot_network(wn, link_attribute=velocity, \n...    title='Pipe velocity at hour 1', link_colorbar_label='Velocity (m/s)', ax=axes[0])\n>>> ax = wntr.graphics.plot_network(wn, link_attribute=length_top5, link_width=2, \n...    title='Longest 5 pipes', link_cmap = plt.cm.viridis, \n...    link_colorbar_label='Pipe length (m)', ax=axes[1])\n>>> ax = wntr.graphics.plot_network(wn, node_attribute=tank_names, \n...    title='Location of tanks', ax=axes[2])\n```\n\n----------------------------------------\n\nTITLE: Querying Custom Link Attribute 'material'\nDESCRIPTION: This snippet shows how to retrieve the values of a custom attribute added to model elements. It uses the `query_link_attribute` method to get the values of the 'material' attribute for all links (pipes, pumps, valves) and stores the result in a Pandas Series named `material`.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/waternetworkmodel.rst#_snippet_17\n\nLANGUAGE: python\nCODE:\n```\n>>> material = wn.query_link_attribute('material')\n```\n\n----------------------------------------\n\nTITLE: Calculating and Adding Betweenness Centrality to WNTR GIS Object in Python\nDESCRIPTION: This snippet calculates the betweenness centrality for nodes in a water network model using NetworkX. First, the WNTR model (`wn`) is converted to a NetworkX graph (`G`). Then, `nx.betweenness_centrality` computes the centrality scores. Finally, these scores are added as a new attribute named 'betweenness_centrality' to the junctions layer within the `WaterNetworkGIS` object (`wn_gis`) using the `add_node_attributes` method. The `.head()` method displays the updated junction attributes.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/basics_tutorial.ipynb#_snippet_95\n\nLANGUAGE: python\nCODE:\n```\n# Compute betweenness centrality and add it to the WaterNetworkGIS object\nG = wn.to_graph() # directed multigraph\nbetweenness_centrality = nx.betweenness_centrality(G)\n\nwn_gis.add_node_attributes(betweenness_centrality, 'betweenness_centrality')\nwn_gis.junctions.head()\n```\n\n----------------------------------------\n\nTITLE: Copying, Applying Noise, and Plotting Demand Patterns in WNTR Python\nDESCRIPTION: This snippet copies an existing 'Gaussian' pattern as 'Gaussian_with_noise', applies Gaussian noise (with 0.1 std. dev.) and normalization, and plots both the original and noisy pattern for comparison. It optionally seeds the noise for reproducibility. Dependencies are wntr, matplotlib, and pandas. Returns the modified pattern as a pandas Series and plots using matplotlib axes.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/libraries.rst#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n>>> demand_library.copy_pattern('Gaussian', 'Gaussian_with_noise')\n>>> series = demand_library.apply_noise('Gaussian_with_noise', 0.1, normalize=True,\n...     seed=123)\n>>> ax = demand_library.plot_patterns(names=['Gaussian', 'Gaussian_with_noise'])\n```\n\n----------------------------------------\n\nTITLE: Plotting Original and Modified Expected Demands (Python)\nDESCRIPTION: Plots pre-modification and post-modification expected demand timeseries for a specific junction using Matplotlib. This comparison visually confirms changes to demand attributes.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/basics_tutorial.ipynb#_snippet_27\n\nLANGUAGE: python\nCODE:\n```\n# Plot original and modified expected demands\\nnew_expected_demand = wntr.metrics.expected_demand(wn) \\n\\nplt.figure()\\nax = expected_demand.loc[0:48*3600, \"15\"].plot()\\nnew_expected_demand.loc[0:48*3600, \"15\"].plot(ax=ax)\\ntmp = ax.set_xlabel('Time (s)')\\ntmp = ax.set_ylabel('Expected demand (m$^3$/s)')\n```\n\n----------------------------------------\n\nTITLE: Including Release Note Files Using reStructuredText Directives - reStructuredText\nDESCRIPTION: This snippet demonstrates how to include an external release note file (v0.1.7.rst) into the documentation using the reStructuredText (RST) '.. include::' directive, preceded by a Sphinx reference anchor for cross-referencing. There are no external dependencies other than the existence of the referenced file. The input to this snippet is the relative path to the .rst file, and the output is the inclusion of its contents into the generated piece of documentation at this location.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/whatsnew.rst#_snippet_17\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. _whatsnew_0170:\n\n.. include:: whatsnew/v0.1.7.rst\n```\n\n----------------------------------------\n\nTITLE: Including Release Note Files Using reStructuredText Directives - reStructuredText\nDESCRIPTION: This snippet demonstrates how to include an external release note file (v0.1.3.rst) into the documentation using the reStructuredText (RST) '.. include::' directive, preceded by a Sphinx reference anchor for cross-referencing. There are no external dependencies other than the existence of the referenced file. The input to this snippet is the relative path to the .rst file, and the output is the inclusion of its contents into the generated piece of documentation at this location.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/whatsnew.rst#_snippet_21\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. _whatsnew_0130:\n\n.. include:: whatsnew/v0.1.3.rst\n```\n\n----------------------------------------\n\nTITLE: Setting Initial Pump Status in Water Network Model - Python\nDESCRIPTION: Sets the initial operating status of a pump link (~@Pump-1) to 'Closed' using model's link accessor. Ensures hydraulic simulations start with pumps in the correct state, impacting system dynamics. Requires the model to contain the specified pump and uses WNTR's link API.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/model_development_tutorial.ipynb#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\npump = wn1.get_link(\"~@Pump-1\")\\npump.initial_status = \"Closed\"\\n\n```\n\n----------------------------------------\n\nTITLE: Retrieving List of Valid WNTR GIS Attribute Names - Python\nDESCRIPTION: Prints out allowed GIS attribute names as defined by WNTR, assisting the user in preparing GeoJSON files or in renaming DataFrame columns to conform with model expectations. This step aids troubleshooting of schema mismatches.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/model_development_tutorial.ipynb#_snippet_20\n\nLANGUAGE: python\nCODE:\n```\nprint(wntr.network.io.valid_gis_names())\\n\n```\n\n----------------------------------------\n\nTITLE: Plotting Distribution of Estimated Salt Water Flow Rates in Python\nDESCRIPTION: This snippet generates a histogram to visualize the distribution of the calculated salt water intrusion flow rates across all junctions. It uses Matplotlib to create the histogram, labels the axes, and adds a title.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/salt_water_intrusion_tutorial.ipynb#_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nfig, ax = plt.subplots()\nax.hist(salt_water_flowrate)\nax.set_xlabel(\"Salt water flowrate (m^3 / s)\")\nax.set_ylabel(\"Node count\")\nax.set_title(\"Distribution of salt water flowrate\")\n```\n\n----------------------------------------\n\nTITLE: Plotting Landslide-Pipe Intersections and Pipe Lengths - Python\nDESCRIPTION: This code visualizes intersection statistics between landslides and pipes using matplotlib and pandas DataFrames. It plots, side-by-side, (a) the count of intersecting pipes and (b) the total intersected pipe length for each landslide. Assumes both 'wn_gis' and 'landslide_scenarios' GIS DataFrames are available, as well as axis zoom coordinates. Outputs are twin map plots suitable for report figures.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/landslide_tutorial.ipynb#_snippet_21\n\nLANGUAGE: python\nCODE:\n```\n# Plot intersection results\nfig, axes = plt.subplots(1,2, figsize=(15,5))\n\nwn_gis.pipes.plot(color='gray', linewidth=1, ax=axes[0])\nlandslide_scenarios.plot(column='n', vmax=10, legend=True, ax=axes[0])\ntmp = axes[0].set_title('Number of pipes that intersect each landslide')\ntmp = axes[0].axis('off')\n# Comment/uncomment the following 2 lines to change the zoom on the network graphic\ntmp = axes[0].set_xlim(zoom_coords[0])\ntmp = axes[0].set_ylim(zoom_coords[1])\n\nwn_gis.pipes.plot(color='gray', linewidth=1, ax=axes[1])\nlandslide_scenarios.plot(column='total pipe length', vmax=10000, legend=True, ax=axes[1])\ntmp = axes[1].set_title('Length of pipe that intersect each landslide')\ntmp = axes[1].axis('off')\n# Comment/uncomment the following 2 lines to change the zoom on the network graphic\ntmp = axes[1].set_xlim(zoom_coords[0])\ntmp = axes[1].set_ylim(zoom_coords[1])\n```\n\n----------------------------------------\n\nTITLE: Performing Parameter Sensitivity Analysis on Decay Constant in WNTR (Python)\nDESCRIPTION: Performs a sensitivity analysis by iteratively running the simulation while varying the chlorine decay constant 'k1'. It loops 7 times, updating the `value` attribute of the 'k1' constant object in the `wn.msx` model (incrementing by 2.6 each time, starting from 1.3). In each iteration, it runs the simulation using the existing `sim` object (which references the updated `wn` model) and stores the simulation results object (`resk`) in a dictionary `d_k1`, keyed by the `k1` value used for that simulation.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/multispecies_tutorial.ipynb#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nd_k1 = dict()\nk1 = wn.msx.reaction_system.constants[\"k1\"]\nfor i in range(7):\n    # Increase the reaction rate\n    newk = 1.3 + i * 2.6\n    k1.value = newk\n    resk = sim.run_sim()\n    d_k1[newk] = resk\n```\n\n----------------------------------------\n\nTITLE: Importing NetworkX and WNTR for Graph Extraction - Python\nDESCRIPTION: This snippet imports both NetworkX and WNTR libraries, preparing the workspace for extraction and analysis of a water distribution network as a MultiDiGraph object. While the example omits graph extraction, it establishes the necessary dependencies so that the network model can be analyzed via NetworkX methods.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/resilience.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n>>> import networkx as nx\n>>> import wntr # doctest: +SKIP\n```\n\n----------------------------------------\n\nTITLE: Listing Control Names from WaterNetworkModel in Python\nDESCRIPTION: Shows how to access the `control_name_list` attribute of a WNTR `WaterNetworkModel` (`wn`) to get a list of all defined control names. Assumes `wn` is a populated WaterNetworkModel instance.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/controls.rst#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\n>>> control_name_list = wn.control_name_list\n>>> print(control_name_list)\n['control 1', 'control 2', 'control 3', 'control 4', 'control 5', 'control 6', 'control 7', 'control 8', 'control 9', 'control 10', 'control 11', 'control 12', 'control 13', 'control 14', 'control 15', 'control 16', 'control 17', 'control 18']\n```\n\n----------------------------------------\n\nTITLE: Storing Pumps and Valves as Point Geometries in GIS Conversion - Python\nDESCRIPTION: This code converts the WaterNetworkModel to GeoPandas-based WaterNetworkGIS, specifying that pumps and valves be represented as points (rather than the default lines). This is useful for visualization or spatial analysis when component position, rather than path, is of interest. Inputs: WaterNetworkModel, pumps_as_points=True, valves_as_points=True; Output: WaterNetworkGIS with altered geometry type for those components. Dependency: wntr, geopandas.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/gis.rst#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\n>>> wn_gis = wntr.network.to_gis(wn, pumps_as_points=True, \n...     valves_as_points=True)\n```\n\n----------------------------------------\n\nTITLE: Plotting a Basic Water Network Graphic using WNTR\nDESCRIPTION: Generates a basic plot of the water network using `wntr.graphics.plot_network()`. This visualization colors nodes based on their 'elevation' attribute within the specified range (175 to 300) and includes a title. The comment notes that this function does not plot pipe vertices, unlike plots generated directly from GIS data.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/landslide_tutorial.ipynb#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\n# Create a basic network graphic, showing junction elevation\n# Note, the remaining graphics in this tutorial are created from the geospatial data directly, rather than the `plot_network` function.\n# The `plot_network` function currently does not include vertices.\nax = wntr.graphics.plot_network(wn, node_attribute='elevation', node_range=(175, 300), title='ky10 elevation')\n```\n\n----------------------------------------\n\nTITLE: Visualizing Metric Distributions and Differences Between Models - Python\nDESCRIPTION: Generates comparative network visualizations for demand and pressure across both models and their differences. Multiple subplots show raw and delta values spatially, providing insight into model alignment. Inputs are attribute arrays for plotting across consistent axes.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/model_development_tutorial.ipynb#_snippet_14\n\nLANGUAGE: python\nCODE:\n```\nfig, axes = plt.subplots(1,2, figsize=(12,3.5))\\nax = wntr.graphics.plot_network(wn0, node_attribute=aed0, node_size=30, title=\"wn0 Average Expected Demand\", show_plot=False, ax=axes[0])\\nax = wntr.graphics.plot_network(wn0, node_attribute=pressure0, node_size=30, title=\"wn0 Pressure\", show_plot=False, ax=axes[1])\\n\\nfig, axes = plt.subplots(1,2, figsize=(12,3.5))\\nax = wntr.graphics.plot_network(wn1, node_attribute=aed1, node_size=30, title=\"wn1 Average Expected Demand\", show_plot=False, ax=axes[0])\\nax = wntr.graphics.plot_network(wn1, node_attribute=pressure1, node_size=30, title=\"wn1 Pressure\", show_plot=False, ax=axes[1])\\n\\nfig, axes = plt.subplots(1,2, figsize=(12,3.5))\\nax = wntr.graphics.plot_network(wn1, node_attribute=aed_diff1, node_size=30, title=\"Difference in Average Expected Demand\", show_plot=False, ax=axes[0])\\nax = wntr.graphics.plot_network(wn1, node_attribute=pressure_diff1, node_size=30, title=\"Difference in Pressure\", show_plot=False, ax=axes[1])\\n\n```\n\n----------------------------------------\n\nTITLE: Storing Landslide Intersections and Confidence in Pipe Layer - Python\nDESCRIPTION: This code transfers intersection and confidence ranking summaries to the GIS pipe DataFrame and then sorts the result by the count of intersections. Requires previously prepared intersection results with columns for intersections, counts, and mean confidence. Outputs are updated GIS layers ready for map-based analysis or tabular reporting.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/landslide_tutorial.ipynb#_snippet_23\n\nLANGUAGE: python\nCODE:\n```\n# Add the intersection results to the GIS pipe data\nwn_gis.pipes[['intersections', 'n', 'Confidence_Ranking']] = pipe_intersect[['intersections', 'n', 'mean']]\n\n# Print results in order of descending number of intersections\nwn_gis.pipes.sort_values('n', ascending=False).head()\n```\n\n----------------------------------------\n\nTITLE: Checking the installed WNTR version in Python (Python)\nDESCRIPTION: Prints the installed version number of the WNTR library to the console. This command should be run in a Python console after successfully importing WNTR (`import wntr`) to verify the specific version that has been installed.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/installation.rst#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nprint(wntr.__version__)\n```\n\n----------------------------------------\n\nTITLE: Initializing WNTR MsxLibrary with Local Path in Python\nDESCRIPTION: Initializes a WNTR `MsxLibrary` object, configuring it to search for MSX model files (.msx or .json) in the current directory ('.') in addition to the default library locations, using the `extra_paths` argument. It then calls `model_name_list()` to retrieve and implicitly print the names of all discoverable models, including built-in ones and any found in the current directory (like those created in previous steps).\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/multispecies_tutorial.ipynb#_snippet_14\n\nLANGUAGE: python\nCODE:\n```\nmy_library = MsxLibrary(extra_paths=[\".\"])  # load files from the current directory\nmy_library.model_name_list()\n```\n\n----------------------------------------\n\nTITLE: Creating and Plotting a Tank Volume Curve Using WNTR - Python\nDESCRIPTION: This snippet defines a new tank volume curve in a network model, assigns it to a tank node, and plots the volume-height relationship using WNTR. The curve is specified as a set of (height, volume) tuples. Dependencies are WNTR and an initialized network (wn). Inputs are the tank node ID ('2'), a set of curve points, and curve assignment; output is the rendered Matplotlib axis.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/graphics.rst#_snippet_13\n\nLANGUAGE: python\nCODE:\n```\n>>> wn.add_curve('Curve', 'VOLUME', [\n...    (1,\t0),\n...    (2,\t60),\n...    (3,\t188),\n...    (4,\t372),\n...    (5,\t596),\n...    (6,\t848),\n...    (7,\t1114),\n...    (8,\t1379),\n...    (9,\t1631),\n...    (10, 1856),\n...    (11, 2039),\n...    (12, 2168),\n...    (13, 2228)])\n>>> tank = wn.get_node('2')\n>>> tank.vol_curve_name = 'Curve'\n>>> ax = wntr.graphics.plot_tank_volume_curve(tank)\n```\n\n----------------------------------------\n\nTITLE: Modifying a Constant Value in an MSX Model in WNTR - Python\nDESCRIPTION: Demonstrates retrieving a constant from the MSX model and updating its value attribute in place. The operation directly mutates the model's constant for desorption rate. Requires that the named constant has been added previously. Affects all subsequent simulations using the model.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/advancedsim.rst#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\n>>> M = msx.reaction_system.constants['M']\n>>> M.value = 0.118\n>>> M\nConstant(name='M', value=0.118, units='ug * m^(-2) * s^(-1)', note='Desorption rate (ug/m^2/s)')\n```\n\n----------------------------------------\n\nTITLE: Extracting WSA Results for Each Landslide Scenario - Python\nDESCRIPTION: Extracts the WSA results columns for each scenario from the junction GIS DataFrame to a new DataFrame for statistical analysis. Assumes WSA attributes are indexed by the scenario index. Output is a scenario-by-junction matrix for downstream processing.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/landslide_tutorial.ipynb#_snippet_38\n\nLANGUAGE: python\nCODE:\n```\n# Extract WSA for each scenario \nwsa_results = wn_gis.junctions[landslide_scenarios_downselect.index]\n\nwsa_results.head()\n```\n\n----------------------------------------\n\nTITLE: Plotting Chlorine Residual Sensitivity Results in Python\nDESCRIPTION: Plots the results of the parameter sensitivity analysis using Matplotlib. It iterates through the `d_k1` dictionary (containing results for different 'k1' values) and plots the chlorine ('CL2') concentration time series at a specific node (`query`) for the first 36 hours (3600*36 seconds) of each simulation. A legend is added to identify which 'k1' value corresponds to each line, and the plot is given a title and axis labels.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/multispecies_tutorial.ipynb#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\n# res.node[\"T1\"].loc[0:3600*36, query].plot(style='k.')\nfor newk, resk in d_k1.items():\n    resk.node[\"CL2\"].loc[0 : 3600 * 36, query].plot()\nplt.legend([\"{:.1f}\".format(k) for k in d_k1.keys()], title=\"k1 (1/day)\")\nplt.title(\"Chlorine residual at node {}\".format(query))\nplt.xlabel(\"Seconds\")\nplt.ylabel(\"Concentraion [mg/L]\")\n```\n\n----------------------------------------\n\nTITLE: Plotting Water Network Model using WNTR Graphics in Python\nDESCRIPTION: This snippet visualizes the water network model represented by the `wn` object. It uses `matplotlib.pyplot` to create a figure and axes, and then calls `wntr.graphics.plot_network` to draw the network layout onto the axes.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/salt_water_intrusion_tutorial.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfig, ax = plt.subplots()\nax = wntr.graphics.plot_network(wn, ax=ax)\n```\n\n----------------------------------------\n\nTITLE: Plotting Hydrant Data and Network with Snapped Junctions Highlighted in Python\nDESCRIPTION: This code generates a plot visualizing the hydrant locations and the water network. It first plots the hydrant data using GeoPandas' plot method. Then, it overlays the WNTR network plot using `wntr.graphics.plot_network`, highlighting the specific junctions that the hydrants were snapped to in the previous step by passing the list of snapped junction names (`snapped_to_junctions['node'].to_list()`) to the `node_attribute` parameter.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/gis.rst#_snippet_20\n\nLANGUAGE: python\nCODE:\n```\n>>> ax = hydrant_data.plot()\n>>> ax = wntr.graphics.plot_network(wn, \n...     node_attribute=snapped_to_junctions['node'].to_list(), ax=ax)\n```\n\n----------------------------------------\n\nTITLE: Calculating Mass of Contaminant Consumed - WNTR - Python\nDESCRIPTION: Calculates the mass of contaminant consumed by the population at each node and time using demand and quality results. Both DataFrames should only include applicable nodes (e.g., junctions). This metric quantifies consumer exposure to pollution events.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/resilience.rst#_snippet_20\n\nLANGUAGE: python\nCODE:\n```\n>>> demand = results.node['demand'].loc[:,wn.junction_name_list]\n>>> quality = results.node['quality'].loc[:,wn.junction_name_list]\n>>> MC = wntr.metrics.mass_contaminant_consumed(demand, quality)\n```\n\n----------------------------------------\n\nTITLE: Connecting Reservoirs and Tanks with Pipes using Add Connector Function - Python\nDESCRIPTION: Defines and applies add_connector to connect snapped reservoirs and tanks to their respective nearest junctions by adding new pipe entries. Function takes a snapped dataframe and pipes dataframe, adds new pipe records with attributes like geometry, valves, lengths, and connectivity, and resets the CRS. This step readies pipes for network expansion. Requires shapely's LineString, pandas, and WNTR data structures.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/model_development_tutorial.ipynb#_snippet_25\n\nLANGUAGE: python\nCODE:\n```\ndef add_connector(snap_attribute, pipes):\\n    for name, row in snap_attribute.iterrows():\\n        pipe_crs = pipes.crs\\n        attributes = {'check_valve': 0, \\n                      'diameter': 0.3, \\n                      'initial_status': 'Open',\\n                      'length': 1, \\n                      'minor_loss': 0,\\n                      'roughness': 150,\\n                      'geometry': LineString([row['geometry'], row['geometry']]),\\n                      'start_node_name': row['node'],\\n                      'end_node_name': name}\\n        pipes.loc[name+'_connector'] = attributes\\n        pipes.set_crs(pipe_crs, inplace=True)\\n    return pipes\\n    \\npipes = add_connector(snap_reservoirs, pipes)\\npipes = add_connector(snap_tanks, pipes)\\nprint(pipes.tail())\n```\n\n----------------------------------------\n\nTITLE: Generating and Plotting a Strategic (N-2) WNTR Valve Layer in Python\nDESCRIPTION: This snippet shows how to generate a valve layer using the 'strategic' placement method with `wntr.network.generate_valve_layer`. It specifies an N-2 placement strategy by passing `2` as the third argument, meaning for each node, valves will be placed such that 2 connected pipes *do not* contain a valve protecting that node. The generated `strategic_valve_layer` DataFrame is then visualized on the network map using `wntr.graphics.plot_valve_layer`.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/layers.rst#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n>>> strategic_valve_layer = wntr.network.generate_valve_layer(wn, 'strategic', 2)\n>>> ax = wntr.graphics.plot_valve_layer(wn, strategic_valve_layer, add_colorbar=False)\n```\n\n----------------------------------------\n\nTITLE: Intersecting WNTR Pipes with Demographic Data in Python\nDESCRIPTION: This snippet uses the `wntr.gis.intersect` function to perform a spatial intersection between water network pipes (from `wn_gis.pipes`) and demographic data (likely a GeoDataFrame `demographic_data`). It extracts the 'mean_income' attribute from the intersecting demographic polygons for each pipe. The `.head()` method is then called to display the first few rows of the resulting Series or DataFrame containing the extracted income data associated with pipes.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/basics_tutorial.ipynb#_snippet_93\n\nLANGUAGE: python\nCODE:\n```\n# Intersect pipes with census block groups, extract mean income\npipe_demographics = wntr.gis.intersect(wn_gis.pipes, demographic_data, 'mean_income')\npipe_demographics.head()\n```\n\n----------------------------------------\n\nTITLE: Plotting WSA Distribution Per Scenario Using Boxplots - Python\nDESCRIPTION: Visualizes the spread and central tendency of WSA values across scenarios, using a boxplot. Allows optional y-range truncation and axis labeling. Inputs are aggregated WSA results and matplotlib support. Output helps identify typical and outlier performance across scenarios.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/landslide_tutorial.ipynb#_snippet_39\n\nLANGUAGE: python\nCODE:\n```\n# Plot distribution of WSA for each scenario. Note that WSA can be > 1 and < 0 due to numerical differences in expected and actual demand. \n# For certain types of analysis, the WSA should be truncated to values between 0 and 1.\nax = wsa_results.boxplot()\ntmp = ax.set_ylim(-0.25, 1.25)\ntmp = ax.set_ylabel('WSA')\ntmp = ax.set_title('Distribution of WSA for each scenario')\n```\n\n----------------------------------------\n\nTITLE: Connecting Pipes and Visualizing Network with WNTR - Python\nDESCRIPTION: Connects disconnected pipes within a specified distance threshold using wntr.gis.connect_lines, then visualizes disconnected and newly connected pipes along with junctions on a matplotlib plot. Requires WNTR, Geopandas for dataframes, and matplotlib for plotting (pipes, junctions, and disconnected_pipes are GeoDataFrames). The threshold defines proximity for connection, and zoom_coords controls axis scaling.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/model_development_tutorial.ipynb#_snippet_21\n\nLANGUAGE: python\nCODE:\n```\ndistance_threshold = 100.0 # ft, used to connect pipes\\n\\nprint('Number of diconnected pipes', disconnected_pipes.shape[0])\\npipes, junctions = wntr.gis.connect_lines(disconnected_pipes, distance_threshold)\\nprint('Number of connected pipes', pipes.shape[0])\\nprint(pipes.head())\\nprint(junctions.head())\\n\\nfig, ax = plt.subplots(figsize=(12,5))\\ndisconnected_pipes.plot(color=\\\"b\\\", linewidth=4, alpha=0.5, label='disconnected pipes', ax=ax)\\npipes.plot(color=\\\"r\\\", linewidth=2, alpha=0.5, label='connected pipes', ax=ax)\\njunctions.plot(color=\\\"k\\\", label='junctions', ax=ax)\\nax.legend()\\ntmp = ax.set_xlim(zoom_coords[0])\\ntmp = ax.set_ylim(zoom_coords[1])\n```\n\n----------------------------------------\n\nTITLE: Shortest Path Lengths Between All Nodes (Python)\nDESCRIPTION: This code computes all-pairs shortest path lengths and the average shortest path length for the network using NetworkX. Inputs are the undirected graph `uG`. The functions return a nested dictionary of shortest paths and a scalar average; both are useful for assessing network efficiency and redundancy.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/resilience.rst#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\n>>> shortest_path_length = nx.shortest_path_length(uG)\n>>> ave_shortest_path_length = nx.average_shortest_path_length(uG)\n```\n\n----------------------------------------\n\nTITLE: Calculating Annual GHG Emissions using wntr in Python\nDESCRIPTION: This snippet shows how to compute the annual greenhouse gas emissions associated with pipes in a water network using the `wntr.metrics.annual_ghg_emissions` function. It requires a `wntr` water network model object (`wn`) as input and returns the calculated emissions. The calculation is based on equations from the Battle of Water Networks II.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/resilience.rst#_snippet_25\n\nLANGUAGE: python\nCODE:\n```\n>>> network_ghg = wntr.metrics.annual_ghg_emissions(wn)\n```\n\n----------------------------------------\n\nTITLE: Plotting Pipes with Landslide Intersections by Count - Python\nDESCRIPTION: This snippet visualizes the count of landslide scenarios intersecting each pipe on a network map, highlighting those with n > 0. Requires DataFrames with intersect statistics and matplotlib for plotting. Outputs a thematic map showing risk-exposed infrastructure.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/landslide_tutorial.ipynb#_snippet_24\n\nLANGUAGE: python\nCODE:\n```\n# Plot intersection results\nax = wn_gis.pipes.plot(color='gray', linewidth=1, zorder=1)\nwn_gis.pipes[wn_gis.pipes['n'] > 0].plot(column='n', vmax=20, legend=True, ax=ax)\ntmp = ax.set_title('Number of landslide scenarios that intersect each pipe')\ntmp = ax.axis('off')\n# Comment/uncomment the following 2 lines to change the zoom on the network graphic\ntmp = ax.set_xlim(zoom_coords[0])\ntmp = ax.set_ylim(zoom_coords[1])\n```\n\n----------------------------------------\n\nTITLE: Loading a WNTR Model using Pickle (Python)\nDESCRIPTION: This snippet shows how to load a previously saved WNTR water network model from a pickle file ('wn.pickle'). It opens the file in binary read mode, uses `pickle.load()` to deserialize the object back into the `wn` variable, and closes the file. This restores the exact state of the model as it was when saved, which is useful for restarting simulations or ensuring a clean state before a simulation run, especially if modifications were made.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/hydraulics.rst#_snippet_12\n\nLANGUAGE: python\nCODE:\n```\n>>> f=open('wn.pickle','rb')\n>>> wn = pickle.load(f)\n>>> f.close()\n>>> sim = wntr.sim.WNTRSimulator(wn)\n>>> results = sim.run_sim()\n```\n\n----------------------------------------\n\nTITLE: Adding Pattern Interpolation Option in WNTRSimulator (Python)\nDESCRIPTION: Introduces the `wn.options.time.pattern_interpolation` option for the WNTRSimulator. Enabling this boolean option allows pattern values (like demands) to be interpolated between pattern timesteps, potentially improving solver stability for problems with large pattern changes when using shorter hydraulic timesteps. The default behavior mimics EPANET's step-wise pattern application.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/whatsnew/v0.4.0.rst#_snippet_5\n\nLANGUAGE: Python\nCODE:\n```\nwn.options.time.pattern_interpolation\n```\n\n----------------------------------------\n\nTITLE: Converting Node Coordinates to Longitude/Latitude with WNTR in Python\nDESCRIPTION: This snippet demonstrates converting node coordinates of a water network model to longitude and latitude using WNTR. A dictionary maps two nodes to their known longitude/latitude pairs, which enables the conversion for the rest of the nodes. Dependencies: wntr (and the optional utm Python package if not installed). Inputs: the source model and a mapping of node identifiers to (longitude, latitude) coordinates. Output is a new WaterNetworkModel with longitude/latitude coordinates. At least two well-spaced reference nodes are required for accuracy.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/morph.rst#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\n>>> longlat_map = {'Lake':(-106.6587, 35.0623), '219': (-106.5248, 35.1918)}\n>>> wn_longlat = wntr.morph.convert_node_coordinates_to_longlat(wn, longlat_map)\n```\n\n----------------------------------------\n\nTITLE: Accessing Individual GeoDataFrames within WaterNetworkGIS Object in Python\nDESCRIPTION: Demonstrates how to access individual GeoDataFrames (e.g., `wn_gis.junctions`, `wn_gis.pipes`) stored as attributes within a `WaterNetworkGIS` object (`wn_gis`). Requires WNTR, GeoPandas, and an existing `WaterNetworkGIS` object. All lines are marked with `# doctest: +SKIP`, indicating they are examples and not executed tests. The snippet is skipped if GeoPandas (`gpd`) is not installed.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/model_io.rst#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\n>>> wn_gis.junctions # doctest: +SKIP\n>>> wn_gis.tanks # doctest: +SKIP\n>>> wn_gis.reservoirs # doctest: +SKIP\n>>> wn_gis.pipes # doctest: +SKIP\n>>> wn_gis.pumps # doctest: +SKIP\n>>> wn_gis.valves # doctest: +SKIP\n```\n\n----------------------------------------\n\nTITLE: Initializing WNTR Environment and Defining a Simple Valve Layer in Python\nDESCRIPTION: This hidden doctest snippet imports necessary libraries (wntr, numpy, pandas, matplotlib.pylab), loads a water network model ('Net3.inp') using `wntr.network.model.WaterNetworkModel`, sets a random seed for reproducibility, and creates a basic valve layer using a pandas DataFrame. It defines a single valve located on 'Pipe 1' protecting 'Junction A'. This setup prepares the environment for subsequent valve layer operations.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/layers.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n>>> import wntr\n>>> import numpy as np\n>>> import pandas as pd\n>>> import matplotlib.pylab as plt\n>>> try:\n...    wn = wntr.network.model.WaterNetworkModel('../examples/networks/Net3.inp')\n... except:\n...    wn = wntr.network.model.WaterNetworkModel('examples/networks/Net3.inp')\n>>> np.random.seed(123)\n>>> valve_layer = pd.DataFrame(columns=['link', 'node'])\n>>> valve_layer.loc[0] = ['Pipe 1', 'Junction A']\n```\n\n----------------------------------------\n\nTITLE: Verifying AED and Pressure Differences with Assertions in Python\nDESCRIPTION: Prints the previously calculated average absolute differences in AED (`aed_diff2`) and pressure (`pressure_diff2`). Uses `assert` statements to check if these differences are below specified tolerance levels (1e-5 for AED, 0.05 for pressure), validating the similarity between the results of networks `wn0` and `wn2`. Requires `aed_diff2` and `pressure_diff2` variables to be defined.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/model_development_tutorial.ipynb#_snippet_40\n\nLANGUAGE: python\nCODE:\n```\n# Check that demand and pressure difference between networks is small (but higher error than wn0/wn1 comparison)\nprint(f\"Average absolute difference in average expected demand: {aed_diff2}\")\nprint(f\"Average absolute difference in pressure: {pressure_diff2}\")\nassert (aed_diff2 < 1e-5), \"Average expected demand difference is greater that tolerance\"\nassert (pressure_diff2 < 0.05), \"Pressure difference is greater that tolerance\"\n```\n\n----------------------------------------\n\nTITLE: Removing Link and Node Elements from WNTR Model\nDESCRIPTION: This snippet demonstrates how to remove elements from a `WaterNetworkModel`. It first removes the link (pipe) named 'new_pipe' and then removes the node (junction) named 'new_junction'. Elements can only be removed if no other elements depend on them.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/waternetworkmodel.rst#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n>>> wn.remove_link('new_pipe')\n>>> wn.remove_node('new_junction')\n```\n\n----------------------------------------\n\nTITLE: Plotting Pressure Difference Percentiles over Time using Matplotlib in Python\nDESCRIPTION: This snippet visualizes the calculated pressure difference percentiles over the simulation duration using Matplotlib. It plots the median pressure difference (`m50`) as a line and shades the area between the 25th (`m25`) and 75th (`m75`) percentiles using `ax.fill_between` to represent the interquartile range. The x-axis is labeled as 'Time (hr)'. This provides a visual summary of the impact of skeletonization on pressure results.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/morph.rst#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n>>> fig = plt.figure()\n>>> ax = m50.plot()\n>>> poly = ax.fill_between(m25.index, m25, m75, color='b', alpha=0.2)\n>>> text = ax.set_xlabel('Time (hr)')\n```\n\n----------------------------------------\n\nTITLE: Saving a WNTR Model using Pickle (Python)\nDESCRIPTION: This snippet demonstrates how to save the current state of a WNTR water network model (`wn`) to a binary file ('wn.pickle') using Python's `pickle` module. This process, called serialization, allows the entire model object, including its current state and any modifications, to be stored persistently. After saving, it proceeds to run a simulation using the in-memory `wn` object.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/hydraulics.rst#_snippet_11\n\nLANGUAGE: python\nCODE:\n```\n>>> import pickle\n\t   \n>>> f=open('wn.pickle','wb')\n>>> pickle.dump(wn,f)\n>>> f.close()\n>>> sim = wntr.sim.WNTRSimulator(wn)\n>>> results = sim.run_sim()\n```\n\n----------------------------------------\n\nTITLE: Viewing WNTR Hydraulic Options as a Dictionary in Python\nDESCRIPTION: Shows how to view the options within a specific category (hydraulic options in this case) by converting the corresponding options object (`wn.options.hydraulic`) into a Python dictionary using the `dict()` constructor and printing it.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/options.rst#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n>>> print(dict(wn.options.hydraulic)) # doctest: +SKIP\n```\n\n----------------------------------------\n\nTITLE: Calculating Link Density (Python)\nDESCRIPTION: This snippet uses NetworkX to calculate link density in a given graph. Requires the NetworkX library and a graph object `G`. The function returns a scalar value representing the edge-to-node ratio, which quantifies how densely the network is connected.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/resilience.rst#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n>>> link_density = nx.density(G)\n```\n\n----------------------------------------\n\nTITLE: Importing WNTR Package in Python\nDESCRIPTION: This snippet demonstrates how to import the WNTR package into a Python script or interactive session. Importing WNTR is a prerequisite for building, simulating, or analyzing water network models. There are no arguments; ensure that the package is properly installed in your Python environment. This operation provides access to all WNTR functions and classes for subsequent modeling tasks.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/getting_started.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport wntr\n```\n\n----------------------------------------\n\nTITLE: Plotting Buffered Landslide Scenarios, Original Landslides, and Pipes\nDESCRIPTION: Generates a plot showing three layers: the buffered landslide scenario areas (semi-transparent gray), the original landslide data (red), and the water network pipes (black). This visualization helps understand the spatial relationship between the original landslide locations, the defined impact zones (buffers), and the infrastructure. Title, axis removal, and zoom are applied.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/landslide_tutorial.ipynb#_snippet_17\n\nLANGUAGE: python\nCODE:\n```\n# Plot the landslide data, region included in each landslide scenario, and pipes\nax = landslide_scenarios.plot(color='gray', alpha=0.5)\nax = landslide_data.plot(color='red', label='Landslide data', ax=ax)\nax = wn_gis.pipes.plot(color='black', linewidth=1, ax=ax)\nax.set_title('Landslide scenario and pipe data')\ntmp = ax.axis('off')\n# Comment/uncomment the following 2 lines to change the zoom on the network graphic\ntmp = ax.set_xlim(zoom_coords[0])\ntmp = ax.set_ylim(zoom_coords[1])\n```\n\n----------------------------------------\n\nTITLE: Computing Earthquake Properties for Water Network Pipes with WNTR in Python\nDESCRIPTION: This example computes earthquake-related properties for network pipes, including peak ground acceleration (PGA), peak ground velocity (PGV), and repair rates, using the WNTR scenario.Earthquake class. Dependencies include wntr and an initialized WaterNetworkModel. The snippet sets up the earthquake parameters (epicenter, magnitude, depth), uses the model to calculate distances to each pipe, and applies attenuation and repair rate models. Outputs are dictionaries or arrays containing computed values for each pipe, supporting downstream disaster impact analysis.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/disaster_models.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n>>> epicenter = (32000,15000) # x,y location\\n>>> magnitude = 6.5 # Richter scale\\n>>> depth = 10000 # m, shallow depth\\n>>> earthquake = wntr.scenario.Earthquake(epicenter, magnitude, depth)\\n>>> distance = earthquake.distance_to_epicenter(wn, element_type=wntr.network.Pipe)\\n>>> pga = earthquake.pga_attenuation_model(distance)  \\n>>> pgv = earthquake.pgv_attenuation_model(distance)\\n>>> repair_rate = earthquake.repair_rate_model(pgv) \n```\n\n----------------------------------------\n\nTITLE: Calculating Diameter and Eccentricity (Python)\nDESCRIPTION: This example calculates network diameter and eccentricity using NetworkX on an undirected graph. It requires the undirected graph `uG` and the NetworkX library. Outputs include the diameter (longest shortest path) and the eccentricity mapping (node-wise maximum shortest path length), useful for characterizing network reachability.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/resilience.rst#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n>>> diameter = nx.diameter(uG)\n>>> eccentricity = nx.eccentricity(uG)\n```\n\n----------------------------------------\n\nTITLE: Plotting Selected Hydrant Locations on the Network Map in Python\nDESCRIPTION: This snippet visualizes the randomly selected hydrant locations on the water network map. It uses `wntr.graphics.plot_network`, highlighting the nodes specified in the `hydrant_nodes` list.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/salt_water_intrusion_tutorial.ipynb#_snippet_18\n\nLANGUAGE: python\nCODE:\n```\nwntr.graphics.plot_network(wn, node_attribute=hydrant_nodes)\n```\n\n----------------------------------------\n\nTITLE: Querying Node Attributes with Filtering\nDESCRIPTION: This snippet demonstrates querying node attributes using `query_node_attribute`. It first imports the NumPy library. Then, it retrieves the 'elevation' attribute for all nodes in the model and stores the result (a Pandas Series) in the `node_elevation` variable.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/waternetworkmodel.rst#_snippet_20\n\nLANGUAGE: python\nCODE:\n```\n>>> import numpy as np\n    \n>>> node_elevation = wn.query_node_attribute('elevation')\n```\n\n----------------------------------------\n\nTITLE: Identifying Impacted Junctions Based on WSA Threshold in Python\nDESCRIPTION: This snippet processes a pandas DataFrame named `wsa_results`, where columns represent different scenarios and rows represent junctions with their corresponding Water Service Availability (WSA). It iterates through each scenario, identifies junctions where the WSA value is less than 0.5 by filtering the DataFrame, and stores the index (junction names) of these impacted junctions in a dictionary `impacted_junctions`, keyed by the scenario name. Requires the `pandas` library and an existing `wsa_results` DataFrame.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/landslide_tutorial.ipynb#_snippet_41\n\nLANGUAGE: python\nCODE:\n```\n# Extract junctions that are impacted by WSA < 0.5 for each scenario\nimpacted_junctions = {}\nfor scenario in wsa_results.columns:\n    filter = wsa_results[scenario] < 0.5\n    impacted_junctions[scenario] = wsa_results.index[filter]\n\nimpacted_junctions\n```\n\n----------------------------------------\n\nTITLE: Converting WaterNetworkModel to Dictionary Representation in Python\nDESCRIPTION: Converts a `WaterNetworkModel` object (`wn`) into a Python dictionary representation using `wntr.network.to_dict`. The resulting dictionary (`wn_dict`) organizes network components (nodes, links, etc.) and their attributes. The example demonstrates accessing the first link's data, though this specific print output is skipped in doctests.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/model_io.rst#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n>>> wn_dict = wntr.network.to_dict(wn)\n>>> wn_dict['links'][0] # doctest: +SKIP\n{'name': '20', 'link_type': 'Pipe', 'start_node_name': '3', 'end_node_name': '20', ...\n```\n\n----------------------------------------\n\nTITLE: Checking Network Connectivity with NetworkX and WNTR - Python\nDESCRIPTION: Creates a minimal WNTR water network model from recently constructed pipes and junctions, converts it to a NetworkX graph, and tests whether the undirected graph is fully connected. Establishes integrity of topology prior to modeling; dependencies include `wntr`, `networkx`, and the processed GIS GeoDataFrames. Outputs boolean connectivity status and number of connected components.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/model_development_tutorial.ipynb#_snippet_22\n\nLANGUAGE: python\nCODE:\n```\ngis_data = wntr.gis.WaterNetworkGIS({\\\"junctions\\\": junctions,\\n                                     \\\"pipes\\\": pipes})\\nwn2_temp = wntr.network.from_gis(gis_data)\\nG = wn2_temp.to_graph()\\n\\nuG = G.to_undirected()\\nprint(nx.is_connected(uG))\\nprint(nx.number_connected_components(uG))\\n\\nassert nx.is_connected(uG)\n```\n\n----------------------------------------\n\nTITLE: Plotting Average Salt Density Over Time for Baseline Simulation in Python\nDESCRIPTION: This snippet plots the average salt water density (concentration) across all nodes over the simulation time for the baseline scenario. It calculates the mean of `baseline_quality` at each timestep and plots it. It also highlights the storm duration (`storm_start` to `storm_end`) using `axvspan`.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/salt_water_intrusion_tutorial.ipynb#_snippet_15\n\nLANGUAGE: python\nCODE:\n```\nfig, ax = plt.subplots()\nbaseline_quality.mean(axis=1).plot(ax=ax, label=\"Average salt density\")\nax.axvspan(storm_start, storm_end, color='grey', alpha=0.5, label=\"Storm Duration\")\nax.legend()\nax.set_xlabel(\"Seconds\")\nax.set_ylabel(\"Salt water density (kg/m^3)\")\n```\n\n----------------------------------------\n\nTITLE: Setting Simulation Duration for WaterNetworkModel - Python\nDESCRIPTION: Updates the duration of a simulation to 4 days (in seconds), and prints the modified time options. Ensures that simulations run over the desired period; time units are in seconds.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/basics_tutorial.ipynb#_snippet_51\n\nLANGUAGE: python\nCODE:\n```\n# Change the simulation duration to 4 days\\nwn.options.time.duration = 4*24*3600 # seconds\\nprint(wn.options.time)\n```\n\n----------------------------------------\n\nTITLE: Retrieving a Species from MSX Model by Name in WNTR - Python\nDESCRIPTION: Accesses a species previously added to the MSX model via the reaction_system dictionary using its name key. Returns the matching Species object for further configuration or inspection. Requires: species with specified name must exist in the model.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/advancedsim.rst#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\n>>> PB2 = msx.reaction_system['PB2']\n>>> PB2\nSpecies(name='PB2', species_type='BULK', units='ug', atol=None, rtol=None, note='dissolved lead (Pb)')\n```\n\n----------------------------------------\n\nTITLE: Querying Link Attributes in WNTR (Python)\nDESCRIPTION: Shows how to query attributes of links (like pipes) in a WNTR water network model (`wn`). This example retrieves the 'length' attribute for links where the length is less than 50, using the `numpy.less` comparison function. Requires the `wntr` and `numpy` libraries.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/waternetworkmodel.rst#_snippet_22\n\nLANGUAGE: python\nCODE:\n```\n>>> link_length = wn.query_link_attribute('length', np.less, 50)\n```\n\n----------------------------------------\n\nTITLE: Defining Fire Flow Simulation Parameters in Python\nDESCRIPTION: Defines key parameters for the fire flow simulation. This includes the start time of the fire event within the simulation period, the duration of the fire, the total simulation duration, the magnitude of the fire demand (in consistent units, e.g., m^3/s if using SI), the minimum pressure threshold below which nodes receive no water in PDD, the required pressure threshold for full demand satisfaction in PDD, and the minimum and maximum pipe diameters used to identify potential hydrant locations.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/fire_flow_tutorial.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n# Define simulation parameters \nstart_time = 2*3600 # 2 hours\nfire_duration = 4*3600 # 4 hours\ntotal_duration = start_time + fire_duration\n\nfire_demand = 0.5047 # 8000 GPM\n\nminimum_pressure = 3.52 # 5 psi\nrequired_pressure = 14.06 # 20 psi\n\nmin_pipe_diam = 0.1524 # 6 inch\nmax_pipe_diam = 0.2032 # 8 inch\n```\n\n----------------------------------------\n\nTITLE: Introducing FunctionCondition for Custom Controls in WNTR (Python)\nDESCRIPTION: Adds a new `FunctionCondition` class for defining control logic. This class allows activating a control based on the boolean return value of a user-provided function. It is used internally for valve connection checks and enables users to implement complex, custom control conditions.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/whatsnew/v0.4.0.rst#_snippet_4\n\nLANGUAGE: Python\nCODE:\n```\nFunctionCondition\n```\n\n----------------------------------------\n\nTITLE: Reading Demographic Data from GeoJSON with GeoPandas - Python\nDESCRIPTION: Loads census block group demographic data as a GeoDataFrame. Used for socioeconomic attribute mapping and intersection analyses with network nodes or service areas. Requires geopandas and a valid file path. Outputs sample entries for inspection.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/basics_tutorial.ipynb#_snippet_91\n\nLANGUAGE: python\nCODE:\n```\n# Load demographic data associated with census block groups\\ndemographic_data = gpd.read_file('data/Net1_demographic_data.geojson') \\ndemographic_data.head()\n```\n\n----------------------------------------\n\nTITLE: Examining Junction Attributes in a GeoDataFrame - Python\nDESCRIPTION: This snippet prints the first few rows of the junctions GeoDataFrame to show available attributes such as base demand, elevation, and geometry. It demonstrates how model attributes are mapped into a GeoDataFrame for analysis or visualization. Input: none beyond existing wn_gis object; Output: DataFrame display. Dependency: wntr, geopandas.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/gis.rst#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n>>> print(wn_gis.junctions.head())\n```\n\n----------------------------------------\n\nTITLE: Setting Up Water Network Model and Earthquake Parameters in WNTR (Python)\nDESCRIPTION: Loads a water network model from an EPANET INP file using WNTR. Optionally scales the network node coordinates. Defines key parameters for the earthquake scenario, including the epicenter coordinates, magnitude, depth, total simulation duration, minimum and required pressures for pressure-driven demand analysis, and the start and end times for leaks and repairs.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/earthquake_tutorial.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n# Identify file path to inp file\ninp_file = \"networks/Net3.inp\"\n\n# Create water network model \nwn = wntr.network.WaterNetworkModel(inp_file)\n\n# Morph network coordinates, this is optional\nwn = wntr.morph.scale_node_coordinates(wn, 1000) \n\n# Define simulation parameters \nepicenter = (32000,15000) # m (x,y)\nmagnitude = 6.5 # Richter magnitude\ndepth = 10000 # m\n\ntotal_duration = 24*3600 # 24 hours\n\nminimum_pressure = 3.52 # 5 psi\nrequired_pressure = 14.06 # 20 psi\n\nleak_start_time = 5*3600 # 5 hours\nleak_repair_time =  15*3600 # 15 hours\n```\n\n----------------------------------------\n\nTITLE: Modifying Control Priority in WaterNetworkModel using Python\nDESCRIPTION: Illustrates retrieving a specific control ('control 5') by name using `wn.get_control()`, changing its priority level from 3 (medium) to 1 (low) with the `update_priority()` method, and displaying the control definition before and after the modification. Assumes `wn` is a WaterNetworkModel instance containing a control named 'control 5'.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/controls.rst#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\n>>> control = wn.get_control('control 5')\n>>> print(control)\nIF SYSTEM TIME IS 49:00:00 THEN PUMP 10 STATUS IS OPEN PRIORITY 3\n>>> control.update_priority(1) # low\n>>> print(control)\nIF SYSTEM TIME IS 49:00:00 THEN PUMP 10 STATUS IS OPEN PRIORITY 1\n```\n\n----------------------------------------\n\nTITLE: Assigning Demographic Data to Pipes using WNTR GIS Intersect (Python)\nDESCRIPTION: This snippet overlays the mean_income demographic attribute onto water pipes using wntr.gis.intersect and summarizes the intersection results, including weighted means. It requires demographic and pipe GeoDataFrames and outputs a DataFrame with statistics for each pipe. Dependencies are WNTR and GeoPandas.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/gis.rst#_snippet_32\n\nLANGUAGE: python\nCODE:\n```\n>>> pipe_demographics = wntr.gis.intersect(wn_gis.pipes, demographic_data, 'mean_income')\n>>> print(pipe_demographics)\n    intersections              values  n       sum      min      max     mean  weighted_mean\n10            [0]           [63326.0]  1   63326.0  63326.0  63326.0  63326.0      63326.000\n11         [0, 5]  [63326.0, 57620.0]  2  120946.0  57620.0  63326.0  60473.0      61002.920\n12            [5]           [57620.0]  1   57620.0  57620.0  57620.0  57620.0      57620.000\n21            [3]           [54040.0]  1   54040.0  54040.0  54040.0  54040.0      54040.000\n22         [3, 6]  [54040.0, 44871.0]  2   98911.0  44871.0  54040.0  49455.5      47067.895\n31            [2]           [91452.0]  1   91452.0  91452.0  91452.0  91452.0      91452.000\n110        [5, 7]  [57620.0, 69067.0]  2  126687.0  57620.0  69067.0  63343.5      60580.117\n111        [0, 3]  [63326.0, 54040.0]  2  117366.0  54040.0  63326.0  58683.0      60953.558\n112        [3, 5]  [54040.0, 57620.0]  2  111660.0  54040.0  57620.0  55830.0      56596.728\n113        [5, 6]  [57620.0, 44871.0]  2  102491.0  44871.0  57620.0  51245.5      53707.370\n121        [2, 3]  [91452.0, 54040.0]  2  145492.0  54040.0  91452.0  72746.0      73586.482\n122        [2, 3]  [91452.0, 54040.0]  2  145492.0  54040.0  91452.0  72746.0      66314.037\n```\n\n----------------------------------------\n\nTITLE: Plotting Census Tract and Network Intersections using WNTR & Matplotlib (Python)\nDESCRIPTION: This snippet visualizes the intersected census tracts, junctions, and pipes, coloring census polygons, network nodes, and links by mean and weighted mean demographic attributes. Dependencies are GeoPandas, Matplotlib, and WNTR. Key parameters include attribute column names and color scale ranges for tracts, junctions, and pipes.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/gis.rst#_snippet_33\n\nLANGUAGE: python\nCODE:\n```\n>>> ax = demographic_data.plot(column='mean_income', alpha=0.5,  \n...     cmap='bone', vmin=10000, vmax=100000)\n>>> ax = wntr.graphics.plot_network(wn, node_attribute=junction_demographics['mean'], \n...     link_attribute=pipe_demographics['weighted_mean'], link_width=1.5,\n...     node_range=[40000,80000], link_range=[40000,80000], ax=ax)\n```\n\n----------------------------------------\n\nTITLE: Plotting Locations of Downselected Landslide Scenarios - Python\nDESCRIPTION: Plots the spatial locations of the selected landslide scenarios in blue, overlaying pipes in gray, using GIS-enabled DataFrames and matplotlib. Input data includes a downselected set of scenarios and the GIS pipe network. Output is a map for scenario visualization.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/landslide_tutorial.ipynb#_snippet_30\n\nLANGUAGE: python\nCODE:\n```\n# Plot the location of landslides used in the analysis\nax = landslide_scenarios_downselect.plot(color='blue')\nwn_gis.pipes.plot(color='gray', linewidth=1, ax=ax)\ntmp = ax.set_title('Landslide scenarios')\ntmp = ax.axis('off')\n```\n\n----------------------------------------\n\nTITLE: Generating Valve Layer and Network Segments using WNTR in Python\nDESCRIPTION: Generates a 'strategic' valve layer using `wntr.network.generate_valve_layer`, placing a specified number (`n=2`) of valves strategically. It converts the network model to a graph representation and then uses the `wntr.metrics.valve_segments` function along with the generated valve layer to partition the network's nodes and links into distinct segments. The sizes of these segments are also returned.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/pipe_segments_tutorial.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n# Generate valve layer\nvalve_layer = wntr.network.generate_valve_layer(wn, placement_type='strategic',n=2, seed=123)\nG = wn.to_graph()\n\n# Assign network junctions and links to a segment\nnode_segments, link_segments, seg_sizes = wntr.metrics.valve_segments(G, valve_layer)\n```\n\n----------------------------------------\n\nTITLE: Constructing WaterNetworkModel for Valve Segmentation - Python\nDESCRIPTION: Loads a WaterNetworkModel from EPANET INP, setting up the context for subsequent segmentation based on valve data. This basic setup facilitates network-wide valve grouping operations.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/basics_tutorial.ipynb#_snippet_82\n\nLANGUAGE: python\nCODE:\n```\n# Create a WaterNetworkModel from an EPANET INP file\\nwn = wntr.network.WaterNetworkModel('networks/Net3.inp')\n```\n\n----------------------------------------\n\nTITLE: Accessing Junction Demands in WNTR (Python)\nDESCRIPTION: Retrieves the demand timeseries list for a selected junction ('15'), enabling inspection and later modification of its demand categories or patterns.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/basics_tutorial.ipynb#_snippet_23\n\nLANGUAGE: python\nCODE:\n```\n# Get the demands on Junction 15\\njunction = wn.get_node('15')\\njunction.demand_timeseries_list\n```\n\n----------------------------------------\n\nTITLE: Reading Hydrant Data from GeoJSON Using GeoPandas - Python\nDESCRIPTION: Reads hydrant geospatial data from a GeoJSON file, checks the coordinate reference system, and shows sample entries. Dependencies: geopandas as gpd. Outputs are printed to console. Commonly used as external point data for spatial snapping or overlays.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/basics_tutorial.ipynb#_snippet_88\n\nLANGUAGE: python\nCODE:\n```\n# Load hydrant data\\nhydrant_data = gpd.read_file('data/Net1_hydrant_data.geojson') \\nprint(hydrant_data.crs)\\nhydrant_data.head()\n```\n\n----------------------------------------\n\nTITLE: Visualizing WNTR Valve Layer on Network Map in Python\nDESCRIPTION: Uses the `wntr.graphics.plot_valve_layer` function to create a visualization of the generated valve layer overlaid on the water network map. The `add_colorbar=False` argument prevents a colorbar from being displayed, and `include_network=True` ensures the underlying network is drawn.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/pipe_segments_tutorial.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n# Graph valve layer\nwntr.graphics.plot_valve_layer(wn, valve_layer, add_colorbar=False, include_network=True)\n```\n\n----------------------------------------\n\nTITLE: Sampling Raster Elevations for Tanks using WNTR in Python\nDESCRIPTION: This snippet shows how to sample elevation data for network tanks from a GeoTIFF raster file using `wntr.gis.sample_raster`. It requires an existing WNTR GIS object `wn_gis` with tank data and the `geopandas` and `rasterio` libraries. The result is a pandas Series mapping tank names to their sampled elevation values.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/gis.rst#_snippet_37\n\nLANGUAGE: python\nCODE:\n```\n>>> tanks = wn_gis.tanks\n>>> tank_elevations = wntr.gis.sample_raster(tanks, elevation_data_path)\n>>> print(tank_elevations)\nname\n2    4500.0\ndtype: float64\n```\n\n----------------------------------------\n\nTITLE: Plotting WSA Maps for Each Landslide Scenario - Python\nDESCRIPTION: Generates a grid of network maps, each showing the spatial distribution of WSA for a particular landslide scenario. Uses matplotlib subplots, color maps, and GIS DataFrames. Outputs a figure array illustrating the geographic variability and severity of service disruption for scenario comparison.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/landslide_tutorial.ipynb#_snippet_40\n\nLANGUAGE: python\nCODE:\n```\n# Plot WSA for each scenario\nfig, axes = plt.subplots(2,3, figsize=(15,10))\naxes = axes.flatten()\n\nfor i, scenario in enumerate(wsa_results.columns):\n    wn_gis.pipes.plot(color='gray', linewidth=1, ax=axes[i]) # pipes\n    wn_gis.junctions.plot(column=scenario, cmap='RdYlGn', vmin=0, vmax=1, legend=True, ax=axes[i]) # junction wsa\n    tmp = axes[i].set_title('WSA '+scenario)\n    tmp = axes[i].axis('off')\n    if i >= 6: # axes is defined to have 6 subplots\n        break\n```\n\n----------------------------------------\n\nTITLE: Building a WaterNetworkModel from EPANET INP for Fragility Curve Analysis - Python\nDESCRIPTION: Repeatedly creates a WaterNetworkModel from EPANET INP file as a starting point for network-based fragility analysis. This is identical to the earlier snippet but now provides context for fragility curve workflows. Dependencies: wntr. Output: initialized WaterNetworkModel.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/basics_tutorial.ipynb#_snippet_72\n\nLANGUAGE: python\nCODE:\n```\n# Create a WaterNetworkModel from an EPANET INP file\\nwn = wntr.network.WaterNetworkModel('networks/Net3.inp')\n```\n\n----------------------------------------\n\nTITLE: Filtering Pipe Diameters Greater Than 12 Inches in WNTR (Python)\nDESCRIPTION: Filters and counts pipes with diameters over 12 inches (converted to meters) using numpy operators. Provides both total and filtered pipe counts for diagnostic purposes.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/basics_tutorial.ipynb#_snippet_32\n\nLANGUAGE: python\nCODE:\n```\n# Return pipes diameters > 12 inches\\nlarge_pipe_diameters = wn.query_link_attribute('diameter', np.greater, 12*0.0254)\\nprint(\"Number of pipes:\", len(all_pipe_diameters))\\nprint(\"Number of pipes > 12 inches:\", len(large_pipe_diameters))\n```\n\n----------------------------------------\n\nTITLE: Plotting Storm Surge Raster Data using Rasterio and Matplotlib in Python\nDESCRIPTION: This snippet visualizes the processed storm surge raster data (`inundation_raster`) using `rasterio.plot.show` and `matplotlib`. It displays the raster on a figure, applies the correct spatial transformation (`raster_transform`), and adds a color bar to indicate the surge depth values.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/salt_water_intrusion_tutorial.ipynb#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nfig, ax = plt.subplots(figsize=(10,10))\nimshow = show(inundation_raster, transform=raster_transform, ax=ax, zorder=5)\nim = imshow.get_images()[0]\nfig.colorbar(im, ax=ax, shrink=0.5)\n```\n\n----------------------------------------\n\nTITLE: Testing Pipe Break Simulation Results Against Expected Data in Python\nDESCRIPTION: Includes code for testing the accuracy of the pipe break simulation results. It imports the Pandas library, loads expected results for impacted junctions and population from CSV files, converts them to dictionaries, and uses `assert` statements to compare the calculated results (`num_junctions_impacted`, `num_people_impacted`) against the expected test data. This section is optional for the core analysis.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/pipe_break_tutorial.ipynb#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nimport pandas as pd\n\n# Test simulation results\n# Import expected results\njunct_test = pd.read_csv('../wntr/tests/data_for_testing/pipe_break_demo_junction_test_data.csv', index_col=0).squeeze('columns').to_dict()\njunct_test = {str(key): value for key, value in junct_test.items()}\n\npeople_test = pd.read_csv('../wntr/tests/data_for_testing/pipe_break_demo_people_test_data.csv', index_col=0).squeeze('columns').to_dict()\npeople_test = {str(key): value for key, value in people_test.items()}\n\n# Check if simulation results match expected results\nassert num_junctions_impacted == junct_test, \"impacted junction results differ\"\nassert num_people_impacted == people_test, \"impacted people results differ\"\n```\n\n----------------------------------------\n\nTITLE: Simulating Hydraulic Impacts Under Landslide Scenarios - Python\nDESCRIPTION: Runs a hydraulic simulation for each selected landslide scenario, closing all pipes that intersect the given landslide for a fixed duration. Depends on WNTR, model setup function, and intersection data per scenario. Outputs a dictionary of simulation results per landslide scenario.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/landslide_tutorial.ipynb#_snippet_31\n\nLANGUAGE: python\nCODE:\n```\n# Run a hydraulic simulation for each landslide scenario, store results in a dictionary\n# Each scenario closes all pipes that intersect the landslide for the 48 hour simulation\nresults = {}\nfor i, scenario in landslide_scenarios_downselect.iterrows():\n    wn = model_setup(inp_file)\n    for pipe_i in scenario['intersections']:\n        pipe_object = wn.get_link(pipe_i)\n        pipe_object.initial_status = 'CLOSED'\n    sim = wntr.sim.EpanetSimulator(wn)\n    results[i] = sim.run_sim()\n```\n\n----------------------------------------\n\nTITLE: Selecting Pipes Stochastically using NumPy in Python\nDESCRIPTION: This snippet demonstrates stochastic selection of water pipes based on their failure probabilities using NumPy's random.choice method. The code assumes the availability of the NumPy library and sets up lists representing pipe names and their associated failure probabilities. The number of pipes (N) to select is specified, and selection is done without replacement. The input consists of pipe names and a probability distribution; the output is a list of selected pipe names that reflect the failure likelihoods. Ensure that probabilities sum to 1, and that all required pipes are specified in the probability list.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/advancedsim.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n>>> import numpy as np # doctest: +SKIP\\n\\n>>> pipe_names = ['pipe1', 'pipe2', 'pipe3', 'pipe4']\\n>>> failure_probability = [0.10, 0.20, 0.30, 0.40]\\n>>> N = 2\\n>>> selected_pipes = list(np.random.choice(pipe_names, N, replace=False, \\n...     p=failure_probability))\\n>>> print(selected_pipes) # doctest: +SKIP\\n['pipe2', 'pipe3']\n```\n\n----------------------------------------\n\nTITLE: Assigning Sampled Elevations to Tanks in WNTR Model in Python\nDESCRIPTION: This snippet iterates through all tanks in a WNTR `WaterNetworkModel` object (`wn`) and sets their `elevation` attribute based on previously sampled elevation data from the `tank_elevations` Series. Requires `geopandas` and `rasterio` for prior sampling.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/gis.rst#_snippet_39\n\nLANGUAGE: python\nCODE:\n```\n>>> for tank_name in wn.tank_name_list:\n...     tank = wn.get_node(tank_name)\n...     tank.elevation = tank_elevations[tank_name]\n```\n\n----------------------------------------\n\nTITLE: Accessing and Inspecting Pipe Objects in WNTR (Python)\nDESCRIPTION: Retrieves a pipe object ('105') from the water network and prints the object's type. Facilitates further property inspection and manipulation.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/basics_tutorial.ipynb#_snippet_15\n\nLANGUAGE: python\nCODE:\n```\n# Get a pipe object\\npipe = wn.get_link('105')\\nprint(type(pipe))\\npipe\n```\n\n----------------------------------------\n\nTITLE: Comparing Base Model and Imperfect Model Attributes - Python\nDESCRIPTION: Prints attribute summaries for both the base (wn0) and imperfect (wn2) water network models for comparative diagnostics. This final step provides quick overview statistics on network composition and performance, bypassing node-level alignment. Requires both wn0 and wn2 models constructed and available.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/model_development_tutorial.ipynb#_snippet_37\n\nLANGUAGE: python\nCODE:\n```\nprint(f\\\"Base network attributes: {wn0.describe()}\\\")\\nprint(f\\\"Imperfect network attributes: {wn2.describe()}\\\")\n```\n\n----------------------------------------\n\nTITLE: Plotting Network Nodes Colored by Storm Surge Inundation Level in Python\nDESCRIPTION: This snippet creates a combined plot showing the storm surge raster data and the water network. The storm surge data (`inundation_raster`) is plotted with transparency. The network junctions are overlaid and colored based on their associated 'inundation_level' (obtained from the previous step), using a 'viridis' colormap via `wntr.graphics.plot_network`.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/salt_water_intrusion_tutorial.ipynb#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nfig, ax = plt.subplots(figsize=(10,10))\n\n# plot storm surge data\nim = show(inundation_raster, transform=raster_transform, \n          vmin=np.nanmin(inundation_raster), vmax=np.nanmax(inundation_raster), \n          ax=ax, alpha=0.5)\n\n# plot junctions with associated inundation level\nax = wntr.graphics.plot_network(wn, node_attribute=junctions[\"inundation_level\"], node_cmap=\"viridis\", ax=ax)\n```\n\n----------------------------------------\n\nTITLE: Initializing WNTR Earthquake Object and Calculating Seismic Impacts (Python)\nDESCRIPTION: Initializes a WNTR `Earthquake` object using the defined epicenter, magnitude, and depth. It then calculates the distance of each pipe to the epicenter, estimates Peak Ground Acceleration (PGA) and Peak Ground Velocity (PGV) at each pipe using attenuation models, and computes the Repair Rate (RR) based on PGV. Pipe lengths are queried, and a `FragilityCurve` object is created and configured with 'Minor Leak' and 'Major Leak' states, using exponential distributions based on repair rate to define damage probabilities.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/earthquake_tutorial.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n# Initializes earthquake object\nearthquake = wntr.scenario.Earthquake(epicenter, magnitude, depth) \n\n# Calculates PGA, PGV, and RR\nR = earthquake.distance_to_epicenter(wn, element_type=wntr.network.Pipe)\npga = earthquake.pga_attenuation_model(R)  \npgv = earthquake.pgv_attenuation_model(R)\nRR = earthquake.repair_rate_model(pgv)\n\n# Queries pipe lengths for all pipes in the network\nL = pd.Series(wn.query_link_attribute('length', link_type = wntr.network.Pipe))\n\n# Generates fragility curve\npipe_FC = wntr.scenario.FragilityCurve()\npipe_FC.add_state('Minor Leak', 1, {'Default': expon(scale=0.2)})\npipe_FC.add_state('Major Leak', 2, {'Default': expon()})\n```\n\n----------------------------------------\n\nTITLE: Reading and Displaying EPANET-MSX File Content in Python\nDESCRIPTION: Opens the previously saved 'Net3.msx' file in read mode ('r'), reads its entire content using `fin.read()`, and prints the content to the standard output. This demonstrates reading the text-based EPANET-MSX file format directly.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/multispecies_tutorial.ipynb#_snippet_12\n\nLANGUAGE: python\nCODE:\n```\nwith open(\"Net3.msx\", \"r\") as fin:\n    print(fin.read())\n```\n\n----------------------------------------\n\nTITLE: Creating Rule with OrCondition and Multiple Actions in Python\nDESCRIPTION: Illustrates defining a control rule using `controls.OrCondition` where if either `cond1` or `cond2` is true, multiple actions (`act1`, `act2`) are triggered simultaneously.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/controls.rst#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n>>> cond4 = controls.OrCondition(cond1, cond2)\n>>> rule4 = controls.Rule(cond4, [act1, act2], name='rule4')\n>>> print(rule4)\nIF  TANK 1 LEVEL ABOVE 46.0248 OR SYSTEM TIME >= 121:00:00  THEN PIPE 330 STATUS IS OPEN AND PUMP 10 STATUS IS OPEN PRIORITY 3\n```\n\n----------------------------------------\n\nTITLE: Extracting Pressure Difference Percentiles in Python\nDESCRIPTION: This snippet calculates the 25th, 50th (median), and 75th percentiles of the pressure difference across all common junctions for each time step. It uses the `.quantile()` method on the `pressure_diff` DataFrame (calculated in the previous step), specifying the quantile (0.25, 0.50, 0.75) and `axis=1` to compute percentiles across columns (junctions) for each row (time step). The results are stored in `m25`, `m50`, and `m75` Series.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/morph.rst#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n>>> m25 = pressure_diff.quantile(0.25, axis=1)\n>>> m50 = pressure_diff.quantile(0.50, axis=1)\n>>> m75 = pressure_diff.quantile(0.75, axis=1)\n```\n\n----------------------------------------\n\nTITLE: Simulating Hydraulics on Original and Skeletonized Networks using WNTR/EPANET in Python\nDESCRIPTION: This snippet demonstrates how to simulate hydraulic behavior for both the original (`wn`) and skeletonized (`skel_wn`) water network models. It initializes the EPANET simulator using `wntr.sim.EpanetSimulator` for each network model and runs the simulation using the `run_sim()` method. The results (including pressures, flows, etc., over time) are stored in `results_original` and `results_skel` respectively. This requires the WNTR library and a functional EPANET engine.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/morph.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n>>> sim = wntr.sim.EpanetSimulator(wn)\n>>> results_original = sim.run_sim()\n\n>>> sim = wntr.sim.EpanetSimulator(skel_wn)\n>>> results_skel = sim.run_sim()\n```\n\n----------------------------------------\n\nTITLE: Setting Coordinate Reference System (CRS) for WNTR GIS Data (Python)\nDESCRIPTION: Assigns a Coordinate Reference System (CRS) to the collection of GeoDataFrames (`wn_gis`) previously created from the WNTR model. It uses the `wn_gis.set_crs()` method with the EPSG code 'EPSG:3089', which corresponds to NAD83 / Kentucky Single Zone (ftUS), ensuring the spatial data is properly referenced.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/landslide_tutorial.ipynb#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\n# Set the CRS to EPSG:3089 (NAD83 / Kentucky Single Zone (ftUS))\ncrs = 'EPSG:3089'\nwn_gis.set_crs(crs)\n```\n\n----------------------------------------\n\nTITLE: Estimating Population Served by a WNTR Model (Python)\nDESCRIPTION: Estimates the population served by the water network using `wntr.metrics.population(wn)`. This function typically uses demand data and a default average per capita consumption rate (200 gallons/day) unless specified otherwise. It calculates the total estimated population by summing the population associated with each node and prints the result.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/landslide_tutorial.ipynb#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n# Estimate population using the default average volume of water consumed per capita per day of 200 gallons/day\npopulation = wntr.metrics.population(wn) \ntotal_population = population.sum()\nprint('Total population =', total_population)\n```\n\n----------------------------------------\n\nTITLE: Estimating Salt Water Intrusion Flow Rate based on Inundation Level in Python\nDESCRIPTION: This snippet estimates the salt water intrusion flow rate at each junction. It assumes the flow rate is proportional to the inundation level, applying a scaling factor of -0.0001 (m^3/s per unit inundation level). The negative sign indicates inflow (demand). The resulting flow rates are stored in the `salt_water_flowrate` Series, and its head is printed.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/salt_water_intrusion_tutorial.ipynb#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nsalt_water_flowrate = junctions[\"inundation_level\"].copy()\nsalt_water_flowrate[:] = - 0.0001 * salt_water_flowrate[:] # m3/s\nprint(salt_water_flowrate.head())\n```\n\n----------------------------------------\n\nTITLE: Snapping Hydrant Points to Network Junctions using WNTR (Python)\nDESCRIPTION: This snippet demonstrates the use of the wntr.gis.snap function to associate hydrant point data with network junctions within a specified tolerance. The code operates on GeoDataFrames containing spatial point data and outputs a DataFrame indicating nearest nodes and snap distances. Requires WNTR, GeoPandas, and associated network model instances; the main parameters are the source and target spatial features and a tolerance threshold. Input hydrant and junction GeoDataFrames are required; output includes nearest associations and geometric projections.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/gis.rst#_snippet_22\n\nLANGUAGE: python\nCODE:\n```\n>>> snapped_to_hydrants = wntr.gis.snap(wn_gis.junctions, hydrant_data, tolerance=100.0)\n>>> print(snapped_to_hydrants)\n    node  snap_distance           geometry\n10     2         31.219  POINT (51.2 71.1)\n11     2         21.229  POINT (51.2 71.1)\n12     2          1.628  POINT (51.2 71.1)\n13     1          2.476  POINT (71.8 68.3)\n21     0         18.414  POINT (48.2 37.2)\n22     0          3.329  POINT (48.2 37.2)\n23     0         21.979  POINT (48.2 37.2)\n31     0         32.727  POINT (48.2 37.2)\n32     0         27.259  POINT (48.2 37.2)\n```\n\n----------------------------------------\n\nTITLE: Plotting Landslide Data and Water Pipes using Geopandas/Matplotlib\nDESCRIPTION: Visualizes the loaded landslide areas (red polygons) overlaid with the water network pipes (black lines) using `geopandas` plotting capabilities integrated with `matplotlib`. It sets a title for the plot, turns off the axis labels, and applies the predefined `zoom_coords` to focus on the region of interest.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/landslide_tutorial.ipynb#_snippet_14\n\nLANGUAGE: python\nCODE:\n```\n# Plot the landslide data along with pipes\nax = landslide_data.plot(color='red', label='Landslide data')\nax = wn_gis.pipes.plot(color='black', linewidth=1, ax=ax)\nax.set_title('Landslide and pipe data')\ntmp = ax.axis('off')\n# Comment/uncomment the following 2 lines to change the zoom on the network graphic\ntmp = ax.set_xlim(zoom_coords[0])\ntmp = ax.set_ylim(zoom_coords[1])\n```\n\n----------------------------------------\n\nTITLE: Transforming Coordinate Reference System (CRS) with GeoPandas in Python\nDESCRIPTION: This snippet shows how to read a GeoJSON file and transform its Coordinate Reference System (CRS) using the `to_crs` method in GeoPandas. The transformation is done in-place, modifying the coordinates within the 'geometry' column to match the target CRS ('EPSG:3857'). It prints the CRS and the GeoDataFrame content after the transformation.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/gis.rst#_snippet_14\n\nLANGUAGE: python\nCODE:\n```\n>>> hydrant_data = gpd.read_file('data/Net1_hydrant_data.geojson') # doctest: +SKIP\n\t\n>>> hydrant_data.to_crs('EPSG:3857', inplace=True)\n>>> print(hydrant_data.crs) # doctest: +SKIP\nEPSG:3857\n>>> print(hydrant_data)\n   demand                          geometry\n0    5000   POINT (5365599.456 4467020.994)\n1    1500  POINT (7992739.439 10536729.551)\n2    8000  POINT (5699557.929 11436551.505)\n```\n\n----------------------------------------\n\nTITLE: Adding Custom 'material' Attribute to Pipe Objects\nDESCRIPTION: This snippet demonstrates how to add a custom attribute to existing WNTR element objects. It iterates through all pipes in the `wn` model using `wn.pipes()` and assigns the corresponding material value from the previously created `material` Pandas Series to a new attribute named `material` on each `pipe` object.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/waternetworkmodel.rst#_snippet_15\n\nLANGUAGE: python\nCODE:\n```\n>>> for name, pipe in wn.pipes():\n...     pipe.material = material[name]\n```\n\n----------------------------------------\n\nTITLE: Plotting Comparison of Baseline and Flushing Response Salt Density in Python\nDESCRIPTION: This snippet generates a plot comparing the average salt water density over time for the baseline simulation (`baseline_quality`) and the simulation with hydrant flushing (`response_quality`). It plots both time series on the same axes and uses `axvspan` to indicate the durations of the storm and the hydrant flushing periods.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/salt_water_intrusion_tutorial.ipynb#_snippet_21\n\nLANGUAGE: python\nCODE:\n```\nfig, ax = plt.subplots()\nbaseline_quality.mean(axis=1).plot(ax=ax, label=\"Baseline average salt density\")\nresponse_quality.mean(axis=1).plot(ax=ax, label=\"Response average salt density\")\nax.axvspan(storm_start, storm_end, color='grey', alpha=0.5, label=\"Storm Duration\")\nax.axvspan(hydrant_start, hydrant_end, color='blue', alpha=0.5, label=\"Hydrant Duration\")\nax.legend()\nax.set_xlabel(\"Time (s)\")\nax.set_ylabel(\"Salt water density (kg/m^3)\")\n```\n\n----------------------------------------\n\nTITLE: Selecting Landslide Scenarios for Demonstration - Python\nDESCRIPTION: This snippet demonstrates several options for downselecting a small, representative set of landslide scenarios from a larger DataFrame. Allows for fixed, top-ranked, or random selection. Outputs a reduced DataFrame suitable for scenario comparison studies.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/landslide_tutorial.ipynb#_snippet_29\n\nLANGUAGE: python\nCODE:\n```\n# Further downselect the landslide scenarios for demonstration purposes. Choose one of the following 4 options.\n# Option 1. 6 scenarios that illustrate a wide range of impact\nlandslide_scenarios_downselect = landslide_scenarios.loc[['LS-4495', 'LS-7003', 'LS-7111', 'LS-5086', 'LS-6966', 'LS-7058'],:] \n\n# Option 2. 6 scenarios with the highest intersecting pipe length\n#landslide_scenarios_downselect = landslide_scenarios.sort_values('total pipe length', ascending=False).iloc[0:6,:]\n\n# Option 3. 6 scenarios with the highest number of intersecting pipes\n#landslide_scenarios_downselect = landslide_scenarios.sort_values('n', ascending=False).iloc[0:6,:]\n\n# Option 4. Random selection of 6 scenarios\n#landslide_scenarios_downselect = landslide_scenarios.sample(n=6, random_state=1234)\n\nlandslide_scenarios_downselect\n```\n\n----------------------------------------\n\nTITLE: Converting Controls to Rules in WNTR Water Networks (Python)\nDESCRIPTION: This snippet calls the 'convert_controls_to_rules' method on the network model to transform existing controls into rules. This step is crucial when mixing controls and rules to avoid simulation inconsistencies.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/basics_tutorial.ipynb#_snippet_30\n\nLANGUAGE: python\nCODE:\n```\n# Convert controls to rules.  This can help avoid unintended behavior when controls and rules are both used in complex simulations.\\nwn.convert_controls_to_rules()\n```\n\n----------------------------------------\n\nTITLE: Accessing Library-Format MSX Model from WNTR Library (Python)\nDESCRIPTION: Retrieves the MSX model named 'multisource-cl' (loaded from the 'multisource-cl.json' file saved with `as_library=True`) from the `MsxLibrary` object using `get_model()`. It accesses and implicitly prints the `initial_quality` attribute within `network_data`, showing that it's empty, as expected for a model saved in the library format which strips network-specific data.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/multispecies_tutorial.ipynb#_snippet_16\n\nLANGUAGE: python\nCODE:\n```\nmy_library.get_model(\"multisource-cl\").network_data.initial_quality\n```\n\n----------------------------------------\n\nTITLE: Loading Clipped Landslide GeoJSON Data using Geopandas\nDESCRIPTION: Loads the pre-processed landslide geospatial data from the specified GeoJSON file (`data/ky10_landslide_data.geojson`) into a `geopandas` GeoDataFrame named `landslide_data`. It also sets the DataFrame index using the 'index' column from the file, prints the Coordinate Reference System (CRS) to verify it (expected EPSG:3089), and displays the first few rows using `.head()`.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/landslide_tutorial.ipynb#_snippet_13\n\nLANGUAGE: python\nCODE:\n```\n# Load the landslide data from file and print the CRS to ensure it is in EPSG:3089.  \n# The methods `to_crs` and `set_crs` can be used to change coordinate reference systems if needed.\nlandslide_file = 'data/ky10_landslide_data.geojson'\nlandslide_data = gpd.read_file(landslide_file).set_index('index') \nprint(landslide_data.crs)\n\nlandslide_data.head()\n```\n\n----------------------------------------\n\nTITLE: Checking Acceptable Error Tolerances Between Models - Python\nDESCRIPTION: Verifies that node-level differences in average expected demand and pressure are below a 1e-3 threshold, asserting that perfect and base models are functionally equivalent. Throws errors if tolerances are exceeded. Output: printed mean differences and raised assertions if constraint violated.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/model_development_tutorial.ipynb#_snippet_15\n\nLANGUAGE: python\nCODE:\n```\n# Check that demand and pressure difference between networks is small (< 1e-3)\\nprint(f\"Average absolute difference in average expected demand: {aed_diff1.mean()}\")\\nprint(f\"Average absolute difference in pressure: {pressure_diff1.mean()}\")\\nassert (aed_diff1.mean() < 1e-3), \"Average expected demand difference is greater that tolerance\"\\nassert (pressure_diff1.mean() < 1e-3), \"Pressure difference is greater that tolerance\"\\n\n```\n\n----------------------------------------\n\nTITLE: Disabling Water Quality Simulation - WNTR - Python\nDESCRIPTION: This code disables water quality simulation by setting the quality parameter to 'NONE'. Use when only hydraulic results are needed. Requires a valid WaterNetworkModel instance. Outputs from simulations will omit water quality.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/waterquality.rst#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n>>> wn.options.quality.parameter = 'NONE'\n```\n\n----------------------------------------\n\nTITLE: Saving WNTR MSX Model in Multiple Formats (Python)\nDESCRIPTION: Saves the configured MSX model (`wn.msx`) into three different file formats using `wntr.msx.io` functions. It saves in the standard EPANET-MSX text format ('Net3.msx') using `write_msxfile`, a WNTR-specific JSON format including network data ('Net3-msx.json') using `write_json`, and a library-ready JSON format excluding network-specific data ('multisource-cl.json') using `write_json` with `as_library=True`.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/multispecies_tutorial.ipynb#_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nmsxio.write_msxfile(wn.msx, \"Net3.msx\")\nmsxio.write_json(wn.msx, \"Net3-msx.json\")\nmsxio.write_json(wn.msx, \"multisource-cl.json\", as_library=True)\n```\n\n----------------------------------------\n\nTITLE: Buffering Landslide Polygons for Scenario Analysis using Geopandas\nDESCRIPTION: Creates a new GeoDataFrame `landslide_scenarios` intended for scenario analysis. It starts by copying the original `landslide_data`. Then, it replaces the 'geometry' column with buffered versions of the original landslide polygons, expanding each by 1000 feet using the `.buffer(1000)` method. The buffer distance unit (feet) matches the CRS (EPSG:3089).\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/landslide_tutorial.ipynb#_snippet_15\n\nLANGUAGE: python\nCODE:\n```\n# Create a GeoDataFrame to hold information used in landslide scenarios (initially copied from landslide_data)\n# Buffer each landslide polygon by 1000 ft\nlandslide_scenarios = landslide_data.copy()\nlandslide_scenarios['geometry'] = landslide_data.buffer(1000)\n```\n\n----------------------------------------\n\nTITLE: Plotting a Pump Performance Curve Using WNTR - Python\nDESCRIPTION: Retrieves a pump by link ID from the water network model, then plots its performance curve (e.g., head vs. flow) using WNTR's graphics interface. Requires the wn object (water network model) and WNTR installed. Input is a pump link ID ('10'); output is the Matplotlib axis with the pump curve plot.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/graphics.rst#_snippet_12\n\nLANGUAGE: python\nCODE:\n```\n>>> pump = wn.get_link('10')\n>>> ax = wntr.graphics.plot_pump_curve(pump)\n```\n\n----------------------------------------\n\nTITLE: Accessing Network-Specific MSX Model from WNTR Library (Python)\nDESCRIPTION: Retrieves the MSX model named 'Net3' (which was loaded by the `MsxLibrary` from the 'Net3.msx' file in the current directory) using the `get_model()` method. It then accesses and implicitly prints the `initial_quality` dictionary within the model's `network_data`, demonstrating that network-specific information is retained when loading from a standard .msx or non-library .json file via the library.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/multispecies_tutorial.ipynb#_snippet_15\n\nLANGUAGE: python\nCODE:\n```\nmy_library.get_model(\"Net3\").network_data.initial_quality\n```\n\n----------------------------------------\n\nTITLE: Renaming Columns in Geopandas DataFrame to WNTR GIS Standard - Python\nDESCRIPTION: Renames nonstandard columns (like 'cv') to expected attribute names ('check_valve') to comply with WNTR's GeoJSON input requirements. Ensures correct mapping from file attributes to model features. Appropriate before passing DataFrames to model-building code.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/model_development_tutorial.ipynb#_snippet_19\n\nLANGUAGE: python\nCODE:\n```\ndisconnected_pipes.rename(columns={'cv':'check_valve'}, inplace=True)\\n\n```\n\n----------------------------------------\n\nTITLE: Loading Storm Surge Raster Data using Rasterio in Python\nDESCRIPTION: This snippet loads a specific window of storm surge data from a GeoTIFF file (`raster_path`) using the `rasterio` library. It first determines the bounding box (`min_lon`, `min_lat`, `max_lon`, `max_lat`) from the network's junction coordinates (`wn_gis.junctions`). It then opens the raster file and reads only the data within this window, also extracting the corresponding transform and CRS.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/salt_water_intrusion_tutorial.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nraster_path = join(\"data\", \"coastal_ky4_storm_surge.tif\")\n\nmin_lon, min_lat, max_lon, max_lat = wn_gis.junctions.total_bounds\n\nwith rs.open(raster_path) as src:\n    window = rs.windows.from_bounds(min_lon, min_lat, max_lon, max_lat, src.transform)\n    inundation_raster = src.read(1, window=window)\n    raster_transform = src.window_transform(window)\n    raster_crs = src.crs\n```\n\n----------------------------------------\n\nTITLE: Visualizing Large Pipe Diameters in Water Network (Python)\nDESCRIPTION: Plots pipes with diameters greater than 12 inches, using a specialized link_attribute argument to mark them visually on the network layout. Output highlights major transmission lines in the distribution system.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/basics_tutorial.ipynb#_snippet_33\n\nLANGUAGE: python\nCODE:\n```\n# Plot pipes diameters > 12 inches\\nax = wntr.graphics.plot_network(wn, link_attribute=large_pipe_diameters, node_size=0, link_width=2, title=\"Pipes with diameter > 12 inches\")\n```\n\n----------------------------------------\n\nTITLE: Printing WaterNetworkModel Simulation Options - Python\nDESCRIPTION: Accesses and prints the simulation options for a WaterNetworkModel, displaying configuration such as time, hydraulics, and reporting. Useful for reviewing or debugging simulation settings prior to running a simulation.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/basics_tutorial.ipynb#_snippet_50\n\nLANGUAGE: python\nCODE:\n```\n# Print the WaterNetworkModel options\\nwn.options\n```\n\n----------------------------------------\n\nTITLE: Setting Coordinate Reference System (CRS) with GeoPandas in Python\nDESCRIPTION: This snippet demonstrates reading a GeoJSON file into a GeoPandas GeoDataFrame and then overriding its Coordinate Reference System (CRS) using the `set_crs` method. It prints the CRS and the GeoDataFrame content before and after setting the new CRS to 'EPSG:3857'. Note that `set_crs` with `allow_override=True` only changes the CRS metadata, not the actual coordinate values.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/gis.rst#_snippet_12\n\nLANGUAGE: python\nCODE:\n```\n>>> import geopandas as gpd\n\t\n>>> hydrant_data = gpd.read_file('data/Net1_hydrant_data.geojson') # doctest: +SKIP\n>>> print(hydrant_data.crs) # doctest: +SKIP\nEPSG:4326\n>>> print(hydrant_data)\n   demand           geometry\n0    5000  POINT (48.2 37.2)\n1    1500  POINT (71.8 68.3)\n2    8000  POINT (51.2 71.1)\n\t\n>>> hydrant_data = hydrant_data.set_crs('EPSG:3857', allow_override=True)\n>>> print(hydrant_data.crs) # doctest: +SKIP\nEPSG:3857 \n>>> print(hydrant_data)\n   demand           geometry\n0    5000  POINT (48.2 37.2)\n1    1500  POINT (71.8 68.3)\n2    8000  POINT (51.2 71.1)\n```\n\n----------------------------------------\n\nTITLE: Loading and Comparing Network-Specific vs. Library MSX JSON Files in Python\nDESCRIPTION: Loads the two previously saved WNTR MSX JSON files ('Net3-msx.json' and 'multisource-cl.json') using the standard `json` library. It then uses `pprint` to display the `network_data` section from both loaded dictionaries. This comparison highlights that the standard JSON includes network-specific initial quality data, while the library version (saved with `as_library=True`) has an empty `network_data` dictionary.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/multispecies_tutorial.ipynb#_snippet_13\n\nLANGUAGE: python\nCODE:\n```\nwith_net: dict = None\nwithout_net: dict = None\n\nwith open(\"Net3-msx.json\", \"r\") as fin:\n    with_net = json.load(fin)\nwith open(\"multisource-cl.json\", \"r\") as fin:\n    without_net = json.load(fin)\n\nprint(\"With network data:\")\npprint(with_net[\"network_data\"])\n\nprint(\"As a library:\")\npprint(without_net[\"network_data\"])\n```\n\n----------------------------------------\n\nTITLE: Modifying Valve Setting Attribute Handling in WNTR (Python)\nDESCRIPTION: Redefines the `setting` attribute for Valve components to represent the current simulation setting, making it read-only during simulation. The initial setting value for valves must now be explicitly set using the `initial_setting` attribute prior to simulation.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/whatsnew/v0.4.0.rst#_snippet_2\n\nLANGUAGE: Python\nCODE:\n```\nsetting\n```\n\nLANGUAGE: Python\nCODE:\n```\ninitial_setting\n```\n\n----------------------------------------\n\nTITLE: Visualizing Disconnected Pipes and Building Footprints - Python\nDESCRIPTION: Plots spatial distribution of disconnected pipes overlaid with building footprints to visually assess network topology relative to urban features. Sets plot zoom using earlier defined coordinates and provides legend; users are warned of any limitations (e.g., legend rendering for polygons).\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/model_development_tutorial.ipynb#_snippet_18\n\nLANGUAGE: python\nCODE:\n```\nfig, ax = plt.subplots(figsize=(12,5))\\ndisconnected_pipes.plot(color=\"b\", label='disconnected pipes', ax=ax)\\nbuildings.plot(label='buildings', ax=ax)\\nax.legend()\\ntmp = ax.set_xlim(zoom_coords[0])\\ntmp = ax.set_ylim(zoom_coords[1])\\n# Note that this plot creates a UserWarning regarding the legend, which will not show polygons.\\n# This is a known limitation of geopandas/matplotlib.\\n\n```\n\n----------------------------------------\n\nTITLE: Comparing WaterNetworkModel Attributes After Shapefile Import - Python\nDESCRIPTION: Prints top-level descriptions of the original model and one constructed from Shapefiles, highlighting missing attributes such as patterns and controls. Useful for validating data integrity after format conversion. Output is printed to the console.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/basics_tutorial.ipynb#_snippet_47\n\nLANGUAGE: python\nCODE:\n```\n# Compare model attributes of the original model with the model built from Shapefiles (note the absence of patterns and controls)\\nprint(wn.describe(level=1))\\nprint(wn2.describe(level=1))\n```\n\n----------------------------------------\n\nTITLE: Retrieving Complete Valid GeoJSON Column Names for WNTR Components in Python\nDESCRIPTION: Uses the `wntr.network.io.valid_gis_names` function without arguments (defaults to `complete_list=True`) to retrieve a dictionary (`geojson_column_names`). This dictionary maps component types (like 'junctions') to lists containing all valid column names expected or usable when reading GeoJSON files. Requires WNTR and GeoPandas. The snippet is skipped if GeoPandas (`gpd`) is not installed.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/model_io.rst#_snippet_12\n\nLANGUAGE: python\nCODE:\n```\n>>> geojson_column_names = wntr.network.io.valid_gis_names()\n>>> print(geojson_column_names['junctions'])\n['name', 'base_demand', 'demand_pattern', 'elevation', 'demand_category', 'geometry', 'emitter_coefficient', 'initial_quality', 'minimum_pressure', 'required_pressure', 'pressure_exponent', 'tag']\n```\n\n----------------------------------------\n\nTITLE: Saving the Fragility Curve Figure with Matplotlib in Python\nDESCRIPTION: This snippet finalizes and saves a matplotlib figure representing the fragility curve by adjusting layout, specifying file name, and closing the plot. It assumes you have previously generated a figure handle 'plt'. No inputs are required, and the output is an image file ('fragility_curve.png') saved to disk. This helps preserve visualizations for later review outside the code runtime environment.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/fragility.rst#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n>>> plt.tight_layout()\\n>>> plt.savefig('fragility_curve.png', dpi=300)\\n>>> plt.close()\n```\n\n----------------------------------------\n\nTITLE: Listing Node Results in Simulation Output - Python\nDESCRIPTION: Prints the available keys (parameter names) for node simulation results after an EPANET simulation. The keys correspond to available output variables such as pressure or demand.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/basics_tutorial.ipynb#_snippet_55\n\nLANGUAGE: python\nCODE:\n```\n# Print available node results\\nresults_EPANET.node.keys()\n```\n\n----------------------------------------\n\nTITLE: Specifying Raster Elevation Data Path for Analysis - Python\nDESCRIPTION: This snippet defines the file path for a raster elevation data file (TIF format), which is expected to be used in subsequent analysis or visualization. It checks for GeoPandas and rasterio dependencies before defining the path. No reading or manipulation is performed at this step; it simply sets up the variable for later use. Dependency: none required just to set path, but later operations may require rasterio.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/gis.rst#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n>>> elevation_data_path = examples_dir+'/data/Net1_elevation_data.tif'\n```\n\n----------------------------------------\n\nTITLE: Displaying a Defined WNTR Valve Layer DataFrame in Python\nDESCRIPTION: This snippet prints the contents of the `valve_layer` pandas DataFrame, which was defined in a preceding step. It shows the structure (index, 'link' column, 'node' column) and data of a simple valve layer, illustrating how valve locations (link and protected node) are stored.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/layers.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n>>> print(valve_layer)\n     link        node\n0  Pipe 1  Junction A\n```\n\n----------------------------------------\n\nTITLE: Getting Element Names, Counts, and Model Description\nDESCRIPTION: This snippet shows how to retrieve lists of element names and counts from the model. It accesses the `node_name_list` and `num_nodes` attributes. It also calls the `describe` method (output skipped by `doctest: +SKIP`) to get a summary count of different element types in the model.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/waternetworkmodel.rst#_snippet_19\n\nLANGUAGE: python\nCODE:\n```\n>>> node_names = wn.node_name_list\n>>> num_nodes = wn.num_nodes\n>>> wn.describe(level=0) # doctest: +SKIP\n{'Nodes': 97, 'Links': 119, 'Patterns': 5, 'Curves': 2, 'Sources': 0, 'Controls': 18}\n```\n\n----------------------------------------\n\nTITLE: Breaking Pipes and Preparing Pump Data for Model Integration with WNTR - Python\nDESCRIPTION: Breaks the pipe nearest to each pump and updates the pump dataframe to reflect new topology, determining flow direction based on shortest distance to reservoir. Involves editing the water network model and updating pump start/end nodes. Dependencies: WNTR, snapped pump data, pipes, and distance mapping from previous steps.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/model_development_tutorial.ipynb#_snippet_30\n\nLANGUAGE: python\nCODE:\n```\n# Break pipes and update the pumps dataframe\\npumps = disconnected_pumps.copy()\\nfor pump_name in disconnected_pumps.index:\\n    nearest_pipe = snap_pumps.loc[pump_name, 'link']\\n    pipe = wn2.get_link(nearest_pipe)\\n    # determine start and end node based on distance to the nearest reservoir\\n    distanceA = distance_to_reservoir[pipe.start_node_name]\\n    distanceB = distance_to_reservoir[pipe.end_node_name]\\n    start_node_name = pump_name+'A'\\n    end_node_name = pump_name+'B'\\n    if distanceA > distanceB:\\n        start_node_name = pump_name+'B'\\n        end_node_name = pump_name+'A'\\n    wn2 = wntr.morph.break_pipe(wn2, nearest_pipe, nearest_pipe+'_pump_connector', start_node_name, end_node_name)\\n    pumps['start_node_name'] = start_node_name\\n    pumps['end_node_name'] = end_node_name\n```\n\n----------------------------------------\n\nTITLE: Creating WaterNetworkModel from Dictionary Representation in Python\nDESCRIPTION: Creates a new `WaterNetworkModel` object (`wn2`) from a Python dictionary (`wn_dict`) using the `wntr.network.from_dict` function. This requires a dictionary structured according to WNTR's expectations, typically generated by `to_dict`. Dictionary representations are assumed to use SI units (m, kg, s).\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/model_io.rst#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n>>> wn2 = wntr.network.from_dict(wn_dict)\n```\n\n----------------------------------------\n\nTITLE: Generating and Plotting Valve Layers and Segments in WNTR - Python\nDESCRIPTION: This snippet generates a valve layer in the water network for strategic segmentation, computes node, link, and segment indices, creates a random color map for segment visualization, then plots the network with segments and overlays the valve layer. It uses wntr.network.generate_valve_layer, wn.to_graph, wntr.metrics.topographic.valve_segments, and multiple wntr.graphics utilities. Inputs include the network model (wn), layer type, valve count, and seed; outputs are Matplotlib axes showing segmentations and valve placement.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/graphics.rst#_snippet_14\n\nLANGUAGE: python\nCODE:\n```\n>>> valve_layer = wntr.network.generate_valve_layer(wn, 'strategic', 2, seed=123)\n>>> G = wn.to_graph()   \n>>> node_segments, link_segments, seg_sizes = wntr.metrics.topographic.valve_segments(G, \n...     valve_layer)\n>>> N = seg_sizes.shape[0] \n>>> cmap = wntr.graphics.random_colormap(N) # random color map helps view segments\n>>> ax = wntr.graphics.plot_network(wn, link_attribute=link_segments, node_size=0, \n...     link_width=2, node_range=[0,N], link_range=[0,N], node_cmap=cmap, \n...     link_cmap=cmap, link_colorbar_label='Segment ID')\n>>> ax = wntr.graphics.plot_valve_layer(wn, valve_layer, add_colorbar=False, \n...     include_network=False, ax=ax)\n```\n\n----------------------------------------\n\nTITLE: Computing Total Expected Demand Per Junction - Python\nDESCRIPTION: Aggregates expected demand over time for each junction, summing across the time axis. Builds on the calculated expected_demand DataFrame. Outputs are total expected demand per junction for later normalization.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/landslide_tutorial.ipynb#_snippet_33\n\nLANGUAGE: python\nCODE:\n```\n# Compute total expected demand at each junction (axis 0 is the time index)\nexpected_demand_j = expected_demand.sum(axis=0)\n\nexpected_demand_j\n```\n\n----------------------------------------\n\nTITLE: Accessing Specific WNTR Option Categories in Python\nDESCRIPTION: Demonstrates how to access individual categories of simulation options (Time, Hydraulic, Quality, Reaction, Energy, Report, Graphics, User) by accessing attributes of the main `wn.options` object.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/options.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n>>> wn.options.time  # doctest: +SKIP\n>>> wn.options.hydraulic  # doctest: +SKIP\n>>> wn.options.quality  # doctest: +SKIP\n>>> wn.options.reaction  # doctest: +SKIP\n>>> wn.options.energy  # doctest: +SKIP\n>>> wn.options.report  # doctest: +SKIP\n>>> wn.options.graphics  # doctest: +SKIP\n>>> wn.options.user  # doctest: +SKIP\n```\n\n----------------------------------------\n\nTITLE: Plotting Original, Disconnected, and Connected Pipe Data using Geopandas in Python\nDESCRIPTION: This snippet visualizes the results of the pipe connection process. It plots the disconnected pipes (red), the newly connected pipes (thick, semi-transparent black), and the generated junctions (black points) on the same Matplotlib axes (`ax`) using `geopandas` plotting methods. A legend is added to differentiate the datasets. Requires `geopandas` and `matplotlib`.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/gis.rst#_snippet_45\n\nLANGUAGE: python\nCODE:\n```\n>>> ax = disconnected_pipes.plot(ax=ax, color='r', label='Disconnected pipe data')\n>>> ax = pipes.plot(ax=ax, color='k', linewidth=6, alpha=0.35, label='Connected pipe data')\n>>> ax = junctions.plot(ax=ax, color='k', label='Connected junctions')\n>>> legend = ax.legend()\n```\n\n----------------------------------------\n\nTITLE: Solving Hydraulics with NewtonSolver in WNTR - Python\nDESCRIPTION: Illustrates basic usage of the NewtonSolver class from wntr.sim.solvers to solve a network's hydraulic equations with a specified tolerance. This snippet initializes the solver, solves a model, then rounds and prints the variables' solution values. Dependencies: wntr.sim.solvers, numpy. Parameters: `m` (model to solve). Returns a tuple for solver status and modifies model variables with solutions.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/advancedsim.rst#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n>>> from wntr.sim.solvers import NewtonSolver\n   \n>>> ns = NewtonSolver()\n>>> solver_status = ns.solve(m)\n>>> np.round(m.u.value,4)\n1.618\n>>> np.round(m.v.value,4)\n2.618\n```\n\n----------------------------------------\n\nTITLE: Importing Geospatial and Network Libraries for Water Distribution Modeling - Python\nDESCRIPTION: Imports essential libraries for geospatial data handling (geopandas, shapely), network computations (networkx), visualization (matplotlib), and the WNTR library for water networks. These imports are prerequisites for all subsequent code, ensuring that geospatial data can be processed, water networks constructed/analyzed, and results visualized. Dependencies: geopandas, networkx, shapely, matplotlib, wntr.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/model_development_tutorial.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n## Imports\\nimport geopandas as gpd\\nimport networkx as nx\\nfrom shapely import LineString\\nimport matplotlib.pylab as plt\\nimport wntr\\n\n```\n\n----------------------------------------\n\nTITLE: Modeling and Solving Nonlinear Equations with WNTR AML in Python\nDESCRIPTION: This series of snippets showcase the use of WNTR's custom Algebraic Modeling Language (AML) to formally define variables, constraints, and then solve nonlinear equations relevant to water network simulation. Requires WNTR's AML module, NumPy, and SciPy installed. The code initializes variables, defines constraints, sets model structure, and demonstrates evaluating residuals and Jacobians. Additionally, it leverages SciPy sparse linear solvers for updating variable values. Inputs are algebraic equations formulated as constraints; outputs include residual values and solution vectors. Iterative solving is suggested if residuals are not sufficiently small. Limitations include the need to properly initialize variables and models before evaluation or solution.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/advancedsim.rst#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n>>> from wntr.sim import aml\\n\\n>>> m = aml.Model()\\n>>> m.u = aml.Var(1.0)\\n>>> m.v = aml.Var(1.0)\\n>>> m.c1 = aml.Constraint(m.v - m.u**2)\\n>>> m.c2 = aml.Constraint(m.v - m.u - 1)\n```\n\nLANGUAGE: python\nCODE:\n```\n>>> m.set_structure()\n```\n\nLANGUAGE: python\nCODE:\n```\n>>> m.evaluate_residuals() # doctest: +SKIP\\narray([ 0., -1.])\\n>>> m.evaluate_jacobian() # doctest: +SKIP\\n<2x2 sparse matrix of type '<class 'numpy.float64'>'\\n\\twith 4 stored elements in Compressed Sparse Row format>\\n>>> m.evaluate_jacobian().toarray() # doctest: +SKIP\\narray([[-2.,  1.],\\n       [-1.,  1.]])\n```\n\nLANGUAGE: python\nCODE:\n```\n>>> from scipy.sparse.linalg import spsolve\\n\\n>>> var_values = m.get_x()\\n>>> x = spsolve(m.evaluate_jacobian(), -m.evaluate_residuals())\\n>>> var_values = var_values + x\\n>>> m.load_var_values_from_x(var_values)\\n>>> m.evaluate_residuals() # doctest: +SKIP\\narray([-1., 0.])\n```\n\n----------------------------------------\n\nTITLE: Exporting DataFrame to Excel File - pandas - Python\nDESCRIPTION: This snippet saves the pressure DataFrame to an Excel file named 'pressure.xlsx' using the pandas to_excel() method. Requires the openpyxl Python package (as a dependency) in addition to pandas. Input: a DataFrame to write and an output filename. Output: Excel file written to disk. Limitation: openpyxl must be installed for this functionality.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/resultsobject.rst#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\n>>> pressure.to_excel('pressure.xlsx')\n```\n\n----------------------------------------\n\nTITLE: Adding Prefix to Landslide Scenario Index in Geopandas DataFrame\nDESCRIPTION: Modifies the index of the `landslide_scenarios` GeoDataFrame. It adds the prefix 'LS-' to each existing index value (which were likely numeric IDs). This creates more descriptive index labels suitable for identifying individual landslide scenarios (e.g., 'LS-123').\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/landslide_tutorial.ipynb#_snippet_16\n\nLANGUAGE: python\nCODE:\n```\n# Add a prefix to the landslide scenario index to indicate the scenario name\nlandslide_scenarios.index = 'LS-' + landslide_scenarios.index.astype(str)\n```\n\n----------------------------------------\n\nTITLE: Querying Head Pump Names in WNTR Water Network (Python)\nDESCRIPTION: Prints the names of all head pumps present in the network model using 'head_pump_name_list'. Helps in identifying pumps used for head management.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/basics_tutorial.ipynb#_snippet_13\n\nLANGUAGE: python\nCODE:\n```\n# Print the names of just head pumps\\nprint(\"Head pump names\", wn.head_pump_name_list)\n```\n\n----------------------------------------\n\nTITLE: Querying valid Shapefile field names with WNTR in Python (complete and truncated)\nDESCRIPTION: These code snippets illustrate how to retrieve the list of valid Shapefile field names for water network junctions using WNTR's network.io.valid_gis_names function. The complete attribute set is obtained by default, while a minimal list is returned with complete_list=False. Attribute names are automatically truncated to 10 characters (for Shapefile compatibility). The function returns a dictionary keyed by network element types, and these field lists guide correct Shapefile creation/import. Requires WNTR and optional dependency GeoPandas for Shapefile support.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/model_io.rst#_snippet_17\n\nLANGUAGE: python\nCODE:\n```\nshapefile_field_names = wntr.network.io.valid_gis_names(truncate_names=10)\nprint(shapefile_field_names['junctions'])\n```\n\nLANGUAGE: python\nCODE:\n```\nshapefile_field_names = wntr.network.io.valid_gis_names(complete_list=False, \n   truncate_names=10)\nprint(shapefile_field_names['junctions'])\n```\n\n----------------------------------------\n\nTITLE: Plotting Hydrant-Junction Snap Results - Python\nDESCRIPTION: Plots raw hydrant locations and overlays network nodes, using snapped assignment attributes. Utilizes geopandas plot and wntr.graphics.plot_network for layered visualization. Outputs a plot showing spatial registration of hydrants to nearest nodes.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/basics_tutorial.ipynb#_snippet_90\n\nLANGUAGE: python\nCODE:\n```\n# Plot results\\nax = hydrant_data.plot()\\nax.set_aspect('equal', adjustable='box')\\nax = wntr.graphics.plot_network(wn, node_attribute=snapped_to_junctions['node'].to_list(), ax=ax)\n```\n\n----------------------------------------\n\nTITLE: Modifying Component Status Attribute Handling in WNTR (Python)\nDESCRIPTION: Redefines the `status` attribute for Pipe, Valve, and Pump components to represent the current simulation status, making it read-only during simulation. The initial status for these components must now be explicitly set using the `initial_status` attribute before running a simulation.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/whatsnew/v0.4.0.rst#_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\nstatus\n```\n\nLANGUAGE: Python\nCODE:\n```\ninitial_status\n```\n\n----------------------------------------\n\nTITLE: Referencing WNTR Node Coordinate Translation Method (Python)\nDESCRIPTION: References the `translate_node_coordinates` method in the `wntr.morph.node` module. This function translates the coordinates of all nodes in the network model by specified offsets in the x and y directions.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/whatsnew/v0.1.7.rst#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n~wntr.morph.node.translate_node_coordinates\n```\n\n----------------------------------------\n\nTITLE: Defining Simulation and Pressure Parameters in Python\nDESCRIPTION: Defines key parameters for the pipe break simulation scenario. This includes the simulation time when the break starts (`start_time`), the duration of the break (`break_duration`), the total simulation time (`total_duration`), and pressure thresholds (`minimum_pressure`, `required_pressure`) used for Pressure-Driven Demand (PDD) calculations.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/pipe_segments_tutorial.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n# Define simulation parameters \nstart_time = 2*3600 # 2 hours\nbreak_duration = 12*3600 # 12 hours\ntotal_duration = start_time + break_duration # 14 hours\n\nminimum_pressure = 3.52 # 5 psi\nrequired_pressure = 14.06 # 20 psi\n```\n\n----------------------------------------\n\nTITLE: Saving a WNTR Strategic Valve Layer Plot using Matplotlib in Python\nDESCRIPTION: This hidden doctest snippet adjusts the layout of the current matplotlib plot generated for the strategic valve layer using `plt.tight_layout()` for optimal spacing. It then saves the visualization to a file named 'strategic_valve_layer.png' with a resolution of 300 DPI using `plt.savefig()` and subsequently closes the plot window using `plt.close()` to manage resources.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/layers.rst#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n>>> plt.tight_layout()\n>>> plt.savefig('strategic_valve_layer.png', dpi=300)\n>>> plt.close()\n```\n\n----------------------------------------\n\nTITLE: Querying Node Names in Water Network Model (Python)\nDESCRIPTION: Prints the names of all junctions, tanks, and reservoirs in the model by accessing 'node_name_list'. The output provides a high-level overview of included network nodes.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/basics_tutorial.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n# Print the names of all junctions, tanks, and reservoirs\\nprint(\"Node names\", wn.node_name_list)\n```\n\n----------------------------------------\n\nTITLE: Selecting Top Leaking Pipes for Repair (Python)\nDESCRIPTION: Defines the number of pipes to be targeted for repair (`number_of_pipes_to_repair`). Selects the identifiers of the top leaking pipes/nodes from the previously sorted list (`leaked_sum`) based on this number. Prints the identifiers and their total leaked volumes.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/earthquake_tutorial.ipynb#_snippet_11\n\nLANGUAGE: python\nCODE:\n```\n# Select top pipes to fix\nnumber_of_pipes_to_repair = 4\npipes_to_fix = leaked_sum[0:number_of_pipes_to_repair]\nprint(pipes_to_fix)\n```\n\n----------------------------------------\n\nTITLE: Filtering Patterns by Category and Creating Category-specific Library in WNTR Python\nDESCRIPTION: This snippet filters the existing demand pattern library for patterns in the 'Commercial' category and initializes a new DemandPatternLibrary containing just these patterns. It then prints the list of pattern names in the filtered library. Dependencies are wntr and pandas. Inputs include the target category name.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/libraries.rst#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\n>>> commercial_patterns = demand_library.filter_by_category('Commercial')\n>>> commercial_demand_library = DemandPatternLibrary(commercial_patterns)\n>>> print(commercial_demand_library.pattern_name_list)\n['Micropolis_1', 'Micropolis_4', 'Micropolis_5']\n```\n\n----------------------------------------\n\nTITLE: Saving Demand Pattern Plot to Image File with Tight Layout in Matplotlib Python\nDESCRIPTION: This snippet uses matplotlib to adjust subplots and save the currently plotted demand patterns to a PNG file at high resolution. It assumes a plot already exists. The only dependency is matplotlib, and it does not require any parameters other than accessible plotted axes.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/libraries.rst#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n>>> plt.tight_layout()\n>>> plt.savefig('demand_library.png', dpi=300)\n```\n\n----------------------------------------\n\nTITLE: Calculating Absolute Differences in Node Metrics Between Models - Python\nDESCRIPTION: Computes absolute differences in average expected demand and node pressure between base model and GeoJSON-derived model. The outputs (aed_diff1, pressure_diff1) are Series for spatial error analysis and visualization. Inputs: metric values for two models.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/model_development_tutorial.ipynb#_snippet_13\n\nLANGUAGE: python\nCODE:\n```\n# Compute absolute difference in average expected demand and pressure\\naed_diff1 = (aed0 - aed1).abs()\\npressure_diff1 = (pressure0 - pressure1).abs()\\n\n```\n\n----------------------------------------\n\nTITLE: Listing Tank Properties and Methods (Python)\nDESCRIPTION: Lists all public properties and methods of the given tank object, excluding private ones. Useful for understanding available interactions and attributes.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/basics_tutorial.ipynb#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\n# List properties and methods associated with the tank (omitting private underscore names)\\n[name for name in dir(tank) if not name.startswith('_')]\n```\n\n----------------------------------------\n\nTITLE: Finalizing and Saving Matplotlib Plot in Python\nDESCRIPTION: This hidden snippet finalizes a Matplotlib plot generated previously (stored in `ax`). It sets equal aspect ratio for the axes, applies tight layout, saves the figure to a PNG file with specified DPI, and closes the plot window. Requires `matplotlib`.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/gis.rst#_snippet_41\n\nLANGUAGE: python\nCODE:\n```\n>>> bounds = ax.axis('equal')\n>>> plt.tight_layout()\n>>> plt.savefig('sample_elevations.png', dpi=300)\n>>> plt.close()\n```\n\n----------------------------------------\n\nTITLE: Importing Required Libraries in Python\nDESCRIPTION: This snippet imports necessary Python libraries for the tutorial: `os.path.join` for file path manipulation, `numpy` for numerical operations and array handling, `rasterio` and `rasterio.plot` for reading and visualizing raster data (storm surge), `matplotlib.pyplot` for plotting, and `wntr` for water network analysis.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/salt_water_intrusion_tutorial.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom os.path import join\nimport numpy as np\nimport rasterio as rs\nfrom rasterio.plot import show\nimport matplotlib.pyplot as plt\nimport wntr\n```\n\n----------------------------------------\n\nTITLE: Importing Libraries for WNTR Water Quality Modeling in Python\nDESCRIPTION: Imports required Python libraries for the WNTR multispecies water quality simulation tutorial. This includes `wntr` for network modeling and simulation, `matplotlib` for plotting, `pprint` for pretty printing, `json` for handling JSON data, and specific WNTR components for MSX modeling (`InitialQuality`, `MsxLibrary`, `msxio`).\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/multispecies_tutorial.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom pprint import pprint\nimport json\nimport matplotlib.pyplot as plt\n\nimport wntr\nfrom wntr.msx.elements import InitialQuality\nfrom wntr.library.msx import MsxLibrary\nfrom wntr.msx import io as msxio\n```\n\n----------------------------------------\n\nTITLE: Listing Link Results in Simulation Output - Python\nDESCRIPTION: Prints available keys for link output data in the simulation results, such as flowrate or velocity, facilitating exploration of the result structure.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/basics_tutorial.ipynb#_snippet_56\n\nLANGUAGE: python\nCODE:\n```\n# Print available link results\\nresults_EPANET.link.keys()\n```\n\n----------------------------------------\n\nTITLE: Testing Segment Break Analysis Results against Expected Data in Python\nDESCRIPTION: Performs data validation by comparing the calculated segment break impacts against pre-saved expected results. It imports the pandas library, loads expected junction and population impact data from CSV files into pandas Series, ensures the index data types match the calculated results, and then uses `assert` statements to verify that the calculated `num_junctions_impacted` and `num_people_impacted` Series are identical to the loaded test data. If discrepancies exist, an assertion error is raised.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/pipe_segments_tutorial.ipynb#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nimport pandas as pd\n\n# Test simulation results\n# Import expected results\njunct_test = pd.read_csv('../wntr/tests/data_for_testing/segment_break_demo_junction_test_data.csv', index_col = 0).squeeze('columns')\npeople_test = pd.read_csv('../wntr/tests/data_for_testing/segment_break_demo_people_test_data.csv', index_col = 0).squeeze('columns')\n\n# Check if simulation results match expected results\nnum_junctions_impacted.index = num_junctions_impacted.index.astype('int64')\nnum_people_impacted.index = num_people_impacted.index.astype('int64')\n\nassert (junct_test == num_junctions_impacted).all(axis=None) == True, \"impacted junction results differ\"\nassert (people_test == num_people_impacted).all(axis=None)  == True, \"impacted people results differ\"\n```\n\n----------------------------------------\n\nTITLE: Importing Required Python Libraries for WNTR Landslide Analysis\nDESCRIPTION: Imports necessary Python libraries for the tutorial. `geopandas` is used for handling geospatial data, `shapely.geometry.box` for defining geometric shapes (like the region of interest), `matplotlib.pylab` for plotting, and `wntr` for water network analysis.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/landslide_tutorial.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport geopandas as gpd\nfrom shapely.geometry import box\nimport matplotlib.pylab as plt\nimport wntr\n```\n\n----------------------------------------\n\nTITLE: Sorting Landslide Intersection Results by Pipe Length - Python\nDESCRIPTION: This snippet sorts the results of pipeline-landslide intersections by the total length of affected pipes, returning the highest values for analysis. Requires pandas DataFrame 'landslide_intersect' with a 'sum' column denoting pipe lengths. Inputs are intersection results, output is a sorted and truncated DataFrame for reporting or further analysis.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/landslide_tutorial.ipynb#_snippet_19\n\nLANGUAGE: python\nCODE:\n```\n# Print results in order of descending total pipe length\nlandslide_intersect.sort_values('sum', ascending=False).head()\n```\n\n----------------------------------------\n\nTITLE: Inspecting a Built-in WNTR MSX Library Model (Python)\nDESCRIPTION: Retrieves a built-in MSX model, 'arsenic_chloramine', from the initialized `MsxLibrary` object using `get_model()`. It then iterates through the `reaction_system`'s variables (species, constants, etc.) and reactions, printing the string representation (`repr`) of each element. This demonstrates how to explore the components of pre-defined models available in the WNTR library.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/multispecies_tutorial.ipynb#_snippet_17\n\nLANGUAGE: python\nCODE:\n```\narsenic = my_library.get_model(\"arsenic_chloramine\")\nfor key, value in arsenic.reaction_system.variables():\n    print(repr(value))\nfor key, value in arsenic.reaction_system.reactions():\n    print(repr(value))\n```\n\n----------------------------------------\n\nTITLE: Filtering and Downselecting Unique Landslide Scenarios - Python\nDESCRIPTION: This code filters out landslide scenarios with no intersecting pipes or with missing values, then reduces to only those impacting unique sets of pipes. Relies on DataFrame string conversion and .duplicated() methods. Inputs are GIS scenario DataFrames, output is a cleaned and reduced scenario set suitable for scenario-based simulations.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/landslide_tutorial.ipynb#_snippet_28\n\nLANGUAGE: python\nCODE:\n```\n# Remove scenarios with no intersecting pipes\nlandslide_scenarios = landslide_scenarios[landslide_scenarios['n'] > 0]\nlandslide_scenarios = landslide_scenarios[~landslide_scenarios['n'].isna()]\n\n# Downselect landslide scenarios that impact a unique set of pipes\nduplicated_intersections = landslide_scenarios['intersections'].astype(str).duplicated()\nlandslide_scenarios = landslide_scenarios.loc[~duplicated_intersections, :]\n\nprint('Number of unique landslide scenarios', landslide_scenarios.shape[0])\nlandslide_scenarios.head()\n```\n\n----------------------------------------\n\nTITLE: Running Python Example File Interactively - Python\nDESCRIPTION: This snippet shows how to execute a Python example script (such as getting_started.py) in interactive mode using the python -i command. This mode keeps Python open after script execution, allowing users to interact with variables and view graphics produced during script execution. Python must be installed, with required dependencies (typically WNTR, matplotlib, etc.) available, and the relevant example file located in the working directory. Input is the script filename, and output is an interactive Python session for further exploration or plotting. Use exit() to close the session.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/examples.rst#_snippet_1\n\nLANGUAGE: Shell\nCODE:\n```\npython -i getting_started.py\n```\n\n----------------------------------------\n\nTITLE: Installing Optional Python Dependencies for WNTR - Shell\nDESCRIPTION: This command installs optional dependencies for WNTR listed in requirements.txt. These additional packages enable advanced features like interactive graphics and geospatial data compatibility. Prerequisites: pip and requirements.txt file present. Input: command execution; Output: optional Python packages installed as listed in the requirements file.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/installation.rst#_snippet_9\n\nLANGUAGE: shell\nCODE:\n```\npip install -r requirements.txt\n```\n\n----------------------------------------\n\nTITLE: Setting the Random Seed for Reproducibility with Numpy in Python\nDESCRIPTION: This snippet sets the NumPy random seed to a specific value (12343) to ensure that all downstream random processes (such as sampling) are reproducible. Required dependency is numpy. No outputs are generated except for globally affecting numpy random draws.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/fragility.rst#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n>>> np.random.seed(12343)\n```\n\n----------------------------------------\n\nTITLE: Importing Required Libraries for WNTR Analysis in Python\nDESCRIPTION: Imports the necessary Python libraries: WNTR for water network analysis, Matplotlib for plotting, and NumPy for numerical operations. It also sets a default colormap for network visualizations.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/pipe_break_tutorial.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport wntr\nimport matplotlib\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# Set colormap for network maps\ncmap=matplotlib.colormaps['viridis']\n```\n\n----------------------------------------\n\nTITLE: Population Impacted by Mass Consumed Over Threshold - WNTR - Python\nDESCRIPTION: Combines previously computed population and mass-consumed metrics to calculate the number of people experiencing exposure above a specified mass-consumed threshold (e.g., 80000). Depends on the output of earlier steps and NumPy for comparison. Returns a value (or array) representing impact magnitude.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/resilience.rst#_snippet_23\n\nLANGUAGE: python\nCODE:\n```\n>>> pop = wntr.metrics.population(wn)\n>>> threshold = 80000\n>>> pop_impacted = wntr.metrics.population_impacted(pop, MC, np.greater, \n...     threshold)\n```\n\n----------------------------------------\n\nTITLE: Installing WNTR via PyPI using pip (Shell)\nDESCRIPTION: Installs the latest stable release of the WNTR Python package from the Python Package Index (PyPI) using the pip package installer. This command should be executed in a terminal, command line, or PowerShell prompt. This is one of the primary methods recommended for end-users.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/installation.rst#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\npip install wntr\n```\n\n----------------------------------------\n\nTITLE: Setting Default Hydraulic Pressure Options in WNTR Python\nDESCRIPTION: Shows the default values assigned to `required_pressure` and `minimum_pressure` within `wn.options.hydraulic`. These values are typically defined from the REQUIRED PRESSURE and MINIMUM PRESSURE settings in an EPANET 2.2.0 INP file when creating a WaterNetworkModel. The snippet shows the default values used in EPANET (0.1 psi required pressure, converted to 0.07 meters, and 0 minimum pressure).\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/whatsnew/v0.3.0.rst#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nwn.options.hydraulic.required_pressure = 0.07 # 0.1 psi = 0.07 m\nwn.options.hydraulic.minimum_pressure = 0\n```\n\n----------------------------------------\n\nTITLE: Displaying Sorted Simulation Results using Pandas Series in Python\nDESCRIPTION: Converts the `num_junctions_impacted` dictionary (containing the calculated number of impacted junctions from the simulation) into a pandas Series and then sorts it based on its index (hydrant location names). This allows for convenient display and comparison against expected results or other simulation outputs during testing or analysis.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/fire_flow_tutorial.ipynb#_snippet_12\n\nLANGUAGE: python\nCODE:\n```\npd.Series(num_junctions_impacted).sort_index()\n```\n\n----------------------------------------\n\nTITLE: Storing and Sorting Landslide Intersection Statistics - Python\nDESCRIPTION: This snippet copies key intersection statistics between landslides and pipes into the scenario DataFrame and sorts the results by total pipe length. Requires pandas and 'landslide_intersect' with columns 'intersections', 'n', and 'sum'. Inputs are GIS scenario and intersection DataFrames; outputs are updated DataFrames suitable for further analysis or export.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/landslide_tutorial.ipynb#_snippet_20\n\nLANGUAGE: python\nCODE:\n```\n# Add the intersection results to the landslide scenario data\nlandslide_scenarios[['intersections', 'n', 'total pipe length']] = landslide_intersect[['intersections', 'n', 'sum']]\n\n# Print results in order of descending total pipe length\nlandslide_scenarios.sort_values('total pipe length', ascending=False).head()\n```\n\n----------------------------------------\n\nTITLE: Saving Resampled Demand Patterns Plot to Image File in Matplotlib Python\nDESCRIPTION: This snippet finishes and saves a plot displaying the resampled and original demand patterns to a PNG file with tight subplot layout, using matplotlib. Only matplotlib is required and depends on a relevant previously plotted figure.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/libraries.rst#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\n>>> plt.tight_layout()\n>>> plt.savefig('demand_library_resampled.png', dpi=300)\n```\n\n----------------------------------------\n\nTITLE: Saving the Damage State Figure with Matplotlib in Python\nDESCRIPTION: This snippet saves the damage state figure created in the previous snippet by tightening the layout, exporting to a PNG image ('damage_state.png') at 300 dpi, and closing the plot. Inputs are the previously created plot, with no return objects except for the image file. It finalizes the visualization for external use or documentation.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/fragility.rst#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n>>> plt.tight_layout()\\n>>> plt.savefig('damage_state.png', dpi=300)\\n>>> plt.close()\n```\n\n----------------------------------------\n\nTITLE: Importing WNTR and Scientific Libraries in Python\nDESCRIPTION: This snippet imports WNTR along with core scientific libraries (NumPy, Scipy, NetworkX, GeoPandas, Matplotlib) required for data analysis, visualization, and hydrological computations. Dependencies must be installed in the Python environment and are essential for most following tutorial steps.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/basics_tutorial.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport numpy as np\\nfrom scipy.stats import lognorm\\nimport networkx as nx\\nimport geopandas as gpd\\nimport matplotlib.pylab as plt\\nimport wntr\n```\n\n----------------------------------------\n\nTITLE: Printing Valid GIS Column Names for WaterNetworkModel - Python\nDESCRIPTION: Retrieves the required column names for each network component when building a model from GeoJSON or Shapefiles using wntr.network.io.valid_gis_names. The output is printed for each component category, providing guidance for manual file construction.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/basics_tutorial.ipynb#_snippet_49\n\nLANGUAGE: python\nCODE:\n```\n# Print valid GeoJSON or Shapefiles column names required to build a model\\ncolumn_names = wntr.network.io.valid_gis_names()\\nprint(\\\"Junction column names\\\", column_names['junctions'])\\nprint()\\nprint(\\\"Tank column names\\\", column_names['tanks'])\\nprint()\\nprint(\\\"Reservoir column names\\\", column_names['reservoirs'])\\nprint()\\nprint(\\\"Pipe column names\\\", column_names['pipes'])\\nprint()\\nprint(\\\"Pump column names\\\", column_names['pumps'])\\nprint()\\nprint(\\\"Valve column names\\\", column_names['valves'])\n```\n\n----------------------------------------\n\nTITLE: Setting up Data Testing for Fire Flow Analysis Results in Python\nDESCRIPTION: Imports the pandas library for data manipulation and comparison. It then loads expected results for the number of impacted junctions and impacted population from two separate CSV files located in a testing directory. The data is read into pandas Series, converted to dictionaries, and keys are explicitly converted to strings to ensure consistent comparison with the simulation results stored in dictionaries.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/fire_flow_tutorial.ipynb#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nimport pandas as pd\n\n# Test simulation results\n# Import expected results\njunct_test = pd.read_csv('../wntr/tests/data_for_testing/fire_flow_demo_junction_test_data.csv', index_col=0).squeeze('columns').to_dict()\njunct_test = {str(key): value for key, value in junct_test.items()}\n\npeople_test = pd.read_csv('../wntr/tests/data_for_testing/fire_flow_demo_people_test_data.csv', index_col=0).squeeze('columns').to_dict()\npeople_test = {str(key): value for key, value in people_test.items()}\n\n# Check if simulation results match expected results\nassert num_junctions_impacted == junct_test, \"impacted junction results differ\"\nassert num_people_impacted == people_test, \"impacted people results differ\"\n```\n\n----------------------------------------\n\nTITLE: Saving a WNTR Valve Layer Plot using Matplotlib in Python\nDESCRIPTION: This hidden doctest snippet adjusts the layout of the current matplotlib plot (presumably generated by `wntr.graphics.plot_valve_layer` in the preceding snippet) using `plt.tight_layout()` for better spacing. It then saves the figure to a file named 'random_valve_layer.png' with 300 DPI resolution using `plt.savefig()` and closes the plot window using `plt.close()` to free up resources.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/layers.rst#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n>>> plt.tight_layout()\n>>> plt.savefig('random_valve_layer.png', dpi=300)\n>>> plt.close()\n```\n\n----------------------------------------\n\nTITLE: Displaying Head of Sample Pipe Material Data\nDESCRIPTION: This snippet displays the first 10 entries of the Pandas Series `material`, which contains randomly generated material types assigned to pipes in the network model. This shows an example of external data that can be added as custom attributes.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/waternetworkmodel.rst#_snippet_14\n\nLANGUAGE: python\nCODE:\n```\n>>> print(material.head(10))\n20         Steel\n40     Cast iron\n50          HDPE\n60           PVC\n101    Cast iron\n103          PVC\n105        Steel\n107        Steel\n109    Cast iron\n111        Steel\ndtype: object\n```\n\n----------------------------------------\n\nTITLE: Importing and Initializing WaterNetworkModel with Fallbacks in WNTR Python\nDESCRIPTION: This Python snippet imports matplotlib and wntr, then attempts to load a WaterNetworkModel from two alternative file paths, using exception handling as a fallback if the first path fails. This approach ensures compatibility with varying directory structures for relative and absolute paths when initializing a model. No additional dependencies beyond wntr and matplotlib are required; it expects one of the network files (Net1.inp) to be present at the specified relative locations.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/libraries.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n>>> import matplotlib.pylab as plt\n>>> import wntr\n>>> try:\n...    wn = wntr.network.model.WaterNetworkModel('../examples/networks/Net1.inp')\n... except:\n...    wn = wntr.network.model.WaterNetworkModel('examples/networks/Net1.inp')\n```\n\n----------------------------------------\n\nTITLE: Finalizing and Saving Network Plot (Hidden Doctest) in Python\nDESCRIPTION: This hidden doctest performs cleanup actions for the plot created in the previous step. It sets the plot axes to have equal scaling using `ax.axis('equal')`, adjusts the layout to prevent labels from overlapping using `plt.tight_layout()`, saves the generated figure as a PNG image file named 'snap_points.png' with 300 DPI resolution, and finally closes the plot window using `plt.close()` to free up resources.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/gis.rst#_snippet_21\n\nLANGUAGE: python\nCODE:\n```\n>>> bounds = ax.axis('equal')\n>>> plt.tight_layout()\n>>> plt.savefig('snap_points.png', dpi=300)\n>>> plt.close()\n```\n\n----------------------------------------\n\nTITLE: Creating Disconnected Pipe Geometries for Testing in Python\nDESCRIPTION: This hidden snippet creates a sample GeoDataFrame (`disconnected_pipes`) representing disconnected pipes. It starts from an existing `original_pipes` GeoDataFrame, selects relevant columns, and then iterates through each pipe, randomly rotating and scaling its geometry using `geopandas` and `numpy` functions to simulate disconnected data. Requires `geopandas` and `numpy`.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/gis.rst#_snippet_43\n\nLANGUAGE: python\nCODE:\n```\n>>> np.random.seed(123)\n>>> disconnected_pipes = original_pipes[['diameter', 'length', 'geometry']]\n>>> for i, line in disconnected_pipes.iterrows():\n...     angle = np.random.uniform(-5,5,1)\n...     geom = gpd.GeoSeries(line['geometry'])\n...     geom = geom.rotate(angle)\n...     geom = geom.scale(0.9, 0.9)\n...     disconnected_pipes.loc[i,'geometry'] = geom[0]\n```\n\n----------------------------------------\n\nTITLE: Configuring Matplotlib Layout and Saving Figures in Python\nDESCRIPTION: These commands hide in the doctest output, applying a tight layout, saving the current Matplotlib figure as a PNG image with 300 DPI, and then closing the figure. Dependencies include matplotlib. No input parameters are needed, but make sure a figure exists prior to these calls. The outputs are the saved image file and disposed figure resource. This is commonly used to record plot output for documentation or further analysis.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/morph.rst#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n>>> plt.tight_layout()\n>>> plt.savefig('skel_hydraulics.png', dpi=300)\n>>> plt.close()\n```\n\n----------------------------------------\n\nTITLE: Importing Libraries for WNTR Examples (Hidden Setup)\nDESCRIPTION: This hidden doctest imports necessary Python libraries (NumPy, Pandas, and optionally GeoPandas) commonly used in conjunction with WNTR for data manipulation and analysis. It includes error handling for the optional GeoPandas library.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/waternetworkmodel.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n>>> import numpy as np\n>>> import pandas as pd\n>>> try:\n...    import geopandas as gpd\n... except ModuleNotFoundError:\n...    gpd = None\n```\n\n----------------------------------------\n\nTITLE: Installing WNTR from local source files using pip (Shell)\nDESCRIPTION: Builds and installs WNTR from local source files after downloading the repository (e.g., as a ZIP file from GitHub). This command must be run from the directory containing the `setup.py` file. It requires a C++ compiler (like Visual Studio C++, GNU C++, MinGW) to be installed and accessible on the system's PATH, as WNTR includes C++ code. The '.' indicates installation from the current directory.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/installation.rst#_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\npython -m pip install .\n```\n\n----------------------------------------\n\nTITLE: Referencing WNTR Network Skeletonization Method (Python)\nDESCRIPTION: References the `skeletonize` method within the `wntr.morph.skel` module. This method is used to reduce the size of a water distribution network model by removing less important pipes and nodes while preserving key hydraulic characteristics.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/whatsnew/v0.1.7.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n~wntr.morph.skel.skeletonize\n```\n\n----------------------------------------\n\nTITLE: Defining Zoom Coordinates for Network Graphics in Python\nDESCRIPTION: This snippet defines a Python list of tuples named `zoom_coords`. These coordinates represent the desired x and y limits for Matplotlib plots, allowing visualization to focus on a specific area of the water network in subsequent plotting steps.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/landslide_tutorial.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n# The following line defines coordinates used to zoom in on network graphics\nzoom_coords = [(5.75e6, 5.79e6), (3.82e6, 3.85e6)] \n```\n\n----------------------------------------\n\nTITLE: Enforcing Lower Limit for Required Pressure Option in WNTR (Python)\nDESCRIPTION: Fixes a bug to strictly enforce the EPANET lower limit (0.1 in psi or meters) for the `wn.options.hydraulic.required_pressure` option. If a user attempts to set a value below this minimum, the value 0.1 m is automatically used in the generated INP file, and a warning is issued. This ensures consistency with EPANET's operational constraints.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/whatsnew/v0.4.0.rst#_snippet_9\n\nLANGUAGE: Python\nCODE:\n```\nwn.options.hydraulic.required_pressure\n```\n\n----------------------------------------\n\nTITLE: Saving and Closing Matplotlib Figures - Python\nDESCRIPTION: Finalizes the layout, saves the last-created Matplotlib figure to a specified PNG file with 300 DPI resolution, and closes resources. This is repetitive across segments to export their plots. It requires a currently active Matplotlib figure.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/graphics.rst#_snippet_16\n\nLANGUAGE: python\nCODE:\n```\n>>> plt.tight_layout()\n>>> plt.savefig('plot_tank_volume_curve.png', dpi=300)\n>>> plt.close()\n```\n\nLANGUAGE: python\nCODE:\n```\n>>> plt.tight_layout()\n>>> plt.savefig('plot_valve_segment.png', dpi=300)\n>>> plt.close()\n```\n\nLANGUAGE: python\nCODE:\n```\n>>> plt.tight_layout()\n>>> plt.savefig('plot_valve_segment_attributes.png', dpi=300)\n>>> plt.close()\n```\n\n----------------------------------------\n\nTITLE: Specifying Zoom Coordinates for Network Visualization - Python\nDESCRIPTION: Defines bounding box coordinates to focus plots and analyses on a specific region of the network. Used later to constrain Matplotlib plot extents for zoomed-in views. Coordinates must match the CRS units (feet) for proper alignment. Consumes a tuple of tuples for x and y ranges.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/model_development_tutorial.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n# The following defines coordinates used to zoom in on network graphics\\nzoom_coords = [(4978500, 4982000), (3903000, 3905500)]\\n\n```\n\n----------------------------------------\n\nTITLE: Referencing WNTR Pipe Breaking Method (Python)\nDESCRIPTION: References the `break_pipe` method in the `wntr.morph.link` module. Similar to `split_pipe`, this function modifies a pipe, potentially splitting it or altering its connectivity, likely adding a node.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/whatsnew/v0.1.7.rst#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\n~wntr.morph.link.break_pipe\n```\n\n----------------------------------------\n\nTITLE: Loading WaterNetworkModel with Path Handling (Hidden Setup)\nDESCRIPTION: This hidden doctest attempts to load the 'Net3.inp' file using different relative paths, likely to ensure examples run correctly regardless of the execution directory. It also sets the Matplotlib backend to 'Agg' to prevent GUI windows during testing, including error handling.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/waternetworkmodel.rst#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n>>> try:\n...    wn = wntr.network.model.WaterNetworkModel('../examples/networks/Net3.inp')\n... except:\n...    wn = wntr.network.model.WaterNetworkModel('examples/networks/Net3.inp')\n>>> import matplotlib as mpl\n>>> try:\n...     mpl.use('Agg')\n... except:\n...     pass\n```\n\n----------------------------------------\n\nTITLE: Adding Slots to WNTR Model Options (Python)\nDESCRIPTION: Introduces the use of slots for the `wn.options` object to strictly define available option names. This helps prevent errors from incorrect or deprecated option usage. Users can still define custom options under the `wn.options.user` attribute.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/whatsnew/v0.4.0.rst#_snippet_3\n\nLANGUAGE: Python\nCODE:\n```\nwn.options\n```\n\nLANGUAGE: Python\nCODE:\n```\nwn.options.user\n```\n\n----------------------------------------\n\nTITLE: Finalizing and Saving Geopandas Plot in Python\nDESCRIPTION: This hidden snippet finalizes a Matplotlib plot created using `geopandas` (stored in `ax`). It sets equal aspect ratio, applies tight layout, turns off the axis display, saves the figure to a PNG file, and closes the plot. Requires `geopandas` and `matplotlib`.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/gis.rst#_snippet_46\n\nLANGUAGE: python\nCODE:\n```\n>>> bounds = ax.axis('equal')\n>>> plt.tight_layout()\n>>> temp = plt.axis('off')\n>>> plt.savefig('connect_lines.png', dpi=300)\n>>> plt.close()\n```\n\n----------------------------------------\n\nTITLE: Referencing WNTR Network Model Description Method (Python)\nDESCRIPTION: References the newly added `describe` method of the `WaterNetworkModel` class. This method returns summary statistics about the network model, such as the count of different node types, link types, patterns, etc.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/whatsnew/v0.1.7.rst#_snippet_15\n\nLANGUAGE: python\nCODE:\n```\n~wntr.network.model.WaterNetworkModel.describe\n```\n\n----------------------------------------\n\nTITLE: Saving Gaussian Demand Patterns Plot to Image File in Matplotlib Python\nDESCRIPTION: This snippet uses matplotlib to finalize and save a figure ('demand_library_gaussian.png') with a tight layout, preserving the previously plotted Gaussian and noisy patterns. Requires matplotlib and a previously-generated plot object.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/libraries.rst#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n>>> plt.tight_layout()\n>>> plt.savefig('demand_library_gaussian.png', dpi=300)\n```\n\n----------------------------------------\n\nTITLE: Re-initializing GeoDataFrame from File (Hidden Doctest) in Python\nDESCRIPTION: This hidden doctest re-initializes the `hydrant_data` GeoDataFrame by reading from a specific file path, resetting it after potential modifications in previous examples. This is likely for ensuring consistent state in documentation tests.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/gis.rst#_snippet_15\n\nLANGUAGE: python\nCODE:\n```\n>>> hydrant_data = gpd.read_file(examples_dir+'/data/Net1_hydrant_data.geojson')\n```\n\n----------------------------------------\n\nTITLE: Saving Landslide Intersection Plot as PNG using Matplotlib (Python)\nDESCRIPTION: This hidden test snippet finalizes and saves the figure generated from the previous plotting step, using Matplotlib. It ensures axis are equal, layout is tight, and the plot is saved as a PNG file. Required libraries are Matplotlib (plt) and an axes object from previous plotting.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/gis.rst#_snippet_28\n\nLANGUAGE: python\nCODE:\n```\n>>> bounds = ax.axis('equal')\n>>> plt.tight_layout()\n>>> plt.savefig('intersect_landslide.png', dpi=300)\n>>> plt.close()\n```\n\n----------------------------------------\n\nTITLE: Including Release Note Files Using reStructuredText Directives - reStructuredText\nDESCRIPTION: This snippet demonstrates how to include an external release note file (v0.2.1.rst) into the documentation using the reStructuredText (RST) '.. include::' directive, preceded by a Sphinx reference anchor for cross-referencing. There are no external dependencies other than the existence of the referenced file. The input to this snippet is the relative path to the .rst file, and the output is the inclusion of its contents into the generated piece of documentation at this location.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/whatsnew.rst#_snippet_16\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. _whatsnew_0210:\n\n.. include:: whatsnew/v0.2.1.rst\n```\n\n----------------------------------------\n\nTITLE: Including Release Note Files Using reStructuredText Directives - reStructuredText\nDESCRIPTION: This snippet demonstrates how to include an external release note file (v0.1.5.rst) into the documentation using the reStructuredText (RST) '.. include::' directive, preceded by a Sphinx reference anchor for cross-referencing. There are no external dependencies other than the existence of the referenced file. The input to this snippet is the relative path to the .rst file, and the output is the inclusion of its contents into the generated piece of documentation at this location.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/whatsnew.rst#_snippet_19\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. _whatsnew_0150:\n\n.. include:: whatsnew/v0.1.5.rst\n```\n\n----------------------------------------\n\nTITLE: Displaying Sorted Test Data using Pandas Series in Python\nDESCRIPTION: Converts the `people_test` dictionary (containing expected impacted population results loaded from a file) into a pandas Series and then sorts it based on its index (hydrant location names). This is typically done for easier visual inspection or comparison during debugging or data testing.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/fire_flow_tutorial.ipynb#_snippet_11\n\nLANGUAGE: python\nCODE:\n```\npd.Series(people_test).sort_index()\n```\n\n----------------------------------------\n\nTITLE: Initializing GeoDataFrame from File (Hidden Doctest) in Python\nDESCRIPTION: This hidden doctest initializes the `hydrant_data` GeoDataFrame by reading from a specific file path, likely used for testing setup within the documentation build process. It ensures the `hydrant_data` variable is correctly populated for subsequent examples.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/gis.rst#_snippet_13\n\nLANGUAGE: python\nCODE:\n```\n>>> hydrant_data = gpd.read_file(examples_dir+'/data/Net1_hydrant_data.geojson')\n```\n\n----------------------------------------\n\nTITLE: Generating Sample Pipe Material Data (Hidden Setup)\nDESCRIPTION: This hidden doctest generates a sample Pandas Series representing pipe material data for demonstration purposes. It iterates through the pipes in the `wn` model, randomly assigns a material ('PVC', 'Cast iron', 'Steel', 'HDPE') to each pipe, and stores it in the `material` Series, indexed by pipe name. `np.random.seed` ensures reproducibility.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/waternetworkmodel.rst#_snippet_13\n\nLANGUAGE: python\nCODE:\n```\n>>> np.random.seed(6789)\n>>> material = pd.Series()\n>>> for name, pipe in wn.pipes():\n...     val = np.random.choice(['PVC', 'Cast iron', 'Steel', 'HDPE'], 1, [0.45, 0.2, 0.1, 0.25])[0]\n...     material[name] = val\n```\n\n----------------------------------------\n\nTITLE: Running WNTR Software Tests Locally using pytest\nDESCRIPTION: Executes the WNTR test suite locally using the pytest framework. This command should be run from the root directory of the WNTR project in a command line or PowerShell prompt. It requires pytest to be installed in the Python environment.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/developers.rst#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\npytest wntr\n```\n\n----------------------------------------\n\nTITLE: Setting up WNTR for development from source (Shell)\nDESCRIPTION: Provides a sequence of shell commands for developers to set up a WNTR development environment. It first clones the WNTR repository from GitHub, changes the current directory to the cloned repository, installs WNTR in editable mode (`-e`) allowing code changes to be reflected immediately, and finally installs all necessary development dependencies listed in `requirements.txt`. Requires Git and pip to be installed.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/installation.rst#_snippet_6\n\nLANGUAGE: shell\nCODE:\n```\ngit clone https://github.com/USEPA/WNTR\ncd WNTR\npython -m pip install -e .\npip install -r requirements.txt\n```\n\n----------------------------------------\n\nTITLE: Importing Required Python Packages for WNTR Analysis\nDESCRIPTION: Imports necessary Python libraries for the WNTR earthquake tutorial, including WNTR itself, Matplotlib for plotting, NumPy for numerical operations, Pandas for data handling, and SciPy for statistical functions (specifically the exponential distribution for fragility curves). It also sets a random seed for reproducibility and defines a default colormap for network visualizations.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/earthquake_tutorial.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport wntr\nimport matplotlib\nimport matplotlib.pylab as plt\nimport numpy as np\nimport pandas as pd\nfrom scipy.stats import expon\n\nnp.random.seed(12345)\n\n# Set colormap for network maps\ncmap=matplotlib.colormaps['viridis']\n```\n\n----------------------------------------\n\nTITLE: Importing Libraries and Setting Colormap in Python\nDESCRIPTION: Imports the necessary Python libraries: WNTR for water network analysis, Matplotlib and its pylab interface for plotting. It also sets a default colormap (`viridis`) for use in subsequent network visualizations.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/pipe_segments_tutorial.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport wntr\nimport matplotlib\nimport matplotlib.pylab as plt\n\n# Set colormap for network maps\ncmap=matplotlib.colormaps['viridis']\n```\n\n----------------------------------------\n\nTITLE: Referencing wntr.metrics.topographic.valve_segments Function in Python/reStructuredText\nDESCRIPTION: This snippet uses reStructuredText syntax (with '~' for brevity) to reference the `valve_segments` function within the `wntr.metrics.topographic` module of the WNTR Python library. Efficiency improvements were made by leveraging NetworkX connected components (pull request #318).\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/whatsnew/v1.0.0.rst#_snippet_3\n\nLANGUAGE: rst\nCODE:\n```\n:class:`~wntr.metrics.topographic.valve_segments`\n```\n\n----------------------------------------\n\nTITLE: Referencing WNTR Node Attribute Query Method (Python)\nDESCRIPTION: References the `query_node_attribute` method of the `WaterNetworkModel` class. This method retrieves specified attribute values for nodes in the network. In v0.1.7, its return type was changed from a dictionary to a pandas Series (API change).\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/whatsnew/v0.1.7.rst#_snippet_13\n\nLANGUAGE: python\nCODE:\n```\n~wntr.network.model.WaterNetworkModel.query_node_attribute\n```\n\n----------------------------------------\n\nTITLE: Conditional HTML Output for References Section - Sphinx/reStructuredText/HTML\nDESCRIPTION: This code snippet leverages the 'only' directive in reStructuredText to conditionally output a formatted References header in HTML builds. It includes a section title using top-level reStructuredText underlining. The snippet requires a Sphinx documentation build system and is used to cleanly separate references in the generated HTML output.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/reference.rst#_snippet_1\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. only:: html\n\n    References\n    ==========\n\n```\n\n----------------------------------------\n\nTITLE: Referencing WNTR Link Attribute Query Method (Python)\nDESCRIPTION: References the `query_link_attribute` method of the `WaterNetworkModel` class. This method retrieves specified attribute values for links (pipes, pumps, valves) in the network. In v0.1.7, its return type was changed from a dictionary to a pandas Series (API change).\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/whatsnew/v0.1.7.rst#_snippet_14\n\nLANGUAGE: python\nCODE:\n```\n~wntr.network.model.WaterNetworkModel.query_link_attribute\n```\n\n----------------------------------------\n\nTITLE: Reloading WaterNetworkModel (Hidden Setup)\nDESCRIPTION: This hidden doctest reloads the 'Net3.inp' water network model into the `wn` variable. This is likely done to reset the model state before subsequent examples, ensuring they run independently.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/waternetworkmodel.rst#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n>>> try:\n...    wn = wntr.network.model.WaterNetworkModel('../examples/networks/Net3.inp')\n... except:\n...    wn = wntr.network.model.WaterNetworkModel('examples/networks/Net3.inp') # switch back to net3\n```\n\n----------------------------------------\n\nTITLE: Testing Population Impact Results with Assertions - Python\nDESCRIPTION: This snippet loads precomputed population impact results for both with and without repair scenarios from CSV files, then asserts the calculated results exactly match expected outputs. It requires Pandas for data import and depends on the earlier metric computations. Expected and computed datasets are compared element-wise, with assertion errors raised if results differ.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/earthquake_tutorial.ipynb#_snippet_16\n\nLANGUAGE: python\nCODE:\n```\n# Test simulation results\n# Import expected results\npeople_test = pd.read_csv('../wntr/tests/data_for_testing/earthquake_demo_people_test_data.csv', index_col=0)\npeople_wrepair_test = pd.read_csv('../wntr/tests/data_for_testing/earthquake_demo_people_wrepair_test_data.csv', index_col=0)\n\n# Check if simulation results match expected results\nassert (people_test == people_impacted).all(axis=None) == True, \"impacted people results differ\"\nassert (people_wrepair_test == people_impacted_wrepair).all(axis=None)  == True, \"impacted people wrepair results differ\"\n```\n\n----------------------------------------\n\nTITLE: Installing OpenMP dependency for WNTR on Mac using Homebrew (Bash)\nDESCRIPTION: Installs or reinstalls the necessary OpenMP library (`libomp`) on macOS using the Homebrew package manager. This step is required for users who need the EPANETMSX extensions functionality within WNTR on a Mac, as the pre-built binaries depend on OpenMP. The command uses a specific formula hosted in the WNTR GitHub repository.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/installation.rst#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nbrew reinstall --build-from-source --formula https://github.com/USEPA/WNTR/tree/main/wntr/epanet/libepanet/darwin-formula/libomp.rb\n```\n\n----------------------------------------\n\nTITLE: Restructuring: Creating 'epanet' Package in Python\nDESCRIPTION: Describes the creation of the `epanet` package within the WNTR library to house the EPANET toolkit, INP file reader/writer, and unit conversions. This change involved removing the previously used `pyepanet` package, centralizing EPANET-related functionality.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/whatsnew/v0.1.2.rst#_snippet_0\n\nLANGUAGE: text\nCODE:\n```\nAdded `epanet` package which contains an epanet toolkit, EPANET INP file reader/writer, and unit conversions.  Removed pyepanet package.\n```\n\n----------------------------------------\n\nTITLE: Referencing WNTR Network Animation Method (Python)\nDESCRIPTION: References the `network_animation` method in the `wntr.graphics.network` module. This function creates an animation visualizing dynamic changes in the water network over time, based on simulation results.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/whatsnew/v0.1.7.rst#_snippet_12\n\nLANGUAGE: python\nCODE:\n```\n~wntr.graphics.network.network_animation\n```\n\n----------------------------------------\n\nTITLE: Defining Optional Dependencies for WNTR\nDESCRIPTION: Lists optional Python packages that enhance WNTR's capabilities, such as interactive plotting (plotly), mapping (folium, utm, geopandas, rasterio, rtree), and Excel file support (openpyxl). These are not strictly necessary for basic operation but provide additional features.\nSOURCE: https://github.com/usepa/wntr/blob/main/requirements.txt#_snippet_1\n\nLANGUAGE: requirements\nCODE:\n```\n# Optional\nplotly<6.0\nfolium\nutm\nopenpyxl\ngeopandas\nrasterio\nrtree\n```\n\n----------------------------------------\n\nTITLE: Referencing WNTR Node Coordinate Rotation Method (Python)\nDESCRIPTION: References the `rotate_node_coordinates` method in the `wntr.morph.node` module. This function rotates the coordinates of all nodes in the network model around a specified origin point by a given angle.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/whatsnew/v0.1.7.rst#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n~wntr.morph.node.rotate_node_coordinates\n```\n\n----------------------------------------\n\nTITLE: API Change: Removing 'Waterquality' Class in Python\nDESCRIPTION: Documents the removal of the `Waterquality` class from the `scenario` package. Its functionality is now handled by the `Source` class within the water network model.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/whatsnew/v0.1.2.rst#_snippet_3\n\nLANGUAGE: text\nCODE:\n```\nRemoved Waterquality class from the scenario package.  This functionality has been replaced with Source class in the water network model.\n```\n\n----------------------------------------\n\nTITLE: Installing WNTR Using conda - Bash\nDESCRIPTION: Installs the WNTR package from the conda-forge channel via the conda package manager. Requires the Anaconda or Miniconda distribution and access to the conda-forge channel. The command will resolve and install compatible versions of WNTR and its dependencies in the active conda environment. The '-c conda-forge' flag specifies the community-maintained channel for up-to-date Python packages. Successful execution leads to WNTR being available for use in the workspace.\nSOURCE: https://github.com/usepa/wntr/blob/main/README.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nconda install -c conda-forge wntr\n```\n\n----------------------------------------\n\nTITLE: Referencing WNTR Morphology Module (Python)\nDESCRIPTION: References the newly added module for network morphology within the WNTR library. This module contains various methods for analyzing and modifying the structure and geometry of water networks.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/whatsnew/v0.1.7.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n~wntr.morph\n```\n\n----------------------------------------\n\nTITLE: Running WNTR Tests with Pytest - Shell\nDESCRIPTION: This command runs the WNTR test suite using pytest. It helps developers ensure correct package installation and functionality by executing local tests. Dependencies: WNTR source code and pytest installed. Expected input: command invocation; Output: test results printed to the terminal.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/installation.rst#_snippet_8\n\nLANGUAGE: shell\nCODE:\n```\npytest wntr\n```\n\n----------------------------------------\n\nTITLE: Referencing WNTR Node Coordinate Conversion UTM to Long/Lat (Python)\nDESCRIPTION: References the `convert_node_coordinates_UTM_to_longlat` method in the `wntr.morph.node` module. This function converts node coordinates from the Universal Transverse Mercator (UTM) system to longitude and latitude.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/whatsnew/v0.1.7.rst#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n~wntr.morph.node.convert_node_coordinates_UTM_to_longlat\n```\n\n----------------------------------------\n\nTITLE: Building WNTR Documentation Locally using Make\nDESCRIPTION: Builds the HTML version of the WNTR user manual locally using the 'make' command. This command should be executed from the 'documentation' directory within the WNTR project. It typically relies on Sphinx and associated tools defined in the Makefile. The output HTML files are generated in the 'documentation/_build/html' directory.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/developers.rst#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\nmake html\n```\n\n----------------------------------------\n\nTITLE: Including Release Note Files Using reStructuredText Directives - reStructuredText\nDESCRIPTION: This snippet demonstrates how to include an external release note file (v0.5.0.rst) into the documentation using the reStructuredText (RST) '.. include::' directive, preceded by a Sphinx reference anchor for cross-referencing. There are no external dependencies other than the existence of the referenced file. The input to this snippet is the relative path to the .rst file, and the output is the inclusion of its contents into the generated piece of documentation at this location.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/whatsnew.rst#_snippet_7\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. _whatsnew_050:\n\n.. include:: whatsnew/v0.5.0.rst\n```\n\n----------------------------------------\n\nTITLE: Referencing WNTR Leaflet Network Plotting Method (Python)\nDESCRIPTION: References the `plot_leaflet_network` method in the `wntr.graphics.network` module. This function generates an interactive map visualization of the water network using the Leaflet JavaScript library.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/whatsnew/v0.1.7.rst#_snippet_11\n\nLANGUAGE: python\nCODE:\n```\n~wntr.graphics.network.plot_leaflet_network\n```\n\n----------------------------------------\n\nTITLE: Setting Y-Axis Label with Matplotlib in Python\nDESCRIPTION: This code sets the y-axis label of a matplotlib Axes object to indicate percent change in pressure, typically for use in plotting pressure comparisons. It depends on matplotlib. The parameter 'ax' should be a matplotlib Axes instance, and the method returns the matplotlib text object corresponding to the label. This operation affects only the y-axis labeling and has no effect on data.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/morph.rst#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n>>> text = ax.set_ylabel('Percent change in pressure (%)')\n```\n\n----------------------------------------\n\nTITLE: Referencing wntr.gis.geospatial.intersect Function in Python/reStructuredText\nDESCRIPTION: This snippet uses reStructuredText syntax (with '~' for brevity) to reference the `intersect` function within the `wntr.gis.geospatial` module of the WNTR Python library. The changelog notes updates to sort results for reproducibility and minor documentation changes (pull request #328).\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/whatsnew/v1.0.0.rst#_snippet_1\n\nLANGUAGE: rst\nCODE:\n```\n:class:`~wntr.gis.geospatial.intersect`\n```\n\n----------------------------------------\n\nTITLE: Referencing WNTR Node Coordinate Conversion to Long/Lat (Python)\nDESCRIPTION: References the `convert_node_coordinates_to_longlat` method in the `wntr.morph.node` module. This function converts node coordinates to longitude and latitude, potentially from an assumed standard system if not UTM.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/whatsnew/v0.1.7.rst#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\n~wntr.morph.node.convert_node_coordinates_to_longlat\n```\n\n----------------------------------------\n\nTITLE: Including Release Note Files Using reStructuredText Directives - reStructuredText\nDESCRIPTION: This snippet demonstrates how to include an external release note file (v0.1.2.rst) into the documentation using the reStructuredText (RST) '.. include::' directive, preceded by a Sphinx reference anchor for cross-referencing. There are no external dependencies other than the existence of the referenced file. The input to this snippet is the relative path to the .rst file, and the output is the inclusion of its contents into the generated piece of documentation at this location.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/whatsnew.rst#_snippet_22\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. _whatsnew_0120:\n\n.. include:: whatsnew/v0.1.2.rst\n```\n\n----------------------------------------\n\nTITLE: Referencing wntr.morph.node Class in Python/reStructuredText\nDESCRIPTION: This snippet uses reStructuredText syntax to reference the `wntr.morph.node` class within the WNTR Python library. The context indicates that vertices coordinate transformation functions were added to this class as part of pull request #332.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/whatsnew/v1.0.0.rst#_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n:class:`wntr.morph.node`\n```\n\n----------------------------------------\n\nTITLE: Including Release Note Files Using reStructuredText Directives - reStructuredText\nDESCRIPTION: This snippet demonstrates how to include an external release note file (v0.3.1.rst) into the documentation using the reStructuredText (RST) '.. include::' directive, preceded by a Sphinx reference anchor for cross-referencing. There are no external dependencies other than the existence of the referenced file. The input to this snippet is the relative path to the .rst file, and the output is the inclusion of its contents into the generated piece of documentation at this location.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/whatsnew.rst#_snippet_11\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. _whatsnew_031:\n\n.. include:: whatsnew/v0.3.1.rst\n```\n\n----------------------------------------\n\nTITLE: Configuring and Displaying Sphinx Bibliography List (reStructuredText)\nDESCRIPTION: This snippet uses the '.. bibliography::' directive with options in reStructuredText to include an external bibliography in the output documentation. The ':notcited:' flag lists all references regardless of citation usage, and ':list: bullet' specifies a bulleted style. Requires that a bibliography file is configured in Sphinx. Displays references at the insertion point in the rendered documentation.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/users.rst#_snippet_2\n\nLANGUAGE: restructuredtext\nCODE:\n```\n.. bibliography::\\n    :notcited:\\n    :list: bullet\n```\n\n----------------------------------------\n\nTITLE: Restructuring: Reorganizing Core WNTR Packages in Python\nDESCRIPTION: Notes the reorganization of several core WNTR packages (`metrics`, `network`, `scenario`, `sim`, `utils`) as part of the v0.1.2 restructuring to improve code structure and maintainability.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/whatsnew/v0.1.2.rst#_snippet_2\n\nLANGUAGE: text\nCODE:\n```\nReorganized `metrics`, `network`, `scenario`, `sim`, and `utils` packages\n```\n\n----------------------------------------\n\nTITLE: Including Release Note Files Using reStructuredText Directives - reStructuredText\nDESCRIPTION: This snippet demonstrates how to include an external release note file (v1.2.0.rst) into the documentation using the reStructuredText (RST) '.. include::' directive, preceded by a Sphinx reference anchor for cross-referencing. There are no external dependencies other than the existence of the referenced file. The input to this snippet is the relative path to the .rst file, and the output is the inclusion of its contents into the generated piece of documentation at this location.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/whatsnew.rst#_snippet_4\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. _whatsnew_120:\n\n.. include:: whatsnew/v1.2.0.rst\n```\n\n----------------------------------------\n\nTITLE: Including Release Note Files Using reStructuredText Directives - reStructuredText\nDESCRIPTION: This snippet demonstrates how to include an external release note file (v1.0.0.rst) into the documentation using the reStructuredText (RST) '.. include::' directive, preceded by a Sphinx reference anchor for cross-referencing. There are no external dependencies other than the existence of the referenced file. The input to this snippet is the relative path to the .rst file, and the output is the inclusion of its contents into the generated piece of documentation at this location.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/whatsnew.rst#_snippet_6\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. _whatsnew_100:\n\n.. include:: whatsnew/v1.0.0.rst\n```\n\n----------------------------------------\n\nTITLE: Including Release Note Files Using reStructuredText Directives - reStructuredText\nDESCRIPTION: This snippet demonstrates how to include an external release note file (v1.4.0.rst) into the documentation using the reStructuredText (RST) '.. include::' directive, preceded by a Sphinx reference anchor for cross-referencing. There are no external dependencies other than the existence of the referenced file. The input to this snippet is the relative path to the .rst file, and the output is the inclusion of its contents into the generated piece of documentation at this location.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/whatsnew.rst#_snippet_0\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. _whatsnew_140:\n\n.. include:: whatsnew/v1.4.0.rst\n```\n\n----------------------------------------\n\nTITLE: Including Release Note Files Using reStructuredText Directives - reStructuredText\nDESCRIPTION: This snippet demonstrates how to include an external release note file (v0.2.2.1.rst) into the documentation using the reStructuredText (RST) '.. include::' directive, preceded by a Sphinx reference anchor for cross-referencing. There are no external dependencies other than the existence of the referenced file. The input to this snippet is the relative path to the .rst file, and the output is the inclusion of its contents into the generated piece of documentation at this location.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/whatsnew.rst#_snippet_14\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. _whatsnew_0221:\n\n.. include:: whatsnew/v0.2.2.1.rst\n```\n\n----------------------------------------\n\nTITLE: Including Release Note Files Using reStructuredText Directives - reStructuredText\nDESCRIPTION: This snippet demonstrates how to include an external release note file (v0.1.0.rst) into the documentation using the reStructuredText (RST) '.. include::' directive, preceded by a Sphinx reference anchor for cross-referencing. There are no external dependencies other than the existence of the referenced file. The input to this snippet is the relative path to the .rst file, and the output is the inclusion of its contents into the generated piece of documentation at this location.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/whatsnew.rst#_snippet_24\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. _whatsnew_0100:\n\n.. include:: whatsnew/v0.1.0.rst\n```\n\n----------------------------------------\n\nTITLE: Including Release Note Files Using reStructuredText Directives - reStructuredText\nDESCRIPTION: This snippet demonstrates how to include an external release note file (v0.1.6.rst) into the documentation using the reStructuredText (RST) '.. include::' directive, preceded by a Sphinx reference anchor for cross-referencing. There are no external dependencies other than the existence of the referenced file. The input to this snippet is the relative path to the .rst file, and the output is the inclusion of its contents into the generated piece of documentation at this location.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/whatsnew.rst#_snippet_18\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. _whatsnew_0160:\n\n.. include:: whatsnew/v0.1.6.rst\n```\n\n----------------------------------------\n\nTITLE: Defining Required Dependencies for WNTR\nDESCRIPTION: Specifies the essential Python packages required for the core functionality of the WNTR project. This includes numerical computation (numpy, scipy), network analysis (networkx), data manipulation (pandas), plotting (matplotlib), and package setup (setuptools). Specific version constraints are applied to numpy and scipy for compatibility.\nSOURCE: https://github.com/usepa/wntr/blob/main/requirements.txt#_snippet_0\n\nLANGUAGE: requirements\nCODE:\n```\n# Required\nnumpy>=1.21,<2.0\nscipy<1.13.0\nnetworkx\npandas\nmatplotlib\nsetuptools\n```\n\n----------------------------------------\n\nTITLE: Installing WNTR via Anaconda using conda (Shell)\nDESCRIPTION: Installs the latest stable release of the WNTR Python package from the conda-forge channel using the conda package manager, typically within an Anaconda environment. This command should be executed in a terminal, command line, or PowerShell prompt configured for Anaconda. This is another primary method recommended for end-users, especially those using the Anaconda distribution.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/installation.rst#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\nconda install -c conda-forge wntr\n```\n\n----------------------------------------\n\nTITLE: Including Release Note Files Using reStructuredText Directives - reStructuredText\nDESCRIPTION: This snippet demonstrates how to include an external release note file (v1.3.0.rst) into the documentation using the reStructuredText (RST) '.. include::' directive, preceded by a Sphinx reference anchor for cross-referencing. There are no external dependencies other than the existence of the referenced file. The input to this snippet is the relative path to the .rst file, and the output is the inclusion of its contents into the generated piece of documentation at this location.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/whatsnew.rst#_snippet_3\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. _whatsnew_130:\n\n.. include:: whatsnew/v1.3.0.rst\n```\n\n----------------------------------------\n\nTITLE: Including Release Note Files Using reStructuredText Directives - reStructuredText\nDESCRIPTION: This snippet demonstrates how to include an external release note file (v1.1.0.rst) into the documentation using the reStructuredText (RST) '.. include::' directive, preceded by a Sphinx reference anchor for cross-referencing. There are no external dependencies other than the existence of the referenced file. The input to this snippet is the relative path to the .rst file, and the output is the inclusion of its contents into the generated piece of documentation at this location.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/whatsnew.rst#_snippet_5\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. _whatsnew_110:\n\n.. include:: whatsnew/v1.1.0.rst\n```\n\n----------------------------------------\n\nTITLE: Including Release Note Files Using reStructuredText Directives - reStructuredText\nDESCRIPTION: This snippet demonstrates how to include an external release note file (v0.1.1.rst) into the documentation using the reStructuredText (RST) '.. include::' directive, preceded by a Sphinx reference anchor for cross-referencing. There are no external dependencies other than the existence of the referenced file. The input to this snippet is the relative path to the .rst file, and the output is the inclusion of its contents into the generated piece of documentation at this location.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/whatsnew.rst#_snippet_23\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. _whatsnew_0110:\n\n.. include:: whatsnew/v0.1.1.rst\n```\n\n----------------------------------------\n\nTITLE: Referencing wntr.gis.geospatial.snap Function in Python/reStructuredText\nDESCRIPTION: This snippet uses reStructuredText syntax (with '~' for brevity) to reference the `snap` function within the `wntr.gis.geospatial` module of the WNTR Python library. A bug fix was implemented to prevent false positives in its output (pull request #327).\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/whatsnew/v1.0.0.rst#_snippet_2\n\nLANGUAGE: rst\nCODE:\n```\n:class:`~wntr.gis.geospatial.snap`\n```\n\n----------------------------------------\n\nTITLE: Referencing WNTR Pipe Splitting Method (Python)\nDESCRIPTION: References the `split_pipe` method in the `wntr.morph.link` module. This function splits a specified existing pipe into two new pipes, adding a new node at the split point.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/whatsnew/v0.1.7.rst#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\n~wntr.morph.link.split_pipe\n```\n\n----------------------------------------\n\nTITLE: Resetting Page Numbering for Disclaimer - LaTeX - English\nDESCRIPTION: This snippet is used for resetting the page numbering to roman numerals and starting the count from 1 for the disclaimer section. The LaTeX commands \\pagenumbering{roman} and \\setcounter{page}{1} are included in a raw directive for Sphinx/rST documentation. This is appropriate for prefatory documentation sections such as introductions or disclaimers. There are no inputs; the output is to affect how subsequent pages are numbered and displayed. Dependencies include LaTeX support for raw directives and Sphinx with LaTeX output enabled.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/disclaimer.rst#_snippet_1\n\nLANGUAGE: latex\nCODE:\n```\n.. raw:: latex\n\n    \\pagenumbering{roman}\n    \\setcounter{page}{1}\n\n```\n\n----------------------------------------\n\nTITLE: Including Release Note Files Using reStructuredText Directives - reStructuredText\nDESCRIPTION: This snippet demonstrates how to include an external release note file (v0.4.0.rst) into the documentation using the reStructuredText (RST) '.. include::' directive, preceded by a Sphinx reference anchor for cross-referencing. There are no external dependencies other than the existence of the referenced file. The input to this snippet is the relative path to the .rst file, and the output is the inclusion of its contents into the generated piece of documentation at this location.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/whatsnew.rst#_snippet_10\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. _whatsnew_040:\n\n.. include:: whatsnew/v0.4.0.rst\n```\n\n----------------------------------------\n\nTITLE: Including Release Note Files Using reStructuredText Directives - reStructuredText\nDESCRIPTION: This snippet demonstrates how to include an external release note file (v0.1.4.rst) into the documentation using the reStructuredText (RST) '.. include::' directive, preceded by a Sphinx reference anchor for cross-referencing. There are no external dependencies other than the existence of the referenced file. The input to this snippet is the relative path to the .rst file, and the output is the inclusion of its contents into the generated piece of documentation at this location.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/whatsnew.rst#_snippet_20\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. _whatsnew_0140:\n\n.. include:: whatsnew/v0.1.4.rst\n```\n\n----------------------------------------\n\nTITLE: Including Release Note Files Using reStructuredText Directives - reStructuredText\nDESCRIPTION: This snippet demonstrates how to include an external release note file (v1.3.1.rst) into the documentation using the reStructuredText (RST) '.. include::' directive, preceded by a Sphinx reference anchor for cross-referencing. There are no external dependencies other than the existence of the referenced file. The input to this snippet is the relative path to the .rst file, and the output is the inclusion of its contents into the generated piece of documentation at this location.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/whatsnew.rst#_snippet_2\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. _whatsnew_131:\n\n.. include:: whatsnew/v1.3.1.rst\n```\n\n----------------------------------------\n\nTITLE: Generating Class Documentation with Sphinx Directives in Jinja (Jinja + reStructuredText)\nDESCRIPTION: This snippet demonstrates the use of Jinja templating to produce reStructuredText (rST) documentation for Python classes and modules. It conditionally renders method and attribute lists using Sphinx's autodoc/autosummary features, filtering items for public display while ensuring autosummary generation. Dependencies include Sphinx, Jinja2, and reStructuredText, and the template expects variables such as objname, module, name, all_methods, and all_attributes in its context. No explicit input/output at runtime; this is a generation-time template.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/_templates/autosummary/class.rst#_snippet_0\n\nLANGUAGE: Jinja\nCODE:\n```\n{{ objname | escape | underline}}\\n\\n.. rubric:: *module* :mod:`{{ module }}`\\n\\n.. currentmodule:: {{ module }}\\n\\n.. autoclass:: {{ objname }}\\n\\n{% block methods %}\\n{% if methods %}\\n   .. HACK -- the point here is that we don't want this to appear in the output, but the autosummary should still generate the pages.\\n      .. autosummary::\\n\\n      {% for item in all_methods %}\\n         {%- if not item.startswith('_') or item in ['__call__'] %}\\n         {{ name }}.{{ item }}\\n         {%- endif -%}\\n      {%- endfor %}\\n{% endif %}\\n{% endblock %}\\n\\n{% block attributes %}\\n{% if attributes %}\\n   .. HACK -- the point here is that we don't want this to appear in the output, but the autosummary should still generate the pages.\\n      .. autosummary::\\n\\n      {% for item in all_attributes %}\\n         {%- if not item.startswith('_') %}\\n         {{ name }}.{{ item }}\\n         {%- endif -%}\\n      {%- endfor %}\\n{% endif %}\\n{% endblock %}\\n\\n   {% if methods or attributes %}\\n   ~~~~~~~~~~~~~~~~~~~~~~~~~~~\\n   {% endif %}\\n\n```\n\n----------------------------------------\n\nTITLE: Clipping Landslide Geospatial Data to Region of Interest (Python - Commented)\nDESCRIPTION: This commented-out block outlines the pre-processing steps applied to the original landslide data. It defines a Region of Interest (ROI) by buffering the bounding box of all pipes by 5000 ft. It then reads landslide data from a File Geodatabase (`KGS_Landslide_Inventory_exp.gdb`), clips it to the ROI using `geopandas.clip()`, and saves the result as a GeoJSON file (`data/ky10_landslide_data.geojson`) for use in the tutorial. This reduces data size.\nSOURCE: https://github.com/usepa/wntr/blob/main/examples/landslide_tutorial.ipynb#_snippet_12\n\nLANGUAGE: python\nCODE:\n```\n# To reduce the file size checked into the WNTR repository, the following code was run on the raw data file.\n# The region of interest (ROI) includes a 5000 ft buffer surrounding all pipes. The function `box` was imported from shapely.\n\"\"\"\nbounds = wn_gis.pipes.total_bounds # total_bounds returns the upper and lower bounds on x and y\ngeom = box(*bounds)\nROI = geom.buffer(5000) # feet\n\nlandslide_file = 'data/KGS_Landslide_Inventory_exp.gdb'\nlandslide_data = gpd.read_file(landslide_file, driver=\"FileGDB\", layer='Areas_derived_from_aerial_photography')\nprint(landslide_data.crs)\nlandslide_data = landslide_data.clip(ROI)\nlandslide_data.to_file(\"data/ky10_landslide_data.geojson\", index=True, driver='GeoJSON')\n\"\"\"\n```\n\n----------------------------------------\n\nTITLE: Structuring Document with LaTeX List Commands\nDESCRIPTION: These LaTeX commands are used to structure a document, specifically by clearing the page, adding phantom sections for correct hyperlinking, and inserting lists of tables and figures at the current location.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/acronyms.rst#_snippet_0\n\nLANGUAGE: latex\nCODE:\n```\n.. raw:: latex\n\n    \\clearpage\n\t\\phantomsection\n\t\\listoftables\n\t\\clearpage\n\t\\phantomsection\n\t\\listoffigures\n\t\\clearpage\n```\n\n----------------------------------------\n\nTITLE: Including Release Note Files Using reStructuredText Directives - reStructuredText\nDESCRIPTION: This snippet demonstrates how to include an external release note file (v0.2.3.rst) into the documentation using the reStructuredText (RST) '.. include::' directive, preceded by a Sphinx reference anchor for cross-referencing. There are no external dependencies other than the existence of the referenced file. The input to this snippet is the relative path to the .rst file, and the output is the inclusion of its contents into the generated piece of documentation at this location.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/whatsnew.rst#_snippet_13\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. _whatsnew_0230:\n\n.. include:: whatsnew/v0.2.3.rst\n```\n\n----------------------------------------\n\nTITLE: Setting Page Layout for Disclaimer - LaTeX - English\nDESCRIPTION: This LaTeX code snippet is used to reset the page layout by clearing the page and setting the section numbering depth to zero at the beginning of the disclaimer section. This prepares the documentation for a new, unnumbered section. The key parameter is \\setcounter{secnumdepth}{0}, which hides section numbers for the following sections. This code is intended for projects using Sphinx/rST with LaTeX output and requires the LaTeX compiler to process the raw directives. There are no inputs or outputs beyond formatting changes, and it is only effective in LaTeX contexts that support raw input.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/disclaimer.rst#_snippet_0\n\nLANGUAGE: latex\nCODE:\n```\n.. raw:: latex\n\n    \\clearpage\n    \\setcounter{secnumdepth}{0}\n\n```\n\n----------------------------------------\n\nTITLE: Including Release Note Files Using reStructuredText Directives - reStructuredText\nDESCRIPTION: This snippet demonstrates how to include an external release note file (v0.4.2.rst) into the documentation using the reStructuredText (RST) '.. include::' directive, preceded by a Sphinx reference anchor for cross-referencing. There are no external dependencies other than the existence of the referenced file. The input to this snippet is the relative path to the .rst file, and the output is the inclusion of its contents into the generated piece of documentation at this location.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/whatsnew.rst#_snippet_8\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. _whatsnew_042:\n\n.. include:: whatsnew/v0.4.2.rst\n```\n\n----------------------------------------\n\nTITLE: Configuring Clear Page and Bibliography Environment - LaTeX - reStructuredText\nDESCRIPTION: This snippet uses the reStructuredText raw directive with LaTeX to inject commands for clearing the page and starting a bibliography environment when building PDF outputs. '\\\\clearpage' ensures the references start on a new page. The '\\\\begingroup', custom section/chapter formatting, and '\\\\begin{thebibliography}{1234}' set up the LaTeX environment necessary for properly formatting references in the resulting PDF. No external dependencies beyond a LaTeX environment are needed; it is meant to be processed only by Sphinx builds targeting LaTeX/PDF output.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/reference.rst#_snippet_0\n\nLANGUAGE: LaTeX\nCODE:\n```\n.. raw:: latex\n\n    \\\\clearpage\n\n```\n\nLANGUAGE: LaTeX\nCODE:\n```\n.. raw:: latex\n\n    \\\\begingroup\n    \\\\def\\\\section#1#2{}\n    \\\\def\\\\chapter#1#2{}\n    \\\\begin{thebibliography}{1234}\n\n```\n\nLANGUAGE: LaTeX\nCODE:\n```\n.. raw:: latex\n\n    \\\\end{thebibliography}\n    \\\\endgroup\n\n```\n\n----------------------------------------\n\nTITLE: Inserting Vertical Space in Documentation - LaTeX - English\nDESCRIPTION: This LaTeX code snippet inserts 5mm of vertical space using the \\vspace{5 mm} directive. It is used within a raw LaTeX block in reStructuredText documentation, typically for spacing disclaimer or attribution sections for clarity and separation from other content. It requires a LaTeX-compatible documentation build process, such as Sphinx with a LaTeX builder. There are no parameters or outputs other than additional vertical space in the PDF or printed output.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/disclaimer.rst#_snippet_2\n\nLANGUAGE: latex\nCODE:\n```\n.. raw:: latex\n\n    \\vspace{5 mm}\n\n```\n\n----------------------------------------\n\nTITLE: Embedding HTML Content Within Documentation - HTML in reStructuredText\nDESCRIPTION: This snippet uses the raw directive to directly insert HTML markup (a <div>) into the rendered output, enabling further customization or integration with web-based layouts. It functions only in HTML output contexts and depends on the Sphinx builder recognizing raw HTML blocks. The use of this block allows for additional reference content or interactive sections to be added to the HTML documentation.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/reference.rst#_snippet_2\n\nLANGUAGE: HTML\nCODE:\n```\n.. raw:: html\n\n    <div>\n\n```\n\n----------------------------------------\n\nTITLE: Including Release Note Files Using reStructuredText Directives - reStructuredText\nDESCRIPTION: This snippet demonstrates how to include an external release note file (v0.2.2.rst) into the documentation using the reStructuredText (RST) '.. include::' directive, preceded by a Sphinx reference anchor for cross-referencing. There are no external dependencies other than the existence of the referenced file. The input to this snippet is the relative path to the .rst file, and the output is the inclusion of its contents into the generated piece of documentation at this location.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/whatsnew.rst#_snippet_15\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. _whatsnew_0220:\n\n.. include:: whatsnew/v0.2.2.rst\n```\n\n----------------------------------------\n\nTITLE: Including LaTeX Raw Directive in Sphinx Documentation (reStructuredText)\nDESCRIPTION: This snippet uses the '.. raw:: latex' reStructuredText directive to inject raw LaTeX commands into Sphinx-generated documentation. It allows advanced users to control PDF outputs by supplying custom LaTeX code blocks directly. In this usage, '\\\\clearpage' is issued to force a new page in LaTeX/PDF builds. Requires Sphinx configured with LaTeX output; effective only in LaTeX/PDF builds and ignored in HTML builds.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/users.rst#_snippet_0\n\nLANGUAGE: restructuredtext\nCODE:\n```\n.. raw:: latex\\n\\n    \\\\clearpage\n```\n\n----------------------------------------\n\nTITLE: Including Release Note Files Using reStructuredText Directives - reStructuredText\nDESCRIPTION: This snippet demonstrates how to include an external release note file (v0.4.1.rst) into the documentation using the reStructuredText (RST) '.. include::' directive, preceded by a Sphinx reference anchor for cross-referencing. There are no external dependencies other than the existence of the referenced file. The input to this snippet is the relative path to the .rst file, and the output is the inclusion of its contents into the generated piece of documentation at this location.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/whatsnew.rst#_snippet_9\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. _whatsnew_041:\n\n.. include:: whatsnew/v0.4.1.rst\n```\n\n----------------------------------------\n\nTITLE: Defining Documentation Dependencies for WNTR\nDESCRIPTION: Specifies Python packages required for building the project's documentation. This includes Sphinx as the documentation generator, various themes (sphinx_design, sphinx_rtd_theme, pydata_sphinx_theme), and a bibliography extension (sphinxcontrib-bibtex).\nSOURCE: https://github.com/usepa/wntr/blob/main/requirements.txt#_snippet_2\n\nLANGUAGE: requirements\nCODE:\n```\n# Documentation\nsphinx\nsphinx_design\nsphinx_rtd_theme\npydata_sphinx_theme\nsphinxcontrib-bibtex\n```\n\n----------------------------------------\n\nTITLE: Defining Testing Dependencies for WNTR\nDESCRIPTION: Lists Python packages needed for running the project's test suite. This includes the pytest testing framework, tools for handling Jupyter notebooks (nbformat, nbconvert, ipykernel), and code coverage analysis (coverage).\nSOURCE: https://github.com/usepa/wntr/blob/main/requirements.txt#_snippet_3\n\nLANGUAGE: requirements\nCODE:\n```\n# Testing\npytest\nnbformat\nnbconvert\nipykernel\ncoverage\n```\n\n----------------------------------------\n\nTITLE: Rendering Sphinx Autodoc Template Blocks with Jinja - Jinja\nDESCRIPTION: This code snippet is a Jinja template that structures Sphinx-generated documentation for a Python module. It conditionally generates reStructuredText sections for module attributes, functions, classes, exceptions, and submodules using Jinja block and control statements. The snippet depends on Sphinx, the autosummary extension, and template configuration within a Python documentation workflow. Inputs are Python module elements extracted by Sphinx, while outputs are formatted .rst files for documentation. Limitations include reliance on correct Sphinx and Jinja setup and the presence of module members for rendering.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/_templates/autosummary/module.rst#_snippet_0\n\nLANGUAGE: jinja\nCODE:\n```\n{{ fullname | escape | underline}}\n\n.. automodule:: {{ fullname }}\n   :exclude-members: {% for item in attributes %}{{ item }}, {% endfor %}{% for item in functions %}{{ item }}, {% endfor %}{% for item in classes %}{{ item }}, {% endfor %}{% for item in exceptions %}{{ item }}, {% endfor %}\n\n   {% block attributes %}\n   {% if attributes %}\n   .. rubric:: {{ _('Module Attributes') }}\n\n   .. autosummary::\n      :toctree:\n      :template: autosummary/base.rst\n   {% for item in attributes %}\n      {{ item }}\n   {%- endfor %}\n   {% endif %}\n   {% endblock %}\n\n   {% block functions %}\n   {% if functions %}\n   .. rubric:: {{ _('Functions') }}\n\n   .. autosummary::\n      :nosignatures:\n      :toctree:\n      :template: autosummary/base.rst\n   {% for item in functions %}\n      {{ item }}\n   {%- endfor %}\n   {% endif %}\n   {% endblock %}\n\n   {% block classes %}\n   {% if classes %}\n   .. rubric:: {{ _('Classes') }}\n\n   .. autosummary::\n      :nosignatures:\n      :toctree:\n      :template: autosummary/class.rst\n   {% for item in classes %}\n      {{ item }}\n   {%- endfor %}\n   {% endif %}\n   {% endblock %}\n\n   {% block exceptions %}\n   {% if exceptions %}\n   .. rubric:: {{ _('Exceptions') }}\n\n   .. autosummary::\n      :nosignatures:\n      :toctree:\n      :template: autosummary/exception.rst\n   {% for item in exceptions %}\n      {{ item }}\n   {%- endfor %}\n   {% endif %}\n   {% endblock %}\n\n{% block modules %}\n{% if modules %}\n.. rubric:: Modules\n\n.. autosummary::\n   :toctree:\n   :recursive:\n   :template: autosummary/module.rst\n{% for item in modules %}\n   {{ item }}\n{%- endfor %}\n{% endif %}\n{% endblock %}\n```\n\n----------------------------------------\n\nTITLE: Including Release Note Files Using reStructuredText Directives - reStructuredText\nDESCRIPTION: This snippet demonstrates how to include an external release note file (v0.3.0.rst) into the documentation using the reStructuredText (RST) '.. include::' directive, preceded by a Sphinx reference anchor for cross-referencing. There are no external dependencies other than the existence of the referenced file. The input to this snippet is the relative path to the .rst file, and the output is the inclusion of its contents into the generated piece of documentation at this location.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/whatsnew.rst#_snippet_12\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. _whatsnew_0330:\n\n.. include:: whatsnew/v0.3.0.rst\n```\n\n----------------------------------------\n\nTITLE: Providing Copyright Notice - License Documentation - None\nDESCRIPTION: This snippet provides the official copyright statement for the WNTR Python package, including the intellectual property holder, contract identification, and reservation of government rights. It must be included in redistributions to comply with project and governing body requirements. There are no dependencies or parameters, and the input and output are static legal text; modification or omission may violate license terms.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/license.rst#_snippet_0\n\nLANGUAGE: none\nCODE:\n```\nCopyright 2024 National Technology & Engineering Solutions of Sandia, \nLLC (NTESS). Under the terms of Contract DE-NA0003525 with NTESS, the U.S. \nGovernment retains certain rights in this software.\n```\n\n----------------------------------------\n\nTITLE: Providing Revised BSD License Terms - License Documentation - None\nDESCRIPTION: This snippet records the complete Revised BSD License text dictating conditions for redistribution and use of the WNTR software in both source and binary forms. It outlines obligations, disclaimers, limitations of liability, and requirements for endorsement or promotion. The snippet is to be included verbatim in documentation or other accompanying materials and should not be altered; failure to include it may affect the legal status of distribution or use.\nSOURCE: https://github.com/usepa/wntr/blob/main/documentation/license.rst#_snippet_1\n\nLANGUAGE: none\nCODE:\n```\n\tRedistribution and use in source and binary forms, with or without\n\tmodification, are permitted provided that the following conditions\n\tare met:\n\n\t* Redistributions of source code must retain the above copyright notice, this \n\t  list of conditions and the following disclaimer.\n\t* Redistributions in binary form must reproduce the above copyright notice, \n\t  this list of conditions and the following disclaimer in the documentation \n\t  and/or other materials provided with the distribution.\n\t* Neither the name of Sandia National Laboratories, nor the names of\n\t  its contributors may be used to endorse or promote products derived from\n\t  this software without specific prior written permission.\n\n\tTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\t\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n\tLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n\tA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n\tOWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n\tSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED\n\tTO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n\tPROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n\tLIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n\tNEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n\tSOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n```"
  }
]