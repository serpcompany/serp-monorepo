[
  {
    "owner": "visgl",
    "repo": "math.gl",
    "content": "TITLE: Constructing WebMercatorViewport Instances in JavaScript\nDESCRIPTION: Demonstrates constructing a WebMercatorViewport class with options for width, height, center coordinates, zoom, pitch, bearing, field of view, and camera position. The constructor interprets and sets defaults for parameters as per mapping standards, computing missing altitude or field of view if not provided. It ensures valid viewport dimensions and proper parameter handling, forming the basis for accurate map rendering and interaction.\nSOURCE: https://github.com/visgl/math.gl/blob/master/docs/modules/web-mercator/api-reference/web-mercator-viewport.md#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nconst viewport = new WebMercatorViewport({\n  width: 800,\n  height: 600,\n  latitude: 37.7749,\n  longitude: -122.4194,\n  zoom: 10,\n  pitch: 0,\n  bearing: 0\n  // fovy, altitude, and position can be optionally set\n});\n```\n\n----------------------------------------\n\nTITLE: Fitting a Viewport to Bounds Using fitBounds in WebMercatorViewport (JavaScript)\nDESCRIPTION: Demonstrates how to use fitBounds to create a new WebMercatorViewport instance adjusted to fit a given bounding box, with options for padding, offset, minimum extent, and maximum zoom. The method ensures that geographic data of interest is optimally visible within the viewport and that padding constraints are respected.\nSOURCE: https://github.com/visgl/math.gl/blob/master/docs/modules/web-mercator/api-reference/web-mercator-viewport.md#_snippet_6\n\nLANGUAGE: JavaScript\nCODE:\n```\nconst fittedViewport = viewport.fitBounds([\n  [west, south],\n  [east, north]\n], {padding: 20, offset: [0,0], minExtent: 0.01, maxZoom: 24});\n```\n\n----------------------------------------\n\nTITLE: Creating a Perspective Projection Matrix with Matrix4 in JavaScript\nDESCRIPTION: Demonstrates constructing a perspective projection matrix using Matrix4's perspective method, which accepts parameters for field of view, aspect ratio, near, and far clipping planes. This method is essential for 3D rendering pipelines that require transformation from camera space to clip space. The resulting matrix is typically passed to shaders or other transformation routines. The snippet assumes variables fov, aspect, near, and far are defined in the surrounding context.\nSOURCE: https://github.com/visgl/math.gl/blob/master/docs/modules/core/api-reference/matrix4.md#_snippet_2\n\nLANGUAGE: JavaScript\nCODE:\n```\nconst projectionMatrix = new Matrix4().perspective({fov, aspect, near, far});\n```\n\n----------------------------------------\n\nTITLE: Creating a Perspective Projection Matrix with math.gl Matrix4.perspective (JavaScript)\nDESCRIPTION: Creates a 4x4 perspective projection matrix using `Matrix4.perspective`. It maps geometry within a view frustum (defined by field of view `fov`, `aspect` ratio, and `near`/`far` clipping planes) into normalized device coordinates (clipspace), suitable for GPU rendering. This simulates how objects appear smaller further away.\nSOURCE: https://github.com/visgl/math.gl/blob/master/docs/developer-guide/math/view-and-projection.md#_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nMatrix4.perspective({fov, aspect, near, far})\n```\n\n----------------------------------------\n\nTITLE: Projecting LngLat Offsets to Pixels (High Precision) - GLSL\nDESCRIPTION: This GLSL function enhances the accuracy of projecting longitude/latitude offsets to pixel offsets by incorporating a second uniform (unitsPerDegree2) to compensate for projection distortion with latitude. It is designed for use with math.gl\\'s getDistanceScales(highPrecision: true) and requires both unitsPerDegree and unitsPerDegree2 uniforms. Inputs are expected as a vec3 lngLatZ; output is a higher-accuracy pixel offset (vec3).\nSOURCE: https://github.com/visgl/math.gl/blob/master/docs/developer-guide/geospatial/web-mercator-offset-accuracy.md#_snippet_3\n\nLANGUAGE: GLSL\nCODE:\n```\nuniform vec3 unitsPerDegree;\nuniform vec3 unitsPerDegree2;\nvec3 lnglat_offset_to_pixels_offset_adjusted(vec3 lngLatZ) {\n    return lngLatZ * (unitsPerDegree + unitsPerDegree2 * lngLatZ.y);\n}\n```\n\n----------------------------------------\n\nTITLE: Converting Cartesian to Cartographic Coordinates with Ellipsoid.WGS84 - JavaScript\nDESCRIPTION: This snippet converts a Cartesian coordinate (x, y, z) to a cartographic representation (longitude, latitude, height) on a WGS84 ellipsoid, using the Ellipsoid.WGS84 class from @math.gl/geospatial. Only the @math.gl/geospatial package is required. The input is a numeric array representing the point in 3D space, and the output is an array with geodetic longitude, latitude, and height. Outputs longitude/latitude in radians.\nSOURCE: https://github.com/visgl/math.gl/blob/master/docs/modules/geospatial/README.md#_snippet_1\n\nLANGUAGE: js\nCODE:\n```\nimport {Ellipsoid} from '@math.gl/geospatial';\nconst cartesianPosition = [17832.12, 83234.52, 952313.73];\nconst cartographicPosition = Ellipsoid.WGS84.cartesianToCartographic(cartesianPosition);\n```\n\n----------------------------------------\n\nTITLE: Finding Map Center for Desired Screen Position with WebMercatorViewport in JavaScript\nDESCRIPTION: Uses getMapCenterByLngLatPosition to calculate the longitude and latitude map center that would align a given geographic coordinate to a specific screen pixel. This is important for custom navigation, centering UI, or implementing interactive map features where a particular location must be positioned at a designated viewport point.\nSOURCE: https://github.com/visgl/math.gl/blob/master/docs/modules/web-mercator/api-reference/web-mercator-viewport.md#_snippet_7\n\nLANGUAGE: JavaScript\nCODE:\n```\nconst newCenter = viewport.getMapCenterByLngLatPosition({lngLat: [lng, lat], pos: [x, y]});\n```\n\n----------------------------------------\n\nTITLE: Using WebMercatorViewport for Coordinate Projection (JavaScript)\nDESCRIPTION: This JavaScript example demonstrates importing and using the `WebMercatorViewport` class from the `@math.gl/web-mercator` module. It initializes a viewport with specific dimensions and camera parameters (location, zoom, pitch, bearing) centered on San Francisco. It then shows how to use the `project` method to convert geographic coordinates (longitude, latitude) to screen pixel coordinates and the `unproject` method to perform the reverse conversion.\nSOURCE: https://github.com/visgl/math.gl/blob/master/docs/modules/web-mercator/README.md#_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport WebMercatorViewport from '@math.gl/web-mercator';\n\n// A viewport looking at San Francisco city area\nconst viewport = new WebMercatorViewport({\n  width: 800,\n  height: 600,\n  longitude: -122.45,\n  latitude: 37.78,\n  zoom: 12,\n  pitch: 60,\n  bearing: 30\n});\n\nviewport.project([-122.45, 37.78]);\n// returns pixel coordinates [400, 300]\nviewport.unproject([400, 300]);\n// returns map coordinates [-122.45, 37.78]\n```\n\n----------------------------------------\n\nTITLE: Creating a View Matrix with math.gl Matrix4.lookAt (JavaScript)\nDESCRIPTION: Creates a 4x4 view matrix using the `Matrix4.lookAt` method from the math.gl library. This matrix transforms world coordinates into view coordinates, positioning the camera (eye) at the origin `[0, 0, 0]`, looking down the positive Z-axis, and oriented with a specified 'up' direction. The parameters typically define the eye position, the point to look at, and the up vector.\nSOURCE: https://github.com/visgl/math.gl/blob/master/docs/developer-guide/math/view-and-projection.md#_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nMatrix4.lookAt({...})\n```\n\n----------------------------------------\n\nTITLE: Clipping Polylines with clipPolyline using math.gl in JavaScript\nDESCRIPTION: This code demonstrates how to use the clipPolyline function from the @math.gl/polygon package to trim a polyline to a specified 2D bounding box. It imports the function, defines a polyline and a bounding box, and shows the resulting clipped polyline. The code requires installing @math.gl/polygon and expects all parameters as flat vertex arrays, with an optional options object (such as specifying the dimension size). The function returns an array of polylines that reside within the bounding box and returns an empty array if the input polyline falls completely outside.\nSOURCE: https://github.com/visgl/math.gl/blob/master/docs/modules/polygon/api-reference/clip-polyline.md#_snippet_0\n\nLANGUAGE: js\nCODE:\n```\nimport {clipPolyline} from '@math.gl/polygon';\n\nclipPolyline([-10, -10, 10, 10, 30, -10], [0, 0, 20, 20], {size: 2});\n// returns [[0, 0, 10, 10, 20, 0]]\n```\n\n----------------------------------------\n\nTITLE: Creating an Orthographic Projection Matrix (Box Extents) with math.gl Matrix4.ortho (JavaScript)\nDESCRIPTION: Generates a 4x4 orthographic projection matrix using `Matrix4.ortho`. This method defines the viewing volume as a rectangular box specified by its `left`, `right`, `top`, `bottom`, `near`, and `far` extents in view space coordinates. It maps geometry within this box to clipspace using parallel projection, without perspective distortion.\nSOURCE: https://github.com/visgl/math.gl/blob/master/docs/developer-guide/math/view-and-projection.md#_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nMatrix4.ortho({right, left, top, bottom, near, far})\n```\n\n----------------------------------------\n\nTITLE: Projecting Geographic Coordinates to Screen Pixels via WebMercatorViewport in JavaScript\nDESCRIPTION: Shows usage of the project method to convert longitude and latitude (with optional elevation) into pixel coordinates on screen, using the topLeft option to specify coordinate origin. Accepts [lng, lat] or [lng, lat, Z] arrays and returns corresponding [x, y] or [x, y, z] pixel values according to Web Mercator projection, which is suitable for canvas and SVG rendering.\nSOURCE: https://github.com/visgl/math.gl/blob/master/docs/modules/web-mercator/api-reference/web-mercator-viewport.md#_snippet_1\n\nLANGUAGE: JavaScript\nCODE:\n```\nconst pixel = viewport.project([lng, lat], {topLeft: true});\nconst pixel3D = viewport.project([lng, lat, z], {topLeft: false});\n```\n\n----------------------------------------\n\nTITLE: Importing and Initializing a Vector3 Instance with math.gl in JavaScript\nDESCRIPTION: This snippet demonstrates how to import the Vector3 class from the '@math.gl/core' package and instantiate a new vector. Dependencies include the '@math.gl/core' package. Parameters are the x, y, and z components, and the resulting object can be used for further vector operations as described in the API.\nSOURCE: https://github.com/visgl/math.gl/blob/master/docs/modules/core/api-reference/vector3.md#_snippet_1\n\nLANGUAGE: js\nCODE:\n```\nimport {Vector3} from '@math.gl/core';\nconst vector = new Vector3(1, 1, 1);\n```\n\n----------------------------------------\n\nTITLE: Importing and Using cutPolygonByMercatorBounds (Math.gl, JavaScript)\nDESCRIPTION: This JavaScript snippet shows how to import and invoke cutPolygonByMercatorBounds from the @math.gl/polygon library, passing a flat array representing a polygon's vertices (longitude and latitude) along with an options object specifying the size parameter. The function splits polygons at the 180 meridian and latitude limits, returning an array of polygons with updated vertices. Dependencies: '@math.gl/polygon' must be installed. The snippet demonstrates handling of crossing edges, and the returned structure contains the positions of new polygons split by geographic bounds.\nSOURCE: https://github.com/visgl/math.gl/blob/master/docs/modules/polygon/api-reference/cut-polygon-by-mercator-bounds.md#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport {cutPolygonByMercatorBounds} from '@math.gl/polygon';\n\ncutPolygonByMercatorBounds([-170, 0, 170, 0, 170, 20, -170, 20], {size: 2});\n// returns [\n//   [170, 20, 180, 20, 180, 0, 170, 0],\n//   [-180, 20, -170, 20, -170, 0, -180, 0]\n// ]\n]\n```\n\n----------------------------------------\n\nTITLE: Computing Bounding Volume Visibility against CullingVolume in JavaScript\nDESCRIPTION: The computeVisibility method tests if a given bounding volume is inside, outside, or intersecting the culling volume. It returns one of INTERSECTION.OUTSIDE, INTERSECTION.INTERSECTING, or INTERSECTION.INSIDE. Requires valid bounding volume and culling planes; useful for traversal and optimization in rendering engines. Input is a bounding volume object; output is an enumeration indicating intersection status.\nSOURCE: https://github.com/visgl/math.gl/blob/master/docs/modules/culling/api-reference/culling-volume.md#_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\n/*\ncomputeVisibility(boundingVolume : Object) : Interset\nDetermines whether a bounding volume intersects the culling volume.\n- `boundingVolume` The bounding volume whose intersection with the culling volume is to be tested.\nReturns:\n- `INTERSECTION.OUTSIDE`, `INTERSECTION.INTERSECTING`, or `INTERSECTION.INSIDE`.\n*/\n```\n\n----------------------------------------\n\nTITLE: Importing Matrix4 from math.gl in JavaScript\nDESCRIPTION: Demonstrates how to import the Matrix4 class from the math.gl library using an ECMAScript import statement. This dependency is required for all subsequent examples and is the fundamental prerequisite for using Matrix4 APIs within a JavaScript/TypeScript project. The imported class provides methods for matrix manipulation, projections, and transformations.\nSOURCE: https://github.com/visgl/math.gl/blob/master/docs/modules/core/api-reference/matrix4.md#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport {Matrix4} from `math.gl`;\n```\n\n----------------------------------------\n\nTITLE: cutPolygonByMercatorBounds Function Call with Arguments (Math.gl, JavaScript)\nDESCRIPTION: This snippet provides the function call signature for cutPolygonByMercatorBounds, demonstrating its usage with input positions, hole indices, and optional options object. The snippet is meant to illustrate the flexible arguments of the API, which supports both simple and complex polygons (with or without holes), and allows configuration via the options parameter. This serves as a template for calling the function with customized input data.\nSOURCE: https://github.com/visgl/math.gl/blob/master/docs/modules/polygon/api-reference/cut-polygon-by-mercator-bounds.md#_snippet_1\n\nLANGUAGE: JavaScript\nCODE:\n```\ncutPolygonByMercatorBounds(positions, holeIndices, [options]);\n```\n\n----------------------------------------\n\nTITLE: Interpolating Between Quaternions using slerp() in math.gl (JavaScript)\nDESCRIPTION: This code snippet shows how to interpolate between two quaternion rotations using spherical linear interpolation (slerp) in JavaScript with math.gl. The example creates unit and target Quaternion instances, then iteratively computes an intermediate Quaternion by interpolating between them for ratios in [0, 1). This is especially useful for smoothly blending or animating orientations in 3D graphics. Dependencies include the math.gl Quaternion module; inputs are the two quaternion endpoints and a ratio (0-1), and outputs are interpolated quaternion instances. The main constraint is that both quaternions should be normalized (unit quaternions) to ensure valid interpolation.\nSOURCE: https://github.com/visgl/math.gl/blob/master/docs/developer-guide/math/rotations.md#_snippet_1\n\nLANGUAGE: JavaScript\nCODE:\n```\n  const qUnit = new Quaternion();\n  const qTarget = new Quaternion(...);\n\n  for (let ratio = 0; ratio < 1.0; ratio += 0.1) {\n  \tconst qInterpolated = new Quaternion().slerp(qUnit, qTarget, ratio);\n  }\n```\n\n----------------------------------------\n\nTITLE: Initializing Vector4 Instances in JavaScript\nDESCRIPTION: Demonstrates importing the Vector4 class from '@math.gl/core' and creating instances. A vector is created with w=0, and a point is created with w=1, illustrating its use in projective space representation as described in the surrounding text. Requires the '@math.gl/core' package.\nSOURCE: https://github.com/visgl/math.gl/blob/master/docs/modules/core/api-reference/vector4.md#_snippet_0\n\nLANGUAGE: js\nCODE:\n```\nimport {Vector4} from '@math.gl/core';\nconst vector = new Vector4(1, 1, 1, 0);\nconst point = new Vector4(0, 0, 0, 1);\n```\n\n----------------------------------------\n\nTITLE: Composing and Applying Complex Transformations with Matrix4 in math.gl (JavaScript)\nDESCRIPTION: This example illustrates the chaining of transformations using Matrix4 class methods like scale, multiplyRight, and rotateX to build a composite transformation. The snippet shows correct order-of-operations and demonstrates in-place modification of the Matrix4 instance, as well as transforming a Vector4. Dependencies: math.gl Matrix4 and Vector4. The input transformation matrices and operations must be applied in the intended order, and values must be valid as per geometric expectations.\nSOURCE: https://github.com/visgl/math.gl/blob/master/docs/developer-guide/math/transformations.md#_snippet_4\n\nLANGUAGE: JavaScript\nCODE:\n```\n// Illustrates that transformations are applied in reverse order\nconst partialTransform = new Matrix4(...);\nconst fullTransform = new Matrix4()\n  .scale([1, -1, 1])\n  .multiplyRight(partialTransform)\n  .rotateX({radians: Math.PI});\nconst v = fullTransform.transformVector(new Vector4(...));\n```\n\n----------------------------------------\n\nTITLE: Transforming Vectors as Points with Matrix3 (JavaScript)\nDESCRIPTION: Illustrates transforming 2D and 3D vectors as points using the `transformPoint` method of a Matrix3 instance. This transformation includes any translation components defined in the matrix.\nSOURCE: https://github.com/visgl/math.gl/blob/master/docs/modules/core/api-reference/matrix3.md#_snippet_3\n\nLANGUAGE: js\nCODE:\n```\nconst transform = new Matrix3();\nconst vector2 = transform.transformPoint([1, 2]);\nconst vector3 = transform.transformPoint([1, 2, 1]);\n```\n\n----------------------------------------\n\nTITLE: Configuring Debug Checks in math.gl (JavaScript)\nDESCRIPTION: This snippet illustrates how to enable or disable debug checks using the `configure` function from `@math.gl/core`. Disabling checks (`{debug: false}`) can improve performance slightly but allows potentially invalid objects (like `Vector2` with `NaN` components) to be created without error. Enabling checks (`{debug: true}`) enforces validation and will throw errors for such invalid objects.\nSOURCE: https://github.com/visgl/math.gl/blob/master/docs/developer-guide/performance.md#_snippet_0\n\nLANGUAGE: js\nCODE:\n```\nimport {configure, Vector2} from '@math.gl/core';\nconfigure({debug: false});\nlet vector = new Vector2(NaN, NaN); // Initializes an \"invalid\" vector\n\nconfigure({debug: true});\nlet vector = new Vector2(NaN, NaN); // Now throws an error. The check\n```\n\n----------------------------------------\n\nTITLE: Transforming Vectors using Matrix4.transformPoint in JavaScript\nDESCRIPTION: Demonstrates using the transformPoint method on a Matrix4 instance to transform vectors, including translation (affine transformation). This is commonly used for transforming points in 2D or 3D space, such as converting coordinates via model, view, or projection matrices. The method accepts vectors of size 2, 3, or 4 (homogeneous), and returns the transformed vector in the same or higher dimension.\nSOURCE: https://github.com/visgl/math.gl/blob/master/docs/modules/core/api-reference/matrix4.md#_snippet_4\n\nLANGUAGE: JavaScript\nCODE:\n```\nconst transform = new Matrix4();\nconst vector2 = transform.transformPoint([0, 0]);\nconst vector3 = transform.transformPoint([0, 1, 2]);\nconst vector4 = transform.transformPoint([0, 1, 2, 1]);\n```\n\n----------------------------------------\n\nTITLE: Applying Matrix and Quaternion Transformations with math.gl in JavaScript\nDESCRIPTION: These examples show how to transform a Vector4 instance via a 4x4 matrix, either using a raw array or a Matrix4 instance, leveraging math.gl. The transform method modifies the object in place and returns it for chaining. The code assumes the math.gl Vector4 and Matrix4 classes are available, and the transformation matrices must be in column-major order as required by math.gl.\nSOURCE: https://github.com/visgl/math.gl/blob/master/docs/developer-guide/math/transformations.md#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\n// prettier-ignore\nconst transformedVector1 = new Vector4(1, 0, 0, 1).transform([\n  1, 0, 0, 0,\n  0, 1, 0, 0,\n  0, 0, 1, 0,\n  0, 0, 0, 1\n]);\n// or\nconst transformedVector2 = new Vector4(1, 0, 0, 1).transform(\n  new Matrix4([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1])\n);\n```\n\n----------------------------------------\n\nTITLE: Importing and Using clipPolygon from @math.gl/polygon in JavaScript\nDESCRIPTION: This snippet demonstrates how to import the `clipPolygon` function from the '@math.gl/polygon' library and provides an example usage. It shows clipping a polygon defined by vertices `[-10, -10, 10, 10, 30, -10, -10, -10]` against a bounding box `[0, 0, 20, 20]`. The `{size: 2}` option indicates that the input vertices are 2D coordinates. The returned array `[0, 0, 10, 10, 20, 0, 0, 0]` represents the vertices of the resulting clipped polygon. Note: The example code uses `clipPolyline`, but the context refers to `clipPolygon`.\nSOURCE: https://github.com/visgl/math.gl/blob/master/docs/modules/polygon/api-reference/clip-polygon.md#_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n```js\nimport {clipPolygon} from '@math.gl/polygon';\n\nclipPolyline([-10, -10, 10, 10, 30, -10, -10, -10], [0, 0, 20, 20], {size: 2});\n// returns [0, 0, 10, 10, 20, 0, 0, 0]\n```\n```\n\n----------------------------------------\n\nTITLE: Constructing SphericalCoordinates Objects with Various Parameter Sets in JavaScript\nDESCRIPTION: Documents the constructor API signatures for SphericalCoordinates, supporting spherical, camera, and geographic parameter styles. Parameters can be phi/theta/radius, bearing/pitch/altitude, or longitude/latitude/z. Defaults: phi=0, theta=0, radius=1.0. Inputs should be objects with named properties; outputs are initialized SphericalCoordinates instances.\nSOURCE: https://github.com/visgl/math.gl/blob/master/docs/modules/core/api-reference/spherical-coordinates.md#_snippet_5\n\nLANGUAGE: js\nCODE:\n```\nSphericalCoordinates({phi = 0, theta = 0, radius = 1.0})\nSphericalCoordinates({bearing = 0, pitch = 0, altitude = 1.0})\nSphericalCoordinates({longitude = 0, latitude = 0, z = 1.0})\n\n```\n\n----------------------------------------\n\nTITLE: Function Signature for cutPolylineByMercatorBounds in JavaScript\nDESCRIPTION: Provides the function signature for `cutPolylineByMercatorBounds`. It accepts a mandatory `positions` array (flat vertex coordinates) and an optional `options` object. Key options include `size` (number of elements per vertex, default 2), `startIndex` and `endIndex` (to process a subset of `positions`), and `normalize` (to ensure output longitudes are within [-180, 180], default true).\nSOURCE: https://github.com/visgl/math.gl/blob/master/docs/modules/polygon/api-reference/cut-polyline-by-mercator-bounds.md#_snippet_1\n\nLANGUAGE: js\nCODE:\n```\ncutPolylineByMercatorBounds(positions, [options]);\n```\n\n----------------------------------------\n\nTITLE: Converting Cartographic to Cartesian Coordinates using Ellipsoid.WGS84 in JavaScript\nDESCRIPTION: This snippet demonstrates how to convert a geographic position defined in cartographic coordinates (longitude, latitude, height) into Cartesian (X, Y, Z) coordinates. It utilizes the pre-defined `Ellipsoid.WGS84` constant and its `cartographicToCartesian` method. Longitude and latitude must be converted to radians using `toRadians` from `@math.gl/core` before being passed to the method.\nSOURCE: https://github.com/visgl/math.gl/blob/master/docs/modules/geospatial/api-reference/ellipsoid.md#_snippet_0\n\nLANGUAGE: js\nCODE:\n```\nimport {toRadians} from '@math.gl/core';\nimport {Ellipsoid} from '@math.gl/geospatial';\nconst cartographicPosition = [toRadians(21), toRadians(78), 5000];\nconst cartesianPosition = Ellipsoid.WGS84.cartographicToCartesian(cartographicPosition);\n```\n\n----------------------------------------\n\nTITLE: Creating a Bounding Sphere from Corner Points - math.gl - JavaScript\nDESCRIPTION: This snippet demonstrates how to create a BoundingSphere object around a unit cube by using the fromCornerPoints method provided by the math.gl/culling library. It imports the BoundingSphere class, then initializes a new BoundingSphere, specifying two diagonal corners of the axis-aligned bounding box. The snippet assumes that math.gl/culling is installed as a dependency and requires that the input points are in [x, y, z] array format. Inputs are the minimum and maximum corner points; output is a BoundingSphere instance representing the tightest sphere around the box. Note: the code contains a typo ('cont' should be 'const') and should be corrected before execution.\nSOURCE: https://github.com/visgl/math.gl/blob/master/docs/modules/culling/api-reference/bounding-sphere.md#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport {BoundingSphere} from '@math.gl/culling';\ncont sphere = new BoundingSphere().fromCornerPoints(\n  [-0.5, -0.5, -0.5],\n  [0.5, 0.5, 0.5]\n);\n```\n\n----------------------------------------\n\nTITLE: Manipulating SphericalCoordinates Properties in JavaScript\nDESCRIPTION: Demonstrates common ways to modify an existing SphericalCoordinates object by updating its bearing and theta properties. These operations affect the spherical orientation in place. Inputs are numeric changes applied directly to the object properties. No return value as operations are in-place.\nSOURCE: https://github.com/visgl/math.gl/blob/master/docs/modules/core/api-reference/spherical-coordinates.md#_snippet_4\n\nLANGUAGE: js\nCODE:\n```\nspherical.bearing += 3; // Add three degrees to bearing\nspherical.theta -= Math.PI / 4; // Subtract PI/4 radians from theta.\n\n```\n\n----------------------------------------\n\nTITLE: Instantiating Euler Rotations in math.gl (JavaScript)\nDESCRIPTION: This snippet demonstrates how to create new Euler rotation objects using the math.gl Euler class in JavaScript. Users can instantiate Euler objects with zero or more parameters, depending on the desired initial orientation. This is foundational for further manipulation, conversion to other formats, or application to 3D transformations. Inputs are optional, but users should be aware of conventions such as axis order and angle interpretation based on the math.gl Euler implementation.\nSOURCE: https://github.com/visgl/math.gl/blob/master/docs/developer-guide/math/rotations.md#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nnew Euler();\nnew Euler();\n```\n\n----------------------------------------\n\nTITLE: Importing and Using cutPolygonByGrid in JavaScript\nDESCRIPTION: Demonstrates how to import the `cutPolygonByGrid` function from `@math.gl/polygon` and use it to subdivide a simple polygon defined by vertex positions. The example specifies a vertex size of 2 (x, y coordinates) and a grid resolution of 20, resulting in an array of subdivided polygons.\nSOURCE: https://github.com/visgl/math.gl/blob/master/docs/modules/polygon/api-reference/cut-polygon-by-grid.md#_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {cutPolygonByGrid} from '@math.gl/polygon';\n\ncutPolygonByGrid([0, 15, 15, 0, 0, -15, 0, 15], {size: 2, gridResolution: 20});\n// returns [\n//   [15, 0, 0, -15, 0, 0, 15, 0],\n//   [15, 0, 0, 0, 0, 15, 15, 0]\n// ]\n```\n\n----------------------------------------\n\nTITLE: Transforming a Vector as a Direction Using Matrix4 in JavaScript\nDESCRIPTION: This snippet shows how to transform a 2, 3, or 4-element vector as a direction (i.e., without translation) via the transformDirection method of Matrix4 from math.gl. The vector must have a w-component of 0 if using homogeneous coordinates, and the output can optionally be provided to reuse an existing vector object. This operation is suited for rotating or scaling vectors interpreted as directions, without applying any translation component of the matrix.\nSOURCE: https://github.com/visgl/math.gl/blob/master/docs/modules/core/api-reference/matrix4.md#_snippet_7\n\nLANGUAGE: javascript\nCODE:\n```\nconst vector = matrix4.transformDirection(vector, out)\n```\n\n----------------------------------------\n\nTITLE: Creating Orthographic Projection Matrix with math.gl Matrix4 - JavaScript\nDESCRIPTION: This snippet demonstrates how to use the new Matrix4.orthographic() method from the math.gl library to construct an orthographic projection matrix. The function accepts parameters such as fovy (vertical field of view), aspect (aspect ratio), focalDistance (additional orthographic parameter), near, and far (clipping planes). No external dependencies are required beyond math.gl, and it supports seamless switching between perspective and orthographic projections in WebGL or 3D applications. Inputs are an object containing projection parameters and the output is a Matrix4 orthographic matrix.\nSOURCE: https://github.com/visgl/math.gl/blob/master/docs/whats-new.md#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nMatrix4.orthographic({fovy, aspect, focalDistance, near, far})\n```\n\n----------------------------------------\n\nTITLE: Invoking cutPolylineByGrid with Parameters (JavaScript)\nDESCRIPTION: This usage example shows the call structure for the cutPolylineByGrid function, outlining the primary input arguments. The first argument (positions) is a flat or typed array representing vertex data; the second argument is an optional options object adjusting settings such as vertex size, starting and ending index, grid resolution and offset, and whether to split into multiple polylines at grid intersections. To use this, ensure you import or otherwise have access to cutPolylineByGrid from math.gl. Outputs vary based on the 'broken' flag, returning either a single positions array or an array of such arrays.\nSOURCE: https://github.com/visgl/math.gl/blob/master/docs/modules/polygon/api-reference/cut-polyline-by-grid.md#_snippet_1\n\nLANGUAGE: js\nCODE:\n```\ncutPolylineByGrid(positions, [options]);\n```\n\n----------------------------------------\n\nTITLE: Converting Cartesian to Cartographic Coordinates using Ellipsoid.WGS84 in JavaScript\nDESCRIPTION: This example shows how to convert a position defined in Cartesian coordinates (X, Y, Z) back into cartographic coordinates (longitude, latitude, height). It employs the `cartesianToCartographic` method of the `Ellipsoid.WGS84` instance provided by `@math.gl/geospatial`. The resulting longitude and latitude will be in radians.\nSOURCE: https://github.com/visgl/math.gl/blob/master/docs/modules/geospatial/api-reference/ellipsoid.md#_snippet_1\n\nLANGUAGE: js\nCODE:\n```\nimport {Ellipsoid} from '@math.gl/geospatial';\nconst cartesianPosition = [17832.12, 83234.52, 952313.73];\nconst cartographicPosition = Ellipsoid.WGS84.cartesianToCartographic(cartesianPosition);\n```\n\n----------------------------------------\n\nTITLE: Sorting Bounding Spheres by Distance to Camera - math.gl - JavaScript\nDESCRIPTION: This snippet showcases sorting an array of BoundingSphere instances from back to front relative to a camera position using the distanceSquaredTo method. It initializes several BoundingSphere objects, defines a camera position, and sorts the array by calculating the squared distance from each sphere to the camera. It requires the @math.gl/culling library and that BoundingSphere and camera position variables are appropriately initialized. Key parameters include the camera world coordinate and the spheres array; output is the array sorted in decreasing order of distance from the camera. There is a minor bug in the code (incorrect method parameter usage) which should be fixed for correct execution.\nSOURCE: https://github.com/visgl/math.gl/blob/master/docs/modules/culling/api-reference/bounding-sphere.md#_snippet_1\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport {BoundingSphere} from '@math.gl/culling';\nconst spheres = [new BoundingSphere(...), new BoundingSphere(...), ...];\nconst cameraPosWC = ...;\nspheres.sort(\n  (a, b) => b.distanceSquaredTo(b, cameraPosWC) - a.distanceSquaredTo(a.cameraPosWC)\n);\n```\n\n----------------------------------------\n\nTITLE: Transforming Directions using Matrix4.transformDirection in JavaScript\nDESCRIPTION: Demonstrates the application of the transformDirection method which transforms vectors as directions (ignoring translation). Useful for rotating normals or directional vectors during graphics processing. The input can be a 2D, 3D, or 4D vector, and the output is the rotated (but not translated) direction vector.\nSOURCE: https://github.com/visgl/math.gl/blob/master/docs/modules/core/api-reference/matrix4.md#_snippet_5\n\nLANGUAGE: JavaScript\nCODE:\n```\nconst transform = new Matrix4();\nconst vector2 = transform.transformDirection([0, 0]);\nconst vector3 = transform.transformDirection([0, 1, 2]);\nconst vector4 = transform.transformDirection([0, 1, 2, 1]);\n```\n\n----------------------------------------\n\nTITLE: Creating an Orthographic Projection Matrix (Perspective Params) with math.gl Matrix4.orthographic (JavaScript)\nDESCRIPTION: Creates a 4x4 orthographic projection matrix using `Matrix4.orthographic`. This method takes parameters similar to `Matrix4.perspective` (`fovy`, `aspect`, `near`, `far`) plus a `focalDistance`. The `focalDistance` determines the plane in the equivalent perspective frustum used to calculate the size of the orthographic view box, facilitating easier switching between perspective and orthographic views while maintaining a consistent view size at the focal plane.\nSOURCE: https://github.com/visgl/math.gl/blob/master/docs/developer-guide/math/view-and-projection.md#_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nMatrix4.orthographic({fovy, aspect, focalDistance, near, far})\n```\n\n----------------------------------------\n\nTITLE: Getting Quadkey Center Coordinates using JavaScript\nDESCRIPTION: Retrieves the center longitude and latitude coordinates for a given quadkey cell. It takes a quadkey string as input and returns an array containing two numbers: [longitude, latitude]. This function is part of the experimental QuadKey module.\nSOURCE: https://github.com/visgl/math.gl/blob/master/docs/modules/dggs-quadkey/api-reference/quadkey.md#_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n`getQuadkeyLngLat(quadkey: string): number[]`\n```\n\n----------------------------------------\n\nTITLE: Calling clipPolyline Function with Custom Arguments in JavaScript\nDESCRIPTION: The snippet provides a template for invoking clipPolyline using custom variables for the polyline, bounding box, and options. It is intended to help developers understand the function's general usage, supporting a range of input coordinate formats and options through flexible parameterization. The function expects position arrays (2D or 3D), a bounding box array, and optionally an options object, and returns an array of clipped polylines within the box.\nSOURCE: https://github.com/visgl/math.gl/blob/master/docs/modules/polygon/api-reference/clip-polyline.md#_snippet_1\n\nLANGUAGE: js\nCODE:\n```\nclipPolyline(positions, bbox, [options]);\n```\n\n----------------------------------------\n\nTITLE: Applying Quaternion Transformations on Vectors with math.gl in JavaScript\nDESCRIPTION: These code examples apply quaternion-based transformations to vectors, demonstrating both raw array and Quaternion class input. The main dependency is the math.gl Quaternion class, and the transformByQuaternion method transforms the input vector in place. Input quaternions should be normalized for expected geometric results. The method works with both Vector3 and Vector4 types.\nSOURCE: https://github.com/visgl/math.gl/blob/master/docs/developer-guide/math/transformations.md#_snippet_2\n\nLANGUAGE: JavaScript\nCODE:\n```\nconst transformedVector1 = new Vector4(1, 0, 0).transformByQuaternion([0, 0, 0, 1]);\n// or\nconst transformedVector2 = new Vector3(1, 0, 0).transformByQuaternion(new Quaternion([1, 0, 0, 1]));\n```\n\n----------------------------------------\n\nTITLE: Transforming Vectors via Quaternion Classes Directly in math.gl (JavaScript)\nDESCRIPTION: This sample demonstrates two alternative usages: directly using a vector's transformByQuaternion, or invoking a Quaternion's transformByQuaternion to rotate a vector, optionally storing the result in a supplied Vector3. This pattern supports reuse and avoids allocation if a result object is reused. The math.gl Quaternion and Vector3/4 classes are required, and input quaternion and vectors must match dimensionality.\nSOURCE: https://github.com/visgl/math.gl/blob/master/docs/developer-guide/math/transformations.md#_snippet_3\n\nLANGUAGE: JavaScript\nCODE:\n```\nconst transformedVector1 = new Vector4(1, 0, 0).transformByQuaternion([0, 0, 0, 1]);\n// or\nconst result = new Vector3();\nconst transformedVector2 = new Quaternion([1, 0, 0, 1]).transformByQuaternion([1, 0, 0], result);\n```\n\n----------------------------------------\n\nTITLE: Constructing a Pose Instance (JavaScript)\nDESCRIPTION: This snippet demonstrates the supported constructor signatures for instantiating a Pose object. Poses can be created by specifying position (x, y, z) and orientation (roll, pitch, yaw) parameters directly, or by passing objects/arrays (position, orientation) representing vectors or Euler angles. Inputs can be numbers, arrays, or objects depending on the provided argument options. The resulting instance encapsulates the 6-DOF pose for transformation or comparison.\nSOURCE: https://github.com/visgl/math.gl/blob/master/docs/modules/core/api-reference/pose.md#_snippet_2\n\nLANGUAGE: JavaScript\nCODE:\n```\nnew Pose({x, y, z, roll, pitch, yaw});\nnew Pose({position, orientation});\n```\n\n----------------------------------------\n\nTITLE: Parsing PGM Data with TypeScript Function Signature\nDESCRIPTION: This TypeScript function signature outlines the `parsePGM` function. It accepts a `Uint8Array` containing the binary data of a PGM file and an optional `options` object. The function processes this data and returns an instance of the `GeoidHeightModel` class, representing the parsed Earth Gravity Model.\nSOURCE: https://github.com/visgl/math.gl/blob/master/docs/modules/geoid/api-reference/parse-pgm.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nparsePGM(data: Uint8Array, options: object}): GeoidHeightModel\n```\n\n----------------------------------------\n\nTITLE: Performing Rotations on Vector3 Instances (rotateX) in JavaScript\nDESCRIPTION: This snippet demonstrates rotating a Vector3 around the x-axis using the rotateX method with specified radians and an optional origin. Dependencies include the Vector3 class and the Math.PI constant. Parameters include 'radians' for the rotation angle and 'origin' as an optional pivot point. The rotated vector reflects updated coordinates according to the transformation.\nSOURCE: https://github.com/visgl/math.gl/blob/master/docs/modules/core/api-reference/vector3.md#_snippet_3\n\nLANGUAGE: js\nCODE:\n```\nconst v = new Vector3([1, 0, 0]);\nv.rotateX({radians: Math.PI / 4}); // Rotate around the origin\nv.rotateX({radians: Math.PI / 4, origin: [1, 1, 0]}); // Rotate around the specified point\n```\n\n----------------------------------------\n\nTITLE: Initializing and Translating a Matrix4 Instance in JavaScript\nDESCRIPTION: Shows how to initialize a Matrix4 instance with an identity array and apply a translation using the translate method. The snippet demonstrates direct construction and mutation of a 4x4 matrix for 3D transformations. The parameter to translate is an array specifying the x, y, and z translation, and the method mutates the matrix in place. This pattern is foundational for composing model or view matrices in graphics applications.\nSOURCE: https://github.com/visgl/math.gl/blob/master/docs/modules/core/api-reference/matrix4.md#_snippet_1\n\nLANGUAGE: JavaScript\nCODE:\n```\nconst IDENTITY = [1, 0, ..., 1];\nconst m = new Matrix4(IDENTITY).translate([1, 0, 0]);\n```\n\n----------------------------------------\n\nTITLE: Creating and Translating a Matrix3 Instance (JavaScript)\nDESCRIPTION: Demonstrates creating a new Matrix3 instance from an existing array (representing the identity matrix) and then applying a translation transformation using the `translate` method. This allows manipulating the matrix using Matrix3 methods.\nSOURCE: https://github.com/visgl/math.gl/blob/master/docs/modules/core/api-reference/matrix3.md#_snippet_1\n\nLANGUAGE: js\nCODE:\n```\nconst IDENTITY = [1, 0, ..., 1];\nconst m = new Matrix3(IDENTITY).translate([1, 0]);\n```\n\n----------------------------------------\n\nTITLE: Computing Oriented Bounding Box from Points in math.gl - JavaScript\nDESCRIPTION: This snippet utilizes 'makeOrientedBoundingBoxFromPoints' from the '@math.gl/culling' package to compute an oriented bounding box enclosing two or more 3D points. It demonstrates passing an array of point arrays to the function, which returns an OrientedBoundingBox fit to the supplied points. This approach is efficient for dynamic bounding volume creation, especially in importing or analyzing external geometry. Depends on '@math.gl/culling'.\nSOURCE: https://github.com/visgl/math.gl/blob/master/docs/modules/culling/api-reference/oriented-bounding-box.md#_snippet_2\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport {makeOrientedBoundingBoxFromPoints} from '@math.gl/culling';\\n\\nconst box = makeOrientedBoundingBoxFromPoints([\\n  [2, 0, 0],\\n  [-2, 0, 0]\\n]);\n```\n\n----------------------------------------\n\nTITLE: Reprojecting WGS84 Coordinates Using Proj4Projection - JavaScript\nDESCRIPTION: This snippet demonstrates how to reproject geographic coordinates from the WGS84 system to NAD83 using the Proj4Projection class. It imports the class from @math.gl/proj4, constructs an NAD83 projection string, then initializes Proj4Projection with conversion parameters. The project method is used to convert a position array from WGS84 to NAD83. Dependencies: the @math.gl/proj4 npm package. Key parameters are 'from' and 'to' specifying the source and target projections; project() expects a coordinate array (longitude, latitude, optional altitude) and returns the transformed coordinates.\nSOURCE: https://github.com/visgl/math.gl/blob/master/docs/modules/proj4/api-reference/proj4-projection.md#_snippet_0\n\nLANGUAGE: js\nCODE:\n```\nimport {Proj4Projection} from '@math.gl/proj4';\n\nconst nad83Proj =\n  '+title=NAD83 (long/lat) +proj=longlat +a=6378137.0 +b=6356752.31414036 +ellps=GRS80 +datum=NAD83 +units=degrees';\nconst projection = new Proj4Projection({from: 'WGS84', to: nad83Proj});\n\nconst wgs84Position = [21, 78, 5000];\nconst reprojectedPosition = projection.project(wgs84Position);\n```\n\n----------------------------------------\n\nTITLE: Calculating Sun Direction using @math.gl/sun in JavaScript\nDESCRIPTION: This snippet shows how to import the `getSunDirection` function from the `@math.gl/sun` library and use it to calculate the sun's direction vector. It takes the current timestamp (`Date.now()`), latitude, and longitude as input and returns the direction. Requires the `@math.gl/sun` library to be installed.\nSOURCE: https://github.com/visgl/math.gl/blob/master/docs/modules/sun/README.md#_snippet_1\n\nLANGUAGE: js\nCODE:\n```\nimport {getSunDirection} from '@math.gl/sun';\nconst latitude = 37.7749;\nconst longitude = -122.4194;\nconst sunDir = getSunDirection(Date.now(), latitude, longitude);\n```\n\n----------------------------------------\n\nTITLE: Parsing EPSG Definitions from API Response in JSON\nDESCRIPTION: This JSON block is an example response from the epsg.io API when querying for a coordinate system by its EPSG code (e.g., 4326 for WGS84). It encapsulates CRS metadata, including projection definitions in both WKT and Proj4 format. Integrators query this endpoint to extract identifiers, bounding boxes, and the necessary strings for initializing CRS transformations. No dependencies are needed for parsing as it is standard JSON; fields of interest include 'code', 'wkt', and 'proj4'. Input is an API GET request; output is a JSON object. Limitation: the structure may vary based on the coordinate system or future API updates.\nSOURCE: https://github.com/visgl/math.gl/blob/master/docs/modules/proj4/README.md#_snippet_1\n\nLANGUAGE: JSON\nCODE:\n```\n{\n  \"status\": \"ok\",\n  \"number_result\": 1,\n  \"results\": [\n    {\n      \"code\": \"4326\",\n      \"kind\": \"CRS-GEOGCRS\",\n      \"bbox\": [90.0, -180.0, -90.0, 180.0],\n      \"wkt\": \"GEOGCS[\\\"WGS 84\\\",DATUM[\\\"WGS_1984\\\",SPHEROID[\\\"WGS 84\\\",6378137,298.257223563,AUTHORITY[\\\"EPSG\\\",\\\"7030\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"6326\\\"]],PRIMEM[\\\"Greenwich\\\",0,AUTHORITY[\\\"EPSG\\\",\\\"8901\\\"]],UNIT[\\\"degree\\\",0.0174532925199433,AUTHORITY[\\\"EPSG\\\",\\\"9122\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"4326\\\"]]\",\n      \"unit\": \"degree (supplier to define representation)\",\n      \"proj4\": \"+proj=longlat +datum=WGS84 +no_defs\",\n      \"name\": \"WGS 84\",\n      \"area\": \"World.\",\n      \"default_trans\": 0,\n      \"trans\": [],\n      \"accuracy\": \"\"\n    }\n  ]\n}\n```\n\n----------------------------------------\n\nTITLE: Transforming Vectors by Matrix2 or Matrix3 with math.gl in JavaScript\nDESCRIPTION: These snippets demonstrate how to use transformByMatrix3 and transformByMatrix2 to apply 3x3 or 2x2 matrix transformations to vectors. Dependencies include math.gl types for Matrix2, Matrix3, Vector3, and Vector4. The inputs are the matrix (array or class instance) and the method returns the transformed object; the matrix should be sized to match the transform type.\nSOURCE: https://github.com/visgl/math.gl/blob/master/docs/developer-guide/math/transformations.md#_snippet_1\n\nLANGUAGE: JavaScript\nCODE:\n```\nconst transformedVector1 = new Vector4(1, 0, 0, 1).transformByMatrix3([1, 0, 0, 0, 1, 0, 0, 0, 1]);\n// or\nconst transformedVector2 = new Vector3(1, 0, 0).transformByMatrix2(new Matrix2([1, 0, 0, 1]));\n```\n\n----------------------------------------\n\nTITLE: Importing getGeohashPolygon and Using It - @math.gl/dggs-geohash - JavaScript\nDESCRIPTION: Demonstrates importing the getGeohashPolygon function from the @math.gl/dggs-geohash library and invoking it to obtain a polygon representation of a geohash. This requires the package to be installed via npm. The input parameter 'geohash' should be a string; the output 'polygon' is typically a polygon object or GeoJSON describing the geohash cell. Users should verify the format of the returned polygon for compatibility with their mapping or spatial analysis libraries.\nSOURCE: https://github.com/visgl/math.gl/blob/master/docs/modules/dggs-geohash/README.md#_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport {getGeohashPolygon} from '@math.gl/dggs-geohash';\nconst polygon = getGeohashPolygon(geohash);\n```\n\n----------------------------------------\n\nTITLE: Encoding S2 Index to Token Using Math.gl (JavaScript)\nDESCRIPTION: The function `getS2TokenFromIndex` encodes a 64-bit S2 index (as a `Long` type) back into a token string. It requires an index as input and yields a readable S2 token string. Usage assumes the input index is valid and correctly formatted for the S2 specification. It is part of the math.gl S2 utilities for interoperating between string and numeric representations of S2 cells.\nSOURCE: https://github.com/visgl/math.gl/blob/master/docs/modules/dggs-s2/api-reference/s2.md#_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\ngetS2TokenFromIndex(s2Index: Long): string\n```\n\n----------------------------------------\n\nTITLE: Retrieving WKT String for EPSG Coordinate System\nDESCRIPTION: This snippet presents a WKT (Well-Known Text) string for the WGS84 coordinate system, as returned from a GET request to https://epsg.io/4326.wkt. The WKT format encodes all relevant spatial reference information such as datum, spheroid, unit, and authority. This value can be used directly with libraries that accept coordinate system definitions in WKT syntax. No code execution is necessary beyond copying the string. Limitation: Only valid for systems that accept or parse WKT definitions.\nSOURCE: https://github.com/visgl/math.gl/blob/master/docs/modules/proj4/README.md#_snippet_2\n\nLANGUAGE: plaintext\nCODE:\n```\nGEOGCS[\"WGS 84\",DATUM[\"WGS_1984\",SPHEROID[\"WGS 84\",6378137,298.257223563,AUTHORITY[\"EPSG\",\"7030\"]],AUTHORITY[\"EPSG\",\"6326\"]],PRIMEM[\"Greenwich\",0,AUTHORITY[\"EPSG\",\"8901\"]],UNIT[\"degree\",0.0174532925199433,AUTHORITY[\"EPSG\",\"9122\"]],AUTHORITY[\"EPSG\",\"4326\"]]\n```\n\n----------------------------------------\n\nTITLE: Scaling MathArray with Vector in JavaScript\nDESCRIPTION: These snippets illustrate scaling a MathArray-derived vector by another array, enabling selective modification of components. For example, setting the z component to zero or flipping the y component. The scale method multiplies each element-wise. The method operates on MathArray or its subclass, with the input argument as an array of matching dimension, returning the appropriately scaled MathArray.\nSOURCE: https://github.com/visgl/math.gl/blob/master/docs/modules/core/api-reference/math-array.md#_snippet_3\n\nLANGUAGE: JavaScript\nCODE:\n```\nconst u = v.scale([1, 1, 0]); // Set z component to zero\n```\n\nLANGUAGE: JavaScript\nCODE:\n```\nconst w = v.scale([1, -1, 1]); // Flip y component\n```\n\n----------------------------------------\n\nTITLE: Scaling MathArray with Scalar Value in JavaScript\nDESCRIPTION: This snippet demonstrates scaling a MathArray-derived vector by a scalar, in this case -1, to reverse its direction. The scale method applies the scalar multiplicatively to each component. Requires the scale method to be implemented on the MathArray subclass; 'v' must be a compatible object, and the return value is a new MathArray instance with scaled values.\nSOURCE: https://github.com/visgl/math.gl/blob/master/docs/modules/core/api-reference/math-array.md#_snippet_2\n\nLANGUAGE: JavaScript\nCODE:\n```\nconst u = v.scale(-1); // Reverse direction vector\n```\n\n----------------------------------------\n\nTITLE: Reprojecting Coordinates with Proj4Projection in JavaScript\nDESCRIPTION: This JavaScript snippet demonstrates how to use the @math.gl/proj4 module to convert coordinates from the WGS84 reference system to NAD83. It imports the Proj4Projection class, defines the source and target coordinate systems, constructs a projection, and then transforms a coordinate array using the project method. Dependencies include @math.gl/proj4, and required parameters are the 'from' and 'to' projection definitions (can be aliases or Proj4 strings). Input is a position array; output is a reprojected position array. This approach may be constrained by the accuracy of the provided Proj4 or alias strings.\nSOURCE: https://github.com/visgl/math.gl/blob/master/docs/modules/proj4/README.md#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport {Proj4Projection} from '@math.gl/proj4';\n\nconst nad83Proj =\n  '+title=NAD83 (long/lat) +proj=longlat +a=6378137.0 +b=6356752.31414036 +ellps=GRS80 +datum=NAD83 +units=degrees';\nconst projection = new Proj4Projection({from: 'WGS84', to: nad83Proj});\n\nconst wgs84Position = [21, 78, 5000];\nconst reprojectedPosition = projection.project(wgs84Position);\n```\n\n----------------------------------------\n\nTITLE: Rotating a Vector Around an Axis and Origin using math.gl in JavaScript\nDESCRIPTION: This example demonstrates rotating a Vector3 using the rotateZ method, specifying the rotation in radians and the origin point. Dependencies are math.gl's Vector3 class. The object is mutated and the method parameters control rotation angle and pivot, allowing for geometric transformations around arbitrary origins.\nSOURCE: https://github.com/visgl/math.gl/blob/master/docs/developer-guide/math/transformations.md#_snippet_5\n\nLANGUAGE: JavaScript\nCODE:\n```\nconst v = new Vector3([1, 2, 3]).rotateZ({radians: ..., origin: [1, 1, 0]});\n```\n\n----------------------------------------\n\nTITLE: Getting the Boundary of an S2 Cell Using Math.gl (JavaScript)\nDESCRIPTION: The `getS2Boundary` function returns the geographic boundary of an S2 cell as a Float64Array of [longitude, latitude] coordinate pairs. The function accepts an S2 token string and outputs a one-dimensional Float64Array with alternating longitude and latitude values representing the S2 cell's boundary polygon. The input must be a valid S2 token. The output format is suitable for geospatial rendering or computation.\nSOURCE: https://github.com/visgl/math.gl/blob/master/docs/modules/dggs-s2/api-reference/s2.md#_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\ngetS2Boundary(s2Token: string): Float64Array\n```\n\n----------------------------------------\n\nTITLE: Checking for Standard Number Arrays with `isNumberArray` in TypeScript\nDESCRIPTION: Provides the signature for the `isNumberArray` utility function. It checks if a given `value` (of type `unknown`) is a standard JavaScript array containing numbers, acting as a type guard (`value is NumberArray`). Importantly, it only checks the type of the first element to determine if it's an array of numbers.\nSOURCE: https://github.com/visgl/math.gl/blob/master/docs/modules/types/api-reference/array-types.md#_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nisNumberArray(value: unknown): value as NumberArray\n```\n\n----------------------------------------\n\nTITLE: Cloning MathArray Objects in JavaScript\nDESCRIPTION: This snippet demonstrates how to create a cloned copy of an existing MathArray-derived object. The clone method creates a deep copy, preserving the original object's values but resulting in an entirely separate instance. 'vector' must be an instance of MathArray or its subclass, and the output is a new MathArray object with the same elements.\nSOURCE: https://github.com/visgl/math.gl/blob/master/docs/modules/core/api-reference/math-array.md#_snippet_1\n\nLANGUAGE: JavaScript\nCODE:\n```\nconst clone = vector.clone();\n```\n\n----------------------------------------\n\nTITLE: Creating Oriented Bounding Boxes in math.gl - JavaScript\nDESCRIPTION: This snippet demonstrates how to instantiate an OrientedBoundingBox using math.gl, relying on Vector3, Matrix3, and OrientedBoundingBox from the math.gl/core and math.gl/culling packages. It initializes the center and orientation using vectors and matrices, illustrating the half-axes approach for bounding box definition. Requires '@math.gl/core' and '@math.gl/culling', with 'center' as a Vector3, 'halfAxes' as a Matrix3, and outputs a constructed OrientedBoundingBox ready for spatial operations.\nSOURCE: https://github.com/visgl/math.gl/blob/master/docs/modules/culling/api-reference/oriented-bounding-box.md#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport {Vector3} from '@math.gl/core';\\nimport {OrientedBoundingBox} from '@math.gl/culling';\\n\\nconst center = new Vector3(1.0, 0.0, 0.0);\\nconst halfAxes = new Matrix3().fromScale([1.0, 3.0, 2.0]);\\nconst box = new OrientedBoundingBox(center, halfAxes);\n```\n\n----------------------------------------\n\nTITLE: Retrieving a Child S2 Cell Index Using Math.gl (JavaScript)\nDESCRIPTION: The `getS2ChildIndex` function returns the 64-bit index for a specified child cell of a given parent S2 index and child number. It accepts a parent S2 index (`Long`) and a numeric child index, and returns the appropriate child cell index as another `Long`. It relies on the math.gl S2 API and is used for traversing from parent to child cells in the S2 spatial hierarchy. Inputs must be a valid parent S2 index and a child number; supported number of children is defined by the S2 cell level.\nSOURCE: https://github.com/visgl/math.gl/blob/master/docs/modules/dggs-s2/api-reference/s2.md#_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\ngetS2ChildIndex(s2Index: Long, index: number): Long\n```\n\n----------------------------------------\n\nTITLE: Getting Flattened Quadkey Boundary Vertices using JavaScript\nDESCRIPTION: Calculates the boundary vertices (corners) for a given quadkey cell and returns them as a flat array. It takes a quadkey string and returns a single array of numbers `[lng1, lat1, lng2, lat2, ...]` suitable for certain rendering or processing pipelines. This function is part of the experimental QuadKey module.\nSOURCE: https://github.com/visgl/math.gl/blob/master/docs/modules/dggs-quadkey/api-reference/quadkey.md#_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\n`getQuadkeyBoundaryFlat(quadkey: string): number[]`\n```\n\n----------------------------------------\n\nTITLE: Type Guard Function Signature for Checking 2D Bounds in TypeScript\nDESCRIPTION: Defines the signature for the `is2DBounds` function in TypeScript. This function acts as a type guard, taking a `Bounds` object as input and returning a boolean indicating if it represents 2D bounds. If true, it narrows the type of the input `bounds` parameter to `Bounds2D` within the current scope.\nSOURCE: https://github.com/visgl/math.gl/blob/master/docs/modules/types/api-reference/bounds.md#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nis2DBounds(bounds: Bounds): bounds is Bounds2D\n```\n\n----------------------------------------\n\nTITLE: Defining Fixed-Length `NumericArray` Type Aliases in TypeScript\nDESCRIPTION: Defines TypeScript type aliases (`NumericArray2` through `NumericArray16`) representing either standard JavaScript number arrays or non-big typed arrays of specific, fixed lengths from 2 to 16 elements.\nSOURCE: https://github.com/visgl/math.gl/blob/master/docs/modules/types/api-reference/array-types.md#_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nNumericArray2-NumericArray16\n```\n\n----------------------------------------\n\nTITLE: Defining a Type for 3D Bounds in TypeScript\nDESCRIPTION: Exports a TypeScript type alias `Bounds3D` specifically for 3D geometric bounds. It represents a bounding box using a tuple of two 3-element arrays: `[[minX, minY, minZ], [maxX, maxY, maxZ]]`.\nSOURCE: https://github.com/visgl/math.gl/blob/master/docs/modules/types/api-reference/bounds.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nexport type Bounds3D = [[number, number, number], [number, number, number]];\n```\n\n----------------------------------------\n\nTITLE: Querying Bounding Boxes and Regions with WebMercatorViewport in JavaScript\nDESCRIPTION: Demonstrates the use of getBounds and getBoundingRegion methods to compute the current visible area in bounding box form or as corner vertices. Both methods can take an elevation parameter for accurate 3D data queries, returning arrays of map coordinates defining the visible extent, useful for data fetching and view optimization.\nSOURCE: https://github.com/visgl/math.gl/blob/master/docs/modules/web-mercator/api-reference/web-mercator-viewport.md#_snippet_5\n\nLANGUAGE: JavaScript\nCODE:\n```\nconst bounds = viewport.getBounds({z: 0});\nconst region = viewport.getBoundingRegion({z: 0});\n```\n\n----------------------------------------\n\nTITLE: Optimizing by Supplying a Result Object (JavaScript)\nDESCRIPTION: This optimized version demonstrates passing a pre-allocated `tempVector` as the second argument (`result` parameter) to `matrix4.transformVector([x, y, z], tempVector)`. The method then populates this existing object with the result instead of creating a new one, avoiding allocation overhead within the loop. The returned `v` is a reference to the updated `tempVector`. Requires `Matrix4` and `Vector3` classes from `@math.gl/core`.\nSOURCE: https://github.com/visgl/math.gl/blob/master/docs/developer-guide/performance.md#_snippet_5\n\nLANGUAGE: js\nCODE:\n```\nconst tempVector = new Vector3();\nfor (...) {\n  const v = matrix4.transformVector([x, y, z], tempVector);\n  // v now contains a reference to `tempVector` which was updated with the result of the `tranformVector` operation.\n}\n```\n\n----------------------------------------\n\nTITLE: Constructing an AxisAlignedBoundingBox from Points in math.gl (JavaScript)\nDESCRIPTION: This code demonstrates the creation of an AxisAlignedBoundingBox by passing an array of Vector3 points to the makeAxisAlignedBoundingBoxFromPoints function from @math.gl/culling. The function computes the minimal bounding box that encloses all provided points. A prerequisite is the @math.gl/culling package, and the expected input is an array of 3D points. The output is a bounding box instance that can be used for spatial queries or collision detection.\nSOURCE: https://github.com/visgl/math.gl/blob/master/docs/modules/culling/api-reference/axis-aligned-bounding-box.md#_snippet_1\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport {makeAxisAlignedBoundingBoxFromPoints} from '@math.gl/culling';\\n\\nconst box = makeAxisAlignedBoundingBoxFromPoints([\\n  [2, 0, 0],\\n  [-2, 0, 0]\\n]);\n```\n\n----------------------------------------\n\nTITLE: Defining Projection Aliases with Proj4Projection - JavaScript\nDESCRIPTION: This snippet shows how to define aliases for projection strings using Proj4Projection.defineProjectionAliases, enabling more readable configuration when converting between coordinate systems. After registering aliases for EPSG:4326 (WGS 84) and EPSG:4269 (NAD83), a new Proj4Projection instance is created using these aliases as identifiers for the source and target projections. This makes projection management scalable and less error-prone. Dependencies: @math.gl/proj4; defineProjectionAliases expects a dictionary mapping aliases to PROJ4 strings, and Proj4Projection uses these aliases when specified in the 'from' and 'to' options.\nSOURCE: https://github.com/visgl/math.gl/blob/master/docs/modules/proj4/api-reference/proj4-projection.md#_snippet_1\n\nLANGUAGE: js\nCODE:\n```\nimport {Proj4Projection} from '@math.gl/proj4';\n\nProj4Projection.defineProjectionAliases({\n  'EPSG:4326': '+title=WGS 84 (long/lat) +proj=longlat +ellps=WGS84 +datum=WGS84 +units=degrees',\n  'EPSG:4269':\n    '+title=NAD83 (long/lat) +proj=longlat +a=6378137.0 +b=6356752.31414036 +ellps=GRS80 +datum=NAD83 +units=degrees'\n});\nconst projection = new Proj4Projection({from: 'EPSG:4326', to: 'EPSG:4269'});\n```\n\n----------------------------------------\n\nTITLE: Importing Matrix3 from math.gl (JavaScript)\nDESCRIPTION: Imports the Matrix3 class from the 'math.gl' library, making it available for use in the current JavaScript module. This is the standard way to access the Matrix3 functionality.\nSOURCE: https://github.com/visgl/math.gl/blob/master/docs/modules/core/api-reference/matrix3.md#_snippet_0\n\nLANGUAGE: js\nCODE:\n```\nimport {Matrix3} from `math.gl`;\n```\n\n----------------------------------------\n\nTITLE: Unprojecting Flat Web Mercator Coordinates to Geographic Coordinates in JavaScript\nDESCRIPTION: Describes the unprojectFlat method usage that converts [x, y] Web Mercator coordinates back to [longitude, latitude], using the current or user-specified projection scale. This is useful for quick reverse-mapping tasks or custom analyses involving planar coordinates.\nSOURCE: https://github.com/visgl/math.gl/blob/master/docs/modules/web-mercator/api-reference/web-mercator-viewport.md#_snippet_4\n\nLANGUAGE: JavaScript\nCODE:\n```\nconst lngLat = viewport.unprojectFlat([x, y]);\nconst lngLatScaled = viewport.unprojectFlat([x, y], scale);\n```\n\n----------------------------------------\n\nTITLE: Creating CullingVolume from Bounding Sphere in JavaScript\nDESCRIPTION: This static method constructs a culling volume encapsulating the bounding sphere, by generating six axis-aligned planes to bound the sphere tightly. Input parameter is a BoundingSphere object; output is a CullingVolume instance containing a box aligned to world axes. Relies on correct geometric definitions for bounding spheres and planes, with the resulting planes suitable for fast culling checks.\nSOURCE: https://github.com/visgl/math.gl/blob/master/docs/modules/culling/api-reference/culling-volume.md#_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\n/*\nfromBoundingSphere(boundingSphere : BoundingSphere)\nConstructs a culling volume from a bounding sphere. Creates six planes that create a box containing the sphere. The planes are aligned to the x, y, and z axes in world coordinates.\n- `boundingSphere` The bounding sphere used to create the culling volume.\n*/\n```\n\n----------------------------------------\n\nTITLE: Rendering Examples Index using ExamplesIndex Component in JSX/MDX\nDESCRIPTION: This snippet imports the `ExamplesIndex` component from `@vis.gl/docusaurus-website/components` and uses it within a JSX/MDX file. It renders the component, passing a `getThumbnail` function prop to dynamically determine the thumbnail image path for each example item based on its `docId` or label. This is typically used on a documentation page to create a visual index of available examples.\nSOURCE: https://github.com/visgl/math.gl/blob/master/website/src/examples/index.mdx#_snippet_0\n\nLANGUAGE: jsx\nCODE:\n```\nimport {ExamplesIndex} from '@vis.gl/docusaurus-website/components';\n\n<ExamplesIndex getThumbnail={item => `/images/examples/${item.docId || item.label.toLowerCase()}.jpg`} />\n```\n\n----------------------------------------\n\nTITLE: Installing @math.gl/types using npm\nDESCRIPTION: This command uses the Node Package Manager (npm) to download and install the `@math.gl/types` package. This package provides minimal math types suitable for JavaScript projects. Running this command in a project's terminal will add the package to the project's dependencies.\nSOURCE: https://github.com/visgl/math.gl/blob/master/docs/modules/types/README.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm install @math.gl/types\n```\n\n----------------------------------------\n\nTITLE: Calculating Fly-To Duration with Mapbox-gl-js Algorithm in JavaScript\nDESCRIPTION: This function, `getFlyToDuration`, computes the animation duration (in milliseconds) required to transition between two viewport states using Mapbox-gl-js's flyto calculation logic. It requires source and destination viewport objects with longitude, latitude, and zoom, as well as optional animation parameters (such as curve, speed, screenSpeed, and maxDuration). The function returns the computed duration based on input geometry and speed, or zero if the optional `maxDuration` is exceeded. Dependencies include basic JavaScript math functions and Mapbox parameter conventions; expected inputs are detailed viewport and option objects, and output is a duration integer.\nSOURCE: https://github.com/visgl/math.gl/blob/master/docs/modules/web-mercator/api-reference/web-mercator-utils.md#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nfunction getFlyToDuration(startProps, endProps, opts) {\n  // Returns time in milliseconds, required to perform transition from one viewport to another\n  // Implements mapbox-gl-js flyto duration calculation\n  /*\n    startProps: {width, height, longitude, latitude, zoom}\n    endProps: {longitude, latitude, zoom}\n    opts: {\n      curve?: number = 1.414,\n      speed?: number = 1.2,\n      screenSpeed?: number,\n      maxDuration?: number\n    }\n    Returns: duration (Number), in milliseconds\n  */\n  // Implementation here...\n}\n```\n\n----------------------------------------\n\nTITLE: Importing Math.gl Core Modules in JavaScript\nDESCRIPTION: Demonstrates how to import configuration and equality-checking utilities from the math.gl core module using JavaScript ES module syntax. No additional dependencies are required beyond the math.gl library. The imported functions and objects are used for further configuration and mathematical comparisons elsewhere in the file.\nSOURCE: https://github.com/visgl/math.gl/blob/master/docs/modules/core/api-reference/utilities.md#_snippet_0\n\nLANGUAGE: js\nCODE:\n```\nimport {config, equals} from '@math.gl/core';\n```\n\n----------------------------------------\n\nTITLE: Instantiating an AxisAlignedBoundingBox in math.gl (JavaScript)\nDESCRIPTION: This snippet demonstrates how to import the AxisAlignedBoundingBox class from the @math.gl/culling package and construct a bounding box using two diagonal corners. Dependencies include the @math.gl/culling package, and the key parameters are the two corner arrays that define the box in 3D space. The resulting object can then be used for further geometric or collision computations.\nSOURCE: https://github.com/visgl/math.gl/blob/master/docs/modules/culling/api-reference/axis-aligned-bounding-box.md#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport {AxisAlignedBoundingBox} from '@math.gl/culling';\\n\\nconst box = new AxisAlignedBoundingBox([-1, -1, -1], [1, 1, 1]);\n```\n\n----------------------------------------\n\nTITLE: Decomposing a Transformation Matrix with Matrix4 in math.gl (JavaScript)\nDESCRIPTION: This code illustrates building a matrix by chaining translation, rotation, and scaling, then extracting scale and translation components via getScale and getTranslation. The underlying math.gl Matrix4 class exposes these decomposition methods, but not all transforms (e.g., matrices with shear) are fully decomposable. The snippet returns arrays containing component values; accuracy depends on the absence of unsupported features in the matrix.\nSOURCE: https://github.com/visgl/math.gl/blob/master/docs/developer-guide/math/transformations.md#_snippet_6\n\nLANGUAGE: JavaScript\nCODE:\n```\nconst transform = new Matrix4()\n  .translate([10, 10, 0])\n  .rotateX(Math.PI / 4)\n  .scale(5);\ntransform.getScale(); // [5, 5, 5]\ntransform.getTranslation(); // [ 10, 10, 0]\n```\n\n----------------------------------------\n\nTITLE: Unprojecting Screen Pixels to Geographic Coordinates with WebMercatorViewport in JavaScript\nDESCRIPTION: Demonstrates converting screen pixel coordinates back to longitude and latitude using the unproject method. It handles optional depth components and lets the user specify a target elevation if not present. This functionality enables reverse mapping from screen interactions to geographic positions, accepting options for origin and target elevation, and returning either 2D or 3D map coordinates.\nSOURCE: https://github.com/visgl/math.gl/blob/master/docs/modules/web-mercator/api-reference/web-mercator-viewport.md#_snippet_2\n\nLANGUAGE: JavaScript\nCODE:\n```\nconst lngLat = viewport.unproject([x, y], {topLeft: true});\nconst lngLatZ = viewport.unproject([x, y, z]);\nconst lngLatTargetZ = viewport.unproject([x, y], {targetZ: 100});\n```\n\n----------------------------------------\n\nTITLE: Calculating East-North-Up to Fixed Frame Transform using Ellipsoid.WGS84 in JavaScript\nDESCRIPTION: This snippet computes the 4x4 transformation matrix that converts coordinates from a local East-North-Up (ENU) reference frame, centered at the specified origin (here, cartographic [0, 0, 0]), to the Earth-Centered, Earth-Fixed (ECEF) reference frame associated with the WGS84 ellipsoid. It uses the `eastNorthUpToFixedFrame` method from the `Ellipsoid` class in `@math.gl/geospatial`.\nSOURCE: https://github.com/visgl/math.gl/blob/master/docs/modules/geospatial/api-reference/ellipsoid.md#_snippet_2\n\nLANGUAGE: js\nCODE:\n```\nimport {Ellipsoid} from '@math.gl/geospatial';\nconst transformMatrix = Ellipsoid.WGS84.eastNorthUpToFixedFrame([0, 0, 0]);\n```\n\n----------------------------------------\n\nTITLE: Function Signature for Retrieving 2D Bounds in TypeScript\nDESCRIPTION: Defines the signature for the `get2DBounds` function in TypeScript. This function takes a `Bounds` object (which can be 2D or 3D) as input and returns a `Bounds2D` object. If the input `bounds` are 3D, the function truncates them to 2D before returning.\nSOURCE: https://github.com/visgl/math.gl/blob/master/docs/modules/types/api-reference/bounds.md#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nget2DBounds(bounds: Bounds): Bounds2D\n```\n\n----------------------------------------\n\nTITLE: Optimizing Performance by Reusing Objects (JavaScript)\nDESCRIPTION: This code demonstrates an optimization technique to avoid repeated object creation within a loop. A single `Vector3` object (`tempVector`) is allocated outside the loop and its state is updated inside the loop using the `set(x, y, z)` method. This significantly reduces object allocation overhead compared to creating new objects in each iteration. It requires the `Vector3` class, typically from `@math.gl/core`.\nSOURCE: https://github.com/visgl/math.gl/blob/master/docs/developer-guide/performance.md#_snippet_3\n\nLANGUAGE: js\nCODE:\n```\nconst tempVector = new Vector3();\nfor (...) {\n\tv.set(x, y, z);\n}\n```\n\n----------------------------------------\n\nTITLE: Importing Quaternion from Math.gl Core - JavaScript\nDESCRIPTION: Demonstrates how to import the Quaternion class from the '@math.gl/core' module, which is required for utilizing quaternion operations within JavaScript projects. This dependency is necessary for users to access Quaternion methods and instantiate objects for further computations. The imported class provides all defined methods and properties described in the documentation.\nSOURCE: https://github.com/visgl/math.gl/blob/master/docs/modules/core/api-reference/quaternion.md#_snippet_1\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport {Quaternion} from '@math.gl/core';\n\n```\n\n----------------------------------------\n\nTITLE: Comparing Floating Point Values with Tolerance - JavaScript\nDESCRIPTION: Implements a recommended approach to compare two floating point numbers in JavaScript by checking if their absolute difference is within a small tolerance, defined by config.EPSILON and the maximum absolute value of the inputs or 1. This method helps avoid false negatives caused by rounding errors. Inputs are two numbers, 'a' and 'b', and a required configuration object with an 'EPSILON' property; returns a boolean indicating approximate equality.\nSOURCE: https://github.com/visgl/math.gl/blob/master/docs/developer-guide/math/floating-point.md#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nreturn Math.abs(a - b) <= config.EPSILON * Math.max(1.0, Math.abs(a), Math.abs(b));\n```\n\n----------------------------------------\n\nTITLE: Using earcut for Basic Polygon Triangulation in JavaScript\nDESCRIPTION: Demonstrates importing the `earcut` function from `@math.gl/polygon` and using it to triangulate both a simple polygon and a polygon with a hole. The function takes a flat array of vertex coordinates and optionally an array of hole starting indices. It returns an array of indices representing the resulting triangles.\nSOURCE: https://github.com/visgl/math.gl/blob/master/docs/modules/polygon/api-reference/earcut.md#_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {earcut} from '@math.gl/polygon';\n\nearcut([10, 0, 0, 50, 60, 60, 70, 10]);\n// returns [1, 0, 3, 3, 2, 1]\n\n// Polygon with a hole starting at vertex 4\nearcut([0, 0, 100, 0, 100, 100, 0, 100, 20, 20, 80, 20, 80, 80, 20, 80], [4]);\n// returns [3, 0, 4, 5, 4, 0, 3, 4, 7, 5, 0, 1, 2, 3, 7, 6, 5, 1, 2, 7, 6, 6, 1, 2]\n```\n\n----------------------------------------\n\nTITLE: Scaling Vector3 by a Scalar Value in JavaScript\nDESCRIPTION: This snippet illustrates reversing the direction of a Vector3 by scaling with -1, creating a new vector. This operation depends solely on the Vector3 class implementation. Key parameter is the scalar multiplier, and the output is a new Vector3 instance with its components negated.\nSOURCE: https://github.com/visgl/math.gl/blob/master/docs/modules/core/api-reference/vector3.md#_snippet_4\n\nLANGUAGE: js\nCODE:\n```\nconst u = v.scale(-1); // Reverse direction vector\n```\n\n----------------------------------------\n\nTITLE: Importing SphericalCoordinates from math.gl in JavaScript\nDESCRIPTION: Demonstrates how to import the SphericalCoordinates class from the '@math.gl/core' package for use in JavaScript or TypeScript projects. Requires the '@math.gl/core' NPM package to be installed in the project. No parameters; resulting import makes the SphericalCoordinates constructor available.\nSOURCE: https://github.com/visgl/math.gl/blob/master/docs/modules/core/api-reference/spherical-coordinates.md#_snippet_1\n\nLANGUAGE: js\nCODE:\n```\nimport {SphericalCoordinates} from '@math.gl/core';\n\n```\n\n----------------------------------------\n\nTITLE: Importing the Euler Class from math.gl Core Module (JavaScript)\nDESCRIPTION: Demonstrates the canonical approach to import the Euler class from math.gl's core module for use in an application. Required dependency is the '@math.gl/core' package, and the imported symbol Euler provides access to all documented rotation-related properties and methods. No input or output is directly involved in this snippet.\nSOURCE: https://github.com/visgl/math.gl/blob/master/docs/modules/core/api-reference/euler.md#_snippet_1\n\nLANGUAGE: js\nCODE:\n```\nimport {Euler} from '@math.gl/core';\n```\n\n----------------------------------------\n\nTITLE: Transforming a Vector as a Point Using Matrix4 in JavaScript\nDESCRIPTION: This snippet demonstrates how to transform a 2, 3, or 4-element vector as a point by multiplying it (from the right) with a Matrix4 instance using the transformPoint method. Required dependency is a Matrix4 class implementation from math.gl. The vector input can be an Array, Vector2, Vector3, or Vector4, and an optional 'out' parameter controls output allocation. If no 'out' is provided, the output type will match the input vector's length. The operation applies translation components and manages homogeneous coordinates, ensuring the output w-component is 1.\nSOURCE: https://github.com/visgl/math.gl/blob/master/docs/modules/core/api-reference/matrix4.md#_snippet_6\n\nLANGUAGE: javascript\nCODE:\n```\nconst vector = matrix4.transformPoint(vector, out=)\n```\n\n----------------------------------------\n\nTITLE: Converting Cartographic to Cartesian Coordinates with Ellipsoid.WGS84 - JavaScript\nDESCRIPTION: This snippet demonstrates converting a position from cartographic coordinates (longitude, latitude, height) to cartesian coordinates using the Ellipsoid.WGS84 class from @math.gl/geospatial. It depends on the @math.gl/core and @math.gl/geospatial packages. Longitude and latitude must be provided in radians, requiring conversion with toRadians(). The output is a JavaScript array representing the cartesian position suitable for 3D mapping contexts.\nSOURCE: https://github.com/visgl/math.gl/blob/master/docs/modules/geospatial/README.md#_snippet_0\n\nLANGUAGE: js\nCODE:\n```\nimport {toRadians} from '@math.gl/core';\nimport {Ellipsoid} from '@math.gl/geospatial';\nconst cartographicPosition = [toRadians(21), toRadians(78), 5000];\nconst cartesianPosition = Ellipsoid.WGS84.cartographicToCartesian(cartographicPosition);\n```\n\n----------------------------------------\n\nTITLE: Importing Experimental Namespace (Pre-v2.x, JavaScript)\nDESCRIPTION: This snippet shows the legacy approach to importing experimental features in math.gl v1.x, where modules were accessed via the experimental namespace. The code imports the experimental namespace and destructures the Euler class from it. Requires math.gl v1.x. The 'experimental' namespace and its members have been removed in newer versions.\nSOURCE: https://github.com/visgl/math.gl/blob/master/docs/upgrade-guide.md#_snippet_4\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport {experimental} from '@math.gl/core';\\nconst {Euler} = experimental;\n```\n\n----------------------------------------\n\nTITLE: Defining the distanceSquaredTo Method Signature (TypeScript)\nDESCRIPTION: Defines the signature for the `distanceSquaredTo` method. It computes the estimated squared distance from a given point to the closest point on the bounding sphere and returns this distance as a number. The specific type of the `point` parameter is not explicitly defined in this signature.\nSOURCE: https://github.com/visgl/math.gl/blob/master/docs/modules/culling/api-reference/bounding-volume.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\ndistanceSquaredTo(point) : Number\n```\n\n----------------------------------------\n\nTITLE: Importing and Using cutPolylineByMercatorBounds in JavaScript\nDESCRIPTION: Demonstrates importing the `cutPolylineByMercatorBounds` function from `@math.gl/polygon` and applying it to a sample polyline defined by a flat array of coordinates. The function splits the polyline based on Mercator bounds, specifically designed to handle crossings of the 180th meridian. The example shows input coordinates and the resulting split coordinates.\nSOURCE: https://github.com/visgl/math.gl/blob/master/docs/modules/polygon/api-reference/cut-polyline-by-mercator-bounds.md#_snippet_0\n\nLANGUAGE: js\nCODE:\n```\nimport {cutPolylineByMercatorBounds} from '@math.gl/polygon';\n\ncutPolylineByMercatorBounds([-10, -10, 10, 10, 30, -10], {size: 2, gridResolution: 10});\n// returns [-10, -10, 0, 0, 10, 10, 20, 0, 30, -10]\n```\n\n----------------------------------------\n\nTITLE: Scaling Vector3 Component-wise by Vectors in JavaScript\nDESCRIPTION: This snippet shows two examples of scaling a Vector3 using another vector, enabling selective zeroing or sign flipping of components. Each scale operation takes an array with three numbers; the method multiplies each component of the original vector by the corresponding value. It requires no additional dependencies beyond Vector3.\nSOURCE: https://github.com/visgl/math.gl/blob/master/docs/modules/core/api-reference/vector3.md#_snippet_5\n\nLANGUAGE: js\nCODE:\n```\nconst u = v.scale([1, 1, 0]); // Set z component to zero\nconst w = v.scale([1, -1, 1]); // Flip y component\n```\n\n----------------------------------------\n\nTITLE: Defining the intersectPlane Method Signature (TypeScript)\nDESCRIPTION: Defines the signature for the `intersectPlane` method within the `BoundingVolume` interface. It takes a `Plane` object as input and returns an `INTERSECTION` enum value (`INTERSECTION.INSIDE`, `INTERSECTION.OUTSIDE`, or `INTERSECTION.INTERSECTING`) indicating the bounding volume's position relative to the plane.\nSOURCE: https://github.com/visgl/math.gl/blob/master/docs/modules/culling/api-reference/bounding-volume.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nintersectPlane(plane : Plane) : INTERSECTION\n```\n\n----------------------------------------\n\nTITLE: Defining `BigTypedArray` Type Alias in TypeScript\nDESCRIPTION: Defines a TypeScript type alias `BigTypedArray` that represents any \"big\" JavaScript typed array, specifically `BigInt64Array` or `BigUint64Array`.\nSOURCE: https://github.com/visgl/math.gl/blob/master/docs/modules/types/api-reference/array-types.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nBigTypedArray\n```\n\n----------------------------------------\n\nTITLE: Defining a Union Type for 2D/3D Bounds in TypeScript\nDESCRIPTION: Exports a TypeScript type alias `Bounds` representing either 2D or 3D geometric bounds. Bounds are defined as a tuple containing two points (arrays of numbers): the minimum corner `[minX, minY]` or `[minX, minY, minZ]` and the maximum corner `[maxX, maxY]` or `[maxX, maxY, maxZ]`. This type is used across vis.gl frameworks.\nSOURCE: https://github.com/visgl/math.gl/blob/master/docs/modules/types/api-reference/bounds.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport type Bounds =\n  | [[number, number], [number, number]]\n  | [[number, number, number], [number, number, number]];\n```\n\n----------------------------------------\n\nTITLE: Inverting a Matrix4 Instance in JavaScript\nDESCRIPTION: Illustrates how to compute the inverse of an existing Matrix4 instance using the invert method. This operation is critical for tasks such as transforming objects from world to local space, or for camera manipulations. The snippet assumes 'matrix' is a Matrix4 instance. Inversion may fail if the matrix is singular (determinant is zero).\nSOURCE: https://github.com/visgl/math.gl/blob/master/docs/modules/core/api-reference/matrix4.md#_snippet_3\n\nLANGUAGE: JavaScript\nCODE:\n```\nconst inverse = matrix.invert();\n```\n\n----------------------------------------\n\nTITLE: Constructing a CullingVolume from Planes in JavaScript\nDESCRIPTION: The CullingVolume constructor initializes an instance from an array of Plane objects, where each plane is defined as a Cartesian4 (x, y, z for normal unit vector, w for distance from origin). The optional planes parameter defaults to an empty array, supporting arbitrary culling regions. Prerequisites include valid Plane representations. Inputs are arrays of planes; the output is a new CullingVolume object.\nSOURCE: https://github.com/visgl/math.gl/blob/master/docs/modules/culling/api-reference/culling-volume.md#_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\n/*\nconstructor([planes : Plane[]])\n- `planes` = `[]` An array of clipping planes.\nEach plane is represented by a Cartesian4 object, where the x, y, and z components define the unit vector normal to the plane, and the w component is the distance of the plane from the origin.\n*/\n```\n\n----------------------------------------\n\nTITLE: Defining Static Plane Masks in JavaScript\nDESCRIPTION: These static properties serve as special constants for plane masks, which classify bounding volumes as entirely outside, inside, or indeterminate with respect to a given culling volume. Intended for use with the computeVisibilityWithPlaneMask method, these masks simplify and optimize hierarchical culling evaluations by encoding the spatial relationship between objects and planes. No dependencies required, though meaningful only in the context of a CullingVolume instance.\nSOURCE: https://github.com/visgl/math.gl/blob/master/docs/modules/culling/api-reference/culling-volume.md#_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// For plane masks (as used in `CullingVolume#computeVisibilityWithPlaneMask`), this special\n// value represents the case where the object bounding volume is entirely outside the culling volume.\nCullingVolume.MASK_OUTSIDE;\n\n// For plane masks (as used in `CullingVolume.computeVisibilityWithPlaneMask`), this value represents\n// the case where the object bounding volume is entirely inside the culling volume.\nCullingVolume.MASK_INSIDE;\n\n// For plane masks (as used in`CullingVolume.computeVisibilityWithPlaneMask`), this value represents\n// the case where the object bounding volume (may) intersect all planes of the culling volume.\nCullingVolume.MASK_INDETERMINATE;\n```\n\n----------------------------------------\n\nTITLE: Computing East-North-Up to Fixed Frame Transform with Ellipsoid.WGS84 - JavaScript\nDESCRIPTION: This snippet shows how to get a local east-north-up to Earth's fixed frame transformation matrix at a specified cartographic position using the Ellipsoid.WGS84 class from @math.gl/geospatial. Requires only the @math.gl/geospatial package. The input is an array specifying the cartographic position (longitude, latitude, height), and the output is a transformation matrix suitable for frame-of-reference conversions in geospatial applications.\nSOURCE: https://github.com/visgl/math.gl/blob/master/docs/modules/geospatial/README.md#_snippet_2\n\nLANGUAGE: js\nCODE:\n```\nimport {Ellipsoid} from '@math.gl/geospatial';\nconst transformMatrix = Ellipsoid.WGS84.eastNorthUpToFixedFrame([0, 0, 0]);\n```\n\n----------------------------------------\n\nTITLE: Importing Polygon Class from math.gl in JavaScript\nDESCRIPTION: Demonstrates how to import the Polygon class from the '@math.gl/polygon' package in a JavaScript environment. This is typically required before creating Polygon instances or accessing its geometric methods. The example assumes that math.gl has been installed as a project dependency and that the code is being executed in an environment supporting ES Module syntax. No additional parameters are required for importing, and the Polygon class becomes available for use in subsequent code.\nSOURCE: https://github.com/visgl/math.gl/blob/master/docs/modules/polygon/api-reference/polygon.md#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport {Polygon} from '@math.gl/polygon';\n```\n\n----------------------------------------\n\nTITLE: Inverting a Matrix3 Instance (JavaScript)\nDESCRIPTION: Shows how to compute the inverse of an existing Matrix3 instance using the `invert` method. The result is stored in a new constant `inverse`. Matrix inversion is useful for reversing transformations.\nSOURCE: https://github.com/visgl/math.gl/blob/master/docs/modules/core/api-reference/matrix3.md#_snippet_2\n\nLANGUAGE: js\nCODE:\n```\nconst inverse = matrix.invert();\n```\n\n----------------------------------------\n\nTITLE: Instantiating a Vector2 Object in JavaScript\nDESCRIPTION: Demonstrates the basic usage of the Vector2 class by importing it from the '@math.gl/core' module and creating a new Vector2 instance initialized with x=1 and y=1. This shows the primary way to create and use a 2D vector with the library.\nSOURCE: https://github.com/visgl/math.gl/blob/master/docs/modules/core/api-reference/vector2.md#_snippet_0\n\nLANGUAGE: js\nCODE:\n```\nimport {Vector2} from '@math.gl/core';\nconst vector = new Vector2(1, 1);\n```\n\n----------------------------------------\n\nTITLE: Example Usage of transformWithoutScale in JavaScript\nDESCRIPTION: This JavaScript code snippet, found within a commented-out section, demonstrates how to use a `transformWithoutScale` method (presumably from the Cesium library or a related context). It involves creating a transformation matrix using `Transforms.eastNorthUpToFixedFrame`, initializing a `BoundingSphere`, and then applying the scale-free transformation to it.\nSOURCE: https://github.com/visgl/math.gl/blob/master/docs/modules/culling/api-reference/bounding-volume.md#_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nvar modelMatrix = Transforms.eastNorthUpToFixedFrame(positionOnEllipsoid);\nvar boundingSphere = new BoundingSphere();\nvar newBoundingSphere = BoundingSphere.transformWithoutScale(boundingSphere, modelMatrix);\n```\n\n----------------------------------------\n\nTITLE: Installing @math.gl/sun via npm\nDESCRIPTION: This command uses the Node Package Manager (npm) to install the `@math.gl/sun` library and add it as a dependency to the current project. Requires Node.js and npm to be installed.\nSOURCE: https://github.com/visgl/math.gl/blob/master/docs/modules/sun/README.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm install @math.gl/sun\n```\n\n----------------------------------------\n\nTITLE: Defining the clipPolygon Function Signature and Options in JavaScript\nDESCRIPTION: This snippet outlines the function signature for `clipPolygon`. It takes a flat array of vertex `positions` (Array or TypedArray), a `bbox` array defining the bounding box `[minX, minY, maxX, maxY]`, and an optional `options` object. Options include `size` (number of elements per vertex, default 2), `startIndex` (default 0), and `endIndex` (default `positions.length`). The function returns a new flat array representing the clipped polygon's vertices or an empty array if there's no overlap.\nSOURCE: https://github.com/visgl/math.gl/blob/master/docs/modules/polygon/api-reference/clip-polygon.md#_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\n```js\nclipPolygon(positions, bbox, [options]);\n```\n```\n\n----------------------------------------\n\nTITLE: Creating and Accessing a Vector2 Instance (JavaScript)\nDESCRIPTION: Demonstrates basic usage of the Vector2 class from the @math.gl/core library. It shows how to import the class, instantiate a new 2D vector with specific coordinates (1, 2), and access its components using standard array indexing.\nSOURCE: https://github.com/visgl/math.gl/blob/master/docs/modules/core/README.md#_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport {Vector2} from '@math.gl/core';\nconst vector = new Vector2(1, 2);\nconst x = vector[0];\nconst y = vector[1];\n```\n\n----------------------------------------\n\nTITLE: Vector2 Constructor Signatures in JavaScript\nDESCRIPTION: Illustrates the constructor signatures for the Vector2 class. A new Vector2 can be created by providing individual x and y components (defaulting to 0 if omitted) or by passing an array containing the x and y values. This allows for flexible initialization.\nSOURCE: https://github.com/visgl/math.gl/blob/master/docs/modules/core/api-reference/vector2.md#_snippet_1\n\nLANGUAGE: js\nCODE:\n```\nconstructor((x = 0), (y = 0));\nconstructor([x, y]);\n```\n\n----------------------------------------\n\nTITLE: Mathematical Definition of an Orthographic Projection Matrix (MathML)\nDESCRIPTION: Presents the mathematical formula for an orthographic projection matrix in MathML format. It details how the matrix scales and translates input coordinates based on the provided `left`, `right`, `bottom`, `top`, `near`, and `far` plane values to map the defined view-space box onto the normalized clipspace cube [-1, 1] used by the GPU.\nSOURCE: https://github.com/visgl/math.gl/blob/master/docs/developer-guide/math/view-and-projection.md#_snippet_4\n\nLANGUAGE: mathml\nCODE:\n```\n<math display=\"block\">\n  <mrow>\n    <mfenced open=\"[\" close=\"]\">\n    <mtable>\n      <mtr>\n        <mtd columnalign=\"center\"><msub><mi>scale</mi><mn>x</mn></msub></mtd>\n        <mtd columnalign=\"center\"><mi>...</mi></mtd>\n        <mtd columnalign=\"center\"><mi>...</mi></mtd>\n        <mtd columnalign=\"center\"><msub><mi>translate</mi><mi>x</mi></msub></mtd>\n      </mtr>\n      <mtr>\n        <mtd columnalign=\"center\"><mi>...</mi></mtd>\n        <mtd columnalign=\"center\"><msub><mi>scale</mi><mn>y</mn></msub></mtd>\n        <mtd columnalign=\"center\"><mi>...</mi></mtd>\n        <mtd columnalign=\"center\"><msub><mi>translate</mi><mi>y</mi></msub></mtd>\n      </mtr>\n      <mtr>\n        <mtd columnalign=\"center\"><mi>...</mi></mtd>\n        <mtd columnalign=\"center\"><mi>...</mi></mtd>\n        <mtd columnalign=\"center\"><msub><mi>scale</mi><mn>z</mn></msub></mtd>\n        <mtd columnalign=\"center\"><msub><mi>translate</mi><mi>z</mi></msub></mtd>\n      </mtr>\n      <mtr>\n        <mtd columnalign=\"center\"><mi>...</mi></mtd>\n        <mtd columnalign=\"center\"><mi>...</mi></mtd>\n        <mtd columnalign=\"center\"><mi>...</mi></mtd>\n        <mtd columnalign=\"center\"><msub><mi>scale</mi><mi>global</mi></msub></mtd>\n      </mtr>\n    </mtable>\n    </mfenced>\n\n    <mo>=</mo>\n\n    <mfenced open=\"[\" close=\"]\">\n    <mtable>\n      <mtr>\n        <mtd columnalign=\"center\"><mfrac><mn>-2</mn><mi>left - right</mi></mfrac></mtd>\n        <mtd columnalign=\"center\"><mn>0</mn></mtd>\n        <mtd columnalign=\"center\"><mn>0</mn></mtd>\n        <mtd columnalign=\"center\"><mfrac><mi>left + right</mi><mi>left - right</mi></mfrac></mtd>\n      </mtr>\n      <mtr>\n        <mtd columnalign=\"center\"><mn>0</mn></mtd>\n        <mtd columnalign=\"center\"><mfrac><mn>-2</mn><mi>bottom - top</mi></mfrac></mtd>\n        <mtd columnalign=\"center\"><mn>0</mn></mtd>\n        <mtd columnalign=\"center\"><mfrac><mi>bottom + top</mi><mi>bottom - top</mi></mfrac></mtd>\n      </mtr>\n      <mtr>\n        <mtd columnalign=\"center\"><mn>0</mn></mtd>\n        <mtd columnalign=\"center\"><mn>0</mn></mtd>\n        <mtd columnalign=\"center\"><mfrac><mn>2</mn><mi>near - far</mi></mfrac></mtd>\n        <mtd columnalign=\"center\"><mfrac><mi>near + far</mi><mi>near - far</mi></mfrac></mtd>\n      </mtr>\n      <mtr>\n        <mtd columnalign=\"center\"><mn>0</mn></mtd>\n        <mtd columnalign=\"center\"><mn>0</mn></mtd>\n        <mtd columnalign=\"center\"><mn>0</mn></mtd>\n        <mtd columnalign=\"center\"><mn>1</mn></mtd>\n      </mtr>\n    </mtable>\n    </mfenced>\n\n  </mrow>\n</math>\n```\n\n----------------------------------------\n\nTITLE: Getting the Center Coordinates of an S2 Cell Using Math.gl (JavaScript)\nDESCRIPTION: The function `getS2Center` computes the center longitude and latitude (as an array of numbers) for a given S2 cell token string. It requires the S2 token as input and returns a `number[]` representing the [longitude, latitude] of the cell's center point. The output is suitable for geospatial visualization or analysis. Input must be a valid S2 token; the cell must be properly defined within the S2 grid.\nSOURCE: https://github.com/visgl/math.gl/blob/master/docs/modules/dggs-s2/api-reference/s2.md#_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\ngetS2Center(s2Token: string): number[]\n```\n\n----------------------------------------\n\nTITLE: Transforming Vectors as Directions with Matrix3 (JavaScript)\nDESCRIPTION: Illustrates transforming 2D and 3D vectors as directions using the `transformDirection` method of a Matrix3 instance. This transformation specifically excludes any translation components defined in the matrix, applying only rotation and scaling.\nSOURCE: https://github.com/visgl/math.gl/blob/master/docs/modules/core/api-reference/matrix3.md#_snippet_4\n\nLANGUAGE: js\nCODE:\n```\nconst transform = new Matrix3();\nconst vector2 = transform.transformDirection([1, 2]);\nconst vector3 = transform.transformDirection([1, 2, 1]);\n```\n\n----------------------------------------\n\nTITLE: Defining Fixed-Length `NumberArray` Type Aliases in TypeScript\nDESCRIPTION: Defines TypeScript type aliases (`NumberArray2` through `NumberArray16`) representing standard JavaScript number arrays of specific, fixed lengths from 2 to 16 elements. These are useful for representing vectors or matrices of known sizes.\nSOURCE: https://github.com/visgl/math.gl/blob/master/docs/modules/types/api-reference/array-types.md#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nNumberArray2-NumberArray16\n```\n\n----------------------------------------\n\nTITLE: Defining `BigTypedArrayConstructor` Type Alias in TypeScript\nDESCRIPTION: Defines a TypeScript type alias `BigTypedArrayConstructor` representing the constructor for any \"big\" JavaScript typed array (`BigInt64Array` or `BigUint64Array`).\nSOURCE: https://github.com/visgl/math.gl/blob/master/docs/modules/types/api-reference/array-types.md#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nBigTypedArrayConstructor\n```\n\n----------------------------------------\n\nTITLE: Getting Quadkey Boundary Vertices using JavaScript\nDESCRIPTION: Calculates the boundary vertices (corners) for a given quadkey cell. It accepts a quadkey string and returns an array of coordinate pairs `[[lng1, lat1], [lng2, lat2], ...]` representing the boundary polygon. This function belongs to the experimental QuadKey module.\nSOURCE: https://github.com/visgl/math.gl/blob/master/docs/modules/dggs-quadkey/api-reference/quadkey.md#_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\n`getQuadkeyBoundary(quadkey: string): number[][]`\n```\n\n----------------------------------------\n\nTITLE: Retrieving Longitude/Latitude from Quadkey (JavaScript)\nDESCRIPTION: Shows how to import and use the `getQuadkeyLngLat` function from the `@math.gl/dggs-quadkey` library to obtain the center longitude and latitude coordinates corresponding to a given quadkey string. Requires the `@math.gl/dggs-quadkey` library to be installed. The input `quadkey` variable is expected to hold a valid quadkey string.\nSOURCE: https://github.com/visgl/math.gl/blob/master/docs/modules/dggs-quadkey/README.md#_snippet_1\n\nLANGUAGE: js\nCODE:\n```\nimport {getQuadkeyLngLat} from '@math.gl/dggs-quadkey';\nconst center = getQuadkeyLngLat(quadkey);\n```\n\n----------------------------------------\n\nTITLE: Creating a Plane Instance using math.gl Plane - JavaScript\nDESCRIPTION: This JavaScript snippet demonstrates how to import the Plane class from the '@math.gl/culling' package and instantiate a plane representing the equation x = 0 by specifying a normal vector and a distance. The constructor requires a normalized normal vector and the signed distance from the origin. The resulting Plane instance can be used for spatial computations like collision detection or geometry queries. Dependencies: '@math.gl/culling'. Parameters: normal ([1, 0, 0]) defines the x direction, distance (0.0) positions the plane at the origin.\nSOURCE: https://github.com/visgl/math.gl/blob/master/docs/modules/culling/api-reference/plane.md#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport {Plane} from '@math.gl/culling';\nconst plane = new Plane([1, 0, 0], 0.0);\n```\n\n----------------------------------------\n\nTITLE: Sorting Bounding Boxes Back-to-Front in math.gl - JavaScript\nDESCRIPTION: This snippet shows how to sort an array of OrientedBoundingBox instances from back to front relative to a camera position using the distanceSquaredTo method. Requires an array of OrientedBoundingBox objects ('boxes') and a camera object with a 'positionWC' property. The comparison uses squared distance for performance, and result ordering is suitable for operations such as rendering or culling in 3D engines.\nSOURCE: https://github.com/visgl/math.gl/blob/master/docs/modules/culling/api-reference/oriented-bounding-box.md#_snippet_1\n\nLANGUAGE: JavaScript\nCODE:\n```\nboxes.sort(\\n  (boxA, boxB) =>\\n    boxB.distanceSquaredTo(camera.positionWC) - boxA.distanceSquaredTo(camera.positionWC)\\n);\n```\n\n----------------------------------------\n\nTITLE: Decoding S2 Token to Index Using Math.gl (JavaScript)\nDESCRIPTION: This function, `getIndexFromS2Token`, decodes an S2 token string into its 64-bit index representation, returned as a `Long` type. It requires the S2 token as input and depends on the math.gl S2 module. The result is a 64-bit integer-like object representing the cell index, which can be used by other API functions. The input must be a valid S2 token string; invalid input may cause errors or undefined behavior.\nSOURCE: https://github.com/visgl/math.gl/blob/master/docs/modules/dggs-s2/api-reference/s2.md#_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\ngetIndexFromS2Token(s2Token: string): Long\n```\n\n----------------------------------------\n\nTITLE: Get GeoHash Boundary Polygon (TypeScript/JavaScript)\nDESCRIPTION: This function signature defines `getGeohashBoundary`, which takes a GeoHash string and returns the boundary of the corresponding GeoHash cell as a polygon. The output is an array of coordinate pairs `[[lng, lat], [lng, lat], ...]`, representing the vertices of the boundary. It requires the math.gl GeoHash module.\nSOURCE: https://github.com/visgl/math.gl/blob/master/docs/modules/dggs-geohash/api-reference/geohash.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ngetGeohashBoundary(geohash: string): number[][]\n```\n\n----------------------------------------\n\nTITLE: Get GeoHash Center Coordinates (TypeScript/JavaScript)\nDESCRIPTION: This function signature defines `getGeohashLngLat`, which takes a GeoHash string as input and returns the longitude and latitude coordinates of the center of the corresponding GeoHash cell as an array of two numbers `[lng, lat]`. It depends on the math.gl GeoHash module.\nSOURCE: https://github.com/visgl/math.gl/blob/master/docs/modules/dggs-geohash/api-reference/geohash.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ngetGeohashLngLat(geohash: string): number[]\n```\n\n----------------------------------------\n\nTITLE: Plane Mask-Based Bounding Volume Culling in JavaScript\nDESCRIPTION: This method extends computeVisibility to hierarchical culling scenarios by utilizing parent plane masks. It determines the intersection state by bitmasking against plane relationships and returns a mask encoding potential child volume states. Inputs include a bounding volume and a parent bit mask, which allows for efficient culling by skipping redundant plane checks. The output is a plane mask for further traversal or culling.\nSOURCE: https://github.com/visgl/math.gl/blob/master/docs/modules/culling/api-reference/culling-volume.md#_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\n/*\ncomputeVisibilityWithPlaneMask(boundingVolume : Object, parentPlaneMask : Number) : Number\nDetermines whether a bounding volume intersects the culling volume.\n- `boundingVolume` The bounding volume whose intersection with the culling volume is to be tested.\n- `parentPlaneMask` A bit mask from the boundingVolume's parent's check against the same culling volume, such that if `planeMask & (1 << planeIndex) === 0`, for `k < 31`, then the parent (and therefore this) volume is completely inside `plane[planeIndex]` and that plane check can be skipped.\nReturns:\n- A plane mask as described above (which can be applied to this boundingVolume's children).\n*/\n```\n\n----------------------------------------\n\nTITLE: Importing and Using Matrix4.transform Returning Array (JavaScript)\nDESCRIPTION: This snippet shows the post-v3.0 usage of Matrix4.transform, where the method now returns a standard JavaScript Array if the result parameter is omitted. It demonstrates the import of Matrix4, transformation of a vector, and a type assertion. Requires '@math.gl/core' and a test library. Inputs: a 4D number array. Output: a regular Array.\nSOURCE: https://github.com/visgl/math.gl/blob/master/docs/upgrade-guide.md#_snippet_1\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport {Matrix4} from '@math.gl/core';\\nconst vector = new Matrix4().transform([0, 0, 0, 1]);\\nassert(vector instanceof Array);\n```\n\n----------------------------------------\n\nTITLE: earcut Function Signature and Parameters in JavaScript\nDESCRIPTION: Defines the function signature for the `earcut` utility from `@math.gl/polygon`. It accepts mandatory `positions` (vertex coordinates), optional `holeIndices`, `size` (coordinates per vertex, default 2), optional precomputed `areas`, and an optional projection `plane` ('xy', 'yz', 'xz', default 'xy') for 3D polygons. It returns an array of triangle indices.\nSOURCE: https://github.com/visgl/math.gl/blob/master/docs/modules/polygon/api-reference/earcut.md#_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nearcut(positions[, holeIndices, size = 2, areas, plane]);\n```\n\n----------------------------------------\n\nTITLE: Importing and Using Matrix4.transform Returning Vector4 (JavaScript)\nDESCRIPTION: This snippet illustrates pre-v3.0 usage of the Matrix4.transform method with math.gl, which returned a Vector4 instance by default when the result parameter was not supplied. It demonstrates the import of Matrix4 and Vector4 from the '@math.gl/core' package, the transformation of a vector, and confirming the resulting type with an assertion. Requires '@math.gl/core' and a testing assertion library. Inputs: a 4D number array. Output: a Vector4 instance.\nSOURCE: https://github.com/visgl/math.gl/blob/master/docs/upgrade-guide.md#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport {Matrix4, Vector4} from '@math.gl/core';\\nconst vector = new Matrix4().transform([0, 0, 0, 1]);\\nassert(vector instanceof Vector4);\n```\n\n----------------------------------------\n\nTITLE: Defining a Type for 2D Bounds in TypeScript\nDESCRIPTION: Defines a TypeScript type alias `Bounds2D` specifically for 2D geometric bounds. It represents a bounding box using a tuple of two 2-element arrays: `[[minX, minY], [maxX, maxY]]`.\nSOURCE: https://github.com/visgl/math.gl/blob/master/docs/modules/types/api-reference/bounds.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ntype Bounds2D = [[number, number], [number, number]];\n```\n\n----------------------------------------\n\nTITLE: Declaring the Euler Class for 3D Rotation (math.gl, JavaScript)\nDESCRIPTION: Defines the Euler class extending both MathArray and Array for advanced manipulation of 3D rotation by Euler angles. This snippet establishes the class scaffolding upon which subsequent rotation logic, methods, and properties are built. Dependencies include MathArray and Array; no constructor logic or member definitions are included directly in this line.\nSOURCE: https://github.com/visgl/math.gl/blob/master/docs/modules/core/api-reference/euler.md#_snippet_0\n\nLANGUAGE: js\nCODE:\n```\nclass Euler extends MathArray extends Array\n```\n\n----------------------------------------\n\nTITLE: Validating WGS84 Coordinates Using math.gl Geospatial in JavaScript\nDESCRIPTION: This snippet demonstrates how to import and use the isWGS84 function from the @math.gl/geospatial package to check if a set of 3D coordinates is close to the Earth's surface according to the WGS84 ellipsoid. It requires the math.gl/geospatial library to be installed as a dependency. The function takes an array of three numbers representing a 3D position and returns a boolean indicating proximity to the WGS84 ellipsoid surface. Limitations may include the accuracy of the geospatial model and input units, which are expected to be consistent with the function's requirements.\nSOURCE: https://github.com/visgl/math.gl/blob/master/docs/modules/geospatial/api-reference/helpers.md#_snippet_0\n\nLANGUAGE: js\nCODE:\n```\nimport {isWGS84} from '@math.gl/geospatial';\nisWGS84([17832.12, 83234.52, 952313.73]);\n```\n\n----------------------------------------\n\nTITLE: Inefficient Object Creation within a Loop (JavaScript)\nDESCRIPTION: This snippet highlights a common performance bottleneck where a new `Vector3` object is created in each iteration of a loop using `new Vector3(x, y, z)`. This frequent object allocation can significantly impact performance due to garbage collection overhead. It assumes the existence of the `Vector3` class, likely from `@math.gl/core`.\nSOURCE: https://github.com/visgl/math.gl/blob/master/docs/developer-guide/performance.md#_snippet_2\n\nLANGUAGE: js\nCODE:\n```\nfor (...) {\n\tconst v = new Vector3(x, y, z);\n}\n```\n\n----------------------------------------\n\nTITLE: Function Signature for cutPolygonByGrid in JavaScript\nDESCRIPTION: Shows the function signature for `cutPolygonByGrid`. It requires `positions` (a flat array of vertex coordinates) and accepts optional `holeIndices` (indices indicating the start of holes) and an `options` object for configuration (like `size`, `gridResolution`, `gridOffset`, `edgeTypes`).\nSOURCE: https://github.com/visgl/math.gl/blob/master/docs/modules/polygon/api-reference/cut-polygon-by-grid.md#_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\ncutPolygonByGrid(positions, holeIndices, [options]);\n```\n\n----------------------------------------\n\nTITLE: Converting SphericalCoordinates to Vector3 Direction in JavaScript\nDESCRIPTION: Shows how to convert a SphericalCoordinates object into a direction Vector3, which represents the Cartesian vector corresponding to the current spherical settings. Assumes the Vector3 class or equivalent is available in the environment. No arguments are required unless a custom center is needed. Returns a Vector3 array or object.\nSOURCE: https://github.com/visgl/math.gl/blob/master/docs/modules/core/api-reference/spherical-coordinates.md#_snippet_3\n\nLANGUAGE: js\nCODE:\n```\nconst direction = new SphericalCoordinates().toVector3();\n\n```\n\n----------------------------------------\n\nTITLE: Installing @math.gl/web-mercator via npm (Shell)\nDESCRIPTION: This command uses the Node Package Manager (npm) to install the `@math.gl/web-mercator` library and add it as a dependency to the current project's `package.json` file. Requires Node.js and npm to be installed.\nSOURCE: https://github.com/visgl/math.gl/blob/master/docs/modules/web-mercator/README.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nnpm install @math.gl/web-mercator --save\n```\n\n----------------------------------------\n\nTITLE: Installing @math.gl/dggs-geohash using npm - Bash\nDESCRIPTION: Installs the @math.gl/dggs-geohash library via npm. This step is a prerequisite for using any of the library's geohash utilities in JavaScript. Run this command in your project's root directory to add the package as a dependency; requires npm to be installed.\nSOURCE: https://github.com/visgl/math.gl/blob/master/docs/modules/dggs-geohash/README.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm install @math.gl/dggs-geohash\n```\n\n----------------------------------------\n\nTITLE: Instantiating SphericalCoordinates with Different Parameterizations in JavaScript\nDESCRIPTION: Illustrates how to create SphericalCoordinates objects using various parameter conventions: either with spherical (phi, theta), camera (pitch, bearing), or geographic (longitude, latitude) naming. Each approach requires a JavaScript object with named parameters; the interpretation depends on the naming chosen. The default radius/altitude/z is 1.0 if not specified. Returns a SphericalCoordinates instance; expects valid angular or geographic values as inputs.\nSOURCE: https://github.com/visgl/math.gl/blob/master/docs/modules/core/api-reference/spherical-coordinates.md#_snippet_2\n\nLANGUAGE: js\nCODE:\n```\nconst spherical = new SphericalCoordinates({phi: 0, theta: 0});\nconst spherical = new SphericalCoordinates({pitch: 0, bearing: 0});\nconst spherical = new SphericalCoordinates({longitude: 0, latitude: 0});\n\n```\n\n----------------------------------------\n\nTITLE: Installing @math.gl/dggs-quadkey using npm (Bash)\nDESCRIPTION: Demonstrates how to install the `@math.gl/dggs-quadkey` library using the Node Package Manager (npm). Requires npm and Node.js to be installed. This command downloads and installs the package and its dependencies into the current project's `node_modules` directory.\nSOURCE: https://github.com/visgl/math.gl/blob/master/docs/modules/dggs-quadkey/README.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm install @math.gl/dggs-quadkey\n```\n\n----------------------------------------\n\nTITLE: Accessing and Setting Vector3 Properties in JavaScript\nDESCRIPTION: This snippet shows how to use property accessors (e.g., .x) to set or read the elements of a Vector3 instance. Modification through properties automatically syncs with the underlying array representation, allowing both dot and bracket notation. No additional dependencies are required.\nSOURCE: https://github.com/visgl/math.gl/blob/master/docs/modules/core/api-reference/vector3.md#_snippet_2\n\nLANGUAGE: js\nCODE:\n```\nv.x = 2;\nassert(v[0] === v.x);\n```\n\n----------------------------------------\n\nTITLE: Subdividing a Polyline with Grid using math.gl (JavaScript)\nDESCRIPTION: This example demonstrates how to import and use the cutPolylineByGrid function from the @math.gl/polygon package to subdivide a polyline defined by a flat array of coordinates via grid intersection. The snippet invokes cutPolylineByGrid with an array of vertex positions and an options object specifying the vertex size and grid resolution. To run this example, you must have the @math.gl/polygon module installed. The main parameters control the granularity of the subdivision and the shape of the returned polylines. The expected output is a new array of polyline positions subdivided along the grid; the type of output (flat array vs. array of arrays) depends on the options used.\nSOURCE: https://github.com/visgl/math.gl/blob/master/docs/modules/polygon/api-reference/cut-polyline-by-grid.md#_snippet_0\n\nLANGUAGE: js\nCODE:\n```\nimport {cutPolylineByGrid} from '@math.gl/polygon';\n\ncutPolylineByGrid([-10, -10, 10, 10, 30, -10], {size: 2, gridResolution: 10});\n// returns [-10, -10, 0, 0, 10, 10, 20, 0, 30, -10]\n```\n\n----------------------------------------\n\nTITLE: Projecting Meter Offsets to Pixels (High Precision) - GLSL\nDESCRIPTION: This GLSL snippet implements a high precision conversion from meter offsets to pixel offsets, introducing an additional uniform (unitsPerMeter2) to model the effect of latitude variation on pixel scaling. This approach is recommended when highPrecision:true is passed to math.gl\\'s getDistanceScales, improving accuracy for large or high-latitude offsets. It requires both unitsPerMeter and unitsPerMeter2 uniforms, expects a vec3 meters input, and returns the corrected pixel offset.\nSOURCE: https://github.com/visgl/math.gl/blob/master/docs/developer-guide/geospatial/web-mercator-offset-accuracy.md#_snippet_1\n\nLANGUAGE: GLSL\nCODE:\n```\nuniform vec3 unitsPerMeter;\nuniform vec3 unitsPerMeter2;\nvec3 meters_offset_to_pixels_offset_adjusted(vec3 meters) {\n    return meters * (unitsPerMeter + unitsPerMeter2 * meters.y);\n}\n```\n\n----------------------------------------\n\nTITLE: Importing Polygon Utilities from @math.gl/polygon (JavaScript)\nDESCRIPTION: This snippet demonstrates how to import the `getPolygonWindingDirection` function from the `@math.gl/polygon` package using ES6 module syntax. This makes the function available for use in the current scope. The `@math.gl/polygon` package must be installed as a dependency.\nSOURCE: https://github.com/visgl/math.gl/blob/master/docs/modules/polygon/api-reference/polygon-utils.md#_snippet_0\n\nLANGUAGE: js\nCODE:\n```\nimport {getPolygonWindingDirection} from '@math.gl/polygon';\n```\n\n----------------------------------------\n\nTITLE: Projecting LngLat Offsets to Pixels - GLSL\nDESCRIPTION: This GLSL function projects longitude/latitude/altitude offsets (expressed as a vec3) into pixel offsets using a uniform scaling vector (unitsPerDegree). It is best suited for clusters of closely spaced points near an origin, and requires the host to supply correct unitsPerDegree values from math.gl\\'s getDistanceScales. Inputs must be provided as vec3 in longitude, latitude, and altitude units; output is a vec3 pixel offset.\nSOURCE: https://github.com/visgl/math.gl/blob/master/docs/developer-guide/geospatial/web-mercator-offset-accuracy.md#_snippet_2\n\nLANGUAGE: GLSL\nCODE:\n```\nuniform vec3 unitsPerDegree;\nvec3 lnglat_offset_to_pixels_offset(vec3 lngLatZ) {\n    return lngLatZ * unitsPerDegree;\n}\n```\n\n----------------------------------------\n\nTITLE: Illustrating General Projective Transformation Matrix Operation (MathML)\nDESCRIPTION: This MathML snippet shows the structure of a general 4x4 projective transformation matrix and its multiplication with a 4-component homogeneous coordinate vector (x, y, z, w). It demonstrates how linear transformations (c elements), perspective projection (proj elements), translation (trans elements), and global scaling (scale_global) are combined within a single matrix operation.\nSOURCE: https://github.com/visgl/math.gl/blob/master/docs/developer-guide/math/homogeneous-coordinates.md#_snippet_0\n\nLANGUAGE: markup\nCODE:\n```\n<math display=\"block\">\n  <mrow>\n    <mfenced open=\"[\" close=\"]\">\n      <mtable>\n        <mtr>\n          <mtd columnalign=\"center\"><msub><mi>c</mi><mn>0</mn></msub></mtd>\n          <mtd columnalign=\"center\"><msub><mi>c</mi><mn>1</mn></msub></mtd>\n          <mtd columnalign=\"center\"><msub><mi>c</mi><mn>2</mn></msub></mtd>\n          <mtd columnalign=\"center\"><msub><mi>proj</mi><mi>x</mi></msub></mtd>\n        </mtr>\n        <mtr>\n          <mtd columnalign=\"center\"><msub><mi>c</mi><mn>1</mn></msub></mtd>\n          <mtd columnalign=\"center\"><msub><mi>c</mi><mn>2</mn></msub></mtd>\n          <mtd columnalign=\"center\"><msub><mi>c</mi><mn>3</mn></msub></mtd>\n          <mtd columnalign=\"center\"><msub><mi>proj</mi><mi>y</mi></msub></mtd>\n        </mtr>\n        <mtr>\n          <mtd columnalign=\"center\"><msub><mi>c</mi><mn>2</mn></msub></mtd>\n          <mtd columnalign=\"center\"><msub><mi>c</mi><mn>3</mn></msub></mtd>\n          <mtd columnalign=\"center\"><msub><mi>c</mi><mn>4</mn></msub></mtd>\n          <mtd columnalign=\"center\"><msub><mi>proj</mi><mi>z</mi></msub></mtd>\n        </mtr>\n        <mtr>\n          <mtd columnalign=\"center\"><msub><mi>trans</mi><mi>x</mi></msub></mtd>\n          <mtd columnalign=\"center\"><msub><mi>trans</mi><mi>y</mi></msub></mtd>\n          <mtd columnalign=\"center\"><msub><mi>trans</mi><mi>z</mi></msub></mtd>\n          <mtd columnalign=\"center\"><msub><mi>scale</mi><mi>global</mi></msub></mtd>\n        </mtr>\n      </mtable>\n    </mfenced>\n\n    <mo>.</mo>\n\n    <mfenced open=\"[\" close=\"]\">\n      <mtable>\n        <mtr><mtd columnalign=\"center\"><mi>x</mi></mtd></mtr>\n        <mtr><mtd columnalign=\"center\"><mi>y</mi></mtd></mtr>\n        <mtr><mtd columnalign=\"center\"><mi>z</mi></mtd></mtr>\n        <mtr><mtd columnalign=\"center\"><mi>w</mi></mtd></mtr>\n      </mtable>\n    </mfenced>\n\n  </mrow>\n</math>\n```\n\n----------------------------------------\n\nTITLE: Projecting Meter Offsets to Pixels - GLSL\nDESCRIPTION: This GLSL snippet defines a function to transform a 3D offset vector in meters to pixel offset, using a uniform scaling vector (unitsPerMeter). It is intended for use in GPU-based coordinate transformations, relying on the uniform variable to be filled by host code (e.g., JavaScript via math.gl\\'s getDistanceScales). The function expects a vec3 input in meters and returns a vec3 pixel offset; precision depends on the quality of unitsPerMeter and is subject to floating-point limits.\nSOURCE: https://github.com/visgl/math.gl/blob/master/docs/developer-guide/geospatial/web-mercator-offset-accuracy.md#_snippet_0\n\nLANGUAGE: GLSL\nCODE:\n```\nuniform vec3 unitsPerMeter;\nvec3 meters_offset_to_pixels_offset(vec3 meters) {\n    return meters * unitsPerMeter;\n}\n```\n\n----------------------------------------\n\nTITLE: Setting an Element in Matrix3 - JavaScript\nDESCRIPTION: Illustrates how to use the set method to assign a value to a specific position in a Matrix3 instance. The method requires specifying the row (i) and column (j) indices, the numeric value to set, and an optional boolean flag (columnMajor) to indicate column-major storage order. Returns the updated matrix instance.\nSOURCE: https://github.com/visgl/math.gl/blob/master/docs/modules/core/api-reference/matrix.md#_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nmatrix3.set(i, j, value, columnMajor = false)\n```\n\n----------------------------------------\n\nTITLE: Implicit Result Object Allocation in math.gl (JavaScript)\nDESCRIPTION: This snippet shows the usage of `matrix4.transformVector([x, y, z])` where the result is implicitly assigned to a new `Vector3` object created by the method in each loop iteration. This pattern leads to repeated object allocation, potentially impacting performance in tight loops. It depends on `Matrix4` and `Vector3` classes, usually from `@math.gl/core`.\nSOURCE: https://github.com/visgl/math.gl/blob/master/docs/developer-guide/performance.md#_snippet_4\n\nLANGUAGE: js\nCODE:\n```\nfor (...) {\n  const v = matrix4.transformVector([x, y, z]);\n  // v now contains a reference to a newly allocated `Vector3` which was updated with the result of the `tranformVector` operation.\n}\n```\n\n----------------------------------------\n\nTITLE: Importing @math.gl/dggs-s2 Module - JavaScript\nDESCRIPTION: Demonstrates importing functionality from the @math.gl/dggs-s2 package in a JavaScript environment. The import statement is essential for accessing the library's S2 DGGS features. No specific named imports are shown in this example, which is common for demonstrating the presence and readiness of the dependency in an ES module or Node.js setup. Requires prior installation of the @math.gl/dggs-s2 package.\nSOURCE: https://github.com/visgl/math.gl/blob/master/docs/modules/dggs-s2/README.md#_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport {} from '@math.gl/dggs-s2';\n```\n\n----------------------------------------\n\nTITLE: Getting an Element from Matrix3 - JavaScript\nDESCRIPTION: Shows how to retrieve a numeric value from a Matrix3 by specifying the row (i) and column (j) indices. An optional columnMajor boolean argument determines storage order. Returns the value at the specified indices.\nSOURCE: https://github.com/visgl/math.gl/blob/master/docs/modules/core/api-reference/matrix.md#_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nmatrix3.get(i, j, columnMajor = false)\n```\n\n----------------------------------------\n\nTITLE: Defining WKT for WGS 84 Coordinate Reference System\nDESCRIPTION: This WKT (Well-Known Text) block defines the WGS84 geodetic coordinate reference system and can be used for CRS import into libraries that support WKT strings. It covers the full geodetic specification including datum, spheroid, primem, units, and authorities. Compatible with supporting software such as proj4js or geospatial platforms. No runtime dependencies, just the need for WKT compatibility. It is intended as reference and configuration material, not executable code.\nSOURCE: https://github.com/visgl/math.gl/blob/master/docs/modules/proj4/README.md#_snippet_4\n\nLANGUAGE: plaintext\nCODE:\n```\nGEOGCS[\"WGS 84\",\n    DATUM[\"WGS_1984\",\n        SPHEROID[\"WGS 84\",6378137,298.257223563,\n            AUTHORITY[\"EPSG\",\"7030\"]],\n        AUTHORITY[\"EPSG\",\"6326\"]],\n    PRIMEM[\"Greenwich\",0,\n        AUTHORITY[\"EPSG\",\"8901\"]],\n    UNIT[\"degree\",0.0174532925199433,\n        AUTHORITY[\"EPSG\",\"9122\"]],\n    AUTHORITY[\"EPSG\",\"4326\"]]\n```\n\n----------------------------------------\n\nTITLE: Generating a Tangent Plane from Cartographic Coordinate using math.gl Plane and Ellipsoid - JavaScript\nDESCRIPTION: This JavaScript code snippet creates a tangent plane at a specific geospatial point using math.gl's Plane and Ellipsoid classes. It illustrates how to import Plane and Ellipsoid, compute a surface normal from WGS84 coordinates, and construct a Plane instance tangent to the surface. Required dependencies: '@math.gl/culling' and '@math.gl/geospatial'. Parameters include a cartographic point and the WGS84 geodetic surface normal. The method fromPointNormal sets the plane's orientation and position. Useful for geospatial analysis and mapping applications.\nSOURCE: https://github.com/visgl/math.gl/blob/master/docs/modules/culling/api-reference/plane.md#_snippet_1\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport {Plane} from '@math.gl/culling';\nimport {Ellipsoid} from '@math.gl/geospatial';\nconst point = [-72.0, 40.0, 0];\nconst normal = Ellipsoid.WGS84.geodeticSurfaceNormal([-72.0, 40.0]);\nconst tangentPlane = new Plane().fromPointNormal(point, normal);\n```\n\n----------------------------------------\n\nTITLE: Defining the transform Method Signature (TypeScript)\nDESCRIPTION: Defines the signature for the `transform` method. This method applies a 4x4 affine transformation matrix (represented as a 16-element number array) to the bounding volume and returns a new `BoundingSphere` representing the transformed volume.\nSOURCE: https://github.com/visgl/math.gl/blob/master/docs/modules/culling/api-reference/bounding-volume.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ntransform(transform : Number[16]) : BoundingSphere\n```\n\n----------------------------------------\n\nTITLE: Declaring the Pose Class in Math.gl (JavaScript)\nDESCRIPTION: This code snippet represents the declaration of the Pose class, which encapsulates a 3D position and orientation with six degrees of freedom. This class serves as the primary interface for creating and manipulating pose objects in JavaScript, and its full implementation resides within the math.gl package. No explicit dependencies are shown in this snippet, but math.gl core is required for usage.\nSOURCE: https://github.com/visgl/math.gl/blob/master/docs/modules/core/api-reference/pose.md#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nclass Pose\n```\n\n----------------------------------------\n\nTITLE: Importing Vector2 from @math.gl/polygon - JavaScript\nDESCRIPTION: Shows the ES6 import syntax for bringing the Vector2 class from @math.gl/polygon into a JavaScript file. Assumes the package has already been installed using npm. This enables use of Vector2 functionality in application code that involves polygon-related math operations. The imported class can then be utilized for further geometric computations.\nSOURCE: https://github.com/visgl/math.gl/blob/master/docs/modules/polygon/README.md#_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport {Vector2} from '@math.gl/polygon';\n```\n\n----------------------------------------\n\nTITLE: Installing @math.gl/core with npm\nDESCRIPTION: This shell command uses the Node Package Manager (npm) to install the `@math.gl/core` library. This is the primary method for adding the core math.gl functionalities to a JavaScript or TypeScript project managed with npm, especially when using bundlers like webpack. Running this command downloads the package and adds it as a dependency to your project.\nSOURCE: https://github.com/visgl/math.gl/blob/master/docs/developer-guide/get-started.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nnpm install @math.gl/core\n```\n\n----------------------------------------\n\nTITLE: Installing @math.gl/core with npm (Bash)\nDESCRIPTION: Installs the core math.gl library using the Node Package Manager (npm). This command downloads and adds the @math.gl/core package to your project's dependencies. Requires Node.js and npm to be installed.\nSOURCE: https://github.com/visgl/math.gl/blob/master/docs/modules/core/README.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm install @math.gl/core\n```\n\n----------------------------------------\n\nTITLE: Declaring a Vector3 Class using JavaScript\nDESCRIPTION: This snippet outlines the Vector3 class declaration extending from MathArray and Array, forming the basis for 3D vector manipulation. It serves as a foundational reference for the rest of the API but does not provide implementation details. Dependencies include MathArray, and it assumes a JavaScript ES6+ environment.\nSOURCE: https://github.com/visgl/math.gl/blob/master/docs/modules/core/api-reference/vector3.md#_snippet_0\n\nLANGUAGE: js\nCODE:\n```\nclass Vector3 extends MathArray extends Array\n```\n\n----------------------------------------\n\nTITLE: Defining SphericalCoordinates Class in JavaScript\nDESCRIPTION: Shows the declaration of the SphericalCoordinates class, the main object for spherical coordinate manipulation. This class lays the foundation for all operations related to spherical coordinates in math.gl and is imported by consumers using ES module syntax. Dependencies include the '@math.gl/core' module. No parameters are included at the class definition stage.\nSOURCE: https://github.com/visgl/math.gl/blob/master/docs/modules/core/api-reference/spherical-coordinates.md#_snippet_0\n\nLANGUAGE: js\nCODE:\n```\nclass SphericalCoordinates\n\n```\n\n----------------------------------------\n\nTITLE: Setting Math.gl Global Configuration in JavaScript\nDESCRIPTION: Shows how to modify global configuration parameters for math.gl, such as EPSILON for numerical tolerance, debug flag, output formatting orientation, and numerical precision. These settings affect how math.gl performs floating-point comparisons, logging, and value formatting. Inputs are direct property assignments to the imported config object; outputs are changes in the library's behavior that apply globally within the application context.\nSOURCE: https://github.com/visgl/math.gl/blob/master/docs/modules/core/api-reference/utilities.md#_snippet_1\n\nLANGUAGE: js\nCODE:\n```\nimport {config} from '@math.gl/core';\nconfig.EPSILON = 1e-12;\nconfig.debug = true;\nconfig.printRowMajor = true;\nconfig.precision = 4;\n```\n\n----------------------------------------\n\nTITLE: Importing Benchmark Demo Component in JavaScript\nDESCRIPTION: This JavaScript code snippet imports the `Demo` component from the `website-examples/benchmarks/app` path. This component is likely designed to display or execute benchmark tests for the math.gl library within a web application or documentation page.\nSOURCE: https://github.com/visgl/math.gl/blob/master/website/src/examples/benchmarks.mdx#_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport Demo from 'website-examples/benchmarks/app';\n```\n\n----------------------------------------\n\nTITLE: Defining Quaternion Class with MathArray and Array Inheritance - JavaScript\nDESCRIPTION: Defines a Quaternion class that extends both MathArray and Array, enabling the representation and manipulation of quaternions in JavaScript. The class structure allows each quaternion to be managed as a four-component object (`x`, `y`, `z`, `w`), and supports operations from MathArray. This pattern facilitates vectorized math while maintaining array-like behaviors, though the actual code indicates a syntax error (double 'extends'), suggesting this is intended to show conceptual inheritance.\nSOURCE: https://github.com/visgl/math.gl/blob/master/docs/modules/core/api-reference/quaternion.md#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nclass Quaternion extends MathArray extends Array\n\n```\n\n----------------------------------------\n\nTITLE: Importing Experimental Export as Euler (ESM Syntax, JavaScript)\nDESCRIPTION: This code demonstrates the recommended approach for importing experimental exports in math.gl v2.x and later. It shows how to import the internal Euler class with a leading underscore (_Euler) and alias it as Euler using ES6 import syntax from '@math.gl/core'. Requires math.gl v2.x+. No parameters. Imports a class for use elsewhere in the application.\nSOURCE: https://github.com/visgl/math.gl/blob/master/docs/upgrade-guide.md#_snippet_3\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport {_Euler as Euler} from '@math.gl/core';\n```\n\n----------------------------------------\n\nTITLE: Defining `NumericArray` Type Alias in TypeScript\nDESCRIPTION: Defines a TypeScript type alias `NumericArray` that represents either a standard JavaScript array containing numbers (`number[]`) or any non-big typed array (`TypedArray`). This provides a convenient way to type functions that accept either format.\nSOURCE: https://github.com/visgl/math.gl/blob/master/docs/modules/types/api-reference/array-types.md#_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nNumericArray\n```\n\n----------------------------------------\n\nTITLE: Checking Current Debug Status in math.gl (JavaScript)\nDESCRIPTION: This code snippet uses the `configure` function from `@math.gl/core` without arguments to retrieve the current configuration object and logs the value of the `debug` property to the console, indicating whether debug checks are currently enabled or disabled. It requires the `@math.gl/core` package.\nSOURCE: https://github.com/visgl/math.gl/blob/master/docs/developer-guide/performance.md#_snippet_1\n\nLANGUAGE: js\nCODE:\n```\nimport {configure} from '@math.gl/core';\nconsole.log('Debug status', configure().debug);\n```\n\n----------------------------------------\n\nTITLE: Projecting Flat Geographic Coordinates Using WebMercatorViewport in JavaScript\nDESCRIPTION: Illustrates how to use the projectFlat method to map [lng, lat] geographic coordinates to Web Mercator linear coordinates, optionally specifying a scale. This is useful for projections that do not require 3D or perspective calculations, enabling fast mapping of geocoordinates to planar space.\nSOURCE: https://github.com/visgl/math.gl/blob/master/docs/modules/web-mercator/api-reference/web-mercator-viewport.md#_snippet_3\n\nLANGUAGE: JavaScript\nCODE:\n```\nconst mercator = viewport.projectFlat([lng, lat]);\nconst mercatorScaled = viewport.projectFlat([lng, lat], scale);\n```\n\n----------------------------------------\n\nTITLE: Using @math.gl/geospatial Ellipsoid with math.gl Vector3 (js)\nDESCRIPTION: This snippet demonstrates using the `Ellipsoid` class from the proposed `@math.gl/geospatial` module alongside the `Vector3` class from `@math.gl/core`. It converts cartographic coordinates (longitude, latitude, altitude), represented by a `Vector3` object, to Cartesian coordinates using the `WSG84` ellipsoid model. This illustrates how the proposed submodules can integrate with the core `math.gl` types.\nSOURCE: https://github.com/visgl/math.gl/blob/master/dev-docs/RFCs/math-monorepo-rfc.md#_snippet_1\n\nLANGUAGE: js\nCODE:\n```\nimport {Ellipsoid} from '@math.gl/geospatial';\nimport {Vector3} from '@math.gl/core';\nconst cartesian = Ellipsoid.WSG84.cartographicToCartesian(new Vector3(lng, lat, z));\n```\n\n----------------------------------------\n\nTITLE: Checking for Numeric Arrays (Typed or Standard) with `isNumericArray` in TypeScript\nDESCRIPTION: Provides the signature for the `isNumericArray` utility function. It checks if a given `value` (of type `unknown`) is either a standard JavaScript array of numbers (checking only the first element) or a non-big typed array, acting as a type guard (`value is NumericArray`). It avoids type narrowing problems with `ArrayBuffer.isView()` by excluding `DataView`.\nSOURCE: https://github.com/visgl/math.gl/blob/master/docs/modules/types/api-reference/array-types.md#_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\nisNumericArray(value: unknown): value as NumericArray\n```\n\n----------------------------------------\n\nTITLE: Extending MathArray Base Class in JavaScript\nDESCRIPTION: This snippet defines the MathArray class by extending the native JavaScript Array, which is intended to be used as a base class for mathematical array manipulations. Users should subclass MathArray for custom behavior, rather than instantiate it directly. This sets up core inheritance required for further math operations, and the class assumes ES6 support for class syntax.\nSOURCE: https://github.com/visgl/math.gl/blob/master/docs/modules/core/api-reference/math-array.md#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nclass MathArray extends Array\n```\n\n----------------------------------------\n\nTITLE: Using @math.gl/geospatial Ellipsoid with JavaScript Array (js)\nDESCRIPTION: This snippet demonstrates using the `Ellipsoid` class from the proposed `@math.gl/geospatial` module. It shows how to convert cartographic coordinates (longitude, latitude, altitude), provided as a standard JavaScript array, to Cartesian coordinates using the `WSG84` ellipsoid model. This exemplifies the design goal of allowing submodule usage without strictly depending on core `math.gl` data types.\nSOURCE: https://github.com/visgl/math.gl/blob/master/dev-docs/RFCs/math-monorepo-rfc.md#_snippet_0\n\nLANGUAGE: js\nCODE:\n```\nimport {Ellipsoid} from '@math.gl/geospatial';\nconst cartesian = Ellipsoid.WSG84.cartographicToCartesian([lng, lat, z]);\n```\n\n----------------------------------------\n\nTITLE: Get Flat GeoHash Boundary Polygon (TypeScript/JavaScript)\nDESCRIPTION: This function signature defines `getGeohashBoundaryFlat`, which accepts a GeoHash string and returns the boundary of the GeoHash cell as a flat array of coordinates. The output format is `[lng, lat, lng, lat, ...]`, listing the longitude and latitude values sequentially for all vertices. It depends on the math.gl GeoHash module.\nSOURCE: https://github.com/visgl/math.gl/blob/master/docs/modules/dggs-geohash/api-reference/geohash.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\ngetGeohashBoundaryFlat(geohash: string): number[]\n```\n\n----------------------------------------\n\nTITLE: Restoring Vector4 Output with Matrix4.transform (JavaScript)\nDESCRIPTION: This snippet demonstrates how to restore the previous behavior in math.gl v3.0+ by explicitly providing a Vector4 instance as the result parameter to Matrix4.transform. It imports Matrix4 and Vector4, then performs a transformation and asserts that the output is again a Vector4. Requires '@math.gl/core' and an assertion library. Inputs: a 4D array and a Vector4 object. Output: a Vector4 instance.\nSOURCE: https://github.com/visgl/math.gl/blob/master/docs/upgrade-guide.md#_snippet_2\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport {Matrix4, Vector4} from '@math.gl/core';\\nconst vector = new Matrix4().transform([0, 0, 0, 1], new Vector4());\\nassert(vector instanceof Vector4);\n```\n\n----------------------------------------\n\nTITLE: Extending MathArray for Vector Bases in JavaScript\nDESCRIPTION: This inheritance declaration demonstrates that the Vector class extends the MathArray class, which in turn extends the native JavaScript Array. This design provides specialized vector methods atop standard array behavior, enabling mathematical operations on vector objects. To utilize Vector and its methods, ensure that both math.gl core and its MathArray dependency are included in the project. This base class is meant to be further subclassed (e.g., by Vector2, Vector3, and Vector4) and does not represent a standalone data structure.\nSOURCE: https://github.com/visgl/math.gl/blob/master/docs/modules/core/api-reference/vector.md#_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nclass Vector extends MathArray extends Array\n```\n\n----------------------------------------\n\nTITLE: Defining `TypedArray` Type Alias in TypeScript\nDESCRIPTION: Defines a TypeScript type alias `TypedArray` that represents any non-big JavaScript typed array (e.g., Float32Array, Int8Array, Uint8Array, etc.). This is useful for functions accepting various typed array formats.\nSOURCE: https://github.com/visgl/math.gl/blob/master/docs/modules/types/api-reference/array-types.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nTypedArray\n```\n\n----------------------------------------\n\nTITLE: Calculating Ellipsoid Surface Normal Intersection with Z-Axis (JavaScript)\nDESCRIPTION: Computes the intersection point of the surface normal at a given 'position' on an ellipsoid with the z-axis. Requires the ellipsoid to be an ellipsoid of revolution (radii.x == radii.y) and radii.z > 0. The 'position' must be on the ellipsoid surface. An optional 'buffer' (defaulting to 0.0) can be provided to adjust the ellipsoid size check when determining if the intersection is inside. The result is optionally stored in the 'result' array if provided. Returns the intersection point array if it's inside the ellipsoid (considering the buffer), otherwise returns undefined. Throws an error if 'position' is missing or constraints are violated. Notes indicate the intersection is typically close to the center for Earth datums.\nSOURCE: https://github.com/visgl/math.gl/blob/master/docs/modules/geospatial/api-reference/ellipsoid.md#_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\ngetSurfaceNormalIntersectionWithZAxis(position, buffer, result)\n```\n\n----------------------------------------\n\nTITLE: Defining `TypedArrayConstructor` Type Alias in TypeScript\nDESCRIPTION: Defines a TypeScript type alias `TypedArrayConstructor` representing the constructor for any non-big JavaScript typed array. This allows typing variables that hold constructors like `Float32Array` or `Int16Array`.\nSOURCE: https://github.com/visgl/math.gl/blob/master/docs/modules/types/api-reference/array-types.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nTypedArrayConstructor\n```\n\n----------------------------------------\n\nTITLE: Checking for Typed Arrays with `isTypedArray` in TypeScript\nDESCRIPTION: Provides the signature for the `isTypedArray` utility function. It checks if a given `value` (of type `unknown`) is a non-big typed array, acting as a type guard (`value is TypedArray`). This check correctly excludes `DataView` objects, unlike `ArrayBuffer.isView()`.\nSOURCE: https://github.com/visgl/math.gl/blob/master/docs/modules/types/api-reference/array-types.md#_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nisTypedArray(value: unknown): value as TypedArray\n```\n\n----------------------------------------\n\nTITLE: Defining `NumberArray` Type Alias in TypeScript\nDESCRIPTION: Defines a TypeScript type alias `NumberArray` representing a standard JavaScript array containing only numbers (`number[]`). While provided for completeness, using the standard `number[]` type directly is recommended.\nSOURCE: https://github.com/visgl/math.gl/blob/master/docs/modules/types/api-reference/array-types.md#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nNumberArray\n```\n\n----------------------------------------\n\nTITLE: Importing the Pose Class from Math.gl (JavaScript)\nDESCRIPTION: This code snippet illustrates how to import the Pose class from the '@math.gl/core' package for use in a JavaScript application. Ensuring that the '@math.gl/core' library is installed via npm or yarn is a prerequisite. This import statement enables the usage of Pose and its associated methods and properties.\nSOURCE: https://github.com/visgl/math.gl/blob/master/docs/modules/core/api-reference/pose.md#_snippet_1\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport {Pose} from '@math.gl/core';\n```\n\n----------------------------------------\n\nTITLE: Retrieving Proj4 String for EPSG Coordinate System\nDESCRIPTION: This snippet shows a PROJ.4 string for the WGS84 coordinate reference system, retrieved from https://epsg.io/4326.proj4. The string specifies required projection parameters and can be supplied to software or libraries (such as @math.gl/proj4 or proj4js) needing the CRS setup in PROJ.4 notation. There are no dependencies to use the string directly; the string is strictly informational unless parsed. Limitation: Must be correctly mapped to the desired projection within client code.\nSOURCE: https://github.com/visgl/math.gl/blob/master/docs/modules/proj4/README.md#_snippet_3\n\nLANGUAGE: plaintext\nCODE:\n```\n+proj=longlat +datum=WGS84 +no_defs\n```\n\n----------------------------------------\n\nTITLE: Running math.gl Performance Benchmarks (Bash)\nDESCRIPTION: These shell commands are used to run the performance benchmark suite included in the math.gl repository. `yarn bench` typically runs the benchmarks in Node.js, while `yarn bench browser` runs them in a browser environment, allowing performance comparison across different JavaScript runtimes. Requires `yarn` and the math.gl project setup.\nSOURCE: https://github.com/visgl/math.gl/blob/master/docs/developer-guide/performance.md#_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\nyarn bench\nyarn bench browser\n```\n\n----------------------------------------\n\nTITLE: Rendering Benchmark Demo Component using JSX\nDESCRIPTION: This JSX snippet renders the previously imported `Demo` component. Within a React application or an environment supporting JSX (like MDX), this syntax mounts the `Demo` component, thereby displaying the benchmark interface or results provided by that component.\nSOURCE: https://github.com/visgl/math.gl/blob/master/website/src/examples/benchmarks.mdx#_snippet_1\n\nLANGUAGE: jsx\nCODE:\n```\n<Demo />\n```\n\n----------------------------------------\n\nTITLE: Installing math.gl/dggs-s2 Package via npm - Bash\nDESCRIPTION: Installs the @math.gl/dggs-s2 package into your JavaScript or Node.js project using npm (Node Package Manager). The command should be run in your project's root directory. After successful installation, the package will be available in node_modules for use in your JavaScript code. No options other than the default are specified.\nSOURCE: https://github.com/visgl/math.gl/blob/master/docs/modules/dggs-s2/README.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm install @math.gl/dggs-s2\n```\n\n----------------------------------------\n\nTITLE: Installing @math.gl/polygon with npm - Bash\nDESCRIPTION: Demonstrates how to install the @math.gl/polygon package using npm, which is required before importing and using the module in JavaScript code. The code should be run in a terminal within the project directory. No parameters are needed, and the expected result is the addition of the package to the project's node_modules.\nSOURCE: https://github.com/visgl/math.gl/blob/master/docs/modules/polygon/README.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm install @math.gl/polygon\n```\n\n----------------------------------------\n\nTITLE: Representing Homogeneous Coordinate Notation (MathML)\nDESCRIPTION: This MathML snippet illustrates a specific mathematical notation for homogeneous coordinates. This notation [x:y:z:w] emphasizes the relative nature of the coordinate values, indicating that the vector represents a line through the origin in projective space, and scaling the components does not change the underlying geometric entity.\nSOURCE: https://github.com/visgl/math.gl/blob/master/docs/developer-guide/math/homogeneous-coordinates.md#_snippet_1\n\nLANGUAGE: markup\nCODE:\n```\n<math>\n  <mfenced open=\"[\" close=\"]\" separators=\":::\">\n    <mi>x</mi><mi>y</mi><mi>z</mi>\n  </mfenced>\n</math>\n```"
  }
]