[
  {
    "owner": "modular",
    "repo": "max",
    "content": "TITLE: Declaring Variables Explicitly with var Keyword\nDESCRIPTION: Shows how to explicitly declare variables using the var keyword.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/basics.mdx#2025-04-17_snippet_2\n\nLANGUAGE: mojo\nCODE:\n```\nvar x = 10\n```\n\n----------------------------------------\n\nTITLE: Generic Stack Implementation\nDESCRIPTION: Implements the Stacklike trait with a generic MyStack struct using a List as underlying storage and adding additional functionality.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/traits.mdx#2025-04-17_snippet_14\n\nLANGUAGE: mojo\nCODE:\n```\nstruct MyStack[T: CollectionElement](Stacklike):\n    \"\"\"A simple Stack built using a List.\"\"\"\n    alias EltType = T\n    alias list_type = List[Self.EltType]\n\n    var list: Self.list_type\n\n    fn __init__(out self):\n        self.list = Self.list_type()\n\n    def push(mut self, owned item: Self.EltType):\n        self.list.append(item)\n\n    def pop(mut self) -> Self.EltType:\n        return self.list.pop()\n\n    def dump[U: RepresentableCollectionElement](self: MyStack[U]):\n        print(self.list.__repr__())\n```\n\n----------------------------------------\n\nTITLE: Defining and Launching a Multi-Dimensional GPU Kernel in Mojo\nDESCRIPTION: Example of defining a GPU kernel that prints thread indices and launching it with multi-dimensional thread blocks, demonstrating how to use different dimensions in kernel execution.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/gpu/basics.mdx#2025-04-17_snippet_3\n\nLANGUAGE: mojo\nCODE:\n```\nfn printing_kernel():\n    print(\"GPU thread: [\", thread_idx.x, thread_idx.y, thread_idx.z, \"]\")\n\nvar ctx = DeviceContext()\nctx.enqueue_function[printing_kernel](grid_dim=1, block_dim=(2, 2, 2))\nctx.synchronize()\n```\n\n----------------------------------------\n\nTITLE: Typed String Greeting Function (def)\nDESCRIPTION: Shows a def function with explicit type annotations for arguments and return value.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/functions.mdx#2025-04-17_snippet_5\n\nLANGUAGE: mojo\nCODE:\n```\ndef greet(name: String) -> String:\n    var greeting = \"Hello, \" + name + \"!\"\n    return greeting\n```\n\n----------------------------------------\n\nTITLE: Creating a Hello World Program in Mojo\nDESCRIPTION: A simple \"Hello world\" program demonstrating the required main() function as the program entry point.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/basics.mdx#2025-04-17_snippet_0\n\nLANGUAGE: mojo\nCODE:\n```\ndef main():\n    print(\"Hello, world!\")\n```\n\n----------------------------------------\n\nTITLE: Implementing Parametric Custom Types in Mojo using MLIR\nDESCRIPTION: Example of defining fully-parametric custom types in Mojo by wrapping KGEN types, specifically creating a SIMD type with parametric element type and width.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_230\n\nLANGUAGE: mojo\nCODE:\n```\nstruct SIMD[dt: __mlir_type.`!kgen.dtype`, nelts: __mlir_type.index]:\n    var value:\n      __mlir_type.`!pop.simd<#lit<placeholder index>,\n                             #lit<placeholder !kgen.dtype>>`[nelts, dt]\n\n    fn __add__(self, rhs: SIMD[dt, nelts]) -> SIMD[dt, nelts]:\n        return __mlir_op.`pop.add`(self.value, rhs.value)\n```\n\n----------------------------------------\n\nTITLE: Importing Required Modules for GPU Programming in Mojo\nDESCRIPTION: List of necessary imports for GPU programming in Mojo, including modules for thread management, device context, memory operations, and math functions.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/gpu/basics.mdx#2025-04-17_snippet_2\n\nLANGUAGE: mojo\nCODE:\n```\nfrom gpu import thread_idx, block_idx, warp, barrier\nfrom gpu.host import DeviceContext, DeviceBuffer, HostBuffer\nfrom gpu.memory import AddressSpace\nfrom memory import stack_allocation\nfrom layout import Layout, LayoutTensor\nfrom math import iota\nfrom sys import sizeof\n```\n\n----------------------------------------\n\nTITLE: Using Generic Stack Implementation\nDESCRIPTION: Demonstrates usage of the generic stack implementation with a helper function and main example.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/traits.mdx#2025-04-17_snippet_15\n\nLANGUAGE: mojo\nCODE:\n```\ndef add_to_stack[S: Stacklike](mut stack: S, item: S.EltType):\n    stack.push(item)\n\ndef main():\n    s = MyStack[Int]()\n    add_to_stack(s, 12)\n    add_to_stack(s, 33)\n    s.dump()             # [12, 33]\n    print(s.pop())       # 33\n```\n\n----------------------------------------\n\nTITLE: Declaring Simple Functions with Type Annotations in Mojo\nDESCRIPTION: Illustrates the basic syntax for declaring functions with typed parameters in Mojo. This example shows a function declaration without a body, using the 'index' type.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_240\n\nLANGUAGE: mojo\nCODE:\n```\ndef foo(x: Int):\n```\n\n----------------------------------------\n\nTITLE: Raising an Error in Mojo\nDESCRIPTION: Demonstrates how to raise an error using the 'raise' statement with an Error instance or a string message.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/errors.mdx#2025-04-17_snippet_0\n\nLANGUAGE: mojo\nCODE:\n```\nraise Error(\"integer overflow\")\n```\n\nLANGUAGE: mojo\nCODE:\n```\nraise \"integer overflow\"\n```\n\n----------------------------------------\n\nTITLE: Sum Reduction using Shared Memory in Mojo GPU Kernel\nDESCRIPTION: This kernel performs a sum reduction operation using shared memory, demonstrating how to use shared memory for efficient inter-thread communication within a block.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/gpu/basics.mdx#2025-04-17_snippet_12\n\nLANGUAGE: mojo\nCODE:\n```\nfn sum_reduce_kernel(\n    in_tensor: InputLayoutTensor, out_tensor: OutputLayoutTensor\n):\n    var shared = stack_allocation[\n        threads * sizeof[dtype](),\n        Scalar[dtype],\n        address_space = AddressSpace.SHARED,\n    ]()\n\n    shared[thread_idx.x] = in_tensor[block_idx.x, thread_idx.x][0]\n\n    barrier()\n\n    if thread_idx.x == 0:\n        for i in range(threads):\n            out_tensor[block_idx.x] += shared[i]\n\nctx.enqueue_function[sum_reduce_kernel](\n    in_tensor,\n    out_tensor,\n    grid_dim=blocks,\n    block_dim=threads,\n)\n\ndevice_output_buffer.enqueue_copy_to(host_output_buffer)\nctx.synchronize()\n\nprint(host_output_buffer)\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Value Semantics in Mojo\nDESCRIPTION: This snippet shows how value semantics work in Mojo by assigning and modifying integer values. It demonstrates that modifying a copy doesn't affect the original value.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/values/value-semantics.mdx#2025-04-17_snippet_0\n\nLANGUAGE: mojo\nCODE:\n```\nx = 1\ny = x\ny += 1\n\nprint(x)\nprint(y)\n```\n\n----------------------------------------\n\nTITLE: Using Keyword Arguments in Mojo Functions\nDESCRIPTION: Demonstrates how to use keyword arguments when calling functions in Mojo. This allows parameters to be passed by name instead of position, providing more flexibility in function calls.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_175\n\nLANGUAGE: mojo\nCODE:\n```\nfn foo(a: Int, b: Int = 3) -> Int:\n    return a * b\n\nfn main():\n    print(foo(6, b=7))  # prints '42'\n    print(foo(a=6, b=7))  # prints '42'\n    print(foo(b=7, a=6))  # prints '42'\n```\n\n----------------------------------------\n\nTITLE: Creating a Basic Struct with Lifecycle Methods in Mojo\nDESCRIPTION: Demonstrates defining a struct with fields, initialization methods, and a utility method.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/basics.mdx#2025-04-17_snippet_14\n\nLANGUAGE: mojo\nCODE:\n```\nstruct MyPair:\n    var first: Int\n    var second: Int\n\n    fn __init__(out self, first: Int, second: Int):\n        self.first = first\n        self.second = second\n\n    fn __copyinit__(out self, existing: Self):\n        self.first = existing.first\n        self.second = existing.second\n\n    def dump(self):\n        print(self.first, self.second)\n```\n\n----------------------------------------\n\nTITLE: Implementing Context Managers in Mojo\nDESCRIPTION: Definition of the interface required for implementing context managers in Mojo for use with 'with' statements. The code shows the three required methods for context managers.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_196\n\nLANGUAGE: mojo\nCODE:\n```\nfn __enter__(self) -> T:\nfn __exit__(self):\nfn __exit__(self, err: Error) -> Bool:\n```\n\n----------------------------------------\n\nTITLE: Creating a Generic List in Mojo\nDESCRIPTION: Demonstrates how to create a List of integers in Mojo using generic type parameters. Shows type inference and type checking for list elements.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/types.mdx#2025-04-17_snippet_14\n\nLANGUAGE: mojo\nCODE:\n```\nvar l = List[Int](1, 2, 3, 4)\n# l.append(3.14) # error: FloatLiteral cannot be converted to Int\n```\n\n----------------------------------------\n\nTITLE: Static Type Enforcement in Mojo Variables\nDESCRIPTION: Demonstrates how Mojo enforces static typing for variables, showing an error when attempting to change a variable's type.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/basics.mdx#2025-04-17_snippet_4\n\nLANGUAGE: mojo\nCODE:\n```\nx = 10\nx = \"Foo\" # Error: Cannot convert \"StringLiteral\" value to \"Int\"\n```\n\n----------------------------------------\n\nTITLE: if-elif-else Statement in Mojo\nDESCRIPTION: Demonstrates a complete conditional structure with multiple elif clauses and an else clause for temperature classification.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/control-flow.mdx#2025-04-17_snippet_2\n\nLANGUAGE: mojo\nCODE:\n```\ntemp_celsius = 25\nif temp_celsius <= 0:\n    print(\"It is freezing.\")\nelif temp_celsius < 20:\n    print(\"It is cool.\")\nelif temp_celsius < 30:\n    print(\"It is warm.\")\nelse:\n    print(\"It is hot.\")\n```\n\n----------------------------------------\n\nTITLE: Function Overloading in Mojo\nDESCRIPTION: Example of function overloading in Mojo, showing how to define multiple versions of a function that accept different argument types.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/functions.mdx#2025-04-17_snippet_19\n\nLANGUAGE: mojo\nCODE:\n```\nfn add(x: Int, y: Int) -> Int:\n    return x + y\n\nfn add(x: String, y: String) -> String:\n    return x + y\n```\n\n----------------------------------------\n\nTITLE: Defining and Using Traits in Mojo\nDESCRIPTION: This Mojo code snippet demonstrates how to define a trait, create structs that conform to the trait, and use the trait in a generic function.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/traits.mdx#2025-04-17_snippet_2\n\nLANGUAGE: mojo\nCODE:\n```\ntrait Quackable:\n    fn quack(self):\n        ...\n\n@value\nstruct Duck(Quackable):\n    fn quack(self):\n        print(\"Quack\")\n\n@value\nstruct StealthCow(Quackable):\n    fn quack(self):\n        print(\"Moo!\")\n\nfn make_it_quack[T: Quackable](maybe_a_duck: T):\n    maybe_a_duck.quack()\n\nmake_it_quack(Duck())\nmake_it_quack(StealthCow())\n```\n\n----------------------------------------\n\nTITLE: Advanced Function Overloading with Custom Types\nDESCRIPTION: Complex example demonstrating overload resolution with custom types, implicit conversions, and static methods.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/functions.mdx#2025-04-17_snippet_20\n\nLANGUAGE: mojo\nCODE:\n```\n@value\nstruct MyString:\n    @implicit\n    fn __init__(out self, string: StringLiteral):\n        pass\n\nfn foo(name: String):\n    print(\"String\")\n\nfn foo(name: MyString):\n    print(\"MyString\")\n\nfn call_foo():\n    alias string: StringLiteral = \"Hello\"\n    # foo(string) # error: ambiguous call to 'foo' ... This call is ambiguous because two `foo` functions match it\n    foo(MyString(string))\n```\n\n----------------------------------------\n\nTITLE: Defining Parametric Functions with Type Parameters in Mojo\nDESCRIPTION: Shows the syntax for creating functions with type parameters in Mojo. It demonstrates how to use generic parameters and return typed values.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_239\n\nLANGUAGE: mojo\nCODE:\n```\ndef foo[param: Int](arg: Int) -> Int:\n    result = param + arg\n    return result\n```\n\n----------------------------------------\n\nTITLE: Installing Optimum for ONNX Conversion\nDESCRIPTION: Installs a specific version of the Optimum library from GitHub to support Gemma model conversion to ONNX format.\nSOURCE: https://github.com/modular/max/blob/main/examples/notebooks/gemma2b-python-onnx.ipynb#2025-04-17_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n!python3 -m pip install -q git+https://github.com/huggingface/optimum.git@e0cbf7dea2531603ecd0f36dfce0657baa4310ec\n```\n\n----------------------------------------\n\nTITLE: Implementing a SharedDict with ArcPointer in Mojo\nDESCRIPTION: This example demonstrates how to use ArcPointer to implement a reference-semantic type. The SharedDict struct uses ArcPointer to store a dictionary that is shared between all copies of the struct.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/pointers/index.mdx#2025-04-17_snippet_5\n\nLANGUAGE: mojo\nCODE:\n```\nfrom memory import ArcPointer\nfrom collections import Dict\n\nstruct SharedDict:\n    var attributes: ArcPointer[Dict[String, String]]\n\n    fn __init__(out self):\n        attributesDict = Dict[String, String]()\n        self.attributes = ArcPointer(attributesDict)\n\n    fn __copyinit__(out self, other: Self):\n        self.attributes = other.attributes\n\n    def __setitem__(inout self, key: String, value: String):\n        self.attributes[][key] = value\n\n    def __getitem__(self, key: String) -> String:\n        return self.attributes[].get(key, default=\"\")\n\ndef main():\n    thing1 = SharedDict()\n    thing2 = thing1\n    thing1[\"Flip\"] = \"Flop\"\n    print(thing2[\"Flip\"])\n```\n\n----------------------------------------\n\nTITLE: Manipulating Strings in Mojo\nDESCRIPTION: Demonstrates string concatenation and modification using Mojo's mutable String type. Shows how to append to an existing string.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/types.mdx#2025-04-17_snippet_8\n\nLANGUAGE: mojo\nCODE:\n```\nvar s: String = \"Testing\"\ns += \" Mojo strings\"\nprint(s)\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Mutable References in Mojo Functions\nDESCRIPTION: Shows how to use mutable and immutable references in function arguments to modify values. The add() function takes a mutable x parameter and immutable y parameter to perform addition.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/values/ownership.mdx#2025-04-17_snippet_0\n\nLANGUAGE: mojo\nCODE:\n```\nfn add(mut x: Int, read y: Int):\n    x += y\n\nfn main():\n    var a = 1\n    var b = 2\n    add(a, b)\n    print(a)  # Prints 3\n```\n\n----------------------------------------\n\nTITLE: Using the Indexer Trait with Custom Types\nDESCRIPTION: Demonstrates how to implement the Indexer trait in a custom type AlwaysZero, which allows it to be used with collections that implement __getitem__(). The example shows how a MyList class can use index() with any Indexer type.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_75\n\nLANGUAGE: mojo\nCODE:\n```\n@value\nstruct AlwaysZero(Indexer):\n    fn __index__(self) -> Int:\n        return 0\n\nstruct MyList:\n    var data: List[Int]\n\n    fn __init__(inout self):\n        self.data = List[Int](1, 2, 3, 4)\n\n    fn __getitem__[T: Indexer](self, idx: T) -> Int:\n        return self.data[index(idx)]\n\nprint(MyList()[AlwaysZero()])  # prints `1`\n```\n\n----------------------------------------\n\nTITLE: Basic if Statement in Mojo\nDESCRIPTION: Demonstrates a basic if statement that checks if a temperature is above a threshold and prints appropriate messages.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/control-flow.mdx#2025-04-17_snippet_0\n\nLANGUAGE: mojo\nCODE:\n```\ntemp_celsius = 25\nif temp_celsius > 20:\n    print(\"It is warm.\")\n    print(\"The temperature is\", temp_celsius * 9 / 5 + 32, \"Fahrenheit.\" )\n```\n\n----------------------------------------\n\nTITLE: Importing a Mojo Module\nDESCRIPTION: This snippet shows how to import a struct (MyPair) from a Mojo module (mymodule.mojo) into a main program file (main.mojo) and use it to create an instance.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/packages.md#2025-04-17_snippet_1\n\nLANGUAGE: mojo\nCODE:\n```\nfrom mymodule import MyPair\n\nfn main():\n    var mine = MyPair(2, 4)\n    mine.dump()\n```\n\n----------------------------------------\n\nTITLE: Implicit Tuple Unpacking in Mojo Functions\nDESCRIPTION: Example demonstrating how Mojo now supports implicit variable declarations with tuple unpacking. This allows users to directly assign multiple variables from a function that returns multiple values.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_67\n\nLANGUAGE: mojo\nCODE:\n```\ndef return_two(i: Int) -> (Int, Int):\n  return i, i+1\n\na, b = return_two(5)\n```\n\n----------------------------------------\n\nTITLE: Defining a Struct in a Mojo Module\nDESCRIPTION: This snippet demonstrates how to create a Mojo module file (mymodule.mojo) that defines a struct called MyPair with two integer fields and methods for initialization and printing.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/packages.md#2025-04-17_snippet_0\n\nLANGUAGE: mojo\nCODE:\n```\nstruct MyPair:\n    var first: Int\n    var second: Int\n\n    fn __init__(out self, first: Int, second: Int):\n        self.first = first\n        self.second = second\n\n    fn dump(self):\n        print(self.first, self.second)\n```\n\n----------------------------------------\n\nTITLE: Defining and Using a Parametric Function in Mojo\nDESCRIPTION: Shows how to create a parametric function with compile-time parameters and use it. The function repeats a message a specified number of times.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/basics.mdx#2025-04-17_snippet_21\n\nLANGUAGE: mojo\nCODE:\n```\ndef repeat[count: Int](msg: String):\n    @parameter # evaluate the following for loop at compile time\n    for i in range(count):\n        print(msg)\n\ndef call_repeat():\n    repeat[3](\"Hello\")\n    # Prints \"Hello\" 3 times\n```\n\n----------------------------------------\n\nTITLE: Defining Basic Mojo Struct\nDESCRIPTION: Demonstrates the basic structure definition with two integer fields without a constructor.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/structs.mdx#2025-04-17_snippet_0\n\nLANGUAGE: mojo\nCODE:\n```\nstruct MyPair:\n    var first: Int\n    var second: Int\n```\n\n----------------------------------------\n\nTITLE: Defining and Implementing Traits in Mojo\nDESCRIPTION: Shows how to define a trait with required methods, implement it in a struct, and create generic functions that work with any type conforming to the trait.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_139\n\nLANGUAGE: mojo\nCODE:\n```\ntrait SomeTrait:\n    fn required_method(self, x: Int): ...\n```\n\n----------------------------------------\n\nTITLE: Implementing Stringable, Representable, and Writable Traits in Mojo\nDESCRIPTION: Demonstrates how to implement Stringable, Representable, and Writable traits for a custom type, enabling various string representations and efficient writing.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/traits.mdx#2025-04-17_snippet_8\n\nLANGUAGE: mojo\nCODE:\n```\n@value\nstruct Dog(Stringable, Representable, Writable):\n    var name: String\n    var age: Int\n\n    # Allows the type to be written into any `Writer`\n    fn write_to[W: Writer](self, mut writer: W) -> None:\n        writer.write(\"Dog(\", self.name, \", \", self.age, \")\")\n\n    # Construct and return a `String` using the previous method\n    fn __str__(self) -> String:\n        return String.write(self)\n\n    # Alternative full representation when calling `repr`\n    fn __repr__(self) -> String:\n        return String(\"Dog(name=\", repr(self.name), \", age=\", repr(self.age), \")\")\n\nvar dog = Dog(\"Rex\", 5)\nprint(repr(dog))\nprint(dog)\n\nvar dog_info = \"String: {!s}\\nRepresentation: {!r}\".format(dog, dog)\nprint(dog_info)\n```\n\n----------------------------------------\n\nTITLE: Implementing Struct Constructor\nDESCRIPTION: Shows how to implement a constructor (__init__) method to initialize struct fields.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/structs.mdx#2025-04-17_snippet_1\n\nLANGUAGE: mojo\nCODE:\n```\nstruct MyPair:\n    var first: Int\n    var second: Int\n\n    fn __init__(out self, first: Int, second: Int):\n        self.first = first\n        self.second = second\n```\n\n----------------------------------------\n\nTITLE: Generating custom images with Stable Diffusion\nDESCRIPTION: Command to generate custom images using text prompts with the text_to_image.py script.\nSOURCE: https://github.com/modular/max/blob/main/examples/inference/stable-diffusion-python-onnx/README.md#2025-04-17_snippet_2\n\nLANGUAGE: sh\nCODE:\n```\n./text_to_image.py --prompt \"my image description\" -o my-image.png\n```\n\n----------------------------------------\n\nTITLE: Using in Operator with Lists in Mojo\nDESCRIPTION: Demonstrates how to use the new __contains__ functionality of List to check if an element exists within a list using the 'in' operator.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_82\n\nLANGUAGE: mojo\nCODE:\n```\nif x in my_list:\n```\n\n----------------------------------------\n\nTITLE: Using Coroutines in Async Functions in Mojo\nDESCRIPTION: Demonstrates how to use the `Coroutine[T]` type to handle the results of async function calls, including creating a coroutine and awaiting its result.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_216\n\nLANGUAGE: mojo\nCODE:\n```\nasync fn add_three(a: Int, b: Int, c: Int) -> Int:\n    return a + b + c\n\nasync fn call_it():\n    let task: Coroutine[Int] = add_three(1, 2, 3)\n    print(await task)\n```\n\n----------------------------------------\n\nTITLE: Dictionary Operations in Mojo\nDESCRIPTION: Demonstrates creating and iterating through a Dictionary with key-value pairs.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/types.mdx#2025-04-17_snippet_17\n\nLANGUAGE: mojo\nCODE:\n```\nfrom collections import Dict\n\nvar d = Dict[String, Float64]()\nd[\"plasticity\"] = 3.1\nd[\"elasticity\"] = 1.3\nd[\"electricity\"] = 9.7\nfor item in d.items():\n    print(item[].key, item[].value)\n```\n\n----------------------------------------\n\nTITLE: Handling Errors in Mojo Functions\nDESCRIPTION: Illustrates how to handle errors in functions, comparing unhandled and handled error scenarios.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/errors.mdx#2025-04-17_snippet_2\n\nLANGUAGE: mojo\nCODE:\n```\n# This function doesn't compile because of the unhandled error\nfn unhandled_error(n: Int):\n    print(n, \"+ 1 =\", incr(n))\n\n# This function compiles because it handles the possible error\nfn handled_error(n: Int):\n    try:\n        print(n, \"+ 1 =\", incr(n))\n    except e:\n        print(\"Handled an error:\", e)\n```\n\n----------------------------------------\n\nTITLE: Array Implementation with Lifetime-Aware Slicing\nDESCRIPTION: Implementation of a value semantic array type that produces lifetime-bound slices and prevents concurrent mutation.\nSOURCE: https://github.com/modular/max/blob/main/mojo/proposals/lifetimes-and-provenance.md#2025-04-17_snippet_12\n\nLANGUAGE: mojo\nCODE:\n```\n    # Doesn't require a lifetime param because it owns its data.\n    struct Array[type: AnyType]:\n        var ptr: MutablePointer[type, Self_lifetime]\n        var size: Int\n        var capacity: Int\n\n        fn __getitem__[life: Lifetime](self: inout[life], start: Int,\n                            stop: Int) -> MutableArraySlice[type, life]:\n            return MutableArraySlice(ptr, size)\n```\n\n----------------------------------------\n\nTITLE: Creating a Pointer using address_of() in Mojo\nDESCRIPTION: This snippet shows how to create a Pointer that references an existing value using the address_of() static method. Unlike OwnedPointer, Pointer doesn't own the value it points to.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/pointers/index.mdx#2025-04-17_snippet_2\n\nLANGUAGE: mojo\nCODE:\n```\nptr = Pointer(to=some_value)\n```\n\n----------------------------------------\n\nTITLE: Using Variadic Arguments in Mojo\nDESCRIPTION: Demonstrates the use of variadic arguments in Mojo, showing how they are automatically projected into a VariadicList or VariadicListMem inside the function body for flexible handling.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_163\n\nLANGUAGE: mojo\nCODE:\n```\nfn print_ints(*nums: Int):\n    let len = len(nums)\n    for i in range(len):\n        print(nums[i])\n    print(len)\n```\n\n----------------------------------------\n\nTITLE: For Loop Iterating Over Mojo List\nDESCRIPTION: Demonstrates iterating over a Mojo List collection, accessing elements via pointer dereferencing.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/control-flow.mdx#2025-04-17_snippet_12\n\nLANGUAGE: mojo\nCODE:\n```\nfrom collections import List\n\nstates = List[String](\"California\", \"Hawaii\", \"Oregon\")\nfor state in states:\n    print(state[])\n```\n\n----------------------------------------\n\nTITLE: Defining Functions with Type Annotations in Mojo\nDESCRIPTION: Demonstrates creating a function with the def keyword including parameter and return type annotations.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/basics.mdx#2025-04-17_snippet_8\n\nLANGUAGE: mojo\nCODE:\n```\ndef greet(name: String) -> String:\n    return \"Hello, \" + name + \"!\"\n```\n\n----------------------------------------\n\nTITLE: Writing Basic Tests in Mojo\nDESCRIPTION: A simple example of writing unit tests in Mojo, including an intentionally failing test to demonstrate error output. The example defines an increment function and two test functions that use assert_equal to verify the function's behavior.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/tools/testing.mdx#2025-04-17_snippet_0\n\nLANGUAGE: mojo\nCODE:\n```\n# Content of test_quickstart.mojo\nfrom testing import assert_equal\n\ndef inc(n: Int) -> Int:\n    return n + 1\n\ndef test_inc_zero():\n    # This test contains an intentional logical error to show an example of\n    # what a test failure looks like at runtime.\n    assert_equal(inc(0), 0)\n\ndef test_inc_one():\n    assert_equal(inc(1), 2)\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Implicit Trait Conformance in Mojo\nDESCRIPTION: Shows how a struct can implicitly conform to the Stringable trait by implementing the __str__() method, allowing it to be used with the str() built-in function.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_97\n\nLANGUAGE: mojo\nCODE:\n```\n@value\nstruct Foo:\n    fn __str__(self) -> String:\n        return \"foo!\"\n\nfn main():\n    print(str(Foo())) # prints 'foo!'\n```\n\n----------------------------------------\n\nTITLE: While Loop with Continue Statement in Mojo\nDESCRIPTION: Demonstrates how to skip a specific iteration in a while loop using the continue statement.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/control-flow.mdx#2025-04-17_snippet_8\n\nLANGUAGE: mojo\nCODE:\n```\nn = 0\nwhile n < 5:\n    n += 1\n    if n == 3:\n        continue\n    print(n, end=\", \")\n```\n\n----------------------------------------\n\nTITLE: Implementing Associated Aliases in Structs\nDESCRIPTION: Shows how to implement associated aliases in structs using both constant values and compile-time expressions with parameters.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/traits.mdx#2025-04-17_snippet_11\n\nLANGUAGE: mojo\nCODE:\n```\nstruct Doublespeak(Repeater):\n    alias count: Int = 2\n\nstruct Multispeak[verbosity: Int](Repeater):\n    alias count: Int = verbosity*2+1\n```\n\n----------------------------------------\n\nTITLE: Implementing Trait Inheritance in Mojo\nDESCRIPTION: This Mojo code demonstrates trait inheritance, where a trait can inherit requirements from other traits, and how multiple trait inheritance works.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/traits.mdx#2025-04-17_snippet_4\n\nLANGUAGE: mojo\nCODE:\n```\ntrait Animal:\n    fn make_sound(self):\n        ...\n\n# Bird inherits from Animal\ntrait Bird(Animal):\n    fn fly(self):\n        ...\n\ntrait Named:\n    fn get_name(self) -> String:\n        ...\n\ntrait NamedAnimal(Animal, Named):\n    pass\n```\n\n----------------------------------------\n\nTITLE: Implementing Keyword-Only Arguments in Mojo\nDESCRIPTION: Examples showing how to define keyword-only arguments using the * syntax, both with and without variadic arguments.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/functions.mdx#2025-04-17_snippet_18\n\nLANGUAGE: mojo\nCODE:\n```\nfn sort(*values: Float64, ascending: Bool = True): ...\n\nfn kw_only_args(a1: Int, a2: Int, *, double: Bool) -> Int:\n    var product = a1 * a2\n    if double:\n        return product * 2\n    else:\n        return product\n```\n\n----------------------------------------\n\nTITLE: Implementing Sized Trait for Custom List Type in Mojo\nDESCRIPTION: Demonstrates how to implement the Sized trait for a custom list type, enabling it to work with the built-in len() function.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/traits.mdx#2025-04-17_snippet_6\n\nLANGUAGE: mojo\nCODE:\n```\nstruct MyList(Sized):\n    var size: Int\n    # ...\n\n    fn __init__(out self):\n        self.size = 0\n\n    fn __len__(self) -> Int:\n        return self.size\n\nprint(len(MyList()))\n```\n\n----------------------------------------\n\nTITLE: Examining ONNX Model Structure\nDESCRIPTION: Code to load and examine the ONNX model structure, including inputs and outputs\nSOURCE: https://github.com/modular/max/blob/main/examples/notebooks/mistral7b-python-onnx.ipynb#2025-04-17_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n%%time\nimport onnx\n\n# It will take a while to load in ONNX as well as occupying 28G more memory!\nonnxmodel = onnx.load(\"./onnx/mistral-7b-onnx/model.onnx\")\n\ndef print_dims(tensor):\n    dims = []\n    for dim in tensor.type.tensor_type.shape.dim:\n        if dim.HasField(\"dim_value\"):\n            dims.append(String(dim.dim_value))\n        elif dim.HasField(\"dim_param\"):\n            dims.append(String(dim.dim_param))\n    print(onnx.TensorProto.DataType.Name(tensor.type.tensor_type.elem_type), end=\" \")\n    print(\"[\", \", \".join(dims), \"]\")\n\nprint(\"=== Inputs ===\")\nfor input_tensor in onnxmodel.graph.input:\n    print(input_tensor.name, end=\": \")\n    print_dims(input_tensor)\n\nprint(\"\\n=== Outputs ===\")\nfor output_tensor in onnxmodel.graph.output:\n    print(output_tensor.name, end=\": \")\n    print_dims(output_tensor)\n```\n\n----------------------------------------\n\nTITLE: Creating and Using Mojo Lists\nDESCRIPTION: Demonstrates list creation with type inference and basic list operations including append and pop.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/types.mdx#2025-04-17_snippet_15\n\nLANGUAGE: mojo\nCODE:\n```\nfrom collections import List\n\nvar list = List(2, 3, 5)\nlist.append(7)\nlist.append(11)\nprint(\"Popping last item from list: \", list.pop())\nfor idx in range(len(list)):\n      print(list[idx], end=\", \")\n```\n\n----------------------------------------\n\nTITLE: Value Semantics in Mojo Function Arguments\nDESCRIPTION: This example illustrates how function arguments in Mojo use value semantics by default. The function receives a copy of the argument, and modifying it doesn't affect the original value.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/values/value-semantics.mdx#2025-04-17_snippet_1\n\nLANGUAGE: mojo\nCODE:\n```\ndef add_one(y: Int):\n    y += 1\n    print(y)\n\nx = 1\nadd_one(x)\nprint(x)\n```\n\n----------------------------------------\n\nTITLE: Set Operations in Mojo\nDESCRIPTION: Shows Set creation and intersection operations between two sets.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/types.mdx#2025-04-17_snippet_18\n\nLANGUAGE: mojo\nCODE:\n```\nfrom collections import Set\n\ni_like = Set(\"sushi\", \"ice cream\", \"tacos\", \"pho\")\nyou_like = Set(\"burgers\", \"tacos\", \"salad\", \"ice cream\")\nwe_like = i_like.intersection(you_like)\n\nprint(\"We both like:\")\nfor item in we_like:\n    print(\"-\", item[])\n```\n\n----------------------------------------\n\nTITLE: Using Keyword-Only Arguments in Mojo Functions\nDESCRIPTION: Demonstrates Mojo's support for keyword-only arguments, which are defined after the '*' parameter separator. Shows how to define and call functions with both positional and keyword-only parameters.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_114\n\nLANGUAGE: mojo\nCODE:\n```\nfn my_product(a: Int, b: Int = 1, *, c: Int, d: Int = 2):\n    print(a * b * c * d)\n\nmy_product(3, c=5)     # prints '30'\nmy_product(3, 5, d=7)  # error: missing 1 required keyword-only argument: 'c'\n```\n\n----------------------------------------\n\nTITLE: Implementing Struct Methods\nDESCRIPTION: Shows how to add custom methods to a struct with field calculations.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/structs.mdx#2025-04-17_snippet_3\n\nLANGUAGE: mojo\nCODE:\n```\nstruct MyPair:\n    var first: Int\n    var second: Int\n\n    fn __init__(out self, first: Int, second: Int):\n        self.first = first\n        self.second = second\n\n    fn get_sum(self) -> Int:\n        return self.first + self.second\n```\n\n----------------------------------------\n\nTITLE: Illustrating Automatic Move Optimization in Mojo\nDESCRIPTION: This code demonstrates how Mojo now automatically transforms calls to __copyinit__ methods into __moveinit__ calls when it's the last use of the source value, optimizing performance for types that are both copyable and movable.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_194\n\nLANGUAGE: mojo\nCODE:\n```\nvar someValue = somethingCopyableAndMovable()\nuse(someValue)\n...\nlet otherValue = someValue      # Last use of someValue\nuse(otherValue)\n...\nvar yetAnother = otherValue     # Last use of otherValue\nmutate(yetAnother)\n```\n\n----------------------------------------\n\nTITLE: For Loop Iterating Over Mojo Dict Items\nDESCRIPTION: Shows how to iterate over key-value pairs in a Mojo Dict using the items() method.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/control-flow.mdx#2025-04-17_snippet_15\n\nLANGUAGE: mojo\nCODE:\n```\nfor item in capitals.items():\n    print(item[].value + \", \" + item[].key)\n```\n\n----------------------------------------\n\nTITLE: Implementing Default Parameters in Mojo Structs\nDESCRIPTION: This code shows how Mojo structs can also support default parameters. The example defines a struct with a default string literal parameter and demonstrates instantiating it with both default and custom values.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_166\n\nLANGUAGE: mojo\nCODE:\n```\n@value\nstruct DefaultParams[msg: StringLiteral = \"woof\"]:\n    alias message = msg\n\nfn main():\n    print(DefaultParams[]().message)  # prints 'woof'\n    print(DefaultParams[\"meow\"]().message)  # prints 'meow'\n```\n\n----------------------------------------\n\nTITLE: Converting Scalar Types in Mojo\nDESCRIPTION: Shows how to convert between different scalar types using type constructors. Demonstrates conversion from Int16 to Float32 and subsequent multiplication.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/types.mdx#2025-04-17_snippet_7\n\nLANGUAGE: mojo\nCODE:\n```\nvar my_int: Int16 = 12                 # SIMD[DType.int16, 1]\nvar my_float: Float32 = 0.75           # SIMD[DType.float32, 1]\nresult = Float32(my_int) * my_float    # Result is SIMD[DType.float32, 1]\nprint(\"Result:\", result)\n```\n\n----------------------------------------\n\nTITLE: Using Static Methods\nDESCRIPTION: Demonstrates calling static methods both directly and through instances.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/structs.mdx#2025-04-17_snippet_6\n\nLANGUAGE: mojo\nCODE:\n```\nLogger.log_info(\"Static method called.\")\nvar l = Logger()\nl.log_info(\"Static method called from instance.\")\n```\n\n----------------------------------------\n\nTITLE: Struct Parameter Deduction with Partially Bound Types in Mojo\nDESCRIPTION: Demonstrates struct parameter deduction (CTAD) for partially bound types in Mojo, including deduction from static methods. This shows how parameters can be inferred automatically.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_162\n\nLANGUAGE: mojo\nCODE:\n```\n@value\nstruct Thing[v: Int]: pass\n\nstruct CtadStructWithDefault[a: Int, b: Int, c: Int = 8]:\n    fn __init__(inout self, x: Thing[a]):\n        print(\"hello\", a, b, c)\n\n    @staticmethod\n    fn foo(x: Thing[a]):\n        print(\"🔥\", a, b, c)\n\nfn main():\n    _ = CtadStructWithDefault[b=7](Thing[6]())  # prints 'hello 6 7 8'\n    CtadStructWithDefault[b=7].foo(Thing[6]())  # prints '🔥 6 7 8'\n```\n\n----------------------------------------\n\nTITLE: For Loop with Break Statement in Mojo\nDESCRIPTION: Demonstrates terminating a for loop early using the break statement when a condition is met.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/control-flow.mdx#2025-04-17_snippet_18\n\nLANGUAGE: mojo\nCODE:\n```\nfor i in range(5):\n    if i == 3:\n        break\n    print(i, end=\", \")\n```\n\n----------------------------------------\n\nTITLE: Using Keyword Arguments with __getitem__ in Mojo\nDESCRIPTION: Example of using keyword arguments when invoking __getitem__ with bracket syntax in Mojo. This shows how to implement and call a __getitem__ method that accepts keyword arguments.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_158\n\nLANGUAGE: mojo\nCODE:\n```\n@value\nstruct MyStruct:\n    fn __getitem__(self, x: Int, y: Int, z: Int) -> Int:\n        return x * y + z\n\nMyStruct()[z=7, x=3, y=5]  # returns 22\n```\n\n----------------------------------------\n\nTITLE: Creating Generic Functions with Trait Constraints in Mojo\nDESCRIPTION: Shows how to write generic functions that accept any type conforming to a specific trait, using parameterized functions with trait-typed parameters.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_141\n\nLANGUAGE: mojo\nCODE:\n```\nfn fun_with_traits[T: SomeTrait](x: T):\n    x.required_method(42)\n```\n\n----------------------------------------\n\nTITLE: Using Function Overloading with Parameter Signatures in Mojo\nDESCRIPTION: Demonstration of how to overload functions based on parameter signatures, allowing for multiple implementations of the same function name with different parameter sets.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_188\n\nLANGUAGE: mojo\nCODE:\n```\nfn foo[a: Int](x: Int):\n    pass\n\nfn foo[a: Int, b: Int](x: Int):\n    pass\n```\n\n----------------------------------------\n\nTITLE: GPU Addition Kernel Implementation in Mojo\nDESCRIPTION: Demonstrates a basic GPU kernel implementation for element-wise addition operation using Mojo's gpu package, showing thread and block indexing for parallel execution.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_11\n\nLANGUAGE: mojo\nCODE:\n```\nfrom max.tensor import ManagedTensorSlice\nfrom gpu import thread_idx, block_dim, block_idx\n\nfn gpu_add_kernel(out: ManagedTensorSlice, x: ManagedTensorSlice[out.type, out.rank]):\n    tid_x = thread_idx.x + block_dim.x * block_idx.x\n    tid_y = thread_idx.y + block_dim.y * block_dim.y\n    if tid_x < x.dim_size(0) and tid_y < x.dim_size(1):\n        out[tid_x, tid_y] = x[tid_x, tid_y] + 1\n```\n\n----------------------------------------\n\nTITLE: Defining Core ML Dependencies\nDESCRIPTION: Specifies core machine learning dependencies including PyTorch 2.5.1 with CUDA support, transformers, tokenizers, and other essential packages.\nSOURCE: https://github.com/modular/max/blob/main/src/max/pipelines/requirements.txt#2025-04-17_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\nclick >= 8.1.7\nfastapi >= 0.111.0\ngguf >= 0.10.0\nrequests >= 2.32.3\ntokenizers >= 0.19.1\n# PyTorch 2.5.1 with cuda support\ntorch == 2.5.1\ntorchvision == 0.20.1\ntorchaudio == 2.5.1\ntransformers >= 4.44.2\nsafetensors >= 0.4.5\npsutil\n```\n\n----------------------------------------\n\nTITLE: Using Boolable Trait with List in Mojo\nDESCRIPTION: Example of using the new Boolable trait implementation with List objects. The collection evaluates to True if it contains elements and False otherwise, allowing for concise conditional checks.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_89\n\nLANGUAGE: mojo\nCODE:\n```\ndef list_names(names: List[String]):\n    if names:\n        for name in names:\n            print(name[])\n    else:\n        print(\"No names to list.\")\n```\n\n----------------------------------------\n\nTITLE: Using Chained Assignments and Walrus Operator in Mojo\nDESCRIPTION: Example of chained assignments and the walrus operator, new features that allow for more concise code similar to Python syntax.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_185\n\nLANGUAGE: mojo\nCODE:\n```\na = b = 42  # chained assignment\nsome_function(b := 17)  # walrus operator\n```\n\n----------------------------------------\n\nTITLE: Using Tuple Syntax in Assignment Operations\nDESCRIPTION: Example of using tuple syntax on the left-hand side of assignments, enabling operations like value swapping. Note that parentheses are required and element types must exactly match.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_192\n\nLANGUAGE: mojo\nCODE:\n```\n(a, b) = (b, a)  # swap values using tuple assignment\n```\n\n----------------------------------------\n\nTITLE: Implicit Type Conversion Example\nDESCRIPTION: Shows automatic conversion of integer to floating-point type during assignment.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/variables.mdx#2025-04-17_snippet_3\n\nLANGUAGE: mojo\nCODE:\n```\nvar temperature: Float64 = 99\nprint(temperature)\n```\n\n----------------------------------------\n\nTITLE: Optional Arguments Implementation in Mojo\nDESCRIPTION: Example of implementing optional arguments with default values in a power function.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/functions.mdx#2025-04-17_snippet_9\n\nLANGUAGE: mojo\nCODE:\n```\nfn my_pow(base: Int, exp: Int = 2) -> Int:\n    return base ** exp\n\nfn use_defaults():\n    # Uses the default value for `exp`\n    var z = my_pow(3)\n    print(z)\n```\n\n----------------------------------------\n\nTITLE: Implementing Parametric Function Declarations in Mojo\nDESCRIPTION: Demonstrates the syntax for declaring parametric functions and struct methods with type parameters in Mojo. It shows how to use generic types and specify method receivers.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_235\n\nLANGUAGE: mojo\nCODE:\n```\nstruct SIMD[dt: DType, width: index]:\n    fn struct_method(self: &SIMD[dt, width]):\n        pass\n\ndef fancy_add[dt: DType, width: index](\n    lhs: SIMD[dt, width], rhs: SIMD[dt, width]) -> index:\n  return width\n```\n\n----------------------------------------\n\nTITLE: Naive File Handling Approach in Mojo\nDESCRIPTION: Shows a basic approach to file handling without proper error handling or resource management.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/errors.mdx#2025-04-17_snippet_5\n\nLANGUAGE: mojo\nCODE:\n```\n# Obtain a file handle to read from storage\nf = open(input_file, \"r\")\ncontent = f.read()\n# Process the content as needed\n# Close the file handle\nf.close()\n```\n\n----------------------------------------\n\nTITLE: Using Keyword Parameters in Structs with Mojo\nDESCRIPTION: Example of using compile-time keyword parameters in Mojo structs. This demonstrates how to define structs with keyword parameters and default values, and how to instantiate them with different parameter combinations.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_156\n\nLANGUAGE: mojo\nCODE:\n```\nstruct KwParamStruct[a: Int, msg: String = \"🔥mojo🔥\"]:\n    fn __init__(inout self):\n        print(msg, a)\n\nfn use_kw_params():\n    KwParamStruct[a=42]()               # prints '🔥mojo🔥 42'\n    KwParamStruct[5, msg=\"hello\"]()     # prints 'hello 5'\n    KwParamStruct[msg=\"hello\", a=42]()  # prints 'hello 42'\n```\n\n----------------------------------------\n\nTITLE: Defining Basic Value Struct with @value Decorator in Mojo\nDESCRIPTION: Demonstrates how to create a simple struct with the @value decorator, which automatically synthesizes essential lifecycle methods.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/structs.mdx#2025-04-17_snippet_7\n\nLANGUAGE: mojo\nCODE:\n```\n@value\nstruct MyPet:\n    var name: String\n    var age: Int\n```\n\n----------------------------------------\n\nTITLE: Implementing Interfaces in Mojo with @interface and @implements Decorators\nDESCRIPTION: Demonstration of Mojo's interface system using the @interface and @implements decorators, allowing multiple implementations of the same function interface.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_233\n\nLANGUAGE: mojo\nCODE:\n```\n@interface\ndef add(lhs: index, rhs: index):\n\n@implements(add)\ndef normal_add(lhs: index, rhs: index) -> index:\n    return lhs + rhs\n\n@implements(add)\ndef slow_add(lhs: index, rhs: index) -> index:\n    wait(1000)\n    return normal_add(lhs, rhs)\n```\n\n----------------------------------------\n\nTITLE: Implicit Variable Declaration in Mojo\nDESCRIPTION: Shows implicit variable declaration through direct assignment without using the var keyword.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/variables.mdx#2025-04-17_snippet_1\n\nLANGUAGE: mojo\nCODE:\n```\na = 5\nb = 3.14\n```\n\n----------------------------------------\n\nTITLE: Importing and Using NumPy in Mojo\nDESCRIPTION: Demonstrates how to import and use a Python module (NumPy) in Mojo, showcasing Mojo's Python integration capabilities.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/basics.mdx#2025-04-17_snippet_22\n\nLANGUAGE: mojo\nCODE:\n```\nfrom python import Python\n\ndef main():\n    var np = Python.import_module(\"numpy\")\n    var ar = np.arange(15).reshape(3, 5)\n    print(ar)\n    print(ar.shape)\n```\n\n----------------------------------------\n\nTITLE: Late Initialization Example\nDESCRIPTION: Shows how to use type annotations for late initialization in a function context.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/variables.mdx#2025-04-17_snippet_6\n\nLANGUAGE: mojo\nCODE:\n```\nfn my_function(x: Int):\n    var z: Float32\n    if x != 0:\n        z = 1.0\n    else:\n        z = foo()\n    print(z)\n\nfn foo() -> Float32:\n    return 3.14\n```\n\n----------------------------------------\n\nTITLE: Using Result Parameters in Mojo Function Calls\nDESCRIPTION: Example of using result parameters in Mojo function calls, where functions can return compile-time constants that are used for further compile-time operations like SIMD vector sizing.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_228\n\nLANGUAGE: mojo\nCODE:\n```\nfn get_preferred_simdwidthof[() -> nelts: Int]():\n    return[2]\n\nfn vectorized_function():\n    get_preferred_simdwidthof[() -> nelts]()\n    var x: SIMD[f32, nelts]\n```\n\n----------------------------------------\n\nTITLE: Implementing Variadic Keyword Arguments in Mojo\nDESCRIPTION: Example showing how to define and use variadic keyword arguments in Mojo using the **kwargs syntax. The function prints each keyword argument and its value.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/functions.mdx#2025-04-17_snippet_16\n\nLANGUAGE: mojo\nCODE:\n```\nfn print_nicely(**kwargs: Int) raises:\n  for key in kwargs.keys():\n      print(key[], \"=\", kwargs[key[]])\n\n # prints:\n # `a = 7`\n # `y = 8`\nprint_nicely(a=7, y=8)\n```\n\n----------------------------------------\n\nTITLE: Defining Functions with Position and Keyword Arguments in Mojo\nDESCRIPTION: Demonstrates how to define functions with positional-only and keyword-only arguments using / and * notation.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/functions.mdx#2025-04-17_snippet_7\n\nLANGUAGE: mojo\nCODE:\n```\ndef myfunc(pos_only, /, pos_or_keyword, *, keyword_only):\n```\n\n----------------------------------------\n\nTITLE: Defining Initializers for @register_passable Types in Mojo\nDESCRIPTION: Shows the recommended way to define initializers for @register_passable types using 'inout self' arguments. This approach makes Mojo more consistent and similar to Python.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_120\n\nLANGUAGE: mojo\nCODE:\n```\n@register_passable\nstruct YourPair:\n    var a: Int\n    var b: Int\n    fn __init__(inout self):\n        self.a = 42\n        self.b = 17\n    fn __copyinit__(inout self, existing: Self):\n        self.a = existing.a\n        self.b = existing.b\n```\n\n----------------------------------------\n\nTITLE: Expected output from running the MAX Graph API example\nDESCRIPTION: The expected console output when executing the basic MAX Graph example, showing input/output names and a 2x1 tensor with float32 values.\nSOURCE: https://github.com/modular/max/blob/main/examples/graph-api/basics/README.md#2025-04-17_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\nInput: input0\nOutput: output0\nTensor([[1.0],\n[1.0]], dtype=float32, shape=2x1)\n```\n\n----------------------------------------\n\nTITLE: Context Managers with Error Propagation in Mojo\nDESCRIPTION: Shows how to use context managers that unconditionally propagate inner errors, allowing for simpler code when working with functions that might raise errors within a 'with' block.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_50\n\nLANGUAGE: mojo\nCODE:\n```\ndef might_raise() -> Int:\n    ...\n\ndef foo() -> Int:\n    with ContextMgr():\n        return might_raise()\n    # no longer complains about missing return\n\ndef bar():\n    var x: Int\n    with ContextMgr():\n        x = might_raise()\n    print(x) # no longer complains about 'x' being uninitialized\n```\n\n----------------------------------------\n\nTITLE: Explicit Lifetime Control with Discard Pattern\nDESCRIPTION: Shows how to explicitly control object lifetime using the discard pattern (_) in Mojo.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/lifecycle/death.mdx#2025-04-17_snippet_8\n\nLANGUAGE: mojo\nCODE:\n```\nfn __del__(owned self):\n    self.dump() # Self is still whole here\n\n    consume(self.obj2^)\n    _ = self.obj1\n    # Mojo keeps `obj1` alive until here, after its \"last use\"\n```\n\n----------------------------------------\n\nTITLE: For Loop with Empty Collection and Else Clause in Mojo\nDESCRIPTION: Demonstrates how the else clause executes even when iterating over an empty collection.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/control-flow.mdx#2025-04-17_snippet_20\n\nLANGUAGE: mojo\nCODE:\n```\nfrom collections import List\n\nempty = List[Int]()\nfor i in empty:\n    print(i[])\nelse:\n    print(\"Finished executing 'for' loop\")\n```\n\n----------------------------------------\n\nTITLE: Basic Do Nothing Function in Mojo\nDESCRIPTION: Demonstrates the minimal function declaration possible in Mojo using the def keyword.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/functions.mdx#2025-04-17_snippet_0\n\nLANGUAGE: mojo\nCODE:\n```\ndef do_nothing():\n    pass\n```\n\n----------------------------------------\n\nTITLE: Implementing Trivial Register Passable Structure\nDESCRIPTION: Shows a simplified implementation of the Pair structure using @register_passable(\"trivial\") which automatically synthesizes lifecycle methods for simple types that are just 'bags of bits'.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/decorators/register-passable.md#2025-04-17_snippet_2\n\nLANGUAGE: mojo\nCODE:\n```\n@register_passable(\"trivial\")\nstruct Pair:\n    var a: Int\n    var b: Int\n```\n\n----------------------------------------\n\nTITLE: File Reading with Context Manager in Mojo\nDESCRIPTION: Simplified file reading using Mojo's with statement and context manager functionality for automatic resource cleanup.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/errors.mdx#2025-04-17_snippet_7\n\nLANGUAGE: mojo\nCODE:\n```\nwith open(input_file, \"r\") as f:\n    content = f.read()\n    # Process the content as needed\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Asynchronous GPU Execution in Mojo\nDESCRIPTION: Example showing the asynchronous nature of GPU execution and the importance of synchronization when relying on GPU results in host code.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/gpu/basics.mdx#2025-04-17_snippet_4\n\nLANGUAGE: mojo\nCODE:\n```\nctx.enqueue_function[printing_kernel](grid_dim=1, block_dim=4)\nprint(\"This might print before the GPU has completed its work\")\n```\n\n----------------------------------------\n\nTITLE: Using Generic List with Int Type in Mojo\nDESCRIPTION: Shows how to create and use a generic List container with Int type elements.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/traits.mdx#2025-04-17_snippet_9\n\nLANGUAGE: mojo\nCODE:\n```\nfrom collections import List\n\nvar list = List[Int](1, 2, 3)\nfor i in range(len(list)):\n    print(list[i], sep=\" \", end=\"\")\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Global Variables in Mojo\nDESCRIPTION: Example showing how to use global variables in Mojo. Global variable initializers run when code modules are loaded according to dependency order, and their destructors are called in reverse order.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_182\n\nLANGUAGE: mojo\nCODE:\n```\nvar x = 10  # global variable declaration with var\nlet y = 20  # global variable declaration with let\n```\n\n----------------------------------------\n\nTITLE: Integer Addition Function in Mojo\nDESCRIPTION: Shows a basic function that adds two integers with explicit type declarations.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/functions.mdx#2025-04-17_snippet_1\n\nLANGUAGE: mojo\nCODE:\n```\ndef add(a: Int, b: Int) -> Int:\n    return a+b\n```\n\n----------------------------------------\n\nTITLE: For Loop with Break Bypassing Else Clause in Mojo\nDESCRIPTION: Shows how a break statement prevents the else clause from executing in a for loop.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/control-flow.mdx#2025-04-17_snippet_21\n\nLANGUAGE: mojo\nCODE:\n```\nfrom collections import List\n\nanimals = List[String](\"cat\", \"aardvark\", \"hippopotamus\", \"dog\")\nfor animal in animals:\n    if animal[] == \"dog\":\n        print(\"Found a dog\")\n        break\nelse:\n    print(\"No dog found\")\n```\n\n----------------------------------------\n\nTITLE: Raising an Error in Mojo\nDESCRIPTION: This function demonstrates how to raise an error in Mojo, which will propagate to the calling function if not handled.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/functions.mdx#2025-04-17_snippet_26\n\nLANGUAGE: mojo\nCODE:\n```\ndef raises_error():\n    raise Error(\"There was an error.\")\n```\n\n----------------------------------------\n\nTITLE: Sample Python Module for Mojo Integration\nDESCRIPTION: A Python module that uses NumPy to generate random values, which can be imported and used in Mojo code.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/python/index.mdx#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nimport numpy as np\n\ndef gen_random_values(size, base):\n    # generate a size x size array of random numbers between base and base+1\n    random_array = np.random.rand(size, size)\n    return random_array + base\n```\n\n----------------------------------------\n\nTITLE: Implementing parametric for loop in Mojo\nDESCRIPTION: Shows how to use the @parameter decorator with a for loop to create a loop that's evaluated at compile time, effectively unrolling the loop.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/decorators/parameter.md#2025-04-17_snippet_1\n\nLANGUAGE: mojo\nCODE:\n```\nfn parameter_for[max: Int]():\n    @parameter\n    for i in range(max):\n        @parameter\n        if i == 10:\n            print(\"found 10!\")\n```\n\n----------------------------------------\n\nTITLE: Heterogeneous Variadic Arguments in Mojo\nDESCRIPTION: Implementation of a function that accepts multiple argument types using traits and parameters.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/functions.mdx#2025-04-17_snippet_14\n\nLANGUAGE: mojo\nCODE:\n```\nfn count_many_things[*ArgTypes: Intable](*args: *ArgTypes) -> Int:\n    var total = 0\n\n    @parameter\n    fn add[Type: Intable](value: Type):\n        total += Int(value)\n\n    args.each[add]()\n    return total\n\nprint(count_many_things(5, 11.7, 12))\n```\n\n----------------------------------------\n\nTITLE: Implementing Compile-Time Attribute Checking with __getattr__ in Mojo\nDESCRIPTION: This example demonstrates using the new parameter-based dunder methods capability to implement compile-time attribute name checking. The RGB struct uses a parameterized __getattr__ method to validate attribute names at compile time.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_86\n\nLANGUAGE: mojo\nCODE:\n```\nstruct RGB:\n   fn __getattr__[name: StringLiteral](self) -> Int:\n       @parameter\n       if name == \"r\":   return ...\n       elif name == \"g\": return ...\n       else:\n           constrained[name == \"b\", \"can only access with r, g, or b members\"]()\n           return ...\n\nvar rgb = RGB()\nprint(rgb.b) # Works\nprint(rgb.q) # Compile error\n```\n\n----------------------------------------\n\nTITLE: Creating and Using Runtime Closures in Mojo\nDESCRIPTION: Demonstrates the new Mojo closure model, showing how to create and return runtime closures. This example illustrates how closures capture values by copy and how function pointers can be converted to runtime closures.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_137\n\nLANGUAGE: mojo\nCODE:\n```\nfn outer(b: Bool, x: String) -> fn() escaping -> None:\n    fn closure():\n        print(x) # 'x' is captured by calling String.__copyinit__\n\n    fn bare_function():\n        print(\"hello\") # nothing is captured\n\n    if b:\n        # closure can be safely returned because it owns its state\n        return closure^\n\n    # function pointers can be converted to runtime closures\n    return bare_function\n```\n\n----------------------------------------\n\nTITLE: For Loop Iterating Over Mojo Dict Keys\nDESCRIPTION: Demonstrates iterating over the keys of a Mojo Dict and accessing corresponding values.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/control-flow.mdx#2025-04-17_snippet_14\n\nLANGUAGE: mojo\nCODE:\n```\nfrom collections import Dict\n\ncapitals = Dict[String, String]()\ncapitals[\"California\"] = \"Sacramento\"\ncapitals[\"Hawaii\"] = \"Honolulu\"\ncapitals[\"Oregon\"] = \"Salem\"\n\nfor state in capitals:\n    print(capitals[state[]] + \", \" + state[])\n```\n\n----------------------------------------\n\nTITLE: Setting up Conda Environment for BERT Inference\nDESCRIPTION: Series of commands to create and configure a Conda environment with necessary dependencies for running the BERT inference example.\nSOURCE: https://github.com/modular/max/blob/main/examples/inference/bert-mojo-torchscript/README.md#2025-04-17_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\n# Create a Conda environment if you don't have one\nconda create -n max-repo\n# Update the environment with the environment.yml file\nconda env update -n max-repo -f environment.yml --prune\n# Run the example\nconda run -n max-repo --live-stream bash run.sh\n```\n\n----------------------------------------\n\nTITLE: Combining Variadic Arguments with Keyword-Only Parameters in Mojo\nDESCRIPTION: Shows how to define functions that use both variadic positional arguments and keyword-only parameters. The function calculates a product with an optional offset parameter.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_115\n\nLANGUAGE: mojo\nCODE:\n```\nfn prod_with_offset(*args: Int, offset: Int = 0) -> Int:\n    var res = 1\n    for i in range(len(args)):\n        res *= args[i]\n    return res + offset\n\nprint(prod_with_offset(2, 3, 4, 10))         # prints 240\nprint(prod_with_offset(2, 3, 4, offset=10))  # prints 34\n```\n\n----------------------------------------\n\nTITLE: Analyzing DType Properties in Mojo\nDESCRIPTION: Defines a function to describe properties of a DType, including whether it's floating point or integral, and its minimum and maximum finite values.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/types.mdx#2025-04-17_snippet_5\n\nLANGUAGE: mojo\nCODE:\n```\nfrom utils.numerics import max_finite, min_finite\n\ndef describeDType[dtype: DType]():\n    print(dtype, \"is floating point:\", dtype.is_floating_point())\n    print(dtype, \"is integral:\", dtype.is_integral())\n    print(\"Min/max finite values for\", dtype)\n    print(min_finite[dtype](), max_finite[dtype]())\n\ndescribeDType[DType.float32]()\n```\n\n----------------------------------------\n\nTITLE: Importing and Using a Python Module in Mojo\nDESCRIPTION: Example showing how to import NumPy from Python into a Mojo program and use it to create and display an array.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/python/index.mdx#2025-04-17_snippet_1\n\nLANGUAGE: mojo\nCODE:\n```\nfrom python import Python\n\ndef main():\n    # This is equivalent to Python's `import numpy as np`\n    np = Python.import_module(\"numpy\")\n\n    # Now use numpy as if writing in Python\n    array = np.array([1, 2, 3])\n    print(array)\n```\n\n----------------------------------------\n\nTITLE: Importing a Local Python Module in Mojo\nDESCRIPTION: Mojo code that demonstrates how to add a local directory to Python path and import a custom Python module.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/python/index.mdx#2025-04-17_snippet_3\n\nLANGUAGE: mojo\nCODE:\n```\nfrom python import Python\n\ndef main():\n    Python.add_to_path(\"path/to/module\")\n    mypython = Python.import_module(\"mypython\")\n\n    values = mypython.gen_random_values(2, 3)\n    print(values)\n```\n\n----------------------------------------\n\nTITLE: Implementing Self-Referencing Struct Types\nDESCRIPTION: Demonstrates robust support for structs with fields of self-referencing types, using CollectionElement conformance and proper initialization methods.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_135\n\nLANGUAGE: mojo\nCODE:\n```\nstruct Foo(CollectionElement):\n    var vec: DynamicVector[Self]\n\n    fn __init__(inout self: Self):\n        self.vec = DynamicVector[Self]()\n\n    fn __moveinit__(inout self: Self, owned existing: Self):\n        self.vec = existing.vec ^\n\n    fn __copyinit__(inout self: Self, existing: Self):\n        self.vec = existing.vec\n\nfn main():\n    var foo = Foo()\n    print(len(foo.vec))\n```\n\n----------------------------------------\n\nTITLE: List Iteration with Pointers\nDESCRIPTION: Shows how to iterate through a List using pointers with the dereference operator.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/types.mdx#2025-04-17_snippet_16\n\nLANGUAGE: mojo\nCODE:\n```\nvar list = List(2, 3, 4)\nfor item in list:\n      print(item[], end=\", \")\n```\n\n----------------------------------------\n\nTITLE: Using the Simplified Benchmark Module in Mojo\nDESCRIPTION: Example of using the simplified benchmark module in Mojo to measure function performance. This shows how to run benchmarks, get timing results, and print reports with different units.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_160\n\nLANGUAGE: mojo\nCODE:\n```\nimport benchmark\nfrom time import sleep\n\nfn sleeper():\n    sleep(.01)\n\nfn main():\n    let report = benchmark.run[sleeper]()\n    print(report.mean())\n```\n\n----------------------------------------\n\nTITLE: Creating a Python Dictionary in Mojo\nDESCRIPTION: Shows how to create and manipulate a Python dictionary using the Python.dict() method, which provides a way to work with heterogeneous data collections in Mojo.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/python/types.mdx#2025-04-17_snippet_1\n\nLANGUAGE: mojo\nCODE:\n```\nfrom python import Python\n\ndef main():\n    py_dict = Python.dict()\n    py_dict[\"item_name\"] = \"whizbang\"\n    py_dict[\"price\"] = 11.75\n    py_dict[\"inventory\"] = 100\n    print(py_dict)\n```\n\n----------------------------------------\n\nTITLE: Referencing Function Arguments within Signature in Mojo\nDESCRIPTION: Demonstrates how to reference function argument input parameters within the signature of the function in Mojo, allowing for type dependencies between parameters.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_159\n\nLANGUAGE: mojo\nCODE:\n```\nfn foo(x: SIMD, y: SIMD[x.type, x.size]):\n    pass\n```\n\n----------------------------------------\n\nTITLE: Defining a Struct with @value Decorator in Mojo\nDESCRIPTION: This example shows how to apply the @value decorator to a simple struct with name and age fields, which automatically generates the necessary lifecycle methods.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/decorators/value.md#2025-04-17_snippet_0\n\nLANGUAGE: mojo\nCODE:\n```\n@value\nstruct MyPet:\n    var name: String\n    var age: Int\n```\n\n----------------------------------------\n\nTITLE: Using Type Annotations with Variables in Mojo\nDESCRIPTION: Demonstrates declaring variables with explicit type annotations, with and without initial values.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/basics.mdx#2025-04-17_snippet_3\n\nLANGUAGE: mojo\nCODE:\n```\ndef main():\n    var x: Int = 10\n    var sum: Int\n    sum = x + x\n```\n\n----------------------------------------\n\nTITLE: Creating an OwnedPointer with an Int value in Mojo\nDESCRIPTION: This snippet demonstrates how to declare and initialize an OwnedPointer that points to an Int value. The OwnedPointer allocates memory and stores the value 100.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/pointers/index.mdx#2025-04-17_snippet_0\n\nLANGUAGE: mojo\nCODE:\n```\nvar ptr: OwnedPointer[Int]\nptr = OwnedPointer(100)\n```\n\n----------------------------------------\n\nTITLE: Comprehensive Error Handling Example in Mojo\nDESCRIPTION: Demonstrates a complete example of error handling using try-except-else-finally blocks, including re-raising errors and handling different scenarios.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/errors.mdx#2025-04-17_snippet_4\n\nLANGUAGE: mojo\nCODE:\n```\ndef incr(n: Int) -> Int:\n    if n == Int.MAX:\n        raise \"inc: integer overflow\"\n    else:\n        return n + 1\n\ndef main():\n    values = List(0, 1, Int.MAX)\n    for value in values:\n        try:\n            print()\n            print(\"try     =>\", value[])\n            if value[] == 1:\n                continue\n            result = \"{} incremented is {}\".format(value[], incr(value[]))\n        except e:\n            print(\"except  =>\", e)\n        else:\n            print(\"else    =>\", result)\n        finally:\n            print(\"finally => ====================\")\n```\n\n----------------------------------------\n\nTITLE: Implementing Print Function with Variadic Pack Arguments in Mojo\nDESCRIPTION: This code snippet demonstrates how to implement a simplified version of the print function using the new VariadicPack type to handle heterogeneous variadic arguments. It shows how to process the first argument and then iterate through the rest of the variadic pack.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_83\n\nLANGUAGE: mojo\nCODE:\n```\nfn print[T: Stringable, *Ts: Stringable](first: T, *rest: *Ts):\n    print_string(str(first))\n\n    @parameter\n    fn print_elt[T: Stringable](a: T):\n        print_string(\" \")\n        print_string(a)\n    rest.each[print_elt]()\n```\n\n----------------------------------------\n\nTITLE: Using Blocks and Control Flow in Mojo\nDESCRIPTION: Shows how to use code blocks with indentation for control structures like loops and conditionals.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/basics.mdx#2025-04-17_snippet_5\n\nLANGUAGE: mojo\nCODE:\n```\ndef loop():\n    for x in range(5):\n        if x % 2 == 0:\n            print(x)\n```\n\n----------------------------------------\n\nTITLE: Implementing Control Flow Statements in Mojo\nDESCRIPTION: Demonstrates the syntax for 'if' statements and 'while' loops in Mojo. It includes examples of conditional execution and iterative operations with typed variables.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_238\n\nLANGUAGE: mojo\nCODE:\n```\ndef if_stmt(c: index, a: index, b: index) -> index:\n    var result: index = 0\n    if c:\n        result = a\n    else:\n        result = b\n    return result\n\ndef while_stmt(init: index):\n    while init > 1:\n        init = init - 1\n```\n\n----------------------------------------\n\nTITLE: Running MAX Examples with Magic Command in Shell\nDESCRIPTION: Shell commands to run various MAX examples using the 'magic run' command. These commands execute Python scripts that construct graphs and use custom Mojo kernels for operations like addition, Mandelbrot set calculation, vector addition, top-K sampling, matrix multiplication, and fused attention.\nSOURCE: https://github.com/modular/max/blob/main/examples/custom_ops/README.md#2025-04-17_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\nmagic run addition\nmagic run mandelbrot\nmagic run vector_addition\nmagic run top_k\nmagic run matrix_multiplication\nmagic run fused_attention\n```\n\n----------------------------------------\n\nTITLE: Declaring Type-Safe Function in Mojo using fn\nDESCRIPTION: Example of declaring a function using 'fn' keyword in Mojo, which requires explicit type declarations for arguments and return values, providing compile-time type safety similar to Rust.\nSOURCE: https://github.com/modular/max/blob/main/examples/gui/ragdata/mojo_functions.txt#2025-04-17_snippet_1\n\nLANGUAGE: mojo\nCODE:\n```\nfn greet2(name: String) -> String:\n    return \"Hello, \" + name + \"!\"\n```\n\n----------------------------------------\n\nTITLE: Creating a Simplified Struct with @value Decorator in Mojo\nDESCRIPTION: Demonstrates how to use the @value decorator to automatically generate lifecycle methods for a struct.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/basics.mdx#2025-04-17_snippet_16\n\nLANGUAGE: mojo\nCODE:\n```\n@value\nstruct MyPair:\n    var first: Int\n    var second: Int\n\n    def dump(self):\n        print(self.first, self.second)\n```\n\n----------------------------------------\n\nTITLE: String Concatenation - New Style\nDESCRIPTION: Demonstrates the new efficient way of concatenating strings using the String constructor with buffering.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_15\n\nLANGUAGE: mojo\nCODE:\n```\nvar msg = String(\"my message\", x, y, z, sep=\" \")\n```\n\n----------------------------------------\n\nTITLE: Optional Type with Default Values\nDESCRIPTION: Shows how to use Optional types with default values using or_else().\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/types.mdx#2025-04-17_snippet_20\n\nLANGUAGE: mojo\nCODE:\n```\nvar custom_greeting: Optional[String] = None\nprint(custom_greeting.or_else(\"Hello\"))\n\ncustom_greeting = String(\"Hi\")\nprint(custom_greeting.or_else(\"Hello\"))\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Argument Exclusivity in Mojo\nDESCRIPTION: Shows how Mojo enforces argument exclusivity for mutable references to prevent aliasing. The example demonstrates an invalid case where the same string is passed as both mutable and immutable reference.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/values/ownership.mdx#2025-04-17_snippet_4\n\nLANGUAGE: mojo\nCODE:\n```\nfn append_twice(mut s: String, other: String):\n   # Mojo knows 's' and 'other' cannot be the same string.\n   s += other\n   s += other\n\nfn invalid_access():\n  var my_string = String(\"o\")\n\n  # error: passing `my_string` mut is invalid since it is also passed\n  # read.\n  append_twice(my_string, my_string)\n  print(my_string)\n```\n\n----------------------------------------\n\nTITLE: Comparing Python Objects in Mojo\nDESCRIPTION: Demonstrates how to compare Python objects in Mojo, checking value comparison, identity comparison with 'is' operator, and type checking using Python.type().\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/python/types.mdx#2025-04-17_snippet_4\n\nLANGUAGE: mojo\nCODE:\n```\nfrom python import Python\nfrom python import PythonObject\n\ndef main():\n    var value1: PythonObject = 3.7\n    value2 = Python.evaluate(\"10/3\")\n\n    # Compare values\n    print(\"Is value1 greater than 3:\", value1 > 3)\n    print(\"Is value1 greater than value2:\", value1 > value2)\n\n    # Compare identities\n    value3 = value2\n    print(\"value1 is value2:\", value1 is value2)\n    print(\"value2 is value3:\", value2 is value3)\n\n    # Compare types\n    py_float_type = Python.evaluate(\"float\")\n    print(\"Python float type:\", py_float_type)\n    print(\"value1 type:\", Python.type(value1))\n    print(\"Is value1 a Python float:\", Python.type(value1) is py_float_type)\n```\n\n----------------------------------------\n\nTITLE: Using Walrus Operator in If/While Statements\nDESCRIPTION: Example of using the walrus operator in if/while statements without requiring parentheses, allowing for more concise conditional assignment and checking.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_186\n\nLANGUAGE: mojo\nCODE:\n```\nif x := function():\n    # do something with x\n```\n\n----------------------------------------\n\nTITLE: Basic File I/O Operations in Mojo\nDESCRIPTION: This snippet demonstrates basic file I/O operations using the new 'file' module in Mojo. It shows how to open a file, read its contents, and properly close it.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_167\n\nLANGUAGE: mojo\nCODE:\n```\nvar f = open(\"my_file.txt\", \"r\")\nprint(f.read())\nf.close()\n```\n\n----------------------------------------\n\nTITLE: Using Memory-Only Types in Parameter Expressions in Mojo\nDESCRIPTION: This snippet demonstrates how to use memory-only types in parameter expressions and as function or type parameters in Mojo. It defines an IntPair struct and uses it as a compile-time parameter in a function.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_178\n\nLANGUAGE: mojo\nCODE:\n```\n@value\nstruct IntPair:\n    var first: Int\n    var second: Int\n\nfn add_them[value: IntPair]() -> Int:\n    return value.first + value.second\n\nfn main():\n    print(add_them[IntPair(1, 2)]()) # prints '3'\n```\n\n----------------------------------------\n\nTITLE: Implementing Default Parameter Values in Mojo Functions\nDESCRIPTION: This snippet demonstrates the new support for default parameter values in Mojo functions. It shows how to define functions with default parameters and how they can be called with or without explicitly providing values.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_164\n\nLANGUAGE: mojo\nCODE:\n```\nfn foo[a: Int = 3, msg: StringLiteral = \"woof\"]():\n    print(msg, a)\n\nfn main():\n    foo()  # prints 'woof 3'\n    foo[5]()  # prints 'woof 5'\n    foo[7, \"meow\"]()  # prints 'meow 7'\n```\n\n----------------------------------------\n\nTITLE: Implementing Function Overloading in Mojo\nDESCRIPTION: This Mojo code demonstrates how to implement function overloading for different types without using traits, which becomes impractical with many types.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/traits.mdx#2025-04-17_snippet_1\n\nLANGUAGE: mojo\nCODE:\n```\n@value\nstruct Duck:\n    fn quack(self):\n        print(\"Quack\")\n\n@value\nstruct StealthCow:\n    fn quack(self):\n        print(\"Moo!\")\n\nfn make_it_quack(definitely_a_duck: Duck):\n    definitely_a_duck.quack()\n\nfn make_it_quack(not_a_duck: StealthCow):\n    not_a_duck.quack()\n\nmake_it_quack(Duck())\nmake_it_quack(StealthCow())\n```\n\n----------------------------------------\n\nTITLE: Basic Variable Declaration in Mojo\nDESCRIPTION: Demonstrates explicit variable declaration using the var keyword, showing both untyped and type-annotated declarations.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/variables.mdx#2025-04-17_snippet_0\n\nLANGUAGE: mojo\nCODE:\n```\nvar a = 5\nvar b: Float64 = 3.14\n```\n\n----------------------------------------\n\nTITLE: Importing Python Module in Mojo\nDESCRIPTION: Demonstrates importing the Python module to interact with Python objects from Mojo code.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/control-flow.mdx#2025-04-17_snippet_22\n\nLANGUAGE: mojo\nCODE:\n```\nfrom python import Python\n```\n\n----------------------------------------\n\nTITLE: Using the Unroll Decorator for Loop Optimization in Mojo\nDESCRIPTION: This snippet demonstrates how to use the unroll decorator in Mojo to optimize loops. The @unroll decorator can fully unroll a loop, while @unroll(n) unrolls by a factor of n. Requires loop bounds and iteration step to be compile-time constants.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_181\n\nLANGUAGE: mojo\nCODE:\n```\n# Fully unroll the loop.\n@unroll\nfor i in range(5):\n    print(i)\n\n# Unroll the loop by a factor of 4 (with remainder iterations of 2).\n@unroll(4)\nfor i in range(10):\n    print(i)\n```\n\n----------------------------------------\n\nTITLE: Implementing Variadic Keyword Arguments in Mojo\nDESCRIPTION: Demonstrates the new support for variadic keyword arguments (kwargs) in Mojo, including how to declare and call functions using this feature.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_100\n\nLANGUAGE: mojo\nCODE:\n```\nfn print_nicely(**kwargs: Int) raises:\n  for key in kwargs.keys():\n      print(key[], \"=\", kwargs[key[]])\n\n # prints:\n # `a = 7`\n # `y = 8`\nprint_nicely(a=7, y=8)\n```\n\n----------------------------------------\n\nTITLE: Using Self Type in Parametric Types in Mojo\nDESCRIPTION: Shows how the new `Self` type can be used to refer to the enclosing type with all parameters bound to their current values, simplifying code when working with complex parametric types.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_214\n\nLANGUAGE: mojo\nCODE:\n```\nstruct MyArray[size: Int, element_type: type]:\n   fn __new__() -> Self:\n       return Self {...}\n```\n\n----------------------------------------\n\nTITLE: Working with Tuples in Mojo\nDESCRIPTION: Shows how to create and use tuples in Mojo, including explicit typing, multiple variable assignment, and indexing into tuples.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/types.mdx#2025-04-17_snippet_11\n\nLANGUAGE: mojo\nCODE:\n```\n# Tuples are immutable and can hold multiple types\nexample_tuple = Tuple[Int, String](1, \"Example\")\n\n# Assign multiple variables at once\nx, y = example_tuple\nprint(x, y)\n\n# Get individual values with an index\ns = example_tuple[1]\nprint(s)\n```\n\n----------------------------------------\n\nTITLE: Generic Type Conversion with Constraints\nDESCRIPTION: Example of using requires clauses for generic type conversion with compile-time validation.\nSOURCE: https://github.com/modular/max/blob/main/mojo/proposals/requires-clause.md#2025-04-17_snippet_2\n\nLANGUAGE: mojo\nCODE:\n```\nfn convert[From:.., To:..](value: From) -> To where can_convert_from[From, To]:\n```\n\n----------------------------------------\n\nTITLE: Dictionary Initialization with Capacity\nDESCRIPTION: Shows how to initialize a Dictionary with a specific initial capacity to optimize performance.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_61\n\nLANGUAGE: mojo\nCODE:\n```\nvar dictionary = Dict[Int,Int](power_of_two_initial_capacity = 1024)\n# Insert (2/3 of 1024) entries\n```\n\n----------------------------------------\n\nTITLE: Using Traits with Lifecycle Methods in Mojo\nDESCRIPTION: This Mojo code shows how traits can specify required lifecycle methods, including constructors and move constructors, and how to use them in generic functions.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/traits.mdx#2025-04-17_snippet_5\n\nLANGUAGE: mojo\nCODE:\n```\ntrait DefaultConstructible:\n    fn __init__(out self): ...\n\ntrait MassProducible(DefaultConstructible, Movable):\n    pass\n\nfn factory[T: MassProducible]() -> T:\n    return T()\n\nstruct Thing(MassProducible):\n    var id: Int\n\n    fn __init__(out self):\n        self.id = 0\n\n    fn __moveinit__(out self, owned existing: Self):\n        self.id = existing.id\n\nvar thing = factory[Thing]()\n```\n\n----------------------------------------\n\nTITLE: Freeing Memory with UnsafePointer in Mojo\nDESCRIPTION: Shows how to free memory allocated by an UnsafePointer. This is necessary to prevent memory leaks but results in a dangling pointer that should not be dereferenced afterward.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/pointers/unsafe-pointers.mdx#2025-04-17_snippet_7\n\nLANGUAGE: mojo\nCODE:\n```\nptr.free()\n```\n\n----------------------------------------\n\nTITLE: Mojo Implicit Conversion Implementation\nDESCRIPTION: Demonstrates the proposed syntax for opt-in implicit conversion in Mojo using the @implicit_conversion decorator.\nSOURCE: https://github.com/modular/max/blob/main/mojo/proposals/opt-in-implicit-conversion.md#2025-04-17_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nstruct Foo:\n  @implicit_conversion\n  fn __init__(out self, i: Int):\n    pass\n\nvar foo: Foo = 10\n```\n\n----------------------------------------\n\nTITLE: Valid String Reference Handling in Mojo\nDESCRIPTION: Demonstrates the correct way to handle multiple references by creating a copy of the string when both mutable and immutable references are needed.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/values/ownership.mdx#2025-04-17_snippet_5\n\nLANGUAGE: mojo\nCODE:\n```\nfn valid_access():\n  var my_string = String(\"o\")\n  var other_string = String(my_string)\n  append_twice(my_string, other_string)\n  print(my_string)\n```\n\n----------------------------------------\n\nTITLE: Using Assert Raises Context Manager\nDESCRIPTION: Example of using the assert_raises context manager to verify that a function correctly raises an exception under certain conditions. Demonstrates both passing and failing scenarios.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/tools/testing.mdx#2025-04-17_snippet_5\n\nLANGUAGE: mojo\nCODE:\n```\ndef inc(n: Int) -> Int:\n    if n == Int.MAX:\n         raise Error(\"inc overflow\")\n    return n + 1\n\nprint(\"Test passes because the error is raised\")\nwith assert_raises():\n    _ = inc(Int.MAX)\n\nprint(\"Test fails because the error isn't raised\")\nwith assert_raises():\n    _ = inc(Int.MIN)\n```\n\n----------------------------------------\n\nTITLE: Demonstrating List Iterator Usage in Mojo\nDESCRIPTION: Shows how to iterate over a List of Elements in Mojo, demonstrating the explicit dereferencing pattern when passing borrowed values to functions.\nSOURCE: https://github.com/modular/max/blob/main/mojo/stdlib/docs/faq.md#2025-04-17_snippet_0\n\nLANGUAGE: mojo\nCODE:\n```\nfn use(element: Element): # takes a borrow\n\nfn test(elements: List[Element]):\n  for e in elements:\n    use(e[]) # Passes the referenced value by-borrow without a copy\n```\n\n----------------------------------------\n\nTITLE: Infer-Only Parameters with Structs in Mojo\nDESCRIPTION: Demonstration of infer-only parameters with structs in Mojo, where type parameters can be inferred from dependent parameter values, making struct instantiation more concise.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_71\n\nLANGUAGE: mojo\nCODE:\n```\nstruct ScalarContainer[dt: DType, //, value: Scalar[dt]]:\n    pass\n\nfn foo(x: ScalarContainer[Int32(0)]): # 'dt' is inferred as `DType.int32`\n    pass\n```\n\n----------------------------------------\n\nTITLE: Defining Functions with Parameter Inference in Mojo\nDESCRIPTION: Demonstrates the parameter inference capability in function calls, where parameters can be inferred from the argument list based on type structure.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_218\n\nLANGUAGE: mojo\nCODE:\n```\nfn dyn_cast[DstType: type, SrcType: type](src: SrcType) -> DstType:\n```\n\n----------------------------------------\n\nTITLE: Named Result Bindings in Mojo Functions\nDESCRIPTION: Shows how to use named result bindings in Mojo to directly emplace function results into the output slot. This feature provides more flexibility than traditional NRVO and works with non-movable result types.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_48\n\nLANGUAGE: mojo\nCODE:\n```\nfn efficiently_return_string(b: Bool) -> String as output:\n    if b:\n        output = \"emplaced!\"\n        mutate(output)\n        return\n    return \"regular return\"\n```\n\n----------------------------------------\n\nTITLE: Demonstrating ASAP Destruction with MyPet Values in Mojo\nDESCRIPTION: This example shows how Mojo's ASAP destruction policy works by printing destruction messages for MyPet instances. It demonstrates that values are destroyed immediately after their last use, even when reassigned.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/lifecycle/death.mdx#2025-04-17_snippet_0\n\nLANGUAGE: mojo\nCODE:\n```\n@value\nstruct MyPet:\n    var name: String\n    var age: Int\n\n    fn __del__(owned self):\n        print(\"Destruct\", self.name)\n\nfn pets():\n    var a = MyPet(\"Loki\", 4)\n    var b = MyPet(\"Sylvie\", 2)\n    print(a.name)\n    # a.__del__() runs here for \"Loki\"\n\n    a = MyPet(\"Charlie\", 8)\n    # a.__del__() runs immediately because \"Charlie\" is never used\n\n    print(b.name)\n    # b.__del__() runs here\n\npets()\n```\n\n----------------------------------------\n\nTITLE: Using Boolean Values in Mojo\nDESCRIPTION: Demonstrates the use of Mojo's Bool type, including variable declaration, assignment, and negation using the 'not' operator.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/types.mdx#2025-04-17_snippet_10\n\nLANGUAGE: mojo\nCODE:\n```\nvar conditionA = False\nvar conditionB: Bool\nconditionB = not conditionA\nprint(conditionA, conditionB)\n```\n\n----------------------------------------\n\nTITLE: Iterating over a Python List in Mojo\nDESCRIPTION: Creates a mixed-type Python list and iterates over it using a for loop in Mojo. Each element is accessed as a PythonObject.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/control-flow.mdx#2025-04-17_snippet_23\n\nLANGUAGE: mojo\nCODE:\n```\n# Create a mixed-type Python list\npy_list = Python.evaluate(\"[42, 'cat', 3.14159]\")\nfor py_obj in py_list:  # Each element is of type \"PythonObject\"\n    print(py_obj)\n```\n\n----------------------------------------\n\nTITLE: Defining and Launching a Basic GPU Kernel in Mojo\nDESCRIPTION: Example of defining a simple GPU kernel function that prints thread indices, and launching it using a DeviceContext. Demonstrates basic kernel execution and synchronization.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/gpu/basics.mdx#2025-04-17_snippet_1\n\nLANGUAGE: mojo\nCODE:\n```\nfrom gpu import thread_idx\nfrom gpu.host import DeviceContext\n\ndef main():\n    fn printing_kernel():\n        print(\"GPU thread: [\", thread_idx.x, thread_idx.y, thread_idx.z, \"]\")\n\n    var ctx = DeviceContext()\n\n    ctx.enqueue_function[printing_kernel](grid_dim=1, block_dim=4)\n    ctx.synchronize()\n```\n\n----------------------------------------\n\nTITLE: Declaring Functions with Combined Optional and Variadic Arguments in Mojo\nDESCRIPTION: This example shows how to define a function that accepts both optional arguments with default values and variadic arguments (both positional and keyword). The function demonstrates the new syntax capabilities for parameter declarations in Mojo.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_84\n\nLANGUAGE: mojo\nCODE:\n```\nfn variadic_arg_after_default(\n  a: Int, b: Int = 3, *args: Int, c: Int, d: Int = 1, **kwargs: Int\n): ...\n```\n\n----------------------------------------\n\nTITLE: Creating Row-Major and Column-Major Layouts in Mojo\nDESCRIPTION: Demonstrates how to create 2x4 row-major and 6x6 column-major layouts using the Layout class.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/layout/layouts.mdx#2025-04-17_snippet_0\n\nLANGUAGE: mojo\nCODE:\n```\nfrom layout import Layout, print_layout\n\nvar l2x4row_major = Layout.row_major(2, 4)\nvar l6x6col_major = Layout.col_major(6, 6)\n```\n\n----------------------------------------\n\nTITLE: Value Semantics with SIMD in Mojo\nDESCRIPTION: This snippet demonstrates value semantics with a more complex type (SIMD vector). It shows that modifying the argument inside the function doesn't affect the original value.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/values/value-semantics.mdx#2025-04-17_snippet_2\n\nLANGUAGE: mojo\nCODE:\n```\ndef update_simd(t: SIMD[DType.int32, 4]):\n    t[0] = 9\n    print(t)\n\nv = SIMD[DType.int32, 4](1, 2, 3, 4)\nupdate_simd(v)\nprint(v)\n```\n\n----------------------------------------\n\nTITLE: Implementing Static Method in Mojo Struct\nDESCRIPTION: This snippet demonstrates how to declare a static method 'load_from_file' in a Mojo struct 'MyStruct'. The static method reads bytes from a file and returns a new instance of the struct. It also shows the implementation of __init__ and __moveinit__ methods.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/decorators/staticmethod.md#2025-04-17_snippet_0\n\nLANGUAGE: mojo\nCODE:\n```\nfrom collections import List\nfrom pathlib import Path\n\n\nstruct MyStruct:\n    var data: List[UInt8]\n\n    fn __init__(out self):\n        self.data = List[UInt8]()\n\n    fn __moveinit__(out self, owned existing: Self):\n        self.data = existing.data ^\n\n    @staticmethod\n    fn load_from_file(file_path: Path) raises -> Self:\n        var new_struct = MyStruct()\n        new_struct.data = file_path.read_bytes()\n        return new_struct ^\n```\n\n----------------------------------------\n\nTITLE: Async Functions with Memory-Only Results and Error Handling in Mojo\nDESCRIPTION: Demonstrates async functions that support memory-only results (like String, List) and the raises keyword for error handling. This allows for more flexible return types in asynchronous code.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_51\n\nLANGUAGE: mojo\nCODE:\n```\nasync fn raise_or_string(c: Bool) raises -> String:\n    if c:\n        raise \"whoops!\"\n    return \"hello world!\"\n```\n\n----------------------------------------\n\nTITLE: Tensor Addition with Parameterization\nDESCRIPTION: Demonstrates a function using compile-time parameters for tensor operations.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/functions.mdx#2025-04-17_snippet_2\n\nLANGUAGE: mojo\nCODE:\n```\ndef add_tensors[rank: Int](a: MyTensor[rank], b: MyTensor[rank]) -> MyTensor[rank]:\n    # ...\n```\n\n----------------------------------------\n\nTITLE: Using List.index() Method in Mojo\nDESCRIPTION: Demonstrates how to find the first index of an element in a List using the new index() method for collections of EqualityComparable types.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_80\n\nLANGUAGE: mojo\nCODE:\n```\nvar my_list = List[Int](2, 3, 5, 7, 3)\nprint(my_list.index(3))  # prints 1\n```\n\n----------------------------------------\n\nTITLE: Variadic Arguments Sum Function in Mojo\nDESCRIPTION: Implementation of a sum function that accepts variable number of integer arguments.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/functions.mdx#2025-04-17_snippet_11\n\nLANGUAGE: mojo\nCODE:\n```\nfn sum(*values: Int) -> Int:\n  var sum: Int = 0\n  for value in values:\n    sum = sum + value\n  return sum\n```\n\n----------------------------------------\n\nTITLE: Using any() and all() with SIMD Vectors in Mojo\nDESCRIPTION: Demonstrates how to check for truthy elements in a SIMD vector using the any() and all() functions, which replaces the now-constrained SIMD.__bool__() method for vectors with more than one element.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_78\n\nLANGUAGE: mojo\nCODE:\n```\nfn truthy_simd():\n    var vec = SIMD[DType.int32, 4](0, 1, 2, 3)\n    if any(vec):\n        print(\"any elements are truthy\")\n    if all(vec):\n        print(\"all elements are truthy\")\n```\n\n----------------------------------------\n\nTITLE: Implementing a Custom Destructor for Memory Management in Mojo\nDESCRIPTION: This example demonstrates a struct with a custom destructor to properly clean up dynamically allocated memory. The HeapArray struct manages an array on the heap using UnsafePointer and must free that memory in its destructor.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/lifecycle/death.mdx#2025-04-17_snippet_2\n\nLANGUAGE: mojo\nCODE:\n```\nfrom memory import UnsafePointer\n\nstruct HeapArray:\n    var data: UnsafePointer[Int]\n    var size: Int\n\n    fn __init__(out self, size: Int, val: Int):\n        self.size = size\n        self.data = UnsafePointer[Int].alloc(self.size)\n        for i in range(self.size):\n            (self.data + i).init_pointee_copy(val)\n\n    fn __del__(owned self):\n        for i in range(self.size):\n            (self.data + i).destroy_pointee()\n        self.data.free()\n```\n\n----------------------------------------\n\nTITLE: Automatic Parameterization of Functions in Mojo\nDESCRIPTION: Demonstrates automatic parameterization of functions in Mojo, where parameters from a parametric type are automatically added as input parameters to a function, reducing boilerplate code.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_157\n\nLANGUAGE: mojo\nCODE:\n```\n@value\nstruct Thing[x: Int, y: Int]:\n    pass\n\nfn foo(v: Thing):\n    print(v.x)\n    print(v.y)\n\nfn main():\n    let v = Thing[2, 3]()\n    foo(v)\n```\n\n----------------------------------------\n\nTITLE: Defining an Implicit Conversion Constructor in Mojo\nDESCRIPTION: This snippet demonstrates how to define a struct with an implicit conversion constructor for Int and a non-implicit constructor for Float64. The @implicit decorator is used to mark the Int constructor as eligible for implicit conversion.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/decorators/implicit.md#2025-04-17_snippet_0\n\nLANGUAGE: mojo\nCODE:\n```\nstruct MyInt:\n    var value: Int\n\n    @implicit\n    fn __init__(out self, value: Int):\n        self.value = value\n\n    fn __init__(out self, value: Float64):\n        self.value = Int(value)\n\n```\n\n----------------------------------------\n\nTITLE: Allocating Memory with UnsafePointer in Mojo\nDESCRIPTION: Demonstrates how to allocate memory for a single Int value using the alloc() static method. The allocated memory is uninitialized and must be initialized before use.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/pointers/unsafe-pointers.mdx#2025-04-17_snippet_4\n\nLANGUAGE: mojo\nCODE:\n```\nptr = UnsafePointer[Int].alloc(1)\n```\n\n----------------------------------------\n\nTITLE: Function Call Examples\nDESCRIPTION: Shows different ways to call functions using positional and keyword arguments.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/functions.mdx#2025-04-17_snippet_3\n\nLANGUAGE: mojo\nCODE:\n```\n# positional\nx = add(5, 7)\n# keyword\ny = add(a=9, b=3)\n```\n\n----------------------------------------\n\nTITLE: Defining Functions that Raise Errors with fn in Mojo\nDESCRIPTION: Demonstrates how to declare a function that can raise errors using the fn keyword and raises attribute.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/basics.mdx#2025-04-17_snippet_10\n\nLANGUAGE: mojo\nCODE:\n```\nfn greet(name: String) raises:\n    if (name == \"\"):\n        raise Error(\"Name is empty\")\n    return \"Hello, \" + name + \"!\"\n```\n\n----------------------------------------\n\nTITLE: Iterating over a Python Dictionary using items() in Mojo\nDESCRIPTION: Demonstrates an alternative method to iterate over a Python dictionary in Mojo by using the items() method. This produces a sequence of 2-tuple objects containing both keys and values.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/control-flow.mdx#2025-04-17_snippet_25\n\nLANGUAGE: mojo\nCODE:\n```\nfor py_tuple in py_dict.items():  # Each element is of type \"PythonObject\"\n    print(py_tuple[0], py_tuple[1])\n```\n\n----------------------------------------\n\nTITLE: Implementing Stringable Trait for Custom Types in Mojo\nDESCRIPTION: Shows how to implement the Stringable trait for custom types by defining the __str__ method, allowing the type to be used with print and str() functions.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_145\n\nLANGUAGE: mojo\nCODE:\n```\n@value\nstruct BoxedInt(Stringable):\n    var value: Int\n\n    fn __str__(self) -> String:\n        return self.value\n\nprint(BoxedInt(11), \"hello traits!\", BoxedInt(42))\n```\n\n----------------------------------------\n\nTITLE: Implementing Hashable and Hasher Traits in Mojo\nDESCRIPTION: Comprehensive implementation of hashing functionality including Hashable and Hasher traits, example structs (MyInt, MyString, Person), and DJBX33A hasher implementation. Demonstrates trait inheritance, value types, and hash calculation with configurable secrets.\nSOURCE: https://github.com/modular/max/blob/main/mojo/proposals/improved-hash-module.md#2025-04-17_snippet_7\n\nLANGUAGE: mojo\nCODE:\n```\nfrom os.env import getenv, setenv\nfrom random import random_si64\n\ntrait Hashable:\n    \"\"\"Trait which every hashable type needs to implement.\"\"\"\n    fn __hash__[H: Hasher](self, mut hasher: H):\n        ...\n\ntrait Hasher:\n    \"\"\"Trait which every hash function implementer needs to implement.\"\"\"\n    fn __init__(out self):\n        \"\"\"Expects a no argument instantiation.\"\"\"\n        ...\n    fn _update_with_bytes(mut self, bytes: DTypePointer[DType.uint8], n: Int):\n        \"\"\"Conribute to the hash value based on a sequence of bytes. Use only for complex types which are not just a composition of Hashable types.\"\"\"\n        ...\n    fn _update_with_simd[dt: DType, size: Int](mut self, value: SIMD[dt, size]):\n        \"\"\"Contribute to the hash value with a compile time know fix size value. Used inside of std lib to avoid runtime branching.\"\"\"\n        ...\n    fn update[T: Hashable](mut self, value: T):\n        \"\"\"Contribute to the hash value with a Hashable value. Should be used by implementors of Hashable types which are a composition of Hashable types.\"\"\"\n        ...\n    fn _finish[dt: DType = DType.uint64](owned self) -> Scalar[dt]:\n        \"\"\"Used internally to generate the final hash value, should be simplified to `_finish(owned self) -> Scalar[hash_value_dt]`\n        once trait declarations support parameters and we can switch to `trait Hasher[hash_value_dt: DType]`.\n        This is beneficial as hash functions have different implementations based on the type \"\"\"\n        ...\n\n@value\nstruct MyInt(Hashable):\n    \"\"\"An example for the Int type.\"\"\"\n    var value: Int\n\n    @always_inline\n    fn __hash__[H: Hasher](self, mut hasher: H):\n        hasher._update_with_simd(Int64(self.value))\n\n@value\nstruct MyString(Hashable):\n    \"\"\"An example for the String type.\"\"\"\n    var value: StringLiteral\n\n    @always_inline\n    fn __hash__[H: Hasher](self, mut hasher: H):\n        hasher.update(MyInt(len(self.value)))\n        hasher._update_with_bytes(self.value.data().bitcast[DType.uint8](), len(self.value))\n\n@value\nstruct Person(Hashable):\n    \"\"\"An example for a type composing Hashable types.\"\"\"\n    var name: MyString\n    var age: MyInt\n\n    fn __hash__[H: Hasher](self, mut hasher: H):\n        hasher.update(self.name)\n        hasher.update(self.age)\n\nalias DefaultHasher = DJBX33A_Hasher[0]\n\n@always_inline\nfn my_hash[V: Hashable, hasher_type: Hasher = DefaultHasher](value: V) -> UInt64:\n    \"\"\"Example how the `hash` function should look like.\"\"\"\n    var hasher = hasher_type()\n    hasher.update(value)\n    return hasher^._finish()\n\n@always_inline\nfn _DJBX33A_SECRET() -> UInt64:\n    \"\"\"Example how secret and seed can be stored and retrieved.\"\"\"\n    try:\n        var secret_string = getenv(\"DJBX33A_SECRET\", \"\")\n        return bitcast[DType.uint64](Int64(Int(secret_string)))\n    except:\n        var value = random_si64(Int64.MIN, Int64.MAX)\n        _ = setenv(\"DJBX33A_SECRET\", String(value))\n        return bitcast[DType.uint64](value)\n\nstruct DJBX33A_Hasher[custom_secret: UInt64 = 0](Hasher):\n    \"\"\"Example of a simple Hasher, with an option to provide a custom secret at compile time.\n    When custom secret is set to 0 the secret will be looked up in env var DJBX33A_SECRET.\n    In case env var DJBX33A_SECRET is not set a random int will be generated.\"\"\"\n    var hash_data: UInt64\n    var secret: UInt64\n\n    @always_inline\n    fn __init__(out self):\n        self.hash_data = 5361\n        @parameter\n        if custom_secret != 0:\n            self.secret = custom_secret\n        else:\n            self.secret = _DJBX33A_SECRET()\n\n    @always_inline\n    fn _update_with_bytes(mut self, bytes: DTypePointer[DType.uint8], n: Int):\n        \"\"\"The algorithm is not optimal.\"\"\"\n        for i in range(n):\n            self.hash_data = self.hash_data * 33 + bytes.load(i).cast[DType.uint64]()\n\n    @always_inline\n    fn _update_with_simd[dt: DType, size: Int](mut self, value: SIMD[dt, size]):\n        \"\"\"The algorithm is not optimal.\"\"\"\n        alias size_in_bytes = size * dt.sizeof()\n        var bytes = bitcast[DType.uint8, size_in_bytes](value)\n        @parameter\n        for i in range(size_in_bytes):\n            self.hash_data = self.hash_data * 33 + bytes[i].cast[DType.uint64]()\n\n    @always_inline\n    fn update[T: Hashable](mut self, value: T):\n        value.__hash__(self)\n\n    @always_inline\n    fn _finish[dt: DType = DType.uint64](owned self) -> Scalar[dt]:\n        return (self.hash_data ^ self.secret).cast[dt]()\n\nfn main() raises:\n    var p = Person(\"Maxim\", 43)\n    print(p.name.value, p.age.value)\n\n    var hasher = DJBX33A_Hasher()\n    p.age.__hash__(hasher)\n    print(\"My hasher 43\", hasher^._finish())\n    print(\"Std hash 43\", hash(p.age.value))\n\n    hasher = DJBX33A_Hasher()\n    p.__hash__(hasher)\n    print(\"Person\", hasher^._finish())\n\n    var h1 = my_hash(p)\n    var h2 = my_hash[hasher_type=DJBX33A_Hasher[77777]](p)\n    var h3 = my_hash(p)\n    print(\"Person\", h1, h2, h3)\n```\n\n----------------------------------------\n\nTITLE: Basic String and Integer Variable Declaration\nDESCRIPTION: Shows implicit variable declaration with String and integer types.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/variables.mdx#2025-04-17_snippet_4\n\nLANGUAGE: mojo\nCODE:\n```\nname = String(\"Sam\")\nuser_id = 0\n```\n\n----------------------------------------\n\nTITLE: Implementing a Trait in a Struct in Mojo\nDESCRIPTION: Demonstrates how to make a struct conform to a trait by inheriting from it and implementing the required methods.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_140\n\nLANGUAGE: mojo\nCODE:\n```\nstruct SomeStruct(SomeTrait):\n    fn required_method(self, x: Int):\n        print(\"hello traits\", x)\n```\n\n----------------------------------------\n\nTITLE: Complete TwoStrings Implementation with Lifecycle Methods\nDESCRIPTION: Complete implementation of a structure showing initialization, move constructor, and destructor with field lifetime management.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/lifecycle/death.mdx#2025-04-17_snippet_7\n\nLANGUAGE: mojo\nCODE:\n```\nfn consume(owned str: String):\n    print('Consumed', str)\n\nstruct TwoStrings:\n    var str1: String\n    var str2: String\n\n    fn __init__(out self, one: String):\n        self.str1 = one\n        self.str2 = String(\"bar\")\n\n    fn __moveinit__(out self, owned existing: Self):\n        self.str1 = existing.str1\n        self.str2 = existing.str2\n\n    fn __del__(owned self):\n        self.dump() # Self is still whole here\n        # Mojo calls self.str2.__del__() since str2 isn't used anymore\n\n        consume(self.str1^)\n        # self.str1 has been transferred so it is also destroyed now;\n        # `self.__del__()` is not called (avoiding an infinite loop).\n\n    fn dump(mut self):\n        print('str1:', self.str1)\n        print('str2:', self.str2)\n\nfn use_two_strings():\n    var two_strings = TwoStrings(\"foo\")\n```\n\n----------------------------------------\n\nTITLE: Using stable sort in Mojo\nDESCRIPTION: Demonstrates how to use the new 'stable' parameter in the sort() function to perform a stable sort on a list. The algorithm requires O(N) auxiliary memory and may crash if memory allocation fails.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_64\n\nLANGUAGE: mojo\nCODE:\n```\nsort[cmp_fn, stable=True](list)\n```\n\n----------------------------------------\n\nTITLE: Python-style Reference Semantics with Lists\nDESCRIPTION: This Python snippet demonstrates 'pass by object reference' behavior with lists. It shows how modifying the list inside the function affects the original object.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/values/value-semantics.mdx#2025-04-17_snippet_4\n\nLANGUAGE: python\nCODE:\n```\ndef modify_list(l):\n    l.append(3)\n    print(\"func:\", l)\n\nar = [1, 2]\nmodify_list(ar)\nprint(\"orig:\", ar)\n```\n\n----------------------------------------\n\nTITLE: Implementing Nested Functions in Mojo\nDESCRIPTION: Shows how nested functions are now supported in Mojo, allowing function definitions within other functions.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_223\n\nLANGUAGE: mojo\nCODE:\n```\nfn foo():\n    fn bar():\n        pass\n    bar()\n```\n\n----------------------------------------\n\nTITLE: Specifying Address Space with 'ref' Convention in Mojo\nDESCRIPTION: Demonstrates how to specify an address space along with the lifetime when using the 'ref' convention.\nSOURCE: https://github.com/modular/max/blob/main/mojo/proposals/ref-convention.md#2025-04-17_snippet_2\n\nLANGUAGE: mojo\nCODE:\n```\nfn foo(...) -> ref [lifetime, addr_space] T: ...\n```\n\n----------------------------------------\n\nTITLE: Defining Functions with Variadic Arguments in Mojo\nDESCRIPTION: Shows how to define functions that accept variable numbers of arguments using * and ** notation.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/functions.mdx#2025-04-17_snippet_8\n\nLANGUAGE: mojo\nCODE:\n```\ndef myfunc2(*names, **attributes):\n```\n\n----------------------------------------\n\nTITLE: Custom Slice Type for Container Subscripting in Mojo\nDESCRIPTION: Shows how to define a custom slice type and implement __getitem__ to support custom slicing syntax. The example demonstrates that slice syntax in subscripts is no longer hardcoded to the builtin slice type.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_122\n\nLANGUAGE: mojo\nCODE:\n```\n@value\nstruct UnusualSlice:\n    var a: Int\n    var b: Float64\n    var c: String\n\nstruct YourContainer:\n    fn __getitem__(self, slice: UnusualSlice) -> T: ...\n```\n\n----------------------------------------\n\nTITLE: Basic @always_inline Function in Mojo\nDESCRIPTION: Demonstrates how to use the @always_inline decorator on a simple addition function. This forces the compiler to inline the function body at every call site, eliminating function call overhead.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/decorators/always-inline.md#2025-04-17_snippet_0\n\nLANGUAGE: mojo\nCODE:\n```\n@always_inline\nfn add(a: Int, b: Int) -> Int:\n    return a + b\n\nprint(add(1, 2))\n```\n\n----------------------------------------\n\nTITLE: Allocating Memory for Multiple Values in Mojo\nDESCRIPTION: Demonstrates how to allocate memory for multiple values using UnsafePointer. This creates a contiguous block of memory that can store multiple values of the same type.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/pointers/unsafe-pointers.mdx#2025-04-17_snippet_8\n\nLANGUAGE: mojo\nCODE:\n```\nptr = UnsafePointer[Int].alloc(10) # Allocate space for 10 Int values\n```\n\n----------------------------------------\n\nTITLE: Dereferencing UnsafePointer to Read and Write Values in Mojo\nDESCRIPTION: Shows how to use the dereference operator ([]) to read from and write to memory pointed to by an UnsafePointer. This demonstrates both reading and modifying the stored value.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/pointers/unsafe-pointers.mdx#2025-04-17_snippet_13\n\nLANGUAGE: mojo\nCODE:\n```\n# Read from pointee\nprint(ptr[])\n# mutate pointee\nptr[] = 0\n\n```\n\n----------------------------------------\n\nTITLE: Mutable List Manipulation in Mojo\nDESCRIPTION: Shows how to use the mut keyword to modify a list through a function argument. The mutate() function receives a mutable reference and modifies the original list.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/values/ownership.mdx#2025-04-17_snippet_2\n\nLANGUAGE: mojo\nCODE:\n```\nfrom collections import List\n\ndef mutate(mut l: List[Int]):\n    l.append(5)\n\nvar list = List(1, 2, 3, 4)\n\nmutate(list)\nprint_list(list)\n```\n\n----------------------------------------\n\nTITLE: Creating and Handling Dynamic Error Messages in Mojo\nDESCRIPTION: This snippet demonstrates how error messages in Mojo can now store dynamic messages. It shows defining a function that raises an error with a dynamic message and catching that error.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_173\n\nLANGUAGE: mojo\nCODE:\n```\nfn foo(x: String) raises:\n    raise Error(\"Failed on: \" + x)\n\nfn main():\n    try:\n        foo(\"Hello\")\n    except e:\n        print(e)\n```\n\n----------------------------------------\n\nTITLE: Converting Between Coordinates and Indices in Mojo Layouts\nDESCRIPTION: Demonstrates how to use a Layout object to convert between coordinates and linear index values.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/layout/layouts.mdx#2025-04-17_snippet_2\n\nLANGUAGE: mojo\nCODE:\n```\nvar coords = IntTuple(1, 1)\nvar idx = l3x4row_major(coords)\nprint(\"index at coordinates (1, 1): \", idx)\nprint(\"coordinates at index 7:\", l3x4row_major.idx2crd(7))\n```\n\n----------------------------------------\n\nTITLE: Handling Errors in Non-Raising Functions in Mojo\nDESCRIPTION: These functions demonstrate the difference between unhandled and handled errors in non-raising functions in Mojo.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/functions.mdx#2025-04-17_snippet_27\n\nLANGUAGE: mojo\nCODE:\n```\n# This function will not compile\nfn unhandled_error():\n    raises_error()   # Error: can't call raising function in a non-raising context\n\nfn handle_error():\n    try:\n        raises_error()\n    except e:\n        print(\"Handled an error,\" e)\n```\n\n----------------------------------------\n\nTITLE: Custom Timer Context Manager Implementation in Mojo\nDESCRIPTION: Implementation of a custom context manager that measures and reports execution time of code blocks.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/errors.mdx#2025-04-17_snippet_9\n\nLANGUAGE: mojo\nCODE:\n```\n@value\nstruct Timer:\n    var start_time: Int\n\n    fn __init__(out self):\n        self.start_time = 0\n\n    fn __enter__(mut self) -> Self:\n        self.start_time = time.perf_counter_ns()\n        return self\n\n    fn __exit__(mut self):\n        end_time = time.perf_counter_ns()\n        elapsed_time_ms = round(((end_time - self.start_time) / 1e6), 3)\n        print(\"Elapsed time:\", elapsed_time_ms, \"milliseconds\")\n\ndef main():\n    with Timer():\n        print(\"Beginning execution\")\n        time.sleep(1)\n        if len(sys.argv()) > 1:\n            raise \"simulated error\"\n        time.sleep(1)\n        print(\"Ending execution\")\n```\n\n----------------------------------------\n\nTITLE: Proper Synchronization in GPU Programming with Mojo\nDESCRIPTION: Demonstration of correct synchronization between GPU and CPU execution, ensuring that host code waits for GPU operations to complete before proceeding.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/gpu/basics.mdx#2025-04-17_snippet_5\n\nLANGUAGE: mojo\nCODE:\n```\nctx.enqueue_function[printing_kernel](grid_dim=1, block_dim=4)\nctx.synchronize()\nprint(\"This will print after the GPU has completed its work\")\n```\n\n----------------------------------------\n\nTITLE: MutableArraySlice Implementation\nDESCRIPTION: Implementation of a safe array slice type built on top of MutablePointer with bounds checking and lifetime preservation.\nSOURCE: https://github.com/modular/max/blob/main/mojo/proposals/lifetimes-and-provenance.md#2025-04-17_snippet_11\n\nLANGUAGE: mojo\nCODE:\n```\n    @value\n    @register_passable(\"trivial\")\n    struct MutableArraySlice[type: AnyType, life: Lifetime]:\n        var ptr: MutablePointer[type, life]\n        var size: Int\n\n        fn __init__(inout self):\n        fn __init__(inout self, ptr: MutablePointer[type, life], size: Int):\n\n        # All the normal slicing operations etc, with bounds checks.\n        fn __getitem__(self, offset: Int) -> inout[life] type:\n            assert(offset < size)\n            return ptr[offset]\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Implicit Trait Conformance in Mojo\nDESCRIPTION: This Mojo code shows how a struct can implicitly conform to a trait by implementing the required methods, even without explicitly declaring conformance.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/traits.mdx#2025-04-17_snippet_3\n\nLANGUAGE: mojo\nCODE:\n```\nstruct RubberDucky:\n    fn quack(self):\n        print(\"Squeak!\")\n\nmake_it_quack(RubberDucky())\n```\n\n----------------------------------------\n\nTITLE: Value Copy Alternative to Mutable References\nDESCRIPTION: Demonstrates the alternative approach to mutable references by copying and returning values. This is less efficient than using mut arguments.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/values/ownership.mdx#2025-04-17_snippet_3\n\nLANGUAGE: mojo\nCODE:\n```\nfrom collections import List\n\ndef mutate_copy(l: List[Int]) -> List[Int]:\n    l.append(5)\n    return l\n\nvar list = List(1, 2, 3, 4)\nlist = mutate_copy(list)\nprint_list(list)\n```\n\n----------------------------------------\n\nTITLE: Casting SIMD Types Using Constructors in Mojo\nDESCRIPTION: Shows how to cast between SIMD types using constructors, including scalar to larger vector size conversion and casting between different numeric types.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_21\n\nLANGUAGE: mojo\nCODE:\n```\nvar val = Int8(42)\nvar cast = Int32(val)\n```\n\n----------------------------------------\n\nTITLE: Using __contains__ with Tuple in Mojo\nDESCRIPTION: Shows how to use the new __contains__ method on Tuple to check if a value exists within a tuple using the 'in' operator.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_79\n\nLANGUAGE: mojo\nCODE:\n```\nvar x = Tuple(1, 2, True)\nif 1 in x:\n    print(\"x contains 1\")\n```\n\n----------------------------------------\n\nTITLE: Using out Convention in Constructor Methods\nDESCRIPTION: Example showing the new `out` argument convention for the `self` parameter in Mojo's `__init__()` method, replacing the older `inout` convention, and demonstrating how to store a function pointer to a constructor.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_25\n\nLANGUAGE: mojo\nCODE:\n```\nstruct Foo:\n    fn __init__(out self): pass\n\nfn test():\n    # This works now\n    var fnPtr : fn(out x: Foo)->None = Foo.__init__\n\n    var someFoo : Foo\n    fnPtr(someFoo)  # initializes someFoo.\n```\n\n----------------------------------------\n\nTITLE: Organizing Multiple Tests in a Test File\nDESCRIPTION: An example of organizing multiple test functions in a single test file. Shows how to test different aspects of a module including validation, conversion, and error handling.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/tools/testing.mdx#2025-04-17_snippet_7\n\nLANGUAGE: mojo\nCODE:\n```\n# File: test_my_target_module.mojo\n\nfrom my_target_module import convert_input, validate_input\nfrom testing import assert_equal, assert_false, assert_raises, assert_true\n\ndef test_validate_input():\n\tassert_true(validate_input(\"good\"), msg=\"'good' should be valid input\")\n\tassert_false(validate_input(\"bad\"), msg=\"'bad' should be invalid input\")\n\ndef test_convert_input():\n\tassert_equal(convert_input(\"input1\"), \"output1\")\n\tassert_equal(convert_input(\"input2\"), \"output2\")\n\ndef test_convert_input_error():\n\twith assert_raises():\n\t\t_ = convert_input(\"garbage\")\n```\n\n----------------------------------------\n\nTITLE: Using Named Result Parameters in Function Return Types in Mojo\nDESCRIPTION: Demonstrates how to use named result parameters in function return types, allowing the return type to reference the result parameter.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_220\n\nLANGUAGE: mojo\nCODE:\n```\nfn return_simd[() -> nelts: Int]() -> SIMD[f32, nelts]:\n```\n\n----------------------------------------\n\nTITLE: Iterating over a Python Dictionary by Keys in Mojo\nDESCRIPTION: Creates a mixed-type Python dictionary and iterates over its keys using a for loop in Mojo. Each key is used to access the corresponding value.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/control-flow.mdx#2025-04-17_snippet_24\n\nLANGUAGE: mojo\nCODE:\n```\nfrom python import Python\n\n# Create a mixed-type Python dictionary\npy_dict = Python.evaluate(\"{'a': 1, 'b': 2.71828, 'c': 'sushi'}\")\nfor py_key in py_dict:  # Each element is of type \"PythonObject\"\n    print(py_key, py_dict[py_key])\n```\n\n----------------------------------------\n\nTITLE: Implementing Writable Variadic Pack Printing in Mojo\nDESCRIPTION: Demonstrates how to forward a WritableVariadicPack to a writer for efficient message printing. The example shows printing multiple values with a single syscall to stdout.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog.md#2025-04-17_snippet_0\n\nLANGUAGE: mojo\nCODE:\n```\nfrom utils.write import WritableVariadicPack\n\nfn print_message[*Ts: Writable](*messages: *Ts):\n    print(\"message:\", WritableVariadicPack(messages), \"[end]\")\n\nx = 42\nprint_message(\"'x = \", x, \"'\")\n```\n\nLANGUAGE: text\nCODE:\n```\nmessage: 'x = 42' [end]\n```\n\n----------------------------------------\n\nTITLE: Pointer Arithmetic with UnsafePointer in Mojo\nDESCRIPTION: Shows how to perform pointer arithmetic to access different elements in a contiguous block of memory. This creates a new pointer that points to an offset from the original pointer.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/pointers/unsafe-pointers.mdx#2025-04-17_snippet_15\n\nLANGUAGE: mojo\nCODE:\n```\nthird_ptr = first_ptr + 2\n```\n\n----------------------------------------\n\nTITLE: Dereferencing a pointer in Mojo\nDESCRIPTION: This code demonstrates how to dereference a pointer to update and access the pointee value. The empty square brackets syntax is used to access the value that the pointer points to.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/pointers/index.mdx#2025-04-17_snippet_1\n\nLANGUAGE: mojo\nCODE:\n```\n# Update an initialized value\nptr[] += 10\n# Access an initialized value\nprint(ptr[])\n```\n\n----------------------------------------\n\nTITLE: Defining Structs and Using Type References in Mojo\nDESCRIPTION: Illustrates the syntax for declaring structs with typed members and referencing custom types in function parameters. It also shows how to omit types for object parameters.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_237\n\nLANGUAGE: mojo\nCODE:\n```\nstruct Foo:\n    var member: index\n\ndef bar(x: Foo, obj) -> index:\n    return x.member\n```\n\n----------------------------------------\n\nTITLE: Creating Row-Major and Column-Major Layouts in Mojo\nDESCRIPTION: Demonstrates how to create row-major and column-major layouts using the Layout class's static methods row_major() and col_major(). The example creates 4x4x4 layouts and prints them.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/layout/layouts.mdx#2025-04-17_snippet_4\n\nLANGUAGE: mojo\nCODE:\n```\nprint(Layout.row_major(4, 4, 4))\nprint(Layout.col_major(4, 4, 4))\n```\n\nLANGUAGE: plaintext\nCODE:\n```\n((4, 4, 4):(16, 4, 1))\n((4, 4, 4):(1, 4, 16))\n```\n\n----------------------------------------\n\nTITLE: Deprecated Decorator in Mojo\nDESCRIPTION: Example of Mojo's new @deprecated decorator, which marks declarations as deprecated and triggers warnings when referenced. This helps manage API lifecycle and encourages migration to newer APIs.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_73\n\nLANGUAGE: mojo\nCODE:\n```\n@deprecated(\"Foo is deprecated, use Bar instead\")\nstruct Foo:\n    pass\n\nfn outdated_api(x: Foo): # warning: Foo is deprecated, use Bar instead\n    pass\n\n@deprecated(\"use another function!\")\nfn bar():\n    pass\n\nfn techdebt():\n    bar() # warning: use another function!\n```\n\n----------------------------------------\n\nTITLE: Warp-based Parallel Reduction in Mojo\nDESCRIPTION: Demonstrates warp-level parallel reduction where multiple threads within a block cooperate to sum values. Uses SIMT (Single Instruction Multiple Threads) execution model with warp synchronization.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/gpu/basics.mdx#2025-04-17_snippet_14\n\nLANGUAGE: mojo\nCODE:\n```\nfn warp_reduce_kernel(\n    in_tensor: InputLayoutTensor, out_tensor: OutputLayoutTensor\n):\n    var value = in_tensor.load[1](block_idx.x, thread_idx.x)\n\n    # Each thread gets the value from one thread higher, summing them as they go\n    value = warp.sum(value)\n\n    # Print each reduction step in the first block\n    if block_idx.x == 0:\n        print(\"thread:\", thread_idx.x, \"value:\", value)\n\n    # Thread 0 has the reduced sum of the values from all the other threads\n    if thread_idx.x == 0:\n        out_tensor[block_idx.x] = value\n\nctx.enqueue_function[warp_reduce_kernel](\n    in_tensor,\n    out_tensor,\n    grid_dim=blocks,\n    block_dim=threads,\n)\nctx.synchronize()\n\n# Ensure we have the same result\ndevice_output_buffer.enqueue_copy_to(host_output_buffer)\nctx.synchronize()\n\nprint(host_output_buffer)\n```\n\n----------------------------------------\n\nTITLE: Declaring Dynamic Function in Mojo using def\nDESCRIPTION: Example of declaring a function using 'def' keyword in Mojo, which follows Python-style dynamic typing without requiring explicit type declarations for arguments or return values.\nSOURCE: https://github.com/modular/max/blob/main/examples/gui/ragdata/mojo_functions.txt#2025-04-17_snippet_0\n\nLANGUAGE: mojo\nCODE:\n```\ndef greet(name):\n    return \"Hello, \" + name + \"!\"\n```\n\n----------------------------------------\n\nTITLE: MutablePointer Implementation with Lifetime Support\nDESCRIPTION: Complete implementation of a MutablePointer type showing lifetime parameterization, initialization, and memory management.\nSOURCE: https://github.com/modular/max/blob/main/mojo/proposals/lifetimes-and-provenance.md#2025-04-17_snippet_10\n\nLANGUAGE: mojo\nCODE:\n```\n    @value\n    @register_passable(\"trivial\")\n    struct MutablePointer[type: AnyType, life: Lifetime]:\n        alias pointer_type = __mlir_type[...]\n        var address: pointer_type\n\n           fn __init__(inout self): ...\n        fn __init__(inout self, address: pointer_type): ...\n\n        # Should this be an __init__ to allow implicit conversions?\n        @static_method\n        fn address_of(arg: mutref[life] type) -> Self:\n            ...\n\n        fn __getitem__(self, offset: Int) -> inout[life] type:\n               ...\n\n        @staticmethod\n        fn alloc(count: Int) -> Self: ...\n        fn free(self): ...\n\n    fn exercise_pointer():\n        # Allocated untracked data with static/immortal lifetime.\n        let ptr = MutablePointer[Int, __static_lifetime].alloc(42)\n\n        # Use extended getitem through reference to support setter.\n        ptr[4] = 7\n\n        var localInt = 19\n        let ptr2 = MutablePointer.address_of(localInt)\n        ptr2[0] += 1  # increment localInt\n\n        # ERROR: Cannot mutate localInt while ptr2 lifetime is live\n        localInt += 1\n        use(ptr2)\n```\n\n----------------------------------------\n\nTITLE: Optimized Variadic Print Function in Mojo\nDESCRIPTION: Optimization for handling single arguments in variadic functions by separating the first argument.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/functions.mdx#2025-04-17_snippet_15\n\nLANGUAGE: mojo\nCODE:\n```\nfn print_string(s: String):\n    print(s, end=\"\")\n\nfn print_many[T: Stringable, *Ts: Stringable](first: T, *rest: *Ts):\n    print_string(String(first))\n\n    @parameter\n    fn print_elt[T: Stringable](a: T):\n        print_string(\" \")\n        print_string(String(a))\n    rest.each[print_elt]()\nprint_many(\"Bob\")\n```\n\n----------------------------------------\n\nTITLE: Defining DType Aliases in Mojo\nDESCRIPTION: Shows how scalar types like Int8 and Float32 are defined as aliases for SIMD vectors with a single element, using the DType struct.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/types.mdx#2025-04-17_snippet_4\n\nLANGUAGE: mojo\nCODE:\n```\nalias Scalar = SIMD[size=1]\nalias Int8 = Scalar[DType.int8]\nalias Float32 = Scalar[DType.float32]\n```\n\n----------------------------------------\n\nTITLE: Using a Custom Struct in Mojo\nDESCRIPTION: Shows how to instantiate and use a custom struct object.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/basics.mdx#2025-04-17_snippet_15\n\nLANGUAGE: mojo\nCODE:\n```\ndef use_mypair():\n    var mine = MyPair(2, 4)\n    mine.dump()\n```\n\n----------------------------------------\n\nTITLE: Using Stringable Arguments in debug_assert\nDESCRIPTION: Example demonstrating how `debug_assert` can now accept `Stringable` arguments to format error messages, with no runtime penalty when assertions are disabled, avoiding the overhead of explicit string formatting.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_34\n\nLANGUAGE: mojo\nCODE:\n```\ndebug_assert(x > 0, \"expected x to be more than 0 but got: \", x)\n```\n\n----------------------------------------\n\nTITLE: Defining Associated Alias in Trait\nDESCRIPTION: Demonstrates how to define a basic associated alias in a trait that must be implemented by conforming structs.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/traits.mdx#2025-04-17_snippet_10\n\nLANGUAGE: mojo\nCODE:\n```\ntrait Repeater:\n    alias count: Int\n```\n\n----------------------------------------\n\nTITLE: Performing Elementwise SIMD Operations in Mojo\nDESCRIPTION: Demonstrates elementwise multiplication of two SIMD vectors of int8 values. The result is a new SIMD vector with the products of corresponding elements.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/types.mdx#2025-04-17_snippet_3\n\nLANGUAGE: mojo\nCODE:\n```\nvar vec1 = SIMD[DType.int8, 4](2, 3, 5, 7)\nvar vec2 = SIMD[DType.int8, 4](1, 2, 3, 4)\nvar product = vec1 * vec2\nprint(product)\n```\n\n----------------------------------------\n\nTITLE: Complete GPU Reduction Exercise Solution in Mojo\nDESCRIPTION: Complete implementation of a parallel reduction exercise that processes 32 float values across 8 blocks with 4 threads each. Includes buffer initialization, tensor creation, kernel execution, and result verification.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/gpu/basics.mdx#2025-04-17_snippet_15\n\nLANGUAGE: mojo\nCODE:\n```\nalias dtype_f32 = DType.float32\nalias elements_f32 = 32\nalias blocks_f32 = 8\nalias threads_f32 = elements_f32 // blocks_f32\n\n# Create buffers\nvar in_buffer_host = ctx.enqueue_create_host_buffer[dtype_f32](elements_f32)\nvar in_buffer_device = ctx.enqueue_create_buffer[dtype_f32](elements_f32)\nvar out_buffer_host = ctx.enqueue_create_host_buffer[dtype_f32](blocks_f32)\nvar out_buffer_device = ctx.enqueue_create_buffer[dtype_f32](blocks_f32)\n\n# Zero output buffer values\nctx.enqueue_memset(out_buffer_device, 0)\nctx.synchronize()\n\n# Fill in input values sequentially and copy to device\niota(in_buffer_host.unsafe_ptr(), elements_f32)\nin_buffer_host.enqueue_copy_to(in_buffer_device)\n\n# Create the LayoutTensors\nalias LayoutF32 = Layout.row_major(blocks_f32, threads_f32)\nalias InputTensorF32 = LayoutTensor[dtype_f32, LayoutF32, MutableAnyOrigin]\nvar float_in_tensor = InputTensorF32(in_buffer_device)\n\nalias OutputLayoutF32 = Layout.row_major(blocks_f32)\nalias OutputTensorF32 = LayoutTensor[dtype_f32, OutputLayoutF32, MutableAnyOrigin]\nvar float_out_tensor = OutputTensorF32(out_buffer_device)\n\nfn reduce_sum_f32(in_tensor: InputTensorF32, output_buffer: OutputTensorF32):\n    var value = in_tensor.load[1](block_idx.x, thread_idx.x)\n    value = warp.sum(value)\n    if thread_idx.x == 0:\n        output_buffer[block_idx.x] = value\n\nctx.enqueue_function[reduce_sum_f32](\n    float_in_tensor,\n    float_out_tensor,\n    grid_dim=8,\n    block_dim=4\n)\n\nout_buffer_device.enqueue_copy_to(out_buffer_host)\n\nctx.synchronize()\n\nprint(out_buffer_host)\n```\n\n----------------------------------------\n\nTITLE: Defining a function with variadic keyword arguments in Mojo\nDESCRIPTION: Illustrates the new support for specifying variadic keyword arguments without a type expression in 'def' functions. This syntax is now valid and no longer causes a crash.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_66\n\nLANGUAGE: mojo\nCODE:\n```\ndef foo(**kwargs): ...\n```\n\n----------------------------------------\n\nTITLE: Initializing SIMD Vector in Mojo\nDESCRIPTION: Creates a SIMD vector of four Float32 values. SIMD (single instruction, multiple data) is used for high-performance numeric processing in Mojo.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/types.mdx#2025-04-17_snippet_2\n\nLANGUAGE: mojo\nCODE:\n```\nvar vec = SIMD[DType.float32, 4](3.0, 2.0, 2.0, 1.0)\n```\n\n----------------------------------------\n\nTITLE: Using MLIR Operations in Mojo for Custom Int Type Implementation\nDESCRIPTION: Example of accessing MLIR operations in Mojo to implement custom types, shown here creating an Int type with addition operation.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_231\n\nLANGUAGE: mojo\nCODE:\n```\nstruct Int:\n    var value: __mlir_type.index\n\n    fn __add__(self, rhs: Int) -> Int:\n        return __mlir_op.`index.add`(self.value, rhs.value)\n```\n\n----------------------------------------\n\nTITLE: Short-circuit OR Evaluation in Mojo\nDESCRIPTION: Demonstrates short-circuit evaluation with the OR operator where the second operand is not evaluated if the first is True.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/control-flow.mdx#2025-04-17_snippet_3\n\nLANGUAGE: mojo\nCODE:\n```\ndef true_func() -> Bool:\n    print(\"Executing true_func\")\n    return True\n\ndef false_func() -> Bool:\n    print(\"Executing false_func\")\n    return False\n\nprint('Short-circuit \"or\" evaluation')\nif true_func() or false_func():\n    print(\"True result\")\n```\n\n----------------------------------------\n\nTITLE: Using Keyword Parameters in Functions with Mojo\nDESCRIPTION: Example of using compile-time keyword parameters in Mojo functions. This shows how to define functions with keyword parameters and default values, and how to call them with different parameter orders.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_155\n\nLANGUAGE: mojo\nCODE:\n```\nfn foo[a: Int, b: Int = 42]():\n    print(a, \"+\", b)\n\nfoo[a=5]()        # prints '5 + 42'\nfoo[a=7, b=13]()  # prints '7 + 13'\nfoo[b=20, a=6]()  # prints '6 + 20'\n```\n\n----------------------------------------\n\nTITLE: Converting SIMD Types in Mojo\nDESCRIPTION: Demonstrates explicit conversion between different SIMD types using the cast() method and SIMD constructor. Shows how to perform operations on SIMD values of different types.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/types.mdx#2025-04-17_snippet_6\n\nLANGUAGE: mojo\nCODE:\n```\nsimd1 = SIMD[DType.float32, 4](2.2, 3.3, 4.4, 5.5)\nsimd2 = SIMD[DType.int16, 4](-1, 2, -3, 4)\nsimd3 = simd1 * simd2.cast[DType.float32]()  # Convert with cast() method\nprint(\"simd3:\", simd3)\nsimd4 = simd2 + SIMD[DType.int16, 4](simd1)  # Convert with SIMD constructor\nprint(\"simd4:\", simd4)\n```\n\n----------------------------------------\n\nTITLE: Creating a Complex Tiled Layout Using Layout Constructor in Mojo\nDESCRIPTION: Shows how to create a complex 6x10 tile-major layout using the Layout constructor with explicit shape and stride tuples. The resulting layout is then printed using a custom print_layout function.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/layout/layouts.mdx#2025-04-17_snippet_5\n\nLANGUAGE: mojo\nCODE:\n```\nvar tiled_layout = Layout(\n    IntTuple(IntTuple(3, 2), IntTuple(2, 5)), # shape\n    IntTuple(IntTuple(1, 6), IntTuple(3, 12)) # strides\n)\nprint_layout(tiled_layout)\n```\n\nLANGUAGE: plaintext\nCODE:\n```\n(((3, 2), (2, 5)):((1, 6), (3, 12)))\n       0    1    2    3    4    5    6    7    8    9\n    +----+----+----+----+----+----+----+----+----+----+\n 0  |  0 |  3 | 12 | 15 | 24 | 27 | 36 | 39 | 48 | 51 |\n    +----+----+----+----+----+----+----+----+----+----+\n 1  |  1 |  4 | 13 | 16 | 25 | 28 | 37 | 40 | 49 | 52 |\n    +----+----+----+----+----+----+----+----+----+----+\n 2  |  2 |  5 | 14 | 17 | 26 | 29 | 38 | 41 | 50 | 53 |\n    +----+----+----+----+----+----+----+----+----+----+\n 3  |  6 |  9 | 18 | 21 | 30 | 33 | 42 | 45 | 54 | 57 |\n    +----+----+----+----+----+----+----+----+----+----+\n 4  |  7 | 10 | 19 | 22 | 31 | 34 | 43 | 46 | 55 | 58 |\n    +----+----+----+----+----+----+----+----+----+----+\n 5  |  8 | 11 | 20 | 23 | 32 | 35 | 44 | 47 | 56 | 59 |\n    +----+----+----+----+----+----+----+----+----+----+\n```\n\n----------------------------------------\n\nTITLE: Using String.format() with Conversion Flags\nDESCRIPTION: Demonstrates how to use String.format() with the conversion flags !s and !r for str() and repr() conversions within format strings.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_56\n\nLANGUAGE: mojo\nCODE:\n```\nString(\"{} {!r}\").format(\"Mojo\", \"Mojo\")\n# \"Mojo 'Mojo'\"\n\nString(\"{0!s} {0!r}\").format(\"Mojo\")\n# \"Mojo 'Mojo'\"\n```\n\n----------------------------------------\n\nTITLE: Single Thread SIMD Reduction in Mojo\nDESCRIPTION: Implements a reduction operation using one thread per block, where each thread loads and sums 4 sequential values using SIMD operations. This approach eliminates the need for shared memory synchronization.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/gpu/basics.mdx#2025-04-17_snippet_13\n\nLANGUAGE: mojo\nCODE:\n```\nfn simd_reduce_kernel(\n    in_tensor: InputLayoutTensor, out_tensor: OutputLayoutTensor\n):\n    # The [4] means it loads 4 sequential values before doing the `reduce_add`\n    out_tensor[block_idx.x] = in_tensor.load[4](block_idx.x, 0).reduce_add()\n\nctx.enqueue_function[simd_reduce_kernel](\n    in_tensor,\n    out_tensor,\n    grid_dim=blocks,\n    block_dim=1, # one thread per block\n)\n\n# Ensure we have the same result\ndevice_output_buffer.enqueue_copy_to(host_output_buffer)\nctx.synchronize()\n\nprint(host_output_buffer)\n```\n\n----------------------------------------\n\nTITLE: Using Direct Indexing with Tuple in Mojo\nDESCRIPTION: Example of using the new direct indexing functionality with Tuple, allowing simple access and assignment to tuple elements using square bracket notation, similar to Python.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_92\n\nLANGUAGE: mojo\nCODE:\n```\nvar tuple = (\"Green\", 9.3)\nvar name = tuple[0]\nvar value = tuple[1]\n```\n\n----------------------------------------\n\nTITLE: Creating a Typed List in Mojo\nDESCRIPTION: Demonstrates how to create a typed List in Mojo, which can store any type conforming to the CollectionElement trait.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/basics.mdx#2025-04-17_snippet_20\n\nLANGUAGE: mojo\nCODE:\n```\nmy_list = List[Float64]()\n```\n\n----------------------------------------\n\nTITLE: Multiple File Operations with Context Managers in Mojo\nDESCRIPTION: Example of using multiple context managers to read from one file and write to another, with automatic resource management.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/errors.mdx#2025-04-17_snippet_8\n\nLANGUAGE: mojo\nCODE:\n```\nwith open(input_file, \"r\") as f_in, open(output_file, \"w\") as f_out:\n    input_text = f_in.read()\n    output_text = input_text.upper()\n    f_out.write(output_text)\n```\n\n----------------------------------------\n\nTITLE: Custom Copy Constructor Implementation in Mojo\nDESCRIPTION: Shows how to implement an explicit copy constructor for a custom struct type to handle deep copying of objects.\nSOURCE: https://github.com/modular/max/blob/main/mojo/stdlib/docs/style-guide.md#2025-04-17_snippet_8\n\nLANGUAGE: mojo\nCODE:\n```\nstruct MyStruct:\n    # Invoked as `MyStruct(other)`\n    fn __init__(out self, other: Self):\n        # do a deep copy of MyStruct\n```\n\n----------------------------------------\n\nTITLE: Converting Mojo Types to Python Objects\nDESCRIPTION: Demonstrates how Mojo primitive types implicitly convert into Python objects by creating an in-memory Python module with a function that prints the type of a given value.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/python/types.mdx#2025-04-17_snippet_0\n\nLANGUAGE: mojo\nCODE:\n```\nfrom python import Python\n\ndef main():\n    py_module = \"\"\"\ndef type_printer(value):\n    print(type(value))\n\"\"\"\n    py_utils = Python.evaluate(py_module, file=True, name=\"py_utils\")\n\n    py_utils.type_printer(4)\n    py_utils.type_printer(3.14)\n    py_utils.type_printer((\"Mojo\", True))\n```\n\n----------------------------------------\n\nTITLE: Allocating and Initializing an UnsafePointer in Mojo\nDESCRIPTION: Demonstrates how to allocate memory for an Int value using UnsafePointer and initialize it with a value. This is the basic pattern for dynamic memory allocation in Mojo.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/pointers/unsafe-pointers.mdx#2025-04-17_snippet_0\n\nLANGUAGE: mojo\nCODE:\n```\nfrom memory import UnsafePointer\n\n# Allocate memory to hold a value\nvar ptr = UnsafePointer[Int].alloc(1)\n# Initialize the allocated memory\nptr.init_pointee_copy(100)\n```\n\n----------------------------------------\n\nTITLE: Using Lazy Initialization with Let Declarations in Mojo\nDESCRIPTION: Example showing lazy initialization of 'let' declarations in Mojo functions, allowing for more flexible initialization patterns with conditional logic.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_200\n\nLANGUAGE: mojo\nCODE:\n```\nlet x: Int\nif cond:\n    x = foo()\nelse:\n    x = bar()\nuse(x)\n```\n\n----------------------------------------\n\nTITLE: Creating Static Methods and Initializers in Mojo Structs\nDESCRIPTION: Example showing how to implement static methods and initializers in Mojo structs using __new__ for object creation and @staticmethod for static functionality.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_234\n\nLANGUAGE: mojo\nCODE:\n```\nstruct Foo:\n    var value: index\n\n    def __new__() -> Foo:\n        var result: Foo\n        result.value = Foo.return_a_number() # static method!\n        return result\n\n    @staticmethod\n    def return_a_number() -> index:\n        return 42\n```\n\n----------------------------------------\n\nTITLE: Working with FloatLiteral for Infinite-Precision in Mojo\nDESCRIPTION: Example showing how FloatLiteral provides infinite-precision for compile-time calculations without rounding errors, and converts to Float64 at runtime.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_106\n\nLANGUAGE: mojo\nCODE:\n```\n# third is an infinite-precision FloatLiteral value\nalias third = 1.0 / 3.0\n# t is a Float64\nvar t = third\n```\n\n----------------------------------------\n\nTITLE: Using For Loops with Range in Mojo\nDESCRIPTION: Shows how to use for loops with types that implement the `__iter__`, `__next__`, and `__len__` methods, using the range function as an example.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_219\n\nLANGUAGE: mojo\nCODE:\n```\nfor item in range(start, end, step):\n    print(item)\n```\n\n----------------------------------------\n\nTITLE: Overload Resolution with Requirements in Mojo\nDESCRIPTION: This snippet demonstrates how requirements can affect overload resolution in Mojo. It shows two function overloads with different return types and requirements, illustrating the need for parser-time resolution of these requirements.\nSOURCE: https://github.com/modular/max/blob/main/mojo/proposals/requires-clause.md#2025-04-17_snippet_10\n\nLANGUAGE: mojo\nCODE:\n```\nfn your_function(a: SIMD[F32, _]) -> Int requires a.size.is_prime(): ...\nfn your_function(a: SIMD[F32, _]) -> F32: ...\n```\n\n----------------------------------------\n\nTITLE: Using Named Results with out Convention\nDESCRIPTION: Example showing the new syntax for named results using `out` parameters instead of the older `-> T as name` syntax, where the return value is specified with an output parameter that typically appears at the end of the argument list.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_26\n\nLANGUAGE: mojo\nCODE:\n```\n# This function has type \"fn() -> String\"\nfn example(out result: String):\n  result = \"foo\"\n```\n\n----------------------------------------\n\nTITLE: While Loop with Break Bypassing Else Clause in Mojo\nDESCRIPTION: Shows how a break statement prevents the else clause from executing in a while loop.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/control-flow.mdx#2025-04-17_snippet_11\n\nLANGUAGE: mojo\nCODE:\n```\nn = 0\nwhile n < 5:\n    n += 1\n    if n == 3:\n        break\n    print(n)\nelse:\n    print(\"Executing else clause\")\n```\n\n----------------------------------------\n\nTITLE: Working with Trait Hierarchies in Mojo\nDESCRIPTION: Demonstrates how to work with trait hierarchies, including upcasting from a child trait to a parent trait in generic functions.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_144\n\nLANGUAGE: mojo\nCODE:\n```\nfn the_parents[T: Parent](x: T):\n    x.parent_func()\n\nfn the_children[T: Child](x: T):\n    x.child_func()\n    x.parent_func()\n    # Upcast `x` from instance of `Child` to `Parent`.\n    the_parents(x)\n```\n\n----------------------------------------\n\nTITLE: Converting Values to Strings in Mojo\nDESCRIPTION: Shows how to convert different types to strings using the String constructor and the String.write method, which supports variadic Stringable types.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/types.mdx#2025-04-17_snippet_9\n\nLANGUAGE: mojo\nCODE:\n```\nvar s = String(\"Items in list: \") + String(5)\nprint(s)\n\nvar s = String(\"Items in list: \", 5)\nprint(s)\n```\n\n----------------------------------------\n\nTITLE: SIMD Vector Operations with Strided Load/Store\nDESCRIPTION: Implementation of red channel inversion in an RGB image using SIMD strided operations.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/pointers/unsafe-pointers.mdx#2025-04-17_snippet_21\n\nLANGUAGE: mojo\nCODE:\n```\ndef invert_red_channel(ptr: UnsafePointer[UInt8], pixel_count: Int):\n    # number of values loaded or stored at a time\n    alias simd_width = 8\n    # bytes per pixel, which is also the stride size\n    bpp = 3\n    for i in range(0, pixel_count * bpp, simd_width * bpp):\n        red_values = ptr.offset(i).strided_load[width=simd_width](bpp)\n        # Invert values and store them in their original locations\n        ptr.offset(i).strided_store[width=simd_width](~red_values, bpp)\n```\n\n----------------------------------------\n\nTITLE: Generic Stack Trait Definition\nDESCRIPTION: Defines a generic stack trait using associated alias to specify the element type and declaring generic methods.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/traits.mdx#2025-04-17_snippet_13\n\nLANGUAGE: mojo\nCODE:\n```\ntrait Stacklike:\n    alias EltType: CollectionElement\n\n    def push(mut self, owned item: Self.EltType):\n        pass\n\n    def pop(mut self) -> Self.EltType:\n        pass\n```\n\n----------------------------------------\n\nTITLE: Using Named Results for Non-Movable Objects in Mojo\nDESCRIPTION: This function demonstrates the use of a named result (out argument) to return a NameTag object that may not be movable or copyable.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/functions.mdx#2025-04-17_snippet_22\n\nLANGUAGE: mojo\nCODE:\n```\ndef get_name_tag(owned name: String, out name_tag: NameTag):\n    name_tag = NameTag(name^)\n```\n\n----------------------------------------\n\nTITLE: Implementing Trait Inheritance in Mojo\nDESCRIPTION: Shows how to define traits that inherit from other traits, requiring implementers to conform to all parent traits.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_143\n\nLANGUAGE: mojo\nCODE:\n```\ntrait Parent:\n    fn parent_func(self): ...\n\ntrait Child(Parent):\n    fn child_func(self): ...\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Current Mojo Syntax Conventions\nDESCRIPTION: This code snippet illustrates the current syntax conventions in Mojo for defining a struct with various method signatures, including constructors, operators, and destructors. It showcases the use of 'inout', 'borrowed', and 'owned' keywords.\nSOURCE: https://github.com/modular/max/blob/main/mojo/proposals/ref-convention.md#2025-04-17_snippet_10\n\nLANGUAGE: mojo\nCODE:\n```\n## Today in mojo:\nstruct MyInt:\n   # Note that inout is a lie here, the input is uninitialized.\n   fn __init__(inout self, value: Int): ...\n\n   # borrowed is the default (e.g. on 'rhs') so not usually written.\n   fn __add__(borrowed self, rhs: MyInt) -> MyInt: ...\n\n   # This function actually just takes a mutable reference, the\n   # caller may do some copy in/out depending on its situation though.\n   fn __iadd__(inout self, rhs: MyInt): ...\n\n   # An owned argument must be initialized when the function is called,\n   # and it will be deinitialized by the time the function returns.\n   # (Unless the caller provides a copy.)\n   fn __del__(owned self): ...\n```\n\n----------------------------------------\n\nTITLE: Implementing Intable Trait for Custom Type in Mojo\nDESCRIPTION: Shows how to implement the Intable trait for a custom type, allowing it to be implicitly converted to an Int.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/traits.mdx#2025-04-17_snippet_7\n\nLANGUAGE: mojo\nCODE:\n```\n@value\nstruct Foo(Intable):\n    var i: Int\n\n    fn __int__(self) -> Int:\n        return self.i\n\nvar foo = Foo(42)\nprint(Int(foo) == 42)\n```\n\n----------------------------------------\n\nTITLE: Demonstrating value lifetime in Mojo\nDESCRIPTION: This code snippet illustrates the concept of a value's lifetime in Mojo, showing how a string variable can be alive, not alive, and destroyed at different points in the code.\nSOURCE: https://github.com/modular/max/blob/main/mojo/proposals/resyntaxing-arg-conventions-and-refs.md#2025-04-17_snippet_1\n\nLANGUAGE: mojo\nCODE:\n```\n    var s : String\n    # Not alive here.\n    s = \"hello\"\n    # alive here\n    use(s)\n    # destroyed here.\n    unrelated_stuff()\n    # ...\n    s = \"goodbye\"\n    # alive here\n    use(s)\n    # destroyed here\n```\n\n----------------------------------------\n\nTITLE: Using Variadic Parameters and Arguments in Mojo\nDESCRIPTION: Shows how to use homogeneous variadics in both value argument lists and parameter lists, allowing functions to accept a variable number of arguments.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_221\n\nLANGUAGE: mojo\nCODE:\n```\nfn variadic_params_and_args[*a: Int](*b: Int):\n    print(a[0])\n    print(b[1])\n```\n\n----------------------------------------\n\nTITLE: Moving Values to UnsafePointer Memory in Mojo\nDESCRIPTION: Demonstrates how to move a value into memory pointed to by an UnsafePointer. This transfers ownership of the value to the pointer's memory location using the transfer sigil (^).\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/pointers/unsafe-pointers.mdx#2025-04-17_snippet_10\n\nLANGUAGE: mojo\nCODE:\n```\nstr_ptr.init_pointee_move(my_string^)\n```\n\n----------------------------------------\n\nTITLE: Using Context Managers for File Handling in Mojo\nDESCRIPTION: This example shows how to use context managers with the 'with' statement for file handling in Mojo. This approach automatically handles file closure when the block is exited.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_168\n\nLANGUAGE: mojo\nCODE:\n```\nwith open(\"my_file.txt\", \"r\") as f:\n    print(f.read())\n```\n\n----------------------------------------\n\nTITLE: Parameter Inference with Keyword Arguments in Mojo\nDESCRIPTION: Shows how type parameters can be inferred from keyword arguments in Mojo functions. This enables more flexible function overloading based on parameter types.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_176\n\nLANGUAGE: mojo\nCODE:\n```\nfn bar[A: AnyType, B: AnyType](a: A, b: B):\n    print(\"Hello 🔥\")\n\nfn bar[B: AnyType](a: StringLiteral, b: B):\n    print(a)\n\nfn main():\n    bar(1, 2)  # prints `Hello 🔥`\n    bar(b=2, a=\"Yay!\")  # prints `Yay!`\n```\n\n----------------------------------------\n\nTITLE: Creating Tuples with Implicit Typing in Mojo\nDESCRIPTION: Demonstrates how to create a tuple without explicit typing in Mojo, and how to access its elements.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/types.mdx#2025-04-17_snippet_12\n\nLANGUAGE: mojo\nCODE:\n```\nexample_tuple = (1, String(\"Example\"))\ns = example_tuple[1]\nprint(s)\n```\n\n----------------------------------------\n\nTITLE: Printing Values from GPU Tensor in Mojo\nDESCRIPTION: This kernel demonstrates how to access and print values from a GPU tensor using block and thread indices, showing the mapping of data to threads and blocks.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/gpu/basics.mdx#2025-04-17_snippet_10\n\nLANGUAGE: mojo\nCODE:\n```\nfn print_values_kernel(in_tensor: InputLayoutTensor):\n    var bid = block_idx.x\n    var tid = thread_idx.x\n    print(\"block:\", bid, \"thread:\", tid, \"val:\", in_tensor[bid, tid])\n\nctx.enqueue_function[print_values_kernel](\n    in_tensor, grid_dim=blocks, block_dim=threads,\n)\nctx.synchronize()\n```\n\n----------------------------------------\n\nTITLE: Using the @value Decorator in Mojo\nDESCRIPTION: Example of using the @value decorator in Mojo to automatically generate memberwise initializers, copy constructors, and move constructors for a struct, reducing boilerplate code.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_198\n\nLANGUAGE: mojo\nCODE:\n```\n@value\nstruct MyPet:\n  var name: String\n  var age: Int\n```\n\n----------------------------------------\n\nTITLE: Using Keyword Arguments with Print Function in Mojo\nDESCRIPTION: Example demonstrating the new keyword arguments 'sep' and 'end' for the print() function to customize output formatting.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_105\n\nLANGUAGE: mojo\nCODE:\n```\nprint(\"Hello\", \"Mojo\", sep=\", \", end=\"!!!\\n\") # prints Hello, Mojo!!!\n```\n\n----------------------------------------\n\nTITLE: While Loop with Break Statement in Mojo\nDESCRIPTION: Shows how to terminate a while loop early using the break statement when a condition is met.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/control-flow.mdx#2025-04-17_snippet_9\n\nLANGUAGE: mojo\nCODE:\n```\nn = 0\nwhile n < 5:\n    n += 1\n    if n == 3:\n        break\n    print(n, end=\", \")\n```\n\n----------------------------------------\n\nTITLE: Using Parametric Values in Parameter Contexts in Mojo\nDESCRIPTION: This example shows how input parameters on values can be accessed in parameter contexts in Mojo. It demonstrates defining an alias based on a parametric value and using it in a function call.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_171\n\nLANGUAGE: mojo\nCODE:\n```\nfn foo[value: Int]():\n    print(value)\n\nlet y = Thing[12]()\nalias constant = y.param + 4\nfoo[constant]() # prints '16'\n```\n\n----------------------------------------\n\nTITLE: Using Let Declarations in Mojo Functions\nDESCRIPTION: Demonstrates the new support for 'let' declarations in functions, which are local run-time constant values and always rvalues.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_227\n\nLANGUAGE: mojo\nCODE:\n```\nfn example():\n    let constant_value = 42\n    # Use constant_value...\n```\n\n----------------------------------------\n\nTITLE: Migrating from @adaptive decorator to @parameter if in Mojo\nDESCRIPTION: Demonstrates how to replace the now-removed @adaptive decorator with the @parameter if construct for conditional parameter-time code execution. This example shows how conditional parameter-time logic can be rewritten in the new syntax.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_136\n\nLANGUAGE: mojo\nCODE:\n```\n@adaptive\nfn foo[a: Bool]():\n    constrained[a]()\n    body1()\n\n@adaptive\nfn foo[a: Bool]():\n    constrained[not a]()\n    body2()\n```\n\nLANGUAGE: mojo\nCODE:\n```\nfn foo[a: Bool]():\n    @parameter\n    if a:\n        body1()\n    else:\n        body2()\n```\n\n----------------------------------------\n\nTITLE: Comparing Def and Fn Function Arguments in Mojo\nDESCRIPTION: Illustrates the equivalence between def and fn function declarations, showing how they handle arguments differently but achieve the same behavior.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/values/ownership.mdx#2025-04-17_snippet_9\n\nLANGUAGE: mojo\nCODE:\n```\ndef def_example(a: Int, mut b: Int, owned c):\n    pass\n\nfn fn_example(a_in: Int, mut b: Int, owned c: object):\n    var a = a_in\n    pass\n```\n\n----------------------------------------\n\nTITLE: Implementing Parameterized Hash Function in Mojo\nDESCRIPTION: Defines a hash function parameterized with the Hasher type, allowing users to control the hashing algorithm used for any Hashable type.\nSOURCE: https://github.com/modular/max/blob/main/mojo/proposals/improved-hash-module.md#2025-04-17_snippet_6\n\nLANGUAGE: mojo\nCODE:\n```\nfn hash[T: Hashable, H: Hasher = DefaultHasher](value: T) -> UInt64:\n    var hasher = hasher_type()\n    hasher.update(value)\n    return hasher^._finish()\n```\n\n----------------------------------------\n\nTITLE: Implementing Copy Constructor in Mojo\nDESCRIPTION: Example of implementing a copy constructor (__copyinit__) for non-@register_passable types, showing how to copy member values from an existing instance.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_204\n\nLANGUAGE: mojo\nCODE:\n```\nfn __copyinit__(inout self, existing: Self):\n    self.first = existing.first\n    self.second = existing.second\n```\n\n----------------------------------------\n\nTITLE: Explicit Type Declaration for Dependent Type Function Call in Mojo\nDESCRIPTION: This code demonstrates explicit type declaration when calling a dependent type function in Mojo. It shows how the compiler can infer and simplify the return type based on input values.\nSOURCE: https://github.com/modular/max/blob/main/mojo/stdlib/docs/internal/mlir.md#2025-04-17_snippet_2\n\nLANGUAGE: Mojo\nCODE:\n```\nvar value : T[20] = thing(someT3, someT17)\n```\n\n----------------------------------------\n\nTITLE: String Character Iteration Example - New Style\nDESCRIPTION: Shows the new recommended way of iterating over characters in a Mojo string using the char_slices() method.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_13\n\nLANGUAGE: mojo\nCODE:\n```\nvar s: String = ...\nfor c in s.char_slices():\n    # ...\n```\n\n----------------------------------------\n\nTITLE: Using Inout Variadic Arguments with Memory-Only Types\nDESCRIPTION: Shows how to use inout variadic arguments with memory-only types like String, allowing modification of the original arguments through references.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_130\n\nLANGUAGE: mojo\nCODE:\n```\nfn make_worldly(inout *strs: String):\n    # This \"just works\" as you'd expect!\n    for i in range(len(strs)):\n        strs[i] += \" world\"\nfn main():\n    var s1: String = \"hello\"\n    var s2: String = \"konnichiwa\"\n    var s3: String = \"bonjour\"\n    make_worldly(s1, s2, s3)\n    print(s1)  # hello world\n    print(s2)  # konnichiwa world\n    print(s3)  # bonjour world\n```\n\n----------------------------------------\n\nTITLE: Creating an OwnedPointer with a struct in Mojo\nDESCRIPTION: This snippet demonstrates initializing an OwnedPointer with a struct value. The OwnedPointer allocates memory and moves or copies the struct into that memory, taking ownership of the value.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/pointers/index.mdx#2025-04-17_snippet_3\n\nLANGUAGE: mojo\nCODE:\n```\no_ptr = OwnedPointer(some_big_struct)\n```\n\n----------------------------------------\n\nTITLE: Checking Compile-Time Execution in Mojo\nDESCRIPTION: Shows how to use the new sys.is_compile_time() function to determine if code is being executed at compile time or runtime.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_5\n\nLANGUAGE: mojo\nCODE:\n```\nfrom sys import is_compile_time\n\nfn check_compile_time() -> String:\n  if is_compile_time():\n      return \"compile time\"\n  else:\n      return \"runtime\"\n\ndef main():\n    alias var0 = check_compile_time()\n    var var1 = check_compile_time()\n    print(\"var0 is evaluated at \", var0, \" , while var1 is evaluated at \", var1)\n```\n\n----------------------------------------\n\nTITLE: Direct Ownership Transfer Example in Mojo\nDESCRIPTION: Shows how to transfer ownership of a newly created String value directly to a function that expects an owned argument.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/values/ownership.mdx#2025-04-17_snippet_6\n\nLANGUAGE: mojo\nCODE:\n```\ndef take(owned s: String):\n    pass\n\ntake(String(\"A brand-new String!\"))\n```\n\n----------------------------------------\n\nTITLE: Evaluating Contextual Invariants and Function Requirements in Mojo\nDESCRIPTION: This snippet demonstrates how contextual invariants and function requirements are evaluated during overload resolution in Mojo. It uses a boolean expression to determine if a candidate is valid based on these requirements.\nSOURCE: https://github.com/modular/max/blob/main/mojo/proposals/requires-clause.md#2025-04-17_snippet_6\n\nLANGUAGE: mojo\nCODE:\n```\n(contextual_invariant and function_requirement) == contextual_invariant\n```\n\n----------------------------------------\n\nTITLE: Importing from a Compiled Mojo Package\nDESCRIPTION: This snippet shows how to import a struct (MyPair) from a compiled Mojo package file (mypack.mojopkg) in the main program, demonstrating the flexibility of package imports.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/packages.md#2025-04-17_snippet_5\n\nLANGUAGE: mojo\nCODE:\n```\nfrom mypack.mymodule import MyPair\n```\n\n----------------------------------------\n\nTITLE: Using the new Set Collection Type in Mojo\nDESCRIPTION: Demonstrates the usage of the new Set type in Mojo, which is backed by a Dict. Shows creation, modification, comparison operations, and iteration over set elements.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_113\n\nLANGUAGE: mojo\nCODE:\n```\nfrom collections import Set\n\nvar set = Set[Int](1, 2, 3)\nprint(len(set))  # 3\nset.add(4)\n\nfor element in set:\n    print(element[])\n\nset -= Set[Int](3, 4, 5)\nprint(set == Set[Int](1, 2))  # True\nprint(set | Set[Int](0, 1) == Set[Int](0, 1, 2))  # True\nlet element = set.pop()\nprint(len(set))  # 1\n```\n\n----------------------------------------\n\nTITLE: While Loop with Else Clause in Mojo\nDESCRIPTION: Demonstrates using an else clause that executes when the while loop's condition becomes False.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/control-flow.mdx#2025-04-17_snippet_10\n\nLANGUAGE: mojo\nCODE:\n```\nn = 5\n\nwhile n < 4:\n    print(n)\n    n += 1\nelse:\n    print(\"Loop completed\")\n\n```\n\n----------------------------------------\n\nTITLE: Using Tuple Expressions Without Parentheses in Mojo\nDESCRIPTION: Example of tuple expressions without parentheses, allowing for Python-like syntax for operations such as value swapping.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_184\n\nLANGUAGE: mojo\nCODE:\n```\na, b = b, a  # swap values without temporary variable\n```\n\n----------------------------------------\n\nTITLE: Using sys.exit() Function in Mojo\nDESCRIPTION: Example of using the new sys.exit() function to terminate a Mojo program with a specified exit code, providing a standard way to exit programs.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_96\n\nLANGUAGE: mojo\nCODE:\n```\nfrom sys import exit\n\nexit(0)\n```\n\n----------------------------------------\n\nTITLE: Advanced Parameter Binding with Placeholders\nDESCRIPTION: Shows different ways to use placeholder syntax for unbound parameters in function declarations.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_148\n\nLANGUAGE: mojo\nCODE:\n```\n# These function declarations are roughly equivalent:\nfn eat(f: Fudge[5, _, c=_]): ...                    # implicitly parameterized\nfn eat(f: Fudge[c=_, a=5, b=_]): ...                # implicitly parameterized\nfn eat[_b: Int, _c: Int](f: Fudge[5, _b, _c]): ...  # explicitly parameterized\n```\n\n----------------------------------------\n\nTITLE: Getting a Pointer to an Existing Value in Mojo\nDESCRIPTION: Demonstrates how to get a pointer to an existing value using the address_of() static method. This is useful for getting a pointer to stack-allocated variables.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/pointers/unsafe-pointers.mdx#2025-04-17_snippet_12\n\nLANGUAGE: mojo\nCODE:\n```\nvar counter: Int = 5\nptr = UnsafePointer[Int].address_of(counter)\n```\n\n----------------------------------------\n\nTITLE: Converting from DTypePointer to UnsafePointer\nDESCRIPTION: Shows the pattern for converting from the deprecated DTypePointer type to the new UnsafePointer type, including how to handle generic function signatures.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_57\n\nLANGUAGE: mojo\nCODE:\n```\nDTypePointer[type] -> UnsafePointer[Scalar[type]]\n```\n\nLANGUAGE: mojo\nCODE:\n```\nfn f(ptr: DTypePointer):\n```\n\nLANGUAGE: mojo\nCODE:\n```\nfn f[type: DType, //](ptr: UnsafePointer[Scalar[type]]):\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Python-Mojo Interoperability in Mojo\nDESCRIPTION: This code snippet illustrates how Mojo can seamlessly interoperate with Python code. It defines a Python function using the @python decorator and calls it from a Mojo function, showcasing error handling for potential Python exceptions.\nSOURCE: https://github.com/modular/max/blob/main/mojo/proposals/mojo-and-dynamism.md#2025-04-17_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n@python\ndef python_func(a, b=[]):\n    return a + [2] + b\n\nfn mojo_func():\n    try:\n        print(python_func([3]))\n    except e:\n        print(\"error from Python:\", e)\n```\n\n----------------------------------------\n\nTITLE: Example API Signatures with Owned Convention in Mojo\nDESCRIPTION: Examples demonstrating the current owned keyword usage in method signatures and initialization methods.\nSOURCE: https://github.com/modular/max/blob/main/mojo/proposals/resyntaxing-arg-conventions-and-refs.md#2025-04-17_snippet_6\n\nLANGUAGE: mojo\nCODE:\n```\nstruct List[...]:\n   ...\n   fn append(out self, var value: T): # doesn't send a \"consuming\" signal.\n      ...\n\nstruct YourType:\n   fn __del__(var self):\n      ...\n   fn __moveinit__(out self, var existing: Self):\n      ...\n```\n\n----------------------------------------\n\nTITLE: Adding a Test Function in Mojo\nDESCRIPTION: This snippet shows how to create a test function for the newly added get_cwd_message() function. It uses assert_equal to compare the function's output with an expected value.\nSOURCE: https://github.com/modular/max/blob/main/mojo/stdlib/docs/development.md#2025-04-17_snippet_6\n\nLANGUAGE: mojo\nCODE:\n```\ndef test_get_cwd_message():\n    assert_equal(get_cwd_message(), \"Some random text\")\n```\n\n----------------------------------------\n\nTITLE: While Loop for Fibonacci Sequence in Mojo\nDESCRIPTION: Uses a while loop to generate and print Fibonacci numbers less than 50.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/control-flow.mdx#2025-04-17_snippet_7\n\nLANGUAGE: mojo\nCODE:\n```\nfib_prev = 0\nfib_curr = 1\n\nprint(fib_prev, end=\"\")\nwhile fib_curr < 50:\n    print(\",\", fib_curr, end=\"\")\n    fib_prev, fib_curr = fib_curr, fib_prev + fib_curr\n```\n\n----------------------------------------\n\nTITLE: Creating Lists with Variadic Arguments in Mojo\nDESCRIPTION: Example showing how to construct a List (formerly DynamicVector) using variadic arguments in the constructor.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_104\n\nLANGUAGE: mojo\nCODE:\n```\nvar numbers = List[Int](1, 2, 3)\n```\n\n----------------------------------------\n\nTITLE: File Reading Operations in Mojo\nDESCRIPTION: Shows various ways to read files in Mojo, including reading raw bytes and text data.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_151\n\nLANGUAGE: mojo\nCODE:\n```\nwith open(\"file.binary\", \"r\") as f:\n    data = f.read_bytes()\n\nwith open(\"file.binary\", \"r\") as f:\n    data1 = f.read_bytes(1024)\n    data2 = f.read_bytes(256)\n\nlet text_path = Path(\"file.txt\")\nlet text = text_path.read_text()\n\nlet binary_path = Path(\"file.binary\")\nlet data = binary_path.read_bytes()\n```\n\n----------------------------------------\n\nTITLE: Evaluating Heap-Allocated Memory at Compile-Time in Mojo\nDESCRIPTION: This example shows how Mojo supports evaluating code that uses heap-allocated memory at compile-time and materializing compile-time values with heap-allocated memory into dynamic values.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_179\n\nLANGUAGE: mojo\nCODE:\n```\nfn fillVector(lowerBound: Int, upperBound: Int, step: Int) -> DynamicVector[Int]:\n    var result = DynamicVector[Int]()\n    for i in range(lowerBound, upperBound, step):\n        result.push_back(i)\n    return result\n\nfn main():\n    alias values = fillVector(5, 23, 7)\n    for i in range(0, values.__len__()):\n        print(values[i]) # prints '5', '12', and then '19'\n```\n\n----------------------------------------\n\nTITLE: Declaring Variables with Explicit Types in Mojo\nDESCRIPTION: Shows how to declare variables with explicit types using the 'var' keyword in Mojo. It includes an example of a function with typed parameters and a return value.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_236\n\nLANGUAGE: mojo\nCODE:\n```\ndef foo(lhs: index, rhs: index) -> index:\n    var result: index = lhs + rhs\n    return result\n```\n\n----------------------------------------\n\nTITLE: Late Initialized Local References with Explicit Lifetimes\nDESCRIPTION: Example of using late-initialized local references with explicit lifetimes in Mojo. The function demonstrates conditionally initializing a reference variable that shares the same lifetime as its input references.\nSOURCE: https://github.com/modular/max/blob/main/mojo/proposals/lifetimes-and-provenance.md#2025-04-17_snippet_5\n\nLANGUAGE: mojo\nCODE:\n```\nfn example[life: Lifetime](cond: Bool,\n                           x: ref[life] String,\n                           y: ref[life] String):\n    # Late initialized local borrow with explicit lifetime\n    let str_ref: ref[life] String\n\n    if cond:\n        str_ref = x\n    else:\n        str_ref = y\n    print(str_ref)\n```\n\n----------------------------------------\n\nTITLE: Using Parametric Mutability with UnsafePointer in Mojo\nDESCRIPTION: Shows how collection types return UnsafePointers with mutability inherited from the reference mutability at the call site, with immutable (read) and mutable (mut) examples.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_19\n\nLANGUAGE: mojo\nCODE:\n```\nfn take_lists(read list1: List[Int], mut list2: List[Int]):\n    # Immutable pointer, since receiver is immutable `read` reference\n    var ptr1 = list1.unsafe_ptr()\n\n    # Mutable pointer, since receiver is mutable `mut` reference\n    var ptr2 = list2.unsafe_ptr()\n```\n\n----------------------------------------\n\nTITLE: Methods Generated by @value Decorator in Mojo\nDESCRIPTION: Shows the methods that are automatically synthesized by the @value decorator, including initializer, copy constructor, and move constructor with proper ownership semantics.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_199\n\nLANGUAGE: mojo\nCODE:\n```\nfn __init__(inout self, owned name: String, age: Int):\n    self.name = name^\n    self.age = age\nfn __copyinit__(inout self, existing: Self):\n    self.name = existing.name\n    self.age = existing.age\nfn __moveinit__(inout self, owned existing: Self):\n    self.name = existing.name^\n    self.age = existing.age\n```\n\n----------------------------------------\n\nTITLE: Short-circuit AND Evaluation in Mojo\nDESCRIPTION: Demonstrates short-circuit evaluation with the AND operator where the second operand is not evaluated if the first is False.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/control-flow.mdx#2025-04-17_snippet_4\n\nLANGUAGE: mojo\nCODE:\n```\nprint('Short-circuit \"and\" evaluation')\nif false_func() and true_func():\n    print(\"True result\")\n```\n\n----------------------------------------\n\nTITLE: Mojo Struct Initializer Returning Self\nDESCRIPTION: Alternative struct initialization style returning a new instance, required for @register_passable types.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_208\n\nLANGUAGE: mojo\nCODE:\n```\nfn __init__(x: Int) -> Self:\n    return Self {x: x}\n```\n\n----------------------------------------\n\nTITLE: Using @parameter with if statement in Mojo\nDESCRIPTION: Demonstrates how to use the @parameter decorator with an if statement to ensure only the live branch is compiled into the program, potentially reducing binary size.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/decorators/parameter.md#2025-04-17_snippet_0\n\nLANGUAGE: mojo\nCODE:\n```\n@parameter\nif True:\n    print(\"this will be included in the binary\")\nelse:\n    print(\"this will be eliminated at compile time\")\n```\n\n----------------------------------------\n\nTITLE: Implementing Basic Register Passable Pair Structure\nDESCRIPTION: Demonstrates implementation of a basic register passable Pair structure with custom initialization and copy methods. The structure holds two integer values and shows how they can be manipulated while being passed through registers.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/decorators/register-passable.md#2025-04-17_snippet_0\n\nLANGUAGE: mojo\nCODE:\n```\n@register_passable\nstruct Pair:\n    var a: Int\n    var b: Int\n\n    fn __init__(out self, one: Int, two: Int):\n        self.a = one\n        self.b = two\n\n    fn __copyinit__(out self, existing: Self):\n        self.a = existing.a\n        self.b = existing.b\n\nfn test_pair():\n    var x = Pair(5, 10)\n    var y = x\n\n    print(y.a, y.b)\n    y.a = 10\n    y.b = 20\n    print(y.a, y.b)\n```\n\n----------------------------------------\n\nTITLE: Using Source Location Tracking with __call_location in Mojo\nDESCRIPTION: This code snippet demonstrates how to capture the call location of functions dynamically using the __call_location() function. It implements a custom assertion function that prints the file and line number where the assertion failed.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_87\n\nLANGUAGE: mojo\nCODE:\n```\nfrom builtin._location import __call_location\n\n@always_inline\nfn my_assert(cond: Bool, msg: String):\n    if not cond:\n      var call_loc = __call_location()\n      print(\"In\", call_loc.file_name, \"on line\", str(call_loc.line) + \":\", msg)\n\nfn main():\n    my_assert(False, \"always fails\")  # some_file.mojo, line 193\n```\n\n----------------------------------------\n\nTITLE: Using Partial Automatic Parameterization Function Calls\nDESCRIPTION: Demonstrates how to call functions using partial automatic parameterization with different parameter binding approaches.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_147\n\nLANGUAGE: mojo\nCODE:\n```\neat(Fudge[5, 8]())\n\neat[3](Fudge[5, 3]())\n```\n\n----------------------------------------\n\nTITLE: Dereferencing and Updating UnsafePointer Values in Mojo\nDESCRIPTION: Shows how to access and modify values stored in memory pointed to by an UnsafePointer using the dereference syntax (empty square brackets). This allows reading from and writing to dynamically allocated memory.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/pointers/unsafe-pointers.mdx#2025-04-17_snippet_1\n\nLANGUAGE: mojo\nCODE:\n```\n# Update an initialized value\nptr[] += 10\n# Access an initialized value\nprint(ptr[])\n```\n\n----------------------------------------\n\nTITLE: Using Traits in Generic Functions in Mojo\nDESCRIPTION: Illustrates how to write a generic function that accepts any type conforming to a specific trait, and how to use such a function.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/basics.mdx#2025-04-17_snippet_19\n\nLANGUAGE: mojo\nCODE:\n```\nfn fun_with_traits[T: SomeTrait](x: T):\n    x.required_method(42)\n\nfn use_trait_function():\n    var thing = SomeStruct()\n    fun_with_traits(thing)\n```\n\n----------------------------------------\n\nTITLE: Using PythonObject Wrapper with ListLiteral\nDESCRIPTION: Demonstrates how to explicitly create a wrapped Python object by initializing a PythonObject with a Mojo ListLiteral, showing how to access and modify the list elements.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/python/types.mdx#2025-04-17_snippet_2\n\nLANGUAGE: mojo\nCODE:\n```\nfrom python import PythonObject\n\ndef main():\n    var py_list: PythonObject = [\"cat\", 2, 3.14159, 4]  # A ListLiteral\n    n = py_list[2]\n    print(\"n =\", n)\n    py_list.append(5)\n    py_list[0] = \"aardvark\"\n    print(py_list)\n```\n\n----------------------------------------\n\nTITLE: Variadic List Iteration Example\nDESCRIPTION: Demonstrates how to iterate over variadic arguments using the new iterable VariadicList type.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_154\n\nLANGUAGE: mojo\nCODE:\n```\nfn print_ints(*nums: Int):\n    for num in nums:\n        print(num)\n    print(len(nums))\n```\n\n----------------------------------------\n\nTITLE: Creating and Copying to Device Buffer in Mojo\nDESCRIPTION: This code creates a device buffer on the GPU and copies data from the host buffer to it, demonstrating data transfer from CPU to GPU.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/gpu/basics.mdx#2025-04-17_snippet_8\n\nLANGUAGE: mojo\nCODE:\n```\nvar device_in_buffer = ctx.enqueue_create_buffer[dtype](elements_in)\n\nhost_in_buffer.enqueue_copy_to(device_in_buffer)\n```\n\n----------------------------------------\n\nTITLE: Invoking Generic Functions with Trait-Conforming Types in Mojo\nDESCRIPTION: Demonstrates how to use trait-conforming types with generic functions, where type parameters are inferred automatically.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_142\n\nLANGUAGE: mojo\nCODE:\n```\nvar thing = SomeStruct()\n# Infer the parameter `T`!\nfun_with_traits(thing)\n```\n\n----------------------------------------\n\nTITLE: Defining Positional-Only Arguments in Mojo\nDESCRIPTION: Demonstration of how to define positional-only arguments using the forward slash (/) syntax. The example shows a min function that only accepts positional arguments.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/functions.mdx#2025-04-17_snippet_17\n\nLANGUAGE: mojo\nCODE:\n```\nfn min(a: Int, b: Int, /) -> Int:\n    return a if a < b else b\n```\n\n----------------------------------------\n\nTITLE: Example of Unsupported Variadic Keyword-Only Arguments in Mojo\nDESCRIPTION: Demonstrates syntax that is not currently supported in Mojo. The example shows a function declaration with variadic keyword-only arguments (**kwargs), which is not allowed in the current version.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_116\n\nLANGUAGE: mojo\nCODE:\n```\nfn variadic_kw_only(a: Int, **kwargs): ...\n```\n\n----------------------------------------\n\nTITLE: Floating Point Equality Comparison in Mojo\nDESCRIPTION: Demonstrates how floating-point equality comparison can produce unexpected results due to precision limitations when dealing with large numbers.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/types.mdx#2025-04-17_snippet_0\n\nLANGUAGE: mojo\nCODE:\n```\nvar big_num = 1.0e16\nvar bigger_num = big_num+1.0\nprint(big_num == bigger_num)\n```\n\n----------------------------------------\n\nTITLE: Function Overloading with Implicit Type Conversion in Mojo\nDESCRIPTION: Demonstration of function overloading in Mojo where the compiler selects the appropriate function based on argument types, including consideration of implicit type conversions.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_229\n\nLANGUAGE: mojo\nCODE:\n```\nfn foo(x: Int): pass\nfn foo(x: F64): pass\n\nfoo(Int(1)) # resolves to the first overload\nfoo(1.0)    # resolves to the second overload\nfoo(1)      # error: both candidates viable with 1 implicit conversion!\n```\n\n----------------------------------------\n\nTITLE: Importing from a Mojo Package\nDESCRIPTION: This example demonstrates how to import a struct (MyPair) from a specific module (mymodule) within a Mojo package (mypackage) in the main program file.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/packages.md#2025-04-17_snippet_4\n\nLANGUAGE: mojo\nCODE:\n```\nfrom mypackage.mymodule import MyPair\n\nfn main():\n    var mine = MyPair(2, 4)\n    mine.dump()\n```\n\n----------------------------------------\n\nTITLE: Initializing Structs with Pretty Syntax in Mojo\nDESCRIPTION: Demonstrates the new 'pretty' initialization syntax for structs in Mojo, eliminating the need to directly use the MLIR lit.struct.create op in struct initializers.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_222\n\nLANGUAGE: mojo\nCODE:\n```\nstruct Int:\n    var value: __mlir_type.index\n    fn __new__(value: __mlir_type.index) -> Int:\n        return Int {value: value}\n```\n\n----------------------------------------\n\nTITLE: UnsafePointer Allocation with Alignment Parameter\nDESCRIPTION: Demonstrates the new way to specify alignment in UnsafePointer allocation, moving the alignment parameter from the alloc() method to the type declaration.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_59\n\nLANGUAGE: mojo\nCODE:\n```\nUnsafePointer[type].alloc[alignment](x) # now becomes\nUnsafePointer[type, alignment].alloc(x)\n```\n\n----------------------------------------\n\nTITLE: Mojo Variadic Pack Arguments\nDESCRIPTION: Demonstration of heterogeneous variadic pack arguments usage with type parameters.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_209\n\nLANGUAGE: mojo\nCODE:\n```\nfn foo[*Ts: AnyType](args*: Ts): pass\n\nfoo[Int, F32, String, Bool](1, 1.5, \"hello\", True)\n```\n\n----------------------------------------\n\nTITLE: Converting Between SIMD Vector Types in Mojo\nDESCRIPTION: Shows how to convert between SIMD vector types of the same size but different data types, requiring equal vector sizes.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_23\n\nLANGUAGE: mojo\nCODE:\n```\nvar float_vector = SIMD[DType.float64, 4](vector)\n```\n\n----------------------------------------\n\nTITLE: Creating an ArcPointer with a Dictionary in Mojo\nDESCRIPTION: This code shows how to create an ArcPointer that points to a Dictionary. ArcPointer is a reference-counted smart pointer that can be copied, with all copies sharing ownership of the same value.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/pointers/index.mdx#2025-04-17_snippet_4\n\nLANGUAGE: mojo\nCODE:\n```\nattributesDict = Dict[String, String]()\nattributes = ArcPointer(attributesDict)\n```\n\n----------------------------------------\n\nTITLE: Creating a Python Set with Python.evaluate()\nDESCRIPTION: Shows how to create a Python set using Python.evaluate() and perform operations like checking the number of items and testing for membership in the set.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/python/types.mdx#2025-04-17_snippet_3\n\nLANGUAGE: mojo\nCODE:\n```\nfrom python import Python\n\ndef main():\n    var py_set = Python.evaluate('{2, 3, 2, 7, 11, 3}')\n    num_items = len(py_set)\n    print(num_items, \"items in the set.\")\n    contained = 7 in py_set\n    print(\"Is 7 in the set:\", contained)\n```\n\n----------------------------------------\n\nTITLE: Using Python Keyword Arguments in Mojo\nDESCRIPTION: Illustrates how to pass keyword arguments to Python functions from Mojo, using matplotlib as an example.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_99\n\nLANGUAGE: mojo\nCODE:\n```\nfrom python import Python\n\ndef main():\n    plt = Python.import_module(\"matplotlib.pyplot\")\n    plt.plot((5, 10), (10, 15), color=\"red\")\n    plt.show()\n```\n\n----------------------------------------\n\nTITLE: Iterating Over DynamicVector in Mojo\nDESCRIPTION: Demonstrates how to iterate over a DynamicVector in Mojo. Shows that iteration values are instances of Reference and require dereferencing with the [] operator.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_119\n\nLANGUAGE: mojo\nCODE:\n```\nvar v: DynamicVector[String]()\nv.append(\"Alice\")\nv.append(\"Bob\")\nv.append(\"Charlie\")\nfor x in v:\n    x[] = str(\"Hello, \") + x[]\nfor x in v:\n    print(x[])\n```\n\n----------------------------------------\n\nTITLE: Auto-Dereferenced References with 'ref' Keyword in Mojo\nDESCRIPTION: Demonstration of the new 'ref' keyword that allows functions to return auto-dereferenced references to storage. This eliminates the need for __refitem__() by providing a general way to return and mutate references.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_69\n\nLANGUAGE: mojo\nCODE:\n```\n@value\nstruct Pair:\n    var first: Int\n    var second: Int\n\n    fn get_first_ref(inout self) -> ref [self] Int:\n        return self.first\n\nfn show_mutation():\n    var somePair = Pair(5, 6)\n    somePair.get_first_ref() = 1\n```\n\n----------------------------------------\n\nTITLE: Using reversed() Function with List in Mojo\nDESCRIPTION: Example of using the new reversed() function to iterate through a List in reverse order. This functionality is now supported for several range types, List, and Dict.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_90\n\nLANGUAGE: mojo\nCODE:\n```\nvar numbers = List(1, 2, 3, 4, 5)\nfor number in reversed(numbers):\n    print(number)\n```\n\n----------------------------------------\n\nTITLE: Using PythonObject.__contains__() for Membership Testing\nDESCRIPTION: Example demonstrating how to use the __contains__() method on PythonObject to check if a value exists within a Python collection.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_41\n\nLANGUAGE: mojo\nCODE:\n```\nx = PythonObject([1,2,3])\nif 1 in x:\n    print(\"1 in x\")\n```\n\n----------------------------------------\n\nTITLE: Float Formatting Examples in Mojo\nDESCRIPTION: Examples showing the changes in how Float32 and Float64 values are printed and converted to strings, demonstrating the new roundtrip guarantee and shortest representation format.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_43\n\nLANGUAGE: plaintext\nCODE:\n```\nValue                       Old                       New\nFloat64(0.3)                0.29999999999999999       0.3\nFloat32(0.3)                0.30000001192092896       0.3\nFloat64(0.0001)             0.0001                    0.0001\nFloat32(0.0001)             9.9999997473787516e-05    0.0001\nFloat64(-0.00001)           -1.0000000000000001e-05   -1e-05\nFloat32(-0.00001)           -9.9999997473787516e-06   -1e-05\nFloat32(0.00001234)         1.2339999557298142e-05    1.234e-05\nFloat32(-0.00000123456)     -1.2345600453045336e-06   -1.23456e-06\nFloat64(1.1234567e-320)     1.1235052786429946e-320   1.1235e-320\nFloat64(1.234 * 10**16)     12340000000000000.0       1.234e+16\n```\n\n----------------------------------------\n\nTITLE: Using PythonObject as Dict Key in Mojo\nDESCRIPTION: Example of using PythonObject as a key in Dict thanks to the new KeyElement trait conformance. This allows for easy creation and manipulation of Python dictionaries in Mojo.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_93\n\nLANGUAGE: mojo\nCODE:\n```\ndef main():\n    d = PythonObject(Dict[PythonObject, PythonObject]())\n    d[\"foo\"] = 12\n    d[7] = \"bar\"\n    d[\"foo\"] = [1, 2, \"something else\"]\n    print(d)  # prints `{'foo': [1, 2, 'something else'], 7: 'bar'}`\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Struct Parameter References in Mojo\nDESCRIPTION: Example showing how references to aliases in struct types with unbound parameters are handled. Demonstrates valid and invalid usage of struct parameter references.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_0\n\nLANGUAGE: mojo\nCODE:\n```\nstruct StructWithParam[a: Int, b: Int]:\n    alias a1 = 42\n    alias a2 = a+1\n\nfn test():\n    _ = StructWithParams.a1 # ok\n    _ = StructWithParams[1].a2 # ok\n    _ = StructWithParams.a2 # error, 'a' is unbound.\n```\n\n----------------------------------------\n\nTITLE: Implementing Simplified Context Managers in Mojo\nDESCRIPTION: This code demonstrates Mojo's support for context managers that implement only the __enter__ method without requiring an __exit__ method. It shows how to create a context manager that consumes itself and returns it as a value.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_169\n\nLANGUAGE: mojo\nCODE:\n```\n# This context manager consumes itself and returns it as the value.\nfn __enter__(owned self) -> Self:\n    return self^\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Struct Parameters in Mojo\nDESCRIPTION: Example showing struct definition with infer-only parameters and size-dependent type parameter.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/lib.mdx#2025-04-17_snippet_3\n\nLANGUAGE: mojo\nCODE:\n```\nstruct ExampleStruct[size: Int, //, thing: Thing[size]]:\n```\n\n----------------------------------------\n\nTITLE: Conditional (Ternary) Expression in Mojo\nDESCRIPTION: Shows how to use a conditional expression as a concise way to assign one of two values based on a condition.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/control-flow.mdx#2025-04-17_snippet_5\n\nLANGUAGE: mojo\nCODE:\n```\ntemp_celsius = 15\nforecast = \"warm\" if temp_celsius > 20 else \"cool\"\nprint(\"The forecast for today is\", forecast)\n```\n\n----------------------------------------\n\nTITLE: Moving Owned Values to UnsafePointer Memory in Mojo\nDESCRIPTION: Shows how to move a newly constructed value into memory pointed to by an UnsafePointer. For newly created values, the transfer sigil is not needed as they are already owned.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/pointers/unsafe-pointers.mdx#2025-04-17_snippet_11\n\nLANGUAGE: mojo\nCODE:\n```\nstr_ptr.init_pointee_move(String(\"Owned string\"))\n```\n\n----------------------------------------\n\nTITLE: Struct with Multiple Constraints Example\nDESCRIPTION: Example showing how multiple requires clauses combine in nested contexts.\nSOURCE: https://github.com/modular/max/blob/main/mojo/proposals/requires-clause.md#2025-04-17_snippet_5\n\nLANGUAGE: mojo\nCODE:\n```\nstruct S[a: Int, b: Int, c: Int, d: Int]\n  requires pred1(a):\n  \n    fn some_method(self)\n       requires pred2(b):\n       \n       @parameter\n       if pred3(c):\n       \n           fn nested()\n             requires pred4(d):\n                # Checking at this point.\n                some_callee(self)\n```\n\n----------------------------------------\n\nTITLE: Copying Values to UnsafePointer Memory in Mojo\nDESCRIPTION: Shows how to initialize memory by copying a value into it. This is used when you want to keep the original value intact while storing a copy at the pointer location.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/pointers/unsafe-pointers.mdx#2025-04-17_snippet_9\n\nLANGUAGE: mojo\nCODE:\n```\nptr.init_pointee_copy(my_value)\n```\n\n----------------------------------------\n\nTITLE: Updated Vectorize Function Signature in Mojo\nDESCRIPTION: This code demonstrates the new signature for the vectorize function, where the closure 'func' is now the first parameter, followed by width and an optional unroll_factor.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_127\n\nLANGUAGE: mojo\nCODE:\n```\nvectorize[func, width, unroll_factor = 1](size)\nvectorize[func, width, size, unroll_factor = 1]()\n```\n\n----------------------------------------\n\nTITLE: OS Module Functions in Mojo\nDESCRIPTION: Implementation of get_cwd_and_paths function that combines pathlib functionality with directory listing\nSOURCE: https://github.com/modular/max/blob/main/mojo/stdlib/docs/development.md#2025-04-17_snippet_4\n\nLANGUAGE: mojo\nCODE:\n```\nimport pathlib\n\nfn get_cwd_and_paths() raises -> List[String]:\n    result = List[String]()\n    result.append(pathlib.get_cwd_message())\n    for path in cwd().listdir():\n        result.append(String(path[]))\n```\n\n----------------------------------------\n\nTITLE: Defining a Function that Raises an Error in Mojo\nDESCRIPTION: Shows how to define a function using 'fn' keyword that can raise an error, requiring the 'raises' keyword in the function signature.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/errors.mdx#2025-04-17_snippet_1\n\nLANGUAGE: mojo\nCODE:\n```\nfn incr(n: Int) raises -> Int:\n    if n == Int.MAX:\n        raise \"inc: integer overflow\"\n    else:\n        return n + 1\n```\n\n----------------------------------------\n\nTITLE: Implementing Static Methods\nDESCRIPTION: Shows how to implement and use static methods in a struct using the @staticmethod decorator.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/structs.mdx#2025-04-17_snippet_5\n\nLANGUAGE: mojo\nCODE:\n```\nstruct Logger:\n\n    fn __init__(out self):\n        pass\n\n    @staticmethod\n    fn log_info(message: String):\n        print(\"Info: \", message)\n```\n\n----------------------------------------\n\nTITLE: Reading and Writing UnsafePointer Values in Mojo\nDESCRIPTION: Demonstrates how to read from and write to memory pointed to by an UnsafePointer using the dereference syntax. This allows manipulation of dynamically allocated memory.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/pointers/unsafe-pointers.mdx#2025-04-17_snippet_6\n\nLANGUAGE: mojo\nCODE:\n```\noldValue = ptr[]\nptr[] = newValue\n```\n\n----------------------------------------\n\nTITLE: Python Array Manipulation with PythonObject\nDESCRIPTION: Example of creating nested PythonObjects from lists and using NumPy arrays in Mojo.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_60\n\nLANGUAGE: mojo\nCODE:\n```\nvar np = Python.import_module(\"numpy\")\nvar a = np.array([1, 2, 3])\nvar b = np.array([4, 5, 6])\nvar arrays = PythonObject([a, b])\nassert_equal(len(arrays), 2)\n\nvar stacked = np.hstack((a, b))\nassert_equal(str(stacked), \"[1 2 3 4 5 6]\")\n```\n\n----------------------------------------\n\nTITLE: Infer-Only Parameters with Function in Mojo\nDESCRIPTION: Example of Mojo's new infer-only parameters feature, where parameters before the '//' marker can be inferred rather than explicitly specified by the caller. This improves ergonomics with dependent parameters.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_70\n\nLANGUAGE: mojo\nCODE:\n```\nfn parameter_simd[dt: DType, //, value: Scalar[dt]]():\n    print(value)\n\nfn call_it():\n    parameter_simd[Int32(42)]()\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Argument Conventions in Mojo\nDESCRIPTION: Example showing function signature with mutable argument convention for list sorting.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/lib.mdx#2025-04-17_snippet_2\n\nLANGUAGE: mojo\nCODE:\n```\nfn sort(mut names: List[String]):\n```\n\n----------------------------------------\n\nTITLE: Simplified Import from a Package\nDESCRIPTION: This snippet demonstrates how to import a struct (MyPair) directly from a package name after it has been imported in the package's __init__.mojo file.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/packages.md#2025-04-17_snippet_7\n\nLANGUAGE: mojo\nCODE:\n```\nfrom mypackage import MyPair\n```\n\n----------------------------------------\n\nTITLE: Overloaded Indexing Operations with Keyword Arguments in Mojo\nDESCRIPTION: Demonstrates implementation of overloaded getitem and setitem operations using both positional and keyword arguments for flexible array access patterns.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_10\n\nLANGUAGE: mojo\nCODE:\n```\nstruct OverloadedKwArgs:\n  var vals: List[Int]\n\n  fn __init__(out self):\n      self.vals = List[Int](0, 1, 2)\n\n  fn __getitem__(self, idx: Int) -> Int:\n      return self.vals[idx]\n\n  fn __getitem__(self, *, idx2: Int) -> Int:\n      return self.vals[idx2 * 2]\n\n  fn __setitem__(mut self, idx: Int, val: Int):\n      self.vals[idx] = val\n\n  fn __setitem__(mut self, val: Int, *, idx2: Int):\n        self.vals[idx2 * 2] = val\n\n\nfn main():\n    var x = OverloadedKwArgs()\n    print(x[1])       # 1\n    print(x[idx2=1])  # 2\n\n    x[1] = 42\n    x[idx2=1] = 84\n\n    print(x[1])       # 42\n    print(x[idx2=1])  # 84\n```\n\n----------------------------------------\n\nTITLE: Implementing Nonmaterializable Type Conversion in Mojo\nDESCRIPTION: Demonstrates how to create a nonmaterializable struct that converts to a different type at runtime. The example shows NmStruct converting to HasBool when materialized, with HasBool containing a boolean value derived from the original struct's integer value.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/decorators/nonmaterializable.md#2025-04-17_snippet_0\n\nLANGUAGE: mojo\nCODE:\n```\n@value\n@register_passable(\"trivial\")\nstruct HasBool:\n    var x: Bool\n\n    fn __init__(out self, x: Bool):\n        self.x = x\n\n    @always_inline(\"nodebug\")\n    fn __init__(out self, nms: NmStruct):\n        self.x = True if (nms.x == 77) else False\n\n@value\n@nonmaterializable(HasBool)\n@register_passable(\"trivial\")\nstruct NmStruct:\n    var x: Int\n\n    @always_inline(\"nodebug\")\n    fn __add__(self, rhs: Self) -> Self:\n        return NmStruct(self.x + rhs.x)\n\nalias still_nm_struct = NmStruct(1) + NmStruct(2)\n# When materializing to a run-time variable, it is automatically converted,\n# even without a type annotation.\nvar converted_to_has_bool = still_nm_struct\n```\n\n----------------------------------------\n\nTITLE: Converting Scalar to SIMD Vector in Mojo\nDESCRIPTION: Demonstrates how to create a SIMD vector by broadcasting a scalar value to all elements using the SIMD constructor.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_22\n\nLANGUAGE: mojo\nCODE:\n```\nvar vector = SIMD[DType.int64, 4](cast) # [42, 42, 42, 42]\n```\n\n----------------------------------------\n\nTITLE: For Loop Iterating Over Range in Mojo\nDESCRIPTION: Demonstrates iterating over a sequence of integers using the range() function.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/control-flow.mdx#2025-04-17_snippet_16\n\nLANGUAGE: mojo\nCODE:\n```\nfor i in range(5):\n    print(i, end=\", \")\n```\n\n----------------------------------------\n\nTITLE: Implementing a Trait in Mojo\nDESCRIPTION: Shows how to create a struct that conforms to a trait by implementing its required methods.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/basics.mdx#2025-04-17_snippet_18\n\nLANGUAGE: mojo\nCODE:\n```\n@value\nstruct SomeStruct(SomeTrait):\n    fn required_method(self, x: Int):\n        print(\"hello traits\", x)\n```\n\n----------------------------------------\n\nTITLE: Basic File Reading in Mojo\nDESCRIPTION: Traditional approach to reading a file using explicit open and close operations with error handling.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/errors.mdx#2025-04-17_snippet_6\n\nLANGUAGE: mojo\nCODE:\n```\nf = open(input_file, \"r\")\n\ntry:\n    content = f.read()\n    # Process the content as needed\nfinally:\n    # Ensure that the file handle is closed even if read() raises an error\n    f.close()\n```\n\n----------------------------------------\n\nTITLE: Using is/isnot Operators with Optional in Mojo\nDESCRIPTION: Example of using the new __is__ and __isnot__ methods implemented for Optional type, allowing direct comparison with None using the 'is' and 'is not' operators.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_91\n\nLANGUAGE: mojo\nCODE:\n```\nvar opt = Optional(1)\nif opt is not None:\n    print(opt.value()[])\n```\n\n----------------------------------------\n\nTITLE: Implementing Absable and Roundable Traits for Complex Numbers\nDESCRIPTION: Example of a Complex2 structure implementing the Absable and Roundable traits, which enables it to work with the built-in abs() and round() functions. The implementation provides both specific and default rounding methods.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_77\n\nLANGUAGE: mojo\nCODE:\n```\nfrom math import sqrt\n\n@value\nstruct Complex2(Absable, Roundable):\n    var re: Float64\n    var im: Float64\n\n    fn __abs__(self) -> Self:\n        return Self(sqrt(self.re * self.re + self.im * self.im), 0.0)\n\n    fn __round__(self) -> Self:\n        return Self(round(self.re, 0), round(self.im, 0))\n\n    fn __round__(self, ndigits: Int) -> Self:\n        return Self(round(self.re, ndigits), round(self.im, ndigits))\n\n```\n\n----------------------------------------\n\nTITLE: Using the Tensor Type for RGB to Grayscale Conversion in Mojo\nDESCRIPTION: This example demonstrates how to use the Tensor type in Mojo to represent an RGB image and convert it to grayscale. The Tensor type manages its own memory, handling allocation and deallocation automatically.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_180\n\nLANGUAGE: mojo\nCODE:\n```\nfrom tensor import Tensor, TensorShape\nfrom utils.index import Index\nfrom random import rand\n\nlet height = 256\nlet width = 256\nlet channels = 3\n\n# Create the tensor of dimensions height, width, channels and fill with\n# random value.\nlet image = rand[DType.float32](height, width, channels)\n\n# Declare the grayscale image.\nvar gray_scale_image = Tensor[DType.float32](height, width)\n\n# Perform the RGB to grayscale transform.\nfor y in range(height):\n    for x in range(width):\n        let r = image[y, x, 0]\n        let g = image[y, x, 1]\n        let b = image[y, x, 2]\n        gray_scale_image[Index(y, x)] = 0.299 * r + 0.587 * g + 0.114 * b\n```\n\n----------------------------------------\n\nTITLE: Implementing Hashable for Person Struct in Mojo\nDESCRIPTION: Demonstrates the current approach to implementing the Hashable trait for a complex struct, highlighting the challenges in combining hash values for multiple fields.\nSOURCE: https://github.com/modular/max/blob/main/mojo/proposals/improved-hash-module.md#2025-04-17_snippet_1\n\nLANGUAGE: mojo\nCODE:\n```\n@value\nstruct Person(Hashable):\n    var name: String\n    var age: UInt8\n    var friends_names: List[String]\n\n    fn __hash__(self) -> Int:\n        var hashes = List[Int]()\n        hashes.append(hash(self.name))\n        hashes.append(hash(self.age))\n        for friend in self.friends_names:\n            hashes.append(hash(friend[]))\n\n        # How to combine a hash of hashes ???\n```\n\n----------------------------------------\n\nTITLE: Conditional Conformance with Type Rebinding in Mojo\nDESCRIPTION: This snippet illustrates a potential extension to Mojo's type system, allowing for conditional conformance with type rebinding. It shows how requirements can be used to constrain method implementations based on trait conformance.\nSOURCE: https://github.com/modular/max/blob/main/mojo/proposals/requires-clause.md#2025-04-17_snippet_8\n\nLANGUAGE: mojo\nCODE:\n```\nstruct A[T: AnyType]:\n    var elt : T\n    \n    # existing\n    fn constrained[T2: Copyable](self: A[T2]):\n         var elt_copy = self.elt # invoke copyinit\n         \n    # desired:\n    fn constrained(self)\n      requires T instanceof Copyable:\n         # need to know T is copyable even though declared AnyType\n         var elt_copy = self.elt\n```\n\n----------------------------------------\n\nTITLE: Creating a Slice with optional end in Mojo\nDESCRIPTION: Shows how to create a Slice object with an optional end value using the new constructor that accepts optional values. The example demonstrates accessing the start value from the optional.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_65\n\nLANGUAGE: mojo\nCODE:\n```\nvar s = Slice(1, None, 2)\nprint(s.start.value()) # must retrieve the value from the optional\n```\n\n----------------------------------------\n\nTITLE: Converting Point Struct from Stringable to Formattable\nDESCRIPTION: Shows how to transition a struct from implementing only Stringable to also implementing Formattable, which enables more efficient stream-based writing with print() and avoids unnecessary heap allocations.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_53\n\nLANGUAGE: mojo\nCODE:\n```\nstruct Point(Stringable):\n    var x: Float64\n    var y: Float64\n\n    fn __str__(self) -> String:\n        # Performs 3 allocations: 1 each for str(..) of each of the fields,\n        # and then the final returned `String` allocation.\n        return \"(\" + str(self.x) + \", \" + str(self.y) + \")\"\n```\n\nLANGUAGE: mojo\nCODE:\n```\nstruct Point(Stringable, Formattable):\n    var x: Float64\n    var y: Float64\n\n    fn __str__(self) -> String:\n        return String.format_sequence(self)\n\n    fn format_to(self, inout writer: Formatter):\n        writer.write(\"(\", self.x, \", \", self.y, \")\")\n```\n\n----------------------------------------\n\nTITLE: Using Variadic Parameters with Optional Parameters in Mojo\nDESCRIPTION: This code snippet demonstrates how to define a function with variadic parameters that follow optional parameters with default values. The example shows the new syntax for declaring parameter-level variadic arguments.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_85\n\nLANGUAGE: mojo\nCODE:\n```\nfn variadic_param_after_default[e: Int, f: Int = 2, *params: Int]():\n  pass\n```\n\n----------------------------------------\n\nTITLE: Using Writer and Writable Traits in Mojo\nDESCRIPTION: Example demonstrating the new Writer trait (replacing Formatter) and Writable trait (replacing Formattable), showing how to implement custom types that can be written to output streams.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_39\n\nLANGUAGE: mojo\nCODE:\n```\nfrom memory import Span\n\n@value\nstruct NewString(Writer, Writable):\n    var s: String\n\n    # Writer requirement to write a Span of Bytes\n    fn write_bytes(inout self, bytes: Span[Byte, _]):\n        self.s._iadd[False](bytes)\n\n    # Writer requirement to take multiple args\n    fn write[*Ts: Writable](inout self, *args: *Ts):\n        @parameter\n        fn write_arg[T: Writable](arg: T):\n            arg.write_to(self)\n\n        args.each[write_arg]()\n\n    # Also make it Writable to allow `print` to write the inner String\n    fn write_to[W: Writer](self, inout writer: W):\n        writer.write(self.s)\n\n\n@value\nstruct Point(Writable):\n    var x: Int\n    var y: Int\n\n    # Pass multiple args to the Writer. The Int and StringLiteral types call\n    # `writer.write_bytes` in their own `write_to` implementations.\n    fn write_to[W: Writer](self, inout writer: W):\n        writer.write(\"Point(\", self.x, \", \", self.y, \")\")\n\n    # Enable conversion to a String using `str(point)`\n    fn __str__(self) -> String:\n        return String.write(self)\n\n\nfn main():\n    var point = Point(1, 2)\n    var new_string = NewString(str(point))\n    new_string.write(\"\\n\", Point(3, 4))\n    print(new_string)\n```\n\n----------------------------------------\n\nTITLE: Equivalent Inlined Code in Mojo\nDESCRIPTION: Shows the effective result after the compiler inlines the @always_inline function. This represents what happens behind the scenes when the decorator is used.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/decorators/always-inline.md#2025-04-17_snippet_1\n\nLANGUAGE: mojo\nCODE:\n```\nprint(1 + 2)\n```\n\n----------------------------------------\n\nTITLE: Using Origin Sets with Function Types\nDESCRIPTION: Example showing how function types now accept an origin set parameter to represent captured origins in parameter closures, enabling proper lifetime management without needing explicit lifetime extension.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_33\n\nLANGUAGE: mojo\nCODE:\n```\nfn call_it[f: fn() capturing [_] -> None]():\n    f()\n\nfn test():\n    var msg = String(\"hello world\")\n\n    @parameter\n    fn say_hi():\n        print(msg)\n\n    call_it[say_hi]()\n    # no longer need to write `_ = msg^`!!\n```\n\n----------------------------------------\n\nTITLE: Using Value Semantics with MyPet Struct in Mojo\nDESCRIPTION: Demonstrates how to use the synthesized copy constructor by creating and copying a MyPet instance.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/structs.mdx#2025-04-17_snippet_9\n\nLANGUAGE: mojo\nCODE:\n```\nvar dog = MyPet(\"Charlie\", 5)\nvar poodle = dog\nprint(poodle.name)\n```\n\n----------------------------------------\n\nTITLE: Variable Declaration Patterns with References in Mojo\nDESCRIPTION: Examples of different variable declaration patterns including copy operations, tuple unpacking, and reference binding with both explicit and inferred mutability.\nSOURCE: https://github.com/modular/max/blob/main/mojo/proposals/resyntaxing-arg-conventions-and-refs.md#2025-04-17_snippet_3\n\nLANGUAGE: mojo\nCODE:\n```\n    # Copy an element out of the list, like \"auto x = list[i]\" in C++.\n    var a = list[i]\n\n    # Unpack tuple elements with tuple patterns:\n    var (a1, a2) = list[i]\n\n    # Bind a ref to an element in the list, like \"auto &x = mutlist[i]\" in C++.\n    var (ref b) = mutlist[i]\n    b += \"foo\"\n\n    # I don't see a reason not to allow `ref` in \"target\" syntax, so let's do\n    # that too: \n    ref c = mutlist[i]\n    c += \"foo\"\n\n    # Parametric mutability automatically infers immutable vs mutable reference\n    # from the initializer.\n    ref d = immlist[i]\n    print(len(d))\n```\n\n----------------------------------------\n\nTITLE: Initializing Host Buffer with Sequential Values in Mojo\nDESCRIPTION: This snippet creates a host buffer, fills it with sequential values, and prints the result. It demonstrates buffer creation and data initialization on the CPU side.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/gpu/basics.mdx#2025-04-17_snippet_7\n\nLANGUAGE: mojo\nCODE:\n```\nalias dtype = DType.uint32\nalias blocks = 4\nalias threads = 4\nalias elements_in = blocks * threads\n\nvar host_in_buffer = ctx.enqueue_create_host_buffer[dtype](elements_in)\n\nctx.synchronize()\n\niota(host_in_buffer.unsafe_ptr(), elements_in)\nprint(host_in_buffer)\n```\n\n----------------------------------------\n\nTITLE: Advanced Parametric Mutability Example in Mojo\nDESCRIPTION: Demonstration of parametric mutability propagation through function signatures and local references using a struct example.\nSOURCE: https://github.com/modular/max/blob/main/mojo/proposals/resyntaxing-arg-conventions-and-refs.md#2025-04-17_snippet_4\n\nLANGUAGE: mojo\nCODE:\n```\nstruct Aggregate:\n    var field: String\n\nfn complicated(ref [_] agg: Aggregate) -> ref [agg.field] String:\n    ref field = agg.field  # automatically propagates mutability\n    print(field)\n    return field\n```\n\n----------------------------------------\n\nTITLE: Typed String Greeting Function (fn)\nDESCRIPTION: Demonstrates an fn function with required type annotations and stricter rules.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/functions.mdx#2025-04-17_snippet_6\n\nLANGUAGE: mojo\nCODE:\n```\nfn greet(name: String) -> String:\n    var greeting = \"Hello, \" + name + \"!\"\n    return greeting\n```\n\n----------------------------------------\n\nTITLE: Creating and Using a String-based Dictionary in Mojo\nDESCRIPTION: Demonstrates how to create a custom StringKey wrapper type that conforms to the KeyElement trait and use it to create a dictionary mapping strings to integers.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_129\n\nLANGUAGE: mojo\nCODE:\n```\nfrom collections.dict import Dict, KeyElement\n\n@value\nstruct StringKey(KeyElement):\n    var s: String\n\n    fn __init__(inout self, owned s: String):\n        self.s = s ^\n\n    fn __init__(inout self, s: StringLiteral):\n        self.s = String(s)\n\n    fn __hash__(self) -> Int:\n        return hash(self.s)\n\n    fn __eq__(self, other: Self) -> Bool:\n        return self.s == other.s\n\nfn main() raises:\n    var d = Dict[StringKey, Int]()\n    d[\"cats\"] = 1\n    d[\"dogs\"] = 2\n    print(len(d))         # prints 2\n    print(d[\"cats\"])      # prints 1\n    print(d.pop(\"dogs\"))  # prints 2\n    print(len(d))         # prints 1\n```\n\n----------------------------------------\n\nTITLE: Using Basic Variables in Mojo\nDESCRIPTION: Demonstrates declaring variables implicitly by assignment and using them in calculations.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/basics.mdx#2025-04-17_snippet_1\n\nLANGUAGE: mojo\nCODE:\n```\ndef main():\n    x = 10\n    y = x * x\n    print(y)\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Block and Thread Indexing in Mojo GPU Kernel\nDESCRIPTION: This kernel prints the block and thread indices to demonstrate how blocks and threads are organized in GPU execution.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/gpu/basics.mdx#2025-04-17_snippet_6\n\nLANGUAGE: mojo\nCODE:\n```\nfn block_kernel():\n    print(\n        \"block: [\",\n        block_idx.x,\n        block_idx.y,\n        block_idx.z,\n        \"]\",\n        \"thread: [\",\n        thread_idx.x,\n        thread_idx.y,\n        thread_idx.z,\n        \"]\"\n    )\n\nctx.enqueue_function[block_kernel](grid_dim=(2, 2), block_dim=2)\nctx.synchronize()\n```\n\n----------------------------------------\n\nTITLE: Handling Python Module Import Errors in Mojo\nDESCRIPTION: This code shows how error messages from Python are now exposed in Mojo. It demonstrates trying to import a non-existent Python module and catching the resulting error.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_172\n\nLANGUAGE: mojo\nCODE:\n```\nfn main():\n    try:\n        let my_module = Python.import_module(\"my_uninstalled_module\")\n    except e:\n        print(e)\n```\n\n----------------------------------------\n\nTITLE: Conditional Conformances Implementation in Mojo\nDESCRIPTION: Shows how to implement conditional conformances in Mojo structures where methods can have additional trait requirements beyond what the struct requires. The example demonstrates type constraints on method parameters.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_46\n\nLANGUAGE: mojo\nCODE:\n```\nstruct GenericThing[Type: AnyType]:  # Works with anything\n  # Sugar for 'fn normal_method[Type: AnyType](self: GenericThing[Type]):\n  fn normal_method(self): ...\n\n  # Just redeclare the requirements with more specific types:\n  fn needs_move[Type: Movable](self: GenericThing[Type], owned val: Type):\n    var tmp = val^  # Ok to move 'val' since it is Movable\n    ...\nfn usage_example():\n  var a = GenericThing[Int]()\n  a.normal_method() # Ok, Int conforms to AnyType\n  a.needs_move(42)  # Ok, Int is movable\n\n  var b = GenericThing[NonMovable]()\n  b.normal_method() # Ok, NonMovable conforms to AnyType\n\n    # error: argument type 'NonMovable' does not conform to trait 'Movable'\n  b.needs_move(NonMovable())\n```\n\n----------------------------------------\n\nTITLE: Using Compile-Time Function Execution in Mojo\nDESCRIPTION: Demonstrates the ability to use functions like `count_leading_zeros` at compile time, as referenced in Issue #933.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_36\n\nLANGUAGE: mojo\nCODE:\n```\ncount_leading_zeros\n```\n\n----------------------------------------\n\nTITLE: Using Assert Almost Equal for Floating Point Comparisons\nDESCRIPTION: Example of using assert_almost_equal to compare floating point values with a tolerance. This assertion fails because the difference between the values exceeds the specified absolute tolerance.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/tools/testing.mdx#2025-04-17_snippet_4\n\nLANGUAGE: mojo\nCODE:\n```\nresult = 10 / 3\nassert_almost_equal(result, 3.33, atol=0.001, msg=\"close but no cigar\")\n```\n\n----------------------------------------\n\nTITLE: Variadic __setitem__ Implementation in Mojo\nDESCRIPTION: Demonstrates the implementation of __setitem__ with variadic argument lists. The compiler passes the new value being set as the last keyword argument to __setitem__.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_49\n\nLANGUAGE: mojo\nCODE:\n```\nstruct YourType:\n    fn __setitem__(inout self, *indices: Int, val: Int): ...\n```\n\n----------------------------------------\n\nTITLE: Using Implicit and Explicit Conversions in Mojo\nDESCRIPTION: This example shows how to use the implicit conversion constructor for Int and the explicit conversion for Float64. It demonstrates that Int can be implicitly converted to MyInt, while Float64 requires explicit conversion.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/decorators/implicit.md#2025-04-17_snippet_1\n\nLANGUAGE: mojo\nCODE:\n```\nfn func(n: MyInt):\n    print(\"MyInt value: \", n.value)\n\nfn main():\n    func(Int(42))             # Implicit conversion from Int: OK\n    func(MyInt(Float64(4.2))) # Explicit conversion from Float64: OK\n    func(Float64(4.2))        # Error: can't convert Float64 to MyInt\n```\n\n----------------------------------------\n\nTITLE: Argument Exclusivity Violation Example in Mojo\nDESCRIPTION: Demonstrates how Mojo diagnoses argument exclusivity violations when references are aliased. The example shows an invalid case where the same string is passed as both a borrowed and an inout parameter.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_45\n\nLANGUAGE: mojo\nCODE:\n```\nfn take_two_strings(a: String, inout b: String):\n   # Mojo knows 'a' and 'b' cannot be the same string.\n   b += a\n\nfn invalid_access():\n  var my_string = String()\n\n  # warning: passing `my_string` inout is invalid since it is also passed\n  # borrowed.\n  take_two_strings(my_string, my_string)\n```\n\n----------------------------------------\n\nTITLE: Importing an Entire Mojo Module\nDESCRIPTION: This example demonstrates how to import an entire Mojo module and access its members through the module name in the main program.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/packages.md#2025-04-17_snippet_2\n\nLANGUAGE: mojo\nCODE:\n```\nimport mymodule\n\nfn main():\n    var mine = mymodule.MyPair(2, 4)\n    mine.dump()\n```\n\n----------------------------------------\n\nTITLE: Declaring Tuple Return Types in Mojo Functions\nDESCRIPTION: Shows two ways to explicitly declare the return type of a function that returns a tuple in Mojo.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/types.mdx#2025-04-17_snippet_13\n\nLANGUAGE: mojo\nCODE:\n```\ndef return_tuple_1() -> Tuple[Int, Int]:\n    return Tuple[Int, Int](1, 1)\n\ndef return_tuple_2() -> (Int, Int):\n    return (2, 2)\n```\n\n----------------------------------------\n\nTITLE: Creating a Tiled Layout Using blocked_product() in Mojo\nDESCRIPTION: Shows how to use the blocked_product() function to create a tiled layout by combining a tile layout with a tiler layout. It prints the input tile and tiler layouts, as well as the resulting tiled layout.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/layout/layouts.mdx#2025-04-17_snippet_7\n\nLANGUAGE: mojo\nCODE:\n```\n# Define 2x3 tile\nvar tile = Layout.col_major(3, 2)\n# Define a 2x5 tiler\nvar tiler = Layout.col_major(2, 5)\nvar blocked = blocked_product(tile, tiler)\n\nprint(\"Tile:\")\nprint_layout(tile)\nprint(\"\\nTiler:\")\nprint_layout(tiler)\nprint(\"\\nTiled layout:\")\nprint(blocked)\n```\n\nLANGUAGE: plaintext\nCODE:\n```\nTile:\n((3, 2):(1, 3))\n      0   1\n    +---+---+\n 0  | 0 | 3 |\n    +---+---+\n 1  | 1 | 4 |\n    +---+---+\n 2  | 2 | 5 |\n    +---+---+\n\nTiler:\n((2, 5):(1, 2))\n       0    1    2    3    4\n    +----+----+----+----+----+\n 0  |  0 |  2 |  4 |  6 |  8 |\n    +----+----+----+----+----+\n 1  |  1 |  3 |  5 |  7 |  9 |\n    +----+----+----+----+----+\n\nTiled layout:\n(((3, 2), (2, 5)):((1, 6), (3, 12)))\n```\n\n----------------------------------------\n\nTITLE: Directory Traversal with pathlib.Path in Mojo\nDESCRIPTION: Demonstrates directory traversal using the Path class from the pathlib module. The example recursively walks a directory tree, collecting file paths, and demonstrates the new listdir(), is_dir(), and is_file() methods.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_123\n\nLANGUAGE: mojo\nCODE:\n```\nfrom pathlib import Path\n\nfn walktree(top: Path, inout files: DynamicVector[Path]):\n    try:\n        var ls = top.listdir()\n        for i in range(len(ls)):\n            var child = top / ls[i]\n            if child.is_dir():\n                walktree(child, files)\n            elif child.is_file():\n                files.append(child)\n            else:\n                print(\"Skipping '\" + str(child) + \"'\")\n    except:\n        return\n\nfn main():\n    var files = DynamicVector[Path]()\n\n    walktree(Path(\"/tmp\"), files)\n\n    for i in range(len(files)):\n        print(files[i])\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Variadic Arguments in Mojo\nDESCRIPTION: Example showing function signature with variadic positional and keyword arguments using single and double star syntax.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/lib.mdx#2025-04-17_snippet_1\n\nLANGUAGE: mojo\nCODE:\n```\ndef myfunc2(*names, **attributes):\n```\n\n----------------------------------------\n\nTITLE: Running MAX Engine Example with Magic\nDESCRIPTION: Command to run the BERT inference example using the magic tool, which simplifies the execution process.\nSOURCE: https://github.com/modular/max/blob/main/examples/inference/bert-python-torchscript/README.md#2025-04-17_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\n# Run the MAX Engine example\nmagic run bash run.sh\n# Run the MAX Serving example\nmagic run bash deploy.sh\n```\n\n----------------------------------------\n\nTITLE: Complete BERT Inference Execution Workflow\nDESCRIPTION: Full sequence of commands to run the BERT inference example, including downloading the model, pre-processing text input, running the C inference executable, and post-processing the results.\nSOURCE: https://github.com/modular/max/blob/main/examples/inference/bert-c-torchscript/README.md#2025-04-17_snippet_5\n\nLANGUAGE: sh\nCODE:\n```\npython3 ../common/bert-torchscript/download-model.py\npython3 pre-process.py --text \"Your text\"\n./build/bert ../../models/bert.torchscript\npython3 post-process.py\n```\n\n----------------------------------------\n\nTITLE: Parametric For Loops in Mojo\nDESCRIPTION: Introduction to @parameter for loops in Mojo, a new compile-time programming feature that requires both the sequence and induction values to be parameter values. Useful for metaprogramming and compile-time code generation.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_74\n\nLANGUAGE: mojo\nCODE:\n```\nfn parameter_for[max: Int]():\n    @parameter\n    for i in range(max)\n        @parameter\n        if i == 10:\n            print(\"found 10!\")\n```\n\n----------------------------------------\n\nTITLE: Basic String Greeting Function\nDESCRIPTION: Demonstrates a simple def function without type annotations, similar to Python style.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/functions.mdx#2025-04-17_snippet_4\n\nLANGUAGE: mojo\nCODE:\n```\ndef greet(name):\n    greeting = \"Hello, \" + name + \"!\"\n    return greeting\n```\n\n----------------------------------------\n\nTITLE: Accessing Parametric Type Values Directly in Mojo\nDESCRIPTION: This snippet demonstrates how input parameters of a parametric type can be directly accessed as attribute references on the type or variables of the type in Mojo.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_170\n\nLANGUAGE: mojo\nCODE:\n```\n@value\nstruct Thing[param: Int]:\n    pass\n\nfn main():\n    print(Thing[2].param) # prints '2'\n    let x = Thing[9]()\n    print(x.param) # prints '9'\n```\n\n----------------------------------------\n\nTITLE: Iterating Over LinkedList Elements in Mojo\nDESCRIPTION: Demonstrates how to iterate over elements in a LinkedList using the new __iter__() method.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_4\n\nLANGUAGE: mojo\nCODE:\n```\nvar ll = LinkedList[Int](1, 2, 3)\nfor element in ll:\n  print(element[])\n```\n\n----------------------------------------\n\nTITLE: Defining SIMD Struct with Requirements in Mojo\nDESCRIPTION: This code snippet shows the definition of a SIMD struct in Mojo with specific requirements for the size and data type parameters. It demonstrates how requirements can be used to enforce constraints on struct parameters.\nSOURCE: https://github.com/modular/max/blob/main/mojo/proposals/requires-clause.md#2025-04-17_snippet_7\n\nLANGUAGE: mojo\nCODE:\n```\nstruct SIMD[dtype: DType, size: Int]\n    requires size.is_power_of_two(), \"simd width must be power of 2\"\n    requires dtype is not DType.invalid, \"simd type cannot be DType.invalid\"\n```\n\n----------------------------------------\n\nTITLE: Example of Using Partially Bound Types in Mojo\nDESCRIPTION: Shows how to instantiate a partially bound type where some parameters must be explicitly specified. The example demonstrates that default values aren't applied to parameters that were explicitly unbound.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_118\n\nLANGUAGE: mojo\nCODE:\n```\nalias last_bound = StructWithDefault[*_, 6]\n# When using last_bound, you must specify a, b, and c. last_bound\n# doesn't have a default value for `c`.\nvar s = last_bound[1, 2, 3]()\n```\n\n----------------------------------------\n\nTITLE: Explicit Trait Conformance Declaration in Mojo\nDESCRIPTION: Demonstrates the recommended way to explicitly declare trait conformance for a struct, which is useful for documentation and future language features.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_98\n\nLANGUAGE: mojo\nCODE:\n```\n@value\nstruct Foo(Stringable): ...\n```\n\n----------------------------------------\n\nTITLE: Simplified Reference Argument Syntax\nDESCRIPTION: Example showing the simplified syntax for `ref` function arguments without an explicit origin clause, which are now treated as `ref [_]`, making it more convenient to define functions that take and return references.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_32\n\nLANGUAGE: mojo\nCODE:\n```\nfn takes_and_return_ref(ref a: String) -> ref [a] String:\n    return a\n```\n\n----------------------------------------\n\nTITLE: Reading File Directly into DTypePointer in Mojo\nDESCRIPTION: Example of using the enhanced FileHandle.read() method to read file content directly into a DTypePointer, enabling efficient data loading for numerical applications.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_95\n\nLANGUAGE: mojo\nCODE:\n```\nvar file = open(\"/tmp/example.txt\", \"r\")\n\n# Allocate and load 8 elements\nvar ptr = DTypePointer[DType.float32].alloc(8)\nvar bytes = file.read(ptr, 8)\nprint(\"bytes read\", bytes)\nprint(ptr.load[width=8]())\n```\n\n----------------------------------------\n\nTITLE: Enqueueing GPU Function Directly in Mojo\nDESCRIPTION: Demonstrates how to enqueue a GPU function directly without compiling it first, using DeviceContext.enqueue_function(). This method incurs some overhead, so it's not recommended for frequent reuse.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_1\n\nLANGUAGE: mojo\nCODE:\n```\nfrom gpu.host import DeviceContext\n\nfn func():\n    print(\"Hello from GPU\")\n\nwith DeviceContext() as ctx:\n    ctx.enqueue_function[func](grid_dim=1, block_dim=1)\n```\n\n----------------------------------------\n\nTITLE: MLIR Decorator Reflection in Mojo\nDESCRIPTION: Illustrates the planned implementation of compile-time metaprograms using MLIR integration for decorators in Mojo, allowing programmers to inspect and modify the IR of functions and types.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/roadmap.md#2025-04-17_snippet_1\n\nLANGUAGE: mojo\nCODE:\n```\nfn value(t: TypeSpec):\n    t.__copyinit__ = # synthesize dunder copyinit automatically\n\n@value\nstruct TrivialType: pass\n\nfn full_unroll(loop: mlir.Operation):\n    # unrolling of structured loop\n\nfn main():\n    @full_unroll\n    for i in range(10):\n        print(i)\n```\n\n----------------------------------------\n\nTITLE: Creating a Tiled Layout Using tile_to_shape() in Mojo\nDESCRIPTION: Demonstrates the use of the tile_to_shape() function to create a tiled layout. It takes a column-major 3x2 tile and tiles it to a 6x10 shape, resulting in the same layout as the previous example.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/layout/layouts.mdx#2025-04-17_snippet_6\n\nLANGUAGE: mojo\nCODE:\n```\nvar tts = tile_to_shape(Layout.col_major(3, 2), IntTuple(6, 10))\nprint_layout(tts)\n```\n\nLANGUAGE: plaintext\nCODE:\n```\n(((3, 2), (2, 5)):((1, 6), (3, 12)))\n       0    1    2    3    4    5    6    7    8    9\n    +----+----+----+----+----+----+----+----+----+----+\n 0  |  0 |  3 | 12 | 15 | 24 | 27 | 36 | 39 | 48 | 51 |\n    +----+----+----+----+----+----+----+----+----+----+\n 1  |  1 |  4 | 13 | 16 | 25 | 28 | 37 | 40 | 49 | 52 |\n    +----+----+----+----+----+----+----+----+----+----+\n 2  |  2 |  5 | 14 | 17 | 26 | 29 | 38 | 41 | 50 | 53 |\n    +----+----+----+----+----+----+----+----+----+----+\n 3  |  6 |  9 | 18 | 21 | 30 | 33 | 42 | 45 | 54 | 57 |\n    +----+----+----+----+----+----+----+----+----+----+\n 4  |  7 | 10 | 19 | 22 | 31 | 34 | 43 | 46 | 55 | 58 |\n    +----+----+----+----+----+----+----+----+----+----+\n 5  |  8 | 11 | 20 | 23 | 32 | 35 | 44 | 47 | 56 | 59 |\n    +----+----+----+----+----+----+----+----+----+----+\n```\n\n----------------------------------------\n\nTITLE: String Copying with Owned Arguments in Mojo\nDESCRIPTION: Demonstrates how owned arguments work when copying strings, showing that the original string remains unchanged when not using the transfer sigil.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/values/ownership.mdx#2025-04-17_snippet_7\n\nLANGUAGE: mojo\nCODE:\n```\nfn take_text(owned text: String):\n    text += \"!\"\n    print(text)\n\nfn my_function():\n    var message: String = \"Hello\"\n    take_text(message)\n    print(message)\n\nmy_function()\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Partial Automatic Parameterization in Mojo\nDESCRIPTION: Shows how Mojo handles partial automatic parameterization with struct parameters using the Fudge example struct, including implicit and explicit parameter binding.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_146\n\nLANGUAGE: mojo\nCODE:\n```\n@value\nstruct Fudge[a: Int, b: Int, c: Int = 7]: ...\n\n# These function declarations are roughly equivalent:\nfn eat(f: Fudge[5]): ...               # implicitly parameterized\nfn eat[_b: Int](f: Fudge[5, _b]): ...  # explicitly parameterized\n```\n\n----------------------------------------\n\nTITLE: Inspecting Input and Output Metadata of ONNX Model in Python\nDESCRIPTION: This code snippet demonstrates how to inspect the input and output metadata of the loaded ONNX model. It prints the name, shape, and data type of each input and output tensor.\nSOURCE: https://github.com/modular/max/blob/main/examples/notebooks/gemma2b-python-onnx.ipynb#2025-04-17_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nfor tensor in maxmodel.input_metadata:\n    print(f'name: {tensor.name}, shape: {tensor.shape}, dtype: {tensor.dtype}')\n\nfor tensor in maxmodel.output_metadata:\n    print(f'name: {tensor.name}, shape: {tensor.shape}, dtype: {tensor.dtype}')\n```\n\n----------------------------------------\n\nTITLE: Generating Text with Vanilla Transformers\nDESCRIPTION: Demonstrates text generation using the Gemma-2B model with the standard Transformers library from Hugging Face.\nSOURCE: https://github.com/modular/max/blob/main/examples/notebooks/gemma2b-python-onnx.ipynb#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n%%time\n\nimport torch\nfrom transformers import AutoTokenizer, AutoModelForCausalLM\n\nPROMPT = \"Why did the chicken cross the road?\"\nhf_path = \"google/gemma-2b\"\nhfmodel = AutoModelForCausalLM.from_pretrained(hf_path)\nhftokenizer = AutoTokenizer.from_pretrained(hf_path)\nhftokenizer.pad_token = hftokenizer.eos_token\n\n# Tokenize the text prompt\ninput_ids = hftokenizer(PROMPT, return_tensors=\"pt\", max_length=128, truncation=True)\n\n# Run generation\nout_ids = hfmodel.generate(**input_ids, max_new_tokens=15, do_sample=False)\n\n# De-tokenize the generated response\nresponse = hftokenizer.batch_decode(out_ids, skip_special_tokens=True)[0][len(PROMPT):]\nprint(\"Response:\", response)\n```\n\n----------------------------------------\n\nTITLE: Parallel Multiplication Kernel in Mojo GPU Programming\nDESCRIPTION: This kernel multiplies each value in the input tensor by a constant factor, demonstrating parallel computation on the GPU.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/gpu/basics.mdx#2025-04-17_snippet_11\n\nLANGUAGE: mojo\nCODE:\n```\nfn multiply_kernel[multiplier: Int](in_tensor: InputLayoutTensor):\n    in_tensor[block_idx.x, thread_idx.x] *= multiplier\n\nctx.enqueue_function[multiply_kernel[2]](\n    in_tensor,\n    grid_dim=blocks,\n    block_dim=threads,\n)\n\ndevice_in_buffer.enqueue_copy_to(host_in_buffer)\nctx.synchronize()\n\nvar host_tensor = LayoutTensor[dtype, layout](host_in_buffer)\nprint(host_tensor)\n```\n\n----------------------------------------\n\nTITLE: Creating Nested IntTuples in Mojo\nDESCRIPTION: Shows how to create nested IntTuples to represent hierarchical shapes for layouts.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/layout/layouts.mdx#2025-04-17_snippet_3\n\nLANGUAGE: mojo\nCODE:\n```\nvar shape1 = IntTuple(4, IntTuple(2, 2))\n```\n\n----------------------------------------\n\nTITLE: Creating an Ordered Layout Using make_ordered_layout() in Mojo\nDESCRIPTION: Demonstrates the use of make_ordered_layout() function to create a layout with a specific shape and iteration order. This example creates the same tiled layout as previous examples but specifies the order of dimension traversal.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/layout/layouts.mdx#2025-04-17_snippet_8\n\nLANGUAGE: mojo\nCODE:\n```\nvar ordered = make_ordered_layout(\n    IntTuple(IntTuple(3, 2), IntTuple(2, 5)), # shape\n    IntTuple(IntTuple(0, 2), IntTuple(1, 3))  # order\n)\nprint(ordered)\n```\n\nLANGUAGE: plaintext\nCODE:\n```\n(((3, 2), (2, 5)):((1, 6), (3, 12)))\n```\n\n----------------------------------------\n\nTITLE: Compiling and Enqueueing GPU Function for Multiple Launches in Mojo\nDESCRIPTION: Shows how to compile a GPU function first and then enqueue it multiple times, which is more efficient for repeated use with the same parameters.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_2\n\nLANGUAGE: mojo\nCODE:\n```\nwith DeviceContext() as ctx:\n  var compiled_func = ctx.compile_function[func]()\n  # Multiple kernel launches with the same function/parameters\n  ctx.enqueue_function(compiled_func, grid_dim=1, block_dim=1)\n  ctx.enqueue_function(compiled_func, grid_dim=1, block_dim=1)\n```\n\n----------------------------------------\n\nTITLE: Using the Updated Elementwise Function in Mojo\nDESCRIPTION: Example showing the new parameter order for the elementwise() function, where the rank parameter can now be inferred.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_108\n\nLANGUAGE: mojo\nCODE:\n```\nelementwise[func, simd_width](shape)\n```\n\n----------------------------------------\n\nTITLE: Alternative: Special Separator Parameter\nDESCRIPTION: Demonstrates an alternative syntax using a special separator to distinguish between inferred and required parameters.\nSOURCE: https://github.com/modular/max/blob/main/mojo/proposals/inferred-parameters.md#2025-04-17_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nfn scalar_param[dt: DType, %%%, x: Scalar[dt]](): pass\n```\n\n----------------------------------------\n\nTITLE: Using @implicit Decorator for Single-Argument Constructors\nDESCRIPTION: Example showing how to enable implicit type conversion using the `@implicit` decorator on a single-argument constructor, allowing an `Int` to be implicitly converted to a `Foo` when passed to a function expecting a `Foo`.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_29\n\nLANGUAGE: mojo\nCODE:\n```\nstruct Foo:\n    var value: Int\n\n    @implicit\n    fn __init__(out self, value: Int):\n        self.value = value\n```\n\n----------------------------------------\n\nTITLE: Using the Reference Type for Safe Memory Access\nDESCRIPTION: Demonstrates Mojo's prototype Reference type for safe, lifetime-tracked memory access. References must be explicitly dereferenced with empty brackets.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_133\n\nLANGUAGE: mojo\nCODE:\n```\nfn main():\n    var a: String = \"hello\"\n    var b: String = \" references\"\n\n    var aref = Reference(a)\n    aref[] += b\n    print(a)  # prints \"hello references\"\n\n    aref[] += b\n    # ^last use of b, it is destroyed here.\n\n    print(aref[]) # prints \"hello references references\"\n    # ^last use of a, it is destroyed here.\n```\n\n----------------------------------------\n\nTITLE: Declaring Associated Types in Mojo Traits\nDESCRIPTION: Demonstrates the syntax for declaring associated type aliases within traits, allowing for more flexible generic programming with trait conformance.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_38\n\nLANGUAGE: mojo\nCODE:\n```\nalias T: AnyType\n```\n\nLANGUAGE: mojo\nCODE:\n```\nalias N: Int\n```\n\n----------------------------------------\n\nTITLE: Using Updated Load and Store Methods in Mojo Buffers\nDESCRIPTION: Examples showing the updated syntax for load() and store() methods that replace the previous simd_load() and simd_store() methods, using keyword parameters for width and alignment.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_107\n\nLANGUAGE: mojo\nCODE:\n```\n# Doesn't work\nmy_simd = my_buffer.simd_load[simd_width](index)\n# Works\nmy_simd = my_buffer.load[width=simd_width](index)\n# Doesn't work\nmy_buffer.aligned_simd_store[width, alignment](my_simd)\n# Works\nmy_buffer.store[width=width, alignment=alignment](my_simd)\n```\n\n----------------------------------------\n\nTITLE: Using Parameterized Struct\nDESCRIPTION: Example of instantiating a struct that uses a parameter to define its associated alias value.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/traits.mdx#2025-04-17_snippet_12\n\nLANGUAGE: mojo\nCODE:\n```\nrepeater = Multispeak[12]()\n```\n\n----------------------------------------\n\nTITLE: Updating UnsafePointer Offset Usage in Mojo\nDESCRIPTION: Shows the transition from using the deprecated offset() method to using pointer arithmetic for pointer manipulation.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_58\n\nLANGUAGE: mojo\nCODE:\n```\nnew_ptr = ptr.offset(1)\n\n# Becomes:\n\nnew_ptr = ptr + 1\n```\n\n----------------------------------------\n\nTITLE: Comparing Mojo Argument Conventions with Explicit Lifetimes\nDESCRIPTION: Demonstrates how Mojo's borrowed and inout argument conventions provide syntactic sugar over explicit lifetime declarations, showing both the simplified and long-hand versions.\nSOURCE: https://github.com/modular/max/blob/main/mojo/proposals/lifetimes-and-provenance.md#2025-04-17_snippet_6\n\nLANGUAGE: mojo\nCODE:\n```\n// Mojo today\nfn example(inout a: Int, borrowed b: Float32): …\n\nstruct S:\n  fn method(inout self): …\n\n// Written long-hand with explicit lifetimes.\nfn example[a_life: Lifetime, b_life: Lifetime]\n          (a: mutref[a_life] Int, b: ref[b_life] Float32): …\nstruct S:\n  fn method[self_life: Lifetime](self: mutref[self_life]): …\n```\n\n----------------------------------------\n\nTITLE: Using Inferred Parameter Values with Defaults in Mojo\nDESCRIPTION: This example shows how inferred parameter values take precedence over defaults in Mojo functions. It demonstrates a struct with a parametric value that gets passed to a function with default parameters.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_165\n\nLANGUAGE: mojo\nCODE:\n```\n@value\nstruct Bar[v: Int]:\n    pass\n\nfn foo[a: Int = 42, msg: StringLiteral = \"quack\"](bar: Bar[a]):\n    print(msg, a)\n\nfn main():\n    foo(Bar[9]())  # prints 'quack 9'\n```\n\n----------------------------------------\n\nTITLE: Using Struct Methods\nDESCRIPTION: Demonstrates how to call struct methods on an instance.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/structs.mdx#2025-04-17_snippet_4\n\nLANGUAGE: mojo\nCODE:\n```\nvar mine = MyPair(6, 8)\nprint(mine.get_sum())\n```\n\n----------------------------------------\n\nTITLE: Running Mojo GPU Examples with Magic Commands\nDESCRIPTION: Shell commands to execute the four Mojo GPU example programs. Each command runs a different GPU computation example using the Magic command runner.\nSOURCE: https://github.com/modular/max/blob/main/examples/gpu_functions/README.md#2025-04-17_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nmagic run vector_addition\nmagic run grayscale\nmagic run naive_matrix_multiplication\nmagic run mandelbrot\n```\n\n----------------------------------------\n\nTITLE: Model Input Specification\nDESCRIPTION: Defines input specifications required for MAX Engine model compilation.\nSOURCE: https://github.com/modular/max/blob/main/examples/notebooks/roberta-python-pytorch.ipynb#2025-04-17_snippet_5\n\nLANGUAGE: python\nCODE:\n```\ninput_spec_list = [\n    engine.TorchInputSpec(shape=tensor.size(), dtype=DType.int64)\n    for tensor in inputs.values()\n]\n```\n\n----------------------------------------\n\nTITLE: Declaring and Returning a String in Mojo\nDESCRIPTION: This snippet demonstrates how to declare a function with a String return type and return a string literal.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/functions.mdx#2025-04-17_snippet_21\n\nLANGUAGE: mojo\nCODE:\n```\ndef get_greeting() -> String:\n    return \"Hello\"\n```\n\n----------------------------------------\n\nTITLE: Demonstrating @__copy_capture Usage in Mojo\nDESCRIPTION: This code snippet demonstrates how to use the @__copy_capture decorator in Mojo to capture a value by copy in a nested function. It shows how the captured value remains unchanged even when the original variable is modified.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/decorators/copy-capture.md#2025-04-17_snippet_0\n\nLANGUAGE: mojo\nCODE:\n```\nfn foo(x: Int):\n    var z = x\n\n    @__copy_capture(z)\n    @parameter\n    fn formatter() -> Int:\n        return z\n    z = 2\n    print(formatter())\n\nfn main():\n    foo(5)\n```\n\n----------------------------------------\n\nTITLE: Using Parameter Results in Mojo Functions\nDESCRIPTION: Demonstrates the proper way to use parameter results in Mojo, using forward declarations with alias and binding in a call with an arrow.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_225\n\nLANGUAGE: mojo\nCODE:\n```\nalias a: __mlir_type.index\nalias b: __mlir_type.index\nidx_result_params[xyz * 2 -> a, b]()\n```\n\n----------------------------------------\n\nTITLE: Calling Functions in Parameter Context in Mojo\nDESCRIPTION: Shows how functions can now be called in a parameter context, evaluating the function at compile time and using the result as parameter values.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_226\n\nLANGUAGE: mojo\nCODE:\n```\nfn fma(x: Int, y: Int, z: Int) -> Int:\n    return a + b * c\n\nfn parameter_call():\n    alias nelts = fma(32, 2, 16)\n    var x: SIMD[f32, nelts]\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Lifetime Extension in Mojo\nDESCRIPTION: This snippet demonstrates how a reference in Mojo extends the lifetime of a value until all references to it are used. The StringRef contains a reference to some_str, preventing its destruction until after the last use of some_str_ref.\nSOURCE: https://github.com/modular/max/blob/main/mojo/proposals/lifetimes-and-provenance.md#2025-04-17_snippet_0\n\nLANGUAGE: mojo\nCODE:\n```\n    var some_str = String(\"hello\")\n\n    # The StringRef contains a reference to the some_str value\n    var some_str_ref = StringRef(some_str)\n\n    # Last use of some_str, but don't destroy it because there is a use of\n    # the reference below!\n    use(some_str)\n\n    # References must be propagatable through methods.\n    some_str_ref = some_str_ref.drop_front().drop_back()\n    print(some_str_ref)                                   # Prints \"ell\"\n    # some_str destroyed here after last reference to it\n```\n\n----------------------------------------\n\nTITLE: Printing a 3x4 Row-Major Layout in Mojo\nDESCRIPTION: Creates a 3x4 row-major layout and uses the print_layout() function to generate an ASCII diagram of the layout.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/layout/layouts.mdx#2025-04-17_snippet_1\n\nLANGUAGE: mojo\nCODE:\n```\nvar l3x4row_major = Layout.row_major(3, 4)\nprint_layout(l3x4row_major)\n```\n\n----------------------------------------\n\nTITLE: Using the @nonmaterializable Decorator in Mojo\nDESCRIPTION: Demonstrates the use of the @nonmaterializable decorator to mark data types that should only exist in the parameter domain. When materialized, these types are automatically converted to the specified target type.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_177\n\nLANGUAGE: mojo\nCODE:\n```\n@value\n@register_passable(\"trivial\")\nstruct HasBool:\n    var x: Bool\n    fn __init__(x: Bool) -> Self:\n        return Self {x: x}\n    @always_inline(\"nodebug\")\n    fn __init__(nms: NmStruct) -> Self:\n        return Self {x: True if (nms.x == 77) else False}\n\n@value\n@nonmaterializable(HasBool)\n@register_passable(\"trivial\")\nstruct NmStruct:\n    var x: Int\n    @always_inline(\"nodebug\")\n    fn __add__(self: Self, rhs: Self) -> Self:\n        return NmStruct(self.x + rhs.x)\n\nalias stillNmStruct = NmStruct(1) + NmStruct(2)\n# When materializing to a run-time variable, it is automatically converted,\n# even without a type annotation.\nlet convertedToHasBool = stillNmStruct\n```\n\n----------------------------------------\n\nTITLE: Accessing Homogenous Tuple Elements in Mojo\nDESCRIPTION: Demonstrates the new simplified tuple indexing that produces consistent element types without requiring rebinding.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_8\n\nLANGUAGE: mojo\nCODE:\n```\nvar x = (1, 2, 3, 3, 4)\nvar y : Int = x[idx]     # Just works!\n```\n\n----------------------------------------\n\nTITLE: Iterating Over PythonObject Values in Mojo\nDESCRIPTION: Example showing how PythonObject.__iter__() now works with borrowed references instead of requiring inout, allowing for more idiomatic iteration over Python collections.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_109\n\nLANGUAGE: mojo\nCODE:\n```\nfor value in my_dict.values():\n  ...\n```\n\n----------------------------------------\n\nTITLE: Using Contextual Parameters in Struct Members in Mojo\nDESCRIPTION: Demonstrates how unqualified lookups of struct members apply contextual parameters, allowing static methods to be called without explicitly binding struct parameters.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_213\n\nLANGUAGE: mojo\nCODE:\n```\nstruct Foo[x: Int]:\n    @staticmethod\n    bar(): pass\n\n    foo(self):\n        bar()         # implicitly binds to Foo[x].bar()\n        Foo[2].bar()  # explicitly bind to another parameter\n```\n\n----------------------------------------\n\nTITLE: Compile-time Constant Computation in Mojo\nDESCRIPTION: Demonstrates the compiler's ability to interpret arithmetic operations from the index dialect for compile-time constant computation.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog.md#2025-04-17_snippet_4\n\nLANGUAGE: mojo\nCODE:\n```\nalias a: Int = 1000000000\nalias b: Int = (5 * a) // 2\n```\n\n----------------------------------------\n\nTITLE: Memory-Only Variadic Arguments in Mojo\nDESCRIPTION: Example of handling memory-only types (like String) in variadic arguments with pointer dereferencing.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/functions.mdx#2025-04-17_snippet_12\n\nLANGUAGE: mojo\nCODE:\n```\ndef make_worldly(mut *strs: String):\n    # Requires extra [] to dereference the pointer for now.\n    for i in strs:\n        i[] += \" world\"\n```\n\n----------------------------------------\n\nTITLE: Using the input() Function in Mojo\nDESCRIPTION: Demonstrates how to use the newly added input() function which behaves the same as in Python, reading user input and using it in string concatenation.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_52\n\nLANGUAGE: mojo\nCODE:\n```\nname = input(\"Enter your name: \")\nprint(\"Hello, \" + name + \"!\")\n```\n\n----------------------------------------\n\nTITLE: Using Read Arguments with Lists in Mojo\nDESCRIPTION: Demonstrates using a read (immutable) argument to print a list without modifying it. The function receives an immutable reference to avoid unnecessary copying.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/values/ownership.mdx#2025-04-17_snippet_1\n\nLANGUAGE: mojo\nCODE:\n```\nfrom collections import List\n\ndef print_list(list: List[Int]):\n    print(list.__str__())\n\nvar list = List(1, 2, 3, 4)\nprint_list(list)\n```\n\n----------------------------------------\n\nTITLE: Required Imports\nDESCRIPTION: Imports necessary Python modules for model handling and inference.\nSOURCE: https://github.com/modular/max/blob/main/examples/notebooks/roberta-python-pytorch.ipynb#2025-04-17_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom pathlib import Path\n\nimport torch\nfrom transformers import AutoTokenizer, AutoModelForSequenceClassification\n\nfrom max import engine\nfrom max.dtype import DType\n```\n\n----------------------------------------\n\nTITLE: Converting Model to ONNX Format\nDESCRIPTION: Using Optimum CLI to convert Mistral-7B model to ONNX format\nSOURCE: https://github.com/modular/max/blob/main/examples/notebooks/mistral7b-python-onnx.ipynb#2025-04-17_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n!optimum-cli export onnx --model \"mistralai/Mistral-7B-v0.1\" \"./onnx/mistral-7b-onnx\"\n```\n\n----------------------------------------\n\nTITLE: Using Tuple Type Syntax in Function Returns\nDESCRIPTION: Example of using tuple type syntax in function return types, allowing functions to return multiple values in a structured format.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_191\n\nLANGUAGE: mojo\nCODE:\n```\nfn return_tuple() -> (Int, Int):\n    return (1, 2)\n```\n\n----------------------------------------\n\nTITLE: Using 'ref' Convention for Self Parameter in Mojo\nDESCRIPTION: Shows how the 'ref' convention can replace defining 'self' as a Reference type, allowing for parametric mutability.\nSOURCE: https://github.com/modular/max/blob/main/mojo/proposals/ref-convention.md#2025-04-17_snippet_1\n\nLANGUAGE: mojo\nCODE:\n```\nfn __refitem__(ref [_] self, index: Int) -> Reference[\n        # This is a bit yuck, but is simplified further below.\n        Self.ElementType, __origin_of(self).is_mutable, __origin_of(self)\n    ]:\n```\n\nLANGUAGE: mojo\nCODE:\n```\nfn __refitem__[life: Lifetime](ref [life] self, index: Int) -> Reference[\n        # This is a bit yuck, see below.\n        Self.ElementType, life.is_mutable, life\n    ]:\n```\n\n----------------------------------------\n\nTITLE: Using Adaptive Function Overloads in Mojo\nDESCRIPTION: Example demonstrating how to use the @adaptive decorator for function overloads with signatures that differ only in declared parameter names.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_190\n\nLANGUAGE: mojo\nCODE:\n```\n@adaptive\nfn foobar[w: Int, T: DType]() -> SIMD[T, w]: ...\n\n@adaptive\nfn foobar[w: Int, S: DType]() -> SIMD[S, w]: ...\n```\n\n----------------------------------------\n\nTITLE: Using Multiple Arguments in ref Specifier\nDESCRIPTION: Example demonstrating the improved origin handling that allows multiple arguments in a `ref` specifier and support for the ternary operator, enabling clean expression of algorithms like finding the minimum of two values.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_31\n\nLANGUAGE: mojo\nCODE:\n```\nfn my_min[T: Comparable](ref a: T, ref b: T) -> ref [a, b] T:\n  return a if a < b else b\n```\n\n----------------------------------------\n\nTITLE: Correctly Returning an Immovable Object in Mojo\nDESCRIPTION: This function shows the correct way to return an ImmovableObject by creating and returning it in a single step.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/functions.mdx#2025-04-17_snippet_25\n\nLANGUAGE: mojo\nCODE:\n```\ndef create_immovable_object3(owned name: String) -> ImmovableObject:\n    return ImmovableObject(name^) # OK\n```\n\n----------------------------------------\n\nTITLE: Multi-dimensional Indexing and Slicing with PythonObject\nDESCRIPTION: Example showing how to perform multi-dimensional indexing and slicing with PythonObject when working with NumPy arrays.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_40\n\nLANGUAGE: mojo\nCODE:\n```\nvar np = Python.import_module(\"numpy\")\nvar a = np.array(PythonObject([1,2,3,4,5,6])).reshape(2,3)\nprint((a[0, 1])) # 2\nprint((a[1][::-1])) # [6 5 4]\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Default Behavior of Nested Functions in Mojo\nDESCRIPTION: Example showing how Mojo nested functions that capture values default to non-parametric runtime closures. The captured values are copied and immutable in the closure.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_195\n\nLANGUAGE: mojo\nCODE:\n```\ndef foo(x):\n    # This:\n    def bar(y): return x * y\n    # Is the same as:\n    let bar = lambda y: x * y\n```\n\n----------------------------------------\n\nTITLE: Using SIMD.cast() for Type Inference in Mojo\nDESCRIPTION: Demonstrates using the SIMD.cast() method to infer the size of the new vector when converting between data types.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_24\n\nLANGUAGE: mojo\nCODE:\n```\nvar inferred_size = float_vector.cast[DType.uint64]() # [42, 42, 42, 42]\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Parser Fixit Hints in Mojo\nDESCRIPTION: Illustrates the parser's new ability to generate 'fixit' hints on diagnostics, specifically when a dictionary literal uses an equals sign instead of a colon.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_224\n\nLANGUAGE: mojo\nCODE:\n```\nreturn __mlir_op.`lit.struct.create`[value = 42]()\n```\n\n----------------------------------------\n\nTITLE: For Loop Iterating Over Mojo Set\nDESCRIPTION: Shows how to iterate over a Mojo Set collection and access its elements.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/control-flow.mdx#2025-04-17_snippet_13\n\nLANGUAGE: mojo\nCODE:\n```\nfrom collections import Set\n\nvalues = Set[Int](42, 0)\nfor item in values:\n    print(item[])\n```\n\n----------------------------------------\n\nTITLE: Python-style Assignment in Functions\nDESCRIPTION: This Python example illustrates how assigning a new value to a function argument doesn't affect the original object, demonstrating the 'pass by object reference' behavior.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/values/value-semantics.mdx#2025-04-17_snippet_5\n\nLANGUAGE: python\nCODE:\n```\ndef change_list(l):\n    l = [3, 4]\n    print(\"func:\", l)\n\nar = [1, 2]\nchange_list(ar)\nprint(\"orig:\", ar)\n```\n\n----------------------------------------\n\nTITLE: Implementing ImplicitlyIntable Trait in Mojo\nDESCRIPTION: Demonstrates how to implement the ImplicitlyIntable trait to allow implicit conversion to Int type by implementing the __as_int__() method.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_20\n\nLANGUAGE: mojo\nCODE:\n```\n@value\nstruct Foo(ImplicitlyIntable):\n    var i: Int\n\n    fn __as_int__(self) -> Int:\n        return self.i\n```\n\n----------------------------------------\n\nTITLE: Buffered Writing Example\nDESCRIPTION: Shows how to use write_buffered with a Writer to efficiently append content to an existing string.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_16\n\nLANGUAGE: mojo\nCODE:\n```\nfrom utils.write import write_buffered\n\nvar string = String(\"existing string\")\nwrite_buffered(string, 42, 42.4, True, sep=\" \")\n```\n\n----------------------------------------\n\nTITLE: Optional Type Usage in Mojo\nDESCRIPTION: Demonstrates working with Optional types including initialization and value access.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/types.mdx#2025-04-17_snippet_19\n\nLANGUAGE: mojo\nCODE:\n```\nvar opt: Optional[String] = String(\"Testing\")\nif opt:\n    var value_ref = opt.value()\n    print(value_ref)\n```\n\n----------------------------------------\n\nTITLE: Running MAX Benchmark Comparison in Shell\nDESCRIPTION: Shell command to run benchmarks comparing the performance of GPU to CPU using the MAX framework. This command executes a benchmark script that likely tests the speed of various operations on both GPU and CPU.\nSOURCE: https://github.com/modular/max/blob/main/examples/custom_ops/README.md#2025-04-17_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\nmagic run benchmark\n```\n\n----------------------------------------\n\nTITLE: Inspecting Registers in CUDA-GDB\nDESCRIPTION: Example of using the 'info registers' command in CUDA-GDB to inspect the values of specific GPU registers during debugging.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/tools/gpu-debugging.mdx#2025-04-17_snippet_5\n\nLANGUAGE: plaintext\nCODE:\n```\n`info registers $R0 $R1\ninfo registers $R0 $R1\nR0             0xebfffda8          -335544920\nR1             0xfffda8            16776616\n```\n\n----------------------------------------\n\nTITLE: Importing a Mojo Module with an Alias\nDESCRIPTION: This snippet shows how to import a Mojo module with an alias using the 'as' keyword, allowing for shorter references to the module's members.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/packages.md#2025-04-17_snippet_3\n\nLANGUAGE: mojo\nCODE:\n```\nimport mymodule as my\n\nfn main():\n    var mine = my.MyPair(2, 4)\n    mine.dump()\n```\n\n----------------------------------------\n\nTITLE: Function Parameter Name Independence in Mojo\nDESCRIPTION: Demonstration of how parameter names are no longer load-bearing in function signatures, allowing flexibility in higher-order function definitions.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_205\n\nLANGUAGE: mojo\nCODE:\n```\n# Define a higher-order function...\nfn generator[\n    func: __mlir_type[`!kgen.signature<`, Int, `>() -> !kgen.none`]\n]():\n    pass\n\n# Int parameter is named \"foo\".\nfn f0[foo: Int]():\n    pass\n\n# Int parameter is named \"bar\".\nfn f1[bar: Int]():\n    pass\n\nfn main():\n    # Both can be used as `func`!\n    generator[f0]()\n    generator[f1]()\n```\n\n----------------------------------------\n\nTITLE: Updated Loop Unrolling Syntax in Mojo\nDESCRIPTION: Shows the transition from using the deprecated unroll utility to the new @parameter syntax for loop unrolling. Demonstrates both the old and new approach for comparison.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog.md#2025-04-17_snippet_1\n\nLANGUAGE: mojo\nCODE:\n```\nfrom utils.loop import unroll\n\n# Before\n@always_inline\n@parameter\nfn foo[i: Int]():\n    body_logic[i]()\nunroll[foo, iteration_range]()\n\n# After\n@parameter\nfor i in range(iteration_range):\n    body_logic[i]()\n```\n\n----------------------------------------\n\nTITLE: Variadic Arguments with Register-Passable Types\nDESCRIPTION: Shows how variadic arguments work with register-passable types like Int, which contain values rather than references and don't require dereferencing.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_132\n\nLANGUAGE: mojo\nCODE:\n```\nfn print_ints(*nums: Int):\n    for num in nums:\n        print(num)\n    print(len(nums))\n```\n\n----------------------------------------\n\nTITLE: Automatic Parameter Inference\nDESCRIPTION: Example demonstrating automatic parameterization where unbound parameters in a type are implicitly added to the function signature as infer-only parameters, simplifying code that uses parameterized types.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_35\n\nLANGUAGE: mojo\nCODE:\n```\nfn foo[value: SIMD[DType.int32, _]]():\n  pass\n\n# Equivalent to\nfn foo[size: Int, //, value: SIMD[DType.int32, size]]():\n  pass\n```\n\n----------------------------------------\n\nTITLE: Overloaded Keyword Arguments in Mojo Struct Initialization\nDESCRIPTION: Shows how to implement multiple initializers with different keyword-only arguments in a struct, allowing for flexible object construction patterns.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_9\n\nLANGUAGE: mojo\nCODE:\n```\nstruct OverloadedKwArgs:\n    var val: Int\n\n    fn __init__(out self, single: Int):\n        self.val = single\n\n    fn __init__(out self, *, double: Int):\n        self.val = double * 2\n\n    fn __init__(out self, *, triple: Int):\n        self.val = triple * 3\n\n    fn main():\n        OverloadedKwArgs(1)        # val=1\n        OverloadedKwArgs(double=1) # val=2\n        OverloadedKwArgs(triple=2) # val=6\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Dynamic Type Error Handling in Mojo\nDESCRIPTION: Example showing how the object type handles dynamic function dispatch and error handling when performing operations between incompatible types.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_203\n\nLANGUAGE: mojo\nCODE:\n```\ndef foo(a) -> object:\n    return (a + 3.45) < [1, 2, 3] # raises a TypeError\n```\n\n----------------------------------------\n\nTITLE: Self Lifetime Usage in Struct Methods\nDESCRIPTION: Demonstrates how to explicitly declare and use self lifetime in struct methods and how it composes with different calling contexts.\nSOURCE: https://github.com/modular/max/blob/main/mojo/proposals/lifetimes-and-provenance.md#2025-04-17_snippet_8\n\nLANGUAGE: mojo\nCODE:\n```\n    struct MyExample:\n        fn method[self_life: Lifetime](self: mutref[self_life] Self)\n                -> Pointer[Int, self_life]:\n            ...\n\n    fn callMethod(x: mutref[life1] MyExample):\n        use(x.method())\n\n        var y = MyExample()\n        use(y.method())\n```\n\n----------------------------------------\n\nTITLE: Documenting Structs in Mojo\nDESCRIPTION: Example showing how to document a struct with configuration properties.\nSOURCE: https://github.com/modular/max/blob/main/mojo/stdlib/docs/docstring-style-guide.md#2025-04-17_snippet_2\n\nLANGUAGE: mojo\nCODE:\n```\nstruct RuntimeConfig:\n\"\"\"\nSpecifies the Inference Engine configuration.\n\nConfiguration properties include the number threads, enabling telemetry,\nlogging level, etc.\n\"\"\"\n```\n\n----------------------------------------\n\nTITLE: Potential Dynamic Function Decoration in Mojo\nDESCRIPTION: This example illustrates a potential issue with dynamic function decoration in Mojo, raising questions about how to handle different levels of dynamism in function definitions.\nSOURCE: https://github.com/modular/max/blob/main/mojo/proposals/mojo-and-dynamism.md#2025-04-17_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n@dynamic\ndef bar(a): pass\n\ndef bar(a: Int): pass\n```\n\n----------------------------------------\n\nTITLE: Struct Constructor Without Implicit Conversion\nDESCRIPTION: Example of a single-argument constructor that no longer allows implicit conversion without the `@implicit` decorator. This shows the definition of a `Foo` struct with a constructor that takes an `Int` parameter.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_27\n\nLANGUAGE: mojo\nCODE:\n```\nstruct Foo:\n    var value: Int\n\n    fn __init__(out self, value: Int):\n        self.value = value\n```\n\n----------------------------------------\n\nTITLE: Implicit Conversion with Indexer Types\nDESCRIPTION: Shows how types conforming to the Indexer trait are implicitly convertible to Int, allowing generic APIs to accept Int instead of requiring a generic type parameter that conforms to Indexer.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_76\n\nLANGUAGE: mojo\nCODE:\n```\n@value\nstruct AlwaysZero(Indexer):\n    fn __index__(self) -> Int:\n        return 0\n\n@value\nstruct Incrementer:\n    fn __getitem__(self, idx: Int) -> Int:\n        return idx + 1\n\nvar a = Incrementer()\nprint(a[AlwaysZero()])  # works and prints 1\n```\n\n----------------------------------------\n\nTITLE: Tensor Save and Load Operations\nDESCRIPTION: Demonstrates how to save and load Tensor objects to/from files while preserving shape and datatype information.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_152\n\nLANGUAGE: mojo\nCODE:\n```\nlet tensor = Tensor[DType.float32]()\ntensor.save(path)\n\nlet tensor_from_file = Tensor[DType.float32].load(path)\n```\n\n----------------------------------------\n\nTITLE: Using Variable Scopes in Mojo For Loops\nDESCRIPTION: Example demonstrating variable scopes in Mojo, where loop iteration variables are now scoped to the loop body, allowing reuse of the same variable name in consecutive loops.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_197\n\nLANGUAGE: mojo\nCODE:\n```\nfor i in range(1): pass\nfor i in range(2): pass\n```\n\n----------------------------------------\n\nTITLE: Running Benchmark with Magic\nDESCRIPTION: Command to execute performance benchmark comparing both implementations by running 1,000 evolutions on a 1,024 x 1,024 grid.\nSOURCE: https://github.com/modular/max/blob/main/examples/mojo/life/README.md#2025-04-17_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nmagic run benchmark\n```\n\n----------------------------------------\n\nTITLE: Setting Up and Running YOLOv8 with Conda Environment\nDESCRIPTION: Commands to create a Conda environment, update it with dependencies from environment.yml, and run the example. These steps ensure proper isolation and dependency management.\nSOURCE: https://github.com/modular/max/blob/main/examples/inference/yolo-python-onnx/README.md#2025-04-17_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\n# Create a Conda environment if you don't have one\nconda create -n max-repo\n# Update the environment with the environment.yml file\nconda env update -n max-repo -f environment.yml --prune\n# Run the example\nconda run -n max-repo --live-stream bash run.sh\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Automatic Copy Elision in Mojo\nDESCRIPTION: This snippet shows how Mojo now automatically elides copies for non-trivial copyable values passed as owned without using the transfer operator, optimizing performance when there are no later uses of the value.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_193\n\nLANGUAGE: mojo\nCODE:\n```\nvar someValue: T = ...\n...\ntakeValueAsOwned(someValue)\n...\n```\n\n----------------------------------------\n\nTITLE: Pointer Array Access in Mojo\nDESCRIPTION: Shows how to access and modify values using pointer subscript syntax.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/pointers/unsafe-pointers.mdx#2025-04-17_snippet_17\n\nLANGUAGE: mojo\nCODE:\n```\nfloat_ptr[2] = 3.0\nfor offset in range(6):\n    print(float_ptr[offset], end=\", \")\n```\n\n----------------------------------------\n\nTITLE: Mojo Dependent Type Examples\nDESCRIPTION: Illustrates Mojo's use of dependent types in parameterized functions, showing both higher-order functions and scalar parameter functions.\nSOURCE: https://github.com/modular/max/blob/main/mojo/proposals/inferred-parameters.md#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfn higher_order_func[dt: DType, unary: fn(Scalar[dt]) -> Scalar[dt]](): pass\n\nfn scalar_param[dt: DType, x: Scalar[dt]](): pass\n```\n\n----------------------------------------\n\nTITLE: Using Hash Function for SIMD Types in Mojo\nDESCRIPTION: Demonstrates how to generate hash values for SIMD types using the internal _hash_simd() function, importing from the builtin.hash module.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_138\n\nLANGUAGE: mojo\nCODE:\n```\nfrom builtin.hash import _hash_simd\n\nfn gen_simd_hash():\n    let vector = SIMD[DType.int64, 4](1, 2, 3, 4)\n    let hash = _hash_simd(vector)\n```\n\n----------------------------------------\n\nTITLE: Using the cost_of Function in Autotune Module\nDESCRIPTION: Example of using the cost_of function from the Autotune module to determine the number of MLIR operations in a function at compile time, useful for building heuristics in higher-order generators.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_189\n\nLANGUAGE: mojo\nCODE:\n```\nfrom autotune import cost_of\n\nfn generator[f: fn(Int) -> Int]() -> Int:\n    @parameter\n    if cost_of[fn(Int) -> Int, f]() < 10:\n        return f()\n    else:\n        # Do something else for slower functions...\n```\n\n----------------------------------------\n\nTITLE: Installing Mojo Nightly Build with Magic CLI\nDESCRIPTION: Command for initializing a new Mojo project using the nightly build channel. It creates a project named 'hello-world-nightly' using the mojoproject format and configures it to use packages from conda-forge and the Mojo nightly package repository.\nSOURCE: https://github.com/modular/max/blob/main/mojo/README.md#2025-04-17_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nmagic init hello-world-nightly --format mojoproject \\\n  -c conda-forge -c https://conda.modular.com/max-nightly\n```\n\n----------------------------------------\n\nTITLE: Mojo Struct Initializer Using __init__\nDESCRIPTION: Example of traditional struct initialization style in Mojo where self is mutated directly within the __init__ method.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_207\n\nLANGUAGE: mojo\nCODE:\n```\nfn __init__(self, x: Int):\n    self.x = x\n```\n\n----------------------------------------\n\nTITLE: Creating and Returning an Immovable Object in Mojo\nDESCRIPTION: This snippet shows how to create and return an ImmovableObject using a named result, allowing for multi-step initialization.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/functions.mdx#2025-04-17_snippet_23\n\nLANGUAGE: mojo\nCODE:\n```\nstruct ImmovableObject:\n    var name: String\n\n    fn __init__(out self, owned name: String):\n        self.name = name^\n\ndef create_immovable_object(owned name: String, out obj: ImmovableObject):\n    obj = ImmovableObject(name^)\n    obj.name += \"!\"\n    # obj is implicitly returned\n\ndef main():\n    my_obj = create_immutable_object(\"Blob\")\n```\n\n----------------------------------------\n\nTITLE: Type Error Example in Mojo\nDESCRIPTION: Demonstrates type enforcement by showing an invalid type assignment that results in an error.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/variables.mdx#2025-04-17_snippet_2\n\nLANGUAGE: mojo\nCODE:\n```\ncount = 8 # count is type Int\ncount = \"Nine?\" # Error: can't implicitly convert 'StringLiteral' to 'Int'\n```\n\n----------------------------------------\n\nTITLE: Path Module Functions in Mojo\nDESCRIPTION: Implementation of a get_cwd_message function in the path.mojo file that returns the current working directory with a message\nSOURCE: https://github.com/modular/max/blob/main/mojo/stdlib/docs/development.md#2025-04-17_snippet_1\n\nLANGUAGE: mojo\nCODE:\n```\nfn get_cwd_message() raises -> String:\n    return \"Your cwd is: \" + cwd()\n```\n\n----------------------------------------\n\nTITLE: Extended Getitem Implementation with References\nDESCRIPTION: Shows how to implement reference-based item access for pointer types using the __getref__ method.\nSOURCE: https://github.com/modular/max/blob/main/mojo/proposals/lifetimes-and-provenance.md#2025-04-17_snippet_9\n\nLANGUAGE: mojo\nCODE:\n```\n    struct Pointer[type: AnyType, life: Lifetime]:\n        # This __getref__ returns a reference, so no setitem needed.\n        fn __getref__(self, offset: Int) -> mutref[life] type:\n            return __get_address_as_lvalue[life](...)\n```\n\n----------------------------------------\n\nTITLE: Using 'ref' in Result Positions in Mojo\nDESCRIPTION: Shows how to use the 'ref' convention in function return types to return an automatically dereferenced reference.\nSOURCE: https://github.com/modular/max/blob/main/mojo/proposals/ref-convention.md#2025-04-17_snippet_3\n\nLANGUAGE: mojo\nCODE:\n```\nfn __refitem__(ref [_] self, index: Int)\n    -> ref [self] Self.ElementType:\n```\n\nLANGUAGE: mojo\nCODE:\n```\nfn __refitem__(ref [_] self, index: Int)\n    -> ref [Lifetime(self)] Self.ElementType:\n```\n\n----------------------------------------\n\nTITLE: Lexical Scoping Example\nDESCRIPTION: Demonstrates lexical scoping behavior with explicitly declared variables using var.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/variables.mdx#2025-04-17_snippet_7\n\nLANGUAGE: mojo\nCODE:\n```\ndef lexical_scopes():\n    var num = 1\n    var dig = 1\n    if num == 1:\n        print(\"num:\", num)  # Reads the outer-scope \"num\"\n        var num = 2         # Creates new inner-scope \"num\"\n        print(\"num:\", num)  # Reads the inner-scope \"num\"\n        dig = 2             # Updates the outer-scope \"dig\"\n    print(\"num:\", num)      # Reads the outer-scope \"num\"\n    print(\"dig:\", dig)      # Reads the outer-scope \"dig\"\n\nlexical_scopes()\n```\n\n----------------------------------------\n\nTITLE: Implementing Hashable for Person Struct with New Design in Mojo\nDESCRIPTION: Demonstrates how to implement the redesigned Hashable trait for a Person struct, showing a simpler and more guided approach to hashing multiple fields.\nSOURCE: https://github.com/modular/max/blob/main/mojo/proposals/improved-hash-module.md#2025-04-17_snippet_5\n\nLANGUAGE: mojo\nCODE:\n```\n@value\nstruct Person(Hashable):\n    var name: String\n    var age: Int\n\n    fn __hash__[H: Hasher](self, mut hasher: H):\n        hasher.update(self.name)\n        hasher.update(self.age)\n```\n\n----------------------------------------\n\nTITLE: Keyword Arguments Usage in Mojo\nDESCRIPTION: Demonstrates how to use keyword arguments when calling functions, allowing arguments to be passed in any order.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/functions.mdx#2025-04-17_snippet_10\n\nLANGUAGE: mojo\nCODE:\n```\nfn my_pow(base: Int, exp: Int = 2) -> Int:\n    return base ** exp\n\nfn use_keywords():\n    # Uses keyword argument names (with order reversed)\n    var z = my_pow(exp=3, base=2)\n    print(z)\n```\n\n----------------------------------------\n\nTITLE: Setting up Conda environment for Stable Diffusion\nDESCRIPTION: Commands to create and configure a Conda environment for running the Stable Diffusion example with MAX Engine.\nSOURCE: https://github.com/modular/max/blob/main/examples/inference/stable-diffusion-python-onnx/README.md#2025-04-17_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\n# Create a Conda environment if you don't have one\nconda create -n max-repo\n# Update the environment with the environment.yml file\nconda env update -n max-repo -f environment.yml --prune\n# Run the example\nconda run -n max-repo --live-stream bash run.sh\n```\n\n----------------------------------------\n\nTITLE: Setting Up and Running with Conda Environment\nDESCRIPTION: Steps to create and configure a Conda environment for running the BERT inference example, including environment creation, dependency installation, and execution commands.\nSOURCE: https://github.com/modular/max/blob/main/examples/inference/bert-python-torchscript/README.md#2025-04-17_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\n# Create a Conda environment if you don't have one\nconda create -n max-repo\n# Update the environment with the environment.yml file\nconda env update -n max-repo -f environment.yml --prune\n# Run the example\nconda run -n max-repo --live-stream bash run.sh\n# Run the MAX Serving example\nconda run -n max-repo --live-stream bash deploy.sh\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Enqueue Scheduling in Mojo GPU Operations\nDESCRIPTION: This snippet shows how multiple GPU operations are scheduled and executed in the order they are enqueued, including kernel execution and data transfer.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/gpu/basics.mdx#2025-04-17_snippet_9\n\nLANGUAGE: mojo\nCODE:\n```\nalias size = 4\nalias dtype_u8 = DType.uint8\n\nfn dummy_kernel(buffer: UnsafePointer[Scalar[dtype_u8]]):\n    buffer[thread_idx.x] = thread_idx.x\n\nvar host_buffer = ctx.enqueue_create_host_buffer[dtype_u8](size)\nvar dev_buffer = ctx.enqueue_create_buffer[dtype_u8](size)\nctx.enqueue_function[dummy_kernel](dev_buffer, grid_dim=1, block_dim=size)\ndev_buffer.enqueue_copy_to(host_buffer)\n\nctx.synchronize()\nprint(host_buffer)\n```\n\n----------------------------------------\n\nTITLE: Using Struct Instance\nDESCRIPTION: Demonstrates creating and accessing a struct instance.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/structs.mdx#2025-04-17_snippet_2\n\nLANGUAGE: mojo\nCODE:\n```\nvar mine = MyPair(2,4)\nprint(mine.first)\n```\n\n----------------------------------------\n\nTITLE: VS Code Launch Configuration for Mojo GPU Debugging\nDESCRIPTION: Complete launch.json configuration for debugging Mojo files with CUDA-GDB in VS Code. Includes settings for the current file, breakpoints, and classic debugger support.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/tools/gpu-debugging.mdx#2025-04-17_snippet_2\n\nLANGUAGE: json\nCODE:\n```\n  {\n    \"type\": \"mojo-cuda-gdb\",\n    \"request\": \"launch\",\n    \"name\": \"Mojo: Debug current Mojo file with CUDA-GDB\",\n    \"description\": \"Launch and debug the Mojo file that is active on the editor when the debug session starts, using CUDA-GDB.\",\n    \"mojoFile\": \"${file}\",\n    \"args\": [],\n    \"env\": [],\n    \"cwd\": \"${workspaceFolder}\",\n    \"breakOnLaunch\": true,\n    \"legacyDebugger\": true,\n    \"initCommands\": [\n        \"set environment CUDBG_USE_LEGACY_DEBUGGER=1\"\n    ],\n  }\n```\n\n----------------------------------------\n\nTITLE: Error-Raising Initializer for @register_passable Types in Mojo\nDESCRIPTION: Demonstrates the required syntax for initializers of @register_passable types that may raise errors. The example shows a simple struct with an initializer that raises an exception.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_121\n\nLANGUAGE: mojo\nCODE:\n```\n@register_passable\nstruct RaisingCtor:\n    fn __init__(inout self) raises:\n        raise\n```\n\n----------------------------------------\n\nTITLE: Implementing SIMD Vector Selection in Mojo\nDESCRIPTION: This code snippet demonstrates a function that selects values from input SIMD vectors based on boolean conditions. It includes parameter descriptions, return value explanation, and a usage example.\nSOURCE: https://github.com/modular/max/blob/main/mojo/stdlib/docs/docstring-style-guide.md#2025-04-17_snippet_5\n\nLANGUAGE: mojo\nCODE:\n```\nfn select[\n    result_type: DType\n](\n    self,\n    true_case: SIMD[result_type, size],\n    false_case: SIMD[result_type, size],\n) -> SIMD[result_type, size]:\n    \"\"\"Produces a new vector by selecting values from the input vectors based on\n    the current boolean values of this SIMD vector.\n\n    Parameters:\n        result_type: The element type of the input and output SIMD vectors.\n\n    Args:\n        true_case: The values selected if the positional value is True.\n        false_case: The values selected if the positional value is False.\n\n    Returns:\n        A new vector of the form\n        `[true_case[i] if elem else false_case[i] for i, elem in enumerate(self)]`.\n\n    Examples:\n\n    ```mojo\n    v1 = SIMD[DType.bool, 4](0, 1, 0, 1)\n    true_case =  SIMD[DType.int32, 4](1, 2, 3, 4)\n    false_case = SIMD[DType.int32, 4](0, 0, 0, 0)\n    output = v1.select[DType.int32](true_case, false_case)\n    print(output)\n    ```\n    \"\"\"\n```\n\n----------------------------------------\n\nTITLE: Parameterized Self in Initializers for Mojo Structs\nDESCRIPTION: Demonstrates how struct initializers can indicate specific parameter bindings in the type of their self argument, allowing for different initialization methods based on parameter values.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_47\n\nLANGUAGE: mojo\nCODE:\n```\n@value\nstruct MyStruct[size: Int]:\n    fn __init__(inout self: MyStruct[0]): pass\n    fn __init__(inout self: MyStruct[1], a: Int): pass\n    fn __init__(inout self: MyStruct[2], a: Int, b: Int): pass\n\ndef test(x: Int):\n    a = MyStruct()      # Infers size=0 from 'self' type.\n    b = MyStruct(x)     # Infers size=1 from 'self' type.\n    c = MyStruct(x, x)  # Infers size=2 from 'self' type.\n```\n\n----------------------------------------\n\nTITLE: Field Lifetime Example in Mojo Structure\nDESCRIPTION: Demonstrates how Mojo tracks and manages field lifetimes within a structure, showing automatic field destruction when values are overwritten.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/lifecycle/death.mdx#2025-04-17_snippet_4\n\nLANGUAGE: mojo\nCODE:\n```\n@value\nstruct MyPet:\n    var name: String\n    var age: Int\n\nfn use_two_strings():\n    var pet = MyPet(\"Po\", 8)\n    print(pet.name)\n    # pet.name.__del__() runs here, because this instance is\n    # no longer used; it's replaced below\n\n    pet.name = String(\"Lola\") # Overwrite pet.name\n    print(pet.name)\n    # pet.__del__() runs here\n```\n\n----------------------------------------\n\nTITLE: Function Scoping Example\nDESCRIPTION: Shows function-level scoping behavior with implicitly declared variables.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/variables.mdx#2025-04-17_snippet_8\n\nLANGUAGE: mojo\nCODE:\n```\ndef function_scopes():\n    num = 1\n    if num == 1:\n        print(num)   # Reads the function-scope \"num\"\n        num = 2      # Updates the function-scope variable\n        print(num)   # Reads the function-scope \"num\"\n    print(num)       # Reads the function-scope \"num\"\n\nfunction_scopes()\n```\n\n----------------------------------------\n\nTITLE: Explicit vs Implicit Copy Construction in Mojo\nDESCRIPTION: Demonstrates preferred explicit copy construction over implicit copying. Shows how to properly create copies of objects using explicit constructors.\nSOURCE: https://github.com/modular/max/blob/main/mojo/stdlib/docs/style-guide.md#2025-04-17_snippet_7\n\nLANGUAGE: mojo\nCODE:\n```\nvar copy = original            # 🔴 Avoid\nvar copy = MyStruct(original)  # 🟢 Preferred\n```\n\n----------------------------------------\n\nTITLE: Multiple Return Values with References in Mojo\nDESCRIPTION: Illustrates the limitations of returning multiple reference values in tuples, showing both valid and invalid approaches to multiple return values.\nSOURCE: https://github.com/modular/max/blob/main/mojo/proposals/ref-convention.md#2025-04-17_snippet_7\n\nLANGUAGE: mojo\nCODE:\n```\n# Simple tuple result type is ok of course:\nfn g1(...) -> (Int, Int): ...\n\n# Returning safe pointers is fine: each element needs explicit derefs\nfn g2(...) -> (Pointer[Int, life1], Pointer[Int, life2])\n\n# error: 'ref' is an argument convention, not a type.\nfn g3(...) -> (ref [life1] Int, ref [life2] Int)\n```\n\n----------------------------------------\n\nTITLE: Reference Pattern Usage in Mojo Loops\nDESCRIPTION: Shows how reference patterns could be used in foreach loops to allow mutation of elements within the loop.\nSOURCE: https://github.com/modular/max/blob/main/mojo/proposals/ref-convention.md#2025-04-17_snippet_9\n\nLANGUAGE: mojo\nCODE:\n```\n  for (ref elt) in mutableList:\n     elt = 42\n```\n\n----------------------------------------\n\nTITLE: Writing Documentation Comments (Docstrings) in Mojo\nDESCRIPTION: Shows how to write API documentation using triple quotes (docstrings) that can be extracted by documentation tools.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/basics.mdx#2025-04-17_snippet_13\n\nLANGUAGE: mojo\nCODE:\n```\nfn print(x: String):\n    \"\"\"Prints a string.\n\n    Args:\n        x: The string to print.\n    \"\"\"\n    ...\n```\n\n----------------------------------------\n\nTITLE: Importing from Standard Library Modules\nDESCRIPTION: These examples show different ways to import functions from Mojo's standard library, demonstrating how package-level imports can simplify import statements.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/packages.md#2025-04-17_snippet_8\n\nLANGUAGE: mojo\nCODE:\n```\nfrom algorithm.functional import map\n```\n\nLANGUAGE: mojo\nCODE:\n```\nfrom algorithm import map\n```\n\n----------------------------------------\n\nTITLE: DTypePointer Subscripting Operations\nDESCRIPTION: Shows how to use subscripting with DTypePointer for memory access operations.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_153\n\nLANGUAGE: mojo\nCODE:\n```\nlet p = DTypePointer[DType.float16].alloc(4)\nfor i in range(4):\n    p[i] = i\n    print(p[i])\n```\n\n----------------------------------------\n\nTITLE: Installing Magic and Running the MAX GUI Application\nDESCRIPTION: This bash script demonstrates how to install Magic using curl and then launch the MAX GUI application. The script first downloads and installs the Magic tool from the Modular developer site, then uses it to run the GUI application.\nSOURCE: https://github.com/modular/max/blob/main/examples/gui/README.md#2025-04-17_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ncurl -fsSL https://developer.modular.com/magic | bash\nmagic run gui\n```\n\n----------------------------------------\n\nTITLE: Installing Magic CLI Tool for MAX Pipelines\nDESCRIPTION: This command installs the Magic command-line tool on macOS and Linux systems. Magic is used to manage and run MAX Pipelines.\nSOURCE: https://github.com/modular/max/blob/main/src/max/README.md#2025-04-17_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\ncurl -ssL https://magic.modular.com | bash\n```\n\n----------------------------------------\n\nTITLE: Properly Initializing String UnsafePointer in Mojo\nDESCRIPTION: Demonstrates the correct way to initialize and modify a String value using UnsafePointer. This shows how to avoid undefined behavior by using proper initialization methods.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/pointers/unsafe-pointers.mdx#2025-04-17_snippet_14\n\nLANGUAGE: mojo\nCODE:\n```\nstr_ptr = UnsafePointer[String].alloc(1)\n# str_ptr[] = \"Testing\" # Undefined behavior!\nstr_ptr.init_pointee_move(\"Testing\")\nstr_ptr[] += \" pointers\" # Works now\n```\n\n----------------------------------------\n\nTITLE: Setting Up GPU Programming Environment in Mojo\nDESCRIPTION: Instructions for setting up the environment to run GPU code examples using Mojo, including cloning the repository and running code cells interactively.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/gpu/basics.mdx#2025-04-17_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\ngit clone git@github.com:modular/max\ncd max/mojo/docs/manual/gpu\n```\n\n----------------------------------------\n\nTITLE: Basic Struct Definition without Custom Destructor in Mojo\nDESCRIPTION: This example shows a simple struct that doesn't need a custom destructor because it only contains standard types (String and Int) that have their own destruction behavior.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/lifecycle/death.mdx#2025-04-17_snippet_1\n\nLANGUAGE: mojo\nCODE:\n```\nstruct MyPet:\n    var name: String\n    var age: Int\n\n    fn __init__(out self, name: String, age: Int):\n        self.name = name\n        self.age = age\n```\n\n----------------------------------------\n\nTITLE: Using NDBuffer with Default and Custom Parameters in Mojo\nDESCRIPTION: These examples show how to use the updated NDBuffer type with default parameters and how to specify custom static shapes when needed.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_128\n\nLANGUAGE: mojo\nCODE:\n```\nNDBuffer[DType.float32, 3]\n\nNDBuffer[DType.float32, 3, DimList.create_unknown[3]()] \n\nNDBuffer[DType.float32, 3, DimList(128, 128, 3)]\n```\n\n----------------------------------------\n\nTITLE: Using *_ Syntax for Explicitly Unbinding Parameters in Mojo\nDESCRIPTION: Demonstrates the new *_ syntax that allows explicitly unbinding multiple positional parameters in struct aliases. Shows examples with unbinding at different positions in parameter lists.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_117\n\nLANGUAGE: mojo\nCODE:\n```\nstruct StructWithDefault[a: Int, b: Int, c: Int = 8, d: Int = 9]: pass\n\nalias all_unbound = StructWithDefault[*_]\n# equivalent to\nalias all_unbound = StructWithDefault[_, _, _, _]\n\nalias first_bound = StructWithDefault[5, *_]\n# equivalent to\nalias first_bound = StructWithDefault[5, _, _, _]\n\nalias last_bound = StructWithDefault[*_, 6]\n# equivalent to\nalias last_bound = StructWithDefault[_, _, _, 6]\n\nalias mid_unbound = StructWithDefault[3, *_, 4]\n# equivalent to\nalias mid_unbound = StructWithDefault[3, _, _, 4]\n```\n\n----------------------------------------\n\nTITLE: Mojo Struct Code Organization Template\nDESCRIPTION: Standard template showing the organization of different sections within a Mojo struct definition.\nSOURCE: https://github.com/modular/max/blob/main/mojo/stdlib/docs/style-guide.md#2025-04-17_snippet_6\n\nLANGUAGE: mojo\nCODE:\n```\n# ===-----------------------------------------------------------------------===\n# MyStruct\n# ===-----------------------------------------------------------------------===\n\n\nstruct MyStruct(Sized, Stringable):\n    \"\"\"Description goes here.\"\"\"\n\n    # ===-------------------------------------------------------------------===\n    # Aliases\n    # ===-------------------------------------------------------------------===\n\n    alias factor = 5\n\n    # ===-------------------------------------------------------------------===\n    # Fields\n    # ===-------------------------------------------------------------------===\n\n    var field: Int\n\n    # ===-------------------------------------------------------------------===\n    # Life cycle methods\n    # ===-------------------------------------------------------------------===\n\n    fn __init__(...)\n    fn __moveinit__(...)\n    fn __copyinit__(...)\n\n    fn __del__(...)\n\n    # ===-------------------------------------------------------------------===\n    # Factory methods\n    # ===-------------------------------------------------------------------===\n\n    @staticmethod\n    fn foo(...) -> Self[...]\n\n    # ===-------------------------------------------------------------------===\n    # Operator dunders\n    # ===-------------------------------------------------------------------===\n\n    # Anything that \"backs\" special syntax: [..], *, +, /, //, etc...\n\n    fn __getitem__\n    fn __setitem__\n\n    fn __getattr__\n    fn __setattr__\n\n    fn __iter__     # `for x in self`\n    fn __next__\n    fn __contains__ # `x in self`\n    fn __is__       # `x is self`\n\n    fn __add__\n    fn __iadd__\n\n    # ===-------------------------------------------------------------------===\n    # Trait implementations\n    # ===-------------------------------------------------------------------===\n\n    fn __bool__\n    fn __len__\n    fn __str__\n\n    fn __abs__\n\n    # ===-------------------------------------------------------------------===\n    # Methods\n    # ===-------------------------------------------------------------------===\n\n    fn unsafe_ptr(..)   # e.g.\n```\n\n----------------------------------------\n\nTITLE: Numeric Division with Type Constraints\nDESCRIPTION: Example of constraining numeric operations based on type properties.\nSOURCE: https://github.com/modular/max/blob/main/mojo/proposals/requires-clause.md#2025-04-17_snippet_3\n\nLANGUAGE: mojo\nCODE:\n```\nfn safe_divide[T](a: T, b: T) where (T instanceof Numeric and T.min_value() < 0):\n```\n\n----------------------------------------\n\nTITLE: Debugging Mojo File from Command Line\nDESCRIPTION: This command starts a debug session for a Mojo file in Visual Studio Code from the command line. It uses the mojo debug command with the --vscode flag to launch the debugger in VS Code.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/tools/debugging.mdx#2025-04-17_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nmojo debug --vscode myproject.mojo\n```\n\n----------------------------------------\n\nTITLE: Calling a Dependent Type Function in Mojo\nDESCRIPTION: This snippet shows how a dependent type function is called in Mojo. It illustrates how the compiler handles type inference for the return value based on the input parameters.\nSOURCE: https://github.com/modular/max/blob/main/mojo/stdlib/docs/internal/mlir.md#2025-04-17_snippet_1\n\nLANGUAGE: Mojo\nCODE:\n```\nvalue = thing(someT3, someT17)\n```\n\n----------------------------------------\n\nTITLE: Pointer Origin Type Merging Example in Mojo\nDESCRIPTION: Example demonstrating how pointers with different origins need to be merged to produce a pointer with a union of origins. Currently this fails, but should result in a pointer that includes both origins.\nSOURCE: https://github.com/modular/max/blob/main/mojo/proposals/custom-type-merging.md#2025-04-17_snippet_3\n\nLANGUAGE: mojo\nCODE:\n```\nfn ptr_example(mut x: Int, mut y: Int, cond: Bool):\n  xptr = Pointer.address_of(x) # Type: Pointer[Int, __origin_of(x)]\n  yptr = Pointer.address_of(y) # Type: Pointer[Int, __origin_of(y)]\n\n  # Currently error.   \n  xy_ptr = xptr if cond else yptr\n  # Desired type: Pointer[Int, __origin_of(x, y)]\n  \n  xy_ptr[] += 42\n```\n\n----------------------------------------\n\nTITLE: Basic Mojo Parameter Inference Example\nDESCRIPTION: Shows how Mojo supports parameter inference where type parameters can be deduced from argument types in function calls.\nSOURCE: https://github.com/modular/max/blob/main/mojo/proposals/inferred-parameters.md#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfn infer_me[dt: DType, size: Int](x: SIMD[dt, size]): pass\n\ninfer_me(Int32())\n# Equivalent to\ninfer_me[DType.int32, 1](Int32())\n```\n\n----------------------------------------\n\nTITLE: Defining Functions without Type Annotations in Mojo\nDESCRIPTION: Shows how to define a function using def without explicit type annotations, relying on type inference.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/basics.mdx#2025-04-17_snippet_9\n\nLANGUAGE: mojo\nCODE:\n```\ndef greet(name):\n    return \"Hello, \" + name + \"!\"\n```\n\n----------------------------------------\n\nTITLE: Multi-line if Alternative to Conditional Expression\nDESCRIPTION: Demonstrates the more verbose alternative to conditional expressions using a multi-line if-else statement.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/control-flow.mdx#2025-04-17_snippet_6\n\nLANGUAGE: mojo\nCODE:\n```\nif temp_celsius > 20:\n    forecast = \"warm\"\nelse:\n    forecast = \"cool\"\nprint(\"The forecast for today is\", forecast)\n```\n\n----------------------------------------\n\nTITLE: Explicit Lifetime Control with 'with' Statement\nDESCRIPTION: Demonstrates using the 'with' statement for explicit lifetime control in Mojo.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/lifecycle/death.mdx#2025-04-17_snippet_9\n\nLANGUAGE: mojo\nCODE:\n```\nwith open(\"my_file.txt\", \"r\") as file:\n    print(file.read())\n\n    # Other stuff happens here (whether using `file` or not)...\n    foo()\n    # `file` is alive up to the end of the `with` statement.\n\n# `file` is destroyed when the statement ends.\nbar()\n```\n\n----------------------------------------\n\nTITLE: Debug Assertion Usage in Mojo\nDESCRIPTION: Demonstrates proper usage of debug assertions for runtime checking with descriptive error messages.\nSOURCE: https://github.com/modular/max/blob/main/mojo/stdlib/docs/style-guide.md#2025-04-17_snippet_11\n\nLANGUAGE: mojo\nCODE:\n```\nactual = 41\nexpected = 42\ndebug_assert(actual == expected, \"expected: \", expected, \" but got: \", actual)\n```\n\n----------------------------------------\n\nTITLE: Installing Nightly Mojo Compiler with Magic\nDESCRIPTION: Command to create a new project environment with the latest nightly version of MAX using the magic tool.\nSOURCE: https://github.com/modular/max/blob/main/mojo/CONTRIBUTING.md#2025-04-17_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nmagic init mojo-nightly --format mojoproject\n```\n\n----------------------------------------\n\nTITLE: Conditional Context Manager with Error Handling in Mojo\nDESCRIPTION: Advanced context manager implementation with conditional error handling and suppression capabilities.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/errors.mdx#2025-04-17_snippet_10\n\nLANGUAGE: mojo\nCODE:\n```\n@value\nstruct ConditionalTimer:\n    var start_time: Int\n\n    fn __init__(out self):\n        self.start_time = 0\n\n    fn __enter__(mut self) -> Self:\n        self.start_time = time.perf_counter_ns()\n        return self\n\n    fn __exit__(mut self):\n        end_time = time.perf_counter_ns()\n        elapsed_time_ms = round(((end_time - self.start_time) / 1e6), 3)\n        print(\"Elapsed time:\", elapsed_time_ms, \"milliseconds\")\n\n    fn __exit__(mut self, e: Error) raises -> Bool:\n        if String(e) == \"just a warning\":\n            print(\"Suppressing error:\", e)\n            self.__exit__()\n            return True\n        else:\n            print(\"Propagating error\")\n            self.__exit__()\n            return False\n```\n\n----------------------------------------\n\nTITLE: Using Renamed GPU Warp Operations in Mojo\nDESCRIPTION: Demonstrates the usage of renamed GPU warp operations, which were previously in the 'gpu.shuffle' module and are now in 'gpu.warp'.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_3\n\nLANGUAGE: mojo\nCODE:\n```\nimport gpu.warp as warp\n\nvar val0 = warp.shuffle_down(x, offset)\nvar val1 = warp.broadcast(x)\n```\n\n----------------------------------------\n\nTITLE: Constrained Function Documentation in Mojo\nDESCRIPTION: Shows how to document constraints in function docstrings when using the constrained builtin function.\nSOURCE: https://github.com/modular/max/blob/main/mojo/stdlib/docs/style-guide.md#2025-04-17_snippet_10\n\nLANGUAGE: mojo\nCODE:\n```\nfn add_param_arg[foo: Int](bar: Int) -> Int:\n    \"\"\"Shortened doc string.\n\n    Constraints:\n        `foo` must be more than 0.\n    \"\"\"\n    constrained[foo > 0]()\n    return foo + bar\n```\n\n----------------------------------------\n\nTITLE: Exporting Functions with Custom Names in Mojo\nDESCRIPTION: Shows how to use the `@export` decorator with an explicit symbol name to export a function under a different name than its Mojo identifier.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_217\n\nLANGUAGE: mojo\nCODE:\n```\n@export(\"baz\") # exported as 'baz'\nfn some_mojo_fn_name():\n```\n\n----------------------------------------\n\nTITLE: Implementing For-Loop Reference Patterns in Mojo\nDESCRIPTION: Examples of different for-loop patterns showing element copying and reference binding (both mutable and immutable) when iterating over lists.\nSOURCE: https://github.com/modular/max/blob/main/mojo/proposals/resyntaxing-arg-conventions-and-refs.md#2025-04-17_snippet_2\n\nLANGUAGE: mojo\nCODE:\n```\n  # Copy the elements of the list into elt (required for Python compat), like\n  # \"for (auto elt : list)\" in C++.\n  for elt in list:\n      elt += \"foo\"\n\n  # Bind a mutable reference to elements in the list, like\n  # `for (auto &elt : mutlist)` in C++.\n  # This happens when `mutlist` yields mutable references.\n  for ref elt in mutlist:\n      elt += \"foo\"\n\n  # Bind an immutable reference to elements in the list, like\n  # `for (const auto &elt : immlist)` in C++\n  # This happens when `mutlist` yields immutable references.\n  for ref elt in immlist:\n      use(elt.field) # no need to copy elt to access a subfield.\n      #elt += foo # This would be an error, can't mutate immutable reference.\n```\n\n----------------------------------------\n\nTITLE: Declaring an Uninitialized UnsafePointer in Mojo\nDESCRIPTION: Demonstrates how to declare an uninitialized UnsafePointer variable. This is the first step in the pointer lifecycle, before it points to any memory location.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/pointers/unsafe-pointers.mdx#2025-04-17_snippet_2\n\nLANGUAGE: mojo\nCODE:\n```\nvar ptr: UnsafePointer[Int]\n```\n\n----------------------------------------\n\nTITLE: Attaching Debugger to Running Process by Name\nDESCRIPTION: This command attaches the Mojo debugger to a running process specified by its process name. It uses the mojo debug command with the --vscode and --process-name flags to attach the debugger in VS Code.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/tools/debugging.mdx#2025-04-17_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nmojo debug --vscode --process-name <PROCESS_NAME>\n```\n\n----------------------------------------\n\nTITLE: Initializing UnsafePointer Memory in Mojo\nDESCRIPTION: Shows different ways to initialize memory pointed to by an UnsafePointer, including copying a value, moving a value, or getting the address of an existing value. This prepares the memory for safe access.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/pointers/unsafe-pointers.mdx#2025-04-17_snippet_5\n\nLANGUAGE: mojo\nCODE:\n```\nptr.init_pointee_copy(value)\n# or\nptr.init_pointee_move(value^)\n# or\nptr = UnsafePointer[Int].address_of(value)\n```\n\n----------------------------------------\n\nTITLE: SIMD Construction Checks Implementation - Current Approach\nDESCRIPTION: Current implementation of SIMD type construction checks using runtime constrained checks. Shows the limitations of runtime validation versus desired compile-time checking.\nSOURCE: https://github.com/modular/max/blob/main/mojo/proposals/requires-clause.md#2025-04-17_snippet_0\n\nLANGUAGE: mojo\nCODE:\n```\nfn _simd_construction_checks[type: DType, size: Int]():\n    constrained[\n        type is not DType.invalid, \"simd type cannot be DType.invalid\"\n    ]()\n    constrained[size.is_power_of_two(), \"simd width must be power of 2\"]()\n    ...\n\nstruct SIMD[dtype: DType, size: Int]:\n    @implicit\n    fn __init__(out self, value: FloatLiteral):\n        ...\n        _simd_construction_checks[dtype, size]()\n        constrained[\n            dtype.is_floating_point(), \"the SIMD type must be floating point\"\n        ]()\n\n        <actual code>\n```\n\n----------------------------------------\n\nTITLE: Nested Function Declarations in Mojo\nDESCRIPTION: Demonstrates the difference in nested function declarations between Python and Mojo, highlighting the static nature of Mojo's nested functions.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/roadmap.md#2025-04-17_snippet_5\n\nLANGUAGE: mojo\nCODE:\n```\nfn foo():\n    fn bar(): # static function definition bound to 'bar'\n        pass\n    bar() # direct call\n    var f = bar # materialize 'bar' as a dynamic value\n    f() # indirect call\n```\n\n----------------------------------------\n\nTITLE: Single-line if Statement in Mojo\nDESCRIPTION: Shows how to write if statements as a single line for short, conditional executions.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/control-flow.mdx#2025-04-17_snippet_1\n\nLANGUAGE: mojo\nCODE:\n```\ntemp_celsius = 22\nif temp_celsius < 15: print(\"It is cool.\") # Skipped because condition is False\nif temp_celsius > 20: print(\"It is warm.\")\n```\n\n----------------------------------------\n\nTITLE: Move Constructor and Destructor Signatures in Mojo\nDESCRIPTION: Illustrates the method signatures for move constructor and destructor, showing how Mojo handles owned arguments of the same type.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/lifecycle/death.mdx#2025-04-17_snippet_6\n\nLANGUAGE: mojo\nCODE:\n```\nstruct TwoStrings:\n    fn __moveinit__(out self, owned existing: Self):\n        # Initializes a new `self` by consuming the contents of `existing`\n    fn __del__(owned self):\n        # Destroys all resources in `self`\n```\n\n----------------------------------------\n\nTITLE: Mojo Function Return Omission\nDESCRIPTION: Examples showing how Mojo supports omitting returns at unreachable code paths.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_212\n\nLANGUAGE: mojo\nCODE:\n```\nfn foo(cond: Bool) -> Int:\n    if cond:\n        return 0\n    else:\n        return 1\n\nfn bar() -> Int:\n    while True:\n        pass\n```\n\n----------------------------------------\n\nTITLE: Updated Buffer Memory Copy Syntax in Mojo\nDESCRIPTION: Shows the change in memcpy usage from Buffer types to Pointer and DTypePointer overloads\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_112\n\nLANGUAGE: mojo\nCODE:\n```\n# Doesn't work\nmemcpy(destBuffer, srcBuffer, count)\n# Works\nmemcpy(destBuffer.data, srcBuffer.data, count)\n```\n\n----------------------------------------\n\nTITLE: Addition Example Output\nDESCRIPTION: Expected output showing input tensor names, shapes, and computation result\nSOURCE: https://github.com/modular/max/blob/main/tutorials/max-graph-python/README.md#2025-04-17_snippet_1\n\nLANGUAGE: text\nCODE:\n```\ninput names are:\nname: input0, shape: [1], dtype: DType.float32\nname: input1, shape: [1], dtype: DType.float32\nresult: [2.]\n```\n\n----------------------------------------\n\nTITLE: Using Adaptive Decorator for Function Overloading in Mojo\nDESCRIPTION: Demonstrates the `@adaptive` decorator that allows multiple valid candidates for a function to be resolved at compile time, creating compilation forks for different implementations.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_215\n\nLANGUAGE: mojo\nCODE:\n```\n@adaptive\nfn sort(arr: ArraySlice[Int]):\n    bubble_sort(arr)\n\n@adaptive\nfn sort(arr: ArraySlice[Int]):\n    merge_sort(arr)\n\nfn concat_and_sort(lhs: ArraySlice[Int], rhs: ArraySlice[Int]):\n    let arr = lhs + rhs\n    sort(arr) # this forks compilation, creating two instances\n              # of the surrounding function\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Function Arguments in Mojo\nDESCRIPTION: Example showing function signature with positional-only, positional-or-keyword, and keyword-only arguments with default values.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/lib.mdx#2025-04-17_snippet_0\n\nLANGUAGE: mojo\nCODE:\n```\nfn example_fn(pos: Int, /, pos_or_kw: Int, *, kw_only: Bool = False):\n    ...\n```\n\n----------------------------------------\n\nTITLE: Overload Resolution with Size Requirements\nDESCRIPTION: Example showing how requires clauses can be used to select implementations based on compile-time type capabilities.\nSOURCE: https://github.com/modular/max/blob/main/mojo/proposals/requires-clause.md#2025-04-17_snippet_1\n\nLANGUAGE: mojo\nCODE:\n```\nfn thing[size: Int](value: YourType[size])\n  requires size.is_power_of_2(): ...\nfn thing[size: Int](value: YourType[size])\n  requires not size.is_power_of_2(): ...\n```\n\n----------------------------------------\n\nTITLE: Using Type Introspection in Mojo Functions\nDESCRIPTION: This example demonstrates the use of the new __type_of() magic call to yield the type of a value, allowing reference to types of other variables within function signatures and body.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_125\n\nLANGUAGE: mojo\nCODE:\n```\nfn my_function(x: Int, y: __type_of(x)) -> Int:\n    let z: __type_of(x) = y\n    return z\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Dynamic Type Value Restrictions in Mojo\nDESCRIPTION: Code examples showing how dynamic type values are now restricted in Mojo. The first example shows patterns that are no longer allowed, while the second example shows patterns that are still supported.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_101\n\nLANGUAGE: mojo\nCODE:\n```\nvar t = Int  # dynamic type values not allowed\n\nstruct SomeType: ...\n\ntakes_type(SomeType)  # dynamic type values not allowed\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Python's Function-Level Scoping\nDESCRIPTION: This snippet illustrates Python's function-level scoping rules, which differ from Mojo's current implementation and can lead to UnboundLocalError in certain cases.\nSOURCE: https://github.com/modular/max/blob/main/mojo/proposals/mojo-and-dynamism.md#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ndef foo(k):\n    for i in range(k):\n        print(i)\n    # Mojo complains that `i` is not defined, but this code should compile and\n    # dynamically raise an `UnboundLocalError` depending on the value of `k`!\n    print(i)\n```\n\n----------------------------------------\n\nTITLE: Demonstrating an Invalid Return of Immovable Object in Mojo\nDESCRIPTION: This function illustrates an incorrect attempt to return an ImmovableObject, which fails because the object cannot be moved or copied.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/functions.mdx#2025-04-17_snippet_24\n\nLANGUAGE: mojo\nCODE:\n```\ndef create_immovable_object2(owned name: String) -> ImmovableObject:\n    obj = ImmovableObject(name^)\n    obj.name += \"!\"\n    return obj^ # Error: ImmovableObject is not copyable or movable\n```\n\n----------------------------------------\n\nTITLE: Setting Programmatic Breakpoint in Mojo\nDESCRIPTION: Demonstrates how to use the built-in breakpoint() function to trigger the debugger at specific points in code. The example shows breaking execution when an invalid condition is encountered.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/tools/debugging.mdx#2025-04-17_snippet_5\n\nLANGUAGE: mojo\nCODE:\n```\nif some_value.is_valid():\n   do_the_right_thing()\nelse:\n   # We should never get here!\n   breakpoint()\n```\n\n----------------------------------------\n\nTITLE: List Manipulation with Owned Arguments in Mojo\nDESCRIPTION: Shows how to transfer ownership of strings to a list and how to consume owned strings, demonstrating different ownership transfer patterns.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/values/ownership.mdx#2025-04-17_snippet_8\n\nLANGUAGE: mojo\nCODE:\n```\nfrom collections import List\n\ndef add_to_list(owned name: String, mut list: List[String]):\n    list.append(name^)\n    # name is uninitialized, nothing to destroy\n\ndef consume_string(owned s: String):\n    print(s)\n    # s is destroyed here\n```\n\n----------------------------------------\n\nTITLE: Introducing 'ref' Argument Convention in Mojo\nDESCRIPTION: Demonstrates the usage of the proposed 'ref' argument convention for specifying expected lifetime and auto-dereferencing in function parameters.\nSOURCE: https://github.com/modular/max/blob/main/mojo/proposals/ref-convention.md#2025-04-17_snippet_0\n\nLANGUAGE: mojo\nCODE:\n```\nfn take_int_ref(a: Int, ref [_] b: Int) -> Int:\n    return a+b  # b, not b[]\n```\n\n----------------------------------------\n\nTITLE: Creating a Null UnsafePointer in Mojo\nDESCRIPTION: Shows how to create a null pointer with address 0, which indicates an invalid pointer. This is used when you need a pointer variable that doesn't point to any valid memory yet.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/pointers/unsafe-pointers.mdx#2025-04-17_snippet_3\n\nLANGUAGE: mojo\nCODE:\n```\nptr = UnsafePointer[Int]()\n```\n\n----------------------------------------\n\nTITLE: Defining a Function with Implicit Error Raising in Mojo\nDESCRIPTION: Shows how to define a function using 'def' keyword, which implicitly allows raising errors without the 'raises' keyword.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/errors.mdx#2025-04-17_snippet_3\n\nLANGUAGE: mojo\nCODE:\n```\ndef incr(n: Int) -> Int:\n    if n == Int.MAX:\n        raise \"inc: integer overflow\"\n    else:\n        return n + 1\n```\n\n----------------------------------------\n\nTITLE: Creating parametric closure in Mojo\nDESCRIPTION: Demonstrates how to use the @parameter decorator on a nested function to create a parametric capturing closure, allowing the closure to be used as a parameter.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/decorators/parameter.md#2025-04-17_snippet_2\n\nLANGUAGE: mojo\nCODE:\n```\nfn use_closure[func: fn(Int) capturing [_] -> Int](num: Int) -> Int:\n    return func(num)\n\nfn create_closure():\n    var x = 1\n\n    @parameter\n    fn add(i: Int) -> Int:\n        return x + i\n\n    var y = use_closure[add](2)\n    print(y)\n\ncreate_closure()\n```\n\n----------------------------------------\n\nTITLE: Arbitrary vs Finite Precision Calculation in Mojo\nDESCRIPTION: Illustrates the difference between arbitrary-precision calculations performed at compile time versus finite-precision calculations at runtime using Float64 values.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/types.mdx#2025-04-17_snippet_1\n\nLANGUAGE: mojo\nCODE:\n```\nvar arbitrary_precision = 3.0 * (4.0 / 3.0 - 1.0)\n# use a variable to force the following calculation to occur at runtime\nvar three = 3.0\nvar finite_precision = three * (4.0 / three - 1.0)\nprint(arbitrary_precision, finite_precision)\n```\n\n----------------------------------------\n\nTITLE: Using SIMD and FloatLiteral Conversion to Int in Mojo\nDESCRIPTION: Example showing how FloatLiteral and SIMD types can be converted to Int using to_int or __int__ method calls, matching Python's behavior of rounding towards zero.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_183\n\nLANGUAGE: mojo\nCODE:\n```\nlet float_val = 3.7\nlet int_val = float_val.to_int()  # or float_val.__int__()\n```\n\n----------------------------------------\n\nTITLE: Defining Serving Dependencies\nDESCRIPTION: Lists dependencies required for serving ML models, including Hugging Face hub integration, OpenTelemetry monitoring, and server components like FastAPI and uvicorn.\nSOURCE: https://github.com/modular/max/blob/main/src/max/pipelines/requirements.txt#2025-04-17_snippet_1\n\nLANGUAGE: plaintext\nCODE:\n```\n# serve\nhf-transfer>=0.1.9\nhttpx>=0.28.1,<0.29\nhuggingface-hub>=0.24.0\nopentelemetry-api>=1.29.0\nopentelemetry-exporter-otlp-proto-http>=1.27.0\nopentelemetry-exporter-prometheus>=0.50b0\nopentelemetry-sdk>=1.29.0,<2.0\npillow>=10.3.0\nprometheus-async>=22.2.0\nprometheus-client>=0.21.0\npydantic-settings>=2.7.1\npydantic\npyinstrument>=5.0.1\npython-json-logger>=2.0.7\nsentinel>=0.3.0\nsse-starlette>=2.1.2\ntokenizers>=0.19.0\nuvicorn>=0.34.0\nuvloop>=0.21.0\n```\n\n----------------------------------------\n\nTITLE: Basic Pointer Arithmetic in Mojo\nDESCRIPTION: Demonstrates allocating memory for Float64 values and initializing them using pointer arithmetic.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/pointers/unsafe-pointers.mdx#2025-04-17_snippet_16\n\nLANGUAGE: mojo\nCODE:\n```\nfloat_ptr = UnsafePointer[Float64].alloc(6)\nfor offset in range(6):\n    (float_ptr+offset).init_pointee_copy(0.0)\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Parameter Type Widening in Mojo\nDESCRIPTION: Example function showing how a SIMD type widening operation results in a symbolic expression that can't be easily folded at parse time. The return type becomes SIMD[dt, Int.__add__(n, n)] which causes several issues in the compiler pipeline.\nSOURCE: https://github.com/modular/max/blob/main/mojo/proposals/always_inline_builtin.md#2025-04-17_snippet_0\n\nLANGUAGE: mojo\nCODE:\n```\nfn widen[dt: DType, n: Int](a: SIMD[dt, n], b: SIMD[dt, n]) -> SIMD[dt, n+n]:\n```\n\n----------------------------------------\n\nTITLE: Alternative: Segmented Parameter Lists\nDESCRIPTION: Illustrates an alternative approach using multiple parameter lists to enable right-to-left inference between parameter segments.\nSOURCE: https://github.com/modular/max/blob/main/mojo/proposals/inferred-parameters.md#2025-04-17_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nfn scalar_param[dt: DType][x: Scalar[dt]](): pass\n```\n\n----------------------------------------\n\nTITLE: Password Database Access in Mojo\nDESCRIPTION: Shows how to access user information from the system password database using the pwd module.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_63\n\nLANGUAGE: mojo\nCODE:\n```\nimport pwd\nimport os\ncurrent_user = pwd.getpwuid(os.getuid())\nprint(current_user)\n\nroot = pwd.getpwnam(\"root\")\nprint(root)\n```\n\n----------------------------------------\n\nTITLE: Implementing DefaultHasher in Mojo\nDESCRIPTION: Provides a dummy implementation of a DefaultHasher struct that implements the proposed Hasher trait, serving as a standard library default.\nSOURCE: https://github.com/modular/max/blob/main/mojo/proposals/improved-hash-module.md#2025-04-17_snippet_3\n\nLANGUAGE: mojo\nCODE:\n```\nstruct DefaultHasher(Hasher):\n    var hash: UInt64\n\n    fn __init__(out self):\n        self.hash = 42\n    fn _update_with_bytes(mut self, bytes: DTypePointer[DType.uint8], n: Int):\n        ...\n    fn _update_with_simd[dt: DType, size: Int](mut self, value: SIMD[dt, size]):\n        ...\n    fn update[T: Hashable](mut self, value: T):\n        ...\n    fn _finish[dt: DType = DType.uint64](owned self) -> Scalar[dt]:\n        return self.hash.cast[dt]()\n```\n\n----------------------------------------\n\nTITLE: Proposed Parameter Inference Syntax in Mojo\nDESCRIPTION: Demonstrates the desired syntax for parameter inference where a parameter can be omitted if it can be inferred from other parameters.\nSOURCE: https://github.com/modular/max/blob/main/mojo/proposals/inferred-parameters.md#2025-04-17_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nscalar_param[Int32()]()\n```\n\n----------------------------------------\n\nTITLE: Collecting Test List in Mojo\nDESCRIPTION: Discovers and lists all tests in a directory using the --collect-only option\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/tools/testing.mdx#2025-04-17_snippet_11\n\nLANGUAGE: bash\nCODE:\n```\nmojo test --co test\n```\n\n----------------------------------------\n\nTITLE: Using MLIR Multi-result Operations\nDESCRIPTION: Demonstrates how to use MLIR operations that return multiple results using tuple types.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_150\n\nLANGUAGE: mojo\nCODE:\n```\n# The `ret` variable has type `Tuple[Int, Int]`.\nlet ret = __mlir_op.`multi_result_op`[_type=(Int, Int)]()\n```\n\n----------------------------------------\n\nTITLE: Replacing '__refitem__' with '__getitem__' in Mojo\nDESCRIPTION: Shows how the proposal eliminates the need for '__refitem__' by using '__getitem__' with the new 'ref' convention.\nSOURCE: https://github.com/modular/max/blob/main/mojo/proposals/ref-convention.md#2025-04-17_snippet_5\n\nLANGUAGE: mojo\nCODE:\n```\nfn __getitem__(ref [_] self, index: Int)\n    -> ref [self] Self.ElementType:\n```\n\n----------------------------------------\n\nTITLE: C/C++ External Pointer Integration\nDESCRIPTION: Shows how to work with C/C++ pointers using external_call function.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/pointers/unsafe-pointers.mdx#2025-04-17_snippet_19\n\nLANGUAGE: mojo\nCODE:\n```\nfrom sys.ffi import external_call\n\ndef get_foreign_pointer() -> UnsafePointer[Int]:\n    ptr = external_call[\n        \"my_c_function\",   # external function name\n        UnsafePointer[Int] # return type\n    ]()\n    return ptr\n```\n\n----------------------------------------\n\nTITLE: Using String.format() with Automatic Indexing\nDESCRIPTION: Shows how to use String.format() with automatic indexing, where arguments are placed sequentially into the format string placeholders.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_55\n\nLANGUAGE: mojo\nCODE:\n```\nprint(String(\"{} {} {}\").format(True, 1.125, 2))\n#True 1.125 2\n```\n\n----------------------------------------\n\nTITLE: Output Processing\nDESCRIPTION: Processes model outputs to obtain final sentiment classification.\nSOURCE: https://github.com/modular/max/blob/main/examples/notebooks/roberta-python-pytorch.ipynb#2025-04-17_snippet_8\n\nLANGUAGE: python\nCODE:\n```\n# Extract class prediction from output\npredicted_class_id = outputs[\"result0\"].argmax(axis=-1)[0]\nclassification = hf_model.config.id2label[predicted_class_id]\n\nprint(f\"The sentiment is: {classification}\")\n```\n\n----------------------------------------\n\nTITLE: Multi-line Statements with String Literals in Mojo\nDESCRIPTION: Demonstrates how to split long strings across multiple lines for better readability.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/basics.mdx#2025-04-17_snippet_6\n\nLANGUAGE: mojo\nCODE:\n```\ndef print_line():\n    long_text = \"This is a long line of text that is a lot easier to read if\"\n                \" it is broken up across two lines instead of one long line.\"\n    print(long_text)\n```\n\n----------------------------------------\n\nTITLE: Function Overload Resolution for References in Mojo\nDESCRIPTION: Example showing how Mojo now supports resolving function overloads when forming references to functions, not just when calling them. This enhances the language's capabilities with function pointers and aliases.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_72\n\nLANGUAGE: mojo\nCODE:\n```\nfn overloaded_parameters[value: Int32]():\n    pass\n\nfn overloaded_parameters[value: Float32]():\n    pass\n\nfn form_reference():\n    alias ref = overloaded_parameters[Int32()] # works!\n```\n\n----------------------------------------\n\nTITLE: Alternative: Special Separator at End\nDESCRIPTION: Shows another alternative syntax placing the separator after non-inferred parameters, allowing non-lexical parameter references.\nSOURCE: https://github.com/modular/max/blob/main/mojo/proposals/inferred-parameters.md#2025-04-17_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nfn scalar_param[x: Scalar[dt], %%%, dt: DType](): pass\n```\n\n----------------------------------------\n\nTITLE: Using Parametric Closures with Copy Capture\nDESCRIPTION: Shows how to use the __copy_capture decorator for parametric closures to capture register-passable values by copy rather than by reference.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_134\n\nLANGUAGE: mojo\nCODE:\n```\nfn foo(x: Int):\n    var z = x\n\n    @__copy_capture(z)\n    @parameter\n    fn formatter() -> Int:\n        return z\n    z = 2\n    print(formatter())\n\nfn main():\n    foo(5)\n```\n\n----------------------------------------\n\nTITLE: Nested Function Recursion Limitation in Mojo\nDESCRIPTION: Shows the limitation of recursive nested functions in Mojo, which are not supported due to current language constraints.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/roadmap.md#2025-04-17_snippet_8\n\nLANGUAGE: mojo\nCODE:\n```\nfn try_recursion():\n    fn bar(x: Int): # error: circular reference :<\n        if x < 10:\n            bar(x + 1)\n```\n\n----------------------------------------\n\nTITLE: Chunk Data Processing with Bitcasting\nDESCRIPTION: Demonstrates reading chunks of data by bitcasting between UInt8 and UInt32 pointers.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/pointers/unsafe-pointers.mdx#2025-04-17_snippet_20\n\nLANGUAGE: mojo\nCODE:\n```\ndef read_chunks(owned ptr: UnsafePointer[UInt8]) -> List[List[UInt32]]:\n    chunks = List[List[UInt32]]()\n    # A chunk size of 0 indicates the end of the data\n    chunk_size = Int(ptr[])\n    while (chunk_size > 0):\n        # Skip the 1 byte chunk_size and get a pointer to the first\n        # UInt32 in the chunk\n        ui32_ptr = (ptr + 1).bitcast[UInt32]()\n        chunk = List[UInt32](capacity=chunk_size)\n        for i in range(chunk_size):\n            chunk.append(ui32_ptr[i])\n        chunks.append(chunk)\n        # Move our pointer to the next byte after the current chunk\n        ptr += (1 + 4 * chunk_size)\n        # Read the size of the next chunk\n        chunk_size = Int(ptr[])\n    return chunks\n```\n\n----------------------------------------\n\nTITLE: Using Updated MLIR Operation Attribute Syntax in Mojo\nDESCRIPTION: This code demonstrates the updated syntax for specifying attributes with the __mlir_op prefix in Mojo. It shows the change from colon to equals sign for attribute specification to mimic Python's keyword argument syntax.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_174\n\nLANGUAGE: mojo\nCODE:\n```\n# Old syntax, now fails.\n__mlir_op.`index.bool.constant`[value : __mlir_attr.false]()\n# New syntax.\n__mlir_op.`index.bool.constant`[value=__mlir_attr.false]()\n```\n\n----------------------------------------\n\nTITLE: Variable Declaration Shadowing in Mojo\nDESCRIPTION: Example showing how Mojo now permits implicit variable declarations to shadow global immutable symbols without compiler errors, improving flexibility in variable naming.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_68\n\nLANGUAGE: mojo\nCODE:\n```\nslice = foo()\n```\n\n----------------------------------------\n\nTITLE: Attaching Debugger to Running Process by ID\nDESCRIPTION: This command attaches the Mojo debugger to a running process specified by its process ID. It uses the mojo debug command with the --vscode and --pid flags to attach the debugger in VS Code.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/tools/debugging.mdx#2025-04-17_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nmojo debug --vscode --pid <PROCESS_ID>\n```\n\n----------------------------------------\n\nTITLE: Variant Type Support Check Implementation\nDESCRIPTION: Shows how to use the new Variant.is_type_supported method to check and modify variant types safely.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog.md#2025-04-17_snippet_3\n\nLANGUAGE: mojo\nCODE:\n```\ndef takes_variant(mut arg: Variant):\n    if arg.is_type_supported[Float64]():\n        arg = Float64(1.5)\ndef main():\n    var x = Variant[Int, Float64](1)\n    takes_variant(x)\n    if x.isa[Float64]():\n        print(x[Float64]) # 1.5\n```\n\n----------------------------------------\n\nTITLE: Using For-Loop Iteration with Variadic Arguments\nDESCRIPTION: Demonstrates iterating over variadic arguments with a for loop, requiring an extra dereference operation for memory-only types.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_131\n\nLANGUAGE: mojo\nCODE:\n```\nfn make_worldly(inout *strs: String):\n    # Requires extra [] to dereference the reference for now.\n    for i in strs:\n        i[] += \" world\"\n```\n\n----------------------------------------\n\nTITLE: Chaining Function Calls Across Multiple Lines in Mojo\nDESCRIPTION: Shows how to make code more readable by spreading method chains across multiple lines.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/basics.mdx#2025-04-17_snippet_7\n\nLANGUAGE: mojo\nCODE:\n```\ndef print_hello():\n    text = String(\",\")\n          .join(\"Hello\", \" world!\")\n    print(text)\n```\n\n----------------------------------------\n\nTITLE: Proposed 'inferred' Keyword Implementation\nDESCRIPTION: Shows how the new 'inferred' keyword would be used to mark parameters that can only be inferred and cannot be specified directly by callers.\nSOURCE: https://github.com/modular/max/blob/main/mojo/proposals/inferred-parameters.md#2025-04-17_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfn scalar_param[inferred dt: DType, x: Scalar[dt]](): pass\n\nscalar_param[Int32()]() # 'dt' is skipped and 'Int32()' is bound to 'x'\n```\n\n----------------------------------------\n\nTITLE: Writing Comments in Mojo\nDESCRIPTION: Shows how to write single-line comments in Mojo code, both on their own line and after code.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/basics.mdx#2025-04-17_snippet_11\n\nLANGUAGE: mojo\nCODE:\n```\n# This is a comment. The Mojo compiler ignores this line.\n```\n\n----------------------------------------\n\nTITLE: Internal Representation of Dependent Type in Mojo Compiler\nDESCRIPTION: This snippet shows how the Mojo compiler internally represents a dependent type return value. It demonstrates the symbolic representation used before type inference and simplification.\nSOURCE: https://github.com/modular/max/blob/main/mojo/stdlib/docs/internal/mlir.md#2025-04-17_snippet_3\n\nLANGUAGE: Mojo\nCODE:\n```\nT[Int.add(a, b)]\n```\n\n----------------------------------------\n\nTITLE: Converting List to String in Mojo\nDESCRIPTION: Shows the simplified syntax for converting a List to a String using the __str__() method, though List doesn't yet conform to the Stringable trait.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_81\n\nLANGUAGE: mojo\nCODE:\n```\nvar my_list = List[Int](2, 3)\nprint(my_list.__str__())  # prints [2, 3]\n```\n\n----------------------------------------\n\nTITLE: Integer Type Merging Example in Mojo\nDESCRIPTION: Example showing current limitations in merging different integer types (Int8 and Int16) in a ternary operation. Currently this produces an error, but the desired behavior would convert to the wider type (Int16).\nSOURCE: https://github.com/modular/max/blob/main/mojo/proposals/custom-type-merging.md#2025-04-17_snippet_1\n\nLANGUAGE: mojo\nCODE:\n```\nfn int_example(a: Int8, b: Int16, cond: Bool):\n  # Currently: error: value of type 'SIMD[int8, 1]' is not compatible with value of type 'SIMD[int16, 1]' \n  c = a if cond else b\n  # Desired type: Int16\n```\n\n----------------------------------------\n\nTITLE: Raising an Error in Mojo\nDESCRIPTION: Shows how to raise an error in Mojo using the Error type instead of Exception.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/roadmap.md#2025-04-17_snippet_3\n\nLANGUAGE: mojo\nCODE:\n```\nfn raise_an_error() raises:\n    raise Error(\"I'm an error!\")\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Dynamic Class Definition in Python\nDESCRIPTION: This snippet shows how Python allows dynamic class definitions, including conditional method definitions and code execution within the class body.\nSOURCE: https://github.com/modular/max/blob/main/mojo/proposals/mojo-and-dynamism.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ndefine = True\n\nclass C:\n    print(\"hello\") # prints 'hello'\n    if define:\n        def f(self): print(10)\n    else:\n        def f(self): print(20)\n\n\nC().f() # prints '10'\n```\n\n----------------------------------------\n\nTITLE: Defining Parametric Alias in Mojo\nDESCRIPTION: Demonstrates how to create and use a parametric alias in Mojo, using the Scalar type as an example.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/roadmap.md#2025-04-17_snippet_2\n\nLANGUAGE: mojo\nCODE:\n```\nalias Scalar = SIMD[size=1]\n```\n\nLANGUAGE: mojo\nCODE:\n```\nvar i = Scalar[DType.int8]\n```\n\n----------------------------------------\n\nTITLE: AnyType Function Signature Example\nDESCRIPTION: Demonstrates the syntax for functions accepting register-passable types.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/types.mdx#2025-04-17_snippet_21\n\nLANGUAGE: mojo\nCODE:\n```\nfn any_type_function[ValueType: AnyTrivialRegType](value: ValueType):\n    ...\n```\n\n----------------------------------------\n\nTITLE: Running Individual Test by ID in Mojo\nDESCRIPTION: Executes a single test using its fully qualified ID with import path configuration\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/tools/testing.mdx#2025-04-17_snippet_10\n\nLANGUAGE: bash\nCODE:\n```\nmojo test -I src 'test/my_math/test_dec.mojo::test_dec_valid()'\n```\n\n----------------------------------------\n\nTITLE: Updating Pointer Dereferencing in Mojo\nDESCRIPTION: Demonstrates the change from using __get_address_as_lvalue magic function to using the dereference operator ([]) with Pointer types\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_111\n\nLANGUAGE: mojo\nCODE:\n```\nvar ptr: Pointer[MyRecord]\n...\n# Doesn't work\n__get_address_as_lvalue(ptr.value) = MyRecord(3, 5)\n# Works\nptr[] = MyRecord(3, 5)\n```\n\n----------------------------------------\n\nTITLE: Documenting Functions with Freeform Sections in Mojo\nDESCRIPTION: Example showing how to add freeform sections like Notes to function documentation.\nSOURCE: https://github.com/modular/max/blob/main/mojo/stdlib/docs/docstring-style-guide.md#2025-04-17_snippet_4\n\nLANGUAGE: mojo\nCODE:\n```\nfn noop():\n    \"\"\"Does nothing.\n\n    Notes:\n\n    - Efficiently distributes nothing to all available cores.\n    - Takes advantage of GPU acceleration to do nothing faster.\n    \"\"\"\n```\n\n----------------------------------------\n\nTITLE: Mojo Parameter Return with Error Handling\nDESCRIPTION: Example of using param_return statement in a throwing function to return result parameters.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_210\n\nLANGUAGE: mojo\nCODE:\n```\n@raises\nfn foo[() -> out: Int]():\n    param_return[42]\n    raise Error()\n```\n\n----------------------------------------\n\nTITLE: Unbound Parameter Expression Restrictions in Mojo\nDESCRIPTION: Examples showing how *_ expressions in parameter expressions are now restricted to only appearing at the end of positional parameter lists, not in the middle.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_103\n\nLANGUAGE: mojo\nCODE:\n```\n# No longer supported\nalias FirstUnbound = SomeStruct[*_, 42]\nalias MidUnbound   = SomeStruct[7, *_, 6]\n# Still supported\nalias LastUnbound  = SomeStruct[42, *_]\n```\n\n----------------------------------------\n\nTITLE: Redesigning Hashable Trait in Mojo\nDESCRIPTION: Proposes a redesign of the Hashable trait to follow data flow principles, using the new Hasher trait for more flexible and guided hash implementation.\nSOURCE: https://github.com/modular/max/blob/main/mojo/proposals/improved-hash-module.md#2025-04-17_snippet_4\n\nLANGUAGE: mojo\nCODE:\n```\ntrait Hashable:\n    fn hash_with[H: Hasher](self, mut hasher: H):\n        ...\n```\n\n----------------------------------------\n\nTITLE: Running Single File Tests in Mojo\nDESCRIPTION: Executes tests from a specific test file with import path configuration\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/tools/testing.mdx#2025-04-17_snippet_9\n\nLANGUAGE: bash\nCODE:\n```\nmojo test -I src test/my_math/test_dec.mojo\n```\n\n----------------------------------------\n\nTITLE: Redundant Custom Destructor Implementation in Mojo\nDESCRIPTION: This example shows a struct with an empty destructor implementation. Even with this empty implementation, Mojo still automatically destroys all the fields when they're last used.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/lifecycle/death.mdx#2025-04-17_snippet_3\n\nLANGUAGE: mojo\nCODE:\n```\nstruct MyPet:\n    var name: String\n    var age: Int\n\n    fn __init__(out self, name: String, age: Int):\n        self.name = name\n        self.age = age\n\n    fn __del__(owned self):\n        # Mojo destroys all the fields when they're last used\n        pass\n```\n\n----------------------------------------\n\nTITLE: Alternative Mojo Lifetime Syntax Options\nDESCRIPTION: Various alternative syntax options for expressing lifetime parameters in Mojo, showing different ways to parameterize references with lifetimes.\nSOURCE: https://github.com/modular/max/blob/main/mojo/proposals/lifetimes-and-provenance.md#2025-04-17_snippet_3\n\nLANGUAGE: mojo\nCODE:\n```\nfn f(x: ref[a] String, y: mutref[a] String): ... # Homage to Rust!\nfn f(x: ref(a) String, y: mutref(a) String): ... # Homage to Rust!\nfn f(x: ref a String,  y: mutref a String): ... # Homage to Rust!\nfn f(x: ref 'a String, y: mutref 'a String): ... # Homage to Rust!\nfn f(x: 'a String,     y: mut 'a String): ... # Homage to Rust!\n```\n\n----------------------------------------\n\nTITLE: Current Required Parameter Specification in Mojo\nDESCRIPTION: Shows the current limitation in Mojo where a type parameter must be explicitly specified even when it could be inferred from another parameter.\nSOURCE: https://github.com/modular/max/blob/main/mojo/proposals/inferred-parameters.md#2025-04-17_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nscalar_param[DType.int32, Int32()]() # 'dt' parameter is required\n```\n\n----------------------------------------\n\nTITLE: Non-Movable Results Handling in Mojo\nDESCRIPTION: Demonstrates a potential future syntax for handling non-movable results with multiple return values, showing how unpacking could work.\nSOURCE: https://github.com/modular/max/blob/main/mojo/proposals/ref-convention.md#2025-04-17_snippet_8\n\nLANGUAGE: mojo\nCODE:\n```\nfn do_stuff() -> result: NonMovable:\n  var a : NonMovable\n  a, result = f()\n```\n\n----------------------------------------\n\nTITLE: Defining a Dependent Type Function in Mojo\nDESCRIPTION: This code snippet demonstrates the definition of a function with dependent types in Mojo. It shows how parameter types can depend on other parameters and how the return type is symbolically represented.\nSOURCE: https://github.com/modular/max/blob/main/mojo/stdlib/docs/internal/mlir.md#2025-04-17_snippet_0\n\nLANGUAGE: Mojo\nCODE:\n```\nfn thing[a: Int, b: Int](x: T[a], y: T[b]) -> T[a+b]:\n    ...\n```\n\n----------------------------------------\n\nTITLE: Successful Test Output in Plaintext\nDESCRIPTION: This snippet shows the output of a successful test run, indicating the number of tests passed and the execution time.\nSOURCE: https://github.com/modular/max/blob/main/mojo/stdlib/docs/development.md#2025-04-17_snippet_11\n\nLANGUAGE: plaintext\nCODE:\n```\nTesting Time: 0.65s\n\nTotal Discovered Tests: 1\n  Passed: 1 (100.00%)\n```\n\n----------------------------------------\n\nTITLE: Using Direct Origin References in ref Arguments\nDESCRIPTION: Example showing how `ref` arguments and results can now directly use a memory value in the origin specifier without requiring `__origin_of()`, simplifying return references to arguments.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_30\n\nLANGUAGE: mojo\nCODE:\n```\nfn return_ref(a: String) -> ref [a] String:\n    return a\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Type Rebinding Issues with Parameter Expressions\nDESCRIPTION: Example showing how the current implementation requires complex rebinding logic. The variable x should have type SIMD[dt2, 8] but is initially typed as SIMD[dt, Int.add(4, 4)], requiring special handling to resolve correctly.\nSOURCE: https://github.com/modular/max/blob/main/mojo/proposals/always_inline_builtin.md#2025-04-17_snippet_1\n\nLANGUAGE: mojo\nCODE:\n```\nfn example[dt2: DType](a: SIMD[dt2, 4]):\nvar x = widen(a, a)\n```\n\n----------------------------------------\n\nTITLE: Collecting Tests with JSON Output in Mojo\nDESCRIPTION: Discovers and lists tests in JSON format using both --diagnostic-format json and --collect-only options\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/tools/testing.mdx#2025-04-17_snippet_13\n\nLANGUAGE: bash\nCODE:\n```\nmojo test --diagnostic-format json --co test\n```\n\n----------------------------------------\n\nTITLE: Implementing Explicit Destruction Controls in Mojo\nDESCRIPTION: Shows new annotations and keywords for the experimental explicitly destroyed types feature, including @explicit_destroy annotation, __disable_del keyword, and related traits.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_37\n\nLANGUAGE: mojo\nCODE:\n```\n@explicit_destroy\n```\n\nLANGUAGE: mojo\nCODE:\n```\n__disable_del\n```\n\nLANGUAGE: mojo\nCODE:\n```\nUnknownDestructibility\n```\n\nLANGUAGE: mojo\nCODE:\n```\nImplicitlyDestructible\n```\n\n----------------------------------------\n\nTITLE: Using Assert True with Custom Error Message\nDESCRIPTION: Example of using assert_true with a custom error message. The assertion will fail because the value is False, demonstrating how custom error messages appear in test failures.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/tools/testing.mdx#2025-04-17_snippet_2\n\nLANGUAGE: mojo\nCODE:\n```\nfrom testing import *\nassert_true(False)\n```\n\n----------------------------------------\n\nTITLE: Fixing the Test Function in Mojo\nDESCRIPTION: This snippet shows how to fix the test function by using assert_true and checking if the function output starts with the expected prefix.\nSOURCE: https://github.com/modular/max/blob/main/mojo/stdlib/docs/development.md#2025-04-17_snippet_10\n\nLANGUAGE: mojo\nCODE:\n```\ndef test_get_cwd_message():\n    assert_true(get_cwd_message().startswith(\"Your cwd is:\"))\n```\n\n----------------------------------------\n\nTITLE: Defining Current Hashable Trait in Mojo\nDESCRIPTION: Shows the current implementation of the Hashable trait, which requires returning an Int value. This design has limitations in flexibility and guidance for hash computation.\nSOURCE: https://github.com/modular/max/blob/main/mojo/proposals/improved-hash-module.md#2025-04-17_snippet_0\n\nLANGUAGE: mojo\nCODE:\n```\ntrait Hashable:\n    fn __hash__(self) -> Int:\n        ...\n```\n\n----------------------------------------\n\nTITLE: SIMD Implementation with Requires Clauses\nDESCRIPTION: Proposed syntax for SIMD implementation using requires clauses for compile-time validation.\nSOURCE: https://github.com/modular/max/blob/main/mojo/proposals/requires-clause.md#2025-04-17_snippet_4\n\nLANGUAGE: mojo\nCODE:\n```\nstruct SIMD[dtype: DType, size: Int]\n  requires size.is_power_of_two(), \"simd width must be power of 2\"\n  requires dtype is not DType.invalid, \"simd type cannot be DType.invalid\"\n  \n    @implicit\n    fn __init__(out self, value: FloatLiteral)\n      requires dtype.is_floating_point():\n        <actual code>\n```\n\n----------------------------------------\n\nTITLE: Setting Breakpoints in CUDA-GDB\nDESCRIPTION: Commands for setting breakpoints in CUDA-GDB. Shows both the full 'break' command and its abbreviated 'b' form for setting breakpoints at specific file locations.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/tools/gpu-debugging.mdx#2025-04-17_snippet_3\n\nLANGUAGE: plaintext\nCODE:\n```\nbreak filename.mojo:line_number\nb filename.mojo:line_number\n```\n\n----------------------------------------\n\nTITLE: Using Custom Error Messages with Assertions\nDESCRIPTION: Example showing how to provide a custom error message with an assertion that will fail. The custom message will be included in the error output.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/tools/testing.mdx#2025-04-17_snippet_3\n\nLANGUAGE: mojo\nCODE:\n```\nassert_true(False, msg=\"paradoxes are not allowed\")\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Duck Typing in Python\nDESCRIPTION: This Python code snippet shows how duck typing works in dynamically-typed languages, where two unrelated classes can be used interchangeably based on their implemented methods.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/traits.mdx#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n%%python\nclass Duck:\n    def quack(self):\n        print(\"Quack.\")\n\nclass StealthCow:\n    def quack(self):\n        print(\"Moo!\")\n\ndef make_it_quack_python(maybe_a_duck):\n    try:\n        maybe_a_duck.quack()\n    except:\n        print(\"Not a duck.\")\n\nmake_it_quack_python(Duck())\nmake_it_quack_python(StealthCow())\n```\n\n----------------------------------------\n\nTITLE: Indexing UnsafePointer with SIMD Scalar Integral Types\nDESCRIPTION: Example showing how to index into an UnsafePointer using SIMD scalar integral types like UInt8.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_42\n\nLANGUAGE: mojo\nCODE:\n```\np = UnsafePointer[Int].alloc(1)\ni = UInt8(1)\np[i] = 42\nprint(p[i])\n```\n\n----------------------------------------\n\nTITLE: MAX Engine Integration Setup\nDESCRIPTION: Initial setup for using MAX Engine with the converted ONNX model\nSOURCE: https://github.com/modular/max/blob/main/examples/notebooks/mistral7b-python-onnx.ipynb#2025-04-17_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n%%time\n\nfrom max import engine\n```\n\n----------------------------------------\n\nTITLE: Explicit Variable Declaration with Type Annotation\nDESCRIPTION: Demonstrates explicit variable declaration using var keyword with type annotation.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/variables.mdx#2025-04-17_snippet_5\n\nLANGUAGE: mojo\nCODE:\n```\nvar name = String(\"Sam\")\nvar user_id: Int\n```\n\n----------------------------------------\n\nTITLE: Function Call Requiring Explicit Type Construction\nDESCRIPTION: Example demonstrating how implicit conversion from `Int` to `Foo` is no longer supported by default in Mojo, requiring explicit construction of the `Foo` type when calling a function that expects a `Foo` parameter.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_28\n\nLANGUAGE: mojo\nCODE:\n```\nfn func(foo: Foo):\n    print(\"implicitly converted Int to Foo:\", foo.value)\n\nfn main():\n    func(Int(42))\n```\n\n----------------------------------------\n\nTITLE: Mojo Conditional Parameter Return\nDESCRIPTION: Example of returning different parameters based on conditional branches using @parameter if.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_211\n\nLANGUAGE: mojo\nCODE:\n```\nfn bar[in: Bool -> out: Int]():\n    @parameter\n    if in:\n        param_return[1]\n    else:\n        param_return[2]\n```\n\n----------------------------------------\n\nTITLE: C++ Template Type Inference Example\nDESCRIPTION: Demonstrates C++'s ability to infer template parameter types from function arguments, showing both explicit and implicit type specification.\nSOURCE: https://github.com/modular/max/blob/main/mojo/proposals/inferred-parameters.md#2025-04-17_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\ntemplate <typename T>\nvoid inferMe(T x) {}\n\nint x = 1;\ninferMe(x);\n// Equivalent to\ninferMe<int>(x);\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Supported Type Value Patterns in Mojo\nDESCRIPTION: Examples of type value patterns that are still supported in Mojo, including alias declarations and type parameters in function declarations.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_102\n\nLANGUAGE: mojo\nCODE:\n```\nalias t = Int  # still 🔥\n\nstruct SomeType: ...\n\ntakes_type[SomeType]()  # already 🔥\n\n>fn uses_trait[T: SomeTrait](value: T): ... # still 🔥\n```\n\n----------------------------------------\n\nTITLE: Alternative Memory-Only Variadic Handling in Mojo\nDESCRIPTION: Alternative approach to handling memory-only types in variadic arguments using indexing.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/functions.mdx#2025-04-17_snippet_13\n\nLANGUAGE: mojo\nCODE:\n```\nfn make_worldly(mut *strs: String):\n    # This \"just works\" as you'd expect!\n    for i in range(len(strs)):\n        strs[i] += \" world\"\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Bit Shift Difference between Int8 and UInt8 in Mojo\nDESCRIPTION: This snippet shows how right bit shift operations differ between signed and unsigned 8-bit integers with the same bit pattern. It demonstrates that -1 (Int8) and 255 (UInt8) produce different results when right-shifted by 1.\nSOURCE: https://github.com/modular/max/blob/main/mojo/proposals/byte-as-uint8.md#2025-04-17_snippet_1\n\nLANGUAGE: Mojo\nCODE:\n```\n-1 >> 1  # results in -1 (same bit pattern)\n255 >> 1 # results in 127 (bx01111111)\n```\n\n----------------------------------------\n\nTITLE: Proposing Hasher Trait in Mojo\nDESCRIPTION: Introduces a new Hasher trait to define an abstraction for hashing algorithms, allowing for streaming creation of hash values and flexibility in implementation.\nSOURCE: https://github.com/modular/max/blob/main/mojo/proposals/improved-hash-module.md#2025-04-17_snippet_2\n\nLANGUAGE: mojo\nCODE:\n```\ntrait Hasher:\n    \"\"\"Trait which every hash function implementer needs to implement.\"\"\"\n    fn __init__(out self):\n        \"\"\"Expects a no argument instantiation.\"\"\"\n        ...\n    fn _update_with_bytes(mut self, bytes: DTypePointer[DType.uint8], n: Int):\n        \"\"\"Conribute to the hash value based on a sequence of bytes. Use only for complex types which are not just a composition of Hashable types.\"\"\"\n        ...\n    fn _update_with_simd[dt: DType, size: Int](mut self, value: SIMD[dt, size]):\n        \"\"\"Contribute to the hash value with a compile time know fix size value. Used inside of std lib to avoid runtime branching.\"\"\"\n        ...\n    fn update[T: Hashable](mut self, value: T):\n        \"\"\"Contribute to the hash value with a Hashable value. Should be used by implementors of Hashable types which are a composition of Hashable types.\"\"\"\n        ...\n    fn _finish[dt: DType = DType.uint64](owned self) -> Scalar[dt]:\n        \"\"\"Used internally to generate the final hash value, should be simplified to `_finish(owned self) -> Scalar[hash_value_dt]`\n        once trait declarations support parameters and we can switch to `trait Hasher[hash_value_dt: DType]`.\n        This is beneficial as hash functions have different implementations based on the type \"\"\"\n        ...\n```\n\n----------------------------------------\n\nTITLE: Using Assert Raises with Error Message Verification\nDESCRIPTION: Example demonstrating how to use assert_raises with the 'contains' parameter to verify that an error message contains a specific substring. The first test passes while the second fails.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/tools/testing.mdx#2025-04-17_snippet_6\n\nLANGUAGE: mojo\nCODE:\n```\nprint(\"Test passes because the error contains the substring\")\nwith assert_raises(contains=\"required\"):\n    raise Error(\"missing required argument\")\n\nprint(\"Test fails because the error doesn't contain the substring\")\nwith assert_raises(contains=\"required\"):\n    raise Error(\"invalid value\")\n```\n\n----------------------------------------\n\nTITLE: Common Operations Usage in MLIR POP Dialect\nDESCRIPTION: Examples of SIMD arithmetic, array operations, and memory operations\nSOURCE: https://github.com/modular/max/blob/main/mojo/stdlib/docs/internal/pop_dialect.md#2025-04-17_snippet_7\n\nLANGUAGE: mlir\nCODE:\n```\n// SIMD arithmetic\n%c = pop.add %a, %b : !pop.scalar<f32>\n%d = pop.mul %c, %c : !pop.simd<4, f32>\n\n// Array operations\n%arr = pop.array.create %x, %y, %z : !pop.array<3, f32>\n%elem = pop.array.get %arr[1] : !pop.array<3, f32>\n\n// Memory operations\n%ptr = pop.aligned_alloc %align, %size : !pop.pointer<f32>\npop.store %value, %ptr : !pop.pointer<f32>\n```\n\n----------------------------------------\n\nTITLE: Controlling Auto-Dereferencing in Mojo Function Results\nDESCRIPTION: Demonstrates how developers can control auto-dereferencing behavior by choosing between 'ref' and 'Reference' in function return types.\nSOURCE: https://github.com/modular/max/blob/main/mojo/proposals/ref-convention.md#2025-04-17_snippet_4\n\nLANGUAGE: mojo\nCODE:\n```\nfn yes_auto_deref(...) -> ref [lifetime] Int: ...\nfn no_auto_deref(...) -> Reference[Int, lifetime]: ...\n```\n\n----------------------------------------\n\nTITLE: Union Type Declaration in MLIR POP Dialect\nDESCRIPTION: Examples of union type declarations showing empty, single-type, and multi-type unions\nSOURCE: https://github.com/modular/max/blob/main/mojo/stdlib/docs/internal/pop_dialect.md#2025-04-17_snippet_2\n\nLANGUAGE: mlir\nCODE:\n```\n!pop.union<> // Empty union\n!pop.union<i32> // Union of just int32 types\n!pop.union<i32, i64> // Union of int32 and int64 types.\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Division Difference between Int8 and UInt8 in Mojo\nDESCRIPTION: This snippet illustrates how division results differ between signed and unsigned 8-bit integers with the same bit pattern. It shows that -4 (Int8) and 252 (UInt8) produce different results when divided by 4.\nSOURCE: https://github.com/modular/max/blob/main/mojo/proposals/byte-as-uint8.md#2025-04-17_snippet_0\n\nLANGUAGE: Mojo\nCODE:\n```\n-4 // 4  # equals to -1 (bx11111111)\n252 // 4 # equals to 63 (bx00111111)\n```\n\n----------------------------------------\n\nTITLE: Setting Up Conda Environment and Running Example\nDESCRIPTION: Commands to create a Conda environment, install dependencies from the environment.yml file, and run the example script.\nSOURCE: https://github.com/modular/max/blob/main/examples/inference/resnet50-python-torchscript/README.md#2025-04-17_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n# Create a Conda environment if you don't have one\nconda create -n max-repo\n# Update the environment with the environment.yml file\nconda env update -n max-repo -f environment.yml --prune\n# Run the example\nconda run -n max-repo --live-stream bash run.sh\n```\n\n----------------------------------------\n\nTITLE: Using FileHandle.seek() with Whence Parameter in Mojo\nDESCRIPTION: Examples of using the enhanced FileHandle.seek() method with the new whence parameter, allowing seeking from current position or end of file in addition to the beginning.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_94\n\nLANGUAGE: mojo\nCODE:\n```\nvar f = open(\"/tmp/example.txt\")\n# Skip 32 bytes\nf.seek(os.SEEK_CUR, 32)\n```\n\nLANGUAGE: mojo\nCODE:\n```\n# Start from 32 bytes before the end of the file\nf.seek(os.SEEK_END, -32)\n```\n\n----------------------------------------\n\nTITLE: Pre-commit Manual Run Command\nDESCRIPTION: Command for manually running pre-commit hooks on all files.\nSOURCE: https://github.com/modular/max/blob/main/mojo/stdlib/docs/style-guide.md#2025-04-17_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\npre-commit run --all-files\n```\n\n----------------------------------------\n\nTITLE: Value Semantics in Mojo 'fn' Functions\nDESCRIPTION: This example shows how 'fn' functions in Mojo receive arguments as immutable references by default. It demonstrates making an explicit copy to modify the value locally.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/values/value-semantics.mdx#2025-04-17_snippet_3\n\nLANGUAGE: mojo\nCODE:\n```\nfn add_two(y: Int):\n    # y += 2 # This will cause a compiler error because `y` is immutable\n    # We can instead make an explicit copy:\n    var z = y\n    z += 2\n    print(z)\n\nx = 1\nadd_two(x)\nprint(x)\n```\n\n----------------------------------------\n\nTITLE: Keyword Parameter Inference in Mojo\nDESCRIPTION: Demonstrates how keyword arguments can enable parameter inference by allowing specification of parameters out of order.\nSOURCE: https://github.com/modular/max/blob/main/mojo/proposals/inferred-parameters.md#2025-04-17_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nscalar_param[x=Int32()]() # 'dt' is inferred from 'x'\n```\n\n----------------------------------------\n\nTITLE: UnsafePointer Mutability Example\nDESCRIPTION: Demonstrates the new UnsafePointer mutability inference when using address_of().\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_17\n\nLANGUAGE: mojo\nCODE:\n```\nvar local = 10\n# Constructs a mutable pointer, because `local` is a mutable memory location\nvar ptr = UnsafePointer.address_of(local)\n```\n\n----------------------------------------\n\nTITLE: Using Hidden Code Lines in Mojo Docstrings\nDESCRIPTION: Example demonstrating the new %# syntax to hide lines of code in documentation generation while still executing them during tests.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_110\n\nLANGUAGE: mojo\nCODE:\n```\nvar value = 5\n%# print(value)\n```\n\n----------------------------------------\n\nTITLE: First-Class Reference Type Example in Mojo\nDESCRIPTION: Example showing potential future syntax for using references as first-class types in collections and return values.\nSOURCE: https://github.com/modular/max/blob/main/mojo/proposals/resyntaxing-arg-conventions-and-refs.md#2025-04-17_snippet_5\n\nLANGUAGE: mojo\nCODE:\n```\nstruct Dict[K: KeyElement, V: CollectionElement]:\n    ...\n    fn __getitem__(self, key: K) -> Optional[ref [...] Self.V]:\n        ...\n```\n\n----------------------------------------\n\nTITLE: Python-Mojo Pointer Integration\nDESCRIPTION: Example of creating an UnsafePointer from a NumPy array pointer using unsafe_get_as_pointer().\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/pointers/unsafe-pointers.mdx#2025-04-17_snippet_18\n\nLANGUAGE: mojo\nCODE:\n```\nfrom python import Python\nfrom memory import UnsafePointer\n\ndef share_array():\n    np = Python.import_module(\"numpy\")\n    arr = np.array([1, 2, 3, 4, 5, 6, 7, 8, 9])\n    ptr = arr.ctypes.data.unsafe_get_as_pointer[DType.int64]()\n    for i in range(9):\n        print(ptr[i], end=\", \")\n\nshare_array()\n```\n\n----------------------------------------\n\nTITLE: String Literal Type Merging Example in Mojo\nDESCRIPTION: Example showing limitations in merging different string literals. Currently this produces an error, but the desired behavior would promote both literals to a StaticString type.\nSOURCE: https://github.com/modular/max/blob/main/mojo/proposals/custom-type-merging.md#2025-04-17_snippet_2\n\nLANGUAGE: mojo\nCODE:\n```\nfn ptr_example(mut x: Int, mut y: Int, cond: Bool):\n  alias s1 = \"hello\"    # Type = StringLiteral[\"hello\"]\n  alias s2 = \"goodbye\"  # Type = StringLiteral[\"goodbye\"]\n\n  # Currently error: can't merge two different types.\n  alias someStr = s1 if cond else s2\n  # Desired type: StaticString\n```\n\n----------------------------------------\n\nTITLE: Conditional Debugging with Command-line Parameters in Mojo\nDESCRIPTION: Shows how to implement conditional debugging using command-line parameters. Uses the param_env module to check if a debug flag is defined, allowing selective activation of breakpoints through command-line arguments.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/tools/debugging.mdx#2025-04-17_snippet_6\n\nLANGUAGE: mojo\nCODE:\n```\nfrom param_env import is_defined\n\ndef some_function_with_issues():\n    # ...\n    @parameter\n    if is_defined[\"DEBUG_ME\"]():\n        breakpoint()\n```\n\n----------------------------------------\n\nTITLE: GPU Debug Assert Implementation\nDESCRIPTION: Demonstrates the behavior of debug_assert in AMD GPU kernels, showing how it prints thread information and variadic arguments when assertions fail.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog.md#2025-04-17_snippet_2\n\nLANGUAGE: mojo\nCODE:\n```\nfrom gpu.host import DeviceContext\n\nfn kernel():\n    var x = 1\n    debug_assert(x == 2, \"x should be 2 but is: \", x)\n\ndef main():\n    with DeviceContext() as ctx:\n        ctx.enqueue_function[kernel](grid_dim=2, block_dim=2)\n```\n\nLANGUAGE: text\nCODE:\n```\nAt /tmp/test.mojo:5:17: block: [0,0,0] thread: [0,0,0] Assert Error: x should be 2 but is: 1\nAt /tmp/test.mojo:5:17: block: [0,0,0] thread: [1,0,0] Assert Error: x should be 2 but is: 1\nAt /tmp/test.mojo:5:17: block: [1,0,0] thread: [0,0,0] Assert Error: x should be 2 but is: 1\nAt /tmp/test.mojo:5:17: block: [1,0,0] thread: [1,0,0] Assert Error: x should be 2 but is: 1\n```\n\n----------------------------------------\n\nTITLE: Type Conversion Operations in MLIR POP Dialect\nDESCRIPTION: Example of converting between POP types and MLIR builtin types using cast operations\nSOURCE: https://github.com/modular/max/blob/main/mojo/stdlib/docs/internal/pop_dialect.md#2025-04-17_snippet_3\n\nLANGUAGE: mlir\nCODE:\n```\nkgen.func @llvm_ops(%arg0: !pop.scalar<f32>) -> !pop.scalar<f32> {\n  %0 = pop.cast_to_builtin %arg0 : !pop.scalar<f32> to f32\n  %1 = llvm.fadd %0, %0 : f32\n  %2 = pop.cast_from_builtin %1 : f32 to !pop.scalar<f32>\n  kgen.return %2 : !pop.scalar<f32>\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Reference Convention Limitations in Mojo\nDESCRIPTION: Shows how reference conventions work as argument decorators but not as first-class types, contrasting with Rust's approach. Demonstrates limitations with nested references and local variables.\nSOURCE: https://github.com/modular/max/blob/main/mojo/proposals/ref-convention.md#2025-04-17_snippet_6\n\nLANGUAGE: mojo\nCODE:\n```\nfn weird_tests[life1: Lifetime, life2: Lifetime](\n           ref [life1] arg1: Int,  ## ok\n\n           # error: 'ref' is an argument convention, not a type.\n           ref [life1] arg2: ref [life2] Int,\n\n           # This is ok\n           ref [life1] arg3: Pointer[Int, life2]):\n\n    # error: 'ref' is an argument convention, not a type.\n    var local1: ref [life1] Int\n    var local2: Pointer[Int, life1] # ok!\n```\n\n----------------------------------------\n\nTITLE: Specifying Python Package Dependencies for Max Project\nDESCRIPTION: This snippet lists the required Python packages and their versions for the Max project. It includes an extra index URL for PyTorch CPU wheels and specifies version constraints for various libraries used in computer vision and machine learning tasks.\nSOURCE: https://github.com/modular/max/blob/main/examples/inference/yolo-python-onnx/requirements.txt#2025-04-17_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\n--extra-index-url https://download.pytorch.org/whl/cpu\n\nnetworkx==3.1\ntorch==2.6.0\nonnxruntime==1.17.3\nopencv-python==4.9.0.80\nultralytics==8.2.5\nnumpy<2.0\n```\n\n----------------------------------------\n\nTITLE: For Loop with Continue Statement in Mojo\nDESCRIPTION: Shows how to skip a specific iteration in a for loop using the continue statement.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/control-flow.mdx#2025-04-17_snippet_17\n\nLANGUAGE: mojo\nCODE:\n```\nfor i in range(5):\n    if i == 3:\n        continue\n    print(i, end=\", \")\n```\n\n----------------------------------------\n\nTITLE: LValue Address Conversion in Mojo\nDESCRIPTION: Example showing how to use __get_address_as_lvalue to convert between stored LValues and pointer types for memory management.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_206\n\nLANGUAGE: mojo\nCODE:\n```\n# \"Replacement new\" SomeHeavy value into the memory pointed to by a\n# Pointer[SomeHeavy].\n__get_address_as_lvalue(somePointer.value) = SomeHeavy(4, 5)\n```\n\n----------------------------------------\n\nTITLE: Documenting Fields and Aliases in Mojo\nDESCRIPTION: Example demonstrating how to document fields and aliases with descriptive docstrings.\nSOURCE: https://github.com/modular/max/blob/main/mojo/stdlib/docs/docstring-style-guide.md#2025-04-17_snippet_3\n\nLANGUAGE: mojo\nCODE:\n```\nalias FORWARD = 0\n\"\"\"Perform the forward operation.\"\"\"\n\nalias REVERSE = 1\n\"\"\"Perform the reverse operation.\"\"\"\n\nvar label: Int\n\"\"\"The class label ID.\"\"\"\n\nvar score: Float64\n\"\"\"The prediction score.\"\"\"\n```\n\n----------------------------------------\n\nTITLE: Declaring Main Function in Mojo\nDESCRIPTION: Example of declaring the required main() function as an entry point in a Mojo program. Every Mojo file must include this function as top-level code is not supported.\nSOURCE: https://github.com/modular/max/blob/main/examples/gui/ragdata/mojo_functions.txt#2025-04-17_snippet_2\n\nLANGUAGE: mojo\nCODE:\n```\ndef main():\n   print(\"Hello, world!\")\n```\n\n----------------------------------------\n\nTITLE: Improved Type Error Messages in Mojo\nDESCRIPTION: Example showing the improvement in error message formatting for type conversion errors, with simplified type names that exclude inferred or defaulted parameters.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_44\n\nLANGUAGE: plaintext\nCODE:\n```\n... cannot be converted from 'UnsafePointer[UInt]' to 'UnsafePointer[Int]'\n```\n\n----------------------------------------\n\nTITLE: Simplified Internal Representation of Dependent Type in Mojo\nDESCRIPTION: This code shows the simplified internal representation of a dependent type in the Mojo compiler when using `always_inline(\"builtin\")`. It demonstrates how the compiler optimizes the expression for better constant folding.\nSOURCE: https://github.com/modular/max/blob/main/mojo/stdlib/docs/internal/mlir.md#2025-04-17_snippet_4\n\nLANGUAGE: Mojo\nCODE:\n```\nT[Int{index.add(a.value, b.value)}]\n```\n\n----------------------------------------\n\nTITLE: Implementing __merge_with__ Dunder for Pointer Types in Mojo\nDESCRIPTION: Implementation of the proposed __merge_with__ dunder method for Pointer types to enable merging pointers with different origins into a pointer with a union of origins.\nSOURCE: https://github.com/modular/max/blob/main/mojo/proposals/custom-type-merging.md#2025-04-17_snippet_5\n\nLANGUAGE: mojo\nCODE:\n```\nstruct Pointer[type, origin]:  # slightly simplified from pointer.mojo\n   fn __merge_with__[otherType: __type_of(Pointer[type, _])]\n      (self, out result: Pointer[type, __origin_of(self.origin, otherType.origin)):\n        return __type_of(result)(self._value)\n```\n\n----------------------------------------\n\nTITLE: Path Expansion in Filesystem Operations\nDESCRIPTION: Demonstrates the use of os.path.expanduser() to handle path expansion with home directory symbols.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_62\n\nLANGUAGE: mojo\nCODE:\n```\nimport os\nprint(os.path.expanduser(\"~/.modular\"))\n# /Users/username/.modular\nprint(os.path.expanduser(\"~root/folder\"))\n# /var/root/folder (on macos)\n# /root/folder     (on linux)\n```\n\n----------------------------------------\n\nTITLE: Creating InferenceSession and Loading ONNX Model with MAX Engine in Python\nDESCRIPTION: This snippet shows how to create an InferenceSession using MAX Engine and load an ONNX model file. It's the initial setup required for running inference with the Gemma 2B model.\nSOURCE: https://github.com/modular/max/blob/main/examples/notebooks/gemma2b-python-onnx.ipynb#2025-04-17_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nsession = engine.InferenceSession()\nmaxmodel = session.load(\"./onnx/gemma-2b-onnx/model.onnx\")\n```\n\n----------------------------------------\n\nTITLE: Workaround for Nested Function Naming in Mojo\nDESCRIPTION: Shows a workaround for naming conflicts in nested functions in Mojo by explicitly materializing them as dynamic values.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/roadmap.md#2025-04-17_snippet_6\n\nLANGUAGE: mojo\nCODE:\n```\ndef pick_func(cond)  -> def() capturing:\n    var result: def() capturing # Mojo function type\n    if cond:\n        def bar0(): return 42\n        result = bar0\n    else:\n        def bar1(): return 3\n        result = bar1\n    return result\n```\n\n----------------------------------------\n\nTITLE: Implementing Current Type Merging Algorithm in Mojo\nDESCRIPTION: Pseudo-code representation of Mojo's current type unification algorithm implemented in ExprEmitter::getCommonType. This algorithm handles identical types and implicit conversions but lacks support for more complex type merging scenarios.\nSOURCE: https://github.com/modular/max/blob/main/mojo/proposals/custom-type-merging.md#2025-04-17_snippet_0\n\nLANGUAGE: mojo\nCODE:\n```\nfn get_common_type(typea, typeb) raises -> Type:\n   # If the types are already identical, then we are done.\n   if typea == typeb:\n       return typea\n     \n   # Check for implicit conversions.\n   a_impl_converts_to_b = is_implicitly_convertible(typea -> typeb)\n   b_impl_converts_to_a = is_implicitly_convertible(typeb -> typea)\n   if b_impl_converts_to_a and a_impl_converts_to_b:\n       throw \"ambiguous conversion\"\n   if a_impl_converts_to_b:\n       return typeb  # Use implicit conversion\n   if b_impl_converts_to_a:\n       return typea  # Use implicit conversion\n   \n   # Elided: do similar test for @nonmaterializable types.\n   throw \"no common type found\"\n```\n\n----------------------------------------\n\nTITLE: Implementing __merge_with__ Dunder for StringLiteral in Mojo\nDESCRIPTION: Implementation of the proposed __merge_with__ dunder method for StringLiteral types to enable merging different string literals into a common StaticString type.\nSOURCE: https://github.com/modular/max/blob/main/mojo/proposals/custom-type-merging.md#2025-04-17_snippet_4\n\nLANGUAGE: mojo\nCODE:\n```\nstruct StringLiteral[value: ...]:  # slightly simplified from StringLiteral.mojo\n   fn __merge_with__[\n         otherType: __type_of(StringLiteral[_])\n      ](self) -> StaticString:\n        return self\n```\n\n----------------------------------------\n\nTITLE: Running Mojo Benchmark Command\nDESCRIPTION: Example command for running a specific benchmark file using the Mojo compiler. Shows how to execute a dictionary benchmark from the collections directory.\nSOURCE: https://github.com/modular/max/blob/main/mojo/stdlib/benchmarks/README.md#2025-04-17_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nmagic run mojo run stdlib/benchmarks/collections/bench_dict.mojo\n```\n\n----------------------------------------\n\nTITLE: Using String.format() with Manual Indexing\nDESCRIPTION: Demonstrates the String.format() method with manual indexing of arguments, allowing for precise control over argument placement in the formatted string.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_54\n\nLANGUAGE: mojo\nCODE:\n```\nprint(\n  String(\"{1} Welcome to {0} {1}\").format(\"mojo\", \"🔥\")\n)\n# 🔥 Wecome to mojo 🔥\n```\n\n----------------------------------------\n\nTITLE: Creating a Mojo Project with Magic CLI\nDESCRIPTION: Commands to initialize a new Mojo project using Magic CLI and add dependencies like NumPy to the project environment.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/python/index.mdx#2025-04-17_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\nmagic init my-mojo-project --format mojoproject\n```\n\nLANGUAGE: sh\nCODE:\n```\ncd my-mojo-project\n```\n\nLANGUAGE: sh\nCODE:\n```\nmagic add \"numpy>=2.0\"\n```\n\n----------------------------------------\n\nTITLE: Lifetime Parameterized Struct in Mojo\nDESCRIPTION: Example of a struct that contains a reference by parameterizing it with a lifetime. The StringRef struct contains a pointer to a string with an explicit lifetime parameter.\nSOURCE: https://github.com/modular/max/blob/main/mojo/proposals/lifetimes-and-provenance.md#2025-04-17_snippet_4\n\nLANGUAGE: mojo\nCODE:\n```\nstruct StringRef[life: Lifetime]:\n    var data : Pointer[UInt8, life]\n    var len : Int\n```\n\n----------------------------------------\n\nTITLE: Main Program Using Pathlib in Mojo\nDESCRIPTION: Example main program demonstrating usage of the new pathlib.get_cwd_message function\nSOURCE: https://github.com/modular/max/blob/main/mojo/stdlib/docs/development.md#2025-04-17_snippet_3\n\nLANGUAGE: mojo\nCODE:\n```\nfrom src import pathlib\n\ndef main():\n    print(pathlib.get_cwd_message())\n```\n\n----------------------------------------\n\nTITLE: Demonstrating 'let' to 'var' Migration in Mojo\nDESCRIPTION: This snippet shows how 'let' declarations are now treated as 'var' declarations with a warning, as part of the process of removing 'let' declarations from the language.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_126\n\nLANGUAGE: mojo\nCODE:\n```\nfn test():\n    # treated as a var, but please update your code!\n    let x = 42  # warning: 'let' is being removed, please use 'var' instead\n    x = 9\n```\n\n----------------------------------------\n\nTITLE: Or Expression Behavior with StringLiteral in Mojo\nDESCRIPTION: Illustrates the different behavior of the 'or' expression when using String vs StringLiteral in Mojo.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/roadmap.md#2025-04-17_snippet_9\n\nLANGUAGE: mojo\nCODE:\n```\nfn main():\n    var g: Int = 0\n    var h: String = \"hello\"\n    print(g or h)  # prints `hello`\n    print(g or \"hello\")  # prints `True`\n```\n\n----------------------------------------\n\nTITLE: Implementing Next Token Generation Loop\nDESCRIPTION: Implements a simplified version of the token generation loop, demonstrating how to use the model's forward method to generate text iteratively.\nSOURCE: https://github.com/modular/max/blob/main/examples/notebooks/gemma2b-python-onnx.ipynb#2025-04-17_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom time import time\nfrom transformers.generation.logits_process import LogitsProcessorList\n\nlogits_processor = LogitsProcessorList()\n\ntime_start = time()\ncurrent_seq = input_ids.input_ids\nN_TOKENS = 10\nfor idx in range(N_TOKENS):\n    # Run model's `forward` on the current sequence.\n    # 'logits' output would let us determine the next token for this sequence\n    outputs = hfmodel(current_seq, return_dict=True).logits\n\n    # Get the newly generated next token\n    next_token_logits = outputs[:, -1, :]\n    next_tokens_scores = logits_processor(current_seq, next_token_logits)\n    next_tokens = torch.argmax(next_tokens_scores, dim=-1)\n\n    print(hftokenizer.decode(next_tokens), end=' ', flush=True)\n\n    # Append the new token to our sequence\n    current_seq = torch.cat([current_seq, next_tokens[:, None]], dim=-1)\n\ntime_finish = time()\nprint(f\"Prompt: {PROMPT}\")\nprint(\"Response:\", hftokenizer.batch_decode(current_seq, skip_special_tokens=True)[0][len(PROMPT):])\nprint(f\"Tokens per second: {N_TOKENS / (time_finish - time_start):.2f}\\n\")\n```\n\n----------------------------------------\n\nTITLE: Implicit Lifetime Parameter Declaration Examples\nDESCRIPTION: Shows potential syntax for implicit lifetime declarations in function signatures, though noted as not recommended for near-term implementation.\nSOURCE: https://github.com/modular/max/blob/main/mojo/proposals/lifetimes-and-provenance.md#2025-04-17_snippet_7\n\nLANGUAGE: mojo\nCODE:\n```\nfn longest(x: ref[life] String,\n           y: ref[life] String) -> ref[life] String:\n\n# Alternatively follow Rust's lead.\nfn longest(x: 'life String, y: 'life String) -> 'life String:\n```\n\n----------------------------------------\n\nTITLE: Complex Debug Assertion with Closure in Mojo\nDESCRIPTION: Shows how to use debug assertions with closures for handling side effects and complex conditions.\nSOURCE: https://github.com/modular/max/blob/main/mojo/stdlib/docs/style-guide.md#2025-04-17_snippet_12\n\nLANGUAGE: mojo\nCODE:\n```\ntensor = Tensor[DType.uint8, 1](TensorShape(1), cpu_device())\n\nfn _test_cpu() capturing -> Bool:\n    return \"cpu\" in String(tensor._device)\n\ndebug_assert[_test_cpu](\"This code is only runnable on CPU\")\n```\n\n----------------------------------------\n\nTITLE: Environment Configuration\nDESCRIPTION: Sets environment variables to suppress unnecessary logging output.\nSOURCE: https://github.com/modular/max/blob/main/examples/notebooks/roberta-python-pytorch.ipynb#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n# suppress extraneous logging\nimport os\nos.environ[\"TRANSFORMERS_VERBOSITY\"] = \"critical\"\nos.environ[\"TOKENIZERS_PARALLELISM\"] = \"false\"\n```\n\n----------------------------------------\n\nTITLE: Importing Module Members in __init__.mojo\nDESCRIPTION: This example shows how to import a module member (MyPair) in the __init__.mojo file of a package, making it directly accessible from the package name.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/packages.md#2025-04-17_snippet_6\n\nLANGUAGE: mojo\nCODE:\n```\nfrom .mymodule import MyPair\n```\n\n----------------------------------------\n\nTITLE: Input Processing and Inference Execution\nDESCRIPTION: Processes text input and runs inference using the loaded model.\nSOURCE: https://github.com/modular/max/blob/main/examples/notebooks/roberta-python-pytorch.ipynb#2025-04-17_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nINPUT=\"There are many exciting developments in the field of AI Infrastructure!\"\n\ntokenizer = AutoTokenizer.from_pretrained(HF_MODEL_NAME)\ninputs = tokenizer(INPUT, return_tensors=\"pt\", padding='max_length', truncation=True, max_length=seqlen)\nprint(inputs)\n\noutputs = model.execute(**inputs)\nprint(outputs)\n```\n\n----------------------------------------\n\nTITLE: C++ List Iterator Equivalent Implementation\nDESCRIPTION: C++ equivalent implementation showing explicit pointer dereferencing when iterating over a list and passing references to functions.\nSOURCE: https://github.com/modular/max/blob/main/mojo/stdlib/docs/faq.md#2025-04-17_snippet_1\n\nLANGUAGE: c++\nCODE:\n```\nvoid use(const Element &elt) {...}\nvoid test(const list<Element> &list) {\n  for (Element *e : list) {\n    use(*e);\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Running Unit Tests with Magic\nDESCRIPTION: Command to execute unit tests for both Grid implementations using the Mojo testing framework.\nSOURCE: https://github.com/modular/max/blob/main/examples/mojo/life/README.md#2025-04-17_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nmagic run test\n```\n\n----------------------------------------\n\nTITLE: Type Conversion Implementation in Rust\nDESCRIPTION: Shows Rust's approach to type conversion using the From trait implementation and into() method.\nSOURCE: https://github.com/modular/max/blob/main/mojo/proposals/opt-in-implicit-conversion.md#2025-04-17_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nstruct Foo;\nimpl From<i64> for Foo {\n  fn from(i: i64) -> Foo { Foo(); }\n}\nlet foo = Foo::from(10i64);\nlet foo2: Foo = (10i64).into();\n\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Relative Imports in Mojo\nDESCRIPTION: This snippet shows how to use purely relative 'from' imports in Mojo modules within packages. It imports 'another_module' from the current directory.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_124\n\nLANGUAGE: mojo\nCODE:\n```\nfrom . import another_module\n```\n\n----------------------------------------\n\nTITLE: Target Introspection Parameters\nDESCRIPTION: MLIR parameters used for target feature detection and field access in the compiler.\nSOURCE: https://github.com/modular/max/blob/main/mojo/proposals/stdlib-insider-docs.md#2025-04-17_snippet_1\n\nLANGUAGE: MLIR\nCODE:\n```\n#kgen.param.expr<target_get_field\\n#kgen.param.expr<target_has_feature\n```\n\n----------------------------------------\n\nTITLE: Installing Required Dependencies\nDESCRIPTION: Installation of PyTorch, transformers and ONNX packages required for the tutorial\nSOURCE: https://github.com/modular/max/blob/main/examples/notebooks/mistral7b-python-onnx.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n!python3 -m pip install -q torch --index-url https://download.pytorch.org/whl/cpu\n!python3 -m pip install -q transformers onnx\n```\n\n----------------------------------------\n\nTITLE: Illustrating Field Initialization Inconsistency in Mojo Structs\nDESCRIPTION: Example code demonstrating the current limitations and inconsistencies with 'let' declarations in struct fields, showing potential initialization conflicts.\nSOURCE: https://github.com/modular/max/blob/main/mojo/proposals/remove-let-decls.md#2025-04-17_snippet_0\n\nLANGUAGE: mojo\nCODE:\n```\nstruct Thing:\n    # This is not actually supported right now, but imagine it were.\n    let field = 42\n    fn __init__(out self):\n        self.field = 17  # shouldn't be able to overwrite field?\n```\n\n----------------------------------------\n\nTITLE: Array Type Declaration in MLIR POP Dialect\nDESCRIPTION: Examples of array type declarations showing both concrete and parameterized forms\nSOURCE: https://github.com/modular/max/blob/main/mojo/stdlib/docs/internal/pop_dialect.md#2025-04-17_snippet_1\n\nLANGUAGE: mlir\nCODE:\n```\n!pop.array<4, scalar<f32>> // An array of four scalar floats.\n\n!pop.array<size, type> // A parameterized array.\n```\n\n----------------------------------------\n\nTITLE: Illustrating Function Redefinition Behavior in Python\nDESCRIPTION: This snippet demonstrates how function redefinition affects existing references in Python, highlighting a difference between current Mojo behavior and Python's dynamic nature.\nSOURCE: https://github.com/modular/max/blob/main/mojo/proposals/mojo-and-dynamism.md#2025-04-17_snippet_4\n\nLANGUAGE: python\nCODE:\n```\ndef foo():\n    bar()\n\ndef bar():\n    print(\"hello\")\n\nfoo() # prints 'hello'\n\ndef bar():\n    print(\"goodbye\")\n\nfoo() # should this print 'goodbye'?\n```\n\n----------------------------------------\n\nTITLE: Changing Kernel Focus in CUDA-GDB\nDESCRIPTION: CUDA-GDB commands for inspecting and changing the current kernel focus, which determines which GPU block and thread is being examined during debugging.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/tools/gpu-debugging.mdx#2025-04-17_snippet_4\n\nLANGUAGE: plaintext\nCODE:\n```\ncuda block thread\nblock (0,0,0), thread (0,0,0)\ncuda block 0,0,0 thread 1,0,0\n[Switching focus to CUDA kernel 0, grid 1, block (0,0,0), thread (1,0,0), device 0, sm 0, warp 0, lane 1]\n```\n\n----------------------------------------\n\nTITLE: Running JupyterLab with Magic\nDESCRIPTION: Command to launch JupyterLab using the Magic tool from the current directory.\nSOURCE: https://github.com/modular/max/blob/main/examples/notebooks/README.md#2025-04-17_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\nmagic run jupyter lab\n```\n\n----------------------------------------\n\nTITLE: Docstring Format Example in Mojo\nDESCRIPTION: Demonstrates the Google-style docstring format for Mojo functions, including parameters, arguments, and return value documentation.\nSOURCE: https://github.com/modular/max/blob/main/mojo/stdlib/docs/style-guide.md#2025-04-17_snippet_9\n\nLANGUAGE: mojo\nCODE:\n```\nfn add_param_arg[foo: Int](bar: Int) -> Int:\n    \"\"\"[summary].\n\n    Parameters:\n        foo: [description].\n\n    Args:\n        bar: [description].\n\n    Returns:\n        [description].\n    \"\"\"\n    return foo + bar\n```\n\n----------------------------------------\n\nTITLE: Converting Gemma-2B to ONNX Format\nDESCRIPTION: Uses the Optimum CLI to export the Gemma-2B model to ONNX format, which is required for use with MAX Engine.\nSOURCE: https://github.com/modular/max/blob/main/examples/notebooks/gemma2b-python-onnx.ipynb#2025-04-17_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n!optimum-cli export onnx --model \"google/gemma-2b\" \"./onnx/gemma-2b-onnx\"\n```\n\n----------------------------------------\n\nTITLE: Adding Inline Comments in Mojo\nDESCRIPTION: Demonstrates how to add comments at the end of code lines.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/basics.mdx#2025-04-17_snippet_12\n\nLANGUAGE: mojo\nCODE:\n```\nvar message = \"Hello, World!\" # This is also a valid comment\n```\n\n----------------------------------------\n\nTITLE: Retrieving Kubernetes Application URL\nDESCRIPTION: Template script that determines and outputs the appropriate application URL based on the service type configured in Kubernetes. Handles multiple service types including Ingress, NodePort, LoadBalancer, and ClusterIP, providing specific commands for each scenario.\nSOURCE: https://github.com/modular/max/blob/main/tutorials/helm/max-openai-api/templates/NOTES.txt#2025-04-17_snippet_0\n\nLANGUAGE: helm\nCODE:\n```\n{{- if .Values.ingress.enabled }}\n  {{- range .Values.ingress.hosts }}\n  http{{ if $.Values.ingress.tls }}s{{ end }}://{{ . }}{{ $.Values.ingress.path }}\n  {{- end }}\n{{- else if contains \"NodePort\" .Values.service.type }}\n  NODE_PORT=$(kubectl get --namespace {{ .Release.Namespace }} -o jsonpath=\"{.spec.ports[0].nodePort}\" services {{ template \"max.fullname\" . }})\n  NODE_IP=$(kubectl get nodes --namespace {{ .Release.Namespace }} -o jsonpath=\"{.items[0].status.addresses[0].address}\")\n  echo http://$NODE_IP:$NODE_PORT\n{{- else if contains \"LoadBalancer\" .Values.service.type }}\n     NOTE: It may take a few minutes for the LoadBalancer IP to be available.\n           You can watch the status of by running 'kubectl get svc -w {{ template \"max.fullname\" . }}'\n  SERVICE_IP=$(kubectl get svc --namespace {{ .Release.Namespace }} {{ template \"max.fullname\" . }} -o jsonpath='{.status.loadBalancer.ingress[0].ip}')\n  echo http://$SERVICE_IP:{{ .Values.service.port }}\n{{- else if contains \"ClusterIP\" .Values.service.type }}\n  POD_NAME=$(kubectl get pods --namespace {{ .Release.Namespace }} -l \"app.kubernetes.io/name={{ template \"max.name\" . }},app.kubernetes.io/instance={{ .Release.Name }}\" -o jsonpath=\"{.items[0].metadata.name}\")\n  CONTAINER_PORT=$(kubectl get pod --namespace {{ .Release.Namespace }} $POD_NAME -o jsonpath=\"{.spec.containers[0].ports[0].containerPort}\")\n  echo \"The application is available at the following DNS name from within your cluster:\"\n  echo \"{{ .Release.Name }}.{{ .Release.Namespace }}.svc.cluster.local:$CONTAINER_PORT\"\n  echo \"Or use the following command to forward ports and visit it locally at http://127.0.0.1:8000\"\n  echo \"kubectl port-forward $POD_NAME 8000:$CONTAINER_PORT --namespace {{ .Release.Namespace }}\"\n{{- end }}\n```\n\n----------------------------------------\n\nTITLE: Uninstalling MAX OpenAI API Helm Chart\nDESCRIPTION: Command to uninstall and delete the MAX OpenAI API deployment from a Kubernetes cluster.\nSOURCE: https://github.com/modular/max/blob/main/tutorials/helm/max-openai-api/README.md#2025-04-17_snippet_2\n\nLANGUAGE: console\nCODE:\n```\nhelm delete max-openai-api\n```\n\n----------------------------------------\n\nTITLE: Running the MAX Graph API example with Magic\nDESCRIPTION: Command to execute the basic.🔥 file using Magic, Modular's command-line tool. This runs the example MAX Graph API model.\nSOURCE: https://github.com/modular/max/blob/main/examples/graph-api/basics/README.md#2025-04-17_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nmagic run mojo basic.🔥\n```\n\n----------------------------------------\n\nTITLE: Running the Example with Magic Command\nDESCRIPTION: Command to run the example using the 'magic' tool provided by Modular's documentation system.\nSOURCE: https://github.com/modular/max/blob/main/examples/inference/resnet50-python-torchscript/README.md#2025-04-17_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nmagic run bash run.sh\n```\n\n----------------------------------------\n\nTITLE: Initializing MAX Engine for Inference\nDESCRIPTION: Sets up the MAX Engine InferenceSession to use the converted ONNX model for inference. This step prepares for running inference with MAX Engine.\nSOURCE: https://github.com/modular/max/blob/main/examples/notebooks/gemma2b-python-onnx.ipynb#2025-04-17_snippet_7\n\nLANGUAGE: python\nCODE:\n```\n%%time\n\nfrom max import engine\n```\n\n----------------------------------------\n\nTITLE: Defining a Trait in Mojo\nDESCRIPTION: Demonstrates how to create a trait in Mojo, which serves as a template of characteristics for structs to implement.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/basics.mdx#2025-04-17_snippet_17\n\nLANGUAGE: mojo\nCODE:\n```\ntrait SomeTrait:\n    fn required_method(self, x: Int): ...\n```\n\n----------------------------------------\n\nTITLE: SIMD Vector Type Declaration in MLIR POP Dialect\nDESCRIPTION: Examples of SIMD vector type declarations showing both concrete and parameterized forms\nSOURCE: https://github.com/modular/max/blob/main/mojo/stdlib/docs/internal/pop_dialect.md#2025-04-17_snippet_0\n\nLANGUAGE: mlir\nCODE:\n```\n!pop.simd<4, si32> // A SIMD vector type of 4 signed 32-bit integers\n\n!pop.simd<size, dtype> // A parameterized SIMD type\n```\n\n----------------------------------------\n\nTITLE: Setting Up and Running MAX Graph API Examples with Conda\nDESCRIPTION: Instructions for creating and configuring a Conda environment to run the MAX Graph API examples. Shows how to create the environment, update it with configurations from environment.yml, and run the basic example.\nSOURCE: https://github.com/modular/max/blob/main/examples/graph-api/README.md#2025-04-17_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\n# Create a Conda environment if you don't have one\nconda create -n max-repo\n# Update the environment with the environment.yml file\nconda env update -n max-repo -f environment.yml --prune\n# Run the example\nconda activate max-repo\n\nmojo basics/basic.🔥\n\nconda deactivate\n```\n\n----------------------------------------\n\nTITLE: Proposed Mojo Syntax with New Keywords\nDESCRIPTION: This code snippet demonstrates the proposed changes to Mojo's syntax conventions. It replaces 'inout' with 'init' for constructors, 'inout' with 'mut' for mutable references, 'borrowed' with 'borrow', and 'owned' with 'consume'. These changes aim to make the function signatures more descriptive and intuitive.\nSOURCE: https://github.com/modular/max/blob/main/mojo/proposals/ref-convention.md#2025-04-17_snippet_11\n\nLANGUAGE: mojo\nCODE:\n```\n## Proposed\nstruct MyInt:\n   fn __init__(init self, value: Int): ...\n\n   fn __add__(borrow self, rhs: MyInt) -> MyInt: ...\n\n   fn __iadd__(mut self, rhs: MyInt): ...\n\n   fn __del__(consume self): ...\n```\n\n----------------------------------------\n\nTITLE: Implicit Conversion in Scala\nDESCRIPTION: Demonstrates Scala's implicit conversion syntax using a conversion function.\nSOURCE: https://github.com/modular/max/blob/main/mojo/proposals/opt-in-implicit-conversion.md#2025-04-17_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nimplicit int2foo(int: Int): Foo = Foo\nlet foo: Foo = 10\n\n```\n\n----------------------------------------\n\nTITLE: Implementing __merge_with__ Dunder for SIMD Types in Mojo\nDESCRIPTION: Implementation of the proposed __merge_with__ dunder method for SIMD types to enable merging vectors with different element types but the same size, using a DType helper to determine the appropriate result type.\nSOURCE: https://github.com/modular/max/blob/main/mojo/proposals/custom-type-merging.md#2025-04-17_snippet_6\n\nLANGUAGE: mojo\nCODE:\n```\nstruct SIMD[type: DType, size: Int](\n    fn __merge_with__[otherType: __type_of(SIMD[_, size])]\n      (self, out result: SIMD[type.merged_with(otherType.type), size]):\n        return __type_of(result)(self) # Use explicit conversion ctor\n        \nstruct DType:\n   ... \n   fn merged_with(self, other: DType) -> DType:\n      # ... decide how to merge two dtypes, or use pop operation to do it...\n```\n\n----------------------------------------\n\nTITLE: Activating Magic Project Virtual Environment\nDESCRIPTION: Command to activate the project's virtual environment using Magic package manager. This must be run from the project's root directory before executing any Mojo commands.\nSOURCE: https://github.com/modular/max/blob/main/examples/mojo/testing/README.md#2025-04-17_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nmagic shell\n```\n\n----------------------------------------\n\nTITLE: Documenting Parameters and Arguments in Mojo\nDESCRIPTION: Example showing how to document parameters and arguments in Mojo docstrings with proper formatting and indentation.\nSOURCE: https://github.com/modular/max/blob/main/mojo/stdlib/docs/docstring-style-guide.md#2025-04-17_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\nParameters:\n    size: The static capacity for this array.\n\nArgs:\n    value: The value to fill the array with. In the case of an extremely long\n        description, wrap to another line and indent subsequent lines relative to\n```\n\n----------------------------------------\n\nTITLE: Loading ONNX Model with MAX Engine\nDESCRIPTION: Creates an InferenceSession and loads the Mistral-7B ONNX model using MAX Engine.\nSOURCE: https://github.com/modular/max/blob/main/examples/notebooks/mistral7b-python-onnx.ipynb#2025-04-17_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nsession = engine.InferenceSession()\nmaxmodel = session.load(\"./onnx/mistral-7b-onnx/model.onnx\")\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Python's Local Variable Binding in Nested Functions\nDESCRIPTION: This example shows how Python handles local variable binding in nested functions, including cases that can lead to UnboundLocalError.\nSOURCE: https://github.com/modular/max/blob/main/mojo/proposals/mojo-and-dynamism.md#2025-04-17_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ndef foo():\n    i = 2\n    def bar():\n        print(i)\n    def baz():\n        print(i)\n        i = 10\n    bar() # prints '2'\n    baz() # throws an 'UnboundLocalError'\n```\n\n----------------------------------------\n\nTITLE: Debugging Compiled Mojo Binary from Command Line\nDESCRIPTION: This command starts a debug session for a compiled Mojo binary in Visual Studio Code from the command line. It uses the mojo debug command with the --vscode flag to launch the debugger in VS Code for a compiled binary.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/tools/debugging.mdx#2025-04-17_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nmojo debug --vscode myproject\n```\n\n----------------------------------------\n\nTITLE: Defining StringSlice struct with Lifetime parameter in Mojo\nDESCRIPTION: This code snippet demonstrates the current syntax for defining a StringSlice struct with a parametric Lifetime. It also includes a comment about a potential future syntax improvement.\nSOURCE: https://github.com/modular/max/blob/main/mojo/proposals/resyntaxing-arg-conventions-and-refs.md#2025-04-17_snippet_0\n\nLANGUAGE: mojo\nCODE:\n```\nstruct StringSlice[\n    is_mutable: Bool, //,\n    lifetime: Lifetime[is_mutable].type,\n]\n\n# ASIDE: We have a path to be able to write this as:\n#    struct StringSlice[lifetime: Lifetime[_]]:\n# but are missing a few things unrelated to this proposal.\n```\n\n----------------------------------------\n\nTITLE: Extending a List in Mojo\nDESCRIPTION: Demonstrates various ways to extend a List using the extend() method with different types of data sources.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_6\n\nLANGUAGE: mojo\nCODE:\n```\nbase_data = List[Byte](1, 2, 3)\n\ndata_list = List[Byte](4, 5, 6)\next_data_list = base_data.copy()\next_data_list.extend(data_list) # [1, 2, 3, 4, 5, 6]\n\ndata_span = Span(List[Byte](4, 5, 6))\next_data_span = base_data.copy()\next_data_span.extend(data_span) # [1, 2, 3, 4, 5, 6]\n\ndata_vec = SIMD[DType.uint8, 4](4, 5, 6, 7)\next_data_vec_full = base_data.copy()\next_data_vec_full.extend(data_vec) # [1, 2, 3, 4, 5, 6, 7]\n\next_data_vec_partial = base_data.copy()\next_data_vec_partial.extend(data_vec, count=3) # [1, 2, 3, 4, 5, 6]\n```\n\n----------------------------------------\n\nTITLE: Conda Environment Configuration for Mojo Nightly\nDESCRIPTION: YAML configuration for a Conda environment that uses the Mojo nightly build channel. It specifies the project name, package channels including the nightly channel, supported platforms, and dependencies.\nSOURCE: https://github.com/modular/max/blob/main/mojo/README.md#2025-04-17_snippet_1\n\nLANGUAGE: yaml\nCODE:\n```\n[project]\nname = \"Mojo nightly example\"\nchannels = [\"conda-forge\", \"https://conda.modular.com/max-nightly/\"]\nplatforms = [\"osx-arm64\", \"linux-aarch64\", \"linux-64\"]\n\n[dependencies]\nmax = \"*\"\n```\n\n----------------------------------------\n\nTITLE: Walrus Assignment Expression Limitation in Mojo\nDESCRIPTION: Demonstrates a limitation in Mojo's compiler when using multiple walrus assignment expressions, and provides a workaround.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/roadmap.md#2025-04-17_snippet_10\n\nLANGUAGE: mojo\nCODE:\n```\ndef A() -> Int: return 42\n\ndef B() -> String: return \"waffles\"\n\ndef main():\n    b = String()\n    if (a := A()) and (b := B()):\n        print(\"a =\", a)\n        print(\"b =\", b)\n```\n\n----------------------------------------\n\nTITLE: Using Placement New with __get_address_as_uninit_lvalue in Mojo\nDESCRIPTION: Low-level code showing how to perform 'placement new' and 'replacement new' operations using the __get_address_as_uninit_lvalue and __get_address_as_lvalue builtin functions.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_202\n\nLANGUAGE: mojo\nCODE:\n```\n# \"*Re*placement new\": destroy the existing SomeHeavy value in the memory,\n# then initialize a new value into the slot.\n__get_address_as_lvalue(somePointer.value) = SomeHeavy(4, 5)\n\n# Ok to use an lvalue, convert to borrow etc.\nuse(__get_address_as_lvalue(somePointer.value))\n\n# \"Placement new\": Initialize a new value into uninitialied memory.\n__get_address_as_uninit_lvalue(somePointer.value) = SomeHeavy(4, 5)\n\n# Error, cannot read from uninitialized memory.\nuse(__get_address_as_uninit_lvalue(somePointer.value))\n```\n\n----------------------------------------\n\nTITLE: Next Token Generation Loop Implementation\nDESCRIPTION: Detailed implementation of the token generation loop using the model's forward method directly\nSOURCE: https://github.com/modular/max/blob/main/examples/notebooks/mistral7b-python-onnx.ipynb#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom time import time\nfrom transformers.generation.logits_process import LogitsProcessorList\n\nlogits_processor = LogitsProcessorList()\n\ntime_start = time()\ncurrent_seq = input_ids\nN_TOKENS = 10\nfor idx in range(N_TOKENS):\n    # Run model's `forward` on the current sequence.\n    # 'logits' output would let us determine the next token for this sequence\n    outputs = hfmodel(current_seq, return_dict=True).logits\n\n    # Get the newly generated next token\n    next_token_logits = outputs[:, -1, :]\n    next_tokens_scores = logits_processor(current_seq, next_token_logits)\n    next_tokens = torch.argmax(next_tokens_scores, dim=-1)\n\n    print(hftokenizer.decode(next_tokens), end=' ', flush=True)\n\n    # Append the new token to our sequence\n    current_seq = torch.cat([current_seq, next_tokens[:, None]], dim=-1)\n\ntime_finish = time()\nprint(f\"Prompt: {PROMPT}\")\nprint(\"Response:\", hftokenizer.batch_decode(current_seq.numpy(), skip_special_tokens=True)[0][len(PROMPT):])\nprint(f\"Tokens per second: {N_TOKENS / (time_finish - time_start):.2f}\\n\")\n```\n\n----------------------------------------\n\nTITLE: Using Placement Delete with __get_address_as_owned_value in Mojo\nDESCRIPTION: Low-level code showing how to perform a 'placement delete' operation using the __get_address_as_owned_value builtin function, which creates an owned value from a pointer that must be consumed.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_201\n\nLANGUAGE: mojo\nCODE:\n```\n# \"Placement delete\": destroy the initialized object begin pointed to.\n_ = __get_address_as_owned_value(somePointer.value)\n\n# Result value can be consumed by anything that takes it as an 'owned'\n# argument as well.\nconsume(__get_address_as_owned_value(somePointer.value))\n```\n\n----------------------------------------\n\nTITLE: Running Mojo Format Command\nDESCRIPTION: Example of using the mojo format command line utility to automatically format code according to style guidelines.\nSOURCE: https://github.com/modular/max/blob/main/mojo/stdlib/docs/style-guide.md#2025-04-17_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n> mojo format example.mojo\nAll done! ✨ 🍰 ✨\n1 file left unchanged.\n```\n\n----------------------------------------\n\nTITLE: Running Tests with JSON Output in Mojo\nDESCRIPTION: Executes tests with JSON formatted output using the --diagnostic-format json option\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/tools/testing.mdx#2025-04-17_snippet_12\n\nLANGUAGE: bash\nCODE:\n```\nmojo test --diagnostic-format json test_quickstart.mojo\n```\n\n----------------------------------------\n\nTITLE: Running the YOLOv8 Example with Magic CLI\nDESCRIPTION: Command to run the example using Modular's Magic CLI. This simplifies the execution process by handling environment setup and dependencies.\nSOURCE: https://github.com/modular/max/blob/main/examples/inference/yolo-python-onnx/README.md#2025-04-17_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\nmagic run bash run.sh\n```\n\n----------------------------------------\n\nTITLE: Inspecting Model Metadata\nDESCRIPTION: Prints input and output tensor metadata including names, shapes, and data types for the loaded ONNX model.\nSOURCE: https://github.com/modular/max/blob/main/examples/notebooks/mistral7b-python-onnx.ipynb#2025-04-17_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nfor tensor in maxmodel.input_metadata:\n    print(f'name: {tensor.name}, shape: {tensor.shape}, dtype: {tensor.dtype}')\n\nfor tensor in maxmodel.output_metadata:\n    print(f'name: {tensor.name}, shape: {tensor.shape}, dtype: {tensor.dtype}')\n```\n\n----------------------------------------\n\nTITLE: Installing Required Packages for Gemma-2B with MAX Engine\nDESCRIPTION: Installs PyTorch, Transformers, ONNX, and Hugging Face Hub libraries needed to work with Gemma-2B and MAX Engine.\nSOURCE: https://github.com/modular/max/blob/main/examples/notebooks/gemma2b-python-onnx.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n!python3 -m pip install -q torch --index-url https://download.pytorch.org/whl/cpu\n!python3 -m pip install -q transformers onnx huggingface_hub\n```\n\n----------------------------------------\n\nTITLE: Unsafe Standard Library Operations in Mojo\nDESCRIPTION: Demonstrates unsafe operations in Mojo's standard library that do not raise exceptions, unlike their Python counterparts.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/roadmap.md#2025-04-17_snippet_7\n\nLANGUAGE: mojo\nCODE:\n```\nvar l = List[Int](capacity=0)\nprint(l[1]) # could crash or print garbage values (undefined behavior)\n\nprint(1//0) # does not raise and could print anything (undefined behavior)\n```\n\n----------------------------------------\n\nTITLE: Calling Test Function in Mojo Main\nDESCRIPTION: This snippet demonstrates how to call the test function from the main() function in Mojo.\nSOURCE: https://github.com/modular/max/blob/main/mojo/stdlib/docs/development.md#2025-04-17_snippet_7\n\nLANGUAGE: mojo\nCODE:\n```\ndef main():\n    test_get_cwd_message()\n```\n\n----------------------------------------\n\nTITLE: Mojo Doc Validation Command\nDESCRIPTION: Command for validating API documentation strings in Mojo code.\nSOURCE: https://github.com/modular/max/blob/main/mojo/stdlib/docs/style-guide.md#2025-04-17_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n> mojo doc --diagnose-missing-doc-strings --validate-doc-strings -o /dev/null stdlib/src/\n```\n\n----------------------------------------\n\nTITLE: Running Directory Tests with Import Path in Mojo\nDESCRIPTION: Executes all tests in the test directory with a specified import path using the mojo test command\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/tools/testing.mdx#2025-04-17_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\nmojo test -I src test\n```\n\n----------------------------------------\n\nTITLE: Running Mojo Unit Tests\nDESCRIPTION: Command to run the unit tests for the Complex number implementation using the magic command line tool\nSOURCE: https://github.com/modular/max/blob/main/examples/mojo/operators/README.md#2025-04-17_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nmagic run tests\n```\n\n----------------------------------------\n\nTITLE: Installing max-pipelines Command for MAX\nDESCRIPTION: This command installs the max-pipelines command globally using Magic. The max-pipelines command is used to run MAX Pipelines.\nSOURCE: https://github.com/modular/max/blob/main/src/max/README.md#2025-04-17_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\nmagic global install max-pipelines\n```\n\n----------------------------------------\n\nTITLE: Sharing and Importing Jupyter Notebooks in Mojo Playground\nDESCRIPTION: Instructions for sharing and importing .ipynb notebook files in Mojo Playground via the shared directory and the Copy Sharable link feature.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_187\n\nLANGUAGE: mojo\nCODE:\n```\n# To share a notebook:\n# 1. Save your file in the 'shared' directory\n# 2. Right-click the file and select \"Copy Sharable link\"\n\n# To import a shared notebook:\n# 1. Open the shared link\n# 2. Click \"Import\" at the top of the notebook\n```\n\n----------------------------------------\n\nTITLE: Model Loading in MAX Engine\nDESCRIPTION: Loads the converted TorchScript model into MAX Engine with input specifications.\nSOURCE: https://github.com/modular/max/blob/main/examples/notebooks/roberta-python-pytorch.ipynb#2025-04-17_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nsession = engine.InferenceSession()\nmodel = session.load(model_path, input_specs=input_spec_list)\n```\n\n----------------------------------------\n\nTITLE: Main Program Using OS Module in Mojo\nDESCRIPTION: Example main program showing usage of the new os.get_cwd_and_paths function\nSOURCE: https://github.com/modular/max/blob/main/mojo/stdlib/docs/development.md#2025-04-17_snippet_5\n\nLANGUAGE: mojo\nCODE:\n```\nimport os\n\ndef main():\n    all_paths = os.get_cwd_and_paths()\n    print(all_paths.__str__())\n```\n\n----------------------------------------\n\nTITLE: Examining the ONNX Model Structure\nDESCRIPTION: Loads and prints the structure of the converted ONNX model, showing inputs and outputs. This step is optional and requires significant memory.\nSOURCE: https://github.com/modular/max/blob/main/examples/notebooks/gemma2b-python-onnx.ipynb#2025-04-17_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n%%time\nimport onnx\n\nonnxmodel = onnx.load(\"./onnx/gemma-2b-onnx/model.onnx\")\n\ndef print_dims(tensor):\n    dims = []\n    for dim in tensor.type.tensor_type.shape.dim:\n        if dim.HasField(\"dim_value\"):\n            dims.append(String(dim.dim_value))\n        elif dim.HasField(\"dim_param\"):\n            dims.append(String(dim.dim_param))\n    print(onnx.TensorProto.DataType.Name(tensor.type.tensor_type.elem_type), end=\" \")\n    print(\"[\", \", \".join(dims), \"]\")\n\nprint(\"=== Inputs ===\")\nfor input_tensor in onnxmodel.graph.input:\n    print(input_tensor.name, end=\": \")\n    print_dims(input_tensor)\n\nprint(\"\\n=== Outputs ===\")\nfor output_tensor in onnxmodel.graph.output:\n    print(output_tensor.name, end=\": \")\n    print_dims(output_tensor)\n```\n\n----------------------------------------\n\nTITLE: Executing Mojo Tests via CLI\nDESCRIPTION: Command to run Mojo tests using the mojo test command. This executes all test functions in the specified Mojo file.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/tools/testing.mdx#2025-04-17_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nmojo test test_quickstart.mojo\n```\n\n----------------------------------------\n\nTITLE: Running Basic MAX Pipeline Example\nDESCRIPTION: Command to execute a basic MAX pipeline example using the magic command line tool\nSOURCE: https://github.com/modular/max/blob/main/examples/offline-inference/README.md#2025-04-17_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\nmagic run basic\n```\n\n----------------------------------------\n\nTITLE: Python-style Loop Variable Scoping (Unsupported in Mojo)\nDESCRIPTION: Illustrates a Python-style loop variable scoping that is not supported in Mojo.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/roadmap.md#2025-04-17_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfor i in range(3): pass\nprint(i)\n```\n\n----------------------------------------\n\nTITLE: Running the Document Management System\nDESCRIPTION: This command executes the Python module for the knowledge base system that utilizes the embeddings endpoint.\nSOURCE: https://github.com/modular/max/blob/main/tutorials/run-embeddings-with-max-serve/README.md#2025-04-17_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\npython -m embeddings.kb_system\n```\n\n----------------------------------------\n\nTITLE: Creating and Configuring Conda Environment for MAX\nDESCRIPTION: Shell commands to create a Conda environment, update it with the environment.yml file, and run JupyterLab within the environment.\nSOURCE: https://github.com/modular/max/blob/main/examples/notebooks/README.md#2025-04-17_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\n# Create a Conda environment if you don't have one\nconda create -n max-repo\n# Activate the environment\nconda env update -n max-repo -f environment.yml --prune\n# run JupyterLab\nconda run -n max-repo jupyter lab\n```\n\n----------------------------------------\n\nTITLE: Configuring Mojo Telemetry Settings\nDESCRIPTION: Commands to configure telemetry settings in Mojo SDK, including disabling crash reporting and adjusting telemetry levels. Level 0 records minimal data, level 1 records high-level events, and level 2 records detailed compilation information.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/faq.md#2025-04-17_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\nmodular config-set crash_reporting.enabled=false\n```\n\nLANGUAGE: sh\nCODE:\n```\nmodular config-set telemetry.level=0\n```\n\n----------------------------------------\n\nTITLE: Demonstrating __call_location Limitations in Parameter Contexts in Mojo\nDESCRIPTION: This example shows a limitation of the __call_location() function when used in parameter contexts. The function fails to provide the correct location information when used to initialize a compile-time constant via an alias.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_88\n\nLANGUAGE: mojo\nCODE:\n```\nfrom builtin._location import __call_location\n\n@always_inline\nfn mystery_location() -> String:\n    var loc = __call_location()\n    return str(loc.file_name)\n\ndef main():\n    alias doesnt_work = mystery_location() # <unknown location in parameter context>\n```\n\n----------------------------------------\n\nTITLE: Running Segmentation with MAX Engine on Webcam Input\nDESCRIPTION: Command to execute the segmentation script using MAX Engine with webcam input. This is used for performance testing and displays the model execution time in the window title.\nSOURCE: https://github.com/modular/max/blob/main/examples/inference/yolo-python-onnx/README.md#2025-04-17_snippet_3\n\nLANGUAGE: sh\nCODE:\n```\n./segment.py webcam\n```\n\n----------------------------------------\n\nTITLE: Running Life Version 1 with Magic\nDESCRIPTION: Command to execute version 1 of Conway's Game of Life implementation using the Magic tool. Displays a window showing initial random state and subsequent generations.\nSOURCE: https://github.com/modular/max/blob/main/examples/mojo/life/README.md#2025-04-17_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nmagic run lifev1\n```\n\n----------------------------------------\n\nTITLE: Running Mojo Unit Tests\nDESCRIPTION: Command to execute the unit tests located in the test directory. The -I flag includes the src directory in the module search path, allowing the tests to import the modules being tested.\nSOURCE: https://github.com/modular/max/blob/main/examples/mojo/testing/README.md#2025-04-17_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nmojo test -I src test\n```\n\n----------------------------------------\n\nTITLE: Package Installation Commands\nDESCRIPTION: Installation commands for MAX Engine and required dependencies.\nSOURCE: https://github.com/modular/max/blob/main/examples/notebooks/roberta-python-pytorch.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n# Install the MAX Engine Python package\n!python3 -m pip install -q --find-links \"$(modular config max.path)/wheels\" max-engine\n# Install other packages\n!python3 -m pip install -q transformers\n!python3 -m pip install -q torch --index-url https://download.pytorch.org/whl/cpu\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Limitations of Symbolic Evaluation in Mojo\nDESCRIPTION: This code snippet showcases a limitation of the proposed symbolic evaluation approach in Mojo. It illustrates how certain non-trivial conditions, such as primality checks, cannot be symbolically evaluated at parse time without a parser-time interpreter.\nSOURCE: https://github.com/modular/max/blob/main/mojo/proposals/requires-clause.md#2025-04-17_snippet_9\n\nLANGUAGE: mojo\nCODE:\n```\nstruct X[A: Int]:\n   fn example(self) requires A.is_prime(): ...\n   \n   \nfn test(value: X[2]):\n    # Error, cannot symbolically evaluate '2.is_prime()' to a constant.\n    value.example()\n    \n    @parameter\n    if 2.is_prime(): # tell dumb mojo that 2 is prime.\n       # This is ok.\n       value.example()\n```\n\n----------------------------------------\n\nTITLE: Alternative: Non-Lexical Parameter Lists\nDESCRIPTION: Shows an alternative approach where forward references would be allowed in parameter lists, enabling inference from earlier parameters.\nSOURCE: https://github.com/modular/max/blob/main/mojo/proposals/inferred-parameters.md#2025-04-17_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nfn scalar_param[x: Scalar[dt], dt: DType](): pass\n```\n\n----------------------------------------\n\nTITLE: Installing Optimum for ONNX Conversion\nDESCRIPTION: Installation of HuggingFace Optimum tool for ONNX model conversion\nSOURCE: https://github.com/modular/max/blob/main/examples/notebooks/mistral7b-python-onnx.ipynb#2025-04-17_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n!python3 -m pip install -q optimum\n```\n\n----------------------------------------\n\nTITLE: Building the BERT C Example with CMake\nDESCRIPTION: Commands to build the C executable for BERT inference using CMake. This sets the MAX package directory path and builds the project to create the 'bert' executable.\nSOURCE: https://github.com/modular/max/blob/main/examples/inference/bert-c-torchscript/README.md#2025-04-17_snippet_4\n\nLANGUAGE: sh\nCODE:\n```\nexport MAX_PKG_DIR=`modular config max.path`\ncmake -B build -S .\ncmake --build build\n```\n\n----------------------------------------\n\nTITLE: Serving a Model with MAX Pipelines\nDESCRIPTION: This command demonstrates how to serve a specific model using MAX Pipelines. It uses the DeepSeek-R1-Distill-Llama-8B model as an example.\nSOURCE: https://github.com/modular/max/blob/main/src/max/README.md#2025-04-17_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\nmax-pipelines serve --model-path deepseek-ai/DeepSeek-R1-Distill-Llama-8B\n```\n\n----------------------------------------\n\nTITLE: Running Post-processing for BERT Output\nDESCRIPTION: Command to execute the post-processing Python script that loads the inference output, processes it, and displays the prediction results.\nSOURCE: https://github.com/modular/max/blob/main/examples/inference/bert-c-torchscript/README.md#2025-04-17_snippet_3\n\nLANGUAGE: sh\nCODE:\n```\npython3 post-process.py\n```\n\n----------------------------------------\n\nTITLE: Running MAX Graph API Examples with Magic\nDESCRIPTION: Command for running the basic example using the 'magic' tool, which simplifies execution of MAX Graph API examples.\nSOURCE: https://github.com/modular/max/blob/main/examples/graph-api/README.md#2025-04-17_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\nmagic run basic\n```\n\n----------------------------------------\n\nTITLE: Bitcast Operations in MLIR POP Dialect\nDESCRIPTION: Examples of bitwise reinterpretation between different types using the bitcast operation\nSOURCE: https://github.com/modular/max/blob/main/mojo/stdlib/docs/internal/pop_dialect.md#2025-04-17_snippet_5\n\nLANGUAGE: mlir\nCODE:\n```\n%0 = pop.bitcast %a : !pop.scalar<si32> to !pop.scalar<f32>\n%1 = pop.bitcast %b : !pop.scalar<ui64> to !pop.scalar<si64>\n%2 = pop.bitcast %c : !pop.simd<4, f64> to !pop.simd<4, si64>\n%3 = pop.bitcast %d : !pop.simd<2, f64> to !pop.simd<4, f32>\n```\n\n----------------------------------------\n\nTITLE: Running BERT Inference with Magic CLI\nDESCRIPTION: Command to execute the BERT inference example using the Magic CLI tool.\nSOURCE: https://github.com/modular/max/blob/main/examples/inference/bert-mojo-torchscript/README.md#2025-04-17_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\nmagic run bash run.sh\n```\n\n----------------------------------------\n\nTITLE: Setting Environment Variable for Classic Debugger Backend in VS Code\nDESCRIPTION: Configuration settings to add to launch.json when using the classic debugger backend for CUDA-GDB. This is necessary on systems where the default universal debugger has connection stability issues.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/tools/gpu-debugging.mdx#2025-04-17_snippet_0\n\nLANGUAGE: json\nCODE:\n```\n\"legacyDebugger\": true,\n\"initCommands\": [\n    \"set environment CUDBG_USE_LEGACY_DEBUGGER=1\"\n],\n```\n\n----------------------------------------\n\nTITLE: Logging into Hugging Face Hub\nDESCRIPTION: Prompts for and uses a Hugging Face access token to log into the Hugging Face Hub, which is required to access the Gemma-2B model.\nSOURCE: https://github.com/modular/max/blob/main/examples/notebooks/gemma2b-python-onnx.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport getpass\nfrom huggingface_hub import login\n\naccess_token = getpass.getpass('Enter your Hugging Face Access Token')\nlogin(token=access_token)\n```\n\n----------------------------------------\n\nTITLE: Installing MAX OpenAI API Helm Chart on Kubernetes\nDESCRIPTION: Command to install the MAX OpenAI API Helm chart on a Kubernetes cluster. It sets various configuration options including the Hugging Face model ID, MAX Serve parameters, and environment variables.\nSOURCE: https://github.com/modular/max/blob/main/tutorials/helm/max-openai-api/README.md#2025-04-17_snippet_0\n\nLANGUAGE: console\nCODE:\n```\nhelm install max-openai-api oci://registry-1.docker.io/modular/max-openai-api-chart \\\n  --version <insert-version> \\\n  --set huggingfaceRepoId=<insert-huggingface-model-id>\n  --set maxServe.maxLength=512 \\\n  --set maxServe.maxBatchSize=16 \\\n  --set envSecret.HF_TOKEN=<insert-huggingface-token> \\\n  --set env.HF_HUB_ENABLE_HF_TRANSFER=1 \\\n  --wait\n```\n\n----------------------------------------\n\nTITLE: Running Addition Example with Magic\nDESCRIPTION: Command to execute the addition example using the Magic CLI tool\nSOURCE: https://github.com/modular/max/blob/main/tutorials/max-graph-python/README.md#2025-04-17_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nmagic run addition\n```\n\n----------------------------------------\n\nTITLE: Setting up Conda Environment for BERT Inference\nDESCRIPTION: Commands to create and configure a Conda environment for running the BERT inference example, including environment creation, updating with dependencies, and executing the example.\nSOURCE: https://github.com/modular/max/blob/main/examples/inference/bert-c-torchscript/README.md#2025-04-17_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\n# Create a Conda environment if you don't have one\nconda create -n max-repo\n# Update the environment with the environment.yml file\nconda env update -n max-repo -f environment.yml --prune\n# Run the example\nconda run -n max-repo --live-stream bash run.sh\n```\n\n----------------------------------------\n\nTITLE: Test Failure Output in Plaintext\nDESCRIPTION: This snippet shows the output of a failed test, indicating the exact location and nature of the failure.\nSOURCE: https://github.com/modular/max/blob/main/mojo/stdlib/docs/development.md#2025-04-17_snippet_9\n\nLANGUAGE: plaintext\nCODE:\n```\n/Users/jack/src/mojo-toy-2/stdlib/test/pathlib/test_pathlib.mojo:27:11:\nAssertionError: `left == right` comparison failed:\n   left: Your cwd is: /Users/jack/src/mojo/stdlib\n  right: Some random text\n```\n\n----------------------------------------\n\nTITLE: Creating and Syncing Feature Branch\nDESCRIPTION: Commands to create a new feature branch and keep it updated with the latest changes from the upstream main branch.\nSOURCE: https://github.com/modular/max/blob/main/mojo/CONTRIBUTING.md#2025-04-17_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ngit checkout main\ngit checkout -b my-fix-pr\n```\n\nLANGUAGE: bash\nCODE:\n```\ngit fetch upstream\ngit rebase upstream/main\n```\n\n----------------------------------------\n\nTITLE: Verbose Keyword Parameter Example\nDESCRIPTION: Illustrates how keyword parameters can become verbose with longer parameter names, motivating the need for the 'inferred' keyword proposal.\nSOURCE: https://github.com/modular/max/blob/main/mojo/proposals/inferred-parameters.md#2025-04-17_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nscalar_param[infer_stuff_from_me=Int32()]()\n\n# One would like to write:\nscalar_param[Int32()]()\n```\n\n----------------------------------------\n\nTITLE: Basic MAX Engine Model Loading and Inference\nDESCRIPTION: Shows the three core lines of code needed to load and run inference with MAX Engine.\nSOURCE: https://github.com/modular/max/blob/main/examples/notebooks/roberta-python-pytorch.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom max import engine\n\n# Load your model:\nsession = engine.InferenceSession()\nmodel = session.load(model_path)\n\n# Prepare the inputs, then run an inference:\noutputs = model.execute(**inputs)\n\n# Process the output here.\n```\n\n----------------------------------------\n\nTITLE: PyTorch Model Download and Conversion\nDESCRIPTION: Downloads a RoBERTa model and converts it to TorchScript format.\nSOURCE: https://github.com/modular/max/blob/main/examples/notebooks/roberta-python-pytorch.ipynb#2025-04-17_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nHF_MODEL_NAME = \"cardiffnlp/twitter-roberta-base-emotion-multilabel-latest\"\nhf_model = AutoModelForSequenceClassification.from_pretrained(HF_MODEL_NAME)\nhf_model.config.return_dict = False\n\n# Converting model to TorchScript\nmodel_path = Path(\"roberta.torchscript\")\nbatch = 1\nseqlen = 128\ninputs = {\n    \"input_ids\": torch.zeros((batch, seqlen), dtype=torch.int64),\n    \"attention_mask\": torch.zeros((batch, seqlen), dtype=torch.int64),\n}\nwith torch.no_grad():\n    traced_model = torch.jit.trace(\n        hf_model, example_kwarg_inputs=inputs, strict=False\n    )\n\ntorch.jit.save(traced_model, model_path)\n```\n\n----------------------------------------\n\nTITLE: Test Execution Output\nDESCRIPTION: Example output from running the test suite showing successful test completion\nSOURCE: https://github.com/modular/max/blob/main/tutorials/max-graph-python/README.md#2025-04-17_snippet_3\n\nLANGUAGE: text\nCODE:\n```\n==================== test session starts ====================\nplatform darwin -- Python 3.12.7, pytest-8.3.3, pluggy-1.5.0\nrootdir: /max-repo\nconfigfile: pyproject.toml\ncollected 6 items\n\ntests/test_addition.py ......                         [100%]\n\n===================== 6 passed in 6.94s =====================\n```\n\n----------------------------------------\n\nTITLE: Parametric Constants Usage in MLIR POP Dialect\nDESCRIPTION: Example of using parametric constants in a generator function with type casting\nSOURCE: https://github.com/modular/max/blob/main/mojo/stdlib/docs/internal/pop_dialect.md#2025-04-17_snippet_4\n\nLANGUAGE: mlir\nCODE:\n```\nkgen.generator @addN<N: si32>(%arg0: !pop.scalar<si32>) -> !pop.scalar<si32> {\n  %N = kgen.param.constant: si32 = <N>\n  %rhs = pop.cast_from_builtin %N : si32 to !pop.scalar<si32>\n  %result = pop.add %arg0, %rhs : !pop.scalar<f32>\n  kgen.return %result : !pop.scalar<f32>\n}\n```\n\n----------------------------------------\n\nTITLE: Running Mojo Example using Magic\nDESCRIPTION: This command demonstrates how to run a Mojo example program (matmul.mojo) using the Magic package manager within the examples directory.\nSOURCE: https://github.com/modular/max/blob/main/examples/mojo/README.md#2025-04-17_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nmagic run mojo matmul.mojo\n```\n\n----------------------------------------\n\nTITLE: String Concatenation - Old Style\nDESCRIPTION: Shows the deprecated way of concatenating strings with multiple reallocations.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_14\n\nLANGUAGE: mojo\nCODE:\n```\nvar msg = \"my message \" + String(x) + \" \" + String(y) + \" \" + String(z)\n```\n\n----------------------------------------\n\nTITLE: Rust Function Signatures with Lifetimes\nDESCRIPTION: Examples of Rust function signatures that use lifetime parameters to express the relationship between input references and output references. The lifetime parameter 'a is used to indicate that the returned reference lives as long as both input references.\nSOURCE: https://github.com/modular/max/blob/main/mojo/proposals/lifetimes-and-provenance.md#2025-04-17_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n// This is Rust\nfn longest<'a>(x: &'a str, y: &'a str) -> &'a str {..}\nfn longest2<'a>(x: &'a mut str, y: &'a mut str) -> &'a mut str {..}\n```\n\n----------------------------------------\n\nTITLE: Running BERT Inference with Custom Input\nDESCRIPTION: Example command showing how to use the simple-inference.py script with a custom text input containing a masked word to be predicted.\nSOURCE: https://github.com/modular/max/blob/main/examples/inference/bert-python-torchscript/README.md#2025-04-17_snippet_2\n\nLANGUAGE: sh\nCODE:\n```\npython3 simple-inference.py --text \"Paris is the [MASK] of France.\"\n```\n\n----------------------------------------\n\nTITLE: Importing C/C++ Functions in Mojo\nDESCRIPTION: Demonstrates how Mojo plans to leverage Clang to transparently generate a foreign function interface between C/C++ and Mojo, allowing direct import of C/C++ functions.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/roadmap.md#2025-04-17_snippet_0\n\nLANGUAGE: mojo\nCODE:\n```\nfrom \"math.h\" import cos\n\nprint(cos(0))\n```\n\n----------------------------------------\n\nTITLE: Proposed @dynamic Decorator for Mojo Classes\nDESCRIPTION: This example demonstrates a potential @dynamic decorator for Mojo classes, allowing full Python-like dynamism including method redefinition and deletion at runtime.\nSOURCE: https://github.com/modular/max/blob/main/mojo/proposals/mojo-and-dynamism.md#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n@dynamic\nclass C:\n    def foo(): print(\"warming up\")\n    foo() # prints 'warming up'\n    del foo\n    def foo(): print(\"huzzah\")\n    foo() # prints 'huzzah'\n```\n\n----------------------------------------\n\nTITLE: Pushing Changes and Creating Pull Request\nDESCRIPTION: Commands to push local changes to the remote repository and instructions for creating a pull request.\nSOURCE: https://github.com/modular/max/blob/main/mojo/CONTRIBUTING.md#2025-04-17_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\ngit push -u origin my-fix-pr\n```\n\n----------------------------------------\n\nTITLE: Running BERT Example with Magic\nDESCRIPTION: Command to execute the BERT inference example using the Magic tool, which simplifies the setup and execution process.\nSOURCE: https://github.com/modular/max/blob/main/examples/inference/bert-c-torchscript/README.md#2025-04-17_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\nmagic run bash run.sh\n```\n\n----------------------------------------\n\nTITLE: Pathlib Module Imports in Mojo\nDESCRIPTION: Import statements for the pathlib module including the new get_cwd_message function\nSOURCE: https://github.com/modular/max/blob/main/mojo/stdlib/docs/development.md#2025-04-17_snippet_2\n\nLANGUAGE: mojo\nCODE:\n```\nfrom .path import (\n    DIR_SEPARATOR,\n    cwd,\n    get_cwd_message,\n    Path,\n)\n```\n\n----------------------------------------\n\nTITLE: Text Generation with MAX Engine\nDESCRIPTION: Implements token generation loop using MAX Engine, including KV cache initialization, input preparation, and token processing. Demonstrates performance improvements over PyTorch version.\nSOURCE: https://github.com/modular/max/blob/main/examples/notebooks/mistral7b-python-onnx.ipynb#2025-04-17_snippet_9\n\nLANGUAGE: python\nCODE:\n```\ninputs = {}\nN_BATCH = 1\nN_LAYERS = 32\nN_HEADS = 8\nKV_LEN = 128\n# Initialize the additional layer to 0 for the first iteration:\nfor i in range(N_LAYERS):\n    inputs[f\"past_key_values.{i}.key\"] = torch.zeros([N_BATCH, N_HEADS, 0, KV_LEN], dtype=torch.float).numpy()\n    inputs[f\"past_key_values.{i}.value\"] = torch.zeros([N_BATCH, N_HEADS, 0, KV_LEN], dtype=torch.float).numpy()\n\ncurrent_seq = input_ids\n\ntime_start = time()\nfor idx in range(N_TOKENS):\n    # Prepare inputs dictionary\n    inputs[\"input_ids\"] = current_seq.numpy()\n    inputs[\"position_ids\"] = torch.arange(inputs[\"input_ids\"].shape[1], dtype=torch.long).unsqueeze(0).numpy()\n    inputs[\"attention_mask\"] = torch.ones([1, inputs[\"past_key_values.0.key\"].shape[2] + inputs[\"input_ids\"].shape[1]], dtype=torch.int64).numpy()\n\n    # Run the model with MAX engine\n    max_outputs = maxmodel.execute(**inputs)\n    outputs = torch.from_numpy(max_outputs[\"logits\"])\n\n    # Get the newly generated next token\n    next_token_logits = outputs[:, -1, :]\n    next_tokens_scores = logits_processor(current_seq, next_token_logits)\n    next_tokens = torch.argmax(next_tokens_scores, dim=-1)\n\n    print(hftokenizer.decode(next_tokens), end=' ', flush=True)\n\n    # Append the new token to our sequence\n    current_seq = torch.cat([current_seq, next_tokens[:, None]], dim=-1)\n\n    # Update the KV cache for the next iteration\n    for i in range(N_LAYERS):\n        inputs[f\"past_key_values.{i}.key\"] = max_outputs[f\"present.{i}.key\"]\n        inputs[f\"past_key_values.{i}.value\"] = max_outputs[f\"present.{i}.value\"]\n\ntime_finish = time()\n\nprint(f\"Prompt: {PROMPT}\")\nprint(\"Response:\", hftokenizer.batch_decode(current_seq.numpy(), skip_special_tokens=True)[0][len(PROMPT):])\nprint(f\"Tokens per second: {idx/(time_finish-time_start):.2f}\\n\")\n```\n\n----------------------------------------\n\nTITLE: Running ResNet-50 Inference with Custom Input Image\nDESCRIPTION: Command to run the inference script with a custom input image path using the --input CLI flag.\nSOURCE: https://github.com/modular/max/blob/main/examples/inference/resnet50-python-torchscript/README.md#2025-04-17_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\npython3 simple-inference.py --input=<path_to_input_jpg>\n```\n\n----------------------------------------\n\nTITLE: Running Segmentation with ONNX Runtime on Webcam Input\nDESCRIPTION: Command to execute the segmentation script using ONNX Runtime instead of MAX Engine. This allows for performance comparison between the two backends.\nSOURCE: https://github.com/modular/max/blob/main/examples/inference/yolo-python-onnx/README.md#2025-04-17_snippet_4\n\nLANGUAGE: sh\nCODE:\n```\n./segment.py webcam --onnx\n```\n\n----------------------------------------\n\nTITLE: Running MAX Serve Benchmark with Python Script\nDESCRIPTION: Example command showing how to run the benchmark_serving.py script with parameters specifying the endpoint URL, model, and dataset for benchmarking MAX Serve performance.\nSOURCE: https://github.com/modular/max/blob/main/benchmark/README.md#2025-04-17_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\npython benchmark_serving.py \\\n    --base-url https://company_url.xyz \\\n    --endpoint /v1/completions \\\n    --backend modular \\\n    --model meta-llama/Meta-Llama-3.1-8B-Instruct \\\n    --dataset-path ShareGPT_V3_unfiltered_cleaned_split.json \\\n    --num-prompts 500\n```\n\n----------------------------------------\n\nTITLE: Type Conversion in Scala 3\nDESCRIPTION: Shows the new conversion syntax introduced in Scala 3 using the given keyword.\nSOURCE: https://github.com/modular/max/blob/main/mojo/proposals/opt-in-implicit-conversion.md#2025-04-17_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\ngiven Conversion[Foo, Int] = (_: Int) => Foo\nlet foo: Foo = 10\n\n```\n\n----------------------------------------\n\nTITLE: Running Python Tests\nDESCRIPTION: Command to execute pytest tests using Magic\nSOURCE: https://github.com/modular/max/blob/main/tutorials/max-graph-python/README.md#2025-04-17_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\nmagic run pytest\n```\n\n----------------------------------------\n\nTITLE: Mojo Standard Library Directory Structure\nDESCRIPTION: The standard directory layout for the Mojo standard library project, showing the organization of documentation, source files, and tests.\nSOURCE: https://github.com/modular/max/blob/main/mojo/stdlib/docs/style-guide.md#2025-04-17_snippet_0\n\nLANGUAGE: text\nCODE:\n```\n> stdlib               # stdlib root directory\n    > doc              # folder containing markdown documentation\n    > scripts          # scripts for compiling and running the tests\n    > src              # stdlib mojo source files\n        > builtin      # mojo source for stdlib builtins\n        > collections  # mojo source for stdlib collections\n        > memory       # mojo source for stdlib memory primitives\n        ...\n    > test             # stdlib unit tests\n```\n\n----------------------------------------\n\nTITLE: Activating Debug Mode via Command Line in Mojo\nDESCRIPTION: Example of the command-line syntax to activate debugging with the -D flag, which defines debug parameters for conditional breakpoints.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/tools/debugging.mdx#2025-04-17_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\nmojo debug -D DEBUG_ME main.mojo\n```\n\n----------------------------------------\n\nTITLE: Explicit Implementation of Lifecycle Methods in Mojo\nDESCRIPTION: Shows the equivalent explicit implementation of lifecycle methods that the @value decorator synthesizes automatically, including __init__, __copyinit__, and __moveinit__ methods.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/structs.mdx#2025-04-17_snippet_8\n\nLANGUAGE: mojo\nCODE:\n```\nstruct MyPet:\n    var name: String\n    var age: Int\n\n    fn __init__(out self, owned name: String, age: Int):\n        self.name = name^\n        self.age = age\n\n    fn __copyinit__(out self, existing: Self):\n        self.name = existing.name\n        self.age = existing.age\n\n    fn __moveinit__(out self, owned existing: Self):\n        self.name = existing.name^\n        self.age = existing.age\n```\n\n----------------------------------------\n\nTITLE: Slicing and Extending a List Efficiently in Mojo\nDESCRIPTION: Shows how to efficiently slice a List and extend it with additional data using Span and List operations.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_7\n\nLANGUAGE: mojo\nCODE:\n```\nbase_data = List[Byte](1, 2, 3, 4, 5, 6)\nn4_n5 = Span(base_data)[3:5]\nextra_data = Span(List[Byte](8, 10))\nend_result = List[Byte](capacity=len(n4_n5) + len(extra_data))\nend_result.extend(n4_n5)\nend_result.extend(extra_data) # [4, 5, 8, 10]\n```\n\n----------------------------------------\n\nTITLE: Setting Up the Benchmark Environment with Git and Magic Shell\nDESCRIPTION: Commands for cloning the MAX repository, navigating to the benchmark directory, and entering the local virtual environment using magic shell.\nSOURCE: https://github.com/modular/max/blob/main/benchmark/README.md#2025-04-17_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit clone -b stable https://github.com/modular/max.git\n\ncd max/benchmark\n\nmagic shell\n```\n\n----------------------------------------\n\nTITLE: Running Mojo Layout Examples with Magic CLI\nDESCRIPTION: These commands use the 'magic' command-line interface to execute Mojo layout examples. The first command runs the basic layouts example, while the second runs the tiled layouts example.\nSOURCE: https://github.com/modular/max/blob/main/examples/mojo/layouts/README.md#2025-04-17_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nmagic run mojo basic_layouts\nmagic run mojo tiled_layouts\n```\n\n----------------------------------------\n\nTITLE: Generating Text with ONNX LLM Model using MAX Engine in Python\nDESCRIPTION: This extensive code snippet shows the process of generating text responses using the loaded ONNX model with MAX Engine. It includes initializing inputs, running the model in a loop to generate tokens, and updating the KV cache for each iteration. The code also calculates and prints the tokens per second performance metric.\nSOURCE: https://github.com/modular/max/blob/main/examples/notebooks/gemma2b-python-onnx.ipynb#2025-04-17_snippet_10\n\nLANGUAGE: python\nCODE:\n```\ninputs = {}\nN_BATCH = 1\nN_LAYERS = 18\nN_HEADS = 1\nKV_LEN = 256\n# Initialize the additional layer to 0 for the first iteration:\nfor i in range(N_LAYERS):\n    inputs[f\"past_key_values.{i}.key\"] = torch.zeros([N_BATCH, N_HEADS, 0, KV_LEN], dtype=torch.float).numpy()\n    inputs[f\"past_key_values.{i}.value\"] = torch.zeros([N_BATCH, N_HEADS, 0, KV_LEN], dtype=torch.float).numpy()\n\ncurrent_seq = input_ids.input_ids\n\ntime_start = time()\nfor idx in range(N_TOKENS):\n    # Prepare inputs dictionary\n    inputs[\"input_ids\"] = current_seq.numpy()\n    inputs[\"position_ids\"] = torch.arange(inputs[\"input_ids\"].shape[1], dtype=torch.long).unsqueeze(0).numpy()\n    inputs[\"attention_mask\"] = torch.ones([1, inputs[\"past_key_values.0.key\"].shape[2] + inputs[\"input_ids\"].shape[1]], dtype=torch.int64).numpy()\n\n    # Run the model with MAX engine\n    max_outputs = maxmodel.execute(**inputs)\n    outputs = torch.from_numpy(max_outputs[\"logits\"])\n\n    # Get the newly generated next token\n    next_token_logits = outputs[:, -1, :]\n    next_tokens_scores = logits_processor(current_seq, next_token_logits)\n    next_tokens = torch.argmax(next_tokens_scores, dim=-1)\n\n    print(hftokenizer.decode(next_tokens), end=' ', flush=True)\n\n    # Append the new token to our sequence\n    current_seq = torch.cat([current_seq, next_tokens[:, None]], dim=-1)\n\n    # Update the KV cache for the next iteration\n    for i in range(N_LAYERS):\n        inputs[f\"past_key_values.{i}.key\"] = max_outputs[f\"present.{i}.key\"]\n        inputs[f\"past_key_values.{i}.value\"] = max_outputs[f\"present.{i}.value\"]\n\ntime_finish = time()\n\nprint(f\"Prompt: {PROMPT}\")\nprint(\"Response:\", hftokenizer.batch_decode(current_seq.numpy(), skip_special_tokens=True)[0][len(PROMPT):])\nprint(f\"Tokens per second: {idx/(time_finish-time_start):.2f}\\n\")\n```\n\n----------------------------------------\n\nTITLE: Tkinter UI Implementation in Python\nDESCRIPTION: A Python class that creates a Tkinter UI application with a button and provides methods to handle state and updates.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/python/index.mdx#2025-04-17_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nimport tkinter as tk\n\nclass App:\n    def __init__(self):\n        self._root = tk.Tk()\n        self.clicked = False\n\n    def click(self):\n        self.clicked = True\n\n    def create_button(self, button_text: str):\n        button = tk.Button(\n            master=self._root,\n            text=button_text,\n            command=self.click\n        )\n        button.place(relx=0.5, rely=0.5, anchor=tk.CENTER)\n\n    def create(self, res: str):\n        self._root.geometry(res)\n        self.create_button(\"Hello Mojo!\")\n\n    def update(self):\n        self._root.update()\n```\n\n----------------------------------------\n\nTITLE: End-to-End Kubernetes Cluster Provisioning and MAX OpenAI API Deployment\nDESCRIPTION: A comprehensive set of commands demonstrating the process of provisioning a Kubernetes cluster using eksctl, creating a namespace, deploying the MAX OpenAI API, testing the service, and cleaning up resources.\nSOURCE: https://github.com/modular/max/blob/main/tutorials/helm/max-openai-api/README.md#2025-04-17_snippet_3\n\nLANGUAGE: console\nCODE:\n```\n# provision a k8s cluster (takes 10-15 minutes)\neksctl create cluster \\\n  --name max-openai-api-demo \\\n  --region us-east-1 \\\n  --node-type g5.4xlarge \\\n  --nodes 1\n\n# create a k8s namespace\nkubectl create namespace max-openai-api-demo\n\n# deploy MAX OpenAI API via helm chart (takes 10 minutes)\nhelm install max-openai-api oci://registry-1.docker.io/modular/max-openai-api-chart \\\n  --version <insert-version> \\\n  --namespace max-openai-api-demo \\\n  --set huggingfaceRepoId=modularai/Llama-3.1-8B-Instruct-GGUF\n  --set maxServe.maxLength=512 \\\n  --set maxServe.maxBatchSize=16 \\\n  --set envSecret.HF_TOKEN=<insert-huggingface-token> \\\n  --set env.HF_HUB_ENABLE_HF_TRANSFER=1 \\\n  --timeout 10m0s \\\n  --wait\n\n# forward the remote k8s port to the local network to access the service locally\n# the command is blocking and takes the terminal\n# user another terminal for subsequent curl and ctrl-c to stop the port forwarding\nPOD_NAME=$(kubectl get pods --namespace max-openai-api-demo -l \"app.kubernetes.io/name=max-openai-api-chart,app.kubernetes.io/instance=max-openai-api\" -o jsonpath=\"{.items[0].metadata.name}\")\nCONTAINER_PORT=$(kubectl get pod --namespace max-openai-api-demo $POD_NAME -o jsonpath=\"{.spec.containers[0].ports[0].containerPort}\")\nkubectl port-forward $POD_NAME 8000:$CONTAINER_PORT --namespace max-openai-api-demo &\n\n# test the service\ncurl -N http://localhost:8000/v1/chat/completions \\\n    -H \"Content-Type: application/json\" \\\n    -d '{\n        \"model\": \"modularai/Llama-3.1-8B-Instruct-GGUF\",\n        \"stream\": true,\n        \"messages\": [\n            {\"role\": \"system\", \"content\": \"You are a helpful assistant.\"},\n            {\"role\": \"user\", \"content\": \"Who won the world series in 2020?\"}\n        ]\n    }'\n\n# uninstall MAX OpenAI API\nhelm uninstall max-openai-api --namespace max-openai-api-demo\n\n# Delete the namespace\nkubectl delete namespace max-openai-api-demo\n\n# delete the k8s cluster\neksctl delete cluster \\\n  --name max-openai-api-demo \\\n  --region us-east-1\n```\n\n----------------------------------------\n\nTITLE: Cloning and Setting Up MAX Repository\nDESCRIPTION: Commands to clone the forked MAX repository and set up the upstream remote for syncing changes.\nSOURCE: https://github.com/modular/max/blob/main/mojo/CONTRIBUTING.md#2025-04-17_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ngit clone git@github.com:[your-username]/max.git\ncd max/mojo\n```\n\nLANGUAGE: bash\nCODE:\n```\ngit remote add upstream git@github.com:modular/max.git\ngit fetch upstream\n```\n\n----------------------------------------\n\nTITLE: Running Mojo Main Program\nDESCRIPTION: Command to execute the main Mojo program using the magic command line tool\nSOURCE: https://github.com/modular/max/blob/main/examples/mojo/operators/README.md#2025-04-17_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nmagic run mojo main.mojo\n```\n\n----------------------------------------\n\nTITLE: Cloning the Mojo Repository\nDESCRIPTION: Git command to clone the Mojo repository from GitHub. By default, this clones the 'main' branch which corresponds to the latest nightly build.\nSOURCE: https://github.com/modular/max/blob/main/mojo/README.md#2025-04-17_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/modular/max.git\n```\n\n----------------------------------------\n\nTITLE: Mojo License Header Template\nDESCRIPTION: Standard license header template for Mojo source files.\nSOURCE: https://github.com/modular/max/blob/main/mojo/stdlib/docs/style-guide.md#2025-04-17_snippet_5\n\nLANGUAGE: mojo\nCODE:\n```\n# ===----------------------------------------------------------------------=== #\n# Copyright (c) 2025, Modular Inc. All rights reserved.\n#\n# Licensed under the Apache License v2.0 with LLVM Exceptions:\n# https://llvm.org/LICENSE.txt\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ===----------------------------------------------------------------------=== #\n```\n\n----------------------------------------\n\nTITLE: Equivalent Expanded Struct with Manually Written Lifecycle Methods in Mojo\nDESCRIPTION: This code demonstrates what the compiler actually generates when the @value decorator is applied, showing the __init__, __copyinit__, and __moveinit__ methods that are synthesized automatically.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/decorators/value.md#2025-04-17_snippet_1\n\nLANGUAGE: mojo\nCODE:\n```\nstruct MyPet:\n    var name: String\n    var age: Int\n\n    fn __init__(out self, owned name: String, age: Int):\n        self.name = name^\n        self.age = age\n\n    fn __copyinit__(out self, existing: Self):\n        self.name = existing.name\n        self.age = existing.age\n\n    fn __moveinit__(out self, owned existing: Self):\n        self.name = existing.name^\n        self.age = existing.age\n```\n\n----------------------------------------\n\nTITLE: For Loop with Else Clause in Mojo\nDESCRIPTION: Shows how to use an else clause that executes after a for loop completes all iterations.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/control-flow.mdx#2025-04-17_snippet_19\n\nLANGUAGE: mojo\nCODE:\n```\nfor i in range(5):\n    print(i, end=\", \")\nelse:\n    print(\"\\nFinished executing 'for' loop\")\n```\n\n----------------------------------------\n\nTITLE: Running the Example Mojo Program\nDESCRIPTION: Command to execute the example program that uses functions from the my_math package. This demonstrates the practical application of the code being tested.\nSOURCE: https://github.com/modular/max/blob/main/examples/mojo/testing/README.md#2025-04-17_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nmojo src/example.mojo\n```\n\n----------------------------------------\n\nTITLE: Running Benchmarks Script Command\nDESCRIPTION: Command for running benchmarks with custom configuration using the run-benchmarks script. Demonstrates how to test changes on the current branch.\nSOURCE: https://github.com/modular/max/blob/main/mojo/stdlib/benchmarks/README.md#2025-04-17_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nmagic run stdlib/scripts/run-benchmarks.sh stdlib/benchmarks/collections/bench_dict.mojo\n```\n\n----------------------------------------\n\nTITLE: Configuring CUDA-GDB Debugger Backend in JSON\nDESCRIPTION: This JSON snippet shows how to configure the launch configuration to use the classic CUDA-GDB debugger backend by setting environment variables through initCommands.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/tools/debugging.mdx#2025-04-17_snippet_4\n\nLANGUAGE: json\nCODE:\n```\n\"initCommands\": [\n    \"set environment CUDBG_USE_LEGACY_DEBUGGER=1\"\n],\n```\n\n----------------------------------------\n\nTITLE: String Character Iteration Example - Old Style\nDESCRIPTION: Demonstrates the deprecated way of iterating over characters in a Mojo string using the __iter__() method.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_12\n\nLANGUAGE: mojo\nCODE:\n```\nvar s: String  = ...\nfor c in s:\n    # ...\n```\n\n----------------------------------------\n\nTITLE: Configuring CMake Project for Max Engine BERT Example\nDESCRIPTION: Sets up a CMake project that builds a BERT model example using the Max Engine. The configuration specifies C as the language, includes Max Engine's CMake modules, and links the executable against the Max Engine library.\nSOURCE: https://github.com/modular/max/blob/main/examples/inference/bert-c-torchscript/CMakeLists.txt#2025-04-17_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ncmake_minimum_required(VERSION 3.24)\n\nproject(max-examples LANGUAGES C)\n\nlist(APPEND CMAKE_MODULE_PATH \"$ENV{MAX_PKG_DIR}/lib/cmake\")\ninclude(AddMaxEngine)\n\nadd_executable(bert main.c)\ntarget_link_libraries(bert PUBLIC max-engine)\n```\n\n----------------------------------------\n\nTITLE: Switching to Stable Branch\nDESCRIPTION: Command to switch to the stable branch when using the stable release of MAX, as the main branch is for nightly releases.\nSOURCE: https://github.com/modular/max/blob/main/README.md#2025-04-17_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ngit checkout stable\n```\n\n----------------------------------------\n\nTITLE: Pull Request Creation Output\nDESCRIPTION: Example output showing the link to create a new pull request on GitHub after pushing changes.\nSOURCE: https://github.com/modular/max/blob/main/mojo/CONTRIBUTING.md#2025-04-17_snippet_6\n\nLANGUAGE: plaintext\nCODE:\n```\nremote: Create a pull request for 'my-fix-pr' on GitHub by visiting:\nremote:      https://github.com/[your-username]/max/pull/new/my-fix-pr\n```\n\n----------------------------------------\n\nTITLE: Default Service Configuration\nDESCRIPTION: Default service configuration for MAX deployment, specifying port mappings and service type.\nSOURCE: https://github.com/modular/max/blob/main/tutorials/helm/max-openai-api/README.md#2025-04-17_snippet_5\n\nLANGUAGE: yaml\nCODE:\n```\nservice:\n  ports:\n    - name: \"http\"\n      port: 8000\n      protocol: \"TCP\"\n      targetPort: 8000\n  type: \"ClusterIP\"\n```\n\n----------------------------------------\n\nTITLE: Running Stable Diffusion using magic command\nDESCRIPTION: Command to run the Stable Diffusion example using the 'magic' tool provided by Modular.\nSOURCE: https://github.com/modular/max/blob/main/examples/inference/stable-diffusion-python-onnx/README.md#2025-04-17_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\nmagic run bash run.sh\n```\n\n----------------------------------------\n\nTITLE: Casting Mutable Pointers to Immutable in Mojo\nDESCRIPTION: Demonstrates how to cast a mutable pointer to an immutable pointer using UnsafePointer's origin_cast method with the mut=False parameter.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_18\n\nLANGUAGE: mojo\nCODE:\n```\nvar local = 10\n# Cast the mutable pointer to be immutable.\nvar ptr = UnsafePointer.address_of(local).origin_cast[mut=False]()\n```\n\n----------------------------------------\n\nTITLE: Cloning Mojo Examples Repository using Git\nDESCRIPTION: This command clones the Mojo examples repository from GitHub, allowing developers to access the sample programs locally.\nSOURCE: https://github.com/modular/max/blob/main/examples/mojo/README.md#2025-04-17_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/modular/max.git\n```\n\n----------------------------------------\n\nTITLE: Deactivating Magic Project Virtual Environment\nDESCRIPTION: Command to exit and deactivate the project's virtual environment when done working with the project.\nSOURCE: https://github.com/modular/max/blob/main/examples/mojo/testing/README.md#2025-04-17_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nexit\n```\n\n----------------------------------------\n\nTITLE: Running Specific Tests in Bash\nDESCRIPTION: This bash command shows how to run tests for a specific module (pathlib) using the lit testing tool.\nSOURCE: https://github.com/modular/max/blob/main/mojo/stdlib/docs/development.md#2025-04-17_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\nlit -sv test/pathlib\n```\n\n----------------------------------------\n\nTITLE: Building Standard Library Using Bash Script\nDESCRIPTION: Command to build the Mojo standard library using the build-stdlib.sh script, which creates build artifacts and produces stdlib.mojopkg\nSOURCE: https://github.com/modular/max/blob/main/mojo/stdlib/docs/development.md#2025-04-17_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n./stdlib/scripts/build-stdlib.sh\n```\n\n----------------------------------------\n\nTITLE: Pre-commit Installation Commands\nDESCRIPTION: Commands for installing and setting up pre-commit hooks for automated code formatting.\nSOURCE: https://github.com/modular/max/blob/main/mojo/stdlib/docs/style-guide.md#2025-04-17_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\npip install pre-commit\npre-commit install\n```\n\n----------------------------------------\n\nTITLE: Command-Line Mojo GPU Debugging Launch\nDESCRIPTION: Command to start a GPU debugging session using CUDA-GDB from the command line. The --break-on-launch flag pauses execution at kernel launch to allow setting GPU code breakpoints.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/tools/gpu-debugging.mdx#2025-04-17_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nmojo debug --cuda-gdb --break-on-launch --vscode myproject.mojo\n```\n\n----------------------------------------\n\nTITLE: Running Text Pre-processing for BERT\nDESCRIPTION: Example command for running the pre-processing Python script that prepares input text for BERT inference and saves it to a local directory for use with the C program.\nSOURCE: https://github.com/modular/max/blob/main/examples/inference/bert-c-torchscript/README.md#2025-04-17_snippet_2\n\nLANGUAGE: sh\nCODE:\n```\npython3 pre-process.py --text \"Paris is the [MASK] of France.\"\n```\n\n----------------------------------------\n\nTITLE: MLIR Operation Examples\nDESCRIPTION: Core MLIR operations used in Mojo standard library that require documentation, including external calls, ownership management, and LLVM intrinsics.\nSOURCE: https://github.com/modular/max/blob/main/mojo/proposals/stdlib-insider-docs.md#2025-04-17_snippet_0\n\nLANGUAGE: MLIR\nCODE:\n```\npop.external_call\\nlit.ownership.mark_destroyed\\nlit.ownership.mark_initialized\\nlit.ref.from_pointer\\npop.call_llvm_intrinsic\\nsys.intrinsics.llvm_intrinsic\\npop.inline_asm\\n!lit.origin.set\n```\n\n----------------------------------------\n\nTITLE: Vanilla Transformers Implementation\nDESCRIPTION: Basic implementation using Hugging Face transformers library to generate text with Mistral-7B model\nSOURCE: https://github.com/modular/max/blob/main/examples/notebooks/mistral7b-python-onnx.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n%%time\n\nimport torch\nfrom transformers import AutoTokenizer, AutoModelForCausalLM\n\nPROMPT = \"Why did the chicken cross the road?\"\n\nhf_path = \"mistralai/Mistral-7B-v0.1\"\nhfmodel = AutoModelForCausalLM.from_pretrained(hf_path)\nhftokenizer = AutoTokenizer.from_pretrained(hf_path)\nhftokenizer.pad_token = hftokenizer.eos_token\n\n# Tokenize the text prompt\ninput_ids = hftokenizer(PROMPT, return_tensors=\"pt\", max_length=128, truncation=True).input_ids\n\n# Run generation\nout_ids = hfmodel.generate(input_ids=input_ids, max_new_tokens=15, do_sample=False)\n\n# De-tokenize the generated response\nresponse = hftokenizer.batch_decode(out_ids.numpy(), skip_special_tokens=True)[0][len(PROMPT):]\nprint(\"Response:\", response)\n```\n\n----------------------------------------\n\nTITLE: Code Quality Commands\nDESCRIPTION: Commands for running type checking with mypy and code formatting with black and isort\nSOURCE: https://github.com/modular/max/blob/main/tutorials/max-graph-python/README.md#2025-04-17_snippet_4\n\nLANGUAGE: shell\nCODE:\n```\nmagic run mypy\n```\n\nLANGUAGE: shell\nCODE:\n```\nmagic run black\n```\n\nLANGUAGE: shell\nCODE:\n```\nmagic run isort\n```\n\n----------------------------------------\n\nTITLE: Comparison Operations in MLIR POP Dialect\nDESCRIPTION: Example of comparison operation using the cmp operator\nSOURCE: https://github.com/modular/max/blob/main/mojo/stdlib/docs/internal/pop_dialect.md#2025-04-17_snippet_6\n\nLANGUAGE: mlir\nCODE:\n```\n%result = pop.cmp %lhs, %rhs {predicate = \"sgt\"}\n```\n\n----------------------------------------\n\nTITLE: Alternative: Segmented Parameter List Call Syntax\nDESCRIPTION: Shows how the segmented parameter list approach would be called, demonstrating inference of the first parameter list.\nSOURCE: https://github.com/modular/max/blob/main/mojo/proposals/inferred-parameters.md#2025-04-17_snippet_12\n\nLANGUAGE: python\nCODE:\n```\nscalar_param[Int32()]()\n```\n\n----------------------------------------\n\nTITLE: Configuring Conda for Nightly MAX\nDESCRIPTION: YAML configuration for setting up a Conda environment with the nightly MAX channel.\nSOURCE: https://github.com/modular/max/blob/main/mojo/CONTRIBUTING.md#2025-04-17_snippet_4\n\nLANGUAGE: yaml\nCODE:\n```\n[project]\nname = \"Mojo nightly example\"\nchannels = [\"conda-forge\", \"https://conda.modular.com/max-nightly/\"]\nplatforms = [\"osx-arm64\", \"linux-aarch64\", \"linux-64\"]\n\n[dependencies]\nmax = \"*\"\n```\n\n----------------------------------------\n\nTITLE: Running Life Version 2 with Magic\nDESCRIPTION: Command to execute version 2 of Conway's Game of Life implementation using the Magic tool. Displays a window showing initial random state and subsequent generations.\nSOURCE: https://github.com/modular/max/blob/main/examples/mojo/life/README.md#2025-04-17_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nmagic run lifev2\n```\n\n----------------------------------------\n\nTITLE: Specifying HuggingFace Hub Library Version Constraint\nDESCRIPTION: Defines the required version of huggingface_hub library to be at least 0.24.6 but less than 0.25. This ensures compatibility while preventing automatic updates to potentially breaking versions.\nSOURCE: https://github.com/modular/max/blob/main/examples/graph-api/requirements.txt#2025-04-17_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\nhuggingface_hub >=0.24.6,<0.25\n```\n\n----------------------------------------\n\nTITLE: Upgrading MAX OpenAI API Helm Chart\nDESCRIPTION: Command to upgrade an existing MAX OpenAI API Helm chart installation on a Kubernetes cluster.\nSOURCE: https://github.com/modular/max/blob/main/tutorials/helm/max-openai-api/README.md#2025-04-17_snippet_1\n\nLANGUAGE: console\nCODE:\n```\nhelm upgrade max-openai-api oci://registry-1.docker.io/modular/max-openai-api-chart\n```\n\n----------------------------------------\n\nTITLE: Default MAX Serve Configuration Values\nDESCRIPTION: Default configuration values for MAX serving component including cache strategy, model repository, and inference parameters.\nSOURCE: https://github.com/modular/max/blob/main/tutorials/helm/max-openai-api/README.md#2025-04-17_snippet_4\n\nLANGUAGE: yaml\nCODE:\n```\nmaxServe:\n  cacheStrategy: \"continuous\"\n  huggingfaceRepoId: \"modularai/Llama-3.1-8B-Instruct-GGUF\"\n  maxBatchSize: \"250\"\n  maxLength: \"2048\"\n  maxNumSteps: \"10\"\n```\n\n----------------------------------------\n\nTITLE: Starting Embeddings Endpoint with MAX Pipelines\nDESCRIPTION: This command starts the embeddings endpoint using MAX pipelines, specifying the sentence-transformers model path.\nSOURCE: https://github.com/modular/max/blob/main/tutorials/run-embeddings-with-max-serve/README.md#2025-04-17_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nmax-pipelines serve --model-path=sentence-transformers/all-mpnet-base-v2\n```\n\n----------------------------------------\n\nTITLE: Proposed Mojo Lifetime Syntax for Functions\nDESCRIPTION: Proposed syntax for Mojo lifetimes using the Lifetime type parameter and ref/mutref keywords. The function longest takes two references with the same lifetime 'a' and returns a reference with that same lifetime.\nSOURCE: https://github.com/modular/max/blob/main/mojo/proposals/lifetimes-and-provenance.md#2025-04-17_snippet_2\n\nLANGUAGE: mojo\nCODE:\n```\n# Proposed Mojo syntax.\nfn longest[a: Lifetime](x: ref[a] String,\n                        y: ref[a] String) -> ref[a] String:\n    return x if len(x) >= len(y) else y\n\nfn longest2[a: Lifetime](x: mutref[a] String,\n                         y: mutref[a] String) -> mutref[a] String: ...\n```\n\n----------------------------------------\n\nTITLE: Field Transfer and Reinitialization in Mojo\nDESCRIPTION: Shows how fields can be transferred and reinitialized, demonstrating Mojo's handling of partially initialized objects and field ownership transfer.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/lifecycle/death.mdx#2025-04-17_snippet_5\n\nLANGUAGE: mojo\nCODE:\n```\nfn consume(owned arg: String):\n    pass\n\nfn use(arg: MyPet):\n    print(arg.name)\n\nfn consume_and_use():\n    var pet = MyPet(\"Selma\", 5)\n    consume(pet.name^)\n    # pet.name.__moveinit__() runs here, which destroys pet.name\n    # Now pet is only partially initialized\n\n    # use(pet)  # This fails because pet.name is uninitialized\n\n    pet.name = String(\"Jasper\")  # All together now\n    use(pet)                     # This is ok\n    # pet.__del__() runs here (and only if the object is whole)\n```\n\n----------------------------------------\n\nTITLE: Installing GUI Dependencies for OpenCV on Ubuntu\nDESCRIPTION: Command to install the libgl1 package, which is required for OpenCV's GUI capabilities on Ubuntu. This is necessary for the webcam version of the example.\nSOURCE: https://github.com/modular/max/blob/main/examples/inference/yolo-python-onnx/README.md#2025-04-17_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\napt install -y libgl1\n```\n\n----------------------------------------\n\nTITLE: Polling Tkinter from Mojo Main Loop\nDESCRIPTION: A Mojo program that imports a Python Tkinter application and polls for updates, showing how to work around Python's inability to call Mojo functions.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/python/index.mdx#2025-04-17_snippet_5\n\nLANGUAGE: mojo\nCODE:\n```\nfrom python import Python\n\ndef button_clicked():\n    print(\"Hi from a Mojo🔥 fn!\")\n\ndef main():\n    Python.add_to_path(\".\")\n    app = Python.import_module(\"myapp\").App()\n    app.create(\"800x600\")\n\n    while True:\n        app.update()\n        if app.clicked:\n            button_clicked()\n            app.clicked = False\n```\n\n----------------------------------------\n\nTITLE: Issue Template Format in Markdown\nDESCRIPTION: Standard template structure for submitting bug reports to the Mojo project, including summary, description, environment details, and severity assessment.\nSOURCE: https://github.com/modular/max/blob/main/mojo/CONTRIBUTING.md#2025-04-17_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n- **Summary.** A descriptive summary of the issue.\n- **Description.** A detailed account of the bug, including what was expected\n  and what occurred.\n- **Environment details.**\n  - Mojo Compiler Version\n  - Operating System version\n  - Hardware Specifications\n- **Severity/frequency.** An assessment of the impact ranging from inconvenience\n  to a blocker.\n```\n\n----------------------------------------\n\nTITLE: Using MLIR Operations with Attributes in Mojo\nDESCRIPTION: Example of accessing MLIR operations with custom attributes in Mojo, demonstrating how to attach predicates and specify result types for operations.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_232\n\nLANGUAGE: mojo\nCODE:\n```\n__mlir_op.`index.cmp`[\n    _type: __mlir_type.i1,\n    pred: __mlir_attr.`#index<cmp_predicate slt>`\n](lhs, rhs)\n```\n\n----------------------------------------\n\nTITLE: Defining and Using Scalar Type Alias\nDESCRIPTION: Shows how to create and use parametric type aliases with partial binding.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_149\n\nLANGUAGE: mojo\nCODE:\n```\nalias Scalar = SIMD[size=1]\n\nfn type_aliases():\n    alias T = SIMD\n    print(T[DType.float32, 1]())\n    alias Partial = T[type=DType.int32]\n    print(Partial[2]())\n```\n\n----------------------------------------\n\nTITLE: Printing Benchmark Reports in Mojo\nDESCRIPTION: Shows how to print benchmark reports in Mojo with different time units. This demonstrates the formatting of benchmark results and how to change the output unit.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/changelog-released.md#2025-04-17_snippet_161\n\nLANGUAGE: mojo\nCODE:\n```\nreport.print()\n```\n\nLANGUAGE: plaintext\nCODE:\n```\n---------------------\nBenchmark Report (s)\n---------------------\nMean: 0.012314264957264957\nTotal: 1.440769\nIters: 117\nWarmup Mean: 0.0119335\nWarmup Total: 0.023866999999999999\nWarmup Iters: 2\nFastest Mean: 0.012227958333333334\nSlowest Mean: 0.012442699999999999\n```\n\nLANGUAGE: mojo\nCODE:\n```\nfrom benchmark import Unit\n\nreport.print[Unit.ms]()\n```\n\n----------------------------------------\n\nTITLE: Future Mojo Pattern Matching Example\nDESCRIPTION: Demonstrates the planned pattern matching approach in Mojo for handling reference bindings in list iterations.\nSOURCE: https://github.com/modular/max/blob/main/mojo/stdlib/docs/faq.md#2025-04-17_snippet_2\n\nLANGUAGE: mojo\nCODE:\n```\nfor (ref e) in list:\n  self.append(e) # note no-dereference needed to pattern ref binding above\n```\n\n----------------------------------------\n\nTITLE: Implicit Conversion in C++\nDESCRIPTION: Demonstrates basic implicit type conversion in C++ using a constructor that accepts an integer parameter.\nSOURCE: https://github.com/modular/max/blob/main/mojo/proposals/opt-in-implicit-conversion.md#2025-04-17_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\nstruct Foo { Foo(int x) {} };\nFoo foo = 10;\n\n```\n\n----------------------------------------\n\nTITLE: Documenting Constraints in Mojo\nDESCRIPTION: Example demonstrating how to document compile-time constraints in Mojo using bulleted lists.\nSOURCE: https://github.com/modular/max/blob/main/mojo/stdlib/docs/docstring-style-guide.md#2025-04-17_snippet_1\n\nLANGUAGE: plaintext\nCODE:\n```\nConstraints:\n    - The system must be x86.\n    - `x.type` must be floating point.\n```\n\n----------------------------------------\n\nTITLE: Testing Register Passable Pair Structure\nDESCRIPTION: Shows the execution of the test_pair() function to demonstrate the behavior of the register passable Pair structure.\nSOURCE: https://github.com/modular/max/blob/main/mojo/docs/manual/decorators/register-passable.md#2025-04-17_snippet_1\n\nLANGUAGE: mojo\nCODE:\n```\ntest_pair()\n```\n\n----------------------------------------\n\nTITLE: Cloning MAX Repository\nDESCRIPTION: Command to clone the MAX platform repository from GitHub to the local machine.\nSOURCE: https://github.com/modular/max/blob/main/README.md#2025-04-17_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/modular/max.git\n```"
  }
]