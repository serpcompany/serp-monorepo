[
  {
    "owner": "rust-or",
    "repo": "good_lp",
    "content": "TITLE: Defining and Solving MILP Models Using good_lp in Rust\nDESCRIPTION: This Rust snippet demonstrates declaring variables using the good_lp crate's macro, defining a linear objective function to maximise, adding linear constraints, invoking the default MILP solver, and printing the solution values. It requires the good_lp crate along with its dependencies, and uses the default_solver feature. Inputs include linear constraints and objective coefficients, while outputs are the optimized variable values and evaluated objective expressions. This example highlights idiomatic modeling syntax, solver usage via `.using()`, and result extraction via `.value()` and `.eval()`. Error handling is done using Rust's Result with boxed dynamic error types.\nSOURCE: https://github.com/rust-or/good_lp/blob/main/README.md#_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\nuse std::error::Error;\n\nuse good_lp::{constraint, default_solver, Solution, SolverModel, variables};\n\nfn main() -> Result<(), Box<dyn Error>> {\n    variables! {\n        vars:\n               a <= 1;\n          2 <= b <= 4;\n    } // variables can also be added dynamically\n    let solution = vars.maximise(10 * (a - b / 5) - b)\n        .using(default_solver) // multiple solvers available\n        .with(constraint!(a + 2 <= b))\n        .with(constraint!(1 + a >= 4 - b))\n        .solve()?;\n    println!(\"a={}   b={}\", solution.value(a), solution.value(b));\n    println!(\"a + b = {}\", solution.eval(a + b));\n    Ok(())\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Variables and Constraints Using good_lp Macros in Rust\nDESCRIPTION: Demonstrates how to define optimization variables with bounds and integer constraints using the `variables!` macro of the good_lp crate in Rust. It shows defining continuous and integer variables with bounds specified using f64 and i32 literals. Additionally, it creates a model that maximizes variable `b` subject to linear inequality constraints on variables `a` and `b`. This snippet assumes the use of a default solver compatible with the good_lp API.\nSOURCE: https://github.com/rust-or/good_lp/blob/main/README.md#_snippet_4\n\nLANGUAGE: Rust\nCODE:\n```\n// Correct use of f64 and i32 to specify feasible ranges for Variables\n  variables! {\n    problem:\n      a <= 10.0;\n      2 <= b (integer) <= 4;  // Variables can be restricted using qualifiers like (integer)\n  };\n  let model = problem\n    .maximise(b)\n    .using(default_solver)\n    .with(constraint!(a + 2 <= b))\n    .with(constraint!(1 + a >= 4.0 - b));\n```\n\n----------------------------------------\n\nTITLE: Accessing Solution Values for Variables in good_lp Using Rust\nDESCRIPTION: Illustrates retrieving and printing solution values of optimization variables using the `solution.value()` and `solution.eval()` methods from the good_lp crate in Rust. Emphasizes that solution values are always `f64` regardless of initial variable declarations, which prevents mixing with incompatible integer types in calculations. The snippet demonstrates correct usage for outputting continuous or integer variable values and flags the incorrect usage which leads to compilation errors due to type mismatch.\nSOURCE: https://github.com/rust-or/good_lp/blob/main/README.md#_snippet_5\n\nLANGUAGE: Rust\nCODE:\n```\n// Correct use of f64 for solution values\nprintln!(\"a={}   b={}\", solution.value(a), solution.value(b));\nprintln!(\"a + b = {}\", solution.eval(a + b));\n\n// Incorrect use of i32 in combination with solution value (Will fail!)\nprintln!(\"a + 1 = {}\", solution.value(a) + 1); // This will cause a compilation error!\n```\n\n----------------------------------------\n\nTITLE: Configuring good_lp with Alternative Solver Features Using Cargo.toml\nDESCRIPTION: This TOML snippet shows how to specify an alternative solver feature when adding the good_lp crate as a dependency in a Rust project's Cargo.toml file. It requires disabling default features and enabling a feature corresponding to the desired solver, e.g., coin_cbc or microlp. This configuration enables good_lp to abstract over different solver backends. Users must ensure mutual exclusivity where applicable, e.g., between lpsolve and cplex-rs features, to avoid compilation conflicts.\nSOURCE: https://github.com/rust-or/good_lp/blob/main/README.md#_snippet_1\n\nLANGUAGE: TOML\nCODE:\n```\ngood_lp = { version = \"*\", features = [\"your solver feature name\"], default-features = false }\n```\n\n----------------------------------------\n\nTITLE: Installing CBC Solver Dependencies Using Bash Commands\nDESCRIPTION: This Bash snippet provides command-line instructions to install the CBC (Coin-or branch and cut) solver dependencies on Ubuntu and macOS systems. It installs the CBC solver library and headers needed for compiling and running good_lp with the coin_cbc feature. These commands assume sudo privileges and package managers apt-get for Ubuntu and Homebrew for macOS. Proper installation is necessary for good_lp to interface with CBC solver binaries during problem solving.\nSOURCE: https://github.com/rust-or/good_lp/blob/main/README.md#_snippet_2\n\nLANGUAGE: Bash\nCODE:\n```\nsudo apt-get install coinor-cbc coinor-libcbc-dev\n```\n\nLANGUAGE: Bash\nCODE:\n```\nbrew install cbc\n```\n\n----------------------------------------\n\nTITLE: Installing SCIP Solver Using Conda Shell Command\nDESCRIPTION: This shell command installs the SCIP solver via the conda package manager from the conda-forge channel. It provides an alternative solver option for use with good_lp by enabling the scip feature. The command installs SCIP including all runtime dependencies, facilitating SCIP integration without manual compilation. Users need to have conda installed and configured to execute this command successfully.\nSOURCE: https://github.com/rust-or/good_lp/blob/main/README.md#_snippet_3\n\nLANGUAGE: Shell\nCODE:\n```\nconda install --channel conda-forge scip\n```\n\n----------------------------------------\n\nTITLE: Formatting Rust Code with cargo fmt (Shell)\nDESCRIPTION: Instructs contributors to format their Rust code using the standard `cargo fmt` command before submitting changes. This ensures code style consistency across the project and is a prerequisite for contributions.\nSOURCE: https://github.com/rust-or/good_lp/blob/main/CONTRIBUTING.md#_snippet_0\n\nLANGUAGE: Shell\nCODE:\n```\ncargo fmt\n```\n\n----------------------------------------\n\nTITLE: Launching Dev Container in VS Code (Command)\nDESCRIPTION: Specifies the VS Code command palette action `Dev Containers: Reopen in Container` used to launch the pre-configured development environment defined in the repository. This requires Docker and the VS Code 'Dev Containers' extension to be installed.\nSOURCE: https://github.com/rust-or/good_lp/blob/main/CONTRIBUTING.md#_snippet_1\n\nLANGUAGE: Plain Text\nCODE:\n```\nDev Containers: Reopen in Container\n```"
  }
]