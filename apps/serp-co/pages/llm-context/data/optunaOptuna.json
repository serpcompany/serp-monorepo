[
  {
    "owner": "optuna",
    "repo": "optuna",
    "content": "TITLE: Defining and Optimizing an Objective Function with Optuna in Python\nDESCRIPTION: This snippet demonstrates how to define an objective function for hyperparameter optimization using Optuna. It includes suggesting hyperparameters, training a model, and evaluating its performance. The example uses scikit-learn for a regression task.\nSOURCE: https://github.com/optuna/optuna/blob/master/README.md#2025-04-15_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport ...\n\n# Define an objective function to be minimized.\ndef objective(trial):\n\n    # Invoke suggest methods of a Trial object to generate hyperparameters.\n    regressor_name = trial.suggest_categorical('regressor', ['SVR', 'RandomForest'])\n    if regressor_name == 'SVR':\n        svr_c = trial.suggest_float('svr_c', 1e-10, 1e10, log=True)\n        regressor_obj = sklearn.svm.SVR(C=svr_c)\n    else:\n        rf_max_depth = trial.suggest_int('rf_max_depth', 2, 32)\n        regressor_obj = sklearn.ensemble.RandomForestRegressor(max_depth=rf_max_depth)\n\n    X, y = sklearn.datasets.fetch_california_housing(return_X_y=True)\n    X_train, X_val, y_train, y_val = sklearn.model_selection.train_test_split(X, y, random_state=0)\n\n    regressor_obj.fit(X_train, y_train)\n    y_pred = regressor_obj.predict(X_val)\n\n    error = sklearn.metrics.mean_squared_error(y_val, y_pred)\n\n    return error  # An objective value linked with the Trial object.\n\nstudy = optuna.create_study()  # Create a new study.\nstudy.optimize(objective, n_trials=100)  # Invoke optimization of the objective function.\n```\n\n----------------------------------------\n\nTITLE: Defining Objective Functions with Custom Arguments in Python\nDESCRIPTION: Demonstrates two ways to define objective functions with custom arguments in Optuna: using a callable class and using a lambda function. This allows passing additional parameters to the objective function beyond just the trial object.\nSOURCE: https://github.com/optuna/optuna/blob/master/docs/source/faq.rst#2025-04-15_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport optuna\n\n\nclass Objective:\n    def __init__(self, min_x, max_x):\n        # Hold this implementation specific arguments as the fields of the class.\n        self.min_x = min_x\n        self.max_x = max_x\n\n    def __call__(self, trial):\n        # Calculate an objective value by using the extra arguments.\n        x = trial.suggest_float(\"x\", self.min_x, self.max_x)\n        return (x - 2) ** 2\n\n\n# Execute an optimization by using an `Objective` instance.\nstudy = optuna.create_study()\nstudy.optimize(Objective(-100, 100), n_trials=100)\n```\n\nLANGUAGE: python\nCODE:\n```\nimport optuna\n\n# Objective function that takes three arguments.\ndef objective(trial, min_x, max_x):\n    x = trial.suggest_float(\"x\", min_x, max_x)\n    return (x - 2) ** 2\n\n\n# Extra arguments.\nmin_x = -100\nmax_x = 100\n\n# Execute an optimization by using the above objective function wrapped by `lambda`.\nstudy = optuna.create_study()\nstudy.optimize(lambda trial: objective(trial, min_x, max_x), n_trials=100)\n```\n\n----------------------------------------\n\nTITLE: Implementing Hyperparameter Optimization with Optuna in Python\nDESCRIPTION: Demonstrates how to define and optimize an objective function for hyperparameter tuning using Optuna. The example shows optimization of machine learning models (SVR and RandomForest) with different hyperparameters, using California housing dataset.\nSOURCE: https://github.com/optuna/optuna/blob/master/docs/source/index.rst#2025-04-15_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport ...\n\n# Define an objective function to be minimized.\ndef objective(trial):\n\n    # Invoke suggest methods of a Trial object to generate hyperparameters.\n    regressor_name = trial.suggest_categorical('classifier', ['SVR', 'RandomForest'])\n    if regressor_name == 'SVR':\n        svr_c = trial.suggest_float('svr_c', 1e-10, 1e10, log=True)\n        regressor_obj = sklearn.svm.SVR(C=svr_c)\n    else:\n        rf_max_depth = trial.suggest_int('rf_max_depth', 2, 32)\n        regressor_obj = sklearn.ensemble.RandomForestRegressor(max_depth=rf_max_depth)\n\n    X, y = sklearn.datasets.fetch_california_housing(return_X_y=True)\n    X_train, X_val, y_train, y_val = sklearn.model_selection.train_test_split(X, y, random_state=0)\n\n    regressor_obj.fit(X_train, y_train)\n    y_pred = regressor_obj.predict(X_val)\n\n    error = sklearn.metrics.mean_squared_error(y_val, y_pred)\n\n    return error  # An objective value linked with the Trial object.\n\nstudy = optuna.create_study()  # Create a new study.\nstudy.optimize(objective, n_trials=100)  # Invoke optimization of the objective function.\n```\n\n----------------------------------------\n\nTITLE: Using OptunaHub to load registered modules with Optuna\nDESCRIPTION: Example code demonstrating how to use OptunaHub to load a registered module (AutoSampler) and integrate it with Optuna for optimization. The code defines an objective function and performs optimization over 10 trials.\nSOURCE: https://github.com/optuna/optuna/blob/master/README.md#2025-04-15_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nimport optuna\nimport optunahub\n\n\ndef objective(trial: optuna.Trial) -> float:\n    x = trial.suggest_float(\"x\", -5, 5)\n    y = trial.suggest_float(\"y\", -5, 5)\n    return x**2 + y**2\n\n\nmodule = optunahub.load_module(package=\"samplers/auto_sampler\")\nstudy = optuna.create_study(sampler=module.AutoSampler())\nstudy.optimize(objective, n_trials=10)\n\nprint(study.best_trial.value, study.best_trial.params)\n```\n\n----------------------------------------\n\nTITLE: Launching Optuna Dashboard with Python and Bash\nDESCRIPTION: This snippet demonstrates how to create an Optuna study with a SQLite database, run an optimization, and then launch the Optuna Dashboard to visualize the results.\nSOURCE: https://github.com/optuna/optuna/blob/master/README.md#2025-04-15_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nimport optuna\n\n\ndef objective(trial):\n    x1 = trial.suggest_float(\"x1\", -100, 100)\n    x2 = trial.suggest_float(\"x2\", -100, 100)\n    return x1 ** 2 + 0.01 * x2 ** 2\n\n\nstudy = optuna.create_study(storage=\"sqlite:///db.sqlite3\")  # Create a new study with database.\nstudy.optimize(objective, n_trials=100)\n```\n\nLANGUAGE: bash\nCODE:\n```\n# Run the study specified above\n$ python optimize_toy.py\n\n# Launch the dashboard based on the storage `sqlite:///db.sqlite3`\n$ optuna-dashboard sqlite:///db.sqlite3\n...\nListening on http://localhost:8080/\nHit Ctrl-C to quit.\n```\n\n----------------------------------------\n\nTITLE: Saving and Resuming Optuna Studies Using joblib in Python\nDESCRIPTION: Demonstrates how to save and resume Optuna studies using joblib for in-memory storage. This allows studies to be persisted and loaded across different Python sessions.\nSOURCE: https://github.com/optuna/optuna/blob/master/docs/source/faq.rst#2025-04-15_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nstudy = optuna.create_study()\njoblib.dump(study, \"study.pkl\")\n```\n\nLANGUAGE: python\nCODE:\n```\nstudy = joblib.load(\"study.pkl\")\nprint(\"Best trial until now:\")\nprint(\" Value: \", study.best_trial.value)\nprint(\" Params: \")\nfor key, value in study.best_trial.params.items():\n    print(f\"    {key}: {value}\")\n```\n\n----------------------------------------\n\nTITLE: Implementing Heartbeat Monitoring for Trial Failure Detection\nDESCRIPTION: Demonstrates how to configure heartbeat monitoring in Optuna to automatically mark trials as failed when they are killed unexpectedly, using RDBStorage with heartbeat interval and grace period parameters.\nSOURCE: https://github.com/optuna/optuna/blob/master/docs/source/faq.rst#2025-04-15_snippet_13\n\nLANGUAGE: python\nCODE:\n```\nimport optuna\n\ndef objective(trial):\n    (Very time-consuming computation)\n\n# Recording heartbeats every 60 seconds.\n# Other processes' trials where more than 120 seconds have passed\n# since the last heartbeat was recorded will be automatically failed.\nstorage = optuna.storages.RDBStorage(url=\"sqlite:///:memory:\", heartbeat_interval=60, grace_period=120)\nstudy = optuna.create_study(storage=storage)\nstudy.optimize(objective, n_trials=100)\n```\n\n----------------------------------------\n\nTITLE: Importing Optuna Trial Module in Python\nDESCRIPTION: This code snippet shows how to import the optuna.trial module. The module contains Trial-related classes and functions essential for defining and managing objective functions in Optuna.\nSOURCE: https://github.com/optuna/optuna/blob/master/docs/source/reference/trial.rst#2025-04-15_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\n.. module:: optuna.trial\n```\n\n----------------------------------------\n\nTITLE: Autosummary of Optuna Trial Module Classes and Functions\nDESCRIPTION: This code block uses the autosummary directive to generate a summary of the main classes and functions in the optuna.trial module. It includes Trial, FixedTrial, FrozenTrial, TrialState, and create_trial.\nSOURCE: https://github.com/optuna/optuna/blob/master/docs/source/reference/trial.rst#2025-04-15_snippet_1\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. autosummary::\n   :toctree: generated/\n   :nosignatures:\n\n   Trial\n   FixedTrial\n   FrozenTrial\n   TrialState\n   create_trial\n```\n\n----------------------------------------\n\nTITLE: Setting CUDA_VISIBLE_DEVICES for Multi-GPU Optimization in Bash\nDESCRIPTION: This snippet demonstrates how to use two GPUs for evaluating two trials simultaneously by setting the CUDA_VISIBLE_DEVICES environment variable in separate terminal sessions.\nSOURCE: https://github.com/optuna/optuna/blob/master/docs/source/faq.rst#2025-04-15_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\n# On a terminal.\n#\n# Specify to use the first GPU, and run an optimization.\n$ export CUDA_VISIBLE_DEVICES=0\n$ python main.py\n\n# On another terminal.\n#\n# Specify to use the second GPU, and run another optimization.\n$ export CUDA_VISIBLE_DEVICES=1\n$ python main.py\n```\n\n----------------------------------------\n\nTITLE: Installing Optuna via pip\nDESCRIPTION: Installs the Optuna package using pip, which is the recommended installation method. Requires Python 3.8 or newer.\nSOURCE: https://github.com/optuna/optuna/blob/master/docs/source/installation.rst#2025-04-15_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n$ pip install optuna\n```\n\n----------------------------------------\n\nTITLE: Importing Optuna Integration Module in Python\nDESCRIPTION: This snippet shows how to import the optuna.integration module. The module contains classes used to integrate Optuna with external machine learning frameworks.\nSOURCE: https://github.com/optuna/optuna/blob/master/docs/source/reference/integration.rst#2025-04-15_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n.. module:: optuna.integration\n```\n\n----------------------------------------\n\nTITLE: Installing Optuna via pip and conda in Bash\nDESCRIPTION: This snippet shows how to install Optuna using pip (PyPI) and conda (Anaconda Cloud). It provides commands for both package managers.\nSOURCE: https://github.com/optuna/optuna/blob/master/README.md#2025-04-15_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n# PyPI\n$ pip install optuna\n\n# Anaconda Cloud\n$ conda install -c conda-forge optuna\n```\n\n----------------------------------------\n\nTITLE: Installing OptunaHub via pip with dependencies\nDESCRIPTION: Commands for installing the OptunaHub package and its dependencies using pip. The installation includes AutoSampler dependencies with PyTorch CPU-only version for efficiency.\nSOURCE: https://github.com/optuna/optuna/blob/master/README.md#2025-04-15_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\n$ pip install optunahub\n# Install AutoSampler dependencies (CPU only is sufficient for PyTorch)\n$ pip install cmaes scipy torch --extra-index-url https://download.pytorch.org/whl/cpu\n```\n\n----------------------------------------\n\nTITLE: Optimizing a Model with Constraints using NSGAIISampler in Python\nDESCRIPTION: This example demonstrates how to optimize a model with constraints using the NSGAIISampler. It uses the Binh and Korn function as a benchmark for multi-objective optimization with two constraints.\nSOURCE: https://github.com/optuna/optuna/blob/master/docs/source/faq.rst#2025-04-15_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nimport optuna\n\n\ndef objective(trial):\n    # Binh and Korn function with constraints.\n    x = trial.suggest_float(\"x\", -15, 30)\n    y = trial.suggest_float(\"y\", -15, 30)\n\n    # Constraints which are considered feasible if less than or equal to zero.\n    # The feasible region is basically the intersection of a circle centered at (x=5, y=0)\n    # and the complement to a circle centered at (x=8, y=-3).\n    c0 = (x - 5) ** 2 + y ** 2 - 25\n    c1 = -((x - 8) ** 2) - (y + 3) ** 2 + 7.7\n\n    # Store the constraints as user attributes so that they can be restored after optimization.\n    trial.set_user_attr(\"constraint\", (c0, c1))\n\n    v0 = 4 * x ** 2 + 4 * y ** 2\n    v1 = (x - 5) ** 2 + (y - 5) ** 2\n\n    return v0, v1\n\n\ndef constraints(trial):\n    return trial.user_attrs[\"constraint\"]\n\n\nsampler = optuna.samplers.NSGAIISampler(constraints_func=constraints)\nstudy = optuna.create_study(\n    directions=[\"minimize\", \"minimize\"],\n    sampler=sampler,\n)\nstudy.optimize(objective, n_trials=32, timeout=600)\n\nprint(\"Number of finished trials: \", len(study.trials))\n\nprint(\"Pareto front:\")\n\ntrials = sorted(study.best_trials, key=lambda t: t.values)\n\nfor trial in trials:\n    print(\"  Trial#{}\".format(trial.number))\n    print(\n        \"    Values: Values={}, Constraint={}\".format(\n            trial.values, trial.user_attrs[\"constraint\"][0]\n        )\n    )\n    print(\"    Params: {}\".format(trial.params))\n```\n\n----------------------------------------\n\nTITLE: Installing Optuna via conda\nDESCRIPTION: Installs Optuna using conda package manager from the conda-forge channel.\nSOURCE: https://github.com/optuna/optuna/blob/master/docs/source/installation.rst#2025-04-15_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n$ conda install -c conda-forge optuna\n```\n\n----------------------------------------\n\nTITLE: Obtaining Reproducible Optimization Results in Optuna using Python\nDESCRIPTION: Shows how to make Optuna optimization results reproducible by setting a fixed random seed for the sampler. This ensures consistent parameter suggestions across different runs.\nSOURCE: https://github.com/optuna/optuna/blob/master/docs/source/faq.rst#2025-04-15_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nsampler = TPESampler(seed=10)  # Make the sampler behave in a deterministic way.\nstudy = optuna.create_study(sampler=sampler)\nstudy.optimize(objective)\n```\n\n----------------------------------------\n\nTITLE: Installing Test Dependencies and Running Tests\nDESCRIPTION: Install the packages required for testing Optuna and run the test suite. This includes running all unit tests or targeting specific test files.\nSOURCE: https://github.com/optuna/optuna/blob/master/CONTRIBUTING.md#2025-04-15_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\n# Install required packages to test all modules.\npip install \".[test,optional]\"\n\n# Run all the unit tests.\npytest\n\n# Run all the unit tests defined in the specified test file.\npytest tests/${TARGET_TEST_FILE_NAME}\n```\n\n----------------------------------------\n\nTITLE: Testing Objective Functions with FixedTrial in Python\nDESCRIPTION: This code demonstrates how to use FixedTrial to test objective functions with fixed parameter values, including an example of writing unit tests for the objective function.\nSOURCE: https://github.com/optuna/optuna/blob/master/docs/source/faq.rst#2025-04-15_snippet_7\n\nLANGUAGE: python\nCODE:\n```\ndef objective(trial):\n    x = trial.suggest_float(\"x\", -1.0, 1.0)\n    y = trial.suggest_int(\"y\", -5, 5)\n    return x + y\n\n\nobjective(FixedTrial({\"x\": 1.0, \"y\": -1}))  # 0.0\nobjective(FixedTrial({\"x\": -1.0, \"y\": -4}))  # -5.0\n\n\n# A test function of pytest\ndef test_objective():\n    assert 1.0 == objective(FixedTrial({\"x\": 1.0, \"y\": 0}))\n    assert -1.0 == objective(FixedTrial({\"x\": 0.0, \"y\": -1}))\n    assert 0.0 == objective(FixedTrial({\"x\": -1.0, \"y\": 1}))\n```\n\n----------------------------------------\n\nTITLE: Optuna Module Declaration in RST\nDESCRIPTION: ReStructuredText directive declaring the optuna.importance module namespace.\nSOURCE: https://github.com/optuna/optuna/blob/master/docs/source/reference/importance.rst#2025-04-15_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n.. module:: optuna.importance\n```\n\n----------------------------------------\n\nTITLE: Saving Machine Learning Models in Optuna using ArtifactStore in Python\nDESCRIPTION: Demonstrates how to save machine learning models trained during Optuna optimization using the ArtifactStore functionality. This allows preserving trained models associated with specific trials.\nSOURCE: https://github.com/optuna/optuna/blob/master/docs/source/faq.rst#2025-04-15_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nbase_path = \"./artifacts\"\nos.makedirs(base_path, exist_ok=True)\nartifact_store = optuna.artifacts.FileSystemArtifactStore(base_path=base_path)\n\ndef objective(trial):\n    svc_c = trial.suggest_float(\"svc_c\", 1e-10, 1e10, log=True)\n    clf = sklearn.svm.SVC(C=svc_c)\n    clf.fit(X_train, y_train)\n\n    # Save the model using ArtifactStore\n    with open(\"model.pickle\", \"wb\") as fout:\n        pickle.dump(clf, fout)\n    artifact_id = optuna.artifacts.upload_artifact(\n        artifact_store=artifact_store,\n        file_path=\"model.pickle\",\n        study_or_trial=trial.study,\n    )\n    trial.set_user_attr(\"artifact_id\", artifact_id)\n    return 1.0 - accuracy_score(y_valid, clf.predict(X_valid))\n\nstudy = optuna.create_study()\nstudy.optimize(objective, n_trials=100)\n```\n\nLANGUAGE: python\nCODE:\n```\n# List all models\nfor artifact_meta in optuna.artifacts.get_all_artifact_meta(study_or_trial=study):\n    print(artifact_meta)\n# Download the best model\ntrial = study.best_trial\nbest_artifact_id = trial.user_attrs[\"artifact_id\"]\noptuna.artifacts.download_artifact(\n    artifact_store=artifact_store,\n    file_path='best_model.pickle',\n    artifact_id=best_artifact_id,\n)\n```\n\n----------------------------------------\n\nTITLE: Embedding YouTube Tutorial Video in HTML\nDESCRIPTION: This snippet embeds a YouTube video tutorial for Optuna using an iframe. The video is set to load from youtube-nocookie.com for privacy reasons and includes various allowances for playback features.\nSOURCE: https://github.com/optuna/optuna/blob/master/tutorial/README.rst#2025-04-15_snippet_0\n\nLANGUAGE: html\nCODE:\n```\n<iframe width=\"560\" height=\"315\" src=\"https://www.youtube-nocookie.com/embed/P6NwZVl8ttc\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>\n```\n\n----------------------------------------\n\nTITLE: Using JournalFileBackend for Multi-processing Parallelization\nDESCRIPTION: Shows how to configure Optuna with JournalStorage and JournalFileBackend to enable multi-processing parallelization, which is more reliable than SQLite for concurrent optimization scenarios.\nSOURCE: https://github.com/optuna/optuna/blob/master/docs/source/faq.rst#2025-04-15_snippet_12\n\nLANGUAGE: python\nCODE:\n```\nimport optuna\nfrom optuna.storages import JournalStorage\nfrom optuna.storages.journal import JournalFileBackend\n\nstorage = JournalStorage(JournalFileBackend(\"optuna_journal_storage.log\"))\n\nstudy = optuna.create_study(storage=storage)\n...\n```\n\n----------------------------------------\n\nTITLE: Using RetryFailedTrialCallback with Heartbeat Monitoring\nDESCRIPTION: Shows how to use RetryFailedTrialCallback with heartbeat monitoring to automatically retry trials that have failed due to unexpected process termination, with a maximum retry count configuration.\nSOURCE: https://github.com/optuna/optuna/blob/master/docs/source/faq.rst#2025-04-15_snippet_14\n\nLANGUAGE: python\nCODE:\n```\nimport optuna\nfrom optuna.storages import RetryFailedTrialCallback\n\nstorage = optuna.storages.RDBStorage(\n    url=\"sqlite:///:memory:\",\n    heartbeat_interval=60,\n    grace_period=120,\n    failed_trial_callback=RetryFailedTrialCallback(max_retry=3),\n)\n\nstudy = optuna.create_study(storage=storage)\n```\n\n----------------------------------------\n\nTITLE: Using Optuna with Local SQLite Storage in Python\nDESCRIPTION: Shows how to use Optuna with a local SQLite database for storage, allowing studies to be saved and resumed. This is useful for persisting optimization progress without requiring a remote database server.\nSOURCE: https://github.com/optuna/optuna/blob/master/docs/source/faq.rst#2025-04-15_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nstudy = optuna.create_study(study_name=\"foo_study\", storage=\"sqlite:///example.db\")\nstudy.optimize(objective)  # The state of `study` will be persisted to the local SQLite file.\n```\n\n----------------------------------------\n\nTITLE: Suggesting Variables with Dirichlet Distribution in Python\nDESCRIPTION: This snippet demonstrates how to suggest variables that represent proportions in accordance with the Dirichlet distribution, which can be used as weights when interpolating loss functions.\nSOURCE: https://github.com/optuna/optuna/blob/master/docs/source/faq.rst#2025-04-15_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport optuna\n\n\ndef objective(trial):\n    n = 5\n    x = []\n    for i in range(n):\n        x.append(- np.log(trial.suggest_float(f\"x_{i}\", 0, 1)))\n\n    p = []\n    for i in range(n):\n        p.append(x[i] / sum(x))\n\n    for i in range(n):\n        trial.set_user_attr(f\"p_{i}\", p[i])\n\n    return 0\n\nstudy = optuna.create_study(sampler=optuna.samplers.RandomSampler())\nstudy.optimize(objective, n_trials=1000)\n\nn = 5\np = []\nfor i in range(n):\n    p.append([trial.user_attrs[f\"p_{i}\"] for trial in study.trials])\naxes = plt.subplots(n, n, figsize=(20, 20))[1]\n\nfor i in range(n):\n    for j in range(n):\n        axes[j][i].scatter(p[i], p[j], marker=\".\")\n        axes[j][i].set_xlim(0, 1)\n        axes[j][i].set_ylim(0, 1)\n        axes[j][i].set_xlabel(f\"p_{i}\")\n        axes[j][i].set_ylabel(f\"p_{j}\")\n\nplt.savefig(\"sampled_ps.png\")\n```\n\n----------------------------------------\n\nTITLE: Handling Permutation Parameters using Lehmer Code\nDESCRIPTION: Demonstrates a technique for optimizing over permutation search spaces in Optuna by using Lehmer code to transform permutations into integer search spaces, with an example solving a Traveling Salesman Problem.\nSOURCE: https://github.com/optuna/optuna/blob/master/docs/source/faq.rst#2025-04-15_snippet_15\n\nLANGUAGE: python\nCODE:\n```\nimport numpy as np\n\nimport optuna\n\n\ndef decode(lehmer_code: list[int]) -> list[int]:\n    \"\"\"Decode Lehmer code to permutation.\n\n    This function decodes Lehmer code represented as a list of integers to a permutation.\n    \"\"\"\n    all_indices = list(range(n))\n    output = []\n    for k in lehmer_code:\n        value = all_indices[k]\n        output.append(value)\n        all_indices.remove(value)\n    return output\n\n\n# Euclidean coordinates of cities for TSP.\ncity_coordinates = np.array(\n    [[0.0, 0.0], [1.0, 0.0], [0.0, 1.0], [1.0, 1.0], [2.0, 2.0], [-1.0, -1.0]]\n)\nn = len(city_coordinates)\n\n\ndef objective(trial: optuna.Trial) -> float:\n    # Suggest a permutation in the Lehmer code representation.\n    lehmer_code = [trial.suggest_int(f\"x{i}\", 0, n - i - 1) for i in range(n)]\n    permutation = decode(lehmer_code)\n\n    # Calculate the total distance of the suggested path.\n    total_distance = 0.0\n    for i in range(n):\n        total_distance += np.linalg.norm(\n            city_coordinates[permutation[i]] - city_coordinates[np.roll(permutation, 1)[i]]\n        )\n    return total_distance\n\n\nstudy = optuna.create_study()\nstudy.optimize(objective, n_trials=10)\n```\n\n----------------------------------------\n\nTITLE: Installing Optuna Dashboard via pip\nDESCRIPTION: Command to install the Optuna Dashboard package, which provides a web-based interface for visualizing optimization results and hyperparameter importance.\nSOURCE: https://github.com/optuna/optuna/blob/master/docs/source/index.rst#2025-04-15_snippet_1\n\nLANGUAGE: console\nCODE:\n```\n$ pip install optuna-dashboard\n```\n\n----------------------------------------\n\nTITLE: Installing Optuna development version from Git\nDESCRIPTION: Installs the development version of Optuna directly from the master branch of its GitHub repository using pip.\nSOURCE: https://github.com/optuna/optuna/blob/master/docs/source/installation.rst#2025-04-15_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n$ pip install git+https://github.com/optuna/optuna.git\n```\n\n----------------------------------------\n\nTITLE: Avoiding Out-of-Memory Issues with Garbage Collection in Python\nDESCRIPTION: This snippet shows how to avoid running out of memory when optimizing studies by periodically running the garbage collector, either by setting gc_after_trial or using a callback function.\nSOURCE: https://github.com/optuna/optuna/blob/master/docs/source/faq.rst#2025-04-15_snippet_8\n\nLANGUAGE: python\nCODE:\n```\ndef objective(trial):\n    x = trial.suggest_float(\"x\", -1.0, 1.0)\n    y = trial.suggest_int(\"y\", -5, 5)\n    return x + y\n\n\nstudy = optuna.create_study()\nstudy.optimize(objective, n_trials=10, gc_after_trial=True)\n\n# `gc_after_trial=True` is more or less identical to the following.\nstudy.optimize(objective, n_trials=10, callbacks=[lambda study, trial: gc.collect()])\n```\n\n----------------------------------------\n\nTITLE: Cloning and Installing Optuna for Development\nDESCRIPTION: Clone the Optuna repository from your fork and install it in development mode. This allows you to modify the code and see changes without reinstalling.\nSOURCE: https://github.com/optuna/optuna/blob/master/CONTRIBUTING.md#2025-04-15_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit clone git@github.com:YOUR_NAME/optuna.git\ncd optuna\npip install -e .\n```\n\n----------------------------------------\n\nTITLE: Implementing Custom Logging Callback for Best Value Updates in Python\nDESCRIPTION: This code demonstrates how to implement a custom logging callback function that outputs a log only when the best value is updated during the optimization process.\nSOURCE: https://github.com/optuna/optuna/blob/master/docs/source/faq.rst#2025-04-15_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nimport optuna\n\n\n# Turn off optuna log notes.\noptuna.logging.set_verbosity(optuna.logging.WARN)\n\n\ndef objective(trial):\n    x = trial.suggest_float(\"x\", 0, 1)\n    return x ** 2\n\n\ndef logging_callback(study, frozen_trial):\n    previous_best_value = study.user_attrs.get(\"previous_best_value\", None)\n    if previous_best_value != study.best_value:\n        study.set_user_attr(\"previous_best_value\", study.best_value)\n        print(\n            \"Trial {} finished with best value: {} and parameters: {}. \".format(\n            frozen_trial.number,\n            frozen_trial.value,\n            frozen_trial.params,\n            )\n        )\n\n\nstudy = optuna.create_study()\nstudy.optimize(objective, n_trials=100, callbacks=[logging_callback])\n```\n\n----------------------------------------\n\nTITLE: Preventing Duplicate Parameter Evaluation in Optuna\nDESCRIPTION: Implements a workaround to avoid re-evaluating previously tested parameters in Optuna studies. The solution involves checking the parameter combinations against completed trials before computing the objective function.\nSOURCE: https://github.com/optuna/optuna/blob/master/docs/source/faq.rst#2025-04-15_snippet_16\n\nLANGUAGE: python\nCODE:\n```\nimport optuna\nfrom optuna.trial import TrialState\n\n\ndef objective(trial):\n    # Sample parameters.\n    x = trial.suggest_int(\"x\", -5, 5)\n    y = trial.suggest_int(\"y\", -5, 5)\n    # Fetch all the trials to consider.\n    # In this example, we use only completed trials, but users can specify other states\n    # such as TrialState.PRUNED and TrialState.FAIL.\n    states_to_consider = (TrialState.COMPLETE,)\n    trials_to_consider = trial.study.get_trials(deepcopy=False, states=states_to_consider)\n    # Check whether we already evaluated the sampled `(x, y)`.\n    for t in reversed(trials_to_consider):\n        if trial.params == t.params:\n            # Use the existing value as trial duplicated the parameters.\n            return t.value\n\n    # Compute the objective function if the parameters are not duplicated.\n    # We use the 2D sphere function in this example.\n    return x ** 2 + y ** 2\n\n\nstudy = optuna.create_study()\nstudy.optimize(objective, n_trials=100)\n```\n\n----------------------------------------\n\nTITLE: Removing Artifacts from Optuna Study\nDESCRIPTION: Provides a utility function to remove all artifacts associated with an Optuna study. This includes artifacts linked to individual trials and the study itself. Note that this is an internal feature and not officially supported.\nSOURCE: https://github.com/optuna/optuna/blob/master/docs/source/faq.rst#2025-04-15_snippet_17\n\nLANGUAGE: python\nCODE:\n```\nfrom optuna.artifacts import get_all_artifact_meta\n\n\ndef remove_artifacts(study, artifact_store):\n    # NOTE: ``artifact_store.remove`` is discouraged to use because it is an internal feature.\n    storage = study._storage\n    for trial in study.trials:\n        for artifact_meta in get_all_artifact_meta(trial, storage=storage):\n            # For each trial, remove the artifacts uploaded to ``base_path``.\n            artifact_store.remove(artifact_meta.artifact_id)\n\n    for artifact_meta in get_all_artifact_meta(study):\n        # Remove the artifacts uploaded to ``base_path``.\n        artifact_store.remove(artifact_meta.artifact_id)\n```\n\n----------------------------------------\n\nTITLE: Suppressing Optuna Log Messages in Python\nDESCRIPTION: Shows how to change the logging verbosity in Optuna to suppress log messages. This is useful for reducing output when running many optimization trials.\nSOURCE: https://github.com/optuna/optuna/blob/master/docs/source/faq.rst#2025-04-15_snippet_3\n\nLANGUAGE: python\nCODE:\n```\noptuna.logging.set_verbosity(optuna.logging.WARNING)\n\nstudy = optuna.create_study()\nstudy.optimize(objective)\n# Logs like '[I 2020-07-21 13:41:45,627] Trial 0 finished with value:...' are disabled.\n```\n\n----------------------------------------\n\nTITLE: Importing Optuna Study Module\nDESCRIPTION: Module declaration for optuna.study which contains the Study class and related functionality for managing optimization studies.\nSOURCE: https://github.com/optuna/optuna/blob/master/docs/source/reference/study.rst#2025-04-15_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n.. module:: optuna.study\n```\n\n----------------------------------------\n\nTITLE: Importing Optuna Search Space Module in Python\nDESCRIPTION: Shows how to import the optuna.search_space module, which provides functionality for controlling parameter search spaces in Optuna optimization.\nSOURCE: https://github.com/optuna/optuna/blob/master/docs/source/reference/search_space.rst#2025-04-15_snippet_0\n\nLANGUAGE: restructuredtext\nCODE:\n```\n.. module:: optuna.search_space\n```\n\n----------------------------------------\n\nTITLE: Optuna Pruners Module Declaration\nDESCRIPTION: Module declaration for Optuna's pruners package that contains various pruning strategy implementations. This module is specifically designed for single-objective optimization tasks.\nSOURCE: https://github.com/optuna/optuna/blob/master/docs/source/reference/pruners.rst#2025-04-15_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n.. module:: optuna.pruners\n```\n\n----------------------------------------\n\nTITLE: Importing Optuna Terminator Module in Python\nDESCRIPTION: This snippet shows how to import the optuna.terminator module. The module provides functionality for automatic termination of optimization processes in Optuna.\nSOURCE: https://github.com/optuna/optuna/blob/master/docs/source/reference/terminator.rst#2025-04-15_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n.. module:: optuna.terminator\n```\n\n----------------------------------------\n\nTITLE: Importing Optuna Distributions Module\nDESCRIPTION: Module import statement for optuna.distributions which provides access to the distribution classes and utilities.\nSOURCE: https://github.com/optuna/optuna/blob/master/docs/source/reference/distributions.rst#2025-04-15_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n.. module:: optuna.distributions\n```\n\n----------------------------------------\n\nTITLE: Importing Optuna Exceptions Module in Python\nDESCRIPTION: This code snippet shows how to import the optuna.exceptions module. This module contains Optuna-specific exceptions that derive from the base OptunaError class.\nSOURCE: https://github.com/optuna/optuna/blob/master/docs/source/reference/exceptions.rst#2025-04-15_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\n.. module:: optuna.exceptions\n```\n\n----------------------------------------\n\nTITLE: Optuna Integration Modules Table\nDESCRIPTION: A markdown table showing the mapping between Optuna's integration modules and their required dependencies. Each row contains a link to the source file and the corresponding package requirements.\nSOURCE: https://github.com/optuna/optuna/blob/master/docs/source/reference/integration.rst#2025-04-15_snippet_1\n\nLANGUAGE: markdown\nCODE:\n```\n+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+------------------------------------+\n| `SKorch <https://github.com/optuna/optuna/blob/master/optuna/integration/skorch.py>`__                                                                                            | skorch                             |\n+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+------------------------------------+\n| `TensorBoard <https://github.com/optuna/optuna/blob/master/optuna/integration/tensorboard.py>`__                                                                                  | tensorboard, tensorflow            |\n+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+------------------------------------+\n| `TensorFlow <https://github.com/optuna/optuna/blob/master/optuna/integration/tensorflow.py>`__                                                                                    | tensorflow, tensorflow-estimator   |\n+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+------------------------------------+\n| `TensorFlow + Keras <https://github.com/optuna/optuna/blob/master/optuna/integration/tfkeras.py>`__                                                                               | tensorflow                         |\n+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+------------------------------------+\n| `Weights & Biases <https://github.com/optuna/optuna/blob/master/optuna/integration/wandb.py>`__                                                                                   | wandb                              |\n+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+------------------------------------+\n| `XGBoost <https://github.com/optuna/optuna/blob/master/optuna/integration/xgboost.py>`__                                                                                          | xgboost                            |\n+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+------------------------------------+\n```\n\n----------------------------------------\n\nTITLE: Importing Optuna's Matplotlib Visualization Module\nDESCRIPTION: This snippet shows how to import the Optuna visualization module that uses Matplotlib as its backend. It's essential for using Matplotlib-based visualization functions in Optuna.\nSOURCE: https://github.com/optuna/optuna/blob/master/docs/visualization_matplotlib_examples/GALLERY_HEADER.rst#2025-04-15_snippet_0\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. module:: optuna.visualization.matplotlib\n```\n\n----------------------------------------\n\nTITLE: Optuna AutoSummary Directive\nDESCRIPTION: ReStructuredText directive that automatically generates a summary of the module's key functions and classes.\nSOURCE: https://github.com/optuna/optuna/blob/master/docs/source/reference/importance.rst#2025-04-15_snippet_1\n\nLANGUAGE: rst\nCODE:\n```\n.. autosummary::\n   :toctree: generated/\n   :nosignatures:\n\n   get_param_importances\n   FanovaImportanceEvaluator\n   MeanDecreaseImpurityImportanceEvaluator\n   PedAnovaImportanceEvaluator\n```\n\n----------------------------------------\n\nTITLE: Installing Documentation Dependencies\nDESCRIPTION: Install the dependencies required to build Optuna's documentation. This includes Sphinx and other packages needed for generating the HTML documentation.\nSOURCE: https://github.com/optuna/optuna/blob/master/CONTRIBUTING.md#2025-04-15_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\npip install -e \".[document]\"\n```\n\n----------------------------------------\n\nTITLE: Building Optuna Documentation Locally\nDESCRIPTION: Build the Optuna documentation in HTML format locally to preview changes. This command generates HTML files in the build/html directory.\nSOURCE: https://github.com/optuna/optuna/blob/master/CONTRIBUTING.md#2025-04-15_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\ncd docs\nmake html\n```\n\n----------------------------------------\n\nTITLE: Running Format and Style Checks with formats.sh\nDESCRIPTION: Install the required checking tools and run the formats.sh script to automatically check and fix code formatting, style issues, and type hints.\nSOURCE: https://github.com/optuna/optuna/blob/master/CONTRIBUTING.md#2025-04-15_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n# Install auto-formatters.\n$ pip install \".[checking]\"\n\n$ ./formats.sh\n```\n\n----------------------------------------\n\nTITLE: Setting Up pre-commit for Automatic Code Checks\nDESCRIPTION: Install and configure pre-commit to automatically check format, coding style, and type hints before each commit, helping maintain code quality.\nSOURCE: https://github.com/optuna/optuna/blob/master/CONTRIBUTING.md#2025-04-15_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n# Install `pre-commit`.\n$ pip install pre-commit\n\n$ pre-commit install\n$ pre-commit run --all-files\n```\n\n----------------------------------------\n\nTITLE: Running Targeted Unit Tests in Optuna\nDESCRIPTION: This command runs a specific unit test function from a specified test file using pytest. It demonstrates how to execute targeted tests in the Optuna project.\nSOURCE: https://github.com/optuna/optuna/blob/master/CONTRIBUTING.md#2025-04-15_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\npytest tests/${TARGET_TEST_FILE_NAME} -k ${TARGET_TEST_FUNCTION_NAME}\n```\n\n----------------------------------------\n\nTITLE: Module Definition in RST\nDESCRIPTION: Defines the module path and lists available crossover operations classes for the NSGA-II sampler in Optuna.\nSOURCE: https://github.com/optuna/optuna/blob/master/docs/source/reference/samplers/nsgaii.rst#2025-04-15_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n.. module:: optuna.samplers.nsgaii\n\noptuna.samplers.nsgaii\n======================\n\nThe :mod:`~optuna.samplers.nsgaii` module defines crossover operations used by :class:`~optuna.samplers.NSGAIISampler`.\n\n.. autosummary::\n    :toctree: generated/\n    :nosignatures:\n\n    BaseCrossover\n    UniformCrossover\n    BLXAlphaCrossover\n    SPXCrossover\n    SBXCrossover\n    VSBXCrossover\n    UNDXCrossover\n```\n\n----------------------------------------\n\nTITLE: Storage Support Matrix Definition in RST\nDESCRIPTION: A restructured text table defining the supported storage systems for different artifact store implementations in Optuna.\nSOURCE: https://github.com/optuna/optuna/blob/master/docs/source/reference/artifacts.rst#2025-04-15_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n+-------------------------+----------------------------------------+\n| Class Name              |           Supported Storage            |\n+=========================+========================================+\n| FileSystemArtifactStore | Local File System, Network File System |\n+-------------------------+----------------------------------------+\n| Boto3ArtifactStore      | Amazon S3 Compatible Object Storage    |\n+-------------------------+----------------------------------------+\n| GCSArtifactStore        | Google Cloud Storage                   |\n+-------------------------+----------------------------------------+\n```\n\n----------------------------------------\n\nTITLE: Embedding YouTube Video in restructuredText\nDESCRIPTION: HTML code embedded in restructuredText to display an introductory Optuna tutorial video from YouTube. The iframe includes privacy-enhanced mode (youtube-nocookie) and standard video player settings.\nSOURCE: https://github.com/optuna/optuna/blob/master/docs/source/tutorial/index.rst#2025-04-15_snippet_0\n\nLANGUAGE: html\nCODE:\n```\n<iframe width=\"560\" height=\"315\" src=\"https://www.youtube-nocookie.com/embed/P6NwZVl8ttc\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>\n    <br />\n    <br />\n    <br />\n```\n\n----------------------------------------\n\nTITLE: Adding Note About Matplotlib Backend in ReStructuredText\nDESCRIPTION: This note informs users that the optuna.visualization.matplotlib module uses Matplotlib as its backend for visualization.\nSOURCE: https://github.com/optuna/optuna/blob/master/docs/source/reference/visualization/index.rst#2025-04-15_snippet_1\n\nLANGUAGE: rst\nCODE:\n```\n.. note::\n    The following :mod:`optuna.visualization.matplotlib` module uses Matplotlib as a backend.\n```\n\n----------------------------------------\n\nTITLE: Creating Table of Contents in ReStructuredText\nDESCRIPTION: This directive creates a table of contents for the Matplotlib index, with a maximum depth of 1.\nSOURCE: https://github.com/optuna/optuna/blob/master/docs/source/reference/visualization/index.rst#2025-04-15_snippet_2\n\nLANGUAGE: rst\nCODE:\n```\n.. toctree::\n    :maxdepth: 1\n\n    matplotlib/index\n```\n\n----------------------------------------\n\nTITLE: Adding Reference to Visualization Tutorial in ReStructuredText\nDESCRIPTION: This directive adds a reference to the visualization tutorial, which provides use-cases with examples.\nSOURCE: https://github.com/optuna/optuna/blob/master/docs/source/reference/visualization/index.rst#2025-04-15_snippet_3\n\nLANGUAGE: rst\nCODE:\n```\n.. seealso::\n    The :ref:`visualization` tutorial provides use-cases with examples.\n```\n\n----------------------------------------\n\nTITLE: BibTeX citation for Optuna research paper\nDESCRIPTION: BibTeX entry for citing the Optuna research paper titled \"Optuna: A Next-generation Hyperparameter Optimization Framework\" published at KDD 2019.\nSOURCE: https://github.com/optuna/optuna/blob/master/README.md#2025-04-15_snippet_5\n\nLANGUAGE: bibtex\nCODE:\n```\n@inproceedings{akiba2019optuna,\n  title={{O}ptuna: A Next-Generation Hyperparameter Optimization Framework},\n  author={Akiba, Takuya and Sano, Shotaro and Yanase, Toshihiko and Ohta, Takeru and Koyama, Masanori},\n  booktitle={The 25th ACM SIGKDD International Conference on Knowledge Discovery \\& Data Mining},\n  pages={2623--2631},\n  year={2019}\n}\n```\n\n----------------------------------------\n\nTITLE: RST Documentation Header for Optuna Visualization\nDESCRIPTION: ReStructuredText documentation header and reference labels for the optuna.visualization module documentation.\nSOURCE: https://github.com/optuna/optuna/blob/master/docs/visualization_examples/GALLERY_HEADER.rst#2025-04-15_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n.. _visualization-examples-index:\n\n.. _general_visualization_examples:\n\noptuna.visualization\n====================\n\n```\n\n----------------------------------------\n\nTITLE: RST Documentation Module Description\nDESCRIPTION: Module description in ReStructuredText format explaining the purpose of optuna.visualization and its dependencies.\nSOURCE: https://github.com/optuna/optuna/blob/master/docs/visualization_examples/GALLERY_HEADER.rst#2025-04-15_snippet_1\n\nLANGUAGE: rst\nCODE:\n```\n.. note::\n    In the :mod:`optuna.visualization` module, the following functions use plotly to create figures, but `JupyterLab`_ cannot\n    render them by default. Please follow this `installation guide`_ to show figures in\n    `JupyterLab`_.\n.. note::\n    The :func:`~optuna.visualization.plot_param_importances` requires the Python package of `scikit-learn <https://github.com/scikit-learn/scikit-learn>`__.\n\n    .. _JupyterLab: https://github.com/jupyterlab/jupyterlab\n    .. _installation guide: https://github.com/plotly/plotly.py#jupyterlab-support\n```\n\n----------------------------------------\n\nTITLE: Defining Optuna API Reference Documentation Structure in reStructuredText\nDESCRIPTION: A reStructuredText (rst) toctree directive that lists all the major components of the Optuna API with a maxdepth of 1. This creates a table of contents for the API reference documentation with links to individual module documentation pages.\nSOURCE: https://github.com/optuna/optuna/blob/master/docs/source/reference/index.rst#2025-04-15_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n.. toctree::\n    :maxdepth: 1\n\n    optuna\n    artifacts\n    cli\n    distributions\n    exceptions\n    importance\n    integration\n    logging\n    pruners\n    samplers/index\n    search_space\n    storages\n    study\n    terminator\n    trial\n    visualization/index\n```\n\n----------------------------------------\n\nTITLE: Including Generated Index in ReStructuredText\nDESCRIPTION: This directive includes the content of a generated index file into the current document.\nSOURCE: https://github.com/optuna/optuna/blob/master/docs/source/reference/visualization/index.rst#2025-04-15_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n.. include:: ./generated/index.rst\n```\n\n----------------------------------------\n\nTITLE: RST Reference Link for Optuna Key Features\nDESCRIPTION: ReStructuredText snippet that creates a section and external link to Optuna's key features documentation on GitHub.\nSOURCE: https://github.com/optuna/optuna/blob/master/tutorial/10_key_features/README.rst#2025-04-15_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n.. _key_features:\n\nKey Features\n------------\n\nShowcases Optuna's `Key Features <https://github.com/optuna/optuna/blob/master/README.md#key-features>`__.\n```\n\n----------------------------------------\n\nTITLE: Customizing Methods Section in Sphinx Documentation Template\nDESCRIPTION: This Jinja2 template block overrides the methods section of the default autosummary class template. It filters out the __init__ constructor method from the list of methods to be documented and then renders the remaining methods in the standard autosummary format.\nSOURCE: https://github.com/optuna/optuna/blob/master/docs/source/_templates/autosummary/class.rst#2025-04-15_snippet_0\n\nLANGUAGE: jinja2\nCODE:\n```\n{% block methods %}\n   {% set methods = methods | select(\"ne\", \"__init__\") | list %}\n   {% if methods %}\n   .. rubric:: Methods\n\n   .. autosummary::\n   {% for item in methods %}\n      ~{{ name }}.{{ item }}\n   {%- endfor %}\n   {% endif %}\n\n{% endblock %}\n```\n\n----------------------------------------\n\nTITLE: Displaying Optuna CLI Help Command\nDESCRIPTION: Shows how to access the help documentation for Optuna's command-line interface using the --help flag.\nSOURCE: https://github.com/optuna/optuna/blob/master/docs/source/reference/cli.rst#2025-04-15_snippet_0\n\nLANGUAGE: console\nCODE:\n```\n$ optuna --help\n```"
  }
]