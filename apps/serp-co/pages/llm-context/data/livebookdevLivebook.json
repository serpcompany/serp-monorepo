[
  {
    "owner": "livebook-dev",
    "repo": "livebook",
    "content": "TITLE: Running Livebook with Docker\nDESCRIPTION: Docker commands for running Livebook with various configurations including port mapping, volume mounting, and environment variables.\nSOURCE: https://github.com/livebook-dev/livebook/blob/main/README.md#2025-04-21_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n# Running with the default configuration\ndocker run -p 8080:8080 -p 8081:8081 --pull always ghcr.io/livebook-dev/livebook\n\n# In order to access and save notebooks directly to your machine\n# you can mount a local directory into the container.\n# Make sure to specify the user with \"-u $(id -u):$(id -g)\"\n# so that the created files have proper permissions\ndocker run -p 8080:8080 -p 8081:8081 --pull always -u $(id -u):$(id -g) -v $(pwd):/data ghcr.io/livebook-dev/livebook\n\n# You can configure Livebook using environment variables,\n# for all options see the dedicated \"Environment variables\" section below\ndocker run -p 8080:8080 -p 8081:8081 --pull always -e LIVEBOOK_PASSWORD=\"securesecret\" ghcr.io/livebook-dev/livebook\n\n# Or if you need to run on different ports:\ndocker run -p 8090:8090 -p 8091:8091 --pull always -e LIVEBOOK_PORT=8090 -e LIVEBOOK_IFRAME_PORT=8091 ghcr.io/livebook-dev/livebook\n```\n\n----------------------------------------\n\nTITLE: Basic Livebook Docker Configuration\nDESCRIPTION: Basic Dockerfile setup for deploying Livebook with customizable port and data persistence configuration.\nSOURCE: https://github.com/livebook-dev/livebook/blob/main/docs/deployment/docker.md#2025-04-21_snippet_0\n\nLANGUAGE: dockerfile\nCODE:\n```\nFROM ghcr.io/livebook-dev/livebook\n\n# Configure your port accordingly\nENV LIVEBOOK_PORT=7860\nEXPOSE 7860\n\n# If you have a persistent volume, configure it here\nENV LIVEBOOK_DATA_PATH=\"/data\"\nUSER root\nRUN mkdir -p /data\nRUN chmod 777 /data\n```\n\n----------------------------------------\n\nTITLE: Setting LIVEBOOK_IDENTITY_PROVIDER Environment Variable for Basic Authentication in Livebook\nDESCRIPTION: This environment variable configuration enables Basic Authentication for a Livebook instance by setting a username and password. The format requires the prefix 'basic_auth:' followed by the username and password separated by colons.\nSOURCE: https://github.com/livebook-dev/livebook/blob/main/docs/authentication/basic_auth.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nLIVEBOOK_IDENTITY_PROVIDER=basic_auth:<username>:<password>\n```\n\n----------------------------------------\n\nTITLE: Setting up Tailscale Authentication for Livebook on Linux/standard systems\nDESCRIPTION: This script configures Livebook to use Tailscale authentication by setting the required environment variables and starting the Livebook server. It sets the LIVEBOOK_IP to the Tailscale IP address and configures LIVEBOOK_IDENTITY_PROVIDER to use the Tailscale socket.\nSOURCE: https://github.com/livebook-dev/livebook/blob/main/docs/authentication/tailscale.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nLIVEBOOK_IP=$(tailscale ip -1 | tr -d '\\n') \\\nLIVEBOOK_IDENTITY_PROVIDER=tailscale:/var/run/tailscale/tailscaled.sock \\\nlivebook server\n```\n\n----------------------------------------\n\nTITLE: Setting up Tailscale Authentication for Livebook on macOS\nDESCRIPTION: This script automatically detects the Tailscale port and password on macOS, then starts Livebook with the correct Tailscale configuration. It handles both Mac App Store and standalone Tailscale installations, setting the necessary environment variables before launching the Livebook server.\nSOURCE: https://github.com/livebook-dev/livebook/blob/main/docs/authentication/tailscale.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n#!/bin/bash\n# This script is adapted from https://github.com/tailscale/tailscale/blob/v1.80.2/safesocket/safesocket_darwin.go#L69-L160\n\n# When Tailscale was installed via Mac App Store\nport_and_token=$(lsof -n -a -c IPNExtension -F | grep -o \"sameuserproof-[0-9]*-[a-f0-9]*\" | head -1)\nif [ ! -z \"$port_and_token\" ]; then\n    port=$(echo \"$port_and_token\" | cut -d'-' -f2)\n    token=$(echo \"$port_and_token\" | cut -d'-' -f3)\nelse\n    # When Tailscale was installed using the standalone variant\n    port=$(readlink /Library/Tailscale/ipnport)\n    if [ ! -z \"$port\" ]; then\n        token=$(cat \"/Library/Tailscale/sameuserproof-$port\")\n    fi\nfi\n\ntailscale_ip=$(exec $(ps -xo comm | grep MacOS/Tailscale$) ip | head -1 | tr -d '\\n')\n\nif [ ! -z \"$port\" ] && [ ! -z \"$token\" ] && [ ! -z \"$tailscale_ip\" ]; then\n    LIVEBOOK_IP=$tailscale_ip \\\n    LIVEBOOK_IDENTITY_PROVIDER=tailscale:http://:$token@127.0.0.1:$port \\\n    livebook server\nelse\n    echo \"Error: Missing required configuration\"\n    [ -z \"$port\" ] && echo \"- Could not determine port\"\n    [ -z \"$token\" ] && echo \"- Could not determine token\"\n    [ -z \"$tailscale_ip\" ] && echo \"- Could not determine Tailscale IP\"\nfi\n```\n\n----------------------------------------\n\nTITLE: Configuring Nginx HTTPS Proxy for Livebook\nDESCRIPTION: Complete Nginx configuration for setting up HTTPS proxy to Livebook. Includes SSL certificate configuration, proxy settings for WebSocket support, and automatic HTTP to HTTPS redirection. The configuration handles both secure traffic on port 443 and redirects all HTTP traffic from port 80 to HTTPS.\nSOURCE: https://github.com/livebook-dev/livebook/blob/main/docs/deployment/nginx_https.md#2025-04-21_snippet_0\n\nLANGUAGE: nginx\nCODE:\n```\nhttp {\n    server {\n        listen 443 ssl;\n        server_name your_domain;  # e.g., livebook.example.com\n\n        ssl_certificate /path/to/your/ssl_certificate.crt;  # e.g., /etc/nginx/ssl/livebook.crt\n        ssl_certificate_key /path/to/your/ssl_certificate.key;  # e.g., /etc/nginx/ssl/livebook.key\n\n        location / {\n            proxy_pass http://livebook_ip:livebook_port;  # e.g., http://172.20.0.3:8080 (Livebook's default port is 8080)\n            proxy_http_version 1.1;\n            proxy_set_header Upgrade $http_upgrade;\n            proxy_set_header Connection \"upgrade\";\n            proxy_set_header Host $host;\n            proxy_set_header X-Real-IP $remote_addr;\n            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n            proxy_set_header X-Forwarded-Proto $scheme;\n        }\n    }\n\n    server {\n        listen 80;\n        server_name your_domain;  # e.g., livebook.example.com\n        return 301 https://$host$request_uri;\n    }\n}\n\nevents {}\n```\n\n----------------------------------------\n\nTITLE: Setting LIVEBOOK_NODE Environment Variable for Clustering\nDESCRIPTION: Sets the LIVEBOOK_NODE environment variable with the machine IP for each deployed node in a Livebook cluster. This is required when using DNS-based clustering.\nSOURCE: https://github.com/livebook-dev/livebook/blob/main/docs/deployment/clustering.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nLIVEBOOK_NODE=livebook_server@MACHINE_IP\n```\n\n----------------------------------------\n\nTITLE: Generating Random Values for Livebook Security Variables\nDESCRIPTION: Uses OpenSSL to generate random base64-encoded values for LIVEBOOK_SECRET_KEY_BASE and LIVEBOOK_COOKIE environment variables, which are required for secure clustering.\nSOURCE: https://github.com/livebook-dev/livebook/blob/main/docs/deployment/clustering.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nopenssl rand -base64 48\n```\n\n----------------------------------------\n\nTITLE: Starting a Phoenix Application for Remote Livebook Connection in Shell\nDESCRIPTION: This shell command demonstrates how to start a Phoenix application with specific node name and cookie settings. These settings are used to enable remote connection from a Livebook notebook for system automation and monitoring.\nSOURCE: https://github.com/livebook-dev/livebook/blob/main/docs/use_cases.md#2025-04-21_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\n$ iex --name phoenix-app@127.0.0.1 --cookie secret -S mix phx.server\n```\n\n----------------------------------------\n\nTITLE: Installing Livebook from Source\nDESCRIPTION: Commands for cloning, setting up dependencies, and running Livebook directly from source code.\nSOURCE: https://github.com/livebook-dev/livebook/blob/main/README.md#2025-04-21_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\ngit clone https://github.com/livebook-dev/livebook.git\ncd livebook\nmix deps.get --only prod\n\n# Run the Livebook server\nMIX_ENV=prod mix phx.server\n```\n\n----------------------------------------\n\nTITLE: Setting up Livebook for Development (Shell)\nDESCRIPTION: These commands clone the Livebook repository, set up the project, run the server, and execute tests. They are essential for developers working on Livebook.\nSOURCE: https://github.com/livebook-dev/livebook/blob/main/README.md#2025-04-21_snippet_4\n\nLANGUAGE: shell\nCODE:\n```\ngit clone https://github.com/livebook-dev/livebook.git\ncd livebook\nmix setup\n\n# Run the Livebook server\nmix phx.server\n\n# Run tests\nmix test\n```\n\n----------------------------------------\n\nTITLE: Docker Compose Configuration for Livebook\nDESCRIPTION: Docker Compose template for running Livebook with configured ports for main service and iframe support.\nSOURCE: https://github.com/livebook-dev/livebook/blob/main/docs/deployment/docker.md#2025-04-21_snippet_1\n\nLANGUAGE: yaml\nCODE:\n```\nservices:\n  livebook:\n    image: ghcr.io/livebook-dev/livebook\n    ports:\n      - 8090:8090\n      - 8091:8091\n    environment:\n      - LIVEBOOK_PORT=8090\n      - LIVEBOOK_IFRAME_PORT=8091\n```\n\n----------------------------------------\n\nTITLE: Implementing Custom Zero Trust Authentication Module in Elixir\nDESCRIPTION: This code snippet defines the skeleton for a custom authentication module in Elixir. It includes the required callbacks and specifications for implementing Zero Trust Authentication in Livebook.\nSOURCE: https://github.com/livebook-dev/livebook/blob/main/docs/authentication/custom_auth.md#2025-04-21_snippet_0\n\nLANGUAGE: elixir\nCODE:\n```\ndefmodule MyAuth do\n  use GenServer\n\n  @spec start_link(keyword) :: {:ok, pid()}\n  def start_link(opts) do\n    identity_key = opts[:identity_key]\n    GenServer.start_link(__MODULE__, identity_key, Keyword.take(opts, [:name]))\n  end\n\n  @spec authenticate(GenServer.server(), Plug.Conn.t(), keyword()) ::\n          {Plug.Conn.t(), map() | nil}\n  def authenticate(server, conn, opts \\\\ []) do\n    # Connects to the GenServer given by `server` and returns the user information.\n    # See `opts[:fields]` for the fields to be returned in the map.\n    # Return nil if the user cannot be authenticated.\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Enabling IPv6 Support for Livebook Clustering\nDESCRIPTION: Sets the ERL_AFLAGS environment variable to enable IPv6 support for Erlang distribution protocol. This is necessary if the cloud infrastructure requires IPv6.\nSOURCE: https://github.com/livebook-dev/livebook/blob/main/docs/deployment/clustering.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nERL_AFLAGS=\"-proto_dist inet6_tcp\"\n```\n\n----------------------------------------\n\nTITLE: Configuring Mix.install for Livebook Documentation in Elixir Projects\nDESCRIPTION: This snippet demonstrates how to set up Mix.install in a Livebook notebook to run within the context of an existing Elixir project. It configures the notebook to use the same dependencies and configuration as the root Mix project.\nSOURCE: https://github.com/livebook-dev/livebook/blob/main/docs/use_cases.md#2025-04-21_snippet_0\n\nLANGUAGE: elixir\nCODE:\n```\nMix.install(\n  [\n    {:my_app, path: Path.join(__DIR__, \"..\"), env: :dev}\n  ],\n  config_path: :my_app,\n  lockfile: :my_app\n)\n```\n\n----------------------------------------\n\nTITLE: Building FIPS-Enabled Erlang/Elixir Docker Image\nDESCRIPTION: This Dockerfile creates a base image with FIPS-enabled Erlang/OTP and Elixir. It uses a Red Hat UBI minimal image, installs necessary dependencies, builds Erlang with FIPS enabled, and installs Elixir. This can be used as a base for building Livebook with FIPS support.\nSOURCE: https://github.com/livebook-dev/livebook/blob/main/docs/deployment/fips.md#2025-04-21_snippet_0\n\nLANGUAGE: dockerfile\nCODE:\n```\nFROM registry.access.redhat.com/ubi8/ubi-minimal:8.9-1137\n# Set environment variables for path and language\nENV PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin\n\n# Install system dependencies and clean cache in one layer\nRUN microdnf install -y unzip autoconf git ncurses-devel openssl-devel gcc gcc-c++ make automake perl clang wget tar cmake glibc-locale-source glibc-langpack-en && \\\n    microdnf clean all && \\\n    rm -rf /var/cache/yum\n\nWORKDIR /install\n\n# Download, configure, and install Erlang/OTP with FIPS enabled\nARG ERLANG_VERSION\nRUN wget https://github.com/erlang/otp/archive/OTP-${ERLANG_VERSION}.tar.gz && \\\n    tar -xzvf OTP-${ERLANG_VERSION}.tar.gz && \\\n    cd otp-OTP-${ERLANG_VERSION} && \\\n    ./otp_build autoconf && \\\n    ./configure --enable-fips && \\\n    make && make install\n\n# Clone, checkout, and install Elixir\nARG ELIXIR_VERSION\nRUN git clone https://github.com/elixir-lang/elixir.git && \\\n    cd elixir && \\\n    git checkout v${ELIXIR_VERSION} && \\\n    make compile && \\\n    make install\n```\n\n----------------------------------------\n\nTITLE: Installing and Running Livebook via Escript\nDESCRIPTION: Commands for installing Livebook as an escript and running the server locally.\nSOURCE: https://github.com/livebook-dev/livebook/blob/main/README.md#2025-04-21_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\nmix do local.rebar --force, local.hex --force\nmix escript.install hex livebook\n\n# Start the Livebook server\nlivebook server\n\n# See all the configuration options\nlivebook server --help\n```\n\n----------------------------------------\n\nTITLE: Configuring Livebook Identity Provider in Bash\nDESCRIPTION: These Bash commands demonstrate how to configure Livebook to use a custom identity provider. The first command sets the provider without a custom key, while the second includes a custom identity key.\nSOURCE: https://github.com/livebook-dev/livebook/blob/main/docs/authentication/custom_auth.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nLIVEBOOK_IDENTITY_PROVIDER=\"custom:MyAuth\"\n```\n\nLANGUAGE: bash\nCODE:\n```\nLIVEBOOK_IDENTITY_PROVIDER=\"custom:MyAuth:my-key\"\n```\n\n----------------------------------------\n\nTITLE: Building Livebook Desktop App for Windows (Shell)\nDESCRIPTION: These commands are used to test and build the Windows desktop app for Livebook. They include running the app locally and building the Windows installer.\nSOURCE: https://github.com/livebook-dev/livebook/blob/main/README.md#2025-04-21_snippet_6\n\nLANGUAGE: shell\nCODE:\n```\n# Test Windows app locally\n(cd rel/app/windows && ./run.sh)\n\n# Build Windows installer\n.github/scripts/app/build_windows.sh\n```\n\n----------------------------------------\n\nTITLE: Building Livebook Desktop App for macOS (Shell)\nDESCRIPTION: These commands are used to test and build the macOS desktop app for Livebook. They include running the app locally and building the macOS installer.\nSOURCE: https://github.com/livebook-dev/livebook/blob/main/README.md#2025-04-21_snippet_5\n\nLANGUAGE: shell\nCODE:\n```\n# Test macOS app locally\n(cd rel/app/macos && ./run.sh)\n\n# Build macOS installer\n.github/scripts/app/build_macos.sh\n```\n\n----------------------------------------\n\nTITLE: Running Livebook with Custom Identity Provider in Development\nDESCRIPTION: This Elixir command shows how to run Livebook in development mode with a custom identity provider. It includes setting up the project and starting the Phoenix server with the custom authentication module.\nSOURCE: https://github.com/livebook-dev/livebook/blob/main/docs/authentication/custom_auth.md#2025-04-21_snippet_2\n\nLANGUAGE: elixir\nCODE:\n```\n$ mix setup\n$ LIVEBOOK_IDENTITY_PROVIDER=\"custom:MyAuth\" elixir -r path/to/my_auth.exs -S mix phx.server\n```\n\n----------------------------------------\n\nTITLE: Defining ElixirKit Module in Elixir\nDESCRIPTION: Defines the ElixirKit module with functions for code evaluation, dependency management, and error handling in Livebook. It includes methods for running code, adding dependencies, and formatting runtime errors.\nSOURCE: https://github.com/livebook-dev/livebook/blob/main/elixirkit/elixirkit_swift/README.md#2025-04-21_snippet_0\n\nLANGUAGE: elixir\nCODE:\n```\ndefmodule ElixirKit do\n  @moduledoc false\n\n  @doc \"\"\"\n  Runs the given code and returns the result.\n  \"\"\"\n  @spec run(String.t()) :: term()\n  def run(code) do\n    {result, _binding} = Code.eval_string(code)\n    result\n  end\n\n  @doc \"\"\"\n  Adds the given dependency to the runtime.\n  \"\"\"\n  @spec add_dep(atom(), String.t()) :: :ok | {:error, String.t()}\n  def add_dep(name, version) do\n    {:ok, _} = Application.ensure_all_started(:hex)\n    deps = [{name, version}]\n    {:ok, _} = Mix.install(deps)\n    :ok\n  end\n\n  @doc \"\"\"\n  Formats runtime error, removing unnecessary noise.\n  \"\"\"\n  @spec format_error(any()) :: String.t()\n  def format_error(error) do\n    Exception.format(:error, error, [])\n    |> String.split(\"\\n\")\n    |> Enum.reject(&String.starts_with?(&1, \"    \"))\n    |> Enum.join(\"\\n\")\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Accessing Authenticated User Data in Livebook Teams\nDESCRIPTION: This function call retrieves information about the authenticated user in a multi-session app deployed via Livebook Teams. It provides programmatic access to user data when using Livebook Teams authentication.\nSOURCE: https://github.com/livebook-dev/livebook/blob/main/docs/authentication/basic_auth.md#2025-04-21_snippet_1\n\nLANGUAGE: elixir\nCODE:\n```\nKino.Workspace.app_info/0\n```\n\n----------------------------------------\n\nTITLE: Generating Protobuf Message Modules for Livebook\nDESCRIPTION: Command to generate Protobuf message modules for Livebook's cross-backend communication. This Mix task processes the Protobuf definitions and generates the corresponding Elixir modules.\nSOURCE: https://github.com/livebook-dev/livebook/blob/main/proto/README.md#2025-04-21_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\nmix protobuf.generate\n```\n\n----------------------------------------\n\nTITLE: Installing Erlang Dependencies on Ubuntu\nDESCRIPTION: Command for installing required Erlang applications on Ubuntu systems for running Livebook.\nSOURCE: https://github.com/livebook-dev/livebook/blob/main/README.md#2025-04-21_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\nsudo apt install erlang-inets erlang-os-mon erlang-runtime-tools erlang-ssl erlang-xmerl erlang-dev erlang-parsetools\n```\n\n----------------------------------------\n\nTITLE: Running Livebook Unit Tests\nDESCRIPTION: Command to execute the standard unit test suite for Livebook using Mix\nSOURCE: https://github.com/livebook-dev/livebook/blob/main/test/README.md#2025-04-21_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n$ mix test\n```\n\n----------------------------------------\n\nTITLE: Setting Up Livebook Teams Environment\nDESCRIPTION: Command to set up the Livebook Teams repository with the correct environment configuration. This should be run in the Teams repository when encountering setup issues.\nSOURCE: https://github.com/livebook-dev/livebook/blob/main/test/README.md#2025-04-21_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\n$ MIX_ENV=livebook mix setup\n```\n\n----------------------------------------\n\nTITLE: Starting Elixir Runtime in C#\nDESCRIPTION: This C# method starts the Elixir runtime with specified parameters including name, ready handler, exit handler, and log path.\nSOURCE: https://github.com/livebook-dev/livebook/blob/main/elixirkit/README.md#2025-04-21_snippet_8\n\nLANGUAGE: C#\nCODE:\n```\nElixirKit.API.Start(string name, ReadyHandler ready, ExitHandler? exited = null, string? logPath = null) -> void\n```\n\n----------------------------------------\n\nTITLE: Starting Elixir Runtime in Swift\nDESCRIPTION: This Swift method starts the Elixir runtime with specified parameters including name, log path, and handlers for ready and termination events.\nSOURCE: https://github.com/livebook-dev/livebook/blob/main/elixirkit/README.md#2025-04-21_snippet_1\n\nLANGUAGE: Swift\nCODE:\n```\nElixirKit.API.start(name: String, logPath: String?, readyHandler: () -> Void, terminationHandler: ((Process) -> Void)?) -> Void\n```\n\n----------------------------------------\n\nTITLE: Subscribing to Elixir Runtime Events in C#\nDESCRIPTION: This C# method subscribes to events from the Elixir runtime using a provided event handler.\nSOURCE: https://github.com/livebook-dev/livebook/blob/main/elixirkit/README.md#2025-04-21_snippet_10\n\nLANGUAGE: C#\nCODE:\n```\nElixirKit.API.Subscribe(EventHandler handler) -> void\n```\n\n----------------------------------------\n\nTITLE: Publishing Events to Elixir Runtime in Swift\nDESCRIPTION: This Swift method publishes an event to the Elixir runtime with a specified name and data.\nSOURCE: https://github.com/livebook-dev/livebook/blob/main/elixirkit/README.md#2025-04-21_snippet_2\n\nLANGUAGE: Swift\nCODE:\n```\nElixirKit.API.publish(_ name: String, _ data: String) -> Void\n```\n\n----------------------------------------\n\nTITLE: Structuring ElixirKit Demo Project in Markdown\nDESCRIPTION: This markdown snippet outlines the structure of an ElixirKit demo application. It provides links to the Elixir server implementation and various client implementations in different languages and frameworks.\nSOURCE: https://github.com/livebook-dev/livebook/blob/main/elixirkit/demo/README.md#2025-04-21_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n# Demo\n\nThis is an example ElixirKit application.\n\nSee:\n\n  * [Elixir Server](lib/demo.ex)\n  * [Swift Client](rel/swift)\n  * [AppKit Client](rel/appkit)\n  * [C# Client](rel/dotnet)\n  * [Windows Forms Client](rel/winforms)\n```\n\n----------------------------------------\n\nTITLE: Publishing Events to Elixir Runtime in C#\nDESCRIPTION: This C# method publishes an event to the Elixir runtime with a specified name and data.\nSOURCE: https://github.com/livebook-dev/livebook/blob/main/elixirkit/README.md#2025-04-21_snippet_9\n\nLANGUAGE: C#\nCODE:\n```\nElixirKit.API.Publish(string name, string data) -> void\n```\n\n----------------------------------------\n\nTITLE: Stopping Elixir Runtime in Swift\nDESCRIPTION: This Swift method stops the Elixir runtime.\nSOURCE: https://github.com/livebook-dev/livebook/blob/main/elixirkit/README.md#2025-04-21_snippet_3\n\nLANGUAGE: Swift\nCODE:\n```\nElixirKit.API.stop() -> Void\n```\n\n----------------------------------------\n\nTITLE: Waiting for Elixir Runtime Exit in C#\nDESCRIPTION: This C# method blocks execution until the Elixir runtime exits and returns the exit code.\nSOURCE: https://github.com/livebook-dev/livebook/blob/main/elixirkit/README.md#2025-04-21_snippet_12\n\nLANGUAGE: C#\nCODE:\n```\nElixirKit.API.WaitForExit() -> int\n```\n\n----------------------------------------\n\nTITLE: Waiting for Elixir Runtime Exit in Swift\nDESCRIPTION: This Swift method blocks execution until the Elixir runtime exits.\nSOURCE: https://github.com/livebook-dev/livebook/blob/main/elixirkit/README.md#2025-04-21_snippet_4\n\nLANGUAGE: Swift\nCODE:\n```\nElixirKit.API.waitUntilExit() -> Void\n```\n\n----------------------------------------\n\nTITLE: Checking Elixir Runtime Exit Status in C#\nDESCRIPTION: This C# property indicates whether the Elixir runtime has exited.\nSOURCE: https://github.com/livebook-dev/livebook/blob/main/elixirkit/README.md#2025-04-21_snippet_6\n\nLANGUAGE: C#\nCODE:\n```\nElixirKit.API.HasExited: bool\n```\n\n----------------------------------------\n\nTITLE: Checking Elixir Runtime Status in Swift\nDESCRIPTION: This Swift property checks if the Elixir runtime is currently running.\nSOURCE: https://github.com/livebook-dev/livebook/blob/main/elixirkit/README.md#2025-04-21_snippet_0\n\nLANGUAGE: Swift\nCODE:\n```\nElixirKit.API.isRunning: Bool\n```\n\n----------------------------------------\n\nTITLE: Adding Observer for Elixir Runtime Events in Swift\nDESCRIPTION: This Swift method adds an observer for events from the Elixir runtime, specifying an operation queue and a handler.\nSOURCE: https://github.com/livebook-dev/livebook/blob/main/elixirkit/README.md#2025-04-21_snippet_5\n\nLANGUAGE: Swift\nCODE:\n```\nElixirKit.API.addObserver(queue: OperationQueue?, using: ((String, String)) -> Void) -> Void\n```\n\n----------------------------------------\n\nTITLE: Checking Main Instance in C#\nDESCRIPTION: This C# method checks if the current app is the main instance using a provided ID.\nSOURCE: https://github.com/livebook-dev/livebook/blob/main/elixirkit/README.md#2025-04-21_snippet_7\n\nLANGUAGE: C#\nCODE:\n```\nElixirKit.API.IsMainInstance(string id) -> bool\n```\n\n----------------------------------------\n\nTITLE: Running Livebook Executable\nDESCRIPTION: Executes the Livebook application directly using the run.sh script.\nSOURCE: https://github.com/livebook-dev/livebook/blob/main/elixirkit/demo/rel/appkit/README.md#2025-04-21_snippet_0\n\nLANGUAGE: Shell\nCODE:\n```\n$ ./run.sh\n```\n\n----------------------------------------\n\nTITLE: Running Livebook App Bundle\nDESCRIPTION: Launches the Livebook application bundle using the run_app.sh script.\nSOURCE: https://github.com/livebook-dev/livebook/blob/main/elixirkit/demo/rel/appkit/README.md#2025-04-21_snippet_1\n\nLANGUAGE: Shell\nCODE:\n```\n$ ./run_app.sh\n```\n\n----------------------------------------\n\nTITLE: Building Livebook DMG Installer\nDESCRIPTION: Creates a disk image (.dmg) file for Livebook distribution using the build_dmg.sh script.\nSOURCE: https://github.com/livebook-dev/livebook/blob/main/elixirkit/demo/rel/appkit/README.md#2025-04-21_snippet_2\n\nLANGUAGE: Shell\nCODE:\n```\n$ ./build_dmg.sh\n```\n\n----------------------------------------\n\nTITLE: Running Livebook Demo Application\nDESCRIPTION: Shell command to execute the Livebook demo application using the run script. The command needs to be executed from the project root directory.\nSOURCE: https://github.com/livebook-dev/livebook/blob/main/elixirkit/demo/rel/dotnet/README.md#2025-04-21_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n$ ./run.sh\n```\n\n----------------------------------------\n\nTITLE: Kubernetes Deployment Configuration for Livebook\nDESCRIPTION: Complete Kubernetes configuration including services, deployment, and secrets for running Livebook in a clustered environment with load balancing.\nSOURCE: https://github.com/livebook-dev/livebook/blob/main/docs/deployment/docker.md#2025-04-21_snippet_2\n\nLANGUAGE: yaml\nCODE:\n```\napiVersion: v1\nkind: Service\nmetadata:\n  name: livebook-headless\nspec:\n  clusterIP: None\n  selector:\n    app: livebook\n\n---\n\napiVersion: v1\nkind: Service\nmetadata:\n  name: livebook-loadbalancer\nspec:\n  type: ClusterIP\n  ports:\n    - port: 8080\n      targetPort: 8080\n  selector:\n    app: livebook\n\n---\n\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: livebook\nspec:\n  # When deploying Livebook for authoring notebooks to Kubernetes,\n  # the number of replicas must be 1, since Livebook considers you\n  # will assign one instance per user.\n  replicas: 1\n  selector:\n    matchLabels:\n      app: livebook\n  template:\n    metadata:\n      labels:\n        app: livebook\n    spec:\n      containers:\n        - name: livebook\n          image: ghcr.io/livebook-dev/livebook:latest\n          ports:\n            - containerPort: 8080\n          env:\n            - name: POD_IP\n              valueFrom:\n                fieldRef:\n                  fieldPath: status.podIP\n            - name: POD_NAMESPACE\n              valueFrom:\n                fieldRef:\n                  fieldPath: metadata.namespace\n            - name: LIVEBOOK_NODE\n              value: \"livebook@$(POD_IP)\"\n            - name: LIVEBOOK_CLUSTER\n              value: \"dns:livebook-headless.$(POD_NAMESPACE).svc.cluster.local\"\n            - name: LIVEBOOK_PASSWORD\n              valueFrom:\n                secretKeyRef:\n                  name: livebook-secret\n                  key: LIVEBOOK_PASSWORD\n            - name: LIVEBOOK_SECRET_KEY_BASE\n              valueFrom:\n                secretKeyRef:\n                  name: livebook-secret\n                  key: LIVEBOOK_SECRET_KEY_BASE\n            - name: LIVEBOOK_COOKIE\n              valueFrom:\n                secretKeyRef:\n                  name: livebook-secret\n                  key: LIVEBOOK_COOKIE\n\n---\n\napiVersion: v1\nkind: Secret\nmetadata:\n  name: livebook-secret\n  namespace: livebook-namespace\ntype: Opaque\ndata:\n  LIVEBOOK_PASSWORD: <base64_encoded_password>\n  LIVEBOOK_SECRET_KEY_BASE: <base64_encoded_password>\n  LIVEBOOK_COOKIE: <base64_encoded_password>\n```\n\n----------------------------------------\n\nTITLE: Running Livebook Demo Application using Shell Script\nDESCRIPTION: This command executes a shell script named 'run.sh' to start the Livebook demo application. The script likely contains the necessary setup and launch commands for the Livebook environment.\nSOURCE: https://github.com/livebook-dev/livebook/blob/main/elixirkit/demo/rel/swift/README.md#2025-04-21_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n$ ./run.sh\n```\n\n----------------------------------------\n\nTITLE: Executing Livebook Application via Shell Script\nDESCRIPTION: This command runs the Livebook application using a shell script named 'run.sh'. It assumes the script is in the current directory and has executable permissions.\nSOURCE: https://github.com/livebook-dev/livebook/blob/main/elixirkit/demo/rel/winforms/README.md#2025-04-21_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n$ ./run.sh\n```\n\n----------------------------------------\n\nTITLE: Stopping Elixir Runtime in C#\nDESCRIPTION: This C# method stops the Elixir runtime and returns the exit code.\nSOURCE: https://github.com/livebook-dev/livebook/blob/main/elixirkit/README.md#2025-04-21_snippet_11\n\nLANGUAGE: C#\nCODE:\n```\nElixirKit.API.Stop() -> int\n```\n\n----------------------------------------\n\nTITLE: Running Livebook Application on macOS\nDESCRIPTION: A simple bash command that demonstrates how to run the Livebook application on macOS systems. This is likely part of a developer setup or testing workflow.\nSOURCE: https://github.com/livebook-dev/livebook/blob/main/rel/app/macos/README.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n$ ./run.sh\n```\n\n----------------------------------------\n\nTITLE: Executing Livebook Windows Run Script\nDESCRIPTION: Command to execute the run.sh shell script that launches the Livebook application on Windows.\nSOURCE: https://github.com/livebook-dev/livebook/blob/main/rel/app/windows/README.md#2025-04-21_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n$ ./run.sh\n```\n\n----------------------------------------\n\nTITLE: Ready Handler Delegate in C#\nDESCRIPTION: This C# delegate defines the signature for a callback method to be invoked when the Elixir runtime is ready.\nSOURCE: https://github.com/livebook-dev/livebook/blob/main/elixirkit/README.md#2025-04-21_snippet_13\n\nLANGUAGE: C#\nCODE:\n```\nElixirKit.ReadyHandler:() -> void\n```\n\n----------------------------------------\n\nTITLE: Exit Handler Delegate in C#\nDESCRIPTION: This C# delegate defines the signature for a callback method to be invoked when the Elixir runtime exits, providing the exit code.\nSOURCE: https://github.com/livebook-dev/livebook/blob/main/elixirkit/README.md#2025-04-21_snippet_14\n\nLANGUAGE: C#\nCODE:\n```\nElixirKit.ExitHandler:(int ExitCode) -> void\n```\n\n----------------------------------------\n\nTITLE: Event Handler Delegate in C#\nDESCRIPTION: This C# delegate defines the signature for a callback method to handle events from the Elixir runtime, providing the event name and data.\nSOURCE: https://github.com/livebook-dev/livebook/blob/main/elixirkit/README.md#2025-04-21_snippet_15\n\nLANGUAGE: C#\nCODE:\n```\nElixirKit.EventHandler:(string Name, string Data) -> void\n```\n\n----------------------------------------\n\nTITLE: Defining Global Crawler Exclusion Rule in robots.txt\nDESCRIPTION: This snippet defines a global rule for all web crawlers, instructing them not to access the root directory of the website. It uses the standard robots.txt syntax.\nSOURCE: https://github.com/livebook-dev/livebook/blob/main/iframe/priv/static/robots.txt#2025-04-21_snippet_0\n\nLANGUAGE: robots.txt\nCODE:\n```\nUser-agent: *\nDisallow: /\n```\n\n----------------------------------------\n\nTITLE: Configuring robots.txt to Ban All Spiders\nDESCRIPTION: This snippet demonstrates how to configure robots.txt to prevent all web crawlers from accessing any part of the website. The directives are currently commented out, serving as an example of how to implement such a restriction if needed.\nSOURCE: https://github.com/livebook-dev/livebook/blob/main/static/robots.txt#2025-04-21_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\n# User-agent: *\n# Disallow: /\n```"
  }
]