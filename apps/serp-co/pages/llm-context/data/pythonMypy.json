[
  {
    "owner": "python",
    "repo": "mypy",
    "content": "TITLE: Installing Mypy with pip in Shell\nDESCRIPTION: This Shell command installs Mypy, a static type checker for Python, using pip. It requires Python 3.9 or later.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/getting_started.rst#2025-04-22_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n$ python3 -m pip install mypy\n```\n\n----------------------------------------\n\nTITLE: Basic Python Types\nDESCRIPTION: Core built-in Python types including int, float, bool, str, bytes, and object. These represent the fundamental data types available in Python.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/builtin_types.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nint        # integer\nfloat      # floating point number\nbool       # boolean value (subclass of int)\nstr        # text, sequence of unicode codepoints\nbytes      # 8-bit string, sequence of byte values\nobject     # an arbitrary object (object is the common base class)\n```\n\n----------------------------------------\n\nTITLE: Explicit Type Declaration of Class Attributes - Python\nDESCRIPTION: Demonstrates declaring the type of a class attribute directly in the class body using Python 3.6+ variable annotations. This helps static type checkers like mypy accurately infer attribute types, supporting both instance and class variable usage. Requires no dependencies other than mypy for checking.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/class_basics.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nclass A:\n    x: list[int]  # Declare attribute 'x' of type list[int] \n\na = A()\na.x = [1]     # OK\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Mypy Type Error Detection in Python\nDESCRIPTION: This Python snippet shows a simple program that takes user input (as a string) and attempts to add an integer to it, which causes a TypeError at runtime. Mypy can identify this error statically due to incompatible types (\"str\" and \"int\") for the '+' operator. It illustrates the benefit of using Mypy to catch errors before running the code.\nSOURCE: https://github.com/python/mypy/blob/master/README.md#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n```python\nnumber = input(\"What is your favourite number?\")\nprint(\"It is\", number + 1)  # error: Unsupported operand types for + (\"str\" and \"int\")\n```\n```\n\n----------------------------------------\n\nTITLE: Class and Instance Methods with Type Annotations in Python\nDESCRIPTION: This code illustrates how to use type hints in classes, covering constructor annotations, method definitions, user-defined types, subclassing, and class variables using ClassVar. It also discusses setting dynamic attributes through special methods.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/cheat_sheet_py3.rst#2025-04-22_snippet_3\n\nLANGUAGE: Python\nCODE:\n```\nfrom typing import ClassVar\n\nclass BankAccount:\n    # The \"__init__\" method doesn\\'t return anything, so it gets return\n    # type \"None\" just like any other method that doesn\\'t return anything\n    def __init__(self, account_name: str, initial_balance: int = 0) -> None:\n        # mypy will infer the correct types for these instance variables\n        # based on the types of the parameters.\n        self.account_name = account_name\n        self.balance = initial_balance\n\n    # For instance methods, omit type for \"self\"\n    def deposit(self, amount: int) -> None:\n        self.balance += amount\n\n    def withdraw(self, amount: int) -> None:\n        self.balance -= amount\n\n# User-defined classes are valid as types in annotations\naccount: BankAccount = BankAccount(\"Alice\", 400)\ndef transfer(src: BankAccount, dst: BankAccount, amount: int) -> None:\n    src.withdraw(amount)\n    dst.deposit(amount)\n\n# Functions that accept BankAccount also accept any subclass of BankAccount!\nclass AuditedBankAccount(BankAccount):\n    # You can optionally declare instance variables in the class body\n    audit_log: list[str]\n\n    def __init__(self, account_name: str, initial_balance: int = 0) -> None:\n        super().__init__(account_name, initial_balance)\n        self.audit_log: list[str] = []\n\n    def deposit(self, amount: int) -> None:\n        self.audit_log.append(f\"Deposited {amount}\")\n        self.balance += amount\n\n    def withdraw(self, amount: int) -> None:\n        self.audit_log.append(f\"Withdrew {amount}\")\n        self.balance -= amount\n\naudited = AuditedBankAccount(\"Bob\", 300)\ntransfer(audited, account, 100)  # type checks!\n\n# You can use the ClassVar annotation to declare a class variable\nclass Car:\n    seats: ClassVar[int] = 4\n    passengers: ClassVar[list[str]]\n\n# If you want dynamic attributes on your class, have it\n# override \"__setattr__\" or \"__getattr__\"\nclass A:\n    # This will allow assignment to any A.x, if x is the same type as \"value\"\n    # (use \"value: Any\" to allow arbitrary types)\n    def __setattr__(self, name: str, value: int) -> None: ...\n\n    # This will allow access to any A.x, if x is compatible with the return type\n    def __getattr__(self, name: str) -> int: ...\n\na = A()\na.foo = 42  # Works\na.bar = 'Ex-parrot'  # Fails type checking\n\n```\n\n----------------------------------------\n\nTITLE: Running Mypy for Type Checking in Shell\nDESCRIPTION: This Shell command runs Mypy on a Python file to statically check for type errors. The tool checks code without executing it.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/getting_started.rst#2025-04-22_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\n$ mypy program.py\n```\n\n----------------------------------------\n\nTITLE: Inferring Variable Types with Mypy in Python\nDESCRIPTION: This snippet demonstrates how mypy automatically infers variable types based on initial assignments, and how the special function 'reveal_type' can be used to display the inferred type at runtime. No explicit type annotations are used, and both simple variables and collections (lists) are shown. Requires the use of mypy as a static type checker.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/type_inference_and_annotations.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n# Mypy will infer the type of these variables, despite no annotations\\ni = 1\\nreveal_type(i)  # Revealed type is \\\"builtins.int\\\"\\nl = [1, 2]\\nreveal_type(l)  # Revealed type is \\\"builtins.list[builtins.int]\\\"\n```\n\n----------------------------------------\n\nTITLE: Statically Typed Function in Python\nDESCRIPTION: This Python function, 'greeting', uses type annotations to specify that it accepts and returns a string. Mypy checks type consistency, reporting errors for incorrect types.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/getting_started.rst#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ndef greeting(name: str) -> str:\n    return 'Hello ' + name\n\ngreeting(3)         # Error\n# Argument 1 to \"greeting\" has incompatible type \"int\"; expected \"str\"\ngreeting(b'Alice')  # Error\n# Argument 1 to \"greeting\" has incompatible type \"bytes\"; expected \"str\"\ngreeting(\"World!\")  # No error\ndef bad_greeting(name: str) -> str:\n    return 'Hello ' * name  # Error\n# Unsupported operand types for * (\"str\" and \"str\")\n```\n\n----------------------------------------\n\nTITLE: Using Built-in Types with Annotations in Python\nDESCRIPTION: This snippet illustrates the use of type hints with various built-in types, including int, float, bool, str, bytes, and collections like list, set, dict, and tuple. Python 3.9+ and earlier versions are covered, affecting how collection types are annotated.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/cheat_sheet_py3.rst#2025-04-22_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\n# For most types, just use the name of the type in the annotation\n# Note that mypy can usually infer the type of a variable from its value,\n# so technically these annotations are redundant\nx: int = 1\nx: float = 1.0\nx: bool = True\nx: str = \"test\"\nx: bytes = b\"test\"\n\n# For collections on Python 3.9+, the type of the collection item is in brackets\nx: list[int] = [1]\nx: set[int] = {6, 7}\n\n# For mappings, we need the types of both keys and values\nx: dict[str, float] = {\"field\": 2.0}  # Python 3.9+\n\n# For tuples of fixed size, we specify the types of all the elements\nx: tuple[int, str, float] = (3, \"yes\", 7.5)  # Python 3.9+\n\n# For tuples of variable size, we use one type and ellipsis\nx: tuple[int, ...] = (1, 2, 3)  # Python 3.9+\n\n# On Python 3.8 and earlier, the name of the collection type is\n# capitalized, and the type is imported from the 'typing' module\nfrom typing import List, Set, Dict, Tuple\nx: List[int] = [1]\nx: Set[int] = {6, 7}\nx: Dict[str, float] = {\"field\": 2.0}\nx: Tuple[int, str, float] = (3, \"yes\", 7.5)\nx: Tuple[int, ...] = (1, 2, 3)\n\nfrom typing import Union, Optional\n\n# On Python 3.10+, use the | operator when something could be one of a few types\nx: list[int | str] = [3, 5, \"test\", \"fun\"]  # Python 3.10+\n# On earlier versions, use Union\nx: list[Union[int, str]] = [3, 5, \"test\", \"fun\"]\n\n# Use X | None for a value that could be None on Python 3.10+\n# Use Optional[X] on 3.9 and earlier; Optional[X] is the same as 'X | None'\nx: str | None = \"something\" if some_condition() else None\nif x is not None:\n    # Mypy understands x won\\'t be None here because of the if-statement\n    print(x.upper())\n# If you know a value can never be None due to some logic that mypy doesn\\'t\n# understand, use an assert\nassert x is not None\nprint(x.upper())\n\n```\n\n----------------------------------------\n\nTITLE: Checking Return Value Compatibility with Mypy in Python\nDESCRIPTION: This snippet demonstrates how Mypy checks the compatibility of return values with the expected type signature. An error is shown when the type of the returned value does not match the specified return type.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/error_code_list.rst#2025-04-22_snippet_13\n\nLANGUAGE: python\nCODE:\n```\ndef func(x: int) -> str:\n    # Error: Incompatible return value type (got \"int\", expected \"str\")  [return-value]\n    return x + 1\n```\n\n----------------------------------------\n\nTITLE: Running Mypy Type Checker on a Python Program in Bash\nDESCRIPTION: This command executes the Mypy type checker on the specified Python file (`PROGRAM`). Mypy analyzes the file for type errors based on the type hints present in the code. `PROGRAM` should be replaced with the actual path to the Python file.\nSOURCE: https://github.com/python/mypy/blob/master/README.md#2025-04-22_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n```bash\nmypy PROGRAM\n```\n```\n\n----------------------------------------\n\nTITLE: Declaring and Initializing Variables in Python\nDESCRIPTION: This snippet demonstrates how to declare the type of a variable in Python using type hints and how type inference can make explicit annotations unnecessary. It shows the annotation and conditional initialization of variables using mypy.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/cheat_sheet_py3.rst#2025-04-22_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\n# This is how you declare the type of a variable\nage: int = 1\n\n# You don\\'t need to initialize a variable to annotate it\na: int  # Ok (no value at runtime until assigned)\n\n# Doing so can be useful in conditional branches\nchild: bool\nif age < 18:\n    child = True\nelse:\n    child = False\n\n```\n\n----------------------------------------\n\nTITLE: Running mypy via CLI on Multiple Files and Directories - Bash\nDESCRIPTION: Demonstrates how to run mypy from the command line by providing specific Python files and directories to be type checked. This command requires mypy to be installed and accessible in the shell's PATH. The inputs are file and directory arguments and the output is mypy's type checking report, which will be printed to stdout.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/running_mypy.rst#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n$ mypy foo.py bar.py some_directory\n```\n\n----------------------------------------\n\nTITLE: Handling Function Return Types with Mypy in Python\nDESCRIPTION: Shows the importance of specifying return types to catch errors using Mypy. It contrasts outcomes when return type is explicitly defined as None versus when left as Any by default. Dependencies: time module for sleep. Key parameters: t - time duration for sleep.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/kinds_of_types.rst#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ndef wait(t: float):  # Implicit Any return value\n    print('Waiting...')\n    time.sleep(t)\n\nif wait(2) > 1:   # Mypy doesn't catch this error!\n    ...\n```\n\nLANGUAGE: python\nCODE:\n```\ndef wait(t: float) -> None:\n    print('Waiting...')\n    time.sleep(t)\n\nif wait(2) > 1:   # Error: can't compare None and int\n    ...\n```\n\n----------------------------------------\n\nTITLE: Type Inference Fails for Empty Collections in Python (Mypy Error)\nDESCRIPTION: Demonstrates that mypy cannot infer the type of an empty list in variable assignments and requires a type annotation. Attempting to assign an empty list without an annotation triggers an error, emphasizing the need for explicit typing in such cases.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/type_inference_and_annotations.rst#2025-04-22_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nl = []  # Error: Need type annotation for \\\"l\\\"\n```\n\n----------------------------------------\n\nTITLE: Method Overriding and Type Compatibility Checks with Mypy - Python\nDESCRIPTION: Explains mypy's method signature compatibility checks when overriding statically typed methods in subclasses. Shows both compatible and incompatible overrides, with varying parameter types and counts. Useful for ensuring correct class hierarchies and catching signature mismatches.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/class_basics.rst#2025-04-22_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nclass Base:\n    def f(self, x: int) -> None:\n        ...\n\nclass Derived1(Base):\n    def f(self, x: str) -> None:   # Error: type of 'x' incompatible\n        ...\n\nclass Derived2(Base):\n    def f(self, x: int, y: int) -> None:  # Error: too many arguments\n        ...\n\nclass Derived3(Base):\n    def f(self, x: int) -> None:   # OK\n        ...\n\nclass Derived4(Base):\n    def f(self, x: float) -> None:   # OK: mypy treats int as a subtype of float\n        ...\n\nclass Derived5(Base):\n    def f(self, x: int, y: int = 0) -> None:   # OK: accepts more than the base\n        ...                                    #     class method\n```\n\n----------------------------------------\n\nTITLE: Example mypy.ini Configuration File\nDESCRIPTION: This INI snippet demonstrates a sample `mypy.ini` file structure. It defines global settings under the `[mypy]` section (like `warn_return_any` and `warn_unused_configs`) and module-specific settings using pattern-based sections (e.g., `[mypy-mycode.foo.*]`, `[mypy-mycode.bar]`, `[mypy-somelibrary]`). This illustrates how to set default behaviors and override them for specific modules or third-party libraries, enabling fine-grained control over type checking.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/config_file.rst#2025-04-22_snippet_0\n\nLANGUAGE: ini\nCODE:\n```\n# Global options:\n\n[mypy]\nwarn_return_any = True\nwarn_unused_configs = True\n\n# Per-module options:\n\n[mypy-mycode.foo.*]\ndisallow_untyped_defs = True\n\n[mypy-mycode.bar]\nwarn_return_any = False\n\n[mypy-somelibrary]\nignore_missing_imports = True\n```\n\n----------------------------------------\n\nTITLE: Type Aliases in Mypy with Python\nDESCRIPTION: Shows how to define and use type aliases in Python with Mypy to simplify long type definitions. It features both implicit and explicit alias definitions using the 'type' statement. Examples illustrate creating a shorthand notation for complex types.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/kinds_of_types.rst#2025-04-22_snippet_12\n\nLANGUAGE: Python\nCODE:\n```\ndef f() -> list[dict[tuple[int, str], set[int]]] | tuple[str, list[str]]:\n    ...\n```\n\nLANGUAGE: Python\nCODE:\n```\nAliasType = list[dict[tuple[int, str], set[int]]] | tuple[str, list[str]]\n\ndef f() -> AliasType:\n    ...\n```\n\nLANGUAGE: Python\nCODE:\n```\ntype AliasType = list[dict[tuple[int, str], set[int]]] | tuple[str, list[str]]\n\ndef f() -> AliasType:\n    ...\n```\n\nLANGUAGE: Python\nCODE:\n```\nfrom typing import TypeAlias\n\nAliasType: TypeAlias = list[dict[tuple[int, str], set[int]]] | tuple[str, list[str]]\n```\n\n----------------------------------------\n\nTITLE: Illustrating Mypy Behavior for Unannotated Function Parameters in Python\nDESCRIPTION: This Python function definition serves as a counter-example where Mypy would typically not report an error because neither parameter (`a` nor `b`) has a type annotation, unless specific checking options like `check_untyped_defs` are enabled.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/config_file.rst#2025-04-22_snippet_7\n\nLANGUAGE: python\nCODE:\n```\ndef f(a, b)\n```\n\n----------------------------------------\n\nTITLE: Global Error Code Configuration in Mypy\nDESCRIPTION: This code snippet illustrates the usage of \"--disable-error-code\" and \"--enable-error-code\" flags to manage specific error codes in mypy. The example shows error behavior when trimming a string, enabling developers to finely control warning displays by toggling codes on or off.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/command_line.rst#2025-04-22_snippet_13\n\nLANGUAGE: python\nCODE:\n```\nx = 'a string'\nx.trim()  # error: \"str\" has no attribute \"trim\"  [attr-defined]\n\n# When using --disable-error-code attr-defined\nx = 'a string'\nx.trim()\n\n# --disable-error-code attr-defined --enable-error-code attr-defined\nx = 'a string'\nx.trim()  # error: \"str\" has no attribute \"trim\"  [attr-defined]\n```\n\n----------------------------------------\n\nTITLE: Calling a Generic Function and Type Inference\nDESCRIPTION: Demonstrates calling the generic function `first` with a list of integers and a tuple of strings. It uses `reveal_type` (a Mypy feature) to show how the static type checker correctly infers the return type (`int` and `str`, respectively) based on the type of the input sequence.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/generics.rst#2025-04-22_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nreveal_type(first([1, 2, 3]))   # Revealed type is \"builtins.int\"\nreveal_type(first(('a', 'b')))  # Revealed type is \"builtins.str\"\n```\n\n----------------------------------------\n\nTITLE: Defining Generic Function with Upper Bound in Python\nDESCRIPTION: This Python snippet demonstrates how to define a generic function with a type variable that has an upper bound using the Python 3.12 syntax. It uses the SupportsAbs protocol to ensure that the type variable T is a subtype capable of being used with the abs function. This function finds the maximum of its arguments based on their absolute value.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/generics.rst#2025-04-22_snippet_13\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import SupportsAbs\n\ndef max_by_abs[T: SupportsAbs[float]](*xs: T) -> T:\n    # We can use abs(), because T is a subtype of SupportsAbs[float].\n    return max(xs, key=abs)\n```\n\n----------------------------------------\n\nTITLE: Using Callable Types and Lambdas in Python\nDESCRIPTION: Highlights the use of Callable for specifying function signatures in type annotations with Mypy. It explains how to use Callable with lambdas and how it assists in inferring types. Dependencies: collections.abc for Callable. Key parameters: i, next - function parameters; l - lambda usage.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/kinds_of_types.rst#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom collections.abc import Callable\n\ndef twice(i: int, next: Callable[[int], int]) -> int:\n    return next(next(i))\n\ndef add(i: int) -> int:\n    return i + 1\n\nprint(twice(3, add))   # 5\n```\n\nLANGUAGE: python\nCODE:\n```\nfrom collections.abc import Callable\n\ndef arbitrary_call(f: Callable[..., int]) -> int:\n    return f('x') + f(y=2)  # OK\n\narbitrary_call(ord)   # No static error, but fails at runtime\narbitrary_call(open)  # Error: does not return an int\narbitrary_call(1)     # Error: 'int' is not callable\n```\n\nLANGUAGE: python\nCODE:\n```\nl = map(lambda x: x + 1, [1, 2, 3])   # Infer x as int and l as list[int]\n```\n\nLANGUAGE: python\nCODE:\n```\nfrom collections.abc import Callable\n\nclass C:\n    def __init__(self, app: str) -> None:\n        pass\n\nCallableType = Callable[[str], C]\n\ndef class_or_callable(arg: CallableType) -> None:\n    inst = arg(\"my_app\")\n    reveal_type(inst)  # Revealed type is \"C\"\n```\n\n----------------------------------------\n\nTITLE: Specifying Multiple Files and Directories for mypy Type Checking - Bash\nDESCRIPTION: Shows how to invoke mypy on a mix of individual Python files (including .pyi stubs) and entire directories using the CLI. The command recursively analyzes all suitable source files within any provided directories. Requires mypy installation, files/directories as arguments, and outputs type checking results for all provided paths.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/running_mypy.rst#2025-04-22_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n$ mypy file_1.py foo/file_2.py file_3.pyi some/directory\n```\n\n----------------------------------------\n\nTITLE: Variable Redefinition with Incompatible Types in Python\nDESCRIPTION: Example showing how mypy detects an error when trying to redefine a variable with an incompatible type, as each name within a function can only have a single 'declared' type.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/common_issues.rst#2025-04-22_snippet_10\n\nLANGUAGE: python\nCODE:\n```\ndef f() -> None:\n    n = 1\n    ...\n    n = 'x'  # error: Incompatible types in assignment (expression has type \"str\", variable has type \"int\")\n```\n\n----------------------------------------\n\nTITLE: Displaying Expression Types with Mypy in Python\nDESCRIPTION: Demonstrates using `reveal_type` and `reveal_locals` to inspect the inferred types of expressions and local variables in Python code for better understanding of Mypy's type inference.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/common_issues.rst#2025-04-22_snippet_16\n\nLANGUAGE: python\nCODE:\n```\nreveal_type((1, 'hello'))  # Revealed type is \"tuple[builtins.int, builtins.str]\"\n```\n\nLANGUAGE: python\nCODE:\n```\na = 1\nb = 'one'\nreveal_locals()\n# Revealed local types are:\n#     a: builtins.int\n#     b: builtins.str\n```\n\n----------------------------------------\n\nTITLE: Untyped Function Bypassing Type Checking in Python\nDESCRIPTION: Example showing how a function without type annotations isn't type-checked by mypy, allowing type errors to go undetected. Adding type annotations enables mypy to catch the error of trying to concatenate a string with a list.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/common_issues.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ndef foo(a):\n    return '(' + a.split() + ')'  # No error!\n```\n\n----------------------------------------\n\nTITLE: Implementing Recursive Generic Protocols (Python 3.12)\nDESCRIPTION: Shows how to define and use recursive generic protocols, where a protocol refers to itself in its method signatures. Uses Python 3.12's native type parameter syntax.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/generics.rst#2025-04-22_snippet_50\n\nLANGUAGE: python\nCODE:\n```\nclass Linked[T](Protocol):\n    val: T\n    def next(self) -> 'Linked[T]': ...\n\nclass L:\n    val: int\n    def next(self) -> 'L': ...\n\ndef last(seq: Linked[T]) -> T: ...\n\nresult = last(L())\nreveal_type(result)  # Revealed type is \"builtins.int\"\n```\n\n----------------------------------------\n\nTITLE: Annotating Function Types in Python\nDESCRIPTION: This snippet covers how to use type hints for function definitions, including specifying return types and argument types, handling default values, callables, and yielding functions. It also discusses positional-only and keyword-only arguments.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/cheat_sheet_py3.rst#2025-04-22_snippet_2\n\nLANGUAGE: Python\nCODE:\n```\nfrom collections.abc import Iterator, Callable\nfrom typing import Union, Optional\n\n# This is how you annotate a function definition\ndef stringify(num: int) -> str:\n    return str(num)\n\n# And here\\'s how you specify multiple arguments\ndef plus(num1: int, num2: int) -> int:\n    return num1 + num2\n\n# If a function does not return a value, use None as the return type\n# Default value for an argument goes after the type annotation\ndef show(value: str, excitement: int = 10) -> None:\n    print(value + \"!\" * excitement)\n\n# Note that arguments without a type are dynamically typed (treated as Any)\n# and that functions without any annotations are not checked\ndef untyped(x):\n    x.anything() + 1 + \"string\"  # no errors\n\n# This is how you annotate a callable (function) value\nx: Callable[[int, float], float] = f\ndef register(callback: Callable[[str], int]) -> None: ...\n\n# A generator function that yields ints is secretly just a function that\n# returns an iterator of ints, so that\\'s how we annotate it\ndef gen(n: int) -> Iterator[int]:\n    i = 0\n    while i < n:\n        yield i\n        i += 1\n\n# You can of course split a function annotation over multiple lines\ndef send_email(\n    address: str | list[str],\n    sender: str,\n    cc: list[str] | None,\n    bcc: list[str] | None,\n    subject: str = '',\n    body: list[str] | None = None,\n) -> bool:\n    ...\n\n# Mypy understands positional-only and keyword-only arguments\n# Positional-only arguments can also be marked by using a name starting with\n# two underscores\ndef quux(x: int, /, *, y: int) -> None:\n    pass\n\nquux(3, y=5)  # Ok\nquux(3, 5)  # error: Too many positional arguments for \"quux\"\nquux(x=3, y=5)  # error: Unexpected keyword argument \"x\" for \"quux\"\n\n# This says each positional arg and each keyword arg is a \"str\"\ndef call(self, *args: str, **kwargs: str) -> str:\n    reveal_type(args)  # Revealed type is \"tuple[str, ...]\"\n    reveal_type(kwargs)  # Revealed type is \"dict[str, str]\"\n    request = make_request(*args, **kwargs)\n    return self.do_api_query(request)\n\n```\n\n----------------------------------------\n\nTITLE: Automating Mypy in Continuous Integration - Shell Script - Text\nDESCRIPTION: This shell script snippet demonstrates a typical way to integrate mypy into a Continuous Integration (CI) workflow. The script installs a pinned version of mypy using pip and runs mypy against the 'my_project' directory. The comments suggest that, instead of the literal command, this could call project-specific wrapper scripts or integrate with tools such as tox or make. This ensures consistent type checks and is intended to be copied or adapted for CI config files. Dependencies: Python 3, pip, and network access to download mypy. Parameters: None directly, but assumes the current working directory context. Output: Console output showing installation results and mypy's type-checking results.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/existing_code.rst#2025-04-22_snippet_0\n\nLANGUAGE: text\nCODE:\n```\npython3 -m pip install mypy==1.8\n# Run your standardised mypy invocation, e.g.\nmypy my_project\n# This could also look like `scripts/run_mypy.sh`, `tox run -e mypy`, `make mypy`, etc\n```\n\n----------------------------------------\n\nTITLE: Tuple Types and Their Usage in Python\nDESCRIPTION: Explains how tuple types are used for defining fixed-length and varying-length sequences in Python. Includes examples of type checking with Mypy to ensure assigned values match the defined tuple structure. Dependencies: None. Key parameters: t - demonstrating tuple type.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/kinds_of_types.rst#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ndef f(t: tuple[int, str]) -> None:\n    t = 1, 'foo'    # OK\n    t = 'foo', 1    # Type check error\n```\n\nLANGUAGE: python\nCODE:\n```\ndef print_squared(t: tuple[int, ...]) -> None:\n    for n in t:\n        print(n, n ** 2)\n\nprint_squared(())           # OK\nprint_squared((1, 3, 5))    # OK\nprint_squared([1, 2])       # Error: only a tuple is valid\n```\n\n----------------------------------------\n\nTITLE: Disabling Implicit Re-exports in Mypy\nDESCRIPTION: This snippet demonstrates how to control the re-export of imported values in mypy using the \"--no-implicit-reexport\" flag. This flag prevents automatic exports unless specified in \"__all__\" or when using an alias. The code provides examples with different import styles and how they affect re-export behavior.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/command_line.rst#2025-04-22_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nfrom foo import bar\nfrom foo import bar as bang\nfrom foo import bar as bar\nfrom foo import bar\n__all__ = ['bar']\n```\n\n----------------------------------------\n\nTITLE: Defining a Generic Function (Python 3.12+ Syntax)\nDESCRIPTION: Defines a generic function `first` using the Python 3.12+ syntax `def first[T](...)`. This function accepts a `Sequence` of type `T` and returns the first element, also of type `T`.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/generics.rst#2025-04-22_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nfrom collections.abc import Sequence\n\n# A generic function!\ndef first[T](seq: Sequence[T]) -> T:\n    return seq[0]\n```\n\n----------------------------------------\n\nTITLE: Implicitly Abstract Members in Python Protocol Subclasses\nDESCRIPTION: Shows that omitting implementations (no right-hand side for attributes like `attr`, or using `...` for methods like `method`) in a `typing.Protocol` definition makes those members implicitly abstract. Attempting to instantiate a direct subclass (`ExplicitSubclass`) that inherits these abstract members without providing concrete implementations results in a Mypy instantiation error. Dependency: `typing.Protocol`.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/protocols.rst#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nclass SomeProto(Protocol):\n    attr: int  # Note, no right hand side\n    def method(self) -> str: ...  # Literally just ... here\n\nclass ExplicitSubclass(SomeProto):\n    pass\n\nExplicitSubclass()  # error: Cannot instantiate abstract class 'ExplicitSubclass'\n                    # with abstract attributes 'attr' and 'method'\n```\n\n----------------------------------------\n\nTITLE: Importing and Using Type Aliases in Python 3.12\nDESCRIPTION: Shows how to import type aliases from modules and use them in function signatures and new type definitions. Demonstrates limitations of type aliases in class definitions and instance creation.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/generics.rst#2025-04-22_snippet_54\n\nLANGUAGE: python\nCODE:\n```\nfrom example1 import AliasType\nfrom example2 import Vec\n\n# AliasType and Vec are type aliases (Vec as defined above)\n\ndef fun() -> AliasType:\n    ...\n\ntype OIntVec = Vec[int] | None\n\nclass NewVec[T](Vec[T]):  # Error: not valid as base class\n    ...\n\nx = AliasType()  # Error: can't be used to create instances\n```\n\n----------------------------------------\n\nTITLE: Excluding Files from Mypy Checks\nDESCRIPTION: Shows how to use the --exclude flag to ignore certain files or directories during mypy's recursive discovery process.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/command_line.rst#2025-04-22_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nmypy --exclude '/setup\\.py$' --exclude '/build/'\n```\n\n----------------------------------------\n\nTITLE: Ensuring Coroutine Return Values are Used in Python\nDESCRIPTION: Explains the Mypy error when async def functions are called without using their return value. It suggests using await or storing the result properly to avoid mistakes.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/error_code_list.rst#2025-04-22_snippet_32\n\nLANGUAGE: python\nCODE:\n```\nasync def f() -> None:\n    ...\n\nasync def g() -> None:\n    f()  # Error: missing await\n    await f()  # OK\n```\n\nLANGUAGE: python\nCODE:\n```\n_ = f()  # No error\n```\n\n----------------------------------------\n\nTITLE: Handling None Values in Mypy Python\nDESCRIPTION: Illustrates how to perform operations on values that could be 'None' using explicit checks. It emphasizes using conditional statements to manage optional types, ensuring type safety by checking if values are 'None' before operations. The function 'my_inc' demonstrates this approach.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/kinds_of_types.rst#2025-04-22_snippet_8\n\nLANGUAGE: Python\nCODE:\n```\ndef my_inc(x: int | None) -> int:\n    return x + 1  # Error: Cannot add None and int\n```\n\nLANGUAGE: Python\nCODE:\n```\ndef my_inc(x: int | None) -> int:\n    if x is None:\n        return 0\n    else:\n        return x + 1\n```\n\n----------------------------------------\n\nTITLE: Defining Recursive Protocols for Tree-Like Structures in Python\nDESCRIPTION: Shows how to define a recursive protocol (`TreeLike`) where members (`left`, `right`) are annotated using the protocol type itself (or `None`). This pattern is essential for statically typing recursive data structures like trees or linked lists using structural subtyping. `SimpleTree` structurally conforms to `TreeLike`. Dependencies: `typing.Protocol`, `__future__.annotations`.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/protocols.rst#2025-04-22_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nfrom __future__ import annotations\n\nfrom typing import Protocol\n\nclass TreeLike(Protocol):\n    value: int\n\n    @property\n    def left(self) -> TreeLike | None: ...\n\n    @property\n    def right(self) -> TreeLike | None: ...\n\nclass SimpleTree:\n    def __init__(self, value: int) -> None:\n        self.value = value\n        self.left: SimpleTree | None = None\n        self.right: SimpleTree | None = None\n\nroot: TreeLike = SimpleTree(0)  # OK\n```\n\n----------------------------------------\n\nTITLE: Defining Collection Protocol (Sized, Iterable, Container) (Python)\nDESCRIPTION: Outlines the methods needed for the collections.abc.Collection protocol: __len__, __iter__, and __contains__. Used when defining custom collection types that should be compatible with built-in collection operations (iteration, len, membership).\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/protocols.rst#2025-04-22_snippet_17\n\nLANGUAGE: python\nCODE:\n```\ndef __len__(self) -> int\ndef __iter__(self) -> Iterator[T]\ndef __contains__(self, x: object) -> bool\n\n```\n\n----------------------------------------\n\nTITLE: Using Dataclasses with Type Annotations in Python\nDESCRIPTION: Demonstrates how to define and use dataclasses with proper type annotations in mypy. Shows basic usage with default values and custom field specifications.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/additional_features.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom dataclasses import dataclass, field\n\n@dataclass\nclass Application:\n    name: str\n    plugins: list[str] = field(default_factory=list)\n\ntest = Application(\"Testing...\")  # OK\nbad = Application(\"Testing...\", \"with plugin\")  # Error: list[str] expected\n```\n\n----------------------------------------\n\nTITLE: Handling Union Types in Python\nDESCRIPTION: Illustrates the use of union types in Python to allow flexibility in accepted argument types. Demonstrates runtime type narrowing through isinstance checks with Mypy for static type checking. Dependencies: None. Key parameters: x - demonstrates union type handling.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/kinds_of_types.rst#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\ndef f(x: int | str) -> None:\n    x + 1     # Error: str + int is not valid\n    if isinstance(x, int):\n        # Here type of x is int.\n        x + 1      # OK\n    else:\n        # Here type of x is str.\n        x + 'a'    # OK\n\nf(1)    # OK\nf('x')  # OK\nf(1.1)  # Error\n```\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Union\n\ndef f(x: Union[int, str]) -> None:\n    ...\n```\n\nLANGUAGE: python\nCODE:\n```\nfrom __future__ import annotations\n\ndef f(x: int | str) -> None:   # OK on Python 3.7 and later\n    ...\n```\n\n----------------------------------------\n\nTITLE: Declaring Class Variables Using ClassVar - Python\nDESCRIPTION: Shows use of typing.ClassVar to declare class-level attributes that should not be set on instances. Demonstrates initialization, assignment at the class level (allowed), and instance assignment (type error), emphasizing the impact of ClassVar in mypy and static analysis tools.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/class_basics.rst#2025-04-22_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import ClassVar\n\nclass A:\n    x: ClassVar[int] = 0  # Class variable only\n\nA.x += 1  # OK\n\na = A()\na.x = 1  # Error: Cannot assign to class variable \"x\" via instance\nprint(a.x)  # OK -- can be read through an instance\n```\n\n----------------------------------------\n\nTITLE: Mypy Errors for Missing Library Stubs\nDESCRIPTION: Illustrates the error messages produced by Mypy when it encounters imports from third-party libraries (like `yaml` or `requests`) that lack type hints or installed type stub packages. These errors indicate missing type information and suggest installing the corresponding `types-*` package.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/getting_started.rst#2025-04-22_snippet_9\n\nLANGUAGE: text\nCODE:\n```\nprog.py:1: error: Library stubs not installed for \"yaml\"\nprog.py:1: note: Hint: \"python3 -m pip install types-PyYAML\"\nprog.py:2: error: Library stubs not installed for \"requests\"\nprog.py:2: note: Hint: \"python3 -m pip install types-requests\"\n...\n```\n\n----------------------------------------\n\nTITLE: Defining and Instantiating a Generic Box Class (Python 3.12+ Syntax)\nDESCRIPTION: Defines a simple generic `Box` class using Python 3.12+ syntax. It demonstrates how Mypy infers the type argument during instantiation (e.g., `Box(1)` infers `Box[int]`) and performs type checking on constructor arguments when the type argument is explicit (`Box[int]('some string')` causes an error).\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/generics.rst#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nclass Box[T]:\n    def __init__(self, content: T) -> None:\n        self.content = content\n\nBox(1)       # OK, inferred type is Box[int]\nBox[int](1)  # Also OK\n\n# error: Argument 1 to \"Box\" has incompatible type \"str\"; expected \"int\"\nBox[int]('some string')\n```\n\n----------------------------------------\n\nTITLE: Using Mixin Classes with Protocol Self-Types\nDESCRIPTION: This example shows how to use protocols as self-types in mixin methods to enable code reusability. The Lockable protocol defines common functionality that host classes must implement.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/more_types.rst#2025-04-22_snippet_18\n\nLANGUAGE: python\nCODE:\n```\nclass Lockable(Protocol):\n    @property\n    def lock(self) -> Lock: ...\n\nclass AtomicCloseMixin:\n    def atomic_close(self: Lockable) -> int:\n        with self.lock:\n            # perform actions\n\nclass AtomicOpenMixin:\n    def atomic_open(self: Lockable) -> int:\n        with self.lock:\n            # perform actions\n\nclass File(AtomicCloseMixin, AtomicOpenMixin):\n    def __init__(self) -> None:\n        self.lock = Lock()\n\nclass Bad(AtomicCloseMixin):\n    pass\n\nf = File()\nb: Bad\nf.atomic_close()  # OK\nb.atomic_close()  # Error: Invalid self type for \"atomic_close\"\n```\n\n----------------------------------------\n\nTITLE: Using Ellipsis for Default Arguments in Python Overloads\nDESCRIPTION: Demonstrates using `...` (ellipsis) as a placeholder for default argument values within `@overload` definitions. This is useful because only the presence or absence of a default matters for the signature, not the specific value. The example shows two overload variants for `get_model` where the `flag` parameter has a default value indicated by `...`, followed by the actual implementation signature with a concrete default `flag: bool = True`.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/more_types.rst#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import overload\n\nclass M: ...\n\n@overload\ndef get_model(model_or_pk: M, flag: bool = ...) -> M: ...\n@overload\ndef get_model(model_or_pk: int, flag: bool = ...) -> M | None: ...\n\ndef get_model(model_or_pk: int | M, flag: bool = True) -> M | None:\n    ...\n```\n\n----------------------------------------\n\nTITLE: Check Modules or Strings with mypy - Shell\nDESCRIPTION: Illustrates multiple ways to invoke mypy from the command line: type checking source files, modules by name, and arbitrary code snippets passed with '-c'. These variations support flexible ad-hoc static analysis.\nSOURCE: https://github.com/python/mypy/blob/master/test-data/unit/README.md#2025-04-22_snippet_8\n\nLANGUAGE: shell\nCODE:\n```\npython3 -m mypy PROGRAM.py\n```\n\nLANGUAGE: shell\nCODE:\n```\npython3 -m mypy -m MODULE\n```\n\nLANGUAGE: shell\nCODE:\n```\npython3 -m mypy -c 'import MODULE'\n```\n\n----------------------------------------\n\nTITLE: Explicitly Annotating Variable Types with Python Type Hints\nDESCRIPTION: Illustrates overriding mypy's inferred type by providing an explicit annotation, using the union type syntax ('int | str', supported since Python 3.10). The example assigns an integer but declares the variable as a union of int or str, which allows future assignments of either type. Requires Python 3.10+ for 'int | str' syntax; otherwise, use 'Union[int, str]' from 'typing'.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/type_inference_and_annotations.rst#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nx: int | str = 1\n```\n\n----------------------------------------\n\nTITLE: Defining a Generic Stack Class (Legacy Syntax)\nDESCRIPTION: Defines a generic `Stack` class using the legacy syntax required for Python 3.11 and earlier. This involves importing `TypeVar` and `Generic` from the `typing` module, defining a type variable `T = TypeVar('T')`, and inheriting from `Generic[T]`.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/generics.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import TypeVar, Generic\n\nT = TypeVar('T')  # Define type variable \"T\"\n\nclass Stack(Generic[T]):\n    def __init__(self) -> None:\n        # Create an empty list with items of type T\n        self.items: list[T] = []\n\n    def push(self, item: T) -> None:\n        self.items.append(item)\n\n    def pop(self) -> T:\n        return self.items.pop()\n\n    def empty(self) -> bool:\n        return not self.items\n```\n\n----------------------------------------\n\nTITLE: Greet All with List Type Hint in Python\nDESCRIPTION: This Python function, 'greet_all', accepts a list of strings using a type hint. It demonstrates using a generic type to specify the types of elements within a list, ensuring type safety with Mypy.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/getting_started.rst#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\ndef greet_all(names: list[str]) -> None:\n    for name in names:\n        print('Hello ' + name)\n\nnames = [\"Alice\", \"Bob\", \"Charlie\"]\nages = [10, 20, 30]\n\ngreet_all(names)   # Ok!\ngreet_all(ages)    # Error due to incompatible types\n```\n\n----------------------------------------\n\nTITLE: Generic TypeGuards in Mypy\nDESCRIPTION: Illustrates the use of TypeGuards with generic types, applicable to Python 3.12 syntax, showcasing how runtime checks inform type narrowing and list processing.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/type_narrowing.rst#2025-04-22_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import TypeGuard  # use `typing_extensions` for `python<3.10`\n\ndef is_two_element_tuple[T](val: tuple[T, ...]) -> TypeGuard[tuple[T, T]]:\n    return len(val) == 2\n\ndef func(names: tuple[str, ...]):\n    if is_two_element_tuple(names):\n        reveal_type(names)  # tuple[str, str]\n    else:\n        reveal_type(names)  # tuple[str, ...]\n```\n\n----------------------------------------\n\nTITLE: Defining Iterator Protocol with __next__ and __iter__ (Python)\nDESCRIPTION: Provides the essential methods (__next__ and __iter__) that make a class compatible with collections.abc.Iterator. __next__ yields values of type T; __iter__ returns self or compatible iterator. Used for custom iterator implementations and compatible with Python iteration constructs.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/protocols.rst#2025-04-22_snippet_14\n\nLANGUAGE: python\nCODE:\n```\ndef __next__(self) -> T\ndef __iter__(self) -> Iterator[T]\n\n```\n\n----------------------------------------\n\nTITLE: Normalize ID with Union Type Hint in Python\nDESCRIPTION: This Python function, 'normalize_id', demonstrates using a union type (int | str) to accept multiple types for a single parameter. It shows how Mypy handles type variations within conditional logic.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/getting_started.rst#2025-04-22_snippet_6\n\nLANGUAGE: python\nCODE:\n```\ndef normalize_id(user_id: int | str) -> str:\n    if isinstance(user_id, int):\n        return f'user-{100_000 + user_id}'\n    else:\n        return user_id\n```\n\n----------------------------------------\n\nTITLE: Defining a Simple Custom Protocol `SupportsClose` in Python\nDESCRIPTION: Defines a custom protocol `SupportsClose` using `typing.Protocol` which requires a `close` method. It shows how a class `Resource` structurally conforms to this protocol by having a matching `close` method, without explicitly inheriting `SupportsClose`. This allows instances of `Resource` and file objects from `open()` to be used with the `close_all` function. Dependencies include `typing.Protocol` and `collections.abc.Iterable`.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/protocols.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom collections.abc import Iterable\nfrom typing import Protocol\n\nclass SupportsClose(Protocol):\n    # Empty method body (explicit '...')\n    def close(self) -> None: ...\n\nclass Resource:  # No SupportsClose base class!\n\n    def close(self) -> None:\n       self.resource.release()\n\n    # ... other methods ...\n\ndef close_all(items: Iterable[SupportsClose]) -> None:\n    for item in items:\n        item.close()\n\nclose_all([Resource(), open('some/file')])  # OK\n```\n\n----------------------------------------\n\nTITLE: Explicitly Annotating Empty List and Dictionary Types in Python\nDESCRIPTION: Shows how to assign type annotations to empty lists and dictionaries so that mypy can correctly infer their types. Uses modern type hint syntax; for Python <3.9, use List and Dict from 'typing.' Ensures correct static type checking for collections.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/type_inference_and_annotations.rst#2025-04-22_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nl: list[int] = []       # Create empty list of int\\nd: dict[str, int] = {}  # Create empty dictionary (str -> int)\n```\n\n----------------------------------------\n\nTITLE: Type Checking a Module with mypy - Bash\nDESCRIPTION: Invokes mypy to type check a specified module using the -m flag, which takes the module's importable name. This command requires mypy, and the module must be importable within the current Python environment. The result is a type check of the named module and its dependencies.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/running_mypy.rst#2025-04-22_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n$ mypy -m html.parser\n```\n\n----------------------------------------\n\nTITLE: Generic TypeIs Function for Tuple Shape - Python\nDESCRIPTION: This snippet provides an example of a generic TypeIs function for narrowing tuple shapes. is_two_element_tuple uses a TypeVar to check if a tuple matches a fixed length (2), narrowing the type to exactly two elements when true. The process function shows how the type checker refines the input accordingly. Requires TypeIs (Python 3.13+ or typing_extensions) and familiarity with TypeVar.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/type_narrowing.rst#2025-04-22_snippet_15\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import TypeVar, TypeIs\n\nT = TypeVar('T')\n\ndef is_two_element_tuple(val: tuple[T, ...]) -> TypeIs[tuple[T, T]]:\n    return len(val) == 2\n\ndef process(names: tuple[str, ...]) -> None:\n    if is_two_element_tuple(names):\n        reveal_type(names)  # Revealed type is 'tuple[str, str]'\n    else:\n        reveal_type(names)  # Revealed type is 'tuple[str, ...]'\n```\n\n----------------------------------------\n\nTITLE: Implementing Tagged Unions with Literal Types and TypedDict in Python\nDESCRIPTION: Demonstrates how to use Literal types to create tagged unions with TypedDicts. This pattern enables type-safe discrimination between different TypedDict structures based on a tag field with a specific literal value.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/literal_types.rst#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Literal, TypedDict, Union\n\nclass NewJobEvent(TypedDict):\n    tag: Literal[\"new-job\"]\n    job_name: str\n    config_file_path: str\n\nclass CancelJobEvent(TypedDict):\n    tag: Literal[\"cancel-job\"]\n    job_id: int\n\nEvent = Union[NewJobEvent, CancelJobEvent]\n\ndef process_event(event: Event) -> None:\n    # Since we made sure both TypedDicts have a key named 'tag', it's\n    # safe to do 'event[\"tag\"]'. This expression normally has the type\n    # Literal[\"new-job\", \"cancel-job\"], but the check below will narrow\n    # the type to either Literal[\"new-job\"] or Literal[\"cancel-job\"].\n    #\n    # This in turns narrows the type of 'event' to either NewJobEvent\n    # or CancelJobEvent.\n    if event[\"tag\"] == \"new-job\":\n        print(event[\"job_name\"])\n    else:\n        print(event[\"job_id\"])\n```\n\n----------------------------------------\n\nTITLE: Declaring a TypedDict and Annotating Objects - Python\nDESCRIPTION: Shows how to define a TypedDict type named 'Movie' with explicit structure and use it for strict type checking of a variable. Uses 'from typing import TypedDict', which requires 'typing_extensions' for Python <3.8. The 'Movie' type enforces 'name' as str and 'year' as int. The variable 'movie' is annotated as a Movie and initialized with correct values; incompatible types or missing keys will be detected by type checkers such as mypy.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/typed_dict.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import TypedDict\n\nMovie = TypedDict('Movie', {'name': str, 'year': int})\n\nmovie: Movie = {'name': 'Blade Runner', 'year': 1982}\n```\n\n----------------------------------------\n\nTITLE: Illustrating Valid and Invalid Variable Redefinition Rules in Mypy (Python)\nDESCRIPTION: This Python code demonstrates the conditions under which the `allow_redefinition` Mypy option permits variable type changes. The first redefinition of `items` to a `str` is invalid because the variable hasn't been used yet. Subsequent redefinitions to `str` and then `int` are valid because the variable is used between them. This highlights the requirement that a variable must be used before its type can be redefined within the same block and nesting level.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/config_file.rst#2025-04-22_snippet_9\n\nLANGUAGE: python\nCODE:\n```\ndef process(items: list[str]) -> None:\n   items = \"mypy\"  # invalid redefinition to str because the variable hasn't been used yet\n   print(items)\n   items = \"100\"  # valid, items now has type str\n   items = int(items)  # valid, items now has type int\n```\n\n----------------------------------------\n\nTITLE: Detecting Shadowed Overload Variants in Python\nDESCRIPTION: Illustrates a scenario where one overload variant shadows another, preventing the shadowed variant from ever being selected by Mypy. This occurs when a more general variant (accepting `Expression`) is defined before a more specific one (accepting `Literal`, a subtype of `Expression`). Mypy issues a warning because the second variant is unreachable during type checking.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/more_types.rst#2025-04-22_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import overload\n\nclass Expression:\n    # ...snip...\n\nclass Literal(Expression):\n    # ...snip...\n\n# Warning -- the first overload variant shadows the second!\n\n@overload\ndef add(left: Expression, right: Expression) -> Expression: ...\n\n@overload\ndef add(left: Literal, right: Literal) -> Literal: ...\n\ndef add(left: Expression, right: Expression) -> Expression:\n    # ...snip...\n```\n\n----------------------------------------\n\nTITLE: Instantiating and Using a Generic Stack\nDESCRIPTION: Demonstrates how to instantiate and use the generic `Stack` class. It shows creating a `Stack[int]`, using its `push` and `pop` methods, and illustrates a Mypy type error when attempting to push an item of an incompatible type (`str` into a `Stack[int]`). It also shows creating a `Stack[str]`.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/generics.rst#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n# Construct an empty Stack[int] instance\nstack = Stack[int]()\nstack.push(2)\nstack.pop()\n\n# error: Argument 1 to \"push\" of \"Stack\" has incompatible type \"str\"; expected \"int\"\nstack.push('x')\n\nstack2: Stack[str] = Stack()\nstack2.append('x')\n```\n\n----------------------------------------\n\nTITLE: Using Built-in Generics for Type Hinting in Python\nDESCRIPTION: Demonstrates the use of built-in collection types (`list`, `dict`) and types from `collections.abc` (`Sequence`) as generic type hints in Python, eliminating the need for `typing.List`, `typing.Dict`, etc. This syntax is standard in Python 3.9+ and can be used in Python 3.7+ with `from __future__ import annotations`, though runtime compatibility caveats exist.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/runtime_troubles.rst#2025-04-22_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nfrom collections.abc import Sequence\nx: list[str]\ny: dict[int, str]\nz: Sequence[str] = x\n```\n\n----------------------------------------\n\nTITLE: Using dataclass_transform with Python 3.12 Syntax\nDESCRIPTION: Shows how to use the dataclass_transform decorator to make mypy recognize custom wrappers of dataclass as dataclass decorators, using Python 3.12 generic syntax.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/additional_features.rst#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom dataclasses import dataclass, Field\nfrom typing import dataclass_transform\n\n@dataclass_transform(field_specifiers=(Field,))\ndef my_dataclass[T](cls: type[T]) -> type[T]:\n    ...\n    return dataclass(cls)\n```\n\n----------------------------------------\n\nTITLE: Differentiating Callable Instance and Class Variables Using ClassVar - Python\nDESCRIPTION: Shows the use of Callable and ClassVar annotations to distinguish between instance and class-level callable attributes. Highlights mypy's ability to check call signatures and flag incorrect usage, especially with callables and method binding.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/class_basics.rst#2025-04-22_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nfrom collections.abc import Callable\nfrom typing import ClassVar\n\nclass A:\n    foo: Callable[[int], None]\n    bar: ClassVar[Callable[[A, int], None]]\n    bad: Callable[[A], None]\n\nA().foo(42)  # OK\nA().bar(42)  # OK\nA().bad()  # Error: Too few arguments\n```\n\n----------------------------------------\n\nTITLE: Defining Subclasses of Generic Classes (Python 3.12+ Syntax)\nDESCRIPTION: Illustrates creating subclasses from generic types using Python 3.12+ syntax. Examples include defining a generic subclass `MyMap[KT, VT]` inheriting from `Mapping[KT, VT]`, a non-generic subclass `StrDict` inheriting from a specific generic instantiation `dict[str, str]`, and a generic subclass `AdvancedReceiver[T]` inheriting from a user-defined generic class `Receiver[T]`.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/generics.rst#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Mapping, Iterator\n\n# This is a generic subclass of Mapping\nclass MyMap[KT, VT](Mapping[KT, VT]):\n    def __getitem__(self, k: KT) -> VT: ...\n    def __iter__(self) -> Iterator[KT]: ...\n    def __len__(self) -> int: ...\n\nitems: MyMap[str, int]  # OK\n\n# This is a non-generic subclass of dict\nclass StrDict(dict[str, str]):\n    def __str__(self) -> str:\n        return f'StrDict({super().__str__()})'\n\ndata: StrDict[int, int]  # Error! StrDict is not generic\ndata2: StrDict  # OK\n\n# This is a user-defined generic class\nclass Receiver[T]:\n    def accept(self, value: T) -> None: ...\n\n# This is a generic subclass of Receiver\nclass AdvancedReceiver[T](Receiver[T]): ...\n```\n\n----------------------------------------\n\nTITLE: Defining Subprotocols and Multiple Inheritance in Python Protocols\nDESCRIPTION: Illustrates creating subprotocols by inheriting from existing protocols (`SupportsClose`, `SupportsRead`) and `typing.Protocol`. The `TaggedReadableResource` protocol combines requirements from its bases and adds its own (`label`). Demonstrates how `AdvancedResource` implements this combined protocol structurally. Dependencies include `typing.Protocol` and previously defined `SupportsClose` and `Resource`.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/protocols.rst#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n# ... continuing from the previous example\n\nclass SupportsRead(Protocol):\n    def read(self, amount: int) -> bytes: ...\n\nclass TaggedReadableResource(SupportsClose, SupportsRead, Protocol):\n    label: str\n\nclass AdvancedResource(Resource):\n    def __init__(self, label: str) -> None:\n        self.label = label\n\n    def read(self, amount: int) -> bytes:\n        # some implementation\n        ...\n\nresource: TaggedReadableResource\nresource = AdvancedResource('handle with care')  # OK\n```\n\n----------------------------------------\n\nTITLE: Adopting Strict Type Checking Configuration - Mypy Config - Text\nDESCRIPTION: This config file snippet demonstrates a set of recommended strictness options for mypy, equivalent to using the '--strict' command-line flag as of mypy 1.0. It enables warnings for unused configs, redundant casts, and ignores; enforces strict equality and checking of untyped defs; restricts the use of untyped code; and sets stricter type requirement policies on subclassing, annotation coverage, and return types. Each line is an option in mypy's config file (plain INI/CFG or part of a tool table in pyproject.toml). Intended for gradual enabling to raise the codebase's type safety. No direct parameters; affects all files unless constrained by other config sections. Limitation: may require significant code changes to satisfy stricter rules.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/existing_code.rst#2025-04-22_snippet_5\n\nLANGUAGE: text\nCODE:\n```\n# Start off with these\nwarn_unused_configs = True\nwarn_redundant_casts = True\nwarn_unused_ignores = True\n\n# Getting this passing should be easy\nstrict_equality = True\n\n# Strongly recommend enabling this one as soon as you can\ncheck_untyped_defs = True\n\n# These shouldn't be too much additional work, but may be tricky to\n# get passing if you use a lot of untyped libraries\ndisallow_subclassing_any = True\ndisallow_untyped_decorators = True\ndisallow_any_generics = True\n\n# These next few are various gradations of forcing use of type annotations\ndisallow_untyped_calls = True\ndisallow_incomplete_defs = True\ndisallow_untyped_defs = True\n\n# This one isn't too hard to get passing, but return on investment is lower\nno_implicit_reexport = True\n\n# This one can be tricky to get passing if you use a lot of untyped libraries\nwarn_return_any = True\n\n# This one is a catch-all flag for the rest of strict checks that are technically\n# correct but may not be practical\nextra_checks = True\n```\n\n----------------------------------------\n\nTITLE: Disabling 'import-untyped' Error Code Globally (TOML for pyproject.toml)\nDESCRIPTION: This snippet illustrates how to suppress all 'import-untyped' errors by modifying the [tool.mypy] section in pyproject.toml. By assigning 'disable_error_code = [\"import-untyped\"]', mypy will ignore missing type hints for all unresolved or untyped imports throughout the codebase. Appropriate for use in monorepo or multi-package Python projects with pyproject.toml central configuration.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/running_mypy.rst#2025-04-22_snippet_15\n\nLANGUAGE: ini\nCODE:\n```\n[tool.mypy]\\ndisable_error_code = [\"import-untyped\"]\n```\n\n----------------------------------------\n\nTITLE: Type Narrowing with TypeIs Function - Python\nDESCRIPTION: This snippet shows the use of a TypeIs narrowing function in Python. is_str accepts an object and checks whether it is a string using isinstance, returning TypeIs[str]. The process function demonstrates type refinement logic for if and else branches. This requires Python 3.13 or the typing_extensions backport, and the TypeIs construct requires that the narrowed type T be compatible with the input type.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/type_narrowing.rst#2025-04-22_snippet_13\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import TypeIs\n\ndef is_str(x: object) -> TypeIs[str]:\n    return isinstance(x, str)\n\ndef process(x: int | str) -> None:\n    if is_str(x):\n        reveal_type(x)  # Revealed type is 'str'\n        print(x.upper())  # Valid: x is str\n    else:\n        reveal_type(x)  # Revealed type is 'int'\n        print(x + 1)  # Valid: x is int\n```\n\n----------------------------------------\n\nTITLE: Passing a TypedDict to a Mapping-Typed Function - Python\nDESCRIPTION: Shows how a TypedDict instance can be passed to a function that expects a Mapping[str, object], leveraging TypedDict's compatibility with Mapping. Demonstrates both function definition and call with an inline-constructed TypedDict instance. Dependencies: from typing import Mapping and the previously defined Movie TypedDict.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/typed_dict.rst#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\ndef print_typed_dict(obj: Mapping[str, object]) -> None:\n    for key, value in obj.items():\n        print(f'{key}: {value}')\n\nprint_typed_dict(Movie(name='Toy Story', year=1995))  # OK\n```\n\n----------------------------------------\n\nTITLE: Using Final to Create Context-Sensitive Literal Types in Python\nDESCRIPTION: Demonstrates how to use Final to create context-sensitive literal types without explicitly repeating the value in a Literal annotation. Shows how this approach can simplify type annotations while maintaining type precision.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/literal_types.rst#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Final, Literal\n\ndef expects_literal(x: Literal[19]) -> None: pass\n\nc: Final = 19\n\nreveal_type(c)          # Revealed type is \"Literal[19]?\"\nexpects_literal(c)      # ...and this type checks!\n```\n\n----------------------------------------\n\nTITLE: Customizing Mypy Error Reporting using INI Configuration Files\nDESCRIPTION: Shows how to silence or customize mypy error reporting on a per-module/package basis by editing the configuration file. Options included are ignoring all errors, disabling specific error codes, and silencing import errors. Configuration uses standard INI file format and is typically placed in 'mypy.ini' or 'setup.cfg'.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/type_inference_and_annotations.rst#2025-04-22_snippet_18\n\nLANGUAGE: ini\nCODE:\n```\n# Don't report errors in the 'package_to_fix_later' package\\n[mypy-package_to_fix_later.*]\\nignore_errors = True\\n\\n# Disable specific error codes in the 'tests' package\\n# Also don't require type annotations\\n[mypy-tests.*]\\ndisable_error_code = var-annotated, has-type\\nallow_untyped_defs = True\\n\\n# Silence import errors from the 'library_missing_types' package\\n[mypy-library_missing_types.*]\\nignore_missing_imports = True\n```\n\n----------------------------------------\n\nTITLE: Declaring and Enforcing Final Attributes with Typing Final in Python\nDESCRIPTION: This snippet demonstrates how to declare constants and final class-level attributes using typing.Final so that mypy will enforce single assignment and prevent reassignment or overrides in subclasses. Dependencies include Python 3.8+ (or typing_extensions for earlier versions) and mypy type checking. The constants RATE and DEFAULT_ID are both protected by Final, and further assignment to these names triggers a static analysis error. Inputs are type-annotations and assignments; improper modifications yield type errors.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/final_attrs.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Final\n\nRATE: Final = 3_000\n\nclass Base:\n    DEFAULT_ID: Final = 0\n\nRATE = 300  # Error: can't assign to final attribute\nBase.DEFAULT_ID = 1  # Error: can't override a final attribute\n```\n\n----------------------------------------\n\nTITLE: Defining a Generic Stack Class (Python 3.12+ Syntax)\nDESCRIPTION: Defines a generic `Stack` class using the PEP 695 syntax introduced in Python 3.12. It declares a type parameter `T` directly in the class definition (`class Stack[T]:`) and uses it to type the internal `items` list (`list[T]`).\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/generics.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nclass Stack[T]:\n    def __init__(self) -> None:\n        # Create an empty list with items of type T\n        self.items: list[T] = []\n\n    def push(self, item: T) -> None:\n        self.items.append(item)\n\n    def pop(self) -> T:\n        return self.items.pop()\n\n    def empty(self) -> bool:\n        return not self.items\n```\n\n----------------------------------------\n\nTITLE: Mypy Error Detection with assert_never for Enum Type in Python\nDESCRIPTION: This example shows Mypy reporting an error when the `choose_direction` function fails to handle all members of the `Direction` Enum (the `Direction.down` case is missing). The `assert_never(direction)` call becomes reachable for the unhandled enum member, triggering a Mypy error.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/literal_types.rst#2025-04-22_snippet_18\n\nLANGUAGE: python\nCODE:\n```\ndef choose_direction(direction: Direction) -> None:\n    if direction == Direction.up:\n        print('Going up!')\n        return\n    assert_never(direction)  # E: Argument 1 to \"assert_never\" has incompatible type \"Direction\"; expected \"NoReturn\"\n```\n\n----------------------------------------\n\nTITLE: Simplifying Generic Self Types with typing.Self\nDESCRIPTION: This Python snippet demonstrates the use of the typing.Self feature introduced in PEP 673 to simplify defining generic methods. It eliminates the need for explicit type parameters when the self type is the current class, as shown in a factory method creating paired Friend objects.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/generics.rst#2025-04-22_snippet_20\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Self\n\nclass Friend:\n    other: Self | None = None\n\n    @classmethod\n    def make_pair(cls) -> tuple[Self, Self]:\n        a, b = cls(), cls()\n        a.other = b\n        b.other = a\n        return a, b\n\nclass SuperFriend(Friend):\n    pass\n\na, b = SuperFriend.make_pair()\n```\n\n----------------------------------------\n\nTITLE: Mixing Required and Non-Required Items in TypedDict via Inheritance - Python\nDESCRIPTION: Shows how to use TypedDict inheritance and 'total=False' to mix required (from the base class) and non-required (from the subclass) fields. The base class MovieBase has required fields, while the subclass Movie adds an optional 'based_on' field. This pattern enables more granular requirements in typed dictionaries.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/typed_dict.rst#2025-04-22_snippet_12\n\nLANGUAGE: python\nCODE:\n```\nclass MovieBase(TypedDict):\n    name: str\n    year: int\n\nclass Movie(MovieBase, total=False):\n    based_on: str\n```\n\n----------------------------------------\n\nTITLE: TypedDict ReadOnly Subtyping and Covariant Assignment - Python\nDESCRIPTION: Shows how a TypedDict with mutable fields can be assigned to a TypedDict with corresponding ReadOnly fields because the assignment is covariant. Demonstrates class definitions and a function accepting the read-only variant. Requires 'from typing_extensions import ReadOnly' or Python 3.13+.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/typed_dict.rst#2025-04-22_snippet_14\n\nLANGUAGE: python\nCODE:\n```\nclass Entry(TypedDict):\n    name: ReadOnly[str | None]\n    year: ReadOnly[int]\n\nclass Movie(TypedDict):\n    name: str\n    year: int\n\ndef process_entry(i: Entry) -> None: ...\n\nm: Movie = {\"name\": \"Jaws\", \"year\": 1975}\nprocess_entry(m)  # OK\n```\n\n----------------------------------------\n\nTITLE: Covariance and Contravariance in Python Generics\nDESCRIPTION: This snippet provides examples of covariance and contravariance in Python generics using collection interfaces. It shows how generic classes like Sequence and Callable handle subtype relationships differently, using the shape hierarchy for illustration.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/generics.rst#2025-04-22_snippet_21\n\nLANGUAGE: python\nCODE:\n```\n# We'll use these classes in the examples below\nclass Shape: ...\nclass Triangle(Shape): ...\nclass Square(Shape): ...\n\ndef count_lines(shapes: Sequence[Shape]) -> int:\n    return sum(shape.num_sides for shape in shapes)\n\ntriangles: Sequence[Triangle]\ncount_lines(triangles)  # OK\n\ndef foo(triangle: Triangle, num: int) -> None:\n    shape_or_number: Union[Shape, int]\n    # a Triangle is a Shape, and a Shape is a valid Union[Shape, int]\n    shape_or_number = triangle\n\n# Callable contravariance example\n\ndef cost_of_paint_required(\n    triangle: Triangle,\n    area_calculator: Callable[[Triangle], float]\n) -> float:\n    return area_calculator(triangle) * DOLLAR_PER_SQ_FT\n\ndef area_of_triangle(triangle: Triangle) -> float: ...\ncost_of_paint_required(triangle, area_of_triangle)  # OK\n\ndef area_of_any_shape(shape: Shape) -> float: ...\ncost_of_paint_required(triangle, area_of_any_shape)  # OK\n```\n\n----------------------------------------\n\nTITLE: Named Tuples in Python with Mypy\nDESCRIPTION: Details how to define and use named tuples in Python with types using Mypy. It contrasts the standard 'namedtuple' with 'NamedTuple' from 'typing', highlighting the ability to define item types for better type checking. Demonstrates defining named tuples with both tuple-based and class-based syntax.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/kinds_of_types.rst#2025-04-22_snippet_13\n\nLANGUAGE: Python\nCODE:\n```\nPoint = namedtuple('Point', ['x', 'y'])\np = Point(x=1, y=2)\nprint(p.z)  # Error: Point has no attribute 'z'\n```\n\nLANGUAGE: Python\nCODE:\n```\nfrom typing import NamedTuple\n\nPoint = NamedTuple('Point', [('x', int),\n                             ('y', int)])\np = Point(x=1, y='x')  # Argument has incompatible type \"str\"; expected \"int\"\n```\n\nLANGUAGE: Python\nCODE:\n```\nfrom typing import NamedTuple\n\nclass Point(NamedTuple):\n    x: int\n    y: int\n\np = Point(x=1, y='x')  # Argument has incompatible type \"str\"; expected \"int\"\n```\n\n----------------------------------------\n\nTITLE: Type Annotating Instance Variables inside Methods - Python\nDESCRIPTION: Shows how to provide type annotations for instance variables within method bodies, including the use of self for assignment. Mypy uses these annotations to check types of attributes defined dynamically in methods. This is standard for dynamic attribute addition, but mypy requires explicit assignment for type tracking.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/class_basics.rst#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nclass A:\n    def __init__(self) -> None:\n        self.x: list[int] = []\n\n    def f(self) -> None:\n        self.y: Any = 0\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Non-Re-exporting Import with `implicit_reexport=False` in Mypy (Python)\nDESCRIPTION: This Python code snippet illustrates the behavior when the `implicit_reexport` Mypy configuration option is set to `False`. A simple import like `from foo import bar` does not re-export the `bar` identifier, meaning other modules cannot import `bar` from this module.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/config_file.rst#2025-04-22_snippet_10\n\nLANGUAGE: python\nCODE:\n```\n# This won't re-export the value\nfrom foo import bar\n```\n\n----------------------------------------\n\nTITLE: Type Narrowing with TypeGuard (TypeIs Comparison) - Python\nDESCRIPTION: This code demonstrates a similar pattern to TypeIs, but with TypeGuard as the return type. The is_str function returns a TypeGuard for str, and the type narrowing only occurs in the if branch, not the else. The process function again distinguishes behavior based on the type of x. The snippet clarifies the difference in type inference between TypeIs and TypeGuard. Requires Python 3.10+ or typing_extensions for TypeGuard.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/type_narrowing.rst#2025-04-22_snippet_14\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import TypeGuard, reveal_type\n\ndef is_str(x: object) -> TypeGuard[str]:\n    return isinstance(x, str)\n\ndef process(x: int | str) -> None:\n    if is_str(x):\n        reveal_type(x)  # Revealed type is \"builtins.str\"\n        print(x.upper())  # ok: x is str\n    else:\n        reveal_type(x)  # Revealed type is \"Union[builtins.int, builtins.str]\"\n        print(x + 1)  # ERROR: Unsupported operand types for + (\"str\" and \"int\")  [operator]\n```\n\n----------------------------------------\n\nTITLE: Defining Parent-Child Relationship with TypeGuard - Python\nDESCRIPTION: This snippet demonstrates how to use TypeGuard to distinguish between a Parent and its Child subclass for type narrowing purposes in Python with Mypy. It includes the definition of two classes (Parent and Child), a type guard function is_child, and reveals how the type checker refines types based on the guard. The is_child function depends on the correct isinstance logic and requires at least Python 3.10 or typing_extensions for earlier versions.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/type_narrowing.rst#2025-04-22_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nclass Parent:\n    def method(self) -> None:\n        reveal_type(self)  # Revealed type is \"Parent\"\n        if is_child(self):\n            reveal_type(self)  # Revealed type is \"Child\"\n\nclass Child(Parent):\n    ...\n\ndef is_child(instance: Parent) -> TypeGuard[Child]:\n    return isinstance(instance, Child)\n```\n\n----------------------------------------\n\nTITLE: Type Annotating Function Parameters Using Abstract Base Classes - Python\nDESCRIPTION: Defines a function that accepts iterables of Animal ABCs, demonstrating the use of ABCs as type annotations. Shows how static typing supports flexible input types while ensuring that abstract methods are implemented in subclasses. Requires from typing import Iterable and mypy for static checking.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/class_basics.rst#2025-04-22_snippet_14\n\nLANGUAGE: python\nCODE:\n```\ndef feed_all(animals: Iterable[Animal], food: str) -> None:\n    for animal in animals:\n        animal.eat(food)\n```\n\n----------------------------------------\n\nTITLE: Using Standard Library Types with Mypy in Python\nDESCRIPTION: Demonstrates how Mypy inherently understands and type checks code using types from the Python standard library, such as `pathlib.Path`. The example shows Mypy verifying method calls (`read_text`) and string operations based on the type hints.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/getting_started.rst#2025-04-22_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nfrom pathlib import Path\n\ndef load_template(template_path: Path, name: str) -> str:\n    # Mypy knows that `template_path` has a `read_text` method that returns a str\n    template = template_path.read_text()\n    # ...so it understands this line type checks\n    return template.replace('USERNAME', name)\n```\n\n----------------------------------------\n\nTITLE: Implementing Forward References in Python Type Annotations\nDESCRIPTION: Shows how to reference a class in type annotations before it is defined using either __future__ annotations or string literal annotations.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/cheat_sheet_py3.rst#2025-04-22_snippet_9\n\nLANGUAGE: python\nCODE:\n```\n# You may want to reference a class before it is defined.\n# This is known as a \"forward reference\".\ndef f(foo: A) -> int:  # This will fail at runtime with 'A' is not defined\n    ...\n\n# However, if you add the following special import:\nfrom __future__ import annotations\n# It will work at runtime and type checking will succeed as long as there\n# is a class of that name later on in the file\ndef f(foo: A) -> int:  # Ok\n    ...\n\n# Another option is to just put the type in quotes\ndef f(foo: 'A') -> int:  # Also ok\n    ...\n\nclass A:\n    # This can also come up if you need to reference a class in a type\n    # annotation inside the definition of that class\n    @classmethod\n    def create(cls) -> A:\n        ...\n```\n\n----------------------------------------\n\nTITLE: Excluding Types in Mypy with isinstance\nDESCRIPTION: Using isinstance to exclude types from a union type inside a function to provide more specific type inference.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/type_narrowing.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ndef function(arg: int | str):\n    if isinstance(arg, int):\n        return\n\n    # `arg` can't be `int` at this point:\n    reveal_type(arg)  # Revealed type: \"builtins.str\"\n```\n\n----------------------------------------\n\nTITLE: Annotating __init__ Methods for Constructors - Python\nDESCRIPTION: Provides examples of annotating the __init__ constructor in Python with and without explicit return type, as allowed by mypy if at least one argument is annotated. Proper annotation of __init__ ensures type checking by mypy, while lack of annotation disables type checking for the method body.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/class_basics.rst#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nclass C1:\n    def __init__(self) -> None:\n        self.var = 42\n\nclass C2:\n    def __init__(self, arg: int):\n        self.var = arg\n```\n\n----------------------------------------\n\nTITLE: Decorator with Parameter Specification (**P) Syntax - Python 3.12+\nDESCRIPTION: Illustrates using parameter specification (**P) syntax in Python 3.12+ to write decorators that exactly preserve the wrapped function's signature. The decorator is annotated so that both positional and keyword arguments, as well as output type T, are maintained. Key dependencies: collections.abc.Callable. Enables robust function signature preservation.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/generics.rst#2025-04-22_snippet_37\n\nLANGUAGE: python\nCODE:\n```\nfrom collections.abc import Callable\n\ndef printing_decorator[**P, T](func: Callable[P, T]) -> Callable[P, T]:\n    def wrapper(*args: P.args, **kwds: P.kwargs) -> T:\n        print(\"Calling\", func)\n        return func(*args, **kwds)\n    return wrapper\n```\n\n----------------------------------------\n\nTITLE: Defining Callback Protocols with Positional-Only Parameters (Python)\nDESCRIPTION: Shows creation and compatibility of Protocols and Callable types with positional-only parameters. It introduces a Copy protocol using the '/' marker for positional-only, making it compatible with typical Callable signatures. Dependencies: Python 3.8+, typing, collections.abc. Essential for ensuring positional parameter compatibility in callback signatures in static typing.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/protocols.rst#2025-04-22_snippet_12\n\nLANGUAGE: python\nCODE:\n```\nfrom collections.abc import Callable\nfrom typing import Protocol, TypeVar\n\nT = TypeVar('T')\n\nclass Copy(Protocol):\n    # '/' marks the end of positional-only parameters\n    def __call__(self, origin: T, /) -> T: ...\n\ncopy_a: Callable[[T], T]\ncopy_b: Copy\n\ncopy_a = copy_b  # OK\ncopy_b = copy_a  # Also OK\n\n```\n\n----------------------------------------\n\nTITLE: Creating a Decorator that Adds Parameters with Concatenate (Python 3.11)\nDESCRIPTION: Legacy version of the printing_decorator that adds a new parameter to the decorated function using Concatenate with ParamSpec and TypeVar for Python 3.11 and earlier.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/generics.rst#2025-04-22_snippet_42\n\nLANGUAGE: python\nCODE:\n```\nfrom collections.abc import Callable\nfrom typing import TypeVar\nfrom typing_extensions import Concatenate, ParamSpec\n\nP = ParamSpec('P')\nT = TypeVar('T')\n\ndef printing_decorator(func: Callable[P, T]) -> Callable[Concatenate[str, P], T]:\n    def wrapper(msg: str, /, *args: P.args, **kwds: P.kwargs) -> T:\n        print(\"Calling\", func, \"with\", msg)\n        return func(*args, **kwds)\n    return wrapper\n```\n\n----------------------------------------\n\nTITLE: Defining a Value-Restricted Type Variable for concat Function - Python 3.12+\nDESCRIPTION: Defines a function concat using a type variable S constrained to str or bytes, so only those types and subtypes are allowed. Enforces that both arguments and the return type must be of the same (str or bytes), and prevents cross-type invocation. No external dependencies. Demonstrates input restrictions clearly.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/generics.rst#2025-04-22_snippet_26\n\nLANGUAGE: python\nCODE:\n```\ndef concat[S: (str, bytes)](x: S, y: S) -> S:\n    return x + y\n\nconcat('a', 'b')    # Okay\nconcat(b'a', b'b')  # Okay\nconcat(1, 2)        # Error!\n```\n\n----------------------------------------\n\nTITLE: Creating New Types with NewType in Python\nDESCRIPTION: Illustrates the creation of new distinct types with NewType which has minimal runtime overhead. This method helps prevent runtime errors by distinguishing types statically at compile-time while treating them as equivalent at runtime.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/more_types.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import NewType\n\nUserId = NewType('UserId', int)\n\ndef name_by_id(user_id: UserId) -> str:\n    ...\n\nUserId('user')  # Fails type check\n\nname_by_id(42)  # Fails type check\nname_by_id(UserId(42))  # OK\n\nnum: int = UserId(5) + 1\n```\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import NewType\n\nclass PacketId:\n    def __init__(self, major: int, minor: int) -> None:\n        self._major = major\n        self._minor = minor\n\nTcpPacketId = NewType('TcpPacketId', PacketId)\n\npacket = PacketId(100, 100)\ntcp_packet = TcpPacketId(packet)  # OK\n\ntcp_packet = TcpPacketId(127, 0)  # Fails in type checker and at runtime\n```\n\n----------------------------------------\n\nTITLE: Ensuring variable annotations when type is unclear with Mypy\nDESCRIPTION: Illustrates the need for explicit type annotations when Mypy cannot infer a type, such as empty collections or None defaults. It requires type annotations when initialization doesn't hint element types. An example transitions from an error to a correct annotation.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/error_code_list.rst#2025-04-22_snippet_8\n\nLANGUAGE: Python\nCODE:\n```\n    class Bundle:\n        def __init__(self) -> None:\n            # Error: Need type annotation for \"items\"\n            #        (hint: \"items: list[<type>] = ...\")  [var-annotated]\n            self.items = []\n\n    reveal_type(Bundle().items)  # list[Any]\n```\n\nLANGUAGE: Python\nCODE:\n```\n    class Bundle:\n        def __init__(self) -> None:\n            self.items: list[str] = []  # OK\n\n   reveal_type(Bundle().items)  # list[str]\n```\n\n----------------------------------------\n\nTITLE: Narrowing Types Based on Inner Attribute Check in Python\nDESCRIPTION: This snippet demonstrates how Mypy can narrow the type of a wrapper object `w` by checking the type of its inner attribute `w.inner` using `isinstance`. The `reveal_type` function shows the inferred type within each branch of the conditional.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/literal_types.rst#2025-04-22_snippet_7\n\nLANGUAGE: python\nCODE:\n```\n# runtime in a way `isinstance` can always check.\n#\n# However, we can side-step this by checking the type of `w.inner` to\n# narrow `w` itself:\nif isinstance(w.inner, int):\n    reveal_type(w)  # Revealed type is \"Wrapper[int]\"\nelse:\n    reveal_type(w)  # Revealed type is \"Wrapper[str]\"\n```\n\n----------------------------------------\n\nTITLE: Assignment Expressions with TypeIs for Type Narrowing - Python\nDESCRIPTION: This code demonstrates using assignment expressions together with TypeIs for flow-sensitive type inference. The is_float function is defined to narrow a variable to float if the isinstance check passes. In main, x is created with the walrus operator and narrowed to float inside the if branch. Requires Python 3.8+ for assignment expressions and Python 3.13+ or typing_extensions for TypeIs.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/type_narrowing.rst#2025-04-22_snippet_18\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import TypeIs, reveal_type\n\ndef is_float(x: object) -> TypeIs[float]:\n    return isinstance(x, float)\n\ndef main(a: object) -> None:\n    if is_float(x := a):\n        reveal_type(x)  # Revealed type is 'float'\n        # x is narrowed to float in this block\n        print(x + 1.0)\n```\n\n----------------------------------------\n\nTITLE: Typing Async/Await Functions in Python\nDESCRIPTION: This snippet demonstrates how to type coroutines using async/await syntax. The return type annotation represents the type you expect when awaiting the coroutine. Without awaiting, the type is inferred as Coroutine.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/more_types.rst#2025-04-22_snippet_20\n\nLANGUAGE: python\nCODE:\n```\nimport asyncio\n\nasync def format_string(tag: str, count: int) -> str:\n    return f'T-minus {count} ({tag})'\n\nasync def countdown(tag: str, count: int) -> str:\n    while count > 0:\n        my_str = await format_string(tag, count)  # type is inferred to be str\n        print(my_str)\n        await asyncio.sleep(0.1)\n        count -= 1\n    return \"Blastoff!\"\n\nasyncio.run(countdown(\"Millennium Falcon\", 5))\n```\n\n----------------------------------------\n\nTITLE: Defining Iterable Protocol with __iter__ (Python)\nDESCRIPTION: Demonstrates the minimal required method (__iter__) for an object to conform to the collections.abc.Iterable protocol. Required for enabling for-loops and iterable operations. 'T' is a generic type; outputs an iterator over T. Dependency: typing.Iterator.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/protocols.rst#2025-04-22_snippet_13\n\nLANGUAGE: python\nCODE:\n```\ndef __iter__(self) -> Iterator[T]\n\n```\n\n----------------------------------------\n\nTITLE: Defining SupportsAbs Protocol with __abs__ (Python)\nDESCRIPTION: Defines the __abs__ method signature required for the typing.SupportsAbs protocol. Objects implementing this method can be passed to abs(). 'T' is the return type matching abs(x).\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/protocols.rst#2025-04-22_snippet_19\n\nLANGUAGE: python\nCODE:\n```\ndef __abs__(self) -> T\n\n```\n\n----------------------------------------\n\nTITLE: Exit Method Return Type Check in Python\nDESCRIPTION: Demonstrates Mypy's error when the __exit__ method is said to return a bool while consistently returning False. Suggests using Literal[False] as the correct return type.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/error_code_list.rst#2025-04-22_snippet_28\n\nLANGUAGE: python\nCODE:\n```\nclass MyContext:\n    ...\n    def __exit__(self, exc, value, tb) -> bool:  # Error\n        print('exit')\n        return False\n```\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Literal\n\nclass MyContext:\n    ...\n    def __exit__(self, exc, value, tb) -> Literal[False]:  # OK\n        print('exit')\n        return False\n```\n\nLANGUAGE: python\nCODE:\n```\nclass MyContext:\n    ...\n    def __exit__(self, exc, value, tb) -> None:  # Also OK\n        print('exit')\n```\n\n----------------------------------------\n\nTITLE: Using Mapping Type Annotation in Python\nDESCRIPTION: Demonstrates the Mapping type for dict-like objects that shouldn't be mutated. Shows a type error that would occur when attempting to modify a Mapping object.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/cheat_sheet_py3.rst#2025-04-22_snippet_6\n\nLANGUAGE: python\nCODE:\n```\ndef f(my_mapping: Mapping[int, str]) -> list[int]:\n    my_mapping[5] = 'maybe'  # mypy will complain about this line...\n    return list(my_mapping.keys())\n\nf({3: 'yes', 4: 'no'})\n```\n\n----------------------------------------\n\nTITLE: Defining Generic Type Aliases (Python 3.12)\nDESCRIPTION: Shows how to define and use generic type aliases with the 'type' statement introduced in Python 3.12. Demonstrates both subscripted and unsubscripted usage, as well as constrained type parameters.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/generics.rst#2025-04-22_snippet_52\n\nLANGUAGE: python\nCODE:\n```\nfrom collections.abc import Callable, Iterable\n\ntype TInt[S] = tuple[int, S]\ntype UInt[S] = S | int\ntype CBack[S] = Callable[..., S]\n\ndef response(query: str) -> UInt[str]:  # Same as str | int\n    ...\ndef activate[S](cb: CBack[S]) -> S:        # Same as Callable[..., S]\n    ...\ntable_entry: TInt  # Same as tuple[int, Any]\n\ntype Vec[T: (int, float, complex)] = Iterable[tuple[T, T]]\n\ndef inproduct[T: (int, float, complex)](v: Vec[T]) -> T:\n    return sum(x*y for x, y in v)\n\ndef dilate[T: (int, float, complex)](v: Vec[T], scale: T) -> Vec[T]:\n    return ((x * scale, y * scale) for x, y in v)\n\nv1: Vec[int] = []      # Same as Iterable[tuple[int, int]]\nv2: Vec = []           # Same as Iterable[tuple[Any, Any]]\nv3: Vec[int, int] = [] # Error: Invalid alias, too many type arguments!\n```\n\n----------------------------------------\n\nTITLE: Creating Classes with TypeVar Defaults in Python\nDESCRIPTION: This snippet shows the use of TypeVar defaults as per PEP 696 in Mypy. It sets a default type for type parameters using typing_extensions for versions earlier than Python 3.13, which allows implicit type assignment based on default values.\nSOURCE: https://github.com/python/mypy/blob/master/CHANGELOG.md#2025-04-22_snippet_20\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Generic\\nfrom typing_extensions import TypeVar\\n\\nT = TypeVar(\"T\", default=int)\\n\\nclass C(Generic[T]):\\n   ...\\n\\nx: C = ...\\ny: C[str] = ...\\nreveal_type(x)  # C[int], because of the default\\nreveal_type(y)  # C[str]\n```\n\n----------------------------------------\n\nTITLE: Covariant Generic Box with Final Attribute - Python 3.12+\nDESCRIPTION: Illustrates using 'Final' from 'typing' to declare a Box generic as covariant via an explicitly final attribute. Demonstrates that a public final-typed attribute allows variance to be inferred as covariant in Python 3.12+. The main dependency is the typing module's Final. The Box[T] input remains flexible within the value restriction.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/generics.rst#2025-04-22_snippet_24\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Final\n\nclass Box[T]:  # this type is implicitly covariant\n    def __init__(self, content: T) -> None:\n        self.content: Final = content\n\n    def get_content(self) -> T:\n        return self.content\n```\n\n----------------------------------------\n\nTITLE: Defining and Using Python Classes with Type Checking\nDESCRIPTION: Demonstrates how Mypy reports an error when a class is redefined and when function arguments of incorrect types are used. It shows the importance of unique class definitions for accurate type checking.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/error_code_list.rst#2025-04-22_snippet_22\n\nLANGUAGE: python\nCODE:\n```\nclass A:\n    def __init__(self, x: int) -> None: ...\n\nclass A:  # Error: Name \"A\" already defined on line 1  [no-redef]\n    def __init__(self, x: str) -> None: ...\n\n# Error: Argument 1 to \"A\" has incompatible type \"str\"; expected \"int\"\n#        (the first definition wins!)\nA('x')\n```\n\n----------------------------------------\n\nTITLE: Abstract Class Instantiation Check with Mypy\nDESCRIPTION: Illustrates how Mypy reports errors when attempting to instantiate abstract classes without implementing their methods. It shows the necessity of providing method implementations to convert an abstract class to a concrete one.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/error_code_list.rst#2025-04-22_snippet_24\n\nLANGUAGE: python\nCODE:\n```\nfrom abc import ABCMeta, abstractmethod\n\nclass Persistent(metaclass=ABCMeta):\n    @abstractmethod\n    def save(self) -> None: ...\n\nclass Thing(Persistent):\n    def __init__(self) -> None:\n        ...\n\n    ...  # No \"save\" method\n\n# Error: Cannot instantiate abstract class \"Thing\" with abstract attribute \"save\"  [abstract]\nt = Thing()\n```\n\n----------------------------------------\n\nTITLE: Defining and Accessing Class and Instance Attributes with Mypy - Python\nDESCRIPTION: Illustrates creating a class with type-annotated instance attributes in the constructor and highlights how mypy checks for undefined attributes. It shows proper declaration and assignment of attributes, with mypy generating errors for undefined ones. This pattern requires mypy and is language-specific to Python type hints.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/class_basics.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nclass A:\n    def __init__(self, x: int) -> None:\n        self.x = x  # Aha, attribute 'x' of type 'int'\n\na = A(1)\na.x = 2  # OK!\na.y = 3  # Error: \"A\" has no attribute \"y\"\n```\n\n----------------------------------------\n\nTITLE: Illustrating Mypy Type Error Detection in Python\nDESCRIPTION: This Python code snippet demonstrates a common runtime error where a string returned by `input()` is incorrectly added to an integer. Mypy statically analyzes this code and identifies the `TypeError` (indicated by the comment: 'Unsupported operand types for + (\"str\" and \"int\")') without needing to execute the program, showcasing its core static analysis capability. It relies only on standard Python built-in functions.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/index.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nnumber = input(\"What is your favourite number?\")\nprint(\"It is\", number + 1)  # error: Unsupported operand types for + (\"str\" and \"int\")\n```\n\n----------------------------------------\n\nTITLE: Type Checking Overloads with First Match Rule in Python\nDESCRIPTION: Illustrates how Mypy resolves ambiguity when a function call matches multiple overload variants. Mypy selects the first matching variant defined. In this example, `summarize([])` matches both `summarize(data: list[int])` and `summarize(data: list[str])`. Mypy infers the return type as `float` because the `list[int]` variant is defined first. The implementation must handle this tie-breaking logic consistently at runtime.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/more_types.rst#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n# For Python 3.8 and below you must use `typing.List` instead of `list`. e.g.\n# from typing import List\nfrom typing import overload\n\n@overload\ndef summarize(data: list[int]) -> float: ...\n\n@overload\ndef summarize(data: list[str]) -> str: ...\n\ndef summarize(data):\n    if not data:\n        return 0.0\n    elif isinstance(data[0], int):\n        # Do int specific code\n    else:\n        # Do str-specific code\n\n# What is the type of 'output'? float or str?\noutput = summarize([])\n```\n\n----------------------------------------\n\nTITLE: Unsafe Calls to Abstract Methods via super() - Python\nDESCRIPTION: Illustrates how mypy handles abstract methods without concrete bodies and the dangers of invoking them with super(). Demonstrates two abstract methods: one with only 'pass' and one with a trivial body. Shows that calling an abstract method without a body via super() is unsafe, even if it compiles. This requires the abstractmethod decorator from the standard library 'abc'. Parameters in focus are method return types and the use of super(); calling a 'pass'-only method via super() will yield a type error.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/class_basics.rst#2025-04-22_snippet_16\n\nLANGUAGE: python\nCODE:\n```\nfrom abc import abstractmethod\nclass Base:\n    @abstractmethod\n    def foo(self) -> int: pass\n    @abstractmethod\n    def bar(self) -> int:\n        return 0\nclass Sub(Base):\n    def foo(self) -> int:\n        return super().foo() + 1  # error: Call to abstract method \"foo\" of \"Base\"\n                                  # with trivial body via super() is unsafe\n    @abstractmethod\n    def bar(self) -> int:\n        return super().bar() + 1  # This is OK however.\n```\n\n----------------------------------------\n\nTITLE: Assignment Expressions with TypeGuard for Type Narrowing - Python\nDESCRIPTION: This code snippet illustrates the use of Python's assignment expression (walrus operator :=) in conjunction with TypeGuard to narrow the type of a newly assigned variable. It defines a type guard function is_float to determine if a value is a float, then demonstrates how assignment inside an if-statement narrows only the assigned variable (x) but not the original (a). Requires Python 3.8 or above for assignment expressions and typing.TypeGuard (or typing_extensions for older Python versions).\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/type_narrowing.rst#2025-04-22_snippet_12\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import TypeGuard  # use `typing_extensions` for `python<3.10`\n\ndef is_float(a: object) -> TypeGuard[float]:\n    return isinstance(a, float)\n\ndef main(a: object) -> None:\n    if is_float(x := a):\n        reveal_type(x)  # N: Revealed type is 'builtins.float'\n        reveal_type(a)  # N: Revealed type is 'builtins.object'\n    reveal_type(x)  # N: Revealed type is 'builtins.object'\n    reveal_type(a)  # N: Revealed type is 'builtins.object'\n```\n\n----------------------------------------\n\nTITLE: Enforcing Attribute Assignments Using __slots__ with mypy - Python\nDESCRIPTION: Provides an example of a class using __slots__ for explicit attribute declarations, with mypy checking attribute assignments against the slot definitions. Shows a mypy error raised when trying to assign an attribute not declared in __slots__. This code assumes mypy is used and relies on Python's __slots__ mechanism. The __init__ method accepts parameters corresponding to the slots; any additional assignments to undeclared attributes will fail type checking.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/class_basics.rst#2025-04-22_snippet_17\n\nLANGUAGE: python\nCODE:\n```\nclass Album:\n    __slots__ = ('name', 'year')\n\n    def __init__(self, name: str, year: int) -> None:\n       self.name = name\n       self.year = year\n       # Error: Trying to assign name \"released\" that is not in \"__slots__\" of type \"Album\"\n       self.released = True\n\nmy_album = Album('Songs about Python', 2021)\n```\n\n----------------------------------------\n\nTITLE: Modern Generic Types (Python 3.9+)\nDESCRIPTION: Collection types with type hints using Python 3.9+ syntax. Includes lists, tuples, dictionaries, and various collection abstractions.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/builtin_types.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nlist[str]           # list of str objects\ntuple[int, int]      # tuple of two int objects\ntuple[int, ...]      # tuple of arbitrary number of int objects\ndict[str, int]       # dictionary from str keys to int values\nIterable[int]        # iterable object containing ints\nSequence[bool]       # sequence of booleans (read-only)\nMapping[str, int]    # mapping from str keys to int values (read-only)\ntype[C]              # type object of C\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Invariance in Generic list Container - Python\nDESCRIPTION: Shows that Python's list type is invariant, not covariant, even though naive intuition may suggest otherwise. Illustrates with classes Shape and Circle, and a function that mutates a list, leading to potential runtime errors when type invariance is not respected. No third-party dependencies are required; relies solely on built-in types. Parameters include any classes inheriting from Shape, and the demonstration hinges on method definitions in subclasses.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/generics.rst#2025-04-22_snippet_22\n\nLANGUAGE: python\nCODE:\n```\nclass Circle(Shape):\n    # The rotate method is only defined on Circle, not on Shape\n    def rotate(self): ...\n\ndef add_one(things: list[Shape]) -> None:\n    things.append(Shape())\n\nmy_circles: list[Circle] = []\nadd_one(my_circles)     # This may appear safe, but...\nmy_circles[-1].rotate()  # ...this will fail, since my_circles[0] is now a Shape, not a Circle\n```\n\n----------------------------------------\n\nTITLE: Using Casts with Mypy\nDESCRIPTION: Demonstrates how to use casts in Mypy to help the type checker understand subtype relations without performing runtime checks.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/type_narrowing.rst#2025-04-22_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import cast\n\no: object = [1]\nx = cast(list[int], o)  # OK\ny = cast(list[str], o)  # OK (cast performs no actual runtime check)\n\n# Supporting runtime check with assert:\n\ndef foo(o: object) -> None:\n    print(o + 5)  # Error: can't add 'object' and 'int'\n    assert isinstance(o, int)\n    print(o + 5)  # OK: type of 'o' is 'int' here\n\n# Example using Any type:\n\nfrom typing import cast, Any\n\nx = 1\nx.whatever()  # Type check error\ny = cast(Any, x)\ny.whatever()  # Type check OK (runtime error)\n```\n\n----------------------------------------\n\nTITLE: Using Final Instance Attributes in __init__ Methods (Python)\nDESCRIPTION: Illustrates how to declare final instance attributes within a class, ensuring they are only assigned once, typically in the __init__ method. Requires typing.Final and mypy for enforcement. The snippet shows a class definition with uninitialized final attributes, with one being initialized correctly in __init__, and the other flagged as a mypy error because it lacks initialization. Input is standard class structure; output is static error for missing initializations.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/final_attrs.rst#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nclass ImmutablePoint:\n    x: Final[int]\n    y: Final[int]  # Error: final attribute without an initializer\n\n    def __init__(self) -> None:\n        self.x = 1  # Good\n```\n\n----------------------------------------\n\nTITLE: Declaring Final Variables with Explicit or Inferred Types in Python\nDESCRIPTION: This snippet presents multiple syntactic variants for using typing.Final, including explicit type arguments, omitted types, and class body declarations without a right-hand side. These declarations instruct mypy to treat assignments as final, using type inference where type is not supplied. Prerequisites are typing.Final and mypy. The code demonstrates that Final can be used with both explicit types or without, with inferences leading to int, Literal, or uninitialized (for class bodies).\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/final_attrs.rst#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nID: Final[int] = 1\n```\n\nLANGUAGE: python\nCODE:\n```\nID: Final = 1\n```\n\n----------------------------------------\n\nTITLE: Understanding Async Function Return Types with Yield\nDESCRIPTION: Demonstrates how the presence of yield in async functions affects their return types and type checking behavior. Shows the difference between returning an AsyncIterator directly vs returning a coroutine.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/more_types.rst#2025-04-22_snippet_24\n\nLANGUAGE: python\nCODE:\n```\nfrom collections.abc import AsyncIterator\n\nasync def arange(stop: int) -> AsyncIterator[int]:\n    i = 0\n    while i < stop:\n        yield i\n        i += 1\n\nasync def coroutine(stop: int) -> AsyncIterator[int]:\n    return arange(stop)\n\nasync def main() -> None:\n    reveal_type(arange(5))  # Revealed type is \"typing.AsyncIterator[builtins.int]\"\n    reveal_type(coroutine(5))  # Revealed type is \"typing.Coroutine[Any, Any, typing.AsyncIterator[builtins.int]]\"\n\n    await arange(5)  # Error: Incompatible types in \"await\"\n    reveal_type(await coroutine(5))  # Revealed type is \"typing.AsyncIterator[builtins.int]\"\n```\n\n----------------------------------------\n\nTITLE: Adding Type Annotations to Catch Errors in Python\nDESCRIPTION: Demonstration of how adding type annotations to a function enables mypy to detect a type error when concatenating a string with a list returned by split().\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/common_issues.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ndef foo(a: str) -> str:\n    return '(' + a.split() + ')'\n# error: Unsupported operand types for + (\"str\" and \"list[str]\")\n```\n\n----------------------------------------\n\nTITLE: Validating method overrides with Mypy\nDESCRIPTION: Ensures subclass methods conform to base class signatures. Mypy checks if the arguments and return types are compatible under the Liskov Substitution Principle. Demonstrated through base and derived classes with slight variations.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/error_code_list.rst#2025-04-22_snippet_9\n\nLANGUAGE: Python\nCODE:\n```\n   class Base:\n       def method(self,\n                  arg: int) -> int | None:\n           ...\n\n   class Derived(Base):\n       def method(self,\n                  arg: int | str) -> int:  # OK\n           ...\n\n   class DerivedBad(Base):\n       # Error: Argument 1 of \"method\" is incompatible with \"Base\"  [override]\n       def method(self,\n                  arg: bool) -> int:\n           ...\n```\n\n----------------------------------------\n\nTITLE: Implementing a Type-Preserving Decorator with Parameter Specifications (Python 3.12)\nDESCRIPTION: Demonstrates how to use parameter specifications to create a decorator that preserves the input types but changes the return type from any type T to str. This uses Python 3.12's native type parameter syntax.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/generics.rst#2025-04-22_snippet_39\n\nLANGUAGE: python\nCODE:\n```\nfrom collections.abc import Callable\n\n# We reuse 'P' in the return type, but replace 'T' with 'str'\ndef stringify[**P, T](func: Callable[P, T]) -> Callable[P, str]:\n    def wrapper(*args: P.args, **kwds: P.kwargs) -> str:\n        return str(func(*args, **kwds))\n    return wrapper\n\n @stringify\n def add_forty_two(value: int) -> int:\n     return value + 42\n\n a = add_forty_two(3)\n reveal_type(a)      # Revealed type is \"builtins.str\"\n add_forty_two('x')  # error: Argument 1 to \"add_forty_two\" has incompatible type \"str\"; expected \"int\"\n```\n\n----------------------------------------\n\nTITLE: Ensuring Type Safety with Assertions in Mypy\nDESCRIPTION: Illustrates using assertions to convince Mypy that an attribute is not 'None' when Mypy can't infer it. The class 'Resource' shows how to initialize a class attribute and assert its non-None state in a method.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/kinds_of_types.rst#2025-04-22_snippet_10\n\nLANGUAGE: Python\nCODE:\n```\nclass Resource:\n    path: str | None = None\n\n    def initialize(self, path: str) -> None:\n        self.path = path\n\n    def read(self) -> str:\n        assert self.path is not None\n        with open(self.path) as f:\n           return f.read()\n\nr = Resource()\nr.initialize('/foo/bar')\nr.read()\n```\n\n----------------------------------------\n\nTITLE: Type Checking Consequences of Untyped Decorators - Python\nDESCRIPTION: Demonstrates output of reveal_type and failed type checking when a function has been decorated with an untyped decorator. This reveals types as 'Any' and allows wrong argument types through. Highlights why properly typed decorators are necessary. No dependencies.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/generics.rst#2025-04-22_snippet_34\n\nLANGUAGE: python\nCODE:\n```\nreveal_type(a)        # Revealed type is \"Any\"\nadd_forty_two('foo')  # No type checker error :(\n```\n\n----------------------------------------\n\nTITLE: TypeIs with Additional Parameters for Instance Checks - Python\nDESCRIPTION: This code demonstrates that TypeIs functions may accept extra parameters; here, is_instance_of checks if val is an instance of the specified type typ, narrowing only the first argument. The process function shows how x is narrowed to int when appropriate. Relies on typing.TypeVar, TypeIs, and Python's isinstance, works with TypeIs from typing_extensions for older Python versions.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/type_narrowing.rst#2025-04-22_snippet_16\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Any, TypeVar, reveal_type, TypeIs\n\nT = TypeVar('T')\n\ndef is_instance_of(val: Any, typ: type[T]) -> TypeIs[T]:\n    return isinstance(val, typ)\n\ndef process(x: Any) -> None:\n    if is_instance_of(x, int):\n        reveal_type(x)  # Revealed type is 'int'\n        print(x + 1)  # ok\n    else:\n        reveal_type(x)  # Revealed type is 'Any'\n```\n\n----------------------------------------\n\nTITLE: Preventing Method Overriding with the @final Decorator in Python\nDESCRIPTION: Shows the use of typing.final as a decorator on methods to prevent subclasses from overriding them. Includes a base class with a final method, and a subclass where overriding triggers a mypy error. Inputs are class and method definitions; output is a type error for invalid overrides. Prerequisites: typing.final and mypy. Supported for instance/class/static methods and properties.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/final_attrs.rst#2025-04-22_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import final\n\nclass Base:\n    @final\n    def common_name(self) -> None:\n        ...\n\nclass Derived(Base):\n    def common_name(self) -> None:  # Error: cannot override a final method\n        ...\n```\n\n----------------------------------------\n\nTITLE: Properly Typed Function Decorator with Callable and TypeVar - Python <=3.11\nDESCRIPTION: Demonstrates legacy way of typing decorators that preserve signature: uses TypeVar with a Callable bound, plus cast for the return type. Allows static checking and signature inference with decorated functions. Dependencies: collections.abc.Callable, typing.TypeVar, Any, cast.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/generics.rst#2025-04-22_snippet_36\n\nLANGUAGE: python\nCODE:\n```\nfrom collections.abc import Callable\nfrom typing import Any, TypeVar, cast\n\nF = TypeVar('F', bound=Callable[..., Any])\n\n# A decorator that preserves the signature.\ndef printing_decorator(func: F) -> F:\n    def wrapper(*args, **kwds):\n        print(\"Calling\", func)\n        return func(*args, **kwds)\n    return cast(F, wrapper)\n\n@printing_decorator\ndef add_forty_two(value: int) -> int:\n    return value + 42\n\na = add_forty_two(3)\nreveal_type(a)      # Revealed type is \"builtins.int\"\nadd_forty_two('x')  # Argument 1 to \"add_forty_two\" has incompatible type \"str\"; expected \"int\"\n```\n\n----------------------------------------\n\nTITLE: Preventing Subclassing with the @final Decorator in Python\nDESCRIPTION: Illustrates how applying typing.final as a decorator to a class definition will prevent its subclassing in mypy-checked code. The base class with @final cannot be inherited, and a subclass triggers a static analysis error. Inputs are base and derivative class declarations; output is a mypy error for subclassing final classes. Dependencies: typing.final, mypy. No runtime restriction enforced.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/final_attrs.rst#2025-04-22_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import final\n\n@final\nclass Leaf:\n    ...\n\nclass MyLeaf(Leaf):  # Error: Leaf can't be subclassed\n    ...\n```\n\n----------------------------------------\n\nTITLE: Defining Abstract Base Classes and Concrete Subclasses - Python\nDESCRIPTION: Illustrates the creation of an abstract base class (ABC) using the abc.ABCMeta metaclass and @abstractmethod decorator, defining both abstract methods and properties. Shows correct subclass implementation and mypy's error when attempting to instantiate an abstract class. Demonstrates standard Python idioms for abstraction and interface enforcement.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/class_basics.rst#2025-04-22_snippet_13\n\nLANGUAGE: python\nCODE:\n```\nfrom abc import ABCMeta, abstractmethod\n\nclass Animal(metaclass=ABCMeta):\n    @abstractmethod\n    def eat(self, food: str) -> None: pass\n\n    @property\n    @abstractmethod\n    def can_walk(self) -> bool: pass\n\nclass Cat(Animal):\n    def eat(self, food: str) -> None:\n        ...  # Body omitted\n\n    @property\n    def can_walk(self) -> bool:\n        return True\n\nx = Animal()  # Error: 'Animal' is abstract due to 'eat' and 'can_walk'\ny = Cat()     # OK\n```\n\n----------------------------------------\n\nTITLE: Implementing Enum Exhaustiveness Check with assert_never in Python\nDESCRIPTION: This function `choose_direction` demonstrates exhaustiveness checking for the `Direction` Enum using `if/elif` and `assert_never`. `reveal_type` shows how Mypy narrows the type within each branch. The `assert_never` ensures all enum members are handled.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/literal_types.rst#2025-04-22_snippet_17\n\nLANGUAGE: python\nCODE:\n```\ndef choose_direction(direction: Direction) -> None:\n    if direction is Direction.up:\n        reveal_type(direction)  # N: Revealed type is \"Literal[Direction.up]\"\n        print('Going up!')\n        return\n    elif direction is Direction.down:\n        print('Down')\n        return\n    # This line is never reached\n    assert_never(direction)\n```\n\n----------------------------------------\n\nTITLE: Implementing Custom Async Iterator Class in Python\nDESCRIPTION: Defines an async iterator class 'arange' that generates a sequence of numbers with type hints. Includes a countdown example using asyncio.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/more_types.rst#2025-04-22_snippet_22\n\nLANGUAGE: python\nCODE:\n```\nimport asyncio\n\nclass arange:\n    def __init__(self, start: int, stop: int, step: int) -> None:\n        self.start = start\n        self.stop = stop\n        self.step = step\n        self.count = start - step\n\n    def __aiter__(self) -> AsyncIterator[int]:\n        return self\n\n    async def __anext__(self) -> int:\n        self.count += self.step\n        if self.count == self.stop:\n            raise StopAsyncIteration\n        else:\n            return self.count\n\nasync def run_countdown(tag: str, countdown: AsyncIterator[int]) -> str:\n    async for i in countdown:\n        print(f'T-minus {i} ({tag})')\n        await asyncio.sleep(0.1)\n    return \"Blastoff!\"\n\nasyncio.run(run_countdown(\"Serenity\", arange(5, 0, -1)))\n```\n\n----------------------------------------\n\nTITLE: Defining Sized Protocol with __len__ (Python)\nDESCRIPTION: Specifies the minimal __len__ method required for the collections.abc.Sized interface, enabling objects to be used with len(). Returns an int. Used in custom containers and sequence-like objects.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/protocols.rst#2025-04-22_snippet_15\n\nLANGUAGE: python\nCODE:\n```\ndef __len__(self) -> int\n\n```\n\n----------------------------------------\n\nTITLE: Working with Coroutine Objects in Type Annotations\nDESCRIPTION: This example shows how the result of calling an async function without awaiting is typed. The return type is automatically inferred as Coroutine[Any, Any, T], which is a subtype of Awaitable[T].\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/more_types.rst#2025-04-22_snippet_21\n\nLANGUAGE: python\nCODE:\n```\nmy_coroutine = countdown(\"Millennium Falcon\", 5)\nreveal_type(my_coroutine)  # Revealed type is \"typing.Coroutine[Any, Any, builtins.str]\"\n```\n\n----------------------------------------\n\nTITLE: Declaring Partial TypedDicts with total=False - Python\nDESCRIPTION: Shows how to define a partial (non-total) TypedDict using the 'total=False' parameter, making all items optional. The code demonstrates instantiating an empty dictionary with this type and setting items individually. Requires 'from typing import TypedDict'.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/typed_dict.rst#2025-04-22_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nGuiOptions = TypedDict(\n    'GuiOptions', {'language': str, 'color': str}, total=False)\noptions: GuiOptions = {}  # Okay\noptions['language'] = 'en'\n```\n\n----------------------------------------\n\nTITLE: Defining TypeAliasType for Alias Declarations in Python\nDESCRIPTION: This snippet illustrates the use of TypeAliasType in Mypy for creating type aliases, as described in PEP 695. The snippet enables implicit type aliasing using typing_extensions for Python versions before 3.12.\nSOURCE: https://github.com/python/mypy/blob/master/CHANGELOG.md#2025-04-22_snippet_21\n\nLANGUAGE: python\nCODE:\n```\nfrom typing_extensions import TypeAliasType, TypeVar\\n\\nNewUnionType = TypeAliasType(\"NewUnionType\", int | str)\\nx: NewUnionType = 42\\ny: NewUnionType = 'a'\\nz: NewUnionType = object()  # error: Incompatible types in assignment (expression has type \"object\", variable has type \"int | str\")  [assignment]\\n\\nT = TypeVar(\"T\")\\nListOrSet = TypeAliasType(\"ListOrSet\", list[T] | set[T], type_params=(T,))\\na: ListOrSet[int] = [1, 2]\\nb: ListOrSet[str] = {'a', 'b'}\\nc: ListOrSet[str] = 'test'  # error: Incompatible types in assignment (expression has type \"str\", variable has type \"list[str] | set[str]\")  [assignment]\n```\n\n----------------------------------------\n\nTITLE: Generic Methods with Self Type in Python\nDESCRIPTION: This code demonstrates how to define generic methods where the 'self' parameter can be a generic type, using Python 3.12 syntax. This allows methods like set_scale to maintain the precise return type for instances of classes like Circle and Square, using a set of type constraints to enable type-checked chaining.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/generics.rst#2025-04-22_snippet_15\n\nLANGUAGE: python\nCODE:\n```\nclass Shape:\n    def set_scale[T: Shape](self: T, scale: float) -> T:\n        self.scale = scale\n        return self\n\nclass Circle(Shape):\n    def set_radius(self, r: float) -> 'Circle':\n        self.radius = r\n        return self\n\nclass Square(Shape):\n    def set_width(self, w: float) -> 'Square':\n        self.width = w\n        return self\n\ncircle: Circle = Circle().set_scale(0.5).set_radius(2.7)\nsquare: Square = Square().set_scale(0.5).set_width(3.2)\n```\n\n----------------------------------------\n\nTITLE: Greet All with Iterable Type Hint in Python\nDESCRIPTION: This Python function, 'greet_all', uses an Iterable type hint to accept any iterable collection of strings. It illustrates the use of generics in defining functions that are more flexible with input types, relying on subtype polymorphism.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/getting_started.rst#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom collections.abc import Iterable\n\ndef greet_all(names: Iterable[str]) -> None:\n    for name in names:\n        print('Hello ' + name)\n```\n\n----------------------------------------\n\nTITLE: Function Overloading Using Typing Overload in Python\nDESCRIPTION: Explains how to use function overloading for defining multiple function signatures using MyPy's overload decorator. This helps in achieving precise type checking based on different function annotations.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/more_types.rst#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import overload\n\n# Overload *variants* for 'mouse_event'.\n@overload\ndef mouse_event(x1: int, y1: int) -> ClickEvent: ...\n@overload\ndef mouse_event(x1: int, y1: int, x2: int, y2: int) -> DragEvent: ...\n\ndef mouse_event(x1: int,\n                y1: int,\n                x2: int | None = None,\n                y2: int | None = None) -> ClickEvent | DragEvent:\n    if x2 is None and y2 is None:\n        return ClickEvent(x1, y1)\n    elif x2 is not None and y2 is not None:\n        return DragEvent(x1, y1, x2, y2)\n    else:\n        raise TypeError(\"Bad arguments\")\n```\n\nLANGUAGE: python\nCODE:\n```\nfrom collections.abc import Sequence\nfrom typing import overload\n\nclass MyList[T](Sequence[T]):\n    @overload\n    def __getitem__(self, index: int) -> T: ...\n\n    @overload\n    def __getitem__(self, index: slice) -> Sequence[T]: ...\n\n    def __getitem__(self, index: int | slice) -> T | Sequence[T]:\n        if isinstance(index, int):\n            # Return a T here\n        elif isinstance(index, slice):\n            # Return a sequence of Ts here\n        else:\n            raise TypeError(...)\n```\n\nLANGUAGE: python\nCODE:\n```\nfrom collections.abc import Sequence\nfrom typing import TypeVar, overload\n\nT = TypeVar('T')\n\nclass MyList(Sequence[T]):\n    @overload\n    def __getitem__(self, index: int) -> T: ...\n\n    @overload\n    def __getitem__(self, index: slice) -> Sequence[T]: ...\n\n    def __getitem__(self, index: int | slice) -> T | Sequence[T]:\n        if isinstance(index, int):\n            # Return a T here\n        elif isinstance(index, slice):\n            # Return a sequence of Ts here\n```\n\n----------------------------------------\n\nTITLE: TypedDict Item and Key Validation with Mypy\nDESCRIPTION: This code examines TypedDict type checking capabilities in Mypy, including validation of both key existence and value compatibility in Python's TypedDict constructs.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/error_code_list.rst#2025-04-22_snippet_20\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import TypedDict\n\nclass Point(TypedDict):\n    x: int\n    y: int\n\n# Error: Incompatible types (expression has type \"float\",\n#        TypedDict item \"x\" has type \"int\")  [typeddict-item]\np: Point = {'x': 1.2, 'y': 4}\n```\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import TypedDict\n\nclass Point(TypedDict):\n    x: int\n    y: int\n\nclass Point3D(Point):\n    z: int\n\ndef add_x_coordinates(a: Point, b: Point) -> int:\n    return a[\"x\"] + b[\"x\"]\n\na: Point = {\"x\": 1, \"y\": 4}\nb: Point3D = {\"x\": 2, \"y\": 5, \"z\": 6}\n\nadd_x_coordinates(a, b)  # OK\n\n# Error: Extra key \"z\" for TypedDict \"Point\"  [typeddict-unknown-key]\nadd_x_coordinates(a, {\"x\": 1, \"y\": 4, \"z\": 5})\n```\n\nLANGUAGE: python\nCODE:\n```\na: Point = {\"x\": 1, \"y\": 2}\n# Error: Extra key \"z\" for TypedDict \"Point\"  [typeddict-unknown-key]\na[\"z\"] = 3\n```\n\nLANGUAGE: python\nCODE:\n```\na: Point = {\"x\": 1, \"y\": 2}\n# Error: TypedDict \"Point\" has no key \"z\"  [typeddict-item]\n_ = a[\"z\"]\n```\n\n----------------------------------------\n\nTITLE: Using String Literal Type Annotations to Avoid NameErrors - Python\nDESCRIPTION: Shows how to write type annotations as strings so Python does not attempt to resolve names prematurely, thereby avoiding NameErrors for forward-declared classes. Requires no dependencies and works by quoting the class name in type annotations. Inputs are function parameters/classes; outputs are runtime-safe code compatible with Mypy.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/runtime_troubles.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ndef f(a: list['A']) -> None: ...  # OK, prevents NameError since A is defined later\ndef g(n: 'int') -> None: ...      # Also OK, though not useful\n\nclass A: pass\n```\n\n----------------------------------------\n\nTITLE: Defining Generic Type Aliases in Python\nDESCRIPTION: Demonstrates the creation of generic type aliases using TypeVar and Union. Shows how to use these aliases in function signatures and variable annotations.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/generics.rst#2025-04-22_snippet_53\n\nLANGUAGE: python\nCODE:\n```\nTInt = tuple[int, S]  # 1 type parameter, since only S is free\nUInt = Union[S, int]\nCBack = Callable[..., S]\n\ndef response(query: str) -> UInt[str]:  # Same as Union[str, int]\n    ...\ndef activate(cb: CBack[S]) -> S:        # Same as Callable[..., S]\n    ...\ntable_entry: TInt  # Same as tuple[int, Any]\n\nT = TypeVar('T', int, float, complex)\n\nVec = Iterable[tuple[T, T]]\n\ndef inproduct(v: Vec[T]) -> T:\n    return sum(x*y for x, y in v)\n\ndef dilate(v: Vec[T], scale: T) -> Vec[T]:\n    return ((x * scale, y * scale) for x, y in v)\n\nv1: Vec[int] = []      # Same as Iterable[tuple[int, int]]\nv2: Vec = []           # Same as Iterable[tuple[Any, Any]]\nv3: Vec[int, int] = [] # Error: Invalid alias, too many type arguments!\n```\n\n----------------------------------------\n\nTITLE: Defining Explicit Type Alias with TypeAlias - Python\nDESCRIPTION: This snippet illustrates defining an explicit type alias using the TypeAlias helper from typing or typing_extensions. The Alias variable is annotated as TypeAlias, with class A as its target. Dependency: Python 3.9+ (or typing_extensions for earlier versions). The technique ensures static analysis tools recognize Alias as a type alias.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/common_issues.rst#2025-04-22_snippet_23\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import TypeAlias  # \\\"from typing_extensions\\\" in Python 3.9 and earlier\\n\\nclass A: ...\\nAlias: TypeAlias = A\n```\n\n----------------------------------------\n\nTITLE: Using Enum as Type Annotation in Python\nDESCRIPTION: This snippet shows how to use the `Direction` Enum as a type annotation for the `direction` parameter in the `Movement` class constructor. Mypy checks that arguments passed during instantiation match the expected `Direction` type.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/literal_types.rst#2025-04-22_snippet_15\n\nLANGUAGE: python\nCODE:\n```\nclass Movement:\n    def __init__(self, direction: Direction, speed: float) -> None:\n        self.direction = direction\n        self.speed = speed\n\nMovement(Direction.up, 5.0)  # ok\nMovement('up', 5.0)  # E: Argument 1 to \"Movement\" has incompatible type \"str\"; expected \"Direction\"\n```\n\n----------------------------------------\n\nTITLE: Declaring Collection Variable Types Without Assignment in Python\nDESCRIPTION: This snippet demonstrates the correct way to predeclare a variable with a collection type without an initial value using type annotations. It then unpacks values into the list. This approach avoids mypy errors about undefined types for unpacked or initially empty variables.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/type_inference_and_annotations.rst#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nrs: list[int]  # no assignment!\\np, q, *rs = 1, 2  # OK\n```\n\n----------------------------------------\n\nTITLE: Selectively Disabling Deprecated Warnings in Python with Mypy\nDESCRIPTION: This code snippet shows how to selectively disable warnings generated from warnings.deprecated using the --deprecated-calls-exclude option in Mypy. It demonstrates ignoring a specific deprecated warning for a class method.\nSOURCE: https://github.com/python/mypy/blob/master/CHANGELOG.md#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n# mypy --enable-error-code deprecated\n#      --deprecated-calls-exclude=foo.A\nimport foo\n\nfoo.A().func()  # OK, the deprecated warning is ignored\n\n# file foo.py\nfrom typing_extensions import deprecated\nclass A:\n    @deprecated(\"Use A.func2 instead\")\n    def func(self): pass\n```\n\n----------------------------------------\n\nTITLE: Decorator Type Annotations with Python 3.12 Syntax\nDESCRIPTION: Demonstrates how to type decorators using Python 3.12's syntax with generics. Shows examples of both a simple decorator and one that takes arguments.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/cheat_sheet_py3.rst#2025-04-22_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nfrom collections.abc import Callable\nfrom typing import Any\n\ndef bare_decorator[F: Callable[..., Any]](func: F) -> F:\n    ...\n\ndef decorator_args[F: Callable[..., Any]](url: str) -> Callable[[F], F]:\n    ...\n```\n\n----------------------------------------\n\nTITLE: Accessing TypedDict Fields Safely - Python\nDESCRIPTION: Demonstrates how to retrieve values from a TypedDict using literal string keys. Each accessed field (e.g., 'name', 'year') results in type-aware responses ('name' as str, 'year' as int). No additional dependencies are required. This showcases safe field access checked by static type checkers.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/typed_dict.rst#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nname = movie['name']  # Okay; type of name is str\nyear = movie['year']  # Okay; type of year is int\n```\n\n----------------------------------------\n\nTITLE: Referencing Stub-Only Types with TYPE_CHECKING and __future__ Annotations - Python\nDESCRIPTION: Shows how to safely use types only present in type stubs (which cannot be imported at runtime), by combining typing.TYPE_CHECKING for imports and __future__ annotations for referencing. This prevents ImportErrors while preserving type information for Mypy. Inputs are functions using stub-only types; outputs are type-safe, runtime-safe code. Dependencies: typing, __future__ annotations, and proper stub installation.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/runtime_troubles.rst#2025-04-22_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nfrom __future__ import annotations\nfrom typing import TYPE_CHECKING\nif TYPE_CHECKING:\n    from _typeshed import SupportsRichComparison\n\ndef f(x: SupportsRichComparison) -> None\n```\n\n----------------------------------------\n\nTITLE: Precise Typing of Alternative Constructors in Generic Classes\nDESCRIPTION: This code shows how to use Self type annotations to provide precise typing for alternative constructors in generic classes. The make_pair classmethod returns instances of the calling class with proper generic typing.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/more_types.rst#2025-04-22_snippet_19\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Self\n\nclass Base[T]:\n    def __init__(self, item: T) -> None:\n        self.item = item\n\n    @classmethod\n    def make_pair(cls, item: T) -> tuple[Self, Self]:\n        return cls(item), cls(item)\n\nclass Sub[T](Base[T]):\n    ...\n\npair = Sub.make_pair('yes')  # Type is \"tuple[Sub[str], Sub[str]]\"\nbad = Sub[int].make_pair('no')  # Error: Argument 1 to \"make_pair\" of \"Base\"\n                               # has incompatible type \"str\"; expected \"int\"\n```\n\n----------------------------------------\n\nTITLE: Using MutableMapping Type Annotation in Python\nDESCRIPTION: Demonstrates the MutableMapping type for dict-like objects that can be modified. This function takes a mutable mapping, adds a key-value pair, and returns a set of its values.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/cheat_sheet_py3.rst#2025-04-22_snippet_7\n\nLANGUAGE: python\nCODE:\n```\ndef f(my_mapping: MutableMapping[int, str]) -> set[str]:\n    my_mapping[5] = 'maybe'  # ...but mypy is OK with this.\n    return set(my_mapping.values())\n\nf({3: 'yes', 4: 'no'})\n```\n\n----------------------------------------\n\nTITLE: Implementing TypeIs with Mypy in Python\nDESCRIPTION: This snippet demonstrates how Mypy now supports TypeIs, which allows functions to narrow the type of a value in both branches of an if statement. It requires importing from typing_extensions for Python versions before 3.13.\nSOURCE: https://github.com/python/mypy/blob/master/CHANGELOG.md#2025-04-22_snippet_19\n\nLANGUAGE: python\nCODE:\n```\nfrom typing_extensions import TypeIs\\n\\ndef is_str(s: object) -> TypeIs[str]:\\n    return isinstance(s, str)\\n\\ndef f(o: str | int) -> None:\\n    if is_str(o):\\n        # Type of o is 'str'\\n        ...\\n    else:\\n        # Type of o is 'int'\\n        ...\n```\n\n----------------------------------------\n\nTITLE: Checking attribute existence in classes with Mypy\nDESCRIPTION: The code snippet demonstrates the usage of Mypy to check for defined attributes within a class, producing an error if attributes do not exist. Dependencies include Mypy setup. Inputs and outputs relate to class instantiation and attribute access.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/error_code_list.rst#2025-04-22_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\n   class Resource:\n       def __init__(self, name: str) -> None:\n           self.name = name\n\n   r = Resource('x')\n   print(r.name)  # OK\n   print(r.id)  # Error: \"Resource\" has no attribute \"id\"  [attr-defined]\n   r.id = 5  # Error: \"Resource\" has no attribute \"id\"  [attr-defined]\n```\n\nLANGUAGE: Python\nCODE:\n```\n    # Error: Module \"os\" has no attribute \"non_existent\"  [attr-defined]\n    from os import non_existent\n```\n\n----------------------------------------\n\nTITLE: Validating union type attribute access with Mypy\nDESCRIPTION: This snippet demonstrates Mypy's check that attributes exist for all types in a union, catching potential runtime attribute errors. Requires Python 3.10+ for union syntax. The example shows function calls on union-typed parameter 'animal'.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/error_code_list.rst#2025-04-22_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\n   class Cat:\n       def sleep(self) -> None: ...\n       def miaow(self) -> None: ...\n\n   class Dog:\n       def sleep(self) -> None: ...\n       def follow_me(self) -> None: ...\n\n   def func(animal: Cat | Dog) -> None:\n       # OK: 'sleep' is defined for both Cat and Dog\n       animal.sleep()\n       # Error: Item \"Cat\" of \"Cat | Dog\" has no attribute \"follow_me\"  [union-attr]\n       animal.follow_me()\n```\n\n----------------------------------------\n\nTITLE: Implementing `Iterable` Protocol Structurally in Python\nDESCRIPTION: Demonstrates how a class `IntList` implicitly implements the `collections.abc.Iterable` protocol by defining an `__iter__` method that returns an `Iterator[int]`. Mypy recognizes this structural compatibility, allowing `IntList` instances (and standard lists) to be passed to functions expecting `Iterable[int]`. Dependencies include `collections.abc.Iterator`, `collections.abc.Iterable`, and `__future__.annotations`.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/protocols.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom __future__ import annotations\n\nfrom collections.abc import Iterator, Iterable\n\nclass IntList:\n    def __init__(self, value: int, next: IntList | None) -> None:\n        self.value = value\n        self.next = next\n\n    def __iter__(self) -> Iterator[int]:\n        current = self\n        while current:\n            yield current.value\n            current = current.next\n\ndef print_numbered(items: Iterable[int]) -> None:\n    for n, x in enumerate(items):\n        print(n + 1, x)\n\nx = IntList(3, IntList(5, None))\nprint_numbered(x)  # OK\nprint_numbered([4, 5])  # Also OK\n```\n\n----------------------------------------\n\nTITLE: Type Checking an Inline Python Command with mypy - Bash\nDESCRIPTION: Uses the -c flag to type check a string as a small Python program. Useful for quickly checking expressions or small scripts without a source file. Requires mypy. The evaluation and error report are printed to stdout.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/running_mypy.rst#2025-04-22_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\n$ mypy -c 'x = [1, 2]; print(x())'\n```\n\n----------------------------------------\n\nTITLE: Generic Type Usage Example\nDESCRIPTION: Example demonstrating correct type inference with generic type annotation.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/kinds_of_types.rst#2025-04-22_snippet_19\n\nLANGUAGE: python\nCODE:\n```\nbeginner = new_user(BasicUser)  # Inferred type is BasicUser\nbeginner.upgrade()  # OK\n```\n\n----------------------------------------\n\nTITLE: Analyzing calls to overloaded functions with Mypy\nDESCRIPTION: Displays Mypy's functionality to check overloaded function calls, ensuring at least one signature matches the call's argument types. Uses Python's typing overload system. The code demonstrates multiple overloads and an incompatible call.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/error_code_list.rst#2025-04-22_snippet_6\n\nLANGUAGE: Python\nCODE:\n```\n   from typing import overload\n\n   @overload\n   def inc_maybe(x: None) -> None: ...\n\n   @overload\n   def inc_maybe(x: int) -> int: ...\n\n   def inc_maybe(x: int | None) -> int | None:\n        if x is None:\n            return None\n        else:\n            return x + 1\n\n   inc_maybe(None)  # OK\n   inc_maybe(5)  # OK\n\n   # Error: No overload variant of \"inc_maybe\" matches argument type \"float\"  [call-overload]\n   inc_maybe(1.2)\n```\n\n----------------------------------------\n\nTITLE: User-Defined Type Guards in Mypy\nDESCRIPTION: Explains the creation and use of TypeGuard functions in Mypy for type narrowing based on runtime checks.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/type_narrowing.rst#2025-04-22_snippet_7\n\nLANGUAGE: python\nCODE:\n```\ndef is_str_list(val: list[object]) -> bool:\n    return all(isinstance(x, str) for x in val)\n\ndef func1(val: list[object]) -> None:\n    if is_str_list(val):\n        reveal_type(val)  # Reveals list[object]\n        print(\" \".join(val)) # Error: incompatible type\n\nfrom typing import TypeGuard  # use `typing_extensions` for Python 3.9 and below\n\n def is_str_list(val: list[object]) -> TypeGuard[list[str]]:\n    return all(isinstance(x, str) for x in val)\n\ndef func1(val: list[object]) -> None:\n    if is_str_list(val):\n        reveal_type(val)  # list[str]\n        print(\" \".join(val)) # ok\n```\n\n----------------------------------------\n\nTITLE: Metaclass Attribute Lookup and Inheritance Example with Type Annotations\nDESCRIPTION: Illustrates how Mypy handles attribute lookup in metaclasses, showing how methods defined in the metaclass can be accessed from the class. Demonstrates type variable usage and includes a type error example.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/metaclasses.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import ClassVar, TypeVar\n\nS = TypeVar(\"S\")\n\nclass M(type):\n    count: ClassVar[int] = 0\n\n    def make(cls: type[S]) -> S:\n        M.count += 1\n        return cls()\n\nclass A(metaclass=M):\n    pass\n\na: A = A.make()  # make() is looked up at M; the result is an object of type A\nprint(A.count)\n\nclass B(A):\n    pass\n\nb: B = B.make()  # metaclasses are inherited\nprint(B.count + \" objects were created\")  # Error: Unsupported operand types for + (\"int\" and \"str\")\n```\n\n----------------------------------------\n\nTITLE: Resolving Protocol Attribute Invariance with `@property` in Python\nDESCRIPTION: Presents the solution for the attribute invariance problem by making the protocol attribute read-only. By declaring the `content` attribute using `@property` in the `Box` protocol, it becomes covariant (read-only access). This makes `IntBox` (with its `content: int`) structurally compatible with `Box`, resolving the Mypy error. Dependency: `typing.Protocol`.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/protocols.rst#2025-04-22_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nclass Box(Protocol):\n    @property\n    def content(self) -> object: ...\n\nclass IntBox:\n    content: int # Assuming IntBox now takes content in __init__ or similar\n    def __init__(self, content: int) -> None:\n        self.content = content\n\ndef takes_box(box: Box) -> None: ...\n\ntakes_box(IntBox(42))  # OK\n```\n\n----------------------------------------\n\nTITLE: Defining NoReturn Functions in Python\nDESCRIPTION: Defines functions that never return using the NoReturn type. Dependencies include the typing module or typing_extensions for older Python versions. Functions with NoReturn raise exceptions making code after them unreachable.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/more_types.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import NoReturn\n\ndef stop() -> NoReturn:\n    raise Exception('no way')\n```\n\nLANGUAGE: python\nCODE:\n```\ndef f(x: int) -> int:\n    if x == 0:\n        return x\n    stop()\n    return 'whatever works'  # No error in an unreachable block\n```\n\n----------------------------------------\n\nTITLE: Correctly Ordering Overload Variants (Most Specific First) in Python\nDESCRIPTION: Shows the corrected version of the previous shadowing example. By ordering the overload variants from most specific (`Literal`) to least specific (`Expression`), the shadowing issue is resolved, and Mypy can correctly select the appropriate variant based on the input types. This follows the recommended practice.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/more_types.rst#2025-04-22_snippet_8\n\nLANGUAGE: python\nCODE:\n```\n# Everything is ok now -- the variants are correctly ordered\n# from most to least specific.\n\n@overload\ndef add(left: Literal, right: Literal) -> Literal: ...\n\n@overload\ndef add(left: Expression, right: Expression) -> Expression: ...\n\ndef add(left: Expression, right: Expression) -> Expression:\n    # ...snip...\n```\n\n----------------------------------------\n\nTITLE: Enabling Forward Reference with __future__ Annotations - Python\nDESCRIPTION: Shows correct use of the __future__ import to defer annotation evaluation and allow referencing a class before it is defined. Inputs are a function and a class; output is safe, error-free code usable with Mypy. Requires Python 3.7+ and __future__ import.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/runtime_troubles.rst#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom __future__ import annotations\n\ndef f(x: A) -> None: ...  # OK\nclass A: ...\n```\n\n----------------------------------------\n\nTITLE: Implementing Conditional Overloads with TYPE_CHECKING in Python\nDESCRIPTION: This example demonstrates how to use TYPE_CHECKING to conditionally define function overloads for types that might be unavailable at runtime. The function provides different type signatures based on the input type.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/more_types.rst#2025-04-22_snippet_12\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import TYPE_CHECKING, Any, overload\n\nif TYPE_CHECKING:\n    class A: ...\n    class B: ...\n\n\nif TYPE_CHECKING:\n    @overload\n    def func(var: A) -> A: ...\n\n    @overload\n    def func(var: B) -> B: ...\n\ndef func(var: Any) -> Any:\n    return var\n\n\nreveal_type(func(A()))  # Revealed type is \"A\"\n```\n\n----------------------------------------\n\nTITLE: TypeIs as a Method in a Validator Class - Python\nDESCRIPTION: This snippet shows how a class method (is_valid of Validator) can be written as a TypeIs function where the type narrowing applies to the argument after self. The process method demonstrates that to_validate is narrowed to str inside the if branch. The method pattern requires careful parameter ordering and works with method calls (self as the first parameter).\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/type_narrowing.rst#2025-04-22_snippet_17\n\nLANGUAGE: python\nCODE:\n```\nclass Validator:\n    def is_valid(self, instance: object) -> TypeIs[str]:\n        return isinstance(instance, str)\n\n    def process(self, to_validate: object) -> None:\n        if Validator().is_valid(to_validate):\n            reveal_type(to_validate)  # Revealed type is 'str'\n            print(to_validate.upper())  # ok: to_validate is str\n```\n\n----------------------------------------\n\nTITLE: Narrowing Tuple Types Using len() Checks\nDESCRIPTION: Example showing how Mypy 1.7 can narrow union types of tuples with different lengths based on len() checks, improving type safety when working with tuple unpacking.\nSOURCE: https://github.com/python/mypy/blob/master/CHANGELOG.md#2025-04-22_snippet_29\n\nLANGUAGE: python\nCODE:\n```\ndef f(t: tuple[int, int] | tuple[int, int, int]) -> None:\n    if len(t) == 2:\n        a, b = t   # Ok\n    ...\n```\n\n----------------------------------------\n\nTITLE: Defining Instance Variables Only in Methods Using 'self' - Python\nDESCRIPTION: Demonstrates that instance variables can only be created by explicit assignment through self within methods, not by assignment to arbitrary variables. Mypy will only recognize attributes attached to self, helping prevent errors from dynamic attribute creation.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/class_basics.rst#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nclass A:\n    def __init__(self) -> None:\n        self.y = 1   # Define 'y'\n        a = self\n        a.x = 1      # Error: 'x' not defined\n```\n\n----------------------------------------\n\nTITLE: Enabling Runtime `isinstance` Checks for Protocols in Python\nDESCRIPTION: Demonstrates using the `@typing.runtime_checkable` decorator on a protocol class (`Portable`) to enable runtime checks using `isinstance()`. This allows checking if an object (`Mug`) structurally conforms to the protocol at runtime, although the check is limited (e.g., it doesn't verify method signatures, only existence). Dependencies: `typing.Protocol`, `typing.runtime_checkable`.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/protocols.rst#2025-04-22_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Protocol, runtime_checkable\n\n@runtime_checkable\nclass Portable(Protocol):\n    handles: int\n\nclass Mug:\n    def __init__(self) -> None:\n        self.handles = 1\n\ndef use(handles: int) -> None: ...\n\nmug = Mug()\nif isinstance(mug, Portable):  # Works at runtime!\n   use(mug.handles)\n```\n\n----------------------------------------\n\nTITLE: Guarding None Values in Python with Mypy\nDESCRIPTION: Displays how Mypy infers types in conditional branches when none checks are performed. The 'concat' function demonstrates using conditional checks like 'is not None' to safely concatenate strings that may be 'None'.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/kinds_of_types.rst#2025-04-22_snippet_9\n\nLANGUAGE: Python\nCODE:\n```\ndef concat(x: str | None, y: str | None) -> str | None:\n    if x is not None and y is not None:\n        return x + y\n    else:\n        return None\n```\n\n----------------------------------------\n\nTITLE: Defining Enum and Revealing Member Types with Mypy in Python\nDESCRIPTION: This code defines a simple `Enum` called `Direction`. The `reveal_type` calls show that Mypy infers the type of individual enum members (e.g., `Direction.up`) as a `Literal` specific to that member.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/literal_types.rst#2025-04-22_snippet_14\n\nLANGUAGE: python\nCODE:\n```\nfrom enum import Enum\n\nclass Direction(Enum):\n    up = 'up'\n    down = 'down'\n\nreveal_type(Direction.up)  # Revealed type is \"Literal[Direction.up]?\"\nreveal_type(Direction.down)  # Revealed type is \"Literal[Direction.down]?\"\n```\n\n----------------------------------------\n\nTITLE: Type Checking with attrs.field and attrs.Factory\nDESCRIPTION: Illustrates how typeshed annotations for attrs.field and attrs.Factory help mypy provide better type checking for attrs classes.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/additional_features.rst#2025-04-22_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nimport attrs\n\n@attrs.define\nclass A:\n    one: int = attrs.field(8)\n    two: dict[str, str] = attrs.Factory(dict)\n    bad: str = attrs.field(16)   # Error: can't assign int to str\n```\n\n----------------------------------------\n\nTITLE: Defining Mypy Extensions Argument Specifiers (Python)\nDESCRIPTION: Shows the function signatures for the argument specifiers provided by `mypy_extensions`. These functions (`Arg`, `DefaultArg`, `NamedArg`, `DefaultNamedArg`, `VarArg`, `KwArg`) are used within `Callable` type hints to specify details about function arguments like name, type, optionality, and kind (positional, keyword, variadic). The `type` defaults to `Any`.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/additional_features.rst#2025-04-22_snippet_11\n\nLANGUAGE: python\nCODE:\n```\ndef Arg(type=Any, name=None):\n    # A normal, mandatory, positional argument.\n    # If the name is specified it may be passed as a keyword.\n\ndef DefaultArg(type=Any, name=None):\n    # An optional positional argument (i.e. with a default value).\n    # If the name is specified it may be passed as a keyword.\n\ndef NamedArg(type=Any, name=None):\n    # A mandatory keyword-only argument.\n\ndef DefaultNamedArg(type=Any, name=None):\n    # An optional keyword-only argument (i.e. with a default value).\n\ndef VarArg(type=Any):\n    # A *args-style variadic positional argument.\n    # A single VarArg() specifier represents all remaining\n    # positional arguments.\n\ndef KwArg(type=Any):\n    # A **kwargs-style variadic keyword argument.\n    # A single KwArg() specifier represents all remaining\n    # keyword arguments.\n```\n\n----------------------------------------\n\nTITLE: Defining Awaitable Protocol with __await__ (Python)\nDESCRIPTION: Implements the __await__ method required for collections.abc.Awaitable. Enables custom types to be awaited in async code. __await__ returns a generator; used for async/await constructs. Dependencies: typing.Generator, typing.Any.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/protocols.rst#2025-04-22_snippet_25\n\nLANGUAGE: python\nCODE:\n```\ndef __await__(self) -> Generator[Any, None, T]\n\n```\n\n----------------------------------------\n\nTITLE: Defining Extended Callable Type with Mypy Extensions (Python)\nDESCRIPTION: This snippet demonstrates defining a complex Python function `func` with various argument types (positional, default, varargs, keyword-only, default keyword-only, kwargs) and its corresponding `Callable` type `F` using argument specifiers (`Arg`, `DefaultArg`, `VarArg`, `NamedArg`, `DefaultNamedArg`, `KwArg`) from the `mypy_extensions` library. This feature is noted as deprecated.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/additional_features.rst#2025-04-22_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nfrom collections.abc import Callable\nfrom mypy_extensions import (Arg, DefaultArg, NamedArg,\n                            DefaultNamedArg, VarArg, KwArg)\n\ndef func(__a: int,  # This convention is for nameless arguments\n         b: int,\n         c: int = 0,\n         *args: int,\n         d: int,\n         e: int = 0,\n         **kwargs: int) -> int:\n    ...\n\nF = Callable[[int,  # Or Arg(int)\n              Arg(int, 'b'),\n              DefaultArg(int, 'c'),\n              VarArg(int),\n              NamedArg(int, 'd'),\n              DefaultNamedArg(int, 'e'),\n              KwArg(int)],\n             int]\n\nf: F = func\n```\n\n----------------------------------------\n\nTITLE: Defining a Type-Annotated Recursive Fibonacci Function (Python)\nDESCRIPTION: Python code defining a type-annotated recursive function `fib` to calculate Fibonacci numbers, saved as `fib.py`. It includes basic timing logic using the `time` module to measure execution time. Type annotations are crucial for achieving performance gains with mypyc.\nSOURCE: https://github.com/python/mypy/blob/master/mypyc/doc/getting_started.rst#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nimport time\n\ndef fib(n: int) -> int:\n    if n <= 1:\n        return n\n    else:\n        return fib(n - 2) + fib(n - 1)\n\nt0 = time.time()\nfib(32)\nprint(time.time() - t0)\n```\n\n----------------------------------------\n\nTITLE: Type Checking Overloads with Any Type Argument in Python\nDESCRIPTION: Shows an exception to the 'first match' rule for overload resolution in Mypy. If multiple variants match because an argument is typed as `Any`, Mypy infers the return type as `Any`. This snippet calls the previously defined `summarize` function with a variable explicitly typed as `Any`.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/more_types.rst#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\ndynamic_var: Any = some_dynamic_function()\n\n# output2 is of type 'Any'\noutput2 = summarize(dynamic_var)\n```\n\n----------------------------------------\n\nTITLE: Sharing TypeVar Across Generic Functions (Legacy Syntax)\nDESCRIPTION: Shows how a single `TypeVar` definition (`T = TypeVar('T')`) can be reused in the signatures of multiple generic functions (`first` and `last`) when using the legacy syntax. Both functions operate on a `Sequence[T]` and return a `T`.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/generics.rst#2025-04-22_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import TypeVar, Sequence\n\nT = TypeVar('T')      # Define type variable\n\ndef first(seq: Sequence[T]) -> T:\n    return seq[0]\n\ndef last(seq: Sequence[T]) -> T:\n    return seq[-1]\n```\n\n----------------------------------------\n\nTITLE: Using Iterable and Sequence Type Annotations in Python\nDESCRIPTION: Demonstrates the use of the Iterable generic type for functions that accept any iterable object. This function takes an iterable of integers and returns a list of strings.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/cheat_sheet_py3.rst#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\ndef f(ints: Iterable[int]) -> list[str]:\n    return [str(x) for x in ints]\n\nf(range(1, 3))\n```\n\n----------------------------------------\n\nTITLE: Declaring and Using Literal Type Variables in Python\nDESCRIPTION: Shows various ways to declare variables with literal types, including explicit annotations and using Final. Compares how type inference works with literals vs regular variables.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/literal_types.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\na: Literal[19] = 19\nreveal_type(a)          # Revealed type is \"Literal[19]\"\n\nb = 19\nreveal_type(b)          # Revealed type is \"int\"\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Attribute Invariance Issue in Python Protocols\nDESCRIPTION: Illustrates the concept of attribute invariance for mutable attributes in protocols. Defines a `Box` protocol with a writable `content: object` attribute. Shows that a class `IntBox` with a more specific writable attribute `content: int` is *not* considered a valid subtype by Mypy, causing an error when used where `Box` is expected. This prevents potential runtime type errors. Dependency: `typing.Protocol`.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/protocols.rst#2025-04-22_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nclass Box(Protocol):\n      content: object\n\nclass IntBox:\n      content: int\n\ndef takes_box(box: Box) -> None: ...\n\ntakes_box(IntBox())  # error: Argument 1 to \"takes_box\" has incompatible type \"IntBox\"; expected \"Box\"\n                     # note:  Following member(s) of \"IntBox\" have conflicts:\n                     # note:      content: expected \"object\", got \"int\"\n```\n\n----------------------------------------\n\nTITLE: Invalid Operations on Values Annotated as 'object' - Python\nDESCRIPTION: Demonstrates code that mypy will flag as errors when operating on variables of type 'object', specifically method calls, arithmetic, passing to APIs expecting more concrete types, and type-incompatible assignments. Highlights the difference with 'Any' where such errors would not be caught at analysis time. Intended for mypy users wanting to see statically enforced limits on generic types; errors are indicated in comments.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/dynamic_typing.rst#2025-04-22_snippet_6\n\nLANGUAGE: python\nCODE:\n```\ndef f(o: object) -> None:\n    o.foo()       # Error!\n    o + 2         # Error!\n    open(o)       # Error!\n    n: int = 1\n    n = o         # Error!\n```\n\n----------------------------------------\n\nTITLE: Implementing Decorator Factories with Generics (Python 3.12)\nDESCRIPTION: Demonstrates how to create a decorator factory (second-order decorator) that takes arguments and returns a decorator. This example uses Python 3.12's native type parameter syntax.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/generics.rst#2025-04-22_snippet_43\n\nLANGUAGE: python\nCODE:\n```\nfrom collections.abc import Callable\nfrom typing import Any\n\ndef route[F: Callable[..., Any]](url: str) -> Callable[[F], F]:\n    ...\n\n@route(url='/')\ndef index(request: Any) -> str:\n    return 'Hello world'\n```\n\n----------------------------------------\n\nTITLE: Creating a Dual-Mode Decorator with Overloads (Python 3.11)\nDESCRIPTION: Legacy version of a dual-mode decorator that can be used both with and without arguments, using TypeVar and Optional for Python 3.11 and earlier.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/generics.rst#2025-04-22_snippet_46\n\nLANGUAGE: python\nCODE:\n```\nfrom collections.abc import Callable\nfrom typing import Any, Optional, TypeVar, overload\n\nF = TypeVar('F', bound=Callable[..., Any])\n\n# Bare decorator usage\n@overload\ndef atomic(func: F, /) -> F: ...\n# Decorator with arguments\n@overload\ndef atomic(*, savepoint: bool = True) -> Callable[[F], F]: ...\n\n# Implementation\ndef atomic(func: Optional[Callable[..., Any]] = None, /, *, savepoint: bool = True):\n    ...  # Same as above\n```\n\n----------------------------------------\n\nTITLE: Defining Generic Protocols (Python 3.12)\nDESCRIPTION: Shows how to define and use generic protocols to specify interfaces with generic types. This example demonstrates structural subtyping with Python 3.12's native type parameter syntax.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/generics.rst#2025-04-22_snippet_47\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Protocol\n\nclass Box[T](Protocol):\n    content: T\n\ndef do_stuff(one: Box[str], other: Box[bytes]) -> None:\n    ...\n\nclass StringWrapper:\n    def __init__(self, content: str) -> None:\n        self.content = content\n\nclass BytesWrapper:\n    def __init__(self, content: bytes) -> None:\n        self.content = content\n\ndo_stuff(StringWrapper('one'), BytesWrapper(b'other'))  # OK\n\nx: Box[float] = ...\ny: Box[int] = ...\nx = y  # Error -- Box is invariant\n```\n\n----------------------------------------\n\nTITLE: Defining Reversible Protocol with __reversed__ (Python)\nDESCRIPTION: Implements __reversed__ to allow custom types to support the reversed() function per collections.abc.Reversible. Returns an iterator over T; useful in user-defined sequences or collections.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/protocols.rst#2025-04-22_snippet_18\n\nLANGUAGE: python\nCODE:\n```\ndef __reversed__(self) -> Iterator[T]\n\n```\n\n----------------------------------------\n\nTITLE: Modern Import Style for Iterable and Callable - Python\nDESCRIPTION: The snippet shows the modern recommended style for importing standard protocols and ABCs such as 'Iterable' and 'Callable' from 'collections.abc' instead of 'typing'. This is now best practice for new Python versions and shown in documentation updates. Dependencies: Python 3.9+. Key parameters: imported class names. Input: Import statement; output: reference to type for annotations. Limitation: Not valid before Python 3.3 for all collections.abc types.\nSOURCE: https://github.com/python/mypy/blob/master/CHANGELOG.md#2025-04-22_snippet_12\n\nLANGUAGE: python\nCODE:\n```\nfrom collections.abc import Iterable, Callable\n```\n\n----------------------------------------\n\nTITLE: Type Narrowing and Inner Function Binding - Python\nDESCRIPTION: This snippet illustrates late binding of closures in Python and shows a case where mypy cannot guarantee narrowed types are preserved inside inner functions. It demonstrates assigning x within an outer scope, reassigning, and returning a closure that uses x. No dependencies except typing.Callable. Highlights limitations in type narrowing for inner functions.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/common_issues.rst#2025-04-22_snippet_30\n\nLANGUAGE: python\nCODE:\n```\ndef foo(x: int | None) -> Callable[[], int]:\\n    if x is None:\\n        x = 5\\n    print(x + 1)  # mypy correctly deduces x must be an int here\\n    def inner() -> int:\\n        return x + 1  # but (correctly) complains about this line\\n\\n    x = None  # because x could later be assigned None\\n    return inner\\n\\ninner = foo(5)\\ninner()  # this will raise an error when called\n```\n\n----------------------------------------\n\nTITLE: Suppressing Mypy Type Errors by Line Using type: ignore in Python\nDESCRIPTION: Demonstrates how to suppress mypy type errors on a specific line by adding a '# type: ignore' inline comment. Useful for working around third-party stubs or legacy codebases where the types are temporarily incorrect. Only mypy error reporting is affected; runtime is unchanged.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/type_inference_and_annotations.rst#2025-04-22_snippet_14\n\nLANGUAGE: python\nCODE:\n```\n# Starting app on http://localhost:8000\\napp.run(8000)  # type: ignore\n```\n\n----------------------------------------\n\nTITLE: Untyped Function Parameters Default to 'Any' in Mypy - Python\nDESCRIPTION: Highlights that function parameters without a type annotation implicitly default to 'Any' in mypy. Uses 'reveal_type' for demonstration and shows that arbitrary operations are allowed on the untyped parameter. No dependencies are required besides mypy; limitations include that omitting parameter types disables much of mypy's checking, and enabling flags like '--disallow-untyped-defs' can surface missing types.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/dynamic_typing.rst#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ndef f(x) -> None:\n    reveal_type(x)  # Revealed type is \"Any\"\n    x.can.do[\"anything\", x](\"wants\", 2)\n```\n\n----------------------------------------\n\nTITLE: Using Self Type in Python Class Definitions\nDESCRIPTION: Shows the implementation of the new Self type feature for creating generic self types in class definitions, introduced in PEP 673.\nSOURCE: https://github.com/python/mypy/blob/master/CHANGELOG.md#2025-04-22_snippet_50\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Self\n\nclass Friend:\n    other: Self | None = None\n\n    @classmethod\n    def make_pair(cls) -> tuple[Self, Self]:\n        a, b = cls(), cls()\n        a.other = b\n        b.other = a\n        return a, b\n\nclass SuperFriend(Friend):\n    pass\n\n# a and b have the inferred type \"SuperFriend\", not \"Friend\"\na, b = SuperFriend.make_pair()\n```\n\n----------------------------------------\n\nTITLE: Defining SupportsInt Protocol with __int__ (Python)\nDESCRIPTION: Lays out the __int__ method for typing.SupportsInt; required to use int(x) on objects. No arithmetic required. Returns an int.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/protocols.rst#2025-04-22_snippet_23\n\nLANGUAGE: python\nCODE:\n```\ndef __int__(self) -> int\n\n```\n\n----------------------------------------\n\nTITLE: Inline Adjustment of Mypy Error Codes\nDESCRIPTION: The Python snippet includes a comment to adjust error codes via inline configuration. This demonstrates overriding module or global settings at the file level using Mypy specific inline comments.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/error_codes.rst#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n# mypy: enable-error-code=\"truthy-bool, ignore-without-code\"\n```\n\n----------------------------------------\n\nTITLE: Defining and Using Generic MyPy Native Classes with Runtime Type Erasure (Python)\nDESCRIPTION: Demonstrates the creation of a generic native class `Box[T]`. It highlights that due to runtime type erasure, casting an instance (e.g., `Box[int]`) to an incompatible generic type (`Box[str]`) using `cast` does not raise an immediate error, but accessing the attribute (`item`) later causes a runtime error because the underlying data type doesn't match the expected type.\nSOURCE: https://github.com/python/mypy/blob/master/mypyc/doc/native_classes.rst#2025-04-22_snippet_5\n\nLANGUAGE: Python\nCODE:\n```\nfrom typing import TypeVar, Generic, cast\n\nT = TypeVar('T')\n\nclass Box(Generic[T]):\n    def __init__(self, item: T) -> None:\n        self.item = item\n\nx = Box(1)  # Box[int]\ny = cast(Box[str], x)  # OK (type variable value not checked)\ny.item  # Runtime error: item is \"int\", but \"str\" expected\n```\n\n----------------------------------------\n\nTITLE: Type Checking Missing Required Keys in TypedDict - Python\nDESCRIPTION: Demonstrates a type error when initializing a variable typed as Movie with a dictionary missing a required key ('year'). Type checkers like mypy will raise an error since all keys are required by default in TypedDict.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/typed_dict.rst#2025-04-22_snippet_7\n\nLANGUAGE: python\nCODE:\n```\n# Error: 'year' missing\ntoy_story: Movie = {'name': 'Toy Story'}\n```\n\n----------------------------------------\n\nTITLE: Generic Function with Upper Bound in Legacy Python Syntax\nDESCRIPTION: This snippet details the legacy way (Python 3.11 and earlier) of defining a generic function with a type variable constrained by an upper bound. It uses the TypeVar with a bound parameter to restrict T to being a subtype of SupportsAbs, enabling methods like abs to be used on it.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/generics.rst#2025-04-22_snippet_14\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import TypeVar, SupportsAbs\n\nT = TypeVar('T', bound=SupportsAbs[float])\n\ndef max_by_abs(*xs: T) -> T:\n    return max(xs, key=abs)\n```\n\n----------------------------------------\n\nTITLE: Demonstrating explicit-override error code in Python with mypy\nDESCRIPTION: Shows how mypy can require the @override decorator when overriding a base class method to make overrides more explicit and safer.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/error_code_list2.rst#2025-04-22_snippet_19\n\nLANGUAGE: python\nCODE:\n```\n# mypy: enable-error-code=\"explicit-override\"\n\nfrom typing import override\n\nclass Parent:\n    def f(self, x: int) -> None:\n        pass\n\n    def g(self, y: int) -> None:\n        pass\n\n\nclass Child(Parent):\n    def f(self, x: int) -> None:  # Error: Missing @override decorator\n        pass\n\n    @override\n    def g(self, y: int) -> None:\n        pass\n```\n\n----------------------------------------\n\nTITLE: Defining a Basic Callable Type (Python)\nDESCRIPTION: This snippet shows a standard `Callable` type hint from `collections.abc` (or `typing`) specifying a function that takes an `int`, a `str`, and another `int` as positional arguments and returns a `float`. This serves as a baseline for comparison with extended callable types.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/additional_features.rst#2025-04-22_snippet_12\n\nLANGUAGE: python\nCODE:\n```\nMyFunc = Callable[[int, str, int], float]\n```\n\n----------------------------------------\n\nTITLE: Implementing Literal Exhaustiveness Check with assert_never in Python\nDESCRIPTION: This code demonstrates how to use `assert_never` from `typing_extensions` to ensure all cases of a `Literal` type (`PossibleValues`) are handled within the `validate` function. Mypy will check that the `assert_never` line is unreachable.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/literal_types.rst#2025-04-22_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Literal, NoReturn\nfrom typing_extensions import assert_never\n\nPossibleValues = Literal['one', 'two']\n\ndef validate(x: PossibleValues) -> bool:\n    if x == 'one':\n        return True\n    elif x == 'two':\n        return False\n    assert_never(x)\n```\n\n----------------------------------------\n\nTITLE: Method Decorator Usages for Properties and Abstract Methods - Python\nDESCRIPTION: Illustrates usage of Python standard method decorators @property, @staticmethod, @classmethod, and @abc.abstractmethod. These modify class method behaviors for instance, class, static or abstract semantics. Requires the 'abc' module for abstract methods.\nSOURCE: https://github.com/python/mypy/blob/master/mypyc/doc/native_operations.rst#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n@property\n```\n\nLANGUAGE: python\nCODE:\n```\n@staticmethod\n```\n\nLANGUAGE: python\nCODE:\n```\n@classmethod\n```\n\nLANGUAGE: python\nCODE:\n```\n@abc.abstractmethod\n```\n\n----------------------------------------\n\nTITLE: Applying @final to Overloaded Methods in Python\nDESCRIPTION: Demonstrates declaring overloaded methods with typing.overload and enforcing finality on the underlying implementation with typing.final. The base class defines two overloads and a final method implementation. Inputs are annotated method definitions using overload/final decorators; output is a mypy error if a subclass attempts to override method. Requires typing.final, typing.overload, mypy.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/final_attrs.rst#2025-04-22_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import final, overload\n\nclass Base:\n    @overload\n    def method(self) -> None: ...\n    @overload\n    def method(self, arg: int) -> int: ...\n    @final\n    def method(self, x=None):\n        ...\n```\n\n----------------------------------------\n\nTITLE: Defining and Validating Callback Protocols with Python Protocols (Python)\nDESCRIPTION: This snippet defines a Combiner protocol with a strict __call__ signature and demonstrates validating type correctness of callback implementations with mypy. Dependencies: Python 3.8+ (for Protocols and type hints), collections.abc, typing. Inputs are callback conformers; outputs are checked for match. Parameter names and order are enforced to ensure compatibility and mypy will raise if they differ.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/protocols.rst#2025-04-22_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nfrom collections.abc import Iterable\nfrom typing import Optional, Protocol\n\nclass Combiner(Protocol):\n    def __call__(self, *vals: bytes, maxlen: int | None = None) -> list[bytes]: ...\n\ndef batch_proc(data: Iterable[bytes], cb_results: Combiner) -> bytes:\n    for item in data:\n        ...\n\ndef good_cb(*vals: bytes, maxlen: int | None = None) -> list[bytes]:\n    ...\ndef bad_cb(*vals: bytes, maxitems: int | None) -> list[bytes]:\n    ...\n\nbatch_proc([], good_cb)  # OK\nbatch_proc([], bad_cb)   # Error! Argument 2 has incompatible type because of\n                         # different name and kind in the callback\n\n```\n\n----------------------------------------\n\nTITLE: Valid Variable Redefinition with More Precise Types\nDESCRIPTION: Example demonstrating how a variable can be redefined with a more precise or concrete type, such as converting a generic sequence to a list to use list-specific methods.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/common_issues.rst#2025-04-22_snippet_11\n\nLANGUAGE: python\nCODE:\n```\ndef f(x: Sequence[int]) -> None:\n    # Type of x is Sequence[int] here; we don't know the concrete type.\n    x = list(x)\n    # Type of x is list[int] here.\n    x.sort()  # Okay!\n```\n\n----------------------------------------\n\nTITLE: Using @override Decorator for Explicit Overrides - Python\nDESCRIPTION: Demonstrates how to mark an overriding method explicitly with the @override decorator from typing or typing_extensions, which helps mypy flag missing overrides and supports maintenance by making intentions clear. Highlights error detection when the base method name changes.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/class_basics.rst#2025-04-22_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import override\n\nclass Base:\n    def f(self, x: int) -> None:\n        ...\n    def g_renamed(self, y: str) -> None:\n        ...\n\nclass Derived1(Base):\n    @override\n    def f(self, x: int) -> None:   # OK\n        ...\n\n    @override\n    def g(self, y: str) -> None:   # Error: no corresponding base method found\n        ...\n```\n\n----------------------------------------\n\nTITLE: Untyped __init__ Method Causing Any Type Leakage\nDESCRIPTION: Example demonstrating how an untyped __init__ method can cause instance variables to have 'Any' type, allowing type errors to go undetected by mypy.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/common_issues.rst#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nclass Bad:\n    def __init__(self):\n        self.value = \"asdf\"\n        1 + \"asdf\"  # No error!\n\nbad = Bad()\nbad.value + 1           # No error!\nreveal_type(bad)        # Revealed type is \"__main__.Bad\"\nreveal_type(bad.value)  # Revealed type is \"Any\"\n\nclass Good:\n    def __init__(self) -> None:  # Explicitly return None\n        self.value = value\n```\n\n----------------------------------------\n\nTITLE: Using Ordering Capabilities in Dataclasses with mypy\nDESCRIPTION: Shows how mypy detects special methods in dataclasses based on the flags used to define them, specifically focusing on ordering functionality.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/additional_features.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom dataclasses import dataclass\n\n@dataclass(order=True)\nclass OrderedPoint:\n    x: int\n    y: int\n\n@dataclass(order=False)\nclass UnorderedPoint:\n    x: int\n    y: int\n\nOrderedPoint(1, 2) < OrderedPoint(3, 4)  # OK\nUnorderedPoint(1, 2) < UnorderedPoint(3, 4)  # Error: Unsupported operand types\n```\n\n----------------------------------------\n\nTITLE: Using IO Type Annotation for File-like Objects in Python\nDESCRIPTION: Demonstrates the IO generic type for functions that work with file-like objects. This function returns different standard streams (stdout or stdin) based on the input mode.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/cheat_sheet_py3.rst#2025-04-22_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nimport sys\nfrom typing import IO\n\n# Use IO[str] or IO[bytes] for functions that should accept or return\n# objects that come from an open() call (note that IO does not\n# distinguish between reading, writing or other modes)\ndef get_sys_IO(mode: str = 'w') -> IO[str]:\n    if mode == 'w':\n        return sys.stdout\n    elif mode == 'r':\n        return sys.stdin\n    else:\n        return sys.stdout\n```\n\n----------------------------------------\n\nTITLE: String Formatting Type Safety in Python\nDESCRIPTION: Examples of type-safe string formatting checks including format specifiers and argument count validation.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/error_code_list.rst#2025-04-22_snippet_37\n\nLANGUAGE: python\nCODE:\n```\n\"{} and {}\".format(\"spam\")\n\"{} and {}\".format(\"spam\", \"eggs\")  # OK\n\"{} and {}\".format(\"spam\", \"eggs\", \"cheese\")\n\n\"{:d}\".format(3.14)\n```\n\n----------------------------------------\n\nTITLE: Defining a Value-Restricted TypeVar for concat Function - Python <=3.11\nDESCRIPTION: Shows legacy syntax for value-restricted type variables using TypeVar from typing, limited to str and bytes. The function concat enforces that both arguments and return are the same accepted type, preventing improper usage. The only dependencies are from the typing library.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/generics.rst#2025-04-22_snippet_27\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import TypeVar\n\nAnyStr = TypeVar('AnyStr', str, bytes)\n\ndef concat(x: AnyStr, y: AnyStr) -> AnyStr:\n    return x + y\n```\n\n----------------------------------------\n\nTITLE: Narrowing For Loop Index Variable Types for TypedDict Access in Python\nDESCRIPTION: This example shows how Mypy now narrows the type of for loop index variables to preserve literal types, benefiting safety and correctness in TypedDict lookups. The function func takes a TypedDict X and iterates through known keys as string literals; mypy's reveal_type confirms static understanding of these as Literal types, and no literal-required error is triggered for x[var] lookups. Requires Python 3.8+ and the typing.TypedDict feature; demonstrates how Mypy infers precise types for dynamic keys in a dictionary access pattern.\nSOURCE: https://github.com/python/mypy/blob/master/CHANGELOG.md#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import TypedDict\n\nclass X(TypedDict):\n    hourly: int\n    daily: int\n\ndef func(x: X) -> int:\n    s = 0\n    for var in (\"hourly\", \"daily\"):\n        # \"Union[Literal['hourly']?, Literal['daily']?]\"\n        reveal_type(var)\n\n        # x[var] no longer triggers a literal-required error\n        s += x[var]\n    return s\n```\n\n----------------------------------------\n\nTITLE: Defining Variable with type[...] Annotation - Python\nDESCRIPTION: This Python snippet demonstrates defining a variable with an explicit type using the type[...] annotation. It defines a simple class A and a variable tp of type type[A], assigned to the class itself. This clarifies variable vs type aliasing. No external dependencies are required. Expected input: none; Output: type variable definition.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/common_issues.rst#2025-04-22_snippet_21\n\nLANGUAGE: python\nCODE:\n```\nclass A: ...\\ntp: type[A] = A\n```\n\n----------------------------------------\n\nTITLE: Type Cast Runtime Checking\nDESCRIPTION: Illustrates how type casts are enforced at runtime in Mypyc, performing strict type checking unlike regular Python casts.\nSOURCE: https://github.com/python/mypy/blob/master/mypyc/doc/differences_from_python.rst#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import cast\n...\nx = cast(str, y)\n```\n\n----------------------------------------\n\nTITLE: Demonstrating mutable-override error code in Python with mypy\nDESCRIPTION: Shows how mypy can detect unsafe overrides of mutable attributes where a derived class uses a more restrictive type than the base class.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/error_code_list2.rst#2025-04-22_snippet_20\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Any\n\nclass C:\n    x: float\n    y: float\n    z: float\n\nclass D(C):\n    x: int  # Error: Covariant override of a mutable attribute\n            # (base class \"C\" defined the type as \"float\",\n            # expression has type \"int\")  [mutable-override]\n    y: float  # OK\n    z: Any  # OK\n\ndef f(c: C) -> None:\n    c.x = 1.1\nd = D()\nf(d)\nd.x >> 1  # This will crash at runtime, because d.x is now float, not an int\n```\n\n----------------------------------------\n\nTITLE: Advanced Generator with Send/Return Types\nDESCRIPTION: Generator function using Generator type annotation with yield, send, and return types specified.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/kinds_of_types.rst#2025-04-22_snippet_21\n\nLANGUAGE: python\nCODE:\n```\ndef echo_round() -> Generator[int, float, str]:\n    sent = yield 0\n    while sent >= 0:\n        sent = yield round(sent)\n    return 'Done'\n```\n\n----------------------------------------\n\nTITLE: Checking Unreachable Code in Python with Mypy\nDESCRIPTION: This code snippet utilizes the --warn-unreachable option in mypy to detect code branches that can never be executed, which is often indicative of logic errors and can help in cleaning up the code.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/error_code_list2.rst#2025-04-22_snippet_8\n\nLANGUAGE: python\nCODE:\n```\n# mypy: warn-unreachable\n\ndef example(x: int) -> None:\n    # Error: Right operand of \"or\" is never evaluated  [unreachable]\n    assert isinstance(x, int) or x == 'unused'\n\n    return\n    # Error: Statement is unreachable  [unreachable]\n    print('unreachable')\n```\n\n----------------------------------------\n\nTITLE: Type Inference for Empty Lists with Subsequent Operations\nDESCRIPTION: Example demonstrating how mypy can infer the type of an initially empty list when operations like append are performed on it in the same scope.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/common_issues.rst#2025-04-22_snippet_9\n\nLANGUAGE: python\nCODE:\n```\na = []  # Okay because followed by append, inferred type list[int]\nfor i in range(n):\n    a.append(i * i)\n```\n\n----------------------------------------\n\nTITLE: Allowing Redefinition of Variables with Mypy\nDESCRIPTION: This code demonstrates how to redefine variables within the same block or scope using the \"--allow-redefinition\" flag in mypy. This snippet shows a function where a list is redefined, and later redefinitions alter the variable's type. The variable must be used before any redefinition occurs, illustrating scope limitations on redefinition.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/command_line.rst#2025-04-22_snippet_7\n\nLANGUAGE: python\nCODE:\n```\ndef process(items: list[str]) -> None:\n    # 'items' has type list[str]\n    items = [item.split() for item in items]\n    # 'items' now has type list[list[str]]\n```\n\nLANGUAGE: python\nCODE:\n```\ndef process(items: list[str]) -> None:\n   items = \"mypy\"  # invalid redefinition to str because the variable hasn't been used yet\n   print(items)\n   items = \"100\"  # valid, items now has type str\n   items = int(items)  # valid, items now has type int\n```\n\n----------------------------------------\n\nTITLE: Defining ReadOnly Fields in a TypedDict - Python\nDESCRIPTION: Uses the ReadOnly marker (introduced in Python 3.13/typing_extensions) to declare a field as immutable after initialization. Demonstrates error detection on assignment and allowed operations. Requires 'from typing import TypedDict' and 'from typing_extensions import ReadOnly' on Python <3.13.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/typed_dict.rst#2025-04-22_snippet_13\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import TypedDict\n\n# Or \"from typing ...\" on Python 3.13+\nfrom typing_extensions import ReadOnly\n\nclass Movie(TypedDict):\n    name: ReadOnly[str]\n    num_watched: int\n\nm: Movie = {\"name\": \"Jaws\", \"num_watched\": 1}\nm[\"name\"] = \"The Godfather\"  # Error: \"name\" is read-only\nm[\"num_watched\"] += 1  # OK\n```\n\n----------------------------------------\n\nTITLE: Generic Method with TypeVar in Legacy Syntax\nDESCRIPTION: This snippet explains the legacy (3.11 or earlier) Python syntax for creating a factory method with a generic clause using the TypeVar construct, allowing precise type constraints for class methods and their implementations, enabling chained factory method calls.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/generics.rst#2025-04-22_snippet_18\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import TypeVar\n\nT = TypeVar('T', bound='Friend')\n\nclass Friend:\n    other: \"Friend | None\" = None\n\n    @classmethod\n    def make_pair(cls: type[T]) -> tuple[T, T]:\n        a, b = cls(), cls()\n        a.other = b\n        b.other = a\n        return a, b\n\nclass SuperFriend(Friend):\n    pass\n\na, b = SuperFriend.make_pair()\n```\n\n----------------------------------------\n\nTITLE: Using Alternative Tag Types with Generic Classes in Python 3.12\nDESCRIPTION: Shows how to implement tagged unions with different tag types including generic classes. Demonstrates the limitation of using isinstance with generic types and provides an alternative approach for type narrowing.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/literal_types.rst#2025-04-22_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nclass Wrapper[T]:\n    def __init__(self, inner: T) -> None:\n        self.inner = inner\n\ndef process(w: Wrapper[int] | Wrapper[str]) -> None:\n    # Doing `if isinstance(w, Wrapper[int])` does not work: isinstance requires\n    # that the second argument always be an *erased* type, with no generics.\n    # This is because generics are a typing-only concept and do not exist at\n```\n\n----------------------------------------\n\nTITLE: Handling Unreachable Code in Mypy\nDESCRIPTION: Demonstrates Mypy's handling of code deemed unreachable with a focus on type narrowing and assert statements.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/type_narrowing.rst#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ndef function(arg: int):\n    # error: Subclass of \"int\" and \"str\" cannot exist:\n    # would have incompatible method signatures\n    assert isinstance(arg, str)\n\n    # error: Statement is unreachable\n    print(\"so mypy concludes the assert will always trigger\")\n\nx: int = 1\nassert isinstance(x, str)\nreveal_type(x)  # Revealed type is \"builtins.int\"\nprint(x + '!')  # Typechecks with `mypy`, but fails in runtime.\n```\n\n----------------------------------------\n\nTITLE: Basic Generator with Iterator Type\nDESCRIPTION: Simple generator function annotated with Iterator type that yields squared numbers.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/kinds_of_types.rst#2025-04-22_snippet_20\n\nLANGUAGE: python\nCODE:\n```\ndef squares(n: int) -> Iterator[int]:\n    for i in range(n):\n        yield i * i\n```\n\n----------------------------------------\n\nTITLE: Using typing.TYPE_CHECKING to Handle Import Cycles in Annotations - Python\nDESCRIPTION: This pair of snippets demonstrates how to defer type-only imports using typing.TYPE_CHECKING to avoid import cycles causing runtime errors. Imports inside the TYPE_CHECKING block are only evaluated during static analysis, preventing ImportError or module initialization issues. Inputs involve cross-referencing modules; outputs are import-safe code functioning both at runtime and during type-checking. Dependencies: appropriate module structure and Python's typing module.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/runtime_troubles.rst#2025-04-22_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import TYPE_CHECKING\n\nif TYPE_CHECKING:\n    import bar\n\ndef listify(arg: 'bar.BarClass') -> 'list[bar.BarClass]':\n    return [arg]\n```\n\nLANGUAGE: python\nCODE:\n```\nfrom foo import listify\n\nclass BarClass:\n    def listifyme(self) -> 'list[BarClass]':\n        return listify(self)\n```\n\n----------------------------------------\n\nTITLE: Intelligent Indexing with Literal Types in Python\nDESCRIPTION: Shows how to use Literal types for precise indexing into tuples and TypedDicts. This enables mypy to track exact index types and provide more specific type checking for heterogeneous data structures.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/literal_types.rst#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import TypedDict\n\ntup = (\"foo\", 3.4)\n\n# Indexing with an int literal gives us the exact type for that index\nreveal_type(tup[0])  # Revealed type is \"str\"\n\n# But what if we want the index to be a variable? Normally mypy won't\n# know exactly what the index is and so will return a less precise type:\nint_index = 0\nreveal_type(tup[int_index])  # Revealed type is \"Union[str, float]\"\n\n# But if we use either Literal types or a Final int, we can gain back\n# the precision we originally had:\nlit_index: Literal[0] = 0\nfin_index: Final = 0\nreveal_type(tup[lit_index])  # Revealed type is \"str\"\nreveal_type(tup[fin_index])  # Revealed type is \"str\"\n\n# We can do the same thing with with TypedDict and str keys:\nclass MyDict(TypedDict):\n    name: str\n    main_id: int\n    backup_id: int\n\nd: MyDict = {\"name\": \"Saanvi\", \"main_id\": 111, \"backup_id\": 222}\nname_key: Final = \"name\"\nreveal_type(d[name_key])  # Revealed type is \"str\"\n\n# You can also index using unions of literals\nid_key: Literal[\"main_id\", \"backup_id\"]\nreveal_type(d[id_key])    # Revealed type is \"int\"\n```\n\n----------------------------------------\n\nTITLE: Invalid Explicit Type Argument Passing for Generic Functions\nDESCRIPTION: Illustrates an incorrect usage pattern for generic functions. Unlike generic classes, type arguments cannot be explicitly provided when calling a generic function (e.g., `first[int]([1, 2])`). Mypy always infers these type arguments based on the actual arguments passed to the function.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/generics.rst#2025-04-22_snippet_12\n\nLANGUAGE: python\nCODE:\n```\nfirst[int]([1, 2])  # Error: can't use [...] with generic function\n```\n\n----------------------------------------\n\nTITLE: Defining Basic Callable with Explicit Arg Specifier (Python)\nDESCRIPTION: This snippet demonstrates that a standard `Callable[[int, str, int], float]` type hint is equivalent to using the `Arg` specifier from `mypy_extensions` for each positional argument: `Callable[[Arg(int), Arg(str), Arg(int)], float]`. It clarifies the default behavior represented by `Arg`.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/additional_features.rst#2025-04-22_snippet_13\n\nLANGUAGE: python\nCODE:\n```\nMyFunc = Callable[[Arg(int), Arg(str), Arg(int)], float]\n```\n\n----------------------------------------\n\nTITLE: Demonstrating unused-awaitable error code in Python with mypy\nDESCRIPTION: Shows how mypy detects when awaitable return values are not used, which could indicate missing 'await' keywords in asynchronous code.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/error_code_list2.rst#2025-04-22_snippet_15\n\nLANGUAGE: python\nCODE:\n```\n# mypy: enable-error-code=\"unused-awaitable\"\n\nimport asyncio\n\nasync def f() -> int: ...\n\nasync def g() -> None:\n    # Error: Value of type \"Task[int]\" must be used\n    #        Are you missing an await?\n    asyncio.create_task(f())\n```\n\n----------------------------------------\n\nTITLE: Using TypedDict for **kwargs Typing with Unpack\nDESCRIPTION: Example demonstrating how to use TypedDict with Unpack to provide type annotations for **kwargs parameters in function definitions, enabling type checking for keyword arguments.\nSOURCE: https://github.com/python/mypy/blob/master/CHANGELOG.md#2025-04-22_snippet_26\n\nLANGUAGE: python\nCODE:\n```\n# Or 'from typing_extensions import ...'\nfrom typing import TypedDict, Unpack\n\nclass Person(TypedDict):\n    name: str\n    age: int\n\ndef foo(**kwargs: Unpack[Person]) -> None:\n    ...\n\nfoo(name=\"x\", age=1)  # Ok\nfoo(name=1)  # Error\n```\n\n----------------------------------------\n\nTITLE: Overlapping Overloaded Functions Check in Python\nDESCRIPTION: Shows how Mypy detects potentially unsafe overlapping overload variants with incompatible return types.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/error_code_list.rst#2025-04-22_snippet_39\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import overload\n\nclass A: ...\nclass B(A): ...\n\n@overload\ndef foo(x: B) -> int: ...  # Error: Overloaded function signatures 1 and 2 overlap with incompatible return types  [overload-overlap]\n@overload\ndef foo(x: A) -> str: ...\ndef foo(x): ...\n\ndef takes_a(a: A) -> str:\n    return foo(a)\n\na: A = B()\nvalue = takes_a(a)\nreveal_type(value) # Revealed type is \"builtins.str\"\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Dynamic Typing and 'Any' with Mypy - Python\nDESCRIPTION: Shows assignment and typing rules in mypy when using the 'Any' type, clarifying how dynamic typing works, and which operations mypy will or will not check. Explicitly demonstrates the difference between statically and dynamically typed assignments, including how 'Any' allows bypassing normal checks. Requires 'typing.Any' from the standard library and mypy for type checking; no other dependencies. Inputs are various types assigned to variables, outputs are inferred types and mypy diagnostics; illustrates limitations of relying on 'Any' for correctness.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/dynamic_typing.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Any\n\nnum = 1         # Statically typed (inferred to be int)\nnum = 'x'       # error: Incompatible types in assignment (expression has type \"str\", variable has type \"int\")\n\ndyn: Any = 1    # Dynamically typed (type Any)\ndyn = 'x'       # OK\n\nnum = dyn       # No error, mypy will let you assign a value of type Any to any variable\nnum += 1        # Oops, mypy still thinks num is an int\n```\n\n----------------------------------------\n\nTITLE: Check Abstract Method Calls via Super in Python\nDESCRIPTION: Shows Mypy's error when calling an abstract method using super() that lacks a concrete implementation. This highlights the necessity to ensure methods called via super() have concrete implementations to prevent runtime errors.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/error_code_list.rst#2025-04-22_snippet_26\n\nLANGUAGE: python\nCODE:\n```\nfrom abc import abstractmethod\nclass Base:\n    @abstractmethod\n    def foo(self) -> int: ...\nclass Sub(Base):\n    def foo(self) -> int:\n        return super().foo() + 1  # error: Call to abstract method \"foo\" of \"Base\" with\n                                  # trivial body via super() is unsafe  [safe-super]\nSub().foo()  # This will crash at runtime.\n```\n\n----------------------------------------\n\nTITLE: Disabling Type Checking for Functions or Classes via @typing.no_type_check Decorator in Python\nDESCRIPTION: This snippet uses the '@typing.no_type_check' decorator to disable all mypy type checks for a specific function. Mistyped return values or type mismatches within the decorated scope will not raise errors. This mechanism is helpful for gradually migrating legacy code or disabling checking where correctness can be trusted.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/type_inference_and_annotations.rst#2025-04-22_snippet_19\n\nLANGUAGE: python\nCODE:\n```\n@typing.no_type_check\\ndef foo() -> str:\\n   return 12345  # No error!\n```\n\n----------------------------------------\n\nTITLE: Integrating mypy API in Python - Python\nDESCRIPTION: Demonstrates how to embed mypy type checking directly within a Python application using the mypy.api module. The example shows how to call api.run() with a set of command-line arguments and process the normal and error reports as well as the exit status. Dependencies: Python 3, mypy installed and importable. The sys.argv parameter is used to supply arguments dynamically; outputs are displayed on standard output and error.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/extending_mypy.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport sys\nfrom mypy import api\n\nresult = api.run(sys.argv[1:])\n\nif result[0]:\n    print('\\nType checking report:\\n')\n    print(result[0])  # stdout\n\nif result[1]:\n    print('\\nError report:\\n')\n    print(result[1])  # stderr\n\nprint('\\nExit status:', result[2])\n\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Duck Type Compatibility with int and float in Python\nDESCRIPTION: This code snippet shows how Mypy allows an int object to be used where a float is expected, demonstrating duck type compatibility. The function degrees_to_radians takes a float parameter but can be called with an int without issues.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/duck_type_compatibility.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport math\n\ndef degrees_to_radians(degrees: float) -> float:\n    return math.pi * degrees / 180\n\nn = 90  # Inferred type 'int'\nprint(degrees_to_radians(n))  # Okay!\n```\n\n----------------------------------------\n\nTITLE: Defining a Generic Function (Legacy Syntax)\nDESCRIPTION: Defines the same generic function `first` using the legacy syntax (Python <= 3.11). This requires importing `TypeVar` from `typing`, defining `T = TypeVar('T')`, and using `T` within the function signature `def first(seq: Sequence[T]) -> T:`.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/generics.rst#2025-04-22_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import TypeVar, Sequence\n\nT = TypeVar('T')\n\n# A generic function!\ndef first(seq: Sequence[T]) -> T:\n    return seq[0]\n```\n\n----------------------------------------\n\nTITLE: Properly Typed Function Decorator with Callable TypeVar - Python 3.12+\nDESCRIPTION: Shows how to type annotate a decorator using a type parameter (function signature preserved) in Python 3.12+ using Callable and Any from typing, along with cast for the wrapper. This approach allows mypy to type check uses of the decorated function properly. Dependencies: typing module (Callable, Any, cast).\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/generics.rst#2025-04-22_snippet_35\n\nLANGUAGE: python\nCODE:\n```\nfrom collections.abc import Callable\nfrom typing import Any, cast\n\n# A decorator that preserves the signature.\ndef printing_decorator[F: Callable[..., Any]](func: F) -> F:\n    def wrapper(*args, **kwds):\n        print(\"Calling\", func)\n        return func(*args, **kwds)\n    return cast(F, wrapper)\n\n@printing_decorator\ndef add_forty_two(value: int) -> int:\n    return value + 42\n\na = add_forty_two(3)\nreveal_type(a)      # Revealed type is \"builtins.int\"\nadd_forty_two('x')  # Argument 1 to \"add_forty_two\" has incompatible type \"str\"; expected \"int\"\n```\n\n----------------------------------------\n\nTITLE: Asserting Type Narrowing in Mypy\nDESCRIPTION: Illustrates the use of assert statements to enforce type narrowing in Mypy.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/type_narrowing.rst#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ndef function(arg: Any):\n    assert isinstance(arg, int)\n    reveal_type(arg)  # Revealed type: \"builtins.int\"\n```\n\n----------------------------------------\n\nTITLE: Defining Protocol and Abstract Methods in Python\nDESCRIPTION: This snippet demonstrates the use of abstract methods in a class and how return statements are checked by Mypy. The snippet shows the differences in error reporting for abstract and non-abstract methods.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/error_code_list.rst#2025-04-22_snippet_12\n\nLANGUAGE: python\nCODE:\n```\n@abstractmethod\ndef foo(self) -> int:\n    pass  # OK\ndef bar(self) -> int:\n    pass  # Error: Missing return statement  [empty-body]\n\nclass Proto(Protocol):\n    def bar(self) -> int:\n        pass  # OK\n```\n\n----------------------------------------\n\nTITLE: Safe Handling of Abstract Type Object Types in Python\nDESCRIPTION: Describes how Mypy handles instantiation of abstract types via type objects and reports errors if an abstract type is used where a non-abstract type is expected, particularly in object factory patterns.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/error_code_list.rst#2025-04-22_snippet_25\n\nLANGUAGE: python\nCODE:\n```\nfrom abc import ABCMeta, abstractmethod\n\nclass Config(metaclass=ABCMeta):\n    @abstractmethod\n    def get_value(self, attr: str) -> str: ...\n\ndef make_many[T](typ: type[T], n: int) -> list[T]:\n    return [typ() for _ in range(n)]  # This will raise if typ is abstract\n\n# Error: Only concrete class can be given where \"type[Config]\" is expected [type-abstract]\nmake_many(Config, 5)\n```\n\n----------------------------------------\n\nTITLE: Overloaded Self-Type for Precise Method Typing\nDESCRIPTION: This snippet demonstrates using overloads with self-types to express precise types for methods with different behaviors based on the generic type argument. The export method has different signatures depending on the content type.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/more_types.rst#2025-04-22_snippet_17\n\nLANGUAGE: python\nCODE:\n```\nfrom collections.abc import Callable\nfrom typing import overload\n\nclass Tag[T]:\n    @overload\n    def export(self: Tag[str]) -> str: ...\n    @overload\n    def export(self, converter: Callable[[T], str]) -> str: ...\n\n    def export(self, converter=None):\n        if isinstance(self.item, str):\n            return self.item\n        return converter(self.item)\n```\n\n----------------------------------------\n\nTITLE: Checking Types with assert_type in Python\nDESCRIPTION: Demonstrates type checking using assert_type from typing_extensions, showing both valid and invalid type assertions.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/error_code_list.rst#2025-04-22_snippet_35\n\nLANGUAGE: python\nCODE:\n```\nfrom typing_extensions import assert_type\n\nassert_type([1], list[int])  # OK\n\nassert_type([1], list[str])  # Error\n```\n\n----------------------------------------\n\nTITLE: Type-Context Inference in Function Arguments with Mypy\nDESCRIPTION: Shows that function type annotations provide context to infer the type of inputs, such as using an empty list in a call when the argument is typed as 'list[int]'. Mypy infers the empty list as a list of integers for this call, aiding type safety without redundant annotations.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/type_inference_and_annotations.rst#2025-04-22_snippet_11\n\nLANGUAGE: python\nCODE:\n```\ndef foo(arg: list[int]) -> None:\\n    print('Items:', ''.join(str(a) for a in arg))\\n\\nfoo([])  # OK\n```\n\n----------------------------------------\n\nTITLE: Demonstrating flexible TypedDict creation in Python\nDESCRIPTION: Example showing the more flexible TypedDict creation and update operations in Mypy 1.5. It demonstrates creating TypedDicts with subset keys and updating them.\nSOURCE: https://github.com/python/mypy/blob/master/CHANGELOG.md#2025-04-22_snippet_35\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import TypedDict\n\nclass A(TypedDict):\n    foo: int\n    bar: int\n\nclass B(TypedDict):\n    foo: int\n\na: A = {\"foo\": 1, \"bar\": 2}\nb: B = {\"foo\": 3}\na2: A = { **a, **b}  # OK (previously an error)\n\na.update(b)  # OK (previously an error)\n```\n\n----------------------------------------\n\nTITLE: Using Covariant Type Variables in Protocols (Python 3.11)\nDESCRIPTION: Demonstrates how to use covariant type variables in protocols to allow for subtyping relationships. Uses the legacy syntax for Python 3.11 and earlier with explicit variance specification.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/generics.rst#2025-04-22_snippet_49\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Protocol, TypeVar\n\nT_co = TypeVar('T_co', covariant=True)\n\nclass ReadOnlyBox(Protocol[T_co]):  # OK\n    def content(self) -> T_co: ...\n\nax: ReadOnlyBox[float] = ...\nay: ReadOnlyBox[int] = ...\nax = ay  # OK -- ReadOnlyBox is covariant\n```\n\n----------------------------------------\n\nTITLE: Implementing Overloaded Functions in Python\nDESCRIPTION: Demonstrates how Mypy ensures that overloaded functions are followed by a concrete implementation if not contained within a stub file. This ensures functionality matches declared types.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/error_code_list.rst#2025-04-22_snippet_31\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import overload\n\n@overload\n def func(value: int) -> int:\n     ...\n\n@overload\n def func(value: str) -> str:\n     ...\n\n# presence of required function below is checked\ndef func(value):\n    pass  # actual implementation\n```\n\n----------------------------------------\n\nTITLE: Defining and Instantiating Abstract Base Classes with mypy - Python\nDESCRIPTION: Demonstrates the definition of an abstract base class using the abc.ABCMeta metaclass and the @abstractmethod decorator. It shows a derived class that does not implement all abstract methods, making it implicitly abstract. Attempting to instantiate such an incomplete class leads to a mypy error. This pattern requires the 'abc' standard library and is used to enforce interface contracts. Parameters include the abstract method signatures and their required types; any instantiation of incomplete subclasses triggers a type error.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/class_basics.rst#2025-04-22_snippet_15\n\nLANGUAGE: python\nCODE:\n```\nclass Base(metaclass=ABCMeta):\n    @abstractmethod\n    def f(self, x: int) -> None: pass\n\nclass Derived(Base):  # No error -- Derived is implicitly abstract\n    def g(self) -> None:\n        ...\n```\n\nLANGUAGE: python\nCODE:\n```\nd = Derived()  # Error: 'Derived' is abstract\n```\n\n----------------------------------------\n\nTITLE: Checking Method Assignment in Python with Mypy\nDESCRIPTION: This example discusses how assigning methods on class objects or instances causes ambiguity and is flagged by Mypy. It explains that assigning unbound callable types can be erroneous in Python's static type system.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/error_code_list.rst#2025-04-22_snippet_15\n\nLANGUAGE: python\nCODE:\n```\nclass A:\n    def f(self) -> None: pass\n    def g(self) -> None: pass\n\ndef h(self: A) -> None: pass\n\nA.f = h  # Type of h is Callable[[A], None]\nA().f()  # This works\nA.f = A().g  # Type of A().g is Callable[[], None]\nA().f()  # ...but this also works at runtime\n```\n\n----------------------------------------\n\nTITLE: Ensuring Functions Do Not Return 'Any' in Python with Mypy\nDESCRIPTION: This code snippet demonstrates the use of mypy's --warn-return-any option to ensure that functions do not inadvertently return values of 'Any' type when they are expected to return a specific type, improving type safety.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/error_code_list2.rst#2025-04-22_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n# mypy: warn-return-any\n\ndef fields(s):\n     return s.split(',')\n\ndef first_field(x: str) -> str:\n    # Error: Returning Any from function declared to return \"str\"  [no-any-return]\n    return fields(x)[0]\n```\n\n----------------------------------------\n\nTITLE: Decorator with ParamSpec for Signature Preservation - Python <=3.11\nDESCRIPTION: Shows legacy syntax for writing decorators using typing_extensions.ParamSpec and TypeVar to exactly preserve function signature in decorated functions. Accepts any signature and return type, forwarding the arguments accordingly. Dependencies: collections.abc.Callable, typing_extensions.ParamSpec, typing.TypeVar.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/generics.rst#2025-04-22_snippet_38\n\nLANGUAGE: python\nCODE:\n```\nfrom collections.abc import Callable\nfrom typing import TypeVar\nfrom typing_extensions import ParamSpec\n\nP = ParamSpec('P')\nT = TypeVar('T')\n\ndef printing_decorator(func: Callable[P, T]) -> Callable[P, T]:\n    def wrapper(*args: P.args, **kwds: P.kwargs) -> T:\n        print(\"Calling\", func)\n        return func(*args, **kwds)\n    return wrapper\n```\n\n----------------------------------------\n\nTITLE: Verbose Type Narrowing with if-elif for Optionals - Python\nDESCRIPTION: This revised version of the previous example performs explicit if-elif checks to return a non-None value for type safety. By checking a and b separately, the type checker can confirm only a value of type C (and not None) is ever returned. This is a common workaround for Mypy's cross-variable type analysis limitations.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/type_narrowing.rst#2025-04-22_snippet_20\n\nLANGUAGE: python\nCODE:\n```\ndef f(a: C | None, b: C | None) -> C:\n    if a is not None:\n        return a\n    elif b is not None:\n        return b\n    return C()\n```\n\n----------------------------------------\n\nTITLE: Generic Methods with TypeVar in Legacy Python Syntax\nDESCRIPTION: This snippet shows the legacy syntax (Python 3.11 and earlier) for creating generic methods with a self type using TypeVar. This setup allows for precise method chaining across derived classes like Circle and Square, leveraging the bound TypeVar to restrict 'self' to be a specific subtype.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/generics.rst#2025-04-22_snippet_16\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import TypeVar\n\nT = TypeVar('T', bound='Shape')\n\nclass Shape:\n    def set_scale(self: T, scale: float) -> T:\n        self.scale = scale\n        return self\n\nclass Circle(Shape):\n    def set_radius(self, r: float) -> 'Circle':\n        self.radius = r\n        return self\n\nclass Square(Shape):\n    def set_width(self, w: float) -> 'Square':\n        self.width = w\n        return self\n\ncircle: Circle = Circle().set_scale(0.5).set_radius(2.7)\nsquare: Square = Square().set_scale(0.5).set_width(3.2)\n```\n\n----------------------------------------\n\nTITLE: Inferring Any for Variables in Dynamically Typed Python Functions\nDESCRIPTION: This snippet shows how variables inside functions without explicit function type annotations are inferred as type 'Any' by mypy. The example uses 'reveal_type' to confirm the type is 'Any.' This approach is specific to unchecked (dynamically typed) Python functions in mypy and does not require dependencies beyond mypy.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/type_inference_and_annotations.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ndef untyped_function():\\n    i = 1\\n    reveal_type(i) # Revealed type is \\\"Any\\\"\\n                   # 'reveal_type' always outputs 'Any' in unchecked functions\n```\n\n----------------------------------------\n\nTITLE: Complex Type Checks and Cast in Python\nDESCRIPTION: Demonstrates using explicit type casting with Mypy's `cast` for complex type scenarios where mypy cannot automatically infer types due to limitations in `isinstance` checks.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/common_issues.rst#2025-04-22_snippet_14\n\nLANGUAGE: python\nCODE:\n```\nfrom collections.abc import Sequence\nfrom typing import cast\n\ndef find_first_str(a: Sequence[object]) -> str:\n    index = next((i for i, s in enumerate(a) if isinstance(s, str)), -1)\n    if index < 0:\n        raise ValueError('No str found')\n\n    found = a[index]  # Has type \"object\", despite the fact that we know it is \"str\"\n    return cast(str, found)  # We need an explicit cast to make mypy happy\n```\n\nLANGUAGE: python\nCODE:\n```\ndef find_first_str(a: Sequence[object]) -> str:\n    index = next((i for i, s in enumerate(a) if isinstance(s, str)), -1)\n    if index < 0:\n        raise ValueError('No str found')\n\n    found = a[index]  # Has type \"object\", despite the fact that we know it is \"str\"\n    assert isinstance(found, str)  # Now, \"found\" will be narrowed to \"str\"\n    return found  # No need for the explicit \"cast()\" anymore\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Allowed Variable Redefinition with Mypy in Python\nDESCRIPTION: This Python code snippet illustrates a use case for the `allow_redefinition` Mypy configuration option. It shows a function `process` where the variable `items` is initially defined as `list[str]` and is later redefined within the same scope to `list[list[str]]` after being used. This pattern is allowed when `allow_redefinition` is set to `True`.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/config_file.rst#2025-04-22_snippet_8\n\nLANGUAGE: python\nCODE:\n```\ndef process(items: list[str]) -> None:\n    # 'items' has type list[str]\n    items = [item.split() for item in items]\n    # 'items' now has type list[list[str]]\n```\n\n----------------------------------------\n\nTITLE: Demonstrating PreciseTupleTypes Inference in Mypy Python\nDESCRIPTION: This Python snippet showcases how enabling the `PreciseTupleTypes` feature in Mypy leads to more specific type inference for tuples created through unpacking, concatenation, or after length checks. It contrasts the inferred types with and without the feature using `reveal_type`, showing how `PreciseTupleTypes` provides more detailed tuple structure information.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/command_line.rst#2025-04-22_snippet_16\n\nLANGUAGE: python\nCODE:\n```\nnumbers: tuple[int, ...]\n\nmore_numbers = (1, *numbers, 1)\nreveal_type(more_numbers)\n# Without PreciseTupleTypes: tuple[int, ...]\n# With PreciseTupleTypes: tuple[int, *tuple[int, ...], int]\n\nother_numbers = (1, 1) + numbers\nreveal_type(other_numbers)\n# Without PreciseTupleTypes: tuple[int, ...]\n# With PreciseTupleTypes: tuple[int, int, *tuple[int, ...]]\n\nif len(numbers) > 2:\n    reveal_type(numbers)\n    # Without PreciseTupleTypes: tuple[int, ...]\n    # With PreciseTupleTypes: tuple[int, int, int, *tuple[int, ...]]\nelse:\n    reveal_type(numbers)\n    # Without PreciseTupleTypes: tuple[int, ...]\n    # With PreciseTupleTypes: tuple[()] | tuple[int] | tuple[int, int]\n```\n\n----------------------------------------\n\nTITLE: Basic Type Annotation with type\nDESCRIPTION: Function with basic type annotation using the 'type' keyword, showing a limited implementation.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/kinds_of_types.rst#2025-04-22_snippet_15\n\nLANGUAGE: python\nCODE:\n```\ndef new_user(user_class: type) -> User:\n    # Same  implementation as before\n```\n\n----------------------------------------\n\nTITLE: Checking Generic Type Arguments in Python with Mypy\nDESCRIPTION: This code snippet demonstrates using mypy's --disallow-any-generics option to ensure that generic types have specified type arguments, avoiding implicit 'Any' types. When enabled, mypy will generate a type-arg error for omitted type parameters.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/error_code_list2.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n# mypy: disallow-any-generics\n\n# Error: Missing type parameters for generic type \"list\"  [type-arg]\ndef remove_dups(items: list) -> list:\n    ...\n```\n\n----------------------------------------\n\nTITLE: Suppressing Missing Import Errors with pyproject.toml (TOML)\nDESCRIPTION: This example configures mypy in pyproject.toml to stop reporting missing imports for modules matching the 'foobar.*' pattern. The override includes both the 'module' target and the 'ignore_missing_imports = true' directive. This helps maintain clean type-checking output when using untyped third-party libraries.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/running_mypy.rst#2025-04-22_snippet_13\n\nLANGUAGE: toml\nCODE:\n```\n[[tool.mypy.overrides]]\\nmodule = [\"foobar.*\"]\\nignore_missing_imports = true\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Generic Class Behavior at Runtime in Python 3.12\nDESCRIPTION: Illustrates the runtime behavior of generic classes, showing how indexing returns generic aliases and how instances are created. Demonstrates type erasure at runtime.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/generics.rst#2025-04-22_snippet_56\n\nLANGUAGE: python\nCODE:\n```\n>>> class Stack[T]: ...\n>>> Stack\n__main__.Stack\n>>> Stack[int]\n__main__.Stack[int]\n>>> instance = Stack[int]()\n>>> instance.__class__\n__main__.Stack\n```\n\n----------------------------------------\n\nTITLE: Defining a Metaclass in Python with Mypy\nDESCRIPTION: Demonstrates the basic syntax for defining a metaclass and a class that uses it. The metaclass 'M' extends 'type', and class 'A' is created with 'M' as its metaclass.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/metaclasses.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nclass M(type):\n    pass\n\nclass A(metaclass=M):\n    pass\n```\n\n----------------------------------------\n\nTITLE: Type Checking Overloads with Union Type Argument in Python\nDESCRIPTION: Demonstrates another exception to the 'first match' rule in Mypy's overload resolution. When multiple variants match due to an argument being a `Union` type, Mypy infers the return type as a `Union` of the return types of all matching variants. Here, `summarize` is called with `list[int] | list[str]`, resulting in an inferred return type of `float | str`.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/more_types.rst#2025-04-22_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nsome_list: list[int] | list[str]\n\n# output3 is of type 'float | str'\noutput3 = summarize(some_list)\n```\n\n----------------------------------------\n\nTITLE: Consistent Naming for NamedTuple in Python\nDESCRIPTION: Describes the consistency error reported by Mypy when a named tuple is defined with a name that does not match its first argument. Ensures the name is consistent with the first argument.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/error_code_list.rst#2025-04-22_snippet_29\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import NamedTuple\n\n# Error: First argument to namedtuple() should be \"Point2D\", not \"Point\"\nPoint2D = NamedTuple(\"Point\", [(\"x\", int), (\"y\", int)])\n```\n\n----------------------------------------\n\nTITLE: Handling Invariance of List in Python\nDESCRIPTION: Demonstrates the limitation of invariance in generic collections with Mypy, where list types are invariant by default. Solutions such as using explicit annotations and immutable collections are provided.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/common_issues.rst#2025-04-22_snippet_12\n\nLANGUAGE: python\nCODE:\n```\nclass A: ...\nclass B(A): ...\n\nlst = [A(), A()]  # Inferred type is list[A]\nnew_lst = [B(), B()]  # inferred type is list[B]\nlst = new_lst  # mypy will complain about this, because List is invariant\n```\n\nLANGUAGE: python\nCODE:\n```\nnew_lst: list[A] = [B(), B()]\nlst = new_lst  # OK\n```\n\nLANGUAGE: python\nCODE:\n```\nlst = list(new_lst) # Also OK\n```\n\nLANGUAGE: python\nCODE:\n```\ndef f_bad(x: list[A]) -> A:\n    return x[0]\nf_bad(new_lst) # Fails\n\ndef f_good(x: Sequence[A]) -> A:\n    return x[0]\nf_good(new_lst) # OK\n```\n\n----------------------------------------\n\nTITLE: Defining Generic Functions and Classes with New Type Parameter Syntax - Python\nDESCRIPTION: This snippet demonstrates the creation of generic functions and classes using the Python 3.12+ bracketed type parameter syntax as supported by mypy. The generic function 'f' and generic class 'C' are defined using '[T]', where 'T' is a type variable. 'reveal_type' calls are used to display inferred types for static type checking. No third-party dependencies are required beyond mypy for static analysis. Key parameters:\n- 'f[T](x: T) -> T': A generic function that accepts and returns a value of type 'T'.\n- 'C[T]': A generic class holding a value of type 'T'.\n- 'A[T]': A type alias for 'C[list[T]]'.\nTypical inputs are values of any compatible type, and outputs preserve type relations. The code does not execute at runtime but is intended for static analysis by mypy.\nSOURCE: https://github.com/python/mypy/blob/master/CHANGELOG.md#2025-04-22_snippet_8\n\nLANGUAGE: python\nCODE:\n```\n# Generic function\ndef f[T](x: T) -> T: ...\n\nreveal_type(f(1))  # Revealed type is 'int'\n\n# Generic class\nclass C[T]:\n    def __init__(self, x: T) -> None:\n       self.x = x\n\nc = C('a')\nreveal_type(c.x)  # Revealed type is 'str'\n\n# Type alias\ntype A[T] = C[list[T]]\n```\n\n----------------------------------------\n\nTITLE: Resolving Name Conflicts in Python Method Definitions\nDESCRIPTION: Provides a workaround for method name conflicts with built-in types or imports in Python, recommending the use of type aliases to avoid ambiguity in method declarations.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/common_issues.rst#2025-04-22_snippet_19\n\nLANGUAGE: python\nCODE:\n```\nclass Message:\n    def bytes(self):\n        ...\n    def register(self, path: bytes):  # error: Invalid type \"mod.Message.bytes\"\n        ...\n```\n\nLANGUAGE: python\nCODE:\n```\nbytes_ = bytes\nclass Message:\n\n```\n\n----------------------------------------\n\nTITLE: Defining a Generic Box Class (Legacy Syntax)\nDESCRIPTION: Defines the generic `Box` class using the legacy syntax (Python <= 3.11). This requires importing `TypeVar` and `Generic`, defining `T = TypeVar('T')`, and inheriting from `Generic[T]`. The constructor takes an argument of type `T`.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/generics.rst#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import TypeVar, Generic\n\nT = TypeVar('T')\n\nclass Box(Generic[T]):\n    def __init__(self, content: T) -> None:\n        self.content = content\n```\n\n----------------------------------------\n\nTITLE: Python Version and Platform Checks with Mypy\nDESCRIPTION: Illustrates how to perform Python version and platform-specific checks using `sys.version_info` and `sys.platform` to conditionally execute code based on the target environment and how to use directives to focus type checks for specific Python versions or platforms.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/common_issues.rst#2025-04-22_snippet_15\n\nLANGUAGE: python\nCODE:\n```\nimport sys\n\n# Distinguishing between different versions of Python:\nif sys.version_info >= (3, 13):\n    # Python 3.13+ specific definitions and imports\nelse:\n    # Other definitions and imports\n\n# Distinguishing between different operating systems:\nif sys.platform.startswith(\"linux\"):\n    # Linux-specific code\nelif sys.platform == \"darwin\":\n    # Mac-specific code\nelif sys.platform == \"win32\":\n    # Windows-specific code\nelse:\n    # Other systems\n```\n\nLANGUAGE: python\nCODE:\n```\nimport sys\n\nassert sys.platform != 'win32'\n\n# The rest of this file doesn't apply to Windows.\n```\n\n----------------------------------------\n\nTITLE: Defining Variables and Functions in Python Stub Files (.pyi) using Ellipsis\nDESCRIPTION: This snippet demonstrates the conventional syntax for creating Python stub files (.pyi). It shows how to declare typed variables without assignment (`x: int`) and define function signatures (`func_1`, `func_2`) by replacing function bodies and default argument values with an ellipsis (`...`). This allows Mypy to perform type checking without needing the actual implementation details.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/stubs.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n# Variables with annotations do not need to be assigned a value.\n# So by convention, we omit them in the stub file.\nx: int\n\n# Function bodies cannot be completely removed. By convention,\n# we replace them with `...` instead of the `pass` statement.\ndef func_1(code: str) -> int: ...\n\n# We can do the same with default arguments.\ndef func_2(a: int, b: int = ...) -> int: ...\n```\n\n----------------------------------------\n\nTITLE: Enabling Follow Untyped Imports in mypy.ini Files (INI)\nDESCRIPTION: This snippet demonstrates how to configure mypy to follow untyped imports for a specific package pattern in a mypy.ini file by setting 'follow_untyped_imports = True'. This enables deeper analysis of dependencies without type stubs when mypy type-checks the specified modules. The setting can be customized on a per-module basis using wildcards (e.g., package.*). Required dependency: mypy; this snippet targets use with .ini config files.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/running_mypy.rst#2025-04-22_snippet_10\n\nLANGUAGE: ini\nCODE:\n```\n[mypy-untyped_package.*]\\nfollow_untyped_imports = True\n```\n\n----------------------------------------\n\nTITLE: Declaring Parametric Classes with Default Type Variables (PEP 696) in Python\nDESCRIPTION: This code snippet demonstrates setting default values for type variables in generic Python classes compatible with PEP 696 and Python 3.13+. Using a @dataclass, it defines a Box[T=int] with a type variable T that defaults to int if not specified. Subsequent calls to reveal_type show how type arguments are resolved by default or via instantiation with explicit values. Requires Python 3.13+ and the dataclasses/type-hinting features.\nSOURCE: https://github.com/python/mypy/blob/master/CHANGELOG.md#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n@dataclass\nclass Box[T = int]:  # Set default for \"T\"\n    value: T | None = None\n\nreveal_type(Box())                      # type is Box[int], since it's the default\nreveal_type(Box(value=\"Hello World!\"))  # type is Box[str]\n```\n\n----------------------------------------\n\nTITLE: Value-Restricted Type Variable Preventing Mixed Types - Python\nDESCRIPTION: Demonstrates the type-checking prevention of combining two arguments of different types (str and bytes) when using a value-restricted type variable with the concat function. Confirms that the type checker raises errors for illegal mixed invocations. No dependencies; meant to show constraint failures.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/generics.rst#2025-04-22_snippet_28\n\nLANGUAGE: python\nCODE:\n```\nconcat('string', b'bytes')   # Error!\n```\n\n----------------------------------------\n\nTITLE: Defining Type Alias by Assignment - Python\nDESCRIPTION: This example shows how to create a type alias by assigning a class to a new name at the module level, without an explicit type annotation. Here, Alias becomes a type alias for class A. No dependencies are necessary. Expected input/output: none; This is a style for static type aliasing.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/common_issues.rst#2025-04-22_snippet_22\n\nLANGUAGE: python\nCODE:\n```\nclass A: ...\\nAlias = A\n```\n\n----------------------------------------\n\nTITLE: Example Output: Library Stubs Not Installed (Text)\nDESCRIPTION: This text snippet represents a sample error message generated by mypy when attempting to type-check code that imports a module (e.g., 'yaml') for which no stubs are currently installed. The error output includes hints for the user, such as pip commands they can run to resolve the issue by installing the appropriate types package. The message helps users troubleshoot and install type stubs as needed.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/running_mypy.rst#2025-04-22_snippet_16\n\nLANGUAGE: text\nCODE:\n```\nmain.py:1: error: Library stubs not installed for \"yaml\"\\nmain.py:1: note: Hint: \"python3 -m pip install types-PyYAML\"\\nmain.py:1: note: (or run \"mypy --install-types\" to install all missing stub packages)\n```\n\n----------------------------------------\n\nTITLE: Using InlineTypedDict Syntax in Mypy Python\nDESCRIPTION: This Python code demonstrates the non-standard `InlineTypedDict` syntax enabled by a Mypy feature. It shows how to define a function's return type using an inline dictionary literal resembling a TypedDict definition, specifying expected keys and their value types directly in the function signature.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/command_line.rst#2025-04-22_snippet_17\n\nLANGUAGE: python\nCODE:\n```\ndef test_values() -> {\"int\": int, \"str\": str}:\n    return {\"int\": 42, \"str\": \"test\"}\n```\n\n----------------------------------------\n\nTITLE: Metaclass Inheritance Limitations and Solutions in Python\nDESCRIPTION: Shows the limitations when combining different metaclasses in an inheritance hierarchy. Demonstrates metaclass conflicts and the proper solution using a common metaclass subtype.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/metaclasses.rst#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nclass M1(type): pass\nclass M2(type): pass\n\nclass A1(metaclass=M1): pass\nclass A2(metaclass=M2): pass\n\nclass B1(A1, metaclass=M2): pass  # Mypy Error: metaclass conflict\n# At runtime the above definition raises an exception\n# TypeError: metaclass conflict: the metaclass of a derived class must be a (non-strict) subclass of the metaclasses of all its bases\n\nclass B12(A1, A2): pass  # Mypy Error: metaclass conflict\n\n# This can be solved via a common metaclass subtype:\nclass CorrectMeta(M1, M2): pass\nclass B2(A1, A2, metaclass=CorrectMeta): pass  # OK, runtime is also OK\n```\n\n----------------------------------------\n\nTITLE: Numbers Below with Type Inference in Python\nDESCRIPTION: This Python function, 'nums_below', uses Mypy's type inference to deduce local variable types within a statically typed function, allowing type checking of the function body even without explicit type hints for local variables.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/getting_started.rst#2025-04-22_snippet_7\n\nLANGUAGE: python\nCODE:\n```\ndef nums_below(numbers: Iterable[float], limit: float) -> list[float]:\n    output = []\n    for num in numbers:\n        if num < limit:\n            output.append(num)\n    return output\n```\n\n----------------------------------------\n\nTITLE: Decorator Type Annotations with Pre-3.12 Python Syntax\nDESCRIPTION: Shows how to type decorators using TypeVar with pre-3.12 Python syntax. Demonstrates the same functionality as the 3.12 example but with explicit TypeVar declarations.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/cheat_sheet_py3.rst#2025-04-22_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nfrom collections.abc import Callable\nfrom typing import Any, TypeVar\n\nF = TypeVar('F', bound=Callable[..., Any])\n\ndef bare_decorator(func: F) -> F:\n    ...\n\ndef decorator_args(url: str) -> Callable[[F], F]:\n    ...\n```\n\n----------------------------------------\n\nTITLE: Defining Enum Members According to Typing Rules in Python Using Enum\nDESCRIPTION: This code illustrates the correct and incorrect ways to define members and attributes in a Python Enum class following recently updated typing specifications. Member attributes must be unannotated assignments, while annotations without assignment now constitute non-member attributes or errors. Intended for users migrating type annotations in Enum definitions, the snippet demonstrates both valid enum member assignments, improper annotated members (now errors), and proper non-member attributes; no external dependencies are required beyond enum.Enum.\nSOURCE: https://github.com/python/mypy/blob/master/CHANGELOG.md#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nclass Pet(Enum):\n    CAT = 1  # Member attribute\n    DOG = 2  # Member attribute\n\n    # New error: Enum members must be left unannotated\n    WOLF: int = 3\n\n    species: str  # Considered a non-member attribute\n```\n\n----------------------------------------\n\nTITLE: Implementing Different Property Getter and Setter Types in Python\nDESCRIPTION: This snippet demonstrates how to use different types for property getter and setter in Python, allowing for more flexible type annotations. The setter converts input to int, handling potential ValueError.\nSOURCE: https://github.com/python/mypy/blob/master/CHANGELOG.md#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nclass A:\n    value: int\n\n    @property\n    def f(self) -> int:\n        return self.value\n    @f.setter\n    def f(self, x: str | int) -> None:\n        try:\n            self.value = int(x)\n        except ValueError:\n            raise Exception(f\"'{x}' is not a valid value for 'f'\")\n```\n\n----------------------------------------\n\nTITLE: Generator with None Send/Return Types\nDESCRIPTION: Generator function explicitly annotated with None for send and return types.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/kinds_of_types.rst#2025-04-22_snippet_22\n\nLANGUAGE: python\nCODE:\n```\ndef squares(n: int) -> Generator[int, None, None]:\n    for i in range(n):\n        yield i * i\n```\n\n----------------------------------------\n\nTITLE: Handling Covariant Subtyping in Protocols with Mypy in Python\nDESCRIPTION: Explains the rejection of covariant subtyping for mutable protocol members by mypy, offering solutions like using properties instead to ensure safe type handling.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/common_issues.rst#2025-04-22_snippet_18\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Protocol\n\nclass P(Protocol):\n    x: float\n\ndef fun(arg: P) -> None:\n    arg.x = 3.14\n\nclass C:\n    x = 42\nc = C()\nfun(c)  # This is not safe\nc.x << 5  # Since this will fail!\n```\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Protocol\n\nclass P(Protocol):\n    @property\n    def x(self) -> float:\n       pass\n\ndef fun(arg: P) -> None:\n    ...\n\nclass C:\n    x = 42\nfun(C())  # OK\n```\n\n----------------------------------------\n\nTITLE: Creating a Decorator that Adds Parameters with Concatenate (Python 3.12)\nDESCRIPTION: Shows how to use Concatenate with parameter specifications to create a decorator that adds a new parameter to the decorated function. Uses Python 3.12's native type parameter syntax.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/generics.rst#2025-04-22_snippet_41\n\nLANGUAGE: python\nCODE:\n```\nfrom collections.abc import Callable\nfrom typing import Concatenate\n\ndef printing_decorator[**P, T](func: Callable[P, T]) -> Callable[Concatenate[str, P], T]:\n    def wrapper(msg: str, /, *args: P.args, **kwds: P.kwargs) -> T:\n        print(\"Calling\", func, \"with\", msg)\n        return func(*args, **kwds)\n    return wrapper\n\n@printing_decorator\ndef add_forty_two(value: int) -> int:\n    return value + 42\n\na = add_forty_two('three', 3)\n```\n\n----------------------------------------\n\nTITLE: Detecting Unsafely Overlapping Overloads in Python\nDESCRIPTION: Presents an example of an overload definition that Mypy flags as inherently unsafe. The first variant (`int -> int`) has arguments compatible with the second (`object -> str`), but its return type (`int`) is not compatible with the second's return type (`str`). This situation can lead to runtime errors that bypass static type checking.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/more_types.rst#2025-04-22_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import overload\n\n@overload\ndef unsafe_func(x: int) -> int: ...\n\n@overload\ndef unsafe_func(x: object) -> str: ...\n\ndef unsafe_func(x: object) -> int | str:\n    if isinstance(x, int):\n        return 42\n    else:\n        return \"some string\"\n```\n\n----------------------------------------\n\nTITLE: Optional Types and None Type in Python\nDESCRIPTION: Describes optional types in Python which allow for None values and the implications for type checking with Mypy. Examples show when Mypy will raise type compatibility issues. Dependencies: None. Key parameters: s - string whose length is evaluated.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/kinds_of_types.rst#2025-04-22_snippet_6\n\nLANGUAGE: python\nCODE:\n```\ndef strlen(s: str) -> int | None:\n    if not s:\n        return None  # OK\n    return len(s)\n```\n\nLANGUAGE: python\nCODE:\n```\ndef strlen_invalid(s: str) -> int:\n    if not s:\n        return None  # Error: None not compatible with int\n    return len(s)\n```\n\n----------------------------------------\n\nTITLE: Factory Methods with Generic Clauses in Python\nDESCRIPTION: This snippet demonstrates the defining of factory methods like make_pair, using generic class methods. It uses the Friend class to create paired instances where the other attribute references another instance, showcasing the use of class-level type parameters.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/generics.rst#2025-04-22_snippet_17\n\nLANGUAGE: python\nCODE:\n```\nclass Friend:\n    other: \"Friend | None\" = None\n\n    @classmethod\n    def make_pair[T: Friend](cls: type[T]) -> tuple[T, T]:\n        a, b = cls(), cls()\n        a.other = b\n        b.other = a\n        return a, b\n\nclass SuperFriend(Friend):\n    pass\n\na, b = SuperFriend.make_pair()\n```\n\n----------------------------------------\n\nTITLE: Class-Based Syntax for TypedDict Declaration - Python\nDESCRIPTION: Demonstrates the preferred class-based syntax for defining a TypedDict (supported in Python 3.6+). The class Movie derives from TypedDict, specifying typed fields as class attributes. The required dependency is the 'typing' or 'typing_extensions' module for TypedDict.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/typed_dict.rst#2025-04-22_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import TypedDict  # \"from typing_extensions\" in Python 3.7 and earlier\n\nclass Movie(TypedDict):\n    name: str\n    year: int\n```\n\n----------------------------------------\n\nTITLE: Declaring and Using Class Variables in MyPy Native Classes (Python)\nDESCRIPTION: Illustrates the correct way to declare class variables in native classes using `typing.ClassVar`. It shows that class variables can be accessed via instances and modified via the class itself, but attempting to assign to the class variable through an instance results in an error.\nSOURCE: https://github.com/python/mypy/blob/master/mypyc/doc/native_classes.rst#2025-04-22_snippet_4\n\nLANGUAGE: Python\nCODE:\n```\nfrom typing import ClassVar\n\nclass Cls:\n    cv: ClassVar = 0\n\nCls.cv = 2  # OK\no = Cls()\nprint(o.cv)  # OK (2)\no.cv = 3  # Error!\n```\n\n----------------------------------------\n\nTITLE: Optimized String Methods in Python\nDESCRIPTION: Enumerates various built-in string methods in Python that possess optimized implementations. This covers methods for encoding, searching, splitting, stripping, replacing, partitioning, and checking prefixes/suffixes.\nSOURCE: https://github.com/python/mypy/blob/master/mypyc/doc/str_operations.rst#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ns.encode()\n```\n\nLANGUAGE: python\nCODE:\n```\ns.encode(encoding: str)\n```\n\nLANGUAGE: python\nCODE:\n```\ns.encode(encoding: str, errors: str)\n```\n\nLANGUAGE: python\nCODE:\n```\ns1.endswith(s2: str)\n```\n\nLANGUAGE: python\nCODE:\n```\ns1.endswith(t: tuple[str, ...])\n```\n\nLANGUAGE: python\nCODE:\n```\ns1.find(s2: str)\n```\n\nLANGUAGE: python\nCODE:\n```\ns1.find(s2: str, start: int)\n```\n\nLANGUAGE: python\nCODE:\n```\ns1.find(s2: str, start: int, end: int)\n```\n\nLANGUAGE: python\nCODE:\n```\ns.join(x: Iterable)\n```\n\nLANGUAGE: python\nCODE:\n```\ns.lstrip()\n```\n\nLANGUAGE: python\nCODE:\n```\ns.lstrip(chars: str)\n```\n\nLANGUAGE: python\nCODE:\n```\ns.partition(sep: str)\n```\n\nLANGUAGE: python\nCODE:\n```\ns.removeprefix(prefix: str)\n```\n\nLANGUAGE: python\nCODE:\n```\ns.removesuffix(suffix: str)\n```\n\nLANGUAGE: python\nCODE:\n```\ns.replace(old: str, new: str)\n```\n\nLANGUAGE: python\nCODE:\n```\ns.replace(old: str, new: str, count: int)\n```\n\nLANGUAGE: python\nCODE:\n```\ns1.rfind(s2: str)\n```\n\nLANGUAGE: python\nCODE:\n```\ns1.rfind(s2: str, start: int)\n```\n\nLANGUAGE: python\nCODE:\n```\ns1.rfind(s2: str, start: int, end: int)\n```\n\nLANGUAGE: python\nCODE:\n```\ns.rpartition(sep: str)\n```\n\nLANGUAGE: python\nCODE:\n```\ns.rsplit()\n```\n\nLANGUAGE: python\nCODE:\n```\ns.rsplit(sep: str)\n```\n\nLANGUAGE: python\nCODE:\n```\ns.rsplit(sep: str, maxsplit: int)\n```\n\nLANGUAGE: python\nCODE:\n```\ns.rstrip()\n```\n\nLANGUAGE: python\nCODE:\n```\ns.rstrip(chars: str)\n```\n\nLANGUAGE: python\nCODE:\n```\ns.split()\n```\n\nLANGUAGE: python\nCODE:\n```\ns.split(sep: str)\n```\n\nLANGUAGE: python\nCODE:\n```\ns.split(sep: str, maxsplit: int)\n```\n\nLANGUAGE: python\nCODE:\n```\ns.splitlines()\n```\n\nLANGUAGE: python\nCODE:\n```\ns.splitlines(keepends: bool)\n```\n\nLANGUAGE: python\nCODE:\n```\ns1.startswith(s2: str)\n```\n\nLANGUAGE: python\nCODE:\n```\ns1.startswith(t: tuple[str, ...])\n```\n\nLANGUAGE: python\nCODE:\n```\ns.strip()\n```\n\nLANGUAGE: python\nCODE:\n```\ns.strip(chars: str)\n```\n\n----------------------------------------\n\nTITLE: Customizing Module-Specific Error Code Settings\nDESCRIPTION: This INI code snippet shows how to use a global config section to enable error codes and then selectively disable them for certain modules. Dependence on the main section for declaring global settings and the use of individual module sections for overrides is highlighted.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/error_codes.rst#2025-04-22_snippet_2\n\nLANGUAGE: ini\nCODE:\n```\n[mypy]\\nenable_error_code = truthy-bool, ignore-without-code, unused-awaitable\\n\\n[mypy-extensions.*]\\ndisable_error_code = unused-awaitable\n```\n\n----------------------------------------\n\nTITLE: Verifying Protocol Conformance with Type Hint and Cast in Python\nDESCRIPTION: Demonstrates using a type hint (`_proto: SomeProto`) combined with `typing.cast` as a technique to explicitly request Mypy to verify that a class (`ExplicitSubclass`) conforms to a specific protocol (`SomeProto`). While `cast` suppresses runtime checks, Mypy will still statically analyze if `ExplicitSubclass` structurally matches `SomeProto`. Dependencies: `typing.Protocol`, `typing.cast`, and previously defined `SomeProto`, `ExplicitSubclass`.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/protocols.rst#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import cast # Assuming cast is imported\n\n_proto: SomeProto = cast(ExplicitSubclass, None)\n```\n\n----------------------------------------\n\nTITLE: Defining Callable with VarArg and KwArg Specifiers (Python)\nDESCRIPTION: This snippet illustrates that `Callable[..., int]` is roughly equivalent to using `VarArg()` and `KwArg()` specifiers from `mypy_extensions`: `Callable[[VarArg(), KwArg()], int]`. This explicitly denotes acceptance of any positional (`*args`) and keyword (`**kwargs`) arguments.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/additional_features.rst#2025-04-22_snippet_15\n\nLANGUAGE: python\nCODE:\n```\nMyOtherFunc = Callable[[VarArg(), KwArg()], int]\n```\n\n----------------------------------------\n\nTITLE: Handling Function Return Values in Python\nDESCRIPTION: Explains the Mypy error when a function with a return type of \"None\" is called as if it returns a value. Demonstrates the correct method of calling such functions without expecting a return.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/error_code_list.rst#2025-04-22_snippet_23\n\nLANGUAGE: python\nCODE:\n```\ndef f() -> None:\n    ...\n\n# OK: we don't do anything with the return value\nf()\n\n# Error: \"f\" does not return a value (it only ever returns None)  [func-returns-value]\nif f():\n     print(\"not false\")\n```\n\n----------------------------------------\n\nTITLE: Conditional Overloads Based on Python Version\nDESCRIPTION: This snippet shows how to define function overloads conditionally based on Python version using sys.version_info. Different type signatures are available depending on the Python version being used.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/more_types.rst#2025-04-22_snippet_13\n\nLANGUAGE: python\nCODE:\n```\n# flags: --python-version 3.10\nimport sys\nfrom typing import Any, overload\n\nclass A: ...\nclass B: ...\nclass C: ...\nclass D: ...\n\n\nif sys.version_info < (3, 7):\n    @overload\n    def func(var: A) -> A: ...\n\nelif sys.version_info >= (3, 10):\n    @overload\n    def func(var: B) -> B: ...\n\nelse:\n    @overload\n    def func(var: C) -> C: ...\n\n@overload\ndef func(var: D) -> D: ...\n\ndef func(var: Any) -> Any:\n    return var\n\n\nreveal_type(func(B()))  # Revealed type is \"B\"\nreveal_type(func(C()))  # No overload variant of \"func\" matches argument type \"C\"\n    # Possible overload variants:\n    #     def func(var: B) -> B\n    #     def func(var: D) -> D\n    # Revealed type is \"Any\"\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Attribute Assignment Restrictions in MyPy Native Classes (Python)\nDESCRIPTION: Illustrates how native classes restrict attribute assignment on instances, similar to using `__slots__`. Attributes defined in the class (`x`) or assigned within methods (`y`, `z`) are allowed, but assigning a completely new attribute (`extra`) raises an error at runtime.\nSOURCE: https://github.com/python/mypy/blob/master/mypyc/doc/native_classes.rst#2025-04-22_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\nclass Cls:\n    x: int\n\n    def __init__(self, y: int) -> None:\n        self.x = 0\n        self.y = y\n\n    def method(self) -> None:\n        self.z = \"x\"\n\no = Cls(0)\nprint(o.x, o.y)  # OK\no.z = \"y\"  # OK\no.extra = 3  # Error: no attribute \"extra\"\n```\n\n----------------------------------------\n\nTITLE: Defining Function Outputs Using Inline TypedDicts in Python\nDESCRIPTION: Illustrates defining a function using inline TypedDict syntax for type annotations. Requires '--enable-incomplete-feature=InlineTypedDict' as it is experimental. The function test_values returns a TypedDict with keys 'int' as integer and 'str' as string.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/typed_dict.rst#2025-04-22_snippet_15\n\nLANGUAGE: python\nCODE:\n```\ndef test_values() -> {\"int\": int, \"str\": str}:\n    return {\"int\": 42, \"str\": \"test\"}\n\nclass Response(TypedDict):\n    status: int\n    msg: str\n    # Using inline syntax here avoids defining two additional TypedDicts.\n    content: {\"items\": list[{\"key\": str, \"value\": str}]}\n```\n\n----------------------------------------\n\nTITLE: Implementing Decorator Factories with Generics (Python 3.11)\nDESCRIPTION: Legacy version of a decorator factory that takes arguments and returns a decorator, using TypeVar with bound for Python 3.11 and earlier.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/generics.rst#2025-04-22_snippet_44\n\nLANGUAGE: python\nCODE:\n```\nfrom collections.abc import Callable\nfrom typing import Any, TypeVar\n\nF = TypeVar('F', bound=Callable[..., Any])\n\ndef route(url: str) -> Callable[[F], F]:\n    ...\n\n@route(url='/')\ndef index(request: Any) -> str:\n    return 'Hello world'\n```\n\n----------------------------------------\n\nTITLE: Running mypy with Explicit Namespace Package Base Using MYPYPATH - Bash\nDESCRIPTION: Illustrates running mypy on a directory containing a namespace package, using both --namespace-packages and --explicit-package-bases flags, and sets MYPYPATH to specify the base path. This configures mypy to map source files to their fully qualified module names even without __init__.py files at the top level. Requires environmental variable setting and mypy installation.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/running_mypy.rst#2025-04-22_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\n$ MYPYPATH=src mypy --namespace-packages --explicit-package-bases .\n```\n\n----------------------------------------\n\nTITLE: Disallowing Untyped Function Calls in Python with Mypy\nDESCRIPTION: This example leverages mypy's --disallow-untyped-calls option to prevent calls to functions without type annotations from within functions that do have annotations, thus maintaining type integrity.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/error_code_list2.rst#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n# mypy: disallow-untyped-calls\n\ndef do_it() -> None:\n    # Error: Call to untyped function \"bad\" in typed context  [no-untyped-call]\n    bad()\n\ndef bad():\n    ...\n```\n\n----------------------------------------\n\nTITLE: Preventing use before definition errors with Mypy\nDESCRIPTION: Mypy provides errors for names used prior to their definition, enhancing variable definition clarity. The example shows error generation for utilizing a variable before assignment.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/error_code_list.rst#2025-04-22_snippet_3\n\nLANGUAGE: Python\nCODE:\n```\n    print(x)  # Error: Name \"x\" is used before definition [used-before-def]\n    x = 123\n```\n\n----------------------------------------\n\nTITLE: Undetected Runtime Error with Overloads Due to Implementation Bias in Python\nDESCRIPTION: Illustrates a subtle runtime error involving overloads that Mypy does *not* detect. The `summarize` function's implementation returns `0.0` (a float) for any empty list. When called with an empty list typed as `list[str]`, Mypy infers the return type as `str` based on the second variant. However, the runtime returns `float`, leading to a `TypeError` during string concatenation. This highlights that implementation details can cause discrepancies not caught by static analysis.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/more_types.rst#2025-04-22_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nsome_list: list[str] = []\nsummarize(some_list) + \"danger danger\"  # Type safe, yet crashes at runtime!\n```\n\n----------------------------------------\n\nTITLE: Revealing TypedDict Type for Debugging - Python\nDESCRIPTION: Example using mypy's reveal_type to show the resolved type of a (partial) TypedDict variable, demonstrating how non-required (optional) keys appear in the type. Only works with type-checking tools; ignored at runtime.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/typed_dict.rst#2025-04-22_snippet_9\n\nLANGUAGE: python\nCODE:\n```\n# Revealed type is \"TypedDict('GuiOptions', {'language'?: builtins.str,\n#                                            'color'?: builtins.str})\"\nreveal_type(options)\n```\n\n----------------------------------------\n\nTITLE: Declaring ReadOnly Items in TypedDict (PEP 705) - Python\nDESCRIPTION: This snippet demonstrates using 'typing.ReadOnly' (introduced in PEP 705) to specify certain TypedDict items as read-only, which prohibits assignment after their creation. It shows the definition of a 'TD' TypedDict with both writable and read-only fields and the use of 'ReadOnly' from 'typing_extensions' for compatibility. Dependencies: Python 3.13+ for 'typing.ReadOnly', or install 'typing_extensions' for earlier versions. Key parameters: the type annotations for fields in the TypedDict. Inputs/outputs: TypedDict instances with field-level mutability constraints. Limitation: Enforced at type-check time, not at runtime.\nSOURCE: https://github.com/python/mypy/blob/master/CHANGELOG.md#2025-04-22_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import TypedDict\n\n# Or \"from typing ...\" on Python 3.13\nfrom typing_extensions import ReadOnly\n\nclass TD(TypedDict):\n    a: int\n    b: ReadOnly[int]\n\nd: TD = {\"a\": 1, \"b\": 2}\nd[\"a\"] = 3  # OK\nd[\"b\"] = 5  # Error: \"b\" is ReadOnly\n```\n\n----------------------------------------\n\nTITLE: Demonstrating int to float assignment restrictions in Mypyc\nDESCRIPTION: Example showing how Mypyc now requires explicit conversion when assigning int values to float variables.\nSOURCE: https://github.com/python/mypy/blob/master/CHANGELOG.md#2025-04-22_snippet_45\n\nLANGUAGE: python\nCODE:\n```\ndef example(n: int) -> None:\n    a: float = 1  # Error: cannot assign \"int\" to \"float\"\n    b: float = 1.0  # OK\n    c: float = n  # Error\n    d: float = float(n)  # OK\n```\n\n----------------------------------------\n\nTITLE: Selective Disabling of disallow_untyped_calls with INI - INI\nDESCRIPTION: Provides an example INI configuration for mypy where type checking for untyped calls is enabled globally but selectively disabled as an override for 'some.library.*' modules. The first section enables 'disallow_untyped_calls' for all modules, while the following section disables this check just inside 'some.library.*'. No additional dependencies are required; applies only to INI-based mypy configs.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/config_file.rst#2025-04-22_snippet_4\n\nLANGUAGE: INI\nCODE:\n```\n[mypy]\ndisallow_untyped_calls = True\n\n[mypy-some.library.*]\ndisallow_untyped_calls = False\n```\n\n----------------------------------------\n\nTITLE: Type Annotation for Empty Collections in Python\nDESCRIPTION: Example showing how to properly annotate an empty list with its intended element type, which helps mypy determine the correct type when the initial value doesn't provide enough information.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/common_issues.rst#2025-04-22_snippet_8\n\nLANGUAGE: python\nCODE:\n```\na: list[int] = []\n```\n\n----------------------------------------\n\nTITLE: Identifying Redundant Expressions in Python with Mypy\nDESCRIPTION: This example makes use of the --enable-error-code redundant-expr option to pinpoint and eliminate redundant expressions in Python code, ensuring streamlined and efficient logic.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/error_code_list2.rst#2025-04-22_snippet_10\n\nLANGUAGE: python\nCODE:\n```\n# mypy: enable-error-code=\"redundant-expr\"\n\ndef example(x: int) -> None:\n    # Error: Left operand of \"and\" is always true  [redundant-expr]\n    if isinstance(x, int) and x > 0:\n        pass\n\n    # Error: If condition is always true  [redundant-expr]\n    1 if isinstance(x, int) else 0\n\n    # Error: If condition in comprehension is always true  [redundant-expr]\n    [i for i in range(x) if isinstance(i, int)]\n```\n\n----------------------------------------\n\nTITLE: Unmatchable Overload Signature Check in Python\nDESCRIPTION: Demonstrates how Mypy detects overload signatures that can never be matched due to wider signatures in earlier overloads.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/error_code_list.rst#2025-04-22_snippet_40\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import overload, Union\n\n@overload\ndef process(response1: object, response2: object) -> object:\n    ...\n@overload\ndef process(response1: int, response2: int) -> int: # E: Overloaded function signature 2 will never be matched: signature 1's parameter type(s) are the same or broader  [overload-cannot-match]\n    ...\n\ndef process(response1: object, response2: object) -> object:\n    return response1 + response2\n```\n\n----------------------------------------\n\nTITLE: Installing Mypy using pip in Bash\nDESCRIPTION: This command uses the Python package installer `pip` to install the latest stable version of Mypy. The `-U` flag ensures that Mypy is upgraded if it's already installed. This is the standard way to install Mypy.\nSOURCE: https://github.com/python/mypy/blob/master/README.md#2025-04-22_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n```bash\npython3 -m pip install -U mypy\n```\n```\n\n----------------------------------------\n\nTITLE: Illustrating Immutable Method Assignment in MyPy Native Classes (Python)\nDESCRIPTION: Shows that attempting to reassign or add new methods to a compiled native class at runtime results in an error. This highlights the immutability of their type object namespaces compared to regular Python classes.\nSOURCE: https://github.com/python/mypy/blob/master/mypyc/doc/native_classes.rst#2025-04-22_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\nclass Cls:\n    def method1(self) -> None:\n        print(\"method1\")\n\n    def method2(self) -> None:\n        print(\"method2\")\n\nCls.method1 = Cls.method2  # Error\nCls.new_method = Cls.method2  # Error\n```\n\n----------------------------------------\n\nTITLE: Indexing Operations Checking in Python with Mypy\nDESCRIPTION: Explains how Mypy checks if a value is indexable and if the index type matches the supported types of the data structure. This example uses a dictionary with specific type checks.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/error_code_list.rst#2025-04-22_snippet_18\n\nLANGUAGE: python\nCODE:\n```\na = {'x': 1, 'y': 2}\n\na['x']  # OK\n\n# Error: Invalid index type \"int\" for \"dict[str, int]\"; expected type \"str\"  [index]\nprint(a[1])\n\n# Error: Invalid index type \"bytes\" for \"dict[str, int]\"; expected type \"str\"  [index]\na[b'x'] = 4\n```\n\n----------------------------------------\n\nTITLE: Overriding a Property with a Final Attribute in Python Classes\nDESCRIPTION: Demonstrates that a class can override a base class property by declaring a final attribute in the subclass, which prevents further overriding but is allowed by mypy. This requires typical use of @property for the base, Final for the subclass, and mypy static analysis. Inputs involve class inheritance structures and property/final declarations; output is allowed override, but further subclass attempts to redefine ID will result in errors.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/final_attrs.rst#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nclass Base:\n    @property\n    def ID(self) -> int: ...\n\nclass Derived(Base):\n    ID: Final = 1  # OK\n```\n\n----------------------------------------\n\nTITLE: Contextual Type Inference for List Assignment in Python\nDESCRIPTION: Demonstrates bidirectional type inference in mypy: when assigning to a typed variable, mypy infers the expression's type from the context of the variable. Assigning a plain list to a 'list[object]' variable results in the list being typed as 'list[object]'. Supports type safety when initializing variables.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/type_inference_and_annotations.rst#2025-04-22_snippet_10\n\nLANGUAGE: python\nCODE:\n```\ndef f(l: list[object]) -> None:\\n    l = [1, 2]  # Infer type list[object] for [1, 2], not list[int]\n```\n\n----------------------------------------\n\nTITLE: Using Literal Types with Function Overloading in Python\nDESCRIPTION: Demonstrates how to use Literal types with overloaded functions to provide precise return types based on the literal value of an argument. This creates more specific type signatures that differentiate between True and False boolean inputs.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/literal_types.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import overload, Union, Literal\n\n# The first two overloads use Literal[...] so we can\n# have precise return types:\n\n@overload\ndef fetch_data(raw: Literal[True]) -> bytes: ...\n@overload\ndef fetch_data(raw: Literal[False]) -> str: ...\n\n# The last overload is a fallback in case the caller\n# provides a regular bool:\n\n@overload\ndef fetch_data(raw: bool) -> Union[bytes, str]: ...\n\ndef fetch_data(raw: bool) -> Union[bytes, str]:\n    # Implementation is omitted\n    ...\n\nreveal_type(fetch_data(True))        # Revealed type is \"bytes\"\nreveal_type(fetch_data(False))       # Revealed type is \"str\"\n\n# Variables declared without annotations will continue to have an\n# inferred type of 'bool'.\n\nvariable = True\nreveal_type(fetch_data(variable))    # Revealed type is \"Union[bytes, str]\"\n```\n\n----------------------------------------\n\nTITLE: Avoiding 'Any' Types from Unimported Components in Python with Mypy\nDESCRIPTION: This snippet showcases the --disallow-any-unimported option of mypy, used to catch types that inadvertently become 'Any' due to unresolved imports, thereby preventing unintended type imprecision.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/error_code_list2.rst#2025-04-22_snippet_7\n\nLANGUAGE: python\nCODE:\n```\n# mypy: disallow-any-unimported\n\nfrom animals import Cat  # type: ignore\n\n# Error: Argument 1 to \"feed\" becomes \"Any\" due to an unfollowed import  [no-any-unimported]\ndef feed(cat: Cat) -> None:\n    ...\n```\n\n----------------------------------------\n\nTITLE: Combining @final Decorator with Abstract Base Classes in Python\nDESCRIPTION: Exhibits that applying the @final decorator to an abstract class that still has abstract attributes will cause mypy to generate errors since the final class would be impossible to instantiate. Uses abc.ABCMeta, abc.abstractmethod, and typing.final. Inputs: abstract class declaration, abstract method, @final decoration. Output: static analysis error when class is both abstract and final.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/final_attrs.rst#2025-04-22_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nfrom abc import ABCMeta, abstractmethod\nfrom typing import final\n\n@final\nclass A(metaclass=ABCMeta):  # error: Final class A has abstract attributes \"f\"\n    @abstractmethod\n    def f(self, x: int) -> None: pass\n```\n\n----------------------------------------\n\nTITLE: Attempting to Use a Union for concat Inputs - Python\nDESCRIPTION: Demonstrates the difference between union types and value-restricted type variables. Shows that a union type for concat's arguments results in a runtime (and static) type-checking error when combining incompatible types, illustrating why value restriction is better for this use case. No dependencies.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/generics.rst#2025-04-22_snippet_29\n\nLANGUAGE: python\nCODE:\n```\ndef union_concat(x: str | bytes, y: str | bytes) -> str | bytes:\n    return x + y  # Error: can't concatenate str and bytes\n```\n\n----------------------------------------\n\nTITLE: Using String Literals and Type Comments for Forward References - Python\nDESCRIPTION: Provides alternatives for handling forward references in Python 3.6 and below, including string literal annotations or type comments on parameters. Ensures type hints do not cause NameErrors before the class definition. Inputs are functions and a class; outputs are error-free code compatible with Mypy. No additional dependencies required.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/runtime_troubles.rst#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\ndef f(x: 'A') -> None: ...  # OK\n\n# Also OK\ndef g(x):  # type: (A) -> None\n    ...\n\nclass A: ...\n```\n\n----------------------------------------\n\nTITLE: Validating arguments in function calls with Mypy\nDESCRIPTION: Mypy checks call argument consistency with function signatures, flagging incorrect argument usage, but it does not address argument types here. Requires proper function definitions. The example illustrates too many arguments.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/error_code_list.rst#2025-04-22_snippet_4\n\nLANGUAGE: Python\nCODE:\n```\n    def greet(name: str) -> None:\n         print('hello', name)\n\n    greet('jack')  # OK\n    greet('jill', 'jack')  # Error: Too many arguments for \"greet\"  [call-arg]\n```\n\n----------------------------------------\n\nTITLE: Method Overrides: Argument and Return Type Safety - Python\nDESCRIPTION: This set of examples demonstrates safe and unsafe method overrides in Python according to mypy's type system. It covers generalizing and narrowing argument and return types. Dependencies: collections.abc for type annotations. Shows cases that trigger mypy errors and cases that are allowed, helping clarify method signature compatibility rules in class inheritance.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/common_issues.rst#2025-04-22_snippet_25\n\nLANGUAGE: python\nCODE:\n```\nfrom collections.abc import Sequence, Iterable\\n\\nclass A:\\n    def test(self, t: Sequence[int]) -> Sequence[str]:\\n        ...\\n\\nclass GeneralizedArgument(A):\\n    # A more general argument type is okay\\n    def test(self, t: Iterable[int]) -> Sequence[str]:  # OK\\n        ...\\n\\nclass NarrowerArgument(A):\\n    # A more specific argument type isn't accepted\\n    def test(self, t: list[int]) -> Sequence[str]:  # Error\\n        ...\\n\\nclass NarrowerReturn(A):\\n    # A more specific return type is fine\\n    def test(self, t: Sequence[int]) -> List[str]:  # OK\\n        ...\\n\\nclass GeneralizedReturn(A):\\n    # A more general return type is an error\\n    def test(self, t: Sequence[int]) -> Iterable[str]:  # Error\\n        ...\n```\n\n----------------------------------------\n\nTITLE: Declaring Supertype as Variable Type in Python\nDESCRIPTION: Addresses scenarios where the inferred type is a narrower subclass than desired and suggests providing explicit type annotations to define variables as supertypes for flexible assignments.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/common_issues.rst#2025-04-22_snippet_13\n\nLANGUAGE: python\nCODE:\n```\nclass Shape: ...\nclass Circle(Shape): ...\nclass Triangle(Shape): ...\n\nshape = Circle()    # mypy infers the type of shape to be Circle\nshape = Triangle()  # error: Incompatible types in assignment (expression has type \"Triangle\", variable has type \"Circle\")\n```\n\nLANGUAGE: python\nCODE:\n```\nshape: Shape = Circle()  # The variable s can be any Shape, not just Circle\nshape = Triangle()       # OK\n```\n\n----------------------------------------\n\nTITLE: Mypy Error Detection with assert_never for Literal Type in Python\nDESCRIPTION: This example shows Mypy reporting an error when a new value ('three') is added to `PossibleValues` but the `validate` function is not updated. The `assert_never(x)` call becomes reachable for the unhandled literal, triggering a Mypy error.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/literal_types.rst#2025-04-22_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nPossibleValues = Literal['one', 'two', 'three']\n\ndef validate(x: PossibleValues) -> bool:\n    if x == 'one':\n        return True\n    elif x == 'two':\n        return False\n    # Error: Argument 1 to \"assert_never\" has incompatible type \"Literal['three']\";\n    # expected \"NoReturn\"\n    assert_never(x)\n```\n\n----------------------------------------\n\nTITLE: Mypy argument type validation\nDESCRIPTION: Checks that actual argument types match function signature types, generating errors for mismatches. Demonstrated with a function expecting a list but receiving a tuple instead. Involves typing checks within function calls.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/error_code_list.rst#2025-04-22_snippet_5\n\nLANGUAGE: Python\nCODE:\n```\n    def first(x: list[int]) -> int:\n        return x[0] if x else 0\n\n    t = (5, 4)\n    # Error: Argument 1 to \"first\" has incompatible type \"tuple[int, int]\";\n    #        expected \"list[int]\"  [arg-type]\n    print(first(t))\n```\n\n----------------------------------------\n\nTITLE: Propagating 'Any' via Attribute Access and Function Calls - Python\nDESCRIPTION: Illustrates how values derived from 'Any' are also typed as 'Any', as revealed by mypy's reveal_type utility. Demonstrates that attribute access and function calls preserve the 'Any' type, making it difficult for static analysis to determine actual types downstream. Assumes use of 'reveal_type' function from mypy for showing inferred types, and 'x' parameter as 'Any'; intended for users familiar with mypy's static analysis tools.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/dynamic_typing.rst#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ndef f(x: Any) -> None:\n    y = x.foo()\n    reveal_type(y)  # Revealed type is \"Any\"\n    z = y.bar(\"mypy will let you do anything to y\")\n    reveal_type(z)  # Revealed type is \"Any\"\n```\n\n----------------------------------------\n\nTITLE: Built-in Type and Attribute Functions Usage - Python\nDESCRIPTION: Lists native implementations of built-in type and attribute functions like isinstance, cast, type, len, abs, id, iter, next, hash, getattr, setattr, hasattr, delattr, slice, and globals in Python. No dependencies required except that 'obj', 'type', 'iter', or arguments must be valid Python objects. Functions return varied types, e.g. isinstance returns bool, getattr returns attribute value or default.\nSOURCE: https://github.com/python/mypy/blob/master/mypyc/doc/native_operations.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nisinstance(obj, type: type)\n```\n\nLANGUAGE: python\nCODE:\n```\nisinstance(obj, type: tuple)\n```\n\nLANGUAGE: python\nCODE:\n```\ncast(<type>, obj)\n```\n\nLANGUAGE: python\nCODE:\n```\ntype(obj)\n```\n\nLANGUAGE: python\nCODE:\n```\nlen(obj)\n```\n\nLANGUAGE: python\nCODE:\n```\nabs(obj)\n```\n\nLANGUAGE: python\nCODE:\n```\nid(obj)\n```\n\nLANGUAGE: python\nCODE:\n```\niter(obj)\n```\n\nLANGUAGE: python\nCODE:\n```\nnext(iter: Iterator)\n```\n\nLANGUAGE: python\nCODE:\n```\nhash(obj)\n```\n\nLANGUAGE: python\nCODE:\n```\ngetattr(obj, attr)\n```\n\nLANGUAGE: python\nCODE:\n```\ngetattr(obj, attr, default)\n```\n\nLANGUAGE: python\nCODE:\n```\nsetattr(obj, attr, value)\n```\n\nLANGUAGE: python\nCODE:\n```\nhasattr(obj, attr)\n```\n\nLANGUAGE: python\nCODE:\n```\ndelattr(obj, name)\n```\n\nLANGUAGE: python\nCODE:\n```\nslice(start, stop, step)\n```\n\nLANGUAGE: python\nCODE:\n```\nglobals()\n```\n\n----------------------------------------\n\nTITLE: List Item Type Compatibility in Mypy\nDESCRIPTION: Demonstrates how Mypy ensures that each item in a list matches the inferred list type. An error is raised if an item has an incompatible type.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/error_code_list.rst#2025-04-22_snippet_19\n\nLANGUAGE: python\nCODE:\n```\n# Error: List item 0 has incompatible type \"int\"; expected \"str\"  [list-item]\na: list[str] = [0]\n```\n\n----------------------------------------\n\nTITLE: Defining and Validating Literal Types in Python\nDESCRIPTION: This code defines a `Literal` type `PossibleValues` and a function `validate` that checks its input against the allowed literal values. This initial version does not perform exhaustiveness checking.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/literal_types.rst#2025-04-22_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Literal\n\nPossibleValues = Literal['one', 'two']\n\ndef validate(x: PossibleValues) -> bool:\n    if x == 'one':\n        return True\n    elif x == 'two':\n        return False\n    raise ValueError(f'Invalid value: {x}')\n\nassert validate('one') is True\nassert validate('two') is False\n```\n\n----------------------------------------\n\nTITLE: Sample mypy Error Messages for Missing Imports - Text\nDESCRIPTION: Shows examples of error messages that mypy may emit when it encounters missing modules, missing stubs, or missing py.typed markers during import analysis. These outputs help users understand the nature of import errors and the source of the reporting.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/running_mypy.rst#2025-04-22_snippet_8\n\nLANGUAGE: text\nCODE:\n```\nmain.py:1: error: Skipping analyzing 'django': module is installed, but missing library stubs or py.typed marker\nmain.py:2: error: Library stubs not installed for \"requests\"\nmain.py:3: error: Cannot find implementation or library stub for module named \"this_module_does_not_exist\"\n```\n\n----------------------------------------\n\nTITLE: Defining SupportsBytes Protocol with __bytes__ (Python)\nDESCRIPTION: Specifies the __bytes__ method used for the typing.SupportsBytes protocol. Enables using bytes(x) on objects that implement it. Must return a bytes object.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/protocols.rst#2025-04-22_snippet_20\n\nLANGUAGE: python\nCODE:\n```\ndef __bytes__(self) -> bytes\n\n```\n\n----------------------------------------\n\nTITLE: Silencing Mypy Errors via Dynamic Typing with Any in Python\nDESCRIPTION: Shows how to use 'Any' from the 'typing' module to make variables dynamically typed, thereby silencing mypy errors for mixed or unknown types. This technique is useful when type information cannot be specified or when interfacing with dynamically typed APIs.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/type_inference_and_annotations.rst#2025-04-22_snippet_16\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Any\\n\\ndef f(x: Any, y: str) -> None:\\n    x = 'hello'\\n    x += 1  # OK\n```\n\n----------------------------------------\n\nTITLE: Detecting Unreachable Code with --warn-unreachable\nDESCRIPTION: The following Python code demonstrates MyPy’s --warn-unreachable flag, which reports errors on code paths deemed unreachable after type analysis. It highlights redundancies and logical errors in control flow.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/command_line.rst#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\ndef process(x: int) -> None:\n    # Error: Right operand of \"or\" is never evaluated\n    if isinstance(x, int) or x > 7:\n        # Error: Unsupported operand types for + (\"int\" and \"str\")\n        print(x + \"bad\")\n    else:\n        # Error: 'Statement is unreachable' error\n        print(x + \"bad\")\n```\n\n----------------------------------------\n\nTITLE: Inferring Union Types in Conditional Expressions - Python\nDESCRIPTION: This code illustrates how mypy infers more precise union types for conditional expressions when the two branches return different types. It demonstrates that using a conditional expression with operands of 'str' and 'int' leads to the inferred type 'str | int', and handling of 'Any' in conditionals now results in types like 'Any | None'. Dependencies: No extra dependencies beyond Python (mypy for static checking). Key parameters are the branches of the conditional expression. Expected input: any expression or function matching the demonstrated types; output: static type union inferred by mypy. Limitation: Static typing only; runtime type remains dynamic.\nSOURCE: https://github.com/python/mypy/blob/master/CHANGELOG.md#2025-04-22_snippet_9\n\nLANGUAGE: python\nCODE:\n```\ns = \"foo\" if cond() else 1\n# Type of \"s\" is now \"str | int\" (it used to be \"object\")\n```\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Any\n\ndef func(a: Any, b: bool) -> None:\n    x = a if b else None\n    # Type of x is \"Any | None\"\n    print(x.y)  # Error: None has no attribute \"y\"\n```\n\n----------------------------------------\n\nTITLE: Subclassing with Class Types in Python\nDESCRIPTION: Demonstrates subclassing in Python where a subclass B overrides a method from its superclass A. Mypy checks for method compatibility and identifies missing attributes in class instances. Dependencies: None Key parameters: A, B - they represent class types.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/kinds_of_types.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nclass A:\n    def f(self) -> int:  # Type of self inferred (A)\n        return 2\n\nclass B(A):\n    def f(self) -> int:\n         return 3\n    def g(self) -> int:\n        return 4\n\ndef foo(a: A) -> None:\n    print(a.f())  # 3\n    a.g()         # Error: \"A\" has no attribute \"g\"\n\nfoo(B())  # OK (B is a subclass of A)\n```\n\n----------------------------------------\n\nTITLE: Suppressing All Mypy Errors in a File Using File-Level Ignore in Python\nDESCRIPTION: Demonstrates disabling all mypy type checking in a specific file by placing '# mypy: ignore-errors' at the top. Useful for tests, quick experiments, or files that cannot be fully annotated. Add before any code or imports.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/type_inference_and_annotations.rst#2025-04-22_snippet_17\n\nLANGUAGE: python\nCODE:\n```\n# mypy: ignore-errors\\n# This is a test file, skipping type checking in it.\\nimport unittest\\n...\n```\n\n----------------------------------------\n\nTITLE: Implementing Type Parameter Defaults with PEP 696\nDESCRIPTION: Demonstrates the use of type parameter defaults (PEP 696) by defining a default for TypeVar 'BotT'. The example shows how a Context class uses the default type when no explicit type argument is provided.\nSOURCE: https://github.com/python/mypy/blob/master/CHANGELOG.md#2025-04-22_snippet_24\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Generic\nfrom typing_extensions import TypeVar\n\nclass Bot: ...\n\nBotT = TypeVar(\"BotT\", bound=Bot, default=Bot)\n\nclass Context(Generic[BotT]):\n    bot: BotT\n\nclass MyBot(Bot): ...\n\n# type is Bot (the default)\nreveal_type(Context().bot)\n# type is MyBot\nreveal_type(Context[MyBot]().bot)\n```\n\n----------------------------------------\n\nTITLE: Complete Mypy Configuration Example in TOML\nDESCRIPTION: Comprehensive example of a pyproject.toml file showing global Mypy options and module-specific overrides including regex path exclusions and various warning configurations.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/config_file.rst#2025-04-22_snippet_15\n\nLANGUAGE: toml\nCODE:\n```\n[tool.mypy]\npython_version = \"3.9\"\nwarn_return_any = true\nwarn_unused_configs = true\nexclude = [\n    '^file1\\.py$',\n    \"^file2\\.py$\",\n]\n\n[[tool.mypy.overrides]]\nmodule = \"mycode.foo.*\"\ndisallow_untyped_defs = true\n\n[[tool.mypy.overrides]]\nmodule = \"mycode.bar\"\nwarn_return_any = false\n\n[[tool.mypy.overrides]]\nmodule = [\n    \"somelibrary\",\n    \"some_other_library\"\n]\nignore_missing_imports = true\n```\n\n----------------------------------------\n\nTITLE: Restricted Methods in Generic Classes Using Self-Types\nDESCRIPTION: This code demonstrates how to use self-type annotations to restrict method calls in generic classes. The uppercase_item method is only allowed to be called when the generic parameter is of type str.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/more_types.rst#2025-04-22_snippet_15\n\nLANGUAGE: python\nCODE:\n```\nclass Tag[T]:\n    item: T\n\n    def uppercase_item(self: Tag[str]) -> str:\n        return self.item.upper()\n\ndef label(ti: Tag[int], ts: Tag[str]) -> None:\n    ti.uppercase_item()  # E: Invalid self argument \"Tag[int]\" to attribute function\n                         # \"uppercase_item\" with type \"Callable[[Tag[str]], str]\"\n    ts.uppercase_item()  # This is OK\n```\n\n----------------------------------------\n\nTITLE: Forward Reference without String Literals or __future__ - Python\nDESCRIPTION: Illustrates how referencing a class before it has been defined in a type annotation causes a NameError. This snippet demonstrates an anti-pattern to help explain the need for string literal types or the __future__ annotation import. Input is a function annotated with an as-yet-undefined class; output is a runtime error. No dependencies are required.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/runtime_troubles.rst#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ndef f(x: A) -> None: ...  # NameError: name \"A\" is not defined\nclass A: ...\n```\n\n----------------------------------------\n\nTITLE: Demonstrating ignore-without-code error code in Python with mypy\nDESCRIPTION: Shows how mypy warns when a '# type: ignore' comment doesn't specify error codes, which can silence more errors than intended.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/error_code_list2.rst#2025-04-22_snippet_14\n\nLANGUAGE: python\nCODE:\n```\n# mypy: enable-error-code=\"ignore-without-code\"\n\nclass Foo:\n    def __init__(self, name: str) -> None:\n        self.name = name\n\nf = Foo('foo')\n\n# This line has a typo that mypy can't help with as both:\n# - the expected error 'assignment', and\n# - the unexpected error 'attr-defined'\n# are silenced.\n# Error: \"type: ignore\" comment without error code (consider \"type: ignore[attr-defined]\" instead)\nf.nme = 42  # type: ignore\n\n# This line warns correctly about the typo in the attribute name\n# Error: \"Foo\" has no attribute \"nme\"; maybe \"name\"?\nf.nme = 42  # type: ignore[assignment]\n```\n\n----------------------------------------\n\nTITLE: Running the Compiled Mypyc Module (Console)\nDESCRIPTION: Command to execute the compiled C extension module generated by mypyc. It uses `python3 -c \"import fib\"` to import the module, triggering the execution of the timed code within it. The output demonstrates the significantly faster execution time compared to the interpreted version.\nSOURCE: https://github.com/python/mypy/blob/master/mypyc/doc/getting_started.rst#2025-04-22_snippet_7\n\nLANGUAGE: console\nCODE:\n```\n$ python3 -c \"import fib\"\n0.04097270965576172\n```\n\n----------------------------------------\n\nTITLE: Runtime Error on Extending Enum in Python\nDESCRIPTION: This code demonstrates the standard Python runtime behavior where attempting to inherit from an `Enum` class that already has members defined raises a `TypeError`, as Enums are implicitly final once members are defined.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/literal_types.rst#2025-04-22_snippet_19\n\nLANGUAGE: python\nCODE:\n```\n>>> class AllDirection(Direction):\n...     left = 'left'\n...     right = 'right'\nTraceback (most recent call last):\n  ...\nTypeError: AllDirection: cannot extend enumeration 'Direction'\n```\n\n----------------------------------------\n\nTITLE: Defining Container Protocol with __contains__ (Python)\nDESCRIPTION: Defines the __contains__ method required for objects supporting the 'in' operator. Used for custom container types compatible with collections.abc.Container. Accepts an object; returns bool indicating membership.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/protocols.rst#2025-04-22_snippet_16\n\nLANGUAGE: python\nCODE:\n```\ndef __contains__(self, x: object) -> bool\n\n```\n\n----------------------------------------\n\nTITLE: Silencing Override Error with type: ignore[override] - Python\nDESCRIPTION: This single-class example demonstrates how to suppress mypy override errors by annotating the method with # type: ignore[override]. This is useful when the override is intentional and type safety can be relaxed. Safe use requires the developer to accept responsibility for the runtime risks.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/common_issues.rst#2025-04-22_snippet_26\n\nLANGUAGE: python\nCODE:\n```\nclass NarrowerArgument(A):\\n    def test(self, t: List[int]) -> Sequence[str]:  # type: ignore[override]\\n        ...\n```\n\n----------------------------------------\n\nTITLE: Using Optional Types with Mypy in Python\nDESCRIPTION: Demonstrates the use of 'Optional' for type annotation in Python, indicating that a value could be of a specific type or None. Dependencies include importing 'Optional' from 'typing'. The function 'strlen' returns an 'Optional[int]', indicating it may return an 'int' or 'None'.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/kinds_of_types.rst#2025-04-22_snippet_7\n\nLANGUAGE: Python\nCODE:\n```\nfrom typing import Optional\n\ndef strlen(s: str) -> Optional[int]:\n    ...\n```\n\n----------------------------------------\n\nTITLE: Type Checking a Package Recursively with mypy - Bash\nDESCRIPTION: Uses the -p flag to instruct mypy to recursively type check all submodules and subpackages within a named package. This command requires that the package is importable and accessible in the current environment, with mypy installed. The output covers type checking for the named package and all its contents.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/running_mypy.rst#2025-04-22_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n$ mypy -p html\n```\n\n----------------------------------------\n\nTITLE: Setting a Single Mypy Inline Configuration Flag in Python\nDESCRIPTION: This snippet demonstrates how to set a single Mypy configuration flag directly within a Python file using a comment. The `# mypy: disallow-any-generics` comment instructs Mypy to disallow the use of untyped generics (like `list` instead of `list[int]`) within this specific file.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/inline_config.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n# mypy: disallow-any-generics\n```\n\n----------------------------------------\n\nTITLE: Enabling or Disabling Error Codes in Mypy Configuration\nDESCRIPTION: This INI configuration snippet for a mypy.ini file illustrates how to globally enable and disable specific Mypy error codes and adjust them per module. Key parameters include enabling error codes for strict mode globally while allowing untyped definitions for test modules.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/error_codes.rst#2025-04-22_snippet_1\n\nLANGUAGE: ini\nCODE:\n```\n[mypy]\\nstrict = True\\n\\n[mypy-tests.*]\\nallow_untyped_defs = True\\nallow_untyped_calls = True\\ndisable_error_code = var-annotated, has-type\n```\n\n----------------------------------------\n\nTITLE: Suppressing Mypy Errors with Explanatory Comments in Python\nDESCRIPTION: Enhances error-suppression examples by including a trailing explanation for why the ignore comment was added. This can help with future refactoring or for reviewers to understand the context. Annotations may include versioning or links to known issues.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/type_inference_and_annotations.rst#2025-04-22_snippet_15\n\nLANGUAGE: python\nCODE:\n```\n# Starting app on http://localhost:8000\\napp.run(8000)  # type: ignore  # `run()` in v2.0 accepts an `int`, as a port\n```\n\n----------------------------------------\n\nTITLE: Defining Callable with Unspecified Arguments (Python)\nDESCRIPTION: This snippet shows how to define a `Callable` type hint that accepts any arguments using the ellipsis (`...`) notation. It specifies only the return type (`int`).\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/additional_features.rst#2025-04-22_snippet_14\n\nLANGUAGE: python\nCODE:\n```\nMyOtherFunc = Callable[..., int]\n```\n\n----------------------------------------\n\nTITLE: Runtime Risks of Mutable Attributes Without Invariance Check in Python\nDESCRIPTION: Provides a conceptual example (`takes_box_evil`) illustrating the runtime `TypeError` that could occur if mutable protocol attributes were covariant (allowed subtypes like `int` for `object`). Assigning an incompatible type (`str`) to `box.content` within the function breaks the assumption that `my_int_box.content` is an `int`. Protocol invariance prevents this specific scenario. Dependencies: `typing.Protocol` and classes from the previous example.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/protocols.rst#2025-04-22_snippet_7\n\nLANGUAGE: python\nCODE:\n```\ndef takes_box_evil(box: Box) -> None:\n    box.content = \"asdf\"  # This is bad, since box.content is supposed to be an object\n\nmy_int_box = IntBox()\ntakes_box_evil(my_int_box)\nmy_int_box.content + 1  # Oops, TypeError!\n```\n\n----------------------------------------\n\nTITLE: Incorrect Use of Self Type Variable - Python\nDESCRIPTION: This example demonstrates the use of the Self type variable from typing, and shows a mistake of returning Foo() instead of cls() in a classmethod. Includes two classes, Foo and Bar, and uses reveal_type to show mypy's inference. Dependency: typing.Self and a type checker supporting it. Purpose is to clarify type system expectations in constructors.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/common_issues.rst#2025-04-22_snippet_31\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Self\\n\\nclass Foo:\\n    @classmethod\\n    def constructor(cls) -> Self:\\n        # Instead, either call cls() or change the annotation to -> Foo\\n        return Foo()  # error: Incompatible return value type (got \\\"Foo\\\", expected \\\"Self\\\")\\n\\nclass Bar(Foo):\\n    ...\\n\\nreveal_type(Foo.constructor())  # note: Revealed type is \\\"Foo\\\"\\n# In the context of the subclass Bar, the Self return type promises\\n# that the return value will be Bar\\nreveal_type(Bar.constructor())  # note: Revealed type is \\\"Bar\\\"\n```\n\n----------------------------------------\n\nTITLE: Early and Late Binding Examples\nDESCRIPTION: Demonstrates the difference between early and late binding in Mypyc compiled code, showing various scenarios where each is used.\nSOURCE: https://github.com/python/mypy/blob/master/mypyc/doc/differences_from_python.rst#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Final\n\nimport lib  # \"lib\" is not compiled\n\nx = 0\ny: Final = 1\n\ndef func() -> None:\n    pass\n\nclass Cls:\n    def __init__(self, attr: int) -> None:\n        self.attr = attr\n\n    def method(self) -> None:\n        pass\n\ndef example() -> None:\n    # Early binding:\n    var = y\n    func()\n    o = Cls()\n    o.x\n    o.method()\n\n    # Late binding:\n    var = x  # Module-level variable\n    lib.func()  # Accessing library that is not compiled\n```\n\n----------------------------------------\n\nTITLE: Base Class Forward References with __future__ Annotations - Python\nDESCRIPTION: Demonstrates how Python's __future__ annotations import (PEP 563) affects runtime evaluation of function and variable annotations, but not all use-cases. Shows a case where base class names require string literal types to avoid errors, especially for generic/forward-referenced parents. Input is class definitions using forward-referenced names as base classes; output is an error-free class hierarchy at runtime. Requires Python 3.7+ and appropriate future import.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/runtime_troubles.rst#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n# base class example\nfrom __future__ import annotations\n\nclass A(tuple['B', 'C']): ... # String literal types needed here\nclass B: ...\nclass C: ...\n```\n\n----------------------------------------\n\nTITLE: Deleting the Compiled Mypyc Extension File (Shell)\nDESCRIPTION: Command using `rm` to delete the compiled C extension file (`.so`) generated by mypyc. This allows reverting back to the interpreted Python version of the module. The example uses a wildcard (`*`) to match platform-specific naming variations on Linux.\nSOURCE: https://github.com/python/mypy/blob/master/mypyc/doc/getting_started.rst#2025-04-22_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\n$ rm fib.*.so\n```\n\n----------------------------------------\n\nTITLE: Differentiating Protocols from Regular Subclasses in Python\nDESCRIPTION: Highlights the necessity of explicitly inheriting from `typing.Protocol` to define a protocol. Shows that `NotAProtocol`, which inherits only from the `SupportsClose` protocol, is treated as a regular (non-protocol) class. This leads to a Mypy error when assigning an instance of `Concrete` (which structurally matches but doesn't nominally inherit) because nominal subtyping is expected for non-protocol classes. Dependencies include `typing.Protocol` and the previously defined `SupportsClose`.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/protocols.rst#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nclass NotAProtocol(SupportsClose):  # This is NOT a protocol\n    new_attr: int\n\nclass Concrete:\n   new_attr: int = 0\n\n   def close(self) -> None:\n       ...\n\n# Error: nominal subtyping used by default\nx: NotAProtocol = Concrete()  # Error!\n```\n\n----------------------------------------\n\nTITLE: Modifying Literal Type Without Updating Handler in Python\nDESCRIPTION: This snippet shows adding a new value ('three') to the `PossibleValues` Literal type. Without exhaustiveness checking, Mypy won't detect that the `validate` function (from the previous snippet) doesn't handle this new case.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/literal_types.rst#2025-04-22_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nPossibleValues = Literal['one', 'two', 'three']\n```\n\n----------------------------------------\n\nTITLE: Suppressing Missing Import Errors with mypy.ini (INI)\nDESCRIPTION: This configuration disables missing import errors for all modules in the 'foobar' namespace by setting 'ignore_missing_imports = True' in a specific section of a mypy.ini file. This is effective when a library does not provide type annotations or stubs and you wish to silence related type-checking warnings. It can be used to target specific packages or subpackages using wildcards.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/running_mypy.rst#2025-04-22_snippet_12\n\nLANGUAGE: ini\nCODE:\n```\n[mypy-foobar.*]\\nignore_missing_imports = True\n```\n\n----------------------------------------\n\nTITLE: Preventing Subclass Overrides of Final Attributes in Python Classes\nDESCRIPTION: Shows how typing.Final can be applied to a base class attribute to prevent subclasses from overriding its value. Requires typing.Final and mypy for enforcement. When ListView attempts to assign a new value to BORDER_WIDTH, mypy produces an error because the attribute is final. This mechanism helps maintain subclass invariants, with the only input being the annotated attribute; output is static checking with errors on improper overrides.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/final_attrs.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Final\n\nclass Window:\n    BORDER_WIDTH: Final = 2.5\n    ...\n\nclass ListView(Window):\n    BORDER_WIDTH = 3  # Error: can't override a final attribute\n```\n\n----------------------------------------\n\nTITLE: Invalid Conditional Type Alias Assignment - Python\nDESCRIPTION: This code demonstrates why conditionally assigning multiple types to a would-be type alias without explicit typing is invalid in mypy, triggering an error. It also shows correct usage for type variables. Dependencies: random module for conditions. The example guides use of type[...] for conditional types and places where annotation is necessary.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/common_issues.rst#2025-04-22_snippet_24\n\nLANGUAGE: python\nCODE:\n```\nclass A: ...\\nclass B: ...\\n\\nif random() > 0.5:\\n    Alias = A\\nelse:\\n    # error: Cannot assign multiple types to name \\\"Alias\\\" without an\\n    # explicit \\\"Type[...]\\\" annotation\\n    Alias = B\\n\\ntp: type[object]  # \\\"tp\\\" is a variable with a type object value\\nif random() > 0.5:\\n    tp = A\\nelse:\\n    tp = B  # This is OK\\n\\ndef fun1(x: Alias) -> None: ...  # OK\\ndef fun2(x: tp) -> None: ...  # Error: \\\"tp\\\" is not valid as a type\n```\n\n----------------------------------------\n\nTITLE: Inheritance Order with Traits and Base Classes (Python)\nDESCRIPTION: These Python snippets illustrate the correct and incorrect ordering when a class inherits from both a non-trait base class and one or more traits in mypyc. Traits must always appear after the non-trait base class in the inheritance list.\nSOURCE: https://github.com/python/mypy/blob/master/mypyc/doc/using_type_annotations.rst#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nclass Base: ...\n\nclass Derived(Base, MyTrait, FooTrait):  # OK\n    ...\n```\n\nLANGUAGE: python\nCODE:\n```\nclass Derived2(MyTrait, FooTrait, Base):\n    # Error: traits should come last\n    ...\n```\n\n----------------------------------------\n\nTITLE: Determining Type Parameter Order in Legacy Generic Subclasses\nDESCRIPTION: Explains and demonstrates how the order of type parameters (`T`, `S`, `U`) is determined when defining generic classes using the legacy syntax with multiple generic base classes. The order depends on whether `Generic[...]` is explicitly listed in the bases and the order within it, or defaults to lexicographical order if `Generic` is omitted.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/generics.rst#2025-04-22_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Generic, TypeVar, Any\n\nT = TypeVar('T')\nS = TypeVar('S')\nU = TypeVar('U')\n\nclass One(Generic[T]): ...\nclass Another(Generic[T]): ...\n\nclass First(One[T], Another[S]): ...\nclass Second(One[T], Another[S], Generic[S, U, T]): ...\n\nx: First[int, str]        # Here T is bound to int, S is bound to str\ny: Second[int, str, Any]  # Here T is Any, S is int, and U is str\n```\n\n----------------------------------------\n\nTITLE: Omitting ClassVar Annotation for Attributes - Python\nDESCRIPTION: Demonstrates that attributes without ClassVar can be used as both class and instance variables. Mypy allows assignment at both levels, but cannot enforce strict separation, possibly leading to ambiguous semantics.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/class_basics.rst#2025-04-22_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nclass A:\n    x = 0  # Can be used as a class or instance variable\n\nA.x += 1  # OK\n\na = A()\na.x = 1  # Also OK\n```\n\n----------------------------------------\n\nTITLE: Demonstrating explicit-any error code in Python with mypy\nDESCRIPTION: Shows how mypy can prevent explicit Any annotations when using the disallow-any-explicit option, encouraging more specific typing.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/error_code_list2.rst#2025-04-22_snippet_23\n\nLANGUAGE: python\nCODE:\n```\n# mypy: disallow-any-explicit\nfrom typing import Any\nx: Any = 1  # Error: Explicit \"Any\" type annotation  [explicit-any]\n```\n\n----------------------------------------\n\nTITLE: Restrictions on Using Final in Type Annotations in Python\nDESCRIPTION: This snippet shows incorrect usage of typing.Final in type annotations for collection elements and function arguments, both of which are invalid. Only outermost variable assignments or attributes can be final. Dependencies: typing.Final and mypy, which will emit errors for these usages. Inputs are annotated variables and function definitions; outputs are mypy errors highlighting the improper syntax.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/final_attrs.rst#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nx: list[Final[int]] = []  # Error!\n\ndef fun(x: Final[list[int]]) ->  None:  # Error!\n    ...\n```\n\n----------------------------------------\n\nTITLE: NewType Target Validation in Python\nDESCRIPTION: Explains the Mypy error when a NewType definition references a non-class type, such as Any or a union. It advises resolving this by ensuring the target type is class-type.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/error_code_list.rst#2025-04-22_snippet_27\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import NewType\n\n# The source for \"acme\" is not available for mypy\nfrom acme import Entity  # type: ignore\n\n# Error: Argument 2 to NewType(...) must be subclassable (got \"Any\")  [valid-newtype]\nUserEntity = NewType('UserEntity', Entity)\n```\n\n----------------------------------------\n\nTITLE: Comparing Context-Sensitive vs True Literal Types in Python\nDESCRIPTION: Illustrates the difference between context-sensitive Final variables and explicit Literal type annotations when used in more complex contexts like list appending. Shows how type inference differs between the two approaches.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/literal_types.rst#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Final, Literal\n\na: Final = 19\nb: Literal[19] = 19\n\n# Mypy will choose to infer list[int] here.\nlist_of_ints = []\nlist_of_ints.append(a)\nreveal_type(list_of_ints)  # Revealed type is \"list[int]\"\n\n# But if the variable you're appending is an explicit Literal, mypy\n# will infer list[Literal[19]].\nlist_of_lits = []\nlist_of_lits.append(b)\nreveal_type(list_of_lits)  # Revealed type is \"list[Literal[19]]\"\n```\n\n----------------------------------------\n\nTITLE: Mypy checks for non-empty function bodies\nDESCRIPTION: Mypy identifies functions with non-empty bodies if they declare non-trivial return types but avoid checks for abstract or protocol methods. This ensures that functions adhere to expected behaviour requirements.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/error_code_list.rst#2025-04-22_snippet_11\n\nLANGUAGE: Python\nCODE:\n```\n   from abc import abstractmethod\n   from typing import Protocol\n\n   class RegularABC:\n```\n\n----------------------------------------\n\nTITLE: List Operators in Python\nDESCRIPTION: Defines a set of operators for handling lists in Python, such as indexing, slicing, concatenation, and checking membership. These operations facilitate efficient list manipulation.\nSOURCE: https://github.com/python/mypy/blob/master/mypyc/doc/list_operations.rst#2025-04-22_snippet_2\n\nLANGUAGE: Python\nCODE:\n```\nlst[n]\n```\n\nLANGUAGE: Python\nCODE:\n```\nlst[n:m], lst[n:], lst[:m], lst[:]\n```\n\nLANGUAGE: Python\nCODE:\n```\nlst1 + lst2, lst += iter\n```\n\nLANGUAGE: Python\nCODE:\n```\nlst * n, n * lst, lst *= n\n```\n\nLANGUAGE: Python\nCODE:\n```\nobj in lst\n```\n\n----------------------------------------\n\nTITLE: Unchecked Function Annotation Warning in Python\nDESCRIPTION: Shows how Mypy warns about type annotations in functions that are not being type checked due to missing return annotations.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/error_code_list.rst#2025-04-22_snippet_41\n\nLANGUAGE: python\nCODE:\n```\ndef test_assignment():  # \"-> None\" return annotation is missing\n    # Note: By default the bodies of untyped functions are not checked,\n    # consider using --check-untyped-defs [annotation-unchecked]\n    x: int = \"no way\"\n```\n\n----------------------------------------\n\nTITLE: Partial Type Annotations Leading to Any Type in Python\nDESCRIPTION: Example showing how partial type annotations can lead to 'Any' type inference, causing mypy to miss errors when concatenating a string with a list.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/common_issues.rst#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ndef foo(a) -> str:\n    return '(' + a.split() + ')'  # No error!\n```\n\n----------------------------------------\n\nTITLE: Using Type Variable Inference with Callable Types in Python\nDESCRIPTION: This code demonstrates improved type inference for type variables inside arguments of callable types. The example shows how mypy now correctly infers the return type of a higher-order function that takes a callable with type variables.\nSOURCE: https://github.com/python/mypy/blob/master/CHANGELOG.md#2025-04-22_snippet_31\n\nLANGUAGE: python\nCODE:\n```\ndef f(c: Callable[[T, S], None]) -> Callable[[str, T, S], None]: ...\ndef g(*x: int) -> None: ...\n\nreveal_type(f(g))  # Callable[[str, int, int], None]\n```\n\n----------------------------------------\n\nTITLE: Conditionally Importing Typing Features Based on Python Version\nDESCRIPTION: Illustrates a method to conditionally import a typing feature (`TypeIs`) either from the standard `typing` module (if the Python version is new enough, e.g., 3.13+) or from `typing_extensions` (for older versions). This avoids an unnecessary dependency on `typing_extensions` in environments with newer Python versions and aligns with PEP 508 conditional dependencies.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/runtime_troubles.rst#2025-04-22_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nimport sys\nif sys.version_info >= (3, 13):\n    from typing import TypeIs\nelse:\n    from typing_extensions import TypeIs\n```\n\n----------------------------------------\n\nTITLE: Ignoring Import Errors with Inline Type Ignore - Python\nDESCRIPTION: This Python code snippet shows how to suppress mypy errors for imports lacking type stubs using an inline comment '# type: ignore'. The first line imports a third-party module, 'frobnicate', which doesn't provide type information, and the second line calls its 'initialize()' function, which will not be type checked but is accepted by mypy due to the previous ignore directive. No extra dependencies beyond the imported module and mypy itself. The code expects that 'frobnicate' is installed in the environment (though type checking is bypassed). Limitation: this only suppresses type errors at the specific import location.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/existing_code.rst#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nimport frobnicate  # type: ignore\n...\nfrobnicate.initialize()  # OK (but not checked)\n```\n\n----------------------------------------\n\nTITLE: Operations Permitted on Objects Annotated as 'object' - Python\nDESCRIPTION: Shows valid operations allowed on values of type 'object' in mypy, specifically those universal to all Python objects, such as checking truthiness, printing, or type checking with isinstance. Illustrates the contrast with 'Any', which allows arbitrary actions. No dependencies beyond standard Python and mypy; users should understand that 'object' restricts operations to those always safe regardless of runtime type.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/dynamic_typing.rst#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\ndef f(o: object) -> None:\n    if o:\n        print(o)\n    print(isinstance(o, int))\n    o = 2\n    o = 'foo'\n```\n\n----------------------------------------\n\nTITLE: Directory Structure for Package with Mixed Stub and Runtime Files\nDESCRIPTION: Example directory structure for a package that has a mix of stub files and runtime files, including the py.typed file.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/installed_packages.rst#2025-04-22_snippet_2\n\nLANGUAGE: text\nCODE:\n```\nsetup.py\npackage_b/\n    __init__.py\n    lib.py\n    lib.pyi\n    py.typed\n```\n\n----------------------------------------\n\nTITLE: Type Annotation Triggers Assignment Error in Python with Mypy\nDESCRIPTION: Demonstrates that mypy will report an error if a value is assigned to a variable when the type of the value is incompatible with the annotated type. In this case, assigning a float to a variable annotated as 'int | str' triggers an error. This enforces stricter type safety during assignment.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/type_inference_and_annotations.rst#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nx: int | str = 1.1  # error: Incompatible types in assignment\\n                   # (expression has type \\\"float\\\", variable has type \\\"int | str\\\")\n```\n\n----------------------------------------\n\nTITLE: Configuring Local Partial Types in Mypy Configuration File\nDESCRIPTION: Sets the local_partial_types option to True in the mypy configuration file, which makes daemon and non-daemon mypy runs have the same behavior.\nSOURCE: https://github.com/python/mypy/blob/master/CHANGELOG.md#2025-04-22_snippet_23\n\nLANGUAGE: ini\nCODE:\n```\nlocal_partial_types = True\n```\n\n----------------------------------------\n\nTITLE: Generic Self Types in Python\nDESCRIPTION: This snippet illustrates the use of a generic self type in method signatures, which can be unsafe but supports common idioms. Here, the method 'compare' demonstrates using a comparison function that maintains the self-reference type within class hierarchies.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/generics.rst#2025-04-22_snippet_19\n\nLANGUAGE: python\nCODE:\n```\nclass Base:\n    def compare[T: Base](self: T, other: T) -> bool:\n        return False\n\nclass Sub(Base):\n    def __init__(self, x: int) -> None:\n        self.x = x\n\n    # This is unsafe (see below) but allowed because it's\n    # a common pattern and rarely causes issues in practice.\n    def compare(self, other: 'Sub') -> bool:\n        return self.x > other.x\n\nb: Base = Sub(42)\nb.compare(Base())  # Runtime error here: 'Base' object has no attribute 'x'\n```\n\n----------------------------------------\n\nTITLE: Using __getattr__ with Any Return Type in Python\nDESCRIPTION: Example showing how to use the Any type annotation for __getattr__ method returns when using dynamic Python features that cannot be precisely typed.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/common_issues.rst#2025-04-22_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nclass Wrapper:\n    ...\n    def __getattr__(self, a: str) -> Any:\n        return getattr(self._wrapped, a)\n```\n\n----------------------------------------\n\nTITLE: Creating a Dual-Mode Decorator with Overloads (Python 3.12)\nDESCRIPTION: Shows how to implement a decorator that can be used both with and without arguments by combining with @overload. Uses Python 3.12's native type parameter syntax.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/generics.rst#2025-04-22_snippet_45\n\nLANGUAGE: python\nCODE:\n```\nfrom collections.abc import Callable\nfrom typing import Any, overload\n\n# Bare decorator usage\n@overload\ndef atomic[F: Callable[..., Any]](func: F, /) -> F: ...\n# Decorator with arguments\n@overload\ndef atomic[F: Callable[..., Any]](*, savepoint: bool = True) -> Callable[[F], F]: ...\n\n# Implementation\ndef atomic(func: Callable[..., Any] | None = None, /, *, savepoint: bool = True):\n    def decorator(func: Callable[..., Any]):\n        ...  # Code goes here\n    if __func is not None:\n        return decorator(__func)\n    else:\n        return decorator\n\n# Usage\n@atomic\ndef func1() -> None: ...\n\n@atomic(savepoint=False)\ndef func2() -> None: ...\n```\n\n----------------------------------------\n\nTITLE: Detecting Redundant Casts in Python with Mypy\nDESCRIPTION: This code snippet uses the --warn-redundant-casts option in mypy to identify and warn about unnecessary type casts where the source and target types are identical, helping to clean up redundant code.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/error_code_list2.rst#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n# mypy: warn-redundant-casts\n\nfrom typing import cast\n\nCount = int\n\ndef example(x: Count) -> int:\n    # Error: Redundant cast to \"int\"  [redundant-cast]\n    return cast(int, x)\n```\n\n----------------------------------------\n\nTITLE: Runtime Type Checking Example in Mypyc\nDESCRIPTION: Demonstrates how Mypyc enforces runtime type checking for annotated functions. The function expects an integer argument and returns an integer.\nSOURCE: https://github.com/python/mypy/blob/master/mypyc/doc/differences_from_python.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ndef twice(x: int) -> int:\n    return x * 2\n```\n\n----------------------------------------\n\nTITLE: List Comprehensions in Python\nDESCRIPTION: Illustrates the use of list comprehensions in Python to create lists efficiently. These provide a concise way of including conditional statements and iteration.\nSOURCE: https://github.com/python/mypy/blob/master/mypyc/doc/list_operations.rst#2025-04-22_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\n[... for ... in ...]\n```\n\nLANGUAGE: Python\nCODE:\n```\n[... for ... in ... if ...]\n```\n\n----------------------------------------\n\nTITLE: Generic Types without Type Parameters are Treated as 'Any' in Mypy - Python\nDESCRIPTION: Demonstrates that missing type arguments in generic types (such as 'list') default their contained types to 'Any' in mypy. Uses 'reveal_type' to show the resulting generic type and illustrates that operations on items of type 'Any' are permitted without complaint. Inputs are generic collections without specific type annotations, outputs are inferred types and permissible operations; users may wish to enable '--disallow-any-generics' to enforce stricter typing.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/dynamic_typing.rst#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\ndef f(x: list) -> None:\n    reveal_type(x)        # Revealed type is \"builtins.list[Any]\"\n    reveal_type(x[0])     # Revealed type is \"Any\"\n    x[0].anything_goes()  # OK\n```\n\n----------------------------------------\n\nTITLE: TypedDict Constructor Usage - Python\nDESCRIPTION: Demonstrates how the TypedDict type object can be used as a constructor function to create a dictionary with the correct schema. No explicit annotation is required; at runtime this returns a regular dict but static checkers interpret it as the specified TypedDict. Requires prior TypedDict definition.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/typed_dict.rst#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\ntoy_story = Movie(name='Toy Story', year=1995)\n```\n\n----------------------------------------\n\nTITLE: Importing Future Typing Features with typing_extensions in Python\nDESCRIPTION: Shows how to import type hinting features (like `TypeIs`) that were added in newer Python versions into older Python versions using the `typing_extensions` package. This is the recommended approach for accessing newer typing constructs before they are available in the standard library.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/runtime_troubles.rst#2025-04-22_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nfrom typing_extensions import TypeIs\n```\n\n----------------------------------------\n\nTITLE: Demonstrating how to silence unused-awaitable error in Python with mypy\nDESCRIPTION: Shows how to assign the awaitable value to an unused variable to silence the unused-awaitable error when the return value is intentionally not used.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/error_code_list2.rst#2025-04-22_snippet_16\n\nLANGUAGE: python\nCODE:\n```\nasync def g() -> None:\n    _ = asyncio.create_task(f())  # No error\n```\n\n----------------------------------------\n\nTITLE: Adding Type Comments and String Literal Types for Legacy Python - Python\nDESCRIPTION: Demonstrates using # type: comments and string literal annotations to specify types in codebases supporting Python versions older than 3.6. Type comments can be applied both to variables and functions, helping preserve type information for Mypy and related tools. No external dependencies are needed; inputs are arbitrary code statements, and outputs are unmodified Python values and runtime behavior. Limitation: Type comments are deprecated in newer Python versions.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/runtime_troubles.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\na = 1  # type: int\n\ndef f(x):  # type: (int) -> int\n    return x + 1\n\n# Alternative type comment syntax for functions with many arguments\ndef send_email(\n     address,     # type: Union[str, List[str]]\n     sender,      # type: str\n     cc,          # type: Optional[List[str]]\n     subject='',\n     body=None    # type: List[str]\n ):\n     # type: (...) -> bool\n```\n\n----------------------------------------\n\nTITLE: Demonstrating truthy-iterable error code in Python with mypy\nDESCRIPTION: Shows how mypy flags Iterable types used in boolean contexts, since Iterable does not implement __len__ or __bool__, making the condition potentially misleading.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/error_code_list2.rst#2025-04-22_snippet_13\n\nLANGUAGE: python\nCODE:\n```\nfrom collections.abc import Iterable\n\ndef transform(items: Iterable[int]) -> list[int]:\n    # Error: \"items\" has type \"Iterable[int]\" which can always be true in boolean context. Consider using \"Collection[int]\" instead.  [truthy-iterable]\n    if not items:\n        return [42]\n    return [x + 1 for x in items]\n```\n\n----------------------------------------\n\nTITLE: Configuring Mypy Local Partial Types in Configuration File - Plain Text\nDESCRIPTION: This snippet shows how to configure mypy in a configuration file to enable local partial types by default, which affects how partially-inferred variable types are handled. It involves a config directive that must be placed in 'mypy.ini' or a similar config file. No code execution is involved. Required: A mypy configuration file ('mypy.ini'). Key parameter: 'local_partial_types', which must be set to 'True' or 'False'. Input: static config file, output: mypy's internal behavior is affected during analysis. Limitation: Does not affect Python runtime.\nSOURCE: https://github.com/python/mypy/blob/master/CHANGELOG.md#2025-04-22_snippet_11\n\nLANGUAGE: ini\nCODE:\n```\nlocal_partial_types = True\n```\n\n----------------------------------------\n\nTITLE: Demonstrating correct usage of reveal_type in Python with mypy\nDESCRIPTION: Shows the proper way to import reveal_type from typing or typing_extensions to avoid runtime errors when using this mypy feature.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/error_code_list2.rst#2025-04-22_snippet_22\n\nLANGUAGE: python\nCODE:\n```\n# mypy: enable-error-code=\"unimported-reveal\"\nfrom typing import reveal_type   # or `typing_extensions`\n\nx = 1\n# This won't raise an error:\nreveal_type(x)  # Note: Revealed type is \"builtins.int\"\n```\n\n----------------------------------------\n\nTITLE: Top Level Await Usage Warning in Python\nDESCRIPTION: Describes Mypy's handling of top-level await expressions and the provided errors for general environments. IPC-specific environments may allow such usage without raising an error.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/error_code_list.rst#2025-04-22_snippet_33\n\nLANGUAGE: python\nCODE:\n```\nasync def f() -> None:\n    ...\n\ntop = await f()  # Error: \"await\" outside function  [top-level-await]\n```\n\n----------------------------------------\n\nTITLE: Dynamic Class Definition via Plugin Hook - Python\nDESCRIPTION: Shows assigning a dynamic class with a custom factory function, as a use case for mypy's get_dynamic_class_hook. Such assignments enable runtime-determined class creation; a plugin hook is required to correctly inform mypy's type analysis. Used for frameworks or libraries with dynamic class patterns. mypy plugin must implement symbol table updates.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/extending_mypy.rst#2025-04-22_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nfrom lib import dynamic_class\n\nX = dynamic_class('X', [])\n\n```\n\n----------------------------------------\n\nTITLE: Ensuring defined name usage with Mypy\nDESCRIPTION: Illustrates Mypy's verification that all names have associated definitions in the active scope, preventing undefined name errors. It inherently requires structured Python code with correctly scoped definitions. Sorting illustration with an undefined function triggers an error.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/error_code_list.rst#2025-04-22_snippet_2\n\nLANGUAGE: Python\nCODE:\n```\n    x = sort([3, 2, 4])  # Error: Name \"sort\" is not defined  [name-defined]\n```\n\n----------------------------------------\n\nTITLE: Implicit Covariant Generics with Box Class - Python 3.12+\nDESCRIPTION: Demonstrates how Python 3.12+ syntax allows implicit, flexible variance inference for type parameters in generics. Shows a covariant Box[T] type where T is generic, and underscores that private (single underscore-prefixed) attributes let mypy infer covariance. No external dependencies are required. The central input is the generic parameter T, and the resulting Box instance can accept covariant subtypes.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/generics.rst#2025-04-22_snippet_23\n\nLANGUAGE: python\nCODE:\n```\nclass Box[T]:  # this type is implicitly covariant\n    def __init__(self, content: T) -> None:\n        self._content = content\n\n    def get_content(self) -> T:\n        return self._content\n\ndef look_into(box: Box[Shape]): ...\n\nmy_box = Box(Square())\nlook_into(my_box)  # OK, but mypy would complain here for an invariant type\n```\n\n----------------------------------------\n\nTITLE: Workaround for Enum Equality False Positives in Python with Mypy\nDESCRIPTION: Example showing how to work around strict equality errors with enums by using temporary variables for assertions instead of directly comparing object attributes.\nSOURCE: https://github.com/python/mypy/blob/master/CHANGELOG.md#2025-04-22_snippet_41\n\nLANGUAGE: python\nCODE:\n```\ndef test_something() -> None:\n    ...\n    x = c.x\n    assert x == MyEnum.A  # Does not narrow c.x\n    c.do_something_that_changes_x()\n    x = c.x\n    assert x == MyEnum.B  # OK\n```\n\n----------------------------------------\n\nTITLE: Literal Requirement for Static Type Checking in Python\nDESCRIPTION: Illustrates situations where Mypy expects a string literal for type checks, particularly with TypedDict keys, and provides alternatives using Final or Literal.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/error_code_list.rst#2025-04-22_snippet_30\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Final, Literal, TypedDict\n\nclass Point(TypedDict):\n    x: int\n    y: int\n\ndef test(p: Point) -> None:\n    X: Final = \"x\"\n    p[X]  # OK\n\n    Y: Literal[\"y\"] = \"y\"\n    p[Y]  # OK\n\n    key = \"x\"  # Inferred type of key is `str`\n    # Error: TypedDict key must be a string literal;\n    #   expected one of (\"x\", \"y\")  [literal-required]\n    p[key]\n```\n\n----------------------------------------\n\nTITLE: Constructing a Python Set with Specific Items\nDESCRIPTION: Demonstrates the literal syntax for creating a Python set with predefined items using curly braces. This is an optimized native operation.\nSOURCE: https://github.com/python/mypy/blob/master/mypyc/doc/set_operations.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n{item0, ..., itemN}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Incompatible Assignment between List Types in Python (Mypy Error)\nDESCRIPTION: Exemplifies how mypy enforces type invariance for container types such as lists. Assigning a 'list[int]' to a 'list[object]' parameter produces an error, because such assignments can lead to logical API violations by allowing insertion of incompatible types at runtime.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/type_inference_and_annotations.rst#2025-04-22_snippet_8\n\nLANGUAGE: python\nCODE:\n```\ndef f(l: list[object], k: list[int]) -> None:\\n    l = k  # error: Incompatible types in assignment\n```\n\n----------------------------------------\n\nTITLE: Type Inference Issue and Import Resolution in Mypy\nDESCRIPTION: Covers Mypy's type inference limitations for target variables. Illustrates how to resolve import issues by ensuring modules are correctly located and contain necessary type information.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/error_code_list.rst#2025-04-22_snippet_21\n\nLANGUAGE: python\nCODE:\n```\nclass Problem:\n    def set_x(self) -> None:\n        # Error: Cannot determine type of \"y\"  [has-type]\n        self.x = self.y\n\n    def set_y(self) -> None:\n        self.y: int = self.x  # Added annotation here\n```\n\nLANGUAGE: python\nCODE:\n```\n# Error: Cannot find implementation or library stub for module named \"m0dule_with_typo\"  [import-not-found]\nimport m0dule_with_typo\n```\n\nLANGUAGE: python\nCODE:\n```\n# Error: Library stubs not installed for \"bs4\"  [import-untyped]\nimport bs4\n# Error: Skipping analyzing \"no_py_typed\": module is installed, but missing library stubs or py.typed marker  [import-untyped]\nimport no_py_typed\n```\n\n----------------------------------------\n\nTITLE: Stricter Checks for Untyped Method Overrides in Python\nDESCRIPTION: Example of Mypy's improved checks for untyped method overrides when using --check-untyped-defs, detecting incompatible signatures.\nSOURCE: https://github.com/python/mypy/blob/master/CHANGELOG.md#2025-04-22_snippet_16\n\nLANGUAGE: Python\nCODE:\n```\nclass Base:\n    def f(self, x: int = 0) -> None: ...\n\nclass Derived(Base):\n    # Signature incompatible with \"Base\"\n    def f(self): ...\n```\n\n----------------------------------------\n\nTITLE: Using Generic Dataclasses with Python 3.12 Syntax\nDESCRIPTION: Demonstrates how to define and use generic dataclasses with Python 3.12 syntax, showing how type parameters can be properly inferred by mypy.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/additional_features.rst#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom dataclasses import dataclass\n\n@dataclass\nclass BoxedData[T]:\n    data: T\n    label: str\n\ndef unbox[T](bd: BoxedData[T]) -> T:\n    ...\n\nval = unbox(BoxedData(42, \"<important>\"))  # OK, inferred type is int\n```\n\n----------------------------------------\n\nTITLE: Narrowing Types with isinstance in Mypy\nDESCRIPTION: Demonstrates how to use the isinstance function to narrow types within conditional branches in Mypy.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/type_narrowing.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ndef function(arg: object):\n    if isinstance(arg, int):\n        # Type is narrowed within the ``if`` branch only\n        reveal_type(arg)  # Revealed type: \"builtins.int\"\n    elif isinstance(arg, str) or isinstance(arg, bool):\n        # Type is narrowed differently within this ``elif`` branch:\n        reveal_type(arg)  # Revealed type: \"builtins.str | builtins.bool\"\n\n        # Subsequent narrowing operations will narrow the type further\n        if isinstance(arg, bool):\n            reveal_type(arg)  # Revealed type: \"builtins.bool\"\n\n    # Back outside of the ``if`` statement, the type isn't narrowed:\n    reveal_type(arg)  # Revealed type: \"builtins.object\"\n```\n\n----------------------------------------\n\nTITLE: Mypy Error on Duplicate Enum Member Name in Python\nDESCRIPTION: This snippet shows Mypy detecting and reporting an error when an Enum definition attempts to reuse a member name (`x`).\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/literal_types.rst#2025-04-22_snippet_22\n\nLANGUAGE: python\nCODE:\n```\n class Some(Enum):\n    x = 1\n    x = 2  # E: Attempted to reuse member name \"x\" in Enum definition \"Some\"\n```\n\n----------------------------------------\n\nTITLE: Performance Impact of Erased Callable Types (Python)\nDESCRIPTION: This Python example demonstrates the performance implications of using erased types like `Callable` with mypyc. The function `call_and_inc` accepts a `Callable[[], int]`. While calling the function `f` itself might be slower due to type erasure, mypyc can infer the return type as `int` (a primitive type). This allows subsequent operations on the return value (`n += 1`) to be optimized and executed efficiently.\nSOURCE: https://github.com/python/mypy/blob/master/mypyc/doc/using_type_annotations.rst#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Callable\n\ndef call_and_inc(f: Callable[[], int]) -> int:\n    # Slow call, since f has an erased type\n    n = f()\n    # Fast increment; inferred type of n is int (primitive type)\n    n += 1\n    return n\n```\n\n----------------------------------------\n\nTITLE: Legacy Generic Types (Python 3.8 and earlier)\nDESCRIPTION: Collection types with type hints using typing module syntax for Python 3.8 and earlier versions. These types provide backward compatibility.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/builtin_types.rst#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nList[str]           # list of str objects\nTuple[int, int]      # tuple of two int objects\nTuple[int, ...]      # tuple of arbitrary number of int objects\nDict[str, int]       # dictionary from str keys to int values\nIterable[int]        # iterable object containing ints\nSequence[bool]       # sequence of booleans (read-only)\nMapping[str, int]    # mapping from str keys to int values (read-only)\nType[C]              # type object of C\n```\n\n----------------------------------------\n\nTITLE: Installing Mypy with Mypyc Extras using pip (Shell)\nDESCRIPTION: Standard command to install or update the mypy package, including the optional mypyc components, using pip for Python 3. This installation requires Python 3.9 or later.\nSOURCE: https://github.com/python/mypy/blob/master/mypyc/doc/getting_started.rst#2025-04-22_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n$ python3 -m pip install -U 'mypy[mypyc]'\n```\n\n----------------------------------------\n\nTITLE: Disabling Missing Import Errors Globally with Mypy Config - Text\nDESCRIPTION: This configuration snippet disables missing import errors for all references to 'frobnicate' and 'acme' modules throughout the codebase by matching them using '[mypy-module.*]' sections in the config file. Setting 'ignore_missing_imports = True' in these sections tells mypy not to report missing types for those modules. It's recommended for codebases where type stubs are unavailable or incomplete. Place this in the project's mypy config file. Limitation: suppresses all type errors for the matched modules.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/existing_code.rst#2025-04-22_snippet_4\n\nLANGUAGE: text\nCODE:\n```\n[mypy-frobnicate.*]\nignore_missing_imports = True\n\n[mypy-acme.*]\nignore_missing_imports = True\n```\n\n----------------------------------------\n\nTITLE: Exhaustiveness Checking for Literals with Match Statements in Python\nDESCRIPTION: Demonstrates using a `match` statement (Python 3.10+) for handling `Literal` types. The `assert_never(x)` call ensures that Mypy checks if all cases ('one', 'two') defined in `PossibleValues` are covered by the `case` statements.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/literal_types.rst#2025-04-22_snippet_13\n\nLANGUAGE: python\nCODE:\n```\ndef validate(x: PossibleValues) -> bool:\n    match x:\n        case 'one':\n            return True\n        case 'two':\n            return False\n    assert_never(x)\n```\n\n----------------------------------------\n\nTITLE: Defining Abstract Context Manager Protocol (__enter__ and __exit__) (Python)\nDESCRIPTION: Lists the methods required by contextlib.AbstractContextManager for regular context managers. __enter__ returns managed resource of type T; __exit__ handles exceptions and resource cleanup. Requires knowledge of exception types and tracebacks.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/protocols.rst#2025-04-22_snippet_28\n\nLANGUAGE: python\nCODE:\n```\ndef __enter__(self) -> T\ndef __exit__(self,\n             exc_type: type[BaseException] | None,\n             exc_value: BaseException | None,\n             traceback: TracebackType | None) -> bool | None\n\n```\n\n----------------------------------------\n\nTITLE: Using Value and Heap-Based Representations in mypyc - Python\nDESCRIPTION: This snippet demonstrates mypyc's ability to transparently switch between unboxed and boxed representations of values based on their size and context of use. It explicitly shows how integer and boolean values convert in different list and variable assignments. The implicit conversion of a boolean to an integer and the automatic boxing/unboxing in lists exemplified highlight these mechanisms.\nSOURCE: https://github.com/python/mypy/blob/master/mypyc/doc/using_type_annotations.rst#2025-04-22_snippet_6\n\nLANGUAGE: python\nCODE:\n```\ndef example() -> None:\n    # A small integer uses the value (unboxed) representation\n    x = 5\n    # A large integer uses the heap (boxed) representation\n    x = 2**500\n    # Lists always contain boxed integers\n    a = [55]\n    # When reading from a list, the object is automatically unboxed\n    x = a[0]\n    # True is converted to 1 on assignment\n    x = True\n```\n\n----------------------------------------\n\nTITLE: Overriding and Subtracting Strictness Options - Mypy Config - Text\nDESCRIPTION: This snippet shows how to enable all strict mypy settings globally with 'strict = True' and then selectively disable specific options, such as 'warn_return_any = False'. This lets you start from the strictest baseline and customize strictness for your project's needs. To use, insert in the relevant section of your mypy config file. Changes apply globally unless overridden by more specific module sections.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/existing_code.rst#2025-04-22_snippet_6\n\nLANGUAGE: text\nCODE:\n```\nstrict = True\nwarn_return_any = False\n```\n\n----------------------------------------\n\nTITLE: Adding an Item to a Python Set\nDESCRIPTION: Demonstrates using the `add()` method to insert a single `item` into a Python set `s`. If the item already exists in the set, the set remains unchanged.\nSOURCE: https://github.com/python/mypy/blob/master/mypyc/doc/set_operations.rst#2025-04-22_snippet_6\n\nLANGUAGE: python\nCODE:\n```\ns.add(item)\n```\n\n----------------------------------------\n\nTITLE: Property Decorator Order Check in Python\nDESCRIPTION: Demonstrates Mypy's limitation with decorators preceding the property decorator and how to handle it with type ignore comments.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/error_code_list.rst#2025-04-22_snippet_42\n\nLANGUAGE: python\nCODE:\n```\nclass MyClass:\n    @special  # type: ignore[prop-decorator]\n    @property\n    def magic(self) -> str:\n        return \"xyzzy\"\n```\n\n----------------------------------------\n\nTITLE: Setting Mypy Inline Configuration Flags with Values in Python\nDESCRIPTION: This snippet illustrates setting Mypy flags that require values using the '=' syntax. It also shows that for boolean flags set to true, '= True' can be omitted. The first line is equivalent to `# mypy: disallow-any-generics = True`, while the second line sets the `always-true` flag to the value 'FOO'.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/inline_config.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n# mypy: disallow-any-generics\n# mypy: always-true=FOO\n```\n\n----------------------------------------\n\nTITLE: Demonstrating unused-ignore error code in Python with mypy\nDESCRIPTION: Shows how mypy warns when a '# type: ignore' comment is unnecessary because there would be no error on that line anyway.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/error_code_list2.rst#2025-04-22_snippet_17\n\nLANGUAGE: python\nCODE:\n```\n# Use \"mypy --warn-unused-ignores ...\"\n\ndef add(a: int, b: int) -> int:\n    # Error: unused \"type: ignore\" comment\n    return a + b  # type: ignore\n```\n\n----------------------------------------\n\nTITLE: Using attrs Package with Type Annotations\nDESCRIPTION: Demonstrates how to use the attrs package with type annotations in a way that mypy can understand and validate, showing the standard usage pattern.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/additional_features.rst#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nimport attr\n\n@attrs.define\nclass A:\n    one: int\n    two: int = 7\n    three: int = attrs.field(8)\n```\n\n----------------------------------------\n\nTITLE: Detecting Unsafe Uses of super() in Python\nDESCRIPTION: This snippet indicates how Mypy improves the detection of unsafe uses of super(), particularly for targets with trivial bodies. It ensures that methods in subclasses correctly and safely override those in their parent classes.\nSOURCE: https://github.com/python/mypy/blob/master/CHANGELOG.md#2025-04-22_snippet_22\n\nLANGUAGE: python\nCODE:\n```\nclass Proto(Protocol):\\n    def method(self) -> int: ...\\n\\nclass Sub(Proto):\\n    def method(self) -> int:\\n        return super().meth()  # Error (unsafe)\n```\n\n----------------------------------------\n\nTITLE: Implementing Extra Checks in Mypy\nDESCRIPTION: This code demonstrates enabling additional checks using the \"--extra-checks\" flag which enforces stricter TypedDict updates and positional-only parameters with \"Concatenate\". It provides an example of unsafe TypedDict updates due to potential partial overlaps, highlighting the limitations inherent in structural subtyping.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/command_line.rst#2025-04-22_snippet_12\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import TypedDict\n\nclass Foo(TypedDict):\n    a: int\n\nclass Bar(TypedDict):\n    a: int\n    b: int\n\ndef test(foo: Foo, bar: Bar) -> None:\n    # This is technically unsafe since foo can have a subtype of Foo at\n    # runtime, where type of key \"b\" is incompatible with int, see below\n    bar.update(foo)\n\nclass Bad(Foo):\n    b: str\nbad: Bad = {\"a\": 0, \"b\": \"no\"}\ntest(bad, bar)\n```\n\n----------------------------------------\n\nTITLE: Defining SupportsFloat Protocol with __float__ (Python)\nDESCRIPTION: Exemplifies the __float__ method for typing.SupportsFloat, enabling float(x) conversion. No math operations required. Must return a float.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/protocols.rst#2025-04-22_snippet_22\n\nLANGUAGE: python\nCODE:\n```\ndef __float__(self) -> float\n\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Implicit Generic Base Class in Python 3.12\nDESCRIPTION: Shows that typing.Generic is included as an implicit base class even when using the new syntax for generic classes.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/generics.rst#2025-04-22_snippet_58\n\nLANGUAGE: python\nCODE:\n```\n>>> class Stack[T]: ...\n>>> Stack.mro()\n[<class '__main__.Stack'>, <class 'typing.Generic'>, <class 'object'>]\n```\n\n----------------------------------------\n\nTITLE: Installing Mypy via pip in Python\nDESCRIPTION: Command to install or upgrade Mypy using pip package manager.\nSOURCE: https://github.com/python/mypy/blob/master/CHANGELOG.md#2025-04-22_snippet_43\n\nLANGUAGE: bash\nCODE:\n```\npython3 -m pip install -U mypy\n```\n\n----------------------------------------\n\nTITLE: Configuring Exclude Patterns in pyproject.toml (Array of Strings) - TOML\nDESCRIPTION: Demonstrates how to specify a list of regex patterns for the 'exclude' configuration in a pyproject.toml file using an array of strings. This format requires escaping backslashes in double-quoted strings but not in single-quoted strings. Expected input is one or more regular expressions as strings. No external dependencies beyond mypy are required.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/config_file.rst#2025-04-22_snippet_2\n\nLANGUAGE: TOML\nCODE:\n```\n[tool.mypy]\nexclude = [\n    \"^one\\\\.py$\",  # TOML's double-quoted strings require escaping backslashes\n    'two\\.pyi$',  # but TOML's single-quoted strings do not\n    '^three\\.',\n]\n```\n\n----------------------------------------\n\nTITLE: Defining a Custom mypy Plugin - Python\nDESCRIPTION: Illustrates the minimal structure of a custom mypy plugin by subclassing mypy.plugin.Plugin and providing an entry point. The plugin function takes the mypy version string and returns a Plugin subclass. At least one method hook (like get_type_analyze_hook) can be implemented for custom behavior. The module must be importable and meet mypy plugin API interface requirements; additional hooks can be added as needed.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/extending_mypy.rst#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom mypy.plugin import Plugin\n\nclass CustomPlugin(Plugin):\n    def get_type_analyze_hook(self, fullname: str):\n        # see explanation below\n        ...\n\ndef plugin(version: str):\n    # ignore version argument if the plugin works with all mypy versions.\n    return CustomPlugin\n\n```\n\n----------------------------------------\n\nTITLE: Implementing Async Generator Function in Python\nDESCRIPTION: Shows how to create an async generator function using AsyncGenerator type hint from collections.abc. Demonstrates a more concise way to create async iterators.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/more_types.rst#2025-04-22_snippet_23\n\nLANGUAGE: python\nCODE:\n```\nfrom collections.abc import AsyncGenerator\nfrom typing import Optional\nimport asyncio\n\nasync def arange(start: int, stop: int, step: int) -> AsyncGenerator[int, None]:\n    current = start\n    while (step > 0 and current < stop) or (step < 0 and current > stop):\n        yield current\n        current += step\n\nasyncio.run(run_countdown(\"Battlestar Galactica\", arange(5, 0, -1)))\n```\n\n----------------------------------------\n\nTITLE: Runtime Error from Unsafe Overlap Despite Type Checking in Python\nDESCRIPTION: Demonstrates the runtime consequence of the previously defined unsafe overload (`unsafe_func`). An `int` (42) is assigned to a variable typed as `object`. When `unsafe_func` is called, Mypy infers the return type as `str` based on the `object` variant. However, the implementation returns an `int`, causing a `TypeError` at runtime when string concatenation is attempted.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/more_types.rst#2025-04-22_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nsome_obj: object = 42\nunsafe_func(some_obj) + \" danger danger\"  # Type checks, yet crashes at runtime!\n```\n\n----------------------------------------\n\nTITLE: Defining Abstract Async Context Manager Protocol (__aenter__ and __aexit__) (Python)\nDESCRIPTION: Specifies the methods for contextlib.AbstractAsyncContextManager: __aenter__ (async enter) and __aexit__ (async exit). Allows types to be managed in 'async with' blocks. Exception parameters and Awaitable return types required.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/protocols.rst#2025-04-22_snippet_29\n\nLANGUAGE: python\nCODE:\n```\ndef __aenter__(self) -> Awaitable[T]\ndef __aexit__(self,\n              exc_type: type[BaseException] | None,\n              exc_value: BaseException | None,\n              traceback: TracebackType | None) -> Awaitable[bool | None]\n\n```\n\n----------------------------------------\n\nTITLE: Removing an Item from a Python Set (No Error)\nDESCRIPTION: Demonstrates the `discard()` method, which removes a specified `item` from a Python set `s` if it exists. Unlike `remove()`, it does not raise an error if the `item` is not found.\nSOURCE: https://github.com/python/mypy/blob/master/mypyc/doc/set_operations.rst#2025-04-22_snippet_8\n\nLANGUAGE: python\nCODE:\n```\ns.discard(item)\n```\n\n----------------------------------------\n\nTITLE: Strict Bytes Handling in Mypy\nDESCRIPTION: This code shows how to enforce strict type handling between \"bytes\" and \"bytearray\"/\"memoryview\" using the \"--strict-bytes\" flag in mypy. It showcases function signatures that require bytes and illustrates compatible type errors with examples for different buffer protocol objects. It shows the different types of arguments `f` can take with varying success.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/command_line.rst#2025-04-22_snippet_11\n\nLANGUAGE: python\nCODE:\n```\ndef f(buf: bytes) -> None:\n    assert isinstance(buf, bytes)  # Raises runtime AssertionError with bytearray/memoryview\n    with open(\"binary_file\", \"wb\") as fp:\n        fp.write(buf)\n\nf(bytearray(b\"\"))  # error: Argument 1 to \"f\" has incompatible type \"bytearray\"; expected \"bytes\"\nf(memoryview(b\"\"))  # error: Argument 1 to \"f\" has incompatible type \"memoryview\"; expected \"bytes\"\n\nfrom collections.abc import Buffer  # \"from typing_extensions\" in Python 3.11 and earlier\ndef f(buf: Buffer) -> None:\n    with open(\"binary_file\", \"wb\") as fp:\n        fp.write(buf)\n\nf(b\"\")  # Ok\nf(bytearray(b\"\"))  # Ok\nf(memoryview(b\"\"))  # Ok\n```\n\n----------------------------------------\n\nTITLE: Mypy Import Resolution Example\nDESCRIPTION: Illustrates how mypy handles import resolution with the --ignore-missing-imports flag, showing which imports are ignored and which still produce errors.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/command_line.rst#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nimport package.unknown      # No error, ignored\nx = package.unknown.func()  # OK. 'func' is assumed to be of type 'Any'\n\nfrom package import unknown          # No error, ignored\nfrom package.mod import NonExisting  # Error: Module has no attribute 'NonExisting'\n```\n\n----------------------------------------\n\nTITLE: Experimental Inline TypedDict Syntax in Function Return Types - Python\nDESCRIPTION: This example introduces an experimental, non-standard inline syntax for defining anonymous TypedDict types directly in function return type annotations. Enabling this feature currently requires the '--enable-incomplete-feature=InlineTypedDict' mypy flag. Dependencies: mypy with the experimental feature flag enabled. Key parameters: function arguments, inline dict for the return type (e.g., '{\"name\": str, \"year\": int}'). Input: Arguments to the function; output: dictionary matching the annotated keys and types. Limitation: Not part of Python standard syntax and may be removed in future versions.\nSOURCE: https://github.com/python/mypy/blob/master/CHANGELOG.md#2025-04-22_snippet_13\n\nLANGUAGE: python\nCODE:\n```\ndef func(n: str, y: int) -> {\"name\": str, \"year\": int}:\n    return {\"name\": n, \"year\": y}\n```\n\n----------------------------------------\n\nTITLE: Working with Native Bytes in Python\nDESCRIPTION: This snippet provides an overview of native bytes operations in Python, which are specially optimized for performance. These include constructing bytes with literals or list conversion, and using operators for concatenation, indexing, and slicing. The code demonstrates decoding methods allowing specification of encoding and error handling, and shows joining bytes with iterable. Preserved formatting using the '%...' operator is also mentioned along with utility functions like len() and ord() that work with bytes.\nSOURCE: https://github.com/python/mypy/blob/master/mypyc/doc/bytes_operations.rst#2025-04-22_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\n\"\"bytes_literal = b'example'\\nlist_bytes = bytes([104, 101, 108, 108, 111])\\nconcatenated = b1 + b2\\nindexing = b[n]\\nslice = b[n:m]\\ncomparison = (b1 == b2)\\ndecoded1 = b.decode()\\ndecoded2 = b.decode('utf-8')\\ndecoded3 = b.decode('utf-8', 'strict')\\njoined = b' '.join([b'hello', b'world'])\\nformatted = b'Value: %d' % (42)\\nbyte_length = len(b)\\nord_value = ord(b'\\x41')\"\n```\n\n----------------------------------------\n\nTITLE: Migrating Enum Members in Type Stub Files Using Python Enum\nDESCRIPTION: This snippet shows how enum member annotation semantics have changed for type stub (.pyi) files in Python. Previously, attributes like 'CAT: int' were treated as members, but now must be assigned concrete or placeholder values to be considered enum members. It demonstrates both legacy and modern stub definitions, including the use of cast and ellipsis, and notes that failing to provide values now triggers mypy warnings. Intended for type stub authors, it uses constructs from the enum and typing modules.\nSOURCE: https://github.com/python/mypy/blob/master/CHANGELOG.md#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n# In a type stub (.pyi file)\n\nclass Pet(Enum):\n    # Change in semantics: previously considered members,\n    # now non-member attributes\n    CAT: int\n    DOG: int\n\n    # Mypy will now issue a warning if it detects this\n    # situation in type stubs:\n    # > Detected enum \"Pet\" in a type stub with zero\n    # > members. There is a chance this is due to a recent\n    # > change in the semantics of enum membership. If so,\n    # > use `member = value` to mark an enum member,\n    # > instead of `member: type`\n\nclass Pet(Enum):\n    # As per the specification, you should now do one of\n    # the following:\n    DOG = 1  # Member attribute with value 1 and known type\n    WOLF = cast(int, ...)  # Member attribute with unknown\n                           # value but known type\n    LION = ...  # Member attribute with unknown value and\n                # # unknown type\n```\n\n----------------------------------------\n\nTITLE: Defining Generic Protocols (Python 3.11)\nDESCRIPTION: Legacy syntax for defining generic protocols using TypeVar for Python 3.11 and earlier. The class declaration takes Protocol[T] as a shorthand for Protocol, Generic[T].\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/generics.rst#2025-04-22_snippet_48\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Protocol, TypeVar\n\nT = TypeVar('T')\n\nclass Box(Protocol[T]):\n    content: T\n```\n\n----------------------------------------\n\nTITLE: Using an Untyped Decorator on a Function - Python\nDESCRIPTION: Shows a decorated function using an untyped decorator and demonstrates the effects: the function becomes untyped, and improper argument types are not caught by the type checker, and runtime errors may occur. No dependencies beyond built-in Python.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/generics.rst#2025-04-22_snippet_33\n\nLANGUAGE: python\nCODE:\n```\n# A decorated function.\n@printing_decorator\ndef add_forty_two(value: int) -> int:\n    return value + 42\n\na = add_forty_two(3)\n```\n\n----------------------------------------\n\nTITLE: Creating Python Type Aliases with Inline TypedDicts\nDESCRIPTION: Demonstrates the use of inline TypedDict syntax to create type aliases. Requires explicit type declaration due to ambiguity. Illustrates creating both a variable and a type alias for a TypedDict with string keys 'a' and 'b' and integer values.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/typed_dict.rst#2025-04-22_snippet_16\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import TypeAlias\n\nX = {\"a\": int, \"b\": int}  # creates a variable with type dict[str, type[int]]\nY: TypeAlias = {\"a\": int, \"b\": int}  # creates a type alias\ntype Z = {\"a\": int, \"b\": int}  # same as above (Python 3.12+ only)\n```\n\n----------------------------------------\n\nTITLE: Installing Mypy via pip\nDESCRIPTION: Command to install or upgrade Mypy using pip. This will install the latest version of the Python static type checker.\nSOURCE: https://github.com/python/mypy/blob/master/CHANGELOG.md#2025-04-22_snippet_30\n\nLANGUAGE: bash\nCODE:\n```\npython3 -m pip install -U mypy\n```\n\n----------------------------------------\n\nTITLE: Configuring Exclude Patterns in pyproject.toml (Multi-line String) - TOML\nDESCRIPTION: Shows how to use a single, multi-line string (triple single quotes) in pyproject.toml to set 'exclude' as a regular expression supporting comments and multiline formatting. Single-quoted multi-line strings in TOML do not require escaping backslashes. The pattern matches files named 'one.py', files ending in 'two.pyi', or files starting with 'three.'.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/config_file.rst#2025-04-22_snippet_3\n\nLANGUAGE: TOML\nCODE:\n```\n[tool.mypy]\nexclude = '''(?x)(\n    ^one\\.py$    # files named \"one.py\"\n    | two\\.pyi$  # or files ending with \"two.pyi\"\n    | ^three\\.   # or files starting with \"three.\"\n)'''  # TOML's single-quoted strings do not require escaping backslashes\n```\n\n----------------------------------------\n\nTITLE: Handling Complex Type Annotations in Python\nDESCRIPTION: This snippet explains advanced type functionalities in Python, such as using reveal_type for debugging, handling variables initialized with dynamic types using Any, casting, and controlling mypy's type checking behavior with TYPE_CHECKING.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/cheat_sheet_py3.rst#2025-04-22_snippet_4\n\nLANGUAGE: Python\nCODE:\n```\nfrom typing import Union, Any, Optional, TYPE_CHECKING, cast\n\n# To find out what type mypy infers for an expression anywhere in\n# your program, wrap it in reveal_type().  Mypy will print an error\n# message with the type; remove it again before running the code.\nreveal_type(1)  # Revealed type is \"builtins.int\"\n\n# If you initialize a variable with an empty container or \"None\"\n# you may have to help mypy a bit by providing an explicit type annotation\nx: list[str] = []\nx: str | None = None\n\n# Use Any if you don\\'t know the type of something or it\\'s too\n# dynamic to write a type for\nx: Any = mystery_function()\n# Mypy will let you do anything with x!\nx.whatever() * x[\"you\"] + x(\"want\") - any(x) and all(x) is super  # no errors\n\n# Use a \"type: ignore\" comment to suppress errors on a given line,\n# when your code confuses mypy or runs into an outright bug in mypy.\n# Good practice is to add a comment explaining the issue.\nx = confusing_function()  # type: ignore  # confusing_function won\\'t return None here because ...\n\n# \"cast\" is a helper function that lets you override the inferred\n# type of an expression. It\\'s only for mypy -- there\\'s no runtime check.\na = [4]\nb = cast(list[int], a)  # Passes fine\nc = cast(list[str], a)  # Passes fine despite being a lie (no runtime check)\nreveal_type(c)  # Revealed type is \"builtins.list[builtins.str]\"\nprint(c)  # Still prints [4] ... the object is not changed or casted at runtime\n\n# Use \"TYPE_CHECKING\" if you want to have code that mypy can see but will not\n# be executed at runtime (or to have code that mypy can\\'t see)\nif TYPE_CHECKING:\n    import json\nelse:\n    import orjson as json  # mypy is unaware of this\n\n```\n\n----------------------------------------\n\nTITLE: Defining SupportsRound Protocol with __round__ (Python)\nDESCRIPTION: Documents the __round__ protocol for typing.SupportsRound. __round__ should return the rounded value as type 'T'. Necessary for round(x) compatibility in custom types.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/protocols.rst#2025-04-22_snippet_24\n\nLANGUAGE: python\nCODE:\n```\ndef __round__(self) -> T\n\n```\n\n----------------------------------------\n\nTITLE: List Methods in Python\nDESCRIPTION: Detailed list of native methods available for Python lists, covering adding, removing, searching, and sorting functionalities. These methods are essential for performing various list operations.\nSOURCE: https://github.com/python/mypy/blob/master/mypyc/doc/list_operations.rst#2025-04-22_snippet_4\n\nLANGUAGE: Python\nCODE:\n```\nlst.append(obj)\n```\n\nLANGUAGE: Python\nCODE:\n```\nlst.extend(x: Iterable)\n```\n\nLANGUAGE: Python\nCODE:\n```\nlst.insert(index, obj)\n```\n\nLANGUAGE: Python\nCODE:\n```\nlst.pop(index=-1)\n```\n\nLANGUAGE: Python\nCODE:\n```\nlst.remove(obj)\n```\n\nLANGUAGE: Python\nCODE:\n```\nlst.count(obj)\n```\n\nLANGUAGE: Python\nCODE:\n```\nlst.index(obj)\n```\n\nLANGUAGE: Python\nCODE:\n```\nlst.reverse()\n```\n\nLANGUAGE: Python\nCODE:\n```\nlst.sort()\n```\n\n----------------------------------------\n\nTITLE: Invoking Stubgen with Directory Path\nDESCRIPTION: Shows how to run `stubgen` targeting a directory. The tool will recursively search the specified directory (`my_pkg_dir`) for `.py` files and generate stubs for all discovered modules.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/stubgen.rst#2025-04-22_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n$ stubgen my_pkg_dir\n```\n\n----------------------------------------\n\nTITLE: Applying Native Boolean Operators with Fast Implementations - Python\nDESCRIPTION: Shows the use of fundamental boolean operators 'and', 'or', and 'not' for logical operations between boolean expressions in Python. These operators are natively supported and highly optimized. Inputs (b1, b2) should be boolean values or expressions; output is determined by the logical relationship.\nSOURCE: https://github.com/python/mypy/blob/master/mypyc/doc/bool_operations.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nb1 and b2\nb1 or b2\nnot b\n\n```\n\n----------------------------------------\n\nTITLE: Untyped Function Decorator Example - Python\nDESCRIPTION: Presents an untyped decorator example that wraps a function, prints when it is called, and returns the result. Used to illustrate pitfalls when type annotations are missing, affecting both type inference and type checking. No non-builtin dependencies are involved.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/generics.rst#2025-04-22_snippet_32\n\nLANGUAGE: python\nCODE:\n```\ndef printing_decorator(func):\n    def wrapper(*args, **kwds):\n        print(\"Calling\", func)\n        return func(*args, **kwds)\n    return wrapper\n```\n\n----------------------------------------\n\nTITLE: Running stubtest to Find Inconsistencies Between Implementation and Stubs\nDESCRIPTION: This shell example demonstrates how to use `stubtest`. It first installs `mypy`, then creates a simple Python module `library.py` and a corresponding stub file `library.pyi` with intentional inconsistencies (default argument value for `foo` and variable type for `x`). Finally, it runs `stubtest` on the `library` module, showing how `stubtest` identifies and reports these discrepancies between the runtime implementation and the stub definitions.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/stubtest.rst#2025-04-22_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n$ python3 -m pip install mypy\n\n$ cat library.py\nx = \"hello, stubtest\"\n\ndef foo(x=None):\n    print(x)\n\n$ cat library.pyi\nx: int\n\ndef foo(x: int) -> None: ...\n\n$ python3 -m mypy.stubtest library\nerror: library.foo is inconsistent, runtime argument \"x\" has a default value but stub argument does not\nStub: at line 3\ndef (x: builtins.int)\nRuntime: in file ~/library.py:3\ndef (x=None)\n\nerror: library.x variable differs from runtime type Literal['hello, stubtest']\nStub: at line 1\nbuiltins.int\nRuntime:\n'hello, stubtest'\n```\n\n----------------------------------------\n\nTITLE: Constructing Frozenset in Python\nDESCRIPTION: Demonstrates how to construct an empty frozenset and create a frozenset from an iterable in Python. No external dependencies are required. The constructor can take any iterable as an input, returning an immutable set-like object.\nSOURCE: https://github.com/python/mypy/blob/master/mypyc/doc/frozenset_operations.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrozenset()\n```\n\nLANGUAGE: python\nCODE:\n```\nfrozenset(x: Iterable)\n```\n\n----------------------------------------\n\nTITLE: TypedDict Inheritance for Extending Schemas - Python\nDESCRIPTION: Demonstrates inheritance of TypedDict to extend schemas; the subclass BookBasedMovie adds an additional field. This enables code reuse and mixing of fields. Dependencies: typing.TypedDict or typing_extensions.TypedDict.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/typed_dict.rst#2025-04-22_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nclass Movie(TypedDict):\n    name: str\n    year: int\n\nclass BookBasedMovie(Movie):\n    based_on: str\n```\n\n----------------------------------------\n\nTITLE: Implementing Recursive Generic Protocols (Python 3.11)\nDESCRIPTION: Legacy syntax for defining recursive generic protocols where a protocol refers to itself in its method signatures, using TypeVar for Python 3.11 and earlier.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/generics.rst#2025-04-22_snippet_51\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import TypeVar\n\nT = TypeVar('T')\n\nclass Linked(Protocol[T]):\n    val: T\n    def next(self) -> 'Linked[T]': ...\n```\n\n----------------------------------------\n\nTITLE: Checking Overlapping Comparisons in Python with Mypy\nDESCRIPTION: This snippet employs mypy's --strict-equality option to detect always-true or always-false comparison operations, ensuring that comparisons are valid and meaningful within the code context.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/error_code_list2.rst#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n# mypy: strict-equality\n\ndef is_magic(x: bytes) -> bool:\n    # Error: Non-overlapping equality check (left operand type: \"bytes\",\n    #        right operand type: \"str\")  [comparison-overlap]\n    return x == 'magic'\n```\n\nLANGUAGE: python\nCODE:\n```\n# mypy: strict-equality\n\ndef is_magic(x: bytes) -> bool:\n    return x == b'magic'  # OK\n```\n\n----------------------------------------\n\nTITLE: Defining Subclasses of Generic Classes (Legacy Syntax)\nDESCRIPTION: Shows the same subclassing examples as the previous snippet but using the legacy syntax (Python <= 3.11). This requires `TypeVar` definitions and appropriate inheritance, such as `MyMap(Mapping[KT, VT])`, `StrDict(dict[str, str])`, and `AdvancedReceiver(Receiver[T])`. Note that `Generic` is sometimes implicitly included via other generic base classes.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/generics.rst#2025-04-22_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Generic, TypeVar, Mapping, Iterator\n\nKT = TypeVar('KT')\nVT = TypeVar('VT')\n\n# This is a generic subclass of Mapping\nclass MyMap(Mapping[KT, VT]):\n    def __getitem__(self, k: KT) -> VT: ...\n    def __iter__(self) -> Iterator[KT]: ...\n    def __len__(self) -> int: ...\n\nitems: MyMap[str, int]  # OK\n\n# This is a non-generic subclass of dict\nclass StrDict(dict[str, str]):\n    def __str__(self) -> str:\n        return f'StrDict({super().__str__()})'\n\ndata: StrDict[int, int]  # Error! StrDict is not generic\ndata2: StrDict  # OK\n\n# This is a user-defined generic class\nclass Receiver(Generic[T]):\n    def accept(self, value: T) -> None: ...\n\n# This is a generic subclass of Receiver\nclass AdvancedReceiver(Receiver[T]): ...\n```\n\n----------------------------------------\n\nTITLE: Checking type validity in annotations with Mypy\nDESCRIPTION: Mypy checks the validity of type annotations, ensuring that they reference existing and valid types only. It prevents the use of invalid references as types, such as functions. Example shows improper function usage as a type.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/error_code_list.rst#2025-04-22_snippet_7\n\nLANGUAGE: Python\nCODE:\n```\n    def log(x: object) -> None:\n        print('log:', repr(x))\n\n    # Error: Function \"t.log\" is not valid as a type  [valid-type]\n    def log_all(objs: list[object], f: log) -> None:\n        for x in objs:\n            f(x)\n```\n\nLANGUAGE: Python\nCODE:\n```\n    from collections.abc import Callable\n\n    # OK\n    def log_all(objs: list[object], f: Callable[[object], None]) -> None:\n        for x in objs:\n            f(x)\n```\n\n----------------------------------------\n\nTITLE: Configure pre-commit for Automatic Linting - Shell\nDESCRIPTION: Sets up the pre-commit git hook so that linting checks are automatically run before every commit. This maintains code quality and ensures consistent linting standards across the project.\nSOURCE: https://github.com/python/mypy/blob/master/test-data/unit/README.md#2025-04-22_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\npre-commit install\n```\n\n----------------------------------------\n\nTITLE: Excluding Files Using Regular Expressions in mypy.ini\nDESCRIPTION: This INI snippet shows how to configure the `exclude` option within the `[mypy]` section of a configuration file. It uses a regular expression with the verbose flag (`(?x)`) to define patterns for files and directories that Mypy should ignore during its recursive discovery phase. The example demonstrates matching specific filenames (`one.py`), file extensions (`two.pyi`), and prefixes (`three.`) while using comments and whitespace within the regex for improved readability.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/config_file.rst#2025-04-22_snippet_1\n\nLANGUAGE: ini\nCODE:\n```\n[mypy]\nexclude = (?x)(\n    ^one\\.py$    # files named \"one.py\"\n    | two\\.pyi$  # or files ending with \"two.pyi\"\n    | ^three\\.   # or files starting with \"three.\"\n  )\n```\n\n----------------------------------------\n\nTITLE: Handling Deprecated Calls in Mypy Configuration\nDESCRIPTION: This snippet allows you to selectively ignore deprecated warnings for specific functions or classes in mypy. It defines a deprecated method using a decorator from \"typing_extensions\". This requires the \"typing_extensions\" library. You can exclude specific deprecated calls using the \"--deprecated-calls-exclude\" flag.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/command_line.rst#2025-04-22_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nimport foo\n\nfoo.A().func()  # OK, the deprecated warning is ignored\n\n# file foo.py\nfrom typing_extensions import deprecated\nclass A:\n    @deprecated(\"Use A.func2 instead\")\n    def func(self): pass\n```\n\n----------------------------------------\n\nTITLE: Example Python Module for Stub Generation\nDESCRIPTION: A sample Python module (e.g., `foo.py`) demonstrating various constructs like constants, classes with instance attributes, `__init__` methods, and functions. This code serves as input for the `stubgen` tool example, illustrating a typical module structure for which stubs might be generated.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/stubgen.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n   from other_module import dynamic\n\n   BORDER_WIDTH = 15\n\n   class Window:\n       parent = dynamic()\n       def __init__(self, width, height):\n           self.width = width\n           self.height = height\n\n   def create_empty() -> Window:\n       return Window(0, 0)\n```\n\n----------------------------------------\n\nTITLE: Dictionary Methods in Python\nDESCRIPTION: Built-in dictionary methods for accessing, modifying, and managing dictionary content.\nSOURCE: https://github.com/python/mypy/blob/master/mypyc/doc/dict_operations.rst#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nd.get(key)\nd.get(key, default)\nd.keys()\nd.values()\nd.items()\nd.copy()\nd.clear()\nd.setdefault(key)\nd.setdefault(key, value)\nd1.update(d2: dict)\nd.update(x: Iterable)\n```\n\n----------------------------------------\n\nTITLE: Demonstrating @override decorator usage in Python\nDESCRIPTION: Example showing how to use the @override decorator with the new explicit-override error code. It illustrates proper method overriding and the error generated when the decorator is missing.\nSOURCE: https://github.com/python/mypy/blob/master/CHANGELOG.md#2025-04-22_snippet_34\n\nLANGUAGE: python\nCODE:\n```\n# mypy: enable-error-code=\"explicit-override\"\n\nfrom typing_extensions import override\n\nclass C:\n    def foo(self) -> None: pass\n    def bar(self) -> None: pass\n\nclass D(C):\n    # Error: Method \"foo\" is not using @override but is\n    # overriding a method\n    def foo(self) -> None:\n        ...\n\n    @override\n    def bar(self) -> None:  # OK\n        ...\n```\n\n----------------------------------------\n\nTITLE: Optimized String Construction in Python\nDESCRIPTION: Lists optimized methods for creating string objects in Python. This includes using string literals directly and converting integers or other objects using `str()` or `repr()`.\nSOURCE: https://github.com/python/mypy/blob/master/mypyc/doc/str_operations.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nString literal\n```\n\nLANGUAGE: python\nCODE:\n```\nstr(x: int)\n```\n\nLANGUAGE: python\nCODE:\n```\nstr(x: object)\n```\n\nLANGUAGE: python\nCODE:\n```\nrepr(x: int)\n```\n\nLANGUAGE: python\nCODE:\n```\nrepr(x: object)\n```\n\n----------------------------------------\n\nTITLE: Handling Type Narrowing and Assignments in mypyc - Python\nDESCRIPTION: This snippet illustrates restrictions on type narrowing and assignments in mypyc, particularly concerning floating-point numbers. Key points include the disallowance of assigning integers directly to float variables without explicit conversion and the effects of such assignments in different contexts. The need for explicit conversions and potential errors highlight the care required when operating with incompatible types.\nSOURCE: https://github.com/python/mypy/blob/master/mypyc/doc/using_type_annotations.rst#2025-04-22_snippet_7\n\nLANGUAGE: python\nCODE:\n```\ndef narrowing(n: int) -> None:\n    # Error: Incompatible value representations in assignment\n    # (expression has type \"int\", variable has type \"float\")\n    x: float = 0\n\n    y: float = 0.0  # Ok\n\n    if f():\n        y = n  # Error\n    if f():\n        y = float(n)  # Ok\n```\n\n----------------------------------------\n\nTITLE: Assigning List and Appending Incompatible Types in Python (Type Safety Pitfall)\nDESCRIPTION: Expands on the previous incompatibility error by illustrating how appending to a list after such an assignment could break type safety, placing a string in a list that should have only integers. Demonstrates potential dangers that static type checks aim to prevent.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/type_inference_and_annotations.rst#2025-04-22_snippet_9\n\nLANGUAGE: python\nCODE:\n```\ndef f(l: list[object], k: list[int]) -> None:\\n    l = k\\n    l.append('x')\\n    print(k[-1])  # Ouch; a string in list[int]\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Runtime Class of concat Output - Python\nDESCRIPTION: Illustrates the runtime class of the result from concat using a subtype, confirming type promotion to str via print(type(ss)). Used for clarity around runtime typing versus declared static types. No third-party dependencies.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/generics.rst#2025-04-22_snippet_31\n\nLANGUAGE: python\nCODE:\n```\n>>> print(type(ss))\n<class 'str'>\n```\n\n----------------------------------------\n\nTITLE: Customizing Method Signature with Plugin Hook - Python\nDESCRIPTION: Demonstrates how mypy may call a plugin hook to customize method signatures for third-party libraries, such as mimicking ctypes auto-conversions. Shows annotating a ctypes Array, assigning to elements, and the method signature hook for __setitem__ is discussed. Context: Used for extending type inference in dynamic or binary interop code. Requires related plugin implementation; intended for plugin developers.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/extending_mypy.rst#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom ctypes import Array, c_int\n\nx: Array[c_int]\nx[0] = 42\n\n```\n\n----------------------------------------\n\nTITLE: Subclassing str and Type Promotion in Value-Restricted TypeVar - Python\nDESCRIPTION: Shows how a custom subclass of str behaves when used with a value-restricted type variable: the value's type is promoted to str even if the subclass is used for both inputs. Demonstrates actual vs. expected typing, and uses reveal_type for mypy output. No dependencies required.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/generics.rst#2025-04-22_snippet_30\n\nLANGUAGE: python\nCODE:\n```\nclass S(str): pass\n\nss = concat(S('foo'), S('bar'))\nreveal_type(ss)  # Revealed type is \"builtins.str\"\n```\n\n----------------------------------------\n\nTITLE: Illustrating Invalid Usage of __deletable__ (Outside Class Body) in MyPy (Python)\nDESCRIPTION: Demonstrates an invalid declaration of `__deletable__`. This special attribute must be defined within the body of a native class; defining it at the module level or outside a class context is incorrect and results in an error.\nSOURCE: https://github.com/python/mypy/blob/master/mypyc/doc/native_classes.rst#2025-04-22_snippet_8\n\nLANGUAGE: Python\nCODE:\n```\n__deletable__ = ('a',)  # Error: not in a class body\n```\n\n----------------------------------------\n\nTITLE: Enabling Attribute Deletion in MyPy Native Classes using __deletable__ (Python)\nDESCRIPTION: Shows how to specify which instance attributes can be deleted in a native class by assigning a list or tuple of attribute name strings to the special `__deletable__` class attribute. By default, attributes cannot be deleted. Attempts to delete attributes not listed in `__deletable__` will result in an error.\nSOURCE: https://github.com/python/mypy/blob/master/mypyc/doc/native_classes.rst#2025-04-22_snippet_6\n\nLANGUAGE: Python\nCODE:\n```\nclass Cls:\n   x: int = 0\n   y: int = 0\n   other: int = 0\n\n   __deletable__ = ['x', 'y']  # 'x' and 'y' can be deleted\n\no = Cls()\ndel o.x  # OK\ndel o.y  # OK\ndel o.other  # Error\n```\n\n----------------------------------------\n\nTITLE: Demonstrating possibly-undefined error code in Python with mypy\nDESCRIPTION: Shows how mypy detects variables that may be undefined when they appear in a loop, conditional branch, or except handler. The example demonstrates undefined variables in an if statement and a for loop.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/error_code_list2.rst#2025-04-22_snippet_11\n\nLANGUAGE: python\nCODE:\n```\n# mypy: enable-error-code=\"possibly-undefined\"\n\nfrom collections.abc import Iterable\n\ndef test(values: Iterable[int], flag: bool) -> None:\n    if flag:\n        a = 1\n    z = a + 1  # Error: Name \"a\" may be undefined [possibly-undefined]\n\n    for v in values:\n        b = v\n    z = b + 1  # Error: Name \"b\" may be undefined [possibly-undefined]\n```\n\n----------------------------------------\n\nTITLE: Avoiding Macro Name Clashes: Renaming Macros in Google Test - Shell\nDESCRIPTION: This flag prevents Google Test from defining certain potentially conflicting macros (FAIL, SUCCEED, TEST) by renaming them. Use it in your build if another library defines macros of the same name to avoid collision and adapt your test code to use the GTEST_ prefix as described.\nSOURCE: https://github.com/python/mypy/blob/master/mypyc/external/googletest/README.md#2025-04-22_snippet_8\n\nLANGUAGE: shell\nCODE:\n```\n-DGTEST_DONT_DEFINE_FOO=1\n```\n\n----------------------------------------\n\nTITLE: Undetected None Return Value with Non-Optional Return Type\nDESCRIPTION: Example showing how mypy doesn't catch a 'None' return value when the function is annotated to return a non-optional type if strict optional checking is disabled.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/common_issues.rst#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\ndef foo() -> str:\n    return None  # No error!\n```\n\n----------------------------------------\n\nTITLE: Specifying Multiple Packages and Modules to mypy - Bash\nDESCRIPTION: Demonstrates passing multiple package and module names to mypy in one CLI command, using a combination of --package and --module flags. Each item will be type checked according to its context. Requires mypy and importable modules/packages.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/running_mypy.rst#2025-04-22_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n$ mypy --package p.a --package p.b --module c\n```\n\n----------------------------------------\n\nTITLE: Generated Python Stub File (.pyi) using Stubgen\nDESCRIPTION: The corresponding stub file (e.g., `foo.pyi`) automatically generated by `stubgen` for the preceding example Python module. It includes type hints (often defaulting to `Any`) for the public interface, replacing function bodies and initializers with `...`. This demonstrates the typical output format of `stubgen`, requiring potential manual refinement for more precise types.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/stubgen.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n   from typing import Any\n\n   BORDER_WIDTH: int = ...\n\n   class Window:\n       parent: Any = ...\n       width: Any = ...\n       height: Any = ...\n       def __init__(self, width, height) -> None: ...\n\n   def create_empty() -> Window: ...\n```\n\n----------------------------------------\n\nTITLE: Creating a Python Set using Basic Set Comprehension\nDESCRIPTION: Demonstrates the syntax for creating a Python set using a basic set comprehension. This concise syntax iterates over an iterable and generates set elements.\nSOURCE: https://github.com/python/mypy/blob/master/mypyc/doc/set_operations.rst#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n{... for ... in ...}\n```\n\n----------------------------------------\n\nTITLE: Method Level TypeGuards in Mypy\nDESCRIPTION: Describes the use of methods as TypeGuards to facilitate type narrowing within classes in Mypy.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/type_narrowing.rst#2025-04-22_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nclass StrValidator:\n    def is_valid(self, instance: object) -> TypeGuard[str]:\n        return isinstance(instance, str)\n\ndef func(to_validate: object) -> None:\n    if StrValidator().is_valid(to_validate):\n        reveal_type(to_validate)  # Revealed type is \"builtins.str\"\n```\n\n----------------------------------------\n\nTITLE: Installing Mypy via pip\nDESCRIPTION: Command to install or upgrade the Mypy package using pip. This is the recommended way to install the latest version of the static type checker.\nSOURCE: https://github.com/python/mypy/blob/master/CHANGELOG.md#2025-04-22_snippet_42\n\nLANGUAGE: bash\nCODE:\n```\npython3 -m pip install -U mypy\n```\n\n----------------------------------------\n\nTITLE: Using issubclass for Type Inference in Mypy\nDESCRIPTION: Shows the usage of issubclass for effective type inference with user-defined metaclasses in Mypy.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/type_narrowing.rst#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nclass MyCalcMeta(type):\n    @classmethod\n    def calc(cls) -> int:\n        ...\n\nf(o: object) -> None:\n    t = type(o)  # We must use a variable here\n    reveal_type(t)  # Revealed type is \"builtins.type\"\n\n    if issubclass(t, MyCalcMeta):  # `issubclass(type(o), MyCalcMeta)` won't work\n        reveal_type(t)  # Revealed type is \"Type[MyCalcMeta]\"\n        t.calc()  # Okay\n```\n\n----------------------------------------\n\nTITLE: Enforcing Strict Equality Checks in Mypy\nDESCRIPTION: This snippet shows how to use the \"--strict-equality\" flag in mypy to prevent comparisons of non-overlapping types. The examples provided demonstrate errors when comparing string and byte types, with allowances for comparisons to \"None\". Intended to enhance type safety by avoiding invalid comparison operations.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/command_line.rst#2025-04-22_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nitems: list[int]\nif 'some string' in items:  # Error: non-overlapping container check!\n    ...\n\ntext: str\nif text != b'other bytes':  # Error: non-overlapping equality check!\n    ...\n\nassert text is not None  # OK, check against None is allowed as a special case.\n```\n\n----------------------------------------\n\nTITLE: Handling None with --implicit-optional\nDESCRIPTION: This Python snippet explains the --implicit-optional flag, which allows MyPy to treat parameters with a None default as optional types. This influences how MyPy infers the type of parameters in function definitions.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/command_line.rst#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\ndef foo(x: int = None) -> None:\n    print(x)\n```\n\n----------------------------------------\n\nTITLE: Declaring Covariant Generics Using TypeVar - Python <=3.11\nDESCRIPTION: Shows legacy (Python 3.11 and earlier) syntax for declaring covariant generic classes using TypeVar and Generic from typing, demonstrating explicit variance declaration. All required imports (Generic, TypeVar) are standard library. Box accepts content of type T_co, declared covariant, and the pattern mirrors later Python versions but requires explicit variance flags.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/generics.rst#2025-04-22_snippet_25\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Generic, TypeVar\n\nT_co = TypeVar('T_co', covariant=True)\n\nclass Box(Generic[T_co]):  # this type is declared covariant\n    def __init__(self, content: T_co) -> None:\n        self._content = content\n\n    def get_content(self) -> T_co:\n        return self._content\n\ndef look_into(box: Box[Shape]): ...\n\nmy_box = Box(Square())\nlook_into(my_box)  # OK, but mypy would complain here for an invariant type\n```\n\n----------------------------------------\n\nTITLE: Annotating Variables for Mypyc Optimization in Python\nDESCRIPTION: This code snippet demonstrates how to use type annotations in Python to optimize code compiled with mypyc, avoiding slower generic operations. Dependencies include the 'acme' module.\nSOURCE: https://github.com/python/mypy/blob/master/mypyc/doc/performance_tips_and_tricks.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport acme\n\ndef work() -> None:\n    # Annotate \"items\" to help mypyc\n    items: list[tuple[int, str]] = acme.get_items()\n    for item in items:\n        ...  # Do some work here\n\n```\n\n----------------------------------------\n\nTITLE: Unannotated __init__ Disables Type Checking - Python\nDESCRIPTION: Demonstrates that omitting type annotations in the __init__ method results in the method being dynamically typed and skipped by mypy. This can lead to undetected errors in assignments or operations within the constructor.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/class_basics.rst#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nclass C3:\n    def __init__(self):\n        # This body is not type checked\n        self.var = 42 + 'abc'\n```\n\n----------------------------------------\n\nTITLE: Static Inference of Annotations in Python\nDESCRIPTION: Utilizes 'dmypy suggest' to infer a Python function's type annotations based on code heuristics. This feature aids in generating draft function signatures useful for editor integrations, helping propose or auto-add annotations.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/mypy_daemon.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ndef format_id(user):\n    return f\"User: {user}\"\n\nroot = format_id(0)\n```\n\n----------------------------------------\n\nTITLE: Defining Attributes in Mypy Python Classes\nDESCRIPTION: Explains how to define class attributes in Python when using Mypy for type checking, highlighting annotations to specify optional types. The class 'Counter' is used to show how to annotate attributes with type and initial 'None' value.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/kinds_of_types.rst#2025-04-22_snippet_11\n\nLANGUAGE: Python\nCODE:\n```\nclass Resource:\n    path: str | None = None\n    ...\n```\n\nLANGUAGE: Python\nCODE:\n```\nclass Counter:\n    def __init__(self) -> None:\n        self.count: int | None = None\n```\n\n----------------------------------------\n\nTITLE: Regenerating Source Files Using pump.py (Python Invocation via Shell)\nDESCRIPTION: This step involves running the 'pump.py' Python script to regenerate Google Test source files from corresponding .pump templates after modification. The script 'pump.py' is located in the 'scripts/' directory. Dependencies include a working Python installation. Used only when source templates are changed; details are available in the Pump manual.\nSOURCE: https://github.com/python/mypy/blob/master/mypyc/external/googletest/README.md#2025-04-22_snippet_12\n\nLANGUAGE: python\nCODE:\n```\npython scripts/pump.py\n```\n\n----------------------------------------\n\nTITLE: Using ParamSpec in Type Aliases\nDESCRIPTION: Demonstrates how to use ParamSpec and Callable in type aliases for flexible function type definitions.\nSOURCE: https://github.com/python/mypy/blob/master/CHANGELOG.md#2025-04-22_snippet_51\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import ParamSpec, Callable\n\nP = ParamSpec(\"P\")\nA = Callable[P, None]\n\ndef f(c: A[int, str]) -> None:\n    c(1, \"x\")\n```\n\n----------------------------------------\n\nTITLE: Allowing Interpreted Subclasses for MyPy Native Classes using @mypyc_attr (Python)\nDESCRIPTION: Provides an example of using the `@mypyc_attr` decorator from `mypy_extensions` to permit non-native Python classes (or classes from other compilation units) to inherit from a compiled native class. This modifies the default inheritance restriction. Requires the `mypy-extensions` package.\nSOURCE: https://github.com/python/mypy/blob/master/mypyc/doc/native_classes.rst#2025-04-22_snippet_2\n\nLANGUAGE: Python\nCODE:\n```\nfrom mypy_extensions import mypyc_attr\n\n@mypyc_attr(allow_interpreted_subclasses=True)\nclass Cls:\n    ...\n```\n\n----------------------------------------\n\nTITLE: Silencing Linters in Python Type Comments\nDESCRIPTION: Illustrates how to use `noqa` to silence linter warnings related to unused imports in conjunction with Mypy's type comments, ensuring cleaner code without linter errors.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/common_issues.rst#2025-04-22_snippet_17\n\nLANGUAGE: python\nCODE:\n```\n# to silence complaints about unused imports\nfrom typing import List  # noqa\na = None  # type: List[int]\n```\n\nLANGUAGE: python\nCODE:\n```\na = some_complex_thing()  # type: ignore  # noqa\n```\n\n----------------------------------------\n\nTITLE: Constructing a Python Set from an Iterable\nDESCRIPTION: Illustrates creating a Python set from an existing iterable (like a list, tuple, or string) using the `set()` constructor. Duplicate elements in the input iterable are automatically removed during set creation.\nSOURCE: https://github.com/python/mypy/blob/master/mypyc/doc/set_operations.rst#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nset(x: Iterable)\n```\n\n----------------------------------------\n\nTITLE: Accessing a Missing Module Treated as Any - Python\nDESCRIPTION: Demonstrates Python code that triggers a mypy missing import error, showing that after import failure, accessing members of a missing module is allowed and the resulting variable will have type Any. This snippet illustrates how dynamic typing is applied when mypy cannot resolve an imported module. No additional dependencies required.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/running_mypy.rst#2025-04-22_snippet_9\n\nLANGUAGE: python\nCODE:\n```\n# Error: Cannot find implementation or library stub for module named 'does_not_exist'\nimport does_not_exist\n\n# But this type checks, and x will have type 'Any'\nx = does_not_exist.foobar()\n```\n\n----------------------------------------\n\nTITLE: Executing a Python Program using Python 3 in Bash\nDESCRIPTION: This command runs the specified Python file (`PROGRAM`) using the `python3` interpreter. It demonstrates that Python code can still be executed directly, even if Mypy reports type errors, as type hints do not prevent runtime execution. `PROGRAM` should be replaced with the path to the Python file.\nSOURCE: https://github.com/python/mypy/blob/master/README.md#2025-04-22_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n```bash\npython3 PROGRAM\n```\n```\n\n----------------------------------------\n\nTITLE: Illustrating Type Erasure in Primitive Containers (Python)\nDESCRIPTION: This Python snippet shows how primitive container types like `list` have their item types erased at runtime in mypyc. Assigning a `list[Any]` (containing a string) to a `list[int]` variable does not raise an immediate error, but accessing the item later reveals the type mismatch, causing a runtime error. This highlights the difference between static type checking and mypyc's runtime behavior with erased types.\nSOURCE: https://github.com/python/mypy/blob/master/mypyc/doc/using_type_annotations.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Any\n\ndef example(a: list[Any]) -> None:\n    b: list[int] = a  # No error -- items are not checked\n    print(b[0])  # Error here -- got str, but expected int\n\nexample([\"x\"])\n```\n\n----------------------------------------\n\nTITLE: ReadOnly TypedDict Mutation Check in Python\nDESCRIPTION: Shows how Mypy enforces read-only constraints on TypedDict fields marked with ReadOnly.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/error_code_list.rst#2025-04-22_snippet_43\n\nLANGUAGE: python\nCODE:\n```\nfrom datetime import datetime\nfrom typing import TypedDict\nfrom typing_extensions import ReadOnly\n\nclass User(TypedDict):\n    username: ReadOnly[str]\n    last_active: datetime\n\nuser: User = {'username': 'foobar', 'last_active': datetime.now()}\nuser['last_active'] = datetime.now()  # ok\nuser['username'] = 'other'  # error: ReadOnly TypedDict key \"key\" TypedDict is mutated  [typeddict-readonly-mutated]\n```\n\n----------------------------------------\n\nTITLE: Demonstrating New Generic Syntax in Python 3.12 (PEP 695)\nDESCRIPTION: Examples of the new type parameter syntax for generic functions, classes, and type aliases introduced in Python 3.12 and supported by Mypy 1.11 with the NewGenericSyntax feature flag.\nSOURCE: https://github.com/python/mypy/blob/master/CHANGELOG.md#2025-04-22_snippet_14\n\nLANGUAGE: Python\nCODE:\n```\n# Generic function\ndef f[T](x: T) -> T: ...\n\nreveal_type(f(1))  # Revealed type is 'int'\n\n# Generic class\nclass C[T]:\n    def __init__(self, x: T) -> None:\n       self.x = x\n\nc = C('a')\nreveal_type(c.x)  # Revealed type is 'str'\n\n# Type alias\ntype A[T] = C[list[T]]\n```\n\n----------------------------------------\n\nTITLE: Enabling Follow Untyped Imports in pyproject.toml (TOML)\nDESCRIPTION: This snippet shows the correct way to configure mypy to follow untyped imports for a module pattern using the pyproject.toml configuration file. By adding an override with 'module = [\"untyped_package.*\"]' and setting 'follow_untyped_imports = true', mypy will attempt to analyze the untyped dependencies. Requires mypy and a valid pyproject.toml structure.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/running_mypy.rst#2025-04-22_snippet_11\n\nLANGUAGE: toml\nCODE:\n```\n[[tool.mypy.overrides]]\\nmodule = [\"untyped_package.*\"]\\nfollow_untyped_imports = true\n```\n\n----------------------------------------\n\nTITLE: Testing Python Code with Mypyc\nDESCRIPTION: Provides an example of how default drivers in Mypyc testing framework allow conducting tests. No specific inputs are required beyond the test case setup, which includes multiple sub-cases run in separate Python subprocesses. The target is succinct testing without customization unless necessary.\nSOURCE: https://github.com/python/mypy/blob/master/mypyc/doc/dev-intro.md#2025-04-22_snippet_3\n\nLANGUAGE: Python\nCODE:\n```\n[case testConcatenateLists]\\ndef test_concat_lists() -> None:\\n    assert [1, 2] + [5, 6] == [1, 2, 5, 6]\\n\\ndef test_concat_empty_lists() -> None:\\n    assert [] + [] == []\n```\n\n----------------------------------------\n\nTITLE: Installing Mypy Type Stub Packages using Pip\nDESCRIPTION: Provides the shell command to install type stub packages (`types-PyYAML`, `types-requests`) for third-party libraries using pip. Installing these stubs allows Mypy to find the necessary type information and perform type checking for code that uses these libraries.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/getting_started.rst#2025-04-22_snippet_10\n\nLANGUAGE: shell\nCODE:\n```\n$ python3 -m pip install types-PyYAML types-requests\n```\n\n----------------------------------------\n\nTITLE: Setting Multiple Mypy Inline Flags and Quoted Values in Python\nDESCRIPTION: This example shows how to specify multiple Mypy configuration flags within a single inline comment, separated by commas. It also demonstrates how to handle values containing commas by enclosing the value in double quotes. Here, `disallow-untyped-defs` is enabled, and `always-false` is set to the string \"FOO,BAR\". Multiple flags can also be placed on separate `# mypy:` comment lines.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/inline_config.rst#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n# mypy: disallow-untyped-defs, always-false=\"FOO,BAR\"\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Type Narrowing in Nested Functions in Python with Mypy\nDESCRIPTION: Example showing how Mypy 1.4 now propagates narrowed types to nested functions when the variable is not reassigned after the nested function definition.\nSOURCE: https://github.com/python/mypy/blob/master/CHANGELOG.md#2025-04-22_snippet_37\n\nLANGUAGE: python\nCODE:\n```\ndef outer(x: str | None = None) -> None:\n    if x is None:\n        x = calculate_default()\n    reveal_type(x)  # \"str\" (narrowed)\n\n    def nested() -> None:\n        reveal_type(x)  # Now \"str\" (used to be \"str | None\")\n\n    nested()\n```\n\n----------------------------------------\n\nTITLE: Compiling and Linking Tests with Google Test - Shell\nDESCRIPTION: This snippet illustrates compiling a user test source and linking it with the Google Test library and pthreads. It assumes libgtest.a is present as built previously, and uses -isystem to include Google Test headers. Requires g++ and pthreads support. Output is an executable (your_test) that runs your tests.\nSOURCE: https://github.com/python/mypy/blob/master/mypyc/external/googletest/README.md#2025-04-22_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\ng++ -isystem ${GTEST_DIR}/include -pthread path/to/your_test.cc libgtest.a \\\n    -o your_test\n```\n\n----------------------------------------\n\nTITLE: Demonstrating unimported-reveal error code in Python with mypy\nDESCRIPTION: Shows how mypy warns when using reveal_type without importing it, which can lead to runtime errors in production code.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/error_code_list2.rst#2025-04-22_snippet_21\n\nLANGUAGE: python\nCODE:\n```\n# mypy: enable-error-code=\"unimported-reveal\"\n\nx = 1\nreveal_type(x)  # Note: Revealed type is \"builtins.int\" \\\n                # Error: Name \"reveal_type\" is not defined\n```\n\n----------------------------------------\n\nTITLE: Matching on Nested Types in Generic Classes\nDESCRIPTION: This example shows how to use self-type annotations to match on nested generic types. The first_chunk method is only available when the storage contains a sequence of items.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/more_types.rst#2025-04-22_snippet_16\n\nLANGUAGE: python\nCODE:\n```\nfrom collections.abc import Sequence\n\nclass Storage[T]:\n    def __init__(self, content: T) -> None:\n        self._content = content\n\n    def first_chunk[S](self: Storage[Sequence[S]]) -> S:\n        return self._content[0]\n\npage: Storage[list[str]]\npage.first_chunk()  # OK, type is \"str\"\n\nStorage(0).first_chunk()  # Error: Invalid self argument \"Storage[int]\" to attribute function\n                          # \"first_chunk\" with type \"Callable[[Storage[Sequence[S]]], S]\"\n```\n\n----------------------------------------\n\nTITLE: Final Attributes with Mutable and Immutable Types in Python\nDESCRIPTION: Explores the effect of making mutable and immutable collections final. Assigning a mutable list to a final variable prevents rebinding but not mutation; using immutable abstract base classes like Sequence or tuple will also prevent mutation. The dependency is typing.Final and possibly Sequence from typing. Input consists of annotated variables; outputs are mypy errors if an immutable object is mutated, no errors for mutation of mutable objects even if final.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/final_attrs.rst#2025-04-22_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nx: Final = ['a', 'b']\nx.append('c')  # OK\n\ny: Final[Sequence[str]] = ['a', 'b']\ny.append('x')  # Error: Sequence is immutable\nz: Final = ('a', 'b')  # Also an option\n```\n\n----------------------------------------\n\nTITLE: Installing Development Version of Mypy from GitHub in Bash\nDESCRIPTION: This command installs the most recent version of Mypy directly from the main branch of its GitHub repository using pip's Git integration. The `-U` flag ensures any existing version is upgraded. This is useful for testing cutting-edge features or fixes.\nSOURCE: https://github.com/python/mypy/blob/master/README.md#2025-04-22_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n```bash\npython3 -m pip install -U git+https://github.com/python/mypy.git\n```\n```\n\n----------------------------------------\n\nTITLE: Defining AsyncIterator Protocol with __anext__ and __aiter__ (Python)\nDESCRIPTION: Lays out the methods required for collections.abc.AsyncIterator: __anext__ (asynchronously retrieves the next value) and __aiter__ (returns self or compatible async iterator). Used for async iteration in modern Python.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/protocols.rst#2025-04-22_snippet_27\n\nLANGUAGE: python\nCODE:\n```\ndef __anext__(self) -> Awaitable[T]\ndef __aiter__(self) -> AsyncIterator[T]\n\n```\n\n----------------------------------------\n\nTITLE: Installing Interpreted Version of Mypy using pip in Bash\nDESCRIPTION: This command installs Mypy using pip but forces the installation of the pure Python (interpreted) version by disallowing binary wheels (`--no-binary mypy`). The `-U` flag ensures an upgrade if Mypy is already installed. This is typically slower than the default compiled version but might be needed in specific environments or for debugging.\nSOURCE: https://github.com/python/mypy/blob/master/README.md#2025-04-22_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\n```bash\npython3 -m pip install --no-binary mypy -U mypy\n```\n```\n\n----------------------------------------\n\nTITLE: Declaring and Initializing a Simple Dictionary - Python\nDESCRIPTION: Demonstrates the creation of a basic dictionary object with string keys and values of different types, representing a simple movie data structure. No explicit type-checking or annotation is performed. No special dependencies are required; works with plain Python. Inputs are string and integer values; outputs a Python dict with the specified schema.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/typed_dict.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nmovie = {'name': 'Blade Runner', 'year': 1982}\n```\n\n----------------------------------------\n\nTITLE: Example Mypy Error Message Format\nDESCRIPTION: Demonstrates the default format of a mypy error message. It includes the file path, line number, the error message itself, and an error code in brackets (e.g., `[attr-defined]`). This specific example shows an error indicating that a string object does not have a 'trim' attribute.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/command_line.rst#2025-04-22_snippet_15\n\nLANGUAGE: text\nCODE:\n```\nprog.py:1: error: \"str\" has no attribute \"trim\"  [attr-defined]\n```\n\n----------------------------------------\n\nTITLE: Enable Mypy Verbose Output During Test Runs - Shell\nDESCRIPTION: Adds extra verbosity to test output, including internal debug information from mypy, using the '--mypy-verbose' flag together with single-process restriction. Helpful for diagnosing subtle or complex test failures.\nSOURCE: https://github.com/python/mypy/blob/master/test-data/unit/README.md#2025-04-22_snippet_14\n\nLANGUAGE: shell\nCODE:\n```\npytest -n0 --mypy-verbose -k MethodCall\n```\n\n----------------------------------------\n\nTITLE: Unpacking Variables Without Type Inference in Python (Mypy Error)\nDESCRIPTION: Shows a tuple unpacking operation where mypy cannot infer the type for the variable capturing the rest of the unpack. The example highlights the requirement for an explicit type annotation when there is insufficient data for inference. Annotations for unpacked variables are essential for type safety.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/type_inference_and_annotations.rst#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n# We only unpack two values, so there's no right-hand side value\\n# for mypy to infer the type of \\\"cs\\\" from:\\na, b, *cs = 1, 2  # error: Need type annotation for \\\"cs\\\"\n```\n\n----------------------------------------\n\nTITLE: Legacy Generic Type Annotation (Python 3.11)\nDESCRIPTION: Legacy syntax for generic type annotation using TypeVar with upper bound constraint.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/kinds_of_types.rst#2025-04-22_snippet_18\n\nLANGUAGE: python\nCODE:\n```\nU = TypeVar('U', bound=User)\n\ndef new_user(user_class: type[U]) -> U:\n    # Same implementation as before\n```\n\n----------------------------------------\n\nTITLE: Dynamically Typed Function in Python\nDESCRIPTION: This Python function, 'greeting', concats a string with a name. It's dynamically typed, and Mypy does not check for type consistency, allowing incorrect usage without errors during type checking.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/getting_started.rst#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ndef greeting(name):\n    return 'Hello ' + name\n\ngreeting(123)\ngreeting(b'Alice')\n```\n\n----------------------------------------\n\nTITLE: Checking Assignment Statement Types with Mypy in Python\nDESCRIPTION: This snippet shows how Mypy checks that the type of the assigned expression is compatible with the assignment target's type. An error occurs if there is a type mismatch, as illustrated with the Resource class and attribute assignment.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/error_code_list.rst#2025-04-22_snippet_14\n\nLANGUAGE: python\nCODE:\n```\nclass Resource:\n    def __init__(self, name: str) -> None:\n        self.name = name\n\nr = Resource('A')\n\nr.name = 'B'  # OK\n\n# Error: Incompatible types in assignment (expression has type \"int\",\n#        variable has type \"str\")  [assignment]\nr.name = 5\n```\n\n----------------------------------------\n\nTITLE: Narrowing Enum Values Using Equality Operator in Python with Mypy\nDESCRIPTION: Example demonstrating how Mypy 1.4 enables exhaustiveness checking with enum types using the == operator, showing both an error case with incomplete handling and a corrected version.\nSOURCE: https://github.com/python/mypy/blob/master/CHANGELOG.md#2025-04-22_snippet_38\n\nLANGUAGE: python\nCODE:\n```\nfrom enum import Enum\n\nclass MyEnum(Enum):\n    A = 0\n    B = 1\n    C = 2\n\ndef example(e: MyEnum) -> str:  # Error: Missing return statement\n    if e == MyEnum.A:\n        return 'x'\n    elif e == MyEnum.B:\n        return 'y'\n```\n\n----------------------------------------\n\nTITLE: Detecting Deprecated Features in Python with Mypy\nDESCRIPTION: Here, mypy's functionality is extended with the --enable-error-code deprecated option to highlight usage of deprecated features, enabling developers to replace outdated patterns as described in PEP 702.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/error_code_list2.rst#2025-04-22_snippet_9\n\nLANGUAGE: python\nCODE:\n```\n# mypy: report-deprecated-as-error\n\n# Error: abc.abstractproperty is deprecated: Deprecated, use 'property' with 'abstractmethod' instead\nfrom abc import abstractproperty\n\nfrom typing_extensions import deprecated\n\n@deprecated(\"use new_function\")\ndef old_function() -> None:\n    print(\"I am old\")\n\n# Error: __main__.old_function is deprecated: use new_function\nold_function()\nold_function()  # type: ignore[deprecated]\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Re-exporting Import Using `as` with `implicit_reexport=False` in Mypy (Python)\nDESCRIPTION: This Python snippet shows one way to explicitly re-export an imported name when `implicit_reexport` is `False` in Mypy. Using `from foo import bar as bar` makes `bar` available for other modules to import from the current module.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/config_file.rst#2025-04-22_snippet_11\n\nLANGUAGE: python\nCODE:\n```\n# This will re-export it as bar and allow other modules to import it\nfrom foo import bar as bar\n```\n\n----------------------------------------\n\nTITLE: Defining Protocol Classes and Overloads for Async Iterators\nDESCRIPTION: Shows correct and incorrect ways to define Protocol classes and function overloads for async iterators. Demonstrates how yield affects type signatures in protocol definitions.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/more_types.rst#2025-04-22_snippet_25\n\nLANGUAGE: python\nCODE:\n```\nfrom collections.abc import AsyncIterator\nfrom typing import Protocol, overload\n\nclass LauncherIncorrect(Protocol):\n    async def launch(self) -> AsyncIterator[int]:\n        raise NotImplementedError\n\nclass LauncherCorrect(Protocol):\n    def launch(self) -> AsyncIterator[int]:\n        raise NotImplementedError\n\nclass LauncherAlsoCorrect(Protocol):\n    async def launch(self) -> AsyncIterator[int]:\n        raise NotImplementedError\n        if False:\n            yield 0\n\n@overload\ndef launch(*, count: int = ...) -> AsyncIterator[int]: ...\n@overload\ndef launch(*, time: float = ...) -> AsyncIterator[int]: ...\n\nasync def launch(*, count: int = 0, time: float = 0) -> AsyncIterator[int]:\n    yield 0\n```\n\n----------------------------------------\n\nTITLE: Installing Mypy via pip - Shell\nDESCRIPTION: This shell command installs or upgrades mypy, a static type checker for Python, using pip within a Python 3 environment. Prerequisites include having Python 3 and pip installed and available from the command line. The '-U' flag upgrades mypy if it is already present, and this is appropriate for users wishing to ensure they have the newest compatible version; no arguments beyond the package name 'mypy' are required.\nSOURCE: https://github.com/python/mypy/blob/master/CHANGELOG.md#2025-04-22_snippet_6\n\nLANGUAGE: shell\nCODE:\n```\npython3 -m pip install -U mypy\n```\n\n----------------------------------------\n\nTITLE: Using 'Any' Type in Function Parameters and Expressions - Python\nDESCRIPTION: Demonstrates that any operation on a parameter of type 'Any' is allowed by mypy, regardless of validity at runtime. Illustrates with multiple operations, including method calls, item access, and file operations, showing that mypy will permit all such usages. Assumes 'x' is annotated as 'Any'; useful for understanding the limits of static analysis. Inputs are any value passed as 'x', outputs are the result of operations or the value being returned; constraints are that runtime errors can still occur since static analysis is suppressed.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/dynamic_typing.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ndef f(x: Any) -> int:\n    # All of these are valid!\n    x.foobar(1, y=2)\n    print(x[3] + 'f')\n    if x:\n        x.z = x(2)\n    open(x).read()\n    return x\n```\n\n----------------------------------------\n\nTITLE: Basic Mypy Usage with File Paths\nDESCRIPTION: Demonstrates how to run mypy on specific files and directories using the command line.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/command_line.rst#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n$ mypy foo.py bar.py some_directory\n```\n\n----------------------------------------\n\nTITLE: Setup Script for Package with Inline Type Annotations\nDESCRIPTION: Example setup.py file for a package with inline type annotations, including the py.typed file in package_data.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/installed_packages.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom setuptools import setup\n\nsetup(\n    name=\"SuperPackageA\",\n    author=\"Me\",\n    version=\"0.1\",\n    package_data={\"package_a\": [\"py.typed\"]},\n    packages=[\"package_a\"]\n)\n```\n\n----------------------------------------\n\nTITLE: Adding Type Annotation to Empty List Assignment in Python\nDESCRIPTION: Illustrates the workaround for the contextless assignment problem by adding a type annotation. The empty list is annotated as 'list[int]' to satisfy static type checking when passed to a function expecting a 'list[int]'.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/type_inference_and_annotations.rst#2025-04-22_snippet_13\n\nLANGUAGE: python\nCODE:\n```\n...\\na: list[int] = []  # OK\\nfoo(a)\n```\n\n----------------------------------------\n\nTITLE: Compiling a Python File with Mypyc (Console)\nDESCRIPTION: Command demonstrating the basic usage of the `mypyc` tool to compile the `fib.py` file. This process generates a C extension module (e.g., `fib.cpython-37m-x86_64-linux-gnu.so`) in the current directory.\nSOURCE: https://github.com/python/mypy/blob/master/mypyc/doc/getting_started.rst#2025-04-22_snippet_6\n\nLANGUAGE: console\nCODE:\n```\n$ mypyc fib.py\n```\n\n----------------------------------------\n\nTITLE: Dictionary Operators in Python\nDESCRIPTION: Basic dictionary operators for accessing values and checking key existence.\nSOURCE: https://github.com/python/mypy/blob/master/mypyc/doc/dict_operations.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nd[key]\nvalue in d\n```\n\n----------------------------------------\n\nTITLE: Failed Conditional Overload Example with Non-Inferred Condition\nDESCRIPTION: This example shows what happens when mypy cannot infer a boolean condition to be always True or False. The function overloads cannot be properly merged, resulting in less precise typing.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/more_types.rst#2025-04-22_snippet_14\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Any, overload\n\nclass A: ...\nclass B: ...\n\n\ndef g(bool_var: bool) -> None:\n    if bool_var:  # Condition can't be inferred, unable to merge overloads\n        @overload\n        def func(var: A) -> A: ...\n\n        @overload\n        def func(var: B) -> B: ...\n\n    def func(var: Any) -> Any: ...\n\n    reveal_type(func(A()))  # Revealed type is \"Any\"\n```\n\n----------------------------------------\n\nTITLE: Using Callable in Union Type Expressions with Mypy (Python)\nDESCRIPTION: Demonstrates Mypy's improved support for using type hints, specifically a union type involving `Callable`, directly within expressions. This example shows that printing `Callable[[], int] | None` no longer generates an error, highlighting better handling of complex type annotations in expression contexts. It requires importing `Callable` from the `typing` module.\nSOURCE: https://github.com/python/mypy/blob/master/CHANGELOG.md#2025-04-22_snippet_18\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Callable\n\nprint(Callable[[], int] | None)  # No error\n```\n\n----------------------------------------\n\nTITLE: Legacy Generic Class Behavior at Runtime in Python 3.11 and Earlier\nDESCRIPTION: Shows the runtime behavior of generic classes using the legacy syntax, demonstrating similar behavior to the new syntax in terms of generic aliases and type erasure.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/generics.rst#2025-04-22_snippet_57\n\nLANGUAGE: python\nCODE:\n```\n>>> from typing import TypeVar, Generic\n>>> T = TypeVar('T')\n>>> class Stack(Generic[T]): ...\n>>> Stack\n__main__.Stack\n>>> Stack[int]\n__main__.Stack[int]\n>>> instance = Stack[int]()\n>>> instance.__class__\n__main__.Stack\n```\n\n----------------------------------------\n\nTITLE: Using typing Aliases for Built-in Types in Python 3.8 and Earlier\nDESCRIPTION: Demonstrates the use of typing aliases like List for built-in types that don't support indexing in older Python versions. Shows the difference in behavior between these aliases and the built-in types in newer Python versions.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/generics.rst#2025-04-22_snippet_59\n\nLANGUAGE: python\nCODE:\n```\n>>> # Only relevant for Python 3.8 and below\n>>> # If using Python 3.9 or newer, prefer the 'list[int]' syntax\n>>> from typing import List\n>>> List[int]\ntyping.List[int]\n\n>>> list[int]()\n[]\n>>> from typing import List\n>>> List[int]()\nTraceback (most recent call last):\n...\nTypeError: Type List cannot be instantiated; use list() instead\n```\n\n----------------------------------------\n\nTITLE: Using type: ignore Comment to Silence Mypy Errors\nDESCRIPTION: Example demonstrating how to use '# type: ignore' comments to silence mypy errors for imports that cannot be resolved, such as C extension modules without stubs.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/common_issues.rst#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nimport frobnicate  # Error: No module \"frobnicate\"\nfrobnicate.start()\n```\n\n----------------------------------------\n\nTITLE: Unreachable Code After Always-Failing assert - Python\nDESCRIPTION: This example shows that an assert statement guaranteed to fail (such as asserting a non-None value is None) creates unreachable code for mypy, so errors in it are not surfaced. The code uses a class with a str attribute; asserting it is None ensures that subsequent lines are unreachable.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/common_issues.rst#2025-04-22_snippet_28\n\nLANGUAGE: python\nCODE:\n```\nclass Foo:\\n    bar: str = ''\\n\\ndef bar() -> None:\\n    foo: Foo = Foo()\\n    assert foo.bar is None\\n    x: int = 'abc'  # Unreachable -- no error\n```\n\n----------------------------------------\n\nTITLE: Installing Mypy with orjson Support for Faster Cache - Shell\nDESCRIPTION: This shell command installs or upgrades mypy with the 'faster-cache' extra, which ensures the orjson library is present, for improved cache handling performance. Prerequisites include Python 3, pip, and internet connectivity to fetch both mypy and its optional dependencies. The installation will automatically pull in orjson as required; executing this command is recommended for users seeking performance enhancements in environments where caching speed is important.\nSOURCE: https://github.com/python/mypy/blob/master/CHANGELOG.md#2025-04-22_snippet_7\n\nLANGUAGE: shell\nCODE:\n```\npython3 -m pip install -U mypy[faster-cache]\n```\n\n----------------------------------------\n\nTITLE: Mypy Detecting Missing Return Without assert_never in Python\nDESCRIPTION: This snippet illustrates that even without `assert_never`, if a function with a non-optional return type fails to cover all possible `Literal` input values, Mypy can still report a 'Missing return statement' error if a code path exists that doesn't return.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/literal_types.rst#2025-04-22_snippet_12\n\nLANGUAGE: python\nCODE:\n```\nPossibleValues = Literal['one', 'two', 'three']\n\n# Error: Missing return statement\ndef validate(x: PossibleValues) -> bool:\n    if x == 'one':\n        return True\n    elif x == 'two':\n        return False\n```\n\n----------------------------------------\n\nTITLE: Adjusting Error Message Details in Mypy\nDESCRIPTION: This snippet changes the amount of detail in error messages using flags such as \"--show-error-context\" and \"--show-column-numbers\" in mypy. It provides contextual and column-based error messages to improve debugging efficiency, showing how errors can be communicated with additional detail.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/command_line.rst#2025-04-22_snippet_14\n\nLANGUAGE: python\nCODE:\n```\nclass Test:\n    def foo(self, x: int) -> int:\n        return x + \"bar\"\n```\n\n----------------------------------------\n\nTITLE: Building a Python Wheel with Mypyc Compiled Modules (Shell)\nDESCRIPTION: Command to build a Python wheel distribution (`.whl`) using a `setup.py` script configured with `mypycify`. This packages the compiled C extensions along with other package files into a distributable format, typically placing the wheel in the `dist/` directory.\nSOURCE: https://github.com/python/mypy/blob/master/mypyc/doc/getting_started.rst#2025-04-22_snippet_10\n\nLANGUAGE: bash\nCODE:\n```\npython3 setup.py bdist_wheel\n```\n\n----------------------------------------\n\nTITLE: Ensuring Function Annotations in Python with Mypy\nDESCRIPTION: This snippet highlights the use of mypy's --disallow-untyped-defs option to enforce that all functions have explicit type annotations, preventing untyped function definitions which could lead to imprecise type checking.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/error_code_list2.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n# mypy: disallow-untyped-defs\n\ndef inc(x):  # Error: Function is missing a type annotation  [no-untyped-def]\n    return x + 1\n\ndef inc_ok(x: int) -> int:  # OK\n    return x + 1\n\nclass Counter:\n     # Error: Function is missing a type annotation  [no-untyped-def]\n     def __init__(self):\n         self.value = 0\n\nclass CounterOk:\n     # OK: An explicit \"-> None\" is needed if \"__init__\" takes no arguments\n     def __init__(self) -> None:\n         self.value = 0\n```\n\n----------------------------------------\n\nTITLE: Defining SupportsComplex Protocol with __complex__ (Python)\nDESCRIPTION: Documents the __complex__ method requirement for typing.SupportsComplex, allowing objects to be converted to complex type. No arithmetic operations required. Returns a complex instance.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/protocols.rst#2025-04-22_snippet_21\n\nLANGUAGE: python\nCODE:\n```\ndef __complex__(self) -> complex\n\n```\n\n----------------------------------------\n\nTITLE: List Function Len in Python\nDESCRIPTION: Illustrates the utilization of the len() function to determine the number of items in a list. This is a straightforward way to acquire a list's size.\nSOURCE: https://github.com/python/mypy/blob/master/mypyc/doc/list_operations.rst#2025-04-22_snippet_5\n\nLANGUAGE: Python\nCODE:\n```\nlen(lst: list)\n```\n\n----------------------------------------\n\nTITLE: Adjusting Garbage Collection in Python\nDESCRIPTION: This snippet showcases how to adjust garbage collection frequency in Python using 'gc.set_threshold' to improve performance when compiled with mypyc.\nSOURCE: https://github.com/python/mypy/blob/master/mypyc/doc/performance_tips_and_tricks.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport gc\n\n# Spend less time in gc; do this before significant computation\ngc.set_threshold(150000)\n\n...  # Actual work happens here\n\n```\n\n----------------------------------------\n\nTITLE: Customizing Class Definitions with Plugin - Python\nDESCRIPTION: Shows utilizing Python's @dataclass decorator and indicates how a plugin might add methods (such as __init__) to the class definition. This example is for illustrating how plugins can customize class structures at type-check time for runtime behavior alignment. Used in the context of providing accurate type information to mypy; plugin required for full support.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/extending_mypy.rst#2025-04-22_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nfrom dataclasses import dataclass\n\n@dataclass  # built-in plugin adds `__init__` method here\nclass User:\n    name: str\n\nuser = User(name='example')  # mypy can understand this using a plugin\n\n```\n\n----------------------------------------\n\nTITLE: Handling None and TypeVar in Overloaded Functions in Python\nDESCRIPTION: This code illustrates how mypy no longer considers an overload item with a None argument type to overlap with a type variable, solving a common issue in overloaded function definitions.\nSOURCE: https://github.com/python/mypy/blob/master/CHANGELOG.md#2025-04-22_snippet_32\n\nLANGUAGE: python\nCODE:\n```\n@overload\ndef f(x: None) -> None: ..\n@overload\ndef f(x: T) -> Foo[T]: ...\n...\n```\n\n----------------------------------------\n\nTITLE: Using Local Partial Types in Mypy\nDESCRIPTION: This code illustrates the restriction of partial types to local levels using the \"--local-partial-types\" flag in mypy, requiring explicit type annotations for variables initialized with \"None\". The example involves class and module level variables without explicit type annotations, showing potential errors when the flag is enabled.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/command_line.rst#2025-04-22_snippet_8\n\nLANGUAGE: python\nCODE:\n```\na = None  # Need type annotation here if using --local-partial-types\nb: int | None = None\n\nclass Foo:\n    bar = None  # Need type annotation here if using --local-partial-types\n    baz: int | None = None\n\n    def __init__(self) -> None:\n        self.bar = 1\n\nreveal_type(Foo().bar)  # 'int | None' without --local-partial-types\n```\n\n----------------------------------------\n\nTITLE: Optimized String-Related Functions in Python\nDESCRIPTION: Lists built-in Python functions commonly used with strings that have optimized implementations. This includes `len()` to get the string length and `ord()` to get the Unicode code point of a single character string.\nSOURCE: https://github.com/python/mypy/blob/master/mypyc/doc/str_operations.rst#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nlen(s: str)\n```\n\nLANGUAGE: python\nCODE:\n```\nord(s: str)\n```\n\n----------------------------------------\n\nTITLE: Using Ellipsis for Default Arguments in Python Protocols at Runtime\nDESCRIPTION: This Python code demonstrates using an ellipsis (`...`) as a default value for function arguments within runtime code, specifically in a `typing.Protocol`. This syntax is valid only when the function body lacks runtime logic, containing just an ellipsis, `pass`, `raise NotImplementedError()`, or only a docstring. The example contrasts valid usages (`ok_1`, `ok_2`, `ok_3`) with an invalid one (`not_ok`) where the function body includes executable code, which would cause a Mypy type error.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/stubs.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Protocol\n\nclass Resource(Protocol):\n    def ok_1(self, foo: list[str] = ...) -> None: ...\n\n    def ok_2(self, foo: list[str] = ...) -> None:\n        raise NotImplementedError()\n\n    def ok_3(self, foo: list[str] = ...) -> None:\n        \"\"\"Some docstring\"\"\"\n        pass\n\n    # Error: Incompatible default for argument \"foo\" (default has\n    # type \"ellipsis\", argument has type \"list[str]\")\n    def not_ok(self, foo: list[str] = ...) -> None:\n        print(foo)\n```\n\n----------------------------------------\n\nTITLE: Installing Python Development Headers on Ubuntu (Shell)\nDESCRIPTION: Command to install Python 3 development headers and libraries using apt on Ubuntu (example for 18.04). These are necessary components for the C extension development environment required by mypyc on Linux systems.\nSOURCE: https://github.com/python/mypy/blob/master/mypyc/doc/getting_started.rst#2025-04-22_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n$ sudo apt install python3-dev\n```\n\n----------------------------------------\n\nTITLE: Getting the Size of a Python Set\nDESCRIPTION: Shows how to use the built-in `len()` function to get the number of elements (cardinality) in a Python set `s`. This is an efficient operation.\nSOURCE: https://github.com/python/mypy/blob/master/mypyc/doc/set_operations.rst#2025-04-22_snippet_12\n\nLANGUAGE: python\nCODE:\n```\nlen(s: set)\n```\n\n----------------------------------------\n\nTITLE: Ignoring Undefined Attributes in Python\nDESCRIPTION: This Python code snippet demonstrates how to use a special comment to ignore errors for undefined attributes in Mypy. It requires importing a module and using the ignore syntax with a specific error code.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/error_codes.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n# 'foo' is defined in 'foolib', even though mypy can't see the\\ndefinition.\\nfrom foolib import foo  # type: ignore[attr-defined]\n```\n\n----------------------------------------\n\nTITLE: Clearing all Items from a Python Set\nDESCRIPTION: Shows the `clear()` method, which removes all elements from a Python set `s`, effectively making it an empty set.\nSOURCE: https://github.com/python/mypy/blob/master/mypyc/doc/set_operations.rst#2025-04-22_snippet_10\n\nLANGUAGE: python\nCODE:\n```\ns.clear()\n```\n\n----------------------------------------\n\nTITLE: Multi-Module Override Configuration in TOML\nDESCRIPTION: Example demonstrating how to configure multiple module overrides in a single section of pyproject.toml for Mypy.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/config_file.rst#2025-04-22_snippet_14\n\nLANGUAGE: toml\nCODE:\n```\n[[tool.mypy.overrides]]\nmodule = [\n    'packagename',\n    'packagename2'\n]\n...\n```\n\n----------------------------------------\n\nTITLE: Run Linters via runtests.py Wrapper - Shell\nDESCRIPTION: Executes project linters via the provided 'runtests.py', which wraps around pre-commit checks. This ensures all formatting and linting policies are enforced before integration or check-in.\nSOURCE: https://github.com/python/mypy/blob/master/test-data/unit/README.md#2025-04-22_snippet_10\n\nLANGUAGE: shell\nCODE:\n```\npython3 runtests.py lint\n```\n\n----------------------------------------\n\nTITLE: Calculating Length of Frozenset in Python\nDESCRIPTION: Illustrates how to calculate the number of elements in a frozenset using the 'len' function. This function requires a frozenset as input and returns an integer representing its size.\nSOURCE: https://github.com/python/mypy/blob/master/mypyc/doc/frozenset_operations.rst#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nlen(s: set)\n```\n\n----------------------------------------\n\nTITLE: Sorting Collections Using sorted() - Python\nDESCRIPTION: Shows usage of the sorted() function to sort any iterable in Python. Inputs can be lists or other iterables. Returns a new sorted list; optional keyword arguments for sorting customization.\nSOURCE: https://github.com/python/mypy/blob/master/mypyc/doc/native_operations.rst#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nsorted(obj)\n```\n\n----------------------------------------\n\nTITLE: Handling Mixed Native Integer Types in Binary Operations\nDESCRIPTION: Shows how to handle operations involving mixed native integer types like `i64` and `i32`, ensuring correct type usage with explicit conversion to avoid errors.\nSOURCE: https://github.com/python/mypy/blob/master/mypyc/doc/int_operations.rst#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom mypy_extensions import i64, i32\n\ndef add(x: i64, y: i32) -> None:\n    a = x + y  # Error (i64 + i32)\n    b = x + i64(y)  # OK\n```\n\n----------------------------------------\n\nTITLE: Limitation: Type Analysis with Multiple Optional Variables - Python\nDESCRIPTION: This example illustrates a limitation of Mypy's type inference when dealing with relationships between multiple optional variables. Class C is defined, and function f tries to return either 'a' or 'b' if one is not None, but the type checker cannot deduce that one must be non-None. Requires awareness that Mypy performs symbol-based analysis and may require more explicit checks or assertions for strict type safety.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/type_narrowing.rst#2025-04-22_snippet_19\n\nLANGUAGE: python\nCODE:\n```\nclass C:\n    pass\n\ndef f(a: C | None, b: C | None) -> C:\n    if a is not None or b is not None:\n        return a or b  # Incompatible return value type (got \"C | None\", expected \"C\")\n    return C()\n```\n\n----------------------------------------\n\nTITLE: Suppressing Missing Import Errors (Example Diagnostic) - Console Output - Text\nDESCRIPTION: This snippet shows sample error output produced by mypy when it cannot find type information or stub files for imported modules. These diagnostic messages help developers identify missing dependencies or the need for type stubs. The error format is '<file>:<line>: error: Cannot find implementation or library stub for module named ...'. There are no dependencies, as this is generated output. No direct parameters—output will vary by the actual codebase imports.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/existing_code.rst#2025-04-22_snippet_2\n\nLANGUAGE: text\nCODE:\n```\ncore/config.py:7: error: Cannot find implementation or library stub for module named 'frobnicate'\ncore/model.py:9: error: Cannot find implementation or library stub for module named 'acme'\n...\n```\n\n----------------------------------------\n\nTITLE: Dictionary Construction Syntax in Python\nDESCRIPTION: Various methods to construct dictionary objects including literal syntax, empty dictionaries, and dictionary comprehensions.\nSOURCE: https://github.com/python/mypy/blob/master/mypyc/doc/dict_operations.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n{key: value, ...}\n{}\ndict()\ndict(d: dict)\ndict(x: Iterable)\n{...: ... for ... in ...}\n{...: ... for ... in ... if ...}\n```\n\n----------------------------------------\n\nTITLE: Mypy Error on Extending Final Enum Class in Python\nDESCRIPTION: This snippet shows Mypy statically catching the attempt to inherit from the `Direction` Enum, reporting an error because Enum classes with members are treated as final.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/literal_types.rst#2025-04-22_snippet_20\n\nLANGUAGE: python\nCODE:\n```\nclass AllDirection(Direction):  # E: Cannot inherit from final class \"Direction\"\n    left = 'left'\n    right = 'right'\n```\n\n----------------------------------------\n\nTITLE: Type Usage Example\nDESCRIPTION: Example showing type checking limitation with basic type annotation.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/kinds_of_types.rst#2025-04-22_snippet_16\n\nLANGUAGE: python\nCODE:\n```\nbuyer = new_user(ProUser)\nbuyer.pay()  # Rejected, not a method on User\n```\n\n----------------------------------------\n\nTITLE: Running the Python Script in Interpreted Mode (Console)\nDESCRIPTION: Command to execute the `fib.py` script using the standard Python 3 interpreter. The output shows the execution time for the uncompiled version, establishing a baseline for comparison with the compiled version.\nSOURCE: https://github.com/python/mypy/blob/master/mypyc/doc/getting_started.rst#2025-04-22_snippet_5\n\nLANGUAGE: console\nCODE:\n```\n$ python3 fib.py\n0.4125328063964844\n```\n\n----------------------------------------\n\nTITLE: Function return value checks with Mypy\nDESCRIPTION: Mypy verifies functions with non-None return types to ensure they return values correctly, identifying missing return statements as errors. It requires explicit return paths for all function flows.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/error_code_list.rst#2025-04-22_snippet_10\n\nLANGUAGE: Python\nCODE:\n```\n    # Error: Missing return statement  [return]\n    def show(x: int) -> int:\n        print(x)\n\n    # Error: Missing return statement  [return]\n    def pred1(x: int) -> int:\n        if x > 0:\n            return x - 1\n\n    # OK\n    def pred2(x: int) -> int:\n        if x > 0:\n            return x - 1\n        else:\n            raise ValueError('not defined for zero')\n```\n\n----------------------------------------\n\nTITLE: Illustrating Invalid Usage of __deletable__ (Variable Assignment) in MyPy (Python)\nDESCRIPTION: Provides an example of incorrect usage of `__deletable__` within a native class definition. Assigning a variable containing the list of deletable attributes is not allowed; `__deletable__` must be assigned a literal list or tuple of string literals directly in the class body.\nSOURCE: https://github.com/python/mypy/blob/master/mypyc/doc/native_classes.rst#2025-04-22_snippet_7\n\nLANGUAGE: Python\nCODE:\n```\na = ['x', 'y']\n\nclass Cls:\n   x: int\n   y: int\n\n   __deletable__ = a  # Error: cannot use variable 'a'\n```\n\n----------------------------------------\n\nTITLE: Demonstrating truthy-bool error code in Python with mypy\nDESCRIPTION: Shows how mypy warns when using expressions in boolean contexts that don't implement __bool__ or __len__, which means they will always be considered True.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/error_code_list2.rst#2025-04-22_snippet_12\n\nLANGUAGE: python\nCODE:\n```\n# mypy: enable-error-code=\"truthy-bool\"\n\nclass Foo:\n    pass\nfoo = Foo()\n# Error: \"foo\" has type \"Foo\" which does not implement __bool__ or __len__ so it could always be true in boolean context\nif foo:\n     ...\n```\n\n----------------------------------------\n\nTITLE: Implementing a Type-Preserving Decorator with Parameter Specifications (Python 3.11)\nDESCRIPTION: Legacy version of the stringify decorator that preserves input types but changes the return type to str. This uses TypeVar and ParamSpec from typing and typing_extensions for Python 3.11 and earlier.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/generics.rst#2025-04-22_snippet_40\n\nLANGUAGE: python\nCODE:\n```\nfrom collections.abc import Callable\nfrom typing import TypeVar\nfrom typing_extensions import ParamSpec\n\nP = ParamSpec('P')\nT = TypeVar('T')\n\n# We reuse 'P' in the return type, but replace 'T' with 'str'\ndef stringify(func: Callable[P, T]) -> Callable[P, str]:\n    def wrapper(*args: P.args, **kwds: P.kwargs) -> str:\n        return str(func(*args, **kwds))\n    return wrapper\n```\n\n----------------------------------------\n\nTITLE: Forcing Google Test Tuple Library Selection and Configuration - Shell\nDESCRIPTION: These snippets show how to use compiler flags to enable or disable Google Test's use of its internal TR1 tuple implementation or the system's, by defining preprocessor macros during compilation. These should be included in your build scripts or Makefiles. Each flag tailors the build for integration with different tuple libraries or disables tuple support entirely.\nSOURCE: https://github.com/python/mypy/blob/master/mypyc/external/googletest/README.md#2025-04-22_snippet_5\n\nLANGUAGE: shell\nCODE:\n```\n-DGTEST_USE_OWN_TR1_TUPLE=0\n```\n\nLANGUAGE: shell\nCODE:\n```\n-DGTEST_USE_OWN_TR1_TUPLE=1\n```\n\nLANGUAGE: shell\nCODE:\n```\n-DGTEST_HAS_TR1_TUPLE=0\n```\n\n----------------------------------------\n\nTITLE: Compiling a Python Module with Mypyc\nDESCRIPTION: Command for compiling a Python module to a C extension using the mypyc development version. This generates a compiled version of the module in the current working directory.\nSOURCE: https://github.com/python/mypy/blob/master/mypyc/doc/dev-intro.md#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n$ python -m mypyc program.py\n```\n\n----------------------------------------\n\nTITLE: Checking Membership in a Python Set\nDESCRIPTION: Illustrates using the `in` operator to check if an item exists within a Python set `s`. This operation is highly efficient, typically having an average time complexity of O(1).\nSOURCE: https://github.com/python/mypy/blob/master/mypyc/doc/set_operations.rst#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nitem in s\n```\n\n----------------------------------------\n\nTITLE: Excluding Untyped Function Calls with --untyped-calls-exclude\nDESCRIPTION: This Python snippet illustrates how to use the --untyped-calls-exclude option to selectively disable --disallow-untyped-calls for functions in specified modules or classes. The entries act as prefixes to allow untyped calls from specified sources.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/command_line.rst#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n# mypy --disallow-untyped-calls\n#      --untyped-calls-exclude=third_party_lib.module_a\n#      --untyped-calls-exclude=foo.A\nfrom third_party_lib.module_a import some_func\nfrom third_party_lib.module_b import other_func\nimport foo\n\nsome_func()  # OK, function comes from module `third_party_lib.module_a`\nother_func()  # E: Call to untyped function \"other_func\" in typed context\n\nfoo.A().meth()  # OK, method was defined in class `foo.A`\nfoo.B().meth()  # E: Call to untyped function \"meth\" in typed context\n\n# file foo.py\nclass A:\n    def meth(self): pass\nclass B:\n    def meth(self): pass\n```\n\n----------------------------------------\n\nTITLE: Overriding Statically Typed Methods with Dynamically Typed Methods - Python\nDESCRIPTION: Shows that a subclass can override a statically typed method without type annotations, resulting in unchecked dynamic typing for the override. Illustrates a potential runtime bug undetected by mypy, emphasizing risks of omitting type hints.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/class_basics.rst#2025-04-22_snippet_12\n\nLANGUAGE: python\nCODE:\n```\nclass Base:\n    def inc(self, x: int) -> int:\n        return x + 1\n\nclass Derived(Base):\n    def inc(self, x):   # Override, dynamically typed\n        return 'hello'  # Incompatible with 'Base', but no mypy error\n```\n\n----------------------------------------\n\nTITLE: Handling Generic Standard Library Classes in Annotations and Inheritance - Python\nDESCRIPTION: This sequence of examples shows solutions for subscripting classes that are generic in type stubs but not at runtime (e.g., queue.Queue before Python 3.9). Demonstrates that using generics in annotations is safe with string literals or __future__ import, but subclassing requires TYPE_CHECKING tricks. Includes a pattern for subclassing such generics and keeping Mypy type info without runtime errors, including for user-defined generics. Dependencies: typing module and Python version awareness (3.8/3.9 compatibility as a constraint).\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/runtime_troubles.rst#2025-04-22_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nfrom queue import Queue\n\nclass Tasks(Queue[str]):  # TypeError: 'type' object is not subscriptable\n    ...\n\nresults: Queue[int] = Queue()  # TypeError: 'type' object is not subscriptable\n```\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import TYPE_CHECKING\nfrom queue import Queue\n\nif TYPE_CHECKING:\n    BaseQueue = Queue[str]  # this is only processed by mypy\nelse:\n    BaseQueue = Queue  # this is not seen by mypy but will be executed at runtime\n\nclass Tasks(BaseQueue):  # OK\n    ...\n\ntask_queue: Tasks\nreveal_type(task_queue.get())  # Reveals str\n```\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import TYPE_CHECKING, TypeVar, Generic\nfrom queue import Queue\n\n_T = TypeVar(\"_T\")\nif TYPE_CHECKING:\n    class _MyQueueBase(Queue[_T]): pass\nelse:\n    class _MyQueueBase(Generic[_T], Queue): pass\n\nclass MyQueue(_MyQueueBase[_T]): pass\n\ntask_queue: MyQueue[str]\nreveal_type(task_queue.get())  # Reveals str\n```\n\n----------------------------------------\n\nTITLE: Defining AsyncIterable Protocol with __aiter__ (Python)\nDESCRIPTION: Defines the __aiter__ method for collections.abc.AsyncIterable. Makes a type usable in async for loops. Returns an AsyncIterator over T.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/protocols.rst#2025-04-22_snippet_26\n\nLANGUAGE: python\nCODE:\n```\ndef __aiter__(self) -> AsyncIterator[T]\n\n```\n\n----------------------------------------\n\nTITLE: Legacy Syntax for Type Aliases in Python 3.11 and Earlier\nDESCRIPTION: Demonstrates the legacy syntax for importing and using type aliases, including their use as base classes and for instance creation. Shows differences in behavior compared to the new syntax.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/generics.rst#2025-04-22_snippet_55\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import TypeVar, Generic, Optional\nfrom example1 import AliasType\nfrom example2 import Vec\n\n# AliasType and Vec are type aliases (Vec as defined above)\n\ndef fun() -> AliasType:\n    ...\n\nOIntVec = Optional[Vec[int]]\n\nT = TypeVar('T')\n\n# Old-style type aliases can be used as base classes and you can\n# construct instances using them\n\nclass NewVec(Vec[T]):\n    ...\n\nx = AliasType()\n\nfor i, j in NewVec[int]():\n    ...\n```\n\n----------------------------------------\n\nTITLE: Mypy Error on Assigning to Final Enum Attribute in Python\nDESCRIPTION: This code demonstrates that Mypy considers Enum members (like `Direction.up`) as final attributes and reports an error if there's an attempt to reassign them.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/literal_types.rst#2025-04-22_snippet_21\n\nLANGUAGE: python\nCODE:\n```\nDirection.up = '^'  # E: Cannot assign to final attribute \"up\"\n```\n\n----------------------------------------\n\nTITLE: Silencing Specific Mypy Errors with type: ignore\nDESCRIPTION: Example showing how to properly use '# type: ignore' to silence specific mypy errors, which causes the name to get an implicit Any type.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/common_issues.rst#2025-04-22_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nimport frobnicate  # type: ignore\nfrobnicate.start()  # Okay!\n```\n\n----------------------------------------\n\nTITLE: Constructing Boolean Values with Python Built-in Functions and Literals - Python\nDESCRIPTION: Demonstrates how to construct boolean values using the built-in literals True, False, and the bool() function. These methods provide the foundational approach for working with boolean types in Python. Inputs may be any object (for bool(obj)), returning True if the object is truthy and False otherwise.\nSOURCE: https://github.com/python/mypy/blob/master/mypyc/doc/bool_operations.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nTrue\nFalse\nbool(obj)\n\n```\n\n----------------------------------------\n\nTITLE: Enabling Fine-Grained Caching in Mypy (Shell)\nDESCRIPTION: This command runs mypy with the `--cache-fine-grained` option. This flag adds extra dependency information to the cache files, which is necessary for the mypy daemon to utilize caching effectively. This is typically used during a CI build process to generate the cache.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/additional_features.rst#2025-04-22_snippet_8\n\nLANGUAGE: shell\nCODE:\n```\n$ mypy --cache-fine-grained <args...>\n```\n\n----------------------------------------\n\nTITLE: Dictionary Statements in Python\nDESCRIPTION: Common dictionary statements for assignment and iteration.\nSOURCE: https://github.com/python/mypy/blob/master/mypyc/doc/dict_operations.rst#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nd[key] = value\nfor key in d:\n```\n\n----------------------------------------\n\nTITLE: Install System Libraries for Coverage XML Reports - Shell\nDESCRIPTION: Indicates the necessary system-level packages to be installed in order to use coverage reporting features that rely on lxml. Required for environments where native extension modules need to be present.\nSOURCE: https://github.com/python/mypy/blob/master/test-data/unit/README.md#2025-04-22_snippet_15\n\nLANGUAGE: shell\nCODE:\n```\napt-get install python3-dev libxml2-dev libxslt1-dev\n```\n\n----------------------------------------\n\nTITLE: Installing mypy-extensions for Trait Support (Shell)\nDESCRIPTION: This shell command uses `pip` to install or upgrade the `mypy-extensions` package. This package is a prerequisite for defining and using trait types (`@trait`) with mypyc, which allow a form of multiple inheritance for native classes.\nSOURCE: https://github.com/python/mypy/blob/master/mypyc/doc/using_type_annotations.rst#2025-04-22_snippet_4\n\nLANGUAGE: text\nCODE:\n```\npip install --upgrade mypy-extensions\n```\n\n----------------------------------------\n\nTITLE: Configuring mypy Plugin Entry Point - INI\nDESCRIPTION: Explains how to specify a custom entry point function (other than the standard 'plugin') in the plugins option of the mypy configuration file by using a colon separator. This lets mypy load plugins with non-default setup functions. Dependencies: The specified Python file/module must define the named entry point.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/extending_mypy.rst#2025-04-22_snippet_2\n\nLANGUAGE: ini\nCODE:\n```\n[mypy]\nplugins = custom_plugin:custom_entry_point\n\n```\n\n----------------------------------------\n\nTITLE: Run Type Checker Manually via PYTHONPATH - Shell\nDESCRIPTION: Temporarily updates the PYTHONPATH to include the current project directory and runs mypy as a module to type check a Python file. This manual procedure is useful during isolated development or testing sessions outside automated test runners.\nSOURCE: https://github.com/python/mypy/blob/master/test-data/unit/README.md#2025-04-22_snippet_7\n\nLANGUAGE: shell\nCODE:\n```\nexport PYTHONPATH=$PWD\\npython3 -m mypy PROGRAM.py\n```\n\n----------------------------------------\n\nTITLE: Constructing Lists Native Python\nDESCRIPTION: Demonstrates the various ways to construct lists in Python, including with specific items, empty lists, and from iterables. Key methods include using square brackets and the list() constructor.\nSOURCE: https://github.com/python/mypy/blob/master/mypyc/doc/list_operations.rst#2025-04-22_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\n[item0, ..., itemN]\n```\n\nLANGUAGE: Python\nCODE:\n```\n[]\n```\n\nLANGUAGE: Python\nCODE:\n```\nlist()\n```\n\nLANGUAGE: Python\nCODE:\n```\nlist(x: Iterable)\n```\n\n----------------------------------------\n\nTITLE: Running Mypy in Daemon Mode for Incremental Checking in Bash\nDESCRIPTION: This command starts or utilizes the Mypy daemon (`dmypy`) to perform type checking on the specified `PROGRAM`. Daemon mode keeps Mypy running in the background, significantly speeding up subsequent checks on large codebases by only re-analyzing changed files. `PROGRAM` should be replaced with the path(s) to the Python file(s) or directories.\nSOURCE: https://github.com/python/mypy/blob/master/README.md#2025-04-22_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\n```bash\ndmypy run -- PROGRAM\n```\n```\n\n----------------------------------------\n\nTITLE: Example of Variadic Generic Type Notation - Python\nDESCRIPTION: An example demonstrating type annotations with a hypothetical variadic generic type Vector using two or three type parameters. This illustrates the context in which a mypy plugin might need to supply custom type analysis for library types that aren't natively supported by PEP 484. No code execution occurs; real use requires a mypy plugin to support variadic generics.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/extending_mypy.rst#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom lib import Vector\n\na: Vector[int, int]\nb: Vector[int, int, int]\n\n```\n\n----------------------------------------\n\nTITLE: ClassVar Defaulting to Any Type Without Brackets - Python\nDESCRIPTION: Illustrates that using ClassVar without a type parameter causes the variable to be implicitly of type Any, which may lead to unintended behaviors in type checking. This is a mypy-specific caveat and may change in future releases.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/class_basics.rst#2025-04-22_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nclass A:\n    y: ClassVar = 0  # Type implicitly Any!\n```\n\n----------------------------------------\n\nTITLE: Using Operators with Frozenset in Python\nDESCRIPTION: Shows how to check membership within a frozenset using the 'in' operator. This operation requires a frozenset and the element to be checked, returning a boolean indicating presence.\nSOURCE: https://github.com/python/mypy/blob/master/mypyc/doc/frozenset_operations.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nitem in s\n```\n\n----------------------------------------\n\nTITLE: Creating a Python Set using Set Comprehension with a Filter\nDESCRIPTION: Shows the syntax for creating a Python set using a set comprehension that includes a conditional filter (`if` clause). Only elements satisfying the condition are included in the resulting set.\nSOURCE: https://github.com/python/mypy/blob/master/mypyc/doc/set_operations.rst#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n{... for ... in ... if ...}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Re-exporting Import Using `__all__` with `implicit_reexport=False` in Mypy (Python)\nDESCRIPTION: This Python code demonstrates another method to explicitly re-export an imported name when Mypy's `implicit_reexport` option is `False`. By including the imported name `'bar'` in the module's `__all__` list, it becomes part of the public API and can be imported by other modules.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/config_file.rst#2025-04-22_snippet_12\n\nLANGUAGE: python\nCODE:\n```\n# This will also re-export bar\nfrom foo import bar\n__all__ = ['bar']\n```\n\n----------------------------------------\n\nTITLE: Native Integer Type Inference in for Loop Range\nDESCRIPTION: Demonstrates the type inference mechanism in Mypyc for loop variables when using a for loop with a range constructed from a native integer type.\nSOURCE: https://github.com/python/mypy/blob/master/mypyc/doc/int_operations.rst#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfor x in range(i64(n)):\n    # Type of \"x\" is \"i64\"\n    ...\n```\n\n----------------------------------------\n\nTITLE: Invoking Stubgen with Module/Package Names\nDESCRIPTION: Illustrates running `stubgen` using the `-m` (module) and `-p` (package) flags to specify targets by their importable names. `-m` processes only the specified module, while `-p` processes the package and its submodules recursively.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/stubgen.rst#2025-04-22_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n$ stubgen -m foo -m bar -p my_pkg_dir\n```\n\n----------------------------------------\n\nTITLE: Defining a Trait Type using mypy_extensions (Python)\nDESCRIPTION: This Python snippet illustrates how to define a trait using the `@trait` decorator provided by the `mypy_extensions` library. Traits enable a form of multiple inheritance for native classes compiled with mypyc. The example defines `MyTrait` with an abstract `method`. Classes inheriting from this trait would need to implement `method`.\nSOURCE: https://github.com/python/mypy/blob/master/mypyc/doc/using_type_annotations.rst#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom mypy_extensions import trait\n\n@trait\nclass MyTrait:\n    def method(self) -> None:\n        ...\n```\n\n----------------------------------------\n\nTITLE: Unreachable Code After return Statement - Python\nDESCRIPTION: This snippet illustrates that code after a return statement is considered unreachable by mypy, so type errors are not reported in that section. It demonstrates with a mistyped assignment after return. No dependencies; used for understanding type checker limitations.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/common_issues.rst#2025-04-22_snippet_27\n\nLANGUAGE: python\nCODE:\n```\nclass Foo:\\n    bar: str = ''\\n\\ndef bar() -> None:\\n    foo: Foo = Foo()\\n    return\\n    x: int = 'abc'  # Unreachable -- no error\n```\n\n----------------------------------------\n\nTITLE: Dictionary Functions in Python\nDESCRIPTION: Built-in functions that operate on dictionaries.\nSOURCE: https://github.com/python/mypy/blob/master/mypyc/doc/dict_operations.rst#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nlen(d: dict)\n```\n\n----------------------------------------\n\nTITLE: Module Override Configuration Example in TOML\nDESCRIPTION: Example showing how to specify module-specific overrides in a pyproject.toml file for Mypy configuration.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/config_file.rst#2025-04-22_snippet_13\n\nLANGUAGE: toml\nCODE:\n```\n[[tool.mypy.overrides]]\nmodule = 'packagename'\n...\n```\n\n----------------------------------------\n\nTITLE: Corrected Enum Exhaustiveness Checking in Python with Mypy\nDESCRIPTION: Example showing how to fix the missing enum value error by handling all possible enum values, demonstrating Mypy's improved exhaustiveness checking.\nSOURCE: https://github.com/python/mypy/blob/master/CHANGELOG.md#2025-04-22_snippet_39\n\nLANGUAGE: python\nCODE:\n```\ndef example(e: MyEnum) -> str:  # No error -- all values covered\n    if e == MyEnum.A:\n        return 'x'\n    elif e == MyEnum.B:\n        return 'y'\n    elif e == MyEnum.C:\n        return 'z'\n```\n\n----------------------------------------\n\nTITLE: Optimized String Formatting Expressions in Python\nDESCRIPTION: Highlights common string formatting techniques in Python that are optimized for performance. This includes f-strings (formatted string literals), the `str.format()` method, and the older modulo (`%`) operator for C-style formatting.\nSOURCE: https://github.com/python/mypy/blob/master/mypyc/doc/str_operations.rst#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nF-strings\n```\n\nLANGUAGE: python\nCODE:\n```\n\"...\\\".format(...)\n```\n\nLANGUAGE: python\nCODE:\n```\n\"\\\"...\\\" % (...)\n```\n\n----------------------------------------\n\nTITLE: Equivalent Definition with Keyword-Only Arguments\nDESCRIPTION: Alternative function definition showing how using Unpack[TypedDict] is equivalent to defining functions with explicit keyword-only arguments, providing the same type checking behavior.\nSOURCE: https://github.com/python/mypy/blob/master/CHANGELOG.md#2025-04-22_snippet_27\n\nLANGUAGE: python\nCODE:\n```\ndef foo(*, name: str, age: int) -> None:\n    ...\n```\n\n----------------------------------------\n\nTITLE: Starting Mypy Daemon with Fine-Grained Cache (Shell)\nDESCRIPTION: This command starts the mypy daemon (`dmypy start`) instructing it to use the previously generated fine-grained cache data via the `--use-fine-grained-cache` flag (passed after `--`). This allows subsequent `dmypy check` runs to potentially be much faster by leveraging the detailed cache.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/additional_features.rst#2025-04-22_snippet_9\n\nLANGUAGE: shell\nCODE:\n```\n$ dmypy start -- --use-fine-grained-cache <options...>\n```\n\n----------------------------------------\n\nTITLE: Operator Use Checks in Mypy\nDESCRIPTION: Illustrates error diagnostics when operands used in binary or unary operations, such as addition, are incompatible according to Mypy type checking.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/error_code_list.rst#2025-04-22_snippet_17\n\nLANGUAGE: python\nCODE:\n```\n# Error: Unsupported operand types for + (\"int\" and \"str\")  [operator]\n1 + 'x'\n```\n\n----------------------------------------\n\nTITLE: Debug Tests with Interactive Debuggers - Shell\nDESCRIPTION: Shows how to invoke pytest with flags for single-process execution and post-failure entry into pdb for interactive, step-by-step debugging of test code.\nSOURCE: https://github.com/python/mypy/blob/master/test-data/unit/README.md#2025-04-22_snippet_13\n\nLANGUAGE: shell\nCODE:\n```\npytest -n0 --pdb -k MethodCall\n```\n\n----------------------------------------\n\nTITLE: Removing an Item from a Python Set (Raises Error)\nDESCRIPTION: Shows the `remove()` method, which removes a specified `item` from a Python set `s`. It raises a `KeyError` if the `item` is not found in the set.\nSOURCE: https://github.com/python/mypy/blob/master/mypyc/doc/set_operations.rst#2025-04-22_snippet_7\n\nLANGUAGE: python\nCODE:\n```\ns.remove(item)\n```\n\n----------------------------------------\n\nTITLE: Dataclass Decorator Alias Limitation in mypy\nDESCRIPTION: Demonstrates a known limitation where mypy doesn't recognize aliases of dataclass decorators or dynamically computed decorators for dataclass detection.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/additional_features.rst#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom dataclasses import dataclass\n\ndataclass_alias = dataclass\ndef dataclass_wrapper(cls):\n  return dataclass(cls)\n\n@dataclass_alias\nclass AliasDecorated:\n  \"\"\"\n  Mypy doesn't recognize this as a dataclass because it is decorated by an\n  alias of `dataclass` rather than by `dataclass` itself.\n  \"\"\"\n  attribute: int\n\nAliasDecorated(attribute=1) # error: Unexpected keyword argument\n```\n\n----------------------------------------\n\nTITLE: Running Mypy Daemon with Flags and Files\nDESCRIPTION: Initiates the Mypy daemon to type-check specified files or directories using the 'dmypy run' command. It supports arbitrary Mypy flags for customized configuration. Designed to accelerate type-checking in large codebases by maintaining a persistent server.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/mypy_daemon.rst#2025-04-22_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\ndmypy run -- prog.py pkg/*.py\n```\n\n----------------------------------------\n\nTITLE: Run All Tests with runtests.py - Shell\nDESCRIPTION: Runs the full testing pipeline, including type checking, all test suites, and linting, using the consolidated 'runtests.py' script. Arguments allow selective execution (e.g., self-checks, extra mypyc tests).\nSOURCE: https://github.com/python/mypy/blob/master/test-data/unit/README.md#2025-04-22_snippet_11\n\nLANGUAGE: shell\nCODE:\n```\npython3 runtests.py\n```\n\nLANGUAGE: shell\nCODE:\n```\npython3 runtests.py self\n```\n\nLANGUAGE: shell\nCODE:\n```\npython3 runtests.py mypyc-extra\n```\n\n----------------------------------------\n\nTITLE: Optimizing Python String Concatenation\nDESCRIPTION: Demonstrates a scenario for optimizing string concatenation in Python. Two consecutive concatenations like `a + ':' + b` could be replaced by a single, more efficient three-operand concatenation, avoiding the construction of an intermediate string object resulting from the first addition.\nSOURCE: https://github.com/python/mypy/blob/master/mypyc/doc/future.md#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\na + ':' + b\n```\n\n----------------------------------------\n\nTITLE: Building Docker Container with Root Privileges (Shell)\nDESCRIPTION: Runs the `build.py` script using `sudo` to build the Docker container with root privileges. This may be required if the standard user lacks sufficient permissions to interact with the Docker daemon.\nSOURCE: https://github.com/python/mypy/blob/master/misc/docker/README.md#2025-04-22_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\n$ sudo python3 misc/docker/build.py\n```\n\n----------------------------------------\n\nTITLE: Function Boolean Context Check in Python\nDESCRIPTION: Shows how Mypy catches incorrect usage of functions in boolean contexts since functions always evaluate to true.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/error_code_list.rst#2025-04-22_snippet_36\n\nLANGUAGE: python\nCODE:\n```\ndef f():\n    ...\n\nif f:  # Error: Function \"Callable[[], Any]\" could always be true in boolean context  [truthy-function]\n    pass\n```\n\n----------------------------------------\n\nTITLE: Disabling 'import-untyped' Error Code Globally (INI)\nDESCRIPTION: This mypy.ini configuration disables the 'import-untyped' error code for all modules analyzed by mypy. By setting 'disable_error_code = import-untyped' in the general '[mypy]' section, all errors related to untyped imports are suppressed, reducing noise in type-checking output for large projects depending on untyped libraries.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/running_mypy.rst#2025-04-22_snippet_14\n\nLANGUAGE: ini\nCODE:\n```\n[mypy]\\ndisable_error_code = import-untyped\n```\n\n----------------------------------------\n\nTITLE: Illustrating Mypy Error Reporting for Mixed Parameter Annotations in Python\nDESCRIPTION: This Python function definition demonstrates a scenario where Mypy would report an error because it mixes an annotated parameter (`a: int`) with an unannotated parameter (`b`). This is mentioned as an example in the introductory text.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/config_file.rst#2025-04-22_snippet_6\n\nLANGUAGE: python\nCODE:\n```\ndef f(a: int, b)\n```\n\n----------------------------------------\n\nTITLE: Updating a Python Set with an Iterable\nDESCRIPTION: Illustrates the `update()` method, which adds all elements from a given iterable `x` to the set `s`. Duplicate elements are automatically handled (ignored).\nSOURCE: https://github.com/python/mypy/blob/master/mypyc/doc/set_operations.rst#2025-04-22_snippet_9\n\nLANGUAGE: python\nCODE:\n```\ns.update(x: Iterable)\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Variable Definition Check in Python\nDESCRIPTION: Shows how Mypy detects variables used before definition, which now generates an error by default.\nSOURCE: https://github.com/python/mypy/blob/master/CHANGELOG.md#2025-04-22_snippet_48\n\nLANGUAGE: python\nCODE:\n```\ny = x  # E: Name \"x\" is used before definition [used-before-def]\nx = 0\n```\n\n----------------------------------------\n\nTITLE: Detecting Possibly Undefined Variables in Python\nDESCRIPTION: Demonstrates the new experimental possibly-undefined error code that detects variables that may be undefined in certain code paths.\nSOURCE: https://github.com/python/mypy/blob/master/CHANGELOG.md#2025-04-22_snippet_49\n\nLANGUAGE: python\nCODE:\n```\n    if b:\n        x = 0\n    print(x)  # Error: Name \"x\" may be undefined [possibly-undefined]\n```\n\n----------------------------------------\n\nTITLE: Type Checking functools.partial Usage in Python\nDESCRIPTION: Demonstration of Mypy's new ability to type check uses of functools.partial, detecting incompatible argument types.\nSOURCE: https://github.com/python/mypy/blob/master/CHANGELOG.md#2025-04-22_snippet_15\n\nLANGUAGE: Python\nCODE:\n```\nfrom functools import partial\n\ndef f(a: int, b: str) -> None: ...\n\ng = partial(f, 1)\n\n# Argument has incompatible type \"int\"; expected \"str\"\ng(11)\n```\n\n----------------------------------------\n\nTITLE: Generate Test Coverage Reports with pytest-cov - Shell\nDESCRIPTION: Runs the test suite with coverage measurement enabled, outputting both a terminal and HTML coverage report for the 'mypy' package using pytest-cov. The '--cov-config' and '--cov-report' flags control coverage settings and report formats.\nSOURCE: https://github.com/python/mypy/blob/master/test-data/unit/README.md#2025-04-22_snippet_12\n\nLANGUAGE: shell\nCODE:\n```\npython3 -m pytest --cov mypy --cov-config setup.cfg  --cov-report=term-missing:skip-covered --cov-report=html\n```\n\n----------------------------------------\n\nTITLE: Mypy Error on Incorrect Enum Mixin Types in Python\nDESCRIPTION: This code illustrates Mypy checking for correct Enum base classes. It reports an error if an Enum subclass tries to mix in more than one data type (like `str` and `int`).\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/literal_types.rst#2025-04-22_snippet_23\n\nLANGUAGE: python\nCODE:\n```\nclass WrongEnum(str, int, enum.Enum):\n    # E: Only a single data type mixin is allowed for Enum subtypes, found extra \"int\"\n    ...\n```\n\n----------------------------------------\n\nTITLE: Callable Type Inference in Mypy\nDESCRIPTION: Explains callable type inference using callable, illustrating how MyPy deals with callable types in type check scenarios.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/type_narrowing.rst#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom collections.abc import Callable\n\nx: Callable[[], int]\n\nif callable(x):\n    reveal_type(x)  # N: Revealed type is \"def () -> builtins.int\"\nelse:\n    ...  # Will never be executed and will raise error with `--warn-unreachable`\n\nx: int | Callable[[], int]\n\nif callable(x):\n    reveal_type(x)  # N: Revealed type is \"def () -> builtins.int\"\nelse:\n    reveal_type(x)  # N: Revealed type is \"builtins.int\"\n```\n\n----------------------------------------\n\nTITLE: Excluding Packages from disallow_untyped_calls in mypy INI Config - INI\nDESCRIPTION: Illustrates how to use the 'untyped_calls_exclude' option in mypy INI configuration to globally exclude specific packages (like 'some.library') from the effect of 'disallow_untyped_calls'. Useful for disabling checks on untyped calls originating from specified modules across the entire codebase.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/config_file.rst#2025-04-22_snippet_5\n\nLANGUAGE: INI\nCODE:\n```\n[mypy]\ndisallow_untyped_calls = True\nuntyped_calls_exclude = some.library\n```\n\n----------------------------------------\n\nTITLE: Running Specific Tests for Mypy in Python\nDESCRIPTION: Various commands to run specific tests or checks in the Mypy project, including self-checking, running individual tests, and linting.\nSOURCE: https://github.com/python/mypy/blob/master/CONTRIBUTING.md#2025-04-22_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\n# Use mypy to check mypy's own code\npython runtests.py self\n# or equivalently:\npython -m mypy --config-file mypy_self_check.ini -p mypy\n\n# Run a single test from the test suite\npytest -n0 -k 'test_name'\n\n# Run all test cases in the \"test-data/unit/check-dataclasses.test\" file\npytest mypy/test/testcheck.py::TypeCheckSuite::check-dataclasses.test\n\n# Run the formatters and linters\npython runtests.py lint\n```\n\n----------------------------------------\n\nTITLE: Installing Xcode Command Line Tools on macOS (Shell)\nDESCRIPTION: Command to install necessary C development tools via Xcode command line tools on macOS, required for building Python C extensions used by mypyc. This is a prerequisite for using mypyc on macOS.\nSOURCE: https://github.com/python/mypy/blob/master/mypyc/doc/getting_started.rst#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n$ xcode-select --install\n```\n\n----------------------------------------\n\nTITLE: Installing Missing Type Stubs Automatically with mypy (Text)\nDESCRIPTION: This command-line text shows how to invoke mypy with the '--install-types' flag. Doing so instructs mypy to detect and install all missing type stub packages before performing type checking, automating one aspect of the development workflow. This approach is useful when you want mypy to handle stub management, though it may be slower than installing stubs ahead of time.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/running_mypy.rst#2025-04-22_snippet_17\n\nLANGUAGE: text\nCODE:\n```\nmypy --install-types\n```\n\n----------------------------------------\n\nTITLE: Using 'is' Operator for Fast Object Identity Checks - Python\nDESCRIPTION: Demonstrates use of the 'is' operator in Python to compare object identities. No external dependencies required. Accepts two objects 'x' and 'y' and outputs a boolean indicating identity; optimized in mypyc for performance.\nSOURCE: https://github.com/python/mypy/blob/master/mypyc/doc/native_operations.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nx is y\n```\n\n----------------------------------------\n\nTITLE: MANIFEST.in for Including Type Information in Source Distribution\nDESCRIPTION: Example MANIFEST.in file to ensure inclusion of .pyi and .typed files in the sdist archive.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/installed_packages.rst#2025-04-22_snippet_6\n\nLANGUAGE: text\nCODE:\n```\nglobal-include *.pyi\nglobal-include *.typed\n```\n\n----------------------------------------\n\nTITLE: Running Tests and Commands with Tox\nDESCRIPTION: Commands to use Tox for running tests and other commands in the Mypy project, including running tests with specific Python versions and setting up development environments.\nSOURCE: https://github.com/python/mypy/blob/master/CONTRIBUTING.md#2025-04-22_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\n# Run tests\ntox run -e py\n\n# Run tests using some specific Python version\ntox run -e py311\n\n# Run a specific command\ntox run -e lint\n\n# Run a single test from the test suite\ntox run -e py -- -n0 -k 'test_name'\n\n# Run all test cases in the \"test-data/unit/check-dataclasses.test\" file using\n# Python 3.11 specifically\ntox run -e py311 -- mypy/test/testcheck.py::TypeCheckSuite::check-dataclasses.test\n\n# Set up a development environment with all the project libraries and run a command\ntox -e dev -- mypy --verbose test_case.py\ntox -e dev --override testenv:dev.allowlist_externals+=env -- env  # inspect the environment\n```\n\n----------------------------------------\n\nTITLE: Constructing an Empty Python Set\nDESCRIPTION: Shows how to create an empty set using the `set()` constructor. It is important to use `set()` instead of `{}` for an empty set, as `{}` creates an empty dictionary.\nSOURCE: https://github.com/python/mypy/blob/master/mypyc/doc/set_operations.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nset()\n```\n\n----------------------------------------\n\nTITLE: List Statements in Python\nDESCRIPTION: Explains how to perform item assignment by index and iteration over lists using for loops, critical for manipulating list items directly.\nSOURCE: https://github.com/python/mypy/blob/master/mypyc/doc/list_operations.rst#2025-04-22_snippet_3\n\nLANGUAGE: Python\nCODE:\n```\nlst[n] = x\n```\n\nLANGUAGE: Python\nCODE:\n```\nfor item in lst:\n```\n\n----------------------------------------\n\nTITLE: Improved Type Inference for Unions in Python\nDESCRIPTION: Demonstration of Mypy's enhanced type inference capabilities, now inferring more precise union types in certain contexts.\nSOURCE: https://github.com/python/mypy/blob/master/CHANGELOG.md#2025-04-22_snippet_17\n\nLANGUAGE: Python\nCODE:\n```\nfor x in (1, 'x'):\n    # Previously inferred as 'object'\n    reveal_type(x)  # Revealed type is 'int | str'\n```\n\n----------------------------------------\n\nTITLE: Building Mypy HTML Documentation\nDESCRIPTION: Builds the HTML documentation using Sphinx. The output will be placed in the docs/build directory.\nSOURCE: https://github.com/python/mypy/blob/master/docs/README.md#2025-04-22_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\nmake html\n```\n\n----------------------------------------\n\nTITLE: Mypy Error on Incorrect Enum Base Class Order in Python\nDESCRIPTION: This example shows Mypy reporting an error when `enum.Enum` is not the last base class in the inheritance list when mixins are used.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/literal_types.rst#2025-04-22_snippet_24\n\nLANGUAGE: python\nCODE:\n```\nclass MixinAfterEnum(enum.Enum, Mixin): # E: No base classes are allowed after \"enum.Enum\"\n    ...\n```\n\n----------------------------------------\n\nTITLE: Using Type Guards with Parameters in Mypy\nDESCRIPTION: Shows how type guard functions can take extra parameters, providing more flexibility in type narrowing in Python 3.12.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/type_narrowing.rst#2025-04-22_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import TypeGuard  # use `typing_extensions` for `python<3.10`\ndef is_set_of[T](val: set[Any], type: type[T]) -> TypeGuard[set[T]]:\n    return all(isinstance(x, type) for x in val)\n\nitems: set[Any]\nif is_set_of(items, str):\n    reveal_type(items)  # set[str]\n```\n\n----------------------------------------\n\nTITLE: Inverting Mypy Boolean Inline Configuration Flags in Python\nDESCRIPTION: This snippet demonstrates two ways to invert the meaning of boolean Mypy flags in inline configuration. The `allow-untyped-defs` flag explicitly permits untyped definitions (the inverse of `disallow-untyped-defs`). The `no-strict-optional` flag disables the `strict-optional` check, achieving the same effect as setting `strict-optional = False`.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/inline_config.rst#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n# mypy: allow-untyped-defs, no-strict-optional\n```\n\n----------------------------------------\n\nTITLE: Running Full Test Suite for Mypy in Python\nDESCRIPTION: Command to run the complete test suite for the Mypy project.\nSOURCE: https://github.com/python/mypy/blob/master/CONTRIBUTING.md#2025-04-22_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\npython runtests.py\n```\n\n----------------------------------------\n\nTITLE: Typing Asynchronous Functions in Python with asyncio\nDESCRIPTION: Demonstrates how to type annotate a coroutine function using async/await. The function takes a string tag and integer count, and returns a string after completion.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/cheat_sheet_py3.rst#2025-04-22_snippet_12\n\nLANGUAGE: python\nCODE:\n```\nimport asyncio\n\n# A coroutine is typed like a normal function\nasync def countdown(tag: str, count: int) -> str:\n    while count > 0:\n        print(f'T-minus {count} ({tag})')\n        await asyncio.sleep(0.1)\n        count -= 1\n    return \"Blastoff!\"\n```\n\n----------------------------------------\n\nTITLE: Attribute Access Timing\nDESCRIPTION: Object attribute access takes 30-40 nanoseconds\nSOURCE: https://github.com/python/mypy/blob/master/mypyc/doc/cpython-timings.md#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\no.x\n```\n\n----------------------------------------\n\nTITLE: Optimizing Python String Index Comparison\nDESCRIPTION: Illustrates a potential optimization for string index comparison in Python. Instead of creating an intermediate single-character string object for `s[i]`, the comparison `s[i] == 'x'` could be optimized to directly compare the character value at index `i` with the result of `ord('x')`.\nSOURCE: https://github.com/python/mypy/blob/master/mypyc/doc/future.md#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ns[i] == 'x'\n```\n\n----------------------------------------\n\nTITLE: Setup Script for Package with Mixed Stub and Runtime Files\nDESCRIPTION: Example setup.py file for a package with mixed stub and runtime files, including both py.typed and lib.pyi in package_data.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/installed_packages.rst#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom setuptools import setup\n\nsetup(\n    name=\"SuperPackageB\",\n    author=\"Me\",\n    version=\"0.1\",\n    package_data={\"package_b\": [\"py.typed\", \"lib.pyi\"]},\n    packages=[\"package_b\"]\n)\n```\n\n----------------------------------------\n\nTITLE: Installing typing_extensions for TypedDict Support - Text\nDESCRIPTION: Explains how to install the 'typing_extensions' package using pip, which is necessary to use TypedDict on Python versions prior to 3.8. This example is a shell command for the terminal, not Python code.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/typed_dict.rst#2025-04-22_snippet_6\n\nLANGUAGE: text\nCODE:\n```\npython3 -m pip install --upgrade typing-extensions\n```\n\n----------------------------------------\n\nTITLE: Demonstrating await-not-async Error in Python Coroutines\nDESCRIPTION: Shows incorrect usage of await outside an async function, which raises a type error in Mypy.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/error_code_list.rst#2025-04-22_snippet_34\n\nLANGUAGE: python\nCODE:\n```\nasync def f() -> None:\n    ...\n\ndef g() -> None:\n    await f()  # Error: \"await\" outside coroutine (\"async def\")  [await-not-async]\n```\n\n----------------------------------------\n\nTITLE: Installing Test Requirements and Project in Python\nDESCRIPTION: Commands to install test requirements and the Mypy project in development mode.\nSOURCE: https://github.com/python/mypy/blob/master/CONTRIBUTING.md#2025-04-22_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\npython -m pip install -r test-requirements.txt\npython -m pip install -e .\nhash -r  # This resets shell PATH cache, not necessary on Windows\n```\n\n----------------------------------------\n\nTITLE: Implicit and Explicit Conversion from Native Integer to Standard int\nDESCRIPTION: Illustrates the conversion from a native integer type `i64` to a standard Python `int`, showing both implicit and explicit methods.\nSOURCE: https://github.com/python/mypy/blob/master/mypyc/doc/int_operations.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ndef implicit(x: i64) -> int:\n    # Implicit conversion from i64 to int\n    return x\n\ndef explicit(x: i64) -> int:\n    # Explicit conversion from i64 to int\n    return int(x)\n```\n\n----------------------------------------\n\nTITLE: Efficient Loop Statements over Sequences and Iterators - Python\nDESCRIPTION: Covers custom native implementations of for-loops over sequences, enumerate, and zip in Python. No dependencies other than valid sequences. Accepts any iterable sequence and yields elements; enhances performance versus generic fallback.\nSOURCE: https://github.com/python/mypy/blob/master/mypyc/doc/native_operations.rst#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfor ... in seq:\n```\n\nLANGUAGE: python\nCODE:\n```\nfor ... in enumerate(...):\n```\n\nLANGUAGE: python\nCODE:\n```\nfor ... in zip(...):\n```\n\n----------------------------------------\n\nTITLE: Running a Compiled Python Module\nDESCRIPTION: Command for running a Python module that has been compiled to a C extension. Since compiled modules can't be run directly, this uses the Python interpreter to import and run the module.\nSOURCE: https://github.com/python/mypy/blob/master/mypyc/doc/dev-intro.md#2025-04-22_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n$ python3 -c \"import program\"\n```\n\n----------------------------------------\n\nTITLE: Installing Mypy 1.7 using pip\nDESCRIPTION: Command to install or upgrade to the latest Mypy 1.7 release from the Python Package Index (PyPI).\nSOURCE: https://github.com/python/mypy/blob/master/CHANGELOG.md#2025-04-22_snippet_25\n\nLANGUAGE: bash\nCODE:\n```\npython3 -m pip install -U mypy\n```\n\n----------------------------------------\n\nTITLE: Importing Utility Types for Type Checking in Python\nDESCRIPTION: This snippet demonstrates importing types from the _typeshed package for use in type annotations in .py files, making them available only for type checking purposes. It requires Python's typing module and uses the TYPE_CHECKING constant to conditionally import these types.\nSOURCE: https://github.com/python/mypy/blob/master/mypy/typeshed/stdlib/_typeshed/README.md#2025-04-22_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\nfrom typing import TYPE_CHECKING\n\nif TYPE_CHECKING:\n    from _typeshed import ...\n```\n\n----------------------------------------\n\nTITLE: Demonstrating how to handle unused-ignore with version-specific imports in Python with mypy\nDESCRIPTION: Shows how to use type ignores with version-specific imports, including the unused-ignore error code to support clean mypy runs on different Python versions.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/error_code_list2.rst#2025-04-22_snippet_18\n\nLANGUAGE: python\nCODE:\n```\n# Use \"mypy --warn-unused-ignores ...\"\n\nimport sys\n\ntry:\n    # The \"[unused-ignore]\" is needed to get a clean mypy run\n    # on both Python 3.8, and 3.9 where this module was added\n    import graphlib  # type: ignore[import,unused-ignore]\nexcept ImportError:\n    pass\n\nif sys.version_info >= (3, 9):\n    # The following will not generate an error on either\n    # Python 3.8, or Python 3.9\n    42 + \"testing...\"  # type: ignore\n```\n\n----------------------------------------\n\nTITLE: Compiling Mypyc Extensions In-Place using setup.py (Shell)\nDESCRIPTION: Command using `setup.py build_ext --inplace` to compile the C extensions specified via `mypycify` directly into the source directory alongside the original Python files. This is useful during development for testing compiled modules without needing a full package installation.\nSOURCE: https://github.com/python/mypy/blob/master/mypyc/doc/getting_started.rst#2025-04-22_snippet_11\n\nLANGUAGE: bash\nCODE:\n```\npython3 setup.py build_ext --inplace\n```\n\n----------------------------------------\n\nTITLE: Optimized String Operators in Python\nDESCRIPTION: Details the standard Python string operators that have optimized implementations. These include concatenation (`+`), indexing (`[]`), slicing (`[:]`), equality comparison (`==`, `!=`), augmented assignment (`+=`), and containment checking (`in`).\nSOURCE: https://github.com/python/mypy/blob/master/mypyc/doc/str_operations.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nConcatenation (s1 + s2)\n```\n\nLANGUAGE: python\nCODE:\n```\nIndexing (s[n])\n```\n\nLANGUAGE: python\nCODE:\n```\nSlicing (s[n:m], s[n:], s[:m])\n```\n\nLANGUAGE: python\nCODE:\n```\nComparisons (==, !=)\n```\n\nLANGUAGE: python\nCODE:\n```\nAugmented assignment (s1 += s2)\n```\n\nLANGUAGE: python\nCODE:\n```\nContainment (s1 in s2)\n```\n\n----------------------------------------\n\nTITLE: Class Instantiation Timing\nDESCRIPTION: Class instantiation with attribute initialization in __init__ takes 290-330 nanoseconds\nSOURCE: https://github.com/python/mypy/blob/master/mypyc/doc/cpython-timings.md#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nCls(1)\n```\n\n----------------------------------------\n\nTITLE: Final Value Usage Example\nDESCRIPTION: Demonstrates how Final values are handled in compiled code, showing early binding optimization.\nSOURCE: https://github.com/python/mypy/blob/master/mypyc/doc/differences_from_python.rst#2025-04-22_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nMAX: Final = 100\n\ndef limit_to_max(x: int) -> int:\n     if x > MAX:\n         return MAX\n     return x\n```\n\n----------------------------------------\n\nTITLE: Setup Script for Stub-Only Package\nDESCRIPTION: Example setup.py file for a stub-only package, including .pyi files in package_data.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/installed_packages.rst#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom setuptools import setup\n\nsetup(\n    name=\"SuperPackageC\",\n    author=\"Me\",\n    version=\"0.1\",\n    package_data={\"package_c-stubs\": [\"__init__.pyi\", \"lib.pyi\"]},\n    packages=[\"package_c-stubs\"]\n)\n```\n\n----------------------------------------\n\nTITLE: Demonstrating float subclass conversion in Mypyc\nDESCRIPTION: Example showing how Mypyc now implicitly converts float subclasses to float when assigning to a float-typed variable.\nSOURCE: https://github.com/python/mypy/blob/master/CHANGELOG.md#2025-04-22_snippet_44\n\nLANGUAGE: python\nCODE:\n```\nfrom lib import MyFloat  # MyFloat ia a subclass of \"float\"\n\ndef example() -> None:\n    x = MyFloat(1.5)\n    y: float = x  # Implicit conversion from MyFloat to float\n    print(type(y))  # float, not MyFloat\n```\n\n----------------------------------------\n\nTITLE: Installing Mypy 1.0 using pip\nDESCRIPTION: Command to install or upgrade Mypy to version 1.0 using pip package manager.\nSOURCE: https://github.com/python/mypy/blob/master/CHANGELOG.md#2025-04-22_snippet_47\n\nLANGUAGE: bash\nCODE:\n```\npython3 -m pip install -U mypy\n```\n\n----------------------------------------\n\nTITLE: Summing List with Native Integer Types - Python\nDESCRIPTION: This example demonstrates the usage of native integer types from the mypy_extensions module. It calculates the sum of a list of 64-bit signed integers (i64). The snippet highlights the syntax for importing native integer types and using them in function signatures and operations. Implicit conversions from int to i64 are showcased, along with potential overflow issues.\nSOURCE: https://github.com/python/mypy/blob/master/mypyc/doc/using_type_annotations.rst#2025-04-22_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nfrom mypy_extensions import i64\n\ndef sum_list(l: list[i64]) -> i64:\n    s: i64 = 0\n    for n in l:\n        s += n\n    return s\n\n# Implicit conversions from int to i64\nprint(sum_list([1, 3, 5]))\n```\n\n----------------------------------------\n\nTITLE: Forcing pthread Availability Detection in Google Test - Shell\nDESCRIPTION: These snippets demonstrate defining compiler macros to manually override whether Google Test detects and uses pthread support. Add these flags as needed to your build system to resolve detection issues or enforce explicit multithreading support. Affects internal threading macros and possible need for extra linker flags.\nSOURCE: https://github.com/python/mypy/blob/master/mypyc/external/googletest/README.md#2025-04-22_snippet_6\n\nLANGUAGE: shell\nCODE:\n```\n-DGTEST_HAS_PTHREAD=1\n```\n\nLANGUAGE: shell\nCODE:\n```\n-DGTEST_HAS_PTHREAD=0\n```\n\n----------------------------------------\n\nTITLE: List Indexing Timing\nDESCRIPTION: List element access by index takes 20-40 nanoseconds\nSOURCE: https://github.com/python/mypy/blob/master/mypyc/doc/cpython-timings.md#2025-04-22_snippet_6\n\nLANGUAGE: python\nCODE:\n```\na[i]\n```\n\n----------------------------------------\n\nTITLE: Installing the mypy-extensions Package using pip (Text)\nDESCRIPTION: Displays the shell command using `pip` to install or upgrade the `mypy-extensions` package. This package provides utilities like `@mypyc_attr` for use with MyPy and `mypyc` compiled code.\nSOURCE: https://github.com/python/mypy/blob/master/mypyc/doc/native_classes.rst#2025-04-22_snippet_3\n\nLANGUAGE: text\nCODE:\n```\npip install --upgrade mypy-extensions\n```\n\n----------------------------------------\n\nTITLE: Using native 64-bit integers in Mypyc\nDESCRIPTION: Example demonstrating the use of the new i64 type for native 64-bit integers in Mypyc.\nSOURCE: https://github.com/python/mypy/blob/master/CHANGELOG.md#2025-04-22_snippet_46\n\nLANGUAGE: python\nCODE:\n```\nfrom mypy_extensions import i64\n\ndef inc(x: i64) -> i64:\n    return x + 1\n```\n\n----------------------------------------\n\nTITLE: Creating and Activating Virtual Environment in Bash\nDESCRIPTION: Commands to create a Python virtual environment and activate it for Mypy development.\nSOURCE: https://github.com/python/mypy/blob/master/CONTRIBUTING.md#2025-04-22_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\npython3 -m venv venv\nsource venv/bin/activate\n```\n\n----------------------------------------\n\nTITLE: Installing Mypy with Mypyc Dependencies\nDESCRIPTION: Command to install Mypy with additional dependencies required by mypyc, the compiled version of Mypy, using pip's extras syntax.\nSOURCE: https://github.com/python/mypy/blob/master/CHANGELOG.md#2025-04-22_snippet_28\n\nLANGUAGE: bash\nCODE:\n```\npython3 -m pip install -U 'mypy[mypyc]'\n```\n\n----------------------------------------\n\nTITLE: Defining Enum for Exhaustiveness Checking Example in Python\nDESCRIPTION: This code defines the `Direction` Enum along with necessary imports (`NoReturn`, `assert_never`) to set up the subsequent exhaustiveness checking example.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/literal_types.rst#2025-04-22_snippet_16\n\nLANGUAGE: python\nCODE:\n```\nfrom enum import Enum\nfrom typing import NoReturn\nfrom typing_extensions import assert_never\n\nclass Direction(Enum):\n    up = 'up'\n    down = 'down'\n```\n\n----------------------------------------\n\nTITLE: Including Markdown Changelog into Sphinx Documentation - Sphinx - Markdown\nDESCRIPTION: This snippet shows a Sphinx documentation directive that includes the project's CHANGELOG.md (written in Markdown) into the documentation. It relies on Sphinx's {include} directive supported by Markdown extensions, and requires the project file '../../CHANGELOG.md' to exist relative to this path. The snippet makes all updates in the changelog visible in the generated documentation without manual copying, and allows for centralized release note updates.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/changelog.md#2025-04-22_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n```{include} ../../CHANGELOG.md\n```\n```\n\n----------------------------------------\n\nTITLE: Directory Structure for Stub-Only Package\nDESCRIPTION: Example directory structure for a stub-only package, which does not require a py.typed file.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/installed_packages.rst#2025-04-22_snippet_4\n\nLANGUAGE: text\nCODE:\n```\nsetup.py\npackage_c-stubs/\n    __init__.pyi\n    lib.pyi\n```\n\n----------------------------------------\n\nTITLE: Removing and Returning an Arbitrary Item from a Python Set\nDESCRIPTION: Demonstrates the `pop()` method, which removes and returns an arbitrary element from the set `s`. It raises a `KeyError` if the set is empty. Note that the specific element removed is not guaranteed.\nSOURCE: https://github.com/python/mypy/blob/master/mypyc/doc/set_operations.rst#2025-04-22_snippet_11\n\nLANGUAGE: python\nCODE:\n```\ns.pop()\n```\n\n----------------------------------------\n\nTITLE: Using attrs Package with auto_attribs=False\nDESCRIPTION: Shows how to properly type annotate attrs classes when using auto_attribs=False, demonstrating three different ways to specify types.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/additional_features.rst#2025-04-22_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nimport attrs\n\n@attrs.define\nclass A:\n    one: int = attrs.field()          # Variable annotation (Python 3.6+)\n    two = attrs.field()  # type: int  # Type comment\n    three = attrs.field(type=int)     # type= argument\n```\n\n----------------------------------------\n\nTITLE: Installing Documentation Dependencies for Mypy\nDESCRIPTION: Installs Sphinx and other required dependencies for building Mypy documentation using pip. Must be run from the docs directory.\nSOURCE: https://github.com/python/mypy/blob/master/docs/README.md#2025-04-22_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\npip install -r requirements-docs.txt\n```\n\n----------------------------------------\n\nTITLE: Bytes to String Coercion Checks in Python\nDESCRIPTION: Demonstrates Mypy's checks for implicit bytes to string conversions and proper handling methods.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/error_code_list.rst#2025-04-22_snippet_38\n\nLANGUAGE: python\nCODE:\n```\nb = b\"abc\"\n\nprint(f\"The alphabet starts with {b}\")\n\n# Okay\nprint(f\"The alphabet starts with {b!r}\")  # The alphabet starts with b'abc'\nprint(f\"The alphabet starts with {b.decode('utf-8')}\")  # The alphabet starts with abc\n```\n\n----------------------------------------\n\nTITLE: Named Argument Function Call Timing\nDESCRIPTION: Empty function call with named argument takes 90-110 nanoseconds\nSOURCE: https://github.com/python/mypy/blob/master/mypyc/doc/cpython-timings.md#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nf(n=1)\n```\n\n----------------------------------------\n\nTITLE: Integer Addition Timing\nDESCRIPTION: Integer addition takes 20-35 nanoseconds\nSOURCE: https://github.com/python/mypy/blob/master/mypyc/doc/cpython-timings.md#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nx + y\n```\n\n----------------------------------------\n\nTITLE: TypedDict Invalid Key Access - Python\nDESCRIPTION: Illustrates mypy's static error detection when attempting to access a non-existent key ('director') in a TypedDict object. This code would be flagged at type-check time. The intent is to demonstrate static type safety for fixed schemas.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/typed_dict.rst#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ndirector = movie['director']  # Error: 'director' is not a valid key\n```\n\n----------------------------------------\n\nTITLE: Writing a Mypy Unit Test Case - Python\nDESCRIPTION: Demonstrates the syntax for defining a type-checking-based unit test in the mypy test-data format. Each [case name] entry declares a test, with in-line Python code followed by special comments for flags and expected type errors. The snippet uses optional flags, and inline annotations to assert the presence or absence of errors, and illustrates how to indicate expected error messages. No runtime code is executed; it's strictly for static analysis via mypy's test harness.\nSOURCE: https://github.com/python/mypy/blob/master/test-data/unit/README.md#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n[case testNewSyntaxBasics]\\n# flags: --python-version 3.10\\nx: int\\nx = 5\\ny: int = 5\\n\\na: str\\na = 5  # E: Incompatible types in assignment (expression has type \\\"int\\\", variable has type \\\"str\\\")\\nb: str = 5  # E: Incompatible types in assignment (expression has type \\\"int\\\", variable has type \\\"str\\\")\\n\\nzzz: int\\nzzz: str  # E: Name \\\"zzz\\\" already defined\n```\n\n----------------------------------------\n\nTITLE: Building and Running Google Test Suite (Shell)\nDESCRIPTION: This shell command runs 'make test' to build and execute all enabled tests for Google Test. It assumes prior invocation of CMake to configure the build tree. All tests should pass for a successful configuration and codebase update.\nSOURCE: https://github.com/python/mypy/blob/master/mypyc/external/googletest/README.md#2025-04-22_snippet_11\n\nLANGUAGE: shell\nCODE:\n```\nmake test\n```\n\n----------------------------------------\n\nTITLE: Tuple Creation Timing\nDESCRIPTION: Two-element tuple creation takes 20-35 nanoseconds\nSOURCE: https://github.com/python/mypy/blob/master/mypyc/doc/cpython-timings.md#2025-04-22_snippet_12\n\nLANGUAGE: python\nCODE:\n```\n(x, y)\n```\n\n----------------------------------------\n\nTITLE: Run Specific Test Modules or Cases with pytest - Shell\nDESCRIPTION: Demonstrates several ways to run targeted tests in specific modules or test suites using pytest command-line arguments. These commands are useful for focused testing during development or debugging session.\nSOURCE: https://github.com/python/mypy/blob/master/test-data/unit/README.md#2025-04-22_snippet_5\n\nLANGUAGE: shell\nCODE:\n```\npytest -q mypy/test/testdiff.py\n```\n\nLANGUAGE: shell\nCODE:\n```\npytest -q mypy/test/testsemanal.py::SemAnalTypeInfoSuite\n```\n\nLANGUAGE: shell\nCODE:\n```\npytest -n0 mypy/test/testargs.py::ArgSuite::test_coherence\n```\n\nLANGUAGE: shell\nCODE:\n```\npytest -n0 mypy/test/testcheck.py::TypeCheckSuite::testCallingVariableWithFunctionType\n```\n\n----------------------------------------\n\nTITLE: Creating and Activating Virtual Environment in Windows\nDESCRIPTION: Commands to create a Python virtual environment and activate it for Mypy development on Windows.\nSOURCE: https://github.com/python/mypy/blob/master/CONTRIBUTING.md#2025-04-22_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\npython -m venv venv\n. venv/Scripts/activate\n```\n\n----------------------------------------\n\nTITLE: Passing Files to mypy Via File List (Argument File Syntax) - Bash\nDESCRIPTION: Shows how to use a file containing additional command-line arguments (e.g., a list of files or flags) by prefixing the filename with @. mypy reads the specified file and adds its contents as CLI arguments. This is an alternative to shell expansion for large argument lists or automation use cases.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/running_mypy.rst#2025-04-22_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\n$ mypy @file_of_files.txt\n```\n\n----------------------------------------\n\nTITLE: Filter Test Runs Using pytest -k Option - Shell\nDESCRIPTION: Uses the '-k' switch with pytest to select and run only tests that match a substring or expression pattern. This method is efficient for rapidly verifying individual features without running the entire suite.\nSOURCE: https://github.com/python/mypy/blob/master/test-data/unit/README.md#2025-04-22_snippet_6\n\nLANGUAGE: shell\nCODE:\n```\npytest -q -k \"MethodCall\"\n```\n\n----------------------------------------\n\nTITLE: Configuring mypy Plugins via Config File - INI\nDESCRIPTION: Shows how to specify mypy plugins in a configuration file using either relative/absolute Python file paths or module names. This allows mypy to import and use external plugins to extend its functionality. The plugins key in the [mypy] section accepts a comma-separated list. Config file must be used by the executed mypy instance, and specified files or modules must be importable.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/extending_mypy.rst#2025-04-22_snippet_1\n\nLANGUAGE: ini\nCODE:\n```\n[mypy]\nplugins = /one/plugin.py, other.plugin\n\n```\n\n----------------------------------------\n\nTITLE: Checking Documentation Links\nDESCRIPTION: Validates all internal and external links in the documentation to ensure they are working correctly.\nSOURCE: https://github.com/python/mypy/blob/master/docs/README.md#2025-04-22_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\nmake linkcheck\n```\n\n----------------------------------------\n\nTITLE: Handling False Positives with Enum Equality in Strict Mode\nDESCRIPTION: Example showing a case where Mypy's strict equality mode can cause false positives with enum comparisons in test code, and how to work around it.\nSOURCE: https://github.com/python/mypy/blob/master/CHANGELOG.md#2025-04-22_snippet_40\n\nLANGUAGE: python\nCODE:\n```\n# mypy: strict-equality\n\nfrom enum import Enum\n\nclass MyEnum(Enum):\n    A = 0\n    B = 1\n\nclass C:\n    x: MyEnum\n    ...\n\ndef test_something() -> None:\n    c = C(...)\n    assert c.x == MyEnum.A\n    c.do_something_that_changes_x()\n    assert c.x == MyEnum.B  # Error: Non-overlapping equality check\n```\n\n----------------------------------------\n\nTITLE: Ignoring Errors in Unready Modules - Mypy Configuration - Text\nDESCRIPTION: This configuration snippet disables error reporting for all modules under 'package_to_fix_later'. By adding this section to your mypy config file, you can focus type checking only on selected code, allowing unready or legacy modules to pass without raising errors. The pattern '[mypy-module_pattern.*]' introduces a section for granular control, and 'ignore_errors = True' instructs mypy not to emit errors for the matched files. No dependencies aside from mypy itself; intended for use in a 'mypy.ini', 'setup.cfg', or 'pyproject.toml' file under the '[tool.mypy]' table. Input: code base with modules matching the specified pattern. Output: mypy run with suppressed errors from these modules.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/existing_code.rst#2025-04-22_snippet_1\n\nLANGUAGE: text\nCODE:\n```\n[mypy-package_to_fix_later.*]\nignore_errors = True\n```\n\n----------------------------------------\n\nTITLE: Method Call Timing\nDESCRIPTION: Empty method call with one argument takes 80-160 nanoseconds\nSOURCE: https://github.com/python/mypy/blob/master/mypyc/doc/cpython-timings.md#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\no.f(1)\n```\n\n----------------------------------------\n\nTITLE: Implicit and Explicit Integer Conversions in mypy_extensions\nDESCRIPTION: Demonstrates how implicit and explicit conversions are handled when assigning values to native integer types using the mypy_extensions module.\nSOURCE: https://github.com/python/mypy/blob/master/mypyc/doc/int_operations.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom mypy_extensions import i64\n\ndef implicit() -> None:\n    # Implicit conversion of 0 (int) to i64\n    x: i64 = 0\n\ndef explicit() -> None:\n    # Explicit conversion of 0 (int) to i64\n    x = i64(0)\n```\n\n----------------------------------------\n\nTITLE: Building the mypy-test Docker Container (Shell)\nDESCRIPTION: Executes the `build.py` Python script to build the `mypy-test` Docker image. This image contains all dependencies required to run mypy and mypyc tests within an isolated Docker environment.\nSOURCE: https://github.com/python/mypy/blob/master/misc/docker/README.md#2025-04-22_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\n$ python3 misc/docker/build.py\n```\n\n----------------------------------------\n\nTITLE: Running the Full Test Suite with pytest - Shell\nDESCRIPTION: Executes all defined tests in the mypy project using pytest, including integration and regression tests. The '-q' flag activates less verbose mode, which is especially useful when running in parallel across many CPU cores.\nSOURCE: https://github.com/python/mypy/blob/master/test-data/unit/README.md#2025-04-22_snippet_4\n\nLANGUAGE: shell\nCODE:\n```\npytest -q mypy\n```\n\n----------------------------------------\n\nTITLE: Force Rebuilding the Docker Container (Shell)\nDESCRIPTION: Rebuilds the `mypy-test` Docker container using the `build.py` script, forcing a fresh build by ignoring the Docker build cache (`--no-cache`) and pulling the latest base images (`--pull`). Use this to ensure the container is completely up-to-date or to resolve issues with stale cached layers.\nSOURCE: https://github.com/python/mypy/blob/master/misc/docker/README.md#2025-04-22_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\n$ python3 misc/docker/build.py --no-cache --pull\n```\n\n----------------------------------------\n\nTITLE: Dictionary Assignment Timing\nDESCRIPTION: Dictionary assignment with shared string key takes 40 nanoseconds\nSOURCE: https://github.com/python/mypy/blob/master/mypyc/doc/cpython-timings.md#2025-04-22_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nd[s] = i\n```\n\n----------------------------------------\n\nTITLE: Aggregating Boolean Expressions with any() and all() - Python\nDESCRIPTION: Utilizes the built-in Python functions 'any' and 'all' to aggregate boolean values across iterables or comprehensions. 'any' returns True if at least one expression in the iterable is truthy; 'all' returns True if all are truthy. These functions accept any iterable producing boolean values; outputs are single boolean results.\nSOURCE: https://github.com/python/mypy/blob/master/mypyc/doc/bool_operations.rst#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nany(expr for ... in ...)\nall(expr for ... in ...)\n\n```\n\n----------------------------------------\n\nTITLE: Removing a Compiled C Extension\nDESCRIPTION: Command for deleting a compiled C extension to revert to using the interpreted version of a Python module. This example works on macOS or Linux systems.\nSOURCE: https://github.com/python/mypy/blob/master/mypyc/doc/dev-intro.md#2025-04-22_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n$ rm program.*.so\n```\n\n----------------------------------------\n\nTITLE: Customizing Builtins for Test Fixtures - Python\nDESCRIPTION: Shows how to override or extend the builtins used in a mypy test by embedding a stub definition in the data-driven test file. This pattern allows defining additional methods or types (e.g., extending 'int') as part of local fixtures, affecting type checking and error output within the test scope. The distinction between [file ...] and [fixture ...] sections controls whether the stub is part of the test's output evaluation.\nSOURCE: https://github.com/python/mypy/blob/master/test-data/unit/README.md#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n[case testFoo]\\n...\\n[file builtins.py]\\nclass int:\\n  def next_fibonacci() -> int: pass\n```\n\n----------------------------------------\n\nTITLE: Compiling and Archiving Google Test with GCC - Shell\nDESCRIPTION: This snippet demonstrates compiling the main gtest source to an object file and then creating a static library archive using gcc and ar. It requires gcc/g++, a POSIX-like shell environment, and that ${GTEST_DIR} be set to the root of the Google Test source. The -isystem and -I flags set header search paths; -pthread is necessary as Google Test uses threads. Output is libgtest.a, a static library for linking against your tests.\nSOURCE: https://github.com/python/mypy/blob/master/mypyc/external/googletest/README.md#2025-04-22_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\ng++ -isystem ${GTEST_DIR}/include -I${GTEST_DIR} \\\n    -pthread -c ${GTEST_DIR}/src/gtest-all.cc\nar -rv libgtest.a gtest-all.o\n```\n\n----------------------------------------\n\nTITLE: Basic Function Without Type Annotations\nDESCRIPTION: Simple function creating a new user instance without type annotations.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/kinds_of_types.rst#2025-04-22_snippet_14\n\nLANGUAGE: python\nCODE:\n```\ndef new_user(user_class):\n    user = user_class()\n    # (Here we could write the user object to a database)\n    return user\n```\n\n----------------------------------------\n\nTITLE: Passing Mypy Flags via mypycify in setup.py (Python)\nDESCRIPTION: Example snippet showing how to pass mypy command-line flags (like `--disallow-untyped-defs`) as string arguments within the list passed to the `mypycify` function in a `setup.py` file. This allows customizing mypy's behavior during the mypyc compilation process.\nSOURCE: https://github.com/python/mypy/blob/master/mypyc/doc/getting_started.rst#2025-04-22_snippet_12\n\nLANGUAGE: python\nCODE:\n```\n...\nsetup(\n    name='frobnicate',\n    packages=['frobnicate'],\n    ext_modules=mypycify([\n        '--disallow-untyped-defs',  # Pass a mypy flag\n        'frobnicate.py',\n    ]),\n)\n```\n\n----------------------------------------\n\nTITLE: Composing Function Calls and Variable References - Python\nDESCRIPTION: This Python snippet features two function definitions (foo and bar) and a variable declaration (baz: int), followed by a function call bar(foo(baz)). It's used to illustrate how dmypy can limit the number of inspected expressions returned with the --limit option. Inputs include declared variables and function arguments, and output is controlled by command-line inspection tools, rather than program behavior. There are no external dependencies, and all code remains within a single module with type annotations.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/mypy_daemon.rst#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ndef foo(x: int) -> str: ..\ndef bar(x: str) -> None: ...\nbaz: int\nbar(foo(baz))\n```\n\n----------------------------------------\n\nTITLE: List Creation Timing\nDESCRIPTION: Single element list creation and deallocation takes 35-55 nanoseconds\nSOURCE: https://github.com/python/mypy/blob/master/mypyc/doc/cpython-timings.md#2025-04-22_snippet_7\n\nLANGUAGE: python\nCODE:\n```\n[i]\n```\n\n----------------------------------------\n\nTITLE: Building Google Test with Makefile Example - Shell\nDESCRIPTION: This snippet shows using GNU make with a provided Makefile to build the Google Test library and sample tests. It assumes a suitable make toolchain is available and the working directory is set to ${GTEST_DIR}/make. Output is a runnable unit test (sample1_unittest).\nSOURCE: https://github.com/python/mypy/blob/master/mypyc/external/googletest/README.md#2025-04-22_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\ncd ${GTEST_DIR}/make\nmake\n./sample1_unittest\n```\n\n----------------------------------------\n\nTITLE: Cleaning Mypy Documentation Build\nDESCRIPTION: Removes all built documentation files to ensure a clean state for the next build.\nSOURCE: https://github.com/python/mypy/blob/master/docs/README.md#2025-04-22_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\nmake clean\n```\n\n----------------------------------------\n\nTITLE: Running Tests in Docker with Root Privileges (Shell)\nDESCRIPTION: Executes the `run.sh` script using `sudo` to run `mypyc` tests with `pytest` inside the Docker container. This might be necessary if the user requires root privileges to run the container or interact with the Docker daemon.\nSOURCE: https://github.com/python/mypy/blob/master/misc/docker/README.md#2025-04-22_snippet_5\n\nLANGUAGE: shell\nCODE:\n```\n$ sudo misc/docker/run.sh pytest mypyc\n```\n\n----------------------------------------\n\nTITLE: Integrating Mypyc Compilation into setup.py (Python)\nDESCRIPTION: Example `setup.py` file demonstrating how to use `mypyc.build.mypycify` from `setuptools`. It specifies a list of Python files (`mylib/__init__.py`, `mylib/mod.py`) that should be compiled into C extensions by mypyc during the package build process.\nSOURCE: https://github.com/python/mypy/blob/master/mypyc/doc/getting_started.rst#2025-04-22_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nfrom setuptools import setup\n\nfrom mypyc.build import mypycify\n\nsetup(\n    name='mylib',\n    packages=['mylib'],\n    ext_modules=mypycify([\n        'mylib/__init__.py',\n        'mylib/mod.py',\n    ]),\n)\n```\n\n----------------------------------------\n\nTITLE: Dictionary Access Timing\nDESCRIPTION: Dictionary lookup with shared string key takes 20 nanoseconds\nSOURCE: https://github.com/python/mypy/blob/master/mypyc/doc/cpython-timings.md#2025-04-22_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nd[s]\n```\n\n----------------------------------------\n\nTITLE: Inspecting Union Types and Attributes - Python\nDESCRIPTION: This Python example defines classes A and B, each with different attributes, and a variable var annotated as a Union of A and B. The last line references var directly, which is used to demonstrate the --union-attrs command line option in dmypy, showing the differences in attribute sets for union types. All dependencies are from the standard library (typing.Union), and there are no outputs other than those produced by external inspection tools. Inputs are class definitions and an annotated variable.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/mypy_daemon.rst#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Union\n\nclass A:\n    x: int\n    z: int\nclass B:\n    y: int\n    z: int\nvar: Union[A, B]\nvar\n```\n\n----------------------------------------\n\nTITLE: List Append Timing\nDESCRIPTION: List append operation takes approximately 70 nanoseconds (averaged over 5 appends)\nSOURCE: https://github.com/python/mypy/blob/master/mypyc/doc/cpython-timings.md#2025-04-22_snippet_8\n\nLANGUAGE: python\nCODE:\n```\na.append(i)\n```\n\n----------------------------------------\n\nTITLE: Tuple Unpacking Timing\nDESCRIPTION: Tuple unpacking into two variables takes 10 nanoseconds\nSOURCE: https://github.com/python/mypy/blob/master/mypyc/doc/cpython-timings.md#2025-04-22_snippet_13\n\nLANGUAGE: python\nCODE:\n```\nx, y = t\n```\n\n----------------------------------------\n\nTITLE: Cloning and Entering Mypy Repository in Bash\nDESCRIPTION: Commands to clone the Mypy repository from GitHub and enter the project directory.\nSOURCE: https://github.com/python/mypy/blob/master/CONTRIBUTING.md#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit clone git@github.com:<your_username>/mypy.git\ncd mypy\n```\n\n----------------------------------------\n\nTITLE: Optimizing Docker Performance on macOS with Colima (Shell)\nDESCRIPTION: Starts the Colima runtime on macOS, allocating 8 CPU cores using the `-c` option. This command is highlighted as a way to potentially improve test execution performance by providing more resources to the Docker VM, as the default allocation might be insufficient.\nSOURCE: https://github.com/python/mypy/blob/master/misc/docker/README.md#2025-04-22_snippet_7\n\nLANGUAGE: shell\nCODE:\n```\n$ colima start -c 8\n```\n\n----------------------------------------\n\nTITLE: Socket Hostname Type Checking Example\nDESCRIPTION: Shows how Mypyc enforces type checking for library functions using stub files. The example demonstrates return type verification for socket.gethostname().\nSOURCE: https://github.com/python/mypy/blob/master/mypyc/doc/differences_from_python.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ndef gethostname() -> str: ...\n```\n\n----------------------------------------\n\nTITLE: Mypy Requires Type Annotation for Pure Variable Assignment Outside Context\nDESCRIPTION: Demonstrates a case where the lack of immediate type context results in a mypy error for initializing a variable with an empty list before it is used as an argument to a typed function. Explicit annotation is required outside of direct call context.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/type_inference_and_annotations.rst#2025-04-22_snippet_12\n\nLANGUAGE: python\nCODE:\n```\ndef foo(arg: list[int]) -> None:\\n    print('Items:', ', '.join(arg))\\n\\na = []  # Error: Need type annotation for \\\"a\\\"\\nfoo(a)\n```\n\n----------------------------------------\n\nTITLE: Specifying Python Executable in CMake Config (Shell)\nDESCRIPTION: These shell commands invoke CMake to both enable Google Test's internal tests and explicitly specify the Python interpreter location using -DPYTHON_EXECUTABLE. This is useful if CMake is unable to find Python automatically. The GTEST_DIR variable must still be set. Ensures all required Python-based tests can be configured and run.\nSOURCE: https://github.com/python/mypy/blob/master/mypyc/external/googletest/README.md#2025-04-22_snippet_10\n\nLANGUAGE: shell\nCODE:\n```\ncmake -DPYTHON_EXECUTABLE=path/to/python -Dgtest_build_tests=ON ${GTEST_DIR}\n```\n\n----------------------------------------\n\nTITLE: Starting Colima Docker Runtime (Shell)\nDESCRIPTION: Starts the Colima Docker runtime, allocating a specified number of CPU cores (8 in this example). This is often a prerequisite step on macOS before building or running Docker containers for mypy tests. The `-c` option controls CPU allocation.\nSOURCE: https://github.com/python/mypy/blob/master/misc/docker/README.md#2025-04-22_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n$ colima start -c 8\n```\n\n----------------------------------------\n\nTITLE: Invoking Stubgen with File Paths\nDESCRIPTION: Demonstrates how to run the `stubgen` command-line tool by providing specific Python source file paths as arguments. This command generates corresponding stub files (`.pyi`) in the default output directory (`out/`).\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/stubgen.rst#2025-04-22_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n$ stubgen foo.py bar.py\n```\n\n----------------------------------------\n\nTITLE: Defining and Using Variables in Python Functions - Python\nDESCRIPTION: This snippet demonstrates a simple Python function named foo with two parameters (x: int, longer_name: str) and a return type of None. Both parameters are accessed on separate lines, providing concrete targets for mypy/dmypy inspection commands. There are no external dependencies, and it serves as an example for using dmypy inspect to query the types of variable references in a function. Inputs are integer and string arguments, and outputs are not produced as the function returns None.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/mypy_daemon.rst#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ndef foo(x: int, longer_name: str) -> None:\n    x\n    longer_name\n```\n\n----------------------------------------\n\nTITLE: Primitive Type Behavior Example\nDESCRIPTION: Shows how primitive types like integers behave differently in compiled code, demonstrating type conversion behavior with booleans.\nSOURCE: https://github.com/python/mypy/blob/master/mypyc/doc/differences_from_python.rst#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ndef first_int(x: list[int]) -> int:\n    return x[0]\n\nprint(first_int([True]))  # Output is 1, instead of True!\n```\n\n----------------------------------------\n\nTITLE: Reachable Code with Conditional Flow - Python\nDESCRIPTION: This code demonstrates how mypy reports errors for reachable code that may execute depending on conditions. It includes a type mismatch after a conditional return, illustrating correct detection of type errors in non-unreachable code paths.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/common_issues.rst#2025-04-22_snippet_29\n\nLANGUAGE: python\nCODE:\n```\nclass Foo:\\n    bar: str = ''\\n\\ndef bar() -> None:\\n    foo: Foo = Foo()\\n    if not foo.bar:\\n        return\\n    x: int = 'abc'  # Reachable -- error\n```\n\n----------------------------------------\n\nTITLE: Generating Native Build Files with CMake for Google Test - Shell\nDESCRIPTION: These snippets use CMake to generate project/Makefile files for building Google Test. They show creating a separate build directory and invoking cmake to configure Google Test sources. Optionally, passing -Dgtest_build_samples=ON includes sample tests. Assumes CMake and a suitable compiler are installed; output is makefiles or IDE-specific project files.\nSOURCE: https://github.com/python/mypy/blob/master/mypyc/external/googletest/README.md#2025-04-22_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\nmkdir mybuild       # Create a directory to hold the build output.\ncd mybuild\ncmake ${GTEST_DIR}  # Generate native build scripts.\n```\n\nLANGUAGE: shell\nCODE:\n```\ncmake -Dgtest_build_samples=ON ${GTEST_DIR}\n```\n\n----------------------------------------\n\nTITLE: Serializable Class Definition\nDESCRIPTION: Example of making a native class serializable using the mypyc_attr decorator to enable pickling support.\nSOURCE: https://github.com/python/mypy/blob/master/mypyc/doc/differences_from_python.rst#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom mypy_extensions import mypyc_attr\nimport pickle\n\n@mypyc_attr(serializable=True)\nclass Cls:\n    def __init__(self, n: int) -> None:\n        self.n = n\n\ndata = pickle.dumps(Cls(5))\nobj = pickle.loads(data)  # OK\n```\n\n----------------------------------------\n\nTITLE: Installing Mypy 1.5 using pip\nDESCRIPTION: Command to install or upgrade Mypy to version 1.5 using pip.\nSOURCE: https://github.com/python/mypy/blob/master/CHANGELOG.md#2025-04-22_snippet_33\n\nLANGUAGE: bash\nCODE:\n```\npython3 -m pip install -U mypy\n```\n\n----------------------------------------\n\nTITLE: Alternative Mypy with Mypyc Installation using pip (Shell)\nDESCRIPTION: An alternative command using `python` instead of `python3` to install or update mypy with mypyc extras via pip. This might be necessary on systems where `python` maps to the desired Python 3 version (3.9+).\nSOURCE: https://github.com/python/mypy/blob/master/mypyc/doc/getting_started.rst#2025-04-22_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n$ python -m pip install -U 'mypy[mypyc]'\n```\n\n----------------------------------------\n\nTITLE: Using Annotations for Future Compatibility in Python\nDESCRIPTION: This snippet introduces the __future__ import for annotations, which allows using new type hinting capabilities even in older Python versions. It ensures that all annotations are treated as strings at runtime, which can be beneficial for forward compatibility.\nSOURCE: https://github.com/python/mypy/blob/master/mypy/typeshed/stdlib/_typeshed/README.md#2025-04-22_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\nfrom __future__ import annotations\n```\n\n----------------------------------------\n\nTITLE: Self-Checking the mypy Codebase - Shell\nDESCRIPTION: Runs a specialized static check of the mypy project itself using a designated config file via the mypy module's CLI. Used for ensuring that mypy's own code base passes its type checks.\nSOURCE: https://github.com/python/mypy/blob/master/test-data/unit/README.md#2025-04-22_snippet_9\n\nLANGUAGE: shell\nCODE:\n```\npython3 -m mypy --config-file mypy_self_check.ini -p mypy\n```\n\n----------------------------------------\n\nTITLE: Defining and Using a Native Class with Mypyc (Python)\nDESCRIPTION: This Python example demonstrates the definition of a `Point` class with type-annotated attributes and an `__init__` method. The accompanying `shift` function shows instantiation and attribute access on this class. When compiled with mypyc, such classes become native classes, enabling optimized operations like construction, attribute access, and method calls for improved performance compared to standard Python classes.\nSOURCE: https://github.com/python/mypy/blob/master/mypyc/doc/using_type_annotations.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nclass Point:\n    def __init__(self, x: int, y: int) -> None:\n        self.x = x\n        self.y = y\n\ndef shift(p: Point) -> Point:\n    return Point(p.x + 1, p.y + 1)\n```\n\n----------------------------------------\n\nTITLE: Install Test Requirements Using pip - Shell\nDESCRIPTION: Installs or updates all Python package dependencies needed to run the mypy tests as specified in the test-requirements file. This command ensures a consistent test environment, typically required before running the test suite on a new setup.\nSOURCE: https://github.com/python/mypy/blob/master/test-data/unit/README.md#2025-04-22_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\npython3 -m pip install -U -r test-requirements.txt\n```\n\n----------------------------------------\n\nTITLE: Debugging Segfaults in Mypyc with GDB\nDESCRIPTION: Illustrates the process of debugging Python tests that produce segfaults using GDB in the Mypyc testing framework. Ensures understanding of compiling Python in debug mode and using debuggers is a prerequisite. The emphasis is on capturing and analyzing the C stack trace with necessary preparatory steps described.\nSOURCE: https://github.com/python/mypy/blob/master/mypyc/doc/dev-intro.md#2025-04-22_snippet_4\n\nLANGUAGE: Shell\nCODE:\n```\n\\n$ pytest mypyc -n0 -s --mypyc-debug=gdb -k <name-of-test>\\n...\\n(gdb) r\\n...\\nProgram received signal SIGSEGV, Segmentation fault.\\n...\\n(gdb) bt\\n#0  0x00005555556ed1a2 in _PyObject_HashFast (op=0x0) at ./Include/object.h:336\\n#1  PyDict_GetItemWithError (op=0x7ffff6c894c0, key=0x0) at Objects/dictobject.c:2394\\n...\n```\n\n----------------------------------------\n\nTITLE: Compiling Google Test with CMake (Shell)\nDESCRIPTION: This shell command sequence initializes a build directory and invokes CMake to configure Google Test with its own tests enabled (via -Dgtest_build_tests=ON). It requires CMake to be installed, and the GTEST_DIR environment variable should point to the Google Test source directory. This step sets up the build configuration in preparation for compiling and running tests.\nSOURCE: https://github.com/python/mypy/blob/master/mypyc/external/googletest/README.md#2025-04-22_snippet_9\n\nLANGUAGE: shell\nCODE:\n```\nmkdir mybuild\ncd mybuild\ncmake -Dgtest_build_tests=ON ${GTEST_DIR}\n```\n\n----------------------------------------\n\nTITLE: Installing Development Version of mypy - Shell/Text\nDESCRIPTION: This shell snippet shows how to clone the mypy GitHub repository and install it in development mode using pip. Dependencies: git and Python 3 must be installed. Users can run these commands directly in the terminal to set up a local development environment for mypy. The process works on Unix-like systems with pip and python3 executables.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/common_issues.rst#2025-04-22_snippet_20\n\nLANGUAGE: text\nCODE:\n```\ngit clone https://github.com/python/mypy.git\\ncd mypy\\npython3 -m pip install --upgrade .\n```\n\n----------------------------------------\n\nTITLE: Specifying Package Requirements for Python Project - plaintext\nDESCRIPTION: This snippet lists required dependencies and their minimum versions for a Python project, with comments reminding maintainers to keep the file consistent with pyproject.toml and setup.py. It conditionally includes the 'tomli' package for Python versions earlier than 3.11 using an environment marker. No additional Python code is present; all content is in requirements file format.\nSOURCE: https://github.com/python/mypy/blob/master/mypy-requirements.txt#2025-04-22_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\n# NOTE: this needs to be kept in sync with the \\\"requires\\\" list in pyproject.toml\\n# and the pins in setup.py\\ntyping_extensions>=4.6.0\\nmypy_extensions>=1.0.0\\npathspec>=0.9.0\\ntomli>=1.1.0; python_version<'3.11'\\n\n```\n\n----------------------------------------\n\nTITLE: Optimizing Python Set Membership Test\nDESCRIPTION: Shows how a set membership test with a literal set, such as `x in {1, 3}`, could potentially be optimized. This operation might be translated into a more direct boolean expression like `x == 1 or x == 3`, potentially improving performance by avoiding set object creation and lookup, especially when the set literal is small.\nSOURCE: https://github.com/python/mypy/blob/master/mypyc/doc/future.md#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nx in {1, 3}\n```\n\nLANGUAGE: python\nCODE:\n```\nx == 1 or x == 3\n```\n\n----------------------------------------\n\nTITLE: Specifying mypy requirements with pip requirements file format\nDESCRIPTION: This requirements file references another requirements file (mypy-requirements.txt) and adds type stub packages (types-psutil and types-setuptools) needed for mypy. As noted in the comment, this file must be kept in sync with the 'requires' list in pyproject.toml.\nSOURCE: https://github.com/python/mypy/blob/master/build-requirements.txt#2025-04-22_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\n# NOTE: this needs to be kept in sync with the \"requires\" list in pyproject.toml\n-r mypy-requirements.txt\ntypes-psutil\ntypes-setuptools\n```\n\n----------------------------------------\n\nTITLE: Avoiding Redundant 'Self' Annotations in Python with Mypy\nDESCRIPTION: This snippet shows how to use the 'redundant-self' error code to avoid unnecessary 'Self' annotations in method definitions where 'Self' type usage for the 'self' argument is considered redundant according to PEP 673.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/error_code_list2.rst#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n# mypy: enable-error-code=\"redundant-self\"\n\nfrom typing import Self\n\nclass C:\n    # Error: Redundant \"Self\" annotation for the first method argument\ndef copy(self: Self) -> Self:\n        return type(self)()\n```\n\n----------------------------------------\n\nTITLE: Using the Any Type in Python with Mypy\nDESCRIPTION: Illustrates the use of the Any type in Python, showing how it permits any operations without compile-time checks by Mypy. It further illustrates how type annotations serve as comments without runtime checks. Dependencies: None. Key parameters: a, s - variables demonstrating Any usage.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/kinds_of_types.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\na: Any = None\ns: str = ''\na = 2     # OK (assign \"int\" to \"Any\")\ns = a     # OK (assign \"Any\" to \"str\")\n```\n\nLANGUAGE: python\nCODE:\n```\ndef show_heading(s) -> None:\n    print('=== ' + s + ' ===')  # No static type checking, as s has type Any\n\nshow_heading(1)  # OK (runtime error only; mypy won't generate an error)\n```\n\n----------------------------------------\n\nTITLE: Building Google Test with Xcode Command-Line Tool - Shell\nDESCRIPTION: This snippet invokes xcodebuild to build Google Test as a framework in the default release configuration. Requires Xcode and command-line tools on macOS. Output location is determined by Xcode preferences; building different configurations or destinations requires additional options.\nSOURCE: https://github.com/python/mypy/blob/master/mypyc/external/googletest/README.md#2025-04-22_snippet_4\n\nLANGUAGE: shell\nCODE:\n```\nxcodebuild\n```\n\n----------------------------------------\n\nTITLE: Type Variable Checks with Python 3.12 Syntax in Mypy\nDESCRIPTION: This snippet introduces the concept of type variables with restrictions in Python. It shows how Mypy flags incompatible types for type variables during function calls.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/error_code_list.rst#2025-04-22_snippet_16\n\nLANGUAGE: python\nCODE:\n```\ndef add[T1: (int, float)](x: T1, y: T1) -> T1:\n    return x + y\n\nadd(4, 5.5)  # OK\n\n# Error: Value of type variable \"T1\" of \"add\" cannot be \"str\"  [type-var]\nadd('x', 'y')\n```\n\n----------------------------------------\n\nTITLE: Fast Interpreter Shutdown in Python\nDESCRIPTION: Demonstrates the use of 'os._exit' for quickly terminating a Python process, optimizing batch processes or command-line tools for faster shutdowns.\nSOURCE: https://github.com/python/mypy/blob/master/mypyc/doc/performance_tips_and_tricks.rst#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nimport os\n\nos._exit(code)  # Immediately terminate the Python process\n\n```\n\n----------------------------------------\n\nTITLE: Running Specific Tests with runtests.py in Docker (Shell)\nDESCRIPTION: Uses the `run.sh` script to execute the project's `runtests.py` script inside the Docker container, specifically running the 'self' and 'lint' test suites. This demonstrates running custom test scripts within the container.\nSOURCE: https://github.com/python/mypy/blob/master/misc/docker/README.md#2025-04-22_snippet_6\n\nLANGUAGE: shell\nCODE:\n```\n$ misc/docker/run.sh ./runtests.py self lint\n```\n\n----------------------------------------\n\nTITLE: Example of Mypy error output with documentation links\nDESCRIPTION: Demonstrates the new --show-error-code-links flag output, which adds documentation links to reported errors for better understanding and resolution.\nSOURCE: https://github.com/python/mypy/blob/master/CHANGELOG.md#2025-04-22_snippet_36\n\nLANGUAGE: text\nCODE:\n```\na.py:1: error: Need type annotation for \"foo\" (hint: \"x: List[<type>] = ...\")  [var-annotated]\na.py:1: note: See https://mypy.rtfd.io/en/stable/_refs.html#code-var-annotated for more info\n```\n\n----------------------------------------\n\nTITLE: Running mypyc Tests in Docker Container (Shell)\nDESCRIPTION: Executes the `run.sh` script to run `mypyc` tests using `pytest` inside the `mypy-test` Docker container. Additional pytest arguments like `-k`, `-n0`, `-q` can be appended.\nSOURCE: https://github.com/python/mypy/blob/master/misc/docker/README.md#2025-04-22_snippet_4\n\nLANGUAGE: shell\nCODE:\n```\n$ misc/docker/run.sh pytest mypyc\n```\n\n----------------------------------------\n\nTITLE: Directory Structure for Package with Inline Type Annotations\nDESCRIPTION: Example directory structure for a package that supplies type information via type comments or annotations in the code.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/installed_packages.rst#2025-04-22_snippet_0\n\nLANGUAGE: text\nCODE:\n```\nsetup.py\npackage_a/\n    __init__.py\n    lib.py\n    py.typed\n```\n\n----------------------------------------\n\nTITLE: Generic Type Annotation (Python 3.12)\nDESCRIPTION: Advanced type annotation using generic type syntax in Python 3.12 with upper bound constraint.\nSOURCE: https://github.com/python/mypy/blob/master/docs/source/kinds_of_types.rst#2025-04-22_snippet_17\n\nLANGUAGE: python\nCODE:\n```\ndef new_user[U: User](user_class: type[U]) -> U:\n    # Same implementation as before\n```\n\n----------------------------------------\n\nTITLE: Basic Function Call Timing\nDESCRIPTION: Empty function call with positional argument takes 70-90 nanoseconds\nSOURCE: https://github.com/python/mypy/blob/master/mypyc/doc/cpython-timings.md#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nf(1)\n```\n\n----------------------------------------\n\nTITLE: isinstance Check Timing\nDESCRIPTION: Type checking with isinstance takes 100 nanoseconds\nSOURCE: https://github.com/python/mypy/blob/master/mypyc/doc/cpython-timings.md#2025-04-22_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nisinstance(x, A)\n```\n\n----------------------------------------\n\nTITLE: Building and Linking Google Test as a Shared Library (DLL) - Shell\nDESCRIPTION: These flags configure Google Test to be built and used as a shared library (DLL on Windows). The first is for compiling the gtest library, the second for compiling tests that link to the shared library. Add both to the compiler flags and ensure your linker produces a shared library. Future versions may require these even on platforms where currently optional.\nSOURCE: https://github.com/python/mypy/blob/master/mypyc/external/googletest/README.md#2025-04-22_snippet_7\n\nLANGUAGE: shell\nCODE:\n```\n-DGTEST_CREATE_SHARED_LIBRARY=1\n```\n\nLANGUAGE: shell\nCODE:\n```\n-DGTEST_LINKED_AS_SHARED_LIBRARY=1\n```"
  }
]