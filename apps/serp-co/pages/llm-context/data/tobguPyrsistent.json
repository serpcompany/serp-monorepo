[
  {
    "owner": "tobgu",
    "repo": "pyrsistent",
    "content": "TITLE: Using PVector in Python\nDESCRIPTION: Demonstrates creating and manipulating immutable vectors using PVector. Shows operations like append, set, indexing, slicing, and iteration.\nSOURCE: https://github.com/tobgu/pyrsistent/blob/master/README.rst#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n>>> from pyrsistent import v, pvector\n\n# No mutation of vectors once created, instead they\n# are \"evolved\" leaving the original untouched\n>>> v1 = v(1, 2, 3)\n>>> v2 = v1.append(4)\n>>> v3 = v2.set(1, 5)\n>>> v1\npvector([1, 2, 3])\n>>> v2\npvector([1, 2, 3, 4])\n>>> v3\npvector([1, 5, 3, 4])\n\n# Random access and slicing\n>>> v3[1]\n5\n>>> v3[1:3]\npvector([5, 3])\n\n# Iteration\n>>> list(x + 1 for x in v3)\n[2, 6, 4, 5]\n>>> pvector(2 * x for x in range(3))\npvector([0, 2, 4])\n```\n\n----------------------------------------\n\nTITLE: PVector Usage Example in Python\nDESCRIPTION: Demonstrates basic operations with PVector including creation, appending, setting values, accessing elements, slicing and iteration. PVector is an immutable vector implementation.\nSOURCE: https://github.com/tobgu/pyrsistent/blob/master/docs/source/intro.rst#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n>>> from pyrsistent import v, pvector\n\n# No mutation of vectors once created, instead they\n# are \"evolved\" leaving the original untouched\n>>> v1 = v(1, 2, 3)\n>>> v2 = v1.append(4)\n>>> v3 = v2.set(1, 5)\n>>> v1\npvector([1, 2, 3])\n>>> v2\npvector([1, 2, 3, 4])\n>>> v3\npvector([1, 5, 3, 4])\n\n# Random access and slicing\n>>> v3[1]\n5\n>>> v3[1:3]\npvector([5, 3])\n\n# Iteration\n>>> list(x + 1 for x in v3)\n[2, 6, 4, 5]\n>>> pvector(2 * x for x in range(3))\npvector([0, 2, 4])\n```\n\n----------------------------------------\n\nTITLE: Using PMap in Python\nDESCRIPTION: Shows how to create and manipulate immutable maps using PMap. Demonstrates operations like set, access, nested structure evolution, merging, and iteration.\nSOURCE: https://github.com/tobgu/pyrsistent/blob/master/README.rst#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n>>> from pyrsistent import m, pmap, v\n\n# No mutation of maps once created, instead they are\n# \"evolved\" leaving the original untouched\n>>> m1 = m(a=1, b=2)\n>>> m2 = m1.set('c', 3)\n>>> m3 = m2.set('a', 5)\n>>> m1\npmap({'a': 1, 'b': 2})\n>>> m2\npmap({'a': 1, 'c': 3, 'b': 2})\n>>> m3\npmap({'a': 5, 'c': 3, 'b': 2})\n>>> m3['a']\n5\n\n# Evolution of nested persistent structures\n>>> m4 = m(a=5, b=6, c=v(1, 2))\n>>> m4.transform(('c', 1), 17)\npmap({'a': 5, 'c': pvector([1, 17]), 'b': 6})\n>>> m5 = m(a=1, b=2)\n\n# Evolve by merging with other mappings\n>>> m5.update(m(a=2, c=3), {'a': 17, 'd': 35})\npmap({'a': 17, 'c': 3, 'b': 2, 'd': 35})\n>>> pmap({'x': 1, 'y': 2}) + pmap({'y': 3, 'z': 4})\npmap({'y': 3, 'x': 1, 'z': 4})\n\n# Dict-like methods to convert to list and iterate\n>>> m3.items()\npvector([('a', 5), ('c', 3), ('b', 2)])\n>>> list(m3)\n['a', 'c', 'b']\n```\n\n----------------------------------------\n\nTITLE: PMap Usage Example in Python\nDESCRIPTION: Shows operations with PMap including creation, setting values, transforms, merging and iteration. PMap is an immutable dictionary implementation.\nSOURCE: https://github.com/tobgu/pyrsistent/blob/master/docs/source/intro.rst#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n>>> from pyrsistent import m, pmap, v\n\n# No mutation of maps once created, instead they are\n# \"evolved\" leaving the original untouched\n>>> m1 = m(a=1, b=2)\n>>> m2 = m1.set('c', 3)\n>>> m3 = m2.set('a', 5)\n>>> m1\npmap({'a': 1, 'b': 2})\n>>> m2\npmap({'a': 1, 'c': 3, 'b': 2})\n>>> m3\npmap({'a': 5, 'c': 3, 'b': 2})\n>>> m3['a']\n5\n\n# Evolution of nested persistent structures\n>>> m4 = m(a=5, b=6, c=v(1, 2))\n>>> m4.transform(('c', 1), 17)\npmap({'a': 5, 'c': pvector([1, 17]), 'b': 6})\n>>> m5 = m(a=1, b=2)\n\n# Evolve by merging with other mappings\n>>> m5.update(m(a=2, c=3), {'a': 17, 'd': 35})\npmap({'a': 17, 'c': 3, 'b': 2, 'd': 35})\n>>> pmap({'x': 1, 'y': 2}) + pmap({'y': 3, 'z': 4})\npmap({'y': 3, 'x': 1, 'z': 4})\n\n# Dict-like methods to convert to list and iterate\n>>> m3.items()\npvector([('a', 5), ('c', 3), ('b', 2)])\n>>> list(m3)\n['a', 'c', 'b']\n```\n\n----------------------------------------\n\nTITLE: Using PSet in Python\nDESCRIPTION: Illustrates the usage of immutable sets with PSet. Shows operations like add, remove, and set operations such as union, intersection, and comparison.\nSOURCE: https://github.com/tobgu/pyrsistent/blob/master/README.rst#2025-04-21_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n>>> from pyrsistent import s\n\n# No mutation of sets once created, you know the story...\n>>> s1 = s(1, 2, 3, 2)\n>>> s2 = s1.add(4)\n>>> s3 = s1.remove(1)\n>>> s1\npset([1, 2, 3])\n>>> s2\npset([1, 2, 3, 4])\n>>> s3\npset([2, 3])\n\n# Full support for set operations\n>>> s1 | s(3, 4, 5)\npset([1, 2, 3, 4, 5])\n>>> s1 & s(3, 4, 5)\npset([3])\n>>> s1 < s2\nTrue\n>>> s1 < s(3, 4, 5)\nFalse\n```\n\n----------------------------------------\n\nTITLE: PSet Usage Example in Python\nDESCRIPTION: Demonstrates PSet operations including creation, adding/removing elements and set operations. PSet is an immutable set implementation.\nSOURCE: https://github.com/tobgu/pyrsistent/blob/master/docs/source/intro.rst#2025-04-21_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n>>> from pyrsistent import s\n\n# No mutation of sets once created, you know the story...\n>>> s1 = s(1, 2, 3, 2)\n>>> s2 = s1.add(4)\n>>> s3 = s1.remove(1)\n>>> s1\npset([1, 2, 3])\n>>> s2\npset([1, 2, 3, 4])\n>>> s3\npset([2, 3])\n\n# Full support for set operations\n>>> s1 | s(3, 4, 5)\npset([1, 2, 3, 4, 5])\n>>> s1 & s(3, 4, 5)\npset([3])\n>>> s1 < s2\nTrue\n>>> s1 < s(3, 4, 5)\nFalse\n```\n\n----------------------------------------\n\nTITLE: Defining and Using PRecord in Python\nDESCRIPTION: Demonstrates how to define and use PRecord, a PMap with fixed fields. Shows basic usage, type checking, mandatory fields, and invariants.\nSOURCE: https://github.com/tobgu/pyrsistent/blob/master/README.rst#2025-04-21_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n>>> from pyrsistent import PRecord, field\n>>> class ARecord(PRecord):\n...     x = field()\n...\n>>> r = ARecord(x=3)\n>>> r\nARecord(x=3)\n>>> r.x\n3\n>>> r.set(x=2)\nARecord(x=2)\n>>> r.set(y=2)\nTraceback (most recent call last):\nAttributeError: 'y' is not among the specified fields for ARecord\n```\n\nLANGUAGE: python\nCODE:\n```\n>>> class BRecord(PRecord):\n...     x = field(type=int)\n...     y = field(type=(int, type(None)))\n...\n>>> BRecord(x=3, y=None)\nBRecord(y=None, x=3)\n>>> BRecord(x=3.0)\nTraceback (most recent call last):\nPTypeError: Invalid type for field BRecord.x, was float\n```\n\nLANGUAGE: python\nCODE:\n```\n>>> from pyrsistent import InvariantException\n>>> class CRecord(PRecord):\n...     x = field(mandatory=True)\n...\n>>> r = CRecord(x=3)\n>>> try:\n...    r.discard('x')\n... except InvariantException as e:\n...    print(e.missing_fields)\n...\n('CRecord.x',)\n```\n\nLANGUAGE: python\nCODE:\n```\n>>> class RestrictedVector(PRecord):\n...     __invariant__ = lambda r: (r.y >= r.x, 'x larger than y')\n...     x = field(invariant=lambda x: (x > 0, 'x negative'))\n...     y = field(invariant=lambda y: (y > 0, 'y negative'))\n...\n>>> r = RestrictedVector(y=3, x=2)\n>>> try:\n...    r.set(x=-1, y=-2)\n... except InvariantException as e:\n...    print(e.invariant_errors)\n...\n('y negative', 'x negative')\n>>> try:\n...    r.set(x=2, y=1)\n... except InvariantException as e:\n...    print(e.invariant_errors)\n...\n('x larger than y',)\n```\n\nLANGUAGE: python\nCODE:\n```\n>>> class EvenX(PRecord):\n...     x = field(invariant=lambda x: ((x > 0, 'x negative'), (x % 2 == 0, 'x odd')))\n...\n>>> try:\n```\n\n----------------------------------------\n\nTITLE: PRecord Usage Example in Python\nDESCRIPTION: Shows usage of PRecord for creating records with type checking, mandatory fields and invariants. PRecord is an immutable record type implementation.\nSOURCE: https://github.com/tobgu/pyrsistent/blob/master/docs/source/intro.rst#2025-04-21_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n>>> from pyrsistent import PRecord, field\n>>> class ARecord(PRecord):\n...     x = field()\n...\n>>> r = ARecord(x=3)\n>>> r\nARecord(x=3)\n>>> r.x\n3\n>>> r.set(x=2)\nARecord(x=2)\n>>> r.set(y=2)\nTraceback (most recent call last):\nAttributeError: 'y' is not among the specified fields for ARecord\n```\n\n----------------------------------------\n\nTITLE: Demonstrating PRecord Exception Handling in Python\nDESCRIPTION: Shows how to handle an InvariantException when creating a PRecord instance with invalid data.\nSOURCE: https://github.com/tobgu/pyrsistent/blob/master/README.rst#2025-04-21_snippet_4\n\nLANGUAGE: python\nCODE:\n```\ntry:\n    EvenX(x=-1)\nexcept InvariantException as e:\n   print(e.invariant_errors)\n\n(('x negative', 'x odd'),)\n```\n\n----------------------------------------\n\nTITLE: PRecord Type Checking Example in Python\nDESCRIPTION: Demonstrates type checking capabilities of PRecord fields including support for multiple types and custom type validation.\nSOURCE: https://github.com/tobgu/pyrsistent/blob/master/docs/source/intro.rst#2025-04-21_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n>>> class BRecord(PRecord):\n...     x = field(type=int)\n...     y = field(type=(int, type(None)))\n...\n>>> BRecord(x=3, y=None)\nBRecord(y=None, x=3)\n>>> BRecord(x=3.0)\nTraceback (most recent call last):\nPTypeError: Invalid type for field BRecord.x, was float\n```\n\n----------------------------------------\n\nTITLE: Creating PRecords with Factory Functions in Python\nDESCRIPTION: Demonstrates how to use factory functions for fields in PRecords, including nested PRecord fields.\nSOURCE: https://github.com/tobgu/pyrsistent/blob/master/README.rst#2025-04-21_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nclass DRecord(PRecord):\n    x = field(factory=int)\n\nclass ERecord(PRecord):\n    d = field(type=DRecord)\n\nERecord.create({'d': {'x': '1'}})\nERecord(d=DRecord(x=1))\n```\n\n----------------------------------------\n\nTITLE: PRecord Mandatory Fields Example in Python\nDESCRIPTION: Shows how to define and handle mandatory fields in PRecord with error handling for missing fields.\nSOURCE: https://github.com/tobgu/pyrsistent/blob/master/docs/source/intro.rst#2025-04-21_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n>>> from pyrsistent import InvariantException\n>>> class CRecord(PRecord):\n...     x = field(mandatory=True)\n...\n>>> r = CRecord(x=3)\n>>> try:\n...    r.discard('x')\n... except InvariantException as e:\n...    print(e.missing_fields)\n...\n('CRecord.x',)\n```\n\n----------------------------------------\n\nTITLE: Defining PRecords with Collection Fields in Python\nDESCRIPTION: Shows how to create PRecords with fields that are Pyrsistent collections like pset, pmap, and pvector.\nSOURCE: https://github.com/tobgu/pyrsistent/blob/master/README.rst#2025-04-21_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nfrom pyrsistent import pset_field, pmap_field, pvector_field\nclass MultiRecord(PRecord):\n    set_of_ints = pset_field(int)\n    map_int_to_str = pmap_field(int, str)\n    vector_of_strs = pvector_field(str)\n```\n\n----------------------------------------\n\nTITLE: PRecord Invariants Example in Python\nDESCRIPTION: Demonstrates how to implement and use invariants in PRecord for both field and record level validation with error handling.\nSOURCE: https://github.com/tobgu/pyrsistent/blob/master/docs/source/intro.rst#2025-04-21_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n>>> class RestrictedVector(PRecord):\n...     __invariant__ = lambda r: (r.y >= r.x, 'x larger than y')\n...     x = field(invariant=lambda x: (x > 0, 'x negative'))\n...     y = field(invariant=lambda y: (y > 0, 'y negative'))\n...\n>>> r = RestrictedVector(y=3, x=2)\n>>> try:\n...    r.set(x=-1, y=-2)\n... except InvariantException as e:\n...    print(e.invariant_errors)\n...\n('y negative', 'x negative')\n>>> try:\n...    r.set(x=2, y=1)\n... except InvariantException as e:\n...    print(e.invariant_errors)\n...\n('x larger than y',)\n```\n\n----------------------------------------\n\nTITLE: Serializing PRecords with Custom Functions in Python\nDESCRIPTION: Demonstrates how to use custom serialization functions for PRecord fields, such as formatting dates.\nSOURCE: https://github.com/tobgu/pyrsistent/blob/master/README.rst#2025-04-21_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nfrom datetime import date\nclass Person(PRecord):\n    name = field(type=unicode)\n    birth_date = field(type=date,\n                       serializer=lambda format, d: d.strftime(format['date']))\n\njohn = Person(name=u'John', birth_date=date(1985, 10, 21))\njohn.serialize({'date': '%Y-%m-%d'})\n{'birth_date': '1985-10-21', 'name': u'John'}\n```\n\n----------------------------------------\n\nTITLE: PRecord Multiple Invariants Example in Python\nDESCRIPTION: Shows how to implement multiple invariants for a single field in PRecord with corresponding error handling.\nSOURCE: https://github.com/tobgu/pyrsistent/blob/master/docs/source/intro.rst#2025-04-21_snippet_7\n\nLANGUAGE: python\nCODE:\n```\n>>> class EvenX(PRecord):\n...     x = field(invariant=lambda x: ((x > 0, 'x negative'), (x % 2 == 0, 'x odd')))\n...\n>>> try:\n```\n\n----------------------------------------\n\nTITLE: Defining and Using PClass in Python\nDESCRIPTION: Shows how to create a PClass, which is similar to PRecord but behaves like a plain Python object.\nSOURCE: https://github.com/tobgu/pyrsistent/blob/master/README.rst#2025-04-21_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nfrom pyrsistent import PClass, field\nclass AClass(PClass):\n    x = field()\n\na = AClass(x=3)\na\nAClass(x=3)\na.x\n3\n```\n\n----------------------------------------\n\nTITLE: Demonstrating PRecord Field Invariants in Python\nDESCRIPTION: This snippet shows how to define and use invariants on PRecord fields, including handling exceptions when invariants are violated.\nSOURCE: https://github.com/tobgu/pyrsistent/blob/master/docs/source/intro.rst#2025-04-21_snippet_8\n\nLANGUAGE: python\nCODE:\n```\n...    EvenX(x=-1)\n... except InvariantException as e:\n...    print(e.invariant_errors)\n...\n(('x negative', 'x odd'),)\n```\n\n----------------------------------------\n\nTITLE: Creating and Using Checked Collections in Python\nDESCRIPTION: Demonstrates how to create and use checked versions of PVector, PMap, and PSet with type and invariant checks.\nSOURCE: https://github.com/tobgu/pyrsistent/blob/master/README.rst#2025-04-21_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nfrom pyrsistent import CheckedPVector, CheckedPMap, CheckedPSet, thaw\nclass Positives(CheckedPSet):\n    __type__ = (long, int)\n    __invariant__ = lambda n: (n >= 0, 'Negative')\n\nclass Lottery(PRecord):\n    name = field(type=str)\n    numbers = field(type=Positives, invariant=lambda p: (len(p) > 0, 'No numbers'))\n\nclass Lotteries(CheckedPVector):\n    __type__ = Lottery\n\nclass LotteriesByDate(CheckedPMap):\n    __key_type__ = date\n    __value_type__ = Lotteries\n\nlotteries = LotteriesByDate.create({date(2015, 2, 15): [{'name': 'SuperLotto', 'numbers': {1, 2, 3}},\n                                                        {'name': 'MegaLotto',  'numbers': {4, 5, 6}}],\n                                    date(2015, 2, 16): [{'name': 'SuperLotto', 'numbers': {3, 2, 1}},\n                                                        {'name': 'MegaLotto',  'numbers': {6, 5, 4}}]})\nlotteries\n\nlottery_0215 = lotteries[date(2015, 2, 15)]\nlottery_0215.transform([0, 'name'], 'SuperDuperLotto')\n\nthaw(lottery_0215)\nlottery_0215.serialize()\n```\n\n----------------------------------------\n\nTITLE: Creating PRecords with Factory Functions in Python\nDESCRIPTION: This example demonstrates how to use factory functions for fields in PRecords, including nested PRecord fields.\nSOURCE: https://github.com/tobgu/pyrsistent/blob/master/docs/source/intro.rst#2025-04-21_snippet_9\n\nLANGUAGE: python\nCODE:\n```\n>>> class DRecord(PRecord):\n...     x = field(factory=int)\n...\n>>> class ERecord(PRecord):\n...     d = field(type=DRecord)\n...\n>>> ERecord.create({'d': {'x': '1'}})\nERecord(d=DRecord(x=1))\n```\n\n----------------------------------------\n\nTITLE: Performing Transformations on Pyrsistent Data Structures\nDESCRIPTION: Shows various ways to transform Pyrsistent data structures using the transform method and different matchers.\nSOURCE: https://github.com/tobgu/pyrsistent/blob/master/README.rst#2025-04-21_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nfrom pyrsistent import inc, freeze, thaw, rex, ny, discard\nv1 = freeze([1, 2, 3, 4, 5])\nv1.transform([2], inc)\nv1.transform([lambda ix: 0 < ix < 4], 8)\nv1.transform([lambda ix, v: ix == 0 or v == 5], 0)\n\nv1.transform([ny], 8)\n\nscores = freeze({'John': 12, 'Joseph': 34, 'Sara': 23})\nscores.transform([rex('^Jo')], 0)\n\nnews_paper = freeze({'articles': [{'author': 'Sara', 'content': 'A short article'},\n                                  {'author': 'Steve', 'content': 'A slightly longer article'}],\n                     'weather': {'temperature': '11C', 'wind': '5m/s'}})\nshort_news = news_paper.transform(['articles', ny, 'content'], lambda c: c[:25] + '...' if len(c) > 25 else c)\nvery_short_news = news_paper.transform(['articles', ny, 'content'], lambda c: c[:15] + '...' if len(c) > 15 else c)\n\nthaw(news_paper.transform(['weather'], discard, ['articles', ny, 'content'], discard))\n```\n\n----------------------------------------\n\nTITLE: Defining PRecords with Collection Fields in Python\nDESCRIPTION: This snippet shows how to create PRecords with fields that are pyrsistent collections like pset, pmap, and pvector.\nSOURCE: https://github.com/tobgu/pyrsistent/blob/master/docs/source/intro.rst#2025-04-21_snippet_10\n\nLANGUAGE: python\nCODE:\n```\n>>> from pyrsistent import pset_field, pmap_field, pvector_field\n>>> class MultiRecord(PRecord):\n...     set_of_ints = pset_field(int)\n...     map_int_to_str = pmap_field(int, str)\n...     vector_of_strs = pvector_field(str)\n...\n```\n\n----------------------------------------\n\nTITLE: Using Evolvers with Pyrsistent Data Structures\nDESCRIPTION: Demonstrates how to use evolvers to perform efficient updates on immutable data structures.\nSOURCE: https://github.com/tobgu/pyrsistent/blob/master/README.rst#2025-04-21_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nfrom pyrsistent import v\n\nv1 = v(1, 2, 3)\ne = v1.evolver()\ne[1] = 22\ne = e.append(4)\ne = e.extend([5, 6])\ne[5] += 1\nlen(e)\n\ne.is_dirty()\n\nv1\n\nv2 = e.persistent()\nv2\n\ne.is_dirty()\n```\n\n----------------------------------------\n\nTITLE: Serializing PRecords with Custom Serialization Functions in Python\nDESCRIPTION: This example demonstrates how to implement custom serialization for PRecord fields, including handling date objects.\nSOURCE: https://github.com/tobgu/pyrsistent/blob/master/docs/source/intro.rst#2025-04-21_snippet_11\n\nLANGUAGE: python\nCODE:\n```\n>>> from datetime import date\n>>> class Person(PRecord):\n...     name = field(type=unicode)\n...     birth_date = field(type=date,\n...                        serializer=lambda format, d: d.strftime(format['date']))\n...\n>>> john = Person(name=u'John', birth_date=date(1985, 10, 21))\n>>> john.serialize({'date': '%Y-%m-%d'})\n{'birth_date': '1985-10-21', 'name': u'John'}\n```\n\n----------------------------------------\n\nTITLE: Using Evolvers with PVectors in Pyrsistent\nDESCRIPTION: Demonstrates how to use evolvers to modify immutable PVectors independently without affecting the original data structure, then persist the changes to create new immutable structures.\nSOURCE: https://github.com/tobgu/pyrsistent/blob/master/README.rst#2025-04-21_snippet_12\n\nLANGUAGE: python\nCODE:\n```\n# You may continue to work with the same evolver without affecting the content of v2\n>>> e[0] = 11\n\n# Or create a new evolver from v2. The two evolvers can be updated independently but will both\n# share data with v2 where possible.\n>>> e2 = v2.evolver()\n>>> e2[0] = 1111\n>>> e.persistent()\npvector([11, 22, 3, 4, 5, 7])\n>>> e2.persistent()\npvector([1111, 22, 3, 4, 5, 7])\n```\n\n----------------------------------------\n\nTITLE: Defining and Using PClass in Python\nDESCRIPTION: This snippet shows how to create and use a PClass, which is similar to a PRecord but behaves like a plain Python object.\nSOURCE: https://github.com/tobgu/pyrsistent/blob/master/docs/source/intro.rst#2025-04-21_snippet_12\n\nLANGUAGE: python\nCODE:\n```\n>>> from pyrsistent import PClass, field\n>>> class AClass(PClass):\n...     x = field()\n...\n>>> a = AClass(x=3)\n>>> a\nAClass(x=3)\n>>> a.x\n3\n```\n\n----------------------------------------\n\nTITLE: Converting Between Mutable and Immutable Structures with freeze and thaw\nDESCRIPTION: Shows how to convert between Python's built-in mutable data structures and pyrsistent's immutable data structures using freeze and thaw functions.\nSOURCE: https://github.com/tobgu/pyrsistent/blob/master/README.rst#2025-04-21_snippet_13\n\nLANGUAGE: python\nCODE:\n```\n>>> from pyrsistent import freeze, thaw, v, m\n>>> freeze([1, {'a': 3}])\npvector([1, pmap({'a': 3})])\n>>> thaw(v(1, m(a=3)))\n[1, {'a': 3}]\n```\n\n----------------------------------------\n\nTITLE: Using Checked Collections in Python with Pyrsistent\nDESCRIPTION: This example demonstrates the use of checked collections (CheckedPVector, CheckedPMap, CheckedPSet) with type and invariant checks.\nSOURCE: https://github.com/tobgu/pyrsistent/blob/master/docs/source/intro.rst#2025-04-21_snippet_13\n\nLANGUAGE: python\nCODE:\n```\n>>> from pyrsistent import CheckedPVector, CheckedPMap, CheckedPSet, thaw\n>>> class Positives(CheckedPSet):\n...     __type__ = (long, int)\n...     __invariant__ = lambda n: (n >= 0, 'Negative')\n...\n>>> class Lottery(PRecord):\n...     name = field(type=str)\n...     numbers = field(type=Positives, invariant=lambda p: (len(p) > 0, 'No numbers'))\n...\n>>> class Lotteries(CheckedPVector):\n...     __type__ = Lottery\n...\n>>> class LotteriesByDate(CheckedPMap):\n...     __key_type__ = date\n...     __value_type__ = Lotteries\n...\n>>> lotteries = LotteriesByDate.create({date(2015, 2, 15): [{'name': 'SuperLotto', 'numbers': {1, 2, 3}},\n...                                                         {'name': 'MegaLotto',  'numbers': {4, 5, 6}}],\n...                                     date(2015, 2, 16): [{'name': 'SuperLotto', 'numbers': {3, 2, 1}},\n...                                                         {'name': 'MegaLotto',  'numbers': {6, 5, 4}}]})\n>>> lotteries\nLotteriesByDate({datetime.date(2015, 2, 15): Lotteries([Lottery(numbers=Positives([1, 2, 3]), name='SuperLotto'), Lottery(numbers=Positives([4, 5, 6]), name='MegaLotto')]), datetime.date(2015, 2, 16): Lotteries([Lottery(numbers=Positives([1, 2, 3]), name='SuperLotto'), Lottery(numbers=Positives([4, 5, 6]), name='MegaLotto')])})\n\n# The checked versions support all operations that the corresponding\n# unchecked types do\n>>> lottery_0215 = lotteries[date(2015, 2, 15)]\n>>> lottery_0215.transform([0, 'name'], 'SuperDuperLotto')\nLotteries([Lottery(numbers=Positives([1, 2, 3]), name='SuperDuperLotto'), Lottery(numbers=Positives([4, 5, 6]), name='MegaLotto')])\n\n# But also makes asserts that types and invariants hold\n>>> lottery_0215.transform([0, 'name'], 999)\nTraceback (most recent call last):\nPTypeError: Invalid type for field Lottery.name, was int\n\n>>> lottery_0215.transform([0, 'numbers'], set())\nTraceback (most recent call last):\nInvariantException: Field invariant failed\n\n# They can be converted back to python built ins with either thaw()\n# or serialize() (which provides possibilities to customize serialization)\n>>> thaw(lottery_0215)\n[{'numbers': set([1, 2, 3]), 'name': 'SuperLotto'}, {'numbers': set([4, 5, 6]), 'name': 'MegaLotto'}]\n>>> lottery_0215.serialize()\n[{'numbers': set([1, 2, 3]), 'name': 'SuperLotto'}, {'numbers': set([4, 5, 6]), 'name': 'MegaLotto'}]\n```\n\n----------------------------------------\n\nTITLE: Controlling Recursion with freeze Using the strict Parameter\nDESCRIPTION: Demonstrates how to control the recursive behavior of freeze when converting nested data structures, by using the strict parameter to limit how deeply nested structures are converted.\nSOURCE: https://github.com/tobgu/pyrsistent/blob/master/README.rst#2025-04-21_snippet_14\n\nLANGUAGE: python\nCODE:\n```\n>>> from pyrsistent import freeze, v, m\n>>> freeze(v(1, v(2, [3])))\npvector([1, pvector([2, pvector([3])])])\n>>> freeze(v(1, v(2, [3])), strict=False)\npvector([1, pvector([2, [3]])])\n>>> freeze(m(a=m(b={'c': 1})))\npmap({'a': pmap({'b': pmap({'c': 1})})})}\n>>> freeze(m(a=m(b={'c': 1})), strict=False)\npmap({'a': pmap({'b': {'c': 1}})})\n```\n\n----------------------------------------\n\nTITLE: Performing Transformations on Pyrsistent Data Structures in Python\nDESCRIPTION: This snippet demonstrates various transformation operations on pyrsistent data structures, including deep transformations and pattern matching.\nSOURCE: https://github.com/tobgu/pyrsistent/blob/master/docs/source/intro.rst#2025-04-21_snippet_14\n\nLANGUAGE: python\nCODE:\n```\n# Basic examples\n>>> from pyrsistent import inc, freeze, thaw, rex, ny, discard\n>>> v1 = freeze([1, 2, 3, 4, 5])\n>>> v1.transform([2], inc)\npvector([1, 2, 4, 4, 5])\n>>> v1.transform([lambda ix: 0 < ix < 4], 8)\npvector([1, 8, 8, 8, 5])\n>>> v1.transform([lambda ix, v: ix == 0 or v == 5], 0)\npvector([0, 2, 3, 4, 0])\n\n# The (a)ny matcher can be used to match anything\n>>> v1.transform([ny], 8)\npvector([8, 8, 8, 8, 8])\n\n# Regular expressions can be used for matching\n>>> scores = freeze({'John': 12, 'Joseph': 34, 'Sara': 23})\n>>> scores.transform([rex('^Jo')], 0)\npmap({'Joseph': 0, 'Sara': 23, 'John': 0})\n\n# Transformations can be done on arbitrarily deep structures\n>>> news_paper = freeze({'articles': [{'author': 'Sara', 'content': 'A short article'},\n...                                   {'author': 'Steve', 'content': 'A slightly longer article'}],\n...                      'weather': {'temperature': '11C', 'wind': '5m/s'}})\n>>> short_news = news_paper.transform(['articles', ny, 'content'], lambda c: c[:25] + '...' if len(c) > 25 else c)\n>>> very_short_news = news_paper.transform(['articles', ny, 'content'], lambda c: c[:15] + '...' if len(c) > 15 else c)\n>>> very_short_news.articles[0].content\n'A short article'\n>>> very_short_news.articles[1].content\n'A slightly long...'\n\n# When nothing has been transformed the original data structure is kept\n>>> short_news is news_paper\nTrue\n>>> very_short_news is news_paper\nFalse\n>>> very_short_news.articles[0] is news_paper.articles[0]\nTrue\n\n# There is a special transformation that can be used to discard elements. Also\n# multiple transformations can be applied in one call\n>>> thaw(news_paper.transform(['weather'], discard, ['articles', ny, 'content'], discard))\n{'articles': [{'author': 'Sara'}, {'author': 'Steve'}]}\n```\n\n----------------------------------------\n\nTITLE: Using Evolvers with Pyrsistent Data Structures in Python\nDESCRIPTION: This example shows how to use evolvers, which provide a mutable view of immutable data structures for efficient updates.\nSOURCE: https://github.com/tobgu/pyrsistent/blob/master/docs/source/intro.rst#2025-04-21_snippet_15\n\nLANGUAGE: python\nCODE:\n```\n>>> from pyrsistent import v\n\n# In place mutation as when working with the built in counterpart\n>>> v1 = v(1, 2, 3)\n>>> e = v1.evolver()\n>>> e[1] = 22\n>>> e = e.append(4)\n>>> e = e.extend([5, 6])\n>>> e[5] += 1\n>>> len(e)\n6\n\n# The evolver is considered *dirty* when it contains changes compared to the underlying vector\n>>> e.is_dirty()\nTrue\n\n# But the underlying pvector still remains untouched\n>>> v1\npvector([1, 2, 3])\n\n# Once satisfied with the updates you can produce a new pvector containing the updates.\n# The new pvector will share data with the original pvector in the same way that would have\n# been done if only using operations on the pvector.\n>>> v2 = e.persistent()\n>>> v2\npvector([1, 22, 3, 4, 5, 7])\n\n# The evolver is now no longer considered *dirty* as it contains no differences compared to the\n# pvector just produced.\n>>> e.is_dirty()\n```\n\n----------------------------------------\n\nTITLE: Using Evolvers in pyrsistent\nDESCRIPTION: Demonstrates how to work with evolvers to modify immutable data structures without affecting the original. Shows that multiple evolvers can share data with the original structure while being updated independently.\nSOURCE: https://github.com/tobgu/pyrsistent/blob/master/docs/source/intro.rst#2025-04-21_snippet_16\n\nLANGUAGE: python\nCODE:\n```\n>>> e[0] = 11\n\n# Or create a new evolver from v2. The two evolvers can be updated independently but will both\n# share data with v2 where possible.\n>>> e2 = v2.evolver()\n>>> e2[0] = 1111\n>>> e.persistent()\npvector([11, 22, 3, 4, 5, 7])\n>>> e2.persistent()\npvector([1111, 22, 3, 4, 5, 7])\n```\n\n----------------------------------------\n\nTITLE: Converting Between Mutable and Immutable Structures with freeze and thaw\nDESCRIPTION: Demonstrates the use of freeze and thaw functions to convert between mutable Python data structures and immutable pyrsistent structures. These functions help to integrate pyrsistent with code that uses mutable data structures.\nSOURCE: https://github.com/tobgu/pyrsistent/blob/master/docs/source/intro.rst#2025-04-21_snippet_17\n\nLANGUAGE: python\nCODE:\n```\n>>> from pyrsistent import freeze, thaw, v, m\n>>> freeze([1, {'a': 3}])\npvector([1, pmap({'a': 3})])\n>>> thaw(v(1, m(a=3)))\n[1, {'a': 3}]\n```\n\n----------------------------------------\n\nTITLE: Controlling Recursion in freeze and thaw with strict Flag\nDESCRIPTION: Shows how to control the recursive conversion behavior of freeze and thaw using the strict parameter. When strict=False, freeze and thaw will not convert nested structures completely.\nSOURCE: https://github.com/tobgu/pyrsistent/blob/master/docs/source/intro.rst#2025-04-21_snippet_18\n\nLANGUAGE: python\nCODE:\n```\n>>> from pyrsistent import freeze, v, m\n>>> freeze(v(1, v(2, [3])))\npvector([1, pvector([2, pvector([3])])])\n>>> freeze(v(1, v(2, [3])), strict=False)\npvector([1, pvector([2, [3]])])\n>>> freeze(m(a=m(b={'c': 1})))\npmap({'a': pmap({'b': pmap({'c': 1})})})\n>>> freeze(m(a=m(b={'c': 1})), strict=False)\npmap({'a': pmap({'b': {'c': 1}})})\n```\n\n----------------------------------------\n\nTITLE: Configuring Sphinx Table of Contents for Pyrsistent Documentation\nDESCRIPTION: This snippet defines the table of contents structure for the Pyrsistent documentation using Sphinx's toctree directive. It includes links to introduction, API documentation, and change log pages.\nSOURCE: https://github.com/tobgu/pyrsistent/blob/master/docs/source/index.rst#2025-04-21_snippet_0\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. toctree::\n   :maxdepth: 2\n\n   intro\n   api\n   changes\n```\n\n----------------------------------------\n\nTITLE: Listing Development Dependencies for Pyrsistent\nDESCRIPTION: Specifies the required Python packages and their versions needed for development tasks including testing (pytest, hypothesis), performance testing (pyperform), documentation (Sphinx), and package distribution (setuptools, twine).\nSOURCE: https://github.com/tobgu/pyrsistent/blob/master/requirements.txt#2025-04-21_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\nhypothesis\nmemory-profiler==0.57.0\npsutil==5.7.0\npyperform\npytest\nSphinx\nsphinx-rtd-theme\ntox\nsetuptools>=0.16.1\ntwine>=3.2\npip>=20.2.3\npip-tools\n```\n\n----------------------------------------\n\nTITLE: Generating Python Package Requirements with pip-compile\nDESCRIPTION: This code snippet shows the command used to generate the requirements file using pip-compile. It specifies the Python version and input file used for compilation.\nSOURCE: https://github.com/tobgu/pyrsistent/blob/master/docs/requirements.txt#2025-04-21_snippet_0\n\nLANGUAGE: Shell\nCODE:\n```\n#    pip-compile requirements.in\n```"
  }
]