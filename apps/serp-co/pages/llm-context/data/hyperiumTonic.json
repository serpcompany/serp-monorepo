[
  {
    "owner": "hyperium",
    "repo": "tonic",
    "content": "TITLE: Complete Protocol Buffer definition\nDESCRIPTION: The complete Protocol Buffer definition file for the HelloWorld service including service and message types.\nSOURCE: https://github.com/hyperium/tonic/blob/master/examples/helloworld-tutorial.md#_snippet_6\n\nLANGUAGE: proto\nCODE:\n```\nsyntax = \"proto3\";\npackage helloworld;\n\nservice Greeter {\n    rpc SayHello (HelloRequest) returns (HelloReply);\n}\n\nmessage HelloRequest {\n   string name = 1;\n}\n\nmessage HelloReply {\n    string message = 1;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining gRPC Service in Protocol Buffers\nDESCRIPTION: Protocol Buffer definitions for the RouteGuide service with four types of RPC methods: simple RPC, server-side streaming, client-side streaming, and bidirectional streaming.\nSOURCE: https://github.com/hyperium/tonic/blob/master/examples/routeguide-tutorial.md#_snippet_6\n\nLANGUAGE: proto\nCODE:\n```\nservice RouteGuide {\n   ...\n}\n```\n\nLANGUAGE: proto\nCODE:\n```\n   // Obtains the feature at a given position.\n   rpc GetFeature(Point) returns (Feature) {}\n```\n\nLANGUAGE: proto\nCODE:\n```\n  // Obtains the Features available within the given Rectangle.  Results are\n  // streamed rather than returned at once (e.g. in a response message with a\n  // repeated field), as the rectangle may cover a large area and contain a\n  // huge number of features.\n  rpc ListFeatures(Rectangle) returns (stream Feature) {}\n```\n\nLANGUAGE: proto\nCODE:\n```\n  // Accepts a stream of Points on a route being traversed, returning a\n  // RouteSummary when traversal is completed.\n  rpc RecordRoute(stream Point) returns (RouteSummary) {}\n```\n\nLANGUAGE: proto\nCODE:\n```\n  // Accepts a stream of RouteNotes sent while a route is being traversed,\n  // while receiving other RouteNotes (e.g. from other users).\n  rpc RouteChat(stream RouteNote) returns (stream RouteNote) {}\n```\n\nLANGUAGE: proto\nCODE:\n```\n// Points are represented as latitude-longitude pairs in the E7 representation\n// (degrees multiplied by 10**7 and rounded to the nearest integer).\n// Latitudes should be in the range +/- 90 degrees and longitude should be in\n// the range +/- 180 degrees (inclusive).\nmessage Point {\n  int32 latitude = 1;\n  int32 longitude = 2;\n}\n```\n\n----------------------------------------\n\nTITLE: Starting Tonic gRPC Server Main Function in Rust\nDESCRIPTION: Defines the asynchronous main function to start the Tonic gRPC server. It parses the server address, creates the RouteGuide service instance, wraps it in a `RouteGuideServer` service handler, and binds the server to the specified address, awaiting connections.\nSOURCE: https://github.com/hyperium/tonic/blob/master/examples/routeguide-tutorial.md#_snippet_20\n\nLANGUAGE: Rust\nCODE:\n```\n#[tokio::main]\nasync fn main() -> Result<(), Box<dyn std::error::Error>> {\n    let addr = \"[::1]:10000\".parse().unwrap();\n\n    let route_guide = RouteGuideService {\n        features: Arc::new(data::load()),\n    };\n\n    let svc = RouteGuideServer::new(route_guide);\n\n    Server::builder().add_service(svc).serve(addr).await?;\n\n    Ok(())\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing list_features Server-Side Streaming in Rust\nDESCRIPTION: This code implements the `list_features` RPC, which is a server-side streaming gRPC call. It takes a `Rectangle` as input, filters features based on whether they are within the given rectangle's bounds, and streams the matching features to the client. It utilizes a channel (`mpsc::channel`) to send the features asynchronously, and `tokio::spawn` to run the filtering logic in a separate task.\nSOURCE: https://github.com/hyperium/tonic/blob/master/examples/routeguide-tutorial.md#_snippet_16\n\nLANGUAGE: rust\nCODE:\n```\ntype ListFeaturesStream = ReceiverStream<Result<Feature, Status>>;\n\nasync fn list_features(\n    &self,\n    request: Request<Rectangle>,\n) -> Result<Response<Self::ListFeaturesStream>, Status> {\n    let (tx, rx) = mpsc::channel(4);\n    let features = self.features.clone();\n\n    tokio::spawn(async move {\n        for feature in &features[..] {\n            if in_range(feature.location.as_ref().unwrap(), request.get_ref()) {\n                tx.send(Ok(feature.clone())).await.unwrap();\n            }\n        }\n    });\n\n    Ok(Response::new(ReceiverStream::new(rx)))\n}\n```\n\n----------------------------------------\n\nTITLE: Compiling Proto Files with tonic-build in build.rs (Rust)\nDESCRIPTION: A minimal Rust build script that compiles a single proto file using tonic-build's compile_protos function. It returns a Result to handle errors gracefully and ensures the proto file located at \"proto/service.proto\" is processed to generate Rust code for gRPC stubs.\nSOURCE: https://github.com/hyperium/tonic/blob/master/tonic-build/README.md#_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nfn main() -> Result<(), Box<dyn std::error::Error>> {\n    tonic_build::compile_protos(\"proto/service.proto\")?;\n    Ok(())\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing record_route Client-Side Streaming in Rust\nDESCRIPTION: This code implements the `record_route` RPC, a client-side streaming gRPC call. It receives a stream of `Point`s from the client, calculates distance, counts features, and finally returns a `RouteSummary` containing statistics about the route.  The code iterates over the stream of points, performs calculations within a `while let` loop, and aggregates data to build the summary.\nSOURCE: https://github.com/hyperium/tonic/blob/master/examples/routeguide-tutorial.md#_snippet_17\n\nLANGUAGE: rust\nCODE:\n```\nuse std::time::Instant;\nuse tokio_stream::StreamExt;\n```\n\nLANGUAGE: rust\nCODE:\n```\nasync fn record_route(\n    &self,\n    request: Request<tonic::Streaming<Point>>,\n) -> Result<Response<RouteSummary>, Status> {\n    let mut stream = request.into_inner();\n\n    let mut summary = RouteSummary::default();\n    let mut last_point = None;\n    let now = Instant::now();\n\n    while let Some(point) = stream.next().await {\n        let point = point?;\n        summary.point_count += 1;\n\n        for feature in &self.features[..] {\n            if feature.location.as_ref() == Some(&point) {\n                summary.feature_count += 1;\n            }\n        }\n\n        if let Some(ref last_point) = last_point {\n            summary.distance += calc_distance(last_point, &point);\n        }\n\n        last_point = Some(point);\n    }\n\n    summary.elapsed_time = now.elapsed().as_secs() as i32;\n\n    Ok(Response::new(summary))\n}\n```\n\n----------------------------------------\n\nTITLE: Complete gRPC server implementation\nDESCRIPTION: The complete server implementation that combines imports, service implementation, and runtime setup to create a functional gRPC server.\nSOURCE: https://github.com/hyperium/tonic/blob/master/examples/helloworld-tutorial.md#_snippet_12\n\nLANGUAGE: rust\nCODE:\n```\nuse tonic::{transport::Server, Request, Response, Status};\n\nuse hello_world::greeter_server::{Greeter, GreeterServer};\nuse hello_world::{HelloReply, HelloRequest};\n\npub mod hello_world {\n    tonic::include_proto!(\"helloworld\");\n}\n\n#[derive(Debug, Default)]\npub struct MyGreeter {}\n\n#[tonic::async_trait]\nimpl Greeter for MyGreeter {\n    async fn say_hello(\n        &self,\n        request: Request<HelloRequest>,\n    ) -> Result<Response<HelloReply>, Status> {\n        println!(\"Got a request: {:?}\", request);\n\n        let reply = HelloReply {\n            message: format!(\"Hello {}!\", request.into_inner().name),\n        };\n\n        Ok(Response::new(reply))\n    }\n}\n\n#[tokio::main]\nasync fn main() -> Result<(), Box<dyn std::error::Error>> {\n    let addr = \"[::1]:50051\".parse()?;\n    let greeter = MyGreeter::default();\n\n    Server::builder()\n        .add_service(GreeterServer::new(greeter))\n        .serve(addr)\n        .await?;\n\n    Ok()\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing route_chat Bidirectional Streaming in Rust\nDESCRIPTION: This code implements the `route_chat` RPC, a bidirectional streaming gRPC call. It receives a stream of `RouteNote`s from the client and returns a stream of `RouteNote`s. The code uses the `async_stream` crate to transform the input stream into an output stream. It stores the notes based on location and yields cloned notes back to the client. The implementation includes the use of `HashMap` and demonstrates the complexity of bidirectional streaming.\nSOURCE: https://github.com/hyperium/tonic/blob/master/examples/routeguide-tutorial.md#_snippet_18\n\nLANGUAGE: rust\nCODE:\n```\nuse std::collections::HashMap;\n```\n\nLANGUAGE: rust\nCODE:\n```\ntype RouteChatStream =\n    Pin<Box<dyn Stream<Item = Result<RouteNote, Status>> + Send  + 'static>>;\n\n\nasync fn route_chat(\n    &self,\n    request: Request<tonic::Streaming<RouteNote>>,\n) -> Result<Response<Self::RouteChatStream>, Status> {\n    let mut notes = HashMap::new();\n    let mut stream = request.into_inner();\n\n    let output = async_stream::try_stream! {\n        while let Some(note) = stream.next().await {\n            let note = note?;\n\n            let location = note.location.unwrap();\n\n            let location_notes = notes.entry(location).or_insert(vec![]);\n            location_notes.push(note);\n\n            for note in location_notes {\n                yield note.clone();\n            }\n        }\n    };\n\n    Ok(Response::new(Box::pin(output)\n        as Self::RouteChatStream))\n\n}\n```\n\n----------------------------------------\n\nTITLE: Including Proto Definitions in Rust\nDESCRIPTION: This code uses the `include_proto!` macro from Tonic to include the generated gRPC code, based on the .proto definition, into the scope of the project. This allows the code to use the generated types for messages and service definitions, enabling communication with the gRPC server. The correct path for the generated code depends on the `OUT_DIR` environment variable set by Cargo.\nSOURCE: https://github.com/hyperium/tonic/blob/master/examples/routeguide-tutorial.md#_snippet_11\n\nLANGUAGE: rust\nCODE:\n```\npub mod routeguide {\n    tonic::include_proto!(\"routeguide\");\n}\n\nuse routeguide::route_guide_server::{RouteGuide, RouteGuideServer};\nuse routeguide::{Feature, Point, Rectangle, RouteNote, RouteSummary};\n```\n\n----------------------------------------\n\nTITLE: Calling Tonic Bidirectional Streaming RPC `route_chat` in Rust\nDESCRIPTION: Implements an asynchronous function to call the bidirectional streaming RPC `route_chat`. It creates an outbound stream of `RouteNote` messages using `async_stream!` with a one-second interval, sends it as a request, and then processes the inbound stream of `RouteNote` messages received from the server.\nSOURCE: https://github.com/hyperium/tonic/blob/master/examples/routeguide-tutorial.md#_snippet_33\n\nLANGUAGE: Rust\nCODE:\n```\nasync fn run_route_chat(client: &mut RouteGuideClient<Channel>) -> Result<(), Box<dyn Error>> {\n    let start = time::Instant::now();\n\n    let outbound = async_stream::stream! {\n        let mut interval = time::interval(Duration::from_secs(1));\n\n        while let time = interval.tick().await {\n            let elapsed = time.duration_since(start);\n            let note = RouteNote {\n                location: Some(Point {\n                    latitude: 409146138 + elapsed.as_secs() as i32,\n                    longitude: -746188906,\n                }),\n                message: format!(\"at {:?}\", elapsed),\n            };\n\n            yield note;\n        }\n    };\n\n    let response = client.route_chat(Request::new(outbound)).await?;\n    let mut inbound = response.into_inner();\n\n    while let Some(note) = inbound.message().await? {\n        println!(\"NOTE = {:?}\", note);\n    }\n\n    Ok(())\n}\n```\n\n----------------------------------------\n\nTITLE: Importing dependencies for gRPC client\nDESCRIPTION: Client-side code to import necessary dependencies including the generated gRPC client and Protocol Buffer types.\nSOURCE: https://github.com/hyperium/tonic/blob/master/examples/helloworld-tutorial.md#_snippet_14\n\nLANGUAGE: rust\nCODE:\n```\nuse hello_world::greeter_client::GreeterClient;\nuse hello_world::HelloRequest;\n\npub mod hello_world {\n    tonic::include_proto!(\"helloworld\");\n}\n```\n\n----------------------------------------\n\nTITLE: Connecting Tonic gRPC Client in Rust Main Function\nDESCRIPTION: Defines the main asynchronous function for the client application. It connects to the running gRPC server at the specified URL (`http://[::1]:10000`) using `RouteGuideClient::connect`. The resulting client instance is made mutable to manage internal state.\nSOURCE: https://github.com/hyperium/tonic/blob/master/examples/routeguide-tutorial.md#_snippet_24\n\nLANGUAGE: Rust\nCODE:\n```\n    let mut client = RouteGuideClient::connect(\"http://[::1]:10000\").await?;\n\n     Ok(())\n}\n```\n\n----------------------------------------\n\nTITLE: Extracting ErrorDetails from tonic::Status on Client Side (Rust)\nDESCRIPTION: Shows how a `tonic` client can handle a `Result<Response<T>, Status>` from a gRPC call, specifically focusing on extracting richer error details. It uses the `StatusExt` trait's `get_error_details` method on the received `tonic::Status` to obtain an `ErrorDetails` struct, allowing the client to inspect specific error types (e.g., `bad_request`, `help`) for tailored error handling.\nSOURCE: https://github.com/hyperium/tonic/blob/master/tonic-types/README.md#_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse tonic::{Response, Status};\nuse tonic_types::StatusExt;\n\n// ...\n// Where `req_result` was returned by a gRPC client endpoint method\nfn handle_request_result<T>(req_result: Result<Response<T>, Status>) {\n    match req_result {\n        Ok(response) => {\n            // Handle successful response\n        },\n        Err(status) => {\n            let err_details = status.get_error_details();\n            if let Some(bad_request) = err_details.bad_request() {\n                // Handle bad_request details\n            }\n            if let Some(help) = err_details.help() {\n                // Handle help details\n            }\n            if let Some(localized_message) = err_details.localized_message() {\n                // Handle localized_message details\n            }\n        }\n    };\n}\n```\n\n----------------------------------------\n\nTITLE: Calling Tonic Client Streaming RPC `record_route` in Rust\nDESCRIPTION: Implements an asynchronous function to call the client-side streaming RPC `record_route`. It generates a vector of random `Point`s, converts it into a stream using `tokio_stream::iter`, wraps the stream in a `Request`, sends it to the server, and prints the single `RouteSummary` response.\nSOURCE: https://github.com/hyperium/tonic/blob/master/examples/routeguide-tutorial.md#_snippet_30\n\nLANGUAGE: Rust\nCODE:\n```\nasync fn run_record_route(client: &mut RouteGuideClient<Channel>) -> Result<(), Box<dyn Error>> {\n    let mut rng = rand::rng();\n    let point_count: i32 = rng.random_range(2..100);\n\n    let mut points = vec![];\n    for _ in 0..=point_count {\n        points.push(random_point(&mut rng))\n    }\n\n    println!(\"Traversing {} points\", points.len());\n    let request = Request::new(tokio_stream::iter(points));\n\n    match client.record_route(request).await {\n        Ok(response) => println!(\"SUMMARY: {:?}\", response.into_inner()),\n        Err(e) => println!(\"something went wrong: {:?}\", e),\n    }\n\n    Ok(())\n}\n```\n\n----------------------------------------\n\nTITLE: Defining RouteGuideService Struct in Rust\nDESCRIPTION: This code defines a struct named `RouteGuideService` which represents the gRPC service. This is the base structure to build upon when implementing the service logic. It's a fundamental step in creating a gRPC server using Tonic.\nSOURCE: https://github.com/hyperium/tonic/blob/master/examples/routeguide-tutorial.md#_snippet_10\n\nLANGUAGE: rust\nCODE:\n```\n#[derive(Debug)]\nstruct RouteGuideService;\n```\n\n----------------------------------------\n\nTITLE: Importing Tonic Request Type for RPC in Rust\nDESCRIPTION: Imports the `Request` type from the `tonic` crate. This type is used to wrap the outgoing message payload for any gRPC call made through the Tonic client.\nSOURCE: https://github.com/hyperium/tonic/blob/master/examples/routeguide-tutorial.md#_snippet_25\n\nLANGUAGE: Rust\nCODE:\n```\nuse tonic::Request;\n```\n\n----------------------------------------\n\nTITLE: Calling Tonic Server Streaming RPC `list_features` in Rust\nDESCRIPTION: Implements an asynchronous function to call the server-side streaming RPC `list_features`. It sends a single `Rectangle` request, receives a stream of `Feature` messages, and iterates through the stream using `stream.message().await?` until the stream is closed.\nSOURCE: https://github.com/hyperium/tonic/blob/master/examples/routeguide-tutorial.md#_snippet_28\n\nLANGUAGE: Rust\nCODE:\n```\nasync fn print_features(client: &mut RouteGuideClient<Channel>) -> Result<(), Box<dyn Error>> {\n    let rectangle = Rectangle {\n        lo: Some(Point {\n            latitude: 400000000,\n            longitude: -750000000,\n        }),\n        hi: Some(Point {\n            latitude: 420000000,\n            longitude: -730000000,\n        }),\n    };\n\n    let mut stream = client\n        .list_features(Request::new(rectangle))\n        .await?\n        .into_inner();\n\n    while let Some(feature) = stream.message().await? {\n        println!(\"FEATURE = {:?}\", feature);\n    }\n\n    Ok(())\n}\n```\n\n----------------------------------------\n\nTITLE: Using git Submodules to Integrate Google API Protos and Compile with tonic-build (Shell and Rust)\nDESCRIPTION: Shows how to add Google's official API protobuf definitions as a git submodule and keep them updated. Then, a Rust build script example configures tonic-build to compile the Google pubsub proto files without generating server code, specifying proto root paths for resolving dependencies. This method facilitates managing and generating Rust code from extensive external proto sets.\nSOURCE: https://github.com/hyperium/tonic/blob/master/tonic-build/README.md#_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\ngit submodule add https://github.com/googleapis/googleapis\n\ngit submodule update --remote\n```\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    tonic_build::configure()\n        .build_server(false)\n        //.out_dir(\"src/google\")  // you can change the generated code's location\n        .compile_protos(\n            &[\"proto/googleapis/google/pubsub/v1/pubsub.proto\"],\n            &[\"proto/googleapis\"], // specify the root location to search proto dependencies\n        ).unwrap();\n}\n```\n\n----------------------------------------\n\nTITLE: Enabling gRPC-Web Support for Tonic Server in Rust\nDESCRIPTION: This Rust code snippet demonstrates how to configure a basic Tonic gRPC server to accept gRPC-Web requests. It utilizes the `tokio` runtime, sets up a standard gRPC service (`GreeterServer`), and modifies the `Server::builder` chain by calling `accept_http1(true)` to allow HTTP/1.1 requests and adding `GrpcWebLayer::new()` to handle the gRPC-Web protocol translation. The server then serves requests on the specified address.\nSOURCE: https://github.com/hyperium/tonic/blob/master/tonic-web/README.md#_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\n#[tokio::main]\nasync fn main() -> Result<(), Box<dyn std::error::Error>> {\n    let addr = \"[::1]:50051\".parse().unwrap();\n    let greeter = GreeterServer::new(MyGreeter::default());\n\n   Server::builder()\n       .accept_http1(true)\n       .layer(GrpcWebLayer::new())\n       .add_service(greeter)\n       .serve(addr)\n       .await?;\n\n   Ok(())\n}\n```\n\n----------------------------------------\n\nTITLE: Stubbing out RouteGuide Trait Implementation in Rust\nDESCRIPTION: This code provides the basic structure for implementing the `RouteGuide` trait. It uses the `tonic::async_trait` macro to enable the use of async functions within the trait. The `unimplemented!()` macro is used to indicate that the methods are placeholders and have no actual functionality. These stubs define the different types of RPC calls (unary, server streaming, client streaming, and bidirectional streaming) that the gRPC service will support.\nSOURCE: https://github.com/hyperium/tonic/blob/master/examples/routeguide-tutorial.md#_snippet_12\n\nLANGUAGE: rust\nCODE:\n```\nuse std::pin::Pin;\nuse std::sync::Arc;\nuse tokio::sync::mpsc;\nuse tonic::{Request, Response, Status};\nuse tokio_stream::{wrappers::ReceiverStream, Stream};\n```\n\nLANGUAGE: rust\nCODE:\n```\n#[tonic::async_trait]\nimpl RouteGuide for RouteGuideService {\n    async fn get_feature(&self, _request: Request<Point>) -> Result<Response<Feature>, Status> {\n        unimplemented!()\n    }\n\n    type ListFeaturesStream = ReceiverStream<Result<Feature, Status>>;\n\n    async fn list_features(\n        &self,\n        _request: Request<Rectangle>,\n    ) -> Result<Response<Self::ListFeaturesStream>, Status> {\n        unimplemented!()\n    }\n\n    async fn record_route(\n        &self,\n        _request: Request<tonic::Streaming<Point>>,\n    ) -> Result<Response<RouteSummary>, Status> {\n        unimplemented!()\n    }\n\n    type RouteChatStream = Pin<Box<dyn Stream<Item = Result<RouteNote, Status>> + Send  + 'static>>;\n\n    async fn route_chat(\n        &self,\n        _request: Request<tonic::Streaming<RouteNote>>,\n    ) -> Result<Response<Self::RouteChatStream>, Status> {\n        unimplemented!()\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Importing Dependencies for Client Streaming RPC in Rust\nDESCRIPTION: Imports `ThreadRng` from `rand::rngs` and the `Rng` trait from `rand`. These imports are used to generate random data (points) for the client-side streaming example.\nSOURCE: https://github.com/hyperium/tonic/blob/master/examples/routeguide-tutorial.md#_snippet_29\n\nLANGUAGE: Rust\nCODE:\n```\nuse rand::rngs::ThreadRng;\nuse rand::Rng;\n```\n\n----------------------------------------\n\nTITLE: Creating a build.rs Script for Code Generation\nDESCRIPTION: Build script that uses tonic-build to compile Protocol Buffer definitions into Rust code during the build process.\nSOURCE: https://github.com/hyperium/tonic/blob/master/examples/routeguide-tutorial.md#_snippet_8\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    tonic_build::compile_protos(\"proto/route_guide.proto\")\n        .unwrap_or_else(|e| panic!(\"Failed to compile protos {:?}\", e));\n}\n```\n\n----------------------------------------\n\nTITLE: Executing Tonic gRPC Server (Rust/Cargo)\nDESCRIPTION: Executes the compiled Rust server application using `cargo run`. This command specifically targets the binary named `helloworld-server` defined in the project's `Cargo.toml`. Prerequisites include a compiled server binary.\nSOURCE: https://github.com/hyperium/tonic/blob/master/examples/helloworld-tutorial.md#_snippet_17\n\nLANGUAGE: Shell\nCODE:\n```\ncargo run --bin helloworld-server\n```\n\n----------------------------------------\n\nTITLE: Helper Function to Generate Random Point in Rust\nDESCRIPTION: A helper function that takes a mutable reference to a `ThreadRng` and generates a new `Point` with random latitude and longitude values scaled appropriately. This is used to create test data for the client-side streaming example.\nSOURCE: https://github.com/hyperium/tonic/blob/master/examples/routeguide-tutorial.md#_snippet_31\n\nLANGUAGE: Rust\nCODE:\n```\nfn random_point(rng: &mut ThreadRng) -> Point {\n    let latitude = (rng.random_range(0..180) - 90) * 10_000_000;\n    let longitude = (rng.random_range(0..360) - 180) * 10_000_000;\n    Point {\n        latitude,\n        longitude,\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Cargo Binaries for Tonic in TOML\nDESCRIPTION: Configures the `Cargo.toml` file to define two binary targets: `routeguide-server` pointing to `src/server.rs` and `routeguide-client` pointing to `src/client.rs`. This allows building and running the server and client as separate executables within the same crate.\nSOURCE: https://github.com/hyperium/tonic/blob/master/examples/routeguide-tutorial.md#_snippet_21\n\nLANGUAGE: TOML\nCODE:\n```\n[[bin]]\nname = \"routeguide-server\"\npath = \"src/server.rs\"\n\n[[bin]]\nname = \"routeguide-client\"\npath = \"src/client.rs\"\n```\n\n----------------------------------------\n\nTITLE: Importing Dependencies for Bidirectional Streaming RPC in Rust\nDESCRIPTION: Imports `Duration` from `std::time` and the `time` module from `tokio`. These imports are necessary for creating time intervals used to generate a stream of messages over time in the bidirectional streaming example.\nSOURCE: https://github.com/hyperium/tonic/blob/master/examples/routeguide-tutorial.md#_snippet_32\n\nLANGUAGE: Rust\nCODE:\n```\nuse std::time::Duration;\nuse tokio::time;\n```\n\n----------------------------------------\n\nTITLE: Configuring Dependencies in Cargo.toml\nDESCRIPTION: Adding required dependencies to Cargo.toml including Tonic, PROST, Tokio, and other utilities for the RouteGuide example.\nSOURCE: https://github.com/hyperium/tonic/blob/master/examples/routeguide-tutorial.md#_snippet_7\n\nLANGUAGE: toml\nCODE:\n```\n[dependencies]\ntonic = \"*\"\nprost = \"0.13\"\ntokio = { version = \"1.0\", features = [\"rt-multi-thread\", \"macros\", \"sync\", \"time\"] }\ntokio-stream = \"0.1\"\n\nasync-stream = \"0.2\"\nserde = { version = \"1.0\", features = [\"derive\"] }\nserde_json = \"1.0\"\nrand = \"0.8\"\n\n[build-dependencies]\ntonic-build = \"*\"\n```\n\n----------------------------------------\n\nTITLE: Building the Project with Cargo\nDESCRIPTION: Command to build the project and generate code from Protocol Buffer definitions.\nSOURCE: https://github.com/hyperium/tonic/blob/master/examples/routeguide-tutorial.md#_snippet_9\n\nLANGUAGE: shell\nCODE:\n```\n$ cargo build\n```\n\n----------------------------------------\n\nTITLE: Running Helloworld Server\nDESCRIPTION: This command runs the helloworld server example.  It executes the `helloworld-server` binary using `cargo run`.  It assumes the server code is already built.  This example serves as a basic gRPC implementation.\nSOURCE: https://github.com/hyperium/tonic/blob/master/examples/README.md#_snippet_4\n\nLANGUAGE: Bash\nCODE:\n```\n$ cargo run --bin helloworld-server\n```\n\n----------------------------------------\n\nTITLE: Running Tonic RouteGuide Client via Cargo in Shell\nDESCRIPTION: A shell command to build and run the `routeguide-client` binary defined in `Cargo.toml`. This command executes the client application, which will attempt to connect to the running server and demonstrate the various RPC calls.\nSOURCE: https://github.com/hyperium/tonic/blob/master/examples/routeguide-tutorial.md#_snippet_35\n\nLANGUAGE: Shell\nCODE:\n```\n$ cargo run --bin routeguide-client\n```\n\n----------------------------------------\n\nTITLE: Probing gRPC Health Status using grpc_health_probe - Bash\nDESCRIPTION: This Bash script demonstrates how to continuously check the health status of a specific gRPC service using the `grpc_health_probe` tool. It targets a service running at a given address (`-addr`) and specifies the service name to check (`-service`). The script runs in an infinite loop, pausing for one second between checks, allowing observation of health status changes over time.\nSOURCE: https://github.com/hyperium/tonic/blob/master/examples/src/health/README.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nwhile [ true ]; do\n./grpc_health_probe -addr=[::1]:50051 -service=helloworld.Greeter\nsleep 1\ndone\n```\n\n----------------------------------------\n\nTITLE: Running Helloworld Client\nDESCRIPTION: This command runs the helloworld client example. It utilizes `cargo run` to execute the `helloworld-client` binary. Before running this, you should have the Tonic library installed and built the helloworld client example.\nSOURCE: https://github.com/hyperium/tonic/blob/master/examples/README.md#_snippet_3\n\nLANGUAGE: Bash\nCODE:\n```\n$ cargo run --bin helloworld-client\n```\n\n----------------------------------------\n\nTITLE: Implementing Hash and Eq for Point in Rust\nDESCRIPTION: This code implements the `Hash` and `Eq` traits for the `Point` struct. This allows `Point` instances to be used as keys in hash maps or other data structures that require hashing and equality comparisons. The implementation ensures that `Point` instances are comparable based on their latitude and longitude values.\nSOURCE: https://github.com/hyperium/tonic/blob/master/examples/routeguide-tutorial.md#_snippet_14\n\nLANGUAGE: rust\nCODE:\n```\nuse std::hash::{Hasher, Hash};\n```\n\nLANGUAGE: rust\nCODE:\n```\nimpl Hash for Point {\n    fn hash<H>(&self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.latitude.hash(state);\n        self.longitude.hash(state);\n    }\n}\n\nimpl Eq for Point {}\n```\n\n----------------------------------------\n\nTITLE: Creating directories for Protocol Buffer definitions\nDESCRIPTION: Commands to create a proto directory and an empty Protocol Buffer definition file for the HelloWorld service.\nSOURCE: https://github.com/hyperium/tonic/blob/master/examples/helloworld-tutorial.md#_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\n$ mkdir proto\n$ touch proto/helloworld.proto\n```\n\n----------------------------------------\n\nTITLE: Creating a Directory for Protocol Buffers\nDESCRIPTION: Command to create a directory for storing Protocol Buffer definitions and an empty file for the RouteGuide service.\nSOURCE: https://github.com/hyperium/tonic/blob/master/examples/routeguide-tutorial.md#_snippet_5\n\nLANGUAGE: shell\nCODE:\n```\n$ mkdir proto && touch proto/route_guide.proto\n```\n\n----------------------------------------\n\nTITLE: Executing Shell Commands for Tonic File Setup\nDESCRIPTION: Provides shell commands to rename the default `main.rs` file to `server.rs` and create a new empty file named `client.rs`. These steps are necessary to structure the project with separate files for the server and client binaries as defined in the `Cargo.toml`.\nSOURCE: https://github.com/hyperium/tonic/blob/master/examples/routeguide-tutorial.md#_snippet_22\n\nLANGUAGE: Shell\nCODE:\n```\n$ mv src/main.rs src/server.rs\n$ touch src/client.rs\n```\n\n----------------------------------------\n\nTITLE: Defining Protocol Buffer package\nDESCRIPTION: Initial Protocol Buffer definition setting up the syntax and package name for the HelloWorld service.\nSOURCE: https://github.com/hyperium/tonic/blob/master/examples/helloworld-tutorial.md#_snippet_3\n\nLANGUAGE: proto\nCODE:\n```\nsyntax = \"proto3\";\npackage helloworld;\n```\n\n----------------------------------------\n\nTITLE: Changing to Tonic Repository Directory\nDESCRIPTION: Command to navigate to the Tonic repository's root directory after cloning.\nSOURCE: https://github.com/hyperium/tonic/blob/master/examples/routeguide-tutorial.md#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\n$ cd tonic\n```\n\n----------------------------------------\n\nTITLE: Cloning the Tonic Repository\nDESCRIPTION: Command to clone the Tonic repository from GitHub to get access to the example code.\nSOURCE: https://github.com/hyperium/tonic/blob/master/examples/routeguide-tutorial.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n$ git clone https://github.com/hyperium/tonic.git\n```\n\n----------------------------------------\n\nTITLE: Running Richer Error Client (Vec)\nDESCRIPTION: This command runs the richer error client example using a vector of error message types.  It executes the `richer-error-client-vec` binary using `cargo run`. This showcases a different approach to richer error handling in gRPC.\nSOURCE: https://github.com/hyperium/tonic/blob/master/examples/README.md#_snippet_20\n\nLANGUAGE: Bash\nCODE:\n```\n$ cargo run --bin richer-error-client-vec\n```\n\n----------------------------------------\n\nTITLE: Running Health Checking Server\nDESCRIPTION: This command runs the health checking server example.  It executes `health-server` using `cargo run`. The health checking example provides a mechanism for checking the server's health status within gRPC.\nSOURCE: https://github.com/hyperium/tonic/blob/master/examples/README.md#_snippet_15\n\nLANGUAGE: Bash\nCODE:\n```\n$ cargo run --bin health-server\n```\n\n----------------------------------------\n\nTITLE: Installing Protobuf Compiler (Alpine Linux)\nDESCRIPTION: This code snippet installs the Protocol Buffers compiler and development libraries on Alpine Linux.  It uses the `apk` package manager to install `protoc` and `protobuf-dev`. This is required to build and run the examples that utilize Protocol Buffers.\nSOURCE: https://github.com/hyperium/tonic/blob/master/examples/README.md#_snippet_1\n\nLANGUAGE: Bash\nCODE:\n```\nsudo apk add protoc protobuf-dev\n```\n\n----------------------------------------\n\nTITLE: Including Proto Generated Code and Imports for Tonic Client in Rust\nDESCRIPTION: Includes the gRPC service code generated from the `.proto` file using `tonic::include_proto!`. It then imports the necessary client struct (`RouteGuideClient`) and message types (`Point`, `Rectangle`, `RouteNote`) required for making RPC calls.\nSOURCE: https://github.com/hyperium/tonic/blob/master/examples/routeguide-tutorial.md#_snippet_23\n\nLANGUAGE: Rust\nCODE:\n```\npub mod routeguide {\n    tonic::include_proto!(\"routeguide\");\n}\n\nuse routeguide::route_guide_client::RouteGuideClient;\nuse routeguide::{Point, Rectangle, RouteNote};\n\n\n#[tokio::main]\nasync fn main() -> Result<(), Box<dyn std::error::Error>> {\n```\n\n----------------------------------------\n\nTITLE: Formatting Commit Messages\nDESCRIPTION: This code block details the guidelines for writing effective commit messages within the Tonic project.  It defines a consistent format to improve readability and maintainability by standardizing elements such as prefixing with the crate name and using an imperative verb. The instructions emphasize short descriptions, lowercase, and a wrapping of lines at 72 characters. It requires the understanding of the project's internal structure.\nSOURCE: https://github.com/hyperium/tonic/blob/master/CONTRIBUTING.md#_snippet_0\n\nLANGUAGE: txt\nCODE:\n```\n#### Commit message guidelines\n\nA good commit message should describe what changed and why.\n\n1. The first line should:\n\n  * contain a short description of the change (preferably 50 characters or less,\n    and no more than 72 characters)\n  * be entirely in lowercase with the exception of proper nouns, acronyms, and\n    the words that refer to code, like function/variable names\n  * be prefixed with the name of the crate being changed (without the\n    `tonic` prefix) and start with an imperative verb.\n\n  Examples:\n\n  * build: add regex for parsing field filters\n  * tonic: add `Clone` impl for `Service` and `MakeService`\n\n2. Keep the second line blank.\n3. Wrap all other lines at 72 columns (except for long URLs).\n4. If your patch fixes an open issue, you can add a reference to it at the end\n   of the log. Use the `Fixes: #` prefix and the issue number. For other\n   references use `Refs: #`. `Refs` may include multiple issues, separated by a\n   comma.\n\n   Examples:\n\n   - `Fixes: #1337`\n   - `Refs: #1234`\n\nSample complete commit message:\n\n```txt\nsubcrate: explain the commit in one line\n\nBody of commit message is a few lines of text, explaining things\nin more detail, possibly giving some background about the issue\nbeing fixed, etc.\n\nThe body of the commit message can be several paragraphs, and\nplease do proper word-wrap and keep columns shorter than about\n72 characters or so. That way, `git log` will show things\nnicely even when it is indented.\n\nFixes: #1337\nRefs: #453, #154\n```\n```\n\n----------------------------------------\n\nTITLE: Running Server Reflection Server\nDESCRIPTION: This command runs the server reflection server example. It runs the `reflection-server` binary with `cargo run`. The server reflection example allows clients to discover the server's gRPC services at runtime.\nSOURCE: https://github.com/hyperium/tonic/blob/master/examples/README.md#_snippet_16\n\nLANGUAGE: Bash\nCODE:\n```\n$ cargo run --bin reflection-server\n```\n\n----------------------------------------\n\nTITLE: Running Tonic RouteGuide Server via Cargo in Shell\nDESCRIPTION: A shell command to build and run the `routeguide-server` binary defined in `Cargo.toml`. This command starts the gRPC server, making it available for clients to connect and send requests.\nSOURCE: https://github.com/hyperium/tonic/blob/master/examples/routeguide-tutorial.md#_snippet_34\n\nLANGUAGE: Shell\nCODE:\n```\n$ cargo run --bin routeguide-server\n```\n\n----------------------------------------\n\nTITLE: Importing Dependencies for Server Streaming RPC in Rust\nDESCRIPTION: Imports `Channel` from `tonic::transport` which is needed for the client type signature and `Error` from `std::error` for consistent error handling in the asynchronous function signature.\nSOURCE: https://github.com/hyperium/tonic/blob/master/examples/routeguide-tutorial.md#_snippet_27\n\nLANGUAGE: Rust\nCODE:\n```\nuse tonic::transport::Channel;\nuse std::error::Error;\n```\n\n----------------------------------------\n\nTITLE: Configuring Tonic Proto Compilation in Rust Build Script\nDESCRIPTION: An example Rust code snippet for a build script (`build.rs`). It demonstrates how to explicitly configure `tonic_build` to generate server code only (`build_client(false)`) and output it to a specific directory (`another_crate/src/pb`). It compiles a list of specified `.proto` files.\nSOURCE: https://github.com/hyperium/tonic/blob/master/examples/routeguide-tutorial.md#_snippet_36\n\nLANGUAGE: Rust\nCODE:\n```\nfn main() {\n    tonic_build::configure()\n        .build_client(false)\n        .out_dir(\"another_crate/src/pb\")\n        .compile_protos(&[\"path/my_proto.proto\"], &[\"path\"])\n        .expect(\"failed to compile protos\");\n}\n```\n\n----------------------------------------\n\nTITLE: Updating Rust for async/await compatibility\nDESCRIPTION: Command to update Rust to ensure compatibility with the async/await feature required by Tonic.\nSOURCE: https://github.com/hyperium/tonic/blob/master/examples/helloworld-tutorial.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n$ rustup update\n```\n\n----------------------------------------\n\nTITLE: Creating a New Rust Project for RouteGuide\nDESCRIPTION: Commands to create a new Cargo project for the RouteGuide example and navigate to its directory.\nSOURCE: https://github.com/hyperium/tonic/blob/master/examples/routeguide-tutorial.md#_snippet_4\n\nLANGUAGE: shell\nCODE:\n```\n$ cargo new routeguide\n$ cd routeguide\n```\n\n----------------------------------------\n\nTITLE: Running Authentication Server\nDESCRIPTION: This command runs the authentication server example.  It executes `authentication-server` using `cargo run`. The server must be started before connecting with the client, as the authentication example shows how to handle authentication and authorization in gRPC.\nSOURCE: https://github.com/hyperium/tonic/blob/master/examples/README.md#_snippet_8\n\nLANGUAGE: Bash\nCODE:\n```\n$ cargo run --bin authentication-server\n```\n\n----------------------------------------\n\nTITLE: Prepare Release Branch Script\nDESCRIPTION: This snippet provides instructions for preparing a release branch within the Tonic project. The process involves using Git commands to create a new branch. A shell script, `./prepare-release.sh`, is then executed to update crate versions. The script requires Git for branching and the shell for execution. The version number X.Y.Z must be provided as a parameter to the shell script.\nSOURCE: https://github.com/hyperium/tonic/blob/master/CONTRIBUTING.md#_snippet_1\n\nLANGUAGE: txt\nCODE:\n```\n   git checkout -b <release-branch-name>\n   ./prepare-release.sh <version> # where version is X.Y.Z \n```\n\n----------------------------------------\n\nTITLE: Installing Protobuf Compiler (macOS)\nDESCRIPTION: This code snippet installs the Protocol Buffers compiler on macOS using Homebrew. It assumes that Homebrew is already installed on the system. The command `brew install protobuf` installs the necessary packages to compile Protocol Buffer definitions. This step is essential for building Tonic examples that use gRPC.\nSOURCE: https://github.com/hyperium/tonic/blob/master/examples/README.md#_snippet_2\n\nLANGUAGE: Zsh\nCODE:\n```\nbrew install protobuf\n```\n\n----------------------------------------\n\nTITLE: Generating tonic::Status with ErrorDetails on Server Side (Rust)\nDESCRIPTION: Demonstrates how a gRPC server using `tonic` can create a detailed error status based on the gRPC Richer Error Model. It utilizes the `tonic_types::ErrorDetails` struct and the `StatusExt` trait's `with_error_details` associated function on `tonic::Status` to add specific violations (e.g., `BadRequest`) and other details before returning an error `Status`.\nSOURCE: https://github.com/hyperium/tonic/blob/master/tonic-types/README.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse tonic::{Code, Status};\nuse tonic_types::{ErrorDetails, StatusExt};\n\n// ...\n// Inside a gRPC server endpoint that returns `Result<Response<T>, Status>`\n\n// Create empty `ErrorDetails` struct\nlet mut err_details = ErrorDetails::new();\n\n// Add error details conditionally\nif some_condition {\n    err_details.add_bad_request_violation(\n        \"field_a\",\n        \"description of why the field_a is invalid\"\n    );\n}\n\nif other_condition {\n    err_details.add_bad_request_violation(\n        \"field_b\",\n        \"description of why the field_b is invalid\",\n    );\n}\n\n// Check if any error details were set and return error status if so\nif err_details.has_bad_request_violations() {\n    // Add additional error details if necessary\n    err_details\n        .add_help_link(\"description of link\", \"https://resource.example.local\")\n        .set_localized_message(\"en-US\", \"message for the user\");\n\n    let status = Status::with_error_details(\n        Code::InvalidArgument,\n        \"bad request\",\n        err_details,\n    );\n    return Err(status);\n}\n\n// Handle valid request\n// ...\n```\n\n----------------------------------------\n\nTITLE: Running the RouteGuide Server\nDESCRIPTION: Command to run the example RouteGuide server application using Cargo.\nSOURCE: https://github.com/hyperium/tonic/blob/master/examples/routeguide-tutorial.md#_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\n$ cargo run --bin routeguide-server\n```\n\n----------------------------------------\n\nTITLE: Running Dynamic Load Balance Server\nDESCRIPTION: This command runs the dynamic load balance server.  It uses `cargo run` to execute the `dynamic-load-balance-server` binary. The dynamic load balancing server should be started for the corresponding client to connect to. The example likely shows how to dynamically configure load balancing servers with gRPC.\nSOURCE: https://github.com/hyperium/tonic/blob/master/examples/README.md#_snippet_12\n\nLANGUAGE: Bash\nCODE:\n```\n$ cargo run --bin dynamic-load-balance-server\n```\n\n----------------------------------------\n\nTITLE: Interpreting Criterion Benchmark Results in Tonic\nDESCRIPTION: A sample Criterion benchmark output showing performance metrics for a 'Request_Response/request/100000' test, demonstrating how performance regression is reported with execution time and throughput measurements.\nSOURCE: https://github.com/hyperium/tonic/blob/master/tonic/benches-disabled/README.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nRequest_Response/request/100000                                                                             \n                        time:   [2.7231 us 2.7588 us 2.7969 us]\n                        thrpt:  [33.298 GiB/s 33.758 GiB/s 34.200 GiB/s]\n                 change:\n                        time:   [+16.073% +17.871% +19.980%] (p = 0.00 < 0.05)\n                        thrpt:  [-16.653% -15.162% -13.847%]\n                        Performance has regressed.\nFound 3 outliers among 100 measurements (3.00%)\n  1 (1.00%) high mild\n  2 (2.00%) high severe\n```\n\n----------------------------------------\n\nTITLE: Publish Release Script Execution\nDESCRIPTION: This code shows how to use the `publish-release.sh` script. The script handles the publishing of the crates to crates.io, assuming all the necessary configurations are in place. It requires the release branch to be merged into the `master` branch prior to execution. The script does not take any arguments.\nSOURCE: https://github.com/hyperium/tonic/blob/master/CONTRIBUTING.md#_snippet_4\n\nLANGUAGE: txt\nCODE:\n```\n   ./publish-release.sh\n```\n\n----------------------------------------\n\nTITLE: Implementing get_feature RPC in Rust\nDESCRIPTION: This code implements the `get_feature` RPC, a unary gRPC call. It receives a `Point` as a request and iterates through a list of features, checking if a feature's location matches the requested point. If a match is found, it returns the feature. If not, it returns a default feature.  This demonstrates a simple request-response pattern in gRPC.\nSOURCE: https://github.com/hyperium/tonic/blob/master/examples/routeguide-tutorial.md#_snippet_15\n\nLANGUAGE: rust\nCODE:\n```\nasync fn get_feature(&self, request: Request<Point>) -> Result<Response<Feature>, Status> {\n    for feature in &self.features[..] {\n        if feature.location.as_ref() == Some(request.get_ref()) {\n            return Ok(Response::new(feature.clone()));\n        }\n    }\n\n    Ok(Response::new(Feature::default()))\n}\n```\n\n----------------------------------------\n\nTITLE: Defining RouteGuideService State in Rust\nDESCRIPTION: This code defines the `RouteGuideService` struct with an `Arc<Vec<Feature>>` field, representing the shared state of the server. This state will hold the features loaded from the JSON data file.  Using `Arc` allows multiple threads or tasks to access the same data without requiring explicit locking.\nSOURCE: https://github.com/hyperium/tonic/blob/master/examples/routeguide-tutorial.md#_snippet_13\n\nLANGUAGE: rust\nCODE:\n```\n#[derive(Debug)]\npub struct RouteGuideService {\n    features: Arc<Vec<Feature>>,\n}\n```\n\n----------------------------------------\n\nTITLE: Importing Dependencies for Tonic Server in Rust\nDESCRIPTION: Imports necessary modules for defining a Tonic gRPC server, including the `data` module and the `Server` struct from `tonic::transport`. These imports are prerequisites for setting up the server's main function.\nSOURCE: https://github.com/hyperium/tonic/blob/master/examples/routeguide-tutorial.md#_snippet_19\n\nLANGUAGE: Rust\nCODE:\n```\nmod data;\nuse tonic::transport::Server;\n```\n\n----------------------------------------\n\nTITLE: Configuring tonic-build with Custom Options in build.rs (Rust)\nDESCRIPTION: Demonstrates advanced usage of tonic-build with a configuration builder pattern. It disables server code generation via build_server(false) and compiles multiple proto files with specified include directories. This setup provides greater control over generated code, allowing selective client/server code generation and dependency resolution.\nSOURCE: https://github.com/hyperium/tonic/blob/master/tonic-build/README.md#_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nfn main() -> Result<(), Box<dyn std::error::Error>> {\n   tonic_build::configure()\n        .build_server(false)\n        .compile_protos(\n            &[\"proto/helloworld/helloworld.proto\"],\n            &[\"proto/helloworld\"],\n        )?;\n   Ok(())\n}\n```\n\n----------------------------------------\n\nTITLE: Generate Changelog Command\nDESCRIPTION: This command outlines the usage of `conventional-changelog` to generate a changelog. It specifies the angular preset (`-p angular`), the input file as `CHANGELOG.md`, and instructs the tool to update the changelog in place (`-s`).  It uses the conventional-changelog CLI which relies on the project's commit history and adherence to the commit message guidelines to generate entries. Requires that the commit messages adhere to the conventional commits specification.\nSOURCE: https://github.com/hyperium/tonic/blob/master/CONTRIBUTING.md#_snippet_2\n\nLANGUAGE: txt\nCODE:\n```\n   conventional-changelog -p angular -i CHANGELOG.md -s\n```\n\n----------------------------------------\n\nTITLE: Implementing Greeter service for gRPC server\nDESCRIPTION: Implementation of the Greeter service that handles SayHello RPC requests by formatting a greeting message based on the request name.\nSOURCE: https://github.com/hyperium/tonic/blob/master/examples/helloworld-tutorial.md#_snippet_10\n\nLANGUAGE: rust\nCODE:\n```\n#[derive(Debug, Default)]\npub struct MyGreeter {}\n\n#[tonic::async_trait]\nimpl Greeter for MyGreeter {\n    async fn say_hello(\n        &self,\n        request: Request<HelloRequest>, // Accept request of type HelloRequest\n    ) -> Result<Response<HelloReply>, Status> { // Return an instance of type HelloReply\n        println!(\"Got a request: {:?}\", request);\n\n        let reply = HelloReply {\n            message: format!(\"Hello {}!\", request.into_inner().name), // We must use .into_inner() as the fields of gRPC requests and responses are private\n        };\n\n        Ok(Response::new(reply)) // Send back our formatted greeting\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Protobuf Compiler (Ubuntu)\nDESCRIPTION: This code snippet installs the Protocol Buffers compiler and development libraries on Ubuntu. It first updates and upgrades the system packages, and then installs `protobuf-compiler` and `libprotobuf-dev`. This is a prerequisite for building the Tonic examples, which use Protocol Buffers for message definition and serialization.\nSOURCE: https://github.com/hyperium/tonic/blob/master/examples/README.md#_snippet_0\n\nLANGUAGE: Bash\nCODE:\n```\nsudo apt update && sudo apt upgrade -y\nsudo apt install -y protobuf-compiler libprotobuf-dev\n```\n\n----------------------------------------\n\nTITLE: Release Commit and Branch Creation\nDESCRIPTION: This snippet shows the steps for creating the commit and branch for the release process.  This involves creating a commit with a specific message format (`chore: release vX.Y.Z`), and pushing the release branch. It relies on the previously generated changelog and the version number of the project.\nSOURCE: https://github.com/hyperium/tonic/blob/master/CONTRIBUTING.md#_snippet_3\n\nLANGUAGE: txt\nCODE:\n```\n   conventional-changelog -p angular -i CHANGELOG.md -s\n```\n\n----------------------------------------\n\nTITLE: Executing Tonic gRPC Client (Rust/Cargo)\nDESCRIPTION: Executes the compiled Rust client application using `cargo run`. This command specifically targets the binary named `helloworld-client` defined in the project's `Cargo.toml`. It should be run concurrently with the server. Prerequisites include a compiled client binary.\nSOURCE: https://github.com/hyperium/tonic/blob/master/examples/helloworld-tutorial.md#_snippet_18\n\nLANGUAGE: Shell\nCODE:\n```\ncargo run --bin helloworld-client\n```\n\n----------------------------------------\n\nTITLE: Configuring Cargo.toml for Tonic project\nDESCRIPTION: Cargo.toml configuration specifying dependencies and binary targets for both the server and client applications.\nSOURCE: https://github.com/hyperium/tonic/blob/master/examples/helloworld-tutorial.md#_snippet_7\n\nLANGUAGE: toml\nCODE:\n```\n[package]\nname = \"helloworld-tonic\"\nversion = \"0.1.0\"\nedition = \"2021\"\n\n[[bin]] # Bin to run the HelloWorld gRPC server\nname = \"helloworld-server\"\npath = \"src/server.rs\"\n\n[[bin]] # Bin to run the HelloWorld gRPC client\nname = \"helloworld-client\"\npath = \"src/client.rs\"\n\n[dependencies]\ntonic = \"*\"\nprost = \"0.13\"\ntokio = { version = \"1.0\", features = [\"macros\", \"rt-multi-thread\"] }\n\n[build-dependencies]\ntonic-build = \"*\"\n```\n\n----------------------------------------\n\nTITLE: Calling Tonic Simple RPC `get_feature` in Rust\nDESCRIPTION: Demonstrates how to call a simple unary RPC method, `get_feature`, on the Tonic client. It creates a `Point` message, wraps it in a `tonic::Request`, calls the client method, and awaits the response.\nSOURCE: https://github.com/hyperium/tonic/blob/master/examples/routeguide-tutorial.md#_snippet_26\n\nLANGUAGE: Rust\nCODE:\n```\nlet response = client\n    .get_feature(Request::new(Point {\n        latitude: 409146138,\n        longitude: -746188906,\n    }))\n    .await?;\n\nprintln!(\"RESPONSE = {:?}\", response);\n```\n\n----------------------------------------\n\nTITLE: Implementing gRPC client with Tokio runtime\nDESCRIPTION: Main function for the gRPC client that creates a connection to the server, sends a request, and handles the response.\nSOURCE: https://github.com/hyperium/tonic/blob/master/examples/helloworld-tutorial.md#_snippet_15\n\nLANGUAGE: rust\nCODE:\n```\n#[tokio::main]\nasync fn main() -> Result<(), Box<dyn std::error::Error>> {\n    let mut client = GreeterClient::connect(\"http://[::1]:50051\").await?;\n\n    let request = tonic::Request::new(HelloRequest {\n        name: \"Tonic\".into(),\n    });\n\n    let response = client.say_hello(request).await?;\n\n    println!(\"RESPONSE={:?}\", response);\n\n    Ok()\n}\n```\n\n----------------------------------------\n\nTITLE: Running Richer Error Server (Vec)\nDESCRIPTION: This command runs the richer error server example that uses a vector of error message types.  It executes the `richer-error-server-vec` binary using `cargo run`. This showcases an alternative approach for richer error handling on the server side within gRPC.\nSOURCE: https://github.com/hyperium/tonic/blob/master/examples/README.md#_snippet_22\n\nLANGUAGE: Bash\nCODE:\n```\n$ cargo run --bin richer-error-server-vec\n```\n\n----------------------------------------\n\nTITLE: Running Load Balance Server\nDESCRIPTION: This command runs the load balance server example by using `cargo run` and executing the `load-balance-server` binary. The load balancing server is started so that the client can connect to it, showcasing how to implement load balancing in gRPC.\nSOURCE: https://github.com/hyperium/tonic/blob/master/examples/README.md#_snippet_10\n\nLANGUAGE: Bash\nCODE:\n```\n$ cargo run --bin load-balance-server\n```\n\n----------------------------------------\n\nTITLE: Running RouteGuide Server\nDESCRIPTION: This command runs the routeguide server example using `cargo run`. The `routeguide-server` binary is executed. The server must be started before attempting to connect with the routeguide client. The RouteGuide example showcases more complex interactions with gRPC.\nSOURCE: https://github.com/hyperium/tonic/blob/master/examples/README.md#_snippet_6\n\nLANGUAGE: Bash\nCODE:\n```\n$ cargo run --bin routeguide-server\n```\n\n----------------------------------------\n\nTITLE: Running RouteGuide Client\nDESCRIPTION: This command executes the routeguide client application. It uses `cargo run` to run the `routeguide-client` binary.  This assumes the routeguide client example has been built. This example likely demonstrates gRPC's streaming or other advanced features.\nSOURCE: https://github.com/hyperium/tonic/blob/master/examples/README.md#_snippet_5\n\nLANGUAGE: Bash\nCODE:\n```\n$ cargo run --bin routeguide-client\n```\n\n----------------------------------------\n\nTITLE: Running Richer Error Server (ErrorDetails)\nDESCRIPTION: This command runs the richer error server example using the `ErrorDetails` struct.  It executes the `richer-error-server` binary using `cargo run`. This shows how to handle and propagate detailed error information from the server in gRPC.\nSOURCE: https://github.com/hyperium/tonic/blob/master/examples/README.md#_snippet_21\n\nLANGUAGE: Bash\nCODE:\n```\n$ cargo run --bin richer-error-server\n```\n\n----------------------------------------\n\nTITLE: Running the GCP Pub/Sub Client with OAuth Token\nDESCRIPTION: Command to execute the GCP Pub/Sub client with an OAuth access token and project ID. The command sets the GCP_AUTH_TOKEN environment variable with your access token and passes the project ID as a command line argument.\nSOURCE: https://github.com/hyperium/tonic/blob/master/examples/src/gcp/README.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nGCP_AUTH_TOKEN=\"<access-token>\" cargo run --bin gcp-client -- <project-id>\n```\n\n----------------------------------------\n\nTITLE: Running Richer Error Client (ErrorDetails)\nDESCRIPTION: This command runs the richer error client example, using the `ErrorDetails` struct. It runs the `richer-error-client` binary using `cargo run`. This example demonstrates how to handle more detailed error information in gRPC.\nSOURCE: https://github.com/hyperium/tonic/blob/master/examples/README.md#_snippet_19\n\nLANGUAGE: Bash\nCODE:\n```\n$ cargo run --bin richer-error-client\n```\n\n----------------------------------------\n\nTITLE: Importing dependencies for gRPC server\nDESCRIPTION: Server-side code to import necessary dependencies including Tonic components and generated Protocol Buffer code.\nSOURCE: https://github.com/hyperium/tonic/blob/master/examples/helloworld-tutorial.md#_snippet_9\n\nLANGUAGE: rust\nCODE:\n```\nuse tonic::{transport::Server, Request, Response, Status};\n\nuse hello_world::greeter_server::{Greeter, GreeterServer};\nuse hello_world::{HelloReply, HelloRequest};\n\npub mod hello_world {\n    tonic::include_proto!(\"helloworld\"); // The string specified here must match the proto package name\n}\n```\n\n----------------------------------------\n\nTITLE: Running Autoreloading Server\nDESCRIPTION: This command runs the autoreloading server example using `systemfd` and `cargo watch`. It restarts the server whenever the source code changes. It requires `systemfd` and `cargo-watch` to be installed.\nSOURCE: https://github.com/hyperium/tonic/blob/master/examples/README.md#_snippet_18\n\nLANGUAGE: Bash\nCODE:\n```\nsystemfd --no-pid -s http::[::1]:50051 -- cargo watch -x 'run --bin autoreload-server'\n```\n\n----------------------------------------\n\nTITLE: Defining gRPC Greeter service\nDESCRIPTION: Protocol Buffer definition for the Greeter service with a SayHello RPC method that accepts HelloRequests and returns HelloReplies.\nSOURCE: https://github.com/hyperium/tonic/blob/master/examples/helloworld-tutorial.md#_snippet_4\n\nLANGUAGE: proto\nCODE:\n```\nservice Greeter {\n    // Our SayHello rpc accepts HelloRequests and returns HelloReplies\n    rpc SayHello (HelloRequest) returns (HelloReply);\n}\n```\n\n----------------------------------------\n\nTITLE: Running Dynamic Load Balance Client\nDESCRIPTION: This command executes the dynamic load balance client. It uses `cargo run` to run the `dynamic-load-balance-client` binary. This example likely focuses on dynamic aspects of load balancing in a gRPC context.\nSOURCE: https://github.com/hyperium/tonic/blob/master/examples/README.md#_snippet_11\n\nLANGUAGE: Bash\nCODE:\n```\n$ cargo run --bin dynamic-load-balance-client\n```\n\n----------------------------------------\n\nTITLE: Running TLS Client\nDESCRIPTION: This command runs the TLS client example.  It executes `tls-client` using `cargo run`. This example requires setting up TLS (Transport Layer Security) to secure gRPC communication using `rustls`.\nSOURCE: https://github.com/hyperium/tonic/blob/master/examples/README.md#_snippet_13\n\nLANGUAGE: Bash\nCODE:\n```\n$ cargo run --bin tls-client\n```\n\n----------------------------------------\n\nTITLE: Running TLS Server\nDESCRIPTION: This command runs the TLS server example. It executes the `tls-server` binary using `cargo run`. It requires setting up TLS (Transport Layer Security) to secure gRPC communication.\nSOURCE: https://github.com/hyperium/tonic/blob/master/examples/README.md#_snippet_14\n\nLANGUAGE: Bash\nCODE:\n```\n$ cargo run --bin tls-server\n```\n\n----------------------------------------\n\nTITLE: Running Authentication Client\nDESCRIPTION: This command runs the authentication client example.  It uses `cargo run` to execute the `authentication-client` binary. The authentication example showcases how to implement authentication and authorization with gRPC.\nSOURCE: https://github.com/hyperium/tonic/blob/master/examples/README.md#_snippet_7\n\nLANGUAGE: Bash\nCODE:\n```\n$ cargo run --bin authentication-client\n```\n\n----------------------------------------\n\nTITLE: Running Load Balance Client\nDESCRIPTION: This command runs the load balance client example. It uses `cargo run` to run the `load-balance-client` binary. This demonstrates the implementation of load balancing using gRPC.\nSOURCE: https://github.com/hyperium/tonic/blob/master/examples/README.md#_snippet_9\n\nLANGUAGE: Bash\nCODE:\n```\n$ cargo run --bin load-balance-client\n```\n\n----------------------------------------\n\nTITLE: Running Tower Middleware Server\nDESCRIPTION: This command runs the Tower middleware server example. It executes the `tower-server` binary by running `cargo run`. The server showcases the integration of middleware with the Tower framework for gRPC.\nSOURCE: https://github.com/hyperium/tonic/blob/master/examples/README.md#_snippet_17\n\nLANGUAGE: Bash\nCODE:\n```\n$ cargo run --bin tower-server\n```\n\n----------------------------------------\n\nTITLE: Creating a new Rust project with Cargo\nDESCRIPTION: Commands to create a new Rust project named 'helloworld-tonic' using Cargo and navigate into the project directory.\nSOURCE: https://github.com/hyperium/tonic/blob/master/examples/helloworld-tutorial.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n$ cargo new helloworld-tonic\n$ cd helloworld-tonic\n```\n\n----------------------------------------\n\nTITLE: Complete gRPC client implementation\nDESCRIPTION: The complete client implementation that connects to the gRPC server, sends a request, and prints the response.\nSOURCE: https://github.com/hyperium/tonic/blob/master/examples/helloworld-tutorial.md#_snippet_16\n\nLANGUAGE: rust\nCODE:\n```\nuse hello_world::greeter_client::GreeterClient;\nuse hello_world::HelloRequest;\n\npub mod hello_world {\n    tonic::include_proto!(\"helloworld\");\n}\n\n#[tokio::main]\nasync fn main() -> Result<(), Box<dyn std::error::Error>> {\n    let mut client = GreeterClient::connect(\"http://[::1]:50051\").await?;\n\n    let request = tonic::Request::new(HelloRequest {\n        name: \"Tonic\".into(),\n    });\n\n    let response = client.say_hello(request).await?;\n\n    println!(\"RESPONSE={:?}\", response);\n\n    Ok()\n}\n```\n\n----------------------------------------\n\nTITLE: Setting up Tokio runtime for gRPC server\nDESCRIPTION: Main function that sets up a Tokio runtime, creates a gRPC server instance, and starts serving requests on a specified address.\nSOURCE: https://github.com/hyperium/tonic/blob/master/examples/helloworld-tutorial.md#_snippet_11\n\nLANGUAGE: rust\nCODE:\n```\n#[tokio::main]\nasync fn main() -> Result<(), Box<dyn std::error::Error>> {\n    let addr = \"[::1]:50051\".parse()?;\n    let greeter = MyGreeter::default();\n\n    Server::builder()\n        .add_service(GreeterServer::new(greeter))\n        .serve(addr)\n        .await?;\n\n    Ok()\n}\n```\n\n----------------------------------------\n\nTITLE: Running the RouteGuide Client\nDESCRIPTION: Command to run the example RouteGuide client application using Cargo.\nSOURCE: https://github.com/hyperium/tonic/blob/master/examples/routeguide-tutorial.md#_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\n$ cargo run --bin routeguide-client\n```\n\n----------------------------------------\n\nTITLE: Defining Protocol Buffer message types\nDESCRIPTION: Protocol Buffer message definitions for HelloRequest and HelloReply types used in the Greeter service.\nSOURCE: https://github.com/hyperium/tonic/blob/master/examples/helloworld-tutorial.md#_snippet_5\n\nLANGUAGE: proto\nCODE:\n```\nmessage HelloRequest {\n    // Request message contains the name to be greeted\n    string name = 1;\n}\n\nmessage HelloReply {\n    // Reply contains the greeting message\n    string message = 1;\n}\n```\n\n----------------------------------------\n\nTITLE: Creating build.rs for Protocol Buffer compilation\nDESCRIPTION: Build script that uses tonic-build to compile Protocol Buffer definitions into Rust code during the build process.\nSOURCE: https://github.com/hyperium/tonic/blob/master/examples/helloworld-tutorial.md#_snippet_8\n\nLANGUAGE: rust\nCODE:\n```\nfn main() -> Result<(), Box<dyn std::error::Error>> {\n    tonic_build::compile_protos(\"proto/helloworld.proto\")?\n    Ok()\n}\n```\n\n----------------------------------------\n\nTITLE: Using grpcurl to test gRPC server\nDESCRIPTION: Command to test the gRPC server using grpcurl, a command-line tool for interacting with gRPC services.\nSOURCE: https://github.com/hyperium/tonic/blob/master/examples/helloworld-tutorial.md#_snippet_13\n\nLANGUAGE: shell\nCODE:\n```\n$ grpcurl -plaintext -import-path ./proto -proto helloworld.proto -d '{\"name\": \"Tonic\"}' '[::1]:50051' helloworld.Greeter/SayHello\n```\n\n----------------------------------------\n\nTITLE: Referencing Generated protobuf Rust Modules with tonic::include_proto! Macro (Rust)\nDESCRIPTION: Illustrates how to include compiled protobuf definitions into a Rust module using tonic's include_proto macro. This allows access to generated client structs and request/response messages, demonstrated here with the google.pubsub.v1 API namespace. It exemplifies integrating generated code into application logic.\nSOURCE: https://github.com/hyperium/tonic/blob/master/tonic-build/README.md#_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\npub mod api {\n    tonic::include_proto!(\"google.pubsub.v1\");\n}\nuse api::{publisher_client::PublisherClient, ListTopicsRequest};\n```\n\n----------------------------------------\n\nTITLE: Custom Module Path Mapping for Generated Protobuf Code in Rust (Rust)\nDESCRIPTION: Shows how to organize the generated Rust protobuf code into custom module paths by manually defining modules with #[path] attributes. This technique supports placing generated files outside the default directory and maintaining a clear module hierarchy aligned with proto package namespaces.\nSOURCE: https://github.com/hyperium/tonic/blob/master/tonic-build/README.md#_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\npub mod google {\n    #[path = \"\"]\n    pub mod pubsub {\n        #[path = \"google.pubsub.v1.rs\"]\n        pub mod v1;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Specifying Required Dependencies for tonic-build in Cargo.toml (TOML)\nDESCRIPTION: Defines the dependencies necessary for using tonic and prost in a Rust project, including build dependencies specifically for tonic-build. This configuration is essential for enabling proto compilation and code generation during the build process.\nSOURCE: https://github.com/hyperium/tonic/blob/master/tonic-build/README.md#_snippet_0\n\nLANGUAGE: toml\nCODE:\n```\n[dependencies]\ntonic = \"<tonic-version>\"\nprost = \"<prost-version>\"\n\n[build-dependencies]\ntonic-build = \"<tonic-version>\"\n```\n\n----------------------------------------\n\nTITLE: Initializing gRPC Health Client with Tonic Transport in Rust\nDESCRIPTION: This code snippet demonstrates how to establish a connection and create a new health check client using tonic's transport layer in Rust. It requires the tonic transport module and the health client, allowing interaction with a gRPC health check service. The code sets up the connection via an Endpoint and constructs a HealthClient from the established connection.\nSOURCE: https://github.com/hyperium/tonic/blob/master/tonic-health/README.md#_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\nlet conn = tonic::transport::Endpoint::new(dst)? .connect().await?; \nlet client = HealthClient::new(conn);\n```"
  }
]