[
  {
    "owner": "gcanti",
    "repo": "fp-ts",
    "content": "TITLE: Installing fp-ts via npm\nDESCRIPTION: Command to install the stable version of fp-ts using npm. It's important to maintain a single version of fp-ts in a project to prevent TypeScript compiler issues.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/README.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm install fp-ts\n```\n\n----------------------------------------\n\nTITLE: Importing Modules from fp-ts\nDESCRIPTION: The correct pattern for importing modules from fp-ts. This ensures that you're importing the required modules correctly from the library.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/guides/code-conventions.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport ... from 'fp-ts/<module>'\n```\n\n----------------------------------------\n\nTITLE: Implementing Function Composition with flow\nDESCRIPTION: Performs left-to-right function composition with support for multiple arguments and type safety.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/function.ts.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare function flow<A extends ReadonlyArray<unknown>, B>(ab: (...a: A) => B): (...a: A) => B\nexport declare function flow<A extends ReadonlyArray<unknown>, B, C>(\n  ab: (...a: A) => B,\n  bc: (b: B) => C\n): (...a: A) => C\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport { flow } from 'fp-ts/function'\n\nconst len = (s: string): number => s.length\nconst double = (n: number): number => n * 2\n\nconst f = flow(len, double)\n\nassert.strictEqual(f('aaa'), 6)\n```\n\n----------------------------------------\n\nTITLE: Example Comparing Imperative vs Functional Error Handling with Either\nDESCRIPTION: A comprehensive example demonstrating how to use Either for functional error handling compared to traditional imperative try/catch approaches. Shows handling of multiple potential failure points (empty array, division by zero) in both styles.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Either.ts.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as E from 'fp-ts/Either'\nimport { pipe } from 'fp-ts/function'\n\nconst double = (n: number): number => n * 2\n\nexport const imperative = (as: ReadonlyArray<number>): string => {\n  const head = (as: ReadonlyArray<number>): number => {\n    if (as.length === 0) {\n      throw new Error('empty array')\n    }\n    return as[0]\n  }\n  const inverse = (n: number): number => {\n    if (n === 0) {\n      throw new Error('cannot divide by zero')\n    }\n    return 1 / n\n  }\n  try {\n    return `Result is ${inverse(double(head(as)))}`\n  } catch (err: any) {\n    return `Error is ${err.message}`\n  }\n}\n\nexport const functional = (as: ReadonlyArray<number>): string => {\n  const head = <A>(as: ReadonlyArray<A>): E.Either<string, A> =>\n    as.length === 0 ? E.left('empty array') : E.right(as[0])\n  const inverse = (n: number): E.Either<string, number> => (n === 0 ? E.left('cannot divide by zero') : E.right(1 / n))\n  return pipe(\n    as,\n    head,\n    E.map(double),\n    E.flatMap(inverse),\n    E.match(\n      (err) => `Error is ${err}`, // onLeft handler\n      (head) => `Result is ${head}` // onRight handler\n    )\n  )\n}\n\nassert.deepStrictEqual(imperative([1, 2, 3]), functional([1, 2, 3]))\nassert.deepStrictEqual(imperative([]), functional([]))\nassert.deepStrictEqual(imperative([0]), functional([0]))\n```\n\n----------------------------------------\n\nTITLE: FP-TS Core Module Exports\nDESCRIPTION: TypeScript type declarations for core fp-ts module exports including data types, type classes and utilities. Each export represents a module containing functional programming primitives and operations.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/index.ts.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const array: typeof array\nexport declare const const: typeof const_\nexport declare const either: typeof either\nexport declare const endomorphism: typeof endomorphism\nexport declare const identity: typeof identity\nexport declare const io: typeof io\nexport declare const ioEither: typeof ioEither\nexport declare const ioOption: typeof ioOption\nexport declare const map: typeof map\nexport declare const nonEmptyArray: typeof nonEmptyArray\nexport declare const option: typeof option\nexport declare const predicate: typeof predicate\nexport declare const reader: typeof reader\nexport declare const readerEither: typeof readerEither\nexport declare const readerIO: typeof readerIO\nexport declare const readerTask: typeof readerTask\nexport declare const readerTaskEither: typeof readerTaskEither\nexport declare const readonlyArray: typeof readonlyArray\nexport declare const readonlyMap: typeof readonlyMap\nexport declare const readonlyNonEmptyArray: typeof readonlyNonEmptyArray\nexport declare const readonlyRecord: typeof readonlyRecord\nexport declare const readonlySet: typeof readonlySet\nexport declare const readonlyTuple: typeof readonlyTuple\nexport declare const record: typeof record\nexport declare const refinement: typeof refinement\nexport declare const separated: typeof separated\nexport declare const set: typeof set\nexport declare const state: typeof state\nexport declare const stateReaderTaskEither: typeof stateReaderTaskEither\nexport declare const store: typeof store\nexport declare const task: typeof task\nexport declare const taskEither: typeof taskEither\nexport declare const taskOption: typeof taskOption\nexport declare const taskThese: typeof taskThese\nexport declare const these: typeof these\nexport declare const traced: typeof traced\nexport declare const tree: typeof tree\nexport declare const tuple: typeof tuple\nexport declare const validationT: typeof validationT\nexport declare const writer: typeof writer\n```\n\n----------------------------------------\n\nTITLE: Comparing Imperative vs Functional Error Handling\nDESCRIPTION: A complete example that compares imperative error handling using try/catch with functional error handling using Option. The functional approach avoids exceptions and provides a more composable way to handle possibly failing computations.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Option.ts.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as O from 'fp-ts/Option'\nimport { pipe } from 'fp-ts/function'\n\nconst double = (n: number): number => n * 2\n\nexport const imperative = (as: ReadonlyArray<number>): string => {\n  const head = (as: ReadonlyArray<number>): number => {\n    if (as.length === 0) {\n      throw new Error()\n    }\n    return as[0]\n  }\n  const inverse = (n: number): number => {\n    if (n === 0) {\n      throw new Error()\n    }\n    return 1 / n\n  }\n  try {\n    return `Result is ${inverse(double(head(as)))}`\n  } catch (e) {\n    return 'no result'\n  }\n}\n\nexport const functional = (as: ReadonlyArray<number>): string => {\n  const head = <A>(as: ReadonlyArray<A>): O.Option<A> => (as.length === 0 ? O.none : O.some(as[0]))\n  const inverse = (n: number): O.Option<number> => (n === 0 ? O.none : O.some(1 / n))\n  return pipe(\n    as,\n    head,\n    O.map(double),\n    O.flatMap(inverse),\n    O.match(\n      () => 'no result', // onNone handler\n      (head) => `Result is ${head}` // onSome handler\n    )\n  )\n}\n\nassert.deepStrictEqual(imperative([1, 2, 3]), functional([1, 2, 3]))\nassert.deepStrictEqual(imperative([]), functional([]))\nassert.deepStrictEqual(imperative([0]), functional([0]))\n```\n\n----------------------------------------\n\nTITLE: Implementing Functor Instance for Identity\nDESCRIPTION: Implementation of the Functor type class instance for the Identity data type. This includes defining the URI, augmenting the URItoKind interface, and providing the map function implementation.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/guides/HKT.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n// Identity.ts\n\nimport { Functor1 } from 'fp-ts/Functor'\n\nexport const URI = 'Identity'\n\nexport type URI = typeof URI\n\ndeclare module 'fp-ts/HKT' {\n  interface URItoKind<A> {\n    readonly Identity: Identity<A>\n  }\n}\n\nexport type Identity<A> = A\n\n// Functor instance\nexport const Functor: Functor1<URI> = {\n  URI,\n  map: (ma, f) => f(ma)\n}\n```\n\n----------------------------------------\n\nTITLE: Monad Transformer Export Declarations\nDESCRIPTION: Exports of monad transformer implementations including eitherT, optionT, readerT, stateT, theseT, and writerT. These provide composition of different computational effects.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/index.ts.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const eitherT: typeof eitherT\n```\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const optionT: typeof optionT\n```\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const readerT: typeof readerT\n```\n\n----------------------------------------\n\nTITLE: Converting Promises to TaskEither with Error Handling\nDESCRIPTION: The tryCatch function transforms a Promise that may reject into a TaskEither, handling potential rejection with a provided error mapping function. This ensures asynchronous operations have explicit error handling.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/TaskEither.ts.md#2025-04-23_snippet_36\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const tryCatch: <E, A>(f: LazyArg<Promise<A>>, onRejected: (reason: unknown) => E) => TaskEither<E, A>\n```\n\n----------------------------------------\n\nTITLE: Basic Task Monad Operations in TypeScript\nDESCRIPTION: Demonstrates traditional monadic operations using Task monad with pipe, map, and flatMap to handle command line input and printing.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/guides/do-notation.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { pipe } from 'fp-ts/function'\nimport * as T from 'fp-ts/Task'\n\ndeclare const print: (s: string) => T.Task<void>\ndeclare const readLine: T.Task<string>\n\nconst main: T.Task<{ x: string; y: string }> = pipe(\n  readLine,\n  T.map((x) => ({ x })),\n  T.flatMap(({ x }) =>\n    pipe(\n      readLine,\n      T.map((y) => ({ x, y }))\n    )\n  ),\n  T.tap(({ x }) => print(x)),\n  T.tap(({ y }) => print(y))\n)\n```\n\n----------------------------------------\n\nTITLE: Converting between Option and nullable values in TypeScript\nDESCRIPTION: Utility functions to convert between Option and nullable values (null/undefined) in TypeScript, enabling interoperation between functional code and JavaScript APIs.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Option.ts.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { none, some, fromNullable } from 'fp-ts/Option'\n\nassert.deepStrictEqual(fromNullable(undefined), none)\nassert.deepStrictEqual(fromNullable(null), none)\nassert.deepStrictEqual(fromNullable(1), some(1))\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport { some, none, toNullable } from 'fp-ts/Option'\nimport { pipe } from 'fp-ts/function'\n\nassert.strictEqual(pipe(some(1), toNullable), 1)\nassert.strictEqual(pipe(none, toNullable), null)\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport { some, none, toUndefined } from 'fp-ts/Option'\nimport { pipe } from 'fp-ts/function'\n\nassert.strictEqual(pipe(some(1), toUndefined), 1)\nassert.strictEqual(pipe(none, toUndefined), undefined)\n```\n\n----------------------------------------\n\nTITLE: Option Type Guards\nDESCRIPTION: Type guard functions for checking if an Option value is Some or None, enabling type-safe conditional logic.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Option.ts.md#2025-04-23_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\nimport { some, none, isSome } from 'fp-ts/Option'\n\nassert.strictEqual(isSome(some(1)), true)\nassert.strictEqual(isSome(none), false)\n```\n\n----------------------------------------\n\nTITLE: Implementing getOrElse operation for Either in TypeScript\nDESCRIPTION: Defines a function that returns the wrapped value if it's a Right or a default value if it's a Left.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Either.ts.md#2025-04-23_snippet_8\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare const getOrElse: <E, A>(onLeft: (e: E) => A) => (ma: Either<E, A>) => A\n```\n\n----------------------------------------\n\nTITLE: Do Notation with Task Monad\nDESCRIPTION: Shows how to simplify the previous code using fp-ts do notation with Task monad, making the code more readable and linear.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/guides/do-notation.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst mainDo: T.Task<{ x: string; y: string }> = pipe(\n  T.Do,\n  T.bind('x', () => readLine),\n  T.bind('y', () => readLine),\n  T.tap(({ x }) => print(x)),\n  T.tap(({ y }) => print(y))\n)\n```\n\n----------------------------------------\n\nTITLE: Converting Do Notation from PureScript to TypeScript\nDESCRIPTION: Shows how to translate PureScript's do notation for handling sequential operations into fp-ts pipe operations with Task monad.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/guides/purescript.md#2025-04-23_snippet_0\n\nLANGUAGE: purescript\nCODE:\n```\ndo\n  print \"foo\"\n  print \"bar\"\n  x <- readLine\n  print x\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport { pipe } from 'fp-ts/function'\nimport * as T from 'fp-ts/Task'\n\ndeclare const print: (s: string) => T.Task<void>\ndeclare const readLine: T.Task<string>\n\npipe(\n  T.Do,\n  T.tap(() => print('foo')),\n  T.tap(() => print('bar')),\n  T.bind('x', () => readLine),\n  T.flatMap(({ x }) => print(x))\n)\n```\n\n----------------------------------------\n\nTITLE: Defining Task Interface in TypeScript\nDESCRIPTION: Defines the Task interface representing an asynchronous computation that yields a value of type A and never fails.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Task.ts.md#2025-04-23_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ninterface Task<A> {\n  (): Promise<A>\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Either Type and Interfaces\nDESCRIPTION: Core type definitions for Either, Left, and Right interfaces representing the Either monad\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Either.ts.md#2025-04-23_snippet_24\n\nLANGUAGE: typescript\nCODE:\n```\nexport type Either<E, A> = Left<E> | Right<A>\n\nexport interface Left<E> {\n  readonly _tag: 'Left'\n  readonly left: E\n}\n\nexport interface Right<A> {\n  readonly _tag: 'Right'\n  readonly right: A\n}\n```\n\n----------------------------------------\n\nTITLE: Converting Node-style Callbacks to TaskEither\nDESCRIPTION: The taskify function converts Node.js-style callback functions (which take a callback with error and result parameters) into functions that return a TaskEither. It supports multiple overloads for different argument counts.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/TaskEither.ts.md#2025-04-23_snippet_35\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare function taskify<L, R>(f: (cb: (e: L | null | undefined, r?: R) => void) => void): () => TaskEither<L, R>\nexport declare function taskify<A, L, R>(\n  f: (a: A, cb: (e: L | null | undefined, r?: R) => void) => void\n): (a: A) => TaskEither<L, R>\nexport declare function taskify<A, B, L, R>(\n  f: (a: A, b: B, cb: (e: L | null | undefined, r?: R) => void) => void\n): (a: A, b: B) => TaskEither<L, R>\nexport declare function taskify<A, B, C, L, R>(\n  f: (a: A, b: B, c: C, cb: (e: L | null | undefined, r?: R) => void) => void\n): (a: A, b: B, c: C) => TaskEither<L, R>\nexport declare function taskify<A, B, C, D, L, R>(\n  f: (a: A, b: B, c: C, d: D, cb: (e: L | null | undefined, r?: R) => void) => void\n): (a: A, b: B, c: C, d: D) => TaskEither<L, R>\nexport declare function taskify<A, B, C, D, E, L, R>(\n  f: (a: A, b: B, c: C, d: D, e: E, cb: (e: L | null | undefined, r?: R) => void) => void\n): (a: A, b: B, c: C, d: D, e: E) => TaskEither<L, R>\n```\n\n----------------------------------------\n\nTITLE: Running a Task in fp-ts 2.x (New)\nDESCRIPTION: Example of creating and running a Task in fp-ts 2.x using the thunk approach. Instead of calling run(), the Task is now a function that returns a Promise when invoked.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/guides/upgrade-to-v2.md#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Task } from 'fp-ts/Task'\n\nconst deepThought: Task<number> = () => Promise.resolve(42)\n\ndeepThought().then((n) => {\n  console.log(`The answer is ${n}.`)\n})\n```\n\n----------------------------------------\n\nTITLE: Defining the Either Type in TypeScript\nDESCRIPTION: The core type definition for Either, showing it as a union of Left and Right types. This represents a value that can be one of two possible types.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Either.ts.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ntype Either<E, A> = Left<E> | Right<A>\n```\n\n----------------------------------------\n\nTITLE: Pattern Matching with match\nDESCRIPTION: Function for handling both cases of an Either value through pattern matching\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Either.ts.md#2025-04-23_snippet_26\n\nLANGUAGE: typescript\nCODE:\n```\nimport { match, left, right } from 'fp-ts/Either'\nimport { pipe } from 'fp-ts/function'\n\nfunction onLeft(errors: Array<string>): string {\n  return `Errors: ${errors.join(', ')}`\n}\n\nfunction onRight(value: number): string {\n  return `Ok: ${value}`\n}\n\nassert.strictEqual(pipe(right(1), match(onLeft, onRight)), 'Ok: 1')\nassert.strictEqual(pipe(left(['error 1', 'error 2']), match(onLeft, onRight)), 'Errors: error 1, error 2')\n```\n\n----------------------------------------\n\nTITLE: Implementing Either Data Type with Functor Instance\nDESCRIPTION: Implementation of the Either data type with its Functor instance. Either is a type constructor of kind * -> * -> *, which requires using Functor2 and URItoKind2.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/guides/HKT.md#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\n// Either.ts\n\nimport { Functor2 } from 'fp-ts/Functor'\n\nexport const URI = 'Either'\n\nexport type URI = typeof URI\n\ndeclare module 'fp-ts/HKT' {\n  interface URItoKind2<E, A> {\n    readonly Either: Either<E, A>\n  }\n}\n\nexport interface Left<E> {\n  readonly _tag: 'Left'\n  readonly left: E\n}\n\nexport interface Right<A> {\n  readonly _tag: 'Right'\n  readonly right: A\n}\n\nexport type Either<E, A> = Left<E> | Right<A>\n\nexport const right = <A, E = never>(a: A): Either<E, A> => ({ _tag: 'Right', right: a })\n\n// Functor instance\nexport const Functor: Functor2<URI> = {\n  URI,\n  map: (ma, f) => (ma._tag === 'Left' ? ma : right(f(ma.right)))\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing ReadonlyArray Concatenation in TypeScript\nDESCRIPTION: Defines functions for concatenating ReadonlyArrays, including a version that preserves type information.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReadonlyArray.ts.md#2025-04-23_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const concat: <A>(second: readonly A[]) => (first: readonly A[]) => readonly A[]\n\nexport declare const concatW: <B>(second: readonly B[]) => <A>(first: readonly A[]) => readonly (B | A)[]\n```\n\n----------------------------------------\n\nTITLE: Utility Function Export Declarations\nDESCRIPTION: Exports of utility functions and type definitions for common JavaScript types like boolean, console, date, and others. These provide functional programming utilities for working with basic types.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/index.ts.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const boolean: typeof boolean\n```\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const console: typeof console\n```\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const date: typeof date\n```\n\n----------------------------------------\n\nTITLE: Modifying a specific key in a Record with fp-ts\nDESCRIPTION: Applies a mapping function to one specific key/value pair in a Record. Returns an Option of a new Record with the modified value, or None if the key doesn't exist.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Record.ts.md#2025-04-23_snippet_40\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const modifyAt: <A>(\n  k: string,\n  f: (a: A) => A\n) => <K extends string>(r: Record<K, A>) => Option<Record<K, A>>\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport { modifyAt } from 'fp-ts/Record'\nimport { option } from 'fp-ts'\n\nassert.deepStrictEqual(modifyAt('a', (x: number) => x * 3)({ a: 1, b: 2 }), option.some({ a: 3, b: 2 }))\nassert.deepStrictEqual(modifyAt('c', (x: number) => x * 3)({ a: 1, b: 2 }), option.none)\n```\n\n----------------------------------------\n\nTITLE: Creating NonEmptyArrays with makeBy Function\nDESCRIPTION: Function to create a NonEmptyArray of specified length where each element is generated by applying a function to its index. The parameter n is normalized to a natural number.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/NonEmptyArray.ts.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { makeBy } from 'fp-ts/NonEmptyArray'\nimport { pipe } from 'fp-ts/function'\n\nconst double = (n: number): number => n * 2\nassert.deepStrictEqual(pipe(5, makeBy(double)), [0, 2, 4, 6, 8])\n```\n\n----------------------------------------\n\nTITLE: Multi-criteria Sorting of ReadonlyArray in TypeScript\nDESCRIPTION: Sorts the elements of a readonly array using multiple criteria. Elements are compared using the provided Ord instances in order.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReadonlyArray.ts.md#2025-04-23_snippet_56\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const sortBy: <B>(ords: readonly Ord<B>[]) => <A extends B>(as: readonly A[]) => readonly A[]\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport { sortBy } from 'fp-ts/ReadonlyArray'\nimport { contramap } from 'fp-ts/Ord'\nimport * as S from 'fp-ts/string'\nimport * as N from 'fp-ts/number'\nimport { pipe } from 'fp-ts/function'\n\ninterface Person {\n  readonly name: string\n  readonly age: number\n}\nconst byName = pipe(\n  S.Ord,\n  contramap((p: Person) => p.name)\n)\nconst byAge = pipe(\n  N.Ord,\n  contramap((p: Person) => p.age)\n)\n\nconst sortByNameByAge = sortBy([byName, byAge])\n\nconst persons = [\n  { name: 'a', age: 1 },\n  { name: 'b', age: 3 },\n  { name: 'c', age: 2 },\n  { name: 'b', age: 2 },\n]\nassert.deepStrictEqual(sortByNameByAge(persons), [\n  { name: 'a', age: 1 },\n  { name: 'b', age: 2 },\n  { name: 'b', age: 3 },\n  { name: 'c', age: 2 },\n])\n```\n\n----------------------------------------\n\nTITLE: Using fromNullable with Either in TypeScript\nDESCRIPTION: Example of using the fromNullable function to convert potentially null or undefined values into Either types, providing a default error value for the Left case.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Either.ts.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { fromNullable, left, right } from 'fp-ts/Either'\n\nconst parse = fromNullable('nully')\n\nassert.deepStrictEqual(parse(1), right(1))\nassert.deepStrictEqual(parse(null), left('nully'))\n```\n\n----------------------------------------\n\nTITLE: Error Handling with tryCatch\nDESCRIPTION: Utility function to convert potentially throwing functions into Either values\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Either.ts.md#2025-04-23_snippet_25\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as E from 'fp-ts/Either'\n\nconst unsafeHead = <A>(as: ReadonlyArray<A>): A => {\n  if (as.length > 0) {\n    return as[0]\n  } else {\n    throw new Error('empty array')\n  }\n}\n\nconst head = <A>(as: ReadonlyArray<A>): E.Either<Error, A> =>\n  E.tryCatch(\n    () => unsafeHead(as),\n    (e) => (e instanceof Error ? e : new Error('unknown error'))\n  )\n\nassert.deepStrictEqual(head([]), E.left(new Error('empty array')))\nassert.deepStrictEqual(head([1, 2, 3]), E.right(1))\n```\n\n----------------------------------------\n\nTITLE: Implementing updateAt function for Records in TypeScript\nDESCRIPTION: Creates a function that safely updates a value for a specific key in a Record. It returns an Option type - Some with the updated Record if the key exists, None otherwise.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Record.ts.md#2025-04-23_snippet_54\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const updateAt: <A>(k: string, a: A) => <K extends string>(r: Record<K, A>) => Option<Record<K, A>>\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport { updateAt } from 'fp-ts/Record'\nimport { option } from 'fp-ts'\n\nassert.deepStrictEqual(updateAt('a', 3)({ a: 1, b: 2 }), option.some({ a: 3, b: 2 }))\nassert.deepStrictEqual(updateAt('c', 3)({ a: 1, b: 2 }), option.none)\n```\n\n----------------------------------------\n\nTITLE: Converting Type Class Instances from PureScript to TypeScript\nDESCRIPTION: Shows how to implement type class instances in TypeScript using objects that conform to the type class interface.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/guides/purescript.md#2025-04-23_snippet_5\n\nLANGUAGE: purescript\nCODE:\n```\ninstance functorOption :: Functor Option where\n  map fn (Some x) = Some (fn x)\n  map _  _        = None\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Functor1 } from 'fp-ts/Functor'\nimport { pipe } from 'fp-ts/function'\n\nconst functorOption: Functor1<URI> = {\n  URI,\n  map: (fa, f) =>\n    pipe(\n      fa,\n      maybe(\n        () => none,\n        (a) => some(f(a))\n      )\n    )\n}\n```\n\n----------------------------------------\n\nTITLE: Defining the Option Type in TypeScript\nDESCRIPTION: The fundamental type definition for Option, representing a container for an optional value of type A that can be either None (empty) or Some (containing a value).\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Option.ts.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ntype Option<A> = None | Some<A>\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Apply Usage with Option in TypeScript\nDESCRIPTION: This example shows how to use the Apply typeclass to lift and apply a function of multiple arguments to values wrapped in the Option type constructor.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Apply.ts.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as O from 'fp-ts/Option'\nimport { pipe } from 'fp-ts/function'\n\nconst f = (a: string) => (b: number) => (c: boolean) => a + String(b) + String(c)\nconst fa: O.Option<string> = O.some('s')\nconst fb: O.Option<number> = O.some(1)\nconst fc: O.Option<boolean> = O.some(true)\n\nassert.deepStrictEqual(\n  pipe(\n    // lift a function\n    O.some(f),\n    // apply the first argument\n    O.ap(fa),\n    // apply the second argument\n    O.ap(fb),\n    // apply the third argument\n    O.ap(fc)\n  ),\n  O.some('s1true')\n)\n```\n\n----------------------------------------\n\nTITLE: Defining Monad Interface in TypeScript\nDESCRIPTION: Defines the basic Monad interface that extends Applicative and Chain. This interface represents the core concept of a Monad in functional programming.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Monad.ts.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface Monad<F> extends Applicative<F>, Chain<F> {}\n```\n\n----------------------------------------\n\nTITLE: Implementing GetOrElse with Example - TypeScript\nDESCRIPTION: Function that extracts a value from an Option, returning a default value if None. Includes usage example showing both Some and None cases.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Option.ts.md#2025-04-23_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const getOrElse: <A>(onNone: LazyArg<A>) => (ma: Option<A>) => A\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport { some, none, getOrElse } from 'fp-ts/Option'\nimport { pipe } from 'fp-ts/function'\n\nassert.strictEqual(\n  pipe(\n    some(1),\n    getOrElse(() => 0)\n  ),\n  1\n)\nassert.strictEqual(\n  pipe(\n    none,\n    getOrElse(() => 0)\n  ),\n  0\n)\n```\n\n----------------------------------------\n\nTITLE: Implementing Object Evolution Function in TypeScript\nDESCRIPTION: Defines a function that creates a new object by recursively evolving a shallow copy of an input object according to provided transformation functions. It takes an object of transformation functions and returns a function that applies these transformations to an input object.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/struct.ts.md#2025-04-23_snippet_2\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare const evolve: <A, F extends { [K in keyof A]: (a: A[K]) => unknown }>(\n  transformations: F\n) => (a: A) => { [K in keyof F]: ReturnType<F[K]> }\n```\n\n----------------------------------------\n\nTITLE: Eq interface definition in TypeScript\nDESCRIPTION: Defines the core Eq interface which requires an equals method that takes two values and returns a boolean.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Eq.ts.md#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface Eq<A> {\n  readonly equals: (x: A, y: A) => boolean\n}\n```\n\n----------------------------------------\n\nTITLE: Tree Drawing Example\nDESCRIPTION: Example demonstrating the usage of drawTree function to create a visual representation of a tree.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Tree.ts.md#2025-04-23_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nimport { make, drawTree } from 'fp-ts/Tree'\n\nconst fa = make('a', [make('b'), make('c'), make('d', [make('e'), make('f')])]) \n\nassert.strictEqual(\n  drawTree(fa),\n  `a\n├─ b\n├─ c\n└─ d\n   ├─ e\n   └─ f`\n)\n```\n\n----------------------------------------\n\nTITLE: Defining Apply2 Interface in TypeScript\nDESCRIPTION: This code snippet defines the Apply2 interface, a variant of Apply for type constructors with two type parameters.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Apply.ts.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface Apply2<F extends URIS2> extends Functor2<F> {\n  readonly ap: <E, A, B>(fab: Kind2<F, E, (a: A) => B>, fa: Kind2<F, E, A>) => Kind2<F, E, B>\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing ReadonlyArray Comprehension in TypeScript\nDESCRIPTION: Defines a function for performing array comprehension on ReadonlyArrays. It supports multiple input arrays and optional filtering conditions.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReadonlyArray.ts.md#2025-04-23_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare function comprehension<A, B, C, D, R>(\n  input: readonly [ReadonlyArray<A>, ReadonlyArray<B>, ReadonlyArray<C>, ReadonlyArray<D>],\n  f: (a: A, b: B, c: C, d: D) => R,\n  g?: (a: A, b: B, c: C, d: D) => boolean\n): ReadonlyArray<R>\nexport declare function comprehension<A, B, C, R>(\n  input: readonly [ReadonlyArray<A>, ReadonlyArray<B>, ReadonlyArray<C>],\n  f: (a: A, b: B, c: C) => R,\n  g?: (a: A, b: B, c: C) => boolean\n): ReadonlyArray<R>\nexport declare function comprehension<A, B, R>(\n  input: readonly [ReadonlyArray<A>, ReadonlyArray<B>],\n  f: (a: A, b: B) => R,\n  g?: (a: A, b: B) => boolean\n): ReadonlyArray<R>\nexport declare function comprehension<A, R>(\n  input: readonly [ReadonlyArray<A>],\n  f: (a: A) => R,\n  g?: (a: A) => boolean\n): ReadonlyArray<R>\n```\n\n----------------------------------------\n\nTITLE: Defining Kind Type Alias for `* -> *` Constructors in TypeScript\nDESCRIPTION: Creates a type alias for unary type constructors, which maps a URI (type identifier) to its corresponding type implementation.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/HKT.ts.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nexport type Kind<URI extends URIS, A> = URI extends URIS ? URItoKind<A>[URI] : any\n```\n\n----------------------------------------\n\nTITLE: Using Element Existence Check in ReadonlyArray in TypeScript\nDESCRIPTION: Demonstrates how to use the elem function to check for the existence of elements in a ReadonlyArray of numbers.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReadonlyArray.ts.md#2025-04-23_snippet_22\n\nLANGUAGE: typescript\nCODE:\n```\nimport { elem } from 'fp-ts/ReadonlyArray'\nimport * as N from 'fp-ts/number'\nimport { pipe } from 'fp-ts/function'\n\nassert.strictEqual(pipe([1, 2, 3], elem(N.Eq)(2)), true)\nassert.strictEqual(pipe([1, 2, 3], elem(N.Eq)(0)), false)\n```\n\n----------------------------------------\n\nTITLE: Between Function for Ord in TypeScript\nDESCRIPTION: Creates a function to test whether a value is between a minimum and maximum (inclusive) according to a given Ord instance.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Ord.ts.md#2025-04-23_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const between: <A>(O: Ord<A>) => (low: A, hi: A) => (a: A) => boolean\n```\n\n----------------------------------------\n\nTITLE: Using Tuple to Create Composite Orderings in TypeScript\nDESCRIPTION: Example of using the tuple function to create a composite ordering for tuples combining string, number, and boolean comparisons.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Ord.ts.md#2025-04-23_snippet_24\n\nLANGUAGE: typescript\nCODE:\n```\nimport { tuple } from 'fp-ts/Ord'\nimport * as B from 'fp-ts/boolean'\nimport * as S from 'fp-ts/string'\nimport * as N from 'fp-ts/number'\n\nconst O = tuple(S.Ord, N.Ord, B.Ord)\nassert.strictEqual(O.compare(['a', 1, true], ['b', 2, true]), -1)\nassert.strictEqual(O.compare(['a', 1, true], ['a', 2, true]), -1)\nassert.strictEqual(O.compare(['a', 1, true], ['a', 1, false]), 1)\n```\n\n----------------------------------------\n\nTITLE: Creating ApplySequenceS Example in TypeScript\nDESCRIPTION: Example showing how to use sequenceS with Either to combine multiple computations into a single Either result containing an object with the combined values.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Apply.ts.md#2025-04-23_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as E from 'fp-ts/Either'\nimport { sequenceS } from 'fp-ts/Apply'\n\nconst ado = sequenceS(E.Apply)\n\nassert.deepStrictEqual(\n  ado({\n    a: E.right(1),\n    b: E.right(true),\n  }),\n  E.right({ a: 1, b: true })\n)\nassert.deepStrictEqual(\n  ado({\n    a: E.right(1),\n    b: E.left('error'),\n  }),\n  E.left('error')\n)\n```\n\n----------------------------------------\n\nTITLE: Defining traverseWithIndex function for Records in TypeScript\nDESCRIPTION: Similar to traverse, but the mapping function also takes the key as an input parameter. This function traverses a Record, applying an Applicative function to each key-value pair.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Record.ts.md#2025-04-23_snippet_52\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare function traverseWithIndex<F extends URIS4>(\n  F: Applicative4<F>\n): <K extends string, S, R, E, A, B>(\n  f: (k: K, a: A) => Kind4<F, S, R, E, B>\n) => (ta: Record<K, A>) => Kind4<F, S, R, E, Record<K, B>>\nexport declare function traverseWithIndex<F extends URIS3>(\n  F: Applicative3<F>\n): <K extends string, R, E, A, B>(\n  f: (k: K, a: A) => Kind3<F, R, E, B>\n) => (ta: Record<K, A>) => Kind3<F, R, E, Record<K, B>>\nexport declare function traverseWithIndex<F extends URIS3, E>(\n  F: Applicative3C<F, E>\n): <K extends string, R, A, B>(\n  f: (k: K, a: A) => Kind3<F, R, E, B>\n) => (ta: Record<K, A>) => Kind3<F, R, E, Record<K, B>>\nexport declare function traverseWithIndex<F extends URIS2>(\n  F: Applicative2<F>\n): <K extends string, E, A, B>(f: (k: K, a: A) => Kind2<F, E, B>) => (ta: Record<K, A>) => Kind2<F, E, Record<K, B>>\nexport declare function traverseWithIndex<F extends URIS2, E>(\n  F: Applicative2C<F, E>\n): <K extends string, A, B>(f: (k: K, a: A) => Kind2<F, E, B>) => (ta: Record<K, A>) => Kind2<F, E, Record<K, B>>\nexport declare function traverseWithIndex<F extends URIS>(\n  F: Applicative1<F>\n): <K extends string, A, B>(f: (k: K, a: A) => Kind<F, B>) => (ta: Record<K, A>) => Kind<F, Record<K, B>>\nexport declare function traverseWithIndex<F>(\n  F: Applicative<F>\n): <K extends string, A, B>(f: (k: K, a: A) => HKT<F, B>) => (ta: Record<K, A>) => HKT<F, Record<K, B>>\n```\n\n----------------------------------------\n\nTITLE: Converting from Option to Either in TypeScript\nDESCRIPTION: Example showing how to convert from an Option type to an Either type using the fromOption function, which transforms None into a Left with a specified error value and Some into a Right.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Either.ts.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as E from 'fp-ts/Either'\nimport { pipe } from 'fp-ts/function'\nimport * as O from 'fp-ts/Option'\n\nassert.deepStrictEqual(\n  pipe(\n    O.some(1),\n    E.fromOption(() => 'error')\n  ),\n  E.right(1)\n)\nassert.deepStrictEqual(\n  pipe(\n    O.none,\n    E.fromOption(() => 'error')\n  ),\n  E.left('error')\n)\n```\n\n----------------------------------------\n\nTITLE: Chaining Nullable Values with Option\nDESCRIPTION: Example of safely accessing deeply nested nullable properties using Option's chainNullableK combinator.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Option.ts.md#2025-04-23_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\nimport { some, none, fromNullable, chainNullableK } from 'fp-ts/Option'\nimport { pipe } from 'fp-ts/function'\n\ninterface Employee {\n  readonly company?: {\n    readonly address?: {\n      readonly street?: {\n        readonly name?: string\n      }\n    }\n  }\n}\n\nconst employee1: Employee = { company: { address: { street: { name: 'high street' } } } }\n\nassert.deepStrictEqual(\n  pipe(\n    fromNullable(employee1.company),\n    chainNullableK((company) => company.address),\n    chainNullableK((address) => address.street),\n    chainNullableK((street) => street.name)\n  ),\n  some('high street')\n)\n\nconst employee2: Employee = { company: { address: { street: {} } } }\n\nassert.deepStrictEqual(\n  pipe(\n    fromNullable(employee2.company),\n    chainNullableK((company) => company.address),\n    chainNullableK((address) => address.street),\n    chainNullableK((street) => street.name)\n  ),\n  none\n)\n```\n\n----------------------------------------\n\nTITLE: Finding Array Intersection with Custom Equality in fp-ts\nDESCRIPTION: Creates an array of unique values included in all given arrays using a custom Eq instance for equality comparisons. The order and references of result values are determined by the first array.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReadonlyArray.ts.md#2025-04-23_snippet_38\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare function intersection<A>(E: Eq<A>): {\n  (xs: ReadonlyArray<A>): (ys: ReadonlyArray<A>) => ReadonlyArray<A>\n  (xs: ReadonlyArray<A>, ys: ReadonlyArray<A>): ReadonlyArray<A>\n}\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport { intersection } from 'fp-ts/ReadonlyArray'\nimport * as N from 'fp-ts/number'\nimport { pipe } from 'fp-ts/function'\n\nassert.deepStrictEqual(pipe([1, 2], intersection(N.Eq)([2, 3])), [2])\n```\n\n----------------------------------------\n\nTITLE: Implementing Array Extension in TypeScript\nDESCRIPTION: Defines a function to extend a ReadonlyArray by applying a function to its elements.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReadonlyArray.ts.md#2025-04-23_snippet_27\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const extend: <A, B>(f: (fa: readonly A[]) => B) => (wa: readonly A[]) => readonly B[]\n```\n\n----------------------------------------\n\nTITLE: Mapping Records in TypeScript\nDESCRIPTION: Map a Record passing the values to the iterating function. This function transforms each value in the Record using the provided mapping function.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Record.ts.md#2025-04-23_snippet_19\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const map: <A, B>(f: (a: A) => B) => <K extends string>(fa: Record<K, A>) => Record<K, B>\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport { map } from 'fp-ts/Record'\n\nconst f = (n: number) => `-${n}-`\nassert.deepStrictEqual(map(f)({ a: 3, b: 5 }), { a: '-3-', b: '-5-' })\n```\n\n----------------------------------------\n\nTITLE: Converting Polymorphic Data Types from PureScript to TypeScript\nDESCRIPTION: Shows implementation of polymorphic Option type in TypeScript with HKT module integration.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/guides/purescript.md#2025-04-23_snippet_2\n\nLANGUAGE: purescript\nCODE:\n```\ndata Option a = None | Some a\n```\n\nLANGUAGE: typescript\nCODE:\n```\nexport const URI = 'Option'\n\nexport type URI = typeof URI\n\ndeclare module 'fp-ts/HKT' {\n  interface URItoKind<A> {\n    readonly [URI]: Option<A>\n  }\n}\n\nexport interface None {\n  readonly _tag: 'None'\n}\n\nexport interface Some<A> {\n  readonly _tag: 'Some'\n  readonly value: A\n}\n\nexport type Option<A> = None | Some<A>\n\nexport const none: Option<never> = { _tag: 'None' }\n\nexport const some = <A>(a: A): Option<A> => ({ _tag: 'Some', value: a })\n```\n\n----------------------------------------\n\nTITLE: Implementing a Name Gathering Program in Haskell using do notation\nDESCRIPTION: A Haskell function that asks for the user's first and last name, then combines them and displays a greeting. This implementation uses Haskell's do notation for sequencing IO operations.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/Do.md#2025-04-23_snippet_0\n\nLANGUAGE: Haskell\nCODE:\n```\nnameDo :: IO ()\nnameDo = do putStrLn \"What is your first name? \"\n            first <- getLine\n            putStrLn \"And your last name? \"\n            last <- getLine\n            let full = first ++ \" \" ++ last\n            putStrLn (\"Pleased to meet you, \" ++ full ++ \"!\")\n```\n\n----------------------------------------\n\nTITLE: Defining the Identity Data Type in TypeScript\nDESCRIPTION: A simple definition of the Identity data type, which is just a type alias for its generic parameter.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/guides/HKT.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// Identity.ts\n\nexport type Identity<A> = A\n```\n\n----------------------------------------\n\nTITLE: Safe Element Access by Index with fp-ts Option\nDESCRIPTION: Provides a safe way to read a value at a particular index from an array. Returns Some containing the value if the index is valid, or None if the index is out of bounds.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReadonlyArray.ts.md#2025-04-23_snippet_43\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare function lookup(i: number): <A>(as: ReadonlyArray<A>) => Option<A>\nexport declare function lookup<A>(i: number, as: ReadonlyArray<A>): Option<A>\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport { lookup } from 'fp-ts/ReadonlyArray'\nimport { some, none } from 'fp-ts/Option'\nimport { pipe } from 'fp-ts/function'\n\nassert.deepStrictEqual(pipe([1, 2, 3], lookup(1)), some(2))\nassert.deepStrictEqual(pipe([1, 2, 3], lookup(3)), none)\n```\n\n----------------------------------------\n\nTITLE: Option Type Constructor from Nullable Values\nDESCRIPTION: Creates a smart constructor function that converts nullable values into Option type, providing type-safe handling of potentially undefined or null values.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Option.ts.md#2025-04-23_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nimport { fromNullableK, none, some } from 'fp-ts/Option'\n\nconst f = (s: string): number | undefined => {\n  const n = parseFloat(s)\n  return isNaN(n) ? undefined : n\n}\n\nconst g = fromNullableK(f)\n\nassert.deepStrictEqual(g('1'), some(1))\nassert.deepStrictEqual(g('a'), none)\n```\n\n----------------------------------------\n\nTITLE: Defining Semigroup Interface in TypeScript\nDESCRIPTION: Defines the Semigroup interface with a single 'concat' operation that combines two values of type A.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Semigroup.ts.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ninterface Semigroup<A> {\n  readonly concat: (x: A, y: A) => A\n}\n```\n\n----------------------------------------\n\nTITLE: Haskell Do Notation Example\nDESCRIPTION: Equivalent implementation in Haskell showing the original inspiration for fp-ts do notation.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/guides/do-notation.md#2025-04-23_snippet_2\n\nLANGUAGE: haskell\nCODE:\n```\nmain :: IO (String, String)\nmain = do\n  x <- readLn\n  y <- readLn\n  print x\n  print y\n  return (x, y)\n```\n\n----------------------------------------\n\nTITLE: Creating Eq instance from equals function in TypeScript\nDESCRIPTION: Constructs an Eq instance from a provided equality function. This is the primary constructor for creating custom equality implementations.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Eq.ts.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const fromEquals: <A>(equals: (x: A, y: A) => boolean) => Eq<A>\n```\n\n----------------------------------------\n\nTITLE: Implementing sequenceArray Function for Array Traversal in TypeScript\nDESCRIPTION: Transforms an array of TaskEither values into a TaskEither of an array, collecting all Right values or failing with the first Left encountered.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/TaskEither.ts.md#2025-04-23_snippet_76\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const sequenceArray: <A, E>(arr: readonly TaskEither<E, A>[]) => TaskEither<E, readonly A[]>\n```\n\n----------------------------------------\n\nTITLE: Defining Applicative Interface in TypeScript\nDESCRIPTION: The base Applicative interface extends both Apply and Pointed interfaces, representing a type class that supports the lifting operation for any number of function arguments.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Applicative.ts.md#2025-04-23_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport interface Applicative<F> extends Apply<F>, Pointed<F> {}\n```\n\n----------------------------------------\n\nTITLE: Intercalating Array Elements with Monoid in fp-ts\nDESCRIPTION: Places an element between members of an array, then folds the results using a provided Monoid. Useful for joining array elements with a separator.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReadonlyArray.ts.md#2025-04-23_snippet_37\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const intercalate: <A>(M: Monoid<A>) => (middle: A) => (as: readonly A[]) => A\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as S from 'fp-ts/string'\nimport { intercalate } from 'fp-ts/ReadonlyArray'\n\nassert.deepStrictEqual(intercalate(S.Monoid)('-')(['a', 'b', 'c']), 'a-b-c')\n```\n\n----------------------------------------\n\nTITLE: Defining Magma Interface in TypeScript\nDESCRIPTION: Defines the Magma interface, which represents a pair (A, concat) where A is a non-empty set and concat is a binary operation on A.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Magma.ts.md#2025-04-23_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport interface Magma<A> {\n  readonly concat: (x: A, y: A) => A\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing tapTask Combinator for TaskEither in TypeScript\nDESCRIPTION: Defines the tapTask combinator, which composes computations in sequence, using the return value of one computation to determine the next computation and keeping only the result of the first. It includes an example of usage.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/TaskEither.ts.md#2025-04-23_snippet_4\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare const tapTask: {\n  <A, _>(f: (a: A) => T.Task<_>): <E>(self: TaskEither<E, A>) => TaskEither<E, A>\n  <E, A, _>(self: TaskEither<E, A>, f: (a: A) => T.Task<_>): TaskEither<E, A>\n}\n```\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport * as TE from 'fp-ts/TaskEither'\nimport * as T from 'fp-ts/Task'\nimport * as E from 'fp-ts/Either'\n\nconst effect = TE.tapIO(TE.of(1), (value) => T.of(value + 1))\n\nasync function test() {\n  assert.deepStrictEqual(await effect(), E.of(1))\n}\n\ntest()\n```\n\n----------------------------------------\n\nTITLE: Finding Last Element with Mapper Function in Array with fp-ts\nDESCRIPTION: Finds the last element returned by an option-based selector function. Returns the mapped value of the last element for which the function returns Some, or None if no matches are found.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReadonlyArray.ts.md#2025-04-23_snippet_33\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const findLastMap: <A, B>(f: (a: A) => Option<B>) => (as: readonly A[]) => Option<B>\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport { findLastMap } from 'fp-ts/ReadonlyArray'\nimport { some, none } from 'fp-ts/Option'\n\ninterface Person {\n  readonly name: string\n  readonly age?: number\n}\n\nconst persons: ReadonlyArray<Person> = [{ name: 'John' }, { name: 'Mary', age: 45 }, { name: 'Joey', age: 28 }]\n\n// returns the name of the last person that has an age\nassert.deepStrictEqual(findLastMap((p: Person) => (p.age === undefined ? none : some(p.name)))(persons), some('Joey'))\n```\n\n----------------------------------------\n\nTITLE: Sorting ReadonlyNonEmptyArray with Multiple Criteria in TypeScript\nDESCRIPTION: Function that sorts the elements of a ReadonlyNonEmptyArray using multiple Ord instances for multi-criteria sorting. Elements are compared using the first criterion, then the second, and so on.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReadonlyNonEmptyArray.ts.md#2025-04-23_snippet_59\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const sortBy: <B>(\n  ords: readonly Ord<B>[]\n) => <A extends B>(as: ReadonlyNonEmptyArray<A>) => ReadonlyNonEmptyArray<A>\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as RNEA from 'fp-ts/ReadonlyNonEmptyArray'\nimport { contramap } from 'fp-ts/Ord'\nimport * as S from 'fp-ts/string'\nimport * as N from 'fp-ts/number'\nimport { pipe } from 'fp-ts/function'\n\ninterface Person {\n  name: string\n  age: number\n}\n\nconst byName = pipe(\n  S.Ord,\n  contramap((p: Person) => p.name)\n)\n\nconst byAge = pipe(\n  N.Ord,\n  contramap((p: Person) => p.age)\n)\n\nconst sortByNameByAge = RNEA.sortBy([byName, byAge])\n\nconst persons: RNEA.ReadonlyNonEmptyArray<Person> = [\n  { name: 'a', age: 1 },\n  { name: 'b', age: 3 },\n  { name: 'c', age: 2 },\n  { name: 'b', age: 2 },\n]\n\nassert.deepStrictEqual(sortByNameByAge(persons), [\n  { name: 'a', age: 1 },\n  { name: 'b', age: 2 },\n  { name: 'b', age: 3 },\n  { name: 'c', age: 2 },\n])\n```\n\n----------------------------------------\n\nTITLE: Implementing ReadonlyArray Traversal Functions in TypeScript\nDESCRIPTION: Functions for traversing ReadonlyArray types with TaskEither, including indexed versions and sequential variants.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/TaskEither.ts.md#2025-04-23_snippet_79\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const traverseReadonlyArrayWithIndex: <A, E, B>(\n  f: (index: number, a: A) => TaskEither<E, B>\n) => (as: readonly A[]) => TaskEither<E, readonly B[]>\n```\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const traverseReadonlyArrayWithIndexSeq: <A, E, B>(\n  f: (index: number, a: A) => TaskEither<E, B>\n) => (as: readonly A[]) => TaskEither<E, readonly B[]>\n```\n\n----------------------------------------\n\nTITLE: Pattern Matching Operations\nDESCRIPTION: Functions for pattern matching on readonly arrays, including matching first/last elements and empty/non-empty arrays.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReadonlyArray.ts.md#2025-04-23_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const matchLeft: <B, A>(\n  onEmpty: LazyArg<B>,\n  onNonEmpty: (head: A, tail: readonly A[]) => B\n) => (as: readonly A[]) => B\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport { matchLeft } from 'fp-ts/ReadonlyArray'\n\nconst len: <A>(as: ReadonlyArray<A>) => number = matchLeft(\n  () => 0,\n  (_, tail) => 1 + len(tail)\n)\nassert.strictEqual(len([1, 2, 3]), 3)\n```\n\n----------------------------------------\n\nTITLE: Defining the NonEmptyArray Type in TypeScript\nDESCRIPTION: The core type definition for NonEmptyArray, which extends the standard Array type but ensures at least one element exists at index 0. This provides type safety while maintaining full compatibility with standard Array APIs.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/NonEmptyArray.ts.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport type NonEmptyArray<A> = Array<A> & {\n  0: A\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Tree Fold Usage in TypeScript\nDESCRIPTION: Provides examples of using the fold function to sum values, find maximum value, and count leaves in a tree.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Tree.ts.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { fold, make } from 'fp-ts/Tree'\nimport { concatAll } from 'fp-ts/Monoid'\nimport { MonoidSum } from 'fp-ts/number'\n\nconst t = make(1, [make(2), make(3)])\n\nconst sum = concatAll(MonoidSum)\n\n// Sum the values in a tree:\nassert.deepStrictEqual(fold((a: number, bs: Array<number>) => a + sum(bs))(t), 6)\n\n// Find the maximum value in the tree:\nassert.deepStrictEqual(fold((a: number, bs: Array<number>) => bs.reduce((b, acc) => Math.max(b, acc), a))(t), 3)\n\n// Count the number of leaves in the tree:\nassert.deepStrictEqual(fold((_: number, bs: Array<number>) => (bs.length === 0 ? 1 : sum(bs)))(t), 2)\n```\n\n----------------------------------------\n\nTITLE: Implementing getBooleanAlgebra Function in TypeScript\nDESCRIPTION: Type signature for creating a Boolean algebra instance for unary functions.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/function.ts.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const getBooleanAlgebra: <B>(B: BooleanAlgebra<B>) => <A = never>() => BooleanAlgebra<(a: A) => B>\n```\n\n----------------------------------------\n\nTITLE: Using Contramap to Create Complex Orderings in TypeScript\nDESCRIPTION: Example of using contramap to create an Ord instance for a complex User type by sorting on the lastName field.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Ord.ts.md#2025-04-23_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\nimport { pipe } from 'fp-ts/function'\nimport { contramap, Ord } from 'fp-ts/Ord'\nimport * as RA from 'fp-ts/ReadonlyArray'\nimport * as S from 'fp-ts/string'\n\ninterface User {\n  readonly firstName: string\n  readonly lastName: string\n}\n\nconst ordLastName: Ord<string> = S.Ord\n\nconst ordByLastName: Ord<User> = pipe(\n  ordLastName,\n  contramap((user) => user.lastName)\n)\n\nassert.deepStrictEqual(\n  RA.sort(ordByLastName)([\n    { firstName: 'a', lastName: 'd' },\n    { firstName: 'c', lastName: 'b' },\n  ]),\n  [\n    { firstName: 'c', lastName: 'b' },\n    { firstName: 'a', lastName: 'd' },\n  ]\n)\n```\n\n----------------------------------------\n\nTITLE: Implementing Let Binding for Option - TypeScript\nDESCRIPTION: Function that allows binding a new property to an Option value while preserving the original properties.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Option.ts.md#2025-04-23_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const let: <N, A, B>(\n  name: Exclude<N, keyof A>,\n  f: (a: A) => B\n) => (fa: Option<A>) => Option<{ readonly [K in N | keyof A]: K extends keyof A ? A[K] : B }>\n```\n\n----------------------------------------\n\nTITLE: Using evolve Function for Object Transformation in TypeScript\nDESCRIPTION: Demonstrates how to use the evolve function to transform an object's properties. It applies a length calculation to a string property and doubles a number property.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/struct.ts.md#2025-04-23_snippet_3\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { pipe } from 'fp-ts/function'\nimport { evolve } from 'fp-ts/struct'\n\nassert.deepStrictEqual(\n  pipe(\n    { a: 'a', b: 1 },\n    evolve({\n      a: (a) => a.length,\n      b: (b) => b * 2,\n    })\n  ),\n  { a: 1, b: 2 }\n)\n```\n\n----------------------------------------\n\nTITLE: Creating a ReadonlyArray with makeBy in TypeScript\nDESCRIPTION: Creates a ReadonlyArray of length n with elements initialized using a function f(i) where i is the index.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReadonlyArray.ts.md#2025-04-23_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { makeBy } from 'fp-ts/ReadonlyArray'\n\nconst double = (n: number): number => n * 2\nassert.deepStrictEqual(makeBy(5, double), [0, 2, 4, 6, 8])\n```\n\n----------------------------------------\n\nTITLE: Implementing MonadThrow2 Interface\nDESCRIPTION: Defines MonadThrow2 interface for two-parameter type constructors, extending Monad2 with error handling.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/MonadThrow.ts.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface MonadThrow2<M extends URIS2> extends Monad2<M> {\n  readonly throwError: <E, A>(e: E) => Kind2<M, E, A>\n}\n```\n\n----------------------------------------\n\nTITLE: Defining NonEmptyArray Interface in TypeScript\nDESCRIPTION: Core interface definition for NonEmptyArray type that extends Array with a guaranteed first element.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/NonEmptyArray.ts.md#2025-04-23_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface NonEmptyArray<A> extends Array<A> {\n  0: A\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Bounded Interface in TypeScript\nDESCRIPTION: Interface definition for the Bounded type class that extends Ord to include top and bottom boundary values. Types implementing this interface must satisfy the law: bottom <= a <= top.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Bounded.ts.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface Bounded<A> extends Ord<A> {\n  readonly top: A\n  readonly bottom: A\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing tapIO Combinator for TaskEither in TypeScript\nDESCRIPTION: Defines the tapIO combinator, which composes computations in sequence, using the return value of one computation to determine the next computation and keeping only the result of the first. It includes an example of usage.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/TaskEither.ts.md#2025-04-23_snippet_3\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare const tapIO: {\n  <A, _>(f: (a: A) => IO<_>): <E>(self: TaskEither<E, A>) => TaskEither<E, A>\n  <E, A, _>(self: TaskEither<E, A>, f: (a: A) => IO<_>): TaskEither<E, A>\n}\n```\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { pipe } from 'fp-ts/function'\nimport * as TE from 'fp-ts/TaskEither'\nimport * as E from 'fp-ts/Either'\nimport * as Console from 'fp-ts/Console'\n\n// Will produce `Hello, fp-ts` to the stdout\nconst effectA = TE.tapIO(TE.of(1), (value) => Console.log(`Hello, ${value}`))\n\n// No output to the stdout\nconst effectB = pipe(\n  TE.left('error'),\n  TE.tapIO((value) => Console.log(`Hello, ${value}`))\n)\n\nasync function test() {\n  assert.deepStrictEqual(await effectA(), E.of(1))\n  assert.deepStrictEqual(await effectB(), E.left('error'))\n}\n\ntest()\n```\n\n----------------------------------------\n\nTITLE: Array Filtering Functions in TypeScript\nDESCRIPTION: Functions for filtering and partitioning readonly arrays with index support.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReadonlyArray.ts.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const filterWithIndex: {\n  <A, B extends A>(refinementWithIndex: RefinementWithIndex<number, A, B>): (as: readonly A[]) => readonly B[]\n  <A>(predicateWithIndex: PredicateWithIndex<number, A>): <B extends A>(bs: readonly B[]) => readonly B[]\n  <A>(predicateWithIndex: PredicateWithIndex<number, A>): (as: readonly A[]) => readonly A[]\n}\n```\n\n----------------------------------------\n\nTITLE: Defining IO Interface in TypeScript\nDESCRIPTION: Defines the IO interface representing a non-deterministic synchronous computation that can cause side effects and yields a value of type A.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/IO.ts.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ninterface IO<A> {\n  (): A\n}\n```\n\n----------------------------------------\n\nTITLE: Zipping ReadonlyArrays with Function in TypeScript\nDESCRIPTION: Applies a function to pairs of elements at the same index in two readonly arrays, collecting the results in a new array. If one input array is short, excess elements of the longer array are discarded.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReadonlyArray.ts.md#2025-04-23_snippet_70\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const zipWith: <A, B, C>(fa: readonly A[], fb: readonly B[], f: (a: A, b: B) => C) => readonly C[]\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport { zipWith } from 'fp-ts/ReadonlyArray'\n\nassert.deepStrictEqual(\n  zipWith([1, 2, 3], ['a', 'b', 'c', 'd'], (n, s) => s + n),\n  ['a1', 'b2', 'c3']\n)\n```\n\n----------------------------------------\n\nTITLE: Defining Base Invariant Interface in TypeScript\nDESCRIPTION: Base interface for Invariant type class with a single type parameter F. Includes URI type and imap function for transforming between types while preserving structure.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Invariant.ts.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface Invariant<F> {\n  readonly URI: F\n  readonly imap: <A, B>(fa: HKT<F, A>, f: (a: A) => B, g: (b: B) => A) => HKT<F, B>\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a singleton Record in fp-ts\nDESCRIPTION: Creates a Record with exactly one key/value pair. This is a utility function for initializing Records with a single entry.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Record.ts.md#2025-04-23_snippet_47\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const singleton: <A>(k: string, a: A) => Record<string, A>\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport { singleton } from 'fp-ts/Record'\n\nassert.deepStrictEqual(singleton('a', 1), { a: 1 })\n```\n\n----------------------------------------\n\nTITLE: Implementing fromNullableK for Nullable Lifting\nDESCRIPTION: A function that transforms a function returning a nullable value into a function returning a ReaderTaskEither, with a specified error for null/undefined cases.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReaderTaskEither.ts.md#2025-04-23_snippet_57\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const fromNullableK: <E>(\n  e: E\n) => <A extends readonly unknown[], B>(\n  f: (...a: A) => B | null | undefined\n) => <R = unknown>(...a: A) => ReaderTaskEither<R, E, NonNullable<B>>\n```\n\n----------------------------------------\n\nTITLE: Utility Functions for Predicates in TypeScript\nDESCRIPTION: Defines utility functions for working with predicates, including logical operations (and, or, not) and contramap for transforming predicates.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Predicate.ts.md#2025-04-23_snippet_5\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare const and: <A>(second: Predicate<A>) => (first: Predicate<A>) => Predicate<A>\n```\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare const contramap: <B, A>(f: (b: B) => A) => (predicate: Predicate<A>) => Predicate<B>\n```\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare const not: <A>(predicate: Predicate<A>) => Predicate<A>\n```\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare const or: <A>(second: Predicate<A>) => (first: Predicate<A>) => Predicate<A>\n```\n\n----------------------------------------\n\nTITLE: Defining tap Combinator for ReaderTaskEither in TypeScript\nDESCRIPTION: Defines a tap combinator for ReaderTaskEither that composes computations in sequence, using the return value of one computation to determine the next computation and keeping only the result of the first.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReaderTaskEither.ts.md#2025-04-23_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare const tap: {\n  <R1, E1, A, R2, E2, _>(self: ReaderTaskEither<R1, E1, A>, f: (a: A) => ReaderTaskEither<R2, E2, _>): ReaderTaskEither<\n    R1 & R2,\n    E1 | E2,\n    A\n  >\n  <A, R2, E2, _>(f: (a: A) => ReaderTaskEither<R2, E2, _>): <R1, E1>(\n    self: ReaderTaskEither<R1, E1, A>\n  ) => ReaderTaskEither<R1 & R2, E2 | E1, A>\n}\n```\n\n----------------------------------------\n\nTITLE: Defining throwError Function in TypeScript Option Module\nDESCRIPTION: Function signature for throwError that creates an Option from an error value.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Option.ts.md#2025-04-23_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const throwError: <E, A>(e: E) => Option<A>\n```\n\n----------------------------------------\n\nTITLE: Getting Array Length with fp-ts\nDESCRIPTION: Calculates the number of elements in a ReadonlyArray. This is a thin wrapper around the native length property, providing a functional interface.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReadonlyArray.ts.md#2025-04-23_snippet_53\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const size: <A>(as: readonly A[]) => number\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Semigroup Associativity in TypeScript\nDESCRIPTION: Shows the associativity property that must hold for any Semigroup implementation.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Semigroup.ts.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconcat(x, concat(y, z)) = concat(concat(x, y), z)\n```\n\n----------------------------------------\n\nTITLE: Implementing Object Assign Semigroup in TypeScript\nDESCRIPTION: Creates a semigroup that behaves like Object.assign for merging objects. It takes no parameters and returns a Semigroup for the given object type.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/struct.ts.md#2025-04-23_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare const getAssignSemigroup: <A extends object = never>() => Semigroup<A>\n```\n\n----------------------------------------\n\nTITLE: Modifying Element at Index in Array with fp-ts\nDESCRIPTION: Applies a function to the element at a specified index, creating a new array. Returns Some containing the new array if the index is valid, or None if the index is out of bounds.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReadonlyArray.ts.md#2025-04-23_snippet_44\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const modifyAt: <A>(i: number, f: (a: A) => A) => (as: readonly A[]) => Option<readonly A[]>\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport { modifyAt } from 'fp-ts/ReadonlyArray'\nimport { some, none } from 'fp-ts/Option'\n\nconst double = (x: number): number => x * 2\nassert.deepStrictEqual(modifyAt(1, double)([1, 2, 3]), some([1, 4, 3]))\nassert.deepStrictEqual(modifyAt(1, double)([]), none)\n```\n\n----------------------------------------\n\nTITLE: Defining Monoid Interface in TypeScript\nDESCRIPTION: Core interface definitions for Semigroup and Monoid types. A Monoid extends Semigroup by adding an empty value that acts as an identity for the concat operation.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Monoid.ts.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ninterface Semigroup<A> {\n  readonly concat: (x: A, y: A) => A\n}\n\ninterface Monoid<A> extends Semigroup<A> {\n  readonly empty: A\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing filterOrElse operation for Either in TypeScript\nDESCRIPTION: Defines a function to filter Either values based on a predicate, providing an alternative value if the predicate fails.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Either.ts.md#2025-04-23_snippet_13\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare const filterOrElse: {\n  <A, B extends A, E>(refinement: Refinement<A, B>, onFalse: (a: A) => E): (self: Either<E, A>) => Either<E, B>\n  <A, E>(predicate: Predicate<A>, onFalse: (a: A) => E): <B extends A>(self: Either<E, B>) => Either<E, B>\n  <A, E>(predicate: Predicate<A>, onFalse: (a: A) => E): (self: Either<E, A>) => Either<E, A>\n}\n```\n\n----------------------------------------\n\nTITLE: Filtering Records with Key-Aware Predicates\nDESCRIPTION: Creates a new Record keeping only the entries that satisfy a predicate that considers both key and value. Supports both refinements and predicates with various type signatures.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Record.ts.md#2025-04-23_snippet_29\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare function filterWithIndex<K extends string, A, B extends A>(\n  refinementWithIndex: RefinementWithIndex<K, A, B>\n): (fa: Record<K, A>) => Record<string, B>\nexport declare function filterWithIndex<K extends string, A>(\n  predicateWithIndex: PredicateWithIndex<K, A>\n): <B extends A>(fb: Record<K, B>) => Record<string, B>\nexport declare function filterWithIndex<K extends string, A>(\n  predicateWithIndex: PredicateWithIndex<K, A>\n): (fa: Record<K, A>) => Record<string, A>\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport { filterWithIndex } from 'fp-ts/Record'\n\nassert.deepStrictEqual(filterWithIndex((s: string, v: number) => s.length <= 1 && v > 0)({ a: 1, b: -2, ccc: 3 }), {\n  a: 1,\n})\n```\n\n----------------------------------------\n\nTITLE: Checking if Any Array Element Satisfies Predicate with fp-ts\nDESCRIPTION: Checks if a predicate holds true for any array member. Returns a boolean indicating whether at least one element satisfies the predicate function. Uses a type guard to narrow the array type if it contains matching elements.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReadonlyArray.ts.md#2025-04-23_snippet_54\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const some: <A>(predicate: Predicate<A>) => (as: readonly A[]) => as is RNEA.ReadonlyNonEmptyArray<A>\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport { some } from 'fp-ts/ReadonlyArray'\nimport { pipe } from 'fp-ts/function'\n\nconst isPositive = (n: number): boolean => n > 0\n\nassert.deepStrictEqual(pipe([-1, -2, 3], some(isPositive)), true)\nassert.deepStrictEqual(pipe([-1, -2, -3], some(isPositive)), false)\n```\n\n----------------------------------------\n\nTITLE: Implementing of Constructor for IO in TypeScript\nDESCRIPTION: Implements the 'of' constructor for IO, which creates an IO instance from a value.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/IO.ts.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const of: <A>(a: A) => IO<A>\n```\n\n----------------------------------------\n\nTITLE: Defining TaskEither Interface in TypeScript\nDESCRIPTION: Defines the TaskEither interface, which represents an asynchronous computation that either yields a value of type A or fails with an error of type E.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/TaskEither.ts.md#2025-04-23_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ninterface TaskEither<E, A> extends Task<Either<E, A>> {}\n```\n\n----------------------------------------\n\nTITLE: Converting Type Classes from PureScript to TypeScript\nDESCRIPTION: Shows how to implement type classes in TypeScript using interfaces with higher-kinded types.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/guides/purescript.md#2025-04-23_snippet_4\n\nLANGUAGE: purescript\nCODE:\n```\nclass Functor f where\n  map :: forall a b. (a -> b) -> f a -> f b\n```\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface Functor<F> {\n  readonly URI: F\n  readonly map: <A, B>(fa: HKT<F, A>, f: (a: A) => B) => HKT<F, B>\n}\n\nexport interface Functor1<F extends URIS> {\n  readonly URI: F\n  readonly map: <A, B>(fa: Kind<F, A>, f: (a: A) => B) => Kind<F, B>\n}\n\nexport interface Functor2<F extends URIS2> {\n  readonly URI: F\n  readonly map: <E, A, B>(fa: Kind2<F, E, A>, f: (a: A) => B) => Kind2<F, E, B>\n}\n```\n\n----------------------------------------\n\nTITLE: Using Widen Functions for Error Type Unions\nDESCRIPTION: Demonstrates how 'W' suffixed functions like chainW allow combining different error types into a union type. This enables composing functions with different error types.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/guides/code-conventions.md#2025-04-23_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as E from 'fp-ts/Either'\nimport * as TE from 'fp-ts/TaskEither'\nimport { pipe } from 'fp-ts/pipeable'\n\ndeclare function parseString(s: string): E.Either<string, number>\ndeclare function fetchUser(id: number): TE.TaskEither<Error, User>\n\n// this raises an error because: Type 'string' is not assignable to type 'Error'\nconst program_ = (s: string) => pipe(s, TE.fromEitherK(parseString), TE.chain(fetchUser))\n\n// const program: (s: string) => TE.TaskEither<string | Error, User>\nconst program = (s: string) => pipe(s, TE.fromEitherK(parseString), TE.chainW(fetchUser))\n```\n\n----------------------------------------\n\nTITLE: Filtering and Mapping Records with Key Awareness\nDESCRIPTION: Maps a Record with a function that takes both key and value and returns an Option. The resulting Record contains only entries where the function returned Some values.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Record.ts.md#2025-04-23_snippet_28\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const filterMapWithIndex: <K extends string, A, B>(\n  f: (key: K, a: A) => Option<B>\n) => (fa: Record<K, A>) => Record<string, B>\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport { filterMapWithIndex } from 'fp-ts/Record'\nimport { option } from 'fp-ts'\n\nconst f = (key: string, a: number) => (a >= 0 ? option.some(`${key}${a}`) : option.none)\nassert.deepStrictEqual(filterMapWithIndex(f)({ a: -1, b: 2, c: 3 }), {\n  b: 'b2',\n  c: 'c3',\n})\n```\n\n----------------------------------------\n\nTITLE: Handling Errors with Alternative in TaskEither in TypeScript\nDESCRIPTION: Provides an alternative TaskEither if the original fails.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/TaskEither.ts.md#2025-04-23_snippet_24\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare const orElse: <E1, A, E2>(\n  onLeft: (e: E1) => TaskEither<E2, A>\n) => (ma: TaskEither<E1, A>) => TaskEither<E2, A>\n```\n\n----------------------------------------\n\nTITLE: Converting Promise-returning Functions to TaskEither\nDESCRIPTION: The tryCatchK function converts a function that returns a Promise into a function that returns a TaskEither, with proper error handling using the provided error mapping function.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/TaskEither.ts.md#2025-04-23_snippet_37\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const tryCatchK: <E, A extends readonly unknown[], B>(\n  f: (...a: A) => Promise<B>,\n  onRejected: (reason: unknown) => E\n) => (...a: A) => TaskEither<E, B>\n```\n\n----------------------------------------\n\nTITLE: Looking Up Value by Key in Record\nDESCRIPTION: Retrieves the value for a specific key in a Record, returning it wrapped in an Option. Returns Some with the value if key exists, None otherwise. Supports both curried and non-curried forms.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Record.ts.md#2025-04-23_snippet_38\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const lookup: {\n  (k: string): <A>(r: Record<string, A>) => Option<A>\n  <A>(k: string, r: Record<string, A>): Option<A>\n}\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport { lookup } from 'fp-ts/Record'\nimport { option } from 'fp-ts'\n\nassert.deepStrictEqual(lookup('b')({ a: 'foo', b: 'bar' }), option.some('bar'))\nassert.deepStrictEqual(lookup('c')({ a: 'foo', b: 'bar' }), option.none)\n```\n\n----------------------------------------\n\nTITLE: Defining Extend Interface in TypeScript\nDESCRIPTION: Defines the base Extend interface which extends Functor and provides the extend method for extending computations over a type constructor W.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Extend.ts.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface Extend<W> extends Functor<W> {\n  readonly extend: <A, B>(wa: HKT<W, A>, f: (wa: HKT<W, A>) => B) => HKT<W, B>\n}\n```\n\n----------------------------------------\n\nTITLE: Finding Minimum Element in ReadonlyNonEmptyArray with Ord in TypeScript\nDESCRIPTION: Function that finds the minimum element in a ReadonlyNonEmptyArray using the provided Ord instance for comparison.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReadonlyNonEmptyArray.ts.md#2025-04-23_snippet_51\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const min: <A>(O: Ord<A>) => (as: ReadonlyNonEmptyArray<A>) => A\n```\n\n----------------------------------------\n\nTITLE: Flatmap Operation Example\nDESCRIPTION: Demonstration of flatMap operation on NonEmptyArray to transform and combine array elements.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/NonEmptyArray.ts.md#2025-04-23_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as NEA from 'fp-ts/NonEmptyArray'\nimport { pipe } from 'fp-ts/function'\n\nassert.deepStrictEqual(\n  pipe(\n    [1, 2, 3],\n    NEA.flatMap((n) => [`a${n}`, `b${n}`])\n  ),\n  ['a1', 'b1', 'a2', 'b2', 'a3', 'b3']\n)\n```\n\n----------------------------------------\n\nTITLE: Creating Monoid for Endomorphisms in TypeScript\nDESCRIPTION: Implements a function that returns a Monoid instance for Endomorphism<A> where the empty value is the identity function.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Endomorphism.ts.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const getMonoid: <A = never>() => Monoid<Endomorphism<A>>\n```\n\n----------------------------------------\n\nTITLE: Implementing flatMapNullable Function for Chaining with Nullable Values in TypeScript\nDESCRIPTION: Chains a TaskEither with a nullable-returning function, handling null/undefined with the provided onNullable function, with support for pipeable and data-last styles.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/TaskEither.ts.md#2025-04-23_snippet_70\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const flatMapNullable: {\n  <A, B, E2>(f: (a: A) => B | null | undefined, onNullable: (a: A) => E2): <E1>(\n    self: TaskEither<E1, A>\n  ) => TaskEither<E2 | E1, NonNullable<B>>\n  <E1, A, B, E2>(self: TaskEither<E1, A>, f: (a: A) => B | null | undefined, onNullable: (a: A) => E2): TaskEither<\n    E1 | E2,\n    NonNullable<B>\n  >\n}\n```\n\n----------------------------------------\n\nTITLE: Mapping Records with index keys using fp-ts\nDESCRIPTION: Maps a Record passing the key/value pairs to the iterating function. Returns a new Record with the same keys but values transformed by the provided function.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Record.ts.md#2025-04-23_snippet_39\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const mapWithIndex: <K extends string, A, B>(f: (k: K, a: A) => B) => (fa: Record<K, A>) => Record<K, B>\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport { mapWithIndex } from 'fp-ts/Record'\n\nconst f = (k: string, n: number) => `${k.toUpperCase()}-${n}`\nassert.deepStrictEqual(mapWithIndex(f)({ a: 3, b: 5 }), { a: 'A-3', b: 'B-5' })\n```\n\n----------------------------------------\n\nTITLE: Traversing Reader Array in TypeScript\nDESCRIPTION: Implements traverseArray for Reader, equivalent to ReadonlyArray#traverse(Applicative). It takes a function that produces Readers and an array, returning a Reader that produces an array of results.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Reader.ts.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const traverseArray: <R, A, B>(\n  f: (a: A) => Reader<R, B>\n) => (as: readonly A[]) => Reader<R, readonly B[]>\n```\n\n----------------------------------------\n\nTITLE: Tuple Monoid Example\nDESCRIPTION: Example showing how to create and use monoids for tuples combining different types.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Monoid.ts.md#2025-04-23_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nimport { tuple } from 'fp-ts/Monoid'\nimport * as B from 'fp-ts/boolean'\nimport * as N from 'fp-ts/number'\nimport * as S from 'fp-ts/string'\n\nconst M1 = tuple(S.Monoid, N.MonoidSum)\nassert.deepStrictEqual(M1.concat(['a', 1], ['b', 2]), ['ab', 3])\n\nconst M2 = tuple(S.Monoid, N.MonoidSum, B.MonoidAll)\nassert.deepStrictEqual(M2.concat(['a', 1, true], ['b', 2, false]), ['ab', 3, false])\n```\n\n----------------------------------------\n\nTITLE: Implementing orElse operation for Either in TypeScript\nDESCRIPTION: Defines a function useful for recovering from errors in Either.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Either.ts.md#2025-04-23_snippet_11\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare const orElse: <E1, A, E2>(onLeft: (e: E1) => Either<E2, A>) => (ma: Either<E1, A>) => Either<E2, A>\n```\n\n----------------------------------------\n\nTITLE: Extracting Left Values from Array of Either with fp-ts\nDESCRIPTION: Extracts from an array of Either all the Left elements in order. Useful for collecting error values from a collection of operations that may have failed.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReadonlyArray.ts.md#2025-04-23_snippet_42\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const lefts: <E, A>(as: readonly Either<E, A>[]) => readonly E[]\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport { lefts } from 'fp-ts/ReadonlyArray'\nimport { left, right } from 'fp-ts/Either'\n\nassert.deepStrictEqual(lefts([right(1), left('foo'), right(2)]), ['foo'])\n```\n\n----------------------------------------\n\nTITLE: Creating Empty ReadonlyArray in TypeScript\nDESCRIPTION: Returns an empty readonly array of a specified type.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReadonlyArray.ts.md#2025-04-23_snippet_68\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const zero: <A>() => readonly A[]\n```\n\n----------------------------------------\n\nTITLE: Using Semigroup to Create Complex Sorting Logic in TypeScript\nDESCRIPTION: Example of using the Semigroup instance for Ord to create sorting logic that combines multiple criteria. It demonstrates sorting users by created date descending, then by last name.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Ord.ts.md#2025-04-23_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as D from 'fp-ts/Date'\nimport { pipe } from 'fp-ts/function'\nimport { contramap, getSemigroup, Ord, reverse } from 'fp-ts/Ord'\nimport * as RA from 'fp-ts/ReadonlyArray'\nimport * as S from 'fp-ts/string'\n\ninterface User {\n  readonly id: string\n  readonly lastName: string\n  readonly created: Date\n}\n\nconst ordByLastName: Ord<User> = pipe(\n  S.Ord,\n  contramap((user) => user.lastName)\n)\n\nconst ordByCreated: Ord<User> = pipe(\n  D.Ord,\n  contramap((user) => user.created)\n)\n\nconst ordUserByCreatedDescThenLastName = getSemigroup<User>().concat(reverse(ordByCreated), ordByLastName)\n\nassert.deepStrictEqual(\n  RA.sort(ordUserByCreatedDescThenLastName)([\n    { id: 'c', lastName: 'd', created: new Date(1973, 10, 30) },\n    { id: 'a', lastName: 'b', created: new Date(1973, 10, 30) },\n    { id: 'e', lastName: 'f', created: new Date(1980, 10, 30) },\n  ]),\n  [\n    { id: 'e', lastName: 'f', created: new Date(1980, 10, 30) },\n    { id: 'a', lastName: 'b', created: new Date(1973, 10, 30) },\n    { id: 'c', lastName: 'd', created: new Date(1973, 10, 30) },\n  ]\n)\n```\n\n----------------------------------------\n\nTITLE: Implementing String Semigroup in TypeScript\nDESCRIPTION: Demonstrates a concrete implementation of Semigroup for strings using concatenation.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Semigroup.ts.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Semigroup } from 'fp-ts/Semigroup'\n\nconst semigroupString: Semigroup<string> = {\n  concat: (x, y) => x + y,\n}\n\nconst x = 'x'\nconst y = 'y'\nconst z = 'z'\n\nsemigroupString.concat(x, y) // 'xy'\n\nsemigroupString.concat(x, semigroupString.concat(y, z)) // 'xyz'\n\nsemigroupString.concat(semigroupString.concat(x, y), z) // 'xyz'\n```\n\n----------------------------------------\n\nTITLE: Array Partitioning Functions in TypeScript\nDESCRIPTION: Functions for partitioning readonly arrays into separate collections based on predicates.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReadonlyArray.ts.md#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const partition: {\n  <A, B extends A>(refinement: Refinement<A, B>): (as: readonly A[]) => Separated<readonly A[], readonly B[]>\n  <A>(predicate: Predicate<A>): <B extends A>(bs: readonly B[]) => Separated<readonly B[], readonly B[]>\n  <A>(predicate: Predicate<A>): (as: readonly A[]) => Separated<readonly A[], readonly A[]>\n}\n```\n\n----------------------------------------\n\nTITLE: Union of NonEmptyArrays in TypeScript\nDESCRIPTION: Combines two NonEmptyArrays, removing duplicates based on the provided Eq instance. Returns a new NonEmptyArray containing unique elements from both input arrays.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/NonEmptyArray.ts.md#2025-04-23_snippet_21\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const union: <A>(E: Eq<A>) => (second: NonEmptyArray<A>) => (first: NonEmptyArray<A>) => NonEmptyArray<A>\n```\n\n----------------------------------------\n\nTITLE: Utility Functions for Maps in TypeScript\nDESCRIPTION: Collection of utility functions for working with Maps, including operations for collecting values, deleting entries, checking membership, performing set operations, and manipulating map contents.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Map.ts.md#2025-04-23_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare function collect<K>(O: Ord<K>): <A, B>(f: (k: K, a: A) => B) => (m: Map<K, A>) => Array<B>\n```\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const deleteAt: <K>(E: Eq<K>) => (k: K) => <A>(m: Map<K, A>) => Map<K, A>\n```\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const difference: <K>(E: Eq<K>) => <A>(_second: Map<K, A>) => (first: Map<K, A>) => Map<K, A>\n```\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const elem: <A>(E: Eq<A>) => { (a: A): <K>(m: Map<K, A>) => boolean; <K>(a: A, m: Map<K, A>): boolean }\n```\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const filterMapWithIndex: <K, A, B>(f: (k: K, a: A) => O.Option<B>) => (fa: Map<K, A>) => Map<K, B>\n```\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare function filterWithIndex<K, A, B extends A>(p: (k: K, a: A) => a is B): (m: Map<K, A>) => Map<K, B>\nexport declare function filterWithIndex<K, A>(p: (k: K, a: A) => boolean): <B extends A>(m: Map<K, B>) => Map<K, B>\nexport declare function filterWithIndex<K, A>(p: (k: K, a: A) => boolean): (m: Map<K, A>) => Map<K, A>\n```\n\n----------------------------------------\n\nTITLE: Implementing Option Guard Function - TypeScript\nDESCRIPTION: Function that converts a boolean condition into an Option<void>.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Option.ts.md#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const guard: (b: boolean) => Option<void>\n```\n\n----------------------------------------\n\nTITLE: Sorting ReadonlyNonEmptyArray with Ord in TypeScript\nDESCRIPTION: Function that sorts the elements of a ReadonlyNonEmptyArray using the provided Ord instance for comparison, creating a new non-empty array with the sorted elements.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReadonlyNonEmptyArray.ts.md#2025-04-23_snippet_58\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const sort: <B>(O: Ord<B>) => <A extends B>(as: ReadonlyNonEmptyArray<A>) => ReadonlyNonEmptyArray<A>\n```\n\n----------------------------------------\n\nTITLE: Task Composition Example with tapTask\nDESCRIPTION: Demonstrates the usage of tapTask function for sequential computation with a practical example using ReaderTaskEither and Task types.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReaderTaskEither.ts.md#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as RTE from 'fp-ts/ReaderTaskEither'\nimport * as E from 'fp-ts/Either'\nimport * as T from 'fp-ts/Task'\n\nconst effect = RTE.tapTask(RTE.ask<number>(), (value) => T.of(value + 1))\n\nasync function test() {\n  assert.deepStrictEqual(await effect(1)(), E.of(1))\n}\n\ntest()\n```\n\n----------------------------------------\n\nTITLE: Using Predicate Check for All Elements in ReadonlyArray in TypeScript\nDESCRIPTION: Demonstrates how to use the every function to check if all elements in a ReadonlyArray satisfy a condition.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReadonlyArray.ts.md#2025-04-23_snippet_25\n\nLANGUAGE: typescript\nCODE:\n```\nimport { every } from 'fp-ts/ReadonlyArray'\nimport { pipe } from 'fp-ts/function'\n\nconst isPositive = (n: number): boolean => n > 0\n\nassert.deepStrictEqual(pipe([1, 2, 3], every(isPositive)), true)\nassert.deepStrictEqual(pipe([1, 2, -3], every(isPositive)), false)\n```\n\n----------------------------------------\n\nTITLE: Reader Monad Type Definition in TypeScript\nDESCRIPTION: Type definition for the Reader monad interface representing a computation that can read from an environment R and produce a value of type A.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Reader.ts.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface Reader<R, A> {\n  (r: R): A\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing fromTaskK Utility Function in TypeScript\nDESCRIPTION: Defines the fromTaskK function for lifting Task-returning functions to various monad types. It handles different URIS and arity, providing a way to convert Task-based functions to functions in other monads.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/FromTask.ts.md#2025-04-23_snippet_3\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare function fromTaskK<F extends URIS4>(\n  F: FromTask4<F>\n): <A extends ReadonlyArray<unknown>, B>(f: (...a: A) => Task<B>) => <S, R, E>(...a: A) => Kind4<F, S, R, E, B>\nexport declare function fromTaskK<F extends URIS3>(\n  F: FromTask3<F>\n): <A extends ReadonlyArray<unknown>, B>(f: (...a: A) => Task<B>) => <R, E>(...a: A) => Kind3<F, R, E, B>\nexport declare function fromTaskK<F extends URIS3, E>(\n  F: FromTask3C<F, E>\n): <A extends ReadonlyArray<unknown>, B>(f: (...a: A) => Task<B>) => <R>(...a: A) => Kind3<F, R, E, B>\nexport declare function fromTaskK<F extends URIS2>(\n  F: FromTask2<F>\n): <A extends ReadonlyArray<unknown>, B>(f: (...a: A) => Task<B>) => <E>(...a: A) => Kind2<F, E, B>\nexport declare function fromTaskK<F extends URIS2, E>(\n  F: FromTask2C<F, E>\n): <A extends ReadonlyArray<unknown>, B>(f: (...a: A) => Task<B>) => (...a: A) => Kind2<F, E, B>\nexport declare function fromTaskK<F extends URIS>(\n  F: FromTask1<F>\n): <A extends ReadonlyArray<unknown>, B>(f: (...a: A) => Task<B>) => (...a: A) => Kind<F, B>\nexport declare function fromTaskK<F>(\n  F: FromTask<F>\n): <A extends ReadonlyArray<unknown>, B>(f: (...a: A) => Task<B>) => (...a: A) => HKT<F, B>\n```\n\n----------------------------------------\n\nTITLE: Traversing Array Sequentially (TypeScript)\nDESCRIPTION: Function to traverse an Array sequentially using ApplicativeSeq. It takes a function that maps an element to a Task, and returns a function that takes a ReadonlyArray and returns a Task of ReadonlyArray.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Task.ts.md#2025-04-23_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const traverseSeqArray: <A, B>(f: (a: A) => Task<B>) => (as: readonly A[]) => Task<readonly B[]>\n```\n\n----------------------------------------\n\nTITLE: Example of Using toReadonlyArray with Trees in TypeScript\nDESCRIPTION: Example showing how to convert a tree structure to a flat readonly array using the toReadonlyArray function.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Foldable.ts.md#2025-04-23_snippet_15\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { toReadonlyArray } from 'fp-ts/Foldable'\nimport { Foldable, make } from 'fp-ts/Tree'\n\nconst t = make(1, [make(2, []), make(3, []), make(4, [])])\nassert.deepStrictEqual(toReadonlyArray(Foldable)(t), [1, 2, 3, 4])\n```\n\n----------------------------------------\n\nTITLE: Defining Base Compactable Interface\nDESCRIPTION: Core interface definition for the Compactable typeclass, specifying compact and separate operations on a generic type F.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Compactable.ts.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface Compactable<F> {\n  readonly URI: F\n  /**\n   * Compacts a data structure unwrapping inner Option\n   */\n  readonly compact: <A>(fa: HKT<F, Option<A>>) => HKT<F, A>\n  /**\n   * Separates a data structure moving inner Left to the left side and inner Right to the right side of Separated\n   */\n  readonly separate: <A, B>(fa: HKT<F, Either<A, B>>) => S.Separated<HKT<F, A>, HKT<F, B>>\n}\n```\n\n----------------------------------------\n\nTITLE: Reversing ReadonlyNonEmptyArray in TypeScript\nDESCRIPTION: Function that reverses the order of elements in a ReadonlyNonEmptyArray, creating a new non-empty array with the elements in reverse order.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReadonlyNonEmptyArray.ts.md#2025-04-23_snippet_56\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const reverse: <A>(as: ReadonlyNonEmptyArray<A>) => ReadonlyNonEmptyArray<A>\n```\n\n----------------------------------------\n\nTITLE: Implementing Pipeable Bimap Operator in TypeScript\nDESCRIPTION: Provides a pipeable version of bimap for mapping over both type parameters of a bifunctor simultaneously.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/pipeable.ts.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare function bimap<F extends URIS4>(\n  F: Bifunctor4<F>\n): <E, G, A, B>(f: (e: E) => G, g: (a: A) => B) => <S, R>(fea: Kind4<F, S, R, E, A>) => Kind4<F, S, R, G, B>\n```\n\n----------------------------------------\n\nTITLE: Creating Traversable Instance for Records in TypeScript\nDESCRIPTION: Produces a Traversable instance for a Record, using the provided Ord to sort the Record's entries by key. Traversable allows for iteration over a structure, applying an effect to each element and collecting the results.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Record.ts.md#2025-04-23_snippet_20\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const getTraversable: (O: Ord<string>) => Traversable1<URI>\n```\n\n----------------------------------------\n\nTITLE: Contramap Function for Ord in TypeScript\nDESCRIPTION: Creates a new Ord by transforming the input type using a mapping function. This is useful for deriving orderings for complex types.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Ord.ts.md#2025-04-23_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const contramap: <A, B>(f: (b: B) => A) => (fa: Ord<A>) => Ord<B>\n```\n\n----------------------------------------\n\nTITLE: Implementing fanOut Utility Function\nDESCRIPTION: This function composes a value which introduces a tuple from two values, each introducing one side of the tuple. It's useful for assembling values from smaller components and supporting different types of output.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Strong.ts.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare function fanOut<F extends URIS4>(\n  S: Strong4<F>,\n  C: Category4<F>\n): <S, R, A, B, C>(pab: Kind4<F, S, R, A, B>, pac: Kind4<F, S, R, A, C>) => Kind4<F, S, R, A, [B, C]>\n```\n\n----------------------------------------\n\nTITLE: Implementing State Utility Functions in TypeScript\nDESCRIPTION: Defines utility functions for the State monad, including evaluate, execute, ap, apFirst, apSecond, and bind.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/State.ts.md#2025-04-23_snippet_4\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare const evaluate: <S>(s: S) => <A>(ma: State<S, A>) => A\n\nexport declare const execute: <S>(s: S) => <A>(ma: State<S, A>) => S\n\nexport declare const ap: <E, A>(fa: State<E, A>) => <B>(fab: State<E, (a: A) => B>) => State<E, B>\n\nexport declare const apFirst: <E, B>(second: State<E, B>) => <A>(first: State<E, A>) => State<E, A>\n\nexport declare const apSecond: <E, B>(second: State<E, B>) => <A>(first: State<E, A>) => State<E, B>\n\nexport declare const bind: <N, A, E, B>(\n  name: Exclude<N, keyof A>,\n  f: (a: A) => State<E, B>\n) => (ma: State<E, A>) => State<E, { readonly [K in N | keyof A]: K extends keyof A ? A[K] : B }>\n```\n\n----------------------------------------\n\nTITLE: Converting Data Types from PureScript to TypeScript\nDESCRIPTION: Demonstrates how to convert PureScript's algebraic data types to TypeScript using interfaces and union types.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/guides/purescript.md#2025-04-23_snippet_1\n\nLANGUAGE: purescript\nCODE:\n```\ndata Foo = Bar String | Baz Boolean\n```\n\nLANGUAGE: typescript\nCODE:\n```\ninterface Bar {\n  readonly _tag: 'Bar'\n  readonly value: string\n}\n\ninterface Baz {\n  readonly _tag: 'Baz'\n  readonly value: boolean\n}\n\n// type\ntype Foo = Bar | Baz\n\n// constructors\nconst Bar = (value: string): Foo => ({ _tag: 'Bar', value })\n\nconst Baz = (value: boolean): Foo => ({ _tag: 'Baz', value })\n```\n\n----------------------------------------\n\nTITLE: Removing Duplicates from ReadonlyArray in TypeScript\nDESCRIPTION: Removes duplicates from a readonly array, keeping the first occurrence of an element. It uses an Eq instance for equality comparisons.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReadonlyArray.ts.md#2025-04-23_snippet_65\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const uniq: <A>(E: Eq<A>) => (as: readonly A[]) => readonly A[]\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport { uniq } from 'fp-ts/ReadonlyArray'\nimport * as N from 'fp-ts/number'\n\nassert.deepStrictEqual(uniq(N.Eq)([1, 2, 1]), [1, 2])\n```\n\n----------------------------------------\n\nTITLE: Alternative Base Interface Definition\nDESCRIPTION: Defines the base Alternative interface that extends Applicative, Alt, and Zero type classes.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Alternative.ts.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface Alternative<F> extends Applicative<F>, Alt<F>, Zero<F> {}\n```\n\n----------------------------------------\n\nTITLE: Error Mapping Example in TypeScript\nDESCRIPTION: Example showing how to map the error channel of an IOEither using mapError function.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/IOEither.ts.md#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as IOEither from 'fp-ts/IOEither'\nimport * as Either from 'fp-ts/Either'\n\nconst f = (s: string) => new Error(s)\n\nassert.deepStrictEqual(IOEither.mapError(IOEither.right(1), f)(), Either.right(1))\nassert.deepStrictEqual(IOEither.mapError(IOEither.left('err'), f)(), Either.left(new Error('err')))\n```\n\n----------------------------------------\n\nTITLE: Implementing Monoid Instance for String Concatenation in TypeScript\nDESCRIPTION: Defines a Monoid instance for string concatenation. The empty value is an empty string, and concat operation joins strings.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/string.ts.md#2025-04-23_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare const Monoid: M.Monoid<string>\n```\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport * as S from 'fp-ts/string'\n\nassert.deepStrictEqual(S.Monoid.concat('a', 'b'), 'ab')\nassert.deepStrictEqual(S.Monoid.concat('a', S.Monoid.empty), 'a')\n```\n\n----------------------------------------\n\nTITLE: Implementing getEq for ReadonlyNonEmptyArray in TypeScript\nDESCRIPTION: Creates an Eq instance for ReadonlyNonEmptyArray given an Eq instance for its elements.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReadonlyNonEmptyArray.ts.md#2025-04-23_snippet_14\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const getEq: <A>(E: Eq<A>) => Eq<ReadonlyNonEmptyArray<A>>\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport { getEq } from 'fp-ts/ReadonlyNonEmptyArray'\nimport * as N from 'fp-ts/number'\n\nconst E = getEq(N.Eq)\nassert.strictEqual(E.equals([1, 2], [1, 2]), true)\nassert.strictEqual(E.equals([1, 2], [1, 3]), false)\n```\n\n----------------------------------------\n\nTITLE: Implementing getRaceMonoid for Task in TypeScript\nDESCRIPTION: Implements a function that returns a Monoid for Task, which races multiple tasks and returns the first completed one. It uses Promise.race internally and includes an example of usage.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Task.ts.md#2025-04-23_snippet_3\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare function getRaceMonoid<A = never>(): Monoid<Task<A>>\n\n// Example usage\nimport * as T from 'fp-ts/Task'\n\nasync function test() {\n  const S = T.getRaceMonoid<string>()\n  const fa = T.delay(20)(T.of('a'))\n  const fb = T.delay(10)(T.of('b'))\n  assert.deepStrictEqual(await S.concat(fa, fb)(), 'b')\n}\n\ntest()\n```\n\n----------------------------------------\n\nTITLE: Creating a Semigroup for Ord in TypeScript\nDESCRIPTION: Returns a Semigroup for Ord that allows merging multiple orderings. This is useful for building complex sorting logic with multiple criteria.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Ord.ts.md#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const getSemigroup: <A = never>() => Semigroup<Ord<A>>\n```\n\n----------------------------------------\n\nTITLE: Functor Interface Implementation in TypeScript\nDESCRIPTION: Core Functor interface definition that specifies the map operation for transforming values in a context F. Requires implementation of URI and map function.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Functor.ts.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface Functor<F> {\n  readonly URI: F\n  readonly map: <A, B>(fa: HKT<F, A>, f: (a: A) => B) => HKT<F, B>\n}\n```\n\n----------------------------------------\n\nTITLE: Using Applicative Style in TypeScript\nDESCRIPTION: Demonstrates how to use applicative functors in TypeScript with fp-ts using pipe and Task monad.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/guides/purescript.md#2025-04-23_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as T from 'fp-ts/Task'\nimport { pipe } from 'fp-ts/function'\n\ndeclare const fa: T.Task<number>\ndeclare const fb: T.Task<string>\ndeclare const f: (a: number) => (b: string) => boolean\n\nconst result1 = pipe(fa, T.map(f), T.ap(fb))\n\n// ..or..\nconst result2 = pipe(T.of(f), T.ap(fa), T.ap(fb))\n```\n\n----------------------------------------\n\nTITLE: Implementing Random Integer Generator in TypeScript\nDESCRIPTION: Function that generates a random integer within a specified closed interval [low, high]. Returns an IO monad containing the generated number.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Random.ts.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare function randomInt(low: number, high: number): IO<number>\n```\n\n----------------------------------------\n\nTITLE: Using Kleisli Arrows with fromEitherK and chainEitherK\nDESCRIPTION: Shows how to transform a function returning Either into a function that works with IOEither using Kleisli arrow transformations. The 'K' suffix indicates Kleisli operations.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/guides/code-conventions.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as E from 'fp-ts/Either'\n\nfunction parse(s: string): E.Either<Error, number> {\n  const n = parseFloat(s)\n  return isNaN(n) ? E.left(new Error(`cannot decode ${JSON.stringify(s)} to number`)) : E.right(n)\n}\n```\n\n----------------------------------------\n\nTITLE: Defining the These Data Structure in TypeScript\nDESCRIPTION: Defines the These<E, A> type alias and the Both interface, representing the core data structure of the module.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/These.ts.md#2025-04-23_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport interface Both<E, A> {\n  readonly _tag: 'Both'\n  readonly left: E\n  readonly right: A\n}\n\nexport type These<E, A> = Left<E> | Right<A> | Both<E, A>\n```\n\n----------------------------------------\n\nTITLE: Ring Interface Definition in TypeScript\nDESCRIPTION: Defines the Ring interface that extends Semiring to add subtraction support. Ring instances must satisfy the additive inverse law.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Ring.ts.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface Ring<A> extends Semiring<A> {\n  readonly sub: (x: A, y: A) => A\n}\n```\n\n----------------------------------------\n\nTITLE: Defining bimap Function for These in TypeScript\nDESCRIPTION: Implements a bimap function for the These type, allowing mapping over both the left and right values simultaneously.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/These.ts.md#2025-04-23_snippet_7\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare const bimap: <E, G, A, B>(f: (e: E) => G, g: (a: A) => B) => (fa: These<E, A>) => These<G, B>\n```\n\n----------------------------------------\n\nTITLE: Overloaded Lift Function Implementation\nDESCRIPTION: An improved implementation of the lift function with overloads to support different kinds of functors (URIS, URIS2). This allows the function to work with both Identity and Either.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/guides/HKT.md#2025-04-23_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nexport function lift<F extends URIS2>(\n  F: Functor2<F>\n): <A, B>(f: (a: A) => B) => <E>(fa: Kind2<F, E, A>) => Kind2<F, E, B>\nexport function lift<F extends URIS>(F: Functor1<F>): <A, B>(f: (a: A) => B) => (fa: Kind<F, A>) => Kind<F, B>\nexport function lift<F>(F: Functor<F>): <A, B>(f: (a: A) => B) => (fa: HKT<F, A>) => HKT<F, B>\nexport function lift<F>(F: Functor<F>): <A, B>(f: (a: A) => B) => (fa: HKT<F, A>) => HKT<F, B> {\n  return (f) => (fa) => F.map(fa, f)\n}\n```\n\n----------------------------------------\n\nTITLE: Type Class Instances for Maps in TypeScript\nDESCRIPTION: Type class instances implementing various functional programming patterns for Map including Compactable, Filterable, Functor, and various methods to get Eq, Monoid, Semigroup, and Show instances.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Map.ts.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const Compactable: Compactable2<'Map'>\n```\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const Filterable: Filterable2<'Map'>\n```\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const Functor: Functor2<'Map'>\n```\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const getDifferenceMagma: <K>(E: Eq<K>) => <A>() => Magma<Map<K, A>>\n```\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const getEq: <K, A>(SK: Eq<K>, SA: Eq<A>) => Eq<Map<K, A>>\n```\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const getIntersectionSemigroup: <K, A>(E: Eq<K>, S: Semigroup<A>) => Semigroup<Map<K, A>>\n```\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare function getMonoid<K, A>(SK: Eq<K>, SA: Semigroup<A>): Monoid<Map<K, A>>\n```\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const getShow: <K, A>(SK: Show<K>, SA: Show<A>) => Show<Map<K, A>>\n```\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const getUnionMonoid: <K, A>(E: Eq<K>, S: Semigroup<A>) => Monoid<Map<K, A>>\n```\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const getUnionSemigroup: <K, A>(E: Eq<K>, S: Semigroup<A>) => Semigroup<Map<K, A>>\n```\n\n----------------------------------------\n\nTITLE: Implementing Alt1 Interface for URIS Types\nDESCRIPTION: Type-specific Alt interface for types with kind * -> *. Extends Functor1 and includes an alt operation working with Kind<F, A> types.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Alt.ts.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface Alt1<F extends URIS> extends Functor1<F> {\n  readonly alt: <A>(fa: Kind<F, A>, that: LazyArg<Kind<F, A>>) => Kind<F, A>\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing sequence for ReadonlyNonEmptyArray in TypeScript\nDESCRIPTION: Sequences a ReadonlyNonEmptyArray of effects into an effect of ReadonlyNonEmptyArray.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReadonlyNonEmptyArray.ts.md#2025-04-23_snippet_29\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const sequence: Sequence1<'ReadonlyNonEmptyArray'>\n```\n\n----------------------------------------\n\nTITLE: Defining Apply instance for Either in TypeScript\nDESCRIPTION: Declares the Apply type class instance for Either.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Either.ts.md#2025-04-23_snippet_23\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare const Apply: Apply2<'Either'>\n```\n\n----------------------------------------\n\nTITLE: Taking Left Elements from ReadonlyArray in TypeScript\nDESCRIPTION: Keeps a maximum number of elements from the start of a readonly array, creating a new array. The number is normalized to a non-negative integer.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReadonlyArray.ts.md#2025-04-23_snippet_60\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const takeLeft: (n: number) => <A>(as: readonly A[]) => readonly A[]\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as RA from 'fp-ts/ReadonlyArray'\nimport { pipe } from 'fp-ts/function'\n\nconst input: ReadonlyArray<number> = [1, 2, 3]\nassert.deepStrictEqual(pipe(input, RA.takeLeft(2)), [1, 2])\n\n// out of bounds\nassert.strictEqual(pipe(input, RA.takeLeft(4)), input)\nassert.strictEqual(pipe(input, RA.takeLeft(-1)), input)\n```\n\n----------------------------------------\n\nTITLE: Maximum Function for Ord in TypeScript\nDESCRIPTION: Creates a function to find the maximum of two values according to an Ord instance. If the values are equal, the first argument is chosen.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Ord.ts.md#2025-04-23_snippet_19\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const max: <A>(O: Ord<A>) => (first: A, second: A) => A\n```\n\n----------------------------------------\n\nTITLE: Traversing ReadonlyArray with Index in Parallel (TypeScript)\nDESCRIPTION: Function to traverse a ReadonlyArray with index using ApplicativePar. It takes a function that maps an index and element to a Task, and returns a function that takes a ReadonlyArray and returns a Task of ReadonlyArray.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Task.ts.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const traverseReadonlyArrayWithIndex: <A, B>(\n  f: (index: number, a: A) => Task<B>\n) => (as: readonly A[]) => Task<readonly B[]>\n```\n\n----------------------------------------\n\nTITLE: Defining FilterableWithIndex Interface in TypeScript\nDESCRIPTION: Defines the FilterableWithIndex interface that extends FunctorWithIndex and Filterable. It includes methods for partitioning, filtering, and mapping with index.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/FilterableWithIndex.ts.md#2025-04-23_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport interface FilterableWithIndex<F, I> extends FunctorWithIndex<F, I>, Filterable<F> {\n  readonly partitionMapWithIndex: <A, B, C>(\n    fa: HKT<F, A>,\n    f: (i: I, a: A) => Either<B, C>\n  ) => Separated<HKT<F, B>, HKT<F, C>>\n  readonly partitionWithIndex: PartitionWithIndex<F, I>\n  readonly filterMapWithIndex: <A, B>(fa: HKT<F, A>, f: (i: I, a: A) => Option<B>) => HKT<F, B>\n  readonly filterWithIndex: FilterWithIndex<F, I>\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing tailRec Utility Function for Stack-safe Recursion in TypeScript\nDESCRIPTION: Defines the tailRec utility function for performing stack-safe recursion. It takes an initial value and a function that returns Either<A, B> to continue or complete the recursion.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ChainRec.ts.md#2025-04-23_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const tailRec: <A, B>(startWith: A, f: (a: A) => Either<A, B>) => B\n```\n\n----------------------------------------\n\nTITLE: Checking if Index is Out of Bounds in Array with fp-ts\nDESCRIPTION: Tests whether an array contains a particular index. Returns true if the index is out of bounds, false otherwise.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReadonlyArray.ts.md#2025-04-23_snippet_40\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const isOutOfBound: <A>(i: number, as: readonly A[]) => boolean\n```\n\n----------------------------------------\n\nTITLE: Implementing flatten Function for Nested TaskEither Structures in TypeScript\nDESCRIPTION: Flattens a nested TaskEither structure by combining the inner and outer TaskEither into a single TaskEither while preserving the error type.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/TaskEither.ts.md#2025-04-23_snippet_74\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const flatten: <E, A>(mma: TaskEither<E, TaskEither<E, A>>) => TaskEither<E, A>\n```\n\n----------------------------------------\n\nTITLE: Implementing Do Notation for IO in TypeScript\nDESCRIPTION: Implements various functions for do notation with IO, including Do, apS, bind, bindTo, and let.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/IO.ts.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const Do: IO<{}>\n\nexport declare const apS: <N, A, B>(\n  name: Exclude<N, keyof A>,\n  fb: IO<B>\n) => (fa: IO<A>) => IO<{ readonly [K in N | keyof A]: K extends keyof A ? A[K] : B }>\n\nexport declare const bind: <N, A, B>(\n  name: Exclude<N, keyof A>,\n  f: (a: A) => IO<B>\n) => (ma: IO<A>) => IO<{ readonly [K in N | keyof A]: K extends keyof A ? A[K] : B }>\n\nexport declare const bindTo: <N>(name: N) => <A>(fa: IO<A>) => IO<{ readonly [K in N]: A }>\n\nexport declare const let: <N, A, B>(\n  name: Exclude<N, keyof A>,\n  f: (a: A) => B\n) => (fa: IO<A>) => IO<{ readonly [K in N | keyof A]: K extends keyof A ? A[K] : B }>\n```\n\n----------------------------------------\n\nTITLE: Map Intersection Operation in TypeScript\nDESCRIPTION: Function to compute intersection of two maps based on key equality and value combination using a Magma instance.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Map.ts.md#2025-04-23_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const intersection: <K, A>(\n  E: Eq<K>,\n  M: Magma<A>\n) => (second: Map<K, A>) => (first: Map<K, A>) => Map<K, A>\n```\n\n----------------------------------------\n\nTITLE: Implementing matchE for Effectful Pattern Matching\nDESCRIPTION: Pattern matches on Either structure using effectful functions, transforming both success and error values to a common type with ReaderTask effects.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReaderTaskEither.ts.md#2025-04-23_snippet_81\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const matchE: <R, E, A, B>(\n  onLeft: (e: E) => RT.ReaderTask<R, B>,\n  onRight: (a: A) => RT.ReaderTask<R, B>\n) => (ma: ReaderTaskEither<R, E, A>) => RT.ReaderTask<R, B>\n```\n\n----------------------------------------\n\nTITLE: Struct Show Implementation in TypeScript\nDESCRIPTION: Creates a Show instance for struct-like objects by combining Show instances for each field.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Show.ts.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const struct: <A>(shows: { [K in keyof A]: Show<A[K]> }) => Show<{ readonly [K in keyof A]: A[K] }>\n```\n\n----------------------------------------\n\nTITLE: Map Subset Check Operation\nDESCRIPTION: Function to test if one Map contains all keys and values of another Map using equality comparators.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Map.ts.md#2025-04-23_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const isSubmap: <K, A>(\n  SK: Eq<K>,\n  SA: Eq<A>\n) => { (that: Map<K, A>): (me: Map<K, A>) => boolean; (me: Map<K, A>, that: Map<K, A>): boolean }\n```\n\n----------------------------------------\n\nTITLE: Implementing flatMapNullable for Either Type\nDESCRIPTION: Function to handle nullable values in Either context with error handling\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Either.ts.md#2025-04-23_snippet_28\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const flatMapNullable: {\n  <A, B, E2>(f: (a: A) => B | null | undefined, onNullable: (a: A) => E2): <E1>(\n    self: Either<E1, A>\n  ) => Either<E2 | E1, NonNullable<B>>\n  <E1, A, B, E2>(self: Either<E1, A>, f: (a: A) => B | null | undefined, onNullable: (a: A) => E2): Either<\n    E1 | E2,\n    NonNullable<B>\n  >\n}\n```\n\n----------------------------------------\n\nTITLE: Inserting Element at Index in Array with fp-ts\nDESCRIPTION: Inserts an element at a specified index in an array, creating a new array. Returns Some containing the new array if the index is valid, or None if the index is out of bounds.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReadonlyArray.ts.md#2025-04-23_snippet_36\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const insertAt: <A>(i: number, a: A) => (as: readonly A[]) => Option<RNEA.ReadonlyNonEmptyArray<A>>\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport { insertAt } from 'fp-ts/ReadonlyArray'\nimport { some } from 'fp-ts/Option'\n\nassert.deepStrictEqual(insertAt(2, 5)([1, 2, 3, 4]), some([1, 2, 5, 3, 4]))\n```\n\n----------------------------------------\n\nTITLE: Using SequenceT with Option in TypeScript\nDESCRIPTION: Example demonstrating how to use sequenceT with Option to combine multiple Option values into a tuple within an Option.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Apply.ts.md#2025-04-23_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\nimport { sequenceT } from 'fp-ts/Apply'\nimport * as O from 'fp-ts/Option'\n\nconst sequenceTOption = sequenceT(O.Apply)\nassert.deepStrictEqual(sequenceTOption(O.some(1)), O.some([1]))\nassert.deepStrictEqual(sequenceTOption(O.some(1), O.some('2')), O.some([1, '2']))\nassert.deepStrictEqual(sequenceTOption(O.some(1), O.some('2'), O.none), O.none)\n```\n\n----------------------------------------\n\nTITLE: Zipping NonEmptyArrays in TypeScript\nDESCRIPTION: Combines two NonEmptyArrays element-wise into a single NonEmptyArray of tuples. The resulting array has the length of the shorter input array.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/NonEmptyArray.ts.md#2025-04-23_snippet_28\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare function zip<B>(bs: NonEmptyArray<B>): <A>(as: NonEmptyArray<A>) => NonEmptyArray<[A, B]>\nexport declare function zip<A, B>(as: NonEmptyArray<A>, bs: NonEmptyArray<B>): NonEmptyArray<[A, B]>\n```\n\n----------------------------------------\n\nTITLE: Zipping ReadonlyArrays in TypeScript\nDESCRIPTION: Takes two readonly arrays and returns an array of corresponding pairs. If one input array is short, excess elements of the longer array are discarded.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReadonlyArray.ts.md#2025-04-23_snippet_69\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare function zip<B>(bs: ReadonlyArray<B>): <A>(as: ReadonlyArray<A>) => ReadonlyArray<readonly [A, B]>\nexport declare function zip<A, B>(as: ReadonlyArray<A>, bs: ReadonlyArray<B>): ReadonlyArray<readonly [A, B]>\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport { zip } from 'fp-ts/ReadonlyArray'\nimport { pipe } from 'fp-ts/function'\n\nassert.deepStrictEqual(pipe([1, 2, 3], zip(['a', 'b', 'c', 'd'])), [\n  [1, 'a'],\n  [2, 'b'],\n  [3, 'c'],\n])\n```\n\n----------------------------------------\n\nTITLE: Implementing Eq Instance for String in TypeScript\nDESCRIPTION: Defines an Eq instance for string comparisons. It provides an equals method to check string equality.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/string.ts.md#2025-04-23_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare const Eq: E.Eq<string>\n```\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport * as S from 'fp-ts/string'\n\nassert.deepStrictEqual(S.Eq.equals('a', 'a'), true)\nassert.deepStrictEqual(S.Eq.equals('a', 'b'), false)\n```\n\n----------------------------------------\n\nTITLE: Option Type Constructor from Predicate\nDESCRIPTION: Creates a smart constructor that produces Option values based on a predicate function. Returns Some when predicate is true and None otherwise.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Option.ts.md#2025-04-23_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nimport { none, some, fromPredicate } from 'fp-ts/Option'\n\nconst getOption = fromPredicate((n: number) => n >= 0)\n\nassert.deepStrictEqual(getOption(-1), none)\nassert.deepStrictEqual(getOption(1), some(1))\n```\n\n----------------------------------------\n\nTITLE: Traverse Example with Array Foldable\nDESCRIPTION: Example showing how to use traverse_ with an Array Foldable and IO Applicative to perform side effects.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Foldable.ts.md#2025-04-23_snippet_17\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Foldable } from 'fp-ts/Array'\nimport { traverse_ } from 'fp-ts/Foldable'\nimport { Applicative } from 'fp-ts/IO'\n\nlet log = ''\nconst append = (s: string) => () => (log += s)\ntraverse_(Applicative, Foldable)(['a', 'b', 'c'], append)()\nassert.strictEqual(log, 'abc')\n```\n\n----------------------------------------\n\nTITLE: Creating Integer Ranges with NonEmptyArray\nDESCRIPTION: Function to create a NonEmptyArray containing a range of integers from start to end, inclusive of both endpoints.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/NonEmptyArray.ts.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { range } from 'fp-ts/NonEmptyArray'\n\nassert.deepStrictEqual(range(1, 5), [1, 2, 3, 4, 5])\n```\n\n----------------------------------------\n\nTITLE: Defining ReadonlyNonEmptyArray Type in TypeScript\nDESCRIPTION: Core type definition for ReadonlyNonEmptyArray that extends ReadonlyArray to ensure at least one element exists at index 0.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReadonlyNonEmptyArray.ts.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport type ReadonlyNonEmptyArray<A> = ReadonlyArray<A> & {\n  readonly 0: A\n}\n```\n\n----------------------------------------\n\nTITLE: Option Chaining Example with fp-ts 2.x (New)\nDESCRIPTION: Example of the new API in fp-ts 2.x using pipe with Option. Demonstrates the same operations (map, chain, filter, fold) but with the functional pipe approach.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/guides/upgrade-to-v2.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as O from 'fp-ts/Option'\nimport { pipe } from 'fp-ts/pipeable'\n\npipe(\n  O.some(1),\n  O.map((n) => n * 2),\n  O.chain((n) => (n === 0 ? O.none : O.some(1 / n))),\n  O.filter((n) => n > 1),\n  O.fold(\n    () => 'ko',\n    () => 'ok'\n  )\n)\n```\n\n----------------------------------------\n\nTITLE: Task Utility Functions (TypeScript)\nDESCRIPTION: Various utility functions for working with Tasks, including ApT (empty Task), ap (apply), apFirst, apSecond, delay, and never.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Task.ts.md#2025-04-23_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const ApT: Task<readonly []>\nexport declare const ap: <A>(fa: Task<A>) => <B>(fab: Task<(a: A) => B>) => Task<B>\nexport declare const apFirst: <B>(second: Task<B>) => <A>(first: Task<A>) => Task<A>\nexport declare const apSecond: <B>(second: Task<B>) => <A>(first: Task<A>) => Task<B>\nexport declare function delay(millis: number): <A>(ma: Task<A>) => Task<A>\nexport declare const never: Task<never>\n```\n\n----------------------------------------\n\nTITLE: Defining Store Interface in TypeScript\nDESCRIPTION: Defines the Store interface with two properties: peek function and pos value. Store represents a value along with a way to extract values from related positions.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Store.ts.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface Store<S, A> {\n  readonly peek: (s: S) => A\n  readonly pos: S\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Alt instance with custom error handling for Either in TypeScript\nDESCRIPTION: Defines a function to create an Alt instance that concatenates all errors using a provided Semigroup.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Either.ts.md#2025-04-23_snippet_6\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare const getAltValidation: <E>(SE: Semigroup<E>) => Alt2C<'Either', E>\n```\n\n----------------------------------------\n\nTITLE: Extracting Right Values from Array of Either with fp-ts\nDESCRIPTION: Extracts from an array of Either all the Right elements in order. Useful for collecting successful values from a collection of operations that may have failed.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReadonlyArray.ts.md#2025-04-23_snippet_49\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const rights: <E, A>(as: readonly Either<E, A>[]) => readonly A[]\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport { rights } from 'fp-ts/ReadonlyArray'\nimport { right, left } from 'fp-ts/Either'\n\nassert.deepStrictEqual(rights([right(1), left('foo'), right(2)]), [1, 2])\n```\n\n----------------------------------------\n\nTITLE: Implementing fromIOEitherK for Lifting IOEither Functions in TypeScript\nDESCRIPTION: Creates a function that transforms an IOEither-returning function into a TaskEither-returning function, preserving the error and success types.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/TaskEither.ts.md#2025-04-23_snippet_49\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const fromIOEitherK: <E, A extends readonly unknown[], B>(\n  f: (...a: A) => IOEither<E, B>\n) => (...a: A) => TaskEither<E, B>\n```\n\n----------------------------------------\n\nTITLE: Modifying NonEmptyArray Last Element in TypeScript\nDESCRIPTION: Applies a function to the last element of a NonEmptyArray, creating a new NonEmptyArray. It uses an Endomorphism to transform the last element.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/NonEmptyArray.ts.md#2025-04-23_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const modifyLast: <A>(f: Endomorphism<A>) => (as: NonEmptyArray<A>) => NonEmptyArray<A>\n```\n\n----------------------------------------\n\nTITLE: Creating Ord Instance from Compare Function in TypeScript\nDESCRIPTION: Creates an `Ord` instance from a compare function that returns an `Ordering` value. This is a fundamental constructor for the `Ord` type class.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Ord.ts.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const fromCompare: <A>(compare: (first: A, second: A) => Ordering) => Ord<A>\n```\n\n----------------------------------------\n\nTITLE: Array Folding Operations in TypeScript\nDESCRIPTION: Functions for folding and reducing readonly arrays with monoid and index support.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReadonlyArray.ts.md#2025-04-23_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const foldMap: <M>(M: Monoid<M>) => <A>(f: (a: A) => M) => (fa: readonly A[]) => M\n```\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const reduce: <A, B>(b: B, f: (b: B, a: A) => B) => (fa: readonly A[]) => B\n```\n\n----------------------------------------\n\nTITLE: Implementing Ord Instance for String Comparison in TypeScript\nDESCRIPTION: Defines an Ord instance for string ordering. It provides a compare method to determine the relative order of two strings.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/string.ts.md#2025-04-23_snippet_2\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare const Ord: O.Ord<string>\n```\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport * as S from 'fp-ts/string'\n\nassert.deepStrictEqual(S.Ord.compare('a', 'a'), 0)\nassert.deepStrictEqual(S.Ord.compare('a', 'b'), -1)\nassert.deepStrictEqual(S.Ord.compare('b', 'a'), 1)\n```\n\n----------------------------------------\n\nTITLE: Filtering a Record in TypeScript\nDESCRIPTION: Filters a Record based on a predicate function, keeping only entries that satisfy the condition.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Record.ts.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { filter } from 'fp-ts/Record'\n\nassert.deepStrictEqual(filter((s: string) => s.length < 4)({ a: 'foo', b: 'bar', c: 'verylong' }), {\n  a: 'foo',\n  b: 'bar',\n})\n```\n\n----------------------------------------\n\nTITLE: Option Pattern Matching Example\nDESCRIPTION: Demonstrates pattern matching on Option values using match function to handle both Some and None cases with custom logic.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Option.ts.md#2025-04-23_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\nimport { some, none, match } from 'fp-ts/Option'\nimport { pipe } from 'fp-ts/function'\n\nassert.strictEqual(\n  pipe(\n    some(1),\n    match(\n      () => 'a none',\n      (a) => `a some containing ${a}`\n    )\n  ),\n  'a some containing 1'\n)\n\nassert.strictEqual(\n  pipe(\n    none,\n    match(\n      () => 'a none',\n      (a) => `a some containing ${a}`\n    )\n  ),\n  'a none'\n)\n```\n\n----------------------------------------\n\nTITLE: Converting Pattern Matching from PureScript to TypeScript\nDESCRIPTION: Demonstrates pattern matching implementation in TypeScript using switch statements with exhaustiveness checking.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/guides/purescript.md#2025-04-23_snippet_3\n\nLANGUAGE: purescript\nCODE:\n```\nmaybe :: forall a b. b -> (a -> b) -> Option a -> b\nmaybe b _ None = b\nmaybe _ f (Some a) = f a\n```\n\nLANGUAGE: typescript\nCODE:\n```\nconst maybe =\n  <A, B>(onNone: () => B, onSome: (a: A) => B) =>\n  (fa: Option<A>): B => {\n    switch (fa._tag) {\n      case 'None':\n        return onNone()\n      case 'Some':\n        return onSome(fa.value)\n    }\n  }\n```\n\n----------------------------------------\n\nTITLE: Defining Predicate Interface in TypeScript\nDESCRIPTION: Declares the Predicate interface, which represents a function that takes a value of type A and returns a boolean.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Predicate.ts.md#2025-04-23_snippet_4\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport interface Predicate<A> {\n  (a: A): boolean\n}\n```\n\n----------------------------------------\n\nTITLE: Type-Widening Prepend Operation for Arrays with fp-ts\nDESCRIPTION: Less strict version of prepend that allows adding an element of a different type to an array, resulting in a union type. Useful when mixing different types in the same array.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReadonlyArray.ts.md#2025-04-23_snippet_47\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const prependW: <B>(head: B) => <A>(tail: readonly A[]) => RNEA.ReadonlyNonEmptyArray<B | A>\n```\n\n----------------------------------------\n\nTITLE: Defining Group Interface in TypeScript\nDESCRIPTION: Defines the Group interface which extends Monoid and adds an inverse operation. The Group must satisfy the inverse law: concat(inverse(a), a) <-> empty = concat(a, inverse(a)).\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Group.ts.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface Group<A> extends Monoid<A> {\n  readonly inverse: (a: A) => A\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing tap Combinator for Task in TypeScript\nDESCRIPTION: Implements the tap combinator for Task, which composes computations in sequence, using the return value of one computation to determine the next and keeping only the result of the first.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Task.ts.md#2025-04-23_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare const tap: {\n  <A, _>(self: Task<A>, f: (a: A) => Task<_>): Task<A>\n  <A, _>(f: (a: A) => Task<_>): (self: Task<A>) => Task<A>\n}\n```\n\n----------------------------------------\n\nTITLE: Prepending Element to NonEmptyArray in TypeScript\nDESCRIPTION: Prepends an element to every member of a NonEmptyArray, creating a new NonEmptyArray with the element inserted before each existing element.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/NonEmptyArray.ts.md#2025-04-23_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const prependAll: <A>(middle: A) => (as: NonEmptyArray<A>) => NonEmptyArray<A>\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport { prependAll } from 'fp-ts/NonEmptyArray'\n\nassert.deepStrictEqual(prependAll(9)([1, 2, 3, 4]), [9, 1, 9, 2, 9, 3, 9, 4])\n```\n\n----------------------------------------\n\nTITLE: Implementing mapLeft operation for Either in TypeScript\nDESCRIPTION: Defines a function to map over the first type argument of a bifunctor.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Either.ts.md#2025-04-23_snippet_10\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare const mapLeft: <E, G>(f: (e: E) => G) => <A>(fa: Either<E, A>) => Either<G, A>\n```\n\n----------------------------------------\n\nTITLE: Implementing Bifunctor2 Interface in TypeScript\nDESCRIPTION: Defines the Bifunctor2 interface for handling two-parameter type constructors with URIS2. It includes methods for bimap and mapLeft operations using Kind2.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Bifunctor.ts.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface Bifunctor2<F extends URIS2> {\n  readonly URI: F\n  readonly bimap: <E, A, G, B>(fea: Kind2<F, E, A>, f: (e: E) => G, g: (a: A) => B) => Kind2<F, G, B>\n  readonly mapLeft: <E, A, G>(fea: Kind2<F, E, A>, f: (e: E) => G) => Kind2<F, G, A>\n}\n```\n\n----------------------------------------\n\nTITLE: Testing Key Existence in Record\nDESCRIPTION: Tests whether a specific key exists in a Record. The function is implemented as a type refinement, enabling precise typing when the key exists.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Record.ts.md#2025-04-23_snippet_33\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const has: <K extends string>(k: string, r: Record<K, unknown>) => k is K\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport { has } from 'fp-ts/Record'\n\nassert.deepStrictEqual(has('a', { a: 1, b: 2 }), true)\nassert.deepStrictEqual(has('c', { a: 1, b: 2 }), false)\n```\n\n----------------------------------------\n\nTITLE: Basic Pointed Interface Implementation\nDESCRIPTION: Defines the base Pointed interface for functors with a single type parameter. Contains a URI type identifier and an 'of' function that lifts values into the functor context.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Pointed.ts.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface Pointed<F> {\n  readonly URI: F\n  readonly of: <A>(a: A) => HKT<F, A>\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing String Type Refinement in TypeScript\nDESCRIPTION: Defines a refinement function to check if a value is a string. It returns true for string values and false otherwise.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/string.ts.md#2025-04-23_snippet_5\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare const isString: Refinement<unknown, string>\n```\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport * as S from 'fp-ts/string'\n\nassert.deepStrictEqual(S.isString('a'), true)\nassert.deepStrictEqual(S.isString(1), false)\n```\n\n----------------------------------------\n\nTITLE: Implementing fromPredicate for Predicate-Based TaskEither Creation in TypeScript\nDESCRIPTION: Creates a TaskEither from a predicate function, returning a Right with the value if the predicate is true, or a Left with the result of onFalse otherwise.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/TaskEither.ts.md#2025-04-23_snippet_51\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const fromPredicate: {\n  <E, A, B extends A>(refinement: Refinement<A, B>, onFalse: (a: A) => E): (a: A) => TaskEither<E, B>\n  <E, A>(predicate: Predicate<A>, onFalse: (a: A) => E): <B extends A>(b: B) => TaskEither<E, B>\n  <E, A>(predicate: Predicate<A>, onFalse: (a: A) => E): (a: A) => TaskEither<E, A>\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Random Range Generator in TypeScript\nDESCRIPTION: Function that generates a random number between a minimum value (inclusive) and maximum value (exclusive). Returns an IO monad containing the generated number.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Random.ts.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare function randomRange(min: number, max: number): IO<number>\n```\n\n----------------------------------------\n\nTITLE: Implementing map Function for Value Transformation in TypeScript\nDESCRIPTION: Transforms the Right value of a TaskEither using the provided function, preserving the error type if present.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/TaskEither.ts.md#2025-04-23_snippet_59\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const map: <A, B>(f: (a: A) => B) => <E>(fa: TaskEither<E, A>) => TaskEither<E, B>\n```\n\n----------------------------------------\n\nTITLE: Using Filtering with Effects in ReadonlyArray in TypeScript\nDESCRIPTION: Demonstrates how to use the filterE function to filter elements of a ReadonlyArray using an asynchronous predicate.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReadonlyArray.ts.md#2025-04-23_snippet_29\n\nLANGUAGE: typescript\nCODE:\n```\nimport { pipe } from 'fp-ts/function'\nimport * as RA from 'fp-ts/ReadonlyArray'\nimport * as T from 'fp-ts/Task'\n\nconst filterE = RA.filterE(T.ApplicativePar)\nasync function test() {\n  assert.deepStrictEqual(\n    await pipe(\n      [-1, 2, 3],\n      filterE((n) => T.of(n > 0))\n    )(),\n    [2, 3]\n  )\n}\ntest()\n```\n\n----------------------------------------\n\nTITLE: ConcatAll Utility Usage Example\nDESCRIPTION: Example demonstrating how to use concatAll to combine multiple values using a monoid.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Monoid.ts.md#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport { concatAll } from 'fp-ts/Monoid'\nimport * as N from 'fp-ts/number'\n\nassert.deepStrictEqual(concatAll(N.MonoidSum)([1, 2, 3]), 6)\nassert.deepStrictEqual(concatAll(N.MonoidSum)([]), 0)\n```\n\n----------------------------------------\n\nTITLE: Map Value Modification\nDESCRIPTION: Function to modify a value at a specific key in a Map.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Map.ts.md#2025-04-23_snippet_15\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const modifyAt: <K>(E: Eq<K>) => <A>(k: K, f: (a: A) => A) => (m: Map<K, A>) => O.Option<Map<K, A>>\n```\n\n----------------------------------------\n\nTITLE: ReaderTask Interface Definition\nDESCRIPTION: Core interface definition for ReaderTask that represents a computation which takes an environment R and returns a Task of A.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReaderTask.ts.md#2025-04-23_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface ReaderTask<R, A> {\n  (r: R): Task<A>\n}\n```\n\n----------------------------------------\n\nTITLE: Creating FunctorWithIndex Instance for Record in TypeScript\nDESCRIPTION: Defines a FunctorWithIndex instance for the Record type in fp-ts. FunctorWithIndex extends Functor with a mapWithIndex operation that also provides the index of each element.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Record.ts.md#2025-04-23_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const FunctorWithIndex: FunctorWithIndex1<'Record', string>\n```\n\n----------------------------------------\n\nTITLE: Rotating Elements in ReadonlyNonEmptyArray in TypeScript\nDESCRIPTION: Function that rotates the elements of a ReadonlyNonEmptyArray by a specified number of steps. Positive steps rotate to the right, negative steps rotate to the left.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReadonlyNonEmptyArray.ts.md#2025-04-23_snippet_57\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const rotate: (n: number) => <A>(as: ReadonlyNonEmptyArray<A>) => ReadonlyNonEmptyArray<A>\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport { rotate } from 'fp-ts/ReadonlyNonEmptyArray'\n\nassert.deepStrictEqual(rotate(2)([1, 2, 3, 4, 5]), [4, 5, 1, 2, 3])\nassert.deepStrictEqual(rotate(-2)([1, 2, 3, 4, 5]), [3, 4, 5, 1, 2])\n```\n\n----------------------------------------\n\nTITLE: String Monoid Implementation Example\nDESCRIPTION: Example implementation of a Monoid for strings using concatenation and empty string as identity.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Monoid.ts.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Monoid } from 'fp-ts/Monoid'\n\nconst monoidString: Monoid<string> = {\n  concat: (x, y) => x + y,\n  empty: '',\n}\n```\n\n----------------------------------------\n\nTITLE: Sequencing Reader Array in TypeScript\nDESCRIPTION: Implements sequenceArray for Reader, equivalent to ReadonlyArray#sequence(Applicative). It takes an array of Reader instances and returns a Reader that produces an array of results.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Reader.ts.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const sequenceArray: <R, A>(arr: readonly Reader<R, A>[]) => Reader<R, readonly A[]>\n```\n\n----------------------------------------\n\nTITLE: Defining IORef Class for Mutable References in TypeScript\nDESCRIPTION: Class definition for IORef, which represents a mutable reference in the IO monad. It includes a private value property and methods for reading, writing, and modifying the contained value.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/IORef.ts.md#2025-04-23_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare class IORef<A> {\n  constructor(private value: A)\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing getOrElseW operation for Either in TypeScript\nDESCRIPTION: Defines a less strict version of getOrElse where the handler return type will be merged.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Either.ts.md#2025-04-23_snippet_9\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare const getOrElseW: <E, B>(onLeft: (e: E) => B) => <A>(ma: Either<E, A>) => B | A\n```\n\n----------------------------------------\n\nTITLE: Creating Union Monoid for Records in TypeScript\nDESCRIPTION: Returns a Monoid instance for Records given a Semigroup instance for the base type. The Monoid makes the union of two Records combining the entries that have the same key with the provided Semigroup.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Record.ts.md#2025-04-23_snippet_16\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const getUnionMonoid: <A>(S: Se.Semigroup<A>) => Monoid<Record<string, A>>\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport { SemigroupSum } from 'fp-ts/number'\nimport { getUnionMonoid } from 'fp-ts/Record'\n\nconst M = getUnionMonoid(SemigroupSum)\nassert.deepStrictEqual(M.concat({ foo: 123, bar: 234 }, { foo: 456, baz: 567 }), { foo: 579, bar: 234, baz: 567 })\n```\n\n----------------------------------------\n\nTITLE: Folding Operations for Maps in TypeScript\nDESCRIPTION: Functions for folding (reducing) Map contents, including foldMap, reduce, reduceRight with and without index variants, and methods to get Foldable instances.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Map.ts.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const foldMap: <K>(O: Ord<K>) => <M>(M: Monoid<M>) => <A>(f: (a: A) => M) => (m: Map<K, A>) => M\n```\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const foldMapWithIndex: <K>(\n  O: Ord<K>\n) => <M>(M: Monoid<M>) => <A>(f: (k: K, a: A) => M) => (m: Map<K, A>) => M\n```\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const getFoldable: <K>(O: Ord<K>) => Foldable2C<'Map', K>\n```\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const getFoldableWithIndex: <K>(O: Ord<K>) => FoldableWithIndex2C<'Map', K, K>\n```\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const reduce: <K>(O: Ord<K>) => <B, A>(b: B, f: (b: B, a: A) => B) => (m: Map<K, A>) => B\n```\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const reduceRight: <K>(O: Ord<K>) => <B, A>(b: B, f: (a: A, b: B) => B) => (m: Map<K, A>) => B\n```\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const reduceRightWithIndex: <K>(\n  O: Ord<K>\n) => <B, A>(b: B, f: (k: K, a: A, b: B) => B) => (m: Map<K, A>) => B\n```\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const reduceWithIndex: <K>(O: Ord<K>) => <B, A>(b: B, f: (k: K, b: B, a: A) => B) => (m: Map<K, A>) => B\n```\n\n----------------------------------------\n\nTITLE: Defining flatMapReader Operation for ReaderTaskEither in TypeScript\nDESCRIPTION: Function signature for flatMapReader that composes a ReaderTaskEither with a Reader function, handling the combination of reader environments. Added in v2.16.0.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReaderTaskEither.ts.md#2025-04-23_snippet_90\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const flatMapReader: {\n  <A, R2, B>(f: (a: A) => R.Reader<R2, B>): <R1, E>(self: ReaderTaskEither<R1, E, A>) => ReaderTaskEither<R1 & R2, E, B>\n  <R1, E, A, R2, B>(self: ReaderTaskEither<R1, E, A>, f: (a: A) => R.Reader<R2, B>): ReaderTaskEither<R1 & R2, E, B>\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing fromEitherK for Either Lifting\nDESCRIPTION: Transforms a function returning an Either into a function returning a ReaderTaskEither, lifting pure Either computations into the ReaderTaskEither context.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReaderTaskEither.ts.md#2025-04-23_snippet_62\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const fromEitherK: <E, A extends readonly unknown[], B>(\n  f: (...a: A) => E.Either<E, B>\n) => <R = unknown>(...a: A) => ReaderTaskEither<R, E, B>\n```\n\n----------------------------------------\n\nTITLE: Minimum Function for Ord in TypeScript\nDESCRIPTION: Creates a function to find the minimum of two values according to an Ord instance. If the values are equal, the first argument is chosen.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Ord.ts.md#2025-04-23_snippet_20\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const min: <A>(O: Ord<A>) => (first: A, second: A) => A\n```\n\n----------------------------------------\n\nTITLE: Utility Functions for ReadonlyTuple in TypeScript\nDESCRIPTION: Defines various utility functions for working with ReadonlyTuple, including compose, duplicate, extend, fst, snd, and swap.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReadonlyTuple.ts.md#2025-04-23_snippet_8\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare const compose: <A, B>(ab: readonly [B, A]) => <C>(bc: readonly [C, B]) => readonly [C, A]\n```\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare const duplicate: <E, A>(wa: readonly [A, E]) => readonly [readonly [A, E], E]\n```\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare const extend: <E, A, B>(f: (wa: readonly [A, E]) => B) => (wa: readonly [A, E]) => readonly [B, E]\n```\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare function fst<A, E>(ea: readonly [A, E]): A\n```\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare function snd<A, E>(ea: readonly [A, E]): E\n```\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare const swap: <A, E>(ea: readonly [A, E]) => readonly [E, A]\n```\n\n----------------------------------------\n\nTITLE: Implementing flatMap for ReadonlyNonEmptyArray in TypeScript\nDESCRIPTION: Flattens a ReadonlyNonEmptyArray of ReadonlyNonEmptyArrays into a single ReadonlyNonEmptyArray.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReadonlyNonEmptyArray.ts.md#2025-04-23_snippet_26\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const flatMap: {\n  <A, B>(f: (a: A, i: number) => ReadonlyNonEmptyArray<B>): (ma: ReadonlyNonEmptyArray<A>) => ReadonlyNonEmptyArray<B>\n  <A, B>(ma: ReadonlyNonEmptyArray<A>, f: (a: A, i: number) => ReadonlyNonEmptyArray<B>): ReadonlyNonEmptyArray<B>\n}\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as RNEA from 'fp-ts/ReadonlyNonEmptyArray'\nimport { pipe } from 'fp-ts/function'\n\nassert.deepStrictEqual(\n  pipe(\n    [1, 2, 3],\n    RNEA.flatMap((n) => [`a${n}`, `b${n}`])\n  ),\n  ['a1', 'b1', 'a2', 'b2', 'a3', 'b3']\n)\n```\n\n----------------------------------------\n\nTITLE: Implementing Pipeable Chain Operator in TypeScript\nDESCRIPTION: Implements a pipeable version of chain (flatMap) for sequencing computations that return values in a monadic context.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/pipeable.ts.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare function chain<F extends URIS4>(\n  F: Chain4<F>\n): <A, S, R, E, B>(f: (a: A) => Kind4<F, S, R, E, B>) => (fa: Kind4<F, S, R, E, A>) => Kind4<F, S, R, E, B>\n```\n\n----------------------------------------\n\nTITLE: Implementing Monad Join Operation (flatten)\nDESCRIPTION: Conventional monad join operator for removing one level of monadic structure\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Either.ts.md#2025-04-23_snippet_29\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const flatten: <E, A>(mma: Either<E, Either<E, A>>) => Either<E, A>\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as E from 'fp-ts/Either'\n\nassert.deepStrictEqual(E.flatten(E.right(E.right('a'))), E.right('a'))\nassert.deepStrictEqual(E.flatten(E.right(E.left('e'))), E.left('e'))\nassert.deepStrictEqual(E.flatten(E.left('e')), E.left('e'))\n```\n\n----------------------------------------\n\nTITLE: Getting First Element from Array with fp-ts Option\nDESCRIPTION: Get the first element in an array wrapped in an Option. Returns Some containing the first element if the array is not empty, or None if the array is empty.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReadonlyArray.ts.md#2025-04-23_snippet_34\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const head: <A>(as: readonly A[]) => Option<A>\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport { head } from 'fp-ts/ReadonlyArray'\nimport { some, none } from 'fp-ts/Option'\n\nassert.deepStrictEqual(head([1, 2, 3]), some(1))\nassert.deepStrictEqual(head([]), none)\n```\n\n----------------------------------------\n\nTITLE: Implementing matchE Function for Effectful Pattern Matching in TypeScript\nDESCRIPTION: Handles both Left and Right cases of a TaskEither with functions that return Tasks, combining the results into a single Task.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/TaskEither.ts.md#2025-04-23_snippet_63\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const matchE: <E, A, B>(\n  onLeft: (e: E) => T.Task<B>,\n  onRight: (a: A) => T.Task<B>\n) => (ma: TaskEither<E, A>) => T.Task<B>\n```\n\n----------------------------------------\n\nTITLE: Map Keys Extraction\nDESCRIPTION: Function to get a sorted array of keys from a Map using an Ord instance.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Map.ts.md#2025-04-23_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const keys: <K>(O: Ord<K>) => <A>(m: Map<K, A>) => K[]\n```\n\n----------------------------------------\n\nTITLE: Tree Utility Functions\nDESCRIPTION: Collection of utility functions for tree operations including duplication, element checking, and extension.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Tree.ts.md#2025-04-23_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const duplicate: <A>(wa: Tree<A>) => Tree<Tree<A>>\n```\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare function elem<A>(E: Eq<A>): (a: A, fa: Tree<A>) => boolean\n```\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const exists: <A>(predicate: Predicate<A>) => (ma: Tree<A>) => boolean\n```\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const extend: <A, B>(f: (wa: Tree<A>) => B) => (wa: Tree<A>) => Tree<B>\n```\n\n----------------------------------------\n\nTITLE: Creating Difference Magma for Records in TypeScript\nDESCRIPTION: Produces a Magma with a concat function that combines two Records by making the difference. It returns a new Record containing entries that differ between the two input Records.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Record.ts.md#2025-04-23_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const getDifferenceMagma: <A>() => Magma<Record<string, A>>\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport { getDifferenceMagma, difference } from 'fp-ts/Record'\nimport { Magma } from 'fp-ts/Magma'\n\nconst r1 = { a: 3, c: 3 }\nconst r2 = { a: 1, b: 2 }\nconst m: Magma<Record<string, number>> = getDifferenceMagma<number>()\nassert.deepStrictEqual(m.concat(r1, r2), difference(r2)(r1))\nassert.deepStrictEqual(m.concat(r1, r2), { c: 3, b: 2 })\n```\n\n----------------------------------------\n\nTITLE: Converting Task to TaskEither in TypeScript\nDESCRIPTION: Lifts a Task into a TaskEither, with the error type defaulting to never.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/TaskEither.ts.md#2025-04-23_snippet_6\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare const fromTask: <A, E = never>(fa: T.Task<A>) => TaskEither<E, A>\n```\n\n----------------------------------------\n\nTITLE: Tapping IO Values in IOEither Context\nDESCRIPTION: The tapIO function composes computations in sequence, using the return value of one computation to determine the next computation and keeping only the result of the first. It works with IO values in an IOEither context.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/IOEither.ts.md#2025-04-23_snippet_2\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare const tapIO: {\n  <A, _>(f: (a: A) => I.IO<_>): <E>(self: IOEither<E, A>) => IOEither<E, A>\n  <E, A, _>(self: IOEither<E, A>, f: (a: A) => I.IO<_>): IOEither<E, A>\n}\n```\n\n----------------------------------------\n\nTITLE: Converting TaskEither to Task of Union in TypeScript\nDESCRIPTION: Converts a TaskEither to a Task of the union of its error and success types.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/TaskEither.ts.md#2025-04-23_snippet_8\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare const toUnion: <E, A>(fa: TaskEither<E, A>) => T.Task<E | A>\n```\n\n----------------------------------------\n\nTITLE: Converting Array to Record in TypeScript\nDESCRIPTION: Converts an Array of [key, value] tuples into a Record using the fromEntries function.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Record.ts.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { fromEntries } from 'fp-ts/Record'\n\nassert.deepStrictEqual(\n  fromEntries([\n    ['a', 1],\n    ['b', 2],\n    ['a', 3],\n  ]),\n  { b: 2, a: 3 }\n)\n```\n\n----------------------------------------\n\nTITLE: Implementing Number Type Refinement\nDESCRIPTION: Type guard function for checking if a value is a number.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/number.ts.md#2025-04-23_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const isNumber: Refinement<unknown, number>\n```\n\n----------------------------------------\n\nTITLE: Map to Array Conversion\nDESCRIPTION: Function to convert a Map to a sorted array of key-value pairs.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Map.ts.md#2025-04-23_snippet_20\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare function toArray<K>(O: Ord<K>): <A>(m: Map<K, A>) => Array<[K, A]>\n```\n\n----------------------------------------\n\nTITLE: Implementing ConcatAll Function for Semigroups in TypeScript\nDESCRIPTION: Defines a utility function to concatenate all elements in an array using a given Semigroup.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Semigroup.ts.md#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const concatAll: <A>(S: Semigroup<A>) => (startWith: A) => (as: readonly A[]) => A\n```\n\n----------------------------------------\n\nTITLE: Converting Array to Set in TypeScript\nDESCRIPTION: Creates a Set from an array of elements. It requires an equality function to determine uniqueness of elements in the resulting set.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Set.ts.md#2025-04-23_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare const fromArray: <A>(E: Eq<A>) => (as: A[]) => Set<A>\n```\n\n----------------------------------------\n\nTITLE: Sequencing and Chain Operations\nDESCRIPTION: Functions for composing array operations in sequence and chaining transformations.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReadonlyArray.ts.md#2025-04-23_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const chainFirst: <A, B>(f: (a: A) => readonly B[]) => (first: readonly A[]) => readonly A[]\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as RA from 'fp-ts/ReadonlyArray'\nimport { pipe } from 'fp-ts/function'\n\nassert.deepStrictEqual(\n  pipe(\n    [1, 2, 3],\n    RA.chainFirst(() => ['a', 'b'])\n  ),\n  [1, 1, 2, 2, 3, 3]\n)\n```\n\n----------------------------------------\n\nTITLE: Implementing FromReader ask function in TypeScript\nDESCRIPTION: The ask function is a constructor that retrieves the environment from a reader-compatible monad. It provides type-safe access to the environment without requiring any arguments.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/FromReader.ts.md#2025-04-23_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare function ask<F extends URIS4>(F: FromReader4<F>): <S, R, E>() => Kind4<F, S, R, E, R>\nexport declare function ask<F extends URIS3>(F: FromReader3<F>): <R, E>() => Kind3<F, R, E, R>\nexport declare function ask<F extends URIS3, E>(F: FromReader3C<F, E>): <R>() => Kind3<F, R, E, R>\nexport declare function ask<F extends URIS2>(F: FromReader2<F>): <R>() => Kind2<F, R, R>\nexport declare function ask<F>(F: FromReader<F>): <R>() => HKT2<F, R, R>\n```\n\n----------------------------------------\n\nTITLE: Implementing concat for ReadonlyNonEmptyArray in TypeScript\nDESCRIPTION: Concatenates two ReadonlyNonEmptyArrays or a ReadonlyArray with a ReadonlyNonEmptyArray.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReadonlyNonEmptyArray.ts.md#2025-04-23_snippet_37\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare function concat<A>(\n  second: ReadonlyNonEmptyArray<A>\n): (first: ReadonlyArray<A>) => ReadonlyNonEmptyArray<A>\nexport declare function concat<A>(\n  second: ReadonlyArray<A>\n): (first: ReadonlyNonEmptyArray<A>) => ReadonlyNonEmptyArray<A>\nexport declare function concat<A>(first: ReadonlyArray<A>, second: ReadonlyNonEmptyArray<A>): ReadonlyNonEmptyArray<A>\nexport declare function concat<A>(first: ReadonlyNonEmptyArray<A>, second: ReadonlyArray<A>): ReadonlyNonEmptyArray<A>\n```\n\n----------------------------------------\n\nTITLE: Sorting NonEmptyArray by Multiple Criteria in TypeScript\nDESCRIPTION: Sorts the elements of a NonEmptyArray using multiple Ord instances, creating a new sorted NonEmptyArray based on multiple comparison criteria.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/NonEmptyArray.ts.md#2025-04-23_snippet_17\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const sortBy: <B>(ords: Ord<B>[]) => <A extends B>(as: NonEmptyArray<A>) => NonEmptyArray<A>\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as NEA from 'fp-ts/NonEmptyArray'\nimport { contramap } from 'fp-ts/Ord'\nimport * as S from 'fp-ts/string'\nimport * as N from 'fp-ts/number'\nimport { pipe } from 'fp-ts/function'\n\ninterface Person {\n  name: string\n  age: number\n}\n\nconst byName = pipe(\n  S.Ord,\n  contramap((p: Person) => p.name)\n)\n\nconst byAge = pipe(\n  N.Ord,\n  contramap((p: Person) => p.age)\n)\n\nconst sortByNameByAge = NEA.sortBy([byName, byAge])\n\nconst persons: NEA.NonEmptyArray<Person> = [\n  { name: 'a', age: 1 },\n  { name: 'b', age: 3 },\n  { name: 'c', age: 2 },\n  { name: 'b', age: 2 },\n]\n\nassert.deepStrictEqual(sortByNameByAge(persons), [\n  { name: 'a', age: 1 },\n  { name: 'b', age: 2 },\n  { name: 'b', age: 3 },\n  { name: 'c', age: 2 },\n])\n```\n\n----------------------------------------\n\nTITLE: Creating Max Semigroup in TypeScript\nDESCRIPTION: Defines a function to create a Semigroup that returns the maximum of two values based on a given Ord instance.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Semigroup.ts.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const max: <A>(O: Or.Ord<A>) => Semigroup<A>\n```\n\n----------------------------------------\n\nTITLE: Struct Monoid Example\nDESCRIPTION: Example showing how to create a monoid for a struct of values using individual monoids for each field.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Monoid.ts.md#2025-04-23_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nimport { struct } from 'fp-ts/Monoid'\nimport * as N from 'fp-ts/number'\n\ninterface Point {\n  readonly x: number\n  readonly y: number\n}\n\nconst M = struct<Point>({\n  x: N.MonoidSum,\n  y: N.MonoidSum,\n})\n\nassert.deepStrictEqual(M.concat({ x: 1, y: 2 }, { x: 3, y: 4 }), { x: 4, y: 6 })\n```\n\n----------------------------------------\n\nTITLE: Computing Difference Between Records in TypeScript\nDESCRIPTION: Takes two Records and produces a Record composed of entries from both inputs, removing entries with the same key in both inputs. Returns a function that accepts two Records and returns a new Record with the difference.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Record.ts.md#2025-04-23_snippet_25\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const difference: <A>(second: Record<string, A>) => (first: Record<string, A>) => Record<string, A>\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport { difference } from 'fp-ts/Record'\n\nassert.deepStrictEqual(difference({ a: 1 })({ a: 1, b: 2 }), { b: 2 })\nassert.deepStrictEqual(difference({ a: 3 })({ a: 1, b: 2 }), { b: 2 })\nassert.deepStrictEqual(difference({ a: 3, c: 3 })({ a: 1, b: 2 }), { b: 2, c: 3 })\n```\n\n----------------------------------------\n\nTITLE: Creating Monoid Instance for Records in TypeScript\nDESCRIPTION: Returns a Monoid instance for Records, given a Semigroup instance for the base type. The Monoid makes the union of two Records combining the overlapping entries with the provided Semigroup.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Record.ts.md#2025-04-23_snippet_14\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const getMonoid: <K extends string, A>(S: Se.Semigroup<A>) => Monoid<Record<K, A>>\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport { SemigroupSum } from 'fp-ts/number'\nimport { getMonoid } from 'fp-ts/Record'\n\nconst M = getMonoid(SemigroupSum)\nassert.deepStrictEqual(M.concat({ foo: 123, bar: 234 }, { foo: 456, baz: 567 }), { foo: 579, bar: 234, baz: 567 })\n```\n\n----------------------------------------\n\nTITLE: Getting Semigroup instance for Eq in TypeScript\nDESCRIPTION: Returns a Semigroup instance for Eq, enabling the combination of equality relations.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Eq.ts.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const getSemigroup: <A>() => Semigroup<Eq<A>>\n```\n\n----------------------------------------\n\nTITLE: Defining sequenceArray Operation for ReaderTaskEither in TypeScript\nDESCRIPTION: Function signature for sequenceArray that transforms an array of ReaderTaskEither into a ReaderTaskEither of an array. Equivalent to ReadonlyArray#sequence(Applicative). Added in v2.9.0.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReaderTaskEither.ts.md#2025-04-23_snippet_98\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const sequenceArray: <R, E, A>(\n  arr: readonly ReaderTaskEither<R, E, A>[]\n) => ReaderTaskEither<R, E, readonly A[]>\n```\n\n----------------------------------------\n\nTITLE: Sequencing monadic values in Records with fp-ts\nDESCRIPTION: Transforms a Record containing monadic values into a monad of a Record. For example, converts a Record<string, Option<number>> into an Option<Record<string, number>>. Equivalent to sequenceS in Apply.ts.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Record.ts.md#2025-04-23_snippet_46\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare function sequence<F extends URIS3>(\n  F: Applicative3<F>\n): <K extends string, R, E, A>(ta: Record<K, Kind3<F, R, E, A>>) => Kind3<F, R, E, Record<K, A>>\nexport declare function sequence<F extends URIS3, E>(\n  F: Applicative3C<F, E>\n): <K extends string, R, A>(ta: Record<K, Kind3<F, R, E, A>>) => Kind3<F, R, E, Record<K, A>>\nexport declare function sequence<F extends URIS2>(\n  F: Applicative2<F>\n): <K extends string, E, A>(ta: Record<K, Kind2<F, E, A>>) => Kind2<F, E, Record<K, A>>\nexport declare function sequence<F extends URIS2, E>(\n  F: Applicative2C<F, E>\n): <K extends string, A>(ta: Record<K, Kind2<F, E, A>>) => Kind2<F, E, Record<K, A>>\nexport declare function sequence<F extends URIS>(\n  F: Applicative1<F>\n): <K extends string, A>(ta: Record<K, Kind<F, A>>) => Kind<F, Record<K, A>>\nexport declare function sequence<F>(\n  F: Applicative<F>\n): <K extends string, A>(ta: Record<K, HKT<F, A>>) => HKT<F, Record<K, A>>\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport { sequence } from 'fp-ts/Record'\nimport { option } from 'fp-ts'\nimport { sequenceS } from 'fp-ts/Apply'\n\nassert.deepStrictEqual(\n  sequence(option.Applicative)({ a: option.some(1), b: option.some(2) }),\n  option.some({ a: 1, b: 2 })\n)\nassert.deepStrictEqual(sequence(option.Applicative)({ a: option.some(1), b: option.none }), option.none)\nassert.deepStrictEqual(\n  sequence(option.Applicative)({ a: option.some(1), b: option.some(2) }),\n  sequenceS(option.Applicative)({ a: option.some(1), b: option.some(2) })\n)\n```\n\n----------------------------------------\n\nTITLE: Implementing flatMapIOEither Function for Chaining with IOEither in TypeScript\nDESCRIPTION: Chains a TaskEither with an IOEither-returning function, applying the function to the Right value and merging error types, with support for pipeable and data-last styles.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/TaskEither.ts.md#2025-04-23_snippet_69\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const flatMapIOEither: {\n  <A, E2, B>(f: (a: A) => IOEither<E2, B>): <E1>(self: TaskEither<E1, A>) => TaskEither<E2 | E1, B>\n  <E1, A, E2, B>(self: TaskEither<E1, A>, f: (a: A) => IOEither<E2, B>): TaskEither<E1 | E2, B>\n}\n```\n\n----------------------------------------\n\nTITLE: Converting between Map and ReadonlyMap in TypeScript\nDESCRIPTION: Functions to convert between mutable Map and immutable ReadonlyMap types.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReadonlyMap.ts.md#2025-04-23_snippet_2\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare const fromMap: <K, A>(m: Map<K, A>) => ReadonlyMap<K, A>\n```\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare function toMap<K, A>(m: ReadonlyMap<K, A>): Map<K, A>\n```\n\n----------------------------------------\n\nTITLE: Implementing concatAll for ReadonlyNonEmptyArray in TypeScript\nDESCRIPTION: Folds a ReadonlyNonEmptyArray using the provided Semigroup instance.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReadonlyNonEmptyArray.ts.md#2025-04-23_snippet_38\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const concatAll: <A>(S: Se.Semigroup<A>) => (as: ReadonlyNonEmptyArray<A>) => A\n```\n\n----------------------------------------\n\nTITLE: Implementing NonEmptyArray Traversal Functions in TypeScript\nDESCRIPTION: Functions for traversing ReadonlyNonEmptyArray types with TaskEither, including parallel and sequential variants.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/TaskEither.ts.md#2025-04-23_snippet_80\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const traverseReadonlyNonEmptyArrayWithIndex: <A, E, B>(\n  f: (index: number, a: A) => TaskEither<E, B>\n) => (as: ReadonlyNonEmptyArray<A>) => TaskEither<E, ReadonlyNonEmptyArray<B>>\n```\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const traverseReadonlyNonEmptyArrayWithIndexSeq: <A, E, B>(\n  f: (index: number, a: A) => TaskEither<E, B>\n) => (as: ReadonlyNonEmptyArray<A>) => TaskEither<E, ReadonlyNonEmptyArray<B>>\n```\n\n----------------------------------------\n\nTITLE: Creating Eq for tuples in TypeScript\nDESCRIPTION: Creates an Eq instance for a tuple by combining Eq instances for each element. Compares tuples element by element.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Eq.ts.md#2025-04-23_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const tuple: <A extends readonly unknown[]>(...eqs: { [K in keyof A]: Eq<A[K]> }) => Eq<Readonly<A>>\n```\n\n----------------------------------------\n\nTITLE: Checking if Record is Empty\nDESCRIPTION: Tests whether a Record has no entries. Returns true if the Record is empty, false otherwise.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Record.ts.md#2025-04-23_snippet_35\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const isEmpty: <A>(r: Record<string, A>) => boolean\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport { isEmpty } from 'fp-ts/Record'\n\nassert.deepStrictEqual(isEmpty({}), true)\nassert.deepStrictEqual(isEmpty({ a: 3 }), false)\n```\n\n----------------------------------------\n\nTITLE: Defining State Interface in TypeScript\nDESCRIPTION: Defines the State interface, which represents a function that takes a state S and returns a tuple of a value A and a new state S.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/State.ts.md#2025-04-23_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport interface State<S, A> {\n  (s: S): [A, S]\n}\n```\n\n----------------------------------------\n\nTITLE: Map Entry Lookup with Key\nDESCRIPTION: Function to lookup both key and value by key in a Map, returning an Option of tuple.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Map.ts.md#2025-04-23_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare function lookupWithKey<K>(E: Eq<K>): {\n  (k: K): <A>(m: Map<K, A>) => Option<[K, A]>\n  <A>(k: K, m: Map<K, A>): Option<[K, A]>\n}\n```\n\n----------------------------------------\n\nTITLE: Utility Functions for ReaderEither in TypeScript\nDESCRIPTION: Collection of utility functions including ap, apFirst, apSecond, local, swap and throwError implementations.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReaderEither.ts.md#2025-04-23_snippet_17\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const ap: <R, E, A>(\n  fa: ReaderEither<R, E, A>\n) => <B>(fab: ReaderEither<R, E, (a: A) => B>) => ReaderEither<R, E, B>\n```\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const local: <R2, R1>(f: (r2: R2) => R1) => <E, A>(ma: ReaderEither<R1, E, A>) => ReaderEither<R2, E, A>\n```\n\n----------------------------------------\n\nTITLE: Reducing Records from Right with Custom Order in TypeScript\nDESCRIPTION: Implements a reduceRight function for Records, processing entries from right to left in reverse order, sorted by key according to the given Ord. It takes an initial value and a reducer function.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Record.ts.md#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare function reduceRight(O: Ord<string>): <A, B>(b: B, f: (a: A, b: B) => B) => (fa: Record<string, A>) => B\nexport declare function reduceRight<A, B>(b: B, f: (a: A, b: B) => B): (fa: Record<string, A>) => B\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport { reduceRight } from 'fp-ts/Record'\nimport { Ord } from 'fp-ts/string'\n\nconst x = { c: 3, a: 'foo', b: false }\nassert.deepStrictEqual(reduceRight(Ord)([] as string[], (a, b) => [...b, `-${a}-`])(x), ['-3-', '-false-', '-foo-'])\n```\n\n----------------------------------------\n\nTITLE: Implementing flatMapOption Function for Chaining with Option in TypeScript\nDESCRIPTION: Chains a TaskEither with an Option-returning function, handling None with the provided onNone function, with support for pipeable and data-last styles.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/TaskEither.ts.md#2025-04-23_snippet_71\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const flatMapOption: {\n  <A, B, E2>(f: (a: A) => Option<B>, onNone: (a: A) => E2): <E1>(self: TaskEither<E1, A>) => TaskEither<E2 | E1, B>\n  <E1, A, B, E2>(self: TaskEither<E1, A>, f: (a: A) => Option<B>, onNone: (a: A) => E2): TaskEither<E1 | E2, B>\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing groupBy for ReadonlyNonEmptyArray in TypeScript\nDESCRIPTION: Splits an array into sub-non-empty-arrays stored in an object, based on the result of calling a string-returning function on each element.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReadonlyNonEmptyArray.ts.md#2025-04-23_snippet_44\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const groupBy: <A>(\n  f: (a: A) => string\n) => (as: readonly A[]) => Readonly<Record<string, ReadonlyNonEmptyArray<A>>>\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport { groupBy } from 'fp-ts/ReadonlyNonEmptyArray'\n\nassert.deepStrictEqual(groupBy((s: string) => String(s.length))(['a', 'b', 'ab']), {\n  '1': ['a', 'b'],\n  '2': ['ab'],\n})\n```\n\n----------------------------------------\n\nTITLE: Map Composition Implementation\nDESCRIPTION: Utility function that composes map operations from two Functors. Enables mapping over nested Functor structures.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Functor.ts.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare function map<F extends URIS3, G extends URIS>(\n  F: Functor3<F>,\n  G: Functor1<G>\n): <A, B>(f: (a: A) => B) => <R, E>(fa: Kind3<F, R, E, Kind<G, A>>) => Kind3<F, R, E, Kind<G, B>>\n```\n\n----------------------------------------\n\nTITLE: Collecting Record Entries into Array in TypeScript\nDESCRIPTION: Map a Record into an Array. It passes each key/value pair to the iterating function and collects the results in an array, sorted alphabetically by the original key.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Record.ts.md#2025-04-23_snippet_23\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare function collect(\n  O: Ord<string>\n): <K extends string, A, B>(f: (k: K, a: A) => B) => (r: Record<K, A>) => Array<B>\nexport declare function collect<K extends string, A, B>(f: (k: K, a: A) => B): (r: Record<K, A>) => Array<B>\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport { collect } from 'fp-ts/Record'\nimport { Ord } from 'fp-ts/string'\n\nconst f = <A>(k: string, a: A) => `${k.toUpperCase()}-${a}`\nconst x = { c: 3, a: 'foo', b: false }\nassert.deepStrictEqual(collect(Ord)(f)(x), ['A-foo', 'B-false', 'C-3'])\n```\n\n----------------------------------------\n\nTITLE: Testing Subrecord Relationship\nDESCRIPTION: Tests whether one Record contains all the keys and values of another Record, using a provided Eq instance for value comparison. Can be used in both curried and non-curried forms.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Record.ts.md#2025-04-23_snippet_36\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const isSubrecord: <A>(E: Eq<A>) => {\n  (that: Record<string, A>): (me: Record<string, A>) => boolean\n  (me: Record<string, A>, that: Record<string, A>): boolean\n}\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport { isSubrecord } from 'fp-ts/Record'\nimport { string } from 'fp-ts'\n\nassert.deepStrictEqual(isSubrecord(string.Eq)({ a: 'foo', b: 'bar', c: 'baz' })({ a: 'foo', b: 'bar', c: 'baz' }), true)\nassert.deepStrictEqual(isSubrecord(string.Eq)({ a: 'foo', b: 'bar', c: 'baz' })({ a: 'foo', c: 'baz' }), true)\nassert.deepStrictEqual(\n  isSubrecord(string.Eq)({ a: 'foo', b: 'bar', c: 'baz' })({ a: 'foo', b: 'not-bar', c: 'baz' }),\n  false\n)\nassert.deepStrictEqual(isSubrecord(string.Eq)({ a: 'foo', b: 'bar' })({ a: 'foo', b: 'bar', c: 'baz' }), false)\n```\n\n----------------------------------------\n\nTITLE: Implementing State Constructors in TypeScript\nDESCRIPTION: Defines constructors for the State monad, including get, gets, modify, of, and put functions.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/State.ts.md#2025-04-23_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare const get: <S>() => State<S, S>\n\nexport declare const gets: <S, A>(f: (s: S) => A) => State<S, A>\n\nexport declare const modify: <S>(f: (s: S) => S) => State<S, void>\n\nexport declare const of: <S, A>(a: A) => State<S, A>\n\nexport declare const put: <S>(s: S) => State<S, void>\n```\n\n----------------------------------------\n\nTITLE: Implementing Random Boolean Generator in TypeScript\nDESCRIPTION: Function that returns an IO monad containing a random boolean value with equal probability of true or false.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Random.ts.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const randomBool: IO<boolean>\n```\n\n----------------------------------------\n\nTITLE: Implementing tap Combinator for IO in TypeScript\nDESCRIPTION: Implements the tap combinator for IO, which composes computations in sequence, using the return value of one computation to determine the next computation and keeping only the result of the first.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/IO.ts.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const tap: {\n  <A, _>(self: IO<A>, f: (a: A) => IO<_>): IO<A>\n  <A, _>(f: (a: A) => IO<_>): (self: IO<A>) => IO<A>\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing flatMap Function for Chaining TaskEither Operations in TypeScript\nDESCRIPTION: Chains TaskEither operations by applying a function to the Right value of a TaskEither and flattening the result, with support for pipeable and data-last styles.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/TaskEither.ts.md#2025-04-23_snippet_66\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const flatMap: {\n  <A, E2, B>(f: (a: A) => TaskEither<E2, B>): <E1>(ma: TaskEither<E1, A>) => TaskEither<E2 | E1, B>\n  <E1, A, E2, B>(ma: TaskEither<E1, A>, f: (a: A) => TaskEither<E2, B>): TaskEither<E1 | E2, B>\n}\n```\n\n----------------------------------------\n\nTITLE: Using getAssignSemigroup for Object Merging in TypeScript\nDESCRIPTION: Demonstrates how to use the getAssignSemigroup function to create a semigroup for merging Person objects. It shows that the rightmost object's properties take precedence.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/struct.ts.md#2025-04-23_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { getAssignSemigroup } from 'fp-ts/struct'\n\ninterface Person {\n  readonly name: string\n  readonly age: number\n}\n\nconst S = getAssignSemigroup<Person>()\nassert.deepStrictEqual(S.concat({ name: 'name', age: 23 }, { name: 'name', age: 24 }), { name: 'name', age: 24 })\n```\n\n----------------------------------------\n\nTITLE: Implementing FromPredicate Function for IOOption in TypeScript\nDESCRIPTION: Defines the fromPredicate function for IOOption. It creates an IOOption based on a predicate function.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/IOOption.ts.md#2025-04-23_snippet_28\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const fromPredicate: {\n  <A, B extends A>(refinement: Refinement<A, B>): (a: A) => IOOption<B>\n  <A>(predicate: Predicate<A>): <B extends A>(b: B) => IOOption<B>\n  <A>(predicate: Predicate<A>): (a: A) => IOOption<A>\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing ap for ReadonlyNonEmptyArray in TypeScript\nDESCRIPTION: Applies a ReadonlyNonEmptyArray of functions to a ReadonlyNonEmptyArray of values.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReadonlyNonEmptyArray.ts.md#2025-04-23_snippet_32\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const ap: <A>(\n  as: ReadonlyNonEmptyArray<A>\n) => <B>(fab: ReadonlyNonEmptyArray<(a: A) => B>) => ReadonlyNonEmptyArray<B>\n```\n\n----------------------------------------\n\nTITLE: Show Interface Definition in TypeScript\nDESCRIPTION: Defines the core Show type class interface with a show method that converts values of type A to strings.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Show.ts.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface Show<A> {\n  readonly show: (a: A) => string\n}\n```\n\n----------------------------------------\n\nTITLE: Folding a Record in TypeScript\nDESCRIPTION: Maps and folds a Record using a provided Monoid and mapping function.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Record.ts.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { foldMap } from 'fp-ts/Record'\nimport { Ord } from 'fp-ts/string'\nimport { Monoid } from 'fp-ts/Monoid'\n\nconst m: Monoid<string> = { empty: '', concat: (x: string, y: string) => (x ? `${x} -> ${y}` : `${y}`) }\nconst f = (a: number) => `-${a}-`\nconst x = { c: 3, a: 1, b: 2 }\nassert.deepStrictEqual(foldMap(Ord)(m)(f)(x), '-1- -> -2- -> -3-')\n```\n\n----------------------------------------\n\nTITLE: Parallel Operations with apS\nDESCRIPTION: Demonstrates how to perform parallel operations using apS with the Task monad.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/guides/do-notation.md#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport { pipe } from 'fp-ts/function'\nimport * as T from 'fp-ts/Task'\n\ndeclare const encryptValue: (val: string) => T.Task<string>\n\npipe(\n  T.Do,\n  T.apS('x', encryptValue('hello')),\n  T.apS('y', encryptValue('world')),\n  T.map(({ x, y }) => {\n    /* ... */\n  })\n)\n```\n\n----------------------------------------\n\nTITLE: Implementing HKT Interface for `* -> *` Constructors in TypeScript\nDESCRIPTION: Defines the HKT interface for unary type constructors that take one type parameter. It includes type parameters for the URI (type identifier) and A (the parameter type).\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/HKT.ts.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface HKT<URI, A> {\n  readonly _URI: URI\n  readonly _A: A\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Bifunctor3C Interface in TypeScript\nDESCRIPTION: Defines the Bifunctor3C interface for handling three-parameter type constructors with a fixed error type. It includes methods for bimap and mapLeft operations.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Bifunctor.ts.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface Bifunctor3C<F extends URIS3, E> {\n  readonly URI: F\n  readonly _E: E\n  readonly bimap: <R, A, G, B>(fea: Kind3<F, R, E, A>, f: (e: E) => G, g: (a: A) => B) => Kind3<F, R, G, B>\n  readonly mapLeft: <R, A, G>(fea: Kind3<F, R, E, A>, f: (e: E) => G) => Kind3<F, R, G, A>\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Maps from Foldable Collections in TypeScript\nDESCRIPTION: Creates a map from a foldable collection of key/value pairs, using a specified Magma to combine values for duplicate keys. Supports various higher-kinded types through URIS overloads.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Map.ts.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare function fromFoldable<F extends URIS3, K, A>(\n  E: Eq<K>,\n  M: Magma<A>,\n  F: Foldable3<F>\n): <R, E>(fka: Kind3<F, R, E, [K, A]>) => Map<K, A>\nexport declare function fromFoldable<F extends URIS2, K, A>(\n  E: Eq<K>,\n  M: Magma<A>,\n  F: Foldable2<F>\n): <E>(fka: Kind2<F, E, [K, A]>) => Map<K, A>\nexport declare function fromFoldable<F extends URIS, K, A>(\n  E: Eq<K>,\n  M: Magma<A>,\n  F: Foldable1<F>\n): (fka: Kind<F, [K, A]>) => Map<K, A>\nexport declare function fromFoldable<F, K, A>(E: Eq<K>, M: Magma<A>, F: Foldable<F>): (fka: HKT<F, [K, A]>) => Map<K, A>\n```\n\n----------------------------------------\n\nTITLE: Either-based Refinement Constructor\nDESCRIPTION: Creates a refinement from a function that returns Either type.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Refinement.ts.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const fromEitherK: <A, B extends A>(getEither: (a: A) => Either<unknown, B>) => Refinement<A, B>\n```\n\n----------------------------------------\n\nTITLE: Sorting NonEmptyArray in TypeScript\nDESCRIPTION: Sorts the elements of a NonEmptyArray in increasing order based on a provided Ord instance, creating a new sorted NonEmptyArray.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/NonEmptyArray.ts.md#2025-04-23_snippet_16\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const sort: <B>(O: Ord<B>) => <A extends B>(as: NonEmptyArray<A>) => NonEmptyArray<A>\n```\n\n----------------------------------------\n\nTITLE: Implementing map for ReadonlyNonEmptyArray in TypeScript\nDESCRIPTION: Maps a function over a ReadonlyNonEmptyArray, transforming its elements.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReadonlyNonEmptyArray.ts.md#2025-04-23_snippet_19\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const map: <A, B>(f: (a: A) => B) => (as: ReadonlyNonEmptyArray<A>) => ReadonlyNonEmptyArray<B>\n```\n\n----------------------------------------\n\nTITLE: Map Singleton Creation\nDESCRIPTION: Function to create a new Map with a single key-value pair.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Map.ts.md#2025-04-23_snippet_18\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const singleton: <K, A>(k: K, a: A) => Map<K, A>\n```\n\n----------------------------------------\n\nTITLE: Zipping NonEmptyArrays with Custom Function in TypeScript\nDESCRIPTION: Combines two NonEmptyArrays element-wise using a custom function. The resulting array has the length of the shorter input array.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/NonEmptyArray.ts.md#2025-04-23_snippet_29\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const zipWith: <A, B, C>(\n  as: NonEmptyArray<A>,\n  bs: NonEmptyArray<B>,\n  f: (a: A, b: B) => C\n) => NonEmptyArray<C>\n```\n\n----------------------------------------\n\nTITLE: matchE Function Declaration in TypeScript\nDESCRIPTION: Function to match over Either values in a monadic context, handling both Left and Right cases with appropriate type safety.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/EitherT.ts.md#2025-04-23_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare function matchE<M extends URIS3>(\n  M: Chain3<M>\n): <E, R, FE, B, A>(\n  onLeft: (e: E) => Kind3<M, R, FE, B>,\n  onRight: (a: A) => Kind3<M, R, FE, B>\n) => (ma: Kind3<M, R, FE, Either<E, A>>) => Kind3<M, R, FE, B>\n```\n\n----------------------------------------\n\nTITLE: Implementing traverse_ Function in TypeScript\nDESCRIPTION: Function to traverse a data structure performing effects with an Applicative functor while ignoring the final result. Includes multiple type signatures for different kinds of functors.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Foldable.ts.md#2025-04-23_snippet_16\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare function traverse_<M extends URIS3, F extends URIS>(\n  M: Applicative3<M>,\n  F: Foldable1<F>\n): <R, E, A, B>(fa: Kind<F, A>, f: (a: A) => Kind3<M, R, E, B>) => Kind3<M, R, E, void>\n```\n\n----------------------------------------\n\nTITLE: Mapping Functions - TypeScript\nDESCRIPTION: Functions for mapping over tuple components including bimap, flap, mapFst, and mapSnd\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Tuple.ts.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const bimap: <E, G, A, B>(mapSnd: (e: E) => G, mapFst: (a: A) => B) => (fa: [A, E]) => [B, G]\nexport declare const flap: <A>(a: A) => <E, B>(fab: [(a: A) => B, E]) => [B, E]\nexport declare const mapFst: <A, B>(f: (a: A) => B) => <E>(fa: [A, E]) => [B, E]\nexport declare const mapSnd: <E, G>(f: (e: E) => G) => <A>(fa: [A, E]) => [A, G]\n```\n\n----------------------------------------\n\nTITLE: Deleting Entry from Record in TypeScript\nDESCRIPTION: Delete a key and value from a Record. This function returns a new Record with the specified key removed.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Record.ts.md#2025-04-23_snippet_24\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare function deleteAt<K extends string>(\n  k: K\n): <KS extends string, A>(r: Record<KS, A>) => Record<string extends K ? string : Exclude<KS, K>, A>\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport { deleteAt } from 'fp-ts/Record'\n\nassert.deepStrictEqual(deleteAt('a')({ a: 1, b: 2 }), { b: 2 })\nassert.deepStrictEqual(deleteAt('c')({ a: 1, b: 2 }), { a: 1, b: 2 })\n```\n\n----------------------------------------\n\nTITLE: Implementing Filtering with Effects in ReadonlyArray in TypeScript\nDESCRIPTION: Defines a function to filter elements of a ReadonlyArray using a predicate that returns values in a context.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReadonlyArray.ts.md#2025-04-23_snippet_28\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const filterE: FilterE1<'ReadonlyArray'>\n```\n\n----------------------------------------\n\nTITLE: Using ReadonlyArray Comprehension in TypeScript\nDESCRIPTION: Demonstrates how to use the comprehension function with two input arrays and a filtering condition.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReadonlyArray.ts.md#2025-04-23_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\nimport { comprehension } from 'fp-ts/ReadonlyArray'\nimport { tuple } from 'fp-ts/function'\n\nassert.deepStrictEqual(\n  comprehension(\n    [\n      [1, 2, 3],\n      ['a', 'b'],\n    ],\n    tuple,\n    (a, b) => (a + b.length) % 2 === 0\n  ),\n  [\n    [1, 'a'],\n    [1, 'b'],\n    [3, 'a'],\n    [3, 'b'],\n  ]\n)\n```\n\n----------------------------------------\n\nTITLE: Constructing These Values in TypeScript\nDESCRIPTION: Provides functions to construct These values, including left, right, both, and of.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/These.ts.md#2025-04-23_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare function left<E = never, A = never>(left: E): These<E, A>\n\nexport declare function right<E = never, A = never>(right: A): These<E, A>\n\nexport declare function both<E, A>(left: E, right: A): These<E, A>\n\nexport declare const of: <E = never, A = never>(right: A) => These<E, A>\n```\n\n----------------------------------------\n\nTITLE: Map Key Membership Test\nDESCRIPTION: Function to test whether a key exists in a Map.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Map.ts.md#2025-04-23_snippet_14\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const member: <K>(E: Eq<K>) => { (k: K): <A>(m: Map<K, A>) => boolean; <A>(k: K, m: Map<K, A>): boolean }\n```\n\n----------------------------------------\n\nTITLE: Writer Interface Definition in TypeScript\nDESCRIPTION: Defines the core Writer interface that pairs a value of type A with an accumulator of type W.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Writer.ts.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface Writer<W, A> {\n  (): [A, W]\n}\n```\n\n----------------------------------------\n\nTITLE: Defining BoundedLattice Interface in TypeScript\nDESCRIPTION: The BoundedLattice interface extends both BoundedJoinSemilattice and BoundedMeetSemilattice interfaces. It represents a bounded lattice algebraic structure that satisfies the absorption laws for both meet and join operations.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/BoundedLattice.ts.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface BoundedLattice<A> extends BoundedJoinSemilattice<A>, BoundedMeetSemilattice<A> {}\n```\n\n----------------------------------------\n\nTITLE: Basic Contravariant Interface Definition\nDESCRIPTION: Defines the base Contravariant interface for a single type parameter F. Includes a contramap function that transforms values while preserving the contravariant structure.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Contravariant.ts.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface Contravariant<F> {\n  readonly URI: F\n  readonly contramap: <A, B>(fa: HKT<F, A>, f: (b: B) => A) => HKT<F, B>\n}\n```\n\n----------------------------------------\n\nTITLE: Rotating Array Elements with fp-ts\nDESCRIPTION: Rotates a ReadonlyArray by n steps. Positive values rotate right, while negative values would rotate left. Returns a new array with the rotated elements.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReadonlyArray.ts.md#2025-04-23_snippet_50\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const rotate: (n: number) => <A>(as: readonly A[]) => readonly A[]\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport { rotate } from 'fp-ts/ReadonlyArray'\n\nassert.deepStrictEqual(rotate(2)([1, 2, 3, 4, 5]), [4, 5, 1, 2, 3])\n```\n\n----------------------------------------\n\nTITLE: Implementing Random Array Element Selector in TypeScript\nDESCRIPTION: Function that takes a non-empty array and returns an IO monad containing a randomly selected element from that array.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Random.ts.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const randomElem: <A>(as: ReadonlyNonEmptyArray<A>) => IO<A>\n```\n\n----------------------------------------\n\nTITLE: Implementing Tree Interface in TypeScript\nDESCRIPTION: Defines the Tree interface with a value of type A and a forest of subtrees. This represents the structure of a multi-way tree.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Tree.ts.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface Tree<A> {\n  readonly value: A\n  readonly forest: Forest<A>\n}\n```\n\n----------------------------------------\n\nTITLE: Getting All But Last Element of Array with fp-ts\nDESCRIPTION: Returns all but the last element of an array as a new array wrapped in an Option. Returns Some containing the new array if the original array has elements, or None if empty.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReadonlyArray.ts.md#2025-04-23_snippet_35\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const init: <A>(as: readonly A[]) => Option<readonly A[]>\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport { init } from 'fp-ts/ReadonlyArray'\nimport { some, none } from 'fp-ts/Option'\n\nassert.deepStrictEqual(init([1, 2, 3]), some([1, 2]))\nassert.deepStrictEqual(init([]), none)\n```\n\n----------------------------------------\n\nTITLE: Reverse Function for Ord in TypeScript\nDESCRIPTION: Creates a new Ord instance with the comparison logic reversed. Useful for changing ascending to descending ordering.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Ord.ts.md#2025-04-23_snippet_21\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const reverse: <A>(O: Ord<A>) => Ord<A>\n```\n\n----------------------------------------\n\nTITLE: Partitioning Records with index-based predicates in fp-ts\nDESCRIPTION: Partitions a Record into two parts according to a predicate that takes both the key and value. Returns a Separated object containing left and right Records.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Record.ts.md#2025-04-23_snippet_42\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare function partitionWithIndex<K extends string, A, B extends A>(\n  refinementWithIndex: RefinementWithIndex<K, A, B>\n): (fa: Record<K, A>) => Separated<Record<string, A>, Record<string, B>>\nexport declare function partitionWithIndex<K extends string, A>(\n  predicateWithIndex: PredicateWithIndex<K, A>\n): <B extends A>(fb: Record<K, B>) => Separated<Record<string, B>, Record<string, B>>\nexport declare function partitionWithIndex<K extends string, A>(\n  predicateWithIndex: PredicateWithIndex<K, A>\n): (fa: Record<K, A>) => Separated<Record<string, A>, Record<string, A>>\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport { partitionWithIndex } from 'fp-ts/Record'\n\nassert.deepStrictEqual(\n  partitionWithIndex((key: string, a: number) => key.length <= 1 && a > 0)({ a: -1, b: 2, ccc: 7 }),\n  {\n    left: {\n      a: -1,\n      ccc: 7,\n    },\n    right: {\n      b: 2,\n    },\n  }\n)\n```\n\n----------------------------------------\n\nTITLE: Implementing filterOrElse in TaskEither for TypeScript\nDESCRIPTION: Function that filters TaskEither values based on a predicate or refinement, transforming the value to an error if the condition fails. Multiple overloads are provided to support various use cases including refinements and predicates.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/TaskEither.ts.md#2025-04-23_snippet_30\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const filterOrElse: {\n  <E, A, B extends A>(refinement: Refinement<A, B>, onFalse: (a: A) => E): (ma: TaskEither<E, A>) => TaskEither<E, B>\n  <E, A>(predicate: Predicate<A>, onFalse: (a: A) => E): <B extends A>(mb: TaskEither<E, B>) => TaskEither<E, B>\n  <E, A>(predicate: Predicate<A>, onFalse: (a: A) => E): (ma: TaskEither<E, A>) => TaskEither<E, A>\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing fromIOEitherK for IOEither Lifting\nDESCRIPTION: Transforms a function returning an IOEither into a function returning a ReaderTaskEither, lifting synchronous side-effect computations with error handling.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReaderTaskEither.ts.md#2025-04-23_snippet_63\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const fromIOEitherK: <E, A extends readonly unknown[], B>(\n  f: (...a: A) => IOEither<E, B>\n) => <R = unknown>(...a: A) => ReaderTaskEither<R, E, B>\n```\n\n----------------------------------------\n\nTITLE: Implementing ChainRec1 Interface for First-Order Types in TypeScript\nDESCRIPTION: Defines the ChainRec1 interface for first-order type constructors. It extends Chain1 and provides chainRec for stack-safe recursion with Kind<F, _> types.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ChainRec.ts.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface ChainRec1<F extends URIS> extends Chain1<F> {\n  readonly chainRec: <A, B>(a: A, f: (a: A) => Kind<F, Either<A, B>>) => Kind<F, B>\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Monoid Instances for Predicates in TypeScript\nDESCRIPTION: Defines functions to create Monoid instances for predicates, both for 'all' and 'any' operations. These allow predicates to be combined using monoid operations.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Predicate.ts.md#2025-04-23_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare const getMonoidAll: <A = never>() => Monoid<Predicate<A>>\n```\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare const getMonoidAny: <A = never>() => Monoid<Predicate<A>>\n```\n\n----------------------------------------\n\nTITLE: Using Monoid to Create Complex Sorting Logic in TypeScript\nDESCRIPTION: Example of using the Monoid instance for Ord to create complex sorting logic with multiple criteria. It demonstrates sorting users by name, age, and remember me flag.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Ord.ts.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { sort } from 'fp-ts/Array'\nimport { contramap, reverse, getMonoid } from 'fp-ts/Ord'\nimport * as S from 'fp-ts/string'\nimport * as B from 'fp-ts/boolean'\nimport { pipe } from 'fp-ts/function'\nimport { concatAll } from 'fp-ts/Monoid'\nimport * as N from 'fp-ts/number'\n\ninterface User {\n  readonly id: number\n  readonly name: string\n  readonly age: number\n  readonly rememberMe: boolean\n}\n\nconst byName = pipe(\n  S.Ord,\n  contramap((p: User) => p.name)\n)\n\nconst byAge = pipe(\n  N.Ord,\n  contramap((p: User) => p.age)\n)\n\nconst byRememberMe = pipe(\n  B.Ord,\n  contramap((p: User) => p.rememberMe)\n)\n\nconst M = getMonoid<User>()\n\nconst users: Array<User> = [\n  { id: 1, name: 'Guido', age: 47, rememberMe: false },\n  { id: 2, name: 'Guido', age: 46, rememberMe: true },\n  { id: 3, name: 'Giulio', age: 44, rememberMe: false },\n  { id: 4, name: 'Giulio', age: 44, rememberMe: true },\n]\n\n// sort by name, then by age, then by `rememberMe`\nconst O1 = concatAll(M)([byName, byAge, byRememberMe])\nassert.deepStrictEqual(sort(O1)(users), [\n  { id: 3, name: 'Giulio', age: 44, rememberMe: false },\n  { id: 4, name: 'Giulio', age: 44, rememberMe: true },\n  { id: 2, name: 'Guido', age: 46, rememberMe: true },\n  { id: 1, name: 'Guido', age: 47, rememberMe: false },\n])\n\n// now `rememberMe = true` first, then by name, then by age\nconst O2 = concatAll(M)([reverse(byRememberMe), byName, byAge])\nassert.deepStrictEqual(sort(O2)(users), [\n  { id: 4, name: 'Giulio', age: 44, rememberMe: true },\n  { id: 2, name: 'Guido', age: 46, rememberMe: true },\n  { id: 3, name: 'Giulio', age: 44, rememberMe: false },\n  { id: 1, name: 'Guido', age: 47, rememberMe: false },\n])\n```\n\n----------------------------------------\n\nTITLE: Implementing matchRight for ReadonlyNonEmptyArray in TypeScript\nDESCRIPTION: Breaks a ReadonlyNonEmptyArray into its initial elements and the last element.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReadonlyNonEmptyArray.ts.md#2025-04-23_snippet_23\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const matchRight: <A, B>(f: (init: readonly A[], last: A) => B) => (as: ReadonlyNonEmptyArray<A>) => B\n```\n\n----------------------------------------\n\nTITLE: StateM2C Interface Definition in TypeScript\nDESCRIPTION: Interface definition for State Monad Transformer with URIS2 and error type E. Provides standard monad operations like map, of, ap, chain along with state-specific operations.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/StateT.ts.md#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface StateM2C<M extends URIS2, E> {\n  readonly map: <S, A, B>(fa: StateT2<M, S, E, A>, f: (a: A) => B) => StateT2<M, S, E, B>\n  readonly of: <S, A>(a: A) => StateT2<M, S, E, A>\n  readonly ap: <S, A, B>(fab: StateT2<M, S, E, (a: A) => B>, fa: StateT2<M, S, E, A>) => StateT2<M, S, E, B>\n  readonly chain: <S, A, B>(fa: StateT2<M, S, E, A>, f: (a: A) => StateT2<M, S, E, B>) => StateT2<M, S, E, B>\n  readonly get: <S>() => StateT2<M, S, E, S>\n  readonly put: <S>(s: S) => StateT2<M, S, E, void>\n  readonly modify: <S>(f: (s: S) => S) => StateT2<M, S, E, void>\n  readonly gets: <S, A>(f: (s: S) => A) => StateT2<M, S, E, A>\n  readonly fromState: <S, A>(fa: State<S, A>) => StateT2<M, S, E, A>\n  readonly fromM: <S, A>(ma: Kind2<M, E, A>) => StateT2<M, S, E, A>\n  readonly evalState: <S, A>(ma: StateT2<M, S, E, A>, s: S) => Kind2<M, E, A>\n  readonly execState: <S, A>(ma: StateT2<M, S, E, A>, s: S) => Kind2<M, E, S>\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing chainFirstReaderEitherKW in TypeScript for ReaderTaskEither\nDESCRIPTION: Widening version of chainFirstReaderEitherK that allows for different environment and error types. It merges both environment types (R1 & R2) and error types (E1 | E2) while preserving the original value.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReaderTaskEither.ts.md#2025-04-23_snippet_27\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const chainFirstReaderEitherKW: <R2, E2, A, B>(\n  f: (a: A) => ReaderEither<R2, E2, B>\n) => <R1, E1>(ma: ReaderTaskEither<R1, E1, A>) => ReaderTaskEither<R1 & R2, E2 | E1, A>\n```\n\n----------------------------------------\n\nTITLE: Implementing match for Simple Pattern Matching\nDESCRIPTION: Pattern matches on Either structure using pure functions, transforming both success and error values to a common type within a ReaderTask context.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReaderTaskEither.ts.md#2025-04-23_snippet_80\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const match: <E, B, A>(\n  onLeft: (e: E) => B,\n  onRight: (a: A) => B\n) => <R>(ma: ReaderTaskEither<R, E, A>) => RT.ReaderTask<R, B>\n```\n\n----------------------------------------\n\nTITLE: Splitting NonEmptyArray in TypeScript\nDESCRIPTION: Splits a NonEmptyArray into two pieces, with the first piece having a maximum of n elements. Returns a tuple of two arrays.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/NonEmptyArray.ts.md#2025-04-23_snippet_18\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const splitAt: (n: number) => <A>(as: NonEmptyArray<A>) => [NonEmptyArray<A>, A[]]\n```\n\n----------------------------------------\n\nTITLE: Creating Mutable References with newIORef in TypeScript\nDESCRIPTION: Function to create a new IORef instance with an initial value. It returns an IO monad containing the IORef.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/IORef.ts.md#2025-04-23_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare function newIORef<A>(a: A): IO<IORef<A>>\n```\n\n----------------------------------------\n\nTITLE: Implementing Random Number Generator in TypeScript\nDESCRIPTION: Wrapper function around Math.random() that returns an IO monad containing a random number between 0 (inclusive) and 1 (exclusive).\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Random.ts.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const random: IO<number>\n```\n\n----------------------------------------\n\nTITLE: Implementing chunksOf for ReadonlyNonEmptyArray in TypeScript\nDESCRIPTION: Splits a ReadonlyNonEmptyArray into length-n pieces. The last piece will be shorter if n does not evenly divide the length of the array.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReadonlyNonEmptyArray.ts.md#2025-04-23_snippet_36\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const chunksOf: (\n  n: number\n) => <A>(as: ReadonlyNonEmptyArray<A>) => ReadonlyNonEmptyArray<ReadonlyNonEmptyArray<A>>\n```\n\n----------------------------------------\n\nTITLE: Unzipping NonEmptyArray of Tuples in TypeScript\nDESCRIPTION: Transforms a NonEmptyArray of tuples into a tuple of two NonEmptyArrays, separating the first and second elements of each tuple.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/NonEmptyArray.ts.md#2025-04-23_snippet_24\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const unzip: <A, B>(abs: NonEmptyArray<[A, B]>) => [NonEmptyArray<A>, NonEmptyArray<B>]\n```\n\n----------------------------------------\n\nTITLE: Do Notation with IO Monad\nDESCRIPTION: Demonstrates the same pattern using IO monad instead of Task, showing how to work with different effect types.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/guides/do-notation.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { pipe } from 'fp-ts/function'\nimport * as IO from 'fp-ts/IO'\n\ndeclare const print: (s: string) => IO.IO<void>\ndeclare const readLine: IO.IO<string>\n\nconst mainDo: IO.IO<{ x: string; y: string }> = pipe(\n  IO.Do,\n  IO.bind('x', () => readLine),\n  IO.bind('y', () => readLine),\n  IO.tap(({ x }) => print(x)),\n  IO.tap(({ y }) => print(y))\n)\n```\n\n----------------------------------------\n\nTITLE: Pattern Matching on Boolean Values\nDESCRIPTION: Implements pattern matching functionality for boolean values, allowing different handlers for true and false cases\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/boolean.ts.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const match: <A>(onFalse: LazyArg<A>, onTrue: LazyArg<A>) => (value: boolean) => A\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport { some, map } from 'fp-ts/Option'\nimport { pipe } from 'fp-ts/function'\nimport { match } from 'fp-ts/boolean'\n\nassert.deepStrictEqual(\n  pipe(\n    some(true),\n    map(\n      match(\n        () => 'false',\n        () => 'true'\n      )\n    )\n  ),\n  some('true')\n)\n```\n\n----------------------------------------\n\nTITLE: Getting Tail of ReadonlyArray in TypeScript\nDESCRIPTION: Retrieves all but the first element of a readonly array, creating a new array, or returns None if the array is empty.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReadonlyArray.ts.md#2025-04-23_snippet_59\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const tail: <A>(as: readonly A[]) => Option<readonly A[]>\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport { tail } from 'fp-ts/ReadonlyArray'\nimport { some, none } from 'fp-ts/Option'\n\nassert.deepStrictEqual(tail([1, 2, 3]), some([2, 3]))\nassert.deepStrictEqual(tail([]), none)\n```\n\n----------------------------------------\n\nTITLE: Mapping Operations for Maps in TypeScript\nDESCRIPTION: Functions for mapping over Map values including the standard map function, mapWithIndex for transforming with key access, and flap for applying a value to a Map of functions.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Map.ts.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const flap: <A>(a: A) => <E, B>(fab: Map<E, (a: A) => B>) => Map<E, B>\n```\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const map: <A, B>(f: (a: A) => B) => <K>(fa: Map<K, A>) => Map<K, B>\n```\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const mapWithIndex: <K, A, B>(f: (k: K, a: A) => B) => (fa: Map<K, A>) => Map<K, B>\n```\n\n----------------------------------------\n\nTITLE: Map Key-Value Removal\nDESCRIPTION: Function to remove a key-value pair from a Map, returning both the value and updated Map.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Map.ts.md#2025-04-23_snippet_17\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare function pop<K>(E: Eq<K>): (k: K) => <A>(m: Map<K, A>) => Option<[A, Map<K, A>]>\n```\n\n----------------------------------------\n\nTITLE: Implementing FlatMapIO Function for IOOption in TypeScript\nDESCRIPTION: Defines the flatMapIO function for IOOption. It allows chaining IO operations on IOOption values.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/IOOption.ts.md#2025-04-23_snippet_41\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const flatMapIO: {\n  <A, B>(f: (a: A) => I.IO<B>): (self: IOOption<A>) => IOOption<B>\n  <A, B>(self: IOOption<A>, f: (a: A) => I.IO<B>): IOOption<B>\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing flatMapIOEither for IOEither Chaining\nDESCRIPTION: Chains a function that returns an IOEither with a ReaderTaskEither, allowing synchronous side-effect operations with error handling to be composed with ReaderTaskEither operations.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReaderTaskEither.ts.md#2025-04-23_snippet_87\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const flatMapIOEither: {\n  <A, E2, B>(f: (a: A) => IOEither<E2, B>): <R, E1>(self: ReaderTaskEither<R, E1, A>) => ReaderTaskEither<R, E2 | E1, B>\n  <R, E1, A, E2, B>(self: ReaderTaskEither<R, E1, A>, f: (a: A) => IOEither<E2, B>): ReaderTaskEither<R, E1 | E2, B>\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Map Operation for ReaderT\nDESCRIPTION: Function implementing the functor map operation for the Reader transformer, allowing transformation of values while preserving the Reader and target monad context.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReaderT.ts.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare function map<F extends URIS4>(\n  F: Functor4<F>\n): <A, B>(f: (a: A) => B) => <R, S, FR, FE>(fa: Reader<R, Kind4<F, S, FR, FE, A>>) => Reader<R, Kind4<F, S, FR, FE, B>>\n```\n\n----------------------------------------\n\nTITLE: Implementing ChainEitherK Function in TypeScript\nDESCRIPTION: Defines a utility function for chaining operations that return Either values, supporting different URI levels. This allows for composing operations that may fail with error handling built in.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/FromEither.ts.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare function chainEitherK<M extends URIS4>(\n  F: FromEither4<M>,\n  M: Chain4<M>\n): <A, E, B>(f: (a: A) => Either<E, B>) => <S, R>(ma: Kind4<M, S, R, E, A>) => Kind4<M, S, R, E, B>\nexport declare function chainEitherK<M extends URIS3>(\n  F: FromEither3<M>,\n  M: Chain3<M>\n): <A, E, B>(f: (a: A) => Either<E, B>) => <R>(ma: Kind3<M, R, E, A>) => Kind3<M, R, E, B>\nexport declare function chainEitherK<M extends URIS3, E>(\n  F: FromEither3C<M, E>,\n  M: Chain3C<M, E>\n): <A, B>(f: (a: A) => Either<E, B>) => <R>(ma: Kind3<M, R, E, A>) => Kind3<M, R, E, B>\nexport declare function chainEitherK<M extends URIS2>(\n  F: FromEither2<M>,\n  M: Chain2<M>\n): <A, E, B>(f: (a: A) => Either<E, B>) => (ma: Kind2<M, E, A>) => Kind2<M, E, B>\nexport declare function chainEitherK<M extends URIS2, E>(\n  F: FromEither2C<M, E>,\n  M: Chain2C<M, E>\n): <A, B>(f: (a: A) => Either<E, B>) => (ma: Kind2<M, E, A>) => Kind2<M, E, B>\nexport declare function chainEitherK<M extends URIS>(\n  F: FromEither1<M>,\n  M: Chain1<M>\n): <E, A, B>(f: (a: A) => Either<E, B>) => (ma: Kind<M, A>) => Kind<M, B>\nexport declare function chainEitherK<M>(\n  F: FromEither<M>,\n  M: Chain<M>\n): <A, E, B>(f: (a: A) => Either<E, B>) => (ma: HKT2<M, E, A>) => HKT2<M, E, B>\n```\n\n----------------------------------------\n\nTITLE: Accessing Head Element in ReadonlyNonEmptyArray in TypeScript\nDESCRIPTION: Function that returns the first element of a ReadonlyNonEmptyArray. Since the array is non-empty, this operation is guaranteed to be safe.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReadonlyNonEmptyArray.ts.md#2025-04-23_snippet_45\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const head: <A>(as: ReadonlyNonEmptyArray<A>) => A\n```\n\n----------------------------------------\n\nTITLE: Implementing fromNullableK Function for Lifting Nullable Functions in TypeScript\nDESCRIPTION: Creates a function that transforms a nullable-returning function into a TaskEither-returning function, handling null/undefined values with the provided error.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/TaskEither.ts.md#2025-04-23_snippet_43\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const fromNullableK: <E>(\n  e: E\n) => <A extends readonly unknown[], B>(\n  f: (...a: A) => B | null | undefined\n) => (...a: A) => TaskEither<E, NonNullable<B>>\n```\n\n----------------------------------------\n\nTITLE: Using matchE and match with TaskOption\nDESCRIPTION: Demonstrates the difference between match and matchE functions with TaskOption. The 'E' suffix indicates that the function returns an effect (Task) on match.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/guides/code-conventions.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as T from 'fp-ts/Task'\nimport * as TO from 'fp-ts/TaskOption'\nimport { pipe } from 'fp-ts/function'\n\nconst value = TO.of('hello')\n\n// T.Task<number>\npipe(\n  value,\n  TO.match(\n    () => 0,\n    (str) => str.length\n  )\n)\n\n// T.Task<number>\npipe(\n  value,\n  TO.matchE(\n    () => T.of(0),\n    (str) => T.of(str.length)\n  )\n)\n```\n\n----------------------------------------\n\nTITLE: Using Pipe Function Example\nDESCRIPTION: Demonstrates practical usage of the pipe function to compose string length calculation and number doubling operations.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/function.ts.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { pipe } from 'fp-ts/function'\n\nconst len = (s: string): number => s.length\nconst double = (n: number): number => n * 2\n\n// without pipe\nassert.strictEqual(double(len('aaa')), 6)\n\n// with pipe\nassert.strictEqual(pipe('aaa', len, double), 6)\n```\n\n----------------------------------------\n\nTITLE: Testing Records with predicates in fp-ts\nDESCRIPTION: Tests if at least one value in a Record satisfies the given predicate function. Returns true if any value meets the condition, otherwise false.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Record.ts.md#2025-04-23_snippet_49\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const some: <A>(predicate: (a: A) => boolean) => (r: Record<string, A>) => boolean\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport { some } from 'fp-ts/Record'\n\nassert.deepStrictEqual(some((n: number) => n >= 0)({ a: 1, b: -2 }), true)\nassert.deepStrictEqual(some((n: number) => n >= 0)({ a: -1, b: -2 }), false)\n```\n\n----------------------------------------\n\nTITLE: Replicating a Value in a ReadonlyArray in TypeScript\nDESCRIPTION: Creates a ReadonlyArray containing a value repeated a specified number of times.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReadonlyArray.ts.md#2025-04-23_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { replicate } from 'fp-ts/ReadonlyArray'\n\nassert.deepStrictEqual(replicate(3, 'a'), ['a', 'a', 'a'])\n```\n\n----------------------------------------\n\nTITLE: Sorting ReadonlyArray Elements in TypeScript\nDESCRIPTION: Sorts the elements of a readonly array in increasing order, creating a new array. It uses an Ord instance for comparison.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReadonlyArray.ts.md#2025-04-23_snippet_55\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const sort: <B>(O: Ord<B>) => <A extends B>(as: readonly A[]) => readonly A[]\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport { sort } from 'fp-ts/ReadonlyArray'\nimport * as N from 'fp-ts/number'\n\nassert.deepStrictEqual(sort(N.Ord)([3, 2, 1]), [1, 2, 3])\n```\n\n----------------------------------------\n\nTITLE: Extracting Tail from NonEmptyArray in TypeScript\nDESCRIPTION: Returns the tail (all elements except the first) of a NonEmptyArray as a regular array.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/NonEmptyArray.ts.md#2025-04-23_snippet_19\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const tail: <A>(as: NonEmptyArray<A>) => A[]\n```\n\n----------------------------------------\n\nTITLE: Zipping Two ReadonlyNonEmptyArrays in TypeScript\nDESCRIPTION: Function that combines two ReadonlyNonEmptyArrays into a single ReadonlyNonEmptyArray of tuples, pairing elements with the same index from both arrays.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReadonlyNonEmptyArray.ts.md#2025-04-23_snippet_70\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare function zip<B>(\n  bs: ReadonlyNonEmptyArray<B>\n): <A>(as: ReadonlyNonEmptyArray<A>) => ReadonlyNonEmptyArray<readonly [A, B]>\nexport declare function zip<A, B>(\n  as: ReadonlyNonEmptyArray<A>,\n  bs: ReadonlyNonEmptyArray<B>\n): ReadonlyNonEmptyArray<readonly [A, B]>\n```\n\n----------------------------------------\n\nTITLE: Conversion Functions for StateReaderTaskEither\nDESCRIPTION: Functions for converting between different monad types and StateReaderTaskEither. Includes conversions from Either, IO, Task, Reader, and their variants.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/StateReaderTaskEither.ts.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const fromEither: <E, A, S, R = unknown>(fa: E.Either<E, A>) => StateReaderTaskEither<S, R, E, A>\n\nexport declare const fromIO: <A, S, R = unknown, E = never>(fa: IO<A>) => StateReaderTaskEither<S, R, E, A>\n\nexport declare const fromTask: <A, S, R = unknown, E = never>(fa: Task<A>) => StateReaderTaskEither<S, R, E, A>\n\nexport declare const fromReader: <R, A, S, E = never>(fa: R.Reader<R, A>) => StateReaderTaskEither<S, R, E, A>\n```\n\n----------------------------------------\n\nTITLE: Reducing Set Elements in TypeScript\nDESCRIPTION: Reduces the elements of a set to a single value using a provided function and initial value. Requires an ordering function for traversal.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Set.ts.md#2025-04-23_snippet_4\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare const reduce: <A>(O: Ord<A>) => <B>(b: B, f: (b: B, a: A) => B) => (fa: Set<A>) => B\n```\n\n----------------------------------------\n\nTITLE: Implementing Element Search in ReadonlyArray in TypeScript\nDESCRIPTION: Defines functions to find elements in a ReadonlyArray that satisfy a predicate or to find elements using a mapping function.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReadonlyArray.ts.md#2025-04-23_snippet_30\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare function findFirst<A, B extends A>(refinement: Refinement<A, B>): (as: ReadonlyArray<A>) => Option<B>\nexport declare function findFirst<A>(predicate: Predicate<A>): <B extends A>(bs: ReadonlyArray<B>) => Option<B>\nexport declare function findFirst<A>(predicate: Predicate<A>): (as: ReadonlyArray<A>) => Option<A>\n\nexport declare const findFirstMap: <A, B>(f: (a: A) => Option<B>) => (as: readonly A[]) => Option<B>\n\nexport declare const findIndex: <A>(predicate: Predicate<A>) => (as: readonly A[]) => Option<number>\n\nexport declare function findLast<A, B extends A>(refinement: Refinement<A, B>): (as: ReadonlyArray<A>) => Option<B>\nexport declare function findLast<A>(predicate: Predicate<A>): <B extends A>(bs: ReadonlyArray<B>) => Option<B>\nexport declare function findLast<A>(predicate: Predicate<A>): (as: ReadonlyArray<A>) => Option<A>\n```\n\n----------------------------------------\n\nTITLE: Creating Date Objects with IO Monad in TypeScript\nDESCRIPTION: Function to create a new Date object wrapped in an IO monad. This allows for referentially transparent date creation.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Date.ts.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const create: IO<Date>\n```\n\n----------------------------------------\n\nTITLE: Using fromEitherK and chainEitherK for Composition\nDESCRIPTION: Demonstrates composing a parser function with an IOEither value using both fromEitherK and the more concise chainEitherK helper.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/guides/code-conventions.md#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport { pipe } from 'fp-ts/function'\n\npipe(input, IE.chain(IE.fromEitherK(parse)))() // left(new Error('cannot decode \"foo\" to number'))\n\n// or with less boilerplate\npipe(input, IE.chainEitherK(parse))() // left(new Error('cannot decode \"foo\" to number'))\n```\n\n----------------------------------------\n\nTITLE: Defining Separated Interface in TypeScript\nDESCRIPTION: Defines the Separated interface, which represents a result of separating a whole into two parts. It has two readonly properties: left of type E and right of type A.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Separated.ts.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ninterface Separated<E, A> {\n  readonly left: E\n  readonly right: A\n}\n```\n\n----------------------------------------\n\nTITLE: Defining PartitionWithIndex3 Interface in TypeScript\nDESCRIPTION: Interface for partitioning 3-kind type constructors with index support. Handles both refinement and predicate operations returning separated results.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/FilterableWithIndex.ts.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface PartitionWithIndex3<F extends URIS3, I> {\n  <R, E, A, B extends A>(fa: Kind3<F, R, E, A>, refinementWithIndex: RefinementWithIndex<I, A, B>): Separated<\n    Kind3<F, R, E, A>,\n    Kind3<F, R, E, B>\n  >\n  <R, E, A>(fa: Kind3<F, R, E, A>, predicateWithIndex: PredicateWithIndex<I, A>): Separated<\n    Kind3<F, R, E, A>,\n    Kind3<F, R, E, A>\n  >\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing chainOptionK in TypeScript for ReaderTaskEither\nDESCRIPTION: Function to handle Option values in a chain. It takes a lazy error generator and a function that returns an Option<B>, and returns a function that transforms a ReaderTaskEither<R, E, A> into a ReaderTaskEither<R, E, B>.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReaderTaskEither.ts.md#2025-04-23_snippet_42\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const chainOptionK: <E>(\n  onNone: LazyArg<E>\n) => <A, B>(f: (a: A) => Option<B>) => <R>(ma: ReaderTaskEither<R, E, A>) => ReaderTaskEither<R, E, B>\n```\n\n----------------------------------------\n\nTITLE: Implementing flatMapEither Function for Chaining with Either in TypeScript\nDESCRIPTION: Chains a TaskEither with an Either-returning function, applying the function to the Right value and flattening the result, with support for pipeable and data-last styles.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/TaskEither.ts.md#2025-04-23_snippet_67\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const flatMapEither: {\n  <A, E2, B>(f: (a: A) => E.Either<E2, B>): <E1>(self: TaskEither<E1, A>) => TaskEither<E2 | E1, B>\n  <E1, A, E2, B>(self: TaskEither<E1, A>, f: (a: A) => E.Either<E2, B>): TaskEither<E1 | E2, B>\n}\n```\n\n----------------------------------------\n\nTITLE: Defining URI for Predicate in TypeScript\nDESCRIPTION: Declares a URI constant and type alias for the Predicate type. This is used for type-level programming and identification of the Predicate type.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Predicate.ts.md#2025-04-23_snippet_3\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare const URI: 'Predicate'\n```\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport type URI = typeof URI\n```\n\n----------------------------------------\n\nTITLE: Using strict equality for unknown types in TypeScript\nDESCRIPTION: Provides an Eq instance that uses strict equality (===) for comparing values of unknown type.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Eq.ts.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const eqStrict: Eq<unknown>\n```\n\n----------------------------------------\n\nTITLE: Type Class Instances for ReadonlyArray\nDESCRIPTION: Type class instances implementing functional programming abstractions for readonly arrays.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReadonlyArray.ts.md#2025-04-23_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const Functor: Functor1<'ReadonlyArray'>\n```\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const Monad: Monad1<'ReadonlyArray'>\n```\n\n----------------------------------------\n\nTITLE: Defining error console function in fp-ts\nDESCRIPTION: Defines an error function that takes a value of any type and returns an IO<void>. It wraps the console.error method in the functional IO monad pattern.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Console.ts.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const error: <A>(a: A) => IO<void>\n```\n\n----------------------------------------\n\nTITLE: Basic Natural Transformation Interface Definition\nDESCRIPTION: Defines the base natural transformation interface for mapping between type constructors F and G\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/NaturalTransformation.ts.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface NaturalTransformation<F, G> {\n  <A>(fa: HKT<F, A>): HKT<G, A>\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing split Utility Function\nDESCRIPTION: This function composes a value acting on a tuple from two values, each acting on one of the components of the tuple. It's similar to bi-map for the bi-functor instance of tuple.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Strong.ts.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare function split<F extends URIS4>(\n  S: Strong4<F>,\n  C: Category4<F>\n): <S, R, A, B, C, D>(pab: Kind4<F, S, R, A, B>, pcd: Kind4<F, S, R, C, D>) => Kind4<F, S, R, [A, C], [B, D]>\n```\n\n----------------------------------------\n\nTITLE: Combining Refinements with OR\nDESCRIPTION: Combines two refinements using logical OR operation.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Refinement.ts.md#2025-04-23_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const or: <A, C extends A>(\n  second: Refinement<A, C>\n) => <B extends A>(first: Refinement<A, B>) => Refinement<A, C | B>\n```\n\n----------------------------------------\n\nTITLE: Defining ReaderEither Interface in TypeScript\nDESCRIPTION: Defines the ReaderEither interface, which represents a computation that depends on some environment R and may fail with an error E or succeed with a value A.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReaderEither.ts.md#2025-04-23_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport interface ReaderEither<R, E, A> {\n  (r: R): E.Either<E, A>\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Function Pipe in TypeScript\nDESCRIPTION: Function pipe implementation that allows chaining multiple functions together, passing the output of one function as input to the next. Supports up to 20 functions in the pipeline.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/function.ts.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare function pipe<A>(a: A): A\nexport declare function pipe<A, B>(a: A, ab: (a: A) => B): B\nexport declare function pipe<A, B, C>(a: A, ab: (a: A) => B, bc: (b: B) => C): C\n// ... additional overloads\n```\n\n----------------------------------------\n\nTITLE: Tree Visualization Functions\nDESCRIPTION: Functions for creating 2-dimensional string representations of trees and forests.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Tree.ts.md#2025-04-23_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare function drawForest(forest: Forest<string>): string\n```\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare function drawTree(tree: Tree<string>): string\n```\n\n----------------------------------------\n\nTITLE: Implementing utility functions for IOEither\nDESCRIPTION: Collection of utility functions including ApT, ap, apFirst, apFirstW, apSecond, apSecondW, apW, bracket, bracketW, swap, and throwError for IOEither operations.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/IOEither.ts.md#2025-04-23_snippet_14\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const ApT: IOEither<never, readonly []>\n```\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const ap: <E, A>(fa: IOEither<E, A>) => <B>(fab: IOEither<E, (a: A) => B>) => IOEither<E, B>\n```\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const bracket: <E, A, B>(\n  acquire: IOEither<E, A>,\n  use: (a: A) => IOEither<E, B>,\n  release: (a: A, e: E.Either<E, B>) => IOEither<E, void>\n) => IOEither<E, B>\n```\n\n----------------------------------------\n\nTITLE: Taking Left Elements While Condition in ReadonlyArray\nDESCRIPTION: Calculates the longest initial subarray for which all elements satisfy the specified predicate, creating a new array.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReadonlyArray.ts.md#2025-04-23_snippet_61\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare function takeLeftWhile<A, B extends A>(\n  refinement: Refinement<A, B>\n): (as: ReadonlyArray<A>) => ReadonlyArray<B>\nexport declare function takeLeftWhile<A>(\n  predicate: Predicate<A>\n): <B extends A>(bs: ReadonlyArray<B>) => ReadonlyArray<B>\nexport declare function takeLeftWhile<A>(predicate: Predicate<A>): (as: ReadonlyArray<A>) => ReadonlyArray<A>\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport { takeLeftWhile } from 'fp-ts/ReadonlyArray'\n\nassert.deepStrictEqual(takeLeftWhile((n: number) => n % 2 === 0)([2, 4, 3, 6]), [2, 4])\n```\n\n----------------------------------------\n\nTITLE: Implementing liftOption for Option Value Handling\nDESCRIPTION: Enhanced version of fromOptionK that allows for dynamic error generation based on the input parameters, providing more context-aware error handling for Option types.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReaderTaskEither.ts.md#2025-04-23_snippet_73\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const liftOption: <A extends readonly unknown[], B, E>(\n  f: (...a: A) => Option<B>,\n  onNone: (...a: A) => E\n) => <R>(...a: A) => ReaderTaskEither<R, E, B>\n```\n\n----------------------------------------\n\nTITLE: Implementing Map Function for IOOption in TypeScript\nDESCRIPTION: Defines the map function for IOOption. It transforms the value inside an IOOption using a provided function.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/IOOption.ts.md#2025-04-23_snippet_32\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const map: <A, B>(f: (a: A) => B) => (fa: IOOption<A>) => IOOption<B>\n```\n\n----------------------------------------\n\nTITLE: Implementing sequenceArray for StateReaderTaskEither in TypeScript\nDESCRIPTION: Provides sequenceArray function that transforms an array of StateReaderTaskEither values into a single StateReaderTaskEither of an array, equivalent to ReadonlyArray#sequence with Applicative.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/StateReaderTaskEither.ts.md#2025-04-23_snippet_54\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare const sequenceArray: <S, R, E, A>(\n  arr: readonly StateReaderTaskEither<S, R, E, A>[]\n) => StateReaderTaskEither<S, R, E, readonly A[]>\n```\n\n----------------------------------------\n\nTITLE: IOOption Tap Implementation - TypeScript\nDESCRIPTION: Compose computations in sequence, using the return value of one computation to determine the next computation while keeping only the result of the first.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/IOOption.ts.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const tap: {\n  <A, _>(self: IOOption<A>, f: (a: A) => IOOption<_>): IOOption<A>\n  <A, _>(f: (a: A) => IOOption<_>): (self: IOOption<A>) => IOOption<A>\n}\n```\n\n----------------------------------------\n\nTITLE: Set Difference Operation Example\nDESCRIPTION: Example showing how to compute the difference between two sets using the difference function\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReadonlySet.ts.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { difference } from 'fp-ts/ReadonlySet'\nimport * as N from 'fp-ts/number'\nimport { pipe } from 'fp-ts/function'\n\nassert.deepStrictEqual(pipe(new Set([1, 2]), difference(N.Eq)(new Set([1, 3]))), new Set([2]))\n```\n\n----------------------------------------\n\nTITLE: Creating Applicative instance with custom error handling for Either in TypeScript\nDESCRIPTION: Defines a function to create an Applicative instance that concatenates all errors using a provided Semigroup.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Either.ts.md#2025-04-23_snippet_7\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare const getApplicativeValidation: <E>(SE: Semigroup<E>) => Applicative2C<'Either', E>\n```\n\n----------------------------------------\n\nTITLE: Implementing bind Utility Function for Chain\nDESCRIPTION: A utility function for binding a computation to a name in a monadic context, with overloads for different arities.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Chain.ts.md#2025-04-23_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare function bind<M extends URIS4>(\n  M: Chain4<M>\n): <N extends string, A, S, R, E, B>(\n  name: Exclude<N, keyof A>,\n  f: (a: A) => Kind4<M, S, R, E, B>\n) => (ma: Kind4<M, S, R, E, A>) => Kind4<M, S, R, E, { readonly [K in keyof A | N]: K extends keyof A ? A[K] : B }>\nexport declare function bind<M extends URIS3>(\n  M: Chain3<M>\n): <N extends string, A, R, E, B>(\n  name: Exclude<N, keyof A>,\n  f: (a: A) => Kind3<M, R, E, B>\n) => (ma: Kind3<M, R, E, A>) => Kind3<M, R, E, { readonly [K in keyof A | N]: K extends keyof A ? A[K] : B }>\nexport declare function bind<M extends URIS3, E>(\n  M: Chain3C<M, E>\n): <N extends string, A, R, B>(\n  name: Exclude<N, keyof A>,\n  f: (a: A) => Kind3<M, R, E, B>\n) => (ma: Kind3<M, R, E, A>) => Kind3<M, R, E, { readonly [K in keyof A | N]: K extends keyof A ? A[K] : B }>\nexport declare function bind<M extends URIS2>(\n  M: Chain2<M>\n): <N extends string, A, E, B>(\n  name: Exclude<N, keyof A>,\n  f: (a: A) => Kind2<M, E, B>\n) => (ma: Kind2<M, E, A>) => Kind2<M, E, { readonly [K in keyof A | N]: K extends keyof A ? A[K] : B }>\nexport declare function bind<M extends URIS2, E>(\n  M: Chain2C<M, E>\n): <N extends string, A, B>(\n  name: Exclude<N, keyof A>,\n  f: (a: A) => Kind2<M, E, B>\n) => (ma: Kind2<M, E, A>) => Kind2<M, E, { readonly [K in keyof A | N]: K extends keyof A ? A[K] : B }>\nexport declare function bind<M extends URIS>(\n  M: Chain1<M>\n): <N extends string, A, B>(\n  name: Exclude<N, keyof A>,\n  f: (a: A) => Kind<M, B>\n) => (ma: Kind<M, A>) => Kind<M, { readonly [K in keyof A | N]: K extends keyof A ? A[K] : B }>\nexport declare function bind<M>(\n  M: Chain<M>\n): <N extends string, A, B>(\n  name: Exclude<N, keyof A>,\n  f: (a: A) => HKT<M, B>\n) => (ma: HKT<M, A>) => HKT<M, { readonly [K in keyof A | N]: K extends keyof A ? A[K] : B }>\n```\n\n----------------------------------------\n\nTITLE: Left-to-Right Scan of Array with Accumulator in fp-ts\nDESCRIPTION: Similar to reduce but carries over the intermediate steps. Returns an array containing the initial value followed by all intermediate accumulator values from left to right.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReadonlyArray.ts.md#2025-04-23_snippet_51\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const scanLeft: <A, B>(b: B, f: (b: B, a: A) => B) => (as: readonly A[]) => RNEA.ReadonlyNonEmptyArray<B>\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport { scanLeft } from 'fp-ts/ReadonlyArray'\n\nassert.deepStrictEqual(scanLeft(10, (b, a: number) => b - a)([1, 2, 3]), [10, 9, 7, 4])\n```\n\n----------------------------------------\n\nTITLE: Computing Intersection of Records\nDESCRIPTION: Creates the intersection of two Records, combining only entries with the same key in both inputs. Uses a provided Magma to combine values for overlapping keys.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Record.ts.md#2025-04-23_snippet_34\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const intersection: <A>(\n  M: Magma<A>\n) => (second: Record<string, A>) => (first: Record<string, A>) => Record<string, A>\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport { intersection } from 'fp-ts/Record'\nimport { Magma } from 'fp-ts/Magma'\n\nconst m1: Magma<number> = { concat: (x: number, y: number) => x + y }\nassert.deepStrictEqual(intersection(m1)({ a: 3, c: 3 })({ a: 1, b: 2 }), { a: 4 })\nconst m2: Magma<number> = { concat: (x: number) => x }\nassert.deepStrictEqual(intersection(m2)({ a: 3, c: 3 })({ a: 1, b: 2 }), { a: 1 })\n```\n\n----------------------------------------\n\nTITLE: Implementing MonoidSum for Numbers\nDESCRIPTION: Monoid instance for number addition with identity element 0.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/number.ts.md#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const MonoidSum: Monoid<number>\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport { MonoidSum } from 'fp-ts/number'\n\nassert.deepStrictEqual(MonoidSum.concat(2, MonoidSum.empty), 2)\n```\n\n----------------------------------------\n\nTITLE: Implementing traverse for ReadonlyNonEmptyArray in TypeScript\nDESCRIPTION: Traverses a ReadonlyNonEmptyArray, applying an effectful function to each element.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReadonlyNonEmptyArray.ts.md#2025-04-23_snippet_30\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const traverse: PipeableTraverse1<'ReadonlyNonEmptyArray'>\n```\n\n----------------------------------------\n\nTITLE: Creating Record from Mapped Foldable Collection\nDESCRIPTION: Creates a Record from a foldable collection, using a mapping function to convert elements to key/value pairs and a Magma to combine values for duplicate keys. Includes utility example for zipping arrays.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Record.ts.md#2025-04-23_snippet_32\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare function fromFoldableMap<F extends URIS3, B>(\n  M: Magma<B>,\n  F: Foldable3<F>\n): <R, E, A>(fa: Kind3<F, R, E, A>, f: (a: A) => [string, B]) => Record<string, B>\nexport declare function fromFoldableMap<F extends URIS2, B>(\n  M: Magma<B>,\n  F: Foldable2<F>\n): <E, A>(fa: Kind2<F, E, A>, f: (a: A) => [string, B]) => Record<string, B>\nexport declare function fromFoldableMap<F extends URIS, B>(\n  M: Magma<B>,\n  F: Foldable1<F>\n): <A>(fa: Kind<F, A>, f: (a: A) => [string, B]) => Record<string, B>\nexport declare function fromFoldableMap<F, B>(\n  M: Magma<B>,\n  F: FoldableHKT<F>\n): <A>(fa: HKT<F, A>, f: (a: A) => [string, B]) => Record<string, B>\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport { last } from 'fp-ts/Semigroup'\nimport { Foldable, zip } from 'fp-ts/Array'\nimport { identity } from 'fp-ts/function'\nimport { fromFoldableMap } from 'fp-ts/Record'\n\nexport const zipObject = <K extends string, A>(keys: Array<K>, values: Array<A>): Record<K, A> =>\n  fromFoldableMap(last<A>(), Foldable)(zip(keys, values), identity)\n\nassert.deepStrictEqual(zipObject(['a', 'b'], [1, 2, 3]), { a: 1, b: 2 })\n\ninterface User {\n  readonly id: string\n  readonly name: string\n}\n\nconst users: Array<User> = [\n  { id: 'id1', name: 'name1' },\n  { id: 'id2', name: 'name2' },\n  { id: 'id1', name: 'name3' },\n]\n\nassert.deepStrictEqual(\n  fromFoldableMap(last<User>(), Foldable)(users, (user) => [user.id, user]),\n  {\n    id1: { id: 'id1', name: 'name3' },\n    id2: { id: 'id2', name: 'name2' },\n  }\n)\n```\n\n----------------------------------------\n\nTITLE: Defining FunctorWithIndex Interface in TypeScript\nDESCRIPTION: Base interface for FunctorWithIndex that extends Functor with a mapWithIndex operation which provides access to both index and value during mapping.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/FunctorWithIndex.ts.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface FunctorWithIndex<F, I> extends Functor<F> {\n  readonly mapWithIndex: <A, B>(fa: HKT<F, A>, f: (i: I, a: A) => B) => HKT<F, B>\n}\n```\n\n----------------------------------------\n\nTITLE: Converting TaskOption to TaskEither in TypeScript\nDESCRIPTION: Converts a TaskOption to a TaskEither, providing a function to handle the None case.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/TaskEither.ts.md#2025-04-23_snippet_7\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare const fromTaskOption: <E>(onNone: LazyArg<E>) => <A>(fa: TaskOption<A>) => TaskEither<E, A>\n```\n\n----------------------------------------\n\nTITLE: Implementing flatMapTaskOption Function for Chaining with TaskOption in TypeScript\nDESCRIPTION: Chains a TaskEither with a TaskOption-returning function, handling None with the provided onNone function, with support for pipeable and data-last styles.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/TaskEither.ts.md#2025-04-23_snippet_73\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const flatMapTaskOption: {\n  <A, E2, B>(f: (a: A) => TaskOption<B>, onNone: (a: A) => E2): <E1>(self: TaskEither<E1, A>) => TaskEither<E2 | E1, B>\n  <E1, A, E2, B>(self: TaskEither<E1, A>, f: (a: A) => TaskOption<B>, onNone: (a: A) => E2): TaskEither<E1 | E2, B>\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Refinement Interface in TypeScript\nDESCRIPTION: Generic interface definition for type refinements that narrow type A to type B where B extends A.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Refinement.ts.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface Refinement<A, B extends A> {\n  (a: A): a is B\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Semigroupoid Interface in TypeScript\nDESCRIPTION: Defines the Semigroupoid interface for a higher-kinded type F. It includes a URI property and a compose method for combining two morphisms.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Semigroupoid.ts.md#2025-04-23_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport interface Semigroupoid<F> {\n  readonly URI: F\n  readonly compose: <A, B, C>(bc: HKT2<F, B, C>, ab: HKT2<F, A, B>) => HKT2<F, A, C>\n}\n```\n\n----------------------------------------\n\nTITLE: Defining FunctorWithIndex1 Interface for URIS in TypeScript\nDESCRIPTION: Interface for FunctorWithIndex with a single type parameter, using the higher-kinded type system provided by fp-ts.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/FunctorWithIndex.ts.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface FunctorWithIndex1<F extends URIS, I> extends Functor1<F> {\n  readonly mapWithIndex: <A, B>(fa: Kind<F, A>, f: (i: I, a: A) => B) => Kind<F, B>\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing chainFirstW in TypeScript for ReaderTaskEither\nDESCRIPTION: Widening version of chainFirst that allows for different environment and error types. It takes a function from A to ReaderTaskEither<R2, E2, B> and returns a function that preserves the original value while merging environment and error types.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReaderTaskEither.ts.md#2025-04-23_snippet_37\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const chainFirstW: <R2, E2, A, B>(\n  f: (a: A) => ReaderTaskEither<R2, E2, B>\n) => <R1, E1>(ma: ReaderTaskEither<R1, E1, A>) => ReaderTaskEither<R1 & R2, E2 | E1, A>\n```\n\n----------------------------------------\n\nTITLE: Defining Tree Traverse Operation\nDESCRIPTION: Type definition for the traverse operation on Tree data structure.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Tree.ts.md#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const traverse: PipeableTraverse1<'Tree'>\n```\n\n----------------------------------------\n\nTITLE: Monoid Identity Property Example\nDESCRIPTION: Demonstrates the identity property of Monoids where concat with empty returns the original value.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Monoid.ts.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconcat(x, empty) = concat(empty, x) = x\n```\n\n----------------------------------------\n\nTITLE: Implementing fromIOEitherK for StateReaderTaskEither in TypeScript\nDESCRIPTION: Defines a function to lift an IOEither-returning function into the StateReaderTaskEither context.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/StateReaderTaskEither.ts.md#2025-04-23_snippet_27\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare const fromIOEitherK: <E, A extends readonly unknown[], B>(\n  f: (...a: A) => IOEither<E, B>\n) => <S, R = unknown>(...a: A) => StateReaderTaskEither<S, R, E, B>\n```\n\n----------------------------------------\n\nTITLE: Creating Applicative Instance with Error Concatenation for ReaderTaskEither in TypeScript\nDESCRIPTION: Defines a function to create an Applicative instance for ReaderTaskEither that concatenates errors using a provided Semigroup.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReaderTaskEither.ts.md#2025-04-23_snippet_10\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare function getApplicativeReaderTaskValidation<E>(A: Apply1<T.URI>, S: Semigroup<E>): Applicative3C<URI, E>\n```\n\n----------------------------------------\n\nTITLE: Equality Comparison for Date Objects\nDESCRIPTION: Eq instance for Date objects, providing a way to compare dates for equality in a type-safe manner.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Date.ts.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const Eq: E.Eq<Date>\n```\n\n----------------------------------------\n\nTITLE: Creating Semigroup Instances for Predicates in TypeScript\nDESCRIPTION: Defines functions to create Semigroup instances for predicates, both for 'all' and 'any' operations. These allow predicates to be combined using semigroup operations.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Predicate.ts.md#2025-04-23_snippet_2\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare const getSemigroupAll: <A = never>() => Semigroup<Predicate<A>>\n```\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare const getSemigroupAny: <A = never>() => Semigroup<Predicate<A>>\n```\n\n----------------------------------------\n\nTITLE: Calculating Record size in fp-ts\nDESCRIPTION: Calculates the number of key/value pairs in a Record. This function returns the count of entries in the Record object.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Record.ts.md#2025-04-23_snippet_48\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const size: <A>(r: Record<string, A>) => number\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport { size } from 'fp-ts/Record'\n\nassert.deepStrictEqual(size({ a: true, b: 2, c: 'three' }), 3)\n```\n\n----------------------------------------\n\nTITLE: Creating Filterable instance for Either in TypeScript\nDESCRIPTION: Defines a function to create a Filterable instance for Either given a Monoid for the left side.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Either.ts.md#2025-04-23_snippet_16\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare const getFilterable: <E>(M: Monoid<E>) => Filterable2C<'Either', E>\n```\n\n----------------------------------------\n\nTITLE: Using Alternative (altW) with ReadonlyArray in TypeScript\nDESCRIPTION: Demonstrates the use of the altW function to concatenate two ReadonlyArrays with different element types.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReadonlyArray.ts.md#2025-04-23_snippet_3\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport * as RA from 'fp-ts/ReadonlyArray'\nimport { pipe } from 'fp-ts/function'\n\nassert.deepStrictEqual(\n  pipe(\n    [1, 2, 3],\n    RA.altW(() => ['a', 'b'])\n  ),\n  [1, 2, 3, 'a', 'b']\n)\n```\n\n----------------------------------------\n\nTITLE: Converting Set to Sorted Array in TypeScript\nDESCRIPTION: Converts a Set to a sorted array. It requires an ordering function to determine the sort order of the resulting array.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Set.ts.md#2025-04-23_snippet_2\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare const toArray: <A>(O: Ord<A>) => (set: Set<A>) => A[]\n```\n\n----------------------------------------\n\nTITLE: Rotating NonEmptyArray in TypeScript\nDESCRIPTION: Rotates a NonEmptyArray by a specified number of steps, creating a new NonEmptyArray with elements shifted circularly.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/NonEmptyArray.ts.md#2025-04-23_snippet_15\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const rotate: (n: number) => <A>(as: NonEmptyArray<A>) => NonEmptyArray<A>\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport { rotate } from 'fp-ts/NonEmptyArray'\n\nassert.deepStrictEqual(rotate(2)([1, 2, 3, 4, 5]), [4, 5, 1, 2, 3])\nassert.deepStrictEqual(rotate(-2)([1, 2, 3, 4, 5]), [3, 4, 5, 1, 2])\n```\n\n----------------------------------------\n\nTITLE: Implementing FromIOK Function for IOOption in TypeScript\nDESCRIPTION: Defines the fromIOK function for IOOption. It lifts a function returning IO to a function returning IOOption.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/IOOption.ts.md#2025-04-23_snippet_25\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const fromIOK: <A extends readonly unknown[], B>(f: (...a: A) => I.IO<B>) => (...a: A) => IOOption<B>\n```\n\n----------------------------------------\n\nTITLE: Implementing ChainFirstIOK Function for IOOption in TypeScript\nDESCRIPTION: Defines the chainFirstIOK function for IOOption, which is an alias of tapIO. It allows chaining IO operations while keeping the original value.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/IOOption.ts.md#2025-04-23_snippet_20\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const chainFirstIOK: <A, B>(f: (a: A) => I.IO<B>) => (first: IOOption<A>) => IOOption<A>\n```\n\n----------------------------------------\n\nTITLE: Defining traverse function for Records in TypeScript\nDESCRIPTION: Defines a higher-order function that traverses a Record, applying an Applicative function to each value. Multiple implementations are provided for different URIS (URI types) representing different Applicative functors.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Record.ts.md#2025-04-23_snippet_51\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare function traverse<F extends URIS4>(\n  F: Applicative4<F>\n): <S, R, E, A, B>(\n  f: (a: A) => Kind4<F, S, R, E, B>\n) => <K extends string>(ta: Record<K, A>) => Kind4<F, S, R, E, Record<K, B>>\nexport declare function traverse<F extends URIS3>(\n  F: Applicative3<F>\n): <R, E, A, B>(f: (a: A) => Kind3<F, R, E, B>) => <K extends string>(ta: Record<K, A>) => Kind3<F, R, E, Record<K, B>>\nexport declare function traverse<F extends URIS3, E>(\n  F: Applicative3C<F, E>\n): <R, A, B>(f: (a: A) => Kind3<F, R, E, B>) => <K extends string>(ta: Record<K, A>) => Kind3<F, R, E, Record<K, B>>\nexport declare function traverse<F extends URIS2>(\n  F: Applicative2<F>\n): <E, A, B>(f: (a: A) => Kind2<F, E, B>) => <K extends string>(ta: Record<K, A>) => Kind2<F, E, Record<K, B>>\nexport declare function traverse<F extends URIS2, E>(\n  F: Applicative2C<F, E>\n): <A, B>(f: (a: A) => Kind2<F, E, B>) => <K extends string>(ta: Record<K, A>) => Kind2<F, E, Record<K, B>>\nexport declare function traverse<F extends URIS>(\n  F: Applicative1<F>\n): <A, B>(f: (a: A) => Kind<F, B>) => <K extends string>(ta: Record<K, A>) => Kind<F, Record<K, B>>\nexport declare function traverse<F>(\n  F: Applicative<F>\n): <A, B>(f: (a: A) => HKT<F, B>) => <K extends string>(ta: Record<K, A>) => HKT<F, Record<K, B>>\n```\n\n----------------------------------------\n\nTITLE: Defining flatMap function for ReaderIO in TypeScript\nDESCRIPTION: Flattens a nested ReaderIO structure. It provides two function signatures for different use cases.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReaderIO.ts.md#2025-04-23_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const flatMap: {\n  <A, R2, B>(f: (a: A) => ReaderIO<R2, B>): <R1>(ma: ReaderIO<R1, A>) => ReaderIO<R1 & R2, B>\n  <R1, A, R2, B>(ma: ReaderIO<R1, A>, f: (a: A) => ReaderIO<R2, B>): ReaderIO<R1 & R2, B>\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing mapLeft for Const in TypeScript\nDESCRIPTION: Maps a function over the first type argument of the Const bifunctor. This allows transforming the actual value stored inside a Const while preserving its structure.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Const.ts.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const mapLeft: <E, G>(f: (e: E) => G) => <A>(fa: Const<E, A>) => Const<G, A>\n```\n\n----------------------------------------\n\nTITLE: Creating Tree Constructor Function in TypeScript\nDESCRIPTION: Implements a make function to create a Tree with a given value and optional forest of subtrees.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Tree.ts.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare function make<A>(value: A, forest: Forest<A> = []): Tree<A>\n```\n\n----------------------------------------\n\nTITLE: Mapping and Folding Record Values with Monoid\nDESCRIPTION: Maps a Record by passing each key/value pair to a function, then folds the results using a provided Monoid. Can optionally use an Ord to determine the order of keys during folding.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Record.ts.md#2025-04-23_snippet_30\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare function foldMapWithIndex(\n  O: Ord<string>\n): <M>(M: Monoid<M>) => <K extends string, A>(f: (k: K, a: A) => M) => (fa: Record<K, A>) => M\nexport declare function foldMapWithIndex<M>(\n  M: Monoid<M>\n): <K extends string, A>(f: (k: K, a: A) => M) => (fa: Record<K, A>) => M\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport { foldMapWithIndex } from 'fp-ts/Record'\nimport { Ord } from 'fp-ts/string'\nimport { Monoid } from 'fp-ts/Monoid'\n\nconst m: Monoid<string> = { empty: '', concat: (x: string, y: string) => (x ? `${x} -> ${y}` : `${y}`) }\nconst f = (k: string, a: number) => `${k}-${a}`\nconst x = { c: 3, a: 1, b: 2 }\nassert.deepStrictEqual(foldMapWithIndex(Ord)(m)(f)(x), 'a-1 -> b-2 -> c-3')\n```\n\n----------------------------------------\n\nTITLE: Using Element Search in ReadonlyArray in TypeScript\nDESCRIPTION: Demonstrates how to use various search functions to find elements in ReadonlyArrays.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReadonlyArray.ts.md#2025-04-23_snippet_31\n\nLANGUAGE: typescript\nCODE:\n```\nimport { findFirst, findFirstMap, findIndex, findLast } from 'fp-ts/ReadonlyArray'\nimport { some, none } from 'fp-ts/Option'\n\ntype X = {\n  readonly a: number\n  readonly b: number\n}\n\nassert.deepStrictEqual(\n  findFirst((x: X) => x.a === 1)([\n    { a: 1, b: 1 },\n    { a: 1, b: 2 },\n  ]),\n  some({ a: 1, b: 1 })\n)\n\ninterface Person {\n  readonly name: string\n  readonly age?: number\n}\n\nconst persons: ReadonlyArray<Person> = [{ name: 'John' }, { name: 'Mary', age: 45 }, { name: 'Joey', age: 28 }]\n\n// returns the name of the first person that has an age\nassert.deepStrictEqual(findFirstMap((p: Person) => (p.age === undefined ? none : some(p.name)))(persons), some('Mary'))\n\nassert.deepStrictEqual(findIndex((n: number) => n === 2)([1, 2, 3]), some(1))\nassert.deepStrictEqual(findIndex((n: number) => n === 2)([]), none)\n\nassert.deepStrictEqual(\n  findLast((x: X) => x.a === 1)([\n    { a: 1, b: 1 },\n    { a: 1, b: 2 },\n  ]),\n  some({ a: 1, b: 2 })\n)\n```\n\n----------------------------------------\n\nTITLE: Implementing SemigroupSum for Numbers\nDESCRIPTION: Semigroup instance for number addition.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/number.ts.md#2025-04-23_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const SemigroupSum: Semigroup<number>\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport { SemigroupSum } from 'fp-ts/number'\n\nassert.deepStrictEqual(SemigroupSum.concat(2, 3), 5)\n```\n\n----------------------------------------\n\nTITLE: Implementing Tree Fold Function in TypeScript\nDESCRIPTION: Creates a fold function to recursively process a tree, applying a given function to each node and its subtrees.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Tree.ts.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare function fold<A, B>(f: (a: A, bs: Array<B>) => B): (tree: Tree<A>) => B\n```\n\n----------------------------------------\n\nTITLE: Implementing fromOptionK Function for Lifting Option Functions in TypeScript\nDESCRIPTION: Creates a function that transforms an Option-returning function into a TaskEither-returning function, handling None with the provided onNone function.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/TaskEither.ts.md#2025-04-23_snippet_44\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const fromOptionK: <E>(\n  onNone: LazyArg<E>\n) => <A extends readonly unknown[], B>(f: (...a: A) => Option<B>) => (...a: A) => TaskEither<E, B>\n```\n\n----------------------------------------\n\nTITLE: Prepending Element to Array with fp-ts\nDESCRIPTION: Prepends an element to the front of a ReadonlyArray, creating a new ReadonlyNonEmptyArray. This guarantees the result is non-empty.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReadonlyArray.ts.md#2025-04-23_snippet_45\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const prepend: <A>(head: A) => (tail: readonly A[]) => RNEA.ReadonlyNonEmptyArray<A>\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport { prepend } from 'fp-ts/ReadonlyArray'\nimport { pipe } from 'fp-ts/function'\n\nassert.deepStrictEqual(pipe([2, 3, 4], prepend(1)), [1, 2, 3, 4])\n```\n\n----------------------------------------\n\nTITLE: Implementing fromPredicate for Conditional Logic\nDESCRIPTION: Creates a ReaderTaskEither from a predicate function, producing a Right for values that satisfy the condition and a Left with the specified error otherwise.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReaderTaskEither.ts.md#2025-04-23_snippet_65\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const fromPredicate: {\n  <E, A, B extends A>(refinement: Refinement<A, B>, onFalse: (a: A) => E): <R = unknown>(\n    a: A\n  ) => ReaderTaskEither<R, E, B>\n  <E, A>(predicate: Predicate<A>, onFalse: (a: A) => E): <R = unknown, B extends A = A>(\n    b: B\n  ) => ReaderTaskEither<R, E, B>\n  <E, A>(predicate: Predicate<A>, onFalse: (a: A) => E): <R = unknown>(a: A) => ReaderTaskEither<R, E, A>\n}\n```\n\n----------------------------------------\n\nTITLE: Greater Than or Equal Function for Ord in TypeScript\nDESCRIPTION: Creates a function to test whether one value is non-strictly greater than another using an Ord instance.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Ord.ts.md#2025-04-23_snippet_15\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const geq: <A>(O: Ord<A>) => (first: A, second: A) => boolean\n```\n\n----------------------------------------\n\nTITLE: Implementing swap function for ReaderTaskEither in TypeScript\nDESCRIPTION: Defines a function that swaps the error and success types in a ReaderTaskEither monad.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReaderTaskEither.ts.md#2025-04-23_snippet_119\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const swap: <R, E, A>(ma: ReaderTaskEither<R, E, A>) => ReaderTaskEither<R, A, E>\n```\n\n----------------------------------------\n\nTITLE: Defining Zero interface for generic functors in TypeScript\nDESCRIPTION: This interface defines the structure for a Zero type class for generic functors. It includes a URI type and a zero method that returns an HKT (Higher Kinded Type) of the functor.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Zero.ts.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface Zero<F> {\n  readonly URI: F\n  readonly zero: <A>() => HKT<F, A>\n}\n```\n\n----------------------------------------\n\nTITLE: Splitting ReadonlyArray Based on Predicate in TypeScript\nDESCRIPTION: Splits a readonly array into two parts: the longest initial subarray that satisfies a predicate, and the remaining elements.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReadonlyArray.ts.md#2025-04-23_snippet_57\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare function spanLeft<A, B extends A>(refinement: Refinement<A, B>): (as: ReadonlyArray<A>) => Spanned<B, A>\nexport declare function spanLeft<A>(predicate: Predicate<A>): <B extends A>(bs: ReadonlyArray<B>) => Spanned<B, B>\nexport declare function spanLeft<A>(predicate: Predicate<A>): (as: ReadonlyArray<A>) => Spanned<A, A>\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport { spanLeft } from 'fp-ts/ReadonlyArray'\n\nassert.deepStrictEqual(spanLeft((n: number) => n % 2 === 1)([1, 3, 2, 4, 5]), { init: [1, 3], rest: [2, 4, 5] })\n```\n\n----------------------------------------\n\nTITLE: Defining TaskEither Interface in TypeScript\nDESCRIPTION: Defines the TaskEither interface which extends Task with Either type, representing asynchronous computations that may fail with an error of type E or succeed with a value of type A.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/TaskEither.ts.md#2025-04-23_snippet_39\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface TaskEither<E, A> extends Task<Either<E, A>> {}\n```\n\n----------------------------------------\n\nTITLE: String Manipulation Functions in TypeScript\nDESCRIPTION: A collection of utility functions for string manipulation, including endsWith, includes, isEmpty, replace, size, slice, split, startsWith, toLowerCase, toUpperCase, trim, trimLeft, and trimRight.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/string.ts.md#2025-04-23_snippet_6\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare const empty: ''\n\nexport declare const endsWith: (searchString: string, position?: number | undefined) => (s: string) => boolean\n\nexport declare const includes: (searchString: string, position?: number | undefined) => (s: string) => boolean\n\nexport declare const isEmpty: (s: string) => boolean\n\nexport declare const replace: (searchValue: string | RegExp, replaceValue: string) => (s: string) => string\n\nexport declare const size: (s: string) => number\n\nexport declare const slice: (start: number, end: number) => (s: string) => string\n\nexport declare const split: (separator: string | RegExp) => (s: string) => ReadonlyNonEmptyArray<string>\n\nexport declare const startsWith: (searchString: string, position?: number | undefined) => (s: string) => boolean\n\nexport declare const toLowerCase: (s: string) => string\n\nexport declare const toUpperCase: (s: string) => string\n\nexport declare const trim: (s: string) => string\n\nexport declare const trimLeft: (s: string) => string\n\nexport declare const trimRight: (s: string) => string\n```\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport * as S from 'fp-ts/string'\nimport { pipe } from 'fp-ts/function'\n\nassert.deepStrictEqual(pipe('abc', S.endsWith('c')), true)\nassert.deepStrictEqual(pipe('ab', S.endsWith('c')), false)\n\nassert.deepStrictEqual(pipe('abc', S.includes('b')), true)\nassert.deepStrictEqual(pipe('abc', S.includes('d')), false)\n\nassert.deepStrictEqual(pipe('', S.isEmpty), true)\nassert.deepStrictEqual(pipe('a', S.isEmpty), false)\n\nassert.deepStrictEqual(pipe('abc', S.replace('b', 'd')), 'adc')\n\nassert.deepStrictEqual(pipe('abc', S.size), 3)\n\nassert.deepStrictEqual(pipe('abcd', S.slice(1, 3)), 'bc')\n\nassert.deepStrictEqual(pipe('abc', S.split('')), ['a', 'b', 'c'])\nassert.deepStrictEqual(pipe('', S.split('')), [''])\n\nassert.deepStrictEqual(pipe('abc', S.startsWith('a')), true)\nassert.deepStrictEqual(pipe('bc', S.startsWith('a')), false)\n\nassert.deepStrictEqual(pipe('A', S.toLowerCase), 'a')\n\nassert.deepStrictEqual(pipe('a', S.toUpperCase), 'A')\n\nassert.deepStrictEqual(pipe(' a ', S.trim), 'a')\n\nassert.deepStrictEqual(pipe(' a ', S.trimLeft), 'a ')\n\nassert.deepStrictEqual(pipe(' a ', S.trimRight), ' a')\n```\n\n----------------------------------------\n\nTITLE: Defining Apply Interface in TypeScript\nDESCRIPTION: This code snippet defines the Apply interface, which extends Functor and provides the ap method for applying a function to an argument under a type constructor.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Apply.ts.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface Apply<F> extends Functor<F> {\n  readonly ap: <A, B>(fab: HKT<F, (a: A) => B>, fa: HKT<F, A>) => HKT<F, B>\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing FromThese4 Interface in TypeScript\nDESCRIPTION: Defines the FromThese4 interface for type constructors with four type parameters. It includes a URI and a fromThese method to convert These values to the target type.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/FromThese.ts.md#2025-04-23_snippet_5\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport interface FromThese4<F extends URIS4> {\n  readonly URI: F\n  readonly fromThese: <E, A, S, R>(fa: These<E, A>) => Kind4<F, S, R, E, A>\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing traverseArrayWithIndex for StateReaderTaskEither in TypeScript\nDESCRIPTION: Provides traverseArrayWithIndex function that maps each element of an array along with its index to a StateReaderTaskEither and collects the results, equivalent to ReadonlyArray#traverseWithIndex.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/StateReaderTaskEither.ts.md#2025-04-23_snippet_56\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare const traverseArrayWithIndex: <S, R, E, A, B>(\n  f: (index: number, a: A) => StateReaderTaskEither<S, R, E, B>\n) => (as: readonly A[]) => StateReaderTaskEither<S, R, E, readonly B[]>\n```\n\n----------------------------------------\n\nTITLE: State Modification Functions in StateReaderTaskEither\nDESCRIPTION: Core functions for modifying and accessing state in the StateReaderTaskEither monad transformer. Includes modify(), of(), put(), and right() implementations.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/StateReaderTaskEither.ts.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const modify: <S, R, E = never>(f: Endomorphism<S>) => StateReaderTaskEither<S, R, E, void>\n\nexport declare const of: <S, R = unknown, E = never, A = never>(a: A) => StateReaderTaskEither<S, R, E, A>\n\nexport declare const put: <S, R, E = never>(s: S) => StateReaderTaskEither<S, R, E, void>\n\nexport declare const right: <S, R, E = never, A = never>(a: A) => StateReaderTaskEither<S, R, E, A>\n```\n\n----------------------------------------\n\nTITLE: Finding Maximum Element in ReadonlyNonEmptyArray with Ord in TypeScript\nDESCRIPTION: Function that finds the maximum element in a ReadonlyNonEmptyArray using the provided Ord instance for comparison.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReadonlyNonEmptyArray.ts.md#2025-04-23_snippet_50\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const max: <A>(O: Ord<A>) => (as: ReadonlyNonEmptyArray<A>) => A\n```\n\n----------------------------------------\n\nTITLE: Implementing chainTaskEitherK for StateReaderTaskEither in TypeScript\nDESCRIPTION: Defines chainTaskEitherK as an alias of flatMapTaskEither. It chains a TaskEither operation after a StateReaderTaskEither.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/StateReaderTaskEither.ts.md#2025-04-23_snippet_22\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare const chainTaskEitherK: <E, A, B>(\n  f: (a: A) => TaskEither<E, B>\n) => <S, R>(ma: StateReaderTaskEither<S, R, E, A>) => StateReaderTaskEither<S, R, E, B>\n```\n\n----------------------------------------\n\nTITLE: Implementing tapIO Combinator for ReaderTaskEither in TypeScript\nDESCRIPTION: Defines a tapIO combinator for ReaderTaskEither that composes computations in sequence, using the return value of one computation to determine the next computation and keeping only the result of the first. It includes an example of usage with console output.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReaderTaskEither.ts.md#2025-04-23_snippet_2\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare const tapIO: {\n  <A, _>(f: (a: A) => IO<_>): <R, E>(self: ReaderTaskEither<R, E, A>) => ReaderTaskEither<R, E, A>\n  <R, E, A, _>(self: ReaderTaskEither<R, E, A>, f: (a: A) => IO<_>): ReaderTaskEither<R, E, A>\n}\n\n**Example**\n\nimport * as RTE from 'fp-ts/ReaderTaskEither'\nimport * as E from 'fp-ts/Either'\nimport * as Console from 'fp-ts/Console'\n\n// Will produce `Hello, fp-ts` to the stdout\nconst effect = RTE.tapIO(RTE.ask<string>(), (value) => Console.log(`Hello, ${value}`))\n\nasync function test() {\n  assert.deepStrictEqual(await effect('fp-ts')(), E.of('fp-ts'))\n}\n\ntest()\n```\n\n----------------------------------------\n\nTITLE: Creating Union Semigroup for Records in TypeScript\nDESCRIPTION: Given a Semigroup in the base type, it produces a Semigroup in the Record of the base type. The resulting Semigroup concatenates two Records by union, combining all entries using the provided Semigroup for overlapping keys.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Record.ts.md#2025-04-23_snippet_17\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const getUnionSemigroup: <A>(S: Se.Semigroup<A>) => Se.Semigroup<Record<string, A>>\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport { getUnionSemigroup } from 'fp-ts/Record'\nimport { Semigroup } from 'fp-ts/Semigroup'\n\nconst sNumber: Semigroup<number> = { concat: (x, y) => x - y }\nconst sRecord: Semigroup<Record<string, number>> = getUnionSemigroup(sNumber)\nassert.deepStrictEqual(sRecord.concat({ a: 1, b: 2 }, { b: 3, c: 4 }), { a: 1, b: -1, c: 4 })\n```\n\n----------------------------------------\n\nTITLE: Implementing FromReader asks function in TypeScript\nDESCRIPTION: The asks function is a constructor that creates a computation from a function that depends on the environment. It allows accessing the environment through a mapping function to get a specific value.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/FromReader.ts.md#2025-04-23_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare function asks<F extends URIS4>(F: FromReader4<F>): <R, A, S, E>(f: (r: R) => A) => Kind4<F, S, R, E, A>\nexport declare function asks<F extends URIS3>(F: FromReader3<F>): <R, A, E>(f: (r: R) => A) => Kind3<F, R, E, A>\nexport declare function asks<F extends URIS3, E>(F: FromReader3C<F, E>): <R, A>(f: (r: R) => A) => Kind3<F, R, E, A>\nexport declare function asks<F extends URIS2>(F: FromReader2<F>): <R, A>(f: (r: R) => A) => Kind2<F, R, A>\nexport declare function asks<F>(F: FromReader<F>): <R, A>(f: (r: R) => A) => HKT2<F, R, A>\n```\n\n----------------------------------------\n\nTITLE: ReaderTask Sequencing Operations\nDESCRIPTION: Functions for sequencing ReaderTask computations including flatMap, flatten, and various specialized chain operations.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReaderTask.ts.md#2025-04-23_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const flatMap: {\n  <A, R2, B>(f: (a: A) => ReaderTask<R2, B>): <R1>(ma: ReaderTask<R1, A>) => ReaderTask<R1 & R2, B>\n  <R1, A, R2, B>(ma: ReaderTask<R1, A>, f: (a: A) => ReaderTask<R2, B>): ReaderTask<R1 & R2, B>\n}\n```\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const flatten: <R, A>(mma: ReaderTask<R, ReaderTask<R, A>>) => ReaderTask<R, A>\n```\n\n----------------------------------------\n\nTITLE: Implementing Boolean Monoid for Disjunction\nDESCRIPTION: Implements a boolean monoid under disjunction where the empty value is false. Used for combining boolean values with OR operations.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/boolean.ts.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const MonoidAny: Monoid<boolean>\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport { MonoidAny } from 'fp-ts/boolean'\n\nassert.deepStrictEqual(MonoidAny.concat(true, true), true)\nassert.deepStrictEqual(MonoidAny.concat(true, false), true)\nassert.deepStrictEqual(MonoidAny.concat(false, false), false)\n```\n\n----------------------------------------\n\nTITLE: Implementing foldMap Composition in TypeScript\nDESCRIPTION: Utility function that composes two Foldable instances to allow folding over nested structures using a monoid.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Foldable.ts.md#2025-04-23_snippet_7\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare function foldMap<F extends URIS, G extends URIS>(\n  F: Foldable1<F>,\n  G: Foldable1<G>\n): <M>(M: Monoid<M>) => <A>(f: (a: A) => M) => (fga: Kind<F, Kind<G, A>>) => M\nexport declare function foldMap<F, G>(\n  F: Foldable<F>,\n  G: Foldable<G>\n): <M>(M: Monoid<M>) => <A>(f: (a: A) => M) => (fga: HKT<F, HKT<G, A>>) => M\n```\n\n----------------------------------------\n\nTITLE: Implementing chainFirst Utility Function for Chain\nDESCRIPTION: A utility function that sequences two monadic actions, keeping only the result of the first, with overloads for different arities.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Chain.ts.md#2025-04-23_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare function chainFirst<M extends URIS4>(\n  M: Chain4<M>\n): <A, S, R, E, _>(f: (a: A) => Kind4<M, S, R, E, _>) => (first: Kind4<M, S, R, E, A>) => Kind4<M, S, R, E, A>\nexport declare function chainFirst<M extends URIS3>(\n  M: Chain3<M>\n): <A, R, E, _>(f: (a: A) => Kind3<M, R, E, _>) => (first: Kind3<M, R, E, A>) => Kind3<M, R, E, A>\nexport declare function chainFirst<M extends URIS3, E>(\n  M: Chain3C<M, E>\n): <A, R, _>(f: (a: A) => Kind3<M, R, E, _>) => (first: Kind3<M, R, E, A>) => Kind3<M, R, E, A>\nexport declare function chainFirst<M extends URIS2>(\n  M: Chain2<M>\n): <A, E, _>(f: (a: A) => Kind2<M, E, _>) => (first: Kind2<M, E, A>) => Kind2<M, E, A>\nexport declare function chainFirst<M extends URIS2, E>(\n  M: Chain2C<M, E>\n): <A, _>(f: (a: A) => Kind2<M, E, _>) => (first: Kind2<M, E, A>) => Kind2<M, E, A>\nexport declare function chainFirst<M extends URIS>(\n  M: Chain1<M>\n): <A, _>(f: (a: A) => Kind<M, _>) => (first: Kind<M, A>) => Kind<M, A>\nexport declare function chainFirst<M>(M: Chain<M>): <A, _>(f: (a: A) => HKT<M, _>) => (first: HKT<M, A>) => HKT<M, A>\n```\n\n----------------------------------------\n\nTITLE: Using Element Deletion in ReadonlyArray in TypeScript\nDESCRIPTION: Demonstrates how to use the deleteAt function to remove elements from a ReadonlyArray.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReadonlyArray.ts.md#2025-04-23_snippet_15\n\nLANGUAGE: typescript\nCODE:\n```\nimport { deleteAt } from 'fp-ts/ReadonlyArray'\nimport { some, none } from 'fp-ts/Option'\n\nassert.deepStrictEqual(deleteAt(0)([1, 2, 3]), some([2, 3]))\nassert.deepStrictEqual(deleteAt(1)([]), none)\n```\n\n----------------------------------------\n\nTITLE: Testing All Record Values with Predicate\nDESCRIPTION: Tests if every value in a Record satisfies a given predicate function. Can also be used with a refinement to narrow the type of the Record's values.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Record.ts.md#2025-04-23_snippet_27\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const every: {\n  <A, B extends A>(refinement: Refinement<A, B>): Refinement<Record<string, A>, Record<string, B>>\n  <A>(predicate: Predicate<A>): Predicate<Record<string, A>>\n}\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport { every } from 'fp-ts/Record'\n\nassert.deepStrictEqual(every((n: number) => n >= 0)({ a: 1, b: 2 }), true)\nassert.deepStrictEqual(every((n: number) => n >= 0)({ a: 1, b: -1 }), false)\n```\n\n----------------------------------------\n\nTITLE: ReaderEither mapBoth Operation Example\nDESCRIPTION: Example showing how to map both success and failure channels of a ReaderEither using mapBoth function.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReaderEither.ts.md#2025-04-23_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as ReaderEither from 'fp-ts/ReaderEither'\nimport * as Either from 'fp-ts/Either'\n\nconst f = (s: string) => new Error(s)\nconst g = (n: number) => n * 2\n\nassert.deepStrictEqual(ReaderEither.mapBoth(ReaderEither.right(1), f, g)({}), Either.right(2))\nassert.deepStrictEqual(ReaderEither.mapBoth(ReaderEither.left('err'), f, g)({}), Either.left(new Error('err')))\n```\n\n----------------------------------------\n\nTITLE: Tapping Either Values in IOEither Context\nDESCRIPTION: The tapEither function composes computations in sequence, using the return value of one computation to determine the next computation and keeping only the result of the first. It works with Either values in an IOEither context.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/IOEither.ts.md#2025-04-23_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare const tapEither: {\n  <A, E2, _>(f: (a: A) => E.Either<E2, _>): <E1>(self: IOEither<E1, A>) => IOEither<E2 | E1, A>\n  <E1, A, E2, _>(self: IOEither<E1, A>, f: (a: A) => E.Either<E2, _>): IOEither<E1 | E2, A>\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Traversable Functions for These in TypeScript\nDESCRIPTION: Defines traverse and sequence functions for the These type, enabling compatibility with other traversable structures.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/These.ts.md#2025-04-23_snippet_15\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare const sequence: Sequence2<'These'>\n\nexport declare const traverse: PipeableTraverse2<'These'>\n```\n\n----------------------------------------\n\nTITLE: Implementing mapWithIndex for ReadonlyNonEmptyArray in TypeScript\nDESCRIPTION: Maps a function over a ReadonlyNonEmptyArray, providing both the index and the element to the mapping function.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReadonlyNonEmptyArray.ts.md#2025-04-23_snippet_20\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const mapWithIndex: <A, B>(\n  f: (i: number, a: A) => B\n) => (as: ReadonlyNonEmptyArray<A>) => ReadonlyNonEmptyArray<B>\n```\n\n----------------------------------------\n\nTITLE: Implementing Chain1 Interface for URIS\nDESCRIPTION: Chain interface for type constructors with one type parameter, extending Apply1.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Chain.ts.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface Chain1<F extends URIS> extends Apply1<F> {\n  readonly chain: <A, B>(fa: Kind<F, A>, f: (a: A) => Kind<F, B>) => Kind<F, B>\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Semigroup Instance for String Concatenation in TypeScript\nDESCRIPTION: Defines a Semigroup instance for string concatenation. It provides a concat method to join two strings.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/string.ts.md#2025-04-23_snippet_3\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare const Semigroup: S.Semigroup<string>\n```\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport * as S from 'fp-ts/string'\n\nassert.deepStrictEqual(S.Semigroup.concat('a', 'b'), 'ab')\n```\n\n----------------------------------------\n\nTITLE: Creating Filterable Instance for Record in TypeScript\nDESCRIPTION: Defines a Filterable instance for the Record type in fp-ts. Filterable provides operations to filter elements from a structure based on a predicate.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Record.ts.md#2025-04-23_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const Filterable: Filterable1<'Record'>\n```\n\n----------------------------------------\n\nTITLE: Implementing Field Type Class for Numbers\nDESCRIPTION: Type class instance for Field operations on numbers, providing algebraic field operations.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/number.ts.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const Field: F.Field<number>\n```\n\n----------------------------------------\n\nTITLE: Interspersing Element Between Members of ReadonlyNonEmptyArray in TypeScript\nDESCRIPTION: Function that places an element between each member of a ReadonlyNonEmptyArray, returning a new non-empty array with the interspersed elements.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReadonlyNonEmptyArray.ts.md#2025-04-23_snippet_48\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const intersperse: <A>(middle: A) => (as: ReadonlyNonEmptyArray<A>) => ReadonlyNonEmptyArray<A>\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport { intersperse } from 'fp-ts/ReadonlyNonEmptyArray'\n\nassert.deepStrictEqual(intersperse(9)([1, 2, 3, 4]), [1, 9, 2, 9, 3, 9, 4])\n```\n\n----------------------------------------\n\nTITLE: Updating Element in NonEmptyArray in TypeScript\nDESCRIPTION: Updates an element at a specified index in a NonEmptyArray, returning an Option of a new NonEmptyArray. Returns None if the index is out of bounds.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/NonEmptyArray.ts.md#2025-04-23_snippet_25\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const updateAt: <A>(i: number, a: A) => (as: NonEmptyArray<A>) => Option<NonEmptyArray<A>>\n```\n\n----------------------------------------\n\nTITLE: Getting Last Element from Array with fp-ts Option\nDESCRIPTION: Gets the last element in an array wrapped in an Option. Returns Some containing the last element if the array is not empty, or None if the array is empty.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReadonlyArray.ts.md#2025-04-23_snippet_41\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const last: <A>(as: readonly A[]) => Option<A>\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport { last } from 'fp-ts/ReadonlyArray'\nimport { some, none } from 'fp-ts/Option'\n\nassert.deepStrictEqual(last([1, 2, 3]), some(3))\nassert.deepStrictEqual(last([]), none)\n```\n\n----------------------------------------\n\nTITLE: Ordering Comparison for Date Objects with Example\nDESCRIPTION: Ord instance for Date objects, enabling ordering comparisons between dates. Includes an example demonstrating comparison between two dates.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Date.ts.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const Ord: O.Ord<Date>\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Ord } from 'fp-ts/Date'\n\nassert.deepStrictEqual(Ord.compare(new Date(1, 1, 2020), new Date(1, 1, 2021)), -1)\n```\n\n----------------------------------------\n\nTITLE: Implementing flatMapTask Function for Chaining with Task in TypeScript\nDESCRIPTION: Chains a TaskEither with a Task-returning function, applying the function to the Right value and preserving the error type, with support for pipeable and data-last styles.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/TaskEither.ts.md#2025-04-23_snippet_72\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const flatMapTask: {\n  <A, B>(f: (a: A) => T.Task<B>): <E>(self: TaskEither<E, A>) => TaskEither<E, B>\n  <E, A, B>(self: TaskEither<E, A>, f: (a: A) => T.Task<B>): TaskEither<E, B>\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing flattenW Function with Error Type Widening in TypeScript\nDESCRIPTION: A less strict version of flatten that merges the error types of the nested TaskEither structures when flattening.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/TaskEither.ts.md#2025-04-23_snippet_75\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const flattenW: <E1, E2, A>(mma: TaskEither<E1, TaskEither<E2, A>>) => TaskEither<E1 | E2, A>\n```\n\n----------------------------------------\n\nTITLE: FoldableWithIndex1 Interface Definition for URIS Kind\nDESCRIPTION: Interface for FoldableWithIndex specialized for Kind<F, A> types, extending Foldable1 with indexed folding operations.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/FoldableWithIndex.ts.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface FoldableWithIndex1<F extends URIS, I> extends Foldable1<F> {\n  readonly reduceWithIndex: <A, B>(fa: Kind<F, A>, b: B, f: (i: I, b: B, a: A) => B) => B\n  readonly foldMapWithIndex: <M>(M: Monoid<M>) => <A>(fa: Kind<F, A>, f: (i: I, a: A) => M) => M\n  readonly reduceRightWithIndex: <A, B>(fa: Kind<F, A>, b: B, f: (i: I, a: A, b: B) => B) => B\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Clamp Function for Bounded Types\nDESCRIPTION: Utility function that clamps a value between the bottom and top bounds of a Bounded type. Takes a Bounded instance and returns a function that clamps values of that type.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Bounded.ts.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const clamp: <A>(B: Bounded<A>) => (a: A) => A\n```\n\n----------------------------------------\n\nTITLE: Interspersing Elements in Array with fp-ts\nDESCRIPTION: Places an element between members of an array, creating a new array. Unlike intercalate, this does not fold the results but returns a new array with the separator interspersed between original elements.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReadonlyArray.ts.md#2025-04-23_snippet_39\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const intersperse: <A>(middle: A) => (as: readonly A[]) => readonly A[]\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport { intersperse } from 'fp-ts/ReadonlyArray'\n\nassert.deepStrictEqual(intersperse(9)([1, 2, 3, 4]), [1, 9, 2, 9, 3, 9, 4])\n```\n\n----------------------------------------\n\nTITLE: Filtering Operations for Maps in TypeScript\nDESCRIPTION: A collection of functions for filtering Map contents, including compact, filter, filterMap, partition, partitionMap, and separate operations that work with Options and Predicates.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Map.ts.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const compact: <K, A>(fa: Map<K, O.Option<A>>) => Map<K, A>\n```\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const filter: {\n  <A, B extends A>(refinement: Refinement<A, B>): <K>(fa: Map<K, A>) => Map<K, B>\n  <A>(predicate: Predicate<A>): <K, B extends A>(fb: Map<K, B>) => Map<K, B>\n  <A>(predicate: Predicate<A>): <K>(fa: Map<K, A>) => Map<K, A>\n}\n```\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const filterMap: <A, B>(f: (a: A) => O.Option<B>) => <K>(fa: Map<K, A>) => Map<K, B>\n```\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare function getFilterableWithIndex<K = never>(): FilterableWithIndex2C<URI, K, K>\n```\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare function getWitherable<K>(O: Ord<K>): Witherable2C<URI, K> & TraversableWithIndex2C<URI, K, K>\n```\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const partition: {\n  <A, B extends A>(refinement: Refinement<A, B>): <K>(fa: Map<K, A>) => Separated<Map<K, A>, Map<K, B>>\n  <A>(predicate: Predicate<A>): <K, B extends A>(fb: Map<K, B>) => Separated<Map<K, B>, Map<K, B>>\n  <A>(predicate: Predicate<A>): <K>(fa: Map<K, A>) => Separated<Map<K, A>, Map<K, A>>\n}\n```\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const partitionMap: <A, B, C>(\n  f: (a: A) => Either<B, C>\n) => <K>(fa: Map<K, A>) => Separated<Map<K, B>, Map<K, C>>\n```\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const separate: <K, A, B>(fa: Map<K, Either<A, B>>) => Separated<Map<K, A>, Map<K, B>>\n```\n\n----------------------------------------\n\nTITLE: Type Class Instances for TaskEither\nDESCRIPTION: Various type class instances for TaskEither including Alt, ApplicativePar, ApplicativeSeq, ApplyPar, ApplySeq, Bifunctor, Chain, FromEither, FromIO, FromTask, Functor, Monad, MonadIO, MonadTask, MonadThrow, and Pointed.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/TaskEither.ts.md#2025-04-23_snippet_34\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const Alt: Alt2<'TaskEither'>\n```\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const ApplicativePar: Applicative2<'TaskEither'>\n```\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const ApplicativeSeq: Applicative2<'TaskEither'>\n```\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const ApplyPar: Apply2<'TaskEither'>\n```\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const ApplySeq: Apply2<'TaskEither'>\n```\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const Bifunctor: Bifunctor2<'TaskEither'>\n```\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const Chain: chainable.Chain2<'TaskEither'>\n```\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const FromEither: FromEither2<'TaskEither'>\n```\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const FromIO: FromIO2<'TaskEither'>\n```\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const FromTask: FromTask2<'TaskEither'>\n```\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const Functor: Functor2<'TaskEither'>\n```\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const Monad: Monad2<'TaskEither'>\n```\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const MonadIO: MonadIO2<'TaskEither'>\n```\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const MonadTask: MonadTask2<'TaskEither'>\n```\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const MonadThrow: MonadThrow2<'TaskEither'>\n```\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const Pointed: Pointed2<'TaskEither'>\n```\n\n----------------------------------------\n\nTITLE: Defining FromIO4 Interface in TypeScript\nDESCRIPTION: Interface for lifting computations from the IO monad to a higher-kinded type F with four type parameters. Supports complex monads with state S, environment R, error E, and value A.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/FromIO.ts.md#2025-04-23_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface FromIO4<F extends URIS4> {\n  readonly URI: F\n  readonly fromIO: <A, S, R, E>(fa: IO<A>) => Kind4<F, S, R, E, A>\n}\n```\n\n----------------------------------------\n\nTITLE: Contramap function for transforming Eq instances in TypeScript\nDESCRIPTION: Allows creating an Eq for type B from an Eq for type A and a function from B to A. Useful for creating equality comparisons based on specific fields.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Eq.ts.md#2025-04-23_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const contramap: <A, B>(f: (b: B) => A) => (fa: Eq<A>) => Eq<B>\n```\n\n----------------------------------------\n\nTITLE: Implementing ap Function for StateT in TypeScript\nDESCRIPTION: Defines the ap function for applying a function wrapped in StateT to a value wrapped in StateT. It supports different arities of StateT (URIS, URIS2, URIS3) and handles error types.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/StateT.ts.md#2025-04-23_snippet_4\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare function ap<M extends URIS3>(\n  M: Chain3<M>\n): <S, R, E, A>(fa: StateT3<M, S, R, E, A>) => <B>(fab: StateT3<M, S, R, E, (a: A) => B>) => StateT3<M, S, R, E, B>\nexport declare function ap<M extends URIS3, E>(\n  M: Chain3C<M, E>\n): <S, R, A>(fa: StateT3<M, S, R, E, A>) => <B>(fab: StateT3<M, S, R, E, (a: A) => B>) => StateT3<M, S, R, E, B>\nexport declare function ap<M extends URIS2>(\n  M: Chain2<M>\n): <S, E, A>(fa: StateT2<M, S, E, A>) => <B>(fab: StateT2<M, S, E, (a: A) => B>) => StateT2<M, S, E, B>\nexport declare function ap<M extends URIS2, E>(\n  M: Chain2C<M, E>\n): <S, A>(fa: StateT2<M, S, E, A>) => <B>(fab: StateT2<M, S, E, (a: A) => B>) => StateT2<M, S, E, B>\nexport declare function ap<M extends URIS>(\n  M: Chain1<M>\n): <S, A>(fa: StateT1<M, S, A>) => <B>(fab: StateT1<M, S, (a: A) => B>) => StateT1<M, S, B>\nexport declare function ap<M>(\n  M: Chain<M>\n): <S, A>(fa: StateT<M, S, A>) => <B>(fab: StateT<M, S, (a: A) => B>) => StateT<M, S, B>\n```\n\n----------------------------------------\n\nTITLE: Example of tuple Eq usage with different types in TypeScript\nDESCRIPTION: Demonstrates how to create and use an Eq instance for tuples containing elements of different types (string, number, and boolean).\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Eq.ts.md#2025-04-23_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\nimport { tuple } from 'fp-ts/Eq'\nimport * as S from 'fp-ts/string'\nimport * as N from 'fp-ts/number'\nimport * as B from 'fp-ts/boolean'\n\nconst E = tuple(S.Eq, N.Eq, B.Eq)\nassert.strictEqual(E.equals(['a', 1, true], ['a', 1, true]), true)\nassert.strictEqual(E.equals(['a', 1, true], ['b', 1, true]), false)\nassert.strictEqual(E.equals(['a', 1, true], ['a', 2, true]), false)\nassert.strictEqual(E.equals(['a', 1, true], ['a', 1, false]), false)\n```\n\n----------------------------------------\n\nTITLE: Defining apW Function for ReaderTaskEither in TypeScript\nDESCRIPTION: Function signature for apW, a less strict version of ap that merges environment and error types. Added in v2.8.0.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReaderTaskEither.ts.md#2025-04-23_snippet_115\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const apW: <R2, E2, A>(\n  fa: ReaderTaskEither<R2, E2, A>\n) => <R1, E1, B>(fab: ReaderTaskEither<R1, E1, (a: A) => B>) => ReaderTaskEither<R1 & R2, E2 | E1, B>\n```\n\n----------------------------------------\n\nTITLE: Binding Functions in Do Notation for TaskEither in TypeScript\nDESCRIPTION: Binds a function to an existing object in a do notation chain.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/TaskEither.ts.md#2025-04-23_snippet_12\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare const bind: <N, A, E, B>(\n  name: Exclude<N, keyof A>,\n  f: (a: A) => TaskEither<E, B>\n) => (ma: TaskEither<E, A>) => TaskEither<E, { readonly [K in N | keyof A]: K extends keyof A ? A[K] : B }>\n```\n\n----------------------------------------\n\nTITLE: ReaderEither Type Definition\nDESCRIPTION: Core type interface definition for ReaderEither that combines Reader and Either monads.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReaderEither.ts.md#2025-04-23_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface ReaderEither<R, E, A> extends Reader<R, Either<E, A>> {}\n```\n\n----------------------------------------\n\nTITLE: Implementing Pipeable Compose Operator in TypeScript\nDESCRIPTION: Provides a pipeable version of compose for composing morphisms in a semigroupoid.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/pipeable.ts.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare function compose<F extends URIS4>(\n  F: Semigroupoid4<F>\n): <S, R, E, A>(ea: Kind4<F, S, R, E, A>) => <B>(ab: Kind4<F, S, R, A, B>) => Kind4<F, S, R, E, B>\n```\n\n----------------------------------------\n\nTITLE: Type Class Instances for StateReaderTaskEither\nDESCRIPTION: Implementation of various type class instances including Functor, Monad, Applicative, and others for StateReaderTaskEither.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/StateReaderTaskEither.ts.md#2025-04-23_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const Functor: Functor4<'StateReaderTaskEither'>\n\nexport declare const Monad: Monad4<'StateReaderTaskEither'>\n\nexport declare const Applicative: Applicative4<'StateReaderTaskEither'>\n\nexport declare const Chain: chainable.Chain4<'StateReaderTaskEither'>\n```\n\n----------------------------------------\n\nTITLE: Mapping Both Channels of TaskEither in TypeScript\nDESCRIPTION: Maps both the error and success channels of a TaskEither.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/TaskEither.ts.md#2025-04-23_snippet_22\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare const mapBoth: {\n  <E, G, A, B>(f: (e: E) => G, g: (a: A) => B): (self: TaskEither<E, A>) => TaskEither<G, B>\n  <E, A, G, B>(self: TaskEither<E, A>, f: (e: E) => G, g: (a: A) => B): TaskEither<G, B>\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing fromReaderK utility in TypeScript\nDESCRIPTION: The fromReaderK utility lifts a function that returns a Reader into a function that returns a value in the target monad. It's useful for converting Reader-based functions to work with higher-level monads.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/FromReader.ts.md#2025-04-23_snippet_9\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare function fromReaderK<F extends URIS4>(\n  F: FromReader4<F>\n): <A extends ReadonlyArray<unknown>, R, B>(f: (...a: A) => Reader<R, B>) => <S, E>(...a: A) => Kind4<F, S, R, E, B>\nexport declare function fromReaderK<F extends URIS3>(\n  F: FromReader3<F>\n): <A extends ReadonlyArray<unknown>, R, B>(f: (...a: A) => Reader<R, B>) => <E>(...a: A) => Kind3<F, R, E, B>\nexport declare function fromReaderK<F extends URIS3, E>(\n  F: FromReader3C<F, E>\n): <A extends ReadonlyArray<unknown>, R, B>(f: (...a: A) => Reader<R, B>) => (...a: A) => Kind3<F, R, E, B>\nexport declare function fromReaderK<F extends URIS2>(\n  F: FromReader2<F>\n): <A extends ReadonlyArray<unknown>, R, B>(f: (...a: A) => Reader<R, B>) => (...a: A) => Kind2<F, R, B>\nexport declare function fromReaderK<F>(\n  F: FromReader<F>\n): <A extends ReadonlyArray<unknown>, R, B>(f: (...a: A) => Reader<R, B>) => (...a: A) => HKT2<F, R, B>\n```\n\n----------------------------------------\n\nTITLE: Defining Monad2 Interface for URIS2 in TypeScript\nDESCRIPTION: Defines the Monad2 interface for higher-kinded types with two type parameters. It extends Applicative2 and Chain2 interfaces.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Monad.ts.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface Monad2<M extends URIS2> extends Applicative2<M>, Chain2<M> {}\n```\n\n----------------------------------------\n\nTITLE: Tapping IOEither Values in TypeScript\nDESCRIPTION: The tap function composes computations in sequence, using the return value of one computation to determine the next computation and keeping only the result of the first.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/IOEither.ts.md#2025-04-23_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare const tap: {\n  <E1, A, E2, _>(self: IOEither<E1, A>, f: (a: A) => IOEither<E2, _>): IOEither<E1 | E2, A>\n  <A, E2, _>(f: (a: A) => IOEither<E2, _>): <E1>(self: IOEither<E1, A>) => IOEither<E2 | E1, A>\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Union of Two ReadonlyNonEmptyArrays with Eq in TypeScript\nDESCRIPTION: Function that creates a union of two ReadonlyNonEmptyArrays using the provided Eq instance to determine equality between elements, avoiding duplicates in the result.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReadonlyNonEmptyArray.ts.md#2025-04-23_snippet_63\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const union: <A>(\n  E: Eq<A>\n) => (second: ReadonlyNonEmptyArray<A>) => (first: ReadonlyNonEmptyArray<A>) => ReadonlyNonEmptyArray<A>\n```\n\n----------------------------------------\n\nTITLE: Implementing Chain3C Interface for URIS3 with Fixed Error Type\nDESCRIPTION: Chain interface for type constructors with three type parameters but fixed error type, extending Apply3C.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Chain.ts.md#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface Chain3C<F extends URIS3, E> extends Apply3C<F, E> {\n  readonly chain: <R, A, B>(fa: Kind3<F, R, E, A>, f: (a: A) => Kind3<F, R, E, B>) => Kind3<F, R, E, B>\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing flatMap for Sequential Composition\nDESCRIPTION: Composes ReaderTaskEither operations sequentially, using the result of the first operation to determine the next operation while handling errors.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReaderTaskEither.ts.md#2025-04-23_snippet_84\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const flatMap: {\n  <A, R2, E2, B>(f: (a: A) => ReaderTaskEither<R2, E2, B>): <R1, E1>(\n    ma: ReaderTaskEither<R1, E1, A>\n  ) => ReaderTaskEither<R1 & R2, E2 | E1, B>\n  <R1, E1, A, R2, E2, B>(ma: ReaderTaskEither<R1, E1, A>, f: (a: A) => ReaderTaskEither<R2, E2, B>): ReaderTaskEither<\n    R1 & R2,\n    E1 | E2,\n    B\n  >\n}\n```\n\n----------------------------------------\n\nTITLE: Folding Set Elements with Monoid in TypeScript\nDESCRIPTION: Applies a function to each element of the set and combines the results using a Monoid. Requires both an ordering function and a Monoid instance.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Set.ts.md#2025-04-23_snippet_3\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare const foldMap: <A, M>(O: Ord<A>, M: Monoid<M>) => (f: (a: A) => M) => (fa: Set<A>) => M\n```\n\n----------------------------------------\n\nTITLE: Equals Function for Ord in TypeScript\nDESCRIPTION: Creates a function to test equality between two values using an Ord instance. This is a curried version for easier composition.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Ord.ts.md#2025-04-23_snippet_14\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const equals: <A>(O: Ord<A>) => (second: A) => (first: A) => boolean\n```\n\n----------------------------------------\n\nTITLE: Creating TraversableWithIndex Instance for Records in TypeScript\nDESCRIPTION: Produces a TraversableWithIndex instance for a Record, using the provided Ord to sort the Record's entries by key. TraversableWithIndex extends Traversable with operations that also provide the index of each element.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Record.ts.md#2025-04-23_snippet_21\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const getTraversableWithIndex: (O: Ord<string>) => TraversableWithIndex1<URI, string>\n```\n\n----------------------------------------\n\nTITLE: Array Grouping Implementation\nDESCRIPTION: Example of grouping array elements based on equality using the group function.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/NonEmptyArray.ts.md#2025-04-23_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nimport { group } from 'fp-ts/NonEmptyArray'\nimport * as N from 'fp-ts/number'\n\nassert.deepStrictEqual(group(N.Ord)([1, 2, 1, 1]), [[1], [2], [1, 1]])\n```\n\n----------------------------------------\n\nTITLE: Updating Element at Index in ReadonlyNonEmptyArray in TypeScript\nDESCRIPTION: Function that replaces the element at a specific index in a ReadonlyNonEmptyArray with a new value. Returns an Option that contains the updated array if the index is valid.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReadonlyNonEmptyArray.ts.md#2025-04-23_snippet_67\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const updateAt: <A>(\n  i: number,\n  a: A\n) => (as: ReadonlyNonEmptyArray<A>) => Option<ReadonlyNonEmptyArray<A>>\n```\n\n----------------------------------------\n\nTITLE: Converting Array to ReadonlySet in TypeScript\nDESCRIPTION: Function to create a ReadonlySet from a ReadonlyArray, requiring an equality comparison function\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReadonlySet.ts.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const fromReadonlyArray: <A>(E: Eq<A>) => (as: readonly A[]) => ReadonlySet<A>\n```\n\n----------------------------------------\n\nTITLE: Implementing match for EitherT in TypeScript\nDESCRIPTION: Defines the match function for EitherT, which applies different functions to the left and right cases of an Either. It handles different URIS for functors.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/EitherT.ts.md#2025-04-23_snippet_2\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare function match<F extends URIS3>(\n  F: Functor3<F>\n): <E, B, A>(\n  onLeft: (e: E) => B,\n  onRight: (a: A) => B\n) => <R, ME>(ma: Kind3<F, R, ME, Either<E, A>>) => Kind3<F, R, ME, B>\nexport declare function match<F extends URIS3, FE>(\n  F: Functor3C<F, FE>\n): <E, B, A>(onLeft: (e: E) => B, onRight: (a: A) => B) => <R>(ma: Kind3<F, R, FE, Either<E, A>>) => Kind3<F, R, FE, B>\nexport declare function match<F extends URIS2>(\n  F: Functor2<F>\n): <E, B, A>(onLeft: (e: E) => B, onRight: (a: A) => B) => <FE>(ma: Kind2<F, FE, Either<E, A>>) => Kind2<F, FE, B>\nexport declare function match<F extends URIS2, FE>(\n  F: Functor2C<F, FE>\n): <E, B, A>(onLeft: (e: E) => B, onRight: (a: A) => B) => (ma: Kind2<F, FE, Either<E, A>>) => Kind2<F, FE, B>\nexport declare function match<F extends URIS>(\n  F: Functor1<F>\n): <E, B, A>(onLeft: (e: E) => B, onRight: (a: A) => B) => (ma: Kind<F, Either<E, A>>) => Kind<F, B>\nexport declare function match<F>(\n  F: Functor<F>\n): <E, B, A>(onLeft: (e: E) => B, onRight: (a: A) => B) => (ma: HKT<F, Either<E, A>>) => HKT<F, B>\n```\n\n----------------------------------------\n\nTITLE: Implementing FromPredicate Function in TypeScript\nDESCRIPTION: Defines a function that creates a new value from a predicate condition, supporting different URI levels. It can work with both regular predicates and refinement types, providing type safety with proper error handling.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/FromEither.ts.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare function fromPredicate<F extends URIS4>(\n  F: FromEither4<F>\n): {\n  <A, B extends A, E>(refinement: Refinement<A, B>, onFalse: (a: A) => E): <S, R>(a: A) => Kind4<F, S, R, E, B>\n  <A, E>(predicate: Predicate<A>, onFalse: (a: A) => E): <S, R, B extends A>(b: B) => Kind4<F, S, R, E, B>\n  <A, E>(predicate: Predicate<A>, onFalse: (a: A) => E): <S, R>(a: A) => Kind4<F, S, R, E, A>\n}\nexport declare function fromPredicate<F extends URIS3>(\n  F: FromEither3<F>\n): {\n  <A, B extends A, E>(refinement: Refinement<A, B>, onFalse: (a: A) => E): <R>(a: A) => Kind3<F, R, E, B>\n  <A, E>(predicate: Predicate<A>, onFalse: (a: A) => E): <R, B extends A>(b: B) => Kind3<F, R, E, B>\n  <A, E>(predicate: Predicate<A>, onFalse: (a: A) => E): <R>(a: A) => Kind3<F, R, E, A>\n}\nexport declare function fromPredicate<F extends URIS3, E>(\n  F: FromEither3C<F, E>\n): {\n  <A, B extends A>(refinement: Refinement<A, B>, onFalse: (a: A) => E): <R>(a: A) => Kind3<F, R, E, B>\n  <A>(predicate: Predicate<A>, onFalse: (a: A) => E): <R, B extends A>(b: B) => Kind3<F, R, E, B>\n  <A>(predicate: Predicate<A>, onFalse: (a: A) => E): <R>(a: A) => Kind3<F, R, E, A>\n}\nexport declare function fromPredicate<F extends URIS2>(\n  F: FromEither2<F>\n): {\n  <A, B extends A, E>(refinement: Refinement<A, B>, onFalse: (a: A) => E): (a: A) => Kind2<F, E, B>\n  <A, E>(predicate: Predicate<A>, onFalse: (a: A) => E): <B extends A>(b: B) => Kind2<F, E, B>\n  <A, E>(predicate: Predicate<A>, onFalse: (a: A) => E): (a: A) => Kind2<F, E, A>\n}\nexport declare function fromPredicate<F extends URIS2, E>(\n  F: FromEither2C<F, E>\n): {\n  <A, B extends A>(refinement: Refinement<A, B>, onFalse: (a: A) => E): (a: A) => Kind2<F, E, B>\n  <A>(predicate: Predicate<A>, onFalse: (a: A) => E): <B extends A>(b: B) => Kind2<F, E, B>\n  <A>(predicate: Predicate<A>, onFalse: (a: A) => E): (a: A) => Kind2<F, E, A>\n}\nexport declare function fromPredicate<F>(F: FromEither<F>): {\n  <A, B extends A, E>(refinement: Refinement<A, B>, onFalse: (a: A) => E): (a: A) => HKT2<F, E, B>\n  <A, E>(predicate: Predicate<A>, onFalse: (a: A) => E): <B extends A>(b: B) => HKT2<F, E, B>\n  <A, E>(predicate: Predicate<A>, onFalse: (a: A) => E): (a: A) => HKT2<F, E, A>\n}\n```\n\n----------------------------------------\n\nTITLE: ReaderTask Core Type Class Instances\nDESCRIPTION: Basic type class instances for ReaderTask including Functor, Apply, Chain, and Monad implementations.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReaderTask.ts.md#2025-04-23_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const ApplyPar: Apply2<'ReaderTask'>\n```\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const ApplySeq: Apply2<'ReaderTask'>\n```\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const Chain: chainable.Chain2<'ReaderTask'>\n```\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const Functor: Functor2<'ReaderTask'>\n```\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const Monad: Monad2<'ReaderTask'>\n```\n\n----------------------------------------\n\nTITLE: Creating Bifunctor2C Interface in TypeScript\nDESCRIPTION: Defines the Bifunctor2C interface for handling two-parameter type constructors with a fixed error type. It includes methods for bimap and mapLeft operations.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Bifunctor.ts.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface Bifunctor2C<F extends URIS2, E> {\n  readonly URI: F\n  readonly _E: E\n  readonly bimap: <A, G, B>(fea: Kind2<F, E, A>, f: (e: E) => G, g: (a: A) => B) => Kind2<F, G, B>\n  readonly mapLeft: <A, M>(fea: Kind2<F, E, A>, f: (e: E) => M) => Kind2<F, M, A>\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Endomorphism Interface in TypeScript\nDESCRIPTION: Defines the Endomorphism interface which represents a function that takes a value of type A and returns a value of the same type A.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Endomorphism.ts.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface Endomorphism<A> {\n  (a: A): A\n}\n```\n\n----------------------------------------\n\nTITLE: Converting Option to TaskEither in TypeScript\nDESCRIPTION: Converts an Option to a TaskEither, providing a function to handle the None case.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/TaskEither.ts.md#2025-04-23_snippet_5\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare const fromOption: <E>(onNone: LazyArg<E>) => <A>(fa: Option<A>) => TaskEither<E, A>\n```\n\n----------------------------------------\n\nTITLE: Converting Record to Array in TypeScript\nDESCRIPTION: Converts a Record to a sorted Array of key/value pairs using the toArray function.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Record.ts.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { toArray } from 'fp-ts/Record'\n\nconst x = { c: 3, a: 'foo', b: false }\nassert.deepStrictEqual(toArray(x), [\n  ['a', 'foo'],\n  ['b', false],\n  ['c', 3],\n])\n```\n\n----------------------------------------\n\nTITLE: Defining Comonad2C Interface for URIS2 with Fixed Type in TypeScript\nDESCRIPTION: Defines the Comonad2C interface extending Extend2C for higher-kinded types of arity 2 with a fixed type parameter E.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Comonad.ts.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface Comonad2C<W extends URIS2, E> extends Extend2C<W, E> {\n  readonly extract: <A>(wa: Kind2<W, E, A>) => A\n}\n```\n\n----------------------------------------\n\nTITLE: Ord Interface Definition in TypeScript\nDESCRIPTION: Definition of the Ord interface that extends Eq and adds a compare method for ordering. This is the core type for representing total orderings.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Ord.ts.md#2025-04-23_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface Ord<A> extends Eq<A> {\n  readonly compare: (first: A, second: A) => Ordering\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Pattern Matching for TaskThese in TypeScript\nDESCRIPTION: Provides pattern matching functions like match, matchE, and their widening variants for handling different cases of TaskThese.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/TaskThese.ts.md#2025-04-23_snippet_4\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare const match: <E, B, A>(\n  onLeft: (e: E) => B,\n  onRight: (a: A) => B,\n  onBoth: (e: E, a: A) => B\n) => (fa: TaskThese<E, A>) => T.Task<B>\n\nexport declare const matchE: <E, B, A>(\n  onLeft: (e: E) => T.Task<B>,\n  onRight: (a: A) => T.Task<B>,\n  onBoth: (e: E, a: A) => T.Task<B>\n) => (fa: TaskThese<E, A>) => T.Task<B>\n\nexport declare const matchW: <E, B, A, C, D>(\n  onLeft: (e: E) => B,\n  onRight: (a: A) => C,\n  onBoth: (e: E, a: A) => D\n) => (ma: TaskThese<E, A>) => T.Task<B | C | D>\n\nexport declare const matchEW: <E, B, A, C, D>(\n  onLeft: (e: E) => T.Task<B>,\n  onRight: (a: A) => T.Task<C>,\n  onBoth: (e: E, a: A) => T.Task<D>\n) => (fa: TaskThese<E, A>) => T.Task<B | C | D>\n```\n\n----------------------------------------\n\nTITLE: Partitioning Records with mapWithIndex using Either in fp-ts\nDESCRIPTION: Maps a Record with a function returning an Either and partitions the resulting Record into Left and Right categories. Useful for splitting records based on conditions with transformation.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Record.ts.md#2025-04-23_snippet_41\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const partitionMapWithIndex: <K extends string, A, B, C>(\n  f: (key: K, a: A) => Either<B, C>\n) => (fa: Record<K, A>) => Separated<Record<string, B>, Record<string, C>>\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport { partitionMapWithIndex } from 'fp-ts/Record'\nimport { either } from 'fp-ts'\n\nconst f = (key: string, a: number) =>\n  a >= 0 ? either.right(`${key} is >= 0 (${a})`) : either.left(`${key} is < 0 (${a})`)\nassert.deepStrictEqual(partitionMapWithIndex(f)({ a: -1, b: 2, c: 123 }), {\n  left: {\n    a: 'a is < 0 (-1)',\n  },\n  right: {\n    b: 'b is >= 0 (2)',\n    c: 'c is >= 0 (123)',\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Implementing chainReaderK utility in TypeScript\nDESCRIPTION: The chainReaderK utility composes a computation with a Reader-returning function, transforming the result. It enables chaining computations that depend on the environment.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/FromReader.ts.md#2025-04-23_snippet_8\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare function chainReaderK<M extends URIS4>(\n  F: FromReader4<M>,\n  M: Chain4<M>\n): <A, R, B>(f: (a: A) => Reader<R, B>) => <S, E>(ma: Kind4<M, S, R, E, A>) => Kind4<M, S, R, E, B>\nexport declare function chainReaderK<M extends URIS3>(\n  F: FromReader3<M>,\n  M: Chain3<M>\n): <A, R, B>(f: (a: A) => Reader<R, B>) => <E>(ma: Kind3<M, R, E, A>) => Kind3<M, R, E, B>\nexport declare function chainReaderK<M extends URIS3, E>(\n  F: FromReader3C<M, E>,\n  M: Chain3C<M, E>\n): <A, R, B>(f: (a: A) => Reader<R, B>) => (ma: Kind3<M, R, E, A>) => Kind3<M, R, E, B>\nexport declare function chainReaderK<M extends URIS2>(\n  F: FromReader2<M>,\n  M: Chain2<M>\n): <A, R, B>(f: (a: A) => Reader<R, B>) => (ma: Kind2<M, R, A>) => Kind2<M, R, B>\nexport declare function chainReaderK<M>(\n  F: FromReader<M>,\n  M: Chain<M>\n): <A, R, B>(f: (a: A) => Reader<R, B>) => (ma: HKT2<M, R, A>) => HKT2<M, R, B>\n```\n\n----------------------------------------\n\nTITLE: Implementing mapWithIndex Composition Function in TypeScript\nDESCRIPTION: Utility function for composing mapWithIndex operations from two FunctorWithIndex instances, allowing nested mapping with indices from both structures.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/FunctorWithIndex.ts.md#2025-04-23_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare function mapWithIndex<F extends URIS, I, G extends URIS, J>(\n  F: FunctorWithIndex1<F, I>,\n  G: FunctorWithIndex1<G, J>\n): <A, B>(f: (ij: readonly [I, J], a: A) => B) => (fa: Kind<F, Kind<G, A>>) => Kind<F, Kind<G, B>>\nexport declare function mapWithIndex<F, I, G, J>(\n  F: FunctorWithIndex<F, I>,\n  G: FunctorWithIndex<G, J>\n): <A, B>(f: (ij: readonly [I, J], a: A) => B) => (fa: HKT<F, HKT<G, A>>) => HKT<F, HKT<G, B>>\n```\n\n----------------------------------------\n\nTITLE: Implementing Mapping Functions for TaskThese in TypeScript\nDESCRIPTION: Provides mapping functions like map, bimap, and mapLeft for transforming TaskThese values.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/TaskThese.ts.md#2025-04-23_snippet_3\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare const map: <A, B>(f: (a: A) => B) => <E>(fa: TaskThese<E, A>) => TaskThese<E, B>\n\nexport declare const bimap: <E, G, A, B>(f: (e: E) => G, g: (a: A) => B) => (fa: TaskThese<E, A>) => TaskThese<G, B>\n\nexport declare const mapLeft: <E, G>(f: (e: E) => G) => <A>(fa: TaskThese<E, A>) => TaskThese<G, A>\n```\n\n----------------------------------------\n\nTITLE: Creating Apply instance for Const with Semigroup in TypeScript\nDESCRIPTION: Returns an Apply instance for Const given a Semigroup for the first type parameter. This enables combining Const values using the provided Semigroup.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Const.ts.md#2025-04-23_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare function getApply<E>(S: Semigroup<E>): Apply2C<URI, E>\n```\n\n----------------------------------------\n\nTITLE: Implementing seek Function for Store in TypeScript\nDESCRIPTION: Defines the seek function for Store, repositioning the focus to a specified position.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Store.ts.md#2025-04-23_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare function seek<S>(s: S): <A>(wa: Store<S, A>) => Store<S, A>\n```\n\n----------------------------------------\n\nTITLE: Implementing as for StateReaderTaskEither in TypeScript\nDESCRIPTION: Defines a function to map the Right value of a StateReaderTaskEither to a constant value.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/StateReaderTaskEither.ts.md#2025-04-23_snippet_36\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare const as: {\n  <A>(a: A): <S, R, E, _>(self: StateReaderTaskEither<S, R, E, _>) => StateReaderTaskEither<S, R, E, A>\n  <S, R, E, _, A>(self: StateReaderTaskEither<S, R, E, _>, a: A): StateReaderTaskEither<S, R, E, A>\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing filterOrElseW operation for Either in TypeScript\nDESCRIPTION: Defines a less strict version of filterOrElse where the error types will be merged.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Either.ts.md#2025-04-23_snippet_14\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare const filterOrElseW: {\n  <A, B extends A, E2>(refinement: Refinement<A, B>, onFalse: (a: A) => E2): <E1>(ma: Either<E1, A>) => Either<E2 | E1, B>\n  <A, E2>(predicate: Predicate<A>, onFalse: (a: A) => E2): <E1, B extends A>(mb: Either<E1, B>) => Either<E2 | E1, B>\n  <A, E2>(predicate: Predicate<A>, onFalse: (a: A) => E2): <E1>(ma: Either<E1, A>) => Either<E2 | E1, A>\n}\n```\n\n----------------------------------------\n\nTITLE: Pattern Matching for Ordering\nDESCRIPTION: Function for pattern matching on Ordering values with three handlers for less than, equal, and greater than cases.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Ordering.ts.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const match: <A>(onLessThan: () => A, onEqual: () => A, onGreaterThan: () => A) => (o: Ordering) => A\n```\n\n----------------------------------------\n\nTITLE: Removing Duplicates from ReadonlyNonEmptyArray with Eq in TypeScript\nDESCRIPTION: Function that removes duplicate elements from a ReadonlyNonEmptyArray using the provided Eq instance to determine equality, keeping the first occurrence of each element.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReadonlyNonEmptyArray.ts.md#2025-04-23_snippet_64\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const uniq: <A>(E: Eq<A>) => (as: ReadonlyNonEmptyArray<A>) => ReadonlyNonEmptyArray<A>\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport { uniq } from 'fp-ts/ReadonlyNonEmptyArray'\nimport * as N from 'fp-ts/number'\n\nassert.deepStrictEqual(uniq(N.Eq)([1, 2, 1]), [1, 2])\n```\n\n----------------------------------------\n\nTITLE: Utility Functions for Reader in TypeScript\nDESCRIPTION: Defines various utility functions for working with Reader instances, including ApT, ap, apFirst, apSecond, and their widening variants.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Reader.ts.md#2025-04-23_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const ApT: Reader<unknown, readonly []>\n\nexport declare const ap: <R, A>(fa: Reader<R, A>) => <B>(fab: Reader<R, (a: A) => B>) => Reader<R, B>\n\nexport declare const apFirst: <E, B>(second: Reader<E, B>) => <A>(first: Reader<E, A>) => Reader<E, A>\n\nexport declare const apFirstW: <R2, B>(second: Reader<R2, B>) => <R1, A>(first: Reader<R1, A>) => Reader<R1 & R2, A>\n\nexport declare const apSecond: <E, B>(second: Reader<E, B>) => <A>(first: Reader<E, A>) => Reader<E, B>\n\nexport declare const apSecondW: <R2, B>(second: Reader<R2, B>) => <R1, A>(first: Reader<R1, A>) => Reader<R1 & R2, B>\n\nexport declare const apW: <R2, A>(fa: Reader<R2, A>) => <R1, B>(fab: Reader<R1, (a: A) => B>) => Reader<R1 & R2, B>\n```\n\n----------------------------------------\n\nTITLE: Creating Compactable instance for Either in TypeScript\nDESCRIPTION: Defines a function to create a Compactable instance for Either given a Monoid for the left side.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Either.ts.md#2025-04-23_snippet_15\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare const getCompactable: <E>(M: Monoid<E>) => Compactable2C<'Either', E>\n```\n\n----------------------------------------\n\nTITLE: Implementing match Function for Pattern Matching in TypeScript\nDESCRIPTION: Handles both Left and Right cases of a TaskEither, returning a Task with the result of applying the corresponding function.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/TaskEither.ts.md#2025-04-23_snippet_62\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const match: <E, B, A>(onLeft: (e: E) => B, onRight: (a: A) => B) => (ma: TaskEither<E, A>) => T.Task<B>\n```\n\n----------------------------------------\n\nTITLE: Example Usage of reverse Function in TypeScript\nDESCRIPTION: Demonstrates how to use the reverse function with a number Magma to perform subtraction in reverse order on an array of numbers.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Magma.ts.md#2025-04-23_snippet_7\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { reverse, concatAll } from 'fp-ts/Magma'\nimport * as N from 'fp-ts/number'\n\nconst subAll = concatAll(reverse(N.MagmaSub))(0)\n\nassert.deepStrictEqual(subAll([1, 2, 3]), 2)\n```\n\n----------------------------------------\n\nTITLE: Implementing AltW operation for Either in TypeScript\nDESCRIPTION: Defines a less strict version of the alt function, where the error and return types will be merged.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Either.ts.md#2025-04-23_snippet_5\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare const altW: <E2, B>(that: LazyArg<Either<E2, B>>) => <E1, A>(fa: Either<E1, A>) => Either<E2, B | A>\n```\n\n----------------------------------------\n\nTITLE: Implementing reduce operation for Either in TypeScript\nDESCRIPTION: Defines a function for left-associative fold of an Either structure.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Either.ts.md#2025-04-23_snippet_19\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare const reduce: <A, B>(b: B, f: (b: B, a: A) => B) => <E>(fa: Either<E, A>) => B\n```\n\n----------------------------------------\n\nTITLE: Implementing liftNullable for Handling Nullable Values in TypeScript\nDESCRIPTION: Creates a function that transforms a nullable-returning function into a TaskEither-returning function, using onNullable to handle null/undefined values.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/TaskEither.ts.md#2025-04-23_snippet_54\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const liftNullable: <A extends readonly unknown[], B, E>(\n  f: (...a: A) => B | null | undefined,\n  onNullable: (...a: A) => E\n) => (...a: A) => TaskEither<E, NonNullable<B>>\n```\n\n----------------------------------------\n\nTITLE: Implementing BooleanAlgebra Interface\nDESCRIPTION: Creates a BooleanAlgebra instance for the boolean type\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/boolean.ts.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const BooleanAlgebra: BA.BooleanAlgebra<boolean>\n```\n\n----------------------------------------\n\nTITLE: Modifying Head Element in ReadonlyNonEmptyArray in TypeScript\nDESCRIPTION: Function that applies a transformation function to the first element (head) of a ReadonlyNonEmptyArray, creating a new array with the modified element.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReadonlyNonEmptyArray.ts.md#2025-04-23_snippet_53\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const modifyHead: <A>(f: Endomorphism<A>) => (as: ReadonlyNonEmptyArray<A>) => ReadonlyNonEmptyArray<A>\n```\n\n----------------------------------------\n\nTITLE: Implementing altAll Utility Function for Alt Operations\nDESCRIPTION: A utility function for combining multiple Alt values, overloaded for different types. Takes an Alt instance and returns a function that combines a starting value with an array of values using the alt operation.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Alt.ts.md#2025-04-23_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare function altAll<F extends URIS4>(\n  F: Alt4<F>\n): <S, R, E, A>(startWith: Kind4<F, S, R, E, A>) => (as: ReadonlyArray<Kind4<F, S, R, E, A>>) => Kind4<F, S, R, E, A>\nexport declare function altAll<F extends URIS3>(\n  F: Alt3<F>\n): <R, E, A>(startWith: Kind3<F, R, E, A>) => (as: ReadonlyArray<Kind3<F, R, E, A>>) => Kind3<F, R, E, A>\nexport declare function altAll<F extends URIS3, E>(\n  F: Alt3C<F, E>\n): <R, A>(startWith: Kind3<F, R, E, A>) => (as: ReadonlyArray<Kind3<F, R, E, A>>) => Kind3<F, R, E, A>\nexport declare function altAll<F extends URIS2>(\n  F: Alt2<F>\n): <E, A>(startWith: Kind2<F, E, A>) => (as: ReadonlyArray<Kind2<F, E, A>>) => Kind2<F, E, A>\nexport declare function altAll<F extends URIS2, E>(\n  F: Alt2C<F, E>\n): <A>(startWith: Kind2<F, E, A>) => (as: ReadonlyArray<Kind2<F, E, A>>) => Kind2<F, E, A>\nexport declare function altAll<F extends URIS>(\n  F: Alt1<F>\n): <A>(startWith: Kind<F, A>) => (as: ReadonlyArray<Kind<F, A>>) => Kind<F, A>\nexport declare function altAll<F>(F: Alt<F>): <A>(startWith: HKT<F, A>) => (as: ReadonlyArray<HKT<F, A>>) => HKT<F, A>\n```\n\n----------------------------------------\n\nTITLE: Creating a singleton ReadonlyMap in TypeScript\nDESCRIPTION: Creates a ReadonlyMap with a single key/value pair.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReadonlyMap.ts.md#2025-04-23_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare const singleton: <K, A>(k: K, a: A) => ReadonlyMap<K, A>\n```\n\n----------------------------------------\n\nTITLE: Implementing fromTaskOptionK for Lifting TaskOption Functions in TypeScript\nDESCRIPTION: Creates a function that transforms a TaskOption-returning function into a TaskEither-returning function, handling None with the provided onNone function.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/TaskEither.ts.md#2025-04-23_snippet_53\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const fromTaskOptionK: <E>(\n  onNone: LazyArg<E>\n) => <A extends readonly unknown[], B>(f: (...a: A) => TaskOption<B>) => (...a: A) => TaskEither<E, B>\n```\n\n----------------------------------------\n\nTITLE: Defining Applicative2 Interface for Binary Type Constructors\nDESCRIPTION: Specialized Applicative interface for type constructors with two type parameters, using the URIS2 system for higher-kinded types.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Applicative.ts.md#2025-04-23_snippet_2\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport interface Applicative2<F extends URIS2> extends Apply2<F>, Pointed2<F> {}\n```\n\n----------------------------------------\n\nTITLE: Defining map function for ReaderIO in TypeScript\nDESCRIPTION: Maps over the value of a ReaderIO. It takes a function and a ReaderIO, and returns a new ReaderIO with the function applied to its value.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReaderIO.ts.md#2025-04-23_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const map: <A, B>(f: (a: A) => B) => <R>(fa: ReaderIO<R, A>) => ReaderIO<R, B>\n```\n\n----------------------------------------\n\nTITLE: Defining MonadTask Interface in TypeScript\nDESCRIPTION: Defines the MonadTask interface extending MonadIO and FromTask for generic type M.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/MonadTask.ts.md#2025-04-23_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport interface MonadTask<M> extends MonadIO<M>, FromTask<M> {}\n```\n\n----------------------------------------\n\nTITLE: Sign to Ordering Conversion\nDESCRIPTION: Function to convert a number to an Ordering based on its sign.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Ordering.ts.md#2025-04-23_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const sign: (n: number) => Ordering\n```\n\n----------------------------------------\n\nTITLE: Checking Element Existence with Equality in Records\nDESCRIPTION: Determines if a Record contains a value equal to a provided value using a given Eq instance. The function can be used in both curried and non-curried forms.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Record.ts.md#2025-04-23_snippet_26\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const elem: <A>(E: Eq<A>) => {\n  (a: A): (fa: Record<string, A>) => boolean\n  (a: A, fa: Record<string, A>): boolean\n}\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport { elem } from 'fp-ts/Record'\nimport { number } from 'fp-ts'\n\nassert.deepStrictEqual(elem(number.Eq)(123, { foo: 123, bar: 234 }), true)\nassert.deepStrictEqual(elem(number.Eq)(-7, { foo: 123, bar: 234 }), false)\n```\n\n----------------------------------------\n\nTITLE: Reader Monad Example Implementation in TypeScript\nDESCRIPTION: Demonstrates usage of the Reader monad for accessing variable bindings in a shared environment. Shows how to define bindings, perform lookups, and make assertions about the environment state.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Reader.ts.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { pipe } from 'fp-ts/function'\nimport * as O from 'fp-ts/Option'\nimport * as R from 'fp-ts/Reader'\nimport * as RR from 'fp-ts/ReadonlyRecord'\n\ninterface Bindings extends RR.ReadonlyRecord<string, number> {}\n\n// The Reader monad, which implements this complicated check.\nconst isCountCorrect: R.Reader<Bindings, boolean> = pipe(\n  R.Do,\n  R.bind('count', () => R.asks(lookupVar('count'))),\n  R.bind('bindings', () => R.ask()),\n  R.map(({ count, bindings }) => count === RR.size(bindings))\n)\n\n// The selector function to use with 'asks'.\n// Returns value of the variable with specified name.\nconst lookupVar =\n  (name: string) =>\n  (bindings: Bindings): number =>\n    pipe(\n      bindings,\n      RR.lookup(name),\n      O.getOrElse(() => 0)\n    )\n\nconst sampleBindings: Bindings = { count: 3, a: 1, b: 2 }\n\nassert.deepStrictEqual(isCountCorrect(sampleBindings), true)\n```\n\n----------------------------------------\n\nTITLE: Creating Eq instance for Const in TypeScript\nDESCRIPTION: Creates an Eq instance for Const given an Eq for the first type parameter. This allows comparing Const values for equality.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Const.ts.md#2025-04-23_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const getEq: <E, A>(E: Eq<E>) => Eq<Const<E, A>>\n```\n\n----------------------------------------\n\nTITLE: Implementing MonadIO2C Interface with Error Type\nDESCRIPTION: Extends the MonadIO pattern to support higher-kinded types with two type parameters (URIS2) and a fixed error type E.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/MonadIO.ts.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface MonadIO2C<M extends URIS2, E> extends Monad2C<M, E>, FromIO2C<M, E> {}\n```\n\n----------------------------------------\n\nTITLE: Defining Chain Interface in TypeScript\nDESCRIPTION: The base Chain interface that extends Apply with a chain operation for sequential computation composition.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Chain.ts.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface Chain<F> extends Apply<F> {\n  readonly chain: <A, B>(fa: HKT<F, A>, f: (a: A) => HKT<F, B>) => HKT<F, B>\n}\n```\n\n----------------------------------------\n\nTITLE: Handling Errors with IO in TaskEither in TypeScript\nDESCRIPTION: Provides an IO action to handle errors in TaskEither.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/TaskEither.ts.md#2025-04-23_snippet_25\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare const orElseFirstIOK: <E, B>(onLeft: (e: E) => IO<B>) => <A>(ma: TaskEither<E, A>) => TaskEither<E, A>\n```\n\n----------------------------------------\n\nTITLE: Defining Semiring Interface in TypeScript\nDESCRIPTION: Defines the Semiring interface with add, zero, mul, and one operations. This interface represents types that support addition and multiplication operations with specific algebraic laws.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Semiring.ts.md#2025-04-23_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport interface Semiring<A> {\n  readonly add: (x: A, y: A) => A\n  readonly zero: A\n  readonly mul: (x: A, y: A) => A\n  readonly one: A\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing bind for StateReaderTaskEither in TypeScript\nDESCRIPTION: Provides bind function that allows sequential composition of StateReaderTaskEither operations, binding the result to a named property in a record while maintaining type safety.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/StateReaderTaskEither.ts.md#2025-04-23_snippet_67\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare const bind: <N, A, S, R, E, B>(\n  name: Exclude<N, keyof A>,\n  f: (a: A) => StateReaderTaskEither<S, R, E, B>\n) => (\n  ma: StateReaderTaskEither<S, R, E, A>\n) => StateReaderTaskEither<S, R, E, { readonly [K in N | keyof A]: K extends keyof A ? A[K] : B }>\n```\n\n----------------------------------------\n\nTITLE: Implementing toReadonlyArray Function in TypeScript\nDESCRIPTION: Utility function that converts a Foldable data structure into a readonly array of its values, preserving the traversal order.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Foldable.ts.md#2025-04-23_snippet_14\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare function toReadonlyArray<F extends URIS4>(\n  F: Foldable4<F>\n): <S, R, E, A>(fa: Kind4<F, S, R, E, A>) => ReadonlyArray<A>\nexport declare function toReadonlyArray<F extends URIS3>(\n  F: Foldable3<F>\n): <R, E, A>(fa: Kind3<F, R, E, A>) => ReadonlyArray<A>\nexport declare function toReadonlyArray<F extends URIS3, E>(\n  F: Foldable3C<F, E>\n): <R, A>(fa: Kind3<F, R, E, A>) => ReadonlyArray<A>\nexport declare function toReadonlyArray<F extends URIS2>(\n  F: Foldable2<F>\n): <E, A>(fa: Kind2<F, E, A>) => ReadonlyArray<A>\nexport declare function toReadonlyArray<F extends URIS2, E>(\n  F: Foldable2C<F, E>\n): <A>(fa: Kind2<F, E, A>) => ReadonlyArray<A>\nexport declare function toReadonlyArray<F extends URIS>(F: Foldable1<F>): <A>(fa: Kind<F, A>) => ReadonlyArray<A>\nexport declare function toReadonlyArray<F>(F: Foldable<F>): <A>(fa: HKT<F, A>) => ReadonlyArray<A>\n```\n\n----------------------------------------\n\nTITLE: Implementing Constructors for TaskThese in TypeScript\nDESCRIPTION: Provides constructor functions for creating TaskThese instances, including both, left, right, and their IO and Task variants.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/TaskThese.ts.md#2025-04-23_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare const both: <E, A>(e: E, a: A) => TaskThese<E, A>\n\nexport declare const left: <E = never, A = never>(e: E) => TaskThese<E, A>\n\nexport declare const right: <E = never, A = never>(a: A) => TaskThese<E, A>\n\nexport declare const leftIO: <E = never, A = never>(me: IO<E>) => TaskThese<E, A>\n\nexport declare const rightIO: <E = never, A = never>(ma: IO<A>) => TaskThese<E, A>\n\nexport declare const leftTask: <E = never, A = never>(me: T.Task<E>) => TaskThese<E, A>\n\nexport declare const rightTask: <E = never, A = never>(ma: T.Task<A>) => TaskThese<E, A>\n```\n\n----------------------------------------\n\nTITLE: Converting Between These and Option in TypeScript\nDESCRIPTION: Functions for converting between These and Option types, including fromOption and fromOptions.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/These.ts.md#2025-04-23_snippet_2\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare const fromOption: <E>(onNone: LazyArg<E>) => <A>(fa: Option<A>) => These<E, A>\n\nexport declare const fromOptions: <E, A>(fe: Option<E>, fa: Option<A>) => Option<These<E, A>>\n```\n\n----------------------------------------\n\nTITLE: Defining Alt Interface in TypeScript\nDESCRIPTION: Core interface defining the Alt type class which extends Functor. It includes an alt operation that works with a Higher-Kinded Type (HKT) pattern.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Alt.ts.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface Alt<F> extends Functor<F> {\n  readonly alt: <A>(fa: HKT<F, A>, that: LazyArg<HKT<F, A>>) => HKT<F, A>\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Alt Operation for ReaderTaskEither in TypeScript\nDESCRIPTION: Defines an alt operation for ReaderTaskEither, which is similar to Semigroup but applies to types of kind * -> *.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReaderTaskEither.ts.md#2025-04-23_snippet_7\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare const alt: <R, E, A>(\n  that: () => ReaderTaskEither<R, E, A>\n) => (fa: ReaderTaskEither<R, E, A>) => ReaderTaskEither<R, E, A>\n```\n\n----------------------------------------\n\nTITLE: Implementing Match Function for IOOption in TypeScript\nDESCRIPTION: Defines the match function for IOOption. It allows pattern matching on IOOption values with synchronous handlers.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/IOOption.ts.md#2025-04-23_snippet_35\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const match: <B, A>(onNone: () => B, onSome: (a: A) => B) => (ma: IOOption<A>) => I.IO<B>\n```\n\n----------------------------------------\n\nTITLE: Implementing map for Value Transformation\nDESCRIPTION: Maps the success value of a ReaderTaskEither using the provided function, following the functor pattern to transform values within a context.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReaderTaskEither.ts.md#2025-04-23_snippet_77\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const map: <A, B>(f: (a: A) => B) => <R, E>(fa: ReaderTaskEither<R, E, A>) => ReaderTaskEither<R, E, B>\n```\n\n----------------------------------------\n\nTITLE: Splitting ReadonlyNonEmptyArray into Init and Last in TypeScript\nDESCRIPTION: Function that returns a tuple containing all elements except the last one (init) and the last element of a ReadonlyNonEmptyArray.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReadonlyNonEmptyArray.ts.md#2025-04-23_snippet_62\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const unappend: <A>(as: ReadonlyNonEmptyArray<A>) => readonly [readonly A[], A]\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport { unappend } from 'fp-ts/ReadonlyNonEmptyArray'\n\nassert.deepStrictEqual(unappend([1, 2, 3, 4]), [[1, 2, 3], 4])\n```\n\n----------------------------------------\n\nTITLE: Implementing matchW Function for Widening Pattern Matching in TypeScript\nDESCRIPTION: A less strict version of match that allows the Left and Right handlers to return different types, which are then merged in the resulting Task.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/TaskEither.ts.md#2025-04-23_snippet_65\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const matchW: <E, B, A, C>(\n  onLeft: (e: E) => B,\n  onRight: (a: A) => C\n) => (ma: TaskEither<E, A>) => T.Task<B | C>\n```\n\n----------------------------------------\n\nTITLE: Modifying NonEmptyArray Head in TypeScript\nDESCRIPTION: Applies a function to the head of a NonEmptyArray, creating a new NonEmptyArray. It uses an Endomorphism to transform the first element.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/NonEmptyArray.ts.md#2025-04-23_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const modifyHead: <A>(f: Endomorphism<A>) => (as: NonEmptyArray<A>) => NonEmptyArray<A>\n```\n\n----------------------------------------\n\nTITLE: Implementing Element Existence Check in ReadonlyArray in TypeScript\nDESCRIPTION: Defines a function to check if an element exists in a ReadonlyArray using a provided equality comparator.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReadonlyArray.ts.md#2025-04-23_snippet_21\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare function elem<A>(E: Eq<A>): {\n  (a: A): (as: ReadonlyArray<A>) => boolean\n  (a: A, as: ReadonlyArray<A>): boolean\n}\n```\n\n----------------------------------------\n\nTITLE: Defining traverseReadonlyNonEmptyArrayWithIndexSeq Operation for ReaderTaskEither in TypeScript\nDESCRIPTION: Function signature for traverseReadonlyNonEmptyArrayWithIndexSeq that maps a readonly non-empty array to a ReaderTaskEither using both the index and value, then sequences the results sequentially. Equivalent to ReadonlyNonEmptyArray#traverseWithIndex(ApplicativeSeq). Added in v2.11.0.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReaderTaskEither.ts.md#2025-04-23_snippet_105\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const traverseReadonlyNonEmptyArrayWithIndexSeq: <A, R, E, B>(\n  f: (index: number, a: A) => ReaderTaskEither<R, E, B>\n) => (as: ReadonlyNonEmptyArray<A>) => ReaderTaskEither<R, E, ReadonlyNonEmptyArray<B>>\n```\n\n----------------------------------------\n\nTITLE: Defining Monad2C Interface with Fixed Left Type in TypeScript\nDESCRIPTION: Defines the Monad2C interface for higher-kinded types with two type parameters and a fixed left type. It extends Applicative2C and Chain2C interfaces.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Monad.ts.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface Monad2C<M extends URIS2, L> extends Applicative2C<M, L>, Chain2C<M, L> {}\n```\n\n----------------------------------------\n\nTITLE: Implementing Ord Type Class for Numbers\nDESCRIPTION: Type class instance for ordering operations on numbers.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/number.ts.md#2025-04-23_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const Ord: O.Ord<number>\n```\n\n----------------------------------------\n\nTITLE: Handling Errors in TaskEither in TypeScript\nDESCRIPTION: Provides a function to handle the error case of a TaskEither.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/TaskEither.ts.md#2025-04-23_snippet_20\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare const getOrElse: <E, A>(onLeft: (e: E) => T.Task<A>) => (ma: TaskEither<E, A>) => T.Task<A>\n```\n\n----------------------------------------\n\nTITLE: Defining FilterWithIndex Interface in TypeScript\nDESCRIPTION: Defines the FilterWithIndex interface for filtering elements with index. It includes overloads for refinement and predicate functions.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/FilterableWithIndex.ts.md#2025-04-23_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport interface FilterWithIndex<F, I> {\n  <A, B extends A>(fa: HKT<F, A>, refinementWithIndex: RefinementWithIndex<I, A, B>): HKT<F, B>\n  <A>(fa: HKT<F, A>, predicateWithIndex: PredicateWithIndex<I, A>): HKT<F, A>\n}\n```\n\n----------------------------------------\n\nTITLE: Traversing ReadonlyNonEmptyArray with Index Sequentially (TypeScript)\nDESCRIPTION: Function to traverse a ReadonlyNonEmptyArray with index using ApplicativeSeq. It takes a function that maps an index and element to a Task, and returns a function that takes a ReadonlyNonEmptyArray and returns a Task of ReadonlyNonEmptyArray.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Task.ts.md#2025-04-23_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const traverseReadonlyNonEmptyArrayWithIndexSeq: <A, B>(\n  f: (index: number, a: A) => Task<B>\n) => (as: ReadonlyNonEmptyArray<A>) => Task<ReadonlyNonEmptyArray<B>>\n```\n\n----------------------------------------\n\nTITLE: Implementing tapEither Combinator for TaskEither in TypeScript\nDESCRIPTION: Defines the tapEither combinator, which composes computations in sequence, using the return value of one computation to determine the next computation and keeping only the result of the first. It includes an example of usage.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/TaskEither.ts.md#2025-04-23_snippet_2\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare const tapEither: {\n  <A, E2, _>(f: (a: A) => E.Either<E2, _>): <E1>(self: TaskEither<E1, A>) => TaskEither<E2 | E1, A>\n  <E1, A, E2, _>(self: TaskEither<E1, A>, f: (a: A) => E.Either<E2, _>): TaskEither<E1 | E2, A>\n}\n```\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport * as E from 'fp-ts/Either'\nimport { pipe } from 'fp-ts/function'\nimport * as TE from 'fp-ts/TaskEither'\n\nconst checkString = (value: string) =>\n  pipe(\n    TE.of(value),\n    TE.tapEither(() => (value.length > 0 ? E.right('ok') : E.left('error')))\n  )\n\nasync function test() {\n  assert.deepStrictEqual(await checkString('')(), E.left('error'))\n  assert.deepStrictEqual(await checkString('fp-ts')(), E.right('fp-ts'))\n}\n\ntest()\n```\n\n----------------------------------------\n\nTITLE: Unfolding ReadonlyMap to Unfoldable structure in TypeScript\nDESCRIPTION: Unfolds a ReadonlyMap into a list of key/value pairs using an Unfoldable type class instance.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReadonlyMap.ts.md#2025-04-23_snippet_4\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare function toUnfoldable<K, F extends URIS>(\n  ord: Ord<K>,\n  U: Unfoldable1<F>\n): <A>(d: ReadonlyMap<K, A>) => Kind<F, readonly [K, A]>\nexport declare function toUnfoldable<K, F>(\n  ord: Ord<K>,\n  U: Unfoldable<F>\n): <A>(d: ReadonlyMap<K, A>) => HKT<F, readonly [K, A]>\n```\n\n----------------------------------------\n\nTITLE: Using IORef with flatMap in TypeScript\nDESCRIPTION: Example demonstrating how to use IORef with flatMap to create, write to, and read from a mutable reference in the IO monad.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/IORef.ts.md#2025-04-23_snippet_5\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { flatMap } from 'fp-ts/IO'\nimport { newIORef } from 'fp-ts/IORef'\n\nassert.strictEqual(flatMap(newIORef(1), (ref) => flatMap(ref.write(2), () => ref.read))(), 2)\n```\n\n----------------------------------------\n\nTITLE: Implementing liftNullable for Nullable Value Handling\nDESCRIPTION: Enhanced version of fromNullableK that allows for dynamic error generation based on the input parameters, providing more context-aware error handling.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReaderTaskEither.ts.md#2025-04-23_snippet_72\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const liftNullable: <A extends readonly unknown[], B, E>(\n  f: (...a: A) => B | null | undefined,\n  onNullable: (...a: A) => E\n) => <R>(...a: A) => ReaderTaskEither<R, E, NonNullable<B>>\n```\n\n----------------------------------------\n\nTITLE: Replicating Values in NonEmptyArray\nDESCRIPTION: Function to create a NonEmptyArray by repeating a value a specified number of times. The parameter n is normalized to a natural number.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/NonEmptyArray.ts.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { replicate } from 'fp-ts/NonEmptyArray'\nimport { pipe } from 'fp-ts/function'\n\nassert.deepStrictEqual(pipe(3, replicate('a')), ['a', 'a', 'a'])\n```\n\n----------------------------------------\n\nTITLE: Defining WriterT Base Interface\nDESCRIPTION: Core interface definition for Writer monad transformer that wraps a monadic type M with additional writer context W and value type A.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/WriterT.ts.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface WriterT<M, W, A> {\n  (): HKT<M, [A, W]>\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing bimap Function for Separated in TypeScript\nDESCRIPTION: Defines the bimap function, which maps a pair of functions over the two type arguments of the bifunctor. It takes two functions f and g and returns a new function that applies f to the left part and g to the right part of a Separated instance.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Separated.ts.md#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const bimap: <E, G, A, B>(f: (e: E) => G, g: (a: A) => B) => (fa: Separated<E, A>) => Separated<G, B>\n```\n\n----------------------------------------\n\nTITLE: Implementing let function in StateReaderTaskEither (TypeScript)\nDESCRIPTION: The let function binds a value to a StateReaderTaskEither computation. It creates a new computation with the result of applying function f to the original result added to the result object.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/StateReaderTaskEither.ts.md#2025-04-23_snippet_72\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const let: <N, A, B>(\n  name: Exclude<N, keyof A>,\n  f: (a: A) => B\n) => <S, R, E>(\n  fa: StateReaderTaskEither<S, R, E, A>\n) => StateReaderTaskEither<S, R, E, { readonly [K in N | keyof A]: K extends keyof A ? A[K] : B }>\n```\n\n----------------------------------------\n\nTITLE: Combining NonEmptyArrays with Alt Operation\nDESCRIPTION: Implementation of the Alt typeclass for NonEmptyArray, which concatenates two non-empty arrays together. This preserves the non-empty guarantee while combining collections.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/NonEmptyArray.ts.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as NEA from 'fp-ts/NonEmptyArray'\nimport { pipe } from 'fp-ts/function'\n\nassert.deepStrictEqual(\n  pipe(\n    [1, 2, 3],\n    NEA.alt(() => [4, 5])\n  ),\n  [1, 2, 3, 4, 5]\n)\n```\n\n----------------------------------------\n\nTITLE: Updating Element in ReadonlyArray in TypeScript\nDESCRIPTION: Changes the element at the specified index in a readonly array, creating a new array, or returns None if the index is out of bounds.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReadonlyArray.ts.md#2025-04-23_snippet_67\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const updateAt: <A>(i: number, a: A) => (as: readonly A[]) => Option<readonly A[]>\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport { updateAt } from 'fp-ts/ReadonlyArray'\nimport { some, none } from 'fp-ts/Option'\n\nassert.deepStrictEqual(updateAt(1, 1)([1, 2, 3]), some([1, 1, 3]))\nassert.deepStrictEqual(updateAt(1, 1)([]), none)\n```\n\n----------------------------------------\n\nTITLE: Implementing getUnionSemigroup for ReadonlyNonEmptyArray in TypeScript\nDESCRIPTION: Returns a Semigroup for ReadonlyNonEmptyArray that combines arrays using union.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReadonlyNonEmptyArray.ts.md#2025-04-23_snippet_42\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const getUnionSemigroup: <A>(E: Eq<A>) => Se.Semigroup<ReadonlyNonEmptyArray<A>>\n```\n\n----------------------------------------\n\nTITLE: Defining StateReaderTaskEither Interface in TypeScript\nDESCRIPTION: Defines the basic interface for StateReaderTaskEither which combines State, Reader, Task, and Either monads. It takes a state S and returns a ReaderTaskEither that produces both a value A and a new state S.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/StateReaderTaskEither.ts.md#2025-04-23_snippet_41\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport interface StateReaderTaskEither<S, R, E, A> {\n  (s: S): ReaderTaskEither<R, E, [A, S]>\n}\n```\n\n----------------------------------------\n\nTITLE: Contravariant1 Interface with URIS Constraint\nDESCRIPTION: Defines a Contravariant interface for type constructors with one type parameter, constrained to URIS. Uses Kind instead of HKT for type safety.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Contravariant.ts.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface Contravariant1<F extends URIS> {\n  readonly URI: F\n  readonly contramap: <A, B>(fa: Kind<F, A>, f: (b: B) => A) => Kind<F, B>\n}\n```\n\n----------------------------------------\n\nTITLE: Modifying Last Element in ReadonlyNonEmptyArray in TypeScript\nDESCRIPTION: Function that applies a transformation function to the last element of a ReadonlyNonEmptyArray, creating a new array with the modified element.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReadonlyNonEmptyArray.ts.md#2025-04-23_snippet_54\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const modifyLast: <A>(f: Endomorphism<A>) => (as: ReadonlyNonEmptyArray<A>) => ReadonlyNonEmptyArray<A>\n```\n\n----------------------------------------\n\nTITLE: Implementing chainFirstReaderEitherK in TypeScript for ReaderTaskEither\nDESCRIPTION: Alias of tapReaderEither that executes a ReaderEither-returning side effect without changing the original value. It takes a function from A to ReaderEither<R, E, B> and preserves the original value.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReaderTaskEither.ts.md#2025-04-23_snippet_26\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const chainFirstReaderEitherK: <R, E, A, B>(\n  f: (a: A) => ReaderEither<R, E, B>\n) => (ma: ReaderTaskEither<R, E, A>) => ReaderTaskEither<R, E, A>\n```\n\n----------------------------------------\n\nTITLE: Converting Type Constraints from PureScript to TypeScript\nDESCRIPTION: Shows how to handle type class constraints in TypeScript by passing instances as parameters.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/guides/purescript.md#2025-04-23_snippet_6\n\nLANGUAGE: purescript\nCODE:\n```\ninstance semigroupOption :: Semigroup a => Semigroup (Option a) where\n  append None y = y\n  append x None = x\n  append (Some x) (Some y) = Some (x <> y)\n\ninstance monoidOption :: Semigroup a => Monoid (Option a) where\n  mempty = None\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Semigroup } from 'fp-ts/Semigroup'\nimport { Monoid } from 'fp-ts/Monoid'\n\nfunction getMonoid<A>(S: Semigroup<A>): Monoid<Option<A>> {\n  return {\n    concat: (x, y) => {\n      if (x._tag === 'Some' && y._tag === 'Some') {\n        return some(S.concat(x.value, y.value))\n      } else if (x._tag === 'Some') {\n        return y\n      } else {\n        return x\n      }\n    },\n    empty: none\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing fold Function for These in TypeScript\nDESCRIPTION: Defines the fold function (alias of match) for pattern matching on These values, providing handlers for Left, Right, and Both cases.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/These.ts.md#2025-04-23_snippet_12\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare const fold: <E, A, B>(\n  onLeft: (e: E) => B,\n  onRight: (a: A) => B,\n  onBoth: (e: E, a: A) => B\n) => (fa: These<E, A>) => B\n```\n\n----------------------------------------\n\nTITLE: Splitting ReadonlyNonEmptyArray at Index in TypeScript\nDESCRIPTION: Function that splits a ReadonlyNonEmptyArray into two pieces at a specified index. The first piece has at most n elements and is a non-empty array, while the second piece is a regular array.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReadonlyNonEmptyArray.ts.md#2025-04-23_snippet_60\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const splitAt: (\n  n: number\n) => <A>(as: ReadonlyNonEmptyArray<A>) => readonly [ReadonlyNonEmptyArray<A>, readonly A[]]\n```\n\n----------------------------------------\n\nTITLE: Modifying Element at Index in ReadonlyNonEmptyArray in TypeScript\nDESCRIPTION: Function that applies a transformation function to the element at a specific index in a ReadonlyNonEmptyArray. Returns an Option that contains the modified array if the index is valid.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReadonlyNonEmptyArray.ts.md#2025-04-23_snippet_52\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const modifyAt: <A>(\n  i: number,\n  f: (a: A) => A\n) => (as: ReadonlyNonEmptyArray<A>) => Option<ReadonlyNonEmptyArray<A>>\n```\n\n----------------------------------------\n\nTITLE: Tree Applicative and Chain Operations\nDESCRIPTION: Implementation of applicative and chain operations for Tree data structure.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Tree.ts.md#2025-04-23_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const ap: <A>(fa: Tree<A>) => <B>(fab: Tree<(a: A) => B>) => Tree<B>\n```\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const apFirst: <B>(second: Tree<B>) => <A>(first: Tree<A>) => Tree<A>\n```\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const apSecond: <B>(second: Tree<B>) => <A>(first: Tree<A>) => Tree<B>\n```\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const chainFirst: <A, B>(f: (a: A) => Tree<B>) => (first: Tree<A>) => Tree<A>\n```\n\n----------------------------------------\n\nTITLE: Creating a Filterable Instance for TaskEither with a Monoid\nDESCRIPTION: A function that creates a Filterable instance for TaskEither given a Monoid for the error type, enabling filter, filterMap, and partition operations on TaskEither values.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/TaskEither.ts.md#2025-04-23_snippet_33\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare function getFilterable<E>(M: Monoid<E>): Filterable2C<URI, E>\n```\n\n----------------------------------------\n\nTITLE: Implementing Chain Function for IOOption in TypeScript\nDESCRIPTION: Defines the chain function for IOOption, which is an alias of flatMap. It allows chaining operations on IOOption values.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/IOOption.ts.md#2025-04-23_snippet_16\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const chain: <A, B>(f: (a: A) => IOOption<B>) => (ma: IOOption<A>) => IOOption<B>\n```\n\n----------------------------------------\n\nTITLE: Defining flatMapIO function for ReaderIO in TypeScript\nDESCRIPTION: Flattens a ReaderIO containing an IO. It provides two function signatures for different use cases.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReaderIO.ts.md#2025-04-23_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const flatMapIO: {\n  <A, B>(f: (a: A) => I.IO<B>): <R>(self: ReaderIO<R, A>) => ReaderIO<R, B>\n  <R, A, B>(self: ReaderIO<R, A>, f: (a: A) => I.IO<B>): ReaderIO<R, B>\n}\n```\n\n----------------------------------------\n\nTITLE: Option-based Refinement Constructor\nDESCRIPTION: Creates a type-safe refinement from a function that returns Option type.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Refinement.ts.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const fromOptionK: <A, B extends A>(getOption: (a: A) => Option<B>) => Refinement<A, B>\n```\n\n----------------------------------------\n\nTITLE: Getting Monoid instance for Eq in TypeScript\nDESCRIPTION: Returns a Monoid instance for Eq, allowing combination of multiple equality relations.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Eq.ts.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const getMonoid: <A>() => Monoid<Eq<A>>\n```\n\n----------------------------------------\n\nTITLE: Implementing chainTaskK for ReaderTaskEither\nDESCRIPTION: Alias of flatMapTask that chains a function returning a Task with a ReaderTaskEither, preserving the original error type.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReaderTaskEither.ts.md#2025-04-23_snippet_55\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const chainTaskK: <A, B>(\n  f: (a: A) => T.Task<B>\n) => <R, E>(first: ReaderTaskEither<R, E, A>) => ReaderTaskEither<R, E, B>\n```\n\n----------------------------------------\n\nTITLE: Max Monoid Usage Example\nDESCRIPTION: Example showing how to use the max monoid constructor with numbers.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Monoid.ts.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as N from 'fp-ts/number'\nimport * as M from 'fp-ts/Monoid'\n\nconst M1 = M.max(N.Bounded)\n\nassert.deepStrictEqual(M1.concat(1, 2), 2)\n```\n\n----------------------------------------\n\nTITLE: Implementing chainReaderK in TypeScript for ReaderTaskEither\nDESCRIPTION: Alias of flatMapReader that chains a Reader-returning function with a ReaderTaskEither. It takes a function from A to Reader<R, B> and returns a function that transforms a ReaderTaskEither<R, E, A> into a ReaderTaskEither<R, E, B>.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReaderTaskEither.ts.md#2025-04-23_snippet_48\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const chainReaderK: <A, R, B>(\n  f: (a: A) => R.Reader<R, B>\n) => <E>(ma: ReaderTaskEither<R, E, A>) => ReaderTaskEither<R, E, B>\n```\n\n----------------------------------------\n\nTITLE: Implementing ChainIOK Function for IOOption in TypeScript\nDESCRIPTION: Defines the chainIOK function for IOOption, which is an alias of flatMapIO. It allows chaining IO operations on IOOption values.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/IOOption.ts.md#2025-04-23_snippet_21\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const chainIOK: <A, B>(f: (a: A) => I.IO<B>) => (first: IOOption<A>) => IOOption<B>\n```\n\n----------------------------------------\n\nTITLE: Implementing flatMapIO for IO Chaining\nDESCRIPTION: Chains a function that returns an IO with a ReaderTaskEither, allowing synchronous side-effect operations to be composed with ReaderTaskEither operations.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReaderTaskEither.ts.md#2025-04-23_snippet_86\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const flatMapIO: {\n  <A, B>(f: (a: A) => IO<B>): <R, E>(self: ReaderTaskEither<R, E, A>) => ReaderTaskEither<R, E, B>\n  <R, E, A, B>(self: ReaderTaskEither<R, E, A>, f: (a: A) => IO<B>): ReaderTaskEither<R, E, B>\n}\n```\n\n----------------------------------------\n\nTITLE: Clamp Function for Ord in TypeScript\nDESCRIPTION: Creates a function to clamp a value between a minimum and maximum according to a given Ord instance.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Ord.ts.md#2025-04-23_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const clamp: <A>(O: Ord<A>) => (low: A, hi: A) => (a: A) => A\n```\n\n----------------------------------------\n\nTITLE: Zipping Two ReadonlyNonEmptyArrays with Custom Function in TypeScript\nDESCRIPTION: Function that combines two ReadonlyNonEmptyArrays using a custom combining function that takes elements from both arrays at the same index and produces a result.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReadonlyNonEmptyArray.ts.md#2025-04-23_snippet_71\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const zipWith: <A, B, C>(\n  as: ReadonlyNonEmptyArray<A>,\n  bs: ReadonlyNonEmptyArray<B>,\n  f: (a: A, b: B) => C\n) => ReadonlyNonEmptyArray<C>\n```\n\n----------------------------------------\n\nTITLE: Alternative Computation for TaskEither in TypeScript\nDESCRIPTION: Provides an alternative computation if the first one fails.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/TaskEither.ts.md#2025-04-23_snippet_16\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare const alt: <E, A>(that: LazyArg<TaskEither<E, A>>) => (fa: TaskEither<E, A>) => TaskEither<E, A>\n```\n\n----------------------------------------\n\nTITLE: Using ConcatAll with Number Semigroup in TypeScript\nDESCRIPTION: Demonstrates the usage of concatAll with a number Semigroup to sum an array of numbers.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Semigroup.ts.md#2025-04-23_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nimport { concatAll } from 'fp-ts/Semigroup'\nimport * as N from 'fp-ts/number'\n\nconst sum = concatAll(N.SemigroupSum)(0)\n\nassert.deepStrictEqual(sum([1, 2, 3]), 6)\nassert.deepStrictEqual(sum([]), 0)\n```\n\n----------------------------------------\n\nTITLE: Implementing union function for Records in TypeScript\nDESCRIPTION: Creates a function that combines two Records using a specified Magma to concatenate values with the same key. This allows for custom combining behavior when merging Records.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Record.ts.md#2025-04-23_snippet_53\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const union: <A>(\n  M: Magma<A>\n) => (second: Record<string, A>) => (first: Record<string, A>) => Record<string, A>\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport { union } from 'fp-ts/Record'\nimport { Magma } from 'fp-ts/Magma'\n\nconst m1: Magma<number> = { concat: (x: number, y: number) => x + y }\nassert.deepStrictEqual(union(m1)({ a: 3, c: 3 })({ a: 1, b: 2 }), { a: 4, b: 2, c: 3 })\nconst m2: Magma<number> = { concat: (x: number) => x }\nassert.deepStrictEqual(union(m2)({ a: 3, c: 3 })({ a: 1, b: 2 }), { a: 1, b: 2, c: 3 })\n```\n\n----------------------------------------\n\nTITLE: Implementing flatMapEither for StateReaderTaskEither in TypeScript\nDESCRIPTION: Provides flatMapEither function that allows mapping from a StateReaderTaskEither to an Either and flattening the result, with both pipeable and non-pipeable overloads.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/StateReaderTaskEither.ts.md#2025-04-23_snippet_43\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare const flatMapEither: {\n  <A, E2, B>(f: (a: A) => E.Either<E2, B>): <S, R, E1>(\n    self: StateReaderTaskEither<S, R, E1, A>\n  ) => StateReaderTaskEither<S, R, E2 | E1, B>\n  <S, R, E1, A, E2, B>(self: StateReaderTaskEither<S, R, E1, A>, f: (a: A) => E.Either<E2, B>): StateReaderTaskEither<\n    S,\n    R,\n    E1 | E2,\n    B\n  >\n}\n```\n\n----------------------------------------\n\nTITLE: Defining map Function for These in TypeScript\nDESCRIPTION: Implements the map function for the These type, allowing transformation of the right value while preserving the structure.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/These.ts.md#2025-04-23_snippet_9\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare const map: <A, B>(f: (a: A) => B) => <E>(fa: These<E, A>) => These<E, B>\n```\n\n----------------------------------------\n\nTITLE: Implementing Conversion Functions for TaskThese in TypeScript\nDESCRIPTION: Provides functions to convert from other types like Either, IO, Option, Task, and These to TaskThese.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/TaskThese.ts.md#2025-04-23_snippet_2\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare const fromEither: <E, A>(fa: Either<E, A>) => TaskThese<E, A>\n\nexport declare const fromIO: <A, E = never>(fa: IO<A>) => TaskThese<E, A>\n\nexport declare const fromIOEither: <E, A>(fa: IOEither<E, A>) => TaskThese<E, A>\n\nexport declare const fromOption: <E>(onNone: LazyArg<E>) => <A>(fa: Option<A>) => TaskThese<E, A>\n\nexport declare const fromTask: <A, E = never>(fa: T.Task<A>) => TaskThese<E, A>\n\nexport declare const fromThese: <E, A>(fa: TH.These<E, A>) => TaskThese<E, A>\n```\n\n----------------------------------------\n\nTITLE: Creating Eq Instance for Records in TypeScript\nDESCRIPTION: Given an Eq for the base type, it produces an Eq for a Record of that base type. The resulting Eq can be used to compare two Records for equality.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Record.ts.md#2025-04-23_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const getEq: <K extends string, A>(E: Eq<A>) => Eq<Record<K, A>>\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport { getEq } from 'fp-ts/Record'\nimport { string } from 'fp-ts'\nimport { Eq } from 'fp-ts/Eq'\n\nconst eq: Eq<Record<string, string>> = getEq(string.Eq)\nassert.deepStrictEqual(eq.equals({ a: 'foo' }, { b: 'bar' }), false)\nassert.deepStrictEqual(eq.equals({ a: 'foo' }, { a: 'foo' }), true)\n```\n\n----------------------------------------\n\nTITLE: Updating Head Element in ReadonlyNonEmptyArray in TypeScript\nDESCRIPTION: Function that replaces the first element (head) of a ReadonlyNonEmptyArray with a new value, creating a new non-empty array.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReadonlyNonEmptyArray.ts.md#2025-04-23_snippet_68\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const updateHead: <A>(a: A) => (as: ReadonlyNonEmptyArray<A>) => ReadonlyNonEmptyArray<A>\n```\n\n----------------------------------------\n\nTITLE: Defining Bifunctor Interface in TypeScript\nDESCRIPTION: Defines the Bifunctor interface for handling two-parameter type constructors. It includes methods for bimap and mapLeft operations.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Bifunctor.ts.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface Bifunctor<F> {\n  readonly URI: F\n  readonly bimap: <E, A, G, B>(fea: HKT2<F, E, A>, f: (e: E) => G, g: (a: A) => B) => HKT2<F, G, B>\n  readonly mapLeft: <E, A, G>(fea: HKT2<F, E, A>, f: (e: E) => G) => HKT2<F, G, A>\n}\n```\n\n----------------------------------------\n\nTITLE: Unzipping ReadonlyArray of Pairs in TypeScript\nDESCRIPTION: Takes an array of pairs and returns two corresponding arrays. This function is the reverse of zip.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReadonlyArray.ts.md#2025-04-23_snippet_66\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const unzip: <A, B>(as: readonly (readonly [A, B])[]) => readonly [readonly A[], readonly B[]]\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport { unzip } from 'fp-ts/ReadonlyArray'\n\nassert.deepStrictEqual(\n  unzip([\n    [1, 'a'],\n    [2, 'b'],\n    [3, 'c'],\n  ]),\n  [\n    [1, 2, 3],\n    ['a', 'b', 'c'],\n  ]\n)\n```\n\n----------------------------------------\n\nTITLE: Defining Invariant4 Interface in TypeScript\nDESCRIPTION: Interface for Invariant type class with four type parameters. Extends URIS4 for higher-kinded types with four type parameters.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Invariant.ts.md#2025-04-23_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface Invariant4<F extends URIS4> {\n  readonly URI: F\n  readonly imap: <S, R, E, A, B>(fa: Kind4<F, S, R, E, A>, f: (a: A) => B, g: (b: B) => A) => Kind4<F, S, R, E, B>\n}\n```\n\n----------------------------------------\n\nTITLE: Map Partition with Index and Mapping\nDESCRIPTION: Function to partition and map Map entries using key-value predicate returning Either type.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Map.ts.md#2025-04-23_snippet_16\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const partitionMapWithIndex: <K, A, B, C>(\n  f: (k: K, a: A) => Either<B, C>\n) => (fa: Map<K, A>) => Separated<Map<K, B>, Map<K, C>>\n```\n\n----------------------------------------\n\nTITLE: Implementing MonadIO3 Interface for URIS3 Types\nDESCRIPTION: Extends the MonadIO pattern to support higher-kinded types with three type parameters (URIS3).\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/MonadIO.ts.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface MonadIO3<M extends URIS3> extends Monad3<M>, FromIO3<M> {}\n```\n\n----------------------------------------\n\nTITLE: Defining Functor Instance for Store in TypeScript\nDESCRIPTION: Declares the Functor typeclass instance for Store, enabling mapping operations.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Store.ts.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const Functor: Functor2<'Store'>\n```\n\n----------------------------------------\n\nTITLE: Implementing fromReaderEitherK for ReaderEither Lifting\nDESCRIPTION: Transforms a function returning a ReaderEither into a function returning a ReaderTaskEither, lifting reader context with error handling to include asynchronous capabilities.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReaderTaskEither.ts.md#2025-04-23_snippet_66\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const fromReaderEitherK: <R, E, A extends readonly unknown[], B>(\n  f: (...a: A) => ReaderEither<R, E, B>\n) => (...a: A) => ReaderTaskEither<R, E, B>\n```\n\n----------------------------------------\n\nTITLE: Defining flatMapReader function for ReaderIO in TypeScript\nDESCRIPTION: Flattens a ReaderIO containing a Reader. It provides two function signatures for different use cases.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReaderIO.ts.md#2025-04-23_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const flatMapReader: {\n  <A, R2, B>(f: (a: A) => R.Reader<R2, B>): <R1>(self: ReaderIO<R1, A>) => ReaderIO<R1 & R2, B>\n  <R1, A, R2, B>(self: ReaderIO<R1, A>, f: (a: A) => R.Reader<R2, B>): ReaderIO<R1 & R2, B>\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing chainNullableK in TypeScript for ReaderTaskEither\nDESCRIPTION: Function to handle nullable values in a chain. It takes an error value and a function that returns a potentially null/undefined value, and returns a function that transforms a ReaderTaskEither<R, E, A> into a ReaderTaskEither<R, E, NonNullable<B>>.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReaderTaskEither.ts.md#2025-04-23_snippet_41\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const chainNullableK: <E>(\n  e: E\n) => <A, B>(\n  f: (a: A) => B | null | undefined\n) => <R>(ma: ReaderTaskEither<R, E, A>) => ReaderTaskEither<R, E, NonNullable<B>>\n```\n\n----------------------------------------\n\nTITLE: Reversing NonEmptyArray in TypeScript\nDESCRIPTION: Reverses the order of elements in a NonEmptyArray, creating a new NonEmptyArray with the elements in reverse order.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/NonEmptyArray.ts.md#2025-04-23_snippet_14\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const reverse: <A>(as: NonEmptyArray<A>) => NonEmptyArray<A>\n```\n\n----------------------------------------\n\nTITLE: Defining Generic Comonad Interface in TypeScript\nDESCRIPTION: Defines the Comonad interface which extends Extend and provides an extract method to retrieve a value from a comonadic structure.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Comonad.ts.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface Comonad<W> extends Extend<W> {\n  readonly extract: <A>(wa: HKT<W, A>) => A\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing tapIO Combinator for Task in TypeScript\nDESCRIPTION: Implements the tapIO combinator for Task, which composes computations in sequence, using the return value of one computation to determine the next and keeping only the result of the first. It includes an example of usage.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Task.ts.md#2025-04-23_snippet_2\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare const tapIO: {\n  <A, _>(f: (a: A) => IO<_>): (self: Task<A>) => Task<A>\n  <A, _>(self: Task<A>, f: (a: A) => IO<_>): Task<A>\n}\n\n// Example usage\nimport { pipe } from 'fp-ts/function'\nimport * as T from 'fp-ts/Task'\nimport * as Console from 'fp-ts/Console'\n\n// Will produce `Hello, fp-ts` to the stdout\nconst effect = pipe(\n  T.of('fp-ts'),\n  T.tapIO((value) => Console.log(`Hello, ${value}`))\n)\n\nasync function test() {\n  assert.deepStrictEqual(await effect(), 'fp-ts')\n}\n\ntest()\n```\n\n----------------------------------------\n\nTITLE: Defining warn console function in fp-ts\nDESCRIPTION: Defines a warn function that takes a value of any type and returns an IO<void>. It wraps the console.warn method in the functional IO monad pattern.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Console.ts.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const warn: <A>(a: A) => IO<void>\n```\n\n----------------------------------------\n\nTITLE: ChainNullableK Operation Type Definition\nDESCRIPTION: Type definition for chaining nullable operations on Either monads. Handles null/undefined values with proper error handling and type safety.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/EitherT.ts.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare function chainNullableK<M extends URIS3>(\n  M: Monad3<M>\n): <E>(\n  e: E\n) => <A, B>(\n  f: (a: A) => B | null | undefined\n) => <S, R>(ma: Kind3<M, S, R, Either<E, A>>) => Kind3<M, S, R, Either<E, NonNullable<B>>>\n```\n\n----------------------------------------\n\nTITLE: Defining These Type Alias in TypeScript\nDESCRIPTION: Creates a type alias for These, representing a sum type of Either and Both.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/These.ts.md#2025-04-23_snippet_11\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport type These<E, A> = Either<E, A> | Both<E, A>\n```\n\n----------------------------------------\n\nTITLE: Finding Last Index of Element in Array with TypeScript and fp-ts\nDESCRIPTION: Returns the index of the last element in an array matching a predicate. Returns a Some containing the index if found, or None if not found.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReadonlyArray.ts.md#2025-04-23_snippet_32\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const findLastIndex: <A>(predicate: Predicate<A>) => (as: readonly A[]) => Option<number>\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport { findLastIndex } from 'fp-ts/ReadonlyArray'\nimport { some, none } from 'fp-ts/Option'\n\ninterface X {\n  readonly a: number\n  readonly b: number\n}\nconst xs: ReadonlyArray<X> = [\n  { a: 1, b: 0 },\n  { a: 1, b: 1 },\n]\nassert.deepStrictEqual(findLastIndex((x: { readonly a: number }) => x.a === 1)(xs), some(1))\nassert.deepStrictEqual(findLastIndex((x: { readonly a: number }) => x.a === 4)(xs), none)\n```\n\n----------------------------------------\n\nTITLE: Defining info console function in fp-ts\nDESCRIPTION: Defines an info function that takes a value of any type and returns an IO<void>. It wraps the console.info method in the functional IO monad pattern.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Console.ts.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const info: <A>(a: A) => IO<void>\n```\n\n----------------------------------------\n\nTITLE: Implementing FlatMap Function for IOOption in TypeScript\nDESCRIPTION: Defines the flatMap function for IOOption. It allows chaining operations on IOOption values.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/IOOption.ts.md#2025-04-23_snippet_39\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const flatMap: {\n  <A, B>(f: (a: A) => IOOption<B>): (ma: IOOption<A>) => IOOption<B>\n  <A, B>(ma: IOOption<A>, f: (a: A) => IOOption<B>): IOOption<B>\n}\n```\n\n----------------------------------------\n\nTITLE: Map Operation Type Definition\nDESCRIPTION: Type definition for mapping over values in Either monad context while preserving the structure.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/EitherT.ts.md#2025-04-23_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare function map<F extends URIS3>(\n  F: Functor3<F>\n): <A, B>(f: (a: A) => B) => <R, FE, E>(fa: Kind3<F, R, FE, Either<E, A>>) => Kind3<F, R, FE, Either<E, B>>\n```\n\n----------------------------------------\n\nTITLE: Implementing Tap Combinator for ReaderTask in TypeScript\nDESCRIPTION: Implements the 'tap' combinator for ReaderTask, which composes computations in sequence, using the return value of one computation to determine the next computation and keeping only the result of the first.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReaderTask.ts.md#2025-04-23_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare const tap: {\n  <R1, A, R2, _>(self: ReaderTask<R1, A>, f: (a: A) => ReaderTask<R2, _>): ReaderTask<R1 & R2, A>\n  <A, R2, _>(f: (a: A) => ReaderTask<R2, _>): <R1>(self: ReaderTask<R1, A>) => ReaderTask<R2 & R1, A>\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing tapEither Function for ReaderEither in TypeScript\nDESCRIPTION: Implements the tapEither function, which composes computations in sequence, using the return value of one computation to determine the next computation and keeping only the result of the first.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReaderEither.ts.md#2025-04-23_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare const tapEither: {\n  <A, E2, _>(f: (a: A) => E.Either<E2, _>): <R1, E1>(self: ReaderEither<R1, E1, A>) => ReaderEither<R1, E2 | E1, A>\n  <R1, E1, A, E2, _>(self: ReaderEither<R1, E1, A>, f: (a: A) => E.Either<E2, _>): ReaderEither<R1, E1 | E2, A>\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing tapEither Combinator for ReaderTaskEither in TypeScript\nDESCRIPTION: Defines a tapEither combinator for ReaderTaskEither that composes computations in sequence, using the return value of one computation to determine the next computation and keeping only the result of the first. It includes an example of usage.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReaderTaskEither.ts.md#2025-04-23_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare const tapEither: {\n  <A, E2, _>(f: (a: A) => E.Either<E2, _>): <R, E1>(self: ReaderTaskEither<R, E1, A>) => ReaderTaskEither<R, E2 | E1, A>\n  <R, E1, A, E2, _>(self: ReaderTaskEither<R, E1, A>, f: (a: A) => E.Either<E2, _>): ReaderTaskEither<R, E1 | E2, A>\n}\n\n**Example**\n\nimport * as E from 'fp-ts/Either'\nimport { pipe } from 'fp-ts/function'\nimport * as RTE from 'fp-ts/ReaderTaskEither'\n\nconst checkString = (value: string) =>\n  pipe(\n    RTE.ask<number>(),\n    RTE.tapEither((minLength) => (value.length > minLength ? E.right('ok') : E.left('error')))\n  )\n\nasync function test() {\n  assert.deepStrictEqual(await checkString('')(2)(), E.left('error'))\n  assert.deepStrictEqual(await checkString('fp-ts')(2)(), E.right(2))\n}\n\ntest()\n```\n\n----------------------------------------\n\nTITLE: Defining Foldable1 Interface in TypeScript\nDESCRIPTION: Type class definition for Foldable with a single type parameter using URIS, which is the kind-preserving version of the Foldable interface.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Foldable.ts.md#2025-04-23_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport interface Foldable1<F extends URIS> {\n  readonly URI: F\n  readonly reduce: <A, B>(fa: Kind<F, A>, b: B, f: (b: B, a: A) => B) => B\n  readonly foldMap: <M>(M: Monoid<M>) => <A>(fa: Kind<F, A>, f: (a: A) => M) => M\n  readonly reduceRight: <A, B>(fa: Kind<F, A>, b: B, f: (a: A, b: B) => B) => B\n}\n```\n\n----------------------------------------\n\nTITLE: Unzipping ReadonlyNonEmptyArray of Tuples in TypeScript\nDESCRIPTION: Function that transforms a ReadonlyNonEmptyArray of tuples into a tuple of two ReadonlyNonEmptyArrays, with the first and second elements of each tuple respectively.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReadonlyNonEmptyArray.ts.md#2025-04-23_snippet_66\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const unzip: <A, B>(\n  abs: ReadonlyNonEmptyArray<readonly [A, B]>\n) => readonly [ReadonlyNonEmptyArray<A>, ReadonlyNonEmptyArray<B>]\n```\n\n----------------------------------------\n\nTITLE: Implementing matchEW Function for Widening Effectful Pattern Matching in TypeScript\nDESCRIPTION: A less strict version of matchE that allows the Left and Right handlers to return Tasks with different types, which are then merged.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/TaskEither.ts.md#2025-04-23_snippet_64\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const matchEW: <E, B, A, C>(\n  onLeft: (e: E) => T.Task<B>,\n  onRight: (a: A) => T.Task<C>\n) => (ma: TaskEither<E, A>) => T.Task<B | C>\n```\n\n----------------------------------------\n\nTITLE: Intercalating Elements in ReadonlyNonEmptyArray with Semigroup in TypeScript\nDESCRIPTION: Function that places an element between members of a ReadonlyNonEmptyArray and then folds the results using a provided Semigroup. Useful for operations like joining strings with separators.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReadonlyNonEmptyArray.ts.md#2025-04-23_snippet_47\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const intercalate: <A>(S: Se.Semigroup<A>) => (middle: A) => (as: ReadonlyNonEmptyArray<A>) => A\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as S from 'fp-ts/string'\nimport { intercalate } from 'fp-ts/ReadonlyNonEmptyArray'\n\nassert.deepStrictEqual(intercalate(S.Semigroup)('-')(['a', 'b', 'c']), 'a-b-c')\n```\n\n----------------------------------------\n\nTITLE: Implementing Alt operation for Either in TypeScript\nDESCRIPTION: Defines the alt function for the Either type, which returns the left-most non-Left value or the right-most Left value if both are Left.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Either.ts.md#2025-04-23_snippet_4\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare const alt: <E, A>(that: LazyArg<Either<E, A>>) => (fa: Either<E, A>) => Either<E, A>\n```\n\n----------------------------------------\n\nTITLE: Defining FoldableWithIndex Interface in TypeScript\nDESCRIPTION: Core interface definition for FoldableWithIndex which extends Foldable with indexed versions of reduce, foldMap, and reduceRight operations.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/FoldableWithIndex.ts.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface FoldableWithIndex<F, I> extends Foldable<F> {\n  readonly reduceWithIndex: <A, B>(fa: HKT<F, A>, b: B, f: (i: I, b: B, a: A) => B) => B\n  readonly foldMapWithIndex: <M>(M: Monoid<M>) => <A>(fa: HKT<F, A>, f: (i: I, a: A) => M) => M\n  readonly reduceRightWithIndex: <A, B>(fa: HKT<F, A>, b: B, f: (i: I, a: A, b: B) => B) => B\n}\n```\n\n----------------------------------------\n\nTITLE: Defining the make constructor for Const in TypeScript\nDESCRIPTION: Creates a Const value by wrapping a value of type E. The second type parameter A is ignored in the implementation but preserved in the type signature.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Const.ts.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const make: <E, A = never>(e: E) => Const<E, A>\n```\n\n----------------------------------------\n\nTITLE: Implementing chainReaderTaskKW in TypeScript for ReaderTaskEither\nDESCRIPTION: Widening version of chainReaderTaskK that allows for different environment types. It takes a function from A to ReaderTask<R2, B> and returns a function that transforms a ReaderTaskEither<R1, E, A> into a ReaderTaskEither<R1 & R2, E, B>.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReaderTaskEither.ts.md#2025-04-23_snippet_51\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const chainReaderTaskKW: <A, R2, B>(\n  f: (a: A) => RT.ReaderTask<R2, B>\n) => <R1, E>(ma: ReaderTaskEither<R1, E, A>) => ReaderTaskEither<R1 & R2, E, B>\n```\n\n----------------------------------------\n\nTITLE: Implementing foldW with Type Widening\nDESCRIPTION: Widened version of fold that allows different return types for error and success handlers, merging the resulting types for more flexible composition.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReaderTaskEither.ts.md#2025-04-23_snippet_79\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const foldW: <E, R2, B, A, R3, C>(\n  onLeft: (e: E) => RT.ReaderTask<R2, B>,\n  onRight: (a: A) => RT.ReaderTask<R3, C>\n) => <R1>(ma: ReaderTaskEither<R1, E, A>) => RT.ReaderTask<R1 & R2 & R3, B | C>\n```\n\n----------------------------------------\n\nTITLE: Defining Monad Instance for IOOption in TypeScript\nDESCRIPTION: Declares the Monad instance for the IOOption monad. This provides implementations for the Monad typeclass methods.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/IOOption.ts.md#2025-04-23_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const Monad: Monad1<'IOOption'>\n```\n\n----------------------------------------\n\nTITLE: Implementing orElse Operation for ReaderTaskEither in TypeScript\nDESCRIPTION: Defines an orElse operation for ReaderTaskEither, which handles the case when the Either is Left by returning a new ReaderTaskEither.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReaderTaskEither.ts.md#2025-04-23_snippet_15\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare const orElse: <R, E1, A, E2>(\n  onLeft: (e: E1) => ReaderTaskEither<R, E2, A>\n) => (ma: ReaderTaskEither<R, E1, A>) => ReaderTaskEither<R, E2, A>\n```\n\n----------------------------------------\n\nTITLE: Using Element Dropping in ReadonlyArray in TypeScript\nDESCRIPTION: Demonstrates how to use the dropLeft, dropRight, and dropLeftWhile functions to remove elements from ReadonlyArrays.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReadonlyArray.ts.md#2025-04-23_snippet_19\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as RA from 'fp-ts/ReadonlyArray'\nimport { pipe } from 'fp-ts/function'\n\nconst input: ReadonlyArray<number> = [1, 2, 3]\nassert.deepStrictEqual(pipe(input, RA.dropLeft(2)), [3])\nassert.strictEqual(pipe(input, RA.dropLeft(0)), input)\nassert.strictEqual(pipe(input, RA.dropLeft(-1)), input)\n\nassert.deepStrictEqual(pipe(input, RA.dropRight(2)), [1])\nassert.strictEqual(pipe(input, RA.dropRight(0)), input)\nassert.strictEqual(pipe(input, RA.dropRight(-1)), input)\n\nassert.deepStrictEqual(RA.dropLeftWhile((n: number) => n % 2 === 1)([1, 3, 2, 4, 5]), [2, 4, 5])\n```\n\n----------------------------------------\n\nTITLE: Implementing chainFirstReaderK in TypeScript for ReaderTaskEither\nDESCRIPTION: Alias of tapReader that executes a Reader-returning side effect without changing the original value. It takes a function from A to Reader<R, B> and returns a function that preserves the original value.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReaderTaskEither.ts.md#2025-04-23_snippet_30\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const chainFirstReaderK: <A, R, B>(\n  f: (a: A) => R.Reader<R, B>\n) => <E>(ma: ReaderTaskEither<R, E, A>) => ReaderTaskEither<R, E, A>\n```\n\n----------------------------------------\n\nTITLE: Implementing State Combinators in TypeScript\nDESCRIPTION: Defines the tap combinator for composing State computations in sequence.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/State.ts.md#2025-04-23_snippet_2\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare const tap: {\n  <S, A, _>(self: State<S, A>, f: (a: A) => State<S, _>): State<S, A>\n  <A, S, _>(f: (a: A) => State<S, _>): (self: State<S, A>) => State<S, A>\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Functor Instance for IOOption in TypeScript\nDESCRIPTION: Declares the Functor instance for the IOOption monad. This provides implementations for the Functor typeclass methods.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/IOOption.ts.md#2025-04-23_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const Functor: Functor1<'IOOption'>\n```\n\n----------------------------------------\n\nTITLE: Implementing Pipeable ReduceRightWithIndex Function in TypeScript\nDESCRIPTION: Defines a pipeable reduceRightWithIndex function for various arities of the FoldableWithIndex type class. It allows folding a structure into a single value from right to left, with access to the index.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/pipeable.ts.md#2025-04-23_snippet_23\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare function reduceRightWithIndex<F extends URIS4, I>(\n  F: FoldableWithIndex4<F, I>\n): <A, B>(b: B, f: (i: I, a: A, b: B) => B) => <S, R, E>(fa: Kind4<F, S, R, E, A>) => B\nexport declare function reduceRightWithIndex<F extends URIS3, I>(\n  F: FoldableWithIndex3<F, I>\n): <A, B>(b: B, f: (i: I, a: A, b: B) => B) => <R, E>(fa: Kind3<F, R, E, A>) => B\nexport declare function reduceRightWithIndex<F extends URIS3, I, E>(\n  F: FoldableWithIndex3C<F, I, E>\n): <A, B>(b: B, f: (i: I, a: A, b: B) => B) => <R>(fa: Kind3<F, R, E, A>) => B\nexport declare function reduceRightWithIndex<F extends URIS2, I>(\n  F: FoldableWithIndex2<F, I>\n): <A, B>(b: B, f: (i: I, a: A, b: B) => B) => <E>(fa: Kind2<F, E, A>) => B\nexport declare function reduceRightWithIndex<F extends URIS2, I, E>(\n  F: FoldableWithIndex2C<F, I, E>\n): <A, B>(b: B, f: (i: I, a: A, b: B) => B) => (fa: Kind2<F, E, A>) => B\nexport declare function reduceRightWithIndex<F extends URIS, I>(\n  F: FoldableWithIndex1<F, I>\n): <A, B>(b: B, f: (i: I, a: A, b: B) => B) => (fa: Kind<F, A>) => B\nexport declare function reduceRightWithIndex<F, I>(\n  F: FoldableWithIndex<F, I>\n): <A, B>(b: B, f: (i: I, a: A, b: B) => B) => (fa: HKT<F, A>) => B\n```\n\n----------------------------------------\n\nTITLE: Implementing fromReaderIOK for ReaderIO Lifting\nDESCRIPTION: Transforms a function returning a ReaderIO into a function returning a ReaderTaskEither, lifting reader context with synchronous side-effects to include asynchronous and error handling capabilities.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReaderTaskEither.ts.md#2025-04-23_snippet_67\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const fromReaderIOK: <A extends readonly unknown[], R, B>(\n  f: (...a: A) => RIO.ReaderIO<R, B>\n) => <E = never>(...a: A) => ReaderTaskEither<R, E, B>\n```\n\n----------------------------------------\n\nTITLE: Defining StateT Interface in TypeScript\nDESCRIPTION: Defines the StateT interface for adding state to a monad M. It takes a state S and returns a monadic value of type M containing a tuple of the result A and the new state S.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/StateT.ts.md#2025-04-23_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport interface StateT<M, S, A> {\n  (s: S): HKT<M, [A, S]>\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing flatMapReaderTaskEither for StateReaderTaskEither in TypeScript\nDESCRIPTION: Provides flatMapReaderTaskEither function that allows mapping from a StateReaderTaskEither to a ReaderTaskEither and flattening the result, supporting both pipeable and non-pipeable usage.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/StateReaderTaskEither.ts.md#2025-04-23_snippet_48\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare const flatMapReaderTaskEither: {\n  <A, R2, E2, B>(f: (a: A) => RTE.ReaderTaskEither<R2, E2, B>): <S, R1, E1>(\n    self: StateReaderTaskEither<S, R1, E1, A>\n  ) => StateReaderTaskEither<S, R1 & R2, E2 | E1, B>\n  <S, R1, E1, A, R2, E2, B>(\n    self: StateReaderTaskEither<S, R1, E1, A>,\n    f: (a: A) => RTE.ReaderTaskEither<R2, E2, B>\n  ): StateReaderTaskEither<S, R1 & R2, E1 | E2, B>\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing chainFirstReaderKW in TypeScript for ReaderTaskEither\nDESCRIPTION: Widening version of chainFirstReaderK that allows for different environment types. It takes a function from A to Reader<R1, B> and returns a function that preserves the original value while merging environment types.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReaderTaskEither.ts.md#2025-04-23_snippet_31\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const chainFirstReaderKW: <A, R1, B>(\n  f: (a: A) => R.Reader<R1, B>\n) => <R2, E>(ma: ReaderTaskEither<R2, E, A>) => ReaderTaskEither<R1 & R2, E, A>\n```\n\n----------------------------------------\n\nTITLE: Implementing traverseSeqArray for IOEither\nDESCRIPTION: Function that traverses an array with IOEither operations sequentially. Equivalent to ReadonlyArray#traverse with ApplicativeSeq.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/IOEither.ts.md#2025-04-23_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const traverseSeqArray: <A, E, B>(\n  f: (a: A) => IOEither<E, B>\n) => (as: readonly A[]) => IOEither<E, readonly B[]>\n```\n\n----------------------------------------\n\nTITLE: Tuple Show Implementation in TypeScript\nDESCRIPTION: Creates a Show instance for tuples by combining Show instances for each element.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Show.ts.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const tuple: <A extends readonly unknown[]>(\n  ...shows: { [K in keyof A]: Show<A[K]> }\n) => Show<Readonly<A>>\n```\n\n----------------------------------------\n\nTITLE: Handling Errors with Task in TaskEither in TypeScript\nDESCRIPTION: Provides a Task to handle errors in TaskEither.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/TaskEither.ts.md#2025-04-23_snippet_26\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare const orElseFirstTaskK: <E, B>(\n  onLeft: (e: E) => T.Task<B>\n) => <A>(ma: TaskEither<E, A>) => TaskEither<E, A>\n```\n\n----------------------------------------\n\nTITLE: Defining mapWithIndex Pipeable Function in TypeScript\nDESCRIPTION: Creates a pipeable mapWithIndex function that supports various arity levels (URIS1-4) in the fp-ts library. This function allows applying a transformation function with access to both index and value.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/pipeable.ts.md#2025-04-23_snippet_15\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare function mapWithIndex<F extends URIS4, I>(\n  F: FunctorWithIndex4<F, I>\n): <A, B>(f: (i: I, a: A) => B) => <S, R, E>(fa: Kind4<F, S, R, E, A>) => Kind4<F, S, R, E, B>\nexport declare function mapWithIndex<F extends URIS3, I>(\n  F: FunctorWithIndex3<F, I>\n): <A, B>(f: (i: I, a: A) => B) => <R, E>(fa: Kind3<F, R, E, A>) => Kind3<F, R, E, B>\nexport declare function mapWithIndex<F extends URIS3, I, E>(\n  F: FunctorWithIndex3C<F, I, E>\n): <A, B>(f: (i: I, a: A) => B) => <R>(fa: Kind3<F, R, E, A>) => Kind3<F, R, E, B>\nexport declare function mapWithIndex<F extends URIS2, I>(\n  F: FunctorWithIndex2<F, I>\n): <A, B>(f: (i: I, a: A) => B) => <E>(fa: Kind2<F, E, A>) => Kind2<F, E, B>\nexport declare function mapWithIndex<F extends URIS2, I, E>(\n  F: FunctorWithIndex2C<F, I, E>\n): <A, B>(f: (i: I, a: A) => B) => (fa: Kind2<F, E, A>) => Kind2<F, E, B>\nexport declare function mapWithIndex<F extends URIS, I>(\n  F: FunctorWithIndex1<F, I>\n): <A, B>(f: (i: I, a: A) => B) => (fa: Kind<F, A>) => Kind<F, B>\nexport declare function mapWithIndex<F, I>(\n  F: FunctorWithIndex<F, I>\n): <A, B>(f: (i: I, a: A) => B) => (fa: HKT<F, A>) => HKT<F, B>\n```\n\n----------------------------------------\n\nTITLE: Implementing foldMap operation for Either in TypeScript\nDESCRIPTION: Defines a function to map each element of the structure to a monoid and combine the results.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Either.ts.md#2025-04-23_snippet_18\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare const foldMap: <M>(M: Monoid<M>) => <A>(f: (a: A) => M) => <E>(fa: Either<E, A>) => M\n```\n\n----------------------------------------\n\nTITLE: Updating Last Element in ReadonlyNonEmptyArray in TypeScript\nDESCRIPTION: Function that replaces the last element of a ReadonlyNonEmptyArray with a new value, creating a new non-empty array.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReadonlyNonEmptyArray.ts.md#2025-04-23_snippet_69\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const updateLast: <A>(a: A) => (as: ReadonlyNonEmptyArray<A>) => ReadonlyNonEmptyArray<A>\n```\n\n----------------------------------------\n\nTITLE: IOEither Pattern Matching Functions\nDESCRIPTION: Functions for pattern matching on IOEither values including match, matchE and their variants\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/IOEither.ts.md#2025-04-23_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const match: <E, B, A>(onLeft: (e: E) => B, onRight: (a: A) => B) => (ma: IOEither<E, A>) => I.IO<B>\n```\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const matchE: <E, A, B>(\n  onLeft: (e: E) => I.IO<B>,\n  onRight: (a: A) => I.IO<B>\n) => (ma: IOEither<E, A>) => I.IO<B>\n```\n\n----------------------------------------\n\nTITLE: Defining log console function in fp-ts\nDESCRIPTION: Defines a log function that takes a value of any type and returns an IO<void>. It wraps the console.log method in the functional IO monad pattern.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Console.ts.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const log: <A>(a: A) => IO<void>\n```\n\n----------------------------------------\n\nTITLE: Adding Computed Properties in Do Notation for TaskEither in TypeScript\nDESCRIPTION: Adds a computed property to an object in a do notation chain.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/TaskEither.ts.md#2025-04-23_snippet_15\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare const let: <N, A, B>(\n  name: Exclude<N, keyof A>,\n  f: (a: A) => B\n) => <E>(fa: TaskEither<E, A>) => TaskEither<E, { readonly [K in N | keyof A]: K extends keyof A ? A[K] : B }>\n```\n\n----------------------------------------\n\nTITLE: Removing Duplicates from NonEmptyArray in TypeScript\nDESCRIPTION: Removes duplicate elements from a NonEmptyArray, keeping the first occurrence of each element. Uses the provided Eq instance for equality comparison.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/NonEmptyArray.ts.md#2025-04-23_snippet_22\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const uniq: <A>(E: Eq<A>) => (as: NonEmptyArray<A>) => NonEmptyArray<A>\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport { uniq } from 'fp-ts/NonEmptyArray'\nimport * as N from 'fp-ts/number'\n\nassert.deepStrictEqual(uniq(N.Eq)([1, 2, 1]), [1, 2])\n```\n\n----------------------------------------\n\nTITLE: Implementing traverseSeqArrayWithIndex for IOEither\nDESCRIPTION: Function that traverses an array with index using IOEither operations sequentially. Equivalent to ReadonlyArray#traverseWithIndex with ApplicativeSeq.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/IOEither.ts.md#2025-04-23_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const traverseSeqArrayWithIndex: <A, E, B>(\n  f: (index: number, a: A) => IOEither<E, B>\n) => (as: readonly A[]) => IOEither<E, readonly B[]>\n```\n\n----------------------------------------\n\nTITLE: Implementing MatchW Function for IOOption in TypeScript\nDESCRIPTION: Defines the matchW function for IOOption. It's a less strict version of match that allows widening of handler return types.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/IOOption.ts.md#2025-04-23_snippet_38\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const matchW: <B, A, C>(onNone: () => B, onSome: (a: A) => C) => (ma: IOOption<A>) => I.IO<B | C>\n```\n\n----------------------------------------\n\nTITLE: Declaring BooleanAlgebra Interface in TypeScript\nDESCRIPTION: Defines the BooleanAlgebra interface which extends HeytingAlgebra. Boolean algebras generalize classical logic where one is equivalent to 'true' and zero is equivalent to 'false'.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/BooleanAlgebra.ts.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface BooleanAlgebra<A> extends HeytingAlgebra<A> {}\n```\n\n----------------------------------------\n\nTITLE: Creating Eq for struct types in TypeScript\nDESCRIPTION: Creates an Eq instance for a struct (object) by combining Eq instances for each property.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Eq.ts.md#2025-04-23_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const struct: <A>(eqs: { [K in keyof A]: Eq<A[K]> }) => Eq<{ readonly [K in keyof A]: A[K] }>\n```\n\n----------------------------------------\n\nTITLE: Combining Refinements with AND\nDESCRIPTION: Combines two refinements using logical AND operation.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Refinement.ts.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const and: <A, C extends A>(\n  second: Refinement<A, C>\n) => <B extends A>(first: Refinement<A, B>) => Refinement<A, B & C>\n```\n\n----------------------------------------\n\nTITLE: Handling Errors with Widening in TaskEither in TypeScript\nDESCRIPTION: A less strict version of getOrElse that merges return types.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/TaskEither.ts.md#2025-04-23_snippet_21\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare const getOrElseW: <E, B>(onLeft: (e: E) => T.Task<B>) => <A>(ma: TaskEither<E, A>) => T.Task<B | A>\n```\n\n----------------------------------------\n\nTITLE: Implementing fromIOK for Lifting IO Functions in TypeScript\nDESCRIPTION: Creates a function that transforms an IO-returning function into a TaskEither-returning function, with the success type from the IO and a never error type by default.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/TaskEither.ts.md#2025-04-23_snippet_50\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const fromIOK: <A extends readonly unknown[], B>(\n  f: (...a: A) => IO<B>\n) => <E = never>(...a: A) => TaskEither<E, B>\n```\n\n----------------------------------------\n\nTITLE: Defining Field Interface in TypeScript\nDESCRIPTION: Defines the Field interface that extends Ring type with additional operations for degree calculation, division, and modulo operations. The interface represents an algebraic field structure.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Field.ts.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface Field<A> extends Ring<A> {\n  readonly degree: (a: A) => number\n  readonly div: (x: A, y: A) => A\n  readonly mod: (x: A, y: A) => A\n}\n```\n\n----------------------------------------\n\nTITLE: Defining FromIO Interface in TypeScript\nDESCRIPTION: Base interface for lifting computations from the IO monad to a higher-kinded type F. Provides a fromIO function that transforms an IO<A> into HKT<F, A>.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/FromIO.ts.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface FromIO<F> {\n  readonly URI: F\n  readonly fromIO: <A>(fa: IO<A>) => HKT<F, A>\n}\n```\n\n----------------------------------------\n\nTITLE: Defining flatMapReaderTask Operation for ReaderTaskEither in TypeScript\nDESCRIPTION: Function signature for flatMapReaderTask that composes a ReaderTaskEither with a ReaderTask function, handling the combination of reader environments. Added in v2.16.0.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReaderTaskEither.ts.md#2025-04-23_snippet_93\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const flatMapReaderTask: {\n  <A, R2, B>(f: (a: A) => RT.ReaderTask<R2, B>): <R1, E>(\n    self: ReaderTaskEither<R1, E, A>\n  ) => ReaderTaskEither<R1 & R2, E, B>\n  <R1, E, A, R2, B>(self: ReaderTaskEither<R1, E, A>, f: (a: A) => RT.ReaderTask<R2, B>): ReaderTaskEither<\n    R1 & R2,\n    E,\n    B\n  >\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing chop for ReadonlyNonEmptyArray in TypeScript\nDESCRIPTION: A recursion pattern for processing a ReadonlyNonEmptyArray to produce a new ReadonlyNonEmptyArray, often used for \"chopping\" up the input array.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReadonlyNonEmptyArray.ts.md#2025-04-23_snippet_35\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const chop: <A, B>(\n  f: (as: ReadonlyNonEmptyArray<A>) => readonly [B, readonly A[]]\n) => (as: ReadonlyNonEmptyArray<A>) => ReadonlyNonEmptyArray<B>\n```\n\n----------------------------------------\n\nTITLE: Creating Record from Foldable Collection of Key-Value Pairs\nDESCRIPTION: Creates a Record from a foldable collection of key/value pairs, using a specified Magma to combine values for duplicate keys. Supports various higher-kinded types.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Record.ts.md#2025-04-23_snippet_31\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare function fromFoldable<F extends URIS3, A>(\n  M: Magma<A>,\n  F: Foldable3<F>\n): <R, E>(fka: Kind3<F, R, E, [string, A]>) => Record<string, A>\nexport declare function fromFoldable<F extends URIS2, A>(\n  M: Magma<A>,\n  F: Foldable2<F>\n): <E>(fka: Kind2<F, E, [string, A]>) => Record<string, A>\nexport declare function fromFoldable<F extends URIS, A>(\n  M: Magma<A>,\n  F: Foldable1<F>\n): (fka: Kind<F, [string, A]>) => Record<string, A>\nexport declare function fromFoldable<F, A>(\n  M: Magma<A>,\n  F: FoldableHKT<F>\n): (fka: HKT<F, [string, A]>) => Record<string, A>\n```\n\n----------------------------------------\n\nTITLE: Implementing fold as Alias for matchE in TypeScript\nDESCRIPTION: An alias for matchE that handles both Left and Right cases of a TaskEither, returning a Task with a common result type.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/TaskEither.ts.md#2025-04-23_snippet_60\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const fold: <E, A, B>(\n  onLeft: (e: E) => T.Task<B>,\n  onRight: (a: A) => T.Task<B>\n) => (ma: TaskEither<E, A>) => T.Task<B>\n```\n\n----------------------------------------\n\nTITLE: Implementing Array Difference in TypeScript\nDESCRIPTION: Defines a function to compute the difference between two ReadonlyArrays using a provided equality comparator.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReadonlyArray.ts.md#2025-04-23_snippet_16\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare function difference<A>(E: Eq<A>): {\n  (xs: ReadonlyArray<A>): (ys: ReadonlyArray<A>) => ReadonlyArray<A>\n  (xs: ReadonlyArray<A>, ys: ReadonlyArray<A>): ReadonlyArray<A>\n}\n```\n\n----------------------------------------\n\nTITLE: Prepending Element to Each Member of ReadonlyNonEmptyArray in TypeScript\nDESCRIPTION: Function that prepends a given element to every member of a ReadonlyNonEmptyArray, creating a new non-empty array with the prepended elements.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReadonlyNonEmptyArray.ts.md#2025-04-23_snippet_55\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const prependAll: <A>(middle: A) => (as: ReadonlyNonEmptyArray<A>) => ReadonlyNonEmptyArray<A>\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport { prependAll } from 'fp-ts/ReadonlyNonEmptyArray'\n\nassert.deepStrictEqual(prependAll(9)([1, 2, 3, 4]), [9, 1, 9, 2, 9, 3, 9, 4])\n```\n\n----------------------------------------\n\nTITLE: Using Alternative (alt) with ReadonlyArray in TypeScript\nDESCRIPTION: Demonstrates the use of the alt function to concatenate two ReadonlyArrays.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReadonlyArray.ts.md#2025-04-23_snippet_2\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport * as RA from 'fp-ts/ReadonlyArray'\nimport { pipe } from 'fp-ts/function'\n\nassert.deepStrictEqual(\n  pipe(\n    [1, 2, 3],\n    RA.alt(() => [4, 5])\n  ),\n  [1, 2, 3, 4, 5]\n)\n```\n\n----------------------------------------\n\nTITLE: Defining FromIO Instance for IOOption in TypeScript\nDESCRIPTION: Declares the FromIO instance for the IOOption monad. This provides implementations for converting from IO to IOOption.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/IOOption.ts.md#2025-04-23_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const FromIO: FromIO1<'IOOption'>\n```\n\n----------------------------------------\n\nTITLE: Creating a ReadonlyMap from a Foldable collection in TypeScript\nDESCRIPTION: Creates a ReadonlyMap from a foldable collection of key/value pairs, using a specified Magma to combine values for duplicate keys. Supports various higher-kinded type structures.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReadonlyMap.ts.md#2025-04-23_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare function fromFoldable<F extends URIS3, K, A>(\n  E: Eq<K>,\n  M: Magma<A>,\n  F: Foldable3<F>\n): <R, E>(fka: Kind3<F, R, E, readonly [K, A]>) => ReadonlyMap<K, A>\nexport declare function fromFoldable<F extends URIS2, K, A>(\n  E: Eq<K>,\n  M: Magma<A>,\n  F: Foldable2<F>\n): <E>(fka: Kind2<F, E, readonly [K, A]>) => ReadonlyMap<K, A>\nexport declare function fromFoldable<F extends URIS, K, A>(\n  E: Eq<K>,\n  M: Magma<A>,\n  F: Foldable1<F>\n): (fka: Kind<F, readonly [K, A]>) => ReadonlyMap<K, A>\nexport declare function fromFoldable<F, K, A>(\n  E: Eq<K>,\n  M: Magma<A>,\n  F: Foldable<F>\n): (fka: HKT<F, readonly [K, A]>) => ReadonlyMap<K, A>\n```\n\n----------------------------------------\n\nTITLE: Implementing chainFirstReaderTaskKW in TypeScript for ReaderTaskEither\nDESCRIPTION: Widening version of chainFirstReaderTaskK that allows for different environment types. It takes a function from A to ReaderTask<R2, B> and returns a function that preserves the original value while merging environment types.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReaderTaskEither.ts.md#2025-04-23_snippet_33\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const chainFirstReaderTaskKW: <A, R2, B>(\n  f: (a: A) => RT.ReaderTask<R2, B>\n) => <R1, E>(ma: ReaderTaskEither<R1, E, A>) => ReaderTaskEither<R1 & R2, E, A>\n```\n\n----------------------------------------\n\nTITLE: Implementing altValidation for EitherT in TypeScript\nDESCRIPTION: Defines the altValidation function for EitherT, which combines two computations using a Semigroup for the error type. It handles different URIS (type-level encodings) for monads.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/EitherT.ts.md#2025-04-23_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare function altValidation<M extends URIS3, E>(\n  M: Monad3<M>,\n  S: Semigroup<E>\n): <R, ME, A>(\n  second: LazyArg<Kind3<M, R, ME, Either<E, A>>>\n) => (first: Kind3<M, R, ME, Either<E, A>>) => Kind3<M, R, ME, Either<E, A>>\nexport declare function altValidation<M extends URIS3, ME, E>(\n  M: Monad3C<M, ME>,\n  S: Semigroup<E>\n): <R, A>(\n  second: LazyArg<Kind3<M, R, ME, Either<E, A>>>\n) => (first: Kind3<M, R, ME, Either<E, A>>) => Kind3<M, R, ME, Either<E, A>>\nexport declare function altValidation<M extends URIS2, E>(\n  M: Monad2<M>,\n  S: Semigroup<E>\n): <ME, A>(\n  second: LazyArg<Kind2<M, ME, Either<E, A>>>\n) => (first: Kind2<M, ME, Either<E, A>>) => Kind2<M, ME, Either<E, A>>\nexport declare function altValidation<M extends URIS2, ME, E>(\n  M: Monad2C<M, ME>,\n  S: Semigroup<E>\n): <A>(second: LazyArg<Kind2<M, ME, Either<E, A>>>) => (first: Kind2<M, ME, Either<E, A>>) => Kind2<M, ME, Either<E, A>>\nexport declare function altValidation<M extends URIS, E>(\n  M: Monad1<M>,\n  S: Semigroup<E>\n): <A>(second: LazyArg<Kind<M, Either<E, A>>>) => (first: Kind<M, Either<E, A>>) => Kind<M, Either<E, A>>\nexport declare function altValidation<M, E>(\n  M: Monad<M>,\n  S: Semigroup<E>\n): <A>(second: LazyArg<HKT<M, Either<E, A>>>) => (first: HKT<M, Either<E, A>>) => HKT<M, Either<E, A>>\n```\n\n----------------------------------------\n\nTITLE: ReaderEither mapError Operation Example\nDESCRIPTION: Example demonstrating how to map the error channel of a ReaderEither using mapError function.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReaderEither.ts.md#2025-04-23_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as ReaderEither from 'fp-ts/ReaderEither'\nimport * as Either from 'fp-ts/Either'\n\nconst f = (s: string) => new Error(s)\n\nassert.deepStrictEqual(ReaderEither.mapError(ReaderEither.right(1), f)({}), Either.right(1))\nassert.deepStrictEqual(ReaderEither.mapError(ReaderEither.left('err'), f)({}), Either.left(new Error('err')))\n```\n\n----------------------------------------\n\nTITLE: Implementing Widening orElse Operation for ReaderTaskEither in TypeScript\nDESCRIPTION: Defines a less strict version of orElse (orElseW) for ReaderTaskEither, where the W suffix indicates widening of environment types and return types.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReaderTaskEither.ts.md#2025-04-23_snippet_16\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare const orElseW: <E1, R1, E2, B>(\n  onLeft: (e: E1) => ReaderTaskEither<R1, E2, B>\n) => <R2, A>(ma: ReaderTaskEither<R2, E1, A>) => ReaderTaskEither<R1 & R2, E2, B | A>\n```\n\n----------------------------------------\n\nTITLE: Widening Pattern Matching for Ordering\nDESCRIPTION: Less strict version of match that allows different return types for each handler.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Ordering.ts.md#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const matchW: <A, B, C>(onLessThan: () => A, onEqual: () => B, onGreaterThan: () => C) => (o: Ordering) => A | B | C\n```\n\n----------------------------------------\n\nTITLE: Implementing FromNullableK Function for IOOption in TypeScript\nDESCRIPTION: Defines the fromNullableK function for IOOption. It lifts a function returning a nullable value to a function returning IOOption.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/IOOption.ts.md#2025-04-23_snippet_26\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const fromNullableK: <A extends readonly unknown[], B>(\n  f: (...a: A) => B | null | undefined\n) => (...a: A) => IOOption<NonNullable<B>>\n```\n\n----------------------------------------\n\nTITLE: Defining ReaderTaskEither Interface in TypeScript\nDESCRIPTION: Type definition for the ReaderTaskEither interface, which represents a function that takes an environment R and returns a TaskEither monad with error type E and success type A.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReaderTaskEither.ts.md#2025-04-23_snippet_52\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface ReaderTaskEither<R, E, A> {\n  (r: R): TaskEither<E, A>\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing flatten for ReadonlyNonEmptyArray in TypeScript\nDESCRIPTION: Flattens a ReadonlyNonEmptyArray of ReadonlyNonEmptyArrays into a single ReadonlyNonEmptyArray.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReadonlyNonEmptyArray.ts.md#2025-04-23_snippet_27\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const flatten: <A>(mma: ReadonlyNonEmptyArray<ReadonlyNonEmptyArray<A>>) => ReadonlyNonEmptyArray<A>\n```\n\n----------------------------------------\n\nTITLE: Implementing Ask Constructor for ReaderTask in TypeScript\nDESCRIPTION: Implements the 'ask' constructor for ReaderTask, which reads the current context.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReaderTask.ts.md#2025-04-23_snippet_3\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare const ask: <R>() => ReaderTask<R, R>\n```\n\n----------------------------------------\n\nTITLE: Implementing chainFirst in TypeScript for ReaderTaskEither\nDESCRIPTION: Alias of tap that executes a side effect without changing the original value. It takes a function from A to ReaderTaskEither<R, E, B> and returns a function that preserves the original value while executing the side effect.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReaderTaskEither.ts.md#2025-04-23_snippet_22\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const chainFirst: <R, E, A, B>(\n  f: (a: A) => ReaderTaskEither<R, E, B>\n) => (ma: ReaderTaskEither<R, E, A>) => ReaderTaskEither<R, E, A>\n```\n\n----------------------------------------\n\nTITLE: Creating Union of ReadonlyArrays in TypeScript\nDESCRIPTION: Creates an array of unique values, in order, from all given arrays using an Eq instance for equality comparisons.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReadonlyArray.ts.md#2025-04-23_snippet_64\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare function union<A>(E: Eq<A>): {\n  (xs: ReadonlyArray<A>): (ys: ReadonlyArray<A>) => ReadonlyArray<A>\n  (xs: ReadonlyArray<A>, ys: ReadonlyArray<A>): ReadonlyArray<A>\n}\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport { union } from 'fp-ts/ReadonlyArray'\nimport * as N from 'fp-ts/number'\nimport { pipe } from 'fp-ts/function'\n\nassert.deepStrictEqual(pipe([1, 2], union(N.Eq)([2, 3])), [1, 2, 3])\n```\n\n----------------------------------------\n\nTITLE: Defining FromIO3C Interface in TypeScript\nDESCRIPTION: Interface for lifting computations from the IO monad to a higher-kinded type F with fixed error type E and a reader environment R. Constrains the error type for all operations.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/FromIO.ts.md#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface FromIO3C<F extends URIS3, E> {\n  readonly URI: F\n  readonly _E: E\n  readonly fromIO: <A, R>(fa: IO<A>) => Kind3<F, R, E, A>\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing apFirst for StateReaderTaskEither in TypeScript\nDESCRIPTION: Provides apFirst function that combines two StateReaderTaskEither effects, returning only the result of the first effect while still executing both.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/StateReaderTaskEither.ts.md#2025-04-23_snippet_61\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare const apFirst: <S, R, E, B>(\n  second: StateReaderTaskEither<S, R, E, B>\n) => <A>(first: StateReaderTaskEither<S, R, E, A>) => StateReaderTaskEither<S, R, E, A>\n```\n\n----------------------------------------\n\nTITLE: Implementing TapIO Combinator for ReaderTask in TypeScript\nDESCRIPTION: Implements the 'tapIO' combinator for ReaderTask, which composes computations in sequence, using the return value of one computation to determine the next computation and keeping only the result of the first, with an IO side effect.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReaderTask.ts.md#2025-04-23_snippet_2\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare const tapIO: {\n  <A, _>(f: (a: A) => IO<_>): <R>(self: ReaderTask<R, A>) => ReaderTask<R, A>\n  <R, A, _>(self: ReaderTask<R, A>, f: (a: A) => IO<_>): ReaderTask<R, A>\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Chain2 Interface for URIS2\nDESCRIPTION: Chain interface for type constructors with two type parameters, extending Apply2.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Chain.ts.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface Chain2<F extends URIS2> extends Apply2<F> {\n  readonly chain: <E, A, B>(fa: Kind2<F, E, A>, f: (a: A) => Kind2<F, E, B>) => Kind2<F, E, B>\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing fromOptionK Type Definitions in TypeScript\nDESCRIPTION: Defines type signatures for fromOptionK function that lifts functions returning Option into the target type constructor with error handling. Supports multiple URIS levels.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/FromEither.ts.md#2025-04-23_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare function fromOptionK<F extends URIS4>(\n  F: FromEither4<F>\n): <E>(\n  onNone: LazyArg<E>\n) => <A extends ReadonlyArray<unknown>, B>(f: (...a: A) => Option<B>) => <S, R>(...a: A) => Kind4<F, S, R, E, B>\n```\n\n----------------------------------------\n\nTITLE: Converting Records to collections using Unfoldable in fp-ts\nDESCRIPTION: Unfolds a Record into a list of key/value pairs sorted alphabetically by key. Uses the specified Unfoldable type class (like array or readonlyArray) to create the resulting collection.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Record.ts.md#2025-04-23_snippet_50\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare function toUnfoldable<F extends URIS>(\n  U: Unfoldable1<F>\n): <K extends string, A>(r: Record<K, A>) => Kind<F, [K, A]>\nexport declare function toUnfoldable<F>(U: Unfoldable<F>): <K extends string, A>(r: Record<K, A>) => HKT<F, [K, A]>\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport { array, readonlyArray } from 'fp-ts'\nimport { toUnfoldable } from 'fp-ts/Record'\n\nassert.deepStrictEqual(toUnfoldable(array)({ b: 2, a: 1 }), [\n  ['a', 1],\n  ['b', 2],\n])\nassert.deepStrictEqual(toUnfoldable(readonlyArray)({ b: 2, a: 1 }), [\n  ['a', 1],\n  ['b', 2],\n])\n```\n\n----------------------------------------\n\nTITLE: Implementing concatW for ReadonlyNonEmptyArray in TypeScript\nDESCRIPTION: Concatenates two ReadonlyNonEmptyArrays or a ReadonlyArray with a ReadonlyNonEmptyArray, allowing different types.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReadonlyNonEmptyArray.ts.md#2025-04-23_snippet_39\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare function concatW<B>(\n  second: ReadonlyNonEmptyArray<B>\n): <A>(first: ReadonlyArray<A>) => ReadonlyNonEmptyArray<A | B>\nexport declare function concatW<B>(\n  second: ReadonlyArray<B>\n): <A>(first: ReadonlyNonEmptyArray<A>) => ReadonlyNonEmptyArray<A | B>\n```\n\n----------------------------------------\n\nTITLE: Implementing Bounded Type Class for Numbers\nDESCRIPTION: Type class instance for Bounded numbers, providing bounded operations for the number type.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/number.ts.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const Bounded: B.Bounded<number>\n```\n\n----------------------------------------\n\nTITLE: Defining traverseArray Operation for ReaderTaskEither in TypeScript\nDESCRIPTION: Function signature for traverseArray that maps an array of values to a ReaderTaskEither and then sequences the results. Equivalent to ReadonlyArray#traverse(Applicative). Added in v2.9.0.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReaderTaskEither.ts.md#2025-04-23_snippet_100\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const traverseArray: <R, E, A, B>(\n  f: (a: A) => ReaderTaskEither<R, E, B>\n) => (as: readonly A[]) => ReaderTaskEither<R, E, readonly B[]>\n```\n\n----------------------------------------\n\nTITLE: Implementing apS for StateReaderTaskEither in TypeScript\nDESCRIPTION: Provides apS function that allows building record objects with StateReaderTaskEither values in a type-safe manner, adding a new named property to an existing record.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/StateReaderTaskEither.ts.md#2025-04-23_snippet_63\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare const apS: <N, A, S, R, E, B>(\n  name: Exclude<N, keyof A>,\n  fb: StateReaderTaskEither<S, R, E, B>\n) => (\n  fa: StateReaderTaskEither<S, R, E, A>\n) => StateReaderTaskEither<S, R, E, { readonly [K in N | keyof A]: K extends keyof A ? A[K] : B }>\n```\n\n----------------------------------------\n\nTITLE: Writing to IORef in TypeScript\nDESCRIPTION: Method to write a new value to the IORef. It returns an IO monad of void.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/IORef.ts.md#2025-04-23_snippet_2\n\nLANGUAGE: TypeScript\nCODE:\n```\nwrite(a: A): IO<void>\n```\n\n----------------------------------------\n\nTITLE: Implementing mapLeft Function for Separated in TypeScript\nDESCRIPTION: Defines the mapLeft function, which maps a function over the first type argument of a bifunctor. It takes a function f and returns a new function that applies f to the left part of a Separated instance.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Separated.ts.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const mapLeft: <E, G>(f: (e: E) => G) => <A>(fa: Separated<E, A>) => Separated<G, A>\n```\n\n----------------------------------------\n\nTITLE: Traversable Operations for Maps in TypeScript\nDESCRIPTION: Function to get a TraversableWithIndex instance for Map, which allows traversing the map with access to both keys and values using a specified ordering.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Map.ts.md#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const getTraversableWithIndex: <K>(O: Ord<K>) => TraversableWithIndex2C<'Map', K, K>\n```\n\n----------------------------------------\n\nTITLE: Map With Index Function Signature\nDESCRIPTION: Function signature for mapping over a ReadonlyMap with access to both key and value.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReadonlyMap.ts.md#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const mapWithIndex: <K, A, B>(f: (k: K, a: A) => B) => (fa: ReadonlyMap<K, A>) => ReadonlyMap<K, B>\n```\n\n----------------------------------------\n\nTITLE: Creating DistributiveLattice from Ord in TypeScript\nDESCRIPTION: Defines a function getMinMaxDistributiveLattice that creates a DistributiveLattice instance from a given Ord (ordering) instance. This allows creation of a distributive lattice based on min and max operations.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/DistributiveLattice.ts.md#2025-04-23_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare function getMinMaxDistributiveLattice<A>(O: Ord<A>): DistributiveLattice<A>\n```\n\n----------------------------------------\n\nTITLE: Creating Monoid instance for Const in TypeScript\nDESCRIPTION: Creates a Monoid instance for Const given a Monoid for the first type parameter. This allows combining Const values with an identity element.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Const.ts.md#2025-04-23_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const getMonoid: <E, A>(M: Monoid<E>) => Monoid<Const<E, A>>\n```\n\n----------------------------------------\n\nTITLE: Getting All Elements Except Last from ReadonlyNonEmptyArray in TypeScript\nDESCRIPTION: Function that returns all elements except the last one from a non-empty array, creating a new array. Returns an empty array if the input has only one element.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReadonlyNonEmptyArray.ts.md#2025-04-23_snippet_46\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const init: <A>(as: ReadonlyNonEmptyArray<A>) => readonly A[]\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport { init } from 'fp-ts/ReadonlyNonEmptyArray'\n\nassert.deepStrictEqual(init([1, 2, 3]), [1, 2])\nassert.deepStrictEqual(init([1]), [])\n```\n\n----------------------------------------\n\nTITLE: Implementing group for ReadonlyNonEmptyArray in TypeScript\nDESCRIPTION: Groups equal, consecutive elements of a ReadonlyArray into ReadonlyNonEmptyArrays.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReadonlyNonEmptyArray.ts.md#2025-04-23_snippet_43\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare function group<B>(E: Eq<B>): {\n  <A extends B>(as: ReadonlyNonEmptyArray<A>): ReadonlyNonEmptyArray<ReadonlyNonEmptyArray<A>>\n  <A extends B>(as: ReadonlyArray<A>): ReadonlyArray<ReadonlyNonEmptyArray<A>>\n}\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport { group } from 'fp-ts/ReadonlyNonEmptyArray'\nimport * as N from 'fp-ts/number'\n\nassert.deepStrictEqual(group(N.Eq)([1, 2, 1, 1]), [[1], [2], [1, 1]])\n```\n\n----------------------------------------\n\nTITLE: Reading from IORef in TypeScript\nDESCRIPTION: Property to read the current value from the IORef. It returns an IO monad containing the value.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/IORef.ts.md#2025-04-23_snippet_4\n\nLANGUAGE: TypeScript\nCODE:\n```\nreadonly read: IO<A>\n```\n\n----------------------------------------\n\nTITLE: Defining MonadIO Instance for IOOption in TypeScript\nDESCRIPTION: Declares the MonadIO instance for the IOOption monad. This provides implementations for the MonadIO typeclass methods.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/IOOption.ts.md#2025-04-23_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const MonadIO: MonadIO1<'IOOption'>\n```\n\n----------------------------------------\n\nTITLE: Defining Chain Instance for IOOption in TypeScript\nDESCRIPTION: Declares the Chain instance for the IOOption monad. This provides implementations for the Chain typeclass methods.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/IOOption.ts.md#2025-04-23_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const Chain: chainable.Chain1<'IOOption'>\n```\n\n----------------------------------------\n\nTITLE: Pointed3C Interface with Fixed Error Type\nDESCRIPTION: Variant of Pointed3 with a fixed error type parameter E. Allows specifying reader and value types.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Pointed.ts.md#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface Pointed3C<F extends URIS3, E> {\n  readonly URI: F\n  readonly _E: E\n  readonly of: <R, A>(a: A) => Kind3<F, R, E, A>\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing chainTaskOptionK Function in TypeScript\nDESCRIPTION: Defines a function that chains a TaskOption-returning function with a TaskEither, handling the None case with the provided onNone function. This is recommended to be replaced with flatMapTaskOption.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/TaskEither.ts.md#2025-04-23_snippet_40\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const chainTaskOptionK: <E>(\n  onNone: LazyArg<E>\n) => <A, B>(f: (a: A) => TaskOption<B>) => (ma: TaskEither<E, A>) => TaskEither<E, B>\n```\n\n----------------------------------------\n\nTITLE: Implementing Of Operation for ReaderT\nDESCRIPTION: Function implementing the pure/return operation for the Reader transformer, lifting pure values into the Reader transformer context.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReaderT.ts.md#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare function of<F extends URIS4>(\n  F: Pointed4<F>\n): <A, R, S, FR, FE>(a: A) => Reader<R, Kind4<F, S, FR, FE, A>>\n```\n\n----------------------------------------\n\nTITLE: Defining Monad4 Interface for URIS4 in TypeScript\nDESCRIPTION: Defines the Monad4 interface for higher-kinded types with four type parameters. It extends Applicative4 and Chain4 interfaces.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Monad.ts.md#2025-04-23_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface Monad4<M extends URIS4> extends Applicative4<M>, Chain4<M> {}\n```\n\n----------------------------------------\n\nTITLE: Implementing chainW Function as Alias for flatMap in TypeScript\nDESCRIPTION: An alias for flatMap with type widening that allows merging of error types when chaining TaskEither operations.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/TaskEither.ts.md#2025-04-23_snippet_42\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const chainW: <E2, A, B>(\n  f: (a: A) => TaskEither<E2, B>\n) => <E1>(ma: TaskEither<E1, A>) => TaskEither<E2 | E1, B>\n```\n\n----------------------------------------\n\nTITLE: Implementing ApplicativePar Instance for ReaderTask in TypeScript\nDESCRIPTION: Implements the ApplicativePar instance for ReaderTask, which runs computations in parallel.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReaderTask.ts.md#2025-04-23_snippet_6\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare const ApplicativePar: Applicative2<'ReaderTask'>\n```\n\n----------------------------------------\n\nTITLE: Implementing chainTaskOptionKW Function with Type Widening in TypeScript\nDESCRIPTION: Similar to chainTaskOptionK but with type widening, allowing for merging of error types. The W suffix indicates widening of the error types.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/TaskEither.ts.md#2025-04-23_snippet_41\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const chainTaskOptionKW: <E2>(\n  onNone: LazyArg<E2>\n) => <A, B>(f: (a: A) => TaskOption<B>) => <E1>(ma: TaskEither<E1, A>) => TaskEither<E2 | E1, B>\n```\n\n----------------------------------------\n\nTITLE: Traversing ReadonlyNonEmptyArray with Index in Parallel (TypeScript)\nDESCRIPTION: Function to traverse a ReadonlyNonEmptyArray with index using ApplicativePar. It takes a function that maps an index and element to a Task, and returns a function that takes a ReadonlyNonEmptyArray and returns a Task of ReadonlyNonEmptyArray.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Task.ts.md#2025-04-23_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const traverseReadonlyNonEmptyArrayWithIndex: <A, B>(\n  f: (index: number, a: A) => Task<B>\n) => (as: ReadonlyNonEmptyArray<A>) => Task<ReadonlyNonEmptyArray<B>>\n```\n\n----------------------------------------\n\nTITLE: Implementing Monoid Instance for Functions\nDESCRIPTION: Creates a monoid instance for unary functions given a monoid for the codomain. Includes example usage with predicates.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/function.ts.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const getMonoid: <M>(M: Monoid<M>) => <A = never>() => Monoid<(a: A) => M>\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Predicate } from 'fp-ts/Predicate'\nimport { getMonoid } from 'fp-ts/function'\nimport * as B from 'fp-ts/boolean'\n\nconst f: Predicate<number> = (n) => n <= 2\nconst g: Predicate<number> = (n) => n >= 0\n\nconst M1 = getMonoid(B.MonoidAll)<number>()\n\nassert.deepStrictEqual(M1.concat(f, g)(1), true)\nassert.deepStrictEqual(M1.concat(f, g)(3), false)\n\nconst M2 = getMonoid(B.MonoidAny)<number>()\n\nassert.deepStrictEqual(M2.concat(f, g)(1), true)\nassert.deepStrictEqual(M2.concat(f, g)(3), true)\n```\n\n----------------------------------------\n\nTITLE: Implementing getOrElse Operation for ReaderTaskEither in TypeScript\nDESCRIPTION: Defines a getOrElse operation for ReaderTaskEither, which handles the case when the Either is Left.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReaderTaskEither.ts.md#2025-04-23_snippet_11\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare const getOrElse: <R, E, A>(\n  onLeft: (e: E) => RT.ReaderTask<R, A>\n) => (ma: ReaderTaskEither<R, E, A>) => RT.ReaderTask<R, A>\n```\n\n----------------------------------------\n\nTITLE: Creating Intersection Semigroup for Records in TypeScript\nDESCRIPTION: Given a Semigroup in the base type, it produces a Semigroup in the Record of the base type. The resulting Semigroup concatenates two Records by intersection, combining overlapping entries using the provided Semigroup.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Record.ts.md#2025-04-23_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const getIntersectionSemigroup: <A>(S: Se.Semigroup<A>) => Se.Semigroup<Record<string, A>>\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport { getIntersectionSemigroup } from 'fp-ts/Record'\nimport { Semigroup } from 'fp-ts/Semigroup'\n\nconst sNumber: Semigroup<number> = { concat: (x, y) => x - y }\nconst sRecord: Semigroup<Record<string, number>> = getIntersectionSemigroup(sNumber)\nassert.deepStrictEqual(sRecord.concat({ a: 1, b: 2 }, { b: 3, c: 4 }), { b: -1 })\n```\n\n----------------------------------------\n\nTITLE: Implementing Of Constructor for ReaderTask in TypeScript\nDESCRIPTION: Implements the 'of' constructor for ReaderTask, which creates a ReaderTask that returns a constant value.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReaderTask.ts.md#2025-04-23_snippet_4\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare const of: <R = unknown, A = never>(a: A) => ReaderTask<R, A>\n```\n\n----------------------------------------\n\nTITLE: ReaderTaskEither Constructor Functions\nDESCRIPTION: Collection of constructor functions for creating ReaderTaskEither instances, including ask, asks, and asksReaderTaskEither variations.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReaderTaskEither.ts.md#2025-04-23_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const ask: <R, E = never>() => ReaderTaskEither<R, E, R>\n\nexport declare const asks: <R, A, E = never>(f: (r: R) => A) => ReaderTaskEither<R, E, A>\n\nexport declare const asksReaderTaskEither: <R, E, A>(\n  f: (r: R) => ReaderTaskEither<R, E, A>\n) => ReaderTaskEither<R, E, A>\n```\n\n----------------------------------------\n\nTITLE: Creating Applicative instance for Const with Monoid in TypeScript\nDESCRIPTION: Returns an Applicative instance for Const given a Monoid for the first type parameter. This enables the collection of results using a Monoid while ignoring return values.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Const.ts.md#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare function getApplicative<E>(M: Monoid<E>): Applicative2C<URI, E>\n```\n\n----------------------------------------\n\nTITLE: Defining Base Category Interface in TypeScript\nDESCRIPTION: Defines the base Category interface that extends Semigroupoid with a single type parameter F. Includes an identity function that returns HKT2 type.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Category.ts.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface Category<F> extends Semigroupoid<F> {\n  readonly id: <A>() => HKT2<F, A, A>\n}\n```\n\n----------------------------------------\n\nTITLE: Defining local function for ReaderTaskEither in TypeScript\nDESCRIPTION: Implements a function that changes the value of the local context during the execution of a ReaderTaskEither action. It's similar to Contravariant's contramap.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReaderTaskEither.ts.md#2025-04-23_snippet_118\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const local: <R2, R1>(\n  f: (r2: R2) => R1\n) => <E, A>(ma: ReaderTaskEither<R1, E, A>) => ReaderTaskEither<R2, E, A>\n```\n\n----------------------------------------\n\nTITLE: Implementing ask Function for ReaderEither in TypeScript\nDESCRIPTION: Implements the ask function, which reads the current context in a ReaderEither computation.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReaderEither.ts.md#2025-04-23_snippet_2\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare const ask: <R, E = never>() => ReaderEither<R, E, R>\n```\n\n----------------------------------------\n\nTITLE: Pointed2 Interface for Binary Type Constructors\nDESCRIPTION: Interface for functors with two type parameters using URIS2 constraint. Allows specifying both error and value types.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Pointed.ts.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface Pointed2<F extends URIS2> {\n  readonly URI: F\n  readonly of: <E, A>(a: A) => Kind2<F, E, A>\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Traverse Operation for Either\nDESCRIPTION: Maps structure elements to actions and evaluates from left to right\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Either.ts.md#2025-04-23_snippet_31\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const traverse: PipeableTraverse2<'Either'>\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport { pipe } from 'fp-ts/function'\nimport * as RA from 'fp-ts/ReadonlyArray'\nimport * as E from 'fp-ts/Either'\nimport * as O from 'fp-ts/Option'\n\nassert.deepStrictEqual(pipe(E.right(['a']), E.traverse(O.Applicative)(RA.head)), O.some(E.right('a')))\n\nassert.deepStrictEqual(pipe(E.right([]), E.traverse(O.Applicative)(RA.head)), O.none)\n```\n\n----------------------------------------\n\nTITLE: Defining ChainRec Interface for Stack-safe Recursion in TypeScript\nDESCRIPTION: Defines the ChainRec interface that extends Chain with a chainRec method for stack-safe recursion. This is the base interface for handling recursion with higher-kinded types.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ChainRec.ts.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface ChainRec<F> extends Chain<F> {\n  readonly chainRec: <A, B>(a: A, f: (a: A) => HKT<F, Either<A, B>>) => HKT<F, B>\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing matchEW with Type Widening\nDESCRIPTION: Widened version of matchE that allows different return types for error and success handlers with effectful functions, merging the resulting types.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReaderTaskEither.ts.md#2025-04-23_snippet_82\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const matchEW: <E, R2, B, A, R3, C>(\n  onLeft: (e: E) => RT.ReaderTask<R2, B>,\n  onRight: (a: A) => RT.ReaderTask<R3, C>\n) => <R1>(ma: ReaderTaskEither<R1, E, A>) => RT.ReaderTask<R1 & R2 & R3, B | C>\n```\n\n----------------------------------------\n\nTITLE: Implementing bimap for StateReaderTaskEither in TypeScript\nDESCRIPTION: Defines a function to map over both the error and success types of a StateReaderTaskEither.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/StateReaderTaskEither.ts.md#2025-04-23_snippet_38\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare const bimap: <E, G, A, B>(\n  f: (e: E) => G,\n  g: (a: A) => B\n) => <S, R>(fa: StateReaderTaskEither<S, R, E, A>) => StateReaderTaskEither<S, R, G, B>\n```\n\n----------------------------------------\n\nTITLE: Extracting Sorted Keys from Record\nDESCRIPTION: Retrieves all keys from a Record, sorted alphabetically. Returns an array of the Record's keys in string format.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Record.ts.md#2025-04-23_snippet_37\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const keys: <K extends string>(r: Record<K, unknown>) => K[]\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport { keys } from 'fp-ts/Record'\n\nassert.deepStrictEqual(keys({ c: 1, a: 2, b: 3 }), ['a', 'b', 'c'])\n```\n\n----------------------------------------\n\nTITLE: Simple Option Folding with fp-ts 2.x\nDESCRIPTION: Example showing how to use pipe with a single operation (fold) on an Option. Even with just one function, using pipe allows TypeScript to infer types automatically and maintains consistent argument ordering.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/guides/upgrade-to-v2.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as O from 'fp-ts/Option'\nimport { pipe } from 'fp-ts/function'\n\npipe(\n  O.some(1),\n  O.fold(\n    () => 'ko',\n    (n) => `ok: ${n}`\n  )\n)\n```\n\n----------------------------------------\n\nTITLE: Implementing reduceRight operation for Either in TypeScript\nDESCRIPTION: Defines a function for right-associative fold of an Either structure.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Either.ts.md#2025-04-23_snippet_20\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare const reduceRight: <A, B>(b: B, f: (a: A, b: B) => B) => <E>(fa: Either<E, A>) => B\n```\n\n----------------------------------------\n\nTITLE: Defining FromThese Interface in TypeScript\nDESCRIPTION: Defines the FromThese interface for data types supporting errors and warnings. It includes a URI and a fromThese method to convert These values to the target type.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/FromThese.ts.md#2025-04-23_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport interface FromThese<F> {\n  readonly URI: F\n  readonly fromThese: <E, A>(e: These<E, A>) => HKT2<F, E, A>\n}\n```\n\n----------------------------------------\n\nTITLE: Alternative Utility Function - altAll\nDESCRIPTION: Utility function for combining multiple Alternative values using alt operation. Supports various higher-kinded type variants.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Alternative.ts.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare function altAll<F extends URIS4>(F: Alternative4<F>): <S, R, E, A>(as: ReadonlyArray<Kind4<F, S, R, E, A>>) => Kind4<F, S, R, E, A>\nexport declare function altAll<F extends URIS3>(F: Alternative3<F>): <R, E, A>(as: ReadonlyArray<Kind3<F, R, E, A>>) => Kind3<F, R, E, A>\nexport declare function altAll<F extends URIS3, E>(F: Alternative3C<F, E>): <R, A>(as: ReadonlyArray<Kind3<F, R, E, A>>) => Kind3<F, R, E, A>\nexport declare function altAll<F extends URIS2>(F: Alternative2<F>): <E, A>(as: ReadonlyArray<Kind2<F, E, A>>) => Kind2<F, E, A>\nexport declare function altAll<F extends URIS2, E>(F: Alternative2C<F, E>): <A>(as: ReadonlyArray<Kind2<F, E, A>>) => Kind2<F, E, A>\nexport declare function altAll<F extends URIS>(F: Alternative1<F>): <A>(as: ReadonlyArray<Kind<F, A>>) => Kind<F, A>\nexport declare function altAll<F>(F: Alternative<F>): <A>(as: ReadonlyArray<HKT<F, A>>) => HKT<F, A>\n```\n\n----------------------------------------\n\nTITLE: Defining Foldable2 Interface in TypeScript\nDESCRIPTION: Type class definition for Foldable with two type parameters using URIS2, providing methods for handling data structures with an error type and a value type.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Foldable.ts.md#2025-04-23_snippet_2\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport interface Foldable2<F extends URIS2> {\n  readonly URI: F\n  readonly reduce: <E, A, B>(fa: Kind2<F, E, A>, b: B, f: (b: B, a: A) => B) => B\n  readonly foldMap: <M>(M: Monoid<M>) => <E, A>(fa: Kind2<F, E, A>, f: (a: A) => M) => M\n  readonly reduceRight: <E, A, B>(fa: Kind2<F, E, A>, b: B, f: (a: A, b: B) => B) => B\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Show Instance for String Representation in TypeScript\nDESCRIPTION: Defines a Show instance for string representation. It provides a show method to convert a string to its string representation.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/string.ts.md#2025-04-23_snippet_4\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare const Show: Sh.Show<string>\n```\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport * as S from 'fp-ts/string'\n\nassert.deepStrictEqual(S.Show.show('a'), '\"a\"')\n```\n\n----------------------------------------\n\nTITLE: String Length Grouping Example\nDESCRIPTION: Demonstration of groupBy function to group strings by their length into a record structure.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/NonEmptyArray.ts.md#2025-04-23_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\nimport { groupBy } from 'fp-ts/NonEmptyArray'\n\nassert.deepStrictEqual(groupBy((s: string) => String(s.length))(['a', 'b', 'ab']), {\n  '1': ['a', 'b'],\n  '2': ['ab'],\n})\n```\n\n----------------------------------------\n\nTITLE: Defining PipeableFunctor2C Interface in TypeScript\nDESCRIPTION: A pipeable version of the Functor type class for higher-kinded types of arity 2 with a fixed first type parameter. Provides the map method for functors with a constrained error type.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/pipeable.ts.md#2025-04-23_snippet_65\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface PipeableFunctor2C<F extends URIS2, E> {\n  readonly map: <A, B>(f: (a: A) => B) => (fa: Kind2<F, E, A>) => Kind2<F, E, B>\n}\n```\n\n----------------------------------------\n\nTITLE: Traversing ReadonlyTuple in TypeScript\nDESCRIPTION: Defines 'sequence' and 'traverse' operations for ReadonlyTuple, which are used for working with nested structures.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReadonlyTuple.ts.md#2025-04-23_snippet_7\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare const sequence: Sequence2<'ReadonlyTuple'>\n```\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare const traverse: PipeableTraverse2<'ReadonlyTuple'>\n```\n\n----------------------------------------\n\nTITLE: Mapping Both Channels Example in TypeScript\nDESCRIPTION: Example demonstrating the mapBoth operation that maps both failure and success channels of IOEither.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/IOEither.ts.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as IOEither from 'fp-ts/IOEither'\nimport * as Either from 'fp-ts/Either'\n\nconst f = (s: string) => new Error(s)\nconst g = (n: number) => n * 2\n\nassert.deepStrictEqual(IOEither.mapBoth(IOEither.right(1), f, g)(), Either.right(2))\nassert.deepStrictEqual(IOEither.mapBoth(IOEither.left('err'), f, g)(), Either.left(new Error('err')))\n```\n\n----------------------------------------\n\nTITLE: Defining URI Constants for StateReaderTaskEither in TypeScript\nDESCRIPTION: Defines URI constant and type alias for StateReaderTaskEither to be used with higher-kinded types in fp-ts, allowing the monad to work with generic functions that operate over different monads.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/StateReaderTaskEither.ts.md#2025-04-23_snippet_59\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare const URI: 'StateReaderTaskEither'\n```\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport type URI = typeof URI\n```\n\n----------------------------------------\n\nTITLE: Implementing chainIOEitherKW for StateReaderTaskEither in TypeScript\nDESCRIPTION: Defines chainIOEitherKW as a less strict version of chainIOEitherK. It merges error types when chaining an IOEither operation.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/StateReaderTaskEither.ts.md#2025-04-23_snippet_13\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare const chainIOEitherKW: <E2, A, B>(\n  f: (a: A) => IOEither<E2, B>\n) => <S, R, E1>(ma: StateReaderTaskEither<S, R, E1, A>) => StateReaderTaskEither<S, R, E2 | E1, B>\n```\n\n----------------------------------------\n\nTITLE: Implementing HKT4 Interface for `* -> * -> * -> * -> *` Constructors in TypeScript\nDESCRIPTION: Defines the HKT4 interface for quaternary type constructors that take four type parameters. It extends HKT3 and adds an additional type parameter S.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/HKT.ts.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface HKT4<URI, S, R, E, A> extends HKT3<URI, R, E, A> {\n  readonly _S: S\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Apply3 Interface in TypeScript\nDESCRIPTION: This code snippet defines the Apply3 interface, a variant of Apply for type constructors with three type parameters.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Apply.ts.md#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface Apply3<F extends URIS3> extends Functor3<F> {\n  readonly ap: <R, E, A, B>(fab: Kind3<F, R, E, (a: A) => B>, fa: Kind3<F, R, E, A>) => Kind3<F, R, E, B>\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing flatMap for StateReaderTaskEither in TypeScript\nDESCRIPTION: Provides a flatMap function for StateReaderTaskEither that allows sequencing operations, with two overloads supporting both pipeable and non-pipeable usage patterns.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/StateReaderTaskEither.ts.md#2025-04-23_snippet_42\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare const flatMap: {\n  <A, S, R2, E2, B>(f: (a: A) => StateReaderTaskEither<S, R2, E2, B>): <R1, E1>(\n    ma: StateReaderTaskEither<S, R1, E1, A>\n  ) => StateReaderTaskEither<S, R1 & R2, E2 | E1, B>\n  <S, R1, E1, A, R2, E2, B>(\n    ma: StateReaderTaskEither<S, R1, E1, A>,\n    f: (a: A) => StateReaderTaskEither<S, R2, E2, B>\n  ): StateReaderTaskEither<S, R1 & R2, E1 | E2, B>\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing reduceM Function in TypeScript\nDESCRIPTION: Monadic version of reduce that encapsulates the result in a monad, allowing for effects during folding. Not stack-safe for monads like IO that build up thunks.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Foldable.ts.md#2025-04-23_snippet_11\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare function reduceM<M extends URIS3, F extends URIS>(\n  M: Monad3<M>,\n  F: Foldable1<F>\n): <B, A, R, E>(b: B, f: (b: B, a: A) => Kind3<M, R, E, B>) => (fa: Kind<F, A>) => Kind3<M, R, E, B>\nexport declare function reduceM<M extends URIS3, F extends URIS, E>(\n  M: Monad3C<M, E>,\n  F: Foldable1<F>\n): <B, A, R>(b: B, f: (b: B, a: A) => Kind3<M, R, E, B>) => (fa: Kind<F, A>) => Kind3<M, R, E, B>\nexport declare function reduceM<M extends URIS2, F extends URIS>(\n  M: Monad2<M>,\n  F: Foldable1<F>\n): <B, A, E>(b: B, f: (b: B, a: A) => Kind2<M, E, B>) => (fa: Kind<F, A>) => Kind2<M, E, B>\nexport declare function reduceM<M extends URIS2, F extends URIS, E>(\n  M: Monad2C<M, E>,\n  F: Foldable1<F>\n): <B, A>(b: B, f: (b: B, a: A) => Kind2<M, E, B>) => (fa: Kind<F, A>) => Kind2<M, E, B>\nexport declare function reduceM<M extends URIS, F extends URIS>(\n  M: Monad1<M>,\n  F: Foldable1<F>\n): <B, A>(b: B, f: (b: B, a: A) => Kind<M, B>) => (fa: Kind<F, A>) => Kind<M, B>\nexport declare function reduceM<M, F>(\n  M: Monad<M>,\n  F: Foldable<F>\n): <B, A>(b: B, f: (b: B, a: A) => HKT<M, B>) => (fa: HKT<F, A>) => HKT<M, B>\n```\n\n----------------------------------------\n\nTITLE: Creating Applicative and Monad Instances for ReadonlyTuple in TypeScript\nDESCRIPTION: Defines functions to create Applicative, Apply, Chain, ChainRec, and Monad instances for ReadonlyTuple, given a Monoid or Semigroup.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReadonlyTuple.ts.md#2025-04-23_snippet_5\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare function getApplicative<M>(M: Monoid<M>): Applicative2C<URI, M>\n```\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare function getApply<S>(S: Semigroup<S>): Apply2C<URI, S>\n```\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare function getChain<S>(S: Semigroup<S>): Chain2C<URI, S>\n```\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare function getChainRec<M>(M: Monoid<M>): ChainRec2C<URI, M>\n```\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare function getMonad<M>(M: Monoid<M>): Monad2C<URI, M>\n```\n\n----------------------------------------\n\nTITLE: Implementing chainFirstReaderIOKW in TypeScript for ReaderTaskEither\nDESCRIPTION: Widening version of chainFirstReaderIOK that allows for different environment types. It takes a function from A to ReaderIO<R2, B> and returns a function that preserves the original value while merging environment types.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReaderTaskEither.ts.md#2025-04-23_snippet_29\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const chainFirstReaderIOKW: <A, R2, B>(\n  f: (a: A) => RIO.ReaderIO<R2, B>\n) => <R1, E>(ma: ReaderTaskEither<R1, E, A>) => ReaderTaskEither<R1 & R2, E, A>\n```\n\n----------------------------------------\n\nTITLE: Error Handling Functions in StateReaderTaskEither\nDESCRIPTION: Functions for handling errors and alternative paths in StateReaderTaskEither. Includes alt(), altW(), and mapLeft() implementations.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/StateReaderTaskEither.ts.md#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const alt: <S, R, E, A>(that: LazyArg<StateReaderTaskEither<S, R, E, A>>) => (fa: StateReaderTaskEither<S, R, E, A>) => StateReaderTaskEither<S, R, E, A>\n\nexport declare const altW: <S, R2, E2, B>(that: () => StateReaderTaskEither<S, R2, E2, B>) => <R1, E1, A>(fa: StateReaderTaskEither<S, R1, E1, A>) => StateReaderTaskEither<S, R1 & R2, E2, B | A>\n\nexport declare const mapLeft: <E, G>(f: (e: E) => G) => <S, R, A>(fa: StateReaderTaskEither<S, R, E, A>) => StateReaderTaskEither<S, R, G, A>\n```\n\n----------------------------------------\n\nTITLE: swap Function Declaration in TypeScript\nDESCRIPTION: Function to swap Left and Right variants within an Either monad transformer context.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/EitherT.ts.md#2025-04-23_snippet_16\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare function swap<F extends URIS3>(\n  F: Functor3<F>\n): <R, FE, E, A>(ma: Kind3<F, R, FE, Either<E, A>>) => Kind3<F, R, FE, Either<A, E>>\n```\n\n----------------------------------------\n\nTITLE: Implementing orElseW operation for Either in TypeScript\nDESCRIPTION: Defines a less strict version of orElse where the return types will be merged.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Either.ts.md#2025-04-23_snippet_12\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare const orElseW: <E1, E2, B>(onLeft: (e: E1) => Either<E2, B>) => <A>(ma: Either<E1, A>) => Either<E2, B | A>\n```\n\n----------------------------------------\n\nTITLE: Binding To in Do Notation for TaskEither in TypeScript\nDESCRIPTION: Binds a value to a property in a do notation chain.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/TaskEither.ts.md#2025-04-23_snippet_13\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare const bindTo: <N>(name: N) => <E, A>(fa: TaskEither<E, A>) => TaskEither<E, { readonly [K in N]: A }>\n```\n\n----------------------------------------\n\nTITLE: Choice Interface Definition\nDESCRIPTION: TypeScript interface definition for the Choice typeclass that extends Profunctor.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Choice.ts.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface Choice<F> extends Profunctor<F> {\n  readonly left: <A, B, C>(pab: HKT2<F, A, B>) => HKT2<F, Either<A, C>, Either<B, C>>\n  readonly right: <A, B, C>(pbc: HKT2<F, B, C>) => HKT2<F, Either<A, B>, Either<A, C>>\n}\n```\n\n----------------------------------------\n\nTITLE: Defining chainReaderTaskEitherK for StateReaderTaskEither in TypeScript\nDESCRIPTION: Implements chainReaderTaskEitherK as an alias of flatMapReaderTaskEither. It chains a ReaderTaskEither operation after a StateReaderTaskEither.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/StateReaderTaskEither.ts.md#2025-04-23_snippet_19\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare const chainReaderTaskEitherK: <R, E, A, B>(\n  f: (a: A) => RTE.ReaderTaskEither<R, E, B>\n) => <S>(ma: StateReaderTaskEither<S, R, E, A>) => StateReaderTaskEither<S, R, E, B>\n```\n\n----------------------------------------\n\nTITLE: Defining flatMapOption Operation for ReaderTaskEither in TypeScript\nDESCRIPTION: Function signature for flatMapOption that maps a ReaderTaskEither to another one, handling Option values with a provided error function for None cases. Added in v2.15.0.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReaderTaskEither.ts.md#2025-04-23_snippet_89\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const flatMapOption: {\n  <A, B, E2>(f: (a: A) => Option<B>, onNone: (a: A) => E2): <R, E1>(\n    self: ReaderTaskEither<R, E1, A>\n  ) => ReaderTaskEither<R, E2 | E1, B>\n  <R, E1, A, B, E2>(self: ReaderTaskEither<R, E1, A>, f: (a: A) => Option<B>, onNone: (a: A) => E2): ReaderTaskEither<\n    R,\n    E1 | E2,\n    B\n  >\n}\n```\n\n----------------------------------------\n\nTITLE: Defining apFirst function for ReaderIO in TypeScript\nDESCRIPTION: Combines two ReaderIO actions, keeping only the result of the first.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReaderIO.ts.md#2025-04-23_snippet_24\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const apFirst: <E, B>(second: ReaderIO<E, B>) => <A>(first: ReaderIO<E, A>) => ReaderIO<E, A>\n```\n\n----------------------------------------\n\nTITLE: Array Traversal Functions with ReaderTask\nDESCRIPTION: Functions for traversing arrays with ReaderTask monads, including variations for readonly arrays and non-empty arrays\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReaderTask.ts.md#2025-04-23_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const traverseReadonlyArrayWithIndexSeq: <R, A, B>(\n  f: (index: number, a: A) => ReaderTask<R, B>\n) => (as: readonly A[]) => ReaderTask<R, readonly B[]>\n\nexport declare const traverseReadonlyNonEmptyArrayWithIndex: <A, R, B>(\n  f: (index: number, a: A) => ReaderTask<R, B>\n) => (as: ReadonlyNonEmptyArray<A>) => ReaderTask<R, ReadonlyNonEmptyArray<B>>\n\nexport declare const traverseReadonlyNonEmptyArrayWithIndexSeq: <R, A, B>(\n  f: (index: number, a: A) => ReaderTask<R, B>\n) => (as: ReadonlyNonEmptyArray<A>) => ReaderTask<R, ReadonlyNonEmptyArray<B>>\n```\n\n----------------------------------------\n\nTITLE: Implementing chainEitherKW in TypeScript for ReaderTaskEither\nDESCRIPTION: Widening version of chainEitherK that allows for different error types. It takes a function from A to Either<E2, B> and returns a function that transforms a ReaderTaskEither<R, E1, A> into a ReaderTaskEither<R, E1 | E2, B>.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReaderTaskEither.ts.md#2025-04-23_snippet_21\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const chainEitherKW: <E2, A, B>(\n  f: (a: A) => E.Either<E2, B>\n) => <R, E1>(ma: ReaderTaskEither<R, E1, A>) => ReaderTaskEither<R, E2 | E1, B>\n```\n\n----------------------------------------\n\nTITLE: Defining ReaderIO Interface in TypeScript\nDESCRIPTION: Defines the ReaderIO interface, which represents a computation that reads from an environment and produces an IO effect.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReaderIO.ts.md#2025-04-23_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport interface ReaderIO<R, A> {\n  (r: R): I.IO<A>\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing tapIO Combinator for ReaderIO in TypeScript\nDESCRIPTION: Implements the tapIO combinator, which composes computations in sequence, using the return value of one computation to determine the next and keeping only the result of the first, with an example.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReaderIO.ts.md#2025-04-23_snippet_2\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare const tapIO: {\n  <A, _>(f: (a: A) => I.IO<_>): <R>(self: ReaderIO<R, A>) => ReaderIO<R, A>\n  <R, A, _>(self: ReaderIO<R, A>, f: (a: A) => I.IO<_>): ReaderIO<R, A>\n}\n```\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { pipe } from 'fp-ts/function'\nimport * as RIO from 'fp-ts/ReaderIO'\nimport * as Console from 'fp-ts/Console'\n\n// Will produce `Hello, fp-ts` to the stdout\nconst effect = pipe(\n  RIO.ask<string>(),\n  RIO.tapIO((value) => Console.log(`Hello, ${value}`))\n)\n\nasync function test() {\n  assert.deepStrictEqual(effect('fp-ts')(), 'fp-ts')\n}\n\ntest()\n```\n\n----------------------------------------\n\nTITLE: Implementing fromOptionK for Option Lifting\nDESCRIPTION: Transforms a function returning an Option into a function returning a ReaderTaskEither, with a specified error generator for None cases.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReaderTaskEither.ts.md#2025-04-23_snippet_58\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const fromOptionK: <E>(\n  onNone: LazyArg<E>\n) => <A extends readonly unknown[], B>(f: (...a: A) => Option<B>) => <R = unknown>(...a: A) => ReaderTaskEither<R, E, B>\n```\n\n----------------------------------------\n\nTITLE: Reducing Records with Custom Order in TypeScript\nDESCRIPTION: Implements a reduce function for Records, processing entries in order sorted by key according to the given Ord. It takes an initial value and a reducer function to accumulate results.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Record.ts.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare function reduce(O: Ord<string>): <A, B>(b: B, f: (b: B, a: A) => B) => (fa: Record<string, A>) => B\nexport declare function reduce<A, B>(b: B, f: (b: B, a: A) => B): (fa: Record<string, A>) => B\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport { reduce } from 'fp-ts/Record'\nimport { Ord } from 'fp-ts/string'\n\nconst x = { c: 3, a: 'foo', b: false }\nassert.deepStrictEqual(reduce(Ord)([] as string[], (b, a) => [...b, `-${a}-`])(x), ['-foo-', '-false-', '-3-'])\n```\n\n----------------------------------------\n\nTITLE: Implementing chainEitherK in TypeScript for ReaderTaskEither\nDESCRIPTION: Alias of flatMapEither that chains an Either-returning function with a ReaderTaskEither. It takes a function from A to Either<E, B> and returns a function that transforms a ReaderTaskEither<R, E, A> into a ReaderTaskEither<R, E, B>.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReaderTaskEither.ts.md#2025-04-23_snippet_20\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const chainEitherK: <E, A, B>(\n  f: (a: A) => E.Either<E, B>\n) => <R>(ma: ReaderTaskEither<R, E, A>) => ReaderTaskEither<R, E, B>\n```\n\n----------------------------------------\n\nTITLE: Prepending Element to All Array Elements with fp-ts\nDESCRIPTION: Prepends an element to every member of an array, creating a new array. The provided element will appear before each original array element.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReadonlyArray.ts.md#2025-04-23_snippet_46\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const prependAll: <A>(middle: A) => (as: readonly A[]) => readonly A[]\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport { prependAll } from 'fp-ts/ReadonlyArray'\n\nassert.deepStrictEqual(prependAll(9)([1, 2, 3, 4]), [9, 1, 9, 2, 9, 3, 9, 4])\n```\n\n----------------------------------------\n\nTITLE: Mapping Functions for ReaderEither\nDESCRIPTION: Functions for transforming values inside ReaderEither context, including map, flap, as, and asUnit operations.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReaderEither.ts.md#2025-04-23_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const map: <A, B>(f: (a: A) => B) => <R, E>(fa: ReaderEither<R, E, A>) => ReaderEither<R, E, B>\n```\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const flap: <A>(a: A) => <R, E, B>(fab: ReaderEither<R, E, (a: A) => B>) => ReaderEither<R, E, B>\n```\n\n----------------------------------------\n\nTITLE: Accessing Contravariant instance for Eq in TypeScript\nDESCRIPTION: Provides the Contravariant type class instance for Eq, allowing contravariant mapping operations.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Eq.ts.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const Contravariant: Contravariant1<'Eq'>\n```\n\n----------------------------------------\n\nTITLE: Implementing fromTaskEitherK for StateReaderTaskEither in TypeScript\nDESCRIPTION: Defines a function to lift a TaskEither-returning function into the StateReaderTaskEither context.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/StateReaderTaskEither.ts.md#2025-04-23_snippet_34\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare const fromTaskEitherK: <E, A extends readonly unknown[], B>(\n  f: (...a: A) => TaskEither<E, B>\n) => <S, R = unknown>(...a: A) => StateReaderTaskEither<S, R, E, B>\n```\n\n----------------------------------------\n\nTITLE: Implementing fromEitherK for Lifting Either Functions in TypeScript\nDESCRIPTION: Creates a function that transforms an Either-returning function into a TaskEither-returning function, preserving the error and success types.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/TaskEither.ts.md#2025-04-23_snippet_48\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const fromEitherK: <E, A extends readonly unknown[], B>(\n  f: (...a: A) => E.Either<E, B>\n) => (...a: A) => TaskEither<E, B>\n```\n\n----------------------------------------\n\nTITLE: Creating a Singleton Set in TypeScript\nDESCRIPTION: Creates a new Set containing a single element. This function is useful for initializing sets with one value.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Set.ts.md#2025-04-23_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare const singleton: <A>(a: A) => Set<A>\n```\n\n----------------------------------------\n\nTITLE: Defining PipeableFunctorWithIndex2C Interface in TypeScript\nDESCRIPTION: Extends PipeableFunctor2C to provide indexed mapping operations for arity 2 higher-kinded types with a fixed first type parameter. Adds the mapWithIndex method that uses both index and value.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/pipeable.ts.md#2025-04-23_snippet_70\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface PipeableFunctorWithIndex2C<F extends URIS2, I, E> extends PipeableFunctor2C<F, E> {\n  readonly mapWithIndex: <A, B>(f: (i: I, a: A) => B) => (fa: Kind2<F, E, A>) => Kind2<F, E, B>\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing fromReaderK for Reader Lifting\nDESCRIPTION: Transforms a function returning a Reader into a function returning a ReaderTaskEither, lifting pure reader context to include asynchronous and error handling capabilities.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReaderTaskEither.ts.md#2025-04-23_snippet_68\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const fromReaderK: <A extends readonly unknown[], R, B>(\n  f: (...a: A) => R.Reader<R, B>\n) => <E = never>(...a: A) => ReaderTaskEither<R, E, B>\n```\n\n----------------------------------------\n\nTITLE: IOEither Mapping Functions\nDESCRIPTION: Functions for mapping over IOEither values including map, as, asUnit and flap\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/IOEither.ts.md#2025-04-23_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const map: <A, B>(f: (a: A) => B) => <E>(fa: IOEither<E, A>) => IOEither<E, B>\n```\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const as: {\n  <A>(a: A): <E, _>(self: IOEither<E, _>) => IOEither<E, A>\n  <E, _, A>(self: IOEither<E, _>, a: A): IOEither<E, A>\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Comonad1 Interface for URIS in TypeScript\nDESCRIPTION: Defines the Comonad1 interface extending Extend1 for higher-kinded types of arity 1, providing extract functionality.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Comonad.ts.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface Comonad1<W extends URIS> extends Extend1<W> {\n  readonly extract: <A>(wa: Kind<W, A>) => A\n}\n```\n\n----------------------------------------\n\nTITLE: Defining chainIOEitherK for StateReaderTaskEither in TypeScript\nDESCRIPTION: Implements chainIOEitherK as an alias of flatMapIOEither. It chains an IOEither operation after a StateReaderTaskEither.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/StateReaderTaskEither.ts.md#2025-04-23_snippet_12\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare const chainIOEitherK: <E, A, B>(\n  f: (a: A) => IOEither<E, B>\n) => <S, R>(ma: StateReaderTaskEither<S, R, E, A>) => StateReaderTaskEither<S, R, E, B>\n```\n\n----------------------------------------\n\nTITLE: Defining FunctorWithIndex3 Interface for URIS3 in TypeScript\nDESCRIPTION: Interface for FunctorWithIndex with three type parameters, extending Functor3 with the mapWithIndex operation.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/FunctorWithIndex.ts.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface FunctorWithIndex3<F extends URIS3, I> extends Functor3<F> {\n  readonly mapWithIndex: <R, E, A, B>(fa: Kind3<F, R, E, A>, f: (i: I, a: A) => B) => Kind3<F, R, E, B>\n}\n```\n\n----------------------------------------\n\nTITLE: Defining chainIOK for StateReaderTaskEither in TypeScript\nDESCRIPTION: Implements chainIOK as an alias of flatMapIO. It chains an IO operation after a StateReaderTaskEither.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/StateReaderTaskEither.ts.md#2025-04-23_snippet_14\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare const chainIOK: <A, B>(\n  f: (a: A) => IO<B>\n) => <S, R, E>(first: StateReaderTaskEither<S, R, E, A>) => StateReaderTaskEither<S, R, E, B>\n```\n\n----------------------------------------\n\nTITLE: Implementing Widening orLeft Operation for ReaderTaskEither in TypeScript\nDESCRIPTION: Defines a widening version of orLeft (orLeftW) for ReaderTaskEither, which handles the case when the Either is Left by returning a new ReaderTask with widened types.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReaderTaskEither.ts.md#2025-04-23_snippet_18\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare const orLeftW: <E1, R2, E2>(\n  onLeft: (e: E1) => RT.ReaderTask<R2, E2>\n) => <R1, A>(fa: ReaderTaskEither<R1, E1, A>) => ReaderTaskEither<R1 & R2, E2, A>\n```\n\n----------------------------------------\n\nTITLE: Defining the URI constant for Const in TypeScript\nDESCRIPTION: Defines the URI constant for the Const type constructor, used for type class instances and higher-kinded types.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Const.ts.md#2025-04-23_snippet_21\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const URI: 'Const'\n```\n\n----------------------------------------\n\nTITLE: Implementing asUnit for Void Mapping\nDESCRIPTION: Maps the success value of a ReaderTaskEither to void, useful when only the side effects or completion status matters rather than the actual value.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReaderTaskEither.ts.md#2025-04-23_snippet_75\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const asUnit: <R, E, _>(self: ReaderTaskEither<R, E, _>) => ReaderTaskEither<R, E, void>\n```\n\n----------------------------------------\n\nTITLE: Defining IOOption Interface in TypeScript\nDESCRIPTION: Declares the IOOption interface, which represents an IO of an Option value.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/IOOption.ts.md#2025-04-23_snippet_33\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface IOOption<A> extends IO<Option<A>> {}\n```\n\n----------------------------------------\n\nTITLE: Implementing FlatMapNullable Function for IOOption in TypeScript\nDESCRIPTION: Defines the flatMapNullable function for IOOption. It allows chaining operations with nullable values on IOOption.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/IOOption.ts.md#2025-04-23_snippet_42\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const flatMapNullable: {\n  <A, B>(f: (a: A) => B | null | undefined): (self: IOOption<A>) => IOOption<B>\n  <A, B>(self: IOOption<A>, f: (a: A) => B | null | undefined): IOOption<B>\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing evaluate function in StateReaderTaskEither (TypeScript)\nDESCRIPTION: The evaluate function runs a computation in the StateReaderTaskEither monad with an initial state, but discards the final state and returns only the result as a ReaderTaskEither.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/StateReaderTaskEither.ts.md#2025-04-23_snippet_70\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const evaluate: <S>(\n  s: S\n) => <R, E, A>(ma: StateReaderTaskEither<S, R, E, A>) => RTE.ReaderTaskEither<R, E, A>\n```\n\n----------------------------------------\n\nTITLE: Defining fromIOK function for ReaderIO in TypeScript\nDESCRIPTION: Creates a ReaderIO from an IO-returning function. It takes a function that returns an IO and transforms it into a function that returns a ReaderIO.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReaderIO.ts.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const fromIOK: <A extends readonly unknown[], B>(\n  f: (...a: A) => I.IO<B>\n) => <R = unknown>(...a: A) => ReaderIO<R, B>\n```\n\n----------------------------------------\n\nTITLE: Mapping Left Element of ReadonlyTuple in TypeScript\nDESCRIPTION: Defines a 'mapLeft' function that applies a transformation to the second element of a readonly tuple. It's an alias for 'mapSnd'.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReadonlyTuple.ts.md#2025-04-23_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare const mapLeft: <E, G>(f: (e: E) => G) => <A>(fa: readonly [A, E]) => readonly [A, G]\n```\n\n----------------------------------------\n\nTITLE: Implementing ApFirst Function for IOOption in TypeScript\nDESCRIPTION: Defines the apFirst function for IOOption. It combines two effectful actions, keeping only the result of the first.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/IOOption.ts.md#2025-04-23_snippet_51\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const apFirst: <B>(second: IOOption<B>) => <A>(first: IOOption<A>) => IOOption<A>\n```\n\n----------------------------------------\n\nTITLE: Defining Extend2 Interface for Binary Type Constructors\nDESCRIPTION: Defines the Extend2 interface for binary type constructors that extends Functor2 and provides the extend method with appropriate type parameters.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Extend.ts.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface Extend2<W extends URIS2> extends Functor2<W> {\n  readonly extend: <E, A, B>(wa: Kind2<W, E, A>, f: (wa: Kind2<W, E, A>) => B) => Kind2<W, E, B>\n}\n```\n\n----------------------------------------\n\nTITLE: Defining the getMinMaxBoundedDistributiveLattice Constructor in TypeScript\nDESCRIPTION: Function signature for creating a BoundedDistributiveLattice from an Ord instance and min/max values. It takes an ordering instance and returns a function that accepts minimum and maximum values to create a bounded distributive lattice.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/BoundedDistributiveLattice.ts.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare function getMinMaxBoundedDistributiveLattice<A>(\n  O: Ord<A>\n): (min: A, max: A) => BoundedDistributiveLattice<A>\n```\n\n----------------------------------------\n\nTITLE: Utility Functions for TaskEither Operations\nDESCRIPTION: Collection of utility functions for TaskEither including applicative operations and error handling.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/TaskEither.ts.md#2025-04-23_snippet_82\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const ap: <E, A>(fa: TaskEither<E, A>) => <B>(fab: TaskEither<E, (a: A) => B>) => TaskEither<E, B>\n```\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const bracket: <E, A, B>(\n  acquire: TaskEither<E, A>,\n  use: (a: A) => TaskEither<E, B>,\n  release: (a: A, e: E.Either<E, B>) => TaskEither<E, void>\n) => TaskEither<E, B>\n```\n\n----------------------------------------\n\nTITLE: Defining Category2 Interface in TypeScript\nDESCRIPTION: Defines Category2 interface extending Semigroupoid2 with URIS2 constraint. Includes an identity function returning Kind2 type.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Category.ts.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface Category2<F extends URIS2> extends Semigroupoid2<F> {\n  readonly id: <A>() => Kind2<F, A, A>\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing chainIOK in TypeScript for ReaderTaskEither\nDESCRIPTION: Alias of flatMapIO that chains an IO-returning function with a ReaderTaskEither. It takes a function from A to IO<B> and returns a function that transforms a ReaderTaskEither<R, E, A> into a ReaderTaskEither<R, E, B>.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReaderTaskEither.ts.md#2025-04-23_snippet_40\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const chainIOK: <A, B>(\n  f: (a: A) => IO<B>\n) => <R, E>(first: ReaderTaskEither<R, E, A>) => ReaderTaskEither<R, E, B>\n```\n\n----------------------------------------\n\nTITLE: Implementing chainFirstReaderTaskK in TypeScript for ReaderTaskEither\nDESCRIPTION: Alias of tapReaderTask that executes a ReaderTask-returning side effect without changing the original value. It takes a function from A to ReaderTask<R, B> and preserves the original value.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReaderTaskEither.ts.md#2025-04-23_snippet_32\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const chainFirstReaderTaskK: <A, R, B>(\n  f: (a: A) => RT.ReaderTask<R, B>\n) => <E>(ma: ReaderTaskEither<R, E, A>) => ReaderTaskEither<R, E, A>\n```\n\n----------------------------------------\n\nTITLE: IOEither Base Interface Definition\nDESCRIPTION: Core interface definition for IOEither type that combines IO and Either monads\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/IOEither.ts.md#2025-04-23_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface IOEither<E, A> extends IO<Either<E, A>> {}\n```\n\n----------------------------------------\n\nTITLE: IOOption TapIO Implementation with Example - TypeScript\nDESCRIPTION: Implementation of tapIO with example demonstrating how to compose IO computations while maintaining the original value.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/IOOption.ts.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const tapIO: {\n  <A, _>(f: (a: A) => I.IO<_>): (self: IOOption<A>) => IOOption<A>\n  <A, _>(self: IOOption<A>, f: (a: A) => I.IO<_>): IOOption<A>\n}\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport { pipe } from 'fp-ts/function'\nimport * as IOO from 'fp-ts/IOOption'\nimport * as O from 'fp-ts/Option'\nimport * as Console from 'fp-ts/Console'\n\n// Will produce `Hello, fp-ts` to the stdout\nconst effectA = pipe(\n  IOO.of('fp-ts'),\n  IOO.tapIO((value) => Console.log(`Hello, ${value}`))\n)\n\n// No output to the stdout\nconst effectB = pipe(\n  IOO.none as IOO.IOOption<string>,\n  IOO.tapIO((value) => Console.log(`Hello, ${value}`))\n)\n\nasync function test() {\n  assert.deepStrictEqual(effectA(), O.of('fp-ts'))\n  assert.deepStrictEqual(effectB(), O.none)\n}\n\ntest()\n```\n\n----------------------------------------\n\nTITLE: Implementing FromIO Conversion for ReaderTask in TypeScript\nDESCRIPTION: Implements the 'fromIO' conversion function for ReaderTask, which lifts an IO computation into a ReaderTask.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReaderTask.ts.md#2025-04-23_snippet_5\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare const fromIO: <A, R = unknown>(fa: IO<A>) => ReaderTask<R, A>\n```\n\n----------------------------------------\n\nTITLE: Composing Refinements\nDESCRIPTION: Composes two refinements in sequence, where the output of first refinement is input to second.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Refinement.ts.md#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const compose: <A, B extends A, C extends B>(\n  bc: Refinement<B, C>\n) => (ab: Refinement<A, B>) => Refinement<A, C>\n```\n\n----------------------------------------\n\nTITLE: Implementing orLeft Operation for ReaderTaskEither in TypeScript\nDESCRIPTION: Defines an orLeft operation for ReaderTaskEither, which handles the case when the Either is Left by returning a new ReaderTask.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReaderTaskEither.ts.md#2025-04-23_snippet_17\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare const orLeft: <E1, R, E2>(\n  onLeft: (e: E1) => RT.ReaderTask<R, E2>\n) => <A>(fa: ReaderTaskEither<R, E1, A>) => ReaderTaskEither<R, E2, A>\n```\n\n----------------------------------------\n\nTITLE: Implementing Array Traversal Functions in TypeScript\nDESCRIPTION: Collection of array traversal functions for TaskEither type. These functions allow mapping over arrays while maintaining the TaskEither context.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/TaskEither.ts.md#2025-04-23_snippet_78\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const traverseArray: <A, B, E>(\n  f: (a: A) => TaskEither<E, B>\n) => (as: readonly A[]) => TaskEither<E, readonly B[]>\n```\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const traverseArrayWithIndex: <A, B, E>(\n  f: (index: number, a: A) => TaskEither<E, B>\n) => (as: readonly A[]) => TaskEither<E, readonly B[]>\n```\n\n----------------------------------------\n\nTITLE: Implementing alt Operation in TypeScript\nDESCRIPTION: Defines an associative operation on IOEither type constructor, similar to Semigroup but for types of kind * -> *.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/IOEither.ts.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const alt: <E, A>(that: LazyArg<IOEither<E, A>>) => (fa: IOEither<E, A>) => IOEither<E, A>\n```\n\n----------------------------------------\n\nTITLE: Profunctor2 Interface Implementation\nDESCRIPTION: Implementation of Profunctor for types with two type parameters. Extends Functor2 and adds promap operation.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Profunctor.ts.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface Profunctor2<F extends URIS2> extends Functor2<F> {\n  readonly promap: <E, A, D, B>(fea: Kind2<F, E, A>, f: (d: D) => E, g: (a: A) => B) => Kind2<F, D, B>\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Monad3C Interface with Fixed Error Type in TypeScript\nDESCRIPTION: Defines the Monad3C interface for higher-kinded types with three type parameters and a fixed error type. It extends Applicative3C and Chain3C interfaces.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Monad.ts.md#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface Monad3C<M extends URIS3, E> extends Applicative3C<M, E>, Chain3C<M, E> {}\n```\n\n----------------------------------------\n\nTITLE: Left-to-right reduction of Records with index in fp-ts\nDESCRIPTION: Reduces a Record passing each key/value pair to the iterating function. Keys are processed in order, sorted by key according to the given Ord instance.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Record.ts.md#2025-04-23_snippet_45\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare function reduceWithIndex(\n  O: Ord<string>\n): <K extends string, A, B>(b: B, f: (k: K, b: B, a: A) => B) => (fa: Record<K, A>) => B\nexport declare function reduceWithIndex<K extends string, A, B>(\n  b: B,\n  f: (k: K, b: B, a: A) => B\n): (fa: Record<K, A>) => B\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport { reduceWithIndex } from 'fp-ts/Record'\nimport { Ord } from 'fp-ts/string'\n\nconst x = { c: 3, a: 'foo', b: false }\nassert.deepStrictEqual(reduceWithIndex(Ord)([] as string[], (k, b, a) => [...b, `${k}-${a}`])(x), [\n  'a-foo',\n  'b-false',\n  'c-3',\n])\n```\n\n----------------------------------------\n\nTITLE: Removing a key-value pair from a Record in fp-ts\nDESCRIPTION: Deletes a key and its value from a Record, returning both the value and the modified Record as an Option tuple. Returns None if the key doesn't exist.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Record.ts.md#2025-04-23_snippet_43\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare function pop<K extends string>(\n  k: K\n): <KS extends string, A>(r: Record<KS, A>) => Option<[A, Record<string extends K ? string : Exclude<KS, K>, A>]>\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport { pop } from 'fp-ts/Record'\nimport { option } from 'fp-ts'\n\nassert.deepStrictEqual(pop('a')({ a: 1, b: 2, c: 3 }), option.some([1, { b: 2, c: 3 }]))\nassert.deepStrictEqual(pop('x')({ a: 1, b: 2, c: 3 }), option.none)\n```\n\n----------------------------------------\n\nTITLE: Implementing TraverseReadonlyArrayWithIndex Function for IOOption in TypeScript\nDESCRIPTION: Defines the traverseReadonlyArrayWithIndex function for IOOption. It's equivalent to ReadonlyArray#traverseWithIndex(Applicative).\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/IOOption.ts.md#2025-04-23_snippet_45\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const traverseReadonlyArrayWithIndex: <A, B>(\n  f: (index: number, a: A) => IOOption<B>\n) => (as: readonly A[]) => IOOption<readonly B[]>\n```\n\n----------------------------------------\n\nTITLE: Implementing chainReaderTaskK in TypeScript for ReaderTaskEither\nDESCRIPTION: Alias of flatMapReaderTask that chains a ReaderTask-returning function with a ReaderTaskEither. It takes a function from A to ReaderTask<R, B> and returns a function that transforms a ReaderTaskEither<R, E, A> into a ReaderTaskEither<R, E, B>.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReaderTaskEither.ts.md#2025-04-23_snippet_50\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const chainReaderTaskK: <A, R, B>(\n  f: (a: A) => RT.ReaderTask<R, B>\n) => <E>(ma: ReaderTaskEither<R, E, A>) => ReaderTaskEither<R, E, B>\n```\n\n----------------------------------------\n\nTITLE: Initializing Do Notation for TaskEither in TypeScript\nDESCRIPTION: Provides an empty TaskEither to start a do notation chain.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/TaskEither.ts.md#2025-04-23_snippet_9\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare const Do: TaskEither<never, {}>\n```\n\n----------------------------------------\n\nTITLE: Deprecated getFirstMonoid Function with Example\nDESCRIPTION: Deprecated monoid implementation returning left-most non-None value, with usage example.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Option.ts.md#2025-04-23_snippet_17\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const getFirstMonoid: <A = never>() => Monoid<Option<A>>\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport { getFirstMonoid, some, none } from 'fp-ts/Option'\n\nconst M = getFirstMonoid<number>()\nassert.deepStrictEqual(M.concat(none, none), none)\nassert.deepStrictEqual(M.concat(some(1), none), some(1))\nassert.deepStrictEqual(M.concat(none, some(2)), some(2))\nassert.deepStrictEqual(M.concat(some(1), some(2)), some(1))\n```\n\n----------------------------------------\n\nTITLE: Implementing chainW for StateReaderTaskEither in TypeScript\nDESCRIPTION: Defines chainW as an alias of flatMap. It provides a widening operation that merges environment and error types when chaining StateReaderTaskEither operations.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/StateReaderTaskEither.ts.md#2025-04-23_snippet_25\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare const chainW: <S, R2, E2, A, B>(\n  f: (a: A) => StateReaderTaskEither<S, R2, E2, B>\n) => <R1, E1>(ma: StateReaderTaskEither<S, R1, E1, A>) => StateReaderTaskEither<S, R1 & R2, E2 | E1, B>\n```\n\n----------------------------------------\n\nTITLE: Defining FunctorCompositionHKT2 Interface in TypeScript\nDESCRIPTION: Interface for composing a generic higher-kinded type with a binary higher-kinded type using the HKT representation.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Functor.ts.md#2025-04-23_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface FunctorCompositionHKT2<F, G extends URIS2> {\n  readonly map: <E, A, B>(fa: HKT<F, Kind2<G, E, A>>, f: (a: A) => B) => HKT<F, Kind2<G, E, B>>\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing local function in StateReaderTaskEither (TypeScript)\nDESCRIPTION: The local function changes the value of the local context during the execution of a StateReaderTaskEither action, similar to Contravariant's contramap. It transforms the environment type from R2 to R1.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/StateReaderTaskEither.ts.md#2025-04-23_snippet_73\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const local: <R2, R1>(\n  f: (r2: R2) => R1\n) => <S, E, A>(ma: StateReaderTaskEither<S, R1, E, A>) => StateReaderTaskEither<S, R2, E, A>\n```\n\n----------------------------------------\n\nTITLE: Implementing chainOptionKW in TypeScript for ReaderTaskEither\nDESCRIPTION: Widening version of chainOptionK that allows for different error types. It takes a lazy error generator and a function that returns an Option<B>, and returns a function that transforms a ReaderTaskEither<R, E1, A> into a ReaderTaskEither<R, E1 | E2, B>.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReaderTaskEither.ts.md#2025-04-23_snippet_43\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const chainOptionKW: <E2>(\n  onNone: LazyArg<E2>\n) => <A, B>(f: (a: A) => Option<B>) => <R, E1>(ma: ReaderTaskEither<R, E1, A>) => ReaderTaskEither<R, E2 | E1, B>\n```\n\n----------------------------------------\n\nTITLE: getStateM Factory Function Definition in TypeScript\nDESCRIPTION: Factory function for creating State Monad Transformer instances with various type constraints and error handling capabilities.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/StateT.ts.md#2025-04-23_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare function getStateM<M extends URIS3>(M: Monad3<M>): StateM3<M>\nexport declare function getStateM<M extends URIS3, E>(M: Monad3C<M, E>): StateM3C<M, E>\nexport declare function getStateM<M extends URIS2>(M: Monad2<M>): StateM2<M>\nexport declare function getStateM<M extends URIS2, E>(M: Monad2C<M, E>): StateM2C<M, E>\nexport declare function getStateM<M extends URIS>(M: Monad1<M>): StateM1<M>\nexport declare function getStateM<M>(M: Monad<M>): StateM<M>\n```\n\n----------------------------------------\n\nTITLE: Implementing Chain4 Interface for URIS4\nDESCRIPTION: Chain interface for type constructors with four type parameters, extending Apply4.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Chain.ts.md#2025-04-23_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface Chain4<F extends URIS4> extends Apply4<F> {\n  readonly chain: <S, R, E, A, B>(fa: Kind4<F, S, R, E, A>, f: (a: A) => Kind4<F, S, R, E, B>) => Kind4<F, S, R, E, B>\n}\n```\n\n----------------------------------------\n\nTITLE: Defining PipeableFoldable2 Interface in TypeScript\nDESCRIPTION: A pipeable version of the Foldable type class for higher-kinded types of arity 2. It provides methods for folding a data structure with a generic error type parameter.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/pipeable.ts.md#2025-04-23_snippet_54\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface PipeableFoldable2<F extends URIS2> {\n  readonly reduce: <A, B>(b: B, f: (b: B, a: A) => B) => <E>(fa: Kind2<F, E, A>) => B\n  readonly foldMap: <M>(M: Monoid<M>) => <A>(f: (a: A) => M) => <E>(fa: Kind2<F, E, A>) => M\n  readonly reduceRight: <A, B>(b: B, f: (a: A, b: B) => B) => <E>(fa: Kind2<F, E, A>) => B\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Functional Programming Instances for ReadonlyTuple in TypeScript\nDESCRIPTION: Declares various instances of functional programming concepts like Bifunctor, Comonad, Foldable, Functor, Semigroupoid, and Traversable for ReadonlyTuple.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReadonlyTuple.ts.md#2025-04-23_snippet_4\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare const Bifunctor: Bifunctor2<'ReadonlyTuple'>\n```\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare const Comonad: Comonad2<'ReadonlyTuple'>\n```\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare const Foldable: Foldable2<'ReadonlyTuple'>\n```\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare const Functor: Functor2<'ReadonlyTuple'>\n```\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare const Semigroupoid: Semigroupoid2<'ReadonlyTuple'>\n```\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare const Traversable: Traversable2<'ReadonlyTuple'>\n```\n\n----------------------------------------\n\nTITLE: Creating Show Instance for Records in TypeScript\nDESCRIPTION: Produces a Show for a Record, given a Show for the base type. Record entries are sorted by key with the provided Ord. The resulting Show produces a human-readable representation of a Record instance.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Record.ts.md#2025-04-23_snippet_15\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare function getShow(O: Ord<string>): <A>(S: Show<A>) => Show<Record<string, A>>\nexport declare function getShow<A>(S: Show<A>): Show<Record<string, A>>\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport { getShow } from 'fp-ts/Record'\nimport { Show } from 'fp-ts/Show'\nimport { Ord } from 'fp-ts/string'\n\nconst sNumber: Show<number> = { show: (n: number) => `${n}` }\nconst sRecord: Show<Record<string, number>> = getShow(Ord)(sNumber)\nassert.deepStrictEqual(sRecord.show({ b: 2, a: 1 }), '{ \"a\": 1, \"b\": 2 }')\n```\n\n----------------------------------------\n\nTITLE: Implementing chainFirstReaderK utility in TypeScript\nDESCRIPTION: The chainFirstReaderK utility composes a computation with a Reader-returning function, running the function but keeping the original value. It's similar to tap operations in other functional libraries.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/FromReader.ts.md#2025-04-23_snippet_7\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare function chainFirstReaderK<M extends URIS4>(\n  F: FromReader4<M>,\n  M: Chain4<M>\n): <A, R, B>(f: (a: A) => Reader<R, B>) => <S, E>(ma: Kind4<M, S, R, E, A>) => Kind4<M, S, R, E, A>\nexport declare function chainFirstReaderK<M extends URIS3>(\n  F: FromReader3<M>,\n  M: Chain3<M>\n): <A, R, B>(f: (a: A) => Reader<R, B>) => <E>(ma: Kind3<M, R, E, A>) => Kind3<M, R, E, A>\nexport declare function chainFirstReaderK<M extends URIS3, E>(\n  F: FromReader3C<M, E>,\n  M: Chain3C<M, E>\n): <A, R, B>(f: (a: A) => Reader<R, B>) => (ma: Kind3<M, R, E, A>) => Kind3<M, R, E, A>\nexport declare function chainFirstReaderK<M extends URIS2>(\n  F: FromReader2<M>,\n  M: Chain2<M>\n): <A, R, B>(f: (a: A) => Reader<R, B>) => (ma: Kind2<M, R, A>) => Kind2<M, R, A>\nexport declare function chainFirstReaderK<M>(\n  F: FromReader<M>,\n  M: Chain<M>\n): <A, R, B>(f: (a: A) => Reader<R, B>) => (ma: HKT2<M, R, A>) => HKT2<M, R, A>\n```\n\n----------------------------------------\n\nTITLE: Defining Comonad2 Interface for URIS2 in TypeScript\nDESCRIPTION: Defines the Comonad2 interface extending Extend2 for higher-kinded types of arity 2, providing extract functionality.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Comonad.ts.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface Comonad2<W extends URIS2> extends Extend2<W> {\n  readonly extract: <E, A>(wa: Kind2<W, E, A>) => A\n}\n```\n\n----------------------------------------\n\nTITLE: Defining ap function for ReaderIO in TypeScript\nDESCRIPTION: Applies a ReaderIO of functions to a ReaderIO of values.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReaderIO.ts.md#2025-04-23_snippet_23\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const ap: <R, A>(fa: ReaderIO<R, A>) => <B>(fab: ReaderIO<R, (a: A) => B>) => ReaderIO<R, B>\n```\n\n----------------------------------------\n\nTITLE: Implementing tap Combinator for TaskEither in TypeScript\nDESCRIPTION: Defines the tap combinator, which composes computations in sequence, using the return value of one computation to determine the next computation and keeping only the result of the first.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/TaskEither.ts.md#2025-04-23_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare const tap: {\n  <E1, A, E2, _>(self: TaskEither<E1, A>, f: (a: A) => TaskEither<E2, _>): TaskEither<E1 | E2, A>\n  <A, E2, _>(f: (a: A) => TaskEither<E2, _>): <E1>(self: TaskEither<E1, A>) => TaskEither<E2 | E1, A>\n}\n```\n\n----------------------------------------\n\nTITLE: Defining PipeableChain Interface in TypeScript\nDESCRIPTION: This interface extends PipeableApply and defines chain, chainFirst, and flatten operations for a generic higher-kinded type F.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/pipeable.ts.md#2025-04-23_snippet_37\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface PipeableChain<F> extends PipeableApply<F> {\n  readonly chain: <A, B>(f: (a: A) => HKT<F, B>) => (ma: HKT<F, A>) => HKT<F, B>\n  readonly chainFirst: <A, B>(f: (a: A) => HKT<F, B>) => (ma: HKT<F, A>) => HKT<F, A>\n  readonly flatten: <A>(mma: HKT<F, HKT<F, A>>) => HKT<F, A>\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing chainTaskK Utility Function in TypeScript\nDESCRIPTION: Defines the chainTaskK function for chaining Task computations with various monad types. It handles different URIS and arity, similar to chainFirstTaskK.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/FromTask.ts.md#2025-04-23_snippet_2\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare function chainTaskK<M extends URIS4>(\n  F: FromTask4<M>,\n  M: Chain4<M>\n): <A, B>(f: (a: A) => Task<B>) => <S, R, E>(first: Kind4<M, S, R, E, A>) => Kind4<M, S, R, E, B>\nexport declare function chainTaskK<M extends URIS3>(\n  F: FromTask3<M>,\n  M: Chain3<M>\n): <A, B>(f: (a: A) => Task<B>) => <R, E>(first: Kind3<M, R, E, A>) => Kind3<M, R, E, B>\nexport declare function chainTaskK<M extends URIS3, E>(\n  F: FromTask3C<M, E>,\n  M: Chain3C<M, E>\n): <A, B>(f: (a: A) => Task<B>) => <R>(first: Kind3<M, R, E, A>) => Kind3<M, R, E, B>\nexport declare function chainTaskK<M extends URIS2>(\n  F: FromTask2<M>,\n  M: Chain2<M>\n): <A, B>(f: (a: A) => Task<B>) => <E>(first: Kind2<M, E, A>) => Kind2<M, E, B>\nexport declare function chainTaskK<M extends URIS2, E>(\n  F: FromTask2C<M, E>,\n  M: Chain2C<M, E>\n): <A, B>(f: (a: A) => Task<B>) => (first: Kind2<M, E, A>) => Kind2<M, E, B>\nexport declare function chainTaskK<M extends URIS>(\n  F: FromTask1<M>,\n  M: Chain1<M>\n): <A, B>(f: (a: A) => Task<B>) => (first: Kind<M, A>) => Kind<M, B>\nexport declare function chainTaskK<M>(\n  F: FromTask<M>,\n  M: Chain<M>\n): <A, B>(f: (a: A) => Task<B>) => (first: HKT<M, A>) => HKT<M, B>\n```\n\n----------------------------------------\n\nTITLE: Greater Than Function for Ord in TypeScript\nDESCRIPTION: Creates a function to test whether one value is strictly greater than another using an Ord instance.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Ord.ts.md#2025-04-23_snippet_16\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const gt: <A>(O: Ord<A>) => (first: A, second: A) => boolean\n```\n\n----------------------------------------\n\nTITLE: Implementing fromEither Function for ReaderEither in TypeScript\nDESCRIPTION: Implements the fromEither function, which converts an Either to a ReaderEither.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReaderEither.ts.md#2025-04-23_snippet_3\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare const fromEither: <E, A, R = unknown>(fa: E.Either<E, A>) => ReaderEither<R, E, A>\n```\n\n----------------------------------------\n\nTITLE: Defining FromTask Interface in TypeScript\nDESCRIPTION: Defines the FromTask interface which extends FromIO and includes a fromTask method for lifting Task computations.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/FromTask.ts.md#2025-04-23_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport interface FromTask<F> extends FromIO<F> {\n  readonly fromTask: <A>(fa: Task<A>) => HKT<F, A>\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing reduceRight Composition in TypeScript\nDESCRIPTION: Utility function that composes two Foldable instances to enable right-to-left reduction over nested data structures.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Foldable.ts.md#2025-04-23_snippet_13\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare function reduceRight<F extends URIS, G extends URIS>(\n  F: Foldable1<F>,\n  G: Foldable1<G>\n): <B, A>(b: B, f: (a: A, b: B) => B) => (fga: Kind<F, Kind<G, A>>) => B\nexport declare function reduceRight<F, G>(\n  F: Foldable<F>,\n  G: Foldable<G>\n): <B, A>(b: B, f: (a: A, b: B) => B) => (fga: HKT<F, HKT<G, A>>) => B\n```\n\n----------------------------------------\n\nTITLE: Implementing traverseReadonlyNonEmptyArrayWithIndex for StateReaderTaskEither in TypeScript\nDESCRIPTION: Provides traverseReadonlyNonEmptyArrayWithIndex function that maps each element of a readonly non-empty array along with its index to a StateReaderTaskEither and collects the results.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/StateReaderTaskEither.ts.md#2025-04-23_snippet_58\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare const traverseReadonlyNonEmptyArrayWithIndex: <A, S, R, E, B>(\n  f: (index: number, a: A) => StateReaderTaskEither<S, R, E, B>\n) => (as: ReadonlyNonEmptyArray<A>) => StateReaderTaskEither<S, R, E, ReadonlyNonEmptyArray<B>>\n```\n\n----------------------------------------\n\nTITLE: Implementing flatMapEither for Either Chaining\nDESCRIPTION: Chains a function that returns an Either with a ReaderTaskEither, allowing pure Either operations to be composed with effectful ReaderTaskEither operations.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReaderTaskEither.ts.md#2025-04-23_snippet_85\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const flatMapEither: {\n  <A, E2, B>(f: (a: A) => E.Either<E2, B>): <R, E1>(self: ReaderTaskEither<R, E1, A>) => ReaderTaskEither<R, E2 | E1, B>\n  <R, E1, A, E2, B>(self: ReaderTaskEither<R, E1, A>, f: (a: A) => E.Either<E2, B>): ReaderTaskEither<R, E1 | E2, B>\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing guard function for Zero and Pointed types in TypeScript\nDESCRIPTION: This function implements a guard operation for various Zero and Pointed functor types. It takes a boolean condition and returns a computation in the functor context. The implementation covers different arities and constrained versions.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Zero.ts.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare function guard<F extends URIS4>(\n  F: Zero4<F>,\n  P: Pointed4<F>\n): <S, R, E>(b: boolean) => Kind4<F, S, R, E, void>\nexport declare function guard<F extends URIS3>(F: Zero3<F>, P: Pointed3<F>): <R, E>(b: boolean) => Kind3<F, R, E, void>\nexport declare function guard<F extends URIS3, E>(\n  F: Zero3C<F, E>,\n  P: Pointed3C<F, E>\n): <R>(b: boolean) => Kind3<F, R, E, void>\nexport declare function guard<F extends URIS2>(F: Zero2<F>, P: Pointed2<F>): <E>(b: boolean) => Kind2<F, E, void>\nexport declare function guard<F extends URIS2, E>(\n  F: Zero2C<F, E>,\n  P: Pointed2C<F, E>\n): (b: boolean) => Kind2<F, E, void>\nexport declare function guard<F extends URIS>(F: Zero1<F>, P: Pointed1<F>): (b: boolean) => Kind<F, void>\nexport declare function guard<F>(F: Zero<F>, P: Pointed<F>): (b: boolean) => HKT<F, void>\n```\n\n----------------------------------------\n\nTITLE: Implementing execute function in StateReaderTaskEither (TypeScript)\nDESCRIPTION: The execute function runs a computation in the StateReaderTaskEither monad with an initial state, but discards the result and returns only the final state as a ReaderTaskEither.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/StateReaderTaskEither.ts.md#2025-04-23_snippet_71\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const execute: <S>(\n  s: S\n) => <R, E, A>(ma: StateReaderTaskEither<S, R, E, A>) => RTE.ReaderTaskEither<R, E, S>\n```\n\n----------------------------------------\n\nTITLE: Updating Last Element of NonEmptyArray in TypeScript\nDESCRIPTION: Changes the last element of a NonEmptyArray, creating a new NonEmptyArray with the updated last element.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/NonEmptyArray.ts.md#2025-04-23_snippet_27\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const updateLast: <A>(a: A) => (as: NonEmptyArray<A>) => NonEmptyArray<A>\n```\n\n----------------------------------------\n\nTITLE: Implementing Eq Type Class for Numbers\nDESCRIPTION: Type class instance for equality comparison of numbers.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/number.ts.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const Eq: E.Eq<number>\n```\n\n----------------------------------------\n\nTITLE: Implementing map Function for Store in TypeScript\nDESCRIPTION: Defines the map function for Store, allowing transformation of the stored value.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Store.ts.md#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const map: <A, B>(f: (a: A) => B) => <E>(fa: Store<E, A>) => Store<E, B>\n```\n\n----------------------------------------\n\nTITLE: Example Usage of range Constructor\nDESCRIPTION: Example demonstrating how to create a ReadonlyNonEmptyArray containing a range of integers between given start and end values.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReadonlyNonEmptyArray.ts.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { range } from 'fp-ts/ReadonlyNonEmptyArray'\n\nassert.deepStrictEqual(range(1, 5), [1, 2, 3, 4, 5])\n```\n\n----------------------------------------\n\nTITLE: Implementing asUnit Function for Void Mapping in TypeScript\nDESCRIPTION: Maps the Right value of a TaskEither to void, preserving the error type if present. Useful for discarding the result of successful operations.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/TaskEither.ts.md#2025-04-23_snippet_57\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const asUnit: <E, _>(self: TaskEither<E, _>) => TaskEither<E, void>\n```\n\n----------------------------------------\n\nTITLE: Implementing chainFirstReaderIOK in TypeScript for ReaderTaskEither\nDESCRIPTION: Alias of tapReaderIO that executes a ReaderIO-returning side effect without changing the original value. It takes a function from A to ReaderIO<R, B> and returns a function that preserves the original value.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReaderTaskEither.ts.md#2025-04-23_snippet_28\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const chainFirstReaderIOK: <A, R, B>(\n  f: (a: A) => RIO.ReaderIO<R, B>\n) => <E>(ma: ReaderTaskEither<R, E, A>) => ReaderTaskEither<R, E, A>\n```\n\n----------------------------------------\n\nTITLE: Traversing Readonly Non-Empty Reader Array with Index in TypeScript\nDESCRIPTION: Implements traverseReadonlyNonEmptyArrayWithIndex for Reader, equivalent to ReadonlyNonEmptyArray#traverseWithIndex(Applicative). It's for traversing non-empty readonly arrays with Reader.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Reader.ts.md#2025-04-23_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const traverseReadonlyNonEmptyArrayWithIndex: <A, R, B>(\n  f: (index: number, a: A) => Reader<R, B>\n) => (as: ReadonlyNonEmptyArray<A>) => Reader<R, ReadonlyNonEmptyArray<B>>\n```\n\n----------------------------------------\n\nTITLE: ReaderTask Type Definitions\nDESCRIPTION: Type definitions for ReaderTask including URI constant and type alias\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReaderTask.ts.md#2025-04-23_snippet_14\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const URI: 'ReaderTask'\n\nexport type URI = typeof URI\n```\n\n----------------------------------------\n\nTITLE: Defining Bifunctor Instance for Separated in TypeScript\nDESCRIPTION: Declares the Bifunctor instance for the Separated type, which provides methods for mapping over both type arguments of the bifunctor.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Separated.ts.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const Bifunctor: Bifunctor2<'Separated'>\n```\n\n----------------------------------------\n\nTITLE: Implementing MatchEW Function for IOOption in TypeScript\nDESCRIPTION: Defines the matchEW function for IOOption. It's a less strict version of matchE that allows widening of handler return types.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/IOOption.ts.md#2025-04-23_snippet_37\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const matchEW: <B, C, A>(\n  onNone: () => I.IO<B>,\n  onSome: (a: A) => I.IO<C>\n) => (ma: IOOption<A>) => I.IO<B | C>\n```\n\n----------------------------------------\n\nTITLE: Defining FromState Interface Hierarchy in TypeScript\nDESCRIPTION: Type interfaces defining the FromState typeclass hierarchy for different levels of type parameters.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/FromState.ts.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface FromState<F> {\n  readonly URI: F\n  readonly fromState: <S, A>(fa: State<S, A>) => HKT2<F, S, A>\n}\n\nexport interface FromState2<F extends URIS2> {\n  readonly URI: F\n  readonly fromState: <S, A>(fa: State<S, A>) => Kind2<F, S, A>\n}\n\nexport interface FromState3<F extends URIS3> {\n  readonly URI: F\n  readonly fromState: <S, A, E>(fa: State<S, A>) => Kind3<F, S, E, A>\n}\n\nexport interface FromState3C<F extends URIS3, E> {\n  readonly URI: F\n  readonly _E: E\n  readonly fromState: <S, A>(fa: State<S, A>) => Kind3<F, S, E, A>\n}\n\nexport interface FromState4<F extends URIS4> {\n  readonly URI: F\n  readonly fromState: <S, A, R, E>(fa: State<S, A>) => Kind4<F, S, R, E, A>\n}\n```\n\n----------------------------------------\n\nTITLE: Base Profunctor Interface Implementation\nDESCRIPTION: Defines the base Profunctor interface with two type parameters. Includes URI type, map function for functorial mapping, and promap for profunctorial mapping.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Profunctor.ts.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface Profunctor<F> {\n  readonly URI: F\n  readonly map: <E, A, B>(fa: HKT2<F, E, A>, f: (a: A) => B) => HKT<F, B>\n  readonly promap: <E, A, D, B>(fea: HKT2<F, E, A>, f: (d: D) => E, g: (a: A) => B) => HKT2<F, D, B>\n}\n```\n\n----------------------------------------\n\nTITLE: Defining FunctorComposition21 Interface in TypeScript\nDESCRIPTION: Interface for composing a binary higher-kinded type with a unary higher-kinded type, providing a map operation that transforms values inside the nested structure.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Functor.ts.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface FunctorComposition21<F extends URIS2, G extends URIS> {\n  readonly map: <E, A, B>(fa: Kind2<F, E, Kind<G, A>>, f: (a: A) => B) => Kind2<F, E, Kind<G, B>>\n}\n```\n\n----------------------------------------\n\nTITLE: Defining PipeableContravariant Interfaces in TypeScript\nDESCRIPTION: These interfaces define contramap operations for various higher-kinded types (URIS, URIS2, URIS3, URIS4) and a generic version.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/pipeable.ts.md#2025-04-23_snippet_39\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface PipeableContravariant1<F extends URIS> {\n  readonly contramap: <A, B>(f: (b: B) => A) => (fa: Kind<F, A>) => Kind<F, B>\n}\n\nexport interface PipeableContravariant2C<F extends URIS2, E> {\n  readonly contramap: <A, B>(f: (b: B) => A) => (fa: Kind2<F, E, A>) => Kind2<F, E, B>\n}\n\nexport interface PipeableContravariant2<F extends URIS2> {\n  readonly contramap: <A, B>(f: (b: B) => A) => <E>(fa: Kind2<F, E, A>) => Kind2<F, E, B>\n}\n\nexport interface PipeableContravariant3<F extends URIS3> {\n  readonly contramap: <A, B>(f: (b: B) => A) => <R, E>(fa: Kind3<F, R, E, A>) => Kind3<F, R, E, B>\n}\n\nexport interface PipeableContravariant4<F extends URIS4> {\n  readonly contramap: <A, B>(f: (b: B) => A) => <S, R, E>(fa: Kind4<F, S, R, E, A>) => Kind4<F, S, R, E, B>\n}\n\nexport interface PipeableContravariant<F> {\n  readonly contramap: <A, B>(f: (b: B) => A) => (fa: HKT<F, A>) => HKT<F, B>\n}\n```\n\n----------------------------------------\n\nTITLE: Defining flatMapReaderEither Operation for ReaderTaskEither in TypeScript\nDESCRIPTION: Function signature for flatMapReaderEither that composes a ReaderTaskEither with a ReaderEither function, combining both reader environments and error types. Added in v2.16.0.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReaderTaskEither.ts.md#2025-04-23_snippet_91\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const flatMapReaderEither: {\n  <A, R2, E2, B>(f: (a: A) => ReaderEither<R2, E2, B>): <R1, E1>(\n    self: ReaderTaskEither<R1, E1, A>\n  ) => ReaderTaskEither<R1 & R2, E2 | E1, B>\n  <R1, E1, A, R2, E2, B>(self: ReaderTaskEither<R1, E1, A>, f: (a: A) => ReaderEither<R2, E2, B>): ReaderTaskEither<\n    R1 & R2,\n    E1 | E2,\n    B\n  >\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing chainFirstTaskK Utility Function in TypeScript\nDESCRIPTION: Defines the chainFirstTaskK function for chaining Task computations with various monad types. It handles different URIS (Universally Represented Interface Symbols) and arity.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/FromTask.ts.md#2025-04-23_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare function chainFirstTaskK<M extends URIS4>(\n  F: FromTask4<M>,\n  M: Chain4<M>\n): <A, B>(f: (a: A) => Task<B>) => <S, R, E>(first: Kind4<M, S, R, E, A>) => Kind4<M, S, R, E, A>\nexport declare function chainFirstTaskK<M extends URIS3>(\n  F: FromTask3<M>,\n  M: Chain3<M>\n): <A, B>(f: (a: A) => Task<B>) => <R, E>(first: Kind3<M, R, E, A>) => Kind3<M, R, E, A>\nexport declare function chainFirstTaskK<M extends URIS3, E>(\n  F: FromTask3C<M, E>,\n  M: Chain3C<M, E>\n): <A, B>(f: (a: A) => Task<B>) => <R>(first: Kind3<M, R, E, A>) => Kind3<M, R, E, A>\nexport declare function chainFirstTaskK<M extends URIS2>(\n  F: FromTask2<M>,\n  M: Chain2<M>\n): <A, B>(f: (a: A) => Task<B>) => <E>(first: Kind2<M, E, A>) => Kind2<M, E, A>\nexport declare function chainFirstTaskK<M extends URIS2, E>(\n  F: FromTask2C<M, E>,\n  M: Chain2C<M, E>\n): <A, B>(f: (a: A) => Task<B>) => (first: Kind2<M, E, A>) => Kind2<M, E, A>\nexport declare function chainFirstTaskK<M extends URIS>(\n  F: FromTask1<M>,\n  M: Chain1<M>\n): <A, B>(f: (a: A) => Task<B>) => (first: Kind<M, A>) => Kind<M, A>\nexport declare function chainFirstTaskK<M>(\n  F: FromTask<M>,\n  M: Chain<M>\n): <A, B>(f: (a: A) => Task<B>) => (first: HKT<M, A>) => HKT<M, A>\n```\n\n----------------------------------------\n\nTITLE: Defining MonadTask1 Interface in TypeScript\nDESCRIPTION: Defines the MonadTask1 interface extending MonadIO1 and FromTask1 for URIS type M.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/MonadTask.ts.md#2025-04-23_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport interface MonadTask1<M extends URIS> extends MonadIO1<M>, FromTask1<M> {}\n```\n\n----------------------------------------\n\nTITLE: Implementing Boolean Monoid for Conjunction\nDESCRIPTION: Implements a boolean monoid under conjunction where the empty value is true. Used for combining boolean values with AND operations.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/boolean.ts.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const MonoidAll: Monoid<boolean>\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport { MonoidAll } from 'fp-ts/boolean'\n\nassert.deepStrictEqual(MonoidAll.concat(true, true), true)\nassert.deepStrictEqual(MonoidAll.concat(true, false), false)\n```\n\n----------------------------------------\n\nTITLE: Implementing MagmaSub Type Class for Numbers\nDESCRIPTION: Type class instance for subtraction magma operations on numbers.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/number.ts.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const MagmaSub: Magma<number>\n```\n\n----------------------------------------\n\nTITLE: ReaderTask Array Traversal Functions\nDESCRIPTION: Functions for traversing arrays with ReaderTask operations, including sequence and traverse implementations.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReaderTask.ts.md#2025-04-23_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const sequenceArray: <R, A>(arr: readonly ReaderTask<R, A>[]) => ReaderTask<R, readonly A[]>\n```\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const traverseArray: <R, A, B>(\n  f: (a: A) => ReaderTask<R, B>\n) => (as: readonly A[]) => ReaderTask<R, readonly B[]>\n```\n\n----------------------------------------\n\nTITLE: Defining traverseSeqArray Operation for ReaderTaskEither in TypeScript\nDESCRIPTION: Function signature for traverseSeqArray that maps an array of values to a ReaderTaskEither and then sequences the results sequentially. Equivalent to ReadonlyArray#traverse(ApplicativeSeq). Added in v2.9.0.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReaderTaskEither.ts.md#2025-04-23_snippet_106\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const traverseSeqArray: <R, E, A, B>(\n  f: (a: A) => ReaderTaskEither<R, E, B>\n) => (as: readonly A[]) => ReaderTaskEither<R, E, readonly B[]>\n```\n\n----------------------------------------\n\nTITLE: Defining Comonad3C Interface for URIS3 with Fixed Type in TypeScript\nDESCRIPTION: Defines the Comonad3C interface extending Extend3C for higher-kinded types of arity 3 with a fixed type parameter E.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Comonad.ts.md#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface Comonad3C<W extends URIS3, E> extends Extend3C<W, E> {\n  readonly extract: <R, A>(wa: Kind3<W, R, E, A>) => A\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Both Interface for These in TypeScript\nDESCRIPTION: Defines the interface for the Both case of the These type, representing a value that has both left and right components.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/These.ts.md#2025-04-23_snippet_10\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport interface Both<E, A> {\n  readonly _tag: 'Both'\n  readonly left: E\n  readonly right: A\n}\n```\n\n----------------------------------------\n\nTITLE: Defining ReadonlyNonEmptyArray Type in TypeScript\nDESCRIPTION: Defines the ReadonlyNonEmptyArray type as a ReadonlyArray with at least one element.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReadonlyNonEmptyArray.ts.md#2025-04-23_snippet_21\n\nLANGUAGE: typescript\nCODE:\n```\nexport type ReadonlyNonEmptyArray<A> = ReadonlyArray<A> & {\n  readonly 0: A\n}\n```\n\n----------------------------------------\n\nTITLE: Defining PipeableFilterable Interfaces in TypeScript\nDESCRIPTION: These interfaces extend PipeableCompactable and define filter, filterMap, partition, and partitionMap operations for various higher-kinded types (URIS, URIS2).\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/pipeable.ts.md#2025-04-23_snippet_41\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface PipeableFilterable1<F extends URIS> extends PipeableCompactable1<F> {\n  readonly filter: {\n    <A, B extends A>(refinement: Refinement<A, B>): (fa: Kind<F, A>) => Kind<F, B>\n    <A>(predicate: Predicate<A>): (fa: Kind<F, A>) => Kind<F, A>\n  }\n  readonly filterMap: <A, B>(f: (a: A) => Option<B>) => (fa: Kind<F, A>) => Kind<F, B>\n  readonly partition: {\n    <A, B extends A>(refinement: Refinement<A, B>): (fa: Kind<F, A>) => Separated<Kind<F, A>, Kind<F, B>>\n    <A>(predicate: Predicate<A>): (fa: Kind<F, A>) => Separated<Kind<F, A>, Kind<F, A>>\n  }\n  readonly partitionMap: <A, B, C>(f: (a: A) => Either<B, C>) => (fa: Kind<F, A>) => Separated<Kind<F, B>, Kind<F, C>>\n}\n\nexport interface PipeableFilterable2C<F extends URIS2, E> extends PipeableCompactable2C<F, E> {\n  readonly filter: {\n    <A, B extends A>(refinement: Refinement<A, B>): (fa: Kind2<F, E, A>) => Kind2<F, E, B>\n    <A>(predicate: Predicate<A>): (fa: Kind2<F, E, A>) => Kind2<F, E, A>\n  }\n  readonly filterMap: <A, B>(f: (a: A) => Option<B>) => (fa: Kind2<F, E, A>) => Kind2<F, E, B>\n  readonly partition: {\n    <A, B extends A>(refinement: Refinement<A, B>): (fa: Kind2<F, E, A>) => Separated<Kind2<F, E, A>, Kind2<F, E, B>>\n    <A>(predicate: Predicate<A>): (fa: Kind2<F, E, A>) => Separated<Kind2<F, E, A>, Kind2<F, E, A>>\n  }\n  readonly partitionMap: <A, B, C>(\n    f: (a: A) => Either<B, C>\n  ) => (fa: Kind2<F, E, A>) => Separated<Kind2<F, E, B>, Kind2<F, E, C>>\n}\n```\n\n----------------------------------------\n\nTITLE: Mapping Records with Flap in TypeScript\nDESCRIPTION: Takes a value and a Record of functions and returns a Record by applying each function to the input value. This operation is also known as sequence application.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Record.ts.md#2025-04-23_snippet_18\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const flap: <A>(a: A) => <B>(fab: Record<string, (a: A) => B>) => Record<string, B>\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport { flap } from 'fp-ts/Record'\n\nconst fab = { x: (n: number) => `${n} times 2`, y: (n: number) => `${n * 2}` }\nassert.deepStrictEqual(flap(3)(fab), {\n  x: '3 times 2',\n  y: '6',\n})\n```\n\n----------------------------------------\n\nTITLE: Implementing Chain3 Interface for URIS3\nDESCRIPTION: Chain interface for type constructors with three type parameters, extending Apply3.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Chain.ts.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface Chain3<F extends URIS3> extends Apply3<F> {\n  readonly chain: <R, E, A, B>(fa: Kind3<F, R, E, A>, f: (a: A) => Kind3<F, R, E, B>) => Kind3<F, R, E, B>\n}\n```\n\n----------------------------------------\n\nTITLE: Reducing ReadonlyTuple in TypeScript\nDESCRIPTION: Defines 'reduce' and 'reduceRight' functions for folding a readonly tuple from left to right or right to left respectively.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReadonlyTuple.ts.md#2025-04-23_snippet_3\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare const reduce: <A, B>(b: B, f: (b: B, a: A) => B) => <E>(fa: readonly [A, E]) => B\n```\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare const reduceRight: <A, B>(b: B, f: (a: A, b: B) => B) => <E>(fa: readonly [A, E]) => B\n```\n\n----------------------------------------\n\nTITLE: Implementing traverseReadonlyArrayWithIndex for StateReaderTaskEither in TypeScript\nDESCRIPTION: Provides traverseReadonlyArrayWithIndex function that maps each element of a readonly array along with its index to a StateReaderTaskEither and collects the results.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/StateReaderTaskEither.ts.md#2025-04-23_snippet_57\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare const traverseReadonlyArrayWithIndex: <A, S, R, E, B>(\n  f: (index: number, a: A) => StateReaderTaskEither<S, R, E, B>\n) => (as: readonly A[]) => StateReaderTaskEither<S, R, E, readonly B[]>\n```\n\n----------------------------------------\n\nTITLE: Defining TaskThese Interface in TypeScript\nDESCRIPTION: Defines the TaskThese interface as a Task of These, combining asynchronous computation with the possibility of both error and success values.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/TaskThese.ts.md#2025-04-23_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport interface TaskThese<E, A> extends Task<These<E, A>> {}\n```\n\n----------------------------------------\n\nTITLE: Implementing orElseFirst for EitherT in TypeScript\nDESCRIPTION: Defines the orElseFirst function for EitherT, which applies a fallback function to the error case without changing the result type. It handles different URIS for monads.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/EitherT.ts.md#2025-04-23_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare function orElseFirst<M extends URIS3>(\n  M: Monad3<M>\n): <E, R, ME, B>(\n  onLeft: (e: E) => Kind3<M, R, ME, Either<E, B>>\n) => <A>(ma: Kind3<M, R, ME, Either<E, A>>) => Kind3<M, R, ME, Either<E, A>>\nexport declare function orElseFirst<M extends URIS3, ME>(\n  M: Monad3C<M, ME>\n): <E, R, B>(\n  onLeft: (e: E) => Kind3<M, R, ME, Either<E, B>>\n) => <A>(ma: Kind3<M, R, ME, Either<E, A>>) => Kind3<M, R, ME, Either<E, A>>\nexport declare function orElseFirst<M extends URIS2>(\n  M: Monad2<M>\n): <E, ME, B>(\n  onLeft: (e: E) => Kind2<M, ME, Either<E, B>>\n) => <A>(ma: Kind2<M, ME, Either<E, A>>) => Kind2<M, ME, Either<E, A>>\nexport declare function orElseFirst<M extends URIS2, ME>(\n  M: Monad2C<M, ME>\n): <E, B>(\n  onLeft: (e: E) => Kind2<M, ME, Either<E, B>>\n) => <A>(ma: Kind2<M, ME, Either<E, A>>) => Kind2<M, ME, Either<E, A>>\nexport declare function orElseFirst<M extends URIS>(\n  M: Monad1<M>\n): <E, B>(onLeft: (e: E) => Kind<M, Either<E, B>>) => <A>(ma: Kind<M, Either<E, A>>) => Kind<M, Either<E, A>>\nexport declare function orElseFirst<M>(\n  M: Monad<M>\n): <E, B>(onLeft: (e: E) => HKT<M, Either<E, B>>) => <A>(ma: HKT<M, Either<E, A>>) => HKT<M, Either<E, A>>\n```\n\n----------------------------------------\n\nTITLE: Defining PipeableFunctor Interface in TypeScript\nDESCRIPTION: Base interface for pipeable functor type classes with generic higher-kinded types. Provides the core map method for transforming values within a functor.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/pipeable.ts.md#2025-04-23_snippet_75\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface PipeableFunctor<F> {\n  readonly map: <A, B>(f: (a: A) => B) => (fa: HKT<F, A>) => HKT<F, B>\n}\n```\n\n----------------------------------------\n\nTITLE: Defining FromIO1 Interface in TypeScript\nDESCRIPTION: Interface for lifting computations from the IO monad to a higher-kinded type F with one type parameter. Used for type-level programming with URIS (URI string literal types).\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/FromIO.ts.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface FromIO1<F extends URIS> {\n  readonly URI: F\n  readonly fromIO: <A>(fa: IO<A>) => Kind<F, A>\n}\n```\n\n----------------------------------------\n\nTITLE: Defining flatten function for ReaderIO in TypeScript\nDESCRIPTION: Flattens a nested ReaderIO structure. It takes a ReaderIO of ReaderIO and returns a single ReaderIO.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReaderIO.ts.md#2025-04-23_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const flatten: <R, A>(mma: ReaderIO<R, ReaderIO<R, A>>) => ReaderIO<R, A>\n```\n\n----------------------------------------\n\nTITLE: Implementing flatMapReader for StateReaderTaskEither in TypeScript\nDESCRIPTION: Provides flatMapReader function that allows mapping from a StateReaderTaskEither to a Reader monad and flattening the result, with both pipeable and non-pipeable usage patterns.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/StateReaderTaskEither.ts.md#2025-04-23_snippet_47\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare const flatMapReader: {\n  <A, R2, B>(f: (a: A) => R.Reader<R2, B>): <S, R1, E>(\n    self: StateReaderTaskEither<S, R1, E, A>\n  ) => StateReaderTaskEither<S, R1 & R2, E, B>\n  <S, R1, E, A, R2, B>(self: StateReaderTaskEither<S, R1, E, A>, f: (a: A) => R.Reader<R2, B>): StateReaderTaskEither<\n    S,\n    R1 & R2,\n    E,\n    B\n  >\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Pipeable Contramap Operator in TypeScript\nDESCRIPTION: Implements a pipeable version of contramap for contravariant functors.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/pipeable.ts.md#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare function contramap<F extends URIS4>(\n  F: Contravariant4<F>\n): <A, B>(f: (b: B) => A) => <S, R, E>(fa: Kind4<F, S, R, E, A>) => Kind4<F, S, R, E, B>\n```\n\n----------------------------------------\n\nTITLE: Implementing Sequence Operation for Either\nDESCRIPTION: Evaluates monadic actions from left to right and collects results\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Either.ts.md#2025-04-23_snippet_30\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const sequence: Sequence2<'Either'>\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport { pipe } from 'fp-ts/function'\nimport * as E from 'fp-ts/Either'\nimport * as O from 'fp-ts/Option'\n\nassert.deepStrictEqual(pipe(E.right(O.some('a')), E.sequence(O.Applicative)), O.some(E.right('a')))\n\nassert.deepStrictEqual(pipe(E.right(O.none), E.sequence(O.Applicative)), O.none)\n```\n\n----------------------------------------\n\nTITLE: Implementing Predicate Check for All Elements in ReadonlyArray in TypeScript\nDESCRIPTION: Defines a function to check if all elements in a ReadonlyArray satisfy a given predicate.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReadonlyArray.ts.md#2025-04-23_snippet_24\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare function every<A, B extends A>(\n  refinement: Refinement<A, B>\n): Refinement<ReadonlyArray<A>, ReadonlyArray<B>>\nexport declare function every<A>(predicate: Predicate<A>): Predicate<ReadonlyArray<A>>\n```\n\n----------------------------------------\n\nTITLE: Implementing intercalate Function in TypeScript\nDESCRIPTION: Utility function for folding a data structure with a monoid, combining adjacent elements using a separator value, like joining strings with a delimiter.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Foldable.ts.md#2025-04-23_snippet_8\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare function intercalate<M, F extends URIS3>(\n  M: Monoid<M>,\n  F: Foldable3<F>\n): <R, E>(middle: M, fm: Kind3<F, R, E, M>) => M\nexport declare function intercalate<M, F extends URIS2>(\n  M: Monoid<M>,\n  F: Foldable2<F>\n): <E>(middle: M, fm: Kind2<F, E, M>) => M\nexport declare function intercalate<M, F extends URIS2, E>(\n  M: Monoid<M>,\n  F: Foldable2C<F, E>\n): (middle: M, fm: Kind2<F, E, M>) => M\nexport declare function intercalate<M, F extends URIS>(M: Monoid<M>, F: Foldable1<F>): (middle: M, fm: Kind<F, M>) => M\nexport declare function intercalate<M, F>(M: Monoid<M>, F: Foldable<F>): (middle: M, fm: HKT<F, M>) => M\n```\n\n----------------------------------------\n\nTITLE: Composition and Transformation Functions for Reader in TypeScript\nDESCRIPTION: Defines functions for composing and transforming Reader instances, including compose, first, left, local, promap, right, and second.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Reader.ts.md#2025-04-23_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const compose: <A, B>(ab: Reader<A, B>) => <C>(bc: Reader<B, C>) => Reader<A, C>\n\nexport declare const first: <A, B, C>(pab: Reader<A, B>) => Reader<[A, C], [B, C]>\n\nexport declare const left: <A, B, C>(pab: Reader<A, B>) => Reader<E.Either<A, C>, E.Either<B, C>>\n\nexport declare const local: <R2, R1>(f: (r2: R2) => R1) => <A>(ma: Reader<R1, A>) => Reader<R2, A>\n\nexport declare const promap: <E, A, D, B>(f: (d: D) => E, g: (a: A) => B) => (fea: Reader<E, A>) => Reader<D, B>\n\nexport declare const right: <A, B, C>(pbc: Reader<B, C>) => Reader<E.Either<A, B>, E.Either<A, C>>\n\nexport declare const second: <A, B, C>(pab: Reader<B, C>) => Reader<[A, B], [A, C]>\n```\n\n----------------------------------------\n\nTITLE: Implementing as for Constant Value Mapping\nDESCRIPTION: Maps the success value of a ReaderTaskEither to a constant value, discarding the original success value while preserving the error channel.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReaderTaskEither.ts.md#2025-04-23_snippet_74\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const as: {\n  <A>(a: A): <R, E, _>(self: ReaderTaskEither<R, E, _>) => ReaderTaskEither<R, E, A>\n  <R, E, _, A>(self: ReaderTaskEither<R, E, _>, a: A): ReaderTaskEither<R, E, A>\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing As Function for IOOption in TypeScript\nDESCRIPTION: Defines the as function for IOOption. It maps the Some value of an IOOption to a specified constant value.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/IOOption.ts.md#2025-04-23_snippet_29\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const as: {\n  <A>(a: A): <_>(self: IOOption<_>) => IOOption<A>\n  <_, A>(self: IOOption<_>, a: A): IOOption<A>\n}\n```\n\n----------------------------------------\n\nTITLE: Defining CompactableComposition23 Interface in TypeScript\nDESCRIPTION: This interface extends FunctorComposition23 and defines compact and separate methods for composing two higher-kinded types F and G, where F is of kind 2 and G is of kind 3.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Compactable.ts.md#2025-04-23_snippet_3\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport interface CompactableComposition23<F extends URIS2, G extends URIS3> extends FunctorComposition23<F, G> {\n  readonly compact: <R, FE, GE, A>(fga: Kind2<F, FE, Kind3<G, R, GE, Option<A>>>) => Kind2<F, FE, Kind3<G, R, GE, A>>\n  readonly separate: <R, FE, GE, A, B>(\n    fge: Kind2<F, FE, Kind3<G, R, GE, Either<A, B>>>\n  ) => Separated<Kind2<F, FE, Kind3<G, R, GE, A>>, Kind2<F, FE, Kind3<G, R, GE, B>>>\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Semigroup instance for Const in TypeScript\nDESCRIPTION: Creates a Semigroup instance for Const given a Semigroup for the first type parameter. This allows combining Const values.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Const.ts.md#2025-04-23_snippet_14\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const getSemigroup: <E, A>(S: Semigroup<E>) => Semigroup<Const<E, A>>\n```\n\n----------------------------------------\n\nTITLE: Defining BoundedJoinSemilattice Interface in TypeScript\nDESCRIPTION: The BoundedJoinSemilattice interface extends JoinSemilattice with a zero element. This represents an algebraic structure with a join operation and an identity element for that operation.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/BoundedJoinSemilattice.ts.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface BoundedJoinSemilattice<A> extends JoinSemilattice<A> {\n  readonly zero: A\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing flap Function for Store in TypeScript\nDESCRIPTION: Defines the flap function for Store, which applies a Store of functions to a value.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Store.ts.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const flap: <A>(a: A) => <E, B>(fab: Store<E, (a: A) => B>) => Store<E, B>\n```\n\n----------------------------------------\n\nTITLE: Map Operations in ReadonlyArray\nDESCRIPTION: Functions for transforming array elements while preserving readonly constraints. Includes basic map and mapWithIndex operations.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReadonlyArray.ts.md#2025-04-23_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const map: <A, B>(f: (a: A) => B) => (fa: readonly A[]) => readonly B[]\n```\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const mapWithIndex: <A, B>(f: (i: number, a: A) => B) => (fa: readonly A[]) => readonly B[]\n```\n\n----------------------------------------\n\nTITLE: Defining Semigroupoid3 Interface in TypeScript\nDESCRIPTION: Defines the Semigroupoid3 interface for a higher-kinded type F extending URIS3. It includes a URI property and a compose method for combining two morphisms with three type parameters.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Semigroupoid.ts.md#2025-04-23_snippet_3\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport interface Semigroupoid3<F extends URIS3> {\n  readonly URI: F\n  readonly compose: <R, A, B, C>(ab: Kind3<F, R, B, C>, la: Kind3<F, R, A, B>) => Kind3<F, R, A, C>\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing flatMapOption for StateReaderTaskEither in TypeScript\nDESCRIPTION: Provides flatMapOption function that allows mapping from a StateReaderTaskEither to an Option with a fallback for None cases, supporting both pipeable and non-pipeable patterns.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/StateReaderTaskEither.ts.md#2025-04-23_snippet_46\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare const flatMapOption: {\n  <A, E2, B>(f: (a: A) => Option<B>, onNone: (a: A) => E2): <S, R, E1>(\n    self: StateReaderTaskEither<S, R, E1, A>\n  ) => StateReaderTaskEither<S, R, E2 | E1, B>\n  <S, R, E1, A, E2, B>(\n    self: StateReaderTaskEither<S, R, E1, A>,\n    f: (a: A) => Option<B>,\n    onNone: (a: A) => E2\n  ): StateReaderTaskEither<S, R, E1 | E2, B>\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing FunctorWithIndex Compatibility\nDESCRIPTION: Example showing how TraversableWithIndex must be compatible with FunctorWithIndex operations.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/TraversableWithIndex.ts.md#2025-04-23_snippet_2\n\nLANGUAGE: purescript\nCODE:\n```\nmapWithIndex(ta, f) = traverseWithIndex(identity)(ta, (i, a) => new Identity(f(i, a))).value\n```\n\n----------------------------------------\n\nTITLE: Example of Using intercalate with Trees in TypeScript\nDESCRIPTION: Example showing how to join elements of a tree structure with a separator string using the intercalate function.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Foldable.ts.md#2025-04-23_snippet_9\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { intercalate } from 'fp-ts/Foldable'\nimport * as S from 'fp-ts/string'\nimport { make, Foldable } from 'fp-ts/Tree'\n\nconst t = make('a', [make('b', []), make('c', []), make('d', [])])\nassert.strictEqual(intercalate(S.Monoid, Foldable)('|', t), 'a|b|c|d')\n```\n\n----------------------------------------\n\nTITLE: right Function Declaration in TypeScript\nDESCRIPTION: Utility function to lift a value into a Right instance within a monad transformer context.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/EitherT.ts.md#2025-04-23_snippet_14\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare function right<F extends URIS3>(\n  F: Pointed3<F>\n): <A, R, FE, E = never>(a: A) => Kind3<F, R, FE, Either<E, A>>\n```\n\n----------------------------------------\n\nTITLE: Defining FunctorComposition2C1 Interface in TypeScript\nDESCRIPTION: Interface for composing a binary higher-kinded type (with fixed first type parameter) with a unary higher-kinded type.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Functor.ts.md#2025-04-23_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface FunctorComposition2C1<F extends URIS2, G extends URIS, E> {\n  readonly map: <A, B>(fa: Kind2<F, E, Kind<G, A>>, f: (a: A) => B) => Kind2<F, E, Kind<G, B>>\n}\n```\n\n----------------------------------------\n\nTITLE: Defining PipeableFoldableWithIndex2 Interface in TypeScript\nDESCRIPTION: Extends PipeableFoldable2 to provide indexed folding operations for arity 2 higher-kinded types. Adds methods that receive the index along with values during folding operations.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/pipeable.ts.md#2025-04-23_snippet_59\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface PipeableFoldableWithIndex2<F extends URIS2, I> extends PipeableFoldable2<F> {\n  readonly reduceWithIndex: <A, B>(b: B, f: (i: I, b: B, a: A) => B) => <E>(fa: Kind2<F, E, A>) => B\n  readonly foldMapWithIndex: <M>(M: Monoid<M>) => <A>(f: (i: I, a: A) => M) => <E>(fa: Kind2<F, E, A>) => M\n  readonly reduceRightWithIndex: <A, B>(b: B, f: (i: I, a: A, b: B) => B) => <E>(fa: Kind2<F, E, A>) => B\n}\n```\n\n----------------------------------------\n\nTITLE: Splitting ReadonlyArray at Index in TypeScript\nDESCRIPTION: Splits a readonly array into two pieces, with the first piece having a maximum of n elements.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReadonlyArray.ts.md#2025-04-23_snippet_58\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const splitAt: (n: number) => <A>(as: readonly A[]) => readonly [readonly A[], readonly A[]]\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport { splitAt } from 'fp-ts/ReadonlyArray'\n\nassert.deepStrictEqual(splitAt(2)([1, 2, 3, 4, 5]), [\n  [1, 2],\n  [3, 4, 5],\n])\n```\n\n----------------------------------------\n\nTITLE: Defining PipeableFunctor1 Interface in TypeScript\nDESCRIPTION: A pipeable version of the Functor type class for higher-kinded types of arity 1. It provides the map method for transforming the values contained in a functor.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/pipeable.ts.md#2025-04-23_snippet_64\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface PipeableFunctor1<F extends URIS> {\n  readonly map: <A, B>(f: (a: A) => B) => (fa: Kind<F, A>) => Kind<F, B>\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing mapBoth Operation for ReaderTaskEither in TypeScript\nDESCRIPTION: Defines a mapBoth operation for ReaderTaskEither, which maps both the failure and success channels using specified functions.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReaderTaskEither.ts.md#2025-04-23_snippet_13\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare const mapBoth: {\n  <E, G, A, B>(f: (e: E) => G, g: (a: A) => B): <R>(self: ReaderTaskEither<R, E, A>) => ReaderTaskEither<R, G, B>\n  <R, E, A, G, B>(self: ReaderTaskEither<R, E, A>, f: (e: E) => G, g: (a: A) => B): ReaderTaskEither<R, G, B>\n}\n```\n\n----------------------------------------\n\nTITLE: Reversing Array Order with fp-ts\nDESCRIPTION: Reverses an array, creating a new array with elements in the opposite order. The original array remains unchanged.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReadonlyArray.ts.md#2025-04-23_snippet_48\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const reverse: <A>(as: readonly A[]) => readonly A[]\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport { reverse } from 'fp-ts/ReadonlyArray'\n\nassert.deepStrictEqual(reverse([1, 2, 3]), [3, 2, 1])\n```\n\n----------------------------------------\n\nTITLE: Defining FunctorComposition22 Interface in TypeScript\nDESCRIPTION: Interface for composing two binary higher-kinded types, allowing mapping over values nested within both structures.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Functor.ts.md#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface FunctorComposition22<F extends URIS2, G extends URIS2> {\n  readonly map: <FE, GE, A, B>(fa: Kind2<F, FE, Kind2<G, GE, A>>, f: (a: A) => B) => Kind2<F, FE, Kind2<G, GE, B>>\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing throwError function in StateReaderTaskEither (TypeScript)\nDESCRIPTION: The throwError function creates a StateReaderTaskEither that immediately fails with the provided error value.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/StateReaderTaskEither.ts.md#2025-04-23_snippet_74\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const throwError: <S, R, E, A>(e: E) => StateReaderTaskEither<S, R, E, A>\n```\n\n----------------------------------------\n\nTITLE: Defining Reader URI in TypeScript\nDESCRIPTION: Defines the URI constant and type alias for the Reader monad, used for type-level identification in fp-ts.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Reader.ts.md#2025-04-23_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const URI: 'Reader'\nexport type URI = typeof URI\n```\n\n----------------------------------------\n\nTITLE: Example Usage of replicate Constructor\nDESCRIPTION: Example showing how to create a ReadonlyNonEmptyArray by replicating a value a specified number of times.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReadonlyNonEmptyArray.ts.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { replicate } from 'fp-ts/ReadonlyNonEmptyArray'\nimport { pipe } from 'fp-ts/function'\n\nassert.deepStrictEqual(pipe(3, replicate('a')), ['a', 'a', 'a'])\n```\n\n----------------------------------------\n\nTITLE: Implementing flatten for StateReaderTaskEither in TypeScript\nDESCRIPTION: Provides a flatten function that removes one level of monadic structure from a nested StateReaderTaskEither, converting StateReaderTaskEither<S, R, E, StateReaderTaskEither<S, R, E, A>> to StateReaderTaskEither<S, R, E, A>.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/StateReaderTaskEither.ts.md#2025-04-23_snippet_52\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare const flatten: <S, R, E, A>(\n  mma: StateReaderTaskEither<S, R, E, StateReaderTaskEither<S, R, E, A>>\n) => StateReaderTaskEither<S, R, E, A>\n```\n\n----------------------------------------\n\nTITLE: Defining flattenW function for ReaderIO in TypeScript\nDESCRIPTION: A less strict version of flatten that merges environment types. It takes a ReaderIO of ReaderIO with potentially different environment types and returns a single ReaderIO.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReaderIO.ts.md#2025-04-23_snippet_14\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const flattenW: <R1, R2, A>(mma: ReaderIO<R1, ReaderIO<R2, A>>) => ReaderIO<R1 & R2, A>\n```\n\n----------------------------------------\n\nTITLE: Implementing peeks Function for Store in TypeScript\nDESCRIPTION: Defines the peeks function for Store, extracting a value from a position dependent on the current position.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Store.ts.md#2025-04-23_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare function peeks<S>(f: Endomorphism<S>): <A>(wa: Store<S, A>) => A\n```\n\n----------------------------------------\n\nTITLE: Implementing Pipeable Alt Operator in TypeScript\nDESCRIPTION: Provides a pipeable version of the alt operator that works with higher-kinded types of various arities (1-4). Supports type-safe alternatives in functional programming contexts.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/pipeable.ts.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare function alt<F extends URIS4>(\n  F: Alt4<F>\n): <S, R, E, A>(that: LazyArg<Kind4<F, S, R, E, A>>) => (fa: Kind4<F, S, R, E, A>) => Kind4<F, S, R, E, A>\n```\n\n----------------------------------------\n\nTITLE: Defining sequenceSeqArray Operation for ReaderTaskEither in TypeScript\nDESCRIPTION: Function signature for sequenceSeqArray that transforms an array of ReaderTaskEither into a ReaderTaskEither of an array using sequential evaluation. Equivalent to ReadonlyArray#sequence(ApplicativeSeq). Added in v2.9.0.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReaderTaskEither.ts.md#2025-04-23_snippet_99\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const sequenceSeqArray: <R, E, A>(\n  arr: readonly ReaderTaskEither<R, E, A>[]\n) => ReaderTaskEither<R, E, readonly A[]>\n```\n\n----------------------------------------\n\nTITLE: Implementing Element Existence Check (Alias) in ReadonlyArray in TypeScript\nDESCRIPTION: Defines an alias for the 'some' function to check if any element in a ReadonlyArray satisfies a predicate.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReadonlyArray.ts.md#2025-04-23_snippet_26\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const exists: <A>(predicate: Predicate<A>) => (as: readonly A[]) => as is RNEA.ReadonlyNonEmptyArray<A>\n```\n\n----------------------------------------\n\nTITLE: Defining zero Function in TypeScript Option Module\nDESCRIPTION: Function signature for zero that creates an empty Option instance.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Option.ts.md#2025-04-23_snippet_14\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const zero: <A>() => Option<A>\n```\n\n----------------------------------------\n\nTITLE: Defining Semigroup Instance for Ordering\nDESCRIPTION: Exports a Semigroup instance for Ordering values.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Ordering.ts.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const Semigroup: S.Semigroup<Ordering>\n```\n\n----------------------------------------\n\nTITLE: Modifying IORef Value in TypeScript\nDESCRIPTION: Method to modify the value in the IORef using a provided function. It returns an IO monad of void.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/IORef.ts.md#2025-04-23_snippet_3\n\nLANGUAGE: TypeScript\nCODE:\n```\nmodify(f: (a: A) => A): IO<void>\n```\n\n----------------------------------------\n\nTITLE: Folding These Values in TypeScript\nDESCRIPTION: Provides folding operations for These values, including foldMap, reduce, and reduceRight.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/These.ts.md#2025-04-23_snippet_3\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare const foldMap: <M>(M: Monoid<M>) => <A>(f: (a: A) => M) => <E>(fa: These<E, A>) => M\n\nexport declare const reduce: <A, B>(b: B, f: (b: B, a: A) => B) => <E>(fa: These<E, A>) => B\n\nexport declare const reduceRight: <A, B>(b: B, f: (a: A, b: B) => B) => <E>(fa: These<E, A>) => B\n```\n\n----------------------------------------\n\nTITLE: Folding ReadonlyTuple with Monoid in TypeScript\nDESCRIPTION: Defines a 'foldMap' function that folds a readonly tuple using a provided Monoid and mapping function.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReadonlyTuple.ts.md#2025-04-23_snippet_2\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare const foldMap: <M>(M: Monoid<M>) => <A>(f: (a: A) => M) => <E>(fa: readonly [A, E]) => M\n```\n\n----------------------------------------\n\nTITLE: Array Sequence Operation in TypeScript\nDESCRIPTION: Implements ReadonlyArray#sequence for ReaderEither, converting an array of ReaderEither into a ReaderEither of array.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReaderEither.ts.md#2025-04-23_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const sequenceArray: <R, E, A>(arr: readonly ReaderEither<R, E, A>[]) => ReaderEither<R, E, readonly A[]>\n```\n\n----------------------------------------\n\nTITLE: Profunctor3 Interface Implementation\nDESCRIPTION: Implementation of Profunctor for types with three type parameters. Extends Functor3.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Profunctor.ts.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface Profunctor3<F extends URIS3> extends Functor3<F> {\n  readonly promap: <R, E, A, D, B>(fea: Kind3<F, R, E, A>, f: (d: D) => E, g: (a: A) => B) => Kind3<F, R, D, B>\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing ChainRec3C Interface with Fixed Error Type in TypeScript\nDESCRIPTION: Defines the ChainRec3C interface for third-order type constructors with a fixed error type E. It extends Chain3C and provides chainRec for stack-safe recursion.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ChainRec.ts.md#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface ChainRec3C<F extends URIS3, E> extends Chain3C<F, E> {\n  readonly chainRec: <R, A, B>(a: A, f: (a: A) => Kind3<F, R, E, Either<A, B>>) => Kind3<F, R, E, B>\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing chainOptionKW for StateReaderTaskEither in TypeScript\nDESCRIPTION: Defines chainOptionKW as a less strict version of chainOptionK. It merges error types when chaining an Option operation.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/StateReaderTaskEither.ts.md#2025-04-23_snippet_16\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare const chainOptionKW: <E2>(\n  onNone: LazyArg<E2>\n) => <A, B>(\n  f: (a: A) => Option<B>\n) => <S, R, E1>(ma: StateReaderTaskEither<S, R, E1, A>) => StateReaderTaskEither<S, R, E2 | E1, B>\n```\n\n----------------------------------------\n\nTITLE: Defining Higher-Kinded Compact Function\nDESCRIPTION: Implementation of the compact operation for composed functors with various type constraints and arities.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Compactable.ts.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare function compact<F extends URIS2, G extends URIS2, E>(\n  F: Functor2<F>,\n  G: Compactable2C<G, E>\n): <FE, A>(fa: Kind2<F, FE, Kind2<G, E, Option<A>>>) => Kind2<F, FE, Kind2<G, E, A>>\nexport declare function compact<F extends URIS, G extends URIS2, E>(\n  F: Functor1<F>,\n  G: Compactable2C<G, E>\n): <A>(fa: Kind<F, Kind2<G, E, Option<A>>>) => Kind<F, Kind2<G, E, A>>\nexport declare function compact<F extends URIS, G extends URIS>(\n  F: Functor1<F>,\n  G: Compactable1<G>\n): <A>(fa: Kind<F, Kind<G, Option<A>>>) => Kind<F, Kind<G, A>>\nexport declare function compact<F, G>(\n  F: Functor<F>,\n  G: Compactable<G>\n): <A>(fa: HKT<F, HKT<G, Option<A>>>) => HKT<F, HKT<G, A>>\n```\n\n----------------------------------------\n\nTITLE: Defining PipeableFoldableWithIndex Interface in TypeScript\nDESCRIPTION: Extends the base PipeableFoldable interface to provide indexed folding operations for generic higher-kinded types. Adds methods that receive the index along with values during folding operations.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/pipeable.ts.md#2025-04-23_snippet_62\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface PipeableFoldableWithIndex<F, I> extends PipeableFoldable<F> {\n  readonly reduceWithIndex: <A, B>(b: B, f: (i: I, b: B, a: A) => B) => (fa: HKT<F, A>) => B\n  readonly foldMapWithIndex: <M>(M: Monoid<M>) => <A>(f: (i: I, a: A) => M) => (fa: HKT<F, A>) => M\n  readonly reduceRightWithIndex: <A, B>(b: B, f: (i: I, a: A, b: B) => B) => (fa: HKT<F, A>) => B\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing filterSecond Function for Magma in TypeScript\nDESCRIPTION: Defines the filterSecond function that creates a new Magma by applying a predicate to the second argument of concat.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Magma.ts.md#2025-04-23_snippet_5\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare const filterSecond: <A>(predicate: Predicate<A>) => (M: Magma<A>) => Magma<A>\n```\n\n----------------------------------------\n\nTITLE: Defining WriterT2 Interface for URIS2\nDESCRIPTION: Interface definition for Writer transformer with two type parameters URIS2 constraint.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/WriterT.ts.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface WriterT2<M extends URIS2, E, W, A> {\n  (): Kind2<M, E, [A, W]>\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing fromPredicate for StateReaderTaskEither in TypeScript\nDESCRIPTION: Defines a function to create a StateReaderTaskEither from a predicate, with separate handling for refinements and general predicates.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/StateReaderTaskEither.ts.md#2025-04-23_snippet_30\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare const fromPredicate: {\n  <E, A, B extends A>(refinement: Refinement<A, B>, onFalse: (a: A) => E): <S, R = unknown>(\n    a: A\n  ) => StateReaderTaskEither<S, R, E, B>\n  <E, A>(predicate: Predicate<A>, onFalse: (a: A) => E): <S, R = unknown, B extends A = A>(\n    b: B\n  ) => StateReaderTaskEither<S, R, E, B>\n  <E, A>(predicate: Predicate<A>, onFalse: (a: A) => E): <S, R = unknown>(a: A) => StateReaderTaskEither<S, R, E, A>\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Pointed Instance for IOOption in TypeScript\nDESCRIPTION: Declares the Pointed instance for the IOOption monad. This provides implementations for the Pointed typeclass methods.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/IOOption.ts.md#2025-04-23_snippet_14\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const Pointed: Pointed1<'IOOption'>\n```\n\n----------------------------------------\n\nTITLE: Implementing tapError Operation for ReaderTaskEither in TypeScript\nDESCRIPTION: Defines a tapError operation for ReaderTaskEither, which allows effectfully peeking at the failure of the effect.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReaderTaskEither.ts.md#2025-04-23_snippet_19\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare const tapError: {\n  <E1, R2, E2, _>(onLeft: (e: E1) => ReaderTaskEither<R2, E2, _>): <R1, A>(\n    self: ReaderTaskEither<R1, E1, A>\n  ) => ReaderTaskEither<R1 & R2, E1 | E2, A>\n  <R1, E1, A, R2, E2, _>(\n    self: ReaderTaskEither<R1, E1, A>,\n    onLeft: (e: E1) => ReaderTaskEither<R2, E2, _>\n  ): ReaderTaskEither<R1 & R2, E1 | E2, A>\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Alt instance for Either in TypeScript\nDESCRIPTION: Declares the Alt type class instance for Either.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Either.ts.md#2025-04-23_snippet_21\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare const Alt: Alt2<'Either'>\n```\n\n----------------------------------------\n\nTITLE: Defining Invariant2 Interface in TypeScript\nDESCRIPTION: Interface for Invariant type class with two type parameters. Extends URIS2 for higher-kinded types with two type parameters.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Invariant.ts.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface Invariant2<F extends URIS2> {\n  readonly URI: F\n  readonly imap: <E, A, B>(fa: Kind2<F, E, A>, f: (a: A) => B, g: (b: B) => A) => Kind2<F, E, B>\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Flatten Function for IOOption in TypeScript\nDESCRIPTION: Defines the flatten function for IOOption. It flattens a nested IOOption structure.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/IOOption.ts.md#2025-04-23_snippet_44\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const flatten: <A>(mma: IOOption<IOOption<A>>) => IOOption<A>\n```\n\n----------------------------------------\n\nTITLE: Fallback Values in fp-ts 2.x (New)\nDESCRIPTION: Example of using the simplified API for fallback values in fp-ts 2.x where only lazy evaluation is supported and the L suffix has been removed.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/guides/upgrade-to-v2.md#2025-04-23_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as O from 'fp-ts/Option'\nimport { pipe } from 'fp-ts/function'\n\npipe(\n  O.some(1),\n  O.getOrElse(() => 0)\n)\n```\n\n----------------------------------------\n\nTITLE: Defining the BoundedDistributiveLattice Interface in TypeScript\nDESCRIPTION: Type definition for the BoundedDistributiveLattice interface, which extends both BoundedLattice and DistributiveLattice interfaces. This represents a lattice structure that has both bounded and distributive properties.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/BoundedDistributiveLattice.ts.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface BoundedDistributiveLattice<A> extends BoundedLattice<A>, DistributiveLattice<A> {}\n```\n\n----------------------------------------\n\nTITLE: Unfolding ReadonlyArray in TypeScript\nDESCRIPTION: Generates a readonly array by repeatedly applying a function to an initial value.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReadonlyArray.ts.md#2025-04-23_snippet_63\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const unfold: <A, B>(b: B, f: (b: B) => Option<readonly [A, B]>) => readonly A[]\n```\n\n----------------------------------------\n\nTITLE: Defining Apply4 Interface in TypeScript\nDESCRIPTION: This code snippet defines the Apply4 interface, a variant of Apply for type constructors with four type parameters.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Apply.ts.md#2025-04-23_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface Apply4<F extends URIS4> extends Functor4<F> {\n  readonly ap: <S, R, E, A, B>(fab: Kind4<F, S, R, E, (a: A) => B>, fa: Kind4<F, S, R, E, A>) => Kind4<F, S, R, E, B>\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Comonad Instance for Store in TypeScript\nDESCRIPTION: Declares the Comonad typeclass instance for Store, providing comonadic operations.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Store.ts.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const Comonad: Comonad2<'Store'>\n```\n\n----------------------------------------\n\nTITLE: Declaring Monad for ReadonlyNonEmptyArray in TypeScript\nDESCRIPTION: Defines the Monad type class instance for ReadonlyNonEmptyArray.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReadonlyNonEmptyArray.ts.md#2025-04-23_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const Monad: Monad1<'ReadonlyNonEmptyArray'>\n```\n\n----------------------------------------\n\nTITLE: Implementing Semigroup for Either\nDESCRIPTION: Example showing Semigroup implementation that concatenates Right values\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Either.ts.md#2025-04-23_snippet_27\n\nLANGUAGE: typescript\nCODE:\n```\nimport { getSemigroup, left, right } from 'fp-ts/Either'\nimport { SemigroupSum } from 'fp-ts/number'\n\nconst S = getSemigroup<string, number>(SemigroupSum)\nassert.deepStrictEqual(S.concat(left('a'), left('b')), left('a'))\nassert.deepStrictEqual(S.concat(left('a'), right(2)), right(2))\nassert.deepStrictEqual(S.concat(right(1), left('b')), right(1))\nassert.deepStrictEqual(S.concat(right(1), right(2)), right(3))\n```\n\n----------------------------------------\n\nTITLE: Implementing filterMap in TypeScript\nDESCRIPTION: Type declarations for a pipeable filterMap function that works with different URI constraints. Handles various type scenarios including 4-parameter, 3-parameter, 2-parameter, and single parameter kinds.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/pipeable.ts.md#2025-04-23_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare function filterMap<F extends URIS4>(\n  F: Filterable4<F>\n): <A, B>(f: (a: A) => Option<B>) => <S, R, E>(fa: Kind4<F, S, R, E, A>) => Kind4<F, S, R, E, B>\n```\n\n----------------------------------------\n\nTITLE: Implementing Chain2C Interface for URIS2 with Fixed Error Type\nDESCRIPTION: Chain interface for type constructors with two type parameters but fixed error type, extending Apply2C.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Chain.ts.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface Chain2C<F extends URIS2, E> extends Apply2C<F, E> {\n  readonly chain: <A, B>(fa: Kind2<F, E, A>, f: (a: A) => Kind2<F, E, B>) => Kind2<F, E, B>\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing reduce Composition in TypeScript\nDESCRIPTION: Utility function that composes two Foldable instances to enable reduction over nested data structures with a binary function.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Foldable.ts.md#2025-04-23_snippet_10\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare function reduce<F extends URIS, G extends URIS>(\n  F: Foldable1<F>,\n  G: Foldable1<G>\n): <B, A>(b: B, f: (b: B, a: A) => B) => (fga: Kind<F, Kind<G, A>>) => B\nexport declare function reduce<F, G>(\n  F: Foldable<F>,\n  G: Foldable<G>\n): <B, A>(b: B, f: (b: B, a: A) => B) => (fga: HKT<F, HKT<G, A>>) => B\n```\n\n----------------------------------------\n\nTITLE: Implementing duplicate Function for Store in TypeScript\nDESCRIPTION: Defines the duplicate function for Store, creating a nested Store structure.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Store.ts.md#2025-04-23_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const duplicate: <E, A>(wa: Store<E, A>) => Store<E, Store<E, A>>\n```\n\n----------------------------------------\n\nTITLE: Applying Properties with Widening in Do Notation for TaskEither in TypeScript\nDESCRIPTION: A less strict version of apS that merges error types.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/TaskEither.ts.md#2025-04-23_snippet_11\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare const apSW: <A, N extends string, E2, B>(\n  name: Exclude<N, keyof A>,\n  fb: TaskEither<E2, B>\n) => <E1>(fa: TaskEither<E1, A>) => TaskEither<E2 | E1, { readonly [K in N | keyof A]: K extends keyof A ? A[K] : B }>\n```\n\n----------------------------------------\n\nTITLE: Declaring Traversable for ReadonlyNonEmptyArray in TypeScript\nDESCRIPTION: Defines the Traversable type class instance for ReadonlyNonEmptyArray.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReadonlyNonEmptyArray.ts.md#2025-04-23_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const Traversable: Traversable1<'ReadonlyNonEmptyArray'>\n```\n\n----------------------------------------\n\nTITLE: Implementing fold for Pattern Matching\nDESCRIPTION: Alias of matchE that handles both success and error cases, transforming them into a ReaderTask while discarding the Either structure.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReaderTaskEither.ts.md#2025-04-23_snippet_78\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const fold: <R, E, A, B>(\n  onLeft: (e: E) => RT.ReaderTask<R, B>,\n  onRight: (a: A) => RT.ReaderTask<R, B>\n) => (ma: ReaderTaskEither<R, E, A>) => RT.ReaderTask<R, B>\n```\n\n----------------------------------------\n\nTITLE: Type Definitions and URI Constants in TypeScript\nDESCRIPTION: Type definitions and URI constants for TaskEither type identification.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/TaskEither.ts.md#2025-04-23_snippet_81\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const URI: 'TaskEither'\n```\n\nLANGUAGE: typescript\nCODE:\n```\nexport type URI = typeof URI\n```\n\n----------------------------------------\n\nTITLE: Map Union Operation\nDESCRIPTION: Function to compute union of two maps using key equality and value combination via Magma.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Map.ts.md#2025-04-23_snippet_21\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const union: <K, A>(E: Eq<K>, M: Magma<A>) => (second: Map<K, A>) => (first: Map<K, A>) => Map<K, A>\n```\n\n----------------------------------------\n\nTITLE: Implementing flap Function for These in TypeScript\nDESCRIPTION: Defines the flap function for the These type, which applies a value to a function wrapped in a These context.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/These.ts.md#2025-04-23_snippet_8\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare const flap: <A>(a: A) => <E, B>(fab: These<E, (a: A) => B>) => These<E, B>\n```\n\n----------------------------------------\n\nTITLE: HKT Interface Definition\nDESCRIPTION: The definition of the HKT interface, which represents a type constructor of kind * -> *. This is part of fp-ts's machinery for emulating higher-kinded types in TypeScript.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/guides/HKT.md#2025-04-23_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\n// fp-ts/HKT.ts\n\nexport interface HKT<URI, A> {\n  readonly _URI: URI\n  readonly _A: A\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing asUnit for StateReaderTaskEither in TypeScript\nDESCRIPTION: Defines a function to map the Right value of a StateReaderTaskEither to void.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/StateReaderTaskEither.ts.md#2025-04-23_snippet_37\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare const asUnit: <S, R, E, _>(\n  self: StateReaderTaskEither<S, R, E, _>\n) => StateReaderTaskEither<S, R, E, void>\n```\n\n----------------------------------------\n\nTITLE: Implementing 'ap' Composition for Applicative Functors in TypeScript\nDESCRIPTION: This code provides comprehensive type signatures for the 'ap' function, which enables composition of Apply functors. It includes numerous overloaded declarations to support various combinations of higher-kinded type structures (URIS1-4) with different arities and type parameters.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Apply.ts.md#2025-04-23_snippet_8\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare function ap<F extends URIS4, G extends URIS4>(\n  F: Apply4<F>,\n  G: Apply4<G>\n): <FS, FR, FE, GS, GR, GE, A>(\n  fa: Kind4<F, FS, FR, FE, Kind4<G, GS, GR, GE, A>>\n) => <B>(fab: Kind4<F, FS, FR, FE, Kind4<G, GS, GR, GE, (a: A) => B>>) => Kind4<F, FS, FR, FE, Kind4<G, GS, GR, GE, B>>\nexport declare function ap<F extends URIS4, G extends URIS3>(\n  F: Apply4<F>,\n  G: Apply3<G>\n): <S, FR, FE, GR, GE, A>(\n  fa: Kind4<F, S, FR, FE, Kind3<G, GR, GE, A>>\n) => <B>(fab: Kind4<F, S, FR, FE, Kind3<G, GR, GE, (a: A) => B>>) => Kind4<F, S, FR, FE, Kind3<G, GR, GE, B>>\nexport declare function ap<F extends URIS4, G extends URIS3, GE>(\n  F: Apply4<F>,\n  G: Apply3C<G, GE>\n): <S, FR, FE, GR, A>(\n  fa: Kind4<F, S, FR, FE, Kind3<G, GR, GE, A>>\n) => <B>(fab: Kind4<F, S, FR, FE, Kind3<G, GR, GE, (a: A) => B>>) => Kind4<F, S, FR, FE, Kind3<G, GR, GE, B>>\nexport declare function ap<F extends URIS4, G extends URIS2>(\n  F: Apply4<F>,\n  G: Apply2<G>\n): <S, R, FE, GE, A>(\n  fa: Kind4<F, S, R, FE, Kind2<G, GE, A>>\n) => <B>(fab: Kind4<F, S, R, FE, Kind2<G, GE, (a: A) => B>>) => Kind4<F, S, R, FE, Kind2<G, GE, B>>\nexport declare function ap<F extends URIS4, G extends URIS2, GE>(\n  F: Apply4<F>,\n  G: Apply2C<G, GE>\n): <S, R, FE, A>(\n  fa: Kind4<F, S, R, FE, Kind2<G, GE, A>>\n) => <B>(fab: Kind4<F, S, R, FE, Kind2<G, GE, (a: A) => B>>) => Kind4<F, S, R, FE, Kind2<G, GE, B>>\nexport declare function ap<F extends URIS4, G extends URIS>(\n  F: Apply4<F>,\n  G: Apply1<G>\n): <S, R, E, A>(\n  fa: Kind4<F, S, R, E, Kind<G, A>>\n) => <B>(fab: Kind4<F, S, R, E, Kind<G, (a: A) => B>>) => Kind4<F, S, R, E, Kind<G, B>>\nexport declare function ap<F extends URIS3, FE, G extends URIS4>(\n  F: Apply3C<F, FE>,\n  G: Apply4<G>\n): <FR, S, GR, GE, A>(\n  fa: Kind3<F, FR, FE, Kind4<G, S, GR, GE, A>>\n) => <B>(fab: Kind3<F, FR, FE, Kind4<G, S, GR, GE, (a: A) => B>>) => Kind3<F, FR, FE, Kind4<G, S, GR, GE, B>>\nexport declare function ap<F extends URIS3, FE, G extends URIS3>(\n  F: Apply3C<F, FE>,\n  G: Apply3<G>\n): <FR, GR, GE, A>(\n  fa: Kind3<F, FR, FE, Kind3<G, GR, GE, A>>\n) => <B>(fab: Kind3<F, FR, FE, Kind3<G, GR, GE, (a: A) => B>>) => Kind3<F, FR, FE, Kind3<G, GR, GE, B>>\nexport declare function ap<F extends URIS3, FE, G extends URIS3, GE>(\n  F: Apply3C<F, FE>,\n  G: Apply3C<G, GE>\n): <FR, GR, A>(\n  fa: Kind3<F, FR, FE, Kind3<G, GR, GE, A>>\n) => <B>(fab: Kind3<F, FR, FE, Kind3<G, GR, GE, (a: A) => B>>) => Kind3<F, FR, FE, Kind3<G, GR, GE, B>>\nexport declare function ap<F extends URIS3, FE, G extends URIS2>(\n  F: Apply3C<F, FE>,\n  G: Apply2<G>\n): <R, GE, A>(\n  fa: Kind3<F, R, FE, Kind2<G, GE, A>>\n) => <B>(fab: Kind3<F, R, FE, Kind2<G, GE, (a: A) => B>>) => Kind3<F, R, FE, Kind2<G, GE, B>>\nexport declare function ap<F extends URIS3, FE, G extends URIS2, GE>(\n  F: Apply3C<F, FE>,\n  G: Apply2C<G, GE>\n): <R, A>(\n  fa: Kind3<F, R, FE, Kind2<G, GE, A>>\n) => <B>(fab: Kind3<F, R, FE, Kind2<G, GE, (a: A) => B>>) => Kind3<F, R, FE, Kind2<G, GE, B>>\nexport declare function ap<F extends URIS3, E, G extends URIS>(\n  F: Apply3C<F, E>,\n  G: Apply1<G>\n): <R, A>(\n  fa: Kind3<F, R, E, Kind<G, A>>\n) => <B>(fab: Kind3<F, R, E, Kind<G, (a: A) => B>>) => Kind3<F, R, E, Kind<G, B>>\nexport declare function ap<F extends URIS3, G extends URIS4>(\n  F: Apply3<F>,\n  G: Apply4<G>\n): <FR, FE, S, GR, GE, A>(\n  fa: Kind3<F, FR, FE, Kind4<G, S, GR, GE, A>>\n) => <B>(fab: Kind3<F, FR, FE, Kind4<G, S, GR, GE, (a: A) => B>>) => Kind3<F, FR, FE, Kind4<G, S, GR, GE, B>>\nexport declare function ap<F extends URIS3, G extends URIS3>(\n  F: Apply3<F>,\n  G: Apply3<G>\n): <FR, FE, GR, GE, A>(\n  fa: Kind3<F, FR, FE, Kind3<G, GR, GE, A>>\n) => <B>(fab: Kind3<F, FR, FE, Kind3<G, GR, GE, (a: A) => B>>) => Kind3<F, FR, FE, Kind3<G, GR, GE, B>>\nexport declare function ap<F extends URIS3, G extends URIS3, GE>(\n  F: Apply3<F>,\n  G: Apply3C<G, GE>\n): <FR, FE, GR, A>(\n  fa: Kind3<F, FR, FE, Kind3<G, GR, GE, A>>\n) => <B>(fab: Kind3<F, FR, FE, Kind3<G, GR, GE, (a: A) => B>>) => Kind3<F, FR, FE, Kind3<G, GR, GE, B>>\nexport declare function ap<F extends URIS3, G extends URIS2>(\n  F: Apply3<F>,\n  G: Apply2<G>\n): <R, FE, GE, A>(\n  fa: Kind3<F, R, FE, Kind2<G, GE, A>>\n) => <B>(fab: Kind3<F, R, FE, Kind2<G, GE, (a: A) => B>>) => Kind3<F, R, FE, Kind2<G, GE, B>>\nexport declare function ap<F extends URIS3, G extends URIS2, GE>(\n  F: Apply3<F>,\n  G: Apply2C<G, GE>\n): <R, FE, A>(\n  fa: Kind3<F, R, FE, Kind2<G, GE, A>>\n) => <B>(fab: Kind3<F, R, FE, Kind2<G, GE, (a: A) => B>>) => Kind3<F, R, FE, Kind2<G, GE, B>>\nexport declare function ap<F extends URIS3, G extends URIS>(\n  F: Apply3<F>,\n  G: Apply1<G>\n): <R, E, A>(\n  fa: Kind3<F, R, E, Kind<G, A>>\n) => <B>(fab: Kind3<F, R, E, Kind<G, (a: A) => B>>) => Kind3<F, R, E, Kind<G, B>>\nexport declare function ap<F extends URIS2, FE, G extends URIS4>(\n  F: Apply2C<F, FE>,\n  G: Apply4<G>\n): <S, R, GE, A>(\n  fa: Kind2<F, FE, Kind4<G, S, R, GE, A>>\n) => <B>(fab: Kind2<F, FE, Kind4<G, S, R, GE, (a: A) => B>>) => Kind2<F, FE, Kind4<G, S, R, GE, B>>\nexport declare function ap<F extends URIS2, FE, G extends URIS3>(\n  F: Apply2C<F, FE>,\n  G: Apply3<G>\n): <R, GE, A>(\n  fa: Kind2<F, FE, Kind3<G, R, GE, A>>\n) => <B>(fab: Kind2<F, FE, Kind3<G, R, GE, (a: A) => B>>) => Kind2<F, FE, Kind3<G, R, GE, B>>\nexport declare function ap<F extends URIS2, FE, G extends URIS3, GE>(\n  F: Apply2C<F, FE>,\n  G: Apply3C<G, GE>\n): <R, A>(\n  fa: Kind2<F, FE, Kind3<G, R, GE, A>>\n) => <B>(fab: Kind2<F, FE, Kind3<G, R, GE, (a: A) => B>>) => Kind2<F, FE, Kind3<G, R, GE, B>>\nexport declare function ap<F extends URIS2, FE, G extends URIS2>(\n  F: Apply2C<F, FE>,\n  G: Apply2<G>\n): <GE, A>(\n  fa: Kind2<F, FE, Kind2<G, GE, A>>\n) => <B>(fab: Kind2<F, FE, Kind2<G, GE, (a: A) => B>>) => Kind2<F, FE, Kind2<G, GE, B>>\nexport declare function ap<F extends URIS2, FE, G extends URIS2, GE>(\n  F: Apply2C<F, FE>,\n  G: Apply2C<G, GE>\n): <A>(\n  fa: Kind2<F, FE, Kind2<G, GE, A>>\n) => <B>(fab: Kind2<F, FE, Kind2<G, GE, (a: A) => B>>) => Kind2<F, FE, Kind2<G, GE, B>>\nexport declare function ap<F extends URIS2, E, G extends URIS>(\n  F: Apply2C<F, E>,\n  G: Apply1<G>\n): <A>(fa: Kind2<F, E, Kind<G, A>>) => <B>(fab: Kind2<F, E, Kind<G, (a: A) => B>>) => Kind2<F, E, Kind<G, B>>\nexport declare function ap<F extends URIS2, G extends URIS4>(\n  F: Apply2<F>,\n  G: Apply4<G>\n): <FE, S, R, GE, A>(\n  fa: Kind2<F, FE, Kind4<G, S, R, GE, A>>\n) => <B>(fab: Kind2<F, FE, Kind4<G, S, R, GE, (a: A) => B>>) => Kind2<F, FE, Kind4<G, S, R, GE, B>>\nexport declare function ap<F extends URIS2, G extends URIS3>(\n  F: Apply2<F>,\n  G: Apply3<G>\n): <FE, R, GE, A>(\n  fa: Kind2<F, FE, Kind3<G, R, GE, A>>\n) => <B>(fab: Kind2<F, FE, Kind3<G, R, GE, (a: A) => B>>) => Kind2<F, FE, Kind3<G, R, GE, B>>\nexport declare function ap<F extends URIS2, G extends URIS3, GE>(\n  F: Apply2<F>,\n  G: Apply3C<G, GE>\n): <FE, R, A>(\n  fa: Kind2<F, FE, Kind3<G, R, GE, A>>\n) => <B>(fab: Kind2<F, FE, Kind3<G, R, GE, (a: A) => B>>) => Kind2<F, FE, Kind3<G, R, GE, B>>\nexport declare function ap<F extends URIS2, G extends URIS2>(\n  F: Apply2<F>,\n  G: Apply2<G>\n): <FE, GE, A>(\n  fa: Kind2<F, FE, Kind2<G, GE, A>>\n) => <B>(fab: Kind2<F, FE, Kind2<G, GE, (a: A) => B>>) => Kind2<F, FE, Kind2<G, GE, B>>\nexport declare function ap<F extends URIS2, G extends URIS2, GE>(\n  F: Apply2<F>,\n  G: Apply2C<G, GE>\n): <FE, A>(\n  fa: Kind2<F, FE, Kind2<G, GE, A>>\n) => <B>(fab: Kind2<F, FE, Kind2<G, GE, (a: A) => B>>) => Kind2<F, FE, Kind2<G, GE, B>>\nexport declare function ap<F extends URIS2, G extends URIS>(\n  F: Apply2<F>,\n  G: Apply1<G>\n): <E, A>(fa: Kind2<F, E, Kind<G, A>>) => <B>(fab: Kind2<F, E, Kind<G, (a: A) => B>>) => Kind2<F, E, Kind<G, B>>\nexport declare function ap<F extends URIS, G extends URIS4>(\n  F: Apply1<F>,\n  G: Apply4<G>\n): <S, R, E, A>(\n  fa: Kind<F, Kind4<G, S, R, E, A>>\n) => <B>(fab: Kind<F, Kind4<G, S, R, E, (a: A) => B>>) => Kind<F, Kind4<G, S, R, E, B>>\nexport declare function ap<F extends URIS, G extends URIS3>(\n  F: Apply1<F>,\n  G: Apply3<G>\n): <R, E, A>(\n  fa: Kind<F, Kind3<G, R, E, A>>\n) => <B>(fab: Kind<F, Kind3<G, R, E, (a: A) => B>>) => Kind<F, Kind3<G, R, E, B>>\nexport declare function ap<F extends URIS, G extends URIS3, E>(\n  F: Apply1<F>,\n  G: Apply3C<G, E>\n): <R, A>(\n  fa: Kind<F, Kind3<G, R, E, A>>\n) => <B>(fab: Kind<F, Kind3<G, R, E, (a: A) => B>>) => Kind<F, Kind3<G, R, E, B>>\nexport declare function ap<F extends URIS, G extends URIS2>(\n  F: Apply1<F>,\n  G: Apply2<G>\n): <E, A>(fa: Kind<F, Kind2<G, E, A>>) => <B>(fab: Kind<F, Kind2<G, E, (a: A) => B>>) => Kind<F, Kind2<G, E, B>>\nexport declare function ap<F extends URIS, G extends URIS2, E>(\n  F: Apply1<F>,\n  G: Apply2C<G, E>\n): <A>(fa: Kind<F, Kind2<G, E, A>>) => <B>(fab: Kind<F, Kind2<G, E, (a: A) => B>>) => Kind<F, Kind2<G, E, B>>\nexport declare function ap<F extends URIS, G extends URIS>(\n  F: Apply1<F>,\n  G: Apply1<G>\n): <A>(fa: Kind<F, Kind<G, A>>) => <B>(fab: Kind<F, Kind<G, (a: A) => B>>) => Kind<F, Kind<G, B>>\nexport declare function ap<F, G extends URIS4>(\n  F: Apply<F>,\n  G: Apply4<G>\n): <S, R, E, A>(\n  fa: HKT<F, Kind4<G, S, R, E, A>>\n) => <B>(fab: HKT<F, Kind4<G, S, R, E, (a: A) => B>>) => HKT<F, Kind4<G, S, R, E, B>>\nexport declare function ap<F, G extends URIS3>(\n  F: Apply<F>,\n  G: Apply3<G>\n): <R, E, A>(\n  fa: HKT<F, Kind3<G, R, E, A>>\n) => <B>(fab: HKT<F, Kind3<G, R, E, (a: A) => B>>) => HKT<F, Kind3<G, R, E, B>>\nexport declare function ap<F, G extends URIS3, E>(\n  F: Apply<F>,\n  G: Apply3C<G, E>\n): <R, A>(fa: HKT<F, Kind3<G, R, E, A>>) => <B>(fab: HKT<F, Kind3<G, R, E, (a: A) => B>>) => HKT<F, Kind3<G, R, E, B>>\nexport declare function ap<F, G extends URIS2>(\n  F: Apply<F>,\n  G: Apply2<G>\n): <E, A>(fa: HKT<F, Kind2<G, E, A>>) => <B>(fab: HKT<F, Kind2<G, E, (a: A) => B>>) => HKT<F, Kind2<G, E, B>>\nexport declare function ap<F, G extends URIS2, E>(\n  F: Apply<F>,\n  G: Apply2C<G, E>\n): <A>(fa: HKT<F, Kind2<G, E, A>>) => <B>(fab: HKT<F, Kind2<G, E, (a: A) => B>>) => HKT<F, Kind2<G, E, B>>\nexport declare function ap<F, G extends URIS>(\n  F: Apply<F>,\n  G: Apply1<G>\n\n```\n\n----------------------------------------\n\nTITLE: Implementing filterFirst Function for Magma in TypeScript\nDESCRIPTION: Defines the filterFirst function that creates a new Magma by applying a predicate to the first argument of concat.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Magma.ts.md#2025-04-23_snippet_4\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare const filterFirst: <A>(predicate: Predicate<A>) => (M: Magma<A>) => Magma<A>\n```\n\n----------------------------------------\n\nTITLE: Implementing MatchE Function for IOOption in TypeScript\nDESCRIPTION: Defines the matchE function for IOOption. It allows pattern matching on IOOption values with effectful handlers.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/IOOption.ts.md#2025-04-23_snippet_36\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const matchE: <B, A>(onNone: () => I.IO<B>, onSome: (a: A) => I.IO<B>) => (ma: IOOption<A>) => I.IO<B>\n```\n\n----------------------------------------\n\nTITLE: Defining Apply Instance for IOOption in TypeScript\nDESCRIPTION: Declares the Apply instance for the IOOption monad. This provides implementations for the Apply typeclass methods.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/IOOption.ts.md#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const Apply: Apply1<'IOOption'>\n```\n\n----------------------------------------\n\nTITLE: Defining tapReader Combinator for ReaderTaskEither in TypeScript\nDESCRIPTION: Defines a tapReader combinator for ReaderTaskEither that composes computations in sequence, using the return value of one computation to determine the next computation and keeping only the result of the first.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReaderTaskEither.ts.md#2025-04-23_snippet_3\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare const tapReader: {\n  <A, R2, _>(f: (a: A) => R.Reader<R2, _>): <R1, E>(self: ReaderTaskEither<R1, E, A>) => ReaderTaskEither<R1 & R2, E, A>\n  <R1, E, A, R2, _>(self: ReaderTaskEither<R1, E, A>, f: (a: A) => R.Reader<R2, _>): ReaderTaskEither<R1 & R2, E, A>\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing URItoKind4 Interface for `* -> * -> * -> * -> *` Constructors in TypeScript\nDESCRIPTION: Defines an empty interface to be extended by specific implementations of quaternary type constructors. Acts as a registry that maps URIs to their corresponding implementations.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/HKT.ts.md#2025-04-23_snippet_15\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface URItoKind4<S, R, E, A> {}\n```\n\n----------------------------------------\n\nTITLE: Implementing fromReaderTaskK for ReaderTask Lifting\nDESCRIPTION: Transforms a function returning a ReaderTask into a function returning a ReaderTaskEither, lifting reader context with asynchronous capabilities to include error handling.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReaderTaskEither.ts.md#2025-04-23_snippet_69\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const fromReaderTaskK: <A extends readonly unknown[], R, B>(\n  f: (...a: A) => RT.ReaderTask<R, B>\n) => <E = never>(...a: A) => ReaderTaskEither<R, E, B>\n```\n\n----------------------------------------\n\nTITLE: Implementing MonadIO1 Interface for URIS Types\nDESCRIPTION: Extends the MonadIO pattern to support higher-kinded types with one type parameter (URIS).\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/MonadIO.ts.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface MonadIO1<M extends URIS> extends Monad1<M>, FromIO1<M> {}\n```\n\n----------------------------------------\n\nTITLE: Implementing Ap Function for IOOption in TypeScript\nDESCRIPTION: Defines the ap function for IOOption. It applies a function in IOOption context to a value in IOOption context.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/IOOption.ts.md#2025-04-23_snippet_50\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const ap: <A>(fa: IOOption<A>) => <B>(fab: IOOption<(a: A) => B>) => IOOption<B>\n```\n\n----------------------------------------\n\nTITLE: Chain Operation Type Definition for Either Monad\nDESCRIPTION: Type definition for chaining operations on Either monads across different URI types. Supports 3-level, 2-level and basic monadic operations with proper type inference.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/EitherT.ts.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare function chain<M extends URIS3>(\n  M: Monad3<M>\n): <A, R, ME, E, B>(\n  f: (a: A) => Kind3<M, R, ME, Either<E, B>>\n) => (ma: Kind3<M, R, ME, Either<E, A>>) => Kind3<M, R, ME, Either<E, B>>\n```\n\n----------------------------------------\n\nTITLE: Defining MonadTask3 Interface in TypeScript\nDESCRIPTION: Defines the MonadTask3 interface extending MonadIO3 and FromTask3 for URIS3 type M.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/MonadTask.ts.md#2025-04-23_snippet_4\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport interface MonadTask3<M extends URIS3> extends MonadIO3<M>, FromTask3<M> {}\n```\n\n----------------------------------------\n\nTITLE: Map Size Calculation\nDESCRIPTION: Function to get the number of key-value pairs in a Map.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Map.ts.md#2025-04-23_snippet_19\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const size: <K, A>(m: Map<K, A>) => number\n```\n\n----------------------------------------\n\nTITLE: Defining local function for ReaderIO in TypeScript\nDESCRIPTION: Changes the value of the local context during the execution of a ReaderIO action. It's similar to Contravariant's contramap.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReaderIO.ts.md#2025-04-23_snippet_27\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const local: <R2, R1>(f: (r2: R2) => R1) => <A>(ma: ReaderIO<R1, A>) => ReaderIO<R2, A>\n```\n\n----------------------------------------\n\nTITLE: Natural Transformation with Fixed Error Type\nDESCRIPTION: Defines transformation between type constructors with a fixed error type parameter\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/NaturalTransformation.ts.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface NaturalTransformation12C<F extends URIS, G extends URIS2, E> {\n  <A>(fa: Kind<F, A>): Kind2<G, E, A>\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing chainFirstIOK in TypeScript for ReaderTaskEither\nDESCRIPTION: Alias of tapIO that executes an IO-returning side effect without changing the original value. It takes a function from A to IO<B> and returns a function that preserves the original value while executing the IO effect.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReaderTaskEither.ts.md#2025-04-23_snippet_25\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const chainFirstIOK: <A, B>(\n  f: (a: A) => IO<B>\n) => <R, E>(first: ReaderTaskEither<R, E, A>) => ReaderTaskEither<R, E, A>\n```\n\n----------------------------------------\n\nTITLE: Implementing fromTaskK for Lifting Task Functions in TypeScript\nDESCRIPTION: Creates a function that transforms a Task-returning function into a TaskEither-returning function, with the success type from the Task and a never error type by default.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/TaskEither.ts.md#2025-04-23_snippet_52\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const fromTaskK: <A extends readonly unknown[], B>(\n  f: (...a: A) => T.Task<B>\n) => <E = never>(...a: A) => TaskEither<E, B>\n```\n\n----------------------------------------\n\nTITLE: Implementing ChainFirst Function for IOOption in TypeScript\nDESCRIPTION: Defines the chainFirst function for IOOption, which is an alias of tap. It allows chaining operations while keeping the original value.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/IOOption.ts.md#2025-04-23_snippet_18\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const chainFirst: <A, B>(f: (a: A) => IOOption<B>) => (first: IOOption<A>) => IOOption<A>\n```\n\n----------------------------------------\n\nTITLE: Defining Apply3C Interface in TypeScript\nDESCRIPTION: This code snippet defines the Apply3C interface, a variant of Apply3 with a fixed error type parameter.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Apply.ts.md#2025-04-23_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface Apply3C<F extends URIS3, E> extends Functor3C<F, E> {\n  readonly ap: <R, A, B>(fab: Kind3<F, R, E, (a: A) => B>, fa: Kind3<F, R, E, A>) => Kind3<F, R, E, B>\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Base MonadThrow Interface\nDESCRIPTION: Defines the base MonadThrow interface that extends Monad with throwError functionality for handling errors in a monadic context.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/MonadThrow.ts.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface MonadThrow<M> extends Monad<M> {\n  readonly throwError: <E, A>(e: E) => HKT<M, A>\n}\n```\n\n----------------------------------------\n\nTITLE: Declaring Functor for ReadonlyNonEmptyArray in TypeScript\nDESCRIPTION: Defines the Functor type class instance for ReadonlyNonEmptyArray.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReadonlyNonEmptyArray.ts.md#2025-04-23_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const Functor: Functor1<'ReadonlyNonEmptyArray'>\n```\n\n----------------------------------------\n\nTITLE: Array Equality Comparison Implementation\nDESCRIPTION: Example showing how to use getEq to compare NonEmptyArrays for equality using a custom element equality function.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/NonEmptyArray.ts.md#2025-04-23_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nimport { getEq } from 'fp-ts/NonEmptyArray'\nimport * as N from 'fp-ts/number'\n\nconst E = getEq(N.Eq)\nassert.strictEqual(E.equals([1, 2], [1, 2]), true)\nassert.strictEqual(E.equals([1, 2], [1, 3]), false)\n```\n\n----------------------------------------\n\nTITLE: Implementing Pipeable Promap Function in TypeScript\nDESCRIPTION: Defines a pipeable promap function for various arities of the Profunctor type class. It allows mapping over both the input and output of a profunctor simultaneously.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/pipeable.ts.md#2025-04-23_snippet_20\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare function promap<F extends URIS4>(\n  F: Profunctor4<F>\n): <E, A, D, B>(f: (d: D) => E, g: (a: A) => B) => <S, R>(fbc: Kind4<F, S, R, E, A>) => Kind4<F, S, R, D, B>\nexport declare function promap<F extends URIS3>(\n  F: Profunctor3<F>\n): <E, A, D, B>(f: (d: D) => E, g: (a: A) => B) => <R>(fbc: Kind3<F, R, E, A>) => Kind3<F, R, D, B>\nexport declare function promap<F extends URIS3, E>(\n  F: Profunctor3C<F, E>\n): <A, D, B>(f: (d: D) => E, g: (a: A) => B) => <R>(fbc: Kind3<F, R, E, A>) => Kind3<F, R, D, B>\nexport declare function promap<F extends URIS2>(\n  F: Profunctor2<F>\n): <E, A, D, B>(f: (d: D) => E, g: (a: A) => B) => (fbc: Kind2<F, E, A>) => Kind2<F, D, B>\nexport declare function promap<F extends URIS2, E>(\n  F: Profunctor2C<F, E>\n): <A, D, B>(f: (d: D) => E, g: (a: A) => B) => (fbc: Kind2<F, E, A>) => Kind2<F, D, B>\nexport declare function promap<F>(\n  F: Profunctor<F>\n): <E, A, D, B>(f: (d: D) => E, g: (a: A) => B) => (fbc: HKT2<F, E, A>) => HKT2<F, D, B>\n```\n\n----------------------------------------\n\nTITLE: Defining Applicative Instance for IOOption in TypeScript\nDESCRIPTION: Declares the Applicative instance for the IOOption monad. This provides implementations for the Applicative typeclass methods.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/IOOption.ts.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const Applicative: Applicative1<'IOOption'>\n```\n\n----------------------------------------\n\nTITLE: Defining PipeableFoldable Interface in TypeScript\nDESCRIPTION: Base interface for pipeable foldable type classes with generic higher-kinded types. Provides the core folding operations: reduce, foldMap, and reduceRight.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/pipeable.ts.md#2025-04-23_snippet_63\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface PipeableFoldable<F> {\n  readonly reduce: <A, B>(b: B, f: (b: B, a: A) => B) => (fa: HKT<F, A>) => B\n  readonly foldMap: <M>(M: Monoid<M>) => <A>(f: (a: A) => M) => (fa: HKT<F, A>) => M\n  readonly reduceRight: <A, B>(b: B, f: (a: A, b: B) => B) => (fa: HKT<F, A>) => B\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing FromEitherK Function for IOOption in TypeScript\nDESCRIPTION: Defines the fromEitherK function for IOOption. It lifts a function returning Either to a function returning IOOption.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/IOOption.ts.md#2025-04-23_snippet_24\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const fromEitherK: <E, A extends readonly unknown[], B>(\n  f: (...a: A) => Either<E, B>\n) => (...a: A) => IOOption<B>\n```\n\n----------------------------------------\n\nTITLE: Implementing fromEitherK Type Definitions in TypeScript\nDESCRIPTION: Defines type signatures for fromEitherK function that lifts functions returning Either into the target type constructor. Supports multiple URIS levels.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/FromEither.ts.md#2025-04-23_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare function fromEitherK<F extends URIS4>(\n  F: FromEither4<F>\n): <A extends ReadonlyArray<unknown>, E, B>(f: (...a: A) => Either<E, B>) => <S, R>(...a: A) => Kind4<F, S, R, E, B>\n```\n\n----------------------------------------\n\nTITLE: Creating Applicative Instance for TaskValidation in TypeScript\nDESCRIPTION: Creates an Applicative instance for TaskValidation, allowing concatenation of errors.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/TaskEither.ts.md#2025-04-23_snippet_19\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare function getApplicativeTaskValidation<E>(A: Apply1<T.URI>, S: Semigroup<E>): Applicative2C<URI, E>\n```\n\n----------------------------------------\n\nTITLE: Implementing chainW with Type Widening\nDESCRIPTION: Widened version of chain (alias of flatMap) that merges environment and error types, providing more flexible type composition.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReaderTaskEither.ts.md#2025-04-23_snippet_56\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const chainW: <R2, E2, A, B>(\n  f: (a: A) => ReaderTaskEither<R2, E2, B>\n) => <R1, E1>(ma: ReaderTaskEither<R1, E1, A>) => ReaderTaskEither<R1 & R2, E2 | E1, B>\n```\n\n----------------------------------------\n\nTITLE: Implementing MonadThrow3 Interface\nDESCRIPTION: Defines MonadThrow3 interface for three-parameter type constructors, extending Monad3 with error handling.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/MonadThrow.ts.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface MonadThrow3<M extends URIS3> extends Monad3<M> {\n  readonly throwError: <R, E, A>(e: E) => Kind3<M, R, E, A>\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing ChainOptionK Function in TypeScript\nDESCRIPTION: Defines a utility function for chaining operations that return Option values, with error handling for None cases. This allows for composing operations that may return None with custom error generation.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/FromEither.ts.md#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare function chainOptionK<F extends URIS4>(\n  F: FromEither4<F>,\n  M: Chain4<F>\n): <E>(onNone: LazyArg<E>) => <A, B>(f: (a: A) => Option<B>) => <S, R>(ma: Kind4<F, S, R, E, A>) => Kind4<F, S, R, E, B>\nexport declare function chainOptionK<F extends URIS3>(\n  F: FromEither3<F>,\n  M: Chain3<F>\n): <E>(onNone: LazyArg<E>) => <A, B>(f: (a: A) => Option<B>) => <R>(ma: Kind3<F, R, E, A>) => Kind3<F, R, E, B>\nexport declare function chainOptionK<F extends URIS3, E>(\n  F: FromEither3C<F, E>,\n  M: Chain3C<F, E>\n): (onNone: LazyArg<E>) => <A, B>(f: (a: A) => Option<B>) => <R>(ma: Kind3<F, R, E, A>) => Kind3<F, R, E, B>\nexport declare function chainOptionK<F extends URIS2>(\n  F: FromEither2<F>,\n  M: Chain2<F>\n): <E>(onNone: LazyArg<E>) => <A, B>(f: (a: A) => Option<B>) => (ma: Kind2<F, E, A>) => Kind2<F, E, B>\nexport declare function chainOptionK<F extends URIS2, E>(\n  F: FromEither2C<F, E>,\n  M: Chain2C<F, E>\n): (onNone: LazyArg<E>) => <A, B>(f: (a: A) => Option<B>) => (ma: Kind2<F, E, A>) => Kind2<F, E, B>\nexport declare function chainOptionK<F>(\n  F: FromEither<F>,\n  M: Chain<F>\n): <E>(onNone: LazyArg<E>) => <A, B>(f: (a: A) => Option<B>) => (ma: HKT2<F, E, A>) => HKT2<F, E, B>\n```\n\n----------------------------------------\n\nTITLE: Implementing fromTheseK Utility Function in TypeScript\nDESCRIPTION: Defines the fromTheseK utility function for creating functions that lift These values into a FromThese context. It provides overloads for different FromThese variants.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/FromThese.ts.md#2025-04-23_snippet_6\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare function fromTheseK<F extends URIS4>(\n  F: FromThese4<F>\n): <A extends ReadonlyArray<unknown>, E, B>(f: (...a: A) => These<E, B>) => <S, R>(...a: A) => Kind4<F, S, R, E, B>\nexport declare function fromTheseK<F extends URIS3>(\n  F: FromThese3<F>\n): <A extends ReadonlyArray<unknown>, E, B>(f: (...a: A) => These<E, B>) => <R>(...a: A) => Kind3<F, R, E, B>\nexport declare function fromTheseK<F extends URIS3, E>(\n  F: FromThese3C<F, E>\n): <A extends ReadonlyArray<unknown>, B>(f: (...a: A) => These<E, B>) => <R>(...a: A) => Kind3<F, R, E, B>\nexport declare function fromTheseK<F extends URIS2>(\n  F: FromThese2<F>\n): <A extends ReadonlyArray<unknown>, E, B>(f: (...a: A) => These<E, B>) => (...a: A) => Kind2<F, E, B>\nexport declare function fromTheseK<F extends URIS2, E>(\n  F: FromThese2C<F, E>\n): <A extends ReadonlyArray<unknown>, B>(f: (...a: A) => These<E, B>) => (...a: A) => Kind2<F, E, B>\nexport declare function fromTheseK<F>(\n  F: FromThese<F>\n): <A extends ReadonlyArray<unknown>, E, B>(f: (...a: A) => These<E, B>) => (...a: A) => HKT2<F, E, B>\n```\n\n----------------------------------------\n\nTITLE: Creating FilterableWithIndex Instance for Record in TypeScript\nDESCRIPTION: Defines a FilterableWithIndex instance for the Record type in fp-ts. FilterableWithIndex extends Filterable with operations that also provide the index of each element.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Record.ts.md#2025-04-23_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const FilterableWithIndex: FilterableWithIndex1<'Record', string>\n```\n\n----------------------------------------\n\nTITLE: Defining apFirst Function for ReaderTaskEither in TypeScript\nDESCRIPTION: Function signature for apFirst that combines two ReaderTaskEither values, keeping only the result of the first one. Added in v2.0.0.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReaderTaskEither.ts.md#2025-04-23_snippet_111\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const apFirst: <R, E, B>(\n  second: ReaderTaskEither<R, E, B>\n) => <A>(first: ReaderTaskEither<R, E, A>) => ReaderTaskEither<R, E, A>\n```\n\n----------------------------------------\n\nTITLE: Defining FromReader4 interface in TypeScript\nDESCRIPTION: The FromReader4 interface is a specialized version of FromReader for quadrifunctor monads. It provides a more specific type signature for the fromReader method using the URIS4 type encoding.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/FromReader.ts.md#2025-04-23_snippet_6\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport interface FromReader4<F extends URIS4> {\n  readonly URI: F\n  readonly fromReader: <R, A, S, E>(fa: Reader<R, A>) => Kind4<F, S, R, E, A>\n}\n```\n\n----------------------------------------\n\nTITLE: Utility Functions - TypeScript\nDESCRIPTION: Basic tuple operations including compose, duplicate, extend, fst, snd, and swap\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Tuple.ts.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const compose: <A, B>(ab: [B, A]) => <C>(bc: [C, B]) => [C, A]\nexport declare const duplicate: <E, A>(wa: [A, E]) => [[A, E], E]\nexport declare const extend: <E, A, B>(f: (wa: [A, E]) => B) => (wa: [A, E]) => [B, E]\nexport declare const fst: <A, E>(ea: [A, E]) => A\nexport declare const snd: <A, E>(ea: [A, E]) => E\nexport declare const swap: <A, E>(ea: [A, E]) => [E, A]\n```\n\n----------------------------------------\n\nTITLE: Implementing ChainNullableK Function for IOOption in TypeScript\nDESCRIPTION: Defines the chainNullableK function for IOOption, which is an alias of flatMapNullable. It allows chaining operations with nullable values on IOOption.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/IOOption.ts.md#2025-04-23_snippet_22\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const chainNullableK: <A, B>(\n  f: (a: A) => B | null | undefined\n) => (ma: IOOption<A>) => IOOption<NonNullable<B>>\n```\n\n----------------------------------------\n\nTITLE: Sequential Array Traversal Functions\nDESCRIPTION: Functions for sequential traversal of arrays using ReaderTask, including indexed versions\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReaderTask.ts.md#2025-04-23_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const traverseSeqArray: <R, A, B>(\n  f: (a: A) => ReaderTask<R, B>\n) => (as: readonly A[]) => ReaderTask<R, readonly B[]>\n\nexport declare const traverseSeqArrayWithIndex: <R, A, B>(\n  f: (index: number, a: A) => ReaderTask<R, B>\n) => (as: readonly A[]) => ReaderTask<R, readonly B[]>\n```\n\n----------------------------------------\n\nTITLE: Defining traverseReadonlyArrayWithIndex function for ReaderIO in TypeScript\nDESCRIPTION: Maps each element of a readonly array to a ReaderIO using both the element and its index. It's equivalent to ReadonlyArray#traverseWithIndex(Applicative).\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReaderIO.ts.md#2025-04-23_snippet_18\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const traverseReadonlyArrayWithIndex: <A, R, B>(\n  f: (index: number, a: A) => ReaderIO<R, B>\n) => (as: readonly A[]) => ReaderIO<R, readonly B[]>\n```\n\n----------------------------------------\n\nTITLE: Implementing right Utility Function for Separated in TypeScript\nDESCRIPTION: Defines the right utility function, which extracts the right part of a Separated instance.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Separated.ts.md#2025-04-23_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const right: <E, A>(s: Separated<E, A>) => A\n```\n\n----------------------------------------\n\nTITLE: Implementing flap Function for Function Application in TypeScript\nDESCRIPTION: Applies a value to a TaskEither containing a function, useful for function application in a TaskEither context.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/TaskEither.ts.md#2025-04-23_snippet_58\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const flap: <A>(a: A) => <E, B>(fab: TaskEither<E, (a: A) => B>) => TaskEither<E, B>\n```\n\n----------------------------------------\n\nTITLE: Folding Operations - TypeScript\nDESCRIPTION: Implementation of fold operations (foldMap, reduce, reduceRight) for tuples\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Tuple.ts.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const foldMap: <M>(M: Monoid<M>) => <A>(f: (a: A) => M) => <E>(fa: [A, E]) => M\n```\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const reduce: <A, B>(b: B, f: (b: B, a: A) => B) => <E>(fa: [A, E]) => B\n```\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const reduceRight: <A, B>(b: B, f: (a: A, b: B) => B) => <E>(fa: [A, E]) => B\n```\n\n----------------------------------------\n\nTITLE: Implementing Do Notation for ReaderEither in TypeScript\nDESCRIPTION: Implements the Do notation function, which creates an empty context for use with do notation.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReaderEither.ts.md#2025-04-23_snippet_4\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare const Do: ReaderEither<unknown, never, {}>\n```\n\n----------------------------------------\n\nTITLE: Defining Functor instance for Const in TypeScript\nDESCRIPTION: Provides the Functor type class instance for Const, enabling mapping over the second type parameter (though the actual value remains unchanged).\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Const.ts.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const Functor: Functor2<'Const'>\n```\n\n----------------------------------------\n\nTITLE: Defining MonadTask3C Interface in TypeScript\nDESCRIPTION: Defines the MonadTask3C interface extending MonadIO3C and FromTask3C for URIS3 type M and type E.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/MonadTask.ts.md#2025-04-23_snippet_5\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport interface MonadTask3C<M extends URIS3, E> extends MonadIO3C<M, E>, FromTask3C<M, E> {}\n```\n\n----------------------------------------\n\nTITLE: Extract Function Implementation - TypeScript\nDESCRIPTION: Function to extract the first element from a tuple pair.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Tuple.ts.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const extract: <E, A>(wa: [A, E]) => A\n```\n\n----------------------------------------\n\nTITLE: Trivial Ord Instance in TypeScript\nDESCRIPTION: Provides a trivial Ord instance that treats all values as equal. Useful as a default or fallback ordering.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Ord.ts.md#2025-04-23_snippet_22\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const trivial: Ord<unknown>\n```\n\n----------------------------------------\n\nTITLE: Defining FunctorComposition22C Interface in TypeScript\nDESCRIPTION: Interface for composing two binary higher-kinded types with a fixed second type parameter for the inner functor G.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Functor.ts.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface FunctorComposition22C<F extends URIS2, G extends URIS2, E> {\n  readonly map: <FE, A, B>(fa: Kind2<F, FE, Kind2<G, E, A>>, f: (a: A) => B) => Kind2<F, FE, Kind2<G, E, B>>\n}\n```\n\n----------------------------------------\n\nTITLE: Defining bracketW Function for ReaderTaskEither in TypeScript\nDESCRIPTION: Function signature for bracketW, a less strict version of bracket that allows different environment and error types between the acquire, use, and release functions. Added in v2.12.0.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReaderTaskEither.ts.md#2025-04-23_snippet_117\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare function bracketW<R1, E1, A, R2, E2, B, R3, E3>(\n  acquire: ReaderTaskEither<R1, E1, A>,\n  use: (a: A) => ReaderTaskEither<R2, E2, B>,\n  release: (a: A, e: Either<E2, B>) => ReaderTaskEither<R3, E3, void>\n): ReaderTaskEither<R1 & R2 & R3, E1 | E2 | E3, B>\n```\n\n----------------------------------------\n\nTITLE: Implementing chainFirstEitherK in TypeScript for ReaderTaskEither\nDESCRIPTION: Alias of tapEither that executes an Either-returning side effect without changing the original value. It combines the functionality of tap with an Either-returning function.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReaderTaskEither.ts.md#2025-04-23_snippet_23\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const chainFirstEitherK: <A, E, B>(\n  f: (a: A) => E.Either<E, B>\n) => <R>(ma: ReaderTaskEither<R, E, A>) => ReaderTaskEither<R, E, A>\n```\n\n----------------------------------------\n\nTITLE: Defining Apply2C Interface in TypeScript\nDESCRIPTION: This code snippet defines the Apply2C interface, a variant of Apply2 with a fixed error type parameter.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Apply.ts.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface Apply2C<F extends URIS2, E> extends Functor2C<F, E> {\n  readonly ap: <A, B>(fab: Kind2<F, E, (a: A) => B>, fa: Kind2<F, E, A>) => Kind2<F, E, B>\n}\n```\n\n----------------------------------------\n\nTITLE: Defining partitionMap Pipeable Function in TypeScript\nDESCRIPTION: Creates a pipeable partitionMap function that supports various arity levels (URIS1-4) in the fp-ts library. This function transforms elements and separates them into two data structures based on Either results.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/pipeable.ts.md#2025-04-23_snippet_17\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare function partitionMap<F extends URIS4>(\n  F: Filterable4<F>\n): <A, B, C>(\n  f: (a: A) => Either<B, C>\n) => <S, R, E>(fa: Kind4<F, S, R, E, A>) => Separated<Kind4<F, S, R, E, B>, Kind4<F, S, R, E, C>>\nexport declare function partitionMap<F extends URIS3>(\n  F: Filterable3<F>\n): <A, B, C>(\n  f: (a: A) => Either<B, C>\n) => <R, E>(fa: Kind3<F, R, E, A>) => Separated<Kind3<F, R, E, B>, Kind3<F, R, E, C>>\nexport declare function partitionMap<F extends URIS3, E>(\n  F: Filterable3C<F, E>\n): <A, B, C>(f: (a: A) => Either<B, C>) => <R>(fa: Kind3<F, R, E, A>) => Separated<Kind3<F, R, E, B>, Kind3<F, R, E, C>>\nexport declare function partitionMap<F extends URIS2>(\n  F: Filterable2<F>\n): <A, B, C>(f: (a: A) => Either<B, C>) => <E>(fa: Kind2<F, E, A>) => Separated<Kind2<F, E, B>, Kind2<F, E, C>>\nexport declare function partitionMap<F extends URIS2, E>(\n  F: Filterable2C<F, E>\n): <A, B, C>(f: (a: A) => Either<B, C>) => (fa: Kind2<F, E, A>) => Separated<Kind2<F, E, B>, Kind2<F, E, C>>\nexport declare function partitionMap<F extends URIS>(\n  F: Filterable1<F>\n): <A, B, C>(f: (a: A) => Either<B, C>) => (fa: Kind<F, A>) => Separated<Kind<F, B>, Kind<F, C>>\nexport declare function partitionMap<F>(\n  F: Filterable<F>\n): <A, B, C>(f: (a: A) => Either<B, C>) => (fa: HKT<F, A>) => Separated<HKT<F, B>, HKT<F, C>>\n```\n\n----------------------------------------\n\nTITLE: Implementing Monoid Instance for void Type\nDESCRIPTION: Defines a Monoid instance for the void type in fp-ts. A Monoid represents a type with an associative binary operation and an identity element.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/void.ts.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const Monoid: M.Monoid<void>\n```\n\n----------------------------------------\n\nTITLE: Negating Refinement\nDESCRIPTION: Creates a new refinement that negates the original refinement using Exclude type.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Refinement.ts.md#2025-04-23_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const not: <A, B extends A>(refinement: Refinement<A, B>) => Refinement<A, Exclude<A, B>>\n```\n\n----------------------------------------\n\nTITLE: Implementing Alt4 Interface for Quaternary Type Constructors\nDESCRIPTION: Type-specific Alt interface for types with kind * -> * -> * -> * -> *. Extends Functor4 and includes an alt operation working with Kind4<F, S, R, E, A> types.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Alt.ts.md#2025-04-23_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface Alt4<F extends URIS4> extends Functor4<F> {\n  readonly alt: <S, R, E, A>(fa: Kind4<F, S, R, E, A>, that: LazyArg<Kind4<F, S, R, E, A>>) => Kind4<F, S, R, E, A>\n}\n```\n\n----------------------------------------\n\nTITLE: Defining PipeableFunctorWithIndex Interface in TypeScript\nDESCRIPTION: Extends the base PipeableFunctor interface to provide indexed mapping operations for generic higher-kinded types. Adds the mapWithIndex method that uses both index and value during mapping.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/pipeable.ts.md#2025-04-23_snippet_74\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface PipeableFunctorWithIndex<F, I> extends PipeableFunctor<F> {\n  readonly mapWithIndex: <A, B>(f: (i: I, a: A) => B) => (fa: HKT<F, A>) => HKT<F, B>\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing apW for StateReaderTaskEither in TypeScript\nDESCRIPTION: Provides a widening version of ap (apW) that merges environment and error types when applying a function contained in a StateReaderTaskEither context to a value in another context.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/StateReaderTaskEither.ts.md#2025-04-23_snippet_66\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare const apW: <S, R2, E2, A>(\n  fa: StateReaderTaskEither<S, R2, E2, A>\n) => <R1, E1, B>(fab: StateReaderTaskEither<S, R1, E1, (a: A) => B>) => StateReaderTaskEither<S, R1 & R2, E2 | E1, B>\n```\n\n----------------------------------------\n\nTITLE: Defining chainTaskK for StateReaderTaskEither in TypeScript\nDESCRIPTION: Implements chainTaskK as an alias of flatMapTask. It chains a Task operation after a StateReaderTaskEither.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/StateReaderTaskEither.ts.md#2025-04-23_snippet_24\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare const chainTaskK: <A, B>(\n  f: (a: A) => Task<B>\n) => <S, R, E>(first: StateReaderTaskEither<S, R, E, A>) => StateReaderTaskEither<S, R, E, B>\n```\n\n----------------------------------------\n\nTITLE: Implementing map in TypeScript\nDESCRIPTION: Type declarations for a pipeable map function that transforms values within a Functor context. Supports multiple type parameter scenarios.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/pipeable.ts.md#2025-04-23_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare function map<F extends URIS4>(\n  F: Functor4<F>\n): <A, B>(f: (a: A) => B) => <S, R, E>(fa: Kind4<F, S, R, E, A>) => Kind4<F, S, R, E, B>\n```\n\n----------------------------------------\n\nTITLE: Creating a Compactable Instance for TaskEither with a Monoid\nDESCRIPTION: A function that creates a Compactable instance for TaskEither given a Monoid for the error type, enabling compact and separate operations on TaskEither values.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/TaskEither.ts.md#2025-04-23_snippet_32\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const getCompactable: <E>(M: Monoid<E>) => Compactable2C<'TaskEither', E>\n```\n\n----------------------------------------\n\nTITLE: Implementing tap Combinator in TypeScript\nDESCRIPTION: Function that composes computations in sequence, using the return value of one computation to determine the next computation while keeping only the result of the first.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/StateReaderTaskEither.ts.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const tap: {\n  <S, R1, E1, A, R2, E2, _>(\n    self: StateReaderTaskEither<S, R1, E1, A>,\n    f: (a: A) => StateReaderTaskEither<S, R2, E2, _>\n  ): StateReaderTaskEither<S, R1 & R2, E1 | E2, A>\n  <A, S, R2, E2, _>(f: (a: A) => StateReaderTaskEither<S, R2, E2, _>): <R1, E1>(\n    self: StateReaderTaskEither<S, R1, E1, A>\n  ) => StateReaderTaskEither<S, R1 & R2, E2 | E1, A>\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Zero1 interface for URIS functors in TypeScript\nDESCRIPTION: This interface defines the structure for a Zero type class for functors of kind URIS. It includes a URI type and a zero method that returns a Kind of the functor.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Zero.ts.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface Zero1<F extends URIS> {\n  readonly URI: F\n  readonly zero: <A>() => Kind<F, A>\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing chainReaderKW in TypeScript for ReaderTaskEither\nDESCRIPTION: Widening version of chainReaderK that allows for different environment types. It takes a function from A to Reader<R1, B> and returns a function that transforms a ReaderTaskEither<R2, E, A> into a ReaderTaskEither<R1 & R2, E, B>.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReaderTaskEither.ts.md#2025-04-23_snippet_49\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const chainReaderKW: <A, R1, B>(\n  f: (a: A) => R.Reader<R1, B>\n) => <R2, E>(ma: ReaderTaskEither<R2, E, A>) => ReaderTaskEither<R1 & R2, E, B>\n```\n\n----------------------------------------\n\nTITLE: Implementing seeks Function for Store in TypeScript\nDESCRIPTION: Defines the seeks function for Store, repositioning the focus based on the current position.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Store.ts.md#2025-04-23_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare function seeks<S>(f: Endomorphism<S>): <A>(wa: Store<S, A>) => Store<S, A>\n```\n\n----------------------------------------\n\nTITLE: Defining chainFirstIOK for StateReaderTaskEither in TypeScript\nDESCRIPTION: Defines chainFirstIOK as an alias of tapIO. It chains an IO operation after a StateReaderTaskEither, discarding the result of the IO operation.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/StateReaderTaskEither.ts.md#2025-04-23_snippet_7\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare const chainFirstIOK: <A, B>(\n  f: (a: A) => IO<B>\n) => <S, R, E>(first: StateReaderTaskEither<S, R, E, A>) => StateReaderTaskEither<S, R, E, A>\n```\n\n----------------------------------------\n\nTITLE: Defining flattenW Operation for ReaderTaskEither in TypeScript\nDESCRIPTION: Function signature for flattenW, a less strict version of flatten that merges environment and error types. Added in v2.11.0.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReaderTaskEither.ts.md#2025-04-23_snippet_97\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const flattenW: <R1, E1, R2, E2, A>(\n  mma: ReaderTaskEither<R1, E1, ReaderTaskEither<R2, E2, A>>\n) => ReaderTaskEither<R1 & R2, E1 | E2, A>\n```\n\n----------------------------------------\n\nTITLE: Defining Foldable Interface in TypeScript\nDESCRIPTION: Core interface definition for the Foldable type class, which provides methods for folding generic data structures into a single value.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Foldable.ts.md#2025-04-23_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport interface Foldable<F> {\n  readonly URI: F\n  readonly reduce: <A, B>(fa: HKT<F, A>, b: B, f: (b: B, a: A) => B) => B\n  readonly foldMap: <M>(M: Monoid<M>) => <A>(fa: HKT<F, A>, f: (a: A) => M) => M\n  readonly reduceRight: <A, B>(fa: HKT<F, A>, b: B, f: (a: A, b: B) => B) => B\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Monoid Instance for Ordering\nDESCRIPTION: Exports a Monoid instance for Ordering values.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Ordering.ts.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const Monoid: M.Monoid<Ordering>\n```\n\n----------------------------------------\n\nTITLE: Creating BooleanAlgebra instance for Const in TypeScript\nDESCRIPTION: Creates a BooleanAlgebra instance for Const given a BooleanAlgebra for the first type parameter. This allows using boolean algebra operations on Const values.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Const.ts.md#2025-04-23_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const getBooleanAlgebra: <E, A>(H: BooleanAlgebra<E>) => BooleanAlgebra<Const<E, A>>\n```\n\n----------------------------------------\n\nTITLE: Implementing asks Constructor in TypeScript\nDESCRIPTION: Function that projects a value from the global context in a ReaderEither monad.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/StateReaderTaskEither.ts.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const asks: <S, R, A, E = never>(f: (r: R) => A) => StateReaderTaskEither<S, R, E, A>\n```\n\n----------------------------------------\n\nTITLE: Implementing MonoidProduct for Numbers\nDESCRIPTION: Monoid instance for number multiplication with identity element 1.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/number.ts.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const MonoidProduct: Monoid<number>\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport { MonoidProduct } from 'fp-ts/number'\n\nassert.deepStrictEqual(MonoidProduct.concat(2, MonoidProduct.empty), 2)\n```\n\n----------------------------------------\n\nTITLE: Implementing chainTaskEitherK for ReaderTaskEither\nDESCRIPTION: Alias of flatMapTaskEither that chains a function returning a TaskEither with a ReaderTaskEither, maintaining the same error type.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReaderTaskEither.ts.md#2025-04-23_snippet_53\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const chainTaskEitherK: <E, A, B>(\n  f: (a: A) => TE.TaskEither<E, B>\n) => <R>(ma: ReaderTaskEither<R, E, A>) => ReaderTaskEither<R, E, B>\n```\n\n----------------------------------------\n\nTITLE: Implementing orElseFirst for Error Handling\nDESCRIPTION: Alias of tapError that runs an effect on the error channel without changing the original error, allowing for side effects on errors.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReaderTaskEither.ts.md#2025-04-23_snippet_60\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const orElseFirst: <E, R, B>(\n  onLeft: (e: E) => ReaderTaskEither<R, E, B>\n) => <A>(ma: ReaderTaskEither<R, E, A>) => ReaderTaskEither<R, E, A>\n```\n\n----------------------------------------\n\nTITLE: Implementing flatMapIO Function for Chaining with IO in TypeScript\nDESCRIPTION: Chains a TaskEither with an IO-returning function, applying the function to the Right value and preserving the error type, with support for pipeable and data-last styles.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/TaskEither.ts.md#2025-04-23_snippet_68\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const flatMapIO: {\n  <A, B>(f: (a: A) => IO<B>): <E>(self: TaskEither<E, A>) => TaskEither<E, B>\n  <E, A, B>(self: TaskEither<E, A>, f: (a: A) => IO<B>): TaskEither<E, B>\n}\n```\n\n----------------------------------------\n\nTITLE: Defining PartitionWithIndex Interface in TypeScript\nDESCRIPTION: Defines the PartitionWithIndex interface for partitioning elements with index. It includes overloads for refinement and predicate functions.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/FilterableWithIndex.ts.md#2025-04-23_snippet_2\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport interface PartitionWithIndex<F, I> {\n  <A, B extends A>(fa: HKT<F, A>, refinementWithIndex: RefinementWithIndex<I, A, B>): Separated<HKT<F, A>, HKT<F, B>>\n  <A>(fa: HKT<F, A>, predicateWithIndex: PredicateWithIndex<I, A>): Separated<HKT<F, A>, HKT<F, A>>\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing MonadThrow2C Interface\nDESCRIPTION: Defines MonadThrow2C interface for two-parameter type constructors with a fixed error type, extending Monad2C.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/MonadThrow.ts.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface MonadThrow2C<M extends URIS2, E> extends Monad2C<M, E> {\n  readonly throwError: <A>(e: E) => Kind2<M, E, A>\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing ApT Constant for IOOption in TypeScript\nDESCRIPTION: Defines the ApT constant for IOOption. It represents the applicative unit for IOOption.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/IOOption.ts.md#2025-04-23_snippet_49\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const ApT: IOOption<readonly []>\n```\n\n----------------------------------------\n\nTITLE: Traversing Array with Index Sequentially (TypeScript)\nDESCRIPTION: Function to traverse an Array with index sequentially using ApplicativeSeq. It takes a function that maps an index and element to a Task, and returns a function that takes a ReadonlyArray and returns a Task of ReadonlyArray.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Task.ts.md#2025-04-23_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const traverseSeqArrayWithIndex: <A, B>(\n  f: (index: number, a: A) => Task<B>\n) => (as: readonly A[]) => Task<readonly B[]>\n```\n\n----------------------------------------\n\nTITLE: Defining PipeableFoldable4 Interface in TypeScript\nDESCRIPTION: A pipeable version of the Foldable type class for higher-kinded types of arity 4. It provides folding methods for data structures with four type parameters.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/pipeable.ts.md#2025-04-23_snippet_56\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface PipeableFoldable4<F extends URIS4> {\n  readonly reduce: <A, B>(b: B, f: (b: B, a: A) => B) => <S, R, E>(fa: Kind4<F, S, R, E, A>) => B\n  readonly foldMap: <M>(M: Monoid<M>) => <A>(f: (a: A) => M) => <S, R, E>(fa: Kind4<F, S, R, E, A>) => M\n  readonly reduceRight: <A, B>(b: B, f: (a: A, b: B) => B) => <S, R, E>(fa: Kind4<F, S, R, E, A>) => B\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing mapError Operation for ReaderTaskEither in TypeScript\nDESCRIPTION: Defines a mapError operation for ReaderTaskEither, which maps the error channel using a specified function.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReaderTaskEither.ts.md#2025-04-23_snippet_14\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare const mapError: {\n  <R, E, G>(f: (e: E) => G): <A>(self: ReaderTaskEither<R, E, A>) => ReaderTaskEither<R, G, A>\n  <R, E, A, G>(self: ReaderTaskEither<R, E, A>, f: (e: E) => G): ReaderTaskEither<R, G, A>\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing filterWithIndex in TypeScript\nDESCRIPTION: Type declarations for a pipeable filterWithIndex function that supports both refinements and predicates with index parameters. Handles multiple type parameter scenarios.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/pipeable.ts.md#2025-04-23_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare function filterWithIndex<F extends URIS4, I>(\n  F: FilterableWithIndex4<F, I>\n): {\n  <A, B extends A>(refinement: RefinementWithIndex<I, A, B>): <S, R, E>(\n    fa: Kind4<F, S, R, E, A>\n  ) => Kind4<F, S, R, E, B>\n  <A>(predicate: PredicateWithIndex<I, A>): <S, R, E>(fa: Kind4<F, S, R, E, A>) => Kind4<F, S, R, E, A>\n}\n```\n\n----------------------------------------\n\nTITLE: Defining PipeableFunctorWithIndex2 Interface in TypeScript\nDESCRIPTION: Extends PipeableFunctor2 to provide indexed mapping operations for arity 2 higher-kinded types. Adds the mapWithIndex method that receives both the index and value during mapping.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/pipeable.ts.md#2025-04-23_snippet_71\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface PipeableFunctorWithIndex2<F extends URIS2, I> extends PipeableFunctor2<F> {\n  readonly mapWithIndex: <A, B>(f: (i: I, a: A) => B) => <E>(fa: Kind2<F, E, A>) => Kind2<F, E, B>\n}\n```\n\n----------------------------------------\n\nTITLE: Contravariant Instance for Ord in TypeScript\nDESCRIPTION: Provides a Contravariant instance for the Ord type class, enabling transformation of Ord instances through contramap operations.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Ord.ts.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const Contravariant: Contravariant1<'Ord'>\n```\n\n----------------------------------------\n\nTITLE: Implementing apSecondW for StateReaderTaskEither in TypeScript\nDESCRIPTION: Provides a widening version of apSecond (apSecondW) that merges environment and error types when combining two StateReaderTaskEither effects, keeping only the result of the second.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/StateReaderTaskEither.ts.md#2025-04-23_snippet_65\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare const apSecondW: <S, R2, E2, A, B>(\n  second: StateReaderTaskEither<S, R2, E2, B>\n) => <R1, E1>(first: StateReaderTaskEither<S, R1, E1, A>) => StateReaderTaskEither<S, R1 & R2, E2 | E1, B>\n```\n\n----------------------------------------\n\nTITLE: Implementing chainIOK Utility in TypeScript\nDESCRIPTION: Function that creates a chainIOK operation for sequencing IO computations within various higher-kinded type containers. Lifts an IO-returning function into a chain operation.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/FromIO.ts.md#2025-04-23_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare function chainIOK<M extends URIS4>(\n  F: FromIO4<M>,\n  M: Chain4<M>\n): <A, B>(f: (a: A) => IO<B>) => <S, R, E>(first: Kind4<M, S, R, E, A>) => Kind4<M, S, R, E, B>\nexport declare function chainIOK<M extends URIS3>(\n  F: FromIO3<M>,\n  M: Chain3<M>\n): <A, B>(f: (a: A) => IO<B>) => <R, E>(first: Kind3<M, R, E, A>) => Kind3<M, R, E, B>\nexport declare function chainIOK<M extends URIS3, E>(\n  F: FromIO3C<M, E>,\n  M: Chain3C<M, E>\n): <A, B>(f: (a: A) => IO<B>) => <R>(first: Kind3<M, R, E, A>) => Kind3<M, R, E, B>\nexport declare function chainIOK<M extends URIS2>(\n  F: FromIO2<M>,\n  M: Chain2<M>\n): <A, B>(f: (a: A) => IO<B>) => <E>(first: Kind2<M, E, A>) => Kind2<M, E, B>\nexport declare function chainIOK<M extends URIS2, E>(\n  F: FromIO2C<M, E>,\n  M: Chain2C<M, E>\n): <A, B>(f: (a: A) => IO<B>) => (first: Kind2<M, E, A>) => Kind2<M, E, B>\nexport declare function chainIOK<M extends URIS>(\n  F: FromIO1<M>,\n  M: Chain1<M>\n): <A, B>(f: (a: A) => IO<B>) => (first: Kind<M, A>) => Kind<M, B>\nexport declare function chainIOK<M>(\n  F: FromIO<M>,\n  M: Chain<M>\n): <A, B>(f: (a: A) => IO<B>) => (first: HKT<M, A>) => HKT<M, B>\n```\n\n----------------------------------------\n\nTITLE: Implementing ChainEitherK Function for IOOption in TypeScript\nDESCRIPTION: Defines the chainEitherK function for IOOption, which is an alias of flatMapEither. It allows chaining operations with Either values on IOOption.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/IOOption.ts.md#2025-04-23_snippet_17\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const chainEitherK: <E, A, B>(f: (a: A) => Either<E, B>) => (ma: IOOption<A>) => IOOption<B>\n```\n\n----------------------------------------\n\nTITLE: Defining ReaderM2 Interface in TypeScript\nDESCRIPTION: Defines the ReaderM2 interface with methods for map, of, ap, chain, ask, asks, local, fromReader, and fromM operations. It is parameterized by a type M extending URIS2.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReaderT.ts.md#2025-04-23_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface ReaderM2<M extends URIS2> {\n  readonly map: <R, E, A, B>(ma: ReaderT2<M, R, E, A>, f: (a: A) => B) => ReaderT2<M, R, E, B>\n  readonly of: <R, E, A>(a: A) => ReaderT2<M, R, E, A>\n  readonly ap: <R, E, A, B>(mab: ReaderT2<M, R, E, (a: A) => B>, ma: ReaderT2<M, R, E, A>) => ReaderT2<M, R, E, B>\n  readonly chain: <R, E, A, B>(ma: ReaderT2<M, R, E, A>, f: (a: A) => ReaderT2<M, R, E, B>) => ReaderT2<M, R, E, B>\n  readonly ask: <R, E>() => ReaderT2<M, R, E, R>\n  readonly asks: <R, E, A>(f: (r: R) => A) => ReaderT2<M, R, E, A>\n  readonly local: <R1, E, A, R2>(ma: ReaderT2<M, R1, E, A>, f: (d: R2) => R1) => ReaderT2<M, R2, E, A>\n  readonly fromReader: <R, E, A>(ma: Reader<R, A>) => ReaderT2<M, R, E, A>\n  readonly fromM: <R, E, A>(ma: Kind2<M, E, A>) => ReaderT2<M, R, E, A>\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing State Monad Modify Operation in TypeScript\nDESCRIPTION: Function signatures for modifying the current state using an endomorphism. Supports multiple type hierarchy levels.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/FromState.ts.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare function modify<F extends URIS4>(F: FromState4<F>): <S, R, E>(f: Endomorphism<S>) => Kind4<F, S, R, E, void>\nexport declare function modify<F extends URIS3>(F: FromState3<F>): <S, E>(f: Endomorphism<S>) => Kind3<F, S, E, void>\nexport declare function modify<F extends URIS3, E>(F: FromState3C<F, E>): <S>(f: Endomorphism<S>) => Kind3<F, S, E, void>\nexport declare function modify<F extends URIS2>(F: FromState2<F>): <S>(f: Endomorphism<S>) => Kind2<F, S, void>\nexport declare function modify<F>(F: FromState<F>): <S>(f: Endomorphism<S>) => HKT2<F, S, void>\n```\n\n----------------------------------------\n\nTITLE: Implementing tap Combinator for ReaderIO in TypeScript\nDESCRIPTION: Implements the tap combinator, which composes computations in sequence, using the return value of one computation to determine the next and keeping only the result of the first.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReaderIO.ts.md#2025-04-23_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare const tap: {\n  <R1, A, R2, _>(self: ReaderIO<R1, A>, f: (a: A) => ReaderIO<R2, _>): ReaderIO<R1 & R2, A>\n  <A, R2, _>(f: (a: A) => ReaderIO<R2, _>): <R1>(self: ReaderIO<R1, A>) => ReaderIO<R2 & R1, A>\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing foldMap in TypeScript\nDESCRIPTION: Type declarations for a pipeable foldMap function that uses a Monoid to combine mapped values. Supports various type parameter scenarios for different fold operations.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/pipeable.ts.md#2025-04-23_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare function foldMap<F extends URIS4>(\n  F: Foldable4<F>\n): <M>(M: Monoid<M>) => <A>(f: (a: A) => M) => <S, R, E>(fa: Kind4<F, S, R, E, A>) => M\n```\n\n----------------------------------------\n\nTITLE: Implementing Reverse Function for Bounded Types\nDESCRIPTION: Utility function that creates a new Bounded instance with reversed ordering and swapped top/bottom values. Takes a Bounded instance and returns a new reversed Bounded instance.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Bounded.ts.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const reverse: <A>(B: Bounded<A>) => Bounded<A>\n```\n\n----------------------------------------\n\nTITLE: Implementing flatMapIOEither for StateReaderTaskEither in TypeScript\nDESCRIPTION: Provides flatMapIOEither function that allows mapping from a StateReaderTaskEither to an IOEither monad and flattening the result, with overloads for pipeable and non-pipeable usage.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/StateReaderTaskEither.ts.md#2025-04-23_snippet_45\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare const flatMapIOEither: {\n  <A, E2, B>(f: (a: A) => IOEither<E2, B>): <S, R, E1>(\n    self: StateReaderTaskEither<S, R, E1, A>\n  ) => StateReaderTaskEither<S, R, E2 | E1, B>\n  <S, R, E1, A, E2, B>(self: StateReaderTaskEither<S, R, E1, A>, f: (a: A) => IOEither<E2, B>): StateReaderTaskEither<\n    S,\n    R,\n    E1 | E2,\n    B\n  >\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing upsertAt function for Records in TypeScript\nDESCRIPTION: Creates a function that inserts or updates a value for a key in a Record. Unlike updateAt, this always succeeds, inserting the key-value pair if the key doesn't exist.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Record.ts.md#2025-04-23_snippet_55\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const upsertAt: <A>(k: string, a: A) => (r: Record<string, A>) => Record<string, A>\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport { upsertAt } from 'fp-ts/Record'\n\nassert.deepStrictEqual(upsertAt('a', 5)({ a: 1, b: 2 }), { a: 5, b: 2 })\nassert.deepStrictEqual(upsertAt('c', 5)({ a: 1, b: 2 }), { a: 1, b: 2, c: 5 })\n```\n\n----------------------------------------\n\nTITLE: Defining flatMapReaderIO Operation for ReaderTaskEither in TypeScript\nDESCRIPTION: Function signature for flatMapReaderIO that composes a ReaderTaskEither with a ReaderIO function, handling the combination of reader environments. Added in v2.16.0.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReaderTaskEither.ts.md#2025-04-23_snippet_92\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const flatMapReaderIO: {\n  <A, R2, B>(f: (a: A) => RIO.ReaderIO<R2, B>): <R1, E>(\n    self: ReaderTaskEither<R1, E, A>\n  ) => ReaderTaskEither<R1 & R2, E, B>\n  <R1, E, A, R2, B>(self: ReaderTaskEither<R1, E, A>, f: (a: A) => RIO.ReaderIO<R2, B>): ReaderTaskEither<R1 & R2, E, B>\n}\n```\n\n----------------------------------------\n\nTITLE: Reverse Ordering Function\nDESCRIPTION: Function to reverse an Ordering value.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Ordering.ts.md#2025-04-23_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const reverse: (o: Ordering) => Ordering\n```\n\n----------------------------------------\n\nTITLE: Implementing matchW with Type Widening\nDESCRIPTION: Widened version of match that allows different return types for error and success handlers with pure functions, merging the resulting types.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReaderTaskEither.ts.md#2025-04-23_snippet_83\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const matchW: <E, B, A, C>(\n  onLeft: (e: E) => B,\n  onRight: (a: A) => C\n) => <R>(ma: ReaderTaskEither<R, E, A>) => RT.ReaderTask<R, B | C>\n```\n\n----------------------------------------\n\nTITLE: Defining traverseArrayWithIndex Operation for ReaderTaskEither in TypeScript\nDESCRIPTION: Function signature for traverseArrayWithIndex that maps an array of values to a ReaderTaskEither using both the index and value, then sequences the results. Equivalent to ReadonlyArray#traverseWithIndex(Applicative). Added in v2.9.0.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReaderTaskEither.ts.md#2025-04-23_snippet_101\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const traverseArrayWithIndex: <R, E, A, B>(\n  f: (index: number, a: A) => ReaderTaskEither<R, E, B>\n) => (as: readonly A[]) => ReaderTaskEither<R, E, readonly B[]>\n```\n\n----------------------------------------\n\nTITLE: FoldableWithIndex3 Interface for URIS3 Kind\nDESCRIPTION: Interface for FoldableWithIndex specialized for Kind3<F, R, E, A> types, extending Foldable3 with indexed folding operations.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/FoldableWithIndex.ts.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface FoldableWithIndex3<F extends URIS3, I> extends Foldable3<F> {\n  readonly reduceWithIndex: <R, E, A, B>(fa: Kind3<F, R, E, A>, b: B, f: (i: I, b: B, a: A) => B) => B\n  readonly foldMapWithIndex: <M>(M: Monoid<M>) => <R, E, A>(fa: Kind3<F, R, E, A>, f: (i: I, a: A) => M) => M\n  readonly reduceRightWithIndex: <R, E, A, B>(fa: Kind3<F, R, E, A>, b: B, f: (i: I, a: A, b: B) => B) => B\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Comonad Instance Generator\nDESCRIPTION: Function that creates a Comonad instance for Traced given a Monoid for the position type P.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Traced.ts.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare function getComonad<P>(monoid: Monoid<P>): Comonad2C<URI, P>\n```\n\n----------------------------------------\n\nTITLE: Deprecated tuple equality in TypeScript\nDESCRIPTION: Deprecated function for creating Eq instances for tuples. Users should use the tuple function instead.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Eq.ts.md#2025-04-23_snippet_19\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const getTupleEq: <T extends readonly Eq<any>[]>(\n  ...eqs: T\n) => Eq<{ [K in keyof T]: T[K] extends Eq<infer A> ? A : never }>\n```\n\n----------------------------------------\n\nTITLE: Defining PipeableFoldableWithIndex4 Interface in TypeScript\nDESCRIPTION: Extends PipeableFoldable4 to provide indexed folding operations for arity 4 higher-kinded types. Adds methods that receive the index along with values during folding operations.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/pipeable.ts.md#2025-04-23_snippet_61\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface PipeableFoldableWithIndex4<F extends URIS4, I> extends PipeableFoldable4<F> {\n  readonly reduceWithIndex: <A, B>(b: B, f: (i: I, b: B, a: A) => B) => <S, R, E>(fa: Kind4<F, S, R, E, A>) => B\n  readonly foldMapWithIndex: <M>(M: Monoid<M>) => <A>(f: (i: I, a: A) => M) => <S, R, E>(fa: Kind4<F, S, R, E, A>) => M\n  readonly reduceRightWithIndex: <A, B>(b: B, f: (i: I, a: A, b: B) => B) => <S, R, E>(fa: Kind4<F, S, R, E, A>) => B\n}\n```\n\n----------------------------------------\n\nTITLE: Defining FromIO3 Interface in TypeScript\nDESCRIPTION: Interface for lifting computations from the IO monad to a higher-kinded type F with three type parameters. Adds an additional environment parameter R to support reader-like contexts.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/FromIO.ts.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface FromIO3<F extends URIS3> {\n  readonly URI: F\n  readonly fromIO: <A, R, E>(fa: IO<A>) => Kind3<F, R, E, A>\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing chainFirstReaderK for StateReaderTaskEither in TypeScript\nDESCRIPTION: Defines chainFirstReaderK as an alias of tapReader. It chains a Reader operation after a StateReaderTaskEither, discarding the result of the Reader operation.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/StateReaderTaskEither.ts.md#2025-04-23_snippet_8\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare const chainFirstReaderK: <A, R, B>(\n  f: (a: A) => R.Reader<R, B>\n) => <S, E>(ma: StateReaderTaskEither<S, R, E, A>) => StateReaderTaskEither<S, R, E, A>\n```\n\n----------------------------------------\n\nTITLE: Map Utility Functions\nDESCRIPTION: Collection of utility functions for ReadonlyMap including collect, delete, difference, element testing, and filtering operations.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReadonlyMap.ts.md#2025-04-23_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare function collect<K>(O: Ord<K>): <A, B>(f: (k: K, a: A) => B) => (m: ReadonlyMap<K, A>) => ReadonlyArray<B>\n```\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const deleteAt: <K>(E: Eq<K>) => (k: K) => <A>(m: ReadonlyMap<K, A>) => ReadonlyMap<K, A>\n```\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const difference: <K>(E: Eq<K>) => <A>(_second: ReadonlyMap<K, A>) => (first: ReadonlyMap<K, A>) => ReadonlyMap<K, A>\n```\n\n----------------------------------------\n\nTITLE: Implementing reverse Utility Function for BooleanAlgebra in TypeScript\nDESCRIPTION: Creates a dual algebra for any Boolean algebra by reversing one/zero and join/meet operations. This function allows working with the complementary structure of a given Boolean algebra.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/BooleanAlgebra.ts.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const reverse: <A>(B: BooleanAlgebra<A>) => BooleanAlgebra<A>\n```\n\n----------------------------------------\n\nTITLE: Defining JoinSemilattice Interface in TypeScript\nDESCRIPTION: This snippet defines the JoinSemilattice interface, which represents a join-semilattice structure. It includes a join operation that takes two elements of type A and returns their least upper bound.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/JoinSemilattice.ts.md#2025-04-23_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport interface JoinSemilattice<A> {\n  readonly join: (x: A, y: A) => A\n}\n```\n\n----------------------------------------\n\nTITLE: Declaring FunctorWithIndex for ReadonlyNonEmptyArray in TypeScript\nDESCRIPTION: Defines the FunctorWithIndex type class instance for ReadonlyNonEmptyArray with number index.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReadonlyNonEmptyArray.ts.md#2025-04-23_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const FunctorWithIndex: FunctorWithIndex1<'ReadonlyNonEmptyArray', number>\n```\n\n----------------------------------------\n\nTITLE: Implementing foldW as Alias for matchEW in TypeScript\nDESCRIPTION: An alias for matchEW with type widening, handling both Left and Right cases of a TaskEither with potentially different result types.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/TaskEither.ts.md#2025-04-23_snippet_61\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const foldW: <E, B, A, C>(\n  onLeft: (e: E) => T.Task<B>,\n  onRight: (a: A) => T.Task<C>\n) => (ma: TaskEither<E, A>) => T.Task<B | C>\n```\n\n----------------------------------------\n\nTITLE: Defining URIS2 Type Alias for `* -> * -> *` Constructors in TypeScript\nDESCRIPTION: Creates a type alias for the keys of the URItoKind2 interface, representing the available binary type constructors in the system.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/HKT.ts.md#2025-04-23_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nexport type URIS2 = keyof URItoKind2<any, any>\n```\n\n----------------------------------------\n\nTITLE: Defining FromReader interface in TypeScript\nDESCRIPTION: The FromReader interface defines a type class for monads that can lift computations from the Reader monad. It requires an implementation of the fromReader method to transform a Reader into the target monad.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/FromReader.ts.md#2025-04-23_snippet_2\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport interface FromReader<F> {\n  readonly URI: F\n  readonly fromReader: <R, A>(fa: Reader<R, A>) => HKT2<F, R, A>\n}\n```\n\n----------------------------------------\n\nTITLE: Type Lambdas for Maps in TypeScript\nDESCRIPTION: Type declarations for the Map URI type identifier, used for higher-kinded type operations in the fp-ts ecosystem.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Map.ts.md#2025-04-23_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const URI: 'Map'\n```\n\nLANGUAGE: typescript\nCODE:\n```\nexport type URI = typeof URI\n```\n\n----------------------------------------\n\nTITLE: Unprepending NonEmptyArray in TypeScript\nDESCRIPTION: Returns a tuple containing the head (first element) and the tail (remaining elements) of a NonEmptyArray.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/NonEmptyArray.ts.md#2025-04-23_snippet_23\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const unprepend: <A>(as: NonEmptyArray<A>) => [A, A[]]\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport { unprepend } from 'fp-ts/NonEmptyArray'\n\nassert.deepStrictEqual(unprepend([1, 2, 3]), [1, [2, 3]])\n```\n\n----------------------------------------\n\nTITLE: Implementing MonadThrow3C Interface\nDESCRIPTION: Defines MonadThrow3C interface for three-parameter type constructors with a fixed error type, extending Monad3C.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/MonadThrow.ts.md#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface MonadThrow3C<M extends URIS3, E> extends Monad3C<M, E> {\n  readonly throwError: <R, A>(e: E) => Kind3<M, R, E, A>\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing filterOrElseW in TaskEither with Widened Error Types\nDESCRIPTION: A less strict version of filterOrElse that widens the error types. The 'W' suffix indicates that the error types from the input and the filter function will be merged using a union type.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/TaskEither.ts.md#2025-04-23_snippet_31\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const filterOrElseW: {\n  <A, B extends A, E2>(refinement: Refinement<A, B>, onFalse: (a: A) => E2): <E1>(\n    ma: TaskEither<E1, A>\n  ) => TaskEither<E2 | E1, B>\n  <A, E2>(predicate: Predicate<A>, onFalse: (a: A) => E2): <E1, B extends A>(\n    mb: TaskEither<E1, B>\n  ) => TaskEither<E2 | E1, B>\n  <A, E2>(predicate: Predicate<A>, onFalse: (a: A) => E2): <E1>(ma: TaskEither<E1, A>) => TaskEither<E2 | E1, A>\n}\n```\n\n----------------------------------------\n\nTITLE: Defining PipeableFilterableWithIndex Interface in TypeScript\nDESCRIPTION: Interface definition for PipeableFilterableWithIndex which extends PipeableFilterable adding index-aware filtering operations for generic higher-kinded types. Provides methods that include index information when filtering and partitioning for HKT types.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/pipeable.ts.md#2025-04-23_snippet_50\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface PipeableFilterableWithIndex<F, I> extends PipeableFilterable<F> {\n  readonly filterWithIndex: {\n    <A, B extends A>(refinementWithIndex: RefinementWithIndex<I, A, B>): (fa: HKT<F, A>) => HKT<F, B>\n    <A>(predicateWithIndex: PredicateWithIndex<I, A>): (fa: HKT<F, A>) => HKT<F, A>\n  }\n  readonly filterMapWithIndex: <A, B>(f: (i: I, a: A) => Option<B>) => (fa: HKT<F, A>) => HKT<F, B>\n  readonly partitionWithIndex: {\n    <A, B extends A>(refinementWithIndex: RefinementWithIndex<I, A, B>): (\n      fa: HKT<F, A>\n    ) => Separated<HKT<F, A>, HKT<F, B>>\n    <A>(predicateWithIndex: PredicateWithIndex<I, A>): (fa: HKT<F, A>) => Separated<HKT<F, A>, HKT<F, A>>\n  }\n  readonly partitionMapWithIndex: <A, B, C>(\n    f: (i: I, a: A) => Either<B, C>\n  ) => (fa: HKT<F, A>) => Separated<HKT<F, B>, HKT<F, C>>\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Ord instance for Const in TypeScript\nDESCRIPTION: Creates an Ord instance for Const given an Ord for the first type parameter. This allows comparing Const values for ordering.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Const.ts.md#2025-04-23_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const getOrd: <E, A>(O: Ord<E>) => Ord<Const<E, A>>\n```\n\n----------------------------------------\n\nTITLE: Implementing StateT2 Interface for URIS2 in TypeScript\nDESCRIPTION: Defines the StateT2 interface for monads M with two type parameters (URIS2). It takes a state S and returns a Kind2<M, E, [A, S]>.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/StateT.ts.md#2025-04-23_snippet_2\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport interface StateT2<M extends URIS2, S, E, A> {\n  (s: S): Kind2<M, E, [A, S]>\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing ChainFirstEitherK Function in TypeScript\nDESCRIPTION: Defines a utility function for sequencing operations that return Either values while keeping the original value. This allows for operations that have side effects without changing the value in the chain.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/FromEither.ts.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare function chainFirstEitherK<M extends URIS4>(\n  F: FromEither4<M>,\n  M: Chain4<M>\n): <A, E, B>(f: (a: A) => Either<E, B>) => <S, R>(ma: Kind4<M, S, R, E, A>) => Kind4<M, S, R, E, A>\nexport declare function chainFirstEitherK<M extends URIS3>(\n  F: FromEither3<M>,\n  M: Chain3<M>\n): <A, E, B>(f: (a: A) => Either<E, B>) => <R>(ma: Kind3<M, R, E, A>) => Kind3<M, R, E, A>\nexport declare function chainFirstEitherK<M extends URIS3, E>(\n  F: FromEither3C<M, E>,\n  M: Chain3C<M, E>\n): <A, B>(f: (a: A) => Either<E, B>) => <R>(ma: Kind3<M, R, E, A>) => Kind3<M, R, E, A>\nexport declare function chainFirstEitherK<M extends URIS2>(\n  F: FromEither2<M>,\n  M: Chain2<M>\n): <A, E, B>(f: (a: A) => Either<E, B>) => (ma: Kind2<M, E, A>) => Kind2<M, E, A>\nexport declare function chainFirstEitherK<M extends URIS2, E>(\n  F: FromEither2C<M, E>,\n  M: Chain2C<M, E>\n): <A, B>(f: (a: A) => Either<E, B>) => (ma: Kind2<M, E, A>) => Kind2<M, E, A>\nexport declare function chainFirstEitherK<M extends URIS>(\n  F: FromEither1<M>,\n  M: Chain1<M>\n): <E, A, B>(f: (a: A) => Either<E, B>) => (ma: Kind<M, A>) => Kind<M, A>\nexport declare function chainFirstEitherK<M>(\n  F: FromEither<M>,\n  M: Chain<M>\n): <A, E, B>(f: (a: A) => Either<E, B>) => (ma: HKT2<M, E, A>) => HKT2<M, E, A>\n```\n\n----------------------------------------\n\nTITLE: Defining PipeableFilterableWithIndex3 Interface in TypeScript\nDESCRIPTION: Interface definition for PipeableFilterableWithIndex3 which extends PipeableFilterable3 adding index-aware filtering operations for higher-kinded types of arity 3. Provides methods that include index information when filtering and partitioning.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/pipeable.ts.md#2025-04-23_snippet_48\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface PipeableFilterableWithIndex3<F extends URIS3, I> extends PipeableFilterable3<F> {\n  readonly filterWithIndex: {\n    <A, B extends A>(refinementWithIndex: RefinementWithIndex<I, A, B>): <R, E>(\n      fa: Kind3<F, R, E, A>\n    ) => Kind3<F, R, E, B>\n    <A>(predicateWithIndex: PredicateWithIndex<I, A>): <R, E>(fa: Kind3<F, R, E, A>) => Kind3<F, R, E, A>\n  }\n  readonly filterMapWithIndex: <A, B>(\n    f: (i: I, a: A) => Option<B>\n  ) => <R, E>(fa: Kind3<F, R, E, A>) => Kind3<F, R, E, A>\n  readonly partitionWithIndex: {\n    <A, B extends A>(refinementWithIndex: RefinementWithIndex<I, A, B>): <R, E>(\n      fa: Kind3<F, R, E, A>\n    ) => Separated<Kind3<F, R, E, A>, Kind3<F, R, E, B>>\n    <A>(predicateWithIndex: PredicateWithIndex<I, A>): <R, E>(\n      fa: Kind3<F, R, E, A>\n    ) => Separated<Kind3<F, R, E, A>, Kind3<F, R, E, A>>\n  }\n  readonly partitionMapWithIndex: <A, B, C>(\n    f: (i: I, a: A) => Either<B, C>\n  ) => <R, E>(fa: Kind3<F, R, E, A>) => Separated<Kind3<F, R, E, B>, Kind3<F, R, E, C>>\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing sequenceSeqArray Function for Sequential Array Traversal in TypeScript\nDESCRIPTION: Similar to sequenceArray but processes the array elements sequentially rather than in parallel, maintaining the execution order.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/TaskEither.ts.md#2025-04-23_snippet_77\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const sequenceSeqArray: <A, E>(arr: readonly TaskEither<E, A>[]) => TaskEither<E, readonly A[]>\n```\n\n----------------------------------------\n\nTITLE: Example Usage of alt Method\nDESCRIPTION: Example demonstrating concatenation of two ReadonlyNonEmptyArrays using the alt method which implements the Alt typeclass.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReadonlyNonEmptyArray.ts.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as RNEA from 'fp-ts/ReadonlyNonEmptyArray'\nimport { pipe } from 'fp-ts/function'\n\nassert.deepStrictEqual(\n  pipe(\n    [1, 2, 3],\n    RNEA.alt(() => [4, 5])\n  ),\n  [1, 2, 3, 4, 5]\n)\n```\n\n----------------------------------------\n\nTITLE: Implementing chainReaderIOK in TypeScript for ReaderTaskEither\nDESCRIPTION: Alias of flatMapReaderIO that chains a ReaderIO-returning function with a ReaderTaskEither. It takes a function from A to ReaderIO<R, B> and returns a function that transforms a ReaderTaskEither<R, E, A> into a ReaderTaskEither<R, E, B>.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReaderTaskEither.ts.md#2025-04-23_snippet_46\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const chainReaderIOK: <A, R, B>(\n  f: (a: A) => RIO.ReaderIO<R, B>\n) => <E>(ma: ReaderTaskEither<R, E, A>) => ReaderTaskEither<R, E, B>\n```\n\n----------------------------------------\n\nTITLE: Implementing apFirst for ReadonlyNonEmptyArray in TypeScript\nDESCRIPTION: Combines two effectful actions, keeping only the result of the first.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReadonlyNonEmptyArray.ts.md#2025-04-23_snippet_33\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const apFirst: <B>(\n  second: ReadonlyNonEmptyArray<B>\n) => <A>(first: ReadonlyNonEmptyArray<A>) => ReadonlyNonEmptyArray<A>\n```\n\n----------------------------------------\n\nTITLE: Implementing Flap Function for IOOption in TypeScript\nDESCRIPTION: Defines the flap function for IOOption. It applies a value to a function in an IOOption context.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/IOOption.ts.md#2025-04-23_snippet_31\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const flap: <A>(a: A) => <B>(fab: IOOption<(a: A) => B>) => IOOption<B>\n```\n\n----------------------------------------\n\nTITLE: Defining ReaderTask Interface in TypeScript\nDESCRIPTION: Defines the ReaderTask interface, which represents an asynchronous computation that can read from a shared environment and return a value.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReaderTask.ts.md#2025-04-23_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport interface ReaderTask<R, A> {\n  (r: R): Task<A>\n}\n```\n\n----------------------------------------\n\nTITLE: Example of contramap usage for custom User equality in TypeScript\nDESCRIPTION: Demonstrates how to use contramap to create an Eq instance for a User type based on a unique key field, showing practical application with UUID comparison.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Eq.ts.md#2025-04-23_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nimport { contramap, Eq } from 'fp-ts/Eq'\nimport { pipe } from 'fp-ts/function'\nimport * as S from 'fp-ts/string'\n\ntype UUID = string\n\ninterface User {\n  readonly key: UUID\n  readonly firstName: string\n  readonly lastName: string\n}\n\nconst eqUUID: Eq<UUID> = S.Eq\n\nconst eqUserByKey: Eq<User> = pipe(\n  eqUUID,\n  contramap((user) => user.key)\n)\n\nassert.deepStrictEqual(\n  eqUserByKey.equals({ key: 'k1', firstName: 'a1', lastName: 'b1' }, { key: 'k2', firstName: 'a1', lastName: 'b1' }),\n  false\n)\nassert.deepStrictEqual(\n  eqUserByKey.equals({ key: 'k1', firstName: 'a1', lastName: 'b1' }, { key: 'k1', firstName: 'a2', lastName: 'b1' }),\n  true\n)\n```\n\n----------------------------------------\n\nTITLE: Defining sequenceArray function for ReaderIO in TypeScript\nDESCRIPTION: Transforms an array of ReaderIO into a ReaderIO of an array. It's equivalent to ReadonlyArray#sequence(Applicative).\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReaderIO.ts.md#2025-04-23_snippet_15\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const sequenceArray: <R, A>(arr: readonly ReaderIO<R, A>[]) => ReaderIO<R, readonly A[]>\n```\n\n----------------------------------------\n\nTITLE: Current Timestamp Utility\nDESCRIPTION: Function that returns the current timestamp (milliseconds since Unix epoch) wrapped in an IO monad for referential transparency.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Date.ts.md#2025-04-23_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const now: IO<number>\n```\n\n----------------------------------------\n\nTITLE: FromNullableK Type Definition\nDESCRIPTION: Type definition for converting functions returning nullable values into functions returning Either monads.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/EitherT.ts.md#2025-04-23_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare function fromNullableK<F extends URIS3>(\n  F: Pointed3<F>\n): <E>(\n  e: E\n) => <A extends ReadonlyArray<unknown>, B>(\n  f: (...a: A) => B | null | undefined\n) => <S, R>(...a: A) => Kind3<F, S, R, Either<E, NonNullable<B>>>\n```\n\n----------------------------------------\n\nTITLE: Defining URIS Type Alias for `* -> *` Constructors in TypeScript\nDESCRIPTION: Creates a type alias for the keys of the URItoKind interface, representing the available unary type constructors in the system.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/HKT.ts.md#2025-04-23_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nexport type URIS = keyof URItoKind<any>\n```\n\n----------------------------------------\n\nTITLE: Implementing isBoth Function for These in TypeScript\nDESCRIPTION: Defines a type guard function to check if a These value is an instance of Both.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/These.ts.md#2025-04-23_snippet_14\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare function isBoth<E, A>(fa: These<E, A>): fa is Both<E, A>\n```\n\n----------------------------------------\n\nTITLE: Defining MonadTask4 Interface in TypeScript\nDESCRIPTION: Defines the MonadTask4 interface extending MonadIO4 and FromTask4 for URIS4 type M.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/MonadTask.ts.md#2025-04-23_snippet_6\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport interface MonadTask4<M extends URIS4> extends MonadIO4<M>, FromTask4<M> {}\n```\n\n----------------------------------------\n\nTITLE: Deprecated ReadonlyNonEmptyArray Type Instance Definition\nDESCRIPTION: Defines a deprecated type instance that combines multiple typeclasses including Monad, Comonad, TraversableWithIndex, FunctorWithIndex, FoldableWithIndex, and Alt for ReadonlyNonEmptyArray type. Users should use specific instances like RNEA.Functor instead.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReadonlyNonEmptyArray.ts.md#2025-04-23_snippet_79\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const readonlyNonEmptyArray: Monad1<'ReadonlyNonEmptyArray'> &\n  Comonad1<'ReadonlyNonEmptyArray'> &\n  TraversableWithIndex1<'ReadonlyNonEmptyArray', number> &\n  FunctorWithIndex1<'ReadonlyNonEmptyArray', number> &\n  FoldableWithIndex1<'ReadonlyNonEmptyArray', number> &\n  Alt1<'ReadonlyNonEmptyArray'>\n```\n\n----------------------------------------\n\nTITLE: Creating Alt Instance for TaskValidation in TypeScript\nDESCRIPTION: Creates an Alt instance for TaskValidation, allowing concatenation of errors.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/TaskEither.ts.md#2025-04-23_snippet_18\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare function getAltTaskValidation<E>(S: Semigroup<E>): Alt2C<URI, E>\n```\n\n----------------------------------------\n\nTITLE: Implementing fromReaderK for StateReaderTaskEither in TypeScript\nDESCRIPTION: Defines a function to lift a Reader-returning function into the StateReaderTaskEither context.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/StateReaderTaskEither.ts.md#2025-04-23_snippet_31\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare const fromReaderK: <A extends readonly unknown[], R, B>(\n  f: (...a: A) => R.Reader<R, B>\n) => <S, E = never>(...a: A) => StateReaderTaskEither<S, R, E, B>\n```\n\n----------------------------------------\n\nTITLE: Defining PipeableFilterableWithIndex2 Interface in TypeScript\nDESCRIPTION: Interface definition for PipeableFilterableWithIndex2 which extends PipeableFilterable2 adding index-aware filtering operations for higher-kinded types of arity 2. Provides methods that include index information when filtering and partitioning.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/pipeable.ts.md#2025-04-23_snippet_47\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface PipeableFilterableWithIndex2<F extends URIS2, I> extends PipeableFilterable2<F> {\n  readonly filterWithIndex: {\n    <A, B extends A>(refinementWithIndex: RefinementWithIndex<I, A, B>): <E>(fa: Kind2<F, E, A>) => Kind2<F, E, B>\n    <A>(predicateWithIndex: PredicateWithIndex<I, A>): <E>(fa: Kind2<F, E, A>) => Kind2<F, E, A>\n  }\n  readonly filterMapWithIndex: <A, B>(f: (i: I, a: A) => Option<B>) => <E>(fa: Kind2<F, E, A>) => Kind2<F, E, B>\n  readonly partitionWithIndex: {\n    <A, B extends A>(refinementWithIndex: RefinementWithIndex<I, A, B>): <E>(\n      fa: Kind2<F, E, A>\n    ) => Separated<Kind2<F, E, A>, Kind2<F, E, B>>\n    <A>(predicateWithIndex: PredicateWithIndex<I, A>): <E>(\n      fa: Kind2<F, E, A>\n    ) => Separated<Kind2<F, E, A>, Kind2<F, E, A>>\n  }\n  readonly partitionMapWithIndex: <A, B, C>(\n    f: (i: I, a: A) => Either<B, C>\n  ) => <E>(fa: Kind2<F, E, A>) => Separated<Kind2<F, E, B>, Kind2<F, E, C>>\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Semigroup for Endomorphisms in TypeScript\nDESCRIPTION: Implements a function that returns a Semigroup instance for Endomorphism<A> where the concat operation is function composition.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Endomorphism.ts.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const getSemigroup: <A = never>() => Semigroup<Endomorphism<A>>\n```\n\n----------------------------------------\n\nTITLE: Defining PipeableFunctor3 Interface in TypeScript\nDESCRIPTION: A pipeable version of the Functor type class for higher-kinded types of arity 3. Provides the map method for functors with three type parameters.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/pipeable.ts.md#2025-04-23_snippet_67\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface PipeableFunctor3<F extends URIS3> {\n  readonly map: <A, B>(f: (a: A) => B) => <R, E>(fa: Kind3<F, R, E, A>) => Kind3<F, R, E, B>\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing ChainRec2 Interface for Second-Order Types in TypeScript\nDESCRIPTION: Defines the ChainRec2 interface for second-order type constructors. It extends Chain2 and provides chainRec for stack-safe recursion with Kind2<F, _, _> types.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ChainRec.ts.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface ChainRec2<F extends URIS2> extends Chain2<F> {\n  readonly chainRec: <E, A, B>(a: A, f: (a: A) => Kind2<F, E, Either<A, B>>) => Kind2<F, E, B>\n}\n```\n\n----------------------------------------\n\nTITLE: PureScript Choice Type Signatures\nDESCRIPTION: Core type signatures for the Choice typeclass left and right functions in PureScript notation.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Choice.ts.md#2025-04-23_snippet_0\n\nLANGUAGE: purescript\nCODE:\n```\nleft ::  forall input output a. p input output -> p (Either input a) (Either output a)\nright :: forall input output a. p input output -> p (Either a input) (Either a output)\n```\n\n----------------------------------------\n\nTITLE: Implementing FromThese3C Interface in TypeScript\nDESCRIPTION: Defines the FromThese3C interface for type constructors with three type parameters and a fixed error type. It includes a URI, an _E type parameter, and a fromThese method.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/FromThese.ts.md#2025-04-23_snippet_4\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport interface FromThese3C<F extends URIS3, E> {\n  readonly URI: F\n  readonly _E: E\n  readonly fromThese: <A, R>(fa: These<E, A>) => Kind3<F, R, E, A>\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing ChainRec2C Interface with Fixed Error Type in TypeScript\nDESCRIPTION: Defines the ChainRec2C interface for second-order type constructors with a fixed error type E. It extends Chain2C and provides chainRec for stack-safe recursion.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ChainRec.ts.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface ChainRec2C<F extends URIS2, E> extends Chain2C<F, E> {\n  readonly chainRec: <A, B>(a: A, f: (a: A) => Kind2<F, E, Either<A, B>>) => Kind2<F, E, B>\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Monad3 Interface for URIS3 in TypeScript\nDESCRIPTION: Defines the Monad3 interface for higher-kinded types with three type parameters. It extends Applicative3 and Chain3 interfaces.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Monad.ts.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface Monad3<M extends URIS3> extends Applicative3<M>, Chain3<M> {}\n```\n\n----------------------------------------\n\nTITLE: Defining PipeableFunctorWithIndex3 Interface in TypeScript\nDESCRIPTION: Extends PipeableFunctor3 to provide indexed mapping operations for arity 3 higher-kinded types. Adds the mapWithIndex method that receives both the index and value during mapping.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/pipeable.ts.md#2025-04-23_snippet_72\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface PipeableFunctorWithIndex3<F extends URIS3, I> extends PipeableFunctor3<F> {\n  readonly mapWithIndex: <A, B>(f: (i: I, a: A) => B) => <R, E>(fa: Kind3<F, R, E, A>) => Kind3<F, R, E, B>\n}\n```\n\n----------------------------------------\n\nTITLE: Right-to-left reduction of Records with index in fp-ts\nDESCRIPTION: Reduces a Record from right to left (in reverse key order) passing each key/value pair to the iterating function. Allows custom ordering of keys using an Ord instance.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Record.ts.md#2025-04-23_snippet_44\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare function reduceRightWithIndex(\n  O: Ord<string>\n): <K extends string, A, B>(b: B, f: (k: K, a: A, b: B) => B) => (fa: Record<K, A>) => B\nexport declare function reduceRightWithIndex<K extends string, A, B>(\n  b: B,\n  f: (k: K, a: A, b: B) => B\n): (fa: Record<K, A>) => B\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport { reduceRightWithIndex } from 'fp-ts/Record'\nimport { Ord } from 'fp-ts/string'\n\nconst x = { c: 3, a: 'foo', b: false }\nassert.deepStrictEqual(reduceRightWithIndex(Ord)([] as string[], (k, a, b) => [...b, `${k}-${a}`])(x), [\n  'c-3',\n  'b-false',\n  'a-foo',\n])\n```\n\n----------------------------------------\n\nTITLE: Implementing chainFirstTaskK in TypeScript for ReaderTaskEither\nDESCRIPTION: Alias of tapTask that executes a Task-returning side effect without changing the original value. It takes a function from A to Task<B> and returns a function that preserves the original value.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReaderTaskEither.ts.md#2025-04-23_snippet_36\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const chainFirstTaskK: <A, B>(\n  f: (a: A) => T.Task<B>\n) => <R, E>(first: ReaderTaskEither<R, E, A>) => ReaderTaskEither<R, E, A>\n```\n\n----------------------------------------\n\nTITLE: Defining PipeableFilterableWithIndex2C Interface in TypeScript\nDESCRIPTION: Interface definition for PipeableFilterableWithIndex2C which extends PipeableFilterable2C adding index-aware filtering operations for higher-kinded types of arity 2 with a fixed error type. Provides methods that include index information when filtering.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/pipeable.ts.md#2025-04-23_snippet_46\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface PipeableFilterableWithIndex2C<F extends URIS2, I, E> extends PipeableFilterable2C<F, E> {\n  readonly filterWithIndex: {\n    <A, B extends A>(refinementWithIndex: RefinementWithIndex<I, A, B>): (fa: Kind2<F, E, A>) => Kind2<F, E, B>\n    <A>(predicateWithIndex: PredicateWithIndex<I, A>): (fa: Kind2<F, E, A>) => Kind2<F, E, A>\n  }\n  readonly filterMapWithIndex: <A, B>(f: (i: I, a: A) => Option<B>) => (fa: Kind2<F, E, A>) => Kind2<F, E, B>\n  readonly partitionWithIndex: {\n    <A, B extends A>(refinementWithIndex: RefinementWithIndex<I, A, B>): (\n      fa: Kind2<F, E, A>\n    ) => Separated<Kind2<F, E, A>, Kind2<F, E, B>>\n    <A>(predicateWithIndex: PredicateWithIndex<I, A>): (fa: Kind2<F, E, A>) => Separated<Kind2<F, E, A>, Kind2<F, E, A>>\n  }\n  readonly partitionMapWithIndex: <A, B, C>(\n    f: (i: I, a: A) => Either<B, C>\n  ) => (fa: Kind2<F, E, A>) => Separated<Kind2<F, E, B>, Kind2<F, E, C>>\n}\n```\n\n----------------------------------------\n\nTITLE: Alternative Higher-Kinded Type Interfaces\nDESCRIPTION: Defines specialized Alternative interfaces for different higher-kinded types with varying type parameters.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Alternative.ts.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface Alternative1<F extends URIS> extends Applicative1<F>, Alt1<F>, Zero1<F> {}\n```\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface Alternative2<F extends URIS2> extends Applicative2<F>, Alt2<F>, Zero2<F> {}\n```\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface Alternative2C<F extends URIS2, E> extends Applicative2C<F, E>, Alt2C<F, E>, Zero2C<F, E> {}\n```\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface Alternative3<F extends URIS3> extends Applicative3<F>, Alt3<F>, Zero3<F> {}\n```\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface Alternative3C<F extends URIS3, E> extends Applicative3C<F, E>, Alt3C<F, E>, Zero3C<F, E> {}\n```\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface Alternative4<F extends URIS4> extends Applicative4<F>, Alt4<F>, Zero4<F> {}\n```\n\n----------------------------------------\n\nTITLE: Array Traverse with Index Operation in TypeScript\nDESCRIPTION: Implements ReadonlyArray#traverseWithIndex for ReaderEither, providing index access during traversal.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReaderEither.ts.md#2025-04-23_snippet_15\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const traverseArrayWithIndex: <R, E, A, B>(\n  f: (index: number, a: A) => ReaderEither<R, E, B>\n) => (as: readonly A[]) => ReaderEither<R, E, readonly B[]>\n```\n\n----------------------------------------\n\nTITLE: Type Class Instances - TypeScript\nDESCRIPTION: Type class instances for tuple operations including Bifunctor, Comonad, Foldable, Functor, Semigroupoid, and Traversable\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Tuple.ts.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const Bifunctor: Bifunctor2<'Tuple'>\nexport declare const Comonad: Comonad2<'Tuple'>\nexport declare const Foldable: Foldable2<'Tuple'>\nexport declare const Functor: Functor2<'Tuple'>\nexport declare const Semigroupoid: Semigroupoid2<'Tuple'>\nexport declare const Traversable: Traversable2<'Tuple'>\n```\n\n----------------------------------------\n\nTITLE: Augmenting URItoKind for Identity\nDESCRIPTION: Using TypeScript's module augmentation to add the Identity type to the URItoKind mapping. This allows the type system to associate the 'Identity' URI with the Identity type.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/guides/HKT.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\n// Identity.ts\n\ndeclare module 'fp-ts/HKT' {\n  interface URItoKind<A> {\n    readonly Identity: Identity<A> // maps the key \"Identity\" to the type `Identity`\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Converting from Reader to ReaderT\nDESCRIPTION: Utility function to lift a Reader computation into a ReaderT context, preserving the environment handling while adding the target monad's structure.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReaderT.ts.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare function fromReader<F extends URIS4>(\n  F: Pointed4<F>\n): <R, A, S, FR, FE>(ma: Reader<R, A>) => Reader<R, Kind4<F, S, FR, FE, A>>\n```\n\n----------------------------------------\n\nTITLE: Defining FunctorComposition23 Interface in TypeScript\nDESCRIPTION: Interface for composing a binary higher-kinded type with a ternary higher-kinded type, allowing complete flexibility in type parameters.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Functor.ts.md#2025-04-23_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface FunctorComposition23<F extends URIS2, G extends URIS3> {\n  readonly map: <FE, R, E, A, B>(fa: Kind2<F, FE, Kind3<G, R, E, A>>, f: (a: A) => B) => Kind2<F, FE, Kind3<G, R, E, B>>\n}\n```\n\n----------------------------------------\n\nTITLE: Defining PipeableMonadThrow2C Interface in TypeScript\nDESCRIPTION: A pipeable version of the MonadThrow type class for higher-kinded types of arity 2 with a fixed error type. Provides methods for working with error handling monads with a constrained error type.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/pipeable.ts.md#2025-04-23_snippet_77\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface PipeableMonadThrow2C<F extends URIS2, E> {\n  readonly fromOption: (onNone: LazyArg<E>) => <A>(ma: Option<A>) => Kind2<F, E, A>\n  readonly fromEither: <A>(ma: Either<E, A>) => Kind2<F, E, A>\n  readonly fromPredicate: {\n    <A, B extends A>(refinement: Refinement<A, B>, onFalse: (a: A) => E): (a: A) => Kind2<F, E, B>\n    <A>(predicate: Predicate<A>, onFalse: (a: A) => E): (a: A) => Kind2<F, E, A>\n  }\n  readonly filterOrElse: {\n    <A, B extends A>(refinement: Refinement<A, B>, onFalse: (a: A) => E): (ma: Kind2<F, E, A>) => Kind2<F, E, B>\n    <A>(predicate: Predicate<A>, onFalse: (a: A) => E): (ma: Kind2<F, E, A>) => Kind2<F, E, A>\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining FunctorWithIndex2 Interface for URIS2 in TypeScript\nDESCRIPTION: Interface for FunctorWithIndex with two type parameters, extending Functor2 with the mapWithIndex operation.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/FunctorWithIndex.ts.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface FunctorWithIndex2<F extends URIS2, I> extends Functor2<F> {\n  readonly mapWithIndex: <E, A, B>(fa: Kind2<F, E, A>, f: (i: I, a: A) => B) => Kind2<F, E, B>\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing duplicate for ReadonlyNonEmptyArray in TypeScript\nDESCRIPTION: Creates a new ReadonlyNonEmptyArray containing increasingly larger sub-arrays of the input ReadonlyNonEmptyArray.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReadonlyNonEmptyArray.ts.md#2025-04-23_snippet_40\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const duplicate: <A>(ma: ReadonlyNonEmptyArray<A>) => ReadonlyNonEmptyArray<ReadonlyNonEmptyArray<A>>\n```\n\n----------------------------------------\n\nTITLE: Defining Lattice Interface in TypeScript\nDESCRIPTION: Defines a Lattice interface that extends both JoinSemilattice and MeetSemilattice interfaces. A Lattice must satisfy absorption laws for meet and join operations in addition to the laws of the extended interfaces.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Lattice.ts.md#2025-04-23_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport interface Lattice<A> extends JoinSemilattice<A>, MeetSemilattice<A> {}\n```\n\n----------------------------------------\n\nTITLE: Implementing TaskThese Array Traversal with Index Sequential\nDESCRIPTION: Function that traverses a readonly array with index using sequential applicative. Takes a semigroup for error handling and returns a function that processes array elements with index.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/TaskThese.ts.md#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const traverseReadonlyArrayWithIndexSeq: <E>(\n  S: Semigroup<E>\n) => <A, B>(f: (index: number, a: A) => TaskThese<E, B>) => (as: readonly A[]) => TaskThese<E, readonly B[]>\n```\n\n----------------------------------------\n\nTITLE: Implementing a Name Gathering Program in TypeScript using fp-ts\nDESCRIPTION: A TypeScript implementation of the same name gathering program using fp-ts library. It uses the Task monad with Do notation helpers like bind, tap, and flatMap to sequence asynchronous operations similar to Haskell's do notation.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/Do.md#2025-04-23_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { pipe } from 'fp-ts/function'\nimport * as T from 'fp-ts/Task'\n\ndeclare const putStrLn: (s: string) => T.Task<void>\ndeclare const getLine: T.Task<string>\n\nconst nameDo: T.Task<void> = pipe(\n  T.Do,\n  T.tap(() => putStrLn('What is your first name? ')),\n  T.bind('first', () => getLine),\n  T.tap(() => putStrLn('And your last name? ')),\n  T.bind('last', () => getLine),\n  T.bind('full', ({ first, last }) => T.of(first + ' ' + last)),\n  T.flatMap(({ full }) => putStrLn('Pleased to meet you, ' + full + '!'))\n)\n```\n\n----------------------------------------\n\nTITLE: Tupled Function Implementation\nDESCRIPTION: Converts a function taking multiple arguments into one that accepts a single tuple argument.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/function.ts.md#2025-04-23_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare function tupled<A extends ReadonlyArray<unknown>, B>(f: (...a: A) => B): (a: A) => B\n```\n\n----------------------------------------\n\nTITLE: Implementing URItoKind3 Interface for `* -> * -> * -> *` Constructors in TypeScript\nDESCRIPTION: Defines an empty interface to be extended by specific implementations of ternary type constructors. Acts as a registry that maps URIs to their corresponding implementations.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/HKT.ts.md#2025-04-23_snippet_14\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface URItoKind3<R, E, A> {}\n```\n\n----------------------------------------\n\nTITLE: Defining Comonad3 Interface for URIS3 in TypeScript\nDESCRIPTION: Defines the Comonad3 interface extending Extend3 for higher-kinded types of arity 3, providing extract functionality.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Comonad.ts.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface Comonad3<W extends URIS3> extends Extend3<W> {\n  readonly extract: <R, E, A>(wa: Kind3<W, R, E, A>) => A\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Traversable Compatibility\nDESCRIPTION: Example showing how TraversableWithIndex must be compatible with standard Traverse operations.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/TraversableWithIndex.ts.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ntraverse(F)(ta, f) = traverseWithIndex(F)(ta, (_, a) => f(a))\n```\n\n----------------------------------------\n\nTITLE: Defining Applicative2C Interface with Fixed First Type Parameter\nDESCRIPTION: Specialized Applicative interface for binary type constructors where the first type parameter is fixed to type E.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Applicative.ts.md#2025-04-23_snippet_3\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport interface Applicative2C<F extends URIS2, E> extends Apply2C<F, E>, Pointed2C<F, E> {}\n```\n\n----------------------------------------\n\nTITLE: Defining FromIO2 Interface in TypeScript\nDESCRIPTION: Interface for lifting computations from the IO monad to a higher-kinded type F with two type parameters (error and value). Extends the capability to handle typed errors.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/FromIO.ts.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface FromIO2<F extends URIS2> {\n  readonly URI: F\n  readonly fromIO: <A, E>(fa: IO<A>) => Kind2<F, E, A>\n}\n```\n\n----------------------------------------\n\nTITLE: Defining FoldableWithIndexComposition22 Interface in TypeScript\nDESCRIPTION: Defines an interface for composing two FoldableWithIndex instances of URIS2 kind. It extends FoldableComposition22 and adds index-aware methods for reducing, folding, and right-reducing.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/FoldableWithIndex.ts.md#2025-04-23_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface FoldableWithIndexComposition22<F extends URIS2, FI, G extends URIS2, GI>\n  extends FoldableComposition22<F, G> {\n  readonly reduceWithIndex: <FE, GE, A, B>(\n    fga: Kind2<F, FE, Kind2<G, GE, A>>,\n    b: B,\n    f: (i: [FI, GI], b: B, a: A) => B\n  ) => B\n  readonly foldMapWithIndex: <M>(\n    M: Monoid<M>\n  ) => <FE, GE, A>(fga: Kind2<F, FE, Kind2<G, GE, A>>, f: (i: [FI, GI], a: A) => M) => M\n  readonly reduceRightWithIndex: <FE, GE, A, B>(\n    fga: Kind2<F, FE, Kind2<G, GE, A>>,\n    b: B,\n    f: (i: [FI, GI], a: A, b: B) => B\n  ) => B\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing FlatMapOption Function for IOOption in TypeScript\nDESCRIPTION: Defines the flatMapOption function for IOOption. It allows chaining operations with Option values on IOOption.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/IOOption.ts.md#2025-04-23_snippet_43\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const flatMapOption: {\n  <A, B>(f: (a: A) => O.Option<B>): (self: IOOption<A>) => IOOption<B>\n  <A, B>(self: IOOption<A>, f: (a: A) => O.Option<B>): IOOption<B>\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing fromTaskK for StateReaderTaskEither in TypeScript\nDESCRIPTION: Defines a function to lift a Task-returning function into the StateReaderTaskEither context.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/StateReaderTaskEither.ts.md#2025-04-23_snippet_35\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare const fromTaskK: <A extends readonly unknown[], B>(\n  f: (...a: A) => Task<B>\n) => <S, R = unknown, E = never>(...a: A) => StateReaderTaskEither<S, R, E, B>\n```\n\n----------------------------------------\n\nTITLE: Implementing Bifunctor4 Interface in TypeScript\nDESCRIPTION: Defines the Bifunctor4 interface for handling four-parameter type constructors. It includes methods for bimap and mapLeft operations using Kind4.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Bifunctor.ts.md#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface Bifunctor4<F extends URIS4> {\n  readonly URI: F\n  readonly bimap: <S, R, E, A, G, B>(fea: Kind4<F, S, R, E, A>, f: (e: E) => G, g: (a: A) => B) => Kind4<F, S, R, G, B>\n  readonly mapLeft: <S, R, E, A, G>(fea: Kind4<F, S, R, E, A>, f: (e: E) => G) => Kind4<F, S, R, G, A>\n}\n```\n\n----------------------------------------\n\nTITLE: Mapping Operations for ReadonlyTuple in TypeScript\nDESCRIPTION: Defines various mapping operations for ReadonlyTuple, including bimap, flap, map, mapFst, and mapSnd.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReadonlyTuple.ts.md#2025-04-23_snippet_6\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare const bimap: <E, G, A, B>(mapSnd: (e: E) => G, mapFst: (a: A) => B) => (fa: readonly [A, E]) => readonly [B, G]\n```\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare const flap: <A>(a: A) => <E, B>(fab: readonly [(a: A) => B, E]) => readonly [B, E]\n```\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare const map: <A, B>(f: (a: A) => B) => <E>(fa: readonly [A, E]) => readonly [B, E]\n```\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare const mapFst: <A, B>(f: (a: A) => B) => <E>(fa: readonly [A, E]) => readonly [B, E]\n```\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare const mapSnd: <E, G>(f: (e: E) => G) => <A>(fa: readonly [A, E]) => readonly [A, G]\n```\n\n----------------------------------------\n\nTITLE: Defining Comonad4 Interface for URIS4 in TypeScript\nDESCRIPTION: Defines the Comonad4 interface extending Extend4 for higher-kinded types of arity 4, providing extract functionality.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Comonad.ts.md#2025-04-23_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface Comonad4<W extends URIS4> extends Extend4<W> {\n  readonly extract: <S, R, E, A>(wa: Kind4<W, S, R, E, A>) => A\n}\n```\n\n----------------------------------------\n\nTITLE: Alternative Computation with Widening for TaskEither in TypeScript\nDESCRIPTION: A less strict version of alt that merges error and return types.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/TaskEither.ts.md#2025-04-23_snippet_17\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare const altW: <E2, B>(\n  that: LazyArg<TaskEither<E2, B>>\n) => <E1, A>(fa: TaskEither<E1, A>) => TaskEither<E2, B | A>\n```\n\n----------------------------------------\n\nTITLE: Implementing flattenW for StateReaderTaskEither in TypeScript\nDESCRIPTION: Provides a widening version of flatten (flattenW) that merges environment and error types when removing one level of monadic structure from a nested StateReaderTaskEither.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/StateReaderTaskEither.ts.md#2025-04-23_snippet_53\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare const flattenW: <S, R1, E1, R2, E2, A>(\n  mma: StateReaderTaskEither<S, R1, E1, StateReaderTaskEither<S, R2, E2, A>>\n) => StateReaderTaskEither<S, R1 & R2, E1 | E2, A>\n```\n\n----------------------------------------\n\nTITLE: Defining CompactableComposition2C1 Interface in TypeScript\nDESCRIPTION: This interface extends FunctorComposition2C1 and defines compact and separate methods for composing two higher-kinded types F and G, where F is of kind 2 and G is of kind 1, with an additional type parameter E.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Compactable.ts.md#2025-04-23_snippet_4\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport interface CompactableComposition2C1<F extends URIS2, G extends URIS, E> extends FunctorComposition2C1<F, G, E> {\n  readonly compact: <A>(fga: Kind2<F, E, Kind<G, Option<A>>>) => Kind2<F, E, Kind<G, A>>\n  readonly separate: <A, B>(\n    fge: Kind2<F, E, Kind<G, Either<A, B>>>\n  ) => Separated<Kind2<F, E, Kind<G, A>>, Kind2<F, E, Kind<G, B>>>\n}\n```\n\n----------------------------------------\n\nTITLE: Tell Function Implementation\nDESCRIPTION: Creates a Writer that appends a value to the accumulator while returning void.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Writer.ts.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const tell: <W>(w: W) => Writer<W, void>\n```\n\n----------------------------------------\n\nTITLE: ReaderTask Mapping Functions\nDESCRIPTION: Functions for transforming ReaderTask values including map, as, asUnit, and flap operations.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReaderTask.ts.md#2025-04-23_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const map: <A, B>(f: (a: A) => B) => <R>(fa: ReaderTask<R, A>) => ReaderTask<R, B>\n```\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const as: {\n  <A>(a: A): <R, _>(self: ReaderTask<R, _>) => ReaderTask<R, A>\n  <R, _, A>(self: ReaderTask<R, _>, a: A): ReaderTask<R, A>\n}\n```\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const asUnit: <R, _>(self: ReaderTask<R, _>) => ReaderTask<R, void>\n```\n\n----------------------------------------\n\nTITLE: Defining PipeableFunctorWithIndex3C Interface in TypeScript\nDESCRIPTION: Defines a pipeable interface for functor operations with index on 3-parameter higher-kinded types with a fixed error type. It extends PipeableFunctor3C and includes a method for mapping with index.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/pipeable.ts.md#2025-04-23_snippet_29\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport interface PipeableFunctorWithIndex3C<F extends URIS3, I, E> extends PipeableFunctor3C<F, E> {\n  readonly mapWithIndex: <A, B>(f: (i: I, a: A) => B) => <R>(fa: Kind3<F, R, E, A>) => Kind3<F, R, E, B>\n}\n```\n\n----------------------------------------\n\nTITLE: Getting All Elements Except First from ReadonlyNonEmptyArray in TypeScript\nDESCRIPTION: Function that returns all elements except the first one (tail) from a ReadonlyNonEmptyArray. The result is a regular array which may be empty if the input has only one element.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReadonlyNonEmptyArray.ts.md#2025-04-23_snippet_61\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const tail: <A>(as: ReadonlyNonEmptyArray<A>) => readonly A[]\n```\n\n----------------------------------------\n\nTITLE: Defining PipeableChain3 Interface in TypeScript\nDESCRIPTION: This interface extends PipeableApply3 and defines chain, chainFirst, and flatten operations for a higher-kinded type F with three type parameters.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/pipeable.ts.md#2025-04-23_snippet_35\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface PipeableChain3<F extends URIS3> extends PipeableApply3<F> {\n  readonly chain: <R, E, A, B>(f: (a: A) => Kind3<F, R, E, B>) => (ma: Kind3<F, R, E, A>) => Kind3<F, R, E, B>\n  readonly chainFirst: <R, E, A, B>(f: (a: A) => Kind3<F, R, E, B>) => (ma: Kind3<F, R, E, A>) => Kind3<F, R, E, A>\n  readonly flatten: <R, E, A>(mma: Kind3<F, R, E, Kind3<F, R, E, A>>) => Kind3<F, R, E, A>\n}\n```\n\n----------------------------------------\n\nTITLE: Defining MonadTask2 Interface in TypeScript\nDESCRIPTION: Defines the MonadTask2 interface extending MonadIO2 and FromTask2 for URIS2 type M.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/MonadTask.ts.md#2025-04-23_snippet_2\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport interface MonadTask2<M extends URIS2> extends MonadIO2<M>, FromTask2<M> {}\n```\n\n----------------------------------------\n\nTITLE: Tupled Function Usage Example\nDESCRIPTION: Example showing how to convert a two-parameter addition function into one accepting a tuple.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/function.ts.md#2025-04-23_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nimport { tupled } from 'fp-ts/function'\n\nconst add = tupled((x: number, y: number): number => x + y)\n\nassert.strictEqual(add([1, 2]), 3)\n```\n\n----------------------------------------\n\nTITLE: Implementing State Monad Gets Operation in TypeScript\nDESCRIPTION: Function signatures for transforming the current state using a mapping function. Supports multiple type hierarchy levels.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/FromState.ts.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare function gets<F extends URIS4>(F: FromState4<F>): <S, R, E, A>(f: (s: S) => A) => Kind4<F, S, R, E, A>\nexport declare function gets<F extends URIS3>(F: FromState3<F>): <S, E, A>(f: (s: S) => A) => Kind3<F, S, E, A>\nexport declare function gets<F extends URIS3, E>(F: FromState3C<F, E>): <S, A>(f: (s: S) => A) => Kind3<F, S, E, A>\nexport declare function gets<F extends URIS2>(F: FromState2<F>): <S, A>(f: (s: S) => A) => Kind2<F, S, A>\nexport declare function gets<F>(F: FromState<F>): <S, A>(f: (s: S) => A) => HKT2<F, S, A>\n```\n\n----------------------------------------\n\nTITLE: Month Equality Utility\nDESCRIPTION: Eq instance for comparing dates based only on their month component.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Date.ts.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const eqMonth: E.Eq<Date>\n```\n\n----------------------------------------\n\nTITLE: Declaring FoldableWithIndex for ReadonlyNonEmptyArray in TypeScript\nDESCRIPTION: Defines the FoldableWithIndex type class instance for ReadonlyNonEmptyArray with number index.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReadonlyNonEmptyArray.ts.md#2025-04-23_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const FoldableWithIndex: FoldableWithIndex1<'ReadonlyNonEmptyArray', number>\n```\n\n----------------------------------------\n\nTITLE: Defining FunctorComposition Interface in TypeScript\nDESCRIPTION: Base interface for composing two generic higher-kinded types using the HKT representation, providing the most general form of functor composition.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Functor.ts.md#2025-04-23_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface FunctorComposition<F, G> {\n  readonly map: <A, B>(fa: HKT<F, HKT<G, A>>, f: (a: A) => B) => HKT<F, HKT<G, B>>\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing chainReaderTaskEitherKW for StateReaderTaskEither in TypeScript\nDESCRIPTION: Defines chainReaderTaskEitherKW as a less strict version of chainReaderTaskEitherK. It merges error types when chaining a ReaderTaskEither operation.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/StateReaderTaskEither.ts.md#2025-04-23_snippet_20\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare const chainReaderTaskEitherKW: <R, E2, A, B>(\n  f: (a: A) => RTE.ReaderTaskEither<R, E2, B>\n) => <S, E1>(ma: StateReaderTaskEither<S, R, E1, A>) => StateReaderTaskEither<S, R, E2 | E1, B>\n```\n\n----------------------------------------\n\nTITLE: Example Usage of concatAll Function in TypeScript\nDESCRIPTION: Demonstrates how to use the concatAll function with a number Magma to perform subtraction on an array of numbers.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Magma.ts.md#2025-04-23_snippet_2\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { concatAll } from 'fp-ts/Magma'\nimport * as N from 'fp-ts/number'\n\nconst subAll = concatAll(N.MagmaSub)(0)\n\nassert.deepStrictEqual(subAll([1, 2, 3]), -6)\n```\n\n----------------------------------------\n\nTITLE: foldMapWithIndex Composition Utility\nDESCRIPTION: Utility function to compose foldMapWithIndex operations from two FoldableWithIndex instances, creating a combined index as a tuple [I, J].\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/FoldableWithIndex.ts.md#2025-04-23_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare function foldMapWithIndex<F extends URIS, I, G extends URIS, J>(\n  F: FoldableWithIndex1<F, I>,\n  G: FoldableWithIndex1<G, J>\n): <M>(M: Monoid<M>) => <A>(f: (ij: readonly [I, J], a: A) => M) => (fga: Kind<F, Kind<G, A>>) => M\nexport declare function foldMapWithIndex<F, I, G, J>(\n  F: FoldableWithIndex<F, I>,\n  G: FoldableWithIndex<G, J>\n): <M>(M: Monoid<M>) => <A>(f: (ij: readonly [I, J], a: A) => M) => (fga: HKT<F, HKT<G, A>>) => M\n```\n\n----------------------------------------\n\nTITLE: IOOption TapEither Implementation with Example - TypeScript\nDESCRIPTION: Implementation of tapEither with example showing how to compose computations using Either type while preserving only the first computation's result.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/IOOption.ts.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const tapEither: {\n  <A, E, _>(f: (a: A) => Either<E, _>): (self: IOOption<A>) => IOOption<A>\n  <A, E, _>(self: IOOption<A>, f: (a: A) => Either<E, _>): IOOption<A>\n}\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport { pipe } from 'fp-ts/function'\nimport * as IOO from 'fp-ts/IOOption'\nimport * as O from 'fp-ts/Option'\nimport * as E from 'fp-ts/Either'\n\nconst compute = (value: number) =>\n  pipe(\n    IOO.of(value),\n    IOO.tapEither((value) => (value > 0 ? E.right('ok') : E.left('error')))\n  )\n\nassert.deepStrictEqual(compute(1)(), O.of(1))\nassert.deepStrictEqual(compute(-1)(), O.none)\n```\n\n----------------------------------------\n\nTITLE: Writer Utility Functions\nDESCRIPTION: Core utility functions for working with Writer values including map, listen, pass, censor, evaluate and execute.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Writer.ts.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const map: <A, B>(f: (a: A) => B) => <E>(fa: Writer<E, A>) => Writer<E, B>\n\nexport declare const listen: <W, A>(fa: Writer<W, A>) => Writer<W, [A, W]>\n\nexport declare const pass: <W, A>(fa: Writer<W, [A, (w: W) => W]>) => Writer<W, A>\n\nexport declare const censor: <W>(f: (w: W) => W) => <A>(fa: Writer<W, A>) => Writer<W, A>\n\nexport declare const evaluate: <W, A>(fa: Writer<W, A>) => A\n\nexport declare const execute: <W, A>(fa: Writer<W, A>) => W\n```\n\n----------------------------------------\n\nTITLE: Array Traverse Operation in TypeScript\nDESCRIPTION: Implements ReadonlyArray#traverse for ReaderEither, mapping each element through a function and collecting results.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReaderEither.ts.md#2025-04-23_snippet_14\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const traverseArray: <R, E, A, B>(\n  f: (a: A) => ReaderEither<R, E, B>\n) => (as: readonly A[]) => ReaderEither<R, E, readonly B[]>\n```\n\n----------------------------------------\n\nTITLE: Implementing GCD Function in TypeScript\nDESCRIPTION: Function signature for calculating the greatest common divisor of two values in a Field, requiring both Eq and Field type constraints.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Field.ts.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare function gcd<A>(E: Eq<A>, field: Field<A>): (x: A, y: A) => A\n```\n\n----------------------------------------\n\nTITLE: Implementing MonadThrow4 Interface\nDESCRIPTION: Defines MonadThrow4 interface for four-parameter type constructors, extending Monad4 with error handling.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/MonadThrow.ts.md#2025-04-23_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface MonadThrow4<M extends URIS4> extends Monad4<M> {\n  readonly throwError: <S, R, E, A>(e: E) => Kind4<M, S, R, E, A>\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Invariant2C Interface in TypeScript\nDESCRIPTION: Constrained version of Invariant2 interface with fixed error type parameter E. Used for two-parameter higher-kinded types with constrained error type.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Invariant.ts.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface Invariant2C<F extends URIS2, E> {\n  readonly URI: F\n  readonly _E: E\n  readonly imap: <A, B>(fa: Kind2<F, E, A>, f: (a: A) => B, g: (b: B) => A) => Kind2<F, E, B>\n}\n```\n\n----------------------------------------\n\nTITLE: FP-TS Type Class Exports\nDESCRIPTION: TypeScript type declarations for functional programming type classes and models including functors, monads, and algebraic structures.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/index.ts.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const alt: typeof alt\nexport declare const alternative: typeof alternative\nexport declare const applicative: typeof applicative\nexport declare const apply: typeof apply\nexport declare const bifunctor: typeof bifunctor\nexport declare const booleanAlgebra: typeof booleanAlgebra\nexport declare const bounded: typeof bounded\nexport declare const boundedDistributiveLattice: typeof boundedDistributiveLattice\nexport declare const boundedJoinSemilattice: typeof boundedJoinSemilattice\nexport declare const boundedLattice: typeof boundedLattice\nexport declare const boundedMeetSemilattice: typeof boundedMeetSemilattice\nexport declare const category: typeof category\nexport declare const chain: typeof chain\nexport declare const chainRec: typeof chainRec\nexport declare const choice: typeof choice\nexport declare const comonad: typeof comonad\nexport declare const compactable: typeof compactable\nexport declare const contravariant: typeof contravariant\n```\n\n----------------------------------------\n\nTITLE: StateM3C Interface Definition in TypeScript\nDESCRIPTION: Interface definition for State Monad Transformer with URIS3 and error type E. Extends functionality to handle an additional type parameter R.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/StateT.ts.md#2025-04-23_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface StateM3C<M extends URIS3, E> {\n  readonly map: <S, R, A, B>(fa: StateT3<M, S, R, E, A>, f: (a: A) => B) => StateT3<M, S, R, E, B>\n  readonly of: <S, R, A>(a: A) => StateT3<M, S, R, E, A>\n  readonly ap: <S, R, A, B>(fab: StateT3<M, S, R, E, (a: A) => B>, fa: StateT3<M, S, R, E, A>) => StateT3<M, S, R, E, B>\n  readonly chain: <S, R, A, B>(\n    fa: StateT3<M, S, R, E, A>,\n    f: (a: A) => StateT3<M, S, R, E, B>\n  ) => StateT3<M, S, R, E, B>\n  readonly get: <R, S>() => StateT3<M, S, R, E, S>\n  readonly put: <R, S>(s: S) => StateT3<M, S, R, E, void>\n  readonly modify: <R, S>(f: (s: S) => S) => StateT3<M, S, R, E, void>\n  readonly gets: <S, R, A>(f: (s: S) => A) => StateT3<M, S, R, E, A>\n  readonly fromState: <S, R, A>(fa: State<S, A>) => StateT3<M, S, R, E, A>\n  readonly fromM: <S, R, A>(ma: Kind3<M, R, E, A>) => StateT3<M, S, R, E, A>\n  readonly evalState: <S, R, A>(ma: StateT3<M, S, R, E, A>, s: S) => Kind3<M, R, E, A>\n  readonly execState: <S, R, A>(ma: StateT3<M, S, R, E, A>, s: S) => Kind3<M, R, E, S>\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Applicative instance for Either in TypeScript\nDESCRIPTION: Declares the Applicative type class instance for Either.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Either.ts.md#2025-04-23_snippet_22\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare const Applicative: Applicative2<'Either'>\n```\n\n----------------------------------------\n\nTITLE: Implementing TaskThese Non-Empty Array Traversal with Index\nDESCRIPTION: Function for traversing a readonly non-empty array with index using parallel applicative. Takes a semigroup for error handling and processes non-empty arrays.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/TaskThese.ts.md#2025-04-23_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const traverseReadonlyNonEmptyArrayWithIndex: <E>(\n  S: Semigroup<E>\n) => <A, B>(\n  f: (index: number, a: A) => TaskThese<E, B>\n) => (as: ReadonlyNonEmptyArray<A>) => TaskThese<E, ReadonlyNonEmptyArray<B>>\n```\n\n----------------------------------------\n\nTITLE: Implementing flatMapTask for StateReaderTaskEither in TypeScript\nDESCRIPTION: Provides flatMapTask function that allows mapping from a StateReaderTaskEither to a Task monad and flattening the result, supporting both pipeable and non-pipeable patterns.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/StateReaderTaskEither.ts.md#2025-04-23_snippet_50\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare const flatMapTask: {\n  <A, B>(f: (a: A) => Task<B>): <S, R, E>(self: StateReaderTaskEither<S, R, E, A>) => StateReaderTaskEither<S, R, E, B>\n  <S, R, E, A, B>(self: StateReaderTaskEither<S, R, E, A>, f: (a: A) => Task<B>): StateReaderTaskEither<S, R, E, B>\n}\n```\n\n----------------------------------------\n\nTITLE: Defining FunctorComposition23C Interface in TypeScript\nDESCRIPTION: Interface for composing a binary higher-kinded type with a ternary higher-kinded type, with a fixed middle type parameter for the inner functor G.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Functor.ts.md#2025-04-23_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface FunctorComposition23C<F extends URIS2, G extends URIS3, E> {\n  readonly map: <FE, R, A, B>(fa: Kind2<F, FE, Kind3<G, R, E, A>>, f: (a: A) => B) => Kind2<F, FE, Kind3<G, R, E, B>>\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Fold Function for IOOption in TypeScript\nDESCRIPTION: Defines the fold function for IOOption, which is an alias of matchE. It allows pattern matching on IOOption values.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/IOOption.ts.md#2025-04-23_snippet_34\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const fold: <B, A>(onNone: () => I.IO<B>, onSome: (a: A) => I.IO<B>) => (ma: IOOption<A>) => I.IO<B>\n```\n\n----------------------------------------\n\nTITLE: FoldableWithIndex2C Interface with Fixed Error Type\nDESCRIPTION: Interface for FoldableWithIndex specialized for Kind2<F, E, A> types with a fixed error type E, extending Foldable2C.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/FoldableWithIndex.ts.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface FoldableWithIndex2C<F extends URIS2, I, E> extends Foldable2C<F, E> {\n  readonly reduceWithIndex: <A, B>(fa: Kind2<F, E, A>, b: B, f: (i: I, b: B, a: A) => B) => B\n  readonly foldMapWithIndex: <M>(M: Monoid<M>) => <A>(fa: Kind2<F, E, A>, f: (i: I, a: A) => M) => M\n  readonly reduceRightWithIndex: <A, B>(fa: Kind2<F, E, A>, b: B, f: (i: I, a: A, b: B) => B) => B\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing fromIOK for IO Lifting\nDESCRIPTION: Transforms a function returning an IO into a function returning a ReaderTaskEither, lifting synchronous side-effect computations without error handling.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReaderTaskEither.ts.md#2025-04-23_snippet_64\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const fromIOK: <A extends readonly unknown[], B>(\n  f: (...a: A) => IO<B>\n) => <R = unknown, E = never>(...a: A) => ReaderTaskEither<R, E, B>\n```\n\n----------------------------------------\n\nTITLE: Implementing MonadIO2 Interface for URIS2 Types\nDESCRIPTION: Extends the MonadIO pattern to support higher-kinded types with two type parameters (URIS2).\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/MonadIO.ts.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface MonadIO2<M extends URIS2> extends Monad2<M>, FromIO2<M> {}\n```\n\n----------------------------------------\n\nTITLE: reduceWithIndex Composition Utility\nDESCRIPTION: Utility function to compose reduceWithIndex operations from two FoldableWithIndex instances, creating a combined index as a tuple [I, J].\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/FoldableWithIndex.ts.md#2025-04-23_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare function reduceWithIndex<F extends URIS, I, G extends URIS, J>(\n  F: FoldableWithIndex1<F, I>,\n  G: FoldableWithIndex1<G, J>\n): <B, A>(b: B, f: (ij: readonly [I, J], b: B, a: A) => B) => (fga: Kind<F, Kind<G, A>>) => B\nexport declare function reduceWithIndex<F, I, G, J>(\n  F: FoldableWithIndex<F, I>,\n  G: FoldableWithIndex<G, J>\n): <B, A>(b: B, f: (ij: readonly [I, J], b: B, a: A) => B) => (fga: HKT<F, HKT<G, A>>) => B\n```\n\n----------------------------------------\n\nTITLE: Defining Applicative3 Interface for Ternary Type Constructors\nDESCRIPTION: Specialized Applicative interface for type constructors with three type parameters, using the URIS3 system for higher-kinded types.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Applicative.ts.md#2025-04-23_snippet_4\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport interface Applicative3<F extends URIS3> extends Apply3<F>, Pointed3<F> {}\n```\n\n----------------------------------------\n\nTITLE: Mapping Error Channel of TaskEither in TypeScript\nDESCRIPTION: Maps the error channel of a TaskEither.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/TaskEither.ts.md#2025-04-23_snippet_23\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare const mapError: {\n  <E, G>(f: (e: E) => G): <A>(self: TaskEither<E, A>) => TaskEither<G, A>\n  <E, A, G>(self: TaskEither<E, A>, f: (e: E) => G): TaskEither<G, A>\n}\n```\n\n----------------------------------------\n\nTITLE: Less Than or Equal Function for Ord in TypeScript\nDESCRIPTION: Creates a function to test whether one value is non-strictly less than another using an Ord instance.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Ord.ts.md#2025-04-23_snippet_17\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const leq: <A>(O: Ord<A>) => (first: A, second: A) => boolean\n```\n\n----------------------------------------\n\nTITLE: Implementing getShow for ReadonlyNonEmptyArray in TypeScript\nDESCRIPTION: Creates a Show instance for ReadonlyNonEmptyArray given a Show instance for its elements.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReadonlyNonEmptyArray.ts.md#2025-04-23_snippet_16\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const getShow: <A>(S: Show<A>) => Show<ReadonlyNonEmptyArray<A>>\n```\n\n----------------------------------------\n\nTITLE: Defining PipeableProfunctor3C Interface in TypeScript\nDESCRIPTION: Defines a pipeable interface for profunctor operations on 3-parameter higher-kinded types with a fixed error type. It extends PipeableFunctor3C and includes a method for promap.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/pipeable.ts.md#2025-04-23_snippet_31\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport interface PipeableProfunctor3C<F extends URIS3, E> extends PipeableFunctor3C<F, E> {\n  readonly promap: <R, A, D, B>(f: (d: D) => E, g: (a: A) => B) => (fbc: Kind3<F, R, E, A>) => Kind3<F, R, D, B>\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Functor Instance for Traced\nDESCRIPTION: Functor type class instance for the Traced type constructor.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Traced.ts.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const Functor: Functor2<'Traced'>\n```\n\n----------------------------------------\n\nTITLE: Defining traverseSeqArrayWithIndex Operation for ReaderTaskEither in TypeScript\nDESCRIPTION: Function signature for traverseSeqArrayWithIndex that maps an array of values to a ReaderTaskEither using both the index and value, then sequences the results sequentially. Equivalent to ReadonlyArray#traverseWithIndex(ApplicativeSeq). Added in v2.9.0.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReaderTaskEither.ts.md#2025-04-23_snippet_107\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const traverseSeqArrayWithIndex: <R, E, A, B>(\n  f: (index: number, a: A) => ReaderTaskEither<R, E, B>\n) => (as: readonly A[]) => ReaderTaskEither<R, E, readonly B[]>\n```\n\n----------------------------------------\n\nTITLE: Defining traverseArray function for ReaderIO in TypeScript\nDESCRIPTION: Maps each element of an array to a ReaderIO and collects the results. It's equivalent to ReadonlyArray#traverse(Applicative).\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReaderIO.ts.md#2025-04-23_snippet_16\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const traverseArray: <A, R, B>(\n  f: (a: A) => ReaderIO<R, B>\n) => (as: readonly A[]) => ReaderIO<R, readonly B[]>\n```\n\n----------------------------------------\n\nTITLE: Defining Kind2 Type Alias for `* -> * -> *` Constructors in TypeScript\nDESCRIPTION: Creates a type alias for binary type constructors, which maps a URI (type identifier) to its corresponding type implementation with two type parameters.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/HKT.ts.md#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nexport type Kind2<URI extends URIS2, E, A> = URI extends URIS2 ? URItoKind2<E, A>[URI] : any\n```\n\n----------------------------------------\n\nTITLE: Implementing filterOrElse Type Definitions in TypeScript\nDESCRIPTION: Defines type signatures for filterOrElse function that works with different URIS (type hierarchy) levels. Handles filtering with fallback error cases using Either type.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/FromEither.ts.md#2025-04-23_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare function filterOrElse<M extends URIS4>(\n  F: FromEither4<M>,\n  M: Chain4<M>\n): {\n  <A, B extends A, E>(refinement: Refinement<A, B>, onFalse: (a: A) => E): <S, R>(\n    ma: Kind4<M, S, R, E, A>\n  ) => Kind4<M, S, R, E, B>\n  <A, E>(predicate: Predicate<A>, onFalse: (a: A) => E): <S, R, B extends A>(\n    mb: Kind4<M, S, R, E, B>\n  ) => Kind4<M, S, R, E, B>\n  <A, E>(predicate: Predicate<A>, onFalse: (a: A) => E): <S, R>(ma: Kind4<M, S, R, E, A>) => Kind4<M, S, R, E, A>\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing MonadThrow1 Interface\nDESCRIPTION: Defines MonadThrow1 interface for single-parameter type constructors, extending Monad1 with error handling.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/MonadThrow.ts.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface MonadThrow1<M extends URIS> extends Monad1<M> {\n  readonly throwError: <E, A>(e: E) => Kind<M, A>\n}\n```\n\n----------------------------------------\n\nTITLE: Defining PipeableFoldableWithIndex1 Interface in TypeScript\nDESCRIPTION: Extends PipeableFoldable1 to provide indexed folding operations for arity 1 higher-kinded types. Adds methods that receive the index along with values during folding operations.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/pipeable.ts.md#2025-04-23_snippet_57\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface PipeableFoldableWithIndex1<F extends URIS, I> extends PipeableFoldable1<F> {\n  readonly reduceWithIndex: <A, B>(b: B, f: (i: I, b: B, a: A) => B) => (fa: Kind<F, A>) => B\n  readonly foldMapWithIndex: <M>(M: Monoid<M>) => <A>(f: (i: I, a: A) => M) => (fa: Kind<F, A>) => M\n  readonly reduceRightWithIndex: <A, B>(b: B, f: (i: I, a: A, b: B) => B) => (fa: Kind<F, A>) => B\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing bindTo for StateReaderTaskEither in TypeScript\nDESCRIPTION: Provides bindTo function that assigns a StateReaderTaskEither value to a named property in a record, creating a new StateReaderTaskEither of a record with that single property.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/StateReaderTaskEither.ts.md#2025-04-23_snippet_68\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare const bindTo: <N>(\n  name: N\n) => <S, R, E, A>(fa: StateReaderTaskEither<S, R, E, A>) => StateReaderTaskEither<S, R, E, { readonly [K in N]: A }>\n```\n\n----------------------------------------\n\nTITLE: Implementing fromIOK for StateReaderTaskEither in TypeScript\nDESCRIPTION: Defines a function to lift an IO-returning function into the StateReaderTaskEither context.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/StateReaderTaskEither.ts.md#2025-04-23_snippet_28\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare const fromIOK: <A extends readonly unknown[], B>(\n  f: (...a: A) => IO<B>\n) => <S, R = unknown, E = never>(...a: A) => StateReaderTaskEither<S, R, E, B>\n```\n\n----------------------------------------\n\nTITLE: Implementing FlatMapEither Function for IOOption in TypeScript\nDESCRIPTION: Defines the flatMapEither function for IOOption. It allows chaining operations with Either values on IOOption.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/IOOption.ts.md#2025-04-23_snippet_40\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const flatMapEither: {\n  <A, B, _>(f: (a: A) => Either<_, B>): (self: IOOption<A>) => IOOption<B>\n  <A, B, _>(self: IOOption<A>, f: (a: A) => Either<_, B>): IOOption<B>\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing left Utility Function for Separated in TypeScript\nDESCRIPTION: Defines the left utility function, which extracts the left part of a Separated instance.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Separated.ts.md#2025-04-23_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const left: <E, A>(s: Separated<E, A>) => E\n```\n\n----------------------------------------\n\nTITLE: MapLeft Operation Type Definition\nDESCRIPTION: Type definition for mapping over Left values in Either monad context while preserving the structure.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/EitherT.ts.md#2025-04-23_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare function mapLeft<F extends URIS3>(\n  F: Functor3<F>\n): <E, G>(f: (e: E) => G) => <R, FE, A>(self: Kind3<F, R, FE, Either<E, A>>) => Kind3<F, R, FE, Either<G, A>>\n```\n\n----------------------------------------\n\nTITLE: Defining partitionMapWithIndex Pipeable Function in TypeScript\nDESCRIPTION: Creates a pipeable partitionMapWithIndex function that supports various arity levels (URIS1-4) in the fp-ts library. This function transforms elements with access to their indices and separates them based on Either results.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/pipeable.ts.md#2025-04-23_snippet_18\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare function partitionMapWithIndex<F extends URIS4, I>(\n  F: FilterableWithIndex4<F, I>\n): <A, B, C>(\n  f: (i: I, a: A) => Either<B, C>\n) => <S, R, E>(fa: Kind4<F, S, R, E, A>) => Separated<Kind4<F, S, R, E, B>, Kind4<F, S, R, E, C>>\nexport declare function partitionMapWithIndex<F extends URIS3, I>(\n  F: FilterableWithIndex3<F, I>\n): <A, B, C>(\n  f: (i: I, a: A) => Either<B, C>\n) => <R, E>(fa: Kind3<F, R, E, A>) => Separated<Kind3<F, R, E, B>, Kind3<F, R, E, C>>\nexport declare function partitionMapWithIndex<F extends URIS3, I, E>(\n  F: FilterableWithIndex3C<F, I, E>\n): <A, B, C>(\n  f: (i: I, a: A) => Either<B, C>\n) => <R>(fa: Kind3<F, R, E, A>) => Separated<Kind3<F, R, E, B>, Kind3<F, R, E, C>>\nexport declare function partitionMapWithIndex<F extends URIS2, I>(\n  F: FilterableWithIndex2<F, I>\n): <A, B, C>(f: (i: I, a: A) => Either<B, C>) => <E>(fa: Kind2<F, E, A>) => Separated<Kind2<F, E, B>, Kind2<F, E, C>>\nexport declare function partitionMapWithIndex<F extends URIS2, I, E>(\n  F: FilterableWithIndex2C<F, I, E>\n): <A, B, C>(f: (i: I, a: A) => Either<B, C>) => (fa: Kind2<F, E, A>) => Separated<Kind2<F, E, B>, Kind2<F, E, C>>\nexport declare function partitionMapWithIndex<F extends URIS, I>(\n  F: FilterableWithIndex1<F, I>\n): <A, B, C>(f: (i: I, a: A) => Either<B, C>) => (fa: Kind<F, A>) => Separated<Kind<F, B>, Kind<F, C>>\nexport declare function partitionMapWithIndex<F, I>(\n  F: FilterableWithIndex<F, I>\n): <A, B, C>(f: (i: I, a: A) => Either<B, C>) => (fa: HKT<F, A>) => Separated<HKT<F, B>, HKT<F, C>>\n```\n\n----------------------------------------\n\nTITLE: Implementing map Function for Separated in TypeScript\nDESCRIPTION: Defines the map function, which can be used to turn functions (a: A) => B into functions (fa: F<A>) => F<B> whose argument and return types use the type constructor F to represent some computational context.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Separated.ts.md#2025-04-23_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const map: <A, B>(f: (a: A) => B) => <E>(fa: Separated<E, A>) => Separated<E, B>\n```\n\n----------------------------------------\n\nTITLE: Defining Invariant1 Interface in TypeScript\nDESCRIPTION: Interface for Invariant type class with one type parameter constrained to URIS. Used for higher-kinded types with single type parameter.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Invariant.ts.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface Invariant1<F extends URIS> {\n  readonly URI: F\n  readonly imap: <A, B>(fa: Kind<F, A>, f: (a: A) => B, g: (b: B) => A) => Kind<F, B>\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Task URI (TypeScript)\nDESCRIPTION: Constant and type alias for the Task URI, used for type identification in fp-ts.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Task.ts.md#2025-04-23_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const URI: 'Task'\nexport type URI = typeof URI\n```\n\n----------------------------------------\n\nTITLE: Defining FunctorCompositionHKT1 Interface in TypeScript\nDESCRIPTION: Interface for composing a generic higher-kinded type with a unary higher-kinded type using the HKT representation.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Functor.ts.md#2025-04-23_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface FunctorCompositionHKT1<F, G extends URIS> {\n  readonly map: <A, B>(fa: HKT<F, Kind<G, A>>, f: (a: A) => B) => HKT<F, Kind<G, B>>\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Kind3 Type Alias for `* -> * -> * -> *` Constructors in TypeScript\nDESCRIPTION: Creates a type alias for ternary type constructors, which maps a URI (type identifier) to its corresponding type implementation with three type parameters.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/HKT.ts.md#2025-04-23_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nexport type Kind3<URI extends URIS3, R, E, A> = URI extends URIS3 ? URItoKind3<R, E, A>[URI] : any\n```\n\n----------------------------------------\n\nTITLE: Creating Semiring instance for Const in TypeScript\nDESCRIPTION: Creates a Semiring instance for Const given a Semiring for the first type parameter. This provides addition and multiplication operations.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Const.ts.md#2025-04-23_snippet_15\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const getSemiring: <E, A>(S: Semiring<E>) => Semiring<Const<E, A>>\n```\n\n----------------------------------------\n\nTITLE: Implementing flatMapTaskEither for StateReaderTaskEither in TypeScript\nDESCRIPTION: Provides flatMapTaskEither function that allows mapping from a StateReaderTaskEither to a TaskEither and flattening the result, with both pipeable and non-pipeable usage patterns.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/StateReaderTaskEither.ts.md#2025-04-23_snippet_51\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare const flatMapTaskEither: {\n  <A, E2, B>(f: (a: A) => TaskEither<E2, B>): <S, R, E1>(\n    self: StateReaderTaskEither<S, R, E1, A>\n  ) => StateReaderTaskEither<S, R, E2 | E1, B>\n  <S, R, E1, A, E2, B>(self: StateReaderTaskEither<S, R, E1, A>, f: (a: A) => TaskEither<E2, B>): StateReaderTaskEither<\n    S,\n    R,\n    E1 | E2,\n    B\n  >\n}\n```\n\n----------------------------------------\n\nTITLE: Traversing Readonly Reader Array with Index in TypeScript\nDESCRIPTION: Implements traverseReadonlyArrayWithIndex for Reader, equivalent to ReadonlyArray#traverseWithIndex(Applicative). It's similar to traverseArrayWithIndex but specifically for readonly arrays.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Reader.ts.md#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const traverseReadonlyArrayWithIndex: <A, R, B>(\n  f: (index: number, a: A) => Reader<R, B>\n) => (as: readonly A[]) => Reader<R, readonly B[]>\n```\n\n----------------------------------------\n\nTITLE: Defining Contravariant instance for Const in TypeScript\nDESCRIPTION: Provides the Contravariant type class instance for Const, enabling contravariant mapping over the second type parameter.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Const.ts.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const Contravariant: Contravariant2<'Const'>\n```\n\n----------------------------------------\n\nTITLE: Defining PipeableMonadThrow3C Interface in TypeScript\nDESCRIPTION: Defines a pipeable interface for monad throw operations on 3-parameter higher-kinded types with a fixed error type. It includes methods for handling Options, Eithers, predicates, and filtering.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/pipeable.ts.md#2025-04-23_snippet_30\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport interface PipeableMonadThrow3C<F extends URIS3, E> {\n  readonly fromOption: (onNone: LazyArg<E>) => <R, A>(ma: Option<A>) => Kind3<F, R, E, A>\n  readonly fromEither: <R, A>(ma: Either<E, A>) => Kind3<F, R, E, A>\n  readonly fromPredicate: {\n    <A, B extends A>(refinement: Refinement<A, B>, onFalse: (a: A) => E): <U>(a: A) => Kind3<F, U, E, B>\n    <A>(predicate: Predicate<A>, onFalse: (a: A) => E): <R>(a: A) => Kind3<F, R, E, A>\n  }\n  readonly filterOrElse: {\n    <A, B extends A>(refinement: Refinement<A, B>, onFalse: (a: A) => E): <R>(\n      ma: Kind3<F, R, E, A>\n    ) => Kind3<F, R, E, B>\n    <A>(predicate: Predicate<A>, onFalse: (a: A) => E): <R>(ma: Kind3<F, R, E, A>) => Kind3<F, R, E, A>\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating throwError function for ReaderTaskEither in TypeScript\nDESCRIPTION: Implements a function that creates a ReaderTaskEither instance representing a failure with the given error value.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReaderTaskEither.ts.md#2025-04-23_snippet_120\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const throwError: <R, E, A>(e: E) => ReaderTaskEither<R, E, A>\n```\n\n----------------------------------------\n\nTITLE: Defining URIS3 Type Alias for `* -> * -> * -> *` Constructors in TypeScript\nDESCRIPTION: Creates a type alias for the keys of the URItoKind3 interface, representing the available ternary type constructors in the system.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/HKT.ts.md#2025-04-23_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\nexport type URIS3 = keyof URItoKind3<any, any, any>\n```\n\n----------------------------------------\n\nTITLE: Defining PredicateWithIndex Type in TypeScript\nDESCRIPTION: Type alias for a predicate function that takes both an index and a value, returning a boolean.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/FilterableWithIndex.ts.md#2025-04-23_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nexport type PredicateWithIndex<I, A> = (i: I, a: A) => boolean\n```\n\n----------------------------------------\n\nTITLE: Implementing liftOption for Handling Option Values in TypeScript\nDESCRIPTION: Creates a function that transforms an Option-returning function into a TaskEither-returning function, using onNone to handle None values.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/TaskEither.ts.md#2025-04-23_snippet_55\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const liftOption: <A extends readonly unknown[], B, E>(\n  f: (...a: A) => Option<B>,\n  onNone: (...a: A) => E\n) => (...a: A) => TaskEither<E, B>\n```\n\n----------------------------------------\n\nTITLE: Creating Compactable Instance for Record in TypeScript\nDESCRIPTION: Defines a Compactable instance for the Record type in fp-ts. Compactable provides operations to remove None values from a structure.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Record.ts.md#2025-04-23_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const Compactable: Compactable1<'Record'>\n```\n\n----------------------------------------\n\nTITLE: Defining PipeableFilterableWithIndex3C Interface in TypeScript\nDESCRIPTION: Defines a pipeable interface for filterable operations with index for 3-parameter higher-kinded types with a fixed error type. It extends PipeableFilterable3C and includes methods for filtering, mapping, and partitioning with index.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/pipeable.ts.md#2025-04-23_snippet_25\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport interface PipeableFilterableWithIndex3C<F extends URIS3, I, E> extends PipeableFilterable3C<F, E> {\n  readonly filterWithIndex: {\n    <A, B extends A>(refinementWithIndex: RefinementWithIndex<I, A, B>): <R>(fa: Kind3<F, R, E, A>) => Kind3<F, R, E, B>\n    <A>(predicateWithIndex: PredicateWithIndex<I, A>): <R, E>(fa: Kind3<F, R, E, A>) => Kind3<F, R, E, A>\n  }\n  readonly filterMapWithIndex: <A, B>(f: (i: I, a: A) => Option<B>) => <R>(fa: Kind3<F, R, E, A>) => Kind3<F, R, E, A>\n  readonly partitionWithIndex: {\n    <A, B extends A>(refinementWithIndex: RefinementWithIndex<I, A, B>): <R>(\n      fa: Kind3<F, R, E, A>\n    ) => Separated<Kind3<F, R, E, A>, Kind3<F, R, E, B>>\n    <A>(predicateWithIndex: PredicateWithIndex<I, A>): <R>(\n      fa: Kind3<F, R, E, A>\n    ) => Separated<Kind3<F, R, E, A>, Kind3<F, R, E, A>>\n  }\n  readonly partitionMapWithIndex: <A, B, C>(\n    f: (i: I, a: A) => Either<B, C>\n  ) => <R>(fa: Kind3<F, R, E, A>) => Separated<Kind3<F, R, E, B>, Kind3<F, R, E, C>>\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Category4 Interface in TypeScript\nDESCRIPTION: Defines Category4 interface extending Semigroupoid4 with URIS4 constraint. Includes an identity function returning Kind4 type with additional type parameters S and R.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Category.ts.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface Category4<F extends URIS4> extends Semigroupoid4<F> {\n  readonly id: <S, R, A>() => Kind4<F, S, R, A, A>\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Foldable3 Interface in TypeScript\nDESCRIPTION: Type class definition for Foldable with three type parameters using URIS3, supporting data structures with reader, error, and value types.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Foldable.ts.md#2025-04-23_snippet_4\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport interface Foldable3<F extends URIS3> {\n  readonly URI: F\n  readonly reduce: <R, E, A, B>(fa: Kind3<F, R, E, A>, b: B, f: (b: B, a: A) => B) => B\n  readonly foldMap: <M>(M: Monoid<M>) => <R, E, A>(fa: Kind3<F, R, E, A>, f: (a: A) => M) => M\n  readonly reduceRight: <R, E, A, B>(fa: Kind3<F, R, E, A>, b: B, f: (a: A, b: B) => B) => B\n}\n```\n\n----------------------------------------\n\nTITLE: Defining traverseArrayWithIndex function for ReaderIO in TypeScript\nDESCRIPTION: Maps each element of an array to a ReaderIO using both the element and its index. It's equivalent to ReadonlyArray#traverseWithIndex(Applicative).\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReaderIO.ts.md#2025-04-23_snippet_17\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const traverseArrayWithIndex: <A, R, B>(\n  f: (index: number, a: A) => ReaderIO<R, B>\n) => (as: readonly A[]) => ReaderIO<R, readonly B[]>\n```\n\n----------------------------------------\n\nTITLE: Defining PipeableFoldable3C Interface in TypeScript\nDESCRIPTION: Defines a pipeable interface for foldable operations on 3-parameter higher-kinded types with a fixed error type. It includes methods for reduce, foldMap, and reduceRight.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/pipeable.ts.md#2025-04-23_snippet_26\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport interface PipeableFoldable3C<F extends URIS3, E> {\n  readonly reduce: <A, B>(b: B, f: (b: B, a: A) => B) => <R>(fa: Kind3<F, R, E, A>) => B\n  readonly foldMap: <M>(M: Monoid<M>) => <A>(f: (a: A) => M) => <R>(fa: Kind3<F, R, E, A>) => M\n  readonly reduceRight: <A, B>(b: B, f: (a: A, b: B) => B) => <R>(fa: Kind3<F, R, E, A>) => B\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing chainFirstIOK Utility in TypeScript\nDESCRIPTION: Function that creates a chainFirst operation for IO-returning functions. Executes an IO computation for its effects but keeps the original value, supporting various higher-kinded type containers.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/FromIO.ts.md#2025-04-23_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare function chainFirstIOK<M extends URIS4>(\n  F: FromIO4<M>,\n  M: Chain4<M>\n): <A, B>(f: (a: A) => IO<B>) => <S, R, E>(first: Kind4<M, S, R, E, A>) => Kind4<M, S, R, E, A>\nexport declare function chainFirstIOK<M extends URIS3>(\n  F: FromIO3<M>,\n  M: Chain3<M>\n): <A, B>(f: (a: A) => IO<B>) => <R, E>(first: Kind3<M, R, E, A>) => Kind3<M, R, E, A>\nexport declare function chainFirstIOK<M extends URIS3, E>(\n  F: FromIO3C<M, E>,\n  M: Chain3C<M, E>\n): <A, B>(f: (a: A) => IO<B>) => <R, E>(first: Kind3<M, R, E, A>) => Kind3<M, R, E, A>\nexport declare function chainFirstIOK<M extends URIS2>(\n  F: FromIO2<M>,\n  M: Chain2<M>\n): <A, B>(f: (a: A) => IO<B>) => <E>(first: Kind2<M, E, A>) => Kind2<M, E, A>\nexport declare function chainFirstIOK<M extends URIS2, E>(\n  F: FromIO2C<M, E>,\n  M: Chain2C<M, E>\n): <A, B>(f: (a: A) => IO<B>) => <E>(first: Kind2<M, E, A>) => Kind2<M, E, A>\nexport declare function chainFirstIOK<M extends URIS>(\n  F: FromIO1<M>,\n  M: Chain1<M>\n): <A, B>(f: (a: A) => IO<B>) => (first: Kind<M, A>) => Kind<M, A>\nexport declare function chainFirstIOK<M>(\n  F: FromIO<M>,\n  M: Chain<M>\n): <A, B>(f: (a: A) => IO<B>) => (first: HKT<M, A>) => HKT<M, A>\n```\n\n----------------------------------------\n\nTITLE: Implementing fromReaderTaskEitherK for StateReaderTaskEither in TypeScript\nDESCRIPTION: Defines a function to lift a ReaderTaskEither-returning function into the StateReaderTaskEither context.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/StateReaderTaskEither.ts.md#2025-04-23_snippet_32\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare const fromReaderTaskEitherK: <R, E, A extends readonly unknown[], B>(\n  f: (...a: A) => RTE.ReaderTaskEither<R, E, B>\n) => <S>(...a: A) => StateReaderTaskEither<S, R, E, B>\n```\n\n----------------------------------------\n\nTITLE: Traversing Reader Array with Index in TypeScript\nDESCRIPTION: Implements traverseArrayWithIndex for Reader, equivalent to ReadonlyArray#traverseWithIndex(Applicative). It's similar to traverseArray but also provides the index to the mapping function.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Reader.ts.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const traverseArrayWithIndex: <R, A, B>(\n  f: (index: number, a: A) => Reader<R, B>\n) => (as: readonly A[]) => Reader<R, readonly B[]>\n```\n\n----------------------------------------\n\nTITLE: Implementing Apply Operation for ReaderT\nDESCRIPTION: Function implementing the ap operation for the Reader transformer, allowing application of functions wrapped in a Reader context. Supports various URI configurations.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReaderT.ts.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare function ap<F extends URIS4>(\n  F: Apply4<F>\n): <R, S, FR, FE, A>(\n  fa: Reader<R, Kind4<F, S, FR, FE, A>>\n) => <B>(fab: Reader<R, Kind4<F, S, FR, FE, (a: A) => B>>) => Reader<R, Kind4<F, S, FR, FE, B>>\n```\n\n----------------------------------------\n\nTITLE: Pointed1 Interface with URIS Constraint\nDESCRIPTION: Variant of Pointed interface for functors with one type parameter using URIS constraint. Uses Kind type instead of HKT.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Pointed.ts.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface Pointed1<F extends URIS> {\n  readonly URI: F\n  readonly of: <A>(a: A) => Kind<F, A>\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing State Monad Put Operation in TypeScript\nDESCRIPTION: Function signatures for replacing the current state with a new value. Supports multiple type hierarchy levels.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/FromState.ts.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare function put<F extends URIS4>(F: FromState4<F>): <S, R, E>(s: S) => Kind4<F, S, R, E, void>\nexport declare function put<F extends URIS3>(F: FromState3<F>): <S, E>(s: S) => Kind3<F, S, E, void>\nexport declare function put<F extends URIS3, E>(F: FromState3C<F, E>): <S>(s: S) => Kind3<F, S, E, void>\nexport declare function put<F extends URIS2>(F: FromState2<F>): <S>(s: S) => Kind2<F, S, void>\nexport declare function put<F>(F: FromState<F>): <S>(s: S) => HKT2<F, S, void>\n```\n\n----------------------------------------\n\nTITLE: Implementing chainReaderEitherK in TypeScript for ReaderTaskEither\nDESCRIPTION: Alias of flatMapReaderEither that chains a ReaderEither-returning function with a ReaderTaskEither. It takes a function from A to ReaderEither<R, E, B> and returns a function that transforms a ReaderTaskEither<R, E, A> into a ReaderTaskEither<R, E, B>.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReaderTaskEither.ts.md#2025-04-23_snippet_44\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const chainReaderEitherK: <R, E, A, B>(\n  f: (a: A) => ReaderEither<R, E, B>\n) => (ma: ReaderTaskEither<R, E, A>) => ReaderTaskEither<R, E, B>\n```\n\n----------------------------------------\n\nTITLE: Creating a Monoid for Ord in TypeScript\nDESCRIPTION: Returns a Monoid for Ord that concatenates orderings by first using one Ord, then another. The empty value considers elements equal.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Ord.ts.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const getMonoid: <A = never>() => Monoid<Ord<A>>\n```\n\n----------------------------------------\n\nTITLE: Implementing HKT2 Interface for `* -> * -> *` Constructors in TypeScript\nDESCRIPTION: Defines the HKT2 interface for binary type constructors that take two type parameters. It extends HKT and adds an additional type parameter E.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/HKT.ts.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface HKT2<URI, E, A> extends HKT<URI, A> {\n  readonly _E: E\n}\n```\n\n----------------------------------------\n\nTITLE: orElse Function Declaration in TypeScript\nDESCRIPTION: Function for error handling that allows transforming the error type in an Either monad transformer context.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/EitherT.ts.md#2025-04-23_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare function orElse<M extends URIS3>(\n  M: Monad3<M>\n): <E1, R, ME, E2, A>(\n  onLeft: (e: E1) => Kind3<M, R, ME, Either<E2, A>>\n) => (ma: Kind3<M, R, ME, Either<E1, A>>) => Kind3<M, R, ME, Either<E2, A>>\n```\n\n----------------------------------------\n\nTITLE: Implementing FromThese2C Interface in TypeScript\nDESCRIPTION: Defines the FromThese2C interface for type constructors with two type parameters and a fixed error type. It includes a URI, an _E type parameter, and a fromThese method.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/FromThese.ts.md#2025-04-23_snippet_2\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport interface FromThese2C<F extends URIS2, E> {\n  readonly URI: F\n  readonly _E: E\n  readonly fromThese: <A>(fa: These<E, A>) => Kind2<F, E, A>\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing URItoKind Interface for `* -> *` Constructors in TypeScript\nDESCRIPTION: Defines an empty interface to be extended by specific implementations of unary type constructors. Acts as a registry that maps URIs to their corresponding implementations.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/HKT.ts.md#2025-04-23_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface URItoKind<A> {}\n```\n\n----------------------------------------\n\nTITLE: Pointed4 Interface for Quaternary Type Constructors\nDESCRIPTION: Interface for functors with four type parameters using URIS4 constraint. Adds a state type parameter S.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Pointed.ts.md#2025-04-23_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface Pointed4<F extends URIS4> {\n  readonly URI: F\n  readonly of: <S, R, E, A>(a: A) => Kind4<F, S, R, E, A>\n}\n```\n\n----------------------------------------\n\nTITLE: Defining PipeableFoldable3 Interface in TypeScript\nDESCRIPTION: A pipeable version of the Foldable type class for higher-kinded types of arity 3. It provides folding methods for data structures with three type parameters.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/pipeable.ts.md#2025-04-23_snippet_55\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface PipeableFoldable3<F extends URIS3> {\n  readonly reduce: <A, B>(b: B, f: (b: B, a: A) => B) => <R, E>(fa: Kind3<F, R, E, A>) => B\n  readonly foldMap: <M>(M: Monoid<M>) => <A>(f: (a: A) => M) => <R, E>(fa: Kind3<F, R, E, A>) => M\n  readonly reduceRight: <A, B>(b: B, f: (a: A, b: B) => B) => <R, E>(fa: Kind3<F, R, E, A>) => B\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing traverseArray for StateReaderTaskEither in TypeScript\nDESCRIPTION: Provides traverseArray function that maps each element of an array to a StateReaderTaskEither and collects the results, equivalent to ReadonlyArray#traverse with Applicative.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/StateReaderTaskEither.ts.md#2025-04-23_snippet_55\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare const traverseArray: <S, R, E, A, B>(\n  f: (a: A) => StateReaderTaskEither<S, R, E, B>\n) => (as: readonly A[]) => StateReaderTaskEither<S, R, E, readonly B[]>\n```\n\n----------------------------------------\n\nTITLE: Type Class Instances for These in TypeScript\nDESCRIPTION: Defines various type class instances for These, including Functor, Bifunctor, Foldable, and Traversable.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/These.ts.md#2025-04-23_snippet_4\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare const Functor: Functor2<'These'>\n\nexport declare const Bifunctor: Bifunctor2<'These'>\n\nexport declare const Foldable: Foldable2<'These'>\n\nexport declare const Traversable: Traversable2<'These'>\n```\n\n----------------------------------------\n\nTITLE: Implementing Map Function for Traced\nDESCRIPTION: Map implementation for transforming values within the Traced context.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Traced.ts.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const map: <A, B>(f: (a: A) => B) => <E>(fa: Traced<E, A>) => Traced<E, B>\n```\n\n----------------------------------------\n\nTITLE: Implementing Natural Transformation for ReaderT\nDESCRIPTION: Function to create a natural transformation between functors F and G within the Reader context. Supports multiple URI variants with different type parameters.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReaderT.ts.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare function fromNaturalTransformation<F extends URIS2, G extends URIS4>(\n  nt: NaturalTransformation24S<F, G>\n): <R, S, A, E>(f: (r: R) => Kind2<F, S, A>) => Reader<R, Kind4<G, S, R, E, A>>\n```\n\n----------------------------------------\n\nTITLE: Implementing chainWithIndex for ReadonlyNonEmptyArray in TypeScript\nDESCRIPTION: Chains a function that takes both index and value over a ReadonlyNonEmptyArray.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReadonlyNonEmptyArray.ts.md#2025-04-23_snippet_25\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const chainWithIndex: <A, B>(\n  f: (i: number, a: A) => ReadonlyNonEmptyArray<B>\n) => (as: ReadonlyNonEmptyArray<A>) => ReadonlyNonEmptyArray<B>\n```\n\n----------------------------------------\n\nTITLE: Implementing flatMapIO for StateReaderTaskEither in TypeScript\nDESCRIPTION: Provides flatMapIO function that allows mapping from a StateReaderTaskEither to an IO monad and flattening the result, supporting both pipeable and non-pipeable patterns.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/StateReaderTaskEither.ts.md#2025-04-23_snippet_44\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare const flatMapIO: {\n  <A, B>(f: (a: A) => IO<B>): <S, R, E>(self: StateReaderTaskEither<S, R, E, A>) => StateReaderTaskEither<S, R, E, B>\n  <S, R, E, A, B>(self: StateReaderTaskEither<S, R, E, A>, f: (a: A) => IO<B>): StateReaderTaskEither<S, R, E, B>\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Base Unfoldable Interface in TypeScript\nDESCRIPTION: Base interface for Unfoldable type class that takes a single type parameter F. Provides unfold operation that generates a data structure from a seed value.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Unfoldable.ts.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface Unfoldable<F> {\n  readonly URI: F\n  readonly unfold: <A, B>(b: B, f: (b: B) => Option<[A, B]>) => HKT<F, A>\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing URItoKind2 Interface for `* -> * -> *` Constructors in TypeScript\nDESCRIPTION: Defines an empty interface to be extended by specific implementations of binary type constructors. Acts as a registry that maps URIs to their corresponding implementations.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/HKT.ts.md#2025-04-23_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface URItoKind2<E, A> {}\n```\n\n----------------------------------------\n\nTITLE: Map Value Lookup\nDESCRIPTION: Function to lookup a value by key in a Map, returning an Option type.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Map.ts.md#2025-04-23_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const lookup: <K>(E: Eq<K>) => {\n  (k: K): <A>(m: Map<K, A>) => O.Option<A>\n  <A>(k: K, m: Map<K, A>): O.Option<A>\n}\n```\n\n----------------------------------------\n\nTITLE: FanIn Function Type Signatures\nDESCRIPTION: PureScript type signature showing specialized fanIn functionality for function application.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Choice.ts.md#2025-04-23_snippet_2\n\nLANGUAGE: purescript\nCODE:\n```\nfanIn :: forall a b c d. (a -> c) -> (b -> c) -> Either a b -> c\n```\n\n----------------------------------------\n\nTITLE: Implementing fromTaskK for Task Lifting\nDESCRIPTION: Transforms a function returning a Task into a function returning a ReaderTaskEither, lifting asynchronous computations without error handling to include reader context and error handling.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReaderTaskEither.ts.md#2025-04-23_snippet_71\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const fromTaskK: <A extends readonly unknown[], B>(\n  f: (...a: A) => T.Task<B>\n) => <R = unknown, E = never>(...a: A) => ReaderTaskEither<R, E, B>\n```\n\n----------------------------------------\n\nTITLE: Implementing mapLeft Function for Error Mapping in TypeScript\nDESCRIPTION: An alias for mapError that transforms the error value of a TaskEither using the provided function while preserving the success value.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/TaskEither.ts.md#2025-04-23_snippet_45\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const mapLeft: <E, G>(f: (e: E) => G) => <A>(fa: TaskEither<E, A>) => TaskEither<G, A>\n```\n\n----------------------------------------\n\nTITLE: Implementing Pipeable ReduceWithIndex Function in TypeScript\nDESCRIPTION: Defines a pipeable reduceWithIndex function for various arities of the FoldableWithIndex type class. It allows folding a structure into a single value with access to the index.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/pipeable.ts.md#2025-04-23_snippet_24\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare function reduceWithIndex<F extends URIS4, I>(\n  F: FoldableWithIndex4<F, I>\n): <A, B>(b: B, f: (i: I, b: B, a: A) => B) => <S, R, E>(fa: Kind4<F, S, R, E, A>) => B\nexport declare function reduceWithIndex<F extends URIS3, I>(\n  F: FoldableWithIndex3<F, I>\n): <A, B>(b: B, f: (i: I, b: B, a: A) => B) => <R, E>(fa: Kind3<F, R, E, A>) => B\nexport declare function reduceWithIndex<F extends URIS3, I, E>(\n  F: FoldableWithIndex3C<F, I, E>\n): <A, B>(b: B, f: (i: I, b: B, a: A) => B) => <R>(fa: Kind3<F, R, E, A>) => B\nexport declare function reduceWithIndex<F extends URIS2, I>(\n  F: FoldableWithIndex2<F, I>\n): <A, B>(b: B, f: (i: I, b: B, a: A) => B) => <E>(fa: Kind2<F, E, A>) => B\nexport declare function reduceWithIndex<F extends URIS2, I, E>(\n  F: FoldableWithIndex2C<F, I, E>\n): <A, B>(b: B, f: (i: I, b: B, a: A) => B) => (fa: Kind2<F, E, A>) => B\nexport declare function reduceWithIndex<F extends URIS, I>(\n  F: FoldableWithIndex1<F, I>\n): <A, B>(b: B, f: (i: I, b: B, a: A) => B) => (fa: Kind<F, A>) => B\nexport declare function reduceWithIndex<F, I>(\n  F: FoldableWithIndex<F, I>\n): <A, B>(b: B, f: (i: I, b: B, a: A) => B) => (fa: HKT<F, A>) => B\n```\n\n----------------------------------------\n\nTITLE: Four-Parameter Natural Transformation\nDESCRIPTION: Defines transformation to a quadruple type constructor with state, reader, and error parameters\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/NaturalTransformation.ts.md#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface NaturalTransformation14<F extends URIS, G extends URIS4> {\n  <A, S, R, E>(fa: Kind<F, A>): Kind4<G, S, R, E, A>\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing chainReaderKW for StateReaderTaskEither in TypeScript\nDESCRIPTION: Defines chainReaderKW as a less strict version of chainReaderK. It merges environment types when chaining a Reader operation.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/StateReaderTaskEither.ts.md#2025-04-23_snippet_18\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare const chainReaderKW: <A, R1, B>(\n  f: (a: A) => R.Reader<R1, B>\n) => <S, R2, E>(ma: StateReaderTaskEither<S, R2, E, A>) => StateReaderTaskEither<S, R1 & R2, E, B>\n```\n\n----------------------------------------\n\nTITLE: Defining Monad1 Interface for URIS in TypeScript\nDESCRIPTION: Defines the Monad1 interface for higher-kinded types with one type parameter. It extends Applicative1 and Chain1 interfaces.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Monad.ts.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface Monad1<F extends URIS> extends Applicative1<F>, Chain1<F> {}\n```\n\n----------------------------------------\n\nTITLE: Defining FunctorCompositionHKT2C Interface in TypeScript\nDESCRIPTION: Interface for composing a generic higher-kinded type with a binary higher-kinded type (with fixed first type parameter) using the HKT representation.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Functor.ts.md#2025-04-23_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface FunctorCompositionHKT2C<F, G extends URIS2, E> {\n  readonly map: <A, B>(fa: HKT<F, Kind2<G, E, A>>, f: (a: A) => B) => HKT<F, Kind2<G, E, B>>\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing map for StateReaderTaskEither in TypeScript\nDESCRIPTION: Defines a function to map over the success value of a StateReaderTaskEither.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/StateReaderTaskEither.ts.md#2025-04-23_snippet_40\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare const map: <A, B>(\n  f: (a: A) => B\n) => <S, R, E>(fa: StateReaderTaskEither<S, R, E, A>) => StateReaderTaskEither<S, R, E, B>\n```\n\n----------------------------------------\n\nTITLE: IOEither Traversing Functions\nDESCRIPTION: Functions for traversing arrays and other data structures with IOEither\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/IOEither.ts.md#2025-04-23_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const traverseArray: <A, E, B>(\n  f: (a: A) => IOEither<E, B>\n) => (as: readonly A[]) => IOEither<E, readonly B[]>\n```\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const sequenceArray: <E, A>(arr: readonly IOEither<E, A>[]) => IOEither<E, readonly A[]>\n```\n\n----------------------------------------\n\nTITLE: Implementing orElseFirstW with Type Widening\nDESCRIPTION: Widened version of orElseFirst that merges environment and error types, providing more flexible error handling with type composition.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReaderTaskEither.ts.md#2025-04-23_snippet_61\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const orElseFirstW: <E1, R2, E2, B>(\n  onLeft: (e: E1) => ReaderTaskEither<R2, E2, B>\n) => <R1, A>(ma: ReaderTaskEither<R1, E1, A>) => ReaderTaskEither<R1 & R2, E1 | E2, A>\n```\n\n----------------------------------------\n\nTITLE: Defining Extend2C Interface with Fixed First Type Parameter\nDESCRIPTION: Defines the Extend2C interface for binary type constructors with a fixed first type parameter E, extending Functor2C with the appropriate extend method.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Extend.ts.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface Extend2C<W extends URIS2, E> extends Functor2C<W, E> {\n  readonly extend: <A, B>(wa: Kind2<W, E, A>, f: (wa: Kind2<W, E, A>) => B) => Kind2<W, E, B>\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing State Instances in TypeScript\nDESCRIPTION: Defines various instances for the State monad, including Applicative, Apply, Chain, Functor, Monad, and Pointed.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/State.ts.md#2025-04-23_snippet_3\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare const Applicative: Applicative2<'State'>\n\nexport declare const Apply: Apply2<'State'>\n\nexport declare const Chain: chainable.Chain2<'State'>\n\nexport declare const Functor: Functor2<'State'>\n\nexport declare const Monad: Monad2<'State'>\n\nexport declare const Pointed: Pointed2<'State'>\n```\n\n----------------------------------------\n\nTITLE: Implementing tapReaderEither Function in TypeScript\nDESCRIPTION: Function that composes computations in sequence, using the return value of one computation for the next while keeping only the first result. Works with ReaderEither types.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReaderTaskEither.ts.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const tapReaderEither: {\n  <A, R2, E2, _>(f: (a: A) => ReaderEither<R2, E2, _>): <R1, E1>(\n    self: ReaderTaskEither<R1, E1, A>\n  ) => ReaderTaskEither<R1 & R2, E2 | E1, A>\n  <R1, E1, A, R2, E2, _>(self: ReaderTaskEither<R1, E1, A>, f: (a: A) => ReaderEither<R2, E2, _>): ReaderTaskEither<\n    R1 & R2,\n    E1 | E2,\n    A\n  >\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing fromEitherK for StateReaderTaskEither in TypeScript\nDESCRIPTION: Defines a function to lift an Either-returning function into the StateReaderTaskEither context.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/StateReaderTaskEither.ts.md#2025-04-23_snippet_26\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare const fromEitherK: <E, A extends readonly unknown[], B>(\n  f: (...a: A) => E.Either<E, B>\n) => <S, R = unknown>(...a: A) => StateReaderTaskEither<S, R, E, B>\n```\n\n----------------------------------------\n\nTITLE: Three-Parameter Natural Transformation\nDESCRIPTION: Defines transformation to a triple type constructor with reader and error parameters\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/NaturalTransformation.ts.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface NaturalTransformation13<F extends URIS, G extends URIS3> {\n  <A, R, E>(fa: Kind<F, A>): Kind3<G, R, E, A>\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Eq Instance for Ordering\nDESCRIPTION: Exports an Eq instance for comparing Ordering values.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Ordering.ts.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const Eq: E.Eq<Ordering>\n```\n\n----------------------------------------\n\nTITLE: Defining URI Constant for Store in TypeScript\nDESCRIPTION: Declares the URI constant for Store, used for type-level identification.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Store.ts.md#2025-04-23_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const URI: 'Store'\n```\n\n----------------------------------------\n\nTITLE: Defining PipeableCompactable Interfaces in TypeScript\nDESCRIPTION: These interfaces define compact and separate operations for various higher-kinded types (URIS, URIS2, URIS3, URIS4) and a generic version.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/pipeable.ts.md#2025-04-23_snippet_38\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface PipeableCompactable1<F extends URIS> {\n  readonly compact: <A>(fa: Kind<F, Option<A>>) => Kind<F, A>\n  readonly separate: <A, B>(fa: Kind<F, Either<A, B>>) => Separated<Kind<F, A>, Kind<F, B>>\n}\n\nexport interface PipeableCompactable2C<F extends URIS2, E> {\n  readonly compact: <A>(fa: Kind2<F, E, Option<A>>) => Kind2<F, E, A>\n  readonly separate: <A, B>(fa: Kind2<F, E, Either<A, B>>) => Separated<Kind2<F, E, A>, Kind2<F, E, B>>\n}\n\nexport interface PipeableCompactable2<F extends URIS2> {\n  readonly compact: <E, A>(fa: Kind2<F, E, Option<A>>) => Kind2<F, E, A>\n  readonly separate: <E, A, B>(fa: Kind2<F, E, Either<A, B>>) => Separated<Kind2<F, E, A>, Kind2<F, E, B>>\n}\n\nexport interface PipeableCompactable3<F extends URIS3> {\n  readonly compact: <R, E, A>(fa: Kind3<F, R, E, Option<A>>) => Kind3<F, R, E, A>\n  readonly separate: <R, E, A, B>(fa: Kind3<F, R, E, Either<A, B>>) => Separated<Kind3<F, R, E, A>, Kind3<F, R, E, B>>\n}\n\nexport interface PipeableCompactable4<F extends URIS4> {\n  readonly compact: <S, R, E, A>(fa: Kind4<F, S, R, E, Option<A>>) => Kind4<F, S, R, E, A>\n  readonly separate: <S, R, E, A, B>(\n    fa: Kind4<F, S, R, E, Either<A, B>>\n  ) => Separated<Kind4<F, S, R, E, A>, Kind4<F, S, R, E, B>>\n}\n\nexport interface PipeableCompactable<F> {\n  readonly compact: <A>(fa: HKT<F, Option<A>>) => HKT<F, A>\n  readonly separate: <A, B>(fa: HKT<F, Either<A, B>>) => Separated<HKT<F, A>, HKT<F, B>>\n}\n```\n\n----------------------------------------\n\nTITLE: Functor1 Interface Definition\nDESCRIPTION: The TypeScript definition of the Functor1 interface from fp-ts. This interface describes type classes for functors of kind * -> *.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/guides/HKT.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\n// fp-ts/Functor.ts\n\nexport interface Functor1<F extends URIS> {\n  readonly URI: F\n  readonly map: <A, B>(fa: Kind<F, A>, f: (a: A) => B) => Kind<F, B>\n}\n```\n\n----------------------------------------\n\nTITLE: Declaring Foldable for ReadonlyNonEmptyArray in TypeScript\nDESCRIPTION: Defines the Foldable type class instance for ReadonlyNonEmptyArray.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReadonlyNonEmptyArray.ts.md#2025-04-23_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const Foldable: Foldable1<'ReadonlyNonEmptyArray'>\n```\n\n----------------------------------------\n\nTITLE: Defining FromReader3C interface in TypeScript\nDESCRIPTION: The FromReader3C interface is a specialized version of FromReader3 with a fixed error type. It provides a more specific type signature for the fromReader method using the URIS3 type encoding and a fixed error type parameter.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/FromReader.ts.md#2025-04-23_snippet_5\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport interface FromReader3C<F extends URIS3, E> {\n  readonly URI: F\n  readonly _E: E\n  readonly fromReader: <R, A>(fa: Reader<R, A>) => Kind3<F, R, E, A>\n}\n```\n\n----------------------------------------\n\nTITLE: Importing the Option Module Example\nDESCRIPTION: A specific example showing how to import the Option module from fp-ts using the recommended pattern.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/guides/code-conventions.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as Option from 'fp-ts/Option'\n```\n\n----------------------------------------\n\nTITLE: Implementing SemigroupProduct for Numbers\nDESCRIPTION: Semigroup instance for number multiplication.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/number.ts.md#2025-04-23_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const SemigroupProduct: Semigroup<number>\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport { SemigroupProduct } from 'fp-ts/number'\n\nassert.deepStrictEqual(SemigroupProduct.concat(2, 3), 6)\n```\n\n----------------------------------------\n\nTITLE: Implementing State Monad Get Operation in TypeScript\nDESCRIPTION: Function signatures for retrieving the current state from different monad variants. Supports multiple type hierarchy levels through URIS2-4.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/FromState.ts.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare function get<F extends URIS4>(F: FromState4<F>): <S, R, E>() => Kind4<F, S, R, E, S>\nexport declare function get<F extends URIS3>(F: FromState3<F>): <S, E>() => Kind3<F, S, E, S>\nexport declare function get<F extends URIS3, E>(F: FromState3C<F, E>): <S>() => Kind3<F, S, E, S>\nexport declare function get<F extends URIS2>(F: FromState2<F>): <S>() => Kind2<F, S, S>\nexport declare function get<F>(F: FromState<F>): <S>() => HKT2<F, S, S>\n```\n\n----------------------------------------\n\nTITLE: Implementing fromStateK for StateReaderTaskEither in TypeScript\nDESCRIPTION: Defines a function to lift a State-returning function into the StateReaderTaskEither context.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/StateReaderTaskEither.ts.md#2025-04-23_snippet_33\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare const fromStateK: <A extends readonly unknown[], S, B>(\n  f: (...a: A) => State<S, B>\n) => <R = unknown, E = never>(...a: A) => StateReaderTaskEither<S, R, E, B>\n```\n\n----------------------------------------\n\nTITLE: Negate Function Signature in TypeScript\nDESCRIPTION: Utility function signature for negating a value in a Ring, equivalent to subtracting from zero.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Ring.ts.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const negate: <A>(R: Ring<A>) => (a: A) => A\n```\n\n----------------------------------------\n\nTITLE: Implementing EitherM Monad Transformer in TypeScript\nDESCRIPTION: Function signatures for creating EitherM instances from different Monad types. Supports URIS2, URIS, and base Monad implementations. This is used to combine Either with other monadic types.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/EitherT.ts.md#2025-04-23_snippet_17\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare function getEitherM<M extends URIS2>(M: Monad2<M>): EitherM2<M>\nexport declare function getEitherM<M extends URIS>(M: Monad1<M>): EitherM1<M>\nexport declare function getEitherM<M>(M: Monad<M>): EitherM<M>\n```\n\n----------------------------------------\n\nTITLE: Defining Applicative1 Interface for Higher-Kinded Types\nDESCRIPTION: Specialized Applicative interface for type constructors with one type parameter, using the URIS system for higher-kinded types.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Applicative.ts.md#2025-04-23_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport interface Applicative1<F extends URIS> extends Apply1<F>, Pointed1<F> {}\n```\n\n----------------------------------------\n\nTITLE: Using tapEither with Option in TypeScript\nDESCRIPTION: Demonstrates the tapEither combinator which composes computations in sequence and allows integration between Either and Option. The function executes a side effect that returns an Either but preserves the original Option value if successful.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Option.ts.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { pipe } from 'fp-ts/function'\nimport * as O from 'fp-ts/Option'\nimport * as E from 'fp-ts/Either'\n\nconst compute = (value: number) =>\n  pipe(\n    O.of(value),\n    O.tapEither((value) => (value > 0 ? E.right('ok') : E.left('error')))\n  )\n\nassert.deepStrictEqual(compute(1), O.of(1))\nassert.deepStrictEqual(compute(-42), O.none)\n```\n\n----------------------------------------\n\nTITLE: Implementing StateT3 Interface for URIS3 in TypeScript\nDESCRIPTION: Defines the StateT3 interface for monads M with three type parameters (URIS3). It takes a state S and returns a Kind3<M, R, E, [A, S]>.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/StateT.ts.md#2025-04-23_snippet_3\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport interface StateT3<M extends URIS3, S, R, E, A> {\n  (s: S): Kind3<M, R, E, [A, S]>\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing mapLeft in TypeScript\nDESCRIPTION: Type declarations for a pipeable mapLeft function for transforming the left side of bifunctors. Handles various type parameter scenarios for bifunctor operations.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/pipeable.ts.md#2025-04-23_snippet_14\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare function mapLeft<F extends URIS4>(\n  F: Bifunctor4<F>\n): <E, G>(f: (e: E) => G) => <S, R, A>(fea: Kind4<F, S, R, E, A>) => Kind4<F, S, R, G, A>\n```\n\n----------------------------------------\n\nTITLE: Implementing ap Function for StateReaderTaskEither in TypeScript\nDESCRIPTION: Provides the ap function for StateReaderTaskEither which applies a function contained in a StateReaderTaskEither context to a value in the same context.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/StateReaderTaskEither.ts.md#2025-04-23_snippet_60\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare const ap: <S, R, E, A>(\n  fa: StateReaderTaskEither<S, R, E, A>\n) => <B>(fab: StateReaderTaskEither<S, R, E, (a: A) => B>) => StateReaderTaskEither<S, R, E, B>\n```\n\n----------------------------------------\n\nTITLE: Defining FunctorWithIndex2C Interface with Fixed Error Type in TypeScript\nDESCRIPTION: Interface for FunctorWithIndex with a fixed error type parameter, useful for error handling contexts.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/FunctorWithIndex.ts.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface FunctorWithIndex2C<F extends URIS2, I, E> extends Functor2C<F, E> {\n  readonly mapWithIndex: <A, B>(fa: Kind2<F, E, A>, f: (i: I, a: A) => B) => Kind2<F, E, B>\n}\n```\n\n----------------------------------------\n\nTITLE: Binding with Widening in Do Notation for TaskEither in TypeScript\nDESCRIPTION: A less strict version of bind that merges error types.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/TaskEither.ts.md#2025-04-23_snippet_14\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare const bindW: <N extends string, A, E2, B>(\n  name: Exclude<N, keyof A>,\n  f: (a: A) => TaskEither<E2, B>\n) => <E1>(fa: TaskEither<E1, A>) => TaskEither<E2 | E1, { readonly [K in N | keyof A]: K extends keyof A ? A[K] : B }>\n```\n\n----------------------------------------\n\nTITLE: Implementing flap Function for Separated in TypeScript\nDESCRIPTION: Defines the flap function, which applies a Separated instance containing a function to a value. It takes a value a and returns a new function that applies the function in the right part of a Separated instance to a.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Separated.ts.md#2025-04-23_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const flap: <A>(a: A) => <E, B>(fab: Separated<E, (a: A) => B>) => Separated<E, B>\n```\n\n----------------------------------------\n\nTITLE: Implementing foldMapWithIndex in TypeScript\nDESCRIPTION: Type declarations for a pipeable foldMapWithIndex function that includes index parameters in fold operations. Works with various type parameter scenarios.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/pipeable.ts.md#2025-04-23_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare function foldMapWithIndex<F extends URIS4, I>(\n  F: FoldableWithIndex4<F, I>\n): <M>(M: Monoid<M>) => <A>(f: (i: I, a: A) => M) => <S, R, E>(fa: Kind4<F, S, R, E, A>) => M\n```\n\n----------------------------------------\n\nTITLE: Implementing Alt3C Interface for Ternary Type Constructors with Fixed Second Type\nDESCRIPTION: Type-specific Alt interface for types with kind * -> * -> * -> * but with a fixed second type parameter E. Extends Functor3C and restricts the alt operation accordingly.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Alt.ts.md#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface Alt3C<F extends URIS3, E> extends Functor3C<F, E> {\n  readonly alt: <R, A>(fa: Kind3<F, R, E, A>, that: LazyArg<Kind3<F, R, E, A>>) => Kind3<F, R, E, A>\n}\n```\n\n----------------------------------------\n\nTITLE: Chaining Set Operations in TypeScript\nDESCRIPTION: Composes computations in sequence, using the return value of one computation to determine the next. Useful for complex set transformations.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Set.ts.md#2025-04-23_snippet_5\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare function chain<B>(E: Eq<B>): <A>(f: (x: A) => Set<B>) => (set: Set<A>) => Set<B>\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Strong with PureScript Functions\nDESCRIPTION: This snippet shows example type signatures for the 'first' and 'second' functions when specialized to PureScript function application. It illustrates how these functions operate on tuples.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Strong.ts.md#2025-04-23_snippet_0\n\nLANGUAGE: purescript\nCODE:\n```\nfirst ::  forall input output a. (input -> output) -> (Tuple input a) -> (Tuple output a)\nsecond :: forall input output a. (input -> output) -> (Tuple a input) -> (Tuple a output)\n```\n\n----------------------------------------\n\nTITLE: Implementing chainReaderEitherKW in TypeScript for ReaderTaskEither\nDESCRIPTION: Widening version of chainReaderEitherK that allows for different environment and error types. It takes a function from A to ReaderEither<R2, E2, B> and transforms a ReaderTaskEither<R1, E1, A> into a ReaderTaskEither<R1 & R2, E1 | E2, B>.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReaderTaskEither.ts.md#2025-04-23_snippet_45\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const chainReaderEitherKW: <R2, E2, A, B>(\n  f: (a: A) => ReaderEither<R2, E2, B>\n) => <R1, E1>(ma: ReaderTaskEither<R1, E1, A>) => ReaderTaskEither<R1 & R2, E2 | E1, B>\n```\n\n----------------------------------------\n\nTITLE: Right-to-Left Scan of Array with Accumulator in fp-ts\nDESCRIPTION: Folds an array from the right, keeping all intermediate results. Returns an array containing the accumulator values in reverse order, with the final accumulator value first.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReadonlyArray.ts.md#2025-04-23_snippet_52\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const scanRight: <A, B>(\n  b: B,\n  f: (a: A, b: B) => B\n) => (as: readonly A[]) => RNEA.ReadonlyNonEmptyArray<B>\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport { scanRight } from 'fp-ts/ReadonlyArray'\n\nassert.deepStrictEqual(scanRight(10, (a: number, b) => b - a)([1, 2, 3]), [4, 5, 7, 10])\n```\n\n----------------------------------------\n\nTITLE: Implementing FoldableWithIndex Compatibility\nDESCRIPTION: Example showing how TraversableWithIndex must be compatible with FoldableWithIndex operations.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/TraversableWithIndex.ts.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nfoldMapWithIndex(M)(ta, f) = traverseWithIndex(getApplicative(M))(ta, (i, a) => new Const(f(i, a))).value\n```\n\n----------------------------------------\n\nTITLE: Implementing apSecond for StateReaderTaskEither in TypeScript\nDESCRIPTION: Provides apSecond function that combines two StateReaderTaskEither effects, returning only the result of the second effect while still executing both.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/StateReaderTaskEither.ts.md#2025-04-23_snippet_64\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare const apSecond: <S, R, E, B>(\n  second: StateReaderTaskEither<S, R, E, B>\n) => <A>(first: StateReaderTaskEither<S, R, E, A>) => StateReaderTaskEither<S, R, E, B>\n```\n\n----------------------------------------\n\nTITLE: Defining the Const type alias in TypeScript\nDESCRIPTION: Defines the Const type constructor, which wraps a value of type E and ignores the type parameter A. The _A field is used for tracking the phantom type.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Const.ts.md#2025-04-23_snippet_20\n\nLANGUAGE: typescript\nCODE:\n```\nexport type Const<E, A> = E & { readonly _A: A }\n```\n\n----------------------------------------\n\nTITLE: Defining traverseReadonlyArrayWithIndex Operation for ReaderTaskEither in TypeScript\nDESCRIPTION: Function signature for traverseReadonlyArrayWithIndex that maps a readonly array of values to a ReaderTaskEither using both the index and value, then sequences the results in parallel. Equivalent to ReadonlyArray#traverseWithIndex(ApplicativePar). Added in v2.11.0.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReaderTaskEither.ts.md#2025-04-23_snippet_102\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const traverseReadonlyArrayWithIndex: <A, R, E, B>(\n  f: (index: number, a: A) => ReaderTaskEither<R, E, B>\n) => (as: readonly A[]) => ReaderTaskEither<R, E, readonly B[]>\n```\n\n----------------------------------------\n\nTITLE: Implementing extract Function for Store in TypeScript\nDESCRIPTION: Defines the extract function for Store, which retrieves the value at the current position.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Store.ts.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const extract: <E, A>(wa: Store<E, A>) => A\n```\n\n----------------------------------------\n\nTITLE: Defining URI Constant for IOOption in TypeScript\nDESCRIPTION: Declares the URI constant for the IOOption type. It's used for type identification in the fp-ts ecosystem.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/IOOption.ts.md#2025-04-23_snippet_47\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const URI: 'IOOption'\n```\n\n----------------------------------------\n\nTITLE: Accessing Last Element in ReadonlyNonEmptyArray in TypeScript\nDESCRIPTION: Function that returns the last element of a ReadonlyNonEmptyArray. This operation is safe because the array is guaranteed to have at least one element.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReadonlyNonEmptyArray.ts.md#2025-04-23_snippet_49\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const last: <A>(as: ReadonlyNonEmptyArray<A>) => A\n```\n\n----------------------------------------\n\nTITLE: Creating Ring instance for Const in TypeScript\nDESCRIPTION: Creates a Ring instance for Const given a Ring for the first type parameter. This provides addition, multiplication, and their inverses.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Const.ts.md#2025-04-23_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const getRing: <E, A>(S: Ring<E>) => Ring<Const<E, A>>\n```\n\n----------------------------------------\n\nTITLE: Defining FoldableWithIndexComposition2C1 Interface in TypeScript\nDESCRIPTION: Defines an interface for composing a FoldableWithIndex instance of URIS2 kind with one of URIS kind. It extends FoldableComposition2C1 and adds index-aware methods for reducing, folding, and right-reducing.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/FoldableWithIndex.ts.md#2025-04-23_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface FoldableWithIndexComposition2C1<F extends URIS2, FI, G extends URIS, GI, FE>\n  extends FoldableComposition2C1<F, G, FE> {\n  readonly reduceWithIndex: <A, B>(fga: Kind2<F, FE, Kind<G, A>>, b: B, f: (i: [FI, GI], b: B, a: A) => B) => B\n  readonly foldMapWithIndex: <M>(M: Monoid<M>) => <A>(fga: Kind2<F, FE, Kind<G, A>>, f: (i: [FI, GI], a: A) => M) => M\n  readonly reduceRightWithIndex: <A, B>(fga: Kind2<F, FE, Kind<G, A>>, b: B, f: (i: [FI, GI], a: A, b: B) => B) => B\n}\n```\n\n----------------------------------------\n\nTITLE: Defining FromReader2 interface in TypeScript\nDESCRIPTION: The FromReader2 interface is a specialized version of FromReader for bifunctor monads. It provides a more specific type signature for the fromReader method using the URIS2 type encoding.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/FromReader.ts.md#2025-04-23_snippet_3\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport interface FromReader2<F extends URIS2> {\n  readonly URI: F\n  readonly fromReader: <E, A>(fa: Reader<E, A>) => Kind2<F, E, A>\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing contramap for Const in TypeScript\nDESCRIPTION: Contramaps a function over the second type parameter of Const. This is part of the Contravariant type class implementation.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Const.ts.md#2025-04-23_snippet_23\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const contramap: <A, B>(f: (b: B) => A) => <E>(fa: Const<E, A>) => Const<E, B>\n```\n\n----------------------------------------\n\nTITLE: Implementing StateT1 Interface for URIS in TypeScript\nDESCRIPTION: Defines the StateT1 interface for monads M with a single type parameter (URIS). It takes a state S and returns a Kind<M, [A, S]>.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/StateT.ts.md#2025-04-23_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport interface StateT1<M extends URIS, S, A> {\n  (s: S): Kind<M, [A, S]>\n}\n```\n\n----------------------------------------\n\nTITLE: Defining flatten Operation for ReaderTaskEither in TypeScript\nDESCRIPTION: Function signature for flatten that collapses a nested ReaderTaskEither structure into a single layer. Added in v2.0.0.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReaderTaskEither.ts.md#2025-04-23_snippet_96\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const flatten: <R, E, A>(\n  mma: ReaderTaskEither<R, E, ReaderTaskEither<R, E, A>>\n) => ReaderTaskEither<R, E, A>\n```\n\n----------------------------------------\n\nTITLE: Using the Lift Function with Identity and Either\nDESCRIPTION: Example of using the lift function with both Identity and Either functors to lift a simple function to operate on these container types.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/guides/HKT.md#2025-04-23_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\nconst double = (n: number): number => n * 2\n\n//                             v-- the Functor instance of Identity\nconst doubleIdentity = lift(identity)(double)\n\n//                           v-- the Functor instance of Either\nconst doubleEither = lift(either)(double)\n```\n\n----------------------------------------\n\nTITLE: Natural Transformation from Unary to Binary Type Constructor\nDESCRIPTION: Defines transformation from unary to binary type constructor with error type parameter\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/NaturalTransformation.ts.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface NaturalTransformation12<F extends URIS, G extends URIS2> {\n  <A, E>(fa: Kind<F, A>): Kind2<G, E, A>\n}\n```\n\n----------------------------------------\n\nTITLE: Creating HeytingAlgebra instance for Const in TypeScript\nDESCRIPTION: Creates a HeytingAlgebra instance for Const given a HeytingAlgebra for the first type parameter. This provides operations for intuitionistic logic.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Const.ts.md#2025-04-23_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const getHeytingAlgebra: <E, A>(H: HeytingAlgebra<E>) => HeytingAlgebra<Const<E, A>>\n```\n\n----------------------------------------\n\nTITLE: Defining URI Constant for Separated in TypeScript\nDESCRIPTION: Declares the URI constant for the Separated type, which is used for type-level identification of the Separated type.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Separated.ts.md#2025-04-23_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const URI: 'Separated'\n```\n\n----------------------------------------\n\nTITLE: Implementing ChainRec4 Interface for Fourth-Order Types in TypeScript\nDESCRIPTION: Defines the ChainRec4 interface for fourth-order type constructors. It extends Chain4 and provides chainRec for stack-safe recursion with Kind4<F, _, _, _, _> types.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ChainRec.ts.md#2025-04-23_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface ChainRec4<F extends URIS4> extends Chain4<F> {\n  readonly chainRec: <S, R, E, A, B>(a: A, f: (a: A) => Kind4<F, S, R, E, Either<A, B>>) => Kind4<F, S, R, E, B>\n}\n```\n\n----------------------------------------\n\nTITLE: Handling Errors with Widening in TaskEither in TypeScript\nDESCRIPTION: A less strict version of orElse that merges return types.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/TaskEither.ts.md#2025-04-23_snippet_27\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare const orElseW: <E1, E2, B>(\n  onLeft: (e: E1) => TaskEither<E2, B>\n) => <A>(ma: TaskEither<E1, A>) => TaskEither<E2, B | A>\n```\n\n----------------------------------------\n\nTITLE: Using bindTo with Task Monad\nDESCRIPTION: Shows an alternative binding approach using bindTo for the first value in a chain of operations.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/guides/do-notation.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { pipe } from 'fp-ts/function'\nimport * as T from 'fp-ts/Task'\n\ndeclare const print: (s: string) => T.Task<void>\ndeclare const readLine: T.Task<string>\n\npipe(\n  readLine,\n  T.bindTo('x'),\n  T.bind('y', () => readLine),\n  T.tap(({ x }) => print(x)),\n  T.tap(({ y }) => print(y))\n)\n```\n\n----------------------------------------\n\nTITLE: Defining Zero3 interface for URIS3 functors in TypeScript\nDESCRIPTION: This interface defines the structure for a Zero type class for functors of kind URIS3. It includes a URI type and a zero method that returns a Kind3 of the functor.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Zero.ts.md#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface Zero3<F extends URIS3> {\n  readonly URI: F\n  readonly zero: <R, E, A>() => Kind3<F, R, E, A>\n}\n```\n\n----------------------------------------\n\nTITLE: Defining chainReaderK for StateReaderTaskEither in TypeScript\nDESCRIPTION: Implements chainReaderK as an alias of flatMapReader. It chains a Reader operation after a StateReaderTaskEither.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/StateReaderTaskEither.ts.md#2025-04-23_snippet_17\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare const chainReaderK: <A, R, B>(\n  f: (a: A) => R.Reader<R, B>\n) => <S, E>(ma: StateReaderTaskEither<S, R, E, A>) => StateReaderTaskEither<S, R, E, B>\n```\n\n----------------------------------------\n\nTITLE: Defining PipeableFilterable4 Interface in TypeScript\nDESCRIPTION: Interface definition for PipeableFilterable4 which extends PipeableCompactable4 with filtering operations for higher-kinded types of arity 4. It provides methods to filter, map, and partition data structures with four type parameters.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/pipeable.ts.md#2025-04-23_snippet_44\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface PipeableFilterable4<F extends URIS4> extends PipeableCompactable4<F> {\n  readonly filter: {\n    <A, B extends A>(refinement: Refinement<A, B>): <S, R, E>(fa: Kind4<F, S, R, E, A>) => Kind4<F, S, R, E, B>\n    <A>(predicate: Predicate<A>): <S, R, E>(fa: Kind4<F, S, R, E, A>) => Kind4<F, S, R, E, A>\n  }\n  readonly filterMap: <A, B>(f: (a: A) => Option<B>) => <S, R, E>(fa: Kind4<F, S, R, E, A>) => Kind4<F, S, R, E, A>\n  readonly partition: {\n    <A, B extends A>(refinement: Refinement<A, B>): <S, R, E>(\n      fa: Kind4<F, S, R, E, A>\n    ) => Separated<Kind4<F, S, R, E, A>, Kind4<F, S, R, E, B>>\n    <A>(predicate: Predicate<A>): <S, R, E>(\n      fa: Kind4<F, S, R, E, A>\n    ) => Separated<Kind4<F, S, R, E, A>, Kind4<F, S, R, E, A>>\n  }\n  readonly partitionMap: <A, B, C>(\n    f: (a: A) => Either<B, C>\n  ) => <S, R, E>(fa: Kind4<F, S, R, E, A>) => Separated<Kind4<F, S, R, E, B>, Kind4<F, S, R, E, C>>\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing chainOptionK for StateReaderTaskEither in TypeScript\nDESCRIPTION: Defines chainOptionK for chaining an Option operation after a StateReaderTaskEither. It uses flatMapOption internally.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/StateReaderTaskEither.ts.md#2025-04-23_snippet_15\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare const chainOptionK: <E>(\n  onNone: LazyArg<E>\n) => <A, B>(\n  f: (a: A) => Option<B>\n) => <S, R>(ma: StateReaderTaskEither<S, R, E, A>) => StateReaderTaskEither<S, R, E, B>\n```\n\n----------------------------------------\n\nTITLE: Implementing chainFirstTaskEitherKW in TypeScript for ReaderTaskEither\nDESCRIPTION: Widening version of chainFirstTaskEitherK that allows for different error types. It takes a function from A to TaskEither<E2, B> and returns a function that preserves the original value while merging error types.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReaderTaskEither.ts.md#2025-04-23_snippet_35\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const chainFirstTaskEitherKW: <E2, A, B>(\n  f: (a: A) => TE.TaskEither<E2, B>\n) => <R, E1>(ma: ReaderTaskEither<R, E1, A>) => ReaderTaskEither<R, E2 | E1, A>\n```\n\n----------------------------------------\n\nTITLE: Declaring Pointed for ReadonlyNonEmptyArray in TypeScript\nDESCRIPTION: Defines the Pointed type class instance for ReadonlyNonEmptyArray.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReadonlyNonEmptyArray.ts.md#2025-04-23_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const Pointed: Pointed1<'ReadonlyNonEmptyArray'>\n```\n\n----------------------------------------\n\nTITLE: Defining PartitionWithIndex4 Interface in TypeScript\nDESCRIPTION: Interface for partitioning 4-kind type constructors with index support. Extends the partition functionality to handle four type parameters.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/FilterableWithIndex.ts.md#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface PartitionWithIndex4<F extends URIS4, I> {\n  <S, R, E, A, B extends A>(fa: Kind4<F, S, R, E, A>, refinementWithIndex: RefinementWithIndex<I, A, B>): Separated<\n    Kind4<F, S, R, E, A>,\n    Kind4<F, S, R, E, B>\n  >\n  <S, R, E, A>(fa: Kind4<F, S, R, E, A>, predicateWithIndex: PredicateWithIndex<I, A>): Separated<\n    Kind4<F, S, R, E, A>,\n    Kind4<F, S, R, E, A>\n  >\n}\n```\n\n----------------------------------------\n\nTITLE: Example of Using reduceM with Option Monad in TypeScript\nDESCRIPTION: Example showing how to use reduceM to fold a tree structure with an Option monad, conditionally accumulating values when they meet a criteria.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Foldable.ts.md#2025-04-23_snippet_12\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { reduceM } from 'fp-ts/Foldable'\nimport { Monad, some } from 'fp-ts/Option'\nimport { make, Foldable } from 'fp-ts/Tree'\nimport { pipe } from 'fp-ts/function'\n\nconst t = make(1, [make(2, []), make(3, []), make(4, [])])\nassert.deepStrictEqual(\n  pipe(\n    t,\n    reduceM(Monad, Foldable)(0, (b, a) => (a > 2 ? some(b + a) : some(b)))\n  ),\n  some(7)\n)\n```\n\n----------------------------------------\n\nTITLE: Implementing FromOption Function in TypeScript\nDESCRIPTION: Defines a function to convert an Option type to a FromEither-compatible type, supporting different URI levels (URIS2, URIS3, etc.) and handling the None case with a provided error function.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/FromEither.ts.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare function fromOption<F extends URIS4>(\n  F: FromEither4<F>\n): <E>(onNone: LazyArg<E>) => <A, S, R>(fa: Option<A>) => Kind4<F, S, R, E, A>\nexport declare function fromOption<F extends URIS3>(\n  F: FromEither3<F>\n): <E>(onNone: LazyArg<E>) => <A, R>(fa: Option<A>) => Kind3<F, R, E, A>\nexport declare function fromOption<F extends URIS3, E>(\n  F: FromEither3C<F, E>\n): (onNone: LazyArg<E>) => <A, R>(fa: Option<A>) => Kind3<F, R, E, A>\nexport declare function fromOption<F extends URIS2>(\n  F: FromEither2<F>\n): <E>(onNone: LazyArg<E>) => <A>(fa: Option<A>) => Kind2<F, E, A>\nexport declare function fromOption<F extends URIS2, E>(\n  F: FromEither2C<F, E>\n): (onNone: LazyArg<E>) => <A>(fa: Option<A>) => Kind2<F, E, A>\nexport declare function fromOption<F>(F: FromEither<F>): <E>(onNone: LazyArg<E>) => <A>(ma: Option<A>) => HKT2<F, E, A>\n```\n\n----------------------------------------\n\nTITLE: Flap Function Implementation\nDESCRIPTION: Higher-order function that implements the flap operation for Functors of different arities. Takes a Functor instance and returns a function that applies a value to a wrapped function.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Functor.ts.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare function flap<F extends URIS4>(\n  F: Functor4<F>\n): <A>(a: A) => <S, R, E, B>(fab: Kind4<F, S, R, E, (a: A) => B>) => Kind4<F, S, R, E, B>\n```\n\n----------------------------------------\n\nTITLE: Boolean Type Refinement\nDESCRIPTION: Provides type refinement functionality to safely check if a value is boolean\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/boolean.ts.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const isBoolean: Refinement<unknown, boolean>\n```\n\n----------------------------------------\n\nTITLE: Defining PipeableSemigroupoid3 Interface in TypeScript\nDESCRIPTION: Defines a deprecated PipeableSemigroupoid3 interface with the compose method for higher-kinded types of arity 3. This interface provides function composition capabilities for ternary type constructors.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/pipeable.ts.md#2025-04-23_snippet_89\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface PipeableSemigroupoid3<F extends URIS3> {\n  readonly compose: <R, E, A>(la: Kind3<F, R, E, A>) => <B>(ab: Kind3<F, R, A, B>) => Kind3<F, R, E, B>\n}\n```\n\n----------------------------------------\n\nTITLE: Example Usage of makeBy Constructor\nDESCRIPTION: Example showing how to create a ReadonlyNonEmptyArray using the makeBy constructor function that takes a mapping function and length.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReadonlyNonEmptyArray.ts.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { makeBy } from 'fp-ts/ReadonlyNonEmptyArray'\nimport { pipe } from 'fp-ts/function'\n\nconst double = (n: number): number => n * 2\nassert.deepStrictEqual(pipe(5, makeBy(double)), [0, 2, 4, 6, 8])\n```\n\n----------------------------------------\n\nTITLE: Defining Deprecated FunctorWithIndexComposition2C1 Interface in TypeScript\nDESCRIPTION: Deprecated interface for composing a FunctorWithIndex2C with a FunctorWithIndex1, extending FunctorComposition2C1.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/FunctorWithIndex.ts.md#2025-04-23_snippet_14\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface FunctorWithIndexComposition2C1<F extends URIS2, FI, G extends URIS, GI, E>\n  extends FunctorComposition2C1<F, G, E> {\n  readonly mapWithIndex: <A, B>(fa: Kind2<F, E, Kind<G, A>>, f: (i: [FI, GI], a: A) => B) => Kind2<F, E, Kind<G, B>>\n}\n```\n\n----------------------------------------\n\nTITLE: Defining ValidationT Interface in TypeScript\nDESCRIPTION: Defines a deprecated interface ValidationT extending HKT with Either type.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ValidationT.ts.md#2025-04-23_snippet_5\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport interface ValidationT<M, E, A> extends HKT<M, Either<E, A>> {}\n```\n\n----------------------------------------\n\nTITLE: Left Constructor Type Definition\nDESCRIPTION: Type definition for creating Left values in an Either monad context.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/EitherT.ts.md#2025-04-23_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare function left<F extends URIS3>(\n  F: Pointed3<F>\n): <E, R, FE, A = never>(e: E) => Kind3<F, R, FE, Either<E, A>>\n```\n\n----------------------------------------\n\nTITLE: Defining URI type alias for IOEither\nDESCRIPTION: Type alias for the IOEither URI constant type.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/IOEither.ts.md#2025-04-23_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\nexport type URI = typeof URI\n```\n\n----------------------------------------\n\nTITLE: Declaring TraversableWithIndex for ReadonlyNonEmptyArray in TypeScript\nDESCRIPTION: Defines the TraversableWithIndex type class instance for ReadonlyNonEmptyArray with number index.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReadonlyNonEmptyArray.ts.md#2025-04-23_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const TraversableWithIndex: TraversableWithIndex1<'ReadonlyNonEmptyArray', number>\n```\n\n----------------------------------------\n\nTITLE: Implementing ChainFirstEitherK Function for IOOption in TypeScript\nDESCRIPTION: Defines the chainFirstEitherK function for IOOption, which is an alias of tapEither. It allows chaining operations with Either values while keeping the original value.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/IOOption.ts.md#2025-04-23_snippet_19\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const chainFirstEitherK: <E, A, B>(f: (a: A) => Either<E, B>) => (ma: IOOption<A>) => IOOption<A>\n```\n\n----------------------------------------\n\nTITLE: Implementing FromThese2 Interface in TypeScript\nDESCRIPTION: Defines the FromThese2 interface for type constructors with two type parameters. It includes a URI and a fromThese method to convert These values to the target type.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/FromThese.ts.md#2025-04-23_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport interface FromThese2<F extends URIS2> {\n  readonly URI: F\n  readonly fromThese: <E, A>(fa: These<E, A>) => Kind2<F, E, A>\n}\n```\n\n----------------------------------------\n\nTITLE: FoldableWithIndex4 Interface for URIS4 Kind\nDESCRIPTION: Interface for FoldableWithIndex specialized for Kind4<F, S, R, E, A> types, extending Foldable4 with indexed folding operations.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/FoldableWithIndex.ts.md#2025-04-23_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface FoldableWithIndex4<F extends URIS4, I> extends Foldable4<F> {\n  readonly reduceWithIndex: <S, R, E, A, B>(fa: Kind4<F, S, R, E, A>, b: B, f: (i: I, b: B, a: A) => B) => B\n  readonly foldMapWithIndex: <M>(M: Monoid<M>) => <S, R, E, A>(fa: Kind4<F, S, R, E, A>, f: (i: I, a: A) => M) => M\n  readonly reduceRightWithIndex: <S, R, E, A, B>(fa: Kind4<F, S, R, E, A>, b: B, f: (i: I, a: A, b: B) => B) => B\n}\n```\n\n----------------------------------------\n\nTITLE: Core Type Classes and Functions Export Declarations\nDESCRIPTION: Exports of core functional programming type classes and functions including distributiveLattice, eq, extend, field, filterable, and others. Each export maintains the same type as its implementation.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/index.ts.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const distributiveLattice: typeof distributiveLattice\n```\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const eq: typeof eq\n```\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const extend: typeof extend\n```\n\n----------------------------------------\n\nTITLE: Implementing Alt3 Interface for Ternary Type Constructors\nDESCRIPTION: Type-specific Alt interface for types with kind * -> * -> * -> *. Extends Functor3 and includes an alt operation working with Kind3<F, R, E, A> types.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Alt.ts.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface Alt3<F extends URIS3> extends Functor3<F> {\n  readonly alt: <R, E, A>(fa: Kind3<F, R, E, A>, that: LazyArg<Kind3<F, R, E, A>>) => Kind3<F, R, E, A>\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing getFunctorComposition Utility Function in TypeScript\nDESCRIPTION: Utility function with multiple overloads for creating functor compositions between different types of functors. Supports various combinations of higher-kinded types with different arities.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Functor.ts.md#2025-04-23_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare function getFunctorComposition<F extends URIS2, G extends URIS3, E>(\n  F: Functor2<F>,\n  G: Functor3C<G, E>\n): FunctorComposition23C<F, G, E>\nexport declare function getFunctorComposition<F extends URIS2, G extends URIS2, E>(\n  F: Functor2<F>,\n  G: Functor2C<G, E>\n): FunctorComposition22C<F, G, E>\nexport declare function getFunctorComposition<F extends URIS2, G extends URIS2>(\n  F: Functor2<F>,\n  G: Functor2<G>\n): FunctorComposition22<F, G>\nexport declare function getFunctorComposition<F extends URIS2, G extends URIS, E>(\n  F: Functor2C<F, E>,\n  G: Functor1<G>\n): FunctorComposition2C1<F, G, E>\nexport declare function getFunctorComposition<F extends URIS2, G extends URIS>(\n  F: Functor2<F>,\n  G: Functor1<G>\n): FunctorComposition21<F, G>\nexport declare function getFunctorComposition<F extends URIS, G extends URIS2, E>(\n  F: Functor1<F>,\n  G: Functor2C<G, E>\n): FunctorComposition12C<F, G, E>\nexport declare function getFunctorComposition<F extends URIS, G extends URIS2>(\n  F: Functor1<F>,\n  G: Functor2<G>\n): FunctorComposition12<F, G>\nexport declare function getFunctorComposition<F extends URIS, G extends URIS>(\n  F: Functor1<F>,\n  G: Functor1<G>\n): FunctorComposition11<F, G>\nexport declare function getFunctorComposition<F, G>(F: Functor<F>, G: Functor<G>): FunctorComposition<F, G>\n```\n\n----------------------------------------\n\nTITLE: Implementing MonadIO4 Interface for URIS4 Types\nDESCRIPTION: Extends the MonadIO pattern to support higher-kinded types with four type parameters (URIS4).\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/MonadIO.ts.md#2025-04-23_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface MonadIO4<M extends URIS4> extends Monad4<M>, FromIO4<M> {}\n```\n\n----------------------------------------\n\nTITLE: Implementing map for Const in TypeScript\nDESCRIPTION: Maps a function over the second type parameter of Const. Since Const ignores its second type parameter, the mapped function doesn't affect the actual value.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Const.ts.md#2025-04-23_snippet_19\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const map: <A, B>(f: (a: A) => B) => <E>(fa: Const<E, A>) => Const<E, B>\n```\n\n----------------------------------------\n\nTITLE: Defining asUnit mapping function for ReaderIO in TypeScript\nDESCRIPTION: Maps the value of a ReaderIO to the void constant value. It transforms any ReaderIO into a ReaderIO<R, void>.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReaderIO.ts.md#2025-04-23_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const asUnit: <R, _>(self: ReaderIO<R, _>) => ReaderIO<R, void>\n```\n\n----------------------------------------\n\nTITLE: Defining bracket Function for ReaderTaskEither in TypeScript\nDESCRIPTION: Function signature for bracket that ensures a resource is cleaned up after use, regardless of whether an error occurs. The release action is called for both successful and error results. Added in v2.0.4.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReaderTaskEither.ts.md#2025-04-23_snippet_116\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare function bracket<R, E, A, B>(\n  acquire: ReaderTaskEither<R, E, A>,\n  use: (a: A) => ReaderTaskEither<R, E, B>,\n  release: (a: A, e: Either<E, B>) => ReaderTaskEither<R, E, void>\n): ReaderTaskEither<R, E, B>\n```\n\n----------------------------------------\n\nTITLE: Defining partitionWithIndex Pipeable Function in TypeScript\nDESCRIPTION: Creates a pipeable partitionWithIndex function that supports various arity levels (URIS1-4) in the fp-ts library. This function separates elements with access to their indices based on a predicate or refinement.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/pipeable.ts.md#2025-04-23_snippet_19\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare function partitionWithIndex<F extends URIS4, I>(\n  F: FilterableWithIndex4<F, I>\n): {\n  <A, B extends A>(refinement: RefinementWithIndex<I, A, B>): <S, R, E>(\n    fa: Kind4<F, S, R, E, A>\n  ) => Separated<Kind4<F, S, R, E, A>, Kind4<F, S, R, E, B>>\n  <A>(predicate: PredicateWithIndex<I, A>): <S, R, E>(\n    fa: Kind4<F, S, R, E, A>\n  ) => Separated<Kind4<F, S, R, E, A>, Kind4<F, S, R, E, A>>\n}\nexport declare function partitionWithIndex<F extends URIS3, I>(\n  F: FilterableWithIndex3<F, I>\n): {\n  <A, B extends A>(refinement: RefinementWithIndex<I, A, B>): <R, E>(\n    fa: Kind3<F, R, E, A>\n  ) => Separated<Kind3<F, R, E, A>, Kind3<F, R, E, B>>\n  <A>(predicate: PredicateWithIndex<I, A>): <R, E>(\n    fa: Kind3<F, R, E, A>\n  ) => Separated<Kind3<F, R, E, A>, Kind3<F, R, E, A>>\n}\nexport declare function partitionWithIndex<F extends URIS3, I, E>(\n  F: FilterableWithIndex3C<F, I, E>\n): {\n  <A, B extends A>(refinement: RefinementWithIndex<I, A, B>): <R>(\n    fa: Kind3<F, R, E, A>\n  ) => Separated<Kind3<F, R, E, A>, Kind3<F, R, E, B>>\n  <A>(predicate: PredicateWithIndex<I, A>): <R>(\n    fa: Kind3<F, R, E, A>\n  ) => Separated<Kind3<F, R, E, A>, Kind3<F, R, E, A>>\n}\nexport declare function partitionWithIndex<F extends URIS2, I>(\n  F: FilterableWithIndex2<F, I>\n): {\n  <A, B extends A>(refinement: RefinementWithIndex<I, A, B>): <E>(\n    fa: Kind2<F, E, A>\n  ) => Separated<Kind2<F, E, A>, Kind2<F, E, B>>\n  <A>(predicate: PredicateWithIndex<I, A>): <E>(fa: Kind2<F, E, A>) => Separated<Kind2<F, E, A>, Kind2<F, E, A>>\n}\nexport declare function partitionWithIndex<F extends URIS2, I, E>(\n  F: FilterableWithIndex2C<F, I, E>\n): {\n  <A, B extends A>(refinement: RefinementWithIndex<I, A, B>): (\n    fa: Kind2<F, E, A>\n  ) => Separated<Kind2<F, E, A>, Kind2<F, E, B>>\n  <A>(predicate: PredicateWithIndex<I, A>): (fa: Kind2<F, E, A>) => Separated<Kind2<F, E, A>, Kind2<F, E, A>>\n}\nexport declare function partitionWithIndex<F extends URIS, I>(\n  F: FilterableWithIndex1<F, I>\n): {\n  <A, B extends A>(refinement: RefinementWithIndex<I, A, B>): (fa: Kind<F, A>) => Separated<Kind<F, A>, Kind<F, B>>\n  <A>(predicate: PredicateWithIndex<I, A>): (fa: Kind<F, A>) => Separated<Kind<F, A>, Kind<F, A>>\n}\nexport declare function partitionWithIndex<F, I>(\n  F: FilterableWithIndex<F, I>\n): {\n  <A, B extends A>(refinement: RefinementWithIndex<I, A, B>): (fa: HKT<F, A>) => Separated<HKT<F, A>, HKT<F, B>>\n  <A>(predicate: PredicateWithIndex<I, A>): (fa: HKT<F, A>) => Separated<HKT<F, A>, HKT<F, A>>\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Alt2C Interface for Binary Type Constructors with Fixed First Type\nDESCRIPTION: Type-specific Alt interface for types with kind * -> * -> * but with a fixed first type parameter E. Extends Functor2C and restricts the alt operation accordingly.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Alt.ts.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface Alt2C<F extends URIS2, E> extends Functor2C<F, E> {\n  readonly alt: <A>(fa: Kind2<F, E, A>, that: LazyArg<Kind2<F, E, A>>) => Kind2<F, E, A>\n}\n```\n\n----------------------------------------\n\nTITLE: Defining chainStateK for StateReaderTaskEither in TypeScript\nDESCRIPTION: Implements chainStateK as an alias of flatMapState. It chains a State operation after a StateReaderTaskEither.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/StateReaderTaskEither.ts.md#2025-04-23_snippet_21\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare const chainStateK: <A, S, B>(\n  f: (a: A) => State<S, B>\n) => <R, E>(ma: StateReaderTaskEither<S, R, E, A>) => StateReaderTaskEither<S, R, E, B>\n```\n\n----------------------------------------\n\nTITLE: Implementing ChainRec3 Interface for Third-Order Types in TypeScript\nDESCRIPTION: Defines the ChainRec3 interface for third-order type constructors. It extends Chain3 and provides chainRec for stack-safe recursion with Kind3<F, _, _, _> types.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ChainRec.ts.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface ChainRec3<F extends URIS3> extends Chain3<F> {\n  readonly chainRec: <R, E, A, B>(a: A, f: (a: A) => Kind3<F, R, E, Either<A, B>>) => Kind3<F, R, E, B>\n}\n```\n\n----------------------------------------\n\nTITLE: Defining PipeableMonadThrow3 Interface in TypeScript\nDESCRIPTION: Defines a deprecated PipeableMonadThrow3 interface with methods for handling optional values, either values, and predicates for higher-kinded types of arity 3. This interface extends monad functionality with error handling operations.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/pipeable.ts.md#2025-04-23_snippet_79\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface PipeableMonadThrow3<F extends URIS3> {\n  readonly fromOption: <E>(onNone: LazyArg<E>) => <R, A>(ma: Option<A>) => Kind3<F, R, E, A>\n  readonly fromEither: <R, E, A>(ma: Either<E, A>) => Kind3<F, R, E, A>\n  readonly fromPredicate: {\n    <E, A, B extends A>(refinement: Refinement<A, B>, onFalse: (a: A) => E): <U>(a: A) => Kind3<F, U, E, B>\n    <E, A>(predicate: Predicate<A>, onFalse: (a: A) => E): <R>(a: A) => Kind3<F, R, E, A>\n  }\n  readonly filterOrElse: {\n    <E, A, B extends A>(refinement: Refinement<A, B>, onFalse: (a: A) => E): <R>(\n      ma: Kind3<F, R, E, A>\n    ) => Kind3<F, R, E, B>\n    <E, A>(predicate: Predicate<A>, onFalse: (a: A) => E): <R>(ma: Kind3<F, R, E, A>) => Kind3<F, R, E, A>\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing chainFirstW for StateReaderTaskEither in TypeScript\nDESCRIPTION: Defines chainFirstW as an alias of tap. It provides a widening operation that merges environment and error types when chaining StateReaderTaskEither operations.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/StateReaderTaskEither.ts.md#2025-04-23_snippet_11\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare const chainFirstW: <S, R2, E2, A, B>(\n  f: (a: A) => StateReaderTaskEither<S, R2, E2, B>\n) => <R1, E1>(ma: StateReaderTaskEither<S, R1, E1, A>) => StateReaderTaskEither<S, R1 & R2, E2 | E1, A>\n```\n\n----------------------------------------\n\nTITLE: Defining flatMapNullable Operation for ReaderTaskEither in TypeScript\nDESCRIPTION: Function signature for flatMapNullable that maps a ReaderTaskEither to another one, handling null/undefined values with a provided error function. Added in v2.15.0.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReaderTaskEither.ts.md#2025-04-23_snippet_88\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const flatMapNullable: {\n  <A, B, E2>(f: (a: A) => B | null | undefined, onNullable: (a: A) => E2): <R, E1>(\n    self: ReaderTaskEither<R, E1, A>\n  ) => ReaderTaskEither<R, E2 | E1, NonNullable<B>>\n  <R, E1, A, B, E2>(\n    self: ReaderTaskEither<R, E1, A>,\n    f: (a: A) => B | null | undefined,\n    onNullable: (a: A) => E2\n  ): ReaderTaskEither<R, E1 | E2, NonNullable<B>>\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing ChainOptionK Function for IOOption in TypeScript\nDESCRIPTION: Defines the chainOptionK function for IOOption, which is an alias of flatMapOption. It allows chaining operations with Option values on IOOption.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/IOOption.ts.md#2025-04-23_snippet_23\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const chainOptionK: <A, B>(f: (a: A) => O.Option<B>) => (ma: IOOption<A>) => IOOption<B>\n```\n\n----------------------------------------\n\nTITLE: Implementing Pipeable ReduceRight Function in TypeScript\nDESCRIPTION: Defines a pipeable reduceRight function for various arities of the Foldable type class. It allows folding a structure into a single value from right to left.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/pipeable.ts.md#2025-04-23_snippet_22\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare function reduceRight<F extends URIS4>(\n  F: Foldable4<F>\n): <A, B>(b: B, f: (a: A, b: B) => B) => <S, R, E>(fa: Kind4<F, S, R, E, A>) => B\nexport declare function reduceRight<F extends URIS3>(\n  F: Foldable3<F>\n): <A, B>(b: B, f: (a: A, b: B) => B) => <R, E>(fa: Kind3<F, R, E, A>) => B\nexport declare function reduceRight<F extends URIS3, E>(\n  F: Foldable3C<F, E>\n): <A, B>(b: B, f: (a: A, b: B) => B) => <R>(fa: Kind3<F, R, E, A>) => B\nexport declare function reduceRight<F extends URIS2>(\n  F: Foldable2<F>\n): <A, B>(b: B, f: (a: A, b: B) => B) => <E>(fa: Kind2<F, E, A>) => B\nexport declare function reduceRight<F extends URIS2, E>(\n  F: Foldable2C<F, E>\n): <A, B>(b: B, f: (a: A, b: B) => B) => (fa: Kind2<F, E, A>) => B\nexport declare function reduceRight<F extends URIS>(\n  F: Foldable1<F>\n): <A, B>(b: B, f: (a: A, b: B) => B) => (fa: Kind<F, A>) => B\nexport declare function reduceRight<F>(F: Foldable<F>): <A, B>(b: B, f: (a: A, b: B) => B) => (fa: HKT<F, A>) => B\n```\n\n----------------------------------------\n\nTITLE: Implementing Utility Functions for These in TypeScript\nDESCRIPTION: Defines various utility functions for These, including ApT, elem, exists, and swap operations.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/These.ts.md#2025-04-23_snippet_17\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare const ApT: These<never, readonly []>\n\nexport declare const elem: <A>(E: Eq<A>) => (a: A) => <E>(ma: These<E, A>) => boolean\n\nexport declare const exists: <A>(predicate: Predicate<A>) => (ma: These<unknown, A>) => boolean\n\nexport declare const swap: <E, A>(fa: These<E, A>) => These<A, E>\n```\n\n----------------------------------------\n\nTITLE: Defining Compactable Instance for IOOption in TypeScript\nDESCRIPTION: Declares the Compactable instance for the IOOption monad. This provides implementations for the Compactable typeclass methods.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/IOOption.ts.md#2025-04-23_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const Compactable: Compactable1<'IOOption'>\n```\n\n----------------------------------------\n\nTITLE: Implementing extend Function for Store in TypeScript\nDESCRIPTION: Defines the extend function for Store, allowing derivation of new Store instances.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Store.ts.md#2025-04-23_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const extend: <E, A, B>(f: (wa: Store<E, A>) => B) => (wa: Store<E, A>) => Store<E, B>\n```\n\n----------------------------------------\n\nTITLE: Defining ReaderIO interface in TypeScript\nDESCRIPTION: Defines the ReaderIO type as a function that takes an environment R and returns an IO<A>.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReaderIO.ts.md#2025-04-23_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface ReaderIO<R, A> {\n  (r: R): I.IO<A>\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Unfoldable3C Interface in TypeScript\nDESCRIPTION: Variant of Unfoldable3 with a fixed error type parameter E. Useful for type constructors that have a fixed error type.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Unfoldable.ts.md#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface Unfoldable3C<F extends URIS3, E> {\n  readonly URI: F\n  readonly _E: E\n  readonly unfold: <R, A, B>(b: B, f: (b: B) => Option<[A, B]>) => Kind3<F, R, E, A>\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing matchLeft for ReadonlyNonEmptyArray in TypeScript\nDESCRIPTION: Breaks a ReadonlyNonEmptyArray into its first element and remaining elements.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReadonlyNonEmptyArray.ts.md#2025-04-23_snippet_22\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const matchLeft: <A, B>(f: (head: A, tail: readonly A[]) => B) => (as: ReadonlyNonEmptyArray<A>) => B\n```\n\n----------------------------------------\n\nTITLE: Implementing Element Dropping in ReadonlyArray in TypeScript\nDESCRIPTION: Defines functions to drop elements from the start or end of a ReadonlyArray, and to drop elements while a condition is met.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReadonlyArray.ts.md#2025-04-23_snippet_18\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const dropLeft: (n: number) => <A>(as: readonly A[]) => readonly A[]\n\nexport declare const dropRight: (n: number) => <A>(as: readonly A[]) => readonly A[]\n\nexport declare function dropLeftWhile<A, B extends A>(\n  refinement: Refinement<A, B>\n): (as: ReadonlyArray<A>) => ReadonlyArray<B>\nexport declare function dropLeftWhile<A>(\n  predicate: Predicate<A>\n): <B extends A>(bs: ReadonlyArray<B>) => ReadonlyArray<B>\nexport declare function dropLeftWhile<A>(predicate: Predicate<A>): (as: ReadonlyArray<A>) => ReadonlyArray<A>\n```\n\n----------------------------------------\n\nTITLE: URI Constant for Ord in TypeScript\nDESCRIPTION: Defines the URI constant for the Ord type class, used for identifying the type in higher-kinded contexts.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Ord.ts.md#2025-04-23_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const URI: 'Ord'\n```\n\n----------------------------------------\n\nTITLE: Defining FunctorWithIndex4 Interface for URIS4 in TypeScript\nDESCRIPTION: Interface for FunctorWithIndex with four type parameters, extending Functor4 with the mapWithIndex operation.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/FunctorWithIndex.ts.md#2025-04-23_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface FunctorWithIndex4<F extends URIS4, I> extends Functor4<F> {\n  readonly mapWithIndex: <S, R, E, A, B>(fa: Kind4<F, S, R, E, A>, f: (i: I, a: A) => B) => Kind4<F, S, R, E, B>\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Empty ReadonlyArray in TypeScript\nDESCRIPTION: Defines an empty ReadonlyArray constant.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReadonlyArray.ts.md#2025-04-23_snippet_23\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const empty: readonly never[]\n```\n\n----------------------------------------\n\nTITLE: Creating Functor Instance for Record in TypeScript\nDESCRIPTION: Defines a Functor instance for the Record type in fp-ts. Functor provides a map operation to transform the values of a structure.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Record.ts.md#2025-04-23_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const Functor: Functor1<'Record'>\n```\n\n----------------------------------------\n\nTITLE: Defining MonadIO Interface in TypeScript\nDESCRIPTION: Defines the basic MonadIO interface that extends both Monad and FromIO types. This is the foundation for lifting IO computations into monadic contexts.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/MonadIO.ts.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface MonadIO<M> extends Monad<M>, FromIO<M> {}\n```\n\n----------------------------------------\n\nTITLE: Defining PipeableChain2C Interface in TypeScript\nDESCRIPTION: This interface extends PipeableApply2C and defines chain, chainFirst, and flatten operations for a higher-kinded type F with two type parameters and a fixed error type E.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/pipeable.ts.md#2025-04-23_snippet_33\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface PipeableChain2C<F extends URIS2, E> extends PipeableApply2C<F, E> {\n  readonly chain: <A, B>(f: (a: A) => Kind2<F, E, B>) => (ma: Kind2<F, E, A>) => Kind2<F, E, B>\n  readonly chainFirst: <A, B>(f: (a: A) => Kind2<F, E, B>) => (ma: Kind2<F, E, A>) => Kind2<F, E, A>\n  readonly flatten: <A>(mma: Kind2<F, E, Kind2<F, E, A>>) => Kind2<F, E, A>\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Foldable4 Interface in TypeScript\nDESCRIPTION: Type class definition for Foldable with four type parameters using URIS4, handling complex data structures with state, reader, error, and value types.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Foldable.ts.md#2025-04-23_snippet_6\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport interface Foldable4<F extends URIS4> {\n  readonly URI: F\n  readonly reduce: <S, R, E, A, B>(fa: Kind4<F, S, R, E, A>, b: B, f: (b: B, a: A) => B) => B\n  readonly foldMap: <M>(M: Monoid<M>) => <S, R, E, A>(fa: Kind4<F, S, R, E, A>, f: (a: A) => M) => M\n  readonly reduceRight: <S, R, E, A, B>(fa: Kind4<F, S, R, E, A>, b: B, f: (a: A, b: B) => B) => B\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Bounded instance for Const in TypeScript\nDESCRIPTION: Creates a Bounded instance for Const given a Bounded for the first type parameter. This provides minimum and maximum values for Const.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Const.ts.md#2025-04-23_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const getBounded: <E, A>(B: Bounded<E>) => Bounded<Const<E, A>>\n```\n\n----------------------------------------\n\nTITLE: Defining flatMapTaskEither Operation for ReaderTaskEither in TypeScript\nDESCRIPTION: Function signature for flatMapTaskEither that composes a ReaderTaskEither with a TaskEither function, combining both error types. Added in v2.16.0.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReaderTaskEither.ts.md#2025-04-23_snippet_95\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const flatMapTaskEither: {\n  <A, E2, B>(f: (a: A) => TE.TaskEither<E2, B>): <R, E1>(\n    self: ReaderTaskEither<R, E1, A>\n  ) => ReaderTaskEither<R, E2 | E1, B>\n  <R, E1, A, E2, B>(self: ReaderTaskEither<R, E1, A>, f: (a: A) => TE.TaskEither<E2, B>): ReaderTaskEither<\n    R,\n    E1 | E2,\n    B\n  >\n}\n```\n\n----------------------------------------\n\nTITLE: Defining traverseReadonlyNonEmptyArrayWithIndex function for ReaderIO in TypeScript\nDESCRIPTION: Maps each element of a readonly non-empty array to a ReaderIO using both the element and its index. It's equivalent to ReadonlyNonEmptyArray#traverseWithIndex(Applicative).\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReaderIO.ts.md#2025-04-23_snippet_19\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const traverseReadonlyNonEmptyArrayWithIndex: <A, R, B>(\n  f: (index: number, a: A) => ReaderIO<R, B>\n) => (as: ReadonlyNonEmptyArray<A>) => ReaderIO<R, ReadonlyNonEmptyArray<B>>\n```\n\n----------------------------------------\n\nTITLE: Defining PipeableFilterable Interface in TypeScript\nDESCRIPTION: Interface definition for PipeableFilterable which extends PipeableCompactable with filtering operations for generic higher-kinded types. Provides base methods for filtering, mapping options, and partitioning data structures for HKT types.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/pipeable.ts.md#2025-04-23_snippet_51\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface PipeableFilterable<F> extends PipeableCompactable<F> {\n  readonly filter: {\n    <A, B extends A>(refinement: Refinement<A, B>): (fa: HKT<F, A>) => HKT<F, B>\n    <A>(predicate: Predicate<A>): (fa: HKT<F, A>) => HKT<F, A>\n  }\n  readonly filterMap: <A, B>(f: (a: A) => Option<B>) => (fa: HKT<F, A>) => HKT<F, B>\n  readonly partition: {\n    <A, B extends A>(refinement: Refinement<A, B>): (fa: HKT<F, A>) => Separated<HKT<F, A>, HKT<F, B>>\n    <A>(predicate: Predicate<A>): (fa: HKT<F, A>) => Separated<HKT<F, A>, HKT<F, A>>\n  }\n  readonly partitionMap: <A, B, C>(f: (a: A) => Either<B, C>) => (fa: HKT<F, A>) => Separated<HKT<F, B>, HKT<F, C>>\n}\n```\n\n----------------------------------------\n\nTITLE: Profunctor4 Interface Implementation\nDESCRIPTION: Implementation of Profunctor for types with four type parameters. Extends Functor4.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Profunctor.ts.md#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface Profunctor4<F extends URIS4> extends Functor4<F> {\n  readonly promap: <S, R, E, A, D, B>(fea: Kind4<F, S, R, E, A>, f: (d: D) => E, g: (a: A) => B) => Kind4<F, S, R, D, B>\n}\n```\n\n----------------------------------------\n\nTITLE: Defining URI constant for IOEither\nDESCRIPTION: Constant representing the unique identifier for the IOEither type.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/IOEither.ts.md#2025-04-23_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const URI: 'IOEither'\n```\n\n----------------------------------------\n\nTITLE: Defining PipeableExtend Interfaces in TypeScript\nDESCRIPTION: These interfaces extend PipeableFunctor and define extend and duplicate operations for various higher-kinded types (URIS, URIS2, URIS3, URIS4) and a generic version.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/pipeable.ts.md#2025-04-23_snippet_40\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface PipeableExtend1<F extends URIS> extends PipeableFunctor1<F> {\n  readonly extend: <A, B>(f: (wa: Kind<F, A>) => B) => (wa: Kind<F, A>) => Kind<F, B>\n  readonly duplicate: <A>(wa: Kind<F, A>) => Kind<F, Kind<F, A>>\n}\n\nexport interface PipeableExtend2C<F extends URIS2, E> extends PipeableFunctor2C<F, E> {\n  readonly extend: <A, B>(f: (wa: Kind2<F, E, A>) => B) => (wa: Kind2<F, E, A>) => Kind2<F, E, B>\n  readonly duplicate: <A>(wa: Kind2<F, E, A>) => Kind2<F, E, Kind2<F, E, A>>\n}\n\nexport interface PipeableExtend2<F extends URIS2> extends PipeableFunctor2<F> {\n  readonly extend: <E, A, B>(f: (wa: Kind2<F, E, A>) => B) => (wa: Kind2<F, E, A>) => Kind2<F, E, B>\n  readonly duplicate: <E, A>(wa: Kind2<F, E, A>) => Kind2<F, E, Kind2<F, E, A>>\n}\n\nexport interface PipeableExtend3<F extends URIS3> extends PipeableFunctor3<F> {\n  readonly extend: <R, E, A, B>(f: (wa: Kind3<F, R, E, A>) => B) => (wa: Kind3<F, R, E, A>) => Kind3<F, R, E, B>\n  readonly duplicate: <R, E, A>(wa: Kind3<F, R, E, A>) => Kind3<F, R, E, Kind3<F, R, E, A>>\n}\n\nexport interface PipeableExtend4<F extends URIS4> extends PipeableFunctor4<F> {\n  readonly extend: <S, R, E, A, B>(\n    f: (wa: Kind4<F, S, R, E, A>) => B\n  ) => (wa: Kind4<F, S, R, E, A>) => Kind4<F, S, R, E, B>\n  readonly duplicate: <S, R, E, A>(wa: Kind4<F, S, R, E, A>) => Kind4<F, S, R, E, Kind4<F, S, R, E, A>>\n}\n\nexport interface PipeableExtend<F> extends PipeableFunctor<F> {\n  readonly extend: <A, B>(f: (wa: HKT<F, A>) => B) => (wa: HKT<F, A>) => HKT<F, B>\n  readonly duplicate: <A>(wa: HKT<F, A>) => HKT<F, HKT<F, A>>\n}\n```\n\n----------------------------------------\n\nTITLE: Defining 'as' mapping function for ReaderIO in TypeScript\nDESCRIPTION: Maps the value of a ReaderIO to a specified constant value. It provides two function signatures for different use cases.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReaderIO.ts.md#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const as: {\n  <A>(a: A): <R, _>(self: ReaderIO<R, _>) => ReaderIO<R, A>\n  <R, _, A>(self: ReaderIO<R, _>, a: A): ReaderIO<R, A>\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing chainIOEitherK in TypeScript for ReaderTaskEither\nDESCRIPTION: Alias of flatMapIOEither that chains an IOEither-returning function with a ReaderTaskEither. It takes a function from A to IOEither<E, B> and returns a function that transforms a ReaderTaskEither<R, E, A> into a ReaderTaskEither<R, E, B>.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReaderTaskEither.ts.md#2025-04-23_snippet_38\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const chainIOEitherK: <E, A, B>(\n  f: (a: A) => IOEither<E, B>\n) => <R>(ma: ReaderTaskEither<R, E, A>) => ReaderTaskEither<R, E, B>\n```\n\n----------------------------------------\n\nTITLE: Date Equality Utility\nDESCRIPTION: Eq instance for comparing Date objects for equality. This is an alias for the Eq instance.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Date.ts.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const eqDate: E.Eq<Date>\n```\n\n----------------------------------------\n\nTITLE: Implementing leftIO Constructor in TypeScript\nDESCRIPTION: Constructor function that creates a StateReaderTaskEither from an IO monad containing a left value.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/StateReaderTaskEither.ts.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare function leftIO<S, R, E, A = never>(me: IO<E>): StateReaderTaskEither<S, R, E, A>\n```\n\n----------------------------------------\n\nTITLE: Defining Invariant3C Interface in TypeScript\nDESCRIPTION: Constrained version of Invariant3 interface with fixed error type parameter E. Used for three-parameter higher-kinded types with constrained error type.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Invariant.ts.md#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface Invariant3C<F extends URIS3, E> {\n  readonly URI: F\n  readonly _E: E\n  readonly imap: <R, A, B>(fa: Kind3<F, R, E, A>, f: (a: A) => B, g: (b: B) => A) => Kind3<F, R, E, B>\n}\n```\n\n----------------------------------------\n\nTITLE: Defining FoldableWithIndexComposition Interface in TypeScript\nDESCRIPTION: Defines a generic interface for composing two FoldableWithIndex instances. It extends FoldableComposition and adds index-aware methods for reducing, folding, and right-reducing using HKT (Higher Kinded Types).\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/FoldableWithIndex.ts.md#2025-04-23_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface FoldableWithIndexComposition<F, FI, G, GI> extends FoldableComposition<F, G> {\n  readonly reduceWithIndex: <A, B>(fga: HKT<F, HKT<G, A>>, b: B, f: (i: [FI, GI], b: B, a: A) => B) => B\n  readonly foldMapWithIndex: <M>(M: Monoid<M>) => <A>(fga: HKT<F, HKT<G, A>>, f: (i: [FI, GI], a: A) => M) => M\n  readonly reduceRightWithIndex: <A, B>(fga: HKT<F, HKT<G, A>>, b: B, f: (i: [FI, GI], a: A, b: B) => B) => B\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing State Monad Utility Functions in TypeScript\nDESCRIPTION: Utility functions chainStateK and fromStateK for working with State monads and function lifting.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/FromState.ts.md#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare function chainStateK<M extends URIS4>(F: FromState4<M>, M: Chain4<M>): <A, S, B>(f: (a: A) => State<S, B>) => <R, E>(ma: Kind4<M, S, R, E, A>) => Kind4<M, S, R, E, B>\nexport declare function chainStateK<M extends URIS3>(F: FromState3<M>, M: Chain3<M>): <A, S, B>(f: (a: A) => State<S, B>) => <E>(ma: Kind3<M, S, E, A>) => Kind3<M, S, E, B>\nexport declare function chainStateK<M extends URIS2>(F: FromState2<M>, M: Chain2<M>): <A, S, B>(f: (a: A) => State<S, B>) => (ma: Kind2<M, S, A>) => Kind2<M, S, B>\nexport declare function chainStateK<M>(F: FromState<M>, M: Chain<M>): <A, S, B>(f: (a: A) => State<S, B>) => (ma: HKT2<M, S, A>) => HKT2<M, S, B>\n\nexport declare function fromStateK<F extends URIS4>(F: FromState4<F>): <A extends ReadonlyArray<unknown>, S, B>(f: (...a: A) => State<S, B>) => <R, E>(...a: A) => Kind4<F, S, R, E, B>\nexport declare function fromStateK<F extends URIS3>(F: FromState3<F>): <A extends ReadonlyArray<unknown>, S, B>(f: (...a: A) => State<S, B>) => <E>(...a: A) => Kind3<F, S, E, B>\nexport declare function fromStateK<F extends URIS3, E>(F: FromState3C<F, E>): <A extends ReadonlyArray<unknown>, S, B>(f: (...a: A) => State<S, B>) => (...a: A) => Kind3<F, S, E, B>\nexport declare function fromStateK<F extends URIS2>(F: FromState2<F>): <A extends ReadonlyArray<unknown>, S, B>(f: (...a: A) => State<S, B>) => (...a: A) => Kind2<F, S, B>\nexport declare function fromStateK<F>(F: FromState<F>): <A extends ReadonlyArray<unknown>, S, B>(f: (...a: A) => State<S, B>) => (...a: A) => HKT2<F, S, B>\n```\n\n----------------------------------------\n\nTITLE: Defining traverseReadonlyNonEmptyArrayWithIndex Operation for ReaderTaskEither in TypeScript\nDESCRIPTION: Function signature for traverseReadonlyNonEmptyArrayWithIndex that maps a readonly non-empty array to a ReaderTaskEither using both the index and value, then sequences the results in parallel. Equivalent to ReadonlyNonEmptyArray#traverseWithIndex(ApplicativePar). Added in v2.11.0.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReaderTaskEither.ts.md#2025-04-23_snippet_104\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const traverseReadonlyNonEmptyArrayWithIndex: <A, R, E, B>(\n  f: (index: number, a: A) => ReaderTaskEither<R, E, B>\n) => (as: ReadonlyNonEmptyArray<A>) => ReaderTaskEither<R, E, ReadonlyNonEmptyArray<B>>\n```\n\n----------------------------------------\n\nTITLE: Defining traverseReadonlyArrayWithIndexSeq Operation for ReaderTaskEither in TypeScript\nDESCRIPTION: Function signature for traverseReadonlyArrayWithIndexSeq that maps a readonly array of values to a ReaderTaskEither using both the index and value, then sequences the results sequentially. Equivalent to ReadonlyArray#traverseWithIndex(ApplicativeSeq). Added in v2.11.0.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReaderTaskEither.ts.md#2025-04-23_snippet_103\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const traverseReadonlyArrayWithIndexSeq: <A, R, E, B>(\n  f: (index: number, a: A) => ReaderTaskEither<R, E, B>\n) => (as: readonly A[]) => ReaderTaskEither<R, E, readonly B[]>\n```\n\n----------------------------------------\n\nTITLE: Defining partition Pipeable Function in TypeScript\nDESCRIPTION: Creates a pipeable partition function that supports various arity levels (URIS1-4) in the fp-ts library. This function separates a data structure into two parts based on a predicate or refinement.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/pipeable.ts.md#2025-04-23_snippet_16\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare function partition<F extends URIS4>(\n  F: Filterable4<F>\n): {\n  <A, B extends A>(refinement: Refinement<A, B>): <S, R, E>(\n    fa: Kind4<F, S, R, E, A>\n  ) => Separated<Kind4<F, S, R, E, A>, Kind4<F, S, R, E, B>>\n  <A>(predicate: Predicate<A>): <S, R, E>(\n    fa: Kind4<F, S, R, E, A>\n  ) => Separated<Kind4<F, S, R, E, A>, Kind4<F, S, R, E, A>>\n}\nexport declare function partition<F extends URIS3>(\n  F: Filterable3<F>\n): {\n  <A, B extends A>(refinement: Refinement<A, B>): <R, E>(\n    fa: Kind3<F, R, E, A>\n  ) => Separated<Kind3<F, R, E, A>, Kind3<F, R, E, B>>\n  <A>(predicate: Predicate<A>): <R, E>(fa: Kind3<F, R, E, A>) => Separated<Kind3<F, R, E, A>, Kind3<F, R, E, A>>\n}\nexport declare function partition<F extends URIS3, E>(\n  F: Filterable3C<F, E>\n): {\n  <A, B extends A>(refinement: Refinement<A, B>): <R>(\n    fa: Kind3<F, R, E, A>\n  ) => Separated<Kind3<F, R, E, A>, Kind3<F, R, E, B>>\n  <A>(predicate: Predicate<A>): <R>(fa: Kind3<F, R, E, A>) => Separated<Kind3<F, R, E, A>, Kind3<F, R, E, A>>\n}\nexport declare function partition<F extends URIS2>(\n  F: Filterable2<F>\n): {\n  <A, B extends A>(refinement: Refinement<A, B>): <E>(fa: Kind2<F, E, A>) => Separated<Kind2<F, E, A>, Kind2<F, E, B>>\n  <A>(predicate: Predicate<A>): <E>(fa: Kind2<F, E, A>) => Separated<Kind2<F, E, A>, Kind2<F, E, A>>\n}\nexport declare function partition<F extends URIS2, E>(\n  F: Filterable2C<F, E>\n): {\n  <A, B extends A>(refinement: Refinement<A, B>): (fa: Kind2<F, E, A>) => Separated<Kind2<F, E, A>, Kind2<F, E, B>>\n  <A>(predicate: Predicate<A>): (fa: Kind2<F, E, A>) => Separated<Kind2<F, E, A>, Kind2<F, E, A>>\n}\nexport declare function partition<F extends URIS>(\n  F: Filterable1<F>\n): {\n  <A, B extends A>(refinement: Refinement<A, B>): (fa: Kind<F, A>) => Separated<Kind<F, A>, Kind<F, B>>\n  <A>(predicate: Predicate<A>): (fa: Kind<F, A>) => Separated<Kind<F, A>, Kind<F, A>>\n}\nexport declare function partition<F>(F: Filterable<F>): {\n  <A, B extends A>(refinement: Refinement<A, B>): (fa: HKT<F, A>) => Separated<HKT<F, A>, HKT<F, B>>\n  <A>(predicate: Predicate<A>): (fa: HKT<F, A>) => Separated<HKT<F, A>, HKT<F, A>>\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing chainFirstTaskEitherK in TypeScript for ReaderTaskEither\nDESCRIPTION: Alias of tapTaskEither that executes a TaskEither-returning side effect without changing the original value. It takes a function from A to TaskEither<E, B> and preserves the original value.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReaderTaskEither.ts.md#2025-04-23_snippet_34\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const chainFirstTaskEitherK: <E, A, B>(\n  f: (a: A) => TE.TaskEither<E, B>\n) => <R>(ma: ReaderTaskEither<R, E, A>) => ReaderTaskEither<R, E, A>\n```\n\n----------------------------------------\n\nTITLE: Implementing TraverseReadonlyNonEmptyArrayWithIndex Function for IOOption in TypeScript\nDESCRIPTION: Defines the traverseReadonlyNonEmptyArrayWithIndex function for IOOption. It's equivalent to ReadonlyNonEmptyArray#traverseWithIndex(Applicative).\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/IOOption.ts.md#2025-04-23_snippet_46\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const traverseReadonlyNonEmptyArrayWithIndex: <A, B>(\n  f: (index: number, a: A) => IOOption<B>\n) => (as: ReadonlyNonEmptyArray<A>) => IOOption<ReadonlyNonEmptyArray<B>>\n```\n\n----------------------------------------\n\nTITLE: FoldableComposition Interface Definitions\nDESCRIPTION: Type definitions for composing Foldable instances with different higher-kinded type combinations. These interfaces are deprecated but show the type structure for folding nested data types.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Foldable.ts.md#2025-04-23_snippet_18\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface FoldableComposition<F, G> {\n  readonly reduce: <A, B>(fga: HKT<F, HKT<G, A>>, b: B, f: (b: B, a: A) => B) => B\n  readonly foldMap: <M>(M: Monoid<M>) => <A>(fa: HKT<F, HKT<G, A>>, f: (a: A) => M) => M\n  readonly reduceRight: <A, B>(fa: HKT<F, HKT<G, A>>, b: B, f: (a: A, b: B) => B) => B\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing experiment Function for Store in TypeScript\nDESCRIPTION: Defines the experiment function for Store, allowing extraction of values from positions dependent on the current position.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Store.ts.md#2025-04-23_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare function experiment<F extends URIS3>(\n  F: Functor3<F>\n): <R, E, S>(f: (s: S) => Kind3<F, R, E, S>) => <A>(wa: Store<S, A>) => Kind3<F, R, E, A>\nexport declare function experiment<F extends URIS3, E>(\n  F: Functor3C<F, E>\n): <R, S>(f: (s: S) => Kind3<F, R, E, S>) => <A>(wa: Store<S, A>) => Kind3<F, R, E, A>\nexport declare function experiment<F extends URIS2>(\n  F: Functor2<F>\n): <E, S>(f: (s: S) => Kind2<F, E, S>) => <A>(wa: Store<S, A>) => Kind2<F, E, A>\nexport declare function experiment<F extends URIS2, E>(\n  F: Functor2C<F, E>\n): <S>(f: (s: S) => Kind2<F, E, S>) => <A>(wa: Store<S, A>) => Kind2<F, E, A>\nexport declare function experiment<F extends URIS>(\n  F: Functor1<F>\n): <S>(f: (s: S) => Kind<F, S>) => <A>(wa: Store<S, A>) => Kind<F, A>\nexport declare function experiment<F>(\n  F: FunctorHKT<F>\n): <S>(f: (s: S) => HKT<F, S>) => <A>(wa: Store<S, A>) => HKT<F, A>\n```\n\n----------------------------------------\n\nTITLE: Year Equality Utility\nDESCRIPTION: Eq instance for comparing dates based only on their year component.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Date.ts.md#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const eqYear: E.Eq<Date>\n```\n\n----------------------------------------\n\nTITLE: Implementing bindW function in StateReaderTaskEither (TypeScript)\nDESCRIPTION: The bindW function allows binding a computation to a StateReaderTaskEither monad, with the W suffix indicating that environment and error types will be merged (widened). It creates a new computation with the result of the bound function added to the original result object.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/StateReaderTaskEither.ts.md#2025-04-23_snippet_69\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const bindW: <N extends string, A, S, R2, E2, B>(\n  name: Exclude<N, keyof A>,\n  f: (a: A) => StateReaderTaskEither<S, R2, E2, B>\n) => <R1, E1>(\n  fa: StateReaderTaskEither<S, R1, E1, A>\n) => StateReaderTaskEither<S, R1 & R2, E2 | E1, { readonly [K in N | keyof A]: K extends keyof A ? A[K] : B }>\n```\n\n----------------------------------------\n\nTITLE: Implementing Element Deletion in ReadonlyArray in TypeScript\nDESCRIPTION: Defines a function to delete an element at a specified index from a ReadonlyArray, returning an Option of the new array.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReadonlyArray.ts.md#2025-04-23_snippet_14\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const deleteAt: (i: number) => <A>(as: readonly A[]) => Option<readonly A[]>\n```\n\n----------------------------------------\n\nTITLE: Defining flatMapTask Operation for ReaderTaskEither in TypeScript\nDESCRIPTION: Function signature for flatMapTask that composes a ReaderTaskEither with a Task function. Added in v2.16.0.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReaderTaskEither.ts.md#2025-04-23_snippet_94\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const flatMapTask: {\n  <A, B>(f: (a: A) => T.Task<B>): <R, E>(self: ReaderTaskEither<R, E, A>) => ReaderTaskEither<R, E, B>\n  <R, E, A, B>(self: ReaderTaskEither<R, E, A>, f: (a: A) => T.Task<B>): ReaderTaskEither<R, E, B>\n}\n```\n\n----------------------------------------\n\nTITLE: Defining CompactableComposition Interface in TypeScript\nDESCRIPTION: This interface extends FunctorComposition and defines compact and separate methods for composing two higher-kinded types F and G using the HKT type constructor.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Compactable.ts.md#2025-04-23_snippet_5\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport interface CompactableComposition<F, G> extends FunctorComposition<F, G> {\n  readonly compact: <A>(fga: HKT<F, HKT<G, Option<A>>>) => HKT<F, HKT<G, A>>\n  readonly separate: <A, B>(fge: HKT<F, HKT<G, Either<A, B>>>) => Separated<HKT<F, HKT<G, A>>, HKT<F, HKT<G, B>>>\n}\n```\n\n----------------------------------------\n\nTITLE: Defining PipeableSemigroupoid Interface in TypeScript\nDESCRIPTION: Defines a deprecated PipeableSemigroupoid interface with the compose method for higher-kinded types using the HKT2 notation. This interface provides a foundational composition operation for semigroupoid structures.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/pipeable.ts.md#2025-04-23_snippet_91\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface PipeableSemigroupoid<F> {\n  readonly compose: <E, A>(la: HKT2<F, E, A>) => <B>(ab: HKT2<F, A, B>) => HKT2<F, E, B>\n}\n```\n\n----------------------------------------\n\nTITLE: PipeableTraverseWithIndex1 Interface Definition\nDESCRIPTION: TypeScript interface definition for pipeable traverse operations with index for unary type constructors.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/TraversableWithIndex.ts.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface PipeableTraverseWithIndex1<T extends URIS, I> {\n  <F extends URIS3>(F: Applicative3<F>): <A, R, E, B>(\n    f: (i: I, a: A) => Kind3<F, R, E, B>\n  ) => (ta: Kind<T, A>) => Kind3<F, R, E, Kind<T, B>>\n  <F extends URIS3, E>(F: Applicative3C<F, E>): <A, R, B>(\n    f: (i: I, a: A) => Kind3<F, R, E, B>\n  ) => (ta: Kind<T, A>) => Kind3<F, R, E, Kind<T, B>>\n  <F extends URIS2>(F: Applicative2<F>): <A, E, B>(\n    f: (i: I, a: A) => Kind2<F, E, B>\n  ) => (ta: Kind<T, A>) => Kind2<F, E, Kind<T, B>>\n  <F extends URIS2, E>(F: Applicative2C<F, E>): <A, B>(\n    f: (i: I, a: A) => Kind2<F, E, B>\n  ) => (ta: Kind<T, A>) => Kind2<F, E, Kind<T, B>>\n  <F extends URIS>(F: Applicative1<F>): <A, B>(f: (i: I, a: A) => Kind<F, B>) => (ta: Kind<T, A>) => Kind<F, Kind<T, B>>\n  <F>(F: Applicative<F>): <A, B>(f: (i: I, a: A) => HKT<F, B>) => (ta: Kind<T, A>) => HKT<F, Kind<T, B>>\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Deprecated FunctorWithIndexComposition12C Interface in TypeScript\nDESCRIPTION: Deprecated interface for composing FunctorWithIndex instances with fixed error type, extending FunctorComposition12C.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/FunctorWithIndex.ts.md#2025-04-23_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface FunctorWithIndexComposition12C<F extends URIS, FI, G extends URIS2, GI, E>\n  extends FunctorComposition12C<F, G, E> {\n  readonly mapWithIndex: <A, B>(fa: Kind<F, Kind2<G, E, A>>, f: (i: [FI, GI], a: A) => B) => Kind<F, Kind2<G, E, B>>\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Traced Interface in TypeScript\nDESCRIPTION: Core interface definition for the Traced type, representing a function from type P to type A.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Traced.ts.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface Traced<P, A> {\n  (p: P): A\n}\n```\n\n----------------------------------------\n\nTITLE: Defining ReaderM Interface in TypeScript\nDESCRIPTION: Defines the general ReaderM interface with methods for map, of, ap, chain, ask, asks, local, fromReader, and fromM operations. It is parameterized by a type M without specific URIS constraints.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReaderT.ts.md#2025-04-23_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface ReaderM<M> {\n  readonly map: <R, A, B>(ma: ReaderT<M, R, A>, f: (a: A) => B) => ReaderT<M, R, B>\n  readonly of: <R, A>(a: A) => ReaderT<M, R, A>\n  readonly ap: <R, A, B>(mab: ReaderT<M, R, (a: A) => B>, ma: ReaderT<M, R, A>) => ReaderT<M, R, B>\n  readonly chain: <R, A, B>(ma: ReaderT<M, R, A>, f: (a: A) => ReaderT<M, R, B>) => ReaderT<M, R, B>\n  readonly ask: <R>() => ReaderT<M, R, R>\n  readonly asks: <R, A>(f: (r: R) => A) => ReaderT<M, R, A>\n  readonly local: <R1, A, R2>(ma: ReaderT<M, R1, A>, f: (d: R2) => R1) => ReaderT<M, R2, A>\n  readonly fromReader: <R, A>(ma: Reader<R, A>) => ReaderT<M, R, A>\n  readonly fromM: <R, A>(ma: HKT<M, A>) => ReaderT<M, R, A>\n}\n```\n\n----------------------------------------\n\nTITLE: Working with Option and Either conversion in TypeScript\nDESCRIPTION: Examples showing how to extract values from Either type into Option, maintaining functional composition and type safety when working with possible errors.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Option.ts.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { getLeft, none, some } from 'fp-ts/Option'\nimport { right, left } from 'fp-ts/Either'\n\nassert.deepStrictEqual(getLeft(right(1)), none)\nassert.deepStrictEqual(getLeft(left('a')), some('a'))\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport { getRight, none, some } from 'fp-ts/Option'\nimport { right, left } from 'fp-ts/Either'\n\nassert.deepStrictEqual(getRight(right(1)), some(1))\nassert.deepStrictEqual(getRight(left('a')), none)\n```\n\n----------------------------------------\n\nTITLE: Set Difference Operation in TypeScript\nDESCRIPTION: Computes the set difference (A - B) between two sets. Returns a new set containing elements in the first set that are not in the second set.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Set.ts.md#2025-04-23_snippet_6\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare function difference<A>(E: Eq<A>): {\n  (that: Set<A>): (me: Set<A>) => Set<A>\n  (me: Set<A>, that: Set<A>): Set<A>\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Foldable3C Interface in TypeScript\nDESCRIPTION: Type class definition for Foldable with three type parameters but fixed error type E, simplifying usage when the error type is consistent.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Foldable.ts.md#2025-04-23_snippet_5\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport interface Foldable3C<F extends URIS3, E> {\n  readonly URI: F\n  readonly _E: E\n  readonly reduce: <R, A, B>(fa: Kind3<F, R, E, A>, b: B, f: (b: B, a: A) => B) => B\n  readonly foldMap: <M>(M: Monoid<M>) => <R, A>(fa: Kind3<F, R, E, A>, f: (a: A) => M) => M\n  readonly reduceRight: <R, A, B>(fa: Kind3<F, R, E, A>, b: B, f: (a: A, b: B) => B) => B\n}\n```\n\n----------------------------------------\n\nTITLE: Defining ReaderT Interfaces in TypeScript\nDESCRIPTION: Defines ReaderT interfaces for different URIS levels (ReaderT1, ReaderT2, ReaderT3) and a general ReaderT interface. These interfaces represent functions that take a value of type R and return a value in the corresponding monad.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReaderT.ts.md#2025-04-23_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface ReaderT1<M extends URIS, R, A> {\n  (r: R): Kind<M, A>\n}\n\nexport interface ReaderT2<M extends URIS2, R, E, A> {\n  (r: R): Kind2<M, E, A>\n}\n\nexport interface ReaderT3<M extends URIS3, R, U, E, A> {\n  (r: R): Kind3<M, U, E, A>\n}\n\nexport interface ReaderT<M, R, A> {\n  (r: R): HKT<M, A>\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Witherable instance for Either in TypeScript\nDESCRIPTION: Defines a function to create a Witherable instance for Either given a Monoid for the left side.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Either.ts.md#2025-04-23_snippet_17\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare const getWitherable: <E>(M: Monoid<E>) => Witherable2C<'Either', E>\n```\n\n----------------------------------------\n\nTITLE: StateM3 Interface Definition in TypeScript\nDESCRIPTION: Interface definition for State Monad Transformer with URIS3. Similar to StateM3C but with flexible error type.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/StateT.ts.md#2025-04-23_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface StateM3<M extends URIS3> {\n  readonly map: <S, R, E, A, B>(fa: StateT3<M, S, R, E, A>, f: (a: A) => B) => StateT3<M, S, R, E, B>\n  readonly of: <S, R, E, A>(a: A) => StateT3<M, S, R, E, A>\n  readonly ap: <S, R, E, A, B>(\n    fab: StateT3<M, S, R, E, (a: A) => B>,\n    fa: StateT3<M, S, R, E, A>\n  ) => StateT3<M, S, R, E, B>\n  readonly chain: <S, R, E, A, B>(\n    fa: StateT3<M, S, R, E, A>,\n    f: (a: A) => StateT3<M, S, R, E, B>\n  ) => StateT3<M, S, R, E, B>\n  readonly get: <R, E, S>() => StateT3<M, S, R, E, S>\n  readonly put: <R, E, S>(s: S) => StateT3<M, S, R, E, void>\n  readonly modify: <R, E, S>(f: (s: S) => S) => StateT3<M, S, R, E, void>\n  readonly gets: <S, R, E, A>(f: (s: S) => A) => StateT3<M, S, R, E, A>\n  readonly fromState: <S, R, E, A>(fa: State<S, A>) => StateT3<M, S, R, E, A>\n  readonly fromM: <S, R, E, A>(ma: Kind3<M, R, E, A>) => StateT3<M, S, R, E, A>\n  readonly evalState: <S, R, E, A>(ma: StateT3<M, S, R, E, A>, s: S) => Kind3<M, R, E, A>\n  readonly execState: <S, R, E, A>(ma: StateT3<M, S, R, E, A>, s: S) => Kind3<M, R, E, S>\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Zero Function for IOOption in TypeScript\nDESCRIPTION: Defines the zero function for IOOption. It returns an IOOption representing the absence of a value.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/IOOption.ts.md#2025-04-23_snippet_53\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const zero: <A>() => IOOption<A>\n```\n\n----------------------------------------\n\nTITLE: Defining FromReader3 interface in TypeScript\nDESCRIPTION: The FromReader3 interface is a specialized version of FromReader for trifunctor monads. It provides a more specific type signature for the fromReader method using the URIS3 type encoding.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/FromReader.ts.md#2025-04-23_snippet_4\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport interface FromReader3<F extends URIS3> {\n  readonly URI: F\n  readonly fromReader: <R, A, E>(fa: Reader<R, A>) => Kind3<F, R, E, A>\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Show instance for Const in TypeScript\nDESCRIPTION: Creates a Show instance for Const given a Show for the first type parameter. This allows converting Const values to readable strings.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Const.ts.md#2025-04-23_snippet_16\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare function getShow<E, A>(S: Show<E>): Show<Const<E, A>>\n```\n\n----------------------------------------\n\nTITLE: Implementing endo Function for Magma in TypeScript\nDESCRIPTION: Defines the endo function that creates a new Magma by applying an endomorphism to the concat operation.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Magma.ts.md#2025-04-23_snippet_3\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare const endo: <A>(f: Endomorphism<A>) => (M: Magma<A>) => Magma<A>\n```\n\n----------------------------------------\n\nTITLE: Deprecated Array Deconstruction Operation (unsnoc)\nDESCRIPTION: Deprecated function for deconstructing a ReadonlyNonEmptyArray into a tuple of initial elements and last element. Users should use the unappend function instead.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReadonlyNonEmptyArray.ts.md#2025-04-23_snippet_82\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const unsnoc: <A>(as: ReadonlyNonEmptyArray<A>) => readonly [readonly A[], A]\n```\n\n----------------------------------------\n\nTITLE: Profunctor3C Interface Implementation\nDESCRIPTION: Constrained version of Profunctor3 with a fixed type parameter E. Extends Functor3C.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Profunctor.ts.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface Profunctor3C<F extends URIS3, E> extends Functor3C<F, E> {\n  readonly promap: <R, A, D, B>(fea: Kind3<F, R, E, A>, f: (d: D) => E, g: (a: A) => B) => Kind3<F, R, D, B>\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Unfoldable4 Interface in TypeScript\nDESCRIPTION: Variant of Unfoldable for type constructors with four type parameters. Adds state type parameter S.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Unfoldable.ts.md#2025-04-23_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface Unfoldable4<F extends URIS4> {\n  readonly URI: F\n  readonly unfold: <S, R, E, A, B>(b: B, f: (b: B) => Option<[A, B]>) => Kind4<F, S, R, E, A>\n}\n```\n\n----------------------------------------\n\nTITLE: Reverse Monoid Example\nDESCRIPTION: Example showing how to create and use a reversed monoid that swaps concat arguments.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Monoid.ts.md#2025-04-23_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nimport { reverse } from 'fp-ts/Monoid'\nimport * as S from 'fp-ts/string'\n\nassert.deepStrictEqual(reverse(S.Monoid).concat('a', 'b'), 'ba')\n```\n\n----------------------------------------\n\nTITLE: Defining Invariant3 Interface in TypeScript\nDESCRIPTION: Interface for Invariant type class with three type parameters. Extends URIS3 for higher-kinded types with three type parameters.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Invariant.ts.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface Invariant3<F extends URIS3> {\n  readonly URI: F\n  readonly imap: <R, E, A, B>(fa: Kind3<F, R, E, A>, f: (a: A) => B, g: (b: B) => A) => Kind3<F, R, E, B>\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing TaskThese Utility Functions\nDESCRIPTION: Collection of utility functions for TaskThese including ApT (empty tuple), swap (exchange error and value), and toTuple2 (convert to tuple).\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/TaskThese.ts.md#2025-04-23_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const ApT: TaskThese<never, readonly []>\n```\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const swap: <E, A>(fa: TaskThese<E, A>) => TaskThese<A, E>\n```\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const toTuple2: <E, A>(e: LazyArg<E>, a: LazyArg<A>) => (fa: TaskThese<E, A>) => T.Task<readonly [E, A]>\n```\n\n----------------------------------------\n\nTITLE: Defining Applicative3C Interface with Fixed First Type Parameter\nDESCRIPTION: Specialized Applicative interface for ternary type constructors where the first type parameter is fixed to type E.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Applicative.ts.md#2025-04-23_snippet_5\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport interface Applicative3C<F extends URIS3, E> extends Apply3C<F, E>, Pointed3C<F, E> {}\n```\n\n----------------------------------------\n\nTITLE: Creating Singleton ReadonlySet in TypeScript\nDESCRIPTION: Function to create a ReadonlySet containing a single element\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReadonlySet.ts.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const singleton: <A>(a: A) => ReadonlySet<A>\n```\n\n----------------------------------------\n\nTITLE: Implementing Utility Functions for Traced\nDESCRIPTION: Collection of utility functions for manipulating and extracting values from Traced contexts.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Traced.ts.md#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare function censor<P>(f: (p: P) => P): <A>(wa: Traced<P, A>) => Traced<P, A>\n```\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare function listen<P, A>(wa: Traced<P, A>): Traced<P, [A, P]>\n```\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare function listens<P, B>(f: (p: P) => B): <A>(wa: Traced<P, A>) => Traced<P, [A, B]>\n```\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare function tracks<P, A>(M: Monoid<P>, f: (a: A) => P): (wa: Traced<P, A>) => A\n```\n\n----------------------------------------\n\nTITLE: Implementing HKT3 Interface for `* -> * -> * -> *` Constructors in TypeScript\nDESCRIPTION: Defines the HKT3 interface for ternary type constructors that take three type parameters. It extends HKT2 and adds an additional type parameter R.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/HKT.ts.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface HKT3<URI, R, E, A> extends HKT2<URI, E, A> {\n  readonly _R: R\n}\n```\n\n----------------------------------------\n\nTITLE: Defining chainFirstTaskK for StateReaderTaskEither in TypeScript\nDESCRIPTION: Implements chainFirstTaskK as an alias of tapTask. It chains a Task operation after a StateReaderTaskEither, discarding the result of the Task operation.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/StateReaderTaskEither.ts.md#2025-04-23_snippet_10\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare const chainFirstTaskK: <A, B>(\n  f: (a: A) => Task<B>\n) => <S, R, E>(first: StateReaderTaskEither<S, R, E, A>) => StateReaderTaskEither<S, R, E, A>\n```\n\n----------------------------------------\n\nTITLE: URI Type Definitions\nDESCRIPTION: Type definitions for ReadonlyMap URI constant and type alias.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReadonlyMap.ts.md#2025-04-23_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const URI: 'ReadonlyMap'\n```\n\nLANGUAGE: typescript\nCODE:\n```\nexport type URI = typeof URI\n```\n\n----------------------------------------\n\nTITLE: Implementing traverseWithIndex for ReadonlyNonEmptyArray in TypeScript\nDESCRIPTION: Traverses a ReadonlyNonEmptyArray with an index-aware function.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReadonlyNonEmptyArray.ts.md#2025-04-23_snippet_28\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const traverseWithIndex: PipeableTraverseWithIndex1<'ReadonlyNonEmptyArray', number>\n```\n\n----------------------------------------\n\nTITLE: Importing fp-ts Module Reference\nDESCRIPTION: Basic module reference showing how to use fp-ts in TypeScript. While not an actual code snippet, this is referenced in the documentation for modules/function.ts.html\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/index.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nfp-ts\n```\n\n----------------------------------------\n\nTITLE: Defining Deprecated FunctorWithIndexComposition12 Interface in TypeScript\nDESCRIPTION: Deprecated interface for composing a FunctorWithIndex1 with a FunctorWithIndex2, extending FunctorComposition12.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/FunctorWithIndex.ts.md#2025-04-23_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface FunctorWithIndexComposition12<F extends URIS, FI, G extends URIS2, GI>\n  extends FunctorComposition12<F, G> {\n  readonly mapWithIndex: <E, A, B>(fa: Kind<F, Kind2<G, E, A>>, f: (i: [FI, GI], a: A) => B) => Kind<F, Kind2<G, E, B>>\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Separated Constructor in TypeScript\nDESCRIPTION: Defines the separated function, which creates a new Separated instance with the given left and right values.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Separated.ts.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const separated: <E, A>(left: E, right: A) => Separated<E, A>\n```\n\n----------------------------------------\n\nTITLE: Deprecated Tuple Ring Generator\nDESCRIPTION: Deprecated function signature for creating a Ring instance for tuples. Users should use the tuple function instead.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Ring.ts.md#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const getTupleRing: <T extends readonly Ring<any>[]>(\n  ...rings: T\n) => Ring<{ [K in keyof T]: T[K] extends Ring<infer A> ? A : never }>\n```\n\n----------------------------------------\n\nTITLE: Defining WriterT1 Interface for URIS\nDESCRIPTION: Interface definition for Writer transformer with single type parameter URIS constraint.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/WriterT.ts.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface WriterT1<M extends URIS, W, A> {\n  (): Kind<M, [A, W]>\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Kind4 Type Alias for `* -> * -> * -> * -> *` Constructors in TypeScript\nDESCRIPTION: Creates a type alias for quaternary type constructors, which maps a URI (type identifier) to its corresponding type implementation with four type parameters.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/HKT.ts.md#2025-04-23_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nexport type Kind4<URI extends URIS4, S, R, E, A> = URI extends URIS4 ? URItoKind4<S, R, E, A>[URI] : any\n```\n\n----------------------------------------\n\nTITLE: Defining Unfoldable3 Interface in TypeScript\nDESCRIPTION: Variant of Unfoldable for type constructors with three type parameters. Adds resource type parameter R.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Unfoldable.ts.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface Unfoldable3<F extends URIS3> {\n  readonly URI: F\n  readonly unfold: <R, E, A, B>(b: B, f: (b: B) => Option<[A, B]>) => Kind3<F, R, E, A>\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing concatAll Function for Magma in TypeScript\nDESCRIPTION: Defines the concatAll function that concatenates a sequence of values using a given Magma. If the sequence is empty, it returns the provided start value.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Magma.ts.md#2025-04-23_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare const concatAll: <A>(M: Magma<A>) => (startWith: A) => (as: readonly A[]) => A\n```\n\n----------------------------------------\n\nTITLE: Implementing ApSecond Function for IOOption in TypeScript\nDESCRIPTION: Defines the apSecond function for IOOption. It combines two effectful actions, keeping only the result of the second.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/IOOption.ts.md#2025-04-23_snippet_52\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const apSecond: <B>(second: IOOption<B>) => <A>(first: IOOption<A>) => IOOption<B>\n```\n\n----------------------------------------\n\nTITLE: Defining PipeableChain4 Interface in TypeScript\nDESCRIPTION: This interface extends PipeableApply4 and defines chain, chainFirst, and flatten operations for a higher-kinded type F with four type parameters.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/pipeable.ts.md#2025-04-23_snippet_36\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface PipeableChain4<F extends URIS4> extends PipeableApply4<F> {\n  readonly chain: <S, R, E, A, B>(\n    f: (a: A) => Kind4<F, S, R, E, B>\n  ) => (ma: Kind4<F, S, R, E, A>) => Kind4<F, S, R, E, B>\n  readonly chainFirst: <S, R, E, A, B>(\n    f: (a: A) => Kind4<F, S, R, E, B>\n  ) => (ma: Kind4<F, S, R, E, A>) => Kind4<F, S, R, E, A>\n  readonly flatten: <S, R, E, A>(mma: Kind4<F, S, R, E, Kind4<F, S, R, E, A>>) => Kind4<F, S, R, E, A>\n}\n```\n\n----------------------------------------\n\nTITLE: Defining PipeableFilterable2 Interface in TypeScript\nDESCRIPTION: Interface definition for PipeableFilterable2 which extends PipeableCompactable2 with filtering operations for higher-kinded types of arity 2. It provides methods for filtering, mapping options, and partitioning data structures.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/pipeable.ts.md#2025-04-23_snippet_42\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface PipeableFilterable2<F extends URIS2> extends PipeableCompactable2<F> {\n  readonly filter: {\n    <A, B extends A>(refinement: Refinement<A, B>): <E>(fa: Kind2<F, E, A>) => Kind2<F, E, B>\n    <A>(predicate: Predicate<A>): <E>(fa: Kind2<F, E, A>) => Kind2<F, E, A>\n  }\n  readonly filterMap: <A, B>(f: (a: A) => Option<B>) => <E>(fa: Kind2<F, E, A>) => Kind2<F, E, B>\n  readonly partition: {\n    <A, B extends A>(refinement: Refinement<A, B>): <E>(fa: Kind2<F, E, A>) => Separated<Kind2<F, E, A>, Kind2<F, E, B>>\n    <A>(predicate: Predicate<A>): <E>(fa: Kind2<F, E, A>) => Separated<Kind2<F, E, A>, Kind2<F, E, A>>\n  }\n  readonly partitionMap: <A, B, C>(\n    f: (a: A) => Either<B, C>\n  ) => <E>(fa: Kind2<F, E, A>) => Separated<Kind2<F, E, B>, Kind2<F, E, C>>\n}\n```\n\n----------------------------------------\n\nTITLE: reduceRightWithIndex Composition Utility\nDESCRIPTION: Utility function to compose reduceRightWithIndex operations from two FoldableWithIndex instances, creating a combined index as a tuple [I, J].\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/FoldableWithIndex.ts.md#2025-04-23_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare function reduceRightWithIndex<F extends URIS, I, G extends URIS, J>(\n  F: FoldableWithIndex1<F, I>,\n  G: FoldableWithIndex1<G, J>\n): <B, A>(b: B, f: (ij: readonly [I, J], a: A, b: B) => B) => (fga: Kind<F, Kind<G, A>>) => B\nexport declare function reduceRightWithIndex<F, I, G, J>(\n  F: FoldableWithIndex<F, I>,\n  G: FoldableWithIndex<G, J>\n): <B, A>(b: B, f: (ij: readonly [I, J], a: A, b: B) => B) => (fga: HKT<F, HKT<G, A>>) => B\n```\n\n----------------------------------------\n\nTITLE: Defining Deprecated FunctorWithIndexComposition21 Interface in TypeScript\nDESCRIPTION: Deprecated interface for composing a FunctorWithIndex2 with a FunctorWithIndex1, extending FunctorComposition21.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/FunctorWithIndex.ts.md#2025-04-23_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface FunctorWithIndexComposition21<F extends URIS2, FI, G extends URIS, GI>\n  extends FunctorComposition21<F, G> {\n  readonly mapWithIndex: <E, A, B>(fa: Kind2<F, E, Kind<G, A>>, f: (i: [FI, GI], a: A) => B) => Kind2<F, E, Kind<G, B>>\n}\n```\n\n----------------------------------------\n\nTITLE: Deprecated Array Append Operation (snoc)\nDESCRIPTION: Deprecated function for appending an element to the end of a readonly array. Users should use the append function from ReadonlyArray module instead.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReadonlyNonEmptyArray.ts.md#2025-04-23_snippet_80\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const snoc: <A>(init: readonly A[], end: A) => ReadonlyNonEmptyArray<A>\n```\n\n----------------------------------------\n\nTITLE: Taking Right Elements from ReadonlyArray in TypeScript\nDESCRIPTION: Keeps a maximum number of elements from the end of a readonly array, creating a new array. The number is normalized to a non-negative integer.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReadonlyArray.ts.md#2025-04-23_snippet_62\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const takeRight: (n: number) => <A>(as: readonly A[]) => readonly A[]\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as RA from 'fp-ts/ReadonlyArray'\nimport { pipe } from 'fp-ts/function'\n\nconst input: ReadonlyArray<number> = [1, 2, 3]\nassert.deepStrictEqual(pipe(input, RA.takeRight(2)), [2, 3])\n\n// out of bounds\nassert.strictEqual(pipe(input, RA.takeRight(4)), input)\nassert.strictEqual(pipe(input, RA.takeRight(-1)), input)\n```\n\n----------------------------------------\n\nTITLE: Implementing chainIOEitherKW in TypeScript for ReaderTaskEither\nDESCRIPTION: Widening version of chainIOEitherK that allows for different error types. It takes a function from A to IOEither<E2, B> and returns a function that transforms a ReaderTaskEither<R, E1, A> into a ReaderTaskEither<R, E1 | E2, B>.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReaderTaskEither.ts.md#2025-04-23_snippet_39\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const chainIOEitherKW: <E2, A, B>(\n  f: (a: A) => IOEither<E2, B>\n) => <R, E1>(ma: ReaderTaskEither<R, E1, A>) => ReaderTaskEither<R, E2 | E1, B>\n```\n\n----------------------------------------\n\nTITLE: Implementing Pipeable Extend Operator in TypeScript\nDESCRIPTION: Provides a pipeable version of extend for comonadic operations.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/pipeable.ts.md#2025-04-23_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare function extend<F extends URIS4>(\n  F: Extend4<F>\n): <S, R, E, A, B>(f: (wa: Kind4<F, S, R, E, A>) => B) => (wa: Kind4<F, S, R, E, A>) => Kind4<F, S, R, E, B>\n```\n\n----------------------------------------\n\nTITLE: Implementing chain for ReadonlyNonEmptyArray in TypeScript\nDESCRIPTION: Alias of flatMap for ReadonlyNonEmptyArray.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReadonlyNonEmptyArray.ts.md#2025-04-23_snippet_17\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const chain: <A, B>(\n  f: (a: A) => ReadonlyNonEmptyArray<B>\n) => (ma: ReadonlyNonEmptyArray<A>) => ReadonlyNonEmptyArray<B>\n```\n\n----------------------------------------\n\nTITLE: Defining apSecond Function for ReaderTaskEither in TypeScript\nDESCRIPTION: Function signature for apSecond that combines two ReaderTaskEither values, keeping only the result of the second one. Added in v2.0.0.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReaderTaskEither.ts.md#2025-04-23_snippet_113\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const apSecond: <R, E, B>(\n  second: ReaderTaskEither<R, E, B>\n) => <A>(first: ReaderTaskEither<R, E, A>) => ReaderTaskEither<R, E, B>\n```\n\n----------------------------------------\n\nTITLE: Creating an IOEither Value\nDESCRIPTION: Creates a value of type IOEither<Error, string> which will be used to demonstrate Kleisli arrow transformations.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/guides/code-conventions.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as IE from 'fp-ts/IOEither'\n\nconst input: IE.IOEither<Error, string> = IE.right('foo')\n```\n\n----------------------------------------\n\nTITLE: Implementing flap for Applicative Application\nDESCRIPTION: Applies a value to a function inside a ReaderTaskEither context, useful for applying a static value to a function in an effect context.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReaderTaskEither.ts.md#2025-04-23_snippet_76\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const flap: <A>(a: A) => <R, E, B>(fab: ReaderTaskEither<R, E, (a: A) => B>) => ReaderTaskEither<R, E, B>\n```\n\n----------------------------------------\n\nTITLE: Contravariant4 Interface with Four Type Parameters\nDESCRIPTION: Defines a Contravariant interface for type constructors with four type parameters, using Kind4 for type-safe operations.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Contravariant.ts.md#2025-04-23_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface Contravariant4<F extends URIS4> {\n  readonly URI: F\n  readonly contramap: <S, R, E, A, B>(fa: Kind4<F, S, R, E, A>, f: (b: B) => A) => Kind4<F, S, R, E, B>\n}\n```\n\n----------------------------------------\n\nTITLE: Applying Properties in Do Notation for TaskEither in TypeScript\nDESCRIPTION: Applies a TaskEither to an existing object in a do notation chain.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/TaskEither.ts.md#2025-04-23_snippet_10\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare const apS: <N, A, E, B>(\n  name: Exclude<N, keyof A>,\n  fb: TaskEither<E, B>\n) => (fa: TaskEither<E, A>) => TaskEither<E, { readonly [K in N | keyof A]: K extends keyof A ? A[K] : B }>\n```\n\n----------------------------------------\n\nTITLE: Defining TaskThese URI Constants\nDESCRIPTION: Type identifier constants for TaskThese type. Used for type-level programming and type class instances.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/TaskThese.ts.md#2025-04-23_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const URI: 'TaskThese'\n```\n\nLANGUAGE: typescript\nCODE:\n```\nexport type URI = typeof URI\n```\n\n----------------------------------------\n\nTITLE: Implementing Flap Function for Traced\nDESCRIPTION: Flap operator implementation for applying Traced functions to values.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Traced.ts.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const flap: <A>(a: A) => <E, B>(fab: Traced<E, (a: A) => B>) => Traced<E, B>\n```\n\n----------------------------------------\n\nTITLE: Implementing apFirstW for StateReaderTaskEither in TypeScript\nDESCRIPTION: Provides a widening version of apFirst (apFirstW) that merges environment and error types when combining two StateReaderTaskEither effects, keeping only the result of the first.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/StateReaderTaskEither.ts.md#2025-04-23_snippet_62\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare const apFirstW: <S, R2, E2, A, B>(\n  second: StateReaderTaskEither<S, R2, E2, B>\n) => <R1, E1>(first: StateReaderTaskEither<S, R1, E1, A>) => StateReaderTaskEither<S, R1 & R2, E2 | E1, A>\n```\n\n----------------------------------------\n\nTITLE: Implementing flap for StateReaderTaskEither in TypeScript\nDESCRIPTION: Defines a function to apply a value to a StateReaderTaskEither containing a function.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/StateReaderTaskEither.ts.md#2025-04-23_snippet_39\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare const flap: <A>(\n  a: A\n) => <S, R, E, B>(fab: StateReaderTaskEither<S, R, E, (a: A) => B>) => StateReaderTaskEither<S, R, E, B>\n```\n\n----------------------------------------\n\nTITLE: Deprecated TaskThese Functions and Instances\nDESCRIPTION: Collection of deprecated functions and type class instances that should be replaced with newer alternatives.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/TaskThese.ts.md#2025-04-23_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const bifunctorTaskThese: Bifunctor2<'TaskThese'>\n```\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const functorTaskThese: Functor2<'TaskThese'>\n```\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const getSemigroup: <E, A>(SE: Semigroup<E>, SA: Semigroup<A>) => Semigroup<TaskThese<E, A>>\n```\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const taskThese: Functor2<'TaskThese'> & Bifunctor2<'TaskThese'>\n```\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const toTuple: <E, A>(e: E, a: A) => (fa: TaskThese<E, A>) => T.Task<[E, A]>\n```\n\n----------------------------------------\n\nTITLE: Pattern Matching Functions\nDESCRIPTION: Functions for handling both success and error cases in ReaderEither values using pattern matching.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReaderEither.ts.md#2025-04-23_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const match: <E, B, A>(onLeft: (e: E) => B, onRight: (a: A) => B) => <R>(ma: ReaderEither<R, E, A>) => R.Reader<R, B>\n```\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const matchE: <R, E, A, B>(onLeft: (e: E) => R.Reader<R, B>, onRight: (a: A) => R.Reader<R, B>) => (ma: ReaderEither<R, E, A>) => R.Reader<R, B>\n```\n\n----------------------------------------\n\nTITLE: URI type alias for Eq in TypeScript\nDESCRIPTION: Type alias for the URI of the Eq type class, used for type-level operations.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Eq.ts.md#2025-04-23_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nexport type URI = typeof URI\n```\n\n----------------------------------------\n\nTITLE: Defining Functor Instance for Separated in TypeScript\nDESCRIPTION: Declares the Functor instance for the Separated type, which provides methods for mapping over the second type argument of the bifunctor.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Separated.ts.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const Functor: Functor2<'Separated'>\n```\n\n----------------------------------------\n\nTITLE: Defining BoundedMeetSemilattice Interface in TypeScript\nDESCRIPTION: TypeScript interface definition for BoundedMeetSemilattice that extends MeetSemilattice. It adds a 'one' property of type A, representing the identity element for the meet operation.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/BoundedMeetSemilattice.ts.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface BoundedMeetSemilattice<A> extends MeetSemilattice<A> {\n  readonly one: A\n}\n```\n\n----------------------------------------\n\nTITLE: Deprecated parseJSON Function in fp-ts\nDESCRIPTION: A deprecated function for parsing JSON strings. It takes a string input and an error handler function, returning an Either type with either the parsed JSON or an error. Users should use the `parse` function from Json.ts instead.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Either.ts.md#2025-04-23_snippet_32\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare function parseJSON<E>(s: string, onError: (reason: unknown) => E): Either<E, Json>\n```\n\n----------------------------------------\n\nTITLE: Traversable Instance Creation\nDESCRIPTION: Function signatures for creating Traversable instances for ReadonlyMap with ordering.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReadonlyMap.ts.md#2025-04-23_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const getTraversable: <K>(O: Ord<K>) => Traversable2C<'ReadonlyMap', K>\n```\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const getTraversableWithIndex: <K>(O: Ord<K>) => TraversableWithIndex2C<'ReadonlyMap', K, K>\n```\n\n----------------------------------------\n\nTITLE: Defining PipeableMonadThrow1 Interface in TypeScript\nDESCRIPTION: A pipeable version of the MonadThrow type class for higher-kinded types of arity 1. Provides methods for working with error handling monads, including conversion from Option/Either and predicate-based filtering.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/pipeable.ts.md#2025-04-23_snippet_76\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface PipeableMonadThrow1<F extends URIS> {\n  readonly fromOption: <E>(onNone: LazyArg<E>) => <A>(ma: Option<A>) => Kind<F, A>\n  readonly fromEither: <E, A>(ma: Either<E, A>) => Kind<F, A>\n  readonly fromPredicate: {\n    <E, A, B extends A>(refinement: Refinement<A, B>, onFalse: (a: A) => E): (a: A) => Kind<F, B>\n    <E, A>(predicate: Predicate<A>, onFalse: (a: A) => E): (a: A) => Kind<F, A>\n  }\n  readonly filterOrElse: {\n    <E, A, B extends A>(refinement: Refinement<A, B>, onFalse: (a: A) => E): (ma: Kind<F, A>) => Kind<F, B>\n    <E, A>(predicate: Predicate<A>, onFalse: (a: A) => E): (ma: Kind<F, A>) => Kind<F, A>\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Extend3 Interface for Ternary Type Constructors\nDESCRIPTION: Defines the Extend3 interface for ternary type constructors that extends Functor3 and provides the extend method with appropriate type parameters.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Extend.ts.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface Extend3<W extends URIS3> extends Functor3<W> {\n  readonly extend: <R, E, A, B>(wa: Kind3<W, R, E, A>, f: (wa: Kind3<W, R, E, A>) => B) => Kind3<W, R, E, B>\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Category3 Interface in TypeScript\nDESCRIPTION: Defines Category3 interface extending Semigroupoid3 with URIS3 constraint. Includes an identity function returning Kind3 type with additional type parameter R.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Category.ts.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface Category3<F extends URIS3> extends Semigroupoid3<F> {\n  readonly id: <R, A>() => Kind3<F, R, A, A>\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Show Type Class for Numbers\nDESCRIPTION: Type class instance for converting numbers to strings.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/number.ts.md#2025-04-23_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const Show: S.Show<number>\n```\n\n----------------------------------------\n\nTITLE: Defining Higher-Kinded Separate Function\nDESCRIPTION: Implementation of the separate operation for composed functors with various type constraints and arities.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Compactable.ts.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare function separate<F extends URIS2, G extends URIS2, E>(\n  F: Functor2<F>,\n  C: Compactable2C<G, E>,\n  G: Functor2<G>\n): <FE, A, B>(\n  fge: Kind2<F, FE, Kind2<G, E, Either<A, B>>>\n) => S.Separated<Kind2<F, FE, Kind2<G, E, A>>, Kind2<F, FE, Kind2<G, E, B>>>\n```\n\n----------------------------------------\n\nTITLE: Defining PipeableFunctor2 Interface in TypeScript\nDESCRIPTION: A pipeable version of the Functor type class for higher-kinded types of arity 2. Provides the map method for functors with a generic error type parameter.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/pipeable.ts.md#2025-04-23_snippet_66\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface PipeableFunctor2<F extends URIS2> {\n  readonly map: <A, B>(f: (a: A) => B) => <E>(fa: Kind2<F, E, A>) => Kind2<F, E, B>\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Semigroupoid4 Interface in TypeScript\nDESCRIPTION: Defines the Semigroupoid4 interface for a higher-kinded type F extending URIS4. It includes a URI property and a compose method for combining two morphisms with four type parameters.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Semigroupoid.ts.md#2025-04-23_snippet_5\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport interface Semigroupoid4<F extends URIS4> {\n  readonly URI: F\n  readonly compose: <S, R, A, B, C>(ab: Kind4<F, S, R, B, C>, la: Kind4<F, S, R, A, B>) => Kind4<F, S, R, A, C>\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Deprecated FunctorWithIndexComposition Interface in TypeScript\nDESCRIPTION: Deprecated base interface for composing two FunctorWithIndex instances, extending FunctorComposition.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/FunctorWithIndex.ts.md#2025-04-23_snippet_15\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface FunctorWithIndexComposition<F, FI, G, GI> extends FunctorComposition<F, G> {\n  readonly mapWithIndex: <A, B>(fga: HKT<F, HKT<G, A>>, f: (i: [FI, GI], a: A) => B) => HKT<F, HKT<G, B>>\n}\n```\n\n----------------------------------------\n\nTITLE: Deprecated struct equality in TypeScript\nDESCRIPTION: Deprecated function for creating Eq instances for struct types. Users should use the struct function instead.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Eq.ts.md#2025-04-23_snippet_18\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const getStructEq: <O extends Readonly<Record<string, any>>>(eqs: { [K in keyof O]: Eq<O[K]> }) => Eq<O>\n```\n\n----------------------------------------\n\nTITLE: Implementing matchW Function for These in TypeScript\nDESCRIPTION: Defines a widening match function for These, allowing different return types for each case handler.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/These.ts.md#2025-04-23_snippet_13\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare const matchW: <E, B, A, C, D>(\n  onLeft: (e: E) => B,\n  onRight: (a: A) => C,\n  onBoth: (e: E, a: A) => D\n) => (fa: These<E, A>) => B | C | D\n```\n\n----------------------------------------\n\nTITLE: Functor2 Interface Definition\nDESCRIPTION: The TypeScript definition of the Functor2 interface from fp-ts. This interface describes type classes for functors of kind * -> * -> *.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/guides/HKT.md#2025-04-23_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\n// fp-ts/Functor.ts\n\nexport interface Functor2<F extends URIS2> {\n  readonly URI: F\n  readonly map: <E, A, B>(fa: Kind2<F, E, A>, f: (a: A) => B) => Kind2<F, E, B>\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing getSemigroup for ReadonlyNonEmptyArray in TypeScript\nDESCRIPTION: Builds a Semigroup instance for ReadonlyNonEmptyArray.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReadonlyNonEmptyArray.ts.md#2025-04-23_snippet_15\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const getSemigroup: <A = never>() => Se.Semigroup<ReadonlyNonEmptyArray<A>>\n```\n\n----------------------------------------\n\nTITLE: Implementing orElseFirstW with Error Type Widening in TypeScript\nDESCRIPTION: A type-widening version of orElseFirst that merges error types when executing a side effect on the error channel.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/TaskEither.ts.md#2025-04-23_snippet_47\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const orElseFirstW: <E1, E2, B>(\n  onLeft: (e: E1) => TaskEither<E2, B>\n) => <A>(ma: TaskEither<E1, A>) => TaskEither<E1 | E2, A>\n```\n\n----------------------------------------\n\nTITLE: Initial Lift Function Implementation\nDESCRIPTION: A first attempt at implementing a lift function that abstracts over functors. This version has a type error because it doesn't properly handle the different kinds of functors.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/guides/HKT.md#2025-04-23_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nimport { HKT } from 'fp-ts/HKT'\n\nexport function lift<F>(F: Functor<F>): <A, B>(f: (a: A) => B) => (fa: HKT<F, A>) => HKT<F, B> {\n  return (f) => (fa) => F.map(fa, f)\n}\n```\n\n----------------------------------------\n\nTITLE: Defining flap function for ReaderIO in TypeScript\nDESCRIPTION: Applies a value to a ReaderIO of functions. It takes a value and a ReaderIO of functions, and returns a ReaderIO with the function applied to the value.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReaderIO.ts.md#2025-04-23_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const flap: <A>(a: A) => <E, B>(fab: ReaderIO<E, (a: A) => B>) => ReaderIO<E, B>\n```\n\n----------------------------------------\n\nTITLE: URI constant for Eq type class in TypeScript\nDESCRIPTION: Constant representing the unique identifier for the Eq type class in the fp-ts ecosystem.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Eq.ts.md#2025-04-23_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const URI: 'Eq'\n```\n\n----------------------------------------\n\nTITLE: Ring Tuple Usage Example\nDESCRIPTION: Example demonstrating how to create and use a Ring instance for 3-element numeric tuples.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Ring.ts.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { tuple } from 'fp-ts/Ring'\nimport * as N from 'fp-ts/number'\n\nconst R = tuple(N.Field, N.Field, N.Field)\nassert.deepStrictEqual(R.add([1, 2, 3], [4, 5, 6]), [5, 7, 9])\nassert.deepStrictEqual(R.mul([1, 2, 3], [4, 5, 6]), [4, 10, 18])\nassert.deepStrictEqual(R.one, [1, 1, 1])\nassert.deepStrictEqual(R.sub([1, 2, 3], [4, 5, 6]), [-3, -3, -3])\nassert.deepStrictEqual(R.zero, [0, 0, 0])\n```\n\n----------------------------------------\n\nTITLE: Profunctor2C Interface Implementation\nDESCRIPTION: Constrained version of Profunctor2 with a fixed type parameter E. Extends Functor2C.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Profunctor.ts.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface Profunctor2C<F extends URIS2, E> extends Functor2C<F, E> {\n  readonly promap: <A, D, B>(fea: Kind2<F, E, A>, f: (d: D) => E, g: (a: A) => B) => Kind2<F, D, B>\n}\n```\n\n----------------------------------------\n\nTITLE: Defining PipeableFoldable1 Interface in TypeScript\nDESCRIPTION: A pipeable version of the Foldable1 type class for higher-kinded types of arity 1. It provides methods for folding (reducing) a data structure, including reduce, foldMap, and reduceRight.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/pipeable.ts.md#2025-04-23_snippet_52\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface PipeableFoldable1<F extends URIS> {\n  readonly reduce: <A, B>(b: B, f: (b: B, a: A) => B) => (fa: Kind<F, A>) => B\n  readonly foldMap: <M>(M: Monoid<M>) => <A>(f: (a: A) => M) => (fa: Kind<F, A>) => M\n  readonly reduceRight: <A, B>(b: B, f: (a: A, b: B) => B) => (fa: Kind<F, A>) => B\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Extend4 Interface for Quaternary Type Constructors\nDESCRIPTION: Defines the Extend4 interface for quaternary type constructors that extends Functor4 and provides the extend method with appropriate type parameters.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Extend.ts.md#2025-04-23_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface Extend4<W extends URIS4> extends Functor4<W> {\n  readonly extend: <S, R, E, A, B>(wa: Kind4<W, S, R, E, A>, f: (wa: Kind4<W, S, R, E, A>) => B) => Kind4<W, S, R, E, B>\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing apSecond for ReadonlyNonEmptyArray in TypeScript\nDESCRIPTION: Combines two effectful actions, keeping only the result of the second.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReadonlyNonEmptyArray.ts.md#2025-04-23_snippet_34\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const apSecond: <B>(\n  second: ReadonlyNonEmptyArray<B>\n) => <A>(first: ReadonlyNonEmptyArray<A>) => ReadonlyNonEmptyArray<B>\n```\n\n----------------------------------------\n\nTITLE: Deprecated FoldableWithIndex interface for Records in TypeScript\nDESCRIPTION: A deprecated implementation of the FoldableWithIndex typeclass for Records. Users should now use getFoldableWithIndex instead.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Record.ts.md#2025-04-23_snippet_56\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const FoldableWithIndex: FoldableWithIndex1<'Record', string>\n```\n\n----------------------------------------\n\nTITLE: Defining getReaderM Function in TypeScript\nDESCRIPTION: Declares the getReaderM function with multiple overloads to handle different URIS levels. It takes a Monad instance and returns the corresponding ReaderM instance.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReaderT.ts.md#2025-04-23_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare function getReaderM<M extends URIS3>(M: Monad3<M>): ReaderM3<M>\nexport declare function getReaderM<M extends URIS2>(M: Monad2<M>): ReaderM2<M>\nexport declare function getReaderM<M extends URIS2, E>(M: Monad2C<M, E>): ReaderM2C<M, E>\nexport declare function getReaderM<M extends URIS>(M: Monad1<M>): ReaderM1<M>\nexport declare function getReaderM<M>(M: Monad<M>): ReaderM<M>\n```\n\n----------------------------------------\n\nTITLE: Defining URI Type Alias for Endomorphism in TypeScript\nDESCRIPTION: Creates a type alias for the URI constant to be used in type definitions throughout the library.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Endomorphism.ts.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nexport type URI = typeof URI\n```\n\n----------------------------------------\n\nTITLE: Defining apSecondW Function for ReaderTaskEither in TypeScript\nDESCRIPTION: Function signature for apSecondW, a less strict version of apSecond that merges environment and error types. Added in v2.12.0.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReaderTaskEither.ts.md#2025-04-23_snippet_114\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const apSecondW: <R2, E2, B>(\n  second: ReaderTaskEither<R2, E2, B>\n) => <R1, E1, A>(first: ReaderTaskEither<R1, E1, A>) => ReaderTaskEither<R1 & R2, E2 | E1, B>\n```\n\n----------------------------------------\n\nTITLE: Pointed2C Interface with Fixed Error Type\nDESCRIPTION: Variant of Pointed2 with a fixed error type parameter E. Useful for functors where the error type is constant.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Pointed.ts.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface Pointed2C<F extends URIS2, E> {\n  readonly URI: F\n  readonly _E: E\n  readonly of: <A>(a: A) => Kind2<F, E, A>\n}\n```\n\n----------------------------------------\n\nTITLE: Deprecated stateReaderTaskEither instance in StateReaderTaskEither (TypeScript)\nDESCRIPTION: A deprecated monadic instance that provides parallel Monad, Bifunctor, Alt, MonadTask, and MonadThrow implementations for the StateReaderTaskEither type. Users should use small, specific instances instead.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/StateReaderTaskEither.ts.md#2025-04-23_snippet_79\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const stateReaderTaskEither: Monad4<'StateReaderTaskEither'> &\n  Bifunctor4<'StateReaderTaskEither'> &\n  Alt4<'StateReaderTaskEither'> &\n  MonadTask4<'StateReaderTaskEither'> &\n  MonadThrow4<'StateReaderTaskEither'>\n```\n\n----------------------------------------\n\nTITLE: Type-Widening Alt Operation for NonEmptyArray\nDESCRIPTION: A less strict version of the alt operation that allows combining non-empty arrays of different element types, resulting in a union type of elements. The W suffix indicates type widening behavior.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/NonEmptyArray.ts.md#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as NEA from 'fp-ts/NonEmptyArray'\nimport { pipe } from 'fp-ts/function'\n\nassert.deepStrictEqual(\n  pipe(\n    [1, 2, 3] as NEA.NonEmptyArray<number>,\n    NEA.altW(() => ['a', 'b'])\n  ),\n  [1, 2, 3, 'a', 'b']\n)\n```\n\n----------------------------------------\n\nTITLE: Defining Ordering Type\nDESCRIPTION: Type alias defining Ordering as a union type of -1, 0, or 1.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Ordering.ts.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nexport type Ordering = -1 | 0 | 1\n```\n\n----------------------------------------\n\nTITLE: Deprecated Function Semiring Creator in TypeScript\nDESCRIPTION: A deprecated function for creating a Semiring for functions. It's recommended to use the 'getSemiring' function from the function module instead.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Semiring.ts.md#2025-04-23_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare const getFunctionSemiring: <A, B>(S: Semiring<B>) => Semiring<(a: A) => B>\n```\n\n----------------------------------------\n\nTITLE: Implementing fromOptionK for StateReaderTaskEither in TypeScript\nDESCRIPTION: Defines a function to lift an Option-returning function into the StateReaderTaskEither context, with a provided error for None cases.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/StateReaderTaskEither.ts.md#2025-04-23_snippet_29\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare const fromOptionK: <E>(\n  onNone: LazyArg<E>\n) => <A extends readonly unknown[], B>(\n  f: (...a: A) => Option<B>\n) => <S, R = unknown>(...a: A) => StateReaderTaskEither<S, R, E, B>\n```\n\n----------------------------------------\n\nTITLE: Defining PipeableFilterableWithIndex1 Interface in TypeScript\nDESCRIPTION: Interface definition for PipeableFilterableWithIndex1 which extends PipeableFilterable1 adding index-aware filtering operations for higher-kinded types of arity 1. It provides methods that include index information when filtering and partitioning.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/pipeable.ts.md#2025-04-23_snippet_45\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface PipeableFilterableWithIndex1<F extends URIS, I> extends PipeableFilterable1<F> {\n  readonly filterWithIndex: {\n    <A, B extends A>(refinementWithIndex: RefinementWithIndex<I, A, B>): (fa: Kind<F, A>) => Kind<F, B>\n    <A>(predicateWithIndex: PredicateWithIndex<I, A>): (fa: Kind<F, A>) => Kind<F, A>\n  }\n  readonly filterMapWithIndex: <A, B>(f: (i: I, a: A) => Option<B>) => (fa: Kind<F, A>) => Kind<F, B>\n  readonly partitionWithIndex: {\n    <A, B extends A>(refinementWithIndex: RefinementWithIndex<I, A, B>): (\n      fa: Kind<F, A>\n    ) => Separated<Kind<F, A>, Kind<F, B>>\n    <A>(predicateWithIndex: PredicateWithIndex<I, A>): (fa: Kind<F, A>) => Separated<Kind<F, A>, Kind<F, A>>\n  }\n  readonly partitionMapWithIndex: <A, B, C>(\n    f: (i: I, a: A) => Either<B, C>\n  ) => (fa: Kind<F, A>) => Separated<Kind<F, B>, Kind<F, C>>\n}\n```\n\n----------------------------------------\n\nTITLE: StateM2 Interface Definition in TypeScript\nDESCRIPTION: Interface definition for State Monad Transformer with URIS2. Similar to StateM2C but without fixed error type.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/StateT.ts.md#2025-04-23_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface StateM2<M extends URIS2> {\n  readonly map: <S, E, A, B>(fa: StateT2<M, S, E, A>, f: (a: A) => B) => StateT2<M, S, E, B>\n  readonly of: <S, E, A>(a: A) => StateT2<M, S, E, A>\n  readonly ap: <S, E, A, B>(fab: StateT2<M, S, E, (a: A) => B>, fa: StateT2<M, S, E, A>) => StateT2<M, S, E, B>\n  readonly chain: <S, E, A, B>(fa: StateT2<M, S, E, A>, f: (a: A) => StateT2<M, S, E, B>) => StateT2<M, S, E, B>\n  readonly get: <E, S>() => StateT2<M, S, E, S>\n  readonly put: <E, S>(s: S) => StateT2<M, S, E, void>\n  readonly modify: <E, S>(f: (s: S) => S) => StateT2<M, S, E, void>\n  readonly gets: <S, E, A>(f: (s: S) => A) => StateT2<M, S, E, A>\n  readonly fromState: <S, E, A>(fa: State<S, A>) => StateT2<M, S, E, A>\n  readonly fromM: <S, E, A>(ma: Kind2<M, E, A>) => StateT2<M, S, E, A>\n  readonly evalState: <S, E, A>(ma: StateT2<M, S, E, A>, s: S) => Kind2<M, E, A>\n  readonly execState: <S, E, A>(ma: StateT2<M, S, E, A>, s: S) => Kind2<M, E, S>\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing LCM Function in TypeScript\nDESCRIPTION: Function signature for calculating the least common multiple of two values in a Field, requiring both Eq and Field type constraints.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Field.ts.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare function lcm<A>(E: Eq<A>, F: Field<A>): (x: A, y: A) => A\n```\n\n----------------------------------------\n\nTITLE: Implementing Deprecated getFunctorWithIndexComposition Function in TypeScript\nDESCRIPTION: Deprecated utility function for creating composed FunctorWithIndex instances with various type parameters. Users should use mapWithIndex instead.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/FunctorWithIndex.ts.md#2025-04-23_snippet_16\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare function getFunctorWithIndexComposition<F extends URIS2, FI, G extends URIS2, GI, E>(\n  F: FunctorWithIndex2<F, FI>,\n  G: FunctorWithIndex2C<G, FI, E>\n): FunctorWithIndexComposition22C<F, FI, G, GI, E>\nexport declare function getFunctorWithIndexComposition<F extends URIS2, FI, G extends URIS2, GI>(\n  F: FunctorWithIndex2<F, FI>,\n  G: FunctorWithIndex2<G, FI>\n): FunctorWithIndexComposition22<F, FI, G, GI>\nexport declare function getFunctorWithIndexComposition<F extends URIS2, FI, G extends URIS, GI, E>(\n  F: FunctorWithIndex2C<F, FI, E>,\n  G: FunctorWithIndex1<G, GI>\n): FunctorWithIndexComposition2C1<F, FI, G, GI, E>\nexport declare function getFunctorWithIndexComposition<F extends URIS2, FI, G extends URIS, GI>(\n  F: FunctorWithIndex2<F, FI>,\n  G: FunctorWithIndex1<G, GI>\n): FunctorWithIndexComposition21<F, FI, G, GI>\nexport declare function getFunctorWithIndexComposition<F extends URIS, FI, G extends URIS2, GI, E>(\n  F: FunctorWithIndex1<F, FI>,\n  G: FunctorWithIndex2C<G, GI, E>\n): FunctorWithIndexComposition12C<F, FI, G, GI, E>\nexport declare function getFunctorWithIndexComposition<F extends URIS, FI, G extends URIS2, GI>(\n  F: FunctorWithIndex1<F, FI>,\n  G: FunctorWithIndex2<G, GI>\n): FunctorWithIndexComposition12<F, FI, G, GI>\nexport declare function getFunctorWithIndexComposition<F extends URIS, FI, G extends URIS, GI>(\n  F: FunctorWithIndex1<F, FI>,\n  G: FunctorWithIndex1<G, GI>\n): FunctorWithIndexComposition11<F, FI, G, GI>\nexport declare function getFunctorWithIndexComposition<F, FI, G, GI>(\n  F: FunctorWithIndex<F, I>,\n  G: FunctorWithIndex<G, GI>\n): FunctorWithIndexComposition<F, FI, G, GI>\n```\n\n----------------------------------------\n\nTITLE: FromNullable Type Definition\nDESCRIPTION: Type definition for converting nullable values into Either monads with proper error handling.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/EitherT.ts.md#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare function fromNullable<F extends URIS3>(\n  F: Pointed3<F>\n): <E>(e: E) => <A, S, R>(a: A) => Kind3<F, S, R, Either<E, NonNullable<A>>>\n```\n\n----------------------------------------\n\nTITLE: Deprecated getApplyMonoid function for ReaderTaskEither in TypeScript\nDESCRIPTION: A deprecated function for getting an Apply Monoid for ReaderTaskEither. Users are advised to use getApplicativeMonoid from Applicative instead.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReaderTaskEither.ts.md#2025-04-23_snippet_121\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const getApplyMonoid: <R, E, A>(M: Monoid<A>) => Monoid<ReaderTaskEither<R, E, A>>\n```\n\n----------------------------------------\n\nTITLE: Replacing Error in TaskEither in TypeScript\nDESCRIPTION: Replaces the error in a TaskEither with a new error.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/TaskEither.ts.md#2025-04-23_snippet_28\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare const orLeft: <E1, E2>(onLeft: (e: E1) => T.Task<E2>) => <A>(fa: TaskEither<E1, A>) => TaskEither<E2, A>\n```\n\n----------------------------------------\n\nTITLE: Defining Contravariant Instance for Predicate in TypeScript\nDESCRIPTION: Declares a Contravariant instance for the Predicate type. This allows predicates to be mapped contravariantly.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Predicate.ts.md#2025-04-23_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare const Contravariant: Contravariant1<'Predicate'>\n```\n\n----------------------------------------\n\nTITLE: Defining URI Type Alias for IOOption in TypeScript\nDESCRIPTION: Declares the URI type alias for the IOOption type. It's used for type-level operations in the fp-ts ecosystem.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/IOOption.ts.md#2025-04-23_snippet_48\n\nLANGUAGE: typescript\nCODE:\n```\nexport type URI = typeof URI\n```\n\n----------------------------------------\n\nTITLE: Implementing chainReaderIOKW in TypeScript for ReaderTaskEither\nDESCRIPTION: Widening version of chainReaderIOK that allows for different environment types. It takes a function from A to ReaderIO<R2, B> and returns a function that transforms a ReaderTaskEither<R1, E, A> into a ReaderTaskEither<R1 & R2, E, B>.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReaderTaskEither.ts.md#2025-04-23_snippet_47\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const chainReaderIOKW: <A, R2, B>(\n  f: (a: A) => RIO.ReaderIO<R2, B>\n) => <R1, E>(ma: ReaderTaskEither<R1, E, A>) => ReaderTaskEither<R1 & R2, E, B>\n```\n\n----------------------------------------\n\nTITLE: Deprecated readerTaskEither instance for ReaderTaskEither in TypeScript\nDESCRIPTION: A deprecated instance combining multiple typeclasses for ReaderTaskEither. Users are advised to use smaller, specific instances instead.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReaderTaskEither.ts.md#2025-04-23_snippet_125\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const readerTaskEither: Monad3<'ReaderTaskEither'> &\n  Bifunctor3<'ReaderTaskEither'> &\n  Alt3<'ReaderTaskEither'> &\n  MonadTask3<'ReaderTaskEither'> &\n  MonadThrow3<'ReaderTaskEither'>\n```\n\n----------------------------------------\n\nTITLE: Defining Unfoldable1 Interface in TypeScript\nDESCRIPTION: Variant of Unfoldable for type constructors with one type parameter. Uses Kind instead of HKT for better type inference.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Unfoldable.ts.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface Unfoldable1<F extends URIS> {\n  readonly URI: F\n  readonly unfold: <A, B>(b: B, f: (b: B) => Option<[A, B]>) => Kind<F, A>\n}\n```\n\n----------------------------------------\n\nTITLE: Defining URI and URI Type for ReaderTaskEither in TypeScript\nDESCRIPTION: Constant and type alias for the unique identifier of the ReaderTaskEither functor. Added in v2.0.0.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReaderTaskEither.ts.md#2025-04-23_snippet_108\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const URI: 'ReaderTaskEither'\n```\n\nLANGUAGE: typescript\nCODE:\n```\nexport type URI = typeof URI\n```\n\n----------------------------------------\n\nTITLE: Defining Unfoldable2C Interface in TypeScript\nDESCRIPTION: Variant of Unfoldable2 with a fixed error type parameter E. Useful for type constructors that have a fixed error type.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Unfoldable.ts.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface Unfoldable2C<F extends URIS2, E> {\n  readonly URI: F\n  readonly _E: E\n  readonly unfold: <A, B>(b: B, f: (b: B) => Option<[A, B]>) => Kind2<F, E, A>\n}\n```\n\n----------------------------------------\n\nTITLE: Defining URI constant for ReaderIO in TypeScript\nDESCRIPTION: Defines a constant string identifier for the ReaderIO type.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReaderIO.ts.md#2025-04-23_snippet_20\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const URI: 'ReaderIO'\n```\n\n----------------------------------------\n\nTITLE: Identity Refinement Constructor\nDESCRIPTION: Creates an identity refinement that keeps the same type.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Refinement.ts.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const id: <A>() => Refinement<A, A>\n```\n\n----------------------------------------\n\nTITLE: Implementing getApplicativeMonoid Utility Function\nDESCRIPTION: A utility function that lifts a monoid into an applicative functor F. The inner values are concatenated using the provided Monoid instance. Multiple overloads are provided for different arities of higher-kinded types.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Applicative.ts.md#2025-04-23_snippet_7\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare function getApplicativeMonoid<F extends URIS4>(\n  F: Applicative4<F>\n): <A, S, R, E>(M: Monoid<A>) => Monoid<Kind4<F, S, R, E, A>>\nexport declare function getApplicativeMonoid<F extends URIS3>(\n  F: Applicative3<F>\n): <A, R, E>(M: Monoid<A>) => Monoid<Kind3<F, R, E, A>>\nexport declare function getApplicativeMonoid<F extends URIS3, E>(\n  F: Applicative3C<F, E>\n): <A, R>(M: Monoid<A>) => Monoid<Kind3<F, R, E, A>>\nexport declare function getApplicativeMonoid<F extends URIS2>(\n  F: Applicative2<F>\n): <A, E>(M: Monoid<A>) => Monoid<Kind2<F, E, A>>\nexport declare function getApplicativeMonoid<F extends URIS2, E>(\n  F: Applicative2C<F, E>\n): <A>(M: Monoid<A>) => Monoid<Kind2<F, E, A>>\nexport declare function getApplicativeMonoid<F extends URIS>(\n  F: Applicative1<F>\n): <A>(M: Monoid<A>) => Monoid<Kind<F, A>>\nexport declare function getApplicativeMonoid<F>(F: Applicative<F>): <A>(M: Monoid<A>) => Monoid<HKT<F, A>>\n```\n\n----------------------------------------\n\nTITLE: Deprecated stringifyJSON Function in fp-ts\nDESCRIPTION: A deprecated constant function for converting values to JSON strings. It takes an unknown value and an error handler function, returning an Either type with either the JSON string or an error. Users should use the `stringify` function from Json.ts instead.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Either.ts.md#2025-04-23_snippet_33\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const stringifyJSON: <E>(u: unknown, onError: (reason: unknown) => E) => Either<E, string>\n```\n\n----------------------------------------\n\nTITLE: Declaring getValidationM Function in TypeScript\nDESCRIPTION: Declares a deprecated function getValidationM with multiple overloads for different URIS types. It's recommended to use EitherT instead.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ValidationT.ts.md#2025-04-23_snippet_6\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare function getValidationM<E, M extends URIS2>(S: Semigroup<E>, M: Monad2<M>): ValidationM2<M, E>\nexport declare function getValidationM<E, M extends URIS>(S: Semigroup<E>, M: Monad1<M>): ValidationM1<M, E>\nexport declare function getValidationM<E, M>(S: Semigroup<E>, M: Monad<M>): ValidationM<M, E>\n```\n\n----------------------------------------\n\nTITLE: Defining ap Function for ReaderTaskEither in TypeScript\nDESCRIPTION: Function signature for ap that applies a ReaderTaskEither function to a ReaderTaskEither value. Added in v2.0.0.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReaderTaskEither.ts.md#2025-04-23_snippet_110\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const ap: <R, E, A>(\n  fa: ReaderTaskEither<R, E, A>\n) => <B>(fab: ReaderTaskEither<R, E, (a: A) => B>) => ReaderTaskEither<R, E, B>\n```\n\n----------------------------------------\n\nTITLE: Implementing TaskThese Non-Empty Array Traversal with Index Sequential\nDESCRIPTION: Function for traversing a readonly non-empty array with index using sequential applicative. Similar to parallel version but processes elements sequentially.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/TaskThese.ts.md#2025-04-23_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const traverseReadonlyNonEmptyArrayWithIndexSeq: <E>(\n  S: Semigroup<E>\n) => <A, B>(\n  f: (index: number, a: A) => TaskThese<E, B>\n) => (as: ReadonlyNonEmptyArray<A>) => TaskThese<E, ReadonlyNonEmptyArray<B>>\n```\n\n----------------------------------------\n\nTITLE: Deprecated Boolean Ordinal Implementation in TypeScript\nDESCRIPTION: Deprecated ordinal implementation for boolean values. Users should use the Ord implementation from boolean.ts instead.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Ord.ts.md#2025-04-23_snippet_27\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const ordBoolean: Ord<boolean>\n```\n\n----------------------------------------\n\nTITLE: Tree URI Type Definition\nDESCRIPTION: Constant and type alias definitions for Tree's URI identifier.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Tree.ts.md#2025-04-23_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const URI: 'Tree'\n```\n\nLANGUAGE: typescript\nCODE:\n```\nexport type URI = typeof URI\n```\n\n----------------------------------------\n\nTITLE: Implementing fromIOK Utility in TypeScript\nDESCRIPTION: Function that lifts an IO-returning function into a function that returns values in a higher-kinded type container. Supports variadic functions through the use of ReadonlyArray<unknown> for argument types.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/FromIO.ts.md#2025-04-23_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare function fromIOK<F extends URIS4>(\n  F: FromIO4<F>\n): <A extends ReadonlyArray<unknown>, B>(f: (...a: A) => IO<B>) => <S, R, E>(...a: A) => Kind4<F, S, R, E, B>\nexport declare function fromIOK<F extends URIS3>(\n  F: FromIO3<F>\n): <A extends ReadonlyArray<unknown>, B>(f: (...a: A) => IO<B>) => <R, E>(...a: A) => Kind3<F, R, E, B>\nexport declare function fromIOK<F extends URIS3, E>(\n  F: FromIO3C<F, E>\n): <A extends ReadonlyArray<unknown>, B>(f: (...a: A) => IO<B>) => <R>(...a: A) => Kind3<F, R, E, B>\nexport declare function fromIOK<F extends URIS2>(\n  F: FromIO2<F>\n): <A extends ReadonlyArray<unknown>, B>(f: (...a: A) => IO<B>) => <E>(...a: A) => Kind2<F, E, B>\nexport declare function fromIOK<F extends URIS2, E>(\n  F: FromIO2C<F, E>\n): <A extends ReadonlyArray<unknown>, B>(f: (...a: A) => IO<B>) => (...a: A) => Kind2<F, E, B>\nexport declare function fromIOK<F extends URIS>(\n  F: FromIO1<F>\n): <A extends ReadonlyArray<unknown>, B>(f: (...a: A) => IO<B>) => (...a: A) => Kind<F, B>\nexport declare function fromIOK<F>(\n  F: FromIO<F>\n): <A extends ReadonlyArray<unknown>, B>(f: (...a: A) => IO<B>) => (...a: A) => HKT<F, B>\n```\n\n----------------------------------------\n\nTITLE: Declaring booleanAlgebraVoid Instance in TypeScript\nDESCRIPTION: Defines a BooleanAlgebra instance for the void type. This represents a Boolean algebra structure for the empty type.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/BooleanAlgebra.ts.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const booleanAlgebraVoid: BooleanAlgebra<void>\n```\n\n----------------------------------------\n\nTITLE: Implementing mapLeft for Error Mapping\nDESCRIPTION: Alias of mapError that transforms the error value of a ReaderTaskEither using the provided function, preserving the success value.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReaderTaskEither.ts.md#2025-04-23_snippet_59\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const mapLeft: <E, G>(\n  f: (e: E) => G\n) => <R, A>(fa: ReaderTaskEither<R, E, A>) => ReaderTaskEither<R, G, A>\n```\n\n----------------------------------------\n\nTITLE: Implementing chainFirstReaderKW for StateReaderTaskEither in TypeScript\nDESCRIPTION: Defines chainFirstReaderKW as a less strict version of chainFirstReaderK. It merges environment types and error types when chaining a Reader operation.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/StateReaderTaskEither.ts.md#2025-04-23_snippet_9\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare const chainFirstReaderKW: <A, R1, B>(\n  f: (a: A) => R.Reader<R1, B>\n) => <S, R2, E>(ma: StateReaderTaskEither<S, R2, E, A>) => StateReaderTaskEither<S, R1 & R2, E, A>\n```\n\n----------------------------------------\n\nTITLE: Defining Zero4 interface for URIS4 functors in TypeScript\nDESCRIPTION: This interface defines the structure for a Zero type class for functors of kind URIS4. It includes a URI type and a zero method that returns a Kind4 of the functor.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Zero.ts.md#2025-04-23_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface Zero4<F extends URIS4> {\n  readonly URI: F\n  readonly zero: <S, R, E, A>() => Kind4<F, S, R, E, A>\n}\n```\n\n----------------------------------------\n\nTITLE: LeftF Operation Type Definition\nDESCRIPTION: Type definition for lifting values into Left side of Either monad using functors.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/EitherT.ts.md#2025-04-23_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare function leftF<F extends URIS3>(\n  F: Functor3<F>\n): <R, FE, E, A = never>(fe: Kind3<F, R, FE, E>) => Kind3<F, R, FE, Either<E, A>>\n```\n\n----------------------------------------\n\nTITLE: Defining Applicative4 Interface for Quaternary Type Constructors\nDESCRIPTION: Specialized Applicative interface for type constructors with four type parameters, using the URIS4 system for higher-kinded types.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Applicative.ts.md#2025-04-23_snippet_6\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport interface Applicative4<F extends URIS4> extends Apply4<F>, Pointed4<F> {}\n```\n\n----------------------------------------\n\nTITLE: Deprecated invert Function\nDESCRIPTION: Deprecated function to invert Ordering, replaced by reverse.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Ordering.ts.md#2025-04-23_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const invert: (o: Ordering) => Ordering\n```\n\n----------------------------------------\n\nTITLE: Implementing Semigroup Instance for void Type\nDESCRIPTION: Defines a Semigroup instance for the void type in fp-ts. A Semigroup represents a type with an associative binary operation.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/void.ts.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const Semigroup: Se.Semigroup<void>\n```\n\n----------------------------------------\n\nTITLE: Defining URI for These in TypeScript\nDESCRIPTION: Defines the URI constant and type alias for the These type, used for type-level programming.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/These.ts.md#2025-04-23_snippet_16\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare const URI: 'These'\n\nexport type URI = typeof URI\n```\n\n----------------------------------------\n\nTITLE: Adding @obsolete tslint Rule for fp-ts 2.x Migration\nDESCRIPTION: Configuration to add the custom @obsolete tslint rule to help identify code that needs to be migrated to the new fp-ts 2.x API. This rule highlights occurrences of chainable APIs that are obsolete in version 2.x.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/guides/upgrade-to-v2.md#2025-04-23_snippet_0\n\nLANGUAGE: json\nCODE:\n```\n{\n+  \"rulesDirectory\": [\"./node_modules/fp-ts/rules\"],\n   \"rules\": {\n+    \"obsolete\": true\n   }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining URIS4 Type Alias for `* -> * -> * -> * -> *` Constructors in TypeScript\nDESCRIPTION: Creates a type alias for the keys of the URItoKind4 interface, representing the available quaternary type constructors in the system.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/HKT.ts.md#2025-04-23_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\nexport type URIS4 = keyof URItoKind4<any, any, any, any>\n```\n\n----------------------------------------\n\nTITLE: Implementing chainFirst for ReadonlyNonEmptyArray in TypeScript\nDESCRIPTION: Composes computations in sequence, using the return value of one computation to determine the next computation and keeping only the result of the first.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReadonlyNonEmptyArray.ts.md#2025-04-23_snippet_24\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const chainFirst: <A, B>(\n  f: (a: A) => ReadonlyNonEmptyArray<B>\n) => (first: ReadonlyNonEmptyArray<A>) => ReadonlyNonEmptyArray<A>\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as RA from 'fp-ts/ReadonlyArray'\nimport { pipe } from 'fp-ts/function'\n\nassert.deepStrictEqual(\n  pipe(\n    [1, 2, 3],\n    RA.chainFirst(() => ['a', 'b'])\n  ),\n  [1, 1, 2, 2, 3, 3]\n)\n```\n\n----------------------------------------\n\nTITLE: Alternative Monoid Generator Function\nDESCRIPTION: Function to create a Monoid instance for Alternative types, combining inner values using a provided Semigroup.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Alternative.ts.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare function getAlternativeMonoid<F extends URIS4>(F: Alternative4<F>): <A, S, R, E>(S: Semigroup<A>) => Monoid<Kind4<F, S, R, E, A>>\nexport declare function getAlternativeMonoid<F extends URIS3>(F: Alternative3<F>): <A, R, E>(S: Semigroup<A>) => Monoid<Kind3<F, R, E, A>>\nexport declare function getAlternativeMonoid<F extends URIS3, E>(F: Alternative3C<F, E>): <A, R>(S: Semigroup<A>) => Monoid<Kind3<F, R, E, A>>\nexport declare function getAlternativeMonoid<F extends URIS2>(F: Alternative2<F>): <A, E>(S: Semigroup<A>) => Monoid<Kind2<F, E, A>>\nexport declare function getAlternativeMonoid<F extends URIS2, E>(F: Alternative2C<F, E>): <A>(S: Semigroup<A>) => Monoid<Kind2<F, E, A>>\nexport declare function getAlternativeMonoid<F extends URIS>(F: Alternative1<F>): <A>(S: Semigroup<A>) => Monoid<Kind<F, A>>\nexport declare function getAlternativeMonoid<F>(F: Alternative<F>): <A>(S: Semigroup<A>) => Monoid<HKT<F, A>>\n```\n\n----------------------------------------\n\nTITLE: Defining Filterable Instance for IOOption in TypeScript\nDESCRIPTION: Declares the Filterable instance for the IOOption monad. This provides implementations for the Filterable typeclass methods.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/IOOption.ts.md#2025-04-23_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const Filterable: Filterable1<'IOOption'>\n```\n\n----------------------------------------\n\nTITLE: Defining ValidationT2 Type Alias in TypeScript\nDESCRIPTION: Defines a deprecated type alias ValidationT2 representing a Kind2 with Either type.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ValidationT.ts.md#2025-04-23_snippet_4\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport type ValidationT2<M extends URIS2, R, E, A> = Kind2<M, R, Either<E, A>>\n```\n\n----------------------------------------\n\nTITLE: URI Type Definitions in TypeScript\nDESCRIPTION: Defines URI constant and type alias for ReaderEither type identification.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReaderEither.ts.md#2025-04-23_snippet_16\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const URI: 'ReaderEither'\n```\n\nLANGUAGE: typescript\nCODE:\n```\nexport type URI = typeof URI\n```\n\n----------------------------------------\n\nTITLE: Defining fromReaderK function for ReaderIO in TypeScript\nDESCRIPTION: Creates a ReaderIO from a Reader-returning function. It takes a function that returns a Reader and transforms it into a function that returns a ReaderIO.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReaderIO.ts.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const fromReaderK: <A extends readonly unknown[], R, B>(\n  f: (...a: A) => R.Reader<R, B>\n) => (...a: A) => ReaderIO<R, B>\n```\n\n----------------------------------------\n\nTITLE: Defining Type Constants for Traced\nDESCRIPTION: URI constants and type aliases for the Traced type constructor.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Traced.ts.md#2025-04-23_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const URI: 'Traced'\n```\n\nLANGUAGE: typescript\nCODE:\n```\nexport type URI = typeof URI\n```\n\n----------------------------------------\n\nTITLE: Implementing MonadIO3C Interface with Error Type\nDESCRIPTION: Extends the MonadIO pattern to support higher-kinded types with three type parameters (URIS3) and a fixed error type E.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/MonadIO.ts.md#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface MonadIO3C<M extends URIS3, E> extends Monad3C<M, E>, FromIO3C<M, E> {}\n```\n\n----------------------------------------\n\nTITLE: Defining Semigroupoid2C Interface in TypeScript\nDESCRIPTION: Defines the Semigroupoid2C interface for a higher-kinded type F extending URIS2 with a fixed type A. It includes URI and _E properties, and a compose method for combining two morphisms.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Semigroupoid.ts.md#2025-04-23_snippet_2\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport interface Semigroupoid2C<F extends URIS2, A> {\n  readonly URI: F\n  readonly _E: A\n  readonly compose: <B, C>(ab: Kind2<F, B, C>, la: Kind2<F, A, B>) => Kind2<F, A, C>\n}\n```\n\n----------------------------------------\n\nTITLE: Defining HeytingAlgebra Interface in TypeScript\nDESCRIPTION: Defines the HeytingAlgebra interface which extends BoundedDistributiveLattice and adds two operations: implies (for implication) and not (for pseudo-complement). This interface models intuitionistic logic in functional programming.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/HeytingAlgebra.ts.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface HeytingAlgebra<A> extends BoundedDistributiveLattice<A> {\n  readonly implies: (x: A, y: A) => A\n  readonly not: (x: A) => A\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Deprecated ApplicativeCompositionHKT2C Interface\nDESCRIPTION: A deprecated interface representing composition of a general HKT applicative functor with another that has two type parameters, where the second has a fixed first type parameter.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Applicative.ts.md#2025-04-23_snippet_16\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport interface ApplicativeCompositionHKT2C<F, G extends URIS2, E> extends FunctorCompositionHKT2C<F, G, E> {\n  readonly of: <A>(a: A) => HKT<F, Kind2<G, E, A>>\n  readonly ap: <A, B>(fgab: HKT<F, Kind2<G, E, (a: A) => B>>, fga: HKT<F, Kind2<G, E, A>>) => HKT<F, Kind2<G, E, B>>\n}\n```\n\n----------------------------------------\n\nTITLE: Defining PipeableProfunctor Interface in TypeScript\nDESCRIPTION: Defines a deprecated PipeableProfunctor interface with the promap method for higher-kinded types using the HKT2 notation. This provides a foundation for building profunctorial operations in a pipeable style.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/pipeable.ts.md#2025-04-23_snippet_86\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface PipeableProfunctor<F> {\n  readonly promap: <E, A, D, B>(f: (d: D) => E, g: (a: A) => B) => (fbc: HKT2<F, E, A>) => HKT2<F, D, B>\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Forest Type Alias in TypeScript\nDESCRIPTION: Defines a type alias for Forest as an array of Tree<A>. This represents a collection of trees with elements of type A.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Tree.ts.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ntype Forest<A> = Array<Tree<A>>\n```\n\n----------------------------------------\n\nTITLE: Deprecated General Ord Implementation in TypeScript\nDESCRIPTION: Deprecated general Ord implementation. Users should use the Contravariant implementation instead.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Ord.ts.md#2025-04-23_snippet_31\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const ord: Contravariant1<'Ord'>\n```\n\n----------------------------------------\n\nTITLE: Defining PipeableMonadThrow Interface in TypeScript\nDESCRIPTION: Defines a deprecated PipeableMonadThrow interface with methods for handling optional values, either values, and predicates for higher-kinded types using the HKT notation. This interface provides pipeable operators for monadic error handling.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/pipeable.ts.md#2025-04-23_snippet_81\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface PipeableMonadThrow<F> {\n  readonly fromOption: <E>(onNone: LazyArg<E>) => <A>(ma: Option<A>) => HKT<F, A>\n  readonly fromEither: <E, A>(ma: Either<E, A>) => HKT<F, A>\n  readonly fromPredicate: {\n    <E, A, B extends A>(refinement: Refinement<A, B>, onFalse: (a: A) => E): (a: A) => HKT<F, B>\n    <E, A>(predicate: Predicate<A>, onFalse: (a: A) => E): (a: A) => HKT<F, A>\n  }\n  readonly filterOrElse: {\n    <E, A, B extends A>(refinement: Refinement<A, B>, onFalse: (a: A) => E): (ma: HKT<F, A>) => HKT<F, B>\n    <E, A>(predicate: Predicate<A>, onFalse: (a: A) => E): (ma: HKT<F, A>) => HKT<F, A>\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Deprecated FunctorWithIndexComposition22C Interface in TypeScript\nDESCRIPTION: Deprecated interface for composing two FunctorWithIndex2 instances with a fixed error type, extending FunctorComposition22C.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/FunctorWithIndex.ts.md#2025-04-23_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface FunctorWithIndexComposition22C<F extends URIS2, FI, G extends URIS2, GI, E>\n  extends FunctorComposition22C<F, G, E> {\n  readonly mapWithIndex: <FE, A, B>(\n    fa: Kind2<F, FE, Kind2<G, E, A>>,\n    f: (i: [FI, GI], a: A) => B\n  ) => Kind2<F, FE, Kind2<G, E, B>>\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Pipeable Apply Operator in TypeScript\nDESCRIPTION: Implements a pipeable version of the ap (apply) operator for applying a wrapped function to a wrapped value in a functorial context.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/pipeable.ts.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare function ap<F extends URIS4>(\n  F: Apply4<F>\n): <S, R, E, A>(fa: Kind4<F, S, R, E, A>) => <B>(fab: Kind4<F, S, R, E, (a: A) => B>) => Kind4<F, S, R, E, B>\n```\n\n----------------------------------------\n\nTITLE: Zero Refinement Constructor\nDESCRIPTION: Creates an empty refinement that never succeeds.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Refinement.ts.md#2025-04-23_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const zero: <A, B extends A>() => Refinement<A, B>\n```\n\n----------------------------------------\n\nTITLE: Defining PipeableFilterableWithIndex4 Interface in TypeScript\nDESCRIPTION: Interface definition for PipeableFilterableWithIndex4 which extends PipeableFilterable4 adding index-aware filtering operations for higher-kinded types of arity 4. Provides methods that include index information when filtering and partitioning.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/pipeable.ts.md#2025-04-23_snippet_49\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface PipeableFilterableWithIndex4<F extends URIS4, I> extends PipeableFilterable4<F> {\n  readonly filterWithIndex: {\n    <A, B extends A>(refinementWithIndex: RefinementWithIndex<I, A, B>): <S, R, E>(\n      fa: Kind4<F, S, R, E, A>\n    ) => Kind4<F, S, R, E, B>\n    <A>(predicateWithIndex: PredicateWithIndex<I, A>): <S, R, E>(fa: Kind4<F, S, R, E, A>) => Kind4<F, S, R, E, A>\n  }\n  readonly filterMapWithIndex: <A, B>(\n    f: (i: I, a: A) => Option<B>\n  ) => <S, R, E>(fa: Kind4<F, S, R, E, A>) => Kind4<F, S, R, E, A>\n  readonly partitionWithIndex: {\n    <A, B extends A>(refinementWithIndex: RefinementWithIndex<I, A, B>): <S, R, E>(\n      fa: Kind4<F, S, R, E, A>\n    ) => Separated<Kind4<F, S, R, E, A>, Kind4<F, S, R, E, B>>\n    <A>(predicateWithIndex: PredicateWithIndex<I, A>): <S, R, E>(\n      fa: Kind4<F, S, R, E, A>\n    ) => Separated<Kind4<F, S, R, E, A>, Kind4<F, S, R, E, A>>\n  }\n  readonly partitionMapWithIndex: <A, B, C>(\n    f: (i: I, a: A) => Either<B, C>\n  ) => <S, R, E>(fa: Kind4<F, S, R, E, A>) => Separated<Kind4<F, S, R, E, B>, Kind4<F, S, R, E, C>>\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Unfoldable2 Interface in TypeScript\nDESCRIPTION: Variant of Unfoldable for type constructors with two type parameters. Adds an error type parameter E.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Unfoldable.ts.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface Unfoldable2<F extends URIS2> {\n  readonly URI: F\n  readonly unfold: <E, A, B>(b: B, f: (b: B) => Option<[A, B]>) => Kind2<F, E, A>\n}\n```\n\n----------------------------------------\n\nTITLE: Deprecated const_ combined instance for Const in TypeScript\nDESCRIPTION: Provides a combined instance including Functor, Contravariant, and Bifunctor for Const. This is deprecated in favor of using individual instances.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Const.ts.md#2025-04-23_snippet_24\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const const_: Functor2<'Const'> & Contravariant2<'Const'> & Bifunctor2<'Const'>\n```\n\n----------------------------------------\n\nTITLE: Extracting First Element from ReadonlyTuple in TypeScript\nDESCRIPTION: Defines an 'extract' function that returns the first element of a readonly tuple. It takes a tuple of type [A, E] and returns an element of type A.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReadonlyTuple.ts.md#2025-04-23_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare const extract: <E, A>(wa: readonly [A, E]) => A\n```\n\n----------------------------------------\n\nTITLE: Map Empty Check Operation\nDESCRIPTION: Function to test whether a map is empty.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Map.ts.md#2025-04-23_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const isEmpty: <K, A>(m: Map<K, A>) => boolean\n```\n\n----------------------------------------\n\nTITLE: Peeking at Errors in TaskEither in TypeScript\nDESCRIPTION: Allows side effects on the error channel without changing the TaskEither.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/TaskEither.ts.md#2025-04-23_snippet_29\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare const tapError: {\n  <E1, E2, _>(onLeft: (e: E1) => TaskEither<E2, _>): <A>(self: TaskEither<E1, A>) => TaskEither<E1 | E2, A>\n  <E1, A, E2, _>(self: TaskEither<E1, A>, onLeft: (e: E1) => TaskEither<E2, _>): TaskEither<E1 | E2, A>\n}\n```\n\n----------------------------------------\n\nTITLE: Deprecated Task Functions (TypeScript)\nDESCRIPTION: Deprecated functions and instances for Tasks, including fromTask, getMonoid, getSemigroup, taskSeq, and task. These are kept for backwards compatibility but should not be used in new code.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Task.ts.md#2025-04-23_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const fromTask: <A>(fa: Task<A>) => Task<A>\nexport declare const getMonoid: <A>(M: Monoid<A>) => Monoid<Task<A>>\nexport declare const getSemigroup: <A>(S: Semigroup<A>) => Semigroup<Task<A>>\nexport declare const taskSeq: Monad1<'Task'> & MonadTask1<'Task'>\nexport declare const task: Monad1<'Task'> & MonadTask1<'Task'>\n```\n\n----------------------------------------\n\nTITLE: Defining FunctorWithIndex3C Interface with Fixed Error Type in TypeScript\nDESCRIPTION: Interface for FunctorWithIndex with three type parameters and a fixed error type, extending Functor3C.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/FunctorWithIndex.ts.md#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface FunctorWithIndex3C<F extends URIS3, I, E> extends Functor3C<F, E> {\n  readonly mapWithIndex: <R, A, B>(fa: Kind3<F, R, E, A>, f: (i: I, a: A) => B) => Kind3<F, R, E, B>\n}\n```\n\n----------------------------------------\n\nTITLE: Example Usage of altW Method\nDESCRIPTION: Example showing the widening version of alt that allows concatenating arrays of different types.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReadonlyNonEmptyArray.ts.md#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as RNEA from 'fp-ts/ReadonlyNonEmptyArray'\nimport { pipe } from 'fp-ts/function'\n\nassert.deepStrictEqual(\n  pipe(\n    [1, 2, 3] as RNEA.ReadonlyNonEmptyArray<number>,\n    RNEA.altW(() => ['a', 'b'])\n  ),\n  [1, 2, 3, 'a', 'b']\n)\n```\n\n----------------------------------------\n\nTITLE: Implementing Array Duplication in TypeScript\nDESCRIPTION: Defines a function to duplicate each element in a ReadonlyArray.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReadonlyArray.ts.md#2025-04-23_snippet_20\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const duplicate: <A>(wa: readonly A[]) => readonly (readonly A[])[]\n```\n\n----------------------------------------\n\nTITLE: Defining URI for Record in TypeScript\nDESCRIPTION: Defines the URI constant and type alias for the Record type in fp-ts. This is used for type-level identification of the Record structure.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Record.ts.md#2025-04-23_snippet_22\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const URI: 'Record'\n\nexport type URI = typeof URI\n```\n\n----------------------------------------\n\nTITLE: Legacy Utility Functions for TaskEither\nDESCRIPTION: Legacy functions including bimap (alias of mapBoth), chain (alias of flatMap), chainEitherK, chainEitherKW, chainFirst, and other chain variants for TaskEither operations.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/TaskEither.ts.md#2025-04-23_snippet_38\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const bimap: <E, G, A, B>(f: (e: E) => G, g: (a: A) => B) => (fa: TaskEither<E, A>) => TaskEither<G, B>\n```\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const chain: <E, A, B>(f: (a: A) => TaskEither<E, B>) => (ma: TaskEither<E, A>) => TaskEither<E, B>\n```\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const chainEitherK: <E, A, B>(f: (a: A) => E.Either<E, B>) => (ma: TaskEither<E, A>) => TaskEither<E, B>\n```\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const chainEitherKW: <E2, A, B>(\n  f: (a: A) => E.Either<E2, B>\n) => <E1>(ma: TaskEither<E1, A>) => TaskEither<E2 | E1, B>\n```\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const chainFirst: <E, A, B>(f: (a: A) => TaskEither<E, B>) => (ma: TaskEither<E, A>) => TaskEither<E, A>\n```\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const chainFirstEitherK: <A, E, B>(\n  f: (a: A) => E.Either<E, B>\n) => (ma: TaskEither<E, A>) => TaskEither<E, A>\n```\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const chainFirstEitherKW: <A, E2, B>(\n  f: (a: A) => E.Either<E2, B>\n) => <E1>(ma: TaskEither<E1, A>) => TaskEither<E2 | E1, A>\n```\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const chainFirstIOK: <A, B>(f: (a: A) => IO<B>) => <E>(first: TaskEither<E, A>) => TaskEither<E, A>\n```\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const chainFirstTaskK: <A, B>(f: (a: A) => T.Task<B>) => <E>(first: TaskEither<E, A>) => TaskEither<E, A>\n```\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const chainFirstW: <E2, A, B>(\n  f: (a: A) => TaskEither<E2, B>\n) => <E1>(ma: TaskEither<E1, A>) => TaskEither<E2 | E1, A>\n```\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const chainIOEitherK: <E, A, B>(\n  f: (a: A) => IOEither<E, B>\n) => (ma: TaskEither<E, A>) => TaskEither<E, B>\n```\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const chainIOEitherKW: <E2, A, B>(\n  f: (a: A) => IOEither<E2, B>\n) => <E1>(ma: TaskEither<E1, A>) => TaskEither<E2 | E1, B>\n```\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const chainIOK: <A, B>(f: (a: A) => IO<B>) => <E>(first: TaskEither<E, A>) => TaskEither<E, B>\n```\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const chainNullableK: <E>(\n  e: E\n) => <A, B>(f: (a: A) => B | null | undefined) => (ma: TaskEither<E, A>) => TaskEither<E, NonNullable<B>>\n```\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const chainOptionK: <E>(\n  onNone: LazyArg<E>\n) => <A, B>(f: (a: A) => Option<B>) => (ma: TaskEither<E, A>) => TaskEither<E, B>\n```\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const chainOptionKW: <E2>(\n  onNone: LazyArg<E2>\n) => <A, B>(f: (a: A) => Option<B>) => <E1>(ma: TaskEither<E1, A>) => TaskEither<E2 | E1, B>\n```\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const chainTaskK: <A, B>(f: (a: A) => T.Task<B>) => <E>(first: TaskEither<E, A>) => TaskEither<E, B>\n```\n\n----------------------------------------\n\nTITLE: Implementing reverse Function for Magma in TypeScript\nDESCRIPTION: Defines the reverse function that creates the dual of a Magma by swapping the arguments of concat.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Magma.ts.md#2025-04-23_snippet_6\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare const reverse: <A>(M: Magma<A>) => Magma<A>\n```\n\n----------------------------------------\n\nTITLE: GetOrElse Operation Type Definition\nDESCRIPTION: Type definition for extracting values from Either monads with fallback handling for Left cases.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/EitherT.ts.md#2025-04-23_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare function getOrElse<M extends URIS3>(\n  M: Monad3<M>\n): <E, R, ME, A>(onLeft: (e: E) => Kind3<M, R, ME, A>) => (ma: Kind3<M, R, ME, Either<E, A>>) => Kind3<M, R, ME, A>\n```\n\n----------------------------------------\n\nTITLE: Defining PipeableMonadThrow2 Interface in TypeScript\nDESCRIPTION: Defines a deprecated PipeableMonadThrow2 interface with methods for handling optional values, either values, and predicates for higher-kinded types of arity 2. This interface provides pipeable operator implementations for monadic error handling.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/pipeable.ts.md#2025-04-23_snippet_78\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface PipeableMonadThrow2<F extends URIS2> {\n  readonly fromOption: <E>(onNone: LazyArg<E>) => <A>(ma: Option<A>) => Kind2<F, E, A>\n  readonly fromEither: <E, A>(ma: Either<E, A>) => Kind2<F, E, A>\n  readonly fromPredicate: {\n    <E, A, B extends A>(refinement: Refinement<A, B>, onFalse: (a: A) => E): (a: A) => Kind2<F, E, B>\n    <E, A>(predicate: Predicate<A>, onFalse: (a: A) => E): (a: A) => Kind2<F, E, A>\n  }\n  readonly filterOrElse: {\n    <E, A, B extends A>(refinement: Refinement<A, B>, onFalse: (a: A) => E): (ma: Kind2<F, E, A>) => Kind2<F, E, B>\n    <E, A>(predicate: Predicate<A>, onFalse: (a: A) => E): (ma: Kind2<F, E, A>) => Kind2<F, E, A>\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Alternative Instance for IOOption in TypeScript\nDESCRIPTION: Declares the Alternative instance for the IOOption monad. This provides implementations for the Alternative typeclass methods.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/IOOption.ts.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const Alternative: Alternative1<'IOOption'>\n```\n\n----------------------------------------\n\nTITLE: Contravariant2C Interface with Fixed Error Type\nDESCRIPTION: Defines a Contravariant interface for type constructors with two parameters where the error type E is fixed.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Contravariant.ts.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface Contravariant2C<F extends URIS2, E> {\n  readonly URI: F\n  readonly _E: E\n  readonly contramap: <A, B>(fa: Kind2<F, E, A>, f: (b: B) => A) => Kind2<F, E, B>\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Deprecated ApplicativeCompositionHKT1 Interface\nDESCRIPTION: A deprecated interface representing composition of a general HKT applicative functor with another functor that has one type parameter.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Applicative.ts.md#2025-04-23_snippet_15\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport interface ApplicativeCompositionHKT1<F, G extends URIS> extends FunctorCompositionHKT1<F, G> {\n  readonly of: <A>(a: A) => HKT<F, Kind<G, A>>\n  readonly ap: <A, B>(fgab: HKT<F, Kind<G, (a: A) => B>>, fga: HKT<F, Kind<G, A>>) => HKT<F, Kind<G, B>>\n}\n```\n\n----------------------------------------\n\nTITLE: Defining the URI type alias for Const in TypeScript\nDESCRIPTION: Defines the URI type alias for the Const type constructor, used for type class instances and higher-kinded types.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Const.ts.md#2025-04-23_snippet_22\n\nLANGUAGE: typescript\nCODE:\n```\nexport type URI = typeof URI\n```\n\n----------------------------------------\n\nTITLE: Deprecated execState function in StateReaderTaskEither (TypeScript)\nDESCRIPTION: A deprecated function that executes a StateReaderTaskEither computation with an initial state and returns only the final state. Users should use the execute function instead.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/StateReaderTaskEither.ts.md#2025-04-23_snippet_76\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const execState: <S, R, E, A>(\n  ma: StateReaderTaskEither<S, R, E, A>,\n  s: S\n) => RTE.ReaderTaskEither<R, E, S>\n```\n\n----------------------------------------\n\nTITLE: Implementing AsUnit Function for IOOption in TypeScript\nDESCRIPTION: Defines the asUnit function for IOOption. It maps the Some value of an IOOption to the void constant value.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/IOOption.ts.md#2025-04-23_snippet_30\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const asUnit: <_>(self: IOOption<_>) => IOOption<void>\n```\n\n----------------------------------------\n\nTITLE: Defining Zero2 interface for URIS2 functors in TypeScript\nDESCRIPTION: This interface defines the structure for a Zero type class for functors of kind URIS2. It includes a URI type and a zero method that returns a Kind2 of the functor.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Zero.ts.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface Zero2<F extends URIS2> {\n  readonly URI: F\n  readonly zero: <E, A>() => Kind2<F, E, A>\n}\n```\n\n----------------------------------------\n\nTITLE: Deprecated Date Ordinal Implementation in TypeScript\nDESCRIPTION: Deprecated ordinal implementation for Date objects. Users should use the Ord implementation from Date.ts instead.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Ord.ts.md#2025-04-23_snippet_28\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const ordDate: Ord<Date>\n```\n\n----------------------------------------\n\nTITLE: Implementing flap for Const in TypeScript\nDESCRIPTION: Takes a value and a function wrapped in Const, and returns the result of applying the value to the function, wrapped in Const.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Const.ts.md#2025-04-23_snippet_18\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const flap: <A>(a: A) => <E, B>(fab: Const<E, (a: A) => B>) => Const<E, B>\n```\n\n----------------------------------------\n\nTITLE: Unappending NonEmptyArray in TypeScript\nDESCRIPTION: Returns a tuple containing the init (all elements except the last) and the last element of a NonEmptyArray.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/NonEmptyArray.ts.md#2025-04-23_snippet_20\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const unappend: <A>(as: NonEmptyArray<A>) => [A[], A]\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport { unappend } from 'fp-ts/NonEmptyArray'\n\nassert.deepStrictEqual(unappend([1, 2, 3, 4]), [[1, 2, 3], 4])\n```\n\n----------------------------------------\n\nTITLE: Functor Instance Definition\nDESCRIPTION: Provides the Functor type class instance for Writer.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Writer.ts.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const Functor: Functor2<'Writer'>\n```\n\n----------------------------------------\n\nTITLE: Defining Zero Instance for IOOption in TypeScript\nDESCRIPTION: Declares the Zero instance for the IOOption monad. This provides implementations for the Zero typeclass methods.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/IOOption.ts.md#2025-04-23_snippet_15\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const Zero: Zero1<'IOOption'>\n```\n\n----------------------------------------\n\nTITLE: Defining getFoldableWithIndexComposition Function in TypeScript\nDESCRIPTION: Declares a utility function with multiple overloads for composing FoldableWithIndex instances of various URIS kinds. It's marked as deprecated, suggesting the use of individual methods instead.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/FoldableWithIndex.ts.md#2025-04-23_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare function getFoldableWithIndexComposition<F extends URIS2, FI, G extends URIS2, GI, E>(\n  F: FoldableWithIndex2<F, FI>,\n  G: FoldableWithIndex2C<G, GI, E>\n): FoldableWithIndexComposition22C<F, FI, G, GI, E>\nexport declare function getFoldableWithIndexComposition<F extends URIS2, FI, G extends URIS2, GI>(\n  F: FoldableWithIndex2<F, FI>,\n  G: FoldableWithIndex2<G, GI>\n): FoldableWithIndexComposition22<F, FI, G, GI>\nexport declare function getFoldableWithIndexComposition<F extends URIS2, FI, G extends URIS, GI, E>(\n  F: FoldableWithIndex2C<F, FI, E>,\n  G: FoldableWithIndex1<G, GI>\n): FoldableWithIndexComposition2C1<F, FI, G, GI, E>\nexport declare function getFoldableWithIndexComposition<F extends URIS2, FI, G extends URIS, GI>(\n  F: FoldableWithIndex2<F, FI>,\n  G: FoldableWithIndex1<G, GI>\n): FoldableWithIndexComposition21<F, FI, G, GI>\nexport declare function getFoldableWithIndexComposition<F extends URIS, FI, G extends URIS2, GI>(\n  F: FoldableWithIndex1<F, FI>,\n  G: FoldableWithIndex2<G, GI>\n): FoldableWithIndexComposition12<F, FI, G, GI>\nexport declare function getFoldableWithIndexComposition<F extends URIS, FI, G extends URIS2, GI>(\n  F: FoldableWithIndex1<F, FI>,\n  G: FoldableWithIndex2<G, GI>\n): FoldableWithIndexComposition12<F, FI, G, GI>\nexport declare function getFoldableWithIndexComposition<F extends URIS, FI, G extends URIS, GI>(\n  F: FoldableWithIndex1<F, FI>,\n  G: FoldableWithIndex1<G, GI>\n): FoldableWithIndexComposition11<F, FI, G, GI>\nexport declare function getFoldableWithIndexComposition<F, FI, G, GI>(\n  F: FoldableWithIndex<F, FI>,\n  G: FoldableWithIndex<G, GI>\n): FoldableWithIndexComposition<F, FI, G, GI>\n```\n\n----------------------------------------\n\nTITLE: Natural Transformation for Unary Type Constructors\nDESCRIPTION: Defines transformation between two unary type constructors (URIS to URIS)\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/NaturalTransformation.ts.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface NaturalTransformation11<F extends URIS, G extends URIS> {\n  <A>(fa: Kind<F, A>): Kind<G, A>\n}\n```\n\n----------------------------------------\n\nTITLE: Deprecated ReaderTask Functions\nDESCRIPTION: Legacy functions that are marked for deprecation, including monoid operations and instance creators\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReaderTask.ts.md#2025-04-23_snippet_16\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const getMonoid: <R, A>(M: Monoid<A>) => Monoid<ReaderTask<R, A>>\n\nexport declare const getSemigroup: <R, A>(S: Semigroup<A>) => Semigroup<ReaderTask<R, A>>\n\nexport declare const readerTaskSeq: MonadTask2<'ReaderTask'>\n\nexport declare const readerTask: MonadTask2<'ReaderTask'>\n\nexport declare function run<R, A>(ma: ReaderTask<R, A>, r: R): Promise<A>\n\nexport declare const sequenceSeqArray: <R, A>(arr: readonly ReaderTask<R, A>[]) => ReaderTask<R, readonly A[]>\n```\n\n----------------------------------------\n\nTITLE: Defining URI for ReadonlyNonEmptyArray in TypeScript\nDESCRIPTION: Defines the URI constant for ReadonlyNonEmptyArray, used for type-level identification.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReadonlyNonEmptyArray.ts.md#2025-04-23_snippet_31\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const URI: 'ReadonlyNonEmptyArray'\n```\n\nLANGUAGE: typescript\nCODE:\n```\nexport type URI = typeof URI\n```\n\n----------------------------------------\n\nTITLE: Defining URI Type Alias for Separated in TypeScript\nDESCRIPTION: Defines the URI type alias for the Separated type, which is used for type-level identification of the Separated type.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Separated.ts.md#2025-04-23_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nexport type URI = typeof URI\n```\n\n----------------------------------------\n\nTITLE: Defining WriterM Instance Interface\nDESCRIPTION: Interface defining Writer monad operations including map, eval, exec, tell, listen, pass and monad operations.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/WriterT.ts.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface WriterM<M> {\n  readonly map: <W, A, B>(fa: WriterT<M, W, A>, f: (a: A) => B) => WriterT<M, W, B>\n  readonly evalWriter: <W, A>(fa: WriterT<M, W, A>) => HKT<M, A>\n  readonly execWriter: <W, A>(fa: WriterT<M, W, A>) => HKT<M, W>\n  readonly tell: <W>(w: W) => WriterT<M, W, void>\n  readonly listen: <W, A>(fa: WriterT<M, W, A>) => WriterT<M, W, [A, W]>\n  readonly pass: <W, A>(fa: WriterT<M, W, [A, (w: W) => W]>) => WriterT<M, W, A>\n  readonly listens: <W, A, B>(fa: WriterT<M, W, A>, f: (w: W) => B) => WriterT<M, W, [A, B]>\n  readonly censor: <W, A>(fa: WriterT<M, W, A>, f: (w: W) => W) => WriterT<M, W, A>\n  readonly getMonad: <W>(M: Monoid<W>) => {\n    readonly _E: W\n    readonly map: <A, B>(ma: WriterT<M, W, A>, f: (a: A) => B) => WriterT<M, W, B>\n    readonly of: <A>(a: A) => WriterT<M, W, A>\n    readonly ap: <A, B>(mab: WriterT<M, W, (a: A) => B>, ma: WriterT<M, W, A>) => WriterT<M, W, B>\n    readonly chain: <A, B>(ma: WriterT<M, W, A>, f: (a: A) => WriterT<M, W, B>) => WriterT<M, W, B>\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Extend3C Interface with Fixed Second Type Parameter\nDESCRIPTION: Defines the Extend3C interface for ternary type constructors with a fixed second type parameter E, extending Functor3C with the appropriate extend method.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Extend.ts.md#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface Extend3C<W extends URIS3, E> extends Functor3C<W, E> {\n  readonly extend: <R, A, B>(wa: Kind3<W, R, E, A>, f: (wa: Kind3<W, R, E, A>) => B) => Kind3<W, R, E, B>\n}\n```\n\n----------------------------------------\n\nTITLE: Deprecated fieldNumber Implementation\nDESCRIPTION: Deprecated constant implementation of Field interface for number type, marked for removal and replaced by Field implementation in number.ts.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Field.ts.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const fieldNumber: Field<number>\n```\n\n----------------------------------------\n\nTITLE: Defining URI Type Alias for Store in TypeScript\nDESCRIPTION: Defines the URI type alias for Store, used in higher-kinded types.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Store.ts.md#2025-04-23_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nexport type URI = typeof URI\n```\n\n----------------------------------------\n\nTITLE: Deprecated FilterWithIndex Function for ReadonlyNonEmptyArray in TypeScript\nDESCRIPTION: Deprecated function that filters elements of a ReadonlyNonEmptyArray based on their index. Use 'filterWithIndex' from ReadonlyArray instead.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReadonlyNonEmptyArray.ts.md#2025-04-23_snippet_73\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const filterWithIndex: <A>(\n  predicate: (i: number, a: A) => boolean\n) => (as: ReadonlyNonEmptyArray<A>) => Option<ReadonlyNonEmptyArray<A>>\n```\n\n----------------------------------------\n\nTITLE: Defining apFirstW Function for ReaderTaskEither in TypeScript\nDESCRIPTION: Function signature for apFirstW, a less strict version of apFirst that merges environment and error types. Added in v2.12.0.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReaderTaskEither.ts.md#2025-04-23_snippet_112\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const apFirstW: <R2, E2, B>(\n  second: ReaderTaskEither<R2, E2, B>\n) => <R1, E1, A>(first: ReaderTaskEither<R1, E1, A>) => ReaderTaskEither<R1 & R2, E2 | E1, A>\n```\n\n----------------------------------------\n\nTITLE: Defining Zero2C interface for constrained URIS2 functors in TypeScript\nDESCRIPTION: This interface defines the structure for a Zero type class for constrained functors of kind URIS2. It includes a URI type, an _E type parameter, and a zero method that returns a Kind2 of the functor.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Zero.ts.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface Zero2C<F extends URIS2, E> {\n  readonly URI: F\n  readonly _E: E\n  readonly zero: <A>() => Kind2<F, E, A>\n}\n```\n\n----------------------------------------\n\nTITLE: Deprecated empty constant for Records in TypeScript\nDESCRIPTION: A deprecated empty Record constant. Users should use a new empty object literal ({}) instead.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Record.ts.md#2025-04-23_snippet_61\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const empty: Record<string, never>\n```\n\n----------------------------------------\n\nTITLE: Running a Task in fp-ts 1.x (Deprecated)\nDESCRIPTION: Example of creating and running a Task in fp-ts 1.x using the class-based approach with the run() method that returns a Promise.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/guides/upgrade-to-v2.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Task } from 'fp-ts/Task'\n\nconst deepThought = new Task<number>(() => Promise.resolve(42))\n\ndeepThought.run().then((n) => {\n  console.log(`The answer is ${n}.`)\n})\n```\n\n----------------------------------------\n\nTITLE: Implementing chainFirstEitherKW in TypeScript for ReaderTaskEither\nDESCRIPTION: Widening version of chainFirstEitherK that allows for different error types. It executes an Either-returning side effect while preserving the original value and merging error types.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReaderTaskEither.ts.md#2025-04-23_snippet_24\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const chainFirstEitherKW: <A, E2, B>(\n  f: (a: A) => E.Either<E2, B>\n) => <R, E1>(ma: ReaderTaskEither<R, E1, A>) => ReaderTaskEither<R, E2 | E1, A>\n```\n\n----------------------------------------\n\nTITLE: Deprecated strict equality in TypeScript\nDESCRIPTION: Deprecated function for strict equality comparison. Users should use the eqStrict instance instead.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Eq.ts.md#2025-04-23_snippet_20\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const strictEqual: <A>(a: A, b: A) => boolean\n```\n\n----------------------------------------\n\nTITLE: Defining ValidationM2 Interface in TypeScript\nDESCRIPTION: Defines a deprecated interface ValidationM2 that extends ApplicativeComposition22C with additional chain and alt methods for ValidationT2.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ValidationT.ts.md#2025-04-23_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport interface ValidationM2<M extends URIS2, E> extends ApplicativeComposition22C<M, E.URI, E> {\n  readonly chain: <R, A, B>(\n    ma: ValidationT2<M, R, E, A>,\n\n    f: (a: A) => ValidationT2<M, R, E, B>\n  ) => ValidationT2<M, R, E, B>\n\n  readonly alt: <R, A>(\n    fa: ValidationT2<M, R, E, A>,\n    that: LazyArg<ValidationT2<M, R, E, A>>\n  ) => ValidationT2<M, R, E, A>\n}\n```\n\n----------------------------------------\n\nTITLE: Defining PipeableMonadThrow4 Interface in TypeScript\nDESCRIPTION: Defines a deprecated PipeableMonadThrow4 interface with methods for handling optional values, either values, and predicates for higher-kinded types of arity 4. This interface provides error handling operations for monadic computations.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/pipeable.ts.md#2025-04-23_snippet_80\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface PipeableMonadThrow4<F extends URIS4> {\n  readonly fromOption: <E>(onNone: LazyArg<E>) => <S, R, A>(ma: Option<A>) => Kind4<F, S, R, E, A>\n  readonly fromEither: <S, R, E, A>(ma: Either<E, A>) => Kind4<F, S, R, E, A>\n  readonly fromPredicate: {\n    <E, A, B extends A>(refinement: Refinement<A, B>, onFalse: (a: A) => E): <S, R>(a: A) => Kind4<F, S, R, E, B>\n    <E, A>(predicate: Predicate<A>, onFalse: (a: A) => E): <S, R>(a: A) => Kind4<F, S, R, E, A>\n  }\n  readonly filterOrElse: {\n    <E, A, B extends A>(refinement: Refinement<A, B>, onFalse: (a: A) => E): <S, R>(\n      ma: Kind4<F, S, R, E, A>\n    ) => Kind4<F, S, R, E, B>\n    <E, A>(predicate: Predicate<A>, onFalse: (a: A) => E): <S, R>(ma: Kind4<F, S, R, E, A>) => Kind4<F, S, R, E, A>\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Deprecated ApplicativeCompositionHKT2 Interface\nDESCRIPTION: A deprecated interface representing composition of a general HKT applicative functor with another that has two type parameters.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Applicative.ts.md#2025-04-23_snippet_17\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport interface ApplicativeCompositionHKT2<F, G extends URIS2> extends FunctorCompositionHKT2<F, G> {\n  readonly of: <E, A>(a: A) => HKT<F, Kind2<G, E, A>>\n  readonly ap: <E, A, B>(fgab: HKT<F, Kind2<G, E, (a: A) => B>>, fga: HKT<F, Kind2<G, E, A>>) => HKT<F, Kind2<G, E, B>>\n}\n```\n\n----------------------------------------\n\nTITLE: FoldableWithIndex2 Interface Definition for URIS2 Kind\nDESCRIPTION: Interface for FoldableWithIndex specialized for Kind2<F, E, A> types, extending Foldable2 with indexed folding operations.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/FoldableWithIndex.ts.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface FoldableWithIndex2<F extends URIS2, I> extends Foldable2<F> {\n  readonly reduceWithIndex: <E, A, B>(fa: Kind2<F, E, A>, b: B, f: (i: I, b: B, a: A) => B) => B\n  readonly foldMapWithIndex: <M>(M: Monoid<M>) => <E, A>(fa: Kind2<F, E, A>, f: (i: I, a: A) => M) => M\n  readonly reduceRightWithIndex: <E, A, B>(fa: Kind2<F, E, A>, b: B, f: (i: I, a: A, b: B) => B) => B\n}\n```\n\n----------------------------------------\n\nTITLE: Deprecated getApplyMonoid Function Definition\nDESCRIPTION: Deprecated function signature for getApplyMonoid, replaced by getApplicativeMonoid.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Option.ts.md#2025-04-23_snippet_15\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const getApplyMonoid: <A>(M: Monoid<A>) => Monoid<Option<A>>\n```\n\n----------------------------------------\n\nTITLE: Deprecated Reader Functions in TypeScript\nDESCRIPTION: Lists deprecated functions for Reader, including getMonoid, getSemigroup, and the reader instance. These are marked for removal and alternatives are suggested.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Reader.ts.md#2025-04-23_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const getMonoid: <R, A>(M: Monoid<A>) => Monoid<Reader<R, A>>\n\nexport declare const getSemigroup: <R, A>(S: Semigroup<A>) => Semigroup<Reader<R, A>>\n\nexport declare const reader: Monad2<'Reader'> &\n  Profunctor2<'Reader'> &\n  Category2<'Reader'> &\n  Strong2<'Reader'> &\n  Choice2<'Reader'>\n```\n\n----------------------------------------\n\nTITLE: Defining Deprecated ApplicativeComposition22 Interface\nDESCRIPTION: A deprecated interface representing composition of two applicative functors, both with two type parameters.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Applicative.ts.md#2025-04-23_snippet_13\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport interface ApplicativeComposition22<F extends URIS2, G extends URIS2> extends FunctorComposition22<F, G> {\n  readonly of: <FE, GE, A>(a: A) => Kind2<F, FE, Kind2<G, GE, A>>\n  readonly ap: <FE, GE, A, B>(\n    fgab: Kind2<F, FE, Kind2<G, GE, (a: A) => B>>,\n    fga: Kind2<F, FE, Kind2<G, GE, A>>\n  ) => Kind2<F, FE, Kind2<G, GE, B>>\n}\n```\n\n----------------------------------------\n\nTITLE: Deprecated run function for ReaderTaskEither in TypeScript\nDESCRIPTION: A deprecated function that executes a ReaderTaskEither with a given environment and returns a Promise of Either.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReaderTaskEither.ts.md#2025-04-23_snippet_126\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare function run<R, E, A>(ma: ReaderTaskEither<R, E, A>, r: R): Promise<Either<E, A>>\n```\n\n----------------------------------------\n\nTITLE: Defining PipeableFoldableWithIndex2C Interface in TypeScript\nDESCRIPTION: Extends PipeableFoldable2C to provide indexed folding operations for arity 2 higher-kinded types with a fixed first type parameter. Adds methods that receive the index during folding.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/pipeable.ts.md#2025-04-23_snippet_58\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface PipeableFoldableWithIndex2C<F extends URIS2, I, E> extends PipeableFoldable2C<F, E> {\n  readonly reduceWithIndex: <A, B>(b: B, f: (i: I, b: B, a: A) => B) => (fa: Kind2<F, E, A>) => B\n  readonly foldMapWithIndex: <M>(M: Monoid<M>) => <A>(f: (i: I, a: A) => M) => (fa: Kind2<F, E, A>) => M\n  readonly reduceRightWithIndex: <A, B>(b: B, f: (i: I, a: A, b: B) => B) => (fa: Kind2<F, E, A>) => B\n}\n```\n\n----------------------------------------\n\nTITLE: Deprecated Tree Instance\nDESCRIPTION: Deprecated complete tree instance implementing multiple typeclasses. Users should use specific instances instead.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Tree.ts.md#2025-04-23_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const tree: Monad1<'Tree'> & Foldable1<'Tree'> & Traversable1<'Tree'> & Comonad1<'Tree'>\n```\n\n----------------------------------------\n\nTITLE: ReaderEither bindW Operation\nDESCRIPTION: Function for binding values in a ReaderEither context with type widening. The W suffix indicates that environment and error types will be merged.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReaderEither.ts.md#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const bindW: <N extends string, A, R2, E2, B>(\n  name: Exclude<N, keyof A>,\n  f: (a: A) => ReaderEither<R2, E2, B>\n) => <R1, E1>(\n  fa: ReaderEither<R1, E1, A>\n) => ReaderEither<R1 & R2, E2 | E1, { readonly [K in N | keyof A]: K extends keyof A ? A[K] : B }>\n```\n\n----------------------------------------\n\nTITLE: Defining Deprecated ApplicativeComposition12 Interface\nDESCRIPTION: A deprecated interface representing composition of an applicative functor with one type parameter and another with two type parameters.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Applicative.ts.md#2025-04-23_snippet_10\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport interface ApplicativeComposition12<F extends URIS, G extends URIS2> extends FunctorComposition12<F, G> {\n  readonly of: <E, A>(a: A) => Kind<F, Kind2<G, E, A>>\n  readonly ap: <E, A, B>(\n    fgab: Kind<F, Kind2<G, E, (a: A) => B>>,\n    fga: Kind<F, Kind2<G, E, A>>\n  ) => Kind<F, Kind2<G, E, B>>\n}\n```\n\n----------------------------------------\n\nTITLE: StateM Interface Definition in TypeScript\nDESCRIPTION: Base interface definition for State Monad Transformer. Provides core functionality without specific URIS constraints.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/StateT.ts.md#2025-04-23_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface StateM<M> {\n  readonly map: <S, A, B>(fa: StateT<M, S, A>, f: (a: A) => B) => StateT<M, S, B>\n  readonly of: <S, A>(a: A) => StateT<M, S, A>\n  readonly ap: <S, A, B>(fab: StateT<M, S, (a: A) => B>, fa: StateT<M, S, A>) => StateT<M, S, B>\n  readonly chain: <S, A, B>(fa: StateT<M, S, A>, f: (a: A) => StateT<M, S, B>) => StateT<M, S, B>\n  readonly get: <S>() => StateT<M, S, S>\n  readonly put: <S>(s: S) => StateT<M, S, void>\n  readonly modify: <S>(f: (s: S) => S) => StateT<M, S, void>\n  readonly gets: <S, A>(f: (s: S) => A) => StateT<M, S, A>\n  readonly fromState: <S, A>(fa: State<S, A>) => StateT<M, S, A>\n  readonly fromM: <S, A>(ma: HKT<M, A>) => StateT<M, S, A>\n  readonly evalState: <S, A>(ma: StateT<M, S, A>, s: S) => HKT<M, A>\n  readonly execState: <S, A>(ma: StateT<M, S, A>, s: S) => HKT<M, S>\n}\n```\n\n----------------------------------------\n\nTITLE: Deprecated record typeclass instance in TypeScript\nDESCRIPTION: A deprecated combined typeclass instance for Records. Users should use specific, smaller instances like R.Functor instead of the combined R.record instance.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Record.ts.md#2025-04-23_snippet_64\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const record: FunctorWithIndex1<'Record', string> &\n  FoldableWithIndex1<'Record', string> &\n  FilterableWithIndex1<'Record', string> &\n  TraversableWithIndex1<'Record', string> &\n  Witherable1<'Record'>\n```\n\n----------------------------------------\n\nTITLE: Ring Tuple Implementation Signature\nDESCRIPTION: Function signature for creating a Ring instance for tuples given individual Ring instances for each tuple element.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Ring.ts.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const tuple: <A extends readonly unknown[]>(\n  ...rings: { [K in keyof A]: Ring<A[K]> }\n) => Ring<Readonly<A>>\n```\n\n----------------------------------------\n\nTITLE: URItoKind Interface Definition\nDESCRIPTION: The definition of URItoKind, a type-level map that associates URIs with concrete data types. This is a core mechanism in fp-ts for higher-kinded types.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/guides/HKT.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\n// fp-ts/HKT.ts\n\nexport interface URItoKind<A> {}\n```\n\n----------------------------------------\n\nTITLE: Implementing orElseFirst as Alias for tapError in TypeScript\nDESCRIPTION: An alias for tapError that executes a side effect on the error channel without changing the original TaskEither value.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/TaskEither.ts.md#2025-04-23_snippet_46\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const orElseFirst: <E, B>(\n  onLeft: (e: E) => TaskEither<E, B>\n) => <A>(ma: TaskEither<E, A>) => TaskEither<E, A>\n```\n\n----------------------------------------\n\nTITLE: Defining Bifunctor instance for Const in TypeScript\nDESCRIPTION: Provides the Bifunctor type class instance for Const, enabling mapping over both type parameters with functions like bimap.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Const.ts.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const Bifunctor: Bifunctor2<'Const'>\n```\n\n----------------------------------------\n\nTITLE: Deprecated PrependToAll Function for ReadonlyNonEmptyArray in TypeScript\nDESCRIPTION: Deprecated function that prepends an element to every member of a ReadonlyNonEmptyArray. Use 'prependAll' instead.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReadonlyNonEmptyArray.ts.md#2025-04-23_snippet_78\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const prependToAll: <A>(middle: A) => (as: ReadonlyNonEmptyArray<A>) => ReadonlyNonEmptyArray<A>\n```\n\n----------------------------------------\n\nTITLE: Defining PipeableFoldableWithIndex3 Interface in TypeScript\nDESCRIPTION: Extends PipeableFoldable3 to provide indexed folding operations for arity 3 higher-kinded types. Adds methods that receive the index along with values during folding operations.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/pipeable.ts.md#2025-04-23_snippet_60\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface PipeableFoldableWithIndex3<F extends URIS3, I> extends PipeableFoldable3<F> {\n  readonly reduceWithIndex: <A, B>(b: B, f: (i: I, b: B, a: A) => B) => <R, E>(fa: Kind3<F, R, E, A>) => B\n  readonly foldMapWithIndex: <M>(M: Monoid<M>) => <A>(f: (i: I, a: A) => M) => <R, E>(fa: Kind3<F, R, E, A>) => M\n  readonly reduceRightWithIndex: <A, B>(b: B, f: (i: I, a: A, b: B) => B) => <R, E>(fa: Kind3<F, R, E, A>) => B\n}\n```\n\n----------------------------------------\n\nTITLE: Tuple Function for Creating Composite Ord in TypeScript\nDESCRIPTION: Creates an Ord for tuples by combining multiple Ord instances, comparing elements in order.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Ord.ts.md#2025-04-23_snippet_23\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const tuple: <A extends readonly unknown[]>(...ords: { [K in keyof A]: Ord<A[K]> }) => Ord<Readonly<A>>\n```\n\n----------------------------------------\n\nTITLE: Deprecated number equality in TypeScript\nDESCRIPTION: Deprecated Eq instance for number values. Users should use the Eq from the number module instead.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Eq.ts.md#2025-04-23_snippet_15\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const eqNumber: Eq<number>\n```\n\n----------------------------------------\n\nTITLE: Deprecated Traversable interface for Records in TypeScript\nDESCRIPTION: A deprecated implementation of the Traversable typeclass for Records. Users should now use getTraversable instead.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Record.ts.md#2025-04-23_snippet_59\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const Traversable: Traversable1<'Record'>\n```\n\n----------------------------------------\n\nTITLE: Deprecated booleanAlgebraBoolean Instance in TypeScript\nDESCRIPTION: A deprecated BooleanAlgebra instance for the boolean type. Users should use the BooleanAlgebra from boolean.ts instead.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/BooleanAlgebra.ts.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const booleanAlgebraBoolean: BooleanAlgebra<boolean>\n```\n\n----------------------------------------\n\nTITLE: Defining Writer Transformer Constructor\nDESCRIPTION: Function to construct Writer monad transformer instances for different monad types based on arity.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/WriterT.ts.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare function getWriterM<M extends URIS3>(M: Monad3<M>): WriterM3<M>\nexport declare function getWriterM<M extends URIS2>(M: Monad2<M>): WriterM2<M>\nexport declare function getWriterM<M extends URIS2, E>(M: Monad2C<M, E>): WriterM2C<M, E>\nexport declare function getWriterM<M extends URIS>(M: Monad1<M>): WriterM1<M>\nexport declare function getWriterM<M>(M: Monad<M>): WriterM<M>\n```\n\n----------------------------------------\n\nTITLE: Deprecated TraversableWithIndex interface for Records in TypeScript\nDESCRIPTION: A deprecated implementation of the TraversableWithIndex typeclass for Records. Users should now use getTraversableWithIndex instead.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Record.ts.md#2025-04-23_snippet_58\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const TraversableWithIndex: TraversableWithIndex1<'Record', string>\n```\n\n----------------------------------------\n\nTITLE: Option Chaining Example with fp-ts 1.x (Deprecated)\nDESCRIPTION: Example of using the deprecated chainable API in fp-ts 1.x with Option. Shows how to map, chain, filter, and fold an Option using method chaining.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/guides/upgrade-to-v2.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as O from 'fp-ts/Option'\n\nO.some(1)\n  .map((n) => n * 2)\n  .chain((n) => (n === 0 ? O.none : O.some(1 / n)))\n  .filter((n) => n > 1)\n  .foldL(\n    () => 'ko',\n    () => 'ok'\n  )\n```\n\n----------------------------------------\n\nTITLE: Defining PipeableFoldable2C Interface in TypeScript\nDESCRIPTION: A pipeable version of the Foldable type class for higher-kinded types of arity 2 with a fixed first type parameter. It provides methods for folding a data structure with a constrained error type.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/pipeable.ts.md#2025-04-23_snippet_53\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface PipeableFoldable2C<F extends URIS2, E> {\n  readonly reduce: <A, B>(b: B, f: (b: B, a: A) => B) => (fa: Kind2<F, E, A>) => B\n  readonly foldMap: <M>(M: Monoid<M>) => <A>(f: (a: A) => M) => (fa: Kind2<F, E, A>) => M\n  readonly reduceRight: <A, B>(b: B, f: (a: A, b: B) => B) => (fa: Kind2<F, E, A>) => B\n}\n```\n\n----------------------------------------\n\nTITLE: Updating Head of NonEmptyArray in TypeScript\nDESCRIPTION: Changes the head (first element) of a NonEmptyArray, creating a new NonEmptyArray with the updated head.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/NonEmptyArray.ts.md#2025-04-23_snippet_26\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const updateHead: <A>(a: A) => (as: NonEmptyArray<A>) => NonEmptyArray<A>\n```\n\n----------------------------------------\n\nTITLE: Defining Deprecated FunctorWithIndexComposition11 Interface in TypeScript\nDESCRIPTION: Deprecated interface for composing two FunctorWithIndex instances with single type parameters, extending FunctorComposition11.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/FunctorWithIndex.ts.md#2025-04-23_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface FunctorWithIndexComposition11<F extends URIS, FI, G extends URIS, GI>\n  extends FunctorComposition11<F, G> {\n  readonly mapWithIndex: <A, B>(fa: Kind<F, Kind<G, A>>, f: (i: [FI, GI], a: A) => B) => Kind<F, Kind<G, B>>\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Pipeable Function Overloads for Functional Type Classes in TypeScript\nDESCRIPTION: This TypeScript code defines the pipeable function with multiple overloads, supporting different URI levels (URIS, URIS2, URIS3, URIS4) and type class interfaces. The function takes an instance and returns pipeable versions of methods based on the available type class implementations.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/pipeable.ts.md#2025-04-23_snippet_92\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare function pipeable<F extends URIS4, I>(\n  I: { readonly URI: F } & I\n): (I extends Chain4<F>\n  ? PipeableChain4<F>\n  : I extends Apply4<F>\n  ? PipeableApply4<F>\n  : I extends Functor4<F>\n  ? PipeableFunctor4<F>\n  : {}) &\n  (I extends Contravariant4<F> ? PipeableContravariant4<F> : {}) &\n  (I extends FunctorWithIndex4<F, infer Ix> ? PipeableFunctorWithIndex4<F, Ix> : {}) &\n  (I extends Bifunctor4<F> ? PipeableBifunctor4<F> : {}) &\n  (I extends Extend4<F> ? PipeableExtend4<F> : {}) &\n  (I extends FoldableWithIndex4<F, infer Ix>\n    ? PipeableFoldableWithIndex4<F, Ix>\n    : I extends Foldable4<F>\n    ? PipeableFoldable4<F>\n    : {}) &\n  (I extends Alt4<F> ? PipeableAlt4<F> : {}) &\n  (I extends FilterableWithIndex4<F, infer Ix>\n    ? PipeableFilterableWithIndex4<F, Ix>\n    : I extends Filterable4<F>\n    ? PipeableFilterable4<F>\n    : I extends Compactable4<F>\n    ? PipeableCompactable4<F>\n    : {}) &\n  (I extends Profunctor4<F> ? PipeableProfunctor4<F> : {}) &\n  (I extends Semigroupoid4<F> ? PipeableSemigroupoid4<F> : {}) &\n  (I extends MonadThrow4<F> ? PipeableMonadThrow4<F> : {})\nexport declare function pipeable<F extends URIS3, I>(\n  I: { readonly URI: F } & I\n): (I extends Chain3<F>\n  ? PipeableChain3<F>\n  : I extends Apply3<F>\n  ? PipeableApply3<F>\n  : I extends Functor3<F>\n  ? PipeableFunctor3<F>\n  : {}) &\n  (I extends Contravariant3<F> ? PipeableContravariant3<F> : {}) &\n  (I extends FunctorWithIndex3<F, infer Ix> ? PipeableFunctorWithIndex3<F, Ix> : {}) &\n  (I extends Bifunctor3<F> ? PipeableBifunctor3<F> : {}) &\n  (I extends Extend3<F> ? PipeableExtend3<F> : {}) &\n  (I extends FoldableWithIndex3<F, infer Ix>\n    ? PipeableFoldableWithIndex3<F, Ix>\n    : I extends Foldable3<F>\n    ? PipeableFoldable3<F>\n    : {}) &\n  (I extends Alt3<F> ? PipeableAlt3<F> : {}) &\n  (I extends FilterableWithIndex3<F, infer Ix>\n    ? PipeableFilterableWithIndex3<F, Ix>\n    : I extends Filterable3<F>\n    ? PipeableFilterable3<F>\n    : I extends Compactable3<F>\n    ? PipeableCompactable3<F>\n    : {}) &\n  (I extends Profunctor3<F> ? PipeableProfunctor3<F> : {}) &\n  (I extends Semigroupoid3<F> ? PipeableSemigroupoid3<F> : {}) &\n  (I extends MonadThrow3<F> ? PipeableMonadThrow3<F> : {})\nexport declare function pipeable<F extends URIS3, I, E>(\n  I: { readonly URI: F } & I\n): (I extends Chain3C<F, E>\n  ? PipeableChain3C<F, E>\n  : I extends Apply3C<F, E>\n  ? PipeableApply3C<F, E>\n  : I extends Functor3C<F, E>\n  ? PipeableFunctor3C<F, E>\n  : {}) &\n  (I extends Contravariant3C<F, E> ? PipeableContravariant3C<F, E> : {}) &\n  (I extends FunctorWithIndex3C<F, infer Ix, E> ? PipeableFunctorWithIndex3C<F, Ix, E> : {}) &\n  (I extends Bifunctor3C<F, E> ? PipeableBifunctor3C<F, E> : {}) &\n  (I extends Extend3C<F, E> ? PipeableExtend3C<F, E> : {}) &\n  (I extends FoldableWithIndex3C<F, infer Ix, E>\n    ? PipeableFoldableWithIndex3C<F, Ix, E>\n    : I extends Foldable3C<F, E>\n    ? PipeableFoldable3C<F, E>\n    : {}) &\n  (I extends Alt3C<F, E> ? PipeableAlt3C<F, E> : {}) &\n  (I extends FilterableWithIndex3C<F, infer Ix, E>\n    ? PipeableFilterableWithIndex3C<F, Ix, E>\n    : I extends Filterable3C<F, E>\n    ? PipeableFilterable3C<F, E>\n    : I extends Compactable3C<F, E>\n    ? PipeableCompactable3C<F, E>\n    : {}) &\n  (I extends Profunctor3C<F, E> ? PipeableProfunctor3C<F, E> : {}) &\n  (I extends Semigroupoid3C<F, E> ? PipeableSemigroupoid3C<F, E> : {}) &\n  (I extends MonadThrow3C<F, E> ? PipeableMonadThrow3C<F, E> : {})\nexport declare function pipeable<F extends URIS2, I, E>(\n  I: { readonly URI: F; readonly _E: E } & I\n): (I extends Chain2C<F, E>\n  ? PipeableChain2C<F, E>\n  : I extends Apply2C<F, E>\n  ? PipeableApply2C<F, E>\n  : I extends Functor2C<F, E>\n  ? PipeableFunctor2C<F, E>\n  : {}) &\n  (I extends Contravariant2C<F, E> ? PipeableContravariant2C<F, E> : {}) &\n  (I extends FunctorWithIndex2C<F, infer Ix, E> ? PipeableFunctorWithIndex2C<F, Ix, E> : {}) &\n  (I extends Extend2C<F, E> ? PipeableExtend2C<F, E> : {}) &\n  (I extends FoldableWithIndex2C<F, infer Ix, E>\n    ? PipeableFoldableWithIndex2C<F, Ix, E>\n    : I extends Foldable2C<F, E>\n    ? PipeableFoldable2C<F, E>\n    : {}) &\n  (I extends Alt2C<F, E> ? PipeableAlt2C<F, E> : {}) &\n  (I extends FilterableWithIndex2C<F, infer Ix, E>\n    ? PipeableFilterableWithIndex2C<F, Ix, E>\n    : I extends Filterable2C<F, E>\n    ? PipeableFilterable2C<F, E>\n    : I extends Compactable2C<F, E>\n    ? PipeableCompactable2C<F, E>\n    : {}) &\n  (I extends Profunctor2C<F, E> ? PipeableProfunctor2C<F, E> : {}) &\n  (I extends Semigroupoid2C<F, E> ? PipeableSemigroupoid2C<F, E> : {}) &\n  (I extends MonadThrow2C<F, E> ? PipeableMonadThrow2C<F, E> : {})\nexport declare function pipeable<F extends URIS2, I>(\n  I: { readonly URI: F } & I\n): (I extends Chain2<F>\n  ? PipeableChain2<F>\n  : I extends Apply2<F>\n  ? PipeableApply2<F>\n  : I extends Functor2<F>\n  ? PipeableFunctor2<F>\n  : {}) &\n  (I extends Contravariant2<F> ? PipeableContravariant2<F> : {}) &\n  (I extends FunctorWithIndex2<F, infer Ix> ? PipeableFunctorWithIndex2<F, Ix> : {}) &\n  (I extends Bifunctor2<F> ? PipeableBifunctor2<F> : {}) &\n  (I extends Extend2<F> ? PipeableExtend2<F> : {}) &\n  (I extends FoldableWithIndex2<F, infer Ix>\n    ? PipeableFoldableWithIndex2<F, Ix>\n    : I extends Foldable2<F>\n    ? PipeableFoldable2<F>\n    : {}) &\n  (I extends Alt2<F> ? PipeableAlt2<F> : {}) &\n  (I extends FilterableWithIndex2<F, infer Ix>\n    ? PipeableFilterableWithIndex2<F, Ix>\n    : I extends Filterable2<F>\n    ? PipeableFilterable2<F>\n    : I extends Compactable2<F>\n    ? PipeableCompactable2<F>\n    : {}) &\n  (I extends Profunctor2<F> ? PipeableProfunctor2<F> : {}) &\n  (I extends Semigroupoid2<F> ? PipeableSemigroupoid2<F> : {}) &\n  (I extends MonadThrow2<F> ? PipeableMonadThrow2<F> : {})\nexport declare function pipeable<F extends URIS, I>(\n  I: { readonly URI: F } & I\n): (I extends Chain1<F>\n  ? PipeableChain1<F>\n  : I extends Apply1<F>\n  ? PipeableApply1<F>\n  : I extends Functor1<F>\n  ? PipeableFunctor1<F>\n  : {}) &\n  (I extends Contravariant1<F> ? PipeableContravariant1<F> : {}) &\n  (I extends FunctorWithIndex1<F, infer Ix> ? PipeableFunctorWithIndex1<F, Ix> : {}) &\n  (I extends Extend1<F> ? PipeableExtend1<F> : {}) &\n  (I extends FoldableWithIndex1<F, infer Ix>\n    ? PipeableFoldableWithIndex1<F, Ix>\n    : I extends Foldable1<F>\n    ? PipeableFoldable1<F>\n    : {}) &\n  (I extends Alt1<F> ? PipeableAlt1<F> : {}) &\n  (I extends FilterableWithIndex1<F, infer Ix>\n    ? PipeableFilterableWithIndex1<F, Ix>\n    : I extends Filterable1<F>\n    ? PipeableFilterable1<F>\n    : I extends Compactable1<F>\n    ? PipeableCompactable1<F>\n    : {}) &\n  (I extends MonadThrow1<F> ? PipeableMonadThrow1<F> : {})\nexport declare function pipeable<F, I>(\n  I: { readonly URI: F } & I\n): (I extends Chain<F>\n  ? PipeableChain<F>\n  : I extends Apply<F>\n  ? PipeableApply<F>\n  : I extends Functor<F>\n  ? PipeableFunctor<F>\n  : {}) &\n  (I extends Contravariant<F> ? PipeableContravariant<F> : {}) &\n  (I extends FunctorWithIndex<F, infer Ix> ? PipeableFunctorWithIndex<F, Ix> : {}) &\n  (I extends Bifunctor<F> ? PipeableBifunctor<F> : {}) &\n  (I extends Extend<F> ? PipeableExtend<F> : {}) &\n  (I extends FoldableWithIndex<F, infer Ix>\n    ? PipeableFoldableWithIndex<F, Ix>\n    : I extends Foldable<F>\n    ? PipeableFoldable<F>\n    : {}) &\n  (I extends Alt<F> ? PipeableAlt<F> : {}) &\n  (I extends FilterableWithIndex<F, infer Ix>\n    ? PipeableFilterableWithIndex<F, Ix>\n    : I extends Filterable<F>\n    ? PipeableFilterable<F>\n    : I extends Compactable<F>\n    ? PipeableCompactable<F>\n    : {}) &\n  (I extends Profunctor<F> ? PipeableProfunctor<F> : {}) &\n  (I extends Semigroupoid<F> ? PipeableSemigroupoid<F> : {}) &\n  (I extends MonadThrow<F> ? PipeableMonadThrow<F> : {})\n```\n\n----------------------------------------\n\nTITLE: Contravariant3C Interface with Fixed Error Type\nDESCRIPTION: Defines a Contravariant interface for type constructors with three parameters where the error type E is fixed.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Contravariant.ts.md#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface Contravariant3C<F extends URIS3, E> {\n  readonly URI: F\n  readonly _E: E\n  readonly contramap: <R, A, B>(fa: Kind3<F, R, E, A>, f: (b: B) => A) => Kind3<F, R, E, B>\n}\n```\n\n----------------------------------------\n\nTITLE: Deprecated GroupSort Function for ReadonlyNonEmptyArray in TypeScript\nDESCRIPTION: Deprecated function that sorts and then groups elements of an array. This is equivalent to calling 'sort' followed by 'group'.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReadonlyNonEmptyArray.ts.md#2025-04-23_snippet_76\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare function groupSort<B>(O: Ord<B>): {\n  <A extends B>(as: ReadonlyNonEmptyArray<A>): ReadonlyNonEmptyArray<ReadonlyNonEmptyArray<A>>\n  <A extends B>(as: ReadonlyArray<A>): ReadonlyArray<ReadonlyNonEmptyArray<A>>\n}\n```\n\n----------------------------------------\n\nTITLE: Deprecated getTupleOrd Function in TypeScript\nDESCRIPTION: A deprecated function that creates an Ord for tuples. Use the tuple function instead.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Ord.ts.md#2025-04-23_snippet_26\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const getTupleOrd: <T extends readonly Ord<any>[]>(\n  ...ords: T\n) => Ord<{ [K in keyof T]: T[K] extends Ord<infer A> ? A : never }>\n```\n\n----------------------------------------\n\nTITLE: Defining URI type alias for ReaderIO in TypeScript\nDESCRIPTION: Defines a type alias for the URI constant of ReaderIO.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReaderIO.ts.md#2025-04-23_snippet_21\n\nLANGUAGE: typescript\nCODE:\n```\nexport type URI = typeof URI\n```\n\n----------------------------------------\n\nTITLE: Defining ApT Utility for ReaderTaskEither in TypeScript\nDESCRIPTION: Constant representing a ReaderTaskEither containing an empty tuple, commonly used with applicative operations. Added in v2.11.0.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReaderTaskEither.ts.md#2025-04-23_snippet_109\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const ApT: ReaderTaskEither<unknown, never, readonly []>\n```\n\n----------------------------------------\n\nTITLE: Min Monoid Usage Example\nDESCRIPTION: Example showing how to use the min monoid constructor with numbers.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Monoid.ts.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as N from 'fp-ts/number'\nimport * as M from 'fp-ts/Monoid'\n\nconst M1 = M.min(N.Bounded)\n\nassert.deepStrictEqual(M1.concat(1, 2), 1)\n```\n\n----------------------------------------\n\nTITLE: Defining URI Constant for Endomorphism in TypeScript\nDESCRIPTION: Defines a constant URI with the value 'Endomorphism' for type identification in the fp-ts ecosystem.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Endomorphism.ts.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const URI: 'Endomorphism'\n```\n\n----------------------------------------\n\nTITLE: Defining PipeableFoldableWithIndex3C Interface in TypeScript\nDESCRIPTION: Defines a pipeable interface for foldable operations with index on 3-parameter higher-kinded types with a fixed error type. It extends PipeableFoldable3C and includes methods for reducing, folding, and reducing right with index.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/pipeable.ts.md#2025-04-23_snippet_27\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport interface PipeableFoldableWithIndex3C<F extends URIS3, I, E> extends PipeableFoldable3C<F, E> {\n  readonly reduceWithIndex: <A, B>(b: B, f: (i: I, b: B, a: A) => B) => <R>(fa: Kind3<F, R, E, A>) => B\n  readonly foldMapWithIndex: <M>(M: Monoid<M>) => <A>(f: (i: I, a: A) => M) => <R>(fa: Kind3<F, R, E, A>) => M\n  readonly reduceRightWithIndex: <A, B>(b: B, f: (i: I, a: A, b: B) => B) => <R>(fa: Kind3<F, R, E, A>) => B\n}\n```\n\n----------------------------------------\n\nTITLE: Declaring getCompactableComposition Function with Multiple Overloads in TypeScript\nDESCRIPTION: This function is deprecated and has multiple overloads for different combinations of higher-kinded types F and G, along with various constraints on Functor and Compactable. It returns a CompactableComposition instance.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Compactable.ts.md#2025-04-23_snippet_6\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare function getCompactableComposition<F extends URIS2, G extends URIS3, E>(\n  F: Functor2<F>,\n  G: Compactable3C<G, E> & Functor3C<G, E>\n): CompactableComposition23C<F, G, E>\nexport declare function getCompactableComposition<F extends URIS2, G extends URIS2, E>(\n  F: Functor2<F>,\n  G: Compactable2C<G, E> & Functor2C<G, E>\n): CompactableComposition22C<F, G, E>\nexport declare function getCompactableComposition<F extends URIS2, G extends URIS2>(\n  F: Functor2<F>,\n  G: Compactable2<G> & Functor2<G>\n): CompactableComposition22<F, G>\nexport declare function getCompactableComposition<F extends URIS2, G extends URIS, E>(\n  F: Functor2C<F, E>,\n  G: Compactable1<G> & Functor1<G>\n): CompactableComposition2C1<F, G, E>\nexport declare function getCompactableComposition<F extends URIS2, G extends URIS>(\n  F: Functor2<F>,\n  G: Compactable1<G> & Functor1<G>\n): CompactableComposition21<F, G>\nexport declare function getCompactableComposition<F extends URIS, G extends URIS2, E>(\n  F: Functor1<F>,\n  G: Compactable2C<G, E> & Functor2C<G, E>\n): CompactableComposition12<F, G>\nexport declare function getCompactableComposition<F extends URIS, G extends URIS2>(\n  F: Functor1<F>,\n  G: Compactable2<G> & Functor2<G>\n): CompactableComposition12<F, G>\nexport declare function getCompactableComposition<F extends URIS, G extends URIS>(\n  F: Functor1<F>,\n  G: Compactable1<G> & Functor1<G>\n): CompactableComposition11<F, G>\nexport declare function getCompactableComposition<F, G>(\n  F: Functor<F>,\n  G: Compactable<G> & Functor<G>\n): CompactableComposition<F, G>\n```\n\n----------------------------------------\n\nTITLE: Deprecated Cons Function for ReadonlyNonEmptyArray in TypeScript\nDESCRIPTION: Deprecated function that prepends an element to an array to create a ReadonlyNonEmptyArray. Use 'prepend' from ReadonlyArray instead.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReadonlyNonEmptyArray.ts.md#2025-04-23_snippet_72\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare function cons<A>(head: A): (tail: ReadonlyArray<A>) => ReadonlyNonEmptyArray<A>\nexport declare function cons<A>(head: A, tail: ReadonlyArray<A>): ReadonlyNonEmptyArray<A>\n```\n\n----------------------------------------\n\nTITLE: Implementing Widening getOrElse Operation for ReaderTaskEither in TypeScript\nDESCRIPTION: Defines a less strict version of getOrElse (getOrElseW) for ReaderTaskEither, where the W suffix indicates widening of the handler return type.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReaderTaskEither.ts.md#2025-04-23_snippet_12\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare const getOrElseW: <R2, E, B>(\n  onLeft: (e: E) => RT.ReaderTask<R2, B>\n) => <R1, A>(ma: ReaderTaskEither<R1, E, A>) => RT.ReaderTask<R1 & R2, B | A>\n```\n\n----------------------------------------\n\nTITLE: Fallback Values in fp-ts 1.x (Deprecated)\nDESCRIPTION: Example showing both eager (getOrElse) and lazy (getOrElseL) fallback evaluation for Option in fp-ts 1.x.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/guides/upgrade-to-v2.md#2025-04-23_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as O from 'fp-ts/Option'\n\nO.some(1).getOrElse(0) // Direct\nO.some(1).getOrElseL(() => 0) // Lazy, i.e. only run if needed\n```\n\n----------------------------------------\n\nTITLE: Deprecated Fold Function for ReadonlyNonEmptyArray in TypeScript\nDESCRIPTION: Deprecated function that combines all elements of a ReadonlyNonEmptyArray using a Semigroup. Use 'concatAll' instead.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReadonlyNonEmptyArray.ts.md#2025-04-23_snippet_75\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const fold: <A>(S: Se.Semigroup<A>) => (as: ReadonlyNonEmptyArray<A>) => A\n```\n\n----------------------------------------\n\nTITLE: Defining PipeableFunctor4 Interface in TypeScript\nDESCRIPTION: A pipeable version of the Functor type class for higher-kinded types of arity 4. Provides the map method for functors with four type parameters.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/pipeable.ts.md#2025-04-23_snippet_68\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface PipeableFunctor4<F extends URIS4> {\n  readonly map: <A, B>(f: (a: A) => B) => <S, R, E>(fa: Kind4<F, S, R, E, A>) => Kind4<F, S, R, E, B>\n}\n```\n\n----------------------------------------\n\nTITLE: Deprecated IOEither functionality\nDESCRIPTION: Collection of deprecated functions and types including Applicative, getApplyMonoid, getApplySemigroup, getIOValidation, getSemigroup, and ioEither.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/IOEither.ts.md#2025-04-23_snippet_15\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const ioEither: Monad2<'IOEither'> &\n  Bifunctor2<'IOEither'> &\n  Alt2<'IOEither'> &\n  MonadIO2<'IOEither'> &\n  MonadThrow2<'IOEither'>\n```\n\n----------------------------------------\n\nTITLE: Defining PipeableFunctorWithIndex4 Interface in TypeScript\nDESCRIPTION: Extends PipeableFunctor4 to provide indexed mapping operations for arity 4 higher-kinded types. Adds the mapWithIndex method that receives both the index and value during mapping.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/pipeable.ts.md#2025-04-23_snippet_73\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface PipeableFunctorWithIndex4<F extends URIS4, I> extends PipeableFunctor4<F> {\n  readonly mapWithIndex: <A, B>(f: (i: I, a: A) => B) => <S, R, E>(fa: Kind4<F, S, R, E, A>) => Kind4<F, S, R, E, B>\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Deprecated ApplicativeComposition11 Interface\nDESCRIPTION: A deprecated interface representing composition of two applicative functors, both with one type parameter.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Applicative.ts.md#2025-04-23_snippet_8\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport interface ApplicativeComposition11<F extends URIS, G extends URIS> extends FunctorComposition11<F, G> {\n  readonly of: <A>(a: A) => Kind<F, Kind<G, A>>\n  readonly ap: <A, B>(fgab: Kind<F, Kind<G, (a: A) => B>>, fga: Kind<F, Kind<G, A>>) => Kind<F, Kind<G, B>>\n}\n```\n\n----------------------------------------\n\nTITLE: Deprecated string equality in TypeScript\nDESCRIPTION: Deprecated Eq instance for string values. Users should use the Eq from the string module instead.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Eq.ts.md#2025-04-23_snippet_16\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const eqString: Eq<string>\n```\n\n----------------------------------------\n\nTITLE: Defining PipeableFilterable3 Interface in TypeScript\nDESCRIPTION: Interface definition for PipeableFilterable3 which extends PipeableCompactable3 with filtering operations for higher-kinded types of arity 3. It provides methods to filter, map, and partition data structures with three type parameters.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/pipeable.ts.md#2025-04-23_snippet_43\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface PipeableFilterable3<F extends URIS3> extends PipeableCompactable3<F> {\n  readonly filter: {\n    <A, B extends A>(refinement: Refinement<A, B>): <R, E>(fa: Kind3<F, R, E, A>) => Kind3<F, R, E, B>\n    <A>(predicate: Predicate<A>): <R, E>(fa: Kind3<F, R, E, A>) => Kind3<F, R, E, A>\n  }\n  readonly filterMap: <A, B>(f: (a: A) => Option<B>) => <R, E>(fa: Kind3<F, R, E, A>) => Kind3<F, R, E, A>\n  readonly partition: {\n    <A, B extends A>(refinement: Refinement<A, B>): <R, E>(\n      fa: Kind3<F, R, E, A>\n    ) => Separated<Kind3<F, R, E, A>, Kind3<F, R, E, B>>\n    <A>(predicate: Predicate<A>): <R, E>(fa: Kind3<F, R, E, A>) => Separated<Kind3<F, R, E, A>, Kind3<F, R, E, A>>\n  }\n  readonly partitionMap: <A, B, C>(\n    f: (a: A) => Either<B, C>\n  ) => <R, E>(fa: Kind3<F, R, E, A>) => Separated<Kind3<F, R, E, B>, Kind3<F, R, E, C>>\n}\n```\n\n----------------------------------------\n\nTITLE: Defining PipeableSemigroupoid3C Interface in TypeScript\nDESCRIPTION: Defines a pipeable interface for semigroupoid operations on 3-parameter higher-kinded types with a fixed error type. It includes a method for composition.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/pipeable.ts.md#2025-04-23_snippet_32\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport interface PipeableSemigroupoid3C<F extends URIS3, E> {\n  readonly compose: <R, A>(la: Kind3<F, R, E, A>) => <B>(ab: Kind3<F, R, A, B>) => Kind3<F, R, E, B>\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Semigroupoid2 Interface in TypeScript\nDESCRIPTION: Defines the Semigroupoid2 interface for a higher-kinded type F extending URIS2. It includes a URI property and a compose method for combining two morphisms.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Semigroupoid.ts.md#2025-04-23_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport interface Semigroupoid2<F extends URIS2> {\n  readonly URI: F\n  readonly compose: <A, B, C>(ab: Kind2<F, B, C>, la: Kind2<F, A, B>) => Kind2<F, A, C>\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Deprecated ApplicativeComposition Interface\nDESCRIPTION: A deprecated interface representing composition of two general HKT applicative functors.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Applicative.ts.md#2025-04-23_snippet_18\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport interface ApplicativeComposition<F, G> extends FunctorComposition<F, G> {\n  readonly of: <A>(a: A) => HKT<F, HKT<G, A>>\n  readonly ap: <A, B>(fgab: HKT<F, HKT<G, (a: A) => B>>, fga: HKT<F, HKT<G, A>>) => HKT<F, HKT<G, B>>\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing bimap for Const in TypeScript\nDESCRIPTION: Maps a pair of functions over the two type arguments of the Const bifunctor. In practice, only the first function affects the value.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Const.ts.md#2025-04-23_snippet_17\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const bimap: <E, G, A, B>(f: (e: E) => G, g: (a: A) => B) => (fa: Const<E, A>) => Const<G, B>\n```\n\n----------------------------------------\n\nTITLE: Deprecated eq instance in TypeScript\nDESCRIPTION: Deprecated general eq instance that provides Contravariant functionality. Users should use specific instances like E.Contravariant instead.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Eq.ts.md#2025-04-23_snippet_17\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const eq: Contravariant1<'Eq'>\n```\n\n----------------------------------------\n\nTITLE: Defining PipeableFunctor3C Interface in TypeScript\nDESCRIPTION: Defines a pipeable interface for functor operations on 3-parameter higher-kinded types with a fixed error type. It includes a method for mapping.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/pipeable.ts.md#2025-04-23_snippet_28\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport interface PipeableFunctor3C<F extends URIS3, E> {\n  readonly map: <A, B>(f: (a: A) => B) => <R>(fa: Kind3<F, R, E, A>) => Kind3<F, R, E, B>\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Semigroupoid3C Interface in TypeScript\nDESCRIPTION: Defines the Semigroupoid3C interface for a higher-kinded type F extending URIS3 with a fixed type A. It includes URI and _E properties, and a compose method for combining two morphisms with three type parameters.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Semigroupoid.ts.md#2025-04-23_snippet_4\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport interface Semigroupoid3C<F extends URIS3, A> {\n  readonly URI: F\n  readonly _E: A\n  readonly compose: <R, B, C>(ab: Kind3<F, R, B, C>, la: Kind3<F, R, A, B>) => Kind3<F, R, A, C>\n}\n```\n\n----------------------------------------\n\nTITLE: Deprecated BoundedNumber Implementation\nDESCRIPTION: Legacy implementation of Bounded for number type, marked as deprecated. Users should use the Bounded implementation from number.ts instead.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Bounded.ts.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const boundedNumber: Bounded<number>\n```\n\n----------------------------------------\n\nTITLE: Defining MonadTask2C Interface in TypeScript\nDESCRIPTION: Defines the MonadTask2C interface extending MonadIO2C and FromTask2C for URIS2 type M and type E.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/MonadTask.ts.md#2025-04-23_snippet_3\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport interface MonadTask2C<M extends URIS2, E> extends MonadIO2C<M, E>, FromTask2C<M, E> {}\n```\n\n----------------------------------------\n\nTITLE: Defining PartitionWithIndex3C Interface in TypeScript\nDESCRIPTION: Interface for partitioning 3-kind type constructors with fixed error type and index support. Similar to PartitionWithIndex3 but with constrained error type.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/FilterableWithIndex.ts.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface PartitionWithIndex3C<F extends URIS3, I, E> {\n  <R, A, B extends A>(fa: Kind3<F, R, E, A>, refinementWithIndex: RefinementWithIndex<I, A, B>): Separated<\n    Kind3<F, R, E, A>,\n    Kind3<F, R, E, B>\n  >\n  <R, A>(fa: Kind3<F, R, E, A>, predicateWithIndex: PredicateWithIndex<I, A>): Separated<\n    Kind3<F, R, E, A>,\n    Kind3<F, R, E, A>\n  >\n}\n```\n\n----------------------------------------\n\nTITLE: Deprecated Number Ordinal Implementation in TypeScript\nDESCRIPTION: Deprecated ordinal implementation for number values. Users should use the Ord implementation from number.ts instead.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Ord.ts.md#2025-04-23_snippet_29\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const ordNumber: Ord<number>\n```\n\n----------------------------------------\n\nTITLE: Splitting ReadonlyNonEmptyArray into Head and Tail in TypeScript\nDESCRIPTION: Function that returns a tuple containing the first element (head) and all remaining elements (tail) of a ReadonlyNonEmptyArray.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReadonlyNonEmptyArray.ts.md#2025-04-23_snippet_65\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const unprepend: <A>(as: ReadonlyNonEmptyArray<A>) => readonly [A, readonly A[]]\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport { unprepend } from 'fp-ts/ReadonlyNonEmptyArray'\n\nassert.deepStrictEqual(unprepend([1, 2, 3, 4]), [1, [2, 3, 4]])\n```\n\n----------------------------------------\n\nTITLE: Deprecated Array Deconstruction Operation (uncons)\nDESCRIPTION: Deprecated function for deconstructing a ReadonlyNonEmptyArray into a tuple of first element and remaining elements. Users should use the unprepend function instead.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReadonlyNonEmptyArray.ts.md#2025-04-23_snippet_81\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const uncons: <A>(as: ReadonlyNonEmptyArray<A>) => readonly [A, readonly A[]]\n```\n\n----------------------------------------\n\nTITLE: Defining RefinementWithIndex Type in TypeScript\nDESCRIPTION: Type alias for a refinement function that takes an index and a value, acting as a type guard to narrow the type.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/FilterableWithIndex.ts.md#2025-04-23_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nexport type RefinementWithIndex<I, A, B extends A> = (i: I, a: A) => a is B\n```\n\n----------------------------------------\n\nTITLE: Defining ReaderM3 Interface in TypeScript\nDESCRIPTION: Defines the ReaderM3 interface with methods similar to ReaderM2, but parameterized by a type M extending URIS3. It includes additional type parameters for handling three-level nested types.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReaderT.ts.md#2025-04-23_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface ReaderM3<M extends URIS3> {\n  readonly map: <R, U, E, A, B>(ma: ReaderT3<M, R, U, E, A>, f: (a: A) => B) => ReaderT3<M, R, U, E, B>\n  readonly of: <R, U, E, A>(a: A) => ReaderT3<M, R, U, E, A>\n  readonly ap: <R, U, E, A, B>(\n    mab: ReaderT3<M, R, U, E, (a: A) => B>,\n    ma: ReaderT3<M, R, U, E, A>\n  ) => ReaderT3<M, R, U, E, B>\n  readonly chain: <R, U, E, A, B>(\n    ma: ReaderT3<M, R, U, E, A>,\n    f: (a: A) => ReaderT3<M, R, U, E, B>\n  ) => ReaderT3<M, R, U, E, B>\n  readonly ask: <R, U, E>() => ReaderT3<M, R, U, E, R>\n  readonly asks: <R, U, E, A>(f: (r: R) => A) => ReaderT3<M, R, U, E, A>\n  readonly local: <R1, U, E, A, R2>(ma: ReaderT3<M, R1, U, E, A>, f: (d: R2) => R1) => ReaderT3<M, R2, U, E, A>\n  readonly fromReader: <R, U, E, A>(ma: Reader<R, A>) => ReaderT3<M, R, U, E, A>\n  readonly fromM: <R, U, E, A>(ma: Kind3<M, U, E, A>) => ReaderT3<M, R, U, E, A>\n}\n```\n\n----------------------------------------\n\nTITLE: Pointed3 Interface for Ternary Type Constructors\nDESCRIPTION: Interface for functors with three type parameters using URIS3 constraint. Adds a reader type parameter R.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Pointed.ts.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface Pointed3<F extends URIS3> {\n  readonly URI: F\n  readonly of: <R, E, A>(a: A) => Kind3<F, R, E, A>\n}\n```\n\n----------------------------------------\n\nTITLE: Deprecated getDualOrd Function in TypeScript\nDESCRIPTION: A deprecated function that creates an Ord with reversed comparison logic. Use the reverse function instead.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Ord.ts.md#2025-04-23_snippet_25\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const getDualOrd: <A>(O: Ord<A>) => Ord<A>\n```\n\n----------------------------------------\n\nTITLE: Split Function Type Signatures\nDESCRIPTION: PureScript type signature showing specialized split functionality for function application.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Choice.ts.md#2025-04-23_snippet_3\n\nLANGUAGE: purescript\nCODE:\n```\nsplit :: forall a b c d. (a -> b) -> (c -> d) -> (Either a c) -> (Either b d)\n```\n\n----------------------------------------\n\nTITLE: Contravariant3 Interface with Three Type Parameters\nDESCRIPTION: Defines a Contravariant interface for type constructors with three type parameters, using Kind3 for type-safe operations.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Contravariant.ts.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface Contravariant3<F extends URIS3> {\n  readonly URI: F\n  readonly contramap: <R, E, A, B>(fa: Kind3<F, R, E, A>, f: (b: B) => A) => Kind3<F, R, E, B>\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Deprecated ApplicativeComposition12C Interface\nDESCRIPTION: A deprecated interface representing composition of an applicative functor with one type parameter and another with two, where the second has a fixed first type parameter.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Applicative.ts.md#2025-04-23_snippet_9\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport interface ApplicativeComposition12C<F extends URIS, G extends URIS2, E> extends FunctorComposition12C<F, G, E> {\n  readonly of: <A>(a: A) => Kind<F, Kind2<G, E, A>>\n  readonly ap: <A, B>(fgab: Kind<F, Kind2<G, E, (a: A) => B>>, fga: Kind<F, Kind2<G, E, A>>) => Kind<F, Kind2<G, E, B>>\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Alt Instance with Error Concatenation for ReaderTaskEither in TypeScript\nDESCRIPTION: Defines a function to create an Alt instance for ReaderTaskEither that concatenates errors using a provided Semigroup.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReaderTaskEither.ts.md#2025-04-23_snippet_9\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare function getAltReaderTaskValidation<E>(S: Semigroup<E>): Alt3C<URI, E>\n```\n\n----------------------------------------\n\nTITLE: Deprecated store Instance for Store in TypeScript\nDESCRIPTION: Declares the deprecated store instance for Store, which combines multiple typeclasses. It's recommended to use specific instances instead.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Store.ts.md#2025-04-23_snippet_14\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const store: Comonad2<'Store'>\n```\n\n----------------------------------------\n\nTITLE: Defining Strong Interface in TypeScript\nDESCRIPTION: This code defines the Strong interface, which extends Profunctor with 'first' and 'second' methods for working with tuples. It uses higher-kinded types to represent the profunctor.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Strong.ts.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface Strong<F> extends Profunctor<F> {\n  readonly first: <A, B, C>(pab: HKT2<F, A, B>) => HKT2<F, [A, C], [B, C]>\n  readonly second: <A, B, C>(pab: HKT2<F, B, C>) => HKT2<F, [A, B], [A, C]>\n}\n```\n\n----------------------------------------\n\nTITLE: Traversing ReadonlyArray with Index Sequentially (TypeScript)\nDESCRIPTION: Function to traverse a ReadonlyArray with index using ApplicativeSeq. It takes a function that maps an index and element to a Task, and returns a function that takes a ReadonlyArray and returns a Task of ReadonlyArray.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Task.ts.md#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const traverseReadonlyArrayWithIndexSeq: <A, B>(\n  f: (index: number, a: A) => Task<B>\n) => (as: readonly A[]) => Task<readonly B[]>\n```\n\n----------------------------------------\n\nTITLE: Defining Deprecated ApplicativeComposition2C1 Interface\nDESCRIPTION: A deprecated interface representing composition of an applicative functor with two type parameters (first fixed) and another with one type parameter.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Applicative.ts.md#2025-04-23_snippet_14\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport interface ApplicativeComposition2C1<F extends URIS2, G extends URIS, E> extends FunctorComposition2C1<F, G, E> {\n  readonly of: <A>(a: A) => Kind2<F, E, Kind<G, A>>\n  readonly ap: <A, B>(fgab: Kind2<F, E, Kind<G, (a: A) => B>>, fga: Kind2<F, E, Kind<G, A>>) => Kind2<F, E, Kind<G, B>>\n}\n```\n\n----------------------------------------\n\nTITLE: Defining PipeableChain2 Interface in TypeScript\nDESCRIPTION: This interface extends PipeableApply2 and defines chain, chainFirst, and flatten operations for a higher-kinded type F with two type parameters.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/pipeable.ts.md#2025-04-23_snippet_34\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface PipeableChain2<F extends URIS2> extends PipeableApply2<F> {\n  readonly chain: <E, A, B>(f: (a: A) => Kind2<F, E, B>) => (ma: Kind2<F, E, A>) => Kind2<F, E, B>\n  readonly chainFirst: <E, A, B>(f: (a: A) => Kind2<F, E, B>) => (ma: Kind2<F, E, A>) => Kind2<F, E, A>\n  readonly flatten: <E, A>(mma: Kind2<F, E, Kind2<F, E, A>>) => Kind2<F, E, A>\n}\n```\n\n----------------------------------------\n\nTITLE: Deprecated run function in StateReaderTaskEither (TypeScript)\nDESCRIPTION: A deprecated function that runs a StateReaderTaskEither computation with initial state and environment, returning a Promise of Either containing the result and final state.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/StateReaderTaskEither.ts.md#2025-04-23_snippet_77\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare function run<S, R, E, A>(ma: StateReaderTaskEither<S, R, E, A>, s: S, r: R): Promise<Either<E, [A, S]>>\n```\n\n----------------------------------------\n\nTITLE: Basic Type Show Implementations in TypeScript\nDESCRIPTION: Deprecated Show instances for boolean, number, and string types.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Show.ts.md#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const showBoolean: Show<boolean>\n```\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const showNumber: Show<number>\n```\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const showString: Show<string>\n```\n\n----------------------------------------\n\nTITLE: Defining PipeableProfunctor2C Interface in TypeScript\nDESCRIPTION: Defines a deprecated PipeableProfunctor2C interface that extends PipeableFunctor2C with the promap method for higher-kinded types of arity 2 with a fixed first type parameter. This interface enables transformation of input and output types.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/pipeable.ts.md#2025-04-23_snippet_82\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface PipeableProfunctor2C<F extends URIS2, E> extends PipeableFunctor2C<F, E> {\n  readonly promap: <A, D, B>(f: (d: D) => E, g: (a: A) => B) => (fbc: Kind2<F, E, A>) => Kind2<F, D, B>\n}\n```\n\n----------------------------------------\n\nTITLE: ReaderTask Utility Functions\nDESCRIPTION: Various utility functions for working with ReaderTask including applicative operations and environment modifications\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReaderTask.ts.md#2025-04-23_snippet_15\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const ApT: ReaderTask<unknown, readonly []>\n\nexport declare const ap: <R, A>(fa: ReaderTask<R, A>) => <B>(fab: ReaderTask<R, (a: A) => B>) => ReaderTask<R, B>\n\nexport declare const apFirst: <E, B>(second: ReaderTask<E, B>) => <A>(first: ReaderTask<E, A>) => ReaderTask<E, A>\n\nexport declare const apFirstW: <R2, B>(\n  second: ReaderTask<R2, B>\n) => <R1, A>(first: ReaderTask<R1, A>) => ReaderTask<R1 & R2, A>\n\nexport declare const local: <R2, R1>(f: (r2: R2) => R1) => <A>(ma: ReaderTask<R1, A>) => ReaderTask<R2, A>\n```\n\n----------------------------------------\n\nTITLE: Deprecated eqOrdering Instance\nDESCRIPTION: Deprecated Eq instance for Ordering, replaced by Eq.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Ordering.ts.md#2025-04-23_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const eqOrdering: E.Eq<Ordering>\n```\n\n----------------------------------------\n\nTITLE: Defining PipeableProfunctor2 Interface in TypeScript\nDESCRIPTION: Defines a deprecated PipeableProfunctor2 interface that extends PipeableFunctor2 with the promap method for higher-kinded types of arity 2. This interface provides functorial mapping over both input and output types.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/pipeable.ts.md#2025-04-23_snippet_83\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface PipeableProfunctor2<F extends URIS2> extends PipeableFunctor2<F> {\n  readonly promap: <E, A, D, B>(f: (d: D) => E, g: (a: A) => B) => (fbc: Kind2<F, E, A>) => Kind2<F, D, B>\n}\n```\n\n----------------------------------------\n\nTITLE: Defining PipeableProfunctor3 Interface in TypeScript\nDESCRIPTION: Defines a deprecated PipeableProfunctor3 interface that extends PipeableFunctor3 with the promap method for higher-kinded types of arity 3. This interface allows transformation of both contravariant and covariant components.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/pipeable.ts.md#2025-04-23_snippet_84\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface PipeableProfunctor3<F extends URIS3> extends PipeableFunctor3<F> {\n  readonly promap: <R, E, A, D, B>(f: (d: D) => E, g: (a: A) => B) => (fbc: Kind3<F, R, E, A>) => Kind3<F, R, D, B>\n}\n```\n\n----------------------------------------\n\nTITLE: Converting ReadonlyMap to sorted ReadonlyArray in TypeScript\nDESCRIPTION: Converts a ReadonlyMap to a sorted ReadonlyArray of key/value pairs.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReadonlyMap.ts.md#2025-04-23_snippet_3\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare const toReadonlyArray: <K>(O: Ord<K>) => <A>(m: ReadonlyMap<K, A>) => readonly (readonly [K, A])[]\n```\n\n----------------------------------------\n\nTITLE: Defining ValidationM Interface in TypeScript\nDESCRIPTION: Defines a deprecated interface ValidationM that extends ApplicativeCompositionHKT2C with additional chain and alt methods for ValidationT.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ValidationT.ts.md#2025-04-23_snippet_2\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport interface ValidationM<M, E> extends ApplicativeCompositionHKT2C<M, E.URI, E> {\n  readonly chain: <A, B>(ma: ValidationT<M, E, A>, f: (a: A) => ValidationT<M, E, B>) => ValidationT<M, E, B>\n\n  readonly alt: <A>(fa: ValidationT<M, E, A>, that: LazyArg<ValidationT<M, E, A>>) => ValidationT<M, E, A>\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Foldable2C Interface in TypeScript\nDESCRIPTION: Type class definition for Foldable with two type parameters but fixed error type E, allowing for simpler signatures when the error type doesn't change.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Foldable.ts.md#2025-04-23_snippet_3\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport interface Foldable2C<F extends URIS2, E> {\n  readonly URI: F\n  readonly _E: E\n  readonly reduce: <A, B>(fa: Kind2<F, E, A>, b: B, f: (b: B, a: A) => B) => B\n  readonly foldMap: <M>(M: Monoid<M>) => <A>(fa: Kind2<F, E, A>, f: (a: A) => M) => M\n  readonly reduceRight: <A, B>(fa: Kind2<F, E, A>, b: B, f: (a: A, b: B) => B) => B\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing filterMapWithIndex in TypeScript\nDESCRIPTION: Type declarations for a pipeable filterMapWithIndex function that includes an index parameter in the mapping function. Supports multiple type parameter scenarios with index tracking.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/pipeable.ts.md#2025-04-23_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare function filterMapWithIndex<F extends URIS4, I>(\n  F: FilterableWithIndex4<F, I>\n): <A, B>(f: (i: I, a: A) => Option<B>) => <S, R, E>(fa: Kind4<F, S, R, E, A>) => Kind4<F, S, R, E, B>\n```\n\n----------------------------------------\n\nTITLE: Deprecated stateReaderTaskEitherSeq instance in StateReaderTaskEither (TypeScript)\nDESCRIPTION: A deprecated monadic instance that provides sequential Monad, Bifunctor, Alt, MonadTask, and MonadThrow implementations for the StateReaderTaskEither type. Users should use small, specific instances instead.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/StateReaderTaskEither.ts.md#2025-04-23_snippet_78\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const stateReaderTaskEitherSeq: Monad4<'StateReaderTaskEither'> &\n  Bifunctor4<'StateReaderTaskEither'> &\n  Alt4<'StateReaderTaskEither'> &\n  MonadTask4<'StateReaderTaskEither'> &\n  MonadThrow4<'StateReaderTaskEither'>\n```\n\n----------------------------------------\n\nTITLE: Defining Deprecated getApplicativeComposition Function in TypeScript\nDESCRIPTION: This code snippet defines multiple overloads of the deprecated getApplicativeComposition function. It combines two Applicative functors to create a composed Applicative. The function is marked as deprecated, and users are advised to use the 'ap' function from the Apply module instead.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Applicative.ts.md#2025-04-23_snippet_19\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare function getApplicativeComposition<F extends URIS2, G extends URIS2, E>(\n  F: Applicative2<F>,\n  G: Applicative2C<G, E>\n): ApplicativeComposition22C<F, G, E>\nexport declare function getApplicativeComposition<F extends URIS2, G extends URIS2>(\n  F: Applicative2<F>,\n  G: Applicative2<G>\n): ApplicativeComposition22<F, G>\nexport declare function getApplicativeComposition<F extends URIS2, G extends URIS2, E>(\n  F: Applicative2<F>,\n  G: Applicative2C<G, E>\n): ApplicativeComposition22C<F, G, E>\nexport declare function getApplicativeComposition<F extends URIS2, G extends URIS>(\n  F: Applicative2<F>,\n  G: Applicative1<G>\n): ApplicativeComposition21<F, G>\nexport declare function getApplicativeComposition<F extends URIS, G extends URIS2>(\n  F: Applicative1<F>,\n  G: Applicative2<G>\n): ApplicativeComposition12<F, G>\nexport declare function getApplicativeComposition<F extends URIS, G extends URIS2, E>(\n  F: Applicative1<F>,\n  G: Applicative2C<G, E>\n): ApplicativeComposition12C<F, G, E>\nexport declare function getApplicativeComposition<F extends URIS, G extends URIS>(\n  F: Applicative1<F>,\n  G: Applicative1<G>\n): ApplicativeComposition11<F, G>\nexport declare function getApplicativeComposition<F, G extends URIS2>(\n  F: Applicative<F>,\n  G: Applicative2<G>\n): ApplicativeCompositionHKT2<F, G>\nexport declare function getApplicativeComposition<F, G extends URIS2, E>(\n  F: Applicative<F>,\n  G: Applicative2C<G, E>\n): ApplicativeCompositionHKT2C<F, G, E>\nexport declare function getApplicativeComposition<F, G extends URIS>(\n  F: Applicative<F>,\n  G: Applicative1<G>\n): ApplicativeCompositionHKT1<F, G>\nexport declare function getApplicativeComposition<F, G>(\n  F: Applicative<F>,\n  G: Applicative<G>\n): ApplicativeComposition<F, G>\n```\n\n----------------------------------------\n\nTITLE: Deprecated boolean equality in TypeScript\nDESCRIPTION: Deprecated Eq instance for boolean values. Users should use the Eq from the boolean module instead.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Eq.ts.md#2025-04-23_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const eqBoolean: Eq<boolean>\n```\n\n----------------------------------------\n\nTITLE: Defining PipeableProfunctor4 Interface in TypeScript\nDESCRIPTION: Defines a deprecated PipeableProfunctor4 interface that extends PipeableFunctor4 with the promap method for higher-kinded types of arity 4. This interface enables bidirectional transformations of types within a structure.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/pipeable.ts.md#2025-04-23_snippet_85\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface PipeableProfunctor4<F extends URIS4> extends PipeableFunctor4<F> {\n  readonly promap: <S, R, E, A, D, B>(\n    f: (d: D) => E,\n    g: (a: A) => B\n  ) => (fbc: Kind4<F, S, R, E, A>) => Kind4<F, S, R, D, B>\n}\n```\n\n----------------------------------------\n\nTITLE: Deprecated getApplySemigroup function for ReaderTaskEither in TypeScript\nDESCRIPTION: A deprecated function for getting an Apply Semigroup for ReaderTaskEither. It returns the left-most Left value, or concatenates Right values using the provided Semigroup.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReaderTaskEither.ts.md#2025-04-23_snippet_122\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const getApplySemigroup: <R, E, A>(S: Semigroup<A>) => Semigroup<ReaderTaskEither<R, E, A>>\n```\n\n----------------------------------------\n\nTITLE: Defining Zero3C interface for constrained URIS3 functors in TypeScript\nDESCRIPTION: This interface defines the structure for a Zero type class for constrained functors of kind URIS3. It includes a URI type, an _E type parameter, and a zero method that returns a Kind3 of the functor.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Zero.ts.md#2025-04-23_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface Zero3C<F extends URIS3, E> {\n  readonly URI: F\n  readonly _E: E\n  readonly zero: <R, A>() => Kind3<F, R, E, A>\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Deprecated FunctorWithIndexComposition22 Interface in TypeScript\nDESCRIPTION: Deprecated interface for composing two FunctorWithIndex2 instances, extending FunctorComposition22.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/FunctorWithIndex.ts.md#2025-04-23_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface FunctorWithIndexComposition22<F extends URIS2, FI, G extends URIS2, GI>\n  extends FunctorComposition22<F, G> {\n  readonly mapWithIndex: <FE, GE, A, B>(\n    fa: Kind2<F, FE, Kind2<G, GE, A>>,\n    f: (i: [FI, GI], a: A) => B\n  ) => Kind2<F, FE, Kind2<G, GE, B>>\n}\n```\n\n----------------------------------------\n\nTITLE: Deprecated ReadonlyTuple Instance in TypeScript\nDESCRIPTION: Defines a deprecated instance of ReadonlyTuple that combines multiple functional programming concepts. It's recommended to use specific instances instead.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReadonlyTuple.ts.md#2025-04-23_snippet_9\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare const readonlyTuple: Semigroupoid2<'ReadonlyTuple'> & Bifunctor2<'ReadonlyTuple'> & Comonad2<'ReadonlyTuple'> & Foldable2<'ReadonlyTuple'> & Traversable2<'ReadonlyTuple'>\n```\n\n----------------------------------------\n\nTITLE: Defining PipeableSemigroupoid2C Interface in TypeScript\nDESCRIPTION: Defines a deprecated PipeableSemigroupoid2C interface with the compose method for higher-kinded types of arity 2 with a fixed first type parameter. This provides composition functionality for category-like structures.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/pipeable.ts.md#2025-04-23_snippet_87\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface PipeableSemigroupoid2C<F extends URIS2, E> {\n  readonly compose: <A>(la: Kind2<F, E, A>) => <B>(ab: Kind2<F, A, B>) => Kind2<F, E, B>\n}\n```\n\n----------------------------------------\n\nTITLE: Deprecated insertAt function for Records in TypeScript\nDESCRIPTION: A deprecated function for inserting a key-value pair into a Record. Users should use upsertAt instead.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Record.ts.md#2025-04-23_snippet_63\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const insertAt: <A>(k: string, a: A) => (r: Record<string, A>) => Record<string, A>\n```\n\n----------------------------------------\n\nTITLE: Legacy Struct Show Implementation in TypeScript\nDESCRIPTION: Deprecated implementation for creating Show instances for struct-like objects.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Show.ts.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const getStructShow: <O extends Readonly<Record<string, any>>>(shows: {\n  [K in keyof O]: Show<O[K]>\n}) => Show<O>\n```\n\n----------------------------------------\n\nTITLE: Defining PipeableSemigroupoid2 Interface in TypeScript\nDESCRIPTION: Defines a deprecated PipeableSemigroupoid2 interface with the compose method for higher-kinded types of arity 2. This interface enables pipeable composition of morphisms in a category-like structure.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/pipeable.ts.md#2025-04-23_snippet_88\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface PipeableSemigroupoid2<F extends URIS2> {\n  readonly compose: <E, A>(la: Kind2<F, E, A>) => <B>(ab: Kind2<F, A, B>) => Kind2<F, E, B>\n}\n```\n\n----------------------------------------\n\nTITLE: Deprecated option Instance Definition\nDESCRIPTION: Deprecated comprehensive Option type class instance, recommended to use specific instances instead.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Option.ts.md#2025-04-23_snippet_21\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const option: Monad1<'Option'> & Foldable1<'Option'> & Alternative1<'Option'> & Extend1<'Option'> & Witherable1<'Option'> & MonadThrow1<'Option'>\n```\n\n----------------------------------------\n\nTITLE: Default Equals Implementation for Ord in TypeScript\nDESCRIPTION: Provides a default implementation for the equals method based on a compare function. This utility helps when implementing the `Ord` interface.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Ord.ts.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const equalsDefault: <A>(compare: (first: A, second: A) => Ordering) => (x: A, y: A) => boolean\n```\n\n----------------------------------------\n\nTITLE: Defining Apply1 Interface in TypeScript\nDESCRIPTION: This code snippet defines the Apply1 interface, a variant of Apply for type constructors with one type parameter.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Apply.ts.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface Apply1<F extends URIS> extends Functor1<F> {\n  readonly ap: <A, B>(fab: Kind<F, (a: A) => B>, fa: Kind<F, A>) => Kind<F, B>\n}\n```\n\n----------------------------------------\n\nTITLE: Deprecated mapNullable Function Definition\nDESCRIPTION: Deprecated function signature for mapNullable, replaced by chainNullableK.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Option.ts.md#2025-04-23_snippet_20\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const mapNullable: <A, B>(f: (a: A) => B | null | undefined) => (ma: Option<A>) => Option<NonNullable<B>>\n```\n\n----------------------------------------\n\nTITLE: Implementing Widening Alt Operation for ReaderTaskEither in TypeScript\nDESCRIPTION: Defines a less strict version of alt (altW) for ReaderTaskEither, where the W suffix indicates widening of environment, error, and return types.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReaderTaskEither.ts.md#2025-04-23_snippet_8\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare const altW: <R2, E2, B>(\n  that: () => ReaderTaskEither<R2, E2, B>\n) => <R1, E1, A>(fa: ReaderTaskEither<R1, E1, A>) => ReaderTaskEither<R1 & R2, E2, B | A>\n```\n\n----------------------------------------\n\nTITLE: Legacy Tuple Show Implementation in TypeScript\nDESCRIPTION: Deprecated implementation for creating Show instances for tuples.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Show.ts.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const getTupleShow: <T extends readonly Show<any>[]>(\n  ...shows: T\n) => Show<{ [K in keyof T]: T[K] extends Show<infer A> ? A : never }>\n```\n\n----------------------------------------\n\nTITLE: Implementing Pipeable Filter Operator in TypeScript\nDESCRIPTION: Implements a pipeable version of filter that works with both predicates and refinements.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/pipeable.ts.md#2025-04-23_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare function filter<F extends URIS4>(\n  F: Filterable4<F>\n): {\n  <A, B extends A>(refinement: Refinement<A, B>): <S, R, E>(fa: Kind4<F, S, R, E, A>) => Kind4<F, S, R, E, B>\n  <A>(predicate: Predicate<A>): <S, R, E>(fa: Kind4<F, S, R, E, A>) => Kind4<F, S, R, E, A>\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Deprecated ApplicativeComposition21 Interface\nDESCRIPTION: A deprecated interface representing composition of an applicative functor with two type parameters and another with one type parameter.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Applicative.ts.md#2025-04-23_snippet_11\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport interface ApplicativeComposition21<F extends URIS2, G extends URIS> extends FunctorComposition21<F, G> {\n  readonly of: <E, A>(a: A) => Kind2<F, E, Kind<G, A>>\n  readonly ap: <E, A, B>(\n    fgab: Kind2<F, E, Kind<G, (a: A) => B>>,\n    fga: Kind2<F, E, Kind<G, A>>\n  ) => Kind2<F, E, Kind<G, B>>\n}\n```\n\n----------------------------------------\n\nTITLE: URI Type Alias for Ord in TypeScript\nDESCRIPTION: Type alias for the URI of Ord, used for higher-kinded types pattern in TypeScript.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Ord.ts.md#2025-04-23_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nexport type URI = typeof URI\n```\n\n----------------------------------------\n\nTITLE: Implementing FlattenW Operation in TypeScript\nDESCRIPTION: Less strict version of flatten that merges environment and error types. Takes a nested ReaderEither and flattens it into a single ReaderEither.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReaderEither.ts.md#2025-04-23_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const flattenW: <R1, R2, E1, E2, A>(\n  mma: ReaderEither<R1, E1, ReaderEither<R2, E2, A>>\n) => ReaderEither<R1 & R2, E1 | E2, A>\n```\n\n----------------------------------------\n\nTITLE: Deprecated Filter Function for ReadonlyNonEmptyArray in TypeScript\nDESCRIPTION: Deprecated function that filters elements of a ReadonlyNonEmptyArray based on a predicate. Use 'filter' from ReadonlyArray instead.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReadonlyNonEmptyArray.ts.md#2025-04-23_snippet_74\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare function filter<A, B extends A>(\n  refinement: Refinement<A, B>\n): (as: ReadonlyNonEmptyArray<A>) => Option<ReadonlyNonEmptyArray<B>>\nexport declare function filter<A>(\n  predicate: Predicate<A>\n): <B extends A>(bs: ReadonlyNonEmptyArray<B>) => Option<ReadonlyNonEmptyArray<B>>\nexport declare function filter<A>(\n  predicate: Predicate<A>\n): (as: ReadonlyNonEmptyArray<A>) => Option<ReadonlyNonEmptyArray<A>>\n```\n\n----------------------------------------\n\nTITLE: Defining DistributiveLattice Interface in TypeScript\nDESCRIPTION: Defines the DistributiveLattice interface which extends the Lattice interface. This represents a distributive lattice in algebraic structures.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/DistributiveLattice.ts.md#2025-04-23_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport interface DistributiveLattice<A> extends Lattice<A> {}\n```\n\n----------------------------------------\n\nTITLE: Deprecated String Ordinal Implementation in TypeScript\nDESCRIPTION: Deprecated ordinal implementation for string values. Users should use the Ord implementation from string.ts instead.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Ord.ts.md#2025-04-23_snippet_30\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const ordString: Ord<string>\n```\n\n----------------------------------------\n\nTITLE: Configuring Jekyll Frontmatter for fp-ts Guides\nDESCRIPTION: YAML frontmatter configuration that sets up the navigation structure for the fp-ts documentation guides section. Configures the URL permalink, navigation order, child page relationships, and table of contents display.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/guides/index.md#2025-04-23_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\n---\ntitle: Guides\npermalink: /guides/\nnav_order: 5\nhas_children: true\nhas_toc: true\n---\n```\n\n----------------------------------------\n\nTITLE: Defining Extend1 Interface for Unary Type Constructors\nDESCRIPTION: Defines the Extend1 interface for unary type constructors that extends Functor1 and provides the extend method with appropriate type parameters.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Extend.ts.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface Extend1<W extends URIS> extends Functor1<W> {\n  readonly extend: <A, B>(wa: Kind<W, A>, f: (wa: Kind<W, A>) => B) => Kind<W, B>\n}\n```\n\n----------------------------------------\n\nTITLE: Contravariant2 Interface with Two Type Parameters\nDESCRIPTION: Defines a Contravariant interface for type constructors with two type parameters, using Kind2 for type-safe operations.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Contravariant.ts.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface Contravariant2<F extends URIS2> {\n  readonly URI: F\n  readonly contramap: <E, A, B>(fa: Kind2<F, E, A>, f: (b: B) => A) => Kind2<F, E, B>\n}\n```\n\n----------------------------------------\n\nTITLE: Deprecated getFunctionBooleanAlgebra Function in TypeScript\nDESCRIPTION: A deprecated function that creates a BooleanAlgebra for function types. Users should use getBooleanAlgebra from function.ts instead.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/BooleanAlgebra.ts.md#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const getFunctionBooleanAlgebra: <B>(\n  B: BooleanAlgebra<B>\n) => <A = never>() => BooleanAlgebra<(a: A) => B>\n```\n\n----------------------------------------\n\nTITLE: Implementing FromThese3 Interface in TypeScript\nDESCRIPTION: Defines the FromThese3 interface for type constructors with three type parameters. It includes a URI and a fromThese method to convert These values to the target type.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/FromThese.ts.md#2025-04-23_snippet_3\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport interface FromThese3<F extends URIS3> {\n  readonly URI: F\n  readonly fromThese: <E, A, R>(fa: These<E, A>) => Kind3<F, R, E, A>\n}\n```\n\n----------------------------------------\n\nTITLE: Deprecated semigroupOrdering Instance\nDESCRIPTION: Deprecated Semigroup instance for Ordering, replaced by Semigroup.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Ordering.ts.md#2025-04-23_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const semigroupOrdering: S.Semigroup<Ordering>\n```\n\n----------------------------------------\n\nTITLE: Using Max Semigroup with Numbers in TypeScript\nDESCRIPTION: Demonstrates the usage of the max Semigroup with numbers.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Semigroup.ts.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as N from 'fp-ts/number'\nimport * as S from 'fp-ts/Semigroup'\n\nconst S1 = S.max(N.Ord)\n\nassert.deepStrictEqual(S1.concat(1, 2), 2)\n```\n\n----------------------------------------\n\nTITLE: Tuple Function Implementation\nDESCRIPTION: Function for creating tuples from a variable number of arguments.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/function.ts.md#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare function tuple<T extends ReadonlyArray<any>>(...t: T): T\n```\n\n----------------------------------------\n\nTITLE: Implementing fromTaskEitherK for TaskEither Lifting\nDESCRIPTION: Transforms a function returning a TaskEither into a function returning a ReaderTaskEither, lifting asynchronous computations with error handling to include reader context.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReaderTaskEither.ts.md#2025-04-23_snippet_70\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const fromTaskEitherK: <E, A extends readonly unknown[], B>(\n  f: (...a: A) => TE.TaskEither<E, B>\n) => <R = unknown>(...a: A) => ReaderTaskEither<R, E, B>\n```\n\n----------------------------------------\n\nTITLE: Defining fromOptionK Function in TypeScript\nDESCRIPTION: Defines a function that lifts an Option-returning function into a These-returning function. It takes an error generator and returns a function that converts Option<B> to These<E, B>.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/These.ts.md#2025-04-23_snippet_5\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare const fromOptionK: <E>(\n  onNone: LazyArg<E>\n) => <A extends readonly unknown[], B>(f: (...a: A) => Option<B>) => (...a: A) => These<E, B>\n```\n\n----------------------------------------\n\nTITLE: Deprecated evalState function in StateReaderTaskEither (TypeScript)\nDESCRIPTION: A deprecated function that evaluates a StateReaderTaskEither computation with an initial state and returns only the result. Users should use the evaluate function instead.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/StateReaderTaskEither.ts.md#2025-04-23_snippet_75\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const evalState: <S, R, E, A>(\n  ma: StateReaderTaskEither<S, R, E, A>,\n  s: S\n) => RTE.ReaderTaskEither<R, E, A>\n```\n\n----------------------------------------\n\nTITLE: Deprecated getSemigroup function for ReaderTaskEither in TypeScript\nDESCRIPTION: A deprecated function for getting a Semigroup for ReaderTaskEither. Users are advised to use getApplySemigroup from Apply instead.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReaderTaskEither.ts.md#2025-04-23_snippet_123\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const getSemigroup: <R, E, A>(S: Semigroup<A>) => Semigroup<ReaderTaskEither<R, E, A>>\n```\n\n----------------------------------------\n\nTITLE: Implementing Alt2 Interface for Binary Type Constructors\nDESCRIPTION: Type-specific Alt interface for types with kind * -> * -> *. Extends Functor2 and includes an alt operation working with Kind2<F, E, A> types.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Alt.ts.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface Alt2<F extends URIS2> extends Functor2<F> {\n  readonly alt: <E, A>(fa: Kind2<F, E, A>, that: LazyArg<Kind2<F, E, A>>) => Kind2<F, E, A>\n}\n```\n\n----------------------------------------\n\nTITLE: Deprecated readerTaskEitherSeq instance for ReaderTaskEither in TypeScript\nDESCRIPTION: A deprecated instance combining multiple typeclasses for ReaderTaskEither. Users are advised to use smaller, specific instances instead.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReaderTaskEither.ts.md#2025-04-23_snippet_124\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const readerTaskEitherSeq: Monad3<'ReaderTaskEither'> &\n  Bifunctor3<'ReaderTaskEither'> &\n  Alt3<'ReaderTaskEither'> &\n  MonadTask3<'ReaderTaskEither'> &\n  MonadThrow3<'ReaderTaskEither'>\n```\n\n----------------------------------------\n\nTITLE: Defining ValidationM1 Interface in TypeScript\nDESCRIPTION: Defines a deprecated interface ValidationM1 that extends ApplicativeComposition12C with additional chain and alt methods for ValidationT1.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ValidationT.ts.md#2025-04-23_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport interface ValidationM1<M extends URIS, E> extends ApplicativeComposition12C<M, E.URI, E> {\n  readonly chain: <A, B>(ma: ValidationT1<M, E, A>, f: (a: A) => ValidationT1<M, E, B>) => ValidationT1<M, E, B>\n\n  readonly alt: <A>(fa: ValidationT1<M, E, A>, that: LazyArg<ValidationT1<M, E, A>>) => ValidationT1<M, E, A>\n}\n```\n\n----------------------------------------\n\nTITLE: Deprecated getApplySemigroup Function Definition\nDESCRIPTION: Deprecated function signature for getApplySemigroup, replaced by getApplySemigroup from Apply module.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Option.ts.md#2025-04-23_snippet_16\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const getApplySemigroup: <A>(S: Semigroup<A>) => Semigroup<Option<A>>\n```\n\n----------------------------------------\n\nTITLE: Deprecated getLastMonoid Function with Example\nDESCRIPTION: Deprecated monoid implementation returning right-most non-None value, with usage example.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Option.ts.md#2025-04-23_snippet_18\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const getLastMonoid: <A = never>() => Monoid<Option<A>>\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport { getLastMonoid, some, none } from 'fp-ts/Option'\n\nconst M = getLastMonoid<number>()\nassert.deepStrictEqual(M.concat(none, none), none)\nassert.deepStrictEqual(M.concat(some(1), none), some(1))\nassert.deepStrictEqual(M.concat(none, some(2)), some(2))\nassert.deepStrictEqual(M.concat(some(1), some(2)), some(2))\n```\n\n----------------------------------------\n\nTITLE: Implementing Pipeable Reduce Function in TypeScript\nDESCRIPTION: Defines a pipeable reduce function for various arities of the Foldable type class. It allows folding a structure into a single value.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/pipeable.ts.md#2025-04-23_snippet_21\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare function reduce<F extends URIS4>(\n  F: Foldable4<F>\n): <A, B>(b: B, f: (b: B, a: A) => B) => <S, R, E>(fa: Kind4<F, S, R, E, A>) => B\nexport declare function reduce<F extends URIS3>(\n  F: Foldable3<F>\n): <A, B>(b: B, f: (b: B, a: A) => B) => <R, E>(fa: Kind3<F, R, E, A>) => B\nexport declare function reduce<F extends URIS3, E>(\n  F: Foldable3C<F, E>\n): <A, B>(b: B, f: (b: B, a: A) => B) => <R>(fa: Kind3<F, R, E, A>) => B\nexport declare function reduce<F extends URIS2>(\n  F: Foldable2<F>\n): <A, B>(b: B, f: (b: B, a: A) => B) => <E>(fa: Kind2<F, E, A>) => B\nexport declare function reduce<F extends URIS2, E>(\n  F: Foldable2C<F, E>\n): <A, B>(b: B, f: (b: B, a: A) => B) => (fa: Kind2<F, E, A>) => B\nexport declare function reduce<F extends URIS>(\n  F: Foldable1<F>\n): <A, B>(b: B, f: (b: B, a: A) => B) => (fa: Kind<F, A>) => B\nexport declare function reduce<F>(F: Foldable<F>): <A, B>(b: B, f: (b: B, a: A) => B) => (fa: HKT<F, A>) => B\n```\n\n----------------------------------------\n\nTITLE: Deprecated getRefinement Function Definition\nDESCRIPTION: Deprecated function signature for getRefinement, replaced by Refinement module.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Option.ts.md#2025-04-23_snippet_19\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare function getRefinement<A, B extends A>(getOption: (a: A) => Option<B>): Refinement<A, B>\n```\n\n----------------------------------------\n\nTITLE: Deprecated getDualBooleanAlgebra Function in TypeScript\nDESCRIPTION: A deprecated function to create a dual Boolean algebra. Users should use the reverse function instead.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/BooleanAlgebra.ts.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const getDualBooleanAlgebra: <A>(B: BooleanAlgebra<A>) => BooleanAlgebra<A>\n```\n\n----------------------------------------\n\nTITLE: Deprecated Foldable interface for Records in TypeScript\nDESCRIPTION: A deprecated implementation of the Foldable typeclass for Records. Users should now use getFoldable instead.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Record.ts.md#2025-04-23_snippet_57\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const Foldable: Foldable1<'Record'>\n```\n\n----------------------------------------\n\nTITLE: Using Array Difference in TypeScript\nDESCRIPTION: Demonstrates how to use the difference function to compute the difference between two ReadonlyArrays of numbers.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReadonlyArray.ts.md#2025-04-23_snippet_17\n\nLANGUAGE: typescript\nCODE:\n```\nimport { difference } from 'fp-ts/ReadonlyArray'\nimport * as N from 'fp-ts/number'\nimport { pipe } from 'fp-ts/function'\n\nassert.deepStrictEqual(pipe([1, 2], difference(N.Eq)([2, 3])), [1])\n```\n\n----------------------------------------\n\nTITLE: Defining Deprecated ApplicativeComposition22C Interface\nDESCRIPTION: A deprecated interface representing composition of two applicative functors with two type parameters, where the second has a fixed first type parameter.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Applicative.ts.md#2025-04-23_snippet_12\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport interface ApplicativeComposition22C<F extends URIS2, G extends URIS2, E> extends FunctorComposition22C<F, G, E> {\n  readonly of: <FE, A>(a: A) => Kind2<F, FE, Kind2<G, E, A>>\n  readonly ap: <FE, A, B>(\n    fgab: Kind2<F, FE, Kind2<G, E, (a: A) => B>>,\n    fga: Kind2<F, FE, Kind2<G, E, A>>\n  ) => Kind2<F, FE, Kind2<G, E, B>>\n}\n```\n\n----------------------------------------\n\nTITLE: Deprecated Witherable interface for Records in TypeScript\nDESCRIPTION: A deprecated implementation of the Witherable typeclass for Records. Users should now use getWitherable instead.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Record.ts.md#2025-04-23_snippet_60\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const Witherable: Witherable1<'Record'>\n```\n\n----------------------------------------\n\nTITLE: Defining ValidationT1 Type Alias in TypeScript\nDESCRIPTION: Defines a deprecated type alias ValidationT1 representing a Kind with Either type.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ValidationT.ts.md#2025-04-23_snippet_3\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport type ValidationT1<M extends URIS, E, A> = Kind<M, Either<E, A>>\n```\n\n----------------------------------------\n\nTITLE: Defining PipeableSemigroupoid4 Interface in TypeScript\nDESCRIPTION: Defines a deprecated PipeableSemigroupoid4 interface with the compose method for higher-kinded types of arity 4. This interface enables composition of morphisms in category-like structures with four type parameters.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/pipeable.ts.md#2025-04-23_snippet_90\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface PipeableSemigroupoid4<F extends URIS4> {\n  readonly compose: <S, R, E, A>(la: Kind4<F, S, R, E, A>) => <B>(ab: Kind4<F, S, R, A, B>) => Kind4<F, S, R, E, B>\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing extend for ReadonlyNonEmptyArray in TypeScript\nDESCRIPTION: Applies a function to the whole ReadonlyNonEmptyArray, then to all but the first element, then to all but the first two elements, and so on.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReadonlyNonEmptyArray.ts.md#2025-04-23_snippet_41\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const extend: <A, B>(\n  f: (as: ReadonlyNonEmptyArray<A>) => B\n) => (as: ReadonlyNonEmptyArray<A>) => ReadonlyNonEmptyArray<B>\n```\n\n----------------------------------------\n\nTITLE: Defining apW function for ReaderIO in TypeScript\nDESCRIPTION: A less strict version of ap that merges environment types. It applies a ReaderIO of functions to a ReaderIO of values with potentially different environment types.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReaderIO.ts.md#2025-04-23_snippet_26\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const apW: <R2, A>(\n  fa: ReaderIO<R2, A>\n) => <R1, B>(fab: ReaderIO<R1, (a: A) => B>) => ReaderIO<R1 & R2, B>\n```\n\n----------------------------------------\n\nTITLE: Defining FromIO2C Interface in TypeScript\nDESCRIPTION: Interface for lifting computations from the IO monad to a higher-kinded type F with fixed error type E. Used when the error type is constant across operations.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/FromIO.ts.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface FromIO2C<F extends URIS2, E> {\n  readonly URI: F\n  readonly _E: E\n  readonly fromIO: <A>(fa: IO<A>) => Kind2<F, E, A>\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing FromOptionK Function for IOOption in TypeScript\nDESCRIPTION: Defines the fromOptionK function for IOOption. It lifts a function returning Option to a function returning IOOption.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/IOOption.ts.md#2025-04-23_snippet_27\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const fromOptionK: <A extends readonly unknown[], B>(\n  f: (...a: A) => O.Option<B>\n) => (...a: A) => IOOption<B>\n```\n\n----------------------------------------\n\nTITLE: Defining MeetSemilattice Interface in TypeScript\nDESCRIPTION: Defines a TypeScript interface for a meet-semilattice algebraic structure. The interface contains a 'meet' operation that takes two values of type A and returns another value of type A, representing the greatest lower bound of the inputs.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/MeetSemilattice.ts.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface MeetSemilattice<A> {\n  readonly meet: (x: A, y: A) => A\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing as Function for Constant Mapping in TypeScript\nDESCRIPTION: Maps the Right value of a TaskEither to a specified constant value, preserving the error type if present.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/TaskEither.ts.md#2025-04-23_snippet_56\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const as: {\n  <A>(a: A): <E, _>(self: TaskEither<E, _>) => TaskEither<E, A>\n  <E, _, A>(self: TaskEither<E, _>, a: A): TaskEither<E, A>\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Chain Operation for ReaderT\nDESCRIPTION: Function implementing the chain/bind operation for the Reader transformer, enabling sequential composition of Reader computations. Supports multiple URI configurations.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReaderT.ts.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare function chain<M extends URIS4>(\n  M: Chain4<M>\n): <A, R, S, FR, FE, B>(\n  f: (a: A) => Reader<R, Kind4<M, S, FR, FE, B>>\n) => (ma: Reader<R, Kind4<M, S, FR, FE, A>>) => Reader<R, Kind4<M, S, FR, FE, B>>\n```\n\n----------------------------------------\n\nTITLE: FoldableWithIndex3C Interface with Fixed Error Type\nDESCRIPTION: Interface for FoldableWithIndex specialized for Kind3<F, R, E, A> types with a fixed error type E, extending Foldable3C.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/FoldableWithIndex.ts.md#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface FoldableWithIndex3C<F extends URIS3, I, E> extends Foldable3C<F, E> {\n  readonly reduceWithIndex: <R, A, B>(fa: Kind3<F, R, E, A>, b: B, f: (i: I, b: B, a: A) => B) => B\n  readonly foldMapWithIndex: <M>(M: Monoid<M>) => <R, A>(fa: Kind3<F, R, E, A>, f: (i: I, a: A) => M) => M\n  readonly reduceRightWithIndex: <R, A, B>(fa: Kind3<F, R, E, A>, b: B, f: (i: I, a: A, b: B) => B) => B\n}\n```\n\n----------------------------------------\n\nTITLE: Defining apSecond function for ReaderIO in TypeScript\nDESCRIPTION: Combines two ReaderIO actions, keeping only the result of the second.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReaderIO.ts.md#2025-04-23_snippet_25\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const apSecond: <E, B>(second: ReaderIO<E, B>) => <A>(first: ReaderIO<E, A>) => ReaderIO<E, B>\n```\n\n----------------------------------------\n\nTITLE: Defining FromEither Instance for IOOption in TypeScript\nDESCRIPTION: Declares the FromEither instance for the IOOption monad. This provides implementations for converting from Either to IOOption.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/IOOption.ts.md#2025-04-23_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const FromEither: FromEither1<'IOOption'>\n```\n\n----------------------------------------\n\nTITLE: Defining FromEither Interface Hierarchy in TypeScript\nDESCRIPTION: Defines a series of interfaces for the FromEither type class, supporting different higher-kinded type patterns (URIS) for various container types. These interfaces specify how to convert an Either into the target type.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/FromEither.ts.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface FromEither<F> {\n  readonly URI: F\n  readonly fromEither: <E, A>(e: Either<E, A>) => HKT2<F, E, A>\n}\n\nexport interface FromEither1<F extends URIS> {\n  readonly URI: F\n  readonly fromEither: <A>(fa: Either<unknown, A>) => Kind<F, A>\n}\n\nexport interface FromEither2<F extends URIS2> {\n  readonly URI: F\n  readonly fromEither: <E, A>(fa: Either<E, A>) => Kind2<F, E, A>\n}\n\nexport interface FromEither2C<F extends URIS2, E> {\n  readonly URI: F\n  readonly _E: E\n  readonly fromEither: <A>(fa: Either<E, A>) => Kind2<F, E, A>\n}\n\nexport interface FromEither3<F extends URIS3> {\n  readonly URI: F\n  readonly fromEither: <E, A, R>(fa: Either<E, A>) => Kind3<F, R, E, A>\n}\n\nexport interface FromEither3C<F extends URIS3, E> {\n  readonly URI: F\n  readonly _E: E\n  readonly fromEither: <A, R>(fa: Either<E, A>) => Kind3<F, R, E, A>\n}\n\nexport interface FromEither4<F extends URIS4> {\n  readonly URI: F\n  readonly fromEither: <E, A, S, R>(fa: Either<E, A>) => Kind4<F, S, R, E, A>\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing flatMapState for StateReaderTaskEither in TypeScript\nDESCRIPTION: Provides flatMapState function that allows mapping from a StateReaderTaskEither to a State monad and flattening the result, with both pipeable and non-pipeable overloads.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/StateReaderTaskEither.ts.md#2025-04-23_snippet_49\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare const flatMapState: {\n  <S, A, B>(f: (a: A) => State<S, B>): <R, E>(\n    self: StateReaderTaskEither<S, R, E, A>\n  ) => StateReaderTaskEither<S, R, E, B>\n  <S, R, E, A, B>(self: StateReaderTaskEither<S, R, E, A>, f: (a: A) => State<S, B>): StateReaderTaskEither<S, R, E, B>\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Bifunctor3 Interface in TypeScript\nDESCRIPTION: Defines the Bifunctor3 interface for handling three-parameter type constructors. It includes methods for bimap and mapLeft operations using Kind3.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Bifunctor.ts.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface Bifunctor3<F extends URIS3> {\n  readonly URI: F\n  readonly bimap: <R, E, A, G, B>(fea: Kind3<F, R, E, A>, f: (e: E) => G, g: (a: A) => B) => Kind3<F, R, G, B>\n  readonly mapLeft: <R, E, A, G>(fea: Kind3<F, R, E, A>, f: (e: E) => G) => Kind3<F, R, G, A>\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing fromPredicate Function in TypeScript\nDESCRIPTION: Defines a function that creates a These from a predicate. It has multiple overloads to handle different input types and refinements.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/These.ts.md#2025-04-23_snippet_6\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare const fromPredicate: {\n  <A, B extends A, E>(refinement: Refinement<A, B>, onFalse: (a: A) => E): (a: A) => These<E, B>\n  <A, E>(predicate: Predicate<A>, onFalse: (a: A) => E): <B extends A>(b: B) => These<E, B>\n  <A, E>(predicate: Predicate<A>, onFalse: (a: A) => E): (a: A) => These<E, A>\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing chainTaskEitherKW for StateReaderTaskEither in TypeScript\nDESCRIPTION: Defines chainTaskEitherKW as a less strict version of chainTaskEitherK. It merges error types when chaining a TaskEither operation.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/StateReaderTaskEither.ts.md#2025-04-23_snippet_23\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport declare const chainTaskEitherKW: <E2, A, B>(\n  f: (a: A) => TaskEither<E2, B>\n) => <S, R, E1>(ma: StateReaderTaskEither<S, R, E1, A>) => StateReaderTaskEither<S, R, E2 | E1, B>\n```\n\n----------------------------------------\n\nTITLE: Implementing chainTaskEitherKW with Type Widening\nDESCRIPTION: Widened version of chainTaskEitherK that merges environment and error types, allowing for more flexible type composition.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReaderTaskEither.ts.md#2025-04-23_snippet_54\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const chainTaskEitherKW: <E2, A, B>(\n  f: (a: A) => TE.TaskEither<E2, B>\n) => <R, E1>(ma: ReaderTaskEither<R, E1, A>) => ReaderTaskEither<R, E2 | E1, B>\n```\n\n----------------------------------------\n\nTITLE: Writer URI Definitions\nDESCRIPTION: Defines the unique identifier for the Writer type constructor.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Writer.ts.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const URI: 'Writer'\nexport type URI = typeof URI\n```\n\n----------------------------------------\n\nTITLE: rightF Function Declaration in TypeScript\nDESCRIPTION: Function to lift a functor value into a Right instance within a monad transformer context.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/EitherT.ts.md#2025-04-23_snippet_15\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare function rightF<F extends URIS3>(\n  F: Functor3<F>\n): <R, FE, A, E = never>(fa: Kind3<F, R, FE, A>) => Kind3<F, R, FE, Either<E, A>>\n```\n\n----------------------------------------\n\nTITLE: Implementing flap for ReadonlyNonEmptyArray in TypeScript\nDESCRIPTION: Applies a ReadonlyNonEmptyArray of functions to a single value.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReadonlyNonEmptyArray.ts.md#2025-04-23_snippet_18\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const flap: <A>(a: A) => <B>(fab: ReadonlyNonEmptyArray<(a: A) => B>) => ReadonlyNonEmptyArray<B>\n```\n\n----------------------------------------\n\nTITLE: Sequencing Operations\nDESCRIPTION: Functions for composing and chaining ReaderEither operations, including flatMap and its variants.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReaderEither.ts.md#2025-04-23_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const flatMap: { <A, R2, E2, B>(f: (a: A) => ReaderEither<R2, E2, B>): <R1, E1>(ma: ReaderEither<R1, E1, A>) => ReaderEither<R1 & R2, E2 | E1, B> }\n```\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const flatten: <R, E, A>(mma: ReaderEither<R, E, ReaderEither<R, E, A>>) => ReaderEither<R, E, A>\n```\n\n----------------------------------------\n\nTITLE: Less Than Function for Ord in TypeScript\nDESCRIPTION: Creates a function to test whether one value is strictly less than another using an Ord instance.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Ord.ts.md#2025-04-23_snippet_18\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const lt: <A>(O: Ord<A>) => (first: A, second: A) => boolean\n```\n\n----------------------------------------\n\nTITLE: Defining ApT constant for ReaderIO in TypeScript\nDESCRIPTION: Defines a constant ReaderIO that always returns an empty readonly array.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReaderIO.ts.md#2025-04-23_snippet_22\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const ApT: ReaderIO<unknown, readonly []>\n```\n\n----------------------------------------\n\nTITLE: Defining PipeableFunctorWithIndex1 Interface in TypeScript\nDESCRIPTION: Extends PipeableFunctor1 to provide indexed mapping operations for arity 1 higher-kinded types. Adds the mapWithIndex method that receives both the index and value during mapping.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/pipeable.ts.md#2025-04-23_snippet_69\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface PipeableFunctorWithIndex1<F extends URIS, I> extends PipeableFunctor1<F> {\n  readonly mapWithIndex: <A, B>(f: (i: I, a: A) => B) => (fa: Kind<F, A>) => Kind<F, B>\n}\n```\n\n----------------------------------------\n\nTITLE: Deprecated hasOwnProperty function for Records in TypeScript\nDESCRIPTION: A deprecated function for checking if a Record has a specific property. Users should use the has function instead.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Record.ts.md#2025-04-23_snippet_62\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const hasOwnProperty: <K extends string>(k: string, r: Record<K, unknown>) => k is K\n```\n\n----------------------------------------\n\nTITLE: Deprecated Date equality in TypeScript\nDESCRIPTION: Deprecated Eq instance for Date objects. Users should use the Eq from the Date module instead.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Eq.ts.md#2025-04-23_snippet_14\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const eqDate: Eq<Date>\n```\n\n----------------------------------------\n\nTITLE: Deprecated InsertAt Function for ReadonlyNonEmptyArray in TypeScript\nDESCRIPTION: Deprecated function that inserts an element at a specific index in an array, potentially creating a ReadonlyNonEmptyArray. Use 'insertAt' from ReadonlyArray instead.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/ReadonlyNonEmptyArray.ts.md#2025-04-23_snippet_77\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const insertAt: <A>(i: number, a: A) => (as: readonly A[]) => Option<ReadonlyNonEmptyArray<A>>\n```\n\n----------------------------------------\n\nTITLE: Deprecated Function Ring Generator\nDESCRIPTION: Deprecated function signature for creating a Ring instance for functions. Users should use getRing from function.ts instead.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Ring.ts.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const getFunctionRing: <A, B>(R: Ring<B>) => Ring<(a: A) => B>\n```\n\n----------------------------------------\n\nTITLE: Deprecated monoidOrdering Instance\nDESCRIPTION: Deprecated Monoid instance for Ordering, replaced by Monoid.\nSOURCE: https://github.com/gcanti/fp-ts/blob/master/docs/modules/Ordering.ts.md#2025-04-23_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const monoidOrdering: M.Monoid<Ordering>\n```"
  }
]