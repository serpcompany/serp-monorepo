[
  {
    "owner": "geofmureithi",
    "repo": "apalis",
    "content": "TITLE: Basic Apalis Usage with Redis\nDESCRIPTION: This snippet shows a basic example of using Apalis with Redis to process email sending jobs. It defines an `Email` struct representing the job data, a `send_email` function to handle the job, and a `main` function that sets up the Redis storage, defines a worker, and runs it. It also requires the `serde` crate for serialization and deserialization of the job data.\nSOURCE: https://github.com/geofmureithi/apalis/blob/main/README.md#_snippet_1\n\nLANGUAGE: Rust\nCODE:\n```\nuse apalis::prelude::*;\nuse apalis_redis::RedisStorage;\nuse serde::{Deserialize, Serialize};\n\n#[derive(Debug, Deserialize, Serialize)]\nstruct Email {\n    to: String,\n}\n\n/// A function called for every job\nasync fn send_email(job: Email, data: Data<usize>) -> Result<(), Error> {\n  /// execute job\n  Ok(())\n}\n\n#[tokio::main]\nasync fn main() -> {\n    std::env::set_var(\"RUST_LOG\", \"debug\");\n    env_logger::init();\n    let redis_url = std::env::var(\"REDIS_URL\").expect(\"Missing env variable REDIS_URL\");\n    let conn = apalis_redis::connect(redis_url).await.expect(\"Could not connect\");\n    let storage = RedisStorage::new(conn);\n    WorkerBuilder::new(\"email-worker\")\n      .concurrency(2)\n      .data(0usize)\n      .backend(storage)\n      .build_fn(send_email)\n      .run()\n      .await;\n}\n```\n\n----------------------------------------\n\nTITLE: Add Apalis Dependencies to Cargo.toml\nDESCRIPTION: This snippet demonstrates how to add the necessary Apalis dependencies to your `Cargo.toml` file. It includes `apalis` with the `limit` feature enabled for concurrency, and `apalis-redis` for Redis persistence. These dependencies are essential for using Apalis with Redis as the backend.\nSOURCE: https://github.com/geofmureithi/apalis/blob/main/README.md#_snippet_0\n\nLANGUAGE: TOML\nCODE:\n```\n[dependencies]\napalis = { version = \"0.7\", features = \"limit\" } # Limit for concurrency\napalis-redis = { version = \"0.7\" } # Use redis for persistence\n```\n\n----------------------------------------\n\nTITLE: Cron Job Scheduling Example with apalis-cron in Rust\nDESCRIPTION: This code snippet demonstrates how to use `apalis-cron` to schedule a job that runs based on a cron schedule. It defines a simple `Reminder` struct, a handler function `handle_tick`, and sets up a worker that executes the handler function using a cron schedule specified by `@daily`.\nSOURCE: https://github.com/geofmureithi/apalis/blob/main/packages/apalis-cron/README.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse apalis::{prelude::*, layers::retry::RetryPolicy};\nuse std::str::FromStr;\nuse apalis_cron::{CronStream, Schedule};\nuse chrono::{DateTime, Utc};\n\n#[derive(Default, Debug, Clone)]\nstruct Reminder(DateTime<Utc>);\nimpl From<DateTime<Utc>> for Reminder {\n   fn from(t: DateTime<Utc>) -> Self {\n       Reminder(t)\n   }\n}\nasync fn handle_tick(job: Reminder, data: Data<usize>) {\n    // Do something with the current tick\n}\n\n#[tokio::main]\nasync fn main() {\n    let schedule = Schedule::from_str(\"@daily\").unwrap();\n\n    let worker = WorkerBuilder::new(\"morning-cereal\")\n        .retry(RetryPolicy::retries(5))\n        .data(42usize)\n        .backend(CronStream::new(schedule))\n        .build_fn(handle_tick);\n\n    worker.run().await;\n}\n```\n\n----------------------------------------\n\nTITLE: Produce Apalis Jobs\nDESCRIPTION: This snippet demonstrates how to produce jobs using the Redis storage backend. The `produce_route_jobs` function takes a mutable reference to a `RedisStorage` instance and pushes an `Email` job onto the queue. The email will then be processed by a worker.\nSOURCE: https://github.com/geofmureithi/apalis/blob/main/README.md#_snippet_2\n\nLANGUAGE: Rust\nCODE:\n```\n//This can be in another part of the program or another application eg a http server\nasync fn produce_route_jobs(storage: &mut RedisStorage<Email>) -> Result<()> {\n    storage\n        .push(Email {\n            to: \"test@example.com\".to_string(),\n        })\n        .await?;\n}\n```\n\n----------------------------------------\n\nTITLE: Persisting Cron Jobs with SqliteStorage in Rust\nDESCRIPTION: This example demonstrates how to persist cron jobs using `SqliteStorage`. It sets up a SQLite database, creates a cron stream, pipes the stream to the SQLite storage, and then sets up a worker that uses the persisted cron stream. This ensures that cron jobs are not skipped in case of restarts and can be distributed between multiple servers.\nSOURCE: https://github.com/geofmureithi/apalis/blob/main/packages/apalis-cron/README.md#_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n#[tokio::main]\nasync fn main() {\n    let schedule = Schedule::from_str(\"@daily\").unwrap();\n    let cron_stream = CronStream::new(schedule);\n\n    // Lets create a storage for our cron jobs\n    let pool = SqlitePool::connect(\"sqlite::memory:\").await.unwrap();\n    SqliteStorage::setup(&pool)\n        .await\n        .expect(\"unable to run migrations for sqlite\");\n    let sqlite = SqliteStorage::new(pool);\n\n    let backend = cron_stream.pipe_to_storage(sqlite);\n\n    let worker = WorkerBuilder::new(\"morning-cereal\")\n        .backend(backend)\n        .build_fn(handle_tick);\n\n    worker.run().await;\n}\n```\n\n----------------------------------------\n\nTITLE: Apalis Stepped Tasks Example\nDESCRIPTION: This snippet presents an example of using stepped tasks with Apalis and Redis. It configures a stepped email task, defining a series of steps (`welcome`, `campaign`, `complete_campaign`) to be executed sequentially. It initializes tracing, connects to Redis, sets up the storage, starts the stepped task, builds the steps using a `StepBuilder`, and defines the worker.\nSOURCE: https://github.com/geofmureithi/apalis/blob/main/README.md#_snippet_3\n\nLANGUAGE: Rust\nCODE:\n```\n#[tokio::main]\nasync fn main() -> Result<(), std::io::Error> {\n    std::env::set_var(\"RUST_LOG\", \"debug\");\n    tracing_subscriber::fmt::init();\n    let redis_url = std::env::var(\"REDIS_URL\").expect(\"Missing env variable REDIS_URL\");\n    let conn = apalis_redis::connect(redis_url).await.unwrap();\n    let config = apalis_redis::Config::default().set_namespace(\"stepped-email-task\");\n\n\n    let mut storage = RedisStorage::new_with_config(conn, config);\n    storage\n        .start_stepped(WelcomeEmail { user_id: 1 })\n        .await\n        .unwrap();\n\n    // Build steps\n    let steps = StepBuilder::new()\n        .step_fn(welcome) // Steps are tower services\n        .step_fn(campaign)\n        .step_fn(complete_campaign);\n\n    WorkerBuilder::new(\"tasty-banana\")\n        .data(())\n        .enable_tracing()\n        .concurrency(2)\n        .backend(storage)\n        .build_stepped(steps)\n        .on_event(|e| info!(\"{e}\"))\n        .run()\n        .await;\n    Ok(())\n}\n```\n\n----------------------------------------\n\nTITLE: Testing Email Push via curl\nDESCRIPTION: This curl command tests the email push functionality by sending a POST request to the /emails/push endpoint. It includes headers for cache control and content type, as well as a JSON payload with the recipient, subject, and email body.\nSOURCE: https://github.com/geofmureithi/apalis/blob/main/examples/actix-web/README.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ncurl -X POST \\\n  http://localhost:8000/emails/push \\\n  -H 'cache-control: no-cache' \\\n  -H 'content-type: application/json' \\\n  -d '{\n\t\"to\": \"test@gmail.com\",\n\t\"subject\": \"Message from Web\",\n\t\"text\": \"This is the text\"\n}'\n```\n\n----------------------------------------\n\nTITLE: Running MySQL with Docker for Apalis\nDESCRIPTION: This Docker command creates a MySQL container named 'apalis-mysql', sets environment variables for the database name, user, and root password. It also maps port 3306 and mounts volumes for configuration and data persistence. The command runs the MySQL container in detached mode.\nSOURCE: https://github.com/geofmureithi/apalis/blob/main/examples/mysql/README.md#_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\ndocker run \\\n   --name apalis-mysql \\\n   -e MYSQL_DATABASE=apalis-jobs \\\n   -e MYSQL_USER=apalis \\\n   -e MYSQL_ROOT_PASSWORD=strong_password \\\n   -p 3306:3306 \\\n   -v /etc/docker/apalis-mysql:/etc/mysql/conf.d \\\n   -v apalis-mysql-data:/var/lib/mysql \\\n   -d mysql\n```\n\n----------------------------------------\n\nTITLE: Running Apalis with Redis URL\nDESCRIPTION: This command executes the Apalis project using cargo run, setting the REDIS_URL environment variable to connect to a Redis instance running on localhost. The REDIS_URL environment variable specifies the connection string for the Redis server.\nSOURCE: https://github.com/geofmureithi/apalis/blob/main/examples/tracing/README.md#_snippet_0\n\nLANGUAGE: Shell\nCODE:\n```\nREDIS_URL=[redis://127.0.0.1/] cargo run\n```\n\n----------------------------------------\n\nTITLE: Running Apalis with Sentry DSN\nDESCRIPTION: This command runs the Apalis project using `cargo run` after setting the `SENTRY_DSN` environment variable. The `SENTRY_DSN` variable should be replaced with the actual Sentry Data Source Name. This allows the application to report errors to Sentry.\nSOURCE: https://github.com/geofmureithi/apalis/blob/main/examples/sentry/README.md#_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\nSENTRY_DSN=[your sentry dsn] cargo run\n```\n\n----------------------------------------\n\nTITLE: Running Apalis application\nDESCRIPTION: This command executes the Apalis application. It assumes that the project is already set up with the necessary dependencies and configurations.\nSOURCE: https://github.com/geofmureithi/apalis/blob/main/examples/actix-web/README.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ncargo run\n```"
  }
]