[
  {
    "owner": "remeda",
    "repo": "remeda",
    "content": "TITLE: Lazy Evaluation Example\nDESCRIPTION: Shows Remeda's automatic optimization of pipe operations through lazy evaluation of transformations.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/pages/index.mdx#2025-04-07_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\n// Get first 3 unique values\nconst DATA = [1, 2, 2, 3, 3, 4, 5, 6];\n\nconst result = R.pipe(\n  DATA,\n  R.map((x) => {\n    console.log(\"iterate\", x);\n    return x;\n  }),\n  R.unique(),\n  R.take(3),\n); // => [1, 2, 3]\n\n// Console output:\n// iterate 1\n// iterate 2\n// iterate 2\n// iterate 3\n```\n\n----------------------------------------\n\nTITLE: Sorting Users with Remeda\nDESCRIPTION: Demonstrates sorting an array of users by multiple criteria using Remeda's sortBy function with type-safe property access.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/pages/index.mdx#2025-04-07_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as R from \"remeda\";\n// Or import the function directly:\n// import { sortBy } from \"remeda\";\n\ntype User = {\n  firstName: string;\n  lastName: string;\n  lastLogin: number;\n};\n\ndeclare const USERS: User[];\n\nR.sortBy(\n  USERS,\n  [R.prop(\"lastLogin\"), \"desc\"],\n  R.prop(\"lastName\"),\n  R.prop(\"firstName\"),\n);\n```\n\n----------------------------------------\n\nTITLE: Using isPlainObject to Check for Plain JavaScript Objects\nDESCRIPTION: This example demonstrates how the `isPlainObject` function is used to determine if various values are plain JavaScript objects. The function returns true for objects created with object literals or Object constructor, and false for other types.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/mapping/lodash/isPlainObject.md#2025-04-07_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nisPlainObject({}); // => true\nisPlainObject(Object.create({})); // => true\nisPlainObject([]); // => false\nisPlainObject(null); // => false\n```\n\n----------------------------------------\n\nTITLE: Installing Remeda Package\nDESCRIPTION: Various package manager commands to install the Remeda library in a project.\nSOURCE: https://github.com/remeda/remeda/blob/main/README.md#2025-04-07_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm install remeda\npnpm add remeda\nyarn add remeda\nbun install remeda\n```\n\n----------------------------------------\n\nTITLE: Data-First vs Data-Last Syntax\nDESCRIPTION: Demonstrates Remeda's support for both data-first and data-last syntax compared to Lodash and Ramda approaches.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/pages/index.mdx#2025-04-07_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\n// Lodash\n_.pick(obj, [\"firstName\", \"lastName\"]);\n\n// Ramda\nR.pick([\"firstName\", \"lastName\"], obj);\n\n// In Remeda you get both!\nR.pick(obj, [\"firstName\", \"lastName\"]); // data-first\nR.pipe(obj, R.pick([\"firstName\", \"lastName\"])); // data-last\n```\n\n----------------------------------------\n\nTITLE: Implementing allPass Function in TypeScript for Remeda\nDESCRIPTION: This code snippet defines the allPass function, which takes an array of predicates and returns a new function. The returned function checks if all predicates in the array return true for a given value. It uses Array.prototype.every() to iterate through the predicates.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/mapping/ramda/allPass.md#2025-04-07_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { Predicate } from \"../types/common\";\n\n/**\n * Takes a list of predicates and returns a new predicate that returns true for a given list of\n * arguments if every one of the provided predicates is satisfied by those arguments.\n *\n * @param predicates - an array of predicates to check\n * @returns function which accepts value and returns true if all predicates accepts that value\n * @signature\n *    R.allPass(predicates)(value)\n * @example\n *    const john = { age: 29, active: true };\n *    const jane = { age: 32, active: false };\n *    const isOlderThan18 = (x) => x.age > 18;\n *    const isActive = (x) => x.active === true;\n *    const checks = [isOlderThan18, isActive];\n *    R.allPass(checks)(john); // => true\n *    R.allPass(checks)(jane); // => false\n * @category Logic\n */\nexport function allPass<T>(\n  predicates: ReadonlyArray<Predicate<T>>\n): (val: T) => boolean {\n  return (val) => predicates.every((fn) => fn(val));\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing anyPass Function in TypeScript for Remeda Library\nDESCRIPTION: This snippet defines the anyPass function, which takes an array of predicates and returns a new function. The returned function checks if any of the input predicates return true for a given value. It uses type parameters to ensure type safety and compatibility with various predicate types.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/mapping/ramda/anyPass.md#2025-04-07_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { Pred, PredIndexed } from \"./common/types\";\n\n/**\n * Returns `true` if at least one of predicates returns `true` for the input,\n * `false` otherwise.\n *\n * @param predicates - An array of predicate functions to be checked.\n * @returns A function that takes a value and returns true if any predicate returns true for that value.\n * @signature\n *    R.anyPass(predicates)(value)\n * @example\n *    const isDivisibleBy3 = (n: number) => n % 3 === 0\n *    const isDivisibleBy4 = (n: number) => n % 4 === 0\n *    const f = R.anyPass([isDivisibleBy3, isDivisibleBy4])\n *    f(12) // => true\n *    f(5) // => false\n * @dataFirst\n * @indexed\n * @category Logic\n */\nexport function anyPass<T>(\n  predicates: ReadonlyArray<Pred<T> | PredIndexed<T>>\n): (value: T) => boolean;\n\nexport function anyPass<T>(\n  predicates: ReadonlyArray<Pred<T> | PredIndexed<T>>\n): (value: T, index: number, array: T[]) => boolean {\n  return (value, index, array) => {\n    for (let i = 0; i < predicates.length; i++) {\n      if (predicates[i](value, index, array)) {\n        return true;\n      }\n    }\n    return false;\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Comparing Ramda flatten with Remeda flat in TypeScript\nDESCRIPTION: This example demonstrates the difference between Ramda's flatten and Remeda's flat function. Unlike Ramda, Remeda requires a depth parameter, which should be a constant value rather than Infinity or Number.MAX_INTEGER for efficient typing.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/mapping/ramda/flatten.md#2025-04-07_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// Ramda\nflatten(DATA);\n\n// Remeda\nflat(DATA, 100); // ✅\nflat(DATA, Infinity); // ❌\n```\n\n----------------------------------------\n\nTITLE: Using Remeda Functions\nDESCRIPTION: Example demonstrating Remeda's pipe functionality with array operations including tap, unique, and take methods. Shows both full library and individual import approaches.\nSOURCE: https://github.com/remeda/remeda/blob/main/README.md#2025-04-07_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\n// Import everything:\nimport * as R from \"remeda\";\n\n// Or import methods individually:\n// import { pipe, tap, unique, take } from \"remeda\";\n\nR.pipe(\n  [1, 2, 2, 3, 3, 4, 5, 6],\n  R.tap((value) => console.log(`Got ${value}`)),\n  R.unique(),\n  R.take(3),\n); // => [1, 2, 3]\n\n// Console output:\n// Got 1\n// Got 2\n// Got 2\n// Got 3\n```\n\n----------------------------------------\n\nTITLE: Defining and Implementing meanBy Function in TypeScript for Remeda\nDESCRIPTION: This snippet defines the meanBy function, which calculates the mean of an array after applying a mapping function to each element. It handles empty arrays and uses reduce to compute the sum efficiently.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/mapping/lodash/meanBy.md#2025-04-07_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { Predicate, PredIndexed } from \"../types\";\nimport { purry } from \"../purry\";\n\n/**\n * Calculates the mean of the values in an array using a mapping function.\n *\n * @param data - The input array.\n * @param fn - The mapping function.\n * @returns The mean of the mapped values.\n * @example\n *    R.meanBy([1, 2, 3, 4], x => x) // => 2.5\n *    R.meanBy([{ a: 1 }, { a: 2 }, { a: 3 }, { a: 4 }], x => x.a) // => 2.5\n */\nexport function meanBy<T>(data: readonly T[], fn: Predicate<T, number>): number;\nexport function meanBy<T>(fn: Predicate<T, number>): (data: readonly T[]) => number;\nexport function meanBy(...args: any[]) {\n  return purry(_meanBy, args);\n}\n\nfunction _meanBy<T>(data: readonly T[], fn: PredIndexed<T, number>): number {\n  if (data.length === 0) {\n    return NaN;\n  }\n\n  const sum = data.reduce(\n    (acc, item, idx) => acc + fn(item, idx, data),\n    0,\n  );\n\n  return sum / data.length;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Intersection Function in TypeScript for Remeda\nDESCRIPTION: This code snippet defines the intersection function which takes two or more arrays as input and returns a new array containing elements that are present in all input arrays. It utilizes TypeScript's type system for type safety and flexibility.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/mapping/ramda/intersection.md#2025-04-07_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { _curry2 } from './_internal/_curry2';\nimport { _Set } from './_internal/_Set';\n\nexport function intersection<T>(\n\ta: ReadonlyArray<T>,\n\tb: ReadonlyArray<T>,\n): Array<T>;\n\nexport function intersection<T>(\n\ta: ReadonlyArray<T>,\n): (b: ReadonlyArray<T>) => Array<T>;\n\nexport function intersection() {\n\treturn _curry2((a: unknown[], b: unknown[]) => {\n\t\tconst set = new _Set(b);\n\t\treturn a.filter((x) => set.has(x));\n\t});\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Tap Function in TypeScript for Remeda Library\nDESCRIPTION: The 'tap' function is a utility that allows executing a side effect on a value while passing the original value through. It takes a value and a callback function, executes the callback with the value, and then returns the original value.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/mapping/ramda/tap.md#2025-04-07_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nfunction tap<T>(value: T, fn: (value: T) => void): T {\n  fn(value);\n  return value;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining and Using the 'find' Function in Remeda (TypeScript)\nDESCRIPTION: This snippet defines the 'find' function in Remeda, which searches for the first element in an array that satisfies a given predicate. It includes type definitions and curried function signatures for flexibility in usage.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/mapping/ramda/find.md#2025-04-07_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nfunction find<T>(predicate: (item: T) => boolean): (items: readonly T[]) => T | undefined\nfunction find<T>(predicate: (item: T) => boolean, items: readonly T[]): T | undefined\nfunction find<T>(predicate: (item: T) => boolean, items?: readonly T[]): unknown {\n  if (arguments.length === 1) {\n    return (_items: readonly T[]) => find(predicate, _items)\n  }\n  return items!.find(predicate)\n}\n```\n\n----------------------------------------\n\nTITLE: Defining and Using the 'sort' Function in Remeda\nDESCRIPTION: This snippet defines the 'sort' function for the Remeda library. It provides type definitions for sorting arrays in ascending order using the default comparison or a custom comparator function.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/mapping/ramda/sort.md#2025-04-07_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\n/**\n * Sorts the elements of an array in ascending order and returns a new array.\n *\n * @param arr - The input array to be sorted.\n * @param comparator - Optional comparison function to determine the order of elements.\n * @returns A new array with the elements sorted in ascending order.\n * @signature\n *    R.sort(arr)\n *    R.sort(arr, comparator)\n * @example\n *    R.sort([3, 1, 2]) // => [1, 2, 3]\n *    R.sort(['b', 'a', 'c']) // => ['a', 'b', 'c']\n *    R.sort([3, 1, 2], (a, b) => b - a) // => [3, 2, 1]\n * @dataFirst\n * @category List\n */\nexport function sort<T>(arr: readonly T[]): T[]\nexport function sort<T>(arr: readonly T[], comparator: (a: T, b: T) => number): T[]\n\n/**\n * Sorts the elements of an array in ascending order and returns a new array.\n *\n * @param comparator - Optional comparison function to determine the order of elements.\n * @returns A new array with the elements sorted in ascending order.\n * @signature\n *    R.sort(comparator)(arr)\n * @example\n *    R.pipe(\n *      [3, 1, 2],\n *      R.sort((a, b) => b - a)\n *    ) // => [3, 2, 1]\n * @dataLast\n * @category List\n */\nexport function sort<T>(comparator: (a: T, b: T) => number): (arr: readonly T[]) => T[]\nexport function sort(...args: any[]) {\n  return purry(sortImplementation, args)\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Range Function in TypeScript\nDESCRIPTION: The range function generates arrays of sequential numbers. It supports three different call signatures: single parameter (end), two parameters (start, end), or three parameters (start, end, step). The function handles different step values including negative steps for descending ranges.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/mapping/lodash/range.md#2025-04-07_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n/**\n * Creates an array of numbers (positive and/or negative) progressing from `start` up to, but not including, `end`.\n *\n * @param args 1-3 arguments\n * - `end` - The end of the range.\n * - `start` - The start of the range. Default: 0.\n * - `step` - The value to increment or decrement by. Default: 1 if end > start, -1 if end < start.\n *\n * @signature\n *   R.range(end)\n *   R.range(start, end)\n *   R.range(start, end, step)\n * @example\n *   R.range(3) // => [0, 1, 2]\n *   R.range(0, 3) // => [0, 1, 2]\n *   R.range(0, 3, 1) // => [0, 1, 2]\n *   R.range(3, 0) // => [3, 2, 1]\n *   R.range(3, 0, -1) // => [3, 2, 1]\n *   R.range(0, 10, 2) // => [0, 2, 4, 6, 8]\n * @dataFirst\n * @category Util\n */\nexport function range(...args: [end: number] | [start: number, end: number] | [start: number, end: number, step: number]): number[] {\n  if (args.length === 0) {\n    throw new Error(\"range requires at least 1 argument\")\n  }\n  \n  if (args.length === 1) {\n    const [end] = args\n    return end <= 0 ? [] : Array.from({ length: end }, (_, i) => i)\n  }\n  \n  const [start, end] = args\n  let step: number\n  \n  if (args.length === 2) {\n    step = start <= end ? 1 : -1\n  } else {\n    step = args[2]!\n    \n    if ((start <= end && step <= 0) || (start >= end && step >= 0)) {\n      return []\n    }\n  }\n  \n  const length = Math.max(Math.ceil((end - start) / step), 0)\n  \n  return Array.from({ length }, (_, i) => start + i * step)\n}\n```\n\n----------------------------------------\n\nTITLE: Using indexBy with key selectors in Remeda\nDESCRIPTION: Examples showing how to use the indexBy function to convert arrays to objects using both string key selectors and function selectors. The function transforms an array into an object where properties are determined by the specified key or function.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/mapping/ramda/indexBy.md#2025-04-07_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { indexBy } from 'remeda';\n\nconst array = [\n  { id: 1, name: 'John' },\n  { id: 2, name: 'Jane' },\n];\n\nindexBy(array, 'id');\n// => { 1: { id: 1, name: 'John' }, 2: { id: 2, name: 'Jane' } }\n\nindexBy(array, (x) => String(x.id));\n// => { 1: { id: 1, name: 'John' }, 2: { id: 2, name: 'Jane' } }\n\nindexBy([], 'id');\n// => {}\n\n// Type definitions\ndeclare const indexBy: {\n  <T>(array: readonly T[], keySelector: keyof T): { [x: string]: T };\n  <T, K extends PropertyKey>(array: readonly T[], keySelector: (item: T) => K): { [x in K]: T };\n  <T>(keySelector: keyof T): (array: readonly T[]) => { [x: string]: T };\n  <T, K extends PropertyKey>(keySelector: (item: T) => K): (array: readonly T[]) => { [x in K]: T };\n};\n\n```\n\n----------------------------------------\n\nTITLE: Implementing the 'once' function in Remeda (TypeScript)\nDESCRIPTION: The 'once' function takes a function as input and returns a new function that will only execute the original function on the first call, caching and returning that result for all subsequent calls. This is useful for expensive operations that only need to be computed once.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/mapping/lodash/once.md#2025-04-07_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n/**\n * Creates a function that is restricted to be called only once. Repeat calls to the function will return the value of the first call.\n * @param fn - The function to be called once.\n * @signature\n *   R.once(fn)\n * @example\n *   const fn = R.once(Math.random);\n *   fn(); // => 0.3677045149387239\n *   fn(); // => 0.3677045149387239\n *   fn(); // => 0.3677045149387239\n * @category Function\n */\nexport function once<Args extends unknown[], T>(fn: (...args: Args) => T): (...args: Args) => T {\n  let called = false;\n  let result: T;\n\n  return (...args) => {\n    if (!called) {\n      called = true;\n      result = fn(...args);\n    }\n    return result;\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Example Usage of Remeda's 'find' Function (TypeScript)\nDESCRIPTION: This snippet demonstrates how to use the 'find' function from Remeda to search for elements in an array. It shows both the curried and non-curried usage of the function.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/mapping/ramda/find.md#2025-04-07_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { find } from 'remeda'\n\nfind((x: number) => x > 5, [1, 2, 3, 4, 5, 6, 7]) // => 6\nfind((x: number) => x > 5)([1, 2, 3, 4, 5, 6, 7]) // => 6\n```\n\n----------------------------------------\n\nTITLE: Sorting Objects Using Remeda's sortBy Function in TypeScript\nDESCRIPTION: This snippet demonstrates how to use Remeda's sortBy function to sort an array of objects by multiple criteria. It compares the syntax with Ramda's sortWith function, showing how Remeda simplifies complex sorting logic.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/mapping/ramda/sortWith.md#2025-04-07_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst DATA = [\n  {\n    name: \"clara\",\n    age: 40,\n  },\n  {\n    name: \"bob\",\n    age: 30,\n  },\n  {\n    name: \"alice\",\n    age: 40,\n  },\n];\n\n// Ramda\nsortWith([descend(prop(\"age\")), ascend(prop(\"name\"))])(DATA);\n\n// Remeda\nsortBy(DATA, [prop(\"age\"), \"desc\"], prop(\"name\"));\n\n// Or in a pipe\npipe(DATA, sortBy([prop(\"age\"), \"desc\"], prop(\"name\")));\n```\n\n----------------------------------------\n\nTITLE: Comparing Remeda and Lodash sortBy Implementations in TypeScript\nDESCRIPTION: This snippet demonstrates the differences between Lodash and Remeda implementations of the sortBy function. It shows how Lodash allows sorting by property names or callback functions in an array format, while Remeda requires callback functions provided as separate arguments.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/mapping/lodash/sortBy.md#2025-04-07_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst DATA = [\n  { user: \"fred\", age: 48 },\n  { user: \"barney\", age: 34 },\n  { user: \"fred\", age: 40 },\n  { user: \"barney\", age: 36 },\n];\n\n// Lodash\nsortBy(DATA, [\n  function (o) {\n    return o.user;\n  },\n]);\nsortBy(DATA, [\"user\", \"age\"]);\n\n// Remeda\nsortBy(DATA, prop(\"user\"));\nsortBy(DATA, prop(\"user\"), prop(\"age\"));\n```\n\n----------------------------------------\n\nTITLE: Implementing Array Difference in TypeScript with Remeda\nDESCRIPTION: The 'difference' function compares two arrays and returns a new array containing elements from the first array that are not present in the second array. It uses a Set for efficient lookup of values in the second array.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/mapping/ramda/difference.md#2025-04-07_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { difference } from 'remeda';\n\ndifference([1, 2, 3, 4, 5], [2, 4]); // => [1, 3, 5]\ndifference([1, 2, 3, 4, 5])([2, 4]); // => [1, 3, 5]\n```\n\n----------------------------------------\n\nTITLE: Defining Find Function in TypeScript for Remeda Library\nDESCRIPTION: This code snippet defines the 'find' function in TypeScript for the Remeda library. It searches for an element in an array that satisfies a given predicate function.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/mapping/lodash/find.md#2025-04-07_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nfunction find<T>(array: readonly T[], predicate: (item: T) => boolean): T | undefined;\nfunction find<T>(predicate: (item: T) => boolean): (array: readonly T[]) => T | undefined;\n```\n\n----------------------------------------\n\nTITLE: Transforming Object Values with mapValues in JavaScript\nDESCRIPTION: The mapValues function takes an object and a mapping function as arguments. It applies the mapping function to each value in the object, returning a new object with the same keys but transformed values. The mapping function receives the value, key, and entire object as arguments.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/mapping/lodash/mapValues.md#2025-04-07_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { mapValues } from 'remeda';\n\nconst object = { a: 1, b: 2, c: 3 };\nconst result = mapValues(object, (value) => value * 2);\nconsole.log(result); // { a: 2, b: 4, c: 6 }\n```\n\n----------------------------------------\n\nTITLE: Implementing pickBy Function in TypeScript for Remeda Library\nDESCRIPTION: The pickBy function creates a new object by picking properties from the input object that satisfy the given predicate function. It takes an object and a predicate function as arguments and returns a new object with the selected properties.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/mapping/ramda/pickBy.md#2025-04-07_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { purry } from '../purry';\n\n/**\n * Creates a new object with the same keys as `object` and values generated by running each own enumerable string keyed property of `object` thru `predicate`.\n * The predicate is invoked with two arguments: (value, key).\n *\n * @param obj the target object\n * @param predicate The function invoked per property.\n * @signature\n *    R.pickBy(obj, predicate)\n * @example\n *    R.pickBy({ a: 1, b: 2, c: 3, d: 4 }, (val, key) => val % 2 === 0) // => { b: 2, d: 4 }\n *    R.pickBy({ a: 1, b: 2, A: 3, B: 4 }, (val, key) => key.toUpperCase() === key) // => { A: 3, B: 4 }\n * @data_first\n * @category Object\n */\nexport function pickBy<T>(obj: T, predicate: (value: T[keyof T], key: keyof T) => boolean): Partial<T>\n\n/**\n * Creates a new object with the same keys as `object` and values generated by running each own enumerable string keyed property of `object` thru `predicate`.\n * The predicate is invoked with two arguments: (value, key).\n *\n * @param predicate The function invoked per property.\n * @signature\n *    R.pickBy(predicate)(obj)\n * @example\n *    R.pickBy((val, key) => val % 2 === 0)({ a: 1, b: 2, c: 3, d: 4 }) // => { b: 2, d: 4 }\n *    R.pickBy((val, key) => key.toUpperCase() === key)({ a: 1, b: 2, A: 3, B: 4 }) // => { A: 3, B: 4 }\n * @data_last\n * @category Object\n */\nexport function pickBy<T>(predicate: (value: T[keyof T], key: keyof T) => boolean): (obj: T) => Partial<T>\n\nexport function pickBy(...args: any[]) {\n  return purry(_pickBy, args);\n}\n\nfunction _pickBy(obj: any, predicate: (value: any, key: string) => boolean) {\n  if (obj == null) {\n    return {};\n  }\n  return Object.keys(obj).reduce<any>((acc, key) => {\n    if (predicate(obj[key], key)) {\n      acc[key] = obj[key];\n    }\n    return acc;\n  }, {});\n}\n```\n\n----------------------------------------\n\nTITLE: Defining and Implementing the 'invert' Function in TypeScript\nDESCRIPTION: This snippet defines the 'invert' function that takes an object and returns a new object with keys and values swapped. It handles cases where multiple keys have the same value by using an array of keys as the new value.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/mapping/lodash/invert.md#2025-04-07_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { purry } from '../purry';\n\n/**\n * Creates an object with the same values as the provided object and keys generated by running each property\n * of the object through the callback function. If no callback is provided, the values of the original object\n * are used as keys and the keys as values. If the same value is encountered multiple times, the last property to produce it\n * will determine the key in the returned object.\n *\n * @param object - The object to invert.\n * @param callback - The callback function to run against every property.\n * @signature\n *    R.invert(object)\n *    R.invert(object, callback)\n * @example\n *    R.invert({ 'a': 1, 'b': 2, 'c': 1 }) // => { '1': 'c', '2': 'b' }\n *    R.invert({ 'a': 1, 'b': 2, 'c': 1 }, (num) => `${num}`) // => { '1': 'c', '2': 'b' }\n * @dataFirst\n * @category Object\n */\nexport function invert<T extends Record<string, unknown>>(object: T): Record<string, keyof T>;\nexport function invert<T extends Record<string, unknown>, S extends string>(\n  object: T,\n  callback: (value: T[keyof T], key: keyof T, obj: T) => S\n): Record<S, keyof T>;\nexport function invert<T extends Record<string, unknown>, S extends string>(\n  object: T,\n  callback?: (value: T[keyof T], key: keyof T, obj: T) => S\n): Record<string, keyof T> | Record<S, keyof T> {\n  const fn = (\n    object: T,\n    callback: ((value: T[keyof T], key: keyof T, obj: T) => S) | undefined\n  ) => {\n    return Object.entries(object).reduce<Record<string, keyof T>>(\n      (acc, [key, value]) => {\n        const newKey = callback ? callback(value, key as keyof T, object) : `${value}`;\n        acc[newKey] = key as keyof T;\n        return acc;\n      },\n      {}\n    );\n  };\n\n  return purry(fn, arguments);\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing isSymbol Function in TypeScript for Remeda\nDESCRIPTION: This function checks if the provided value is a symbol. It uses the typeof operator to determine the type of the input and returns true if it's a symbol, false otherwise.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/mapping/lodash/isSymbol.md#2025-04-07_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\n/**\n * Checks if `value` is classified as a `Symbol` primitive or object.\n *\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n * @example\n *\n * isSymbol(Symbol.iterator);\n * // => true\n *\n * isSymbol('abc');\n * // => false\n */\nconst isSymbol = (value: unknown): value is symbol => {\n  const type = typeof value;\n  return type === 'symbol';\n};\n\nexport default isSymbol;\n```\n\n----------------------------------------\n\nTITLE: Concatenating Multiple Arrays in TypeScript using Remeda\nDESCRIPTION: Example of using the 'concat' function from the Remeda library to join multiple arrays into a single array. The function takes a base array and any number of additional arrays and returns a new array containing all elements.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/mapping/ramda/concat.md#2025-04-07_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { concat } from 'remeda';\n\nconcat([1, 2], [3, 4], [5, 6]); // => [1, 2, 3, 4, 5, 6]\nconcat([1, 2])([3, 4], [5, 6]); // => [1, 2, 3, 4, 5, 6]\n```\n\n----------------------------------------\n\nTITLE: Implementing mapValues Function in TypeScript for Remeda Library\nDESCRIPTION: This code snippet defines the mapValues function, which takes an object and a mapping function as arguments. It creates a new object with the same keys as the input, but with values transformed by the mapping function. The function supports both eager and lazy evaluation modes.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/mapping/ramda/mapObjIndexed.md#2025-04-07_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { _reduceLazy } from './_reduceLazy'\nimport { _toLazyIndexed } from './_toLazyIndexed'\nimport type { LazyEvaluator } from './types'\n\n/**\n * Takes an object and a mapping function as arguments and\n * returns a new object with the same keys as the original,\n * but with values transformed by the mapping function.\n *\n * @param object - The object to transform.\n * @param fn - The mapping function to apply to each value.\n * @signature\n *    R.mapValues(object, fn)\n * @example\n *    R.mapValues({ a: 1, b: 2 }, x => x * 2) // => { a: 2, b: 4 }\n * @dataFirst\n * @indexed\n * @category Object\n */\nexport function mapValues<T extends object, S>(\n  object: T,\n  fn: (value: T[keyof T], key: keyof T, obj: T) => S\n): { [K in keyof T]: S }\n\n/**\n * Takes a mapping function as an argument and returns a function that,\n * when given an object, returns a new object with the same keys as the original,\n * but with values transformed by the mapping function.\n *\n * @param fn - The mapping function to apply to each value.\n * @signature\n *    R.mapValues(fn)(object)\n * @example\n *    R.pipe({ a: 1, b: 2 }, R.mapValues(x => x * 2)) // => { a: 2, b: 4 }\n * @dataLast\n * @indexed\n * @category Object\n */\nexport function mapValues<T extends object, S>(\n  fn: (value: T[keyof T], key: keyof T, obj: T) => S\n): (object: T) => { [K in keyof T]: S }\n\nexport function mapValues(...args: Array<any>): unknown {\n  return _reduceLazy(\n    args,\n    mapValuesImplementation,\n    mapValuesIndexedImplementation\n  )\n}\n\nfunction mapValuesImplementation(object: object, fn: Function) {\n  return Object.keys(object).reduce((acc, key) => {\n    // @ts-ignore\n    acc[key] = fn(object[key])\n    return acc\n  }, {})\n}\n\nfunction mapValuesIndexedImplementation(object: object, fn: Function) {\n  return Object.keys(object).reduce((acc, key) => {\n    // @ts-ignore\n    acc[key] = fn(object[key], key, object)\n    return acc\n  }, {})\n}\n\nconst mapValuesLazy =\n  (fn: Function): LazyEvaluator =>\n  (value, key, object) => {\n    return [key, fn(value, key, object)]\n  }\n\nconst mapValuesLazyIndexed =\n  (fn: Function): LazyEvaluator =>\n  (value, key, object) => {\n    return _toLazyIndexed([key, fn(value, key, object)], key, object)\n  }\n\nmapValues.lazy = mapValuesLazy\nmapValues.lazyIndexed = mapValuesLazyIndexed\n```\n\n----------------------------------------\n\nTITLE: Throttle Implementation with Arguments Support\nDESCRIPTION: Enhanced throttle implementation that supports passing arguments to the throttled function. Uses a reducer to handle parameters and includes configurable quiet period and burst duration.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/mapping/lodash/throttle.md#2025-04-07_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nfunction throttle<F extends (...args: any) => void>(\n  func: F,\n  wait = 0,\n  {\n    leading = true,\n    trailing = true,\n  }: { readonly leading?: boolean; readonly trailing?: boolean } = {},\n) {\n  const {\n    call,\n    isIdle: _isIdle,\n    ...rest\n  } = funnel(\n    (args: Parameters<F>) => {\n      if (leading || trailing) {\n        func(...args);\n      }\n    },\n    {\n      reducer: (_, ...args: Parameters<F>) => args,\n      minQuietPeriodMs: wait,\n      maxBurstDurationMs: wait,\n      triggerAt: trailing ? (leading ? \"both\" : \"end\") : \"start\",\n    },\n  );\n  return Object.assign(call, rest);\n}\n```\n\n----------------------------------------\n\nTITLE: Reducing Object Properties with Remeda in TypeScript\nDESCRIPTION: Demonstrates the usage of Remeda's reduce function to transform an object by applying a reducer function to its properties. The reducer accumulates values into a new object based on the original object's key-value pairs.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/mapping/lodash/transform.md#2025-04-07_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { reduce } from 'remeda';\n\nconst object = { a: 1, b: 2, c: 3 };\nconst result = reduce(\n  object,\n  (acc, value, key) => {\n    acc[key.toUpperCase()] = value * 2;\n    return acc;\n  },\n  {} as Record<string, number>\n);\n// => { A: 2, B: 4, C: 6 }\n```\n\n----------------------------------------\n\nTITLE: Throttle Implementation with Return Value Caching\nDESCRIPTION: Complete throttle implementation that caches and returns function values. Includes flush and cancel capabilities, along with argument handling and configurable execution timing.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/mapping/lodash/throttle.md#2025-04-07_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nfunction throttle<F extends (...args: any) => any>(\n  func: F,\n  wait = 0,\n  {\n    leading = true,\n    trailing = true,\n  }: { readonly leading?: boolean; readonly trailing?: boolean } = {},\n) {\n  let cachedValue: ReturnType<F> | undefined;\n\n  const { call, flush, cancel } = funnel(\n    (args: Parameters<F>) => {\n      if (leading || trailing) {\n        cachedValue = func(...args) as ReturnType<F>;\n      }\n    },\n    {\n      reducer: (_, ...args: Parameters<F>) => args,\n      minQuietPeriodMs: wait,\n      maxBurstDurationMs: wait,\n      triggerAt: trailing ? (leading ? \"both\" : \"end\") : \"start\",\n    },\n  );\n\n  return Object.assign(\n    (...args: Parameters<F>) => {\n      call(...args);\n      return cachedValue;\n    },\n    {\n      flush: () => {\n        flush();\n        return cachedValue;\n      },\n\n      cancel,\n    },\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Defining fromEntries Function Type in TypeScript\nDESCRIPTION: This snippet defines the TypeScript type for the 'fromEntries' function. It takes an array of tuples (key-value pairs) and returns an object where the keys are of type K and the values are of type V.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/mapping/ramda/fromPairs.md#2025-04-07_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ntype FromEntries = <K extends PropertyKey, V>(\n  entries: Iterable<readonly [K, V]>\n) => { [P in K]: V }\n```\n\n----------------------------------------\n\nTITLE: Plucking Values from Arrays using Ramda and Remeda in TypeScript\nDESCRIPTION: This snippet demonstrates how to extract values associated with a specific key from an array of objects using Ramda's 'pluck' function and Remeda's 'map' and 'prop' functions. It shows the equivalent operations in both libraries.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/mapping/ramda/pluck.md#2025-04-07_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst DATA = [{ val: \"hello\" }, { val: \"world\" }];\n\n// Ramda\nR.pluck(\"val\", DATA); //=> [\"hello\", \"world\"];\n\n// Remeda\nmap(DATA, prop(\"val\"));\n```\n\n----------------------------------------\n\nTITLE: Nested Array Inclusion Check - Typescript\nDESCRIPTION: Shows how to check for nested array inclusion using Ramda's includes and Remeda's isDeepEqual with Array.some().\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/mapping/ramda/includes.md#2025-04-07_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nconst DATA = [[42]];\n\n// Ramda\nincludes([42], DATA);\n\n// Remeda\nDATA.some(isDeepEqual([42]));\n```\n\n----------------------------------------\n\nTITLE: Using fromEntries Function in JavaScript\nDESCRIPTION: This example demonstrates how to use the 'fromEntries' function to convert an array of key-value pairs into an object. It creates an object with properties 'a' and 'b' from the given array.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/mapping/ramda/fromPairs.md#2025-04-07_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { fromEntries } from 'remeda'\n\nfromEntries([\n  ['a', 1],\n  ['b', 2]\n])\n// => { a: 1, b: 2 }\n```\n\n----------------------------------------\n\nTITLE: Implementing flatMap Function in TypeScript for Remeda Library\nDESCRIPTION: This code snippet defines the flatMap function, which takes an array and a callback function. It maps each element using the callback and flattens the result. The function has both curried and non-curried versions for flexibility in usage.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/mapping/lodash/flatMap.md#2025-04-07_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { purry } from '../purry'\n\n/**\n * Maps each element using a mapping function, then flattens the result into\n * a new array.\n *\n * @param items - The array to map and flatten.\n * @param fn - A function that produces an array of new values.\n * @signature\n *    R.flatMap(items, fn)\n * @example\n *    R.flatMap([1, 2, 3], x => [x, x * 10]) // => [1, 10, 2, 20, 3, 30]\n *    R.flatMap([1, 2, 3], x => x % 2 === 0 ? [x] : []) // => [2]\n * @data_first\n * @category Collection\n */\nexport function flatMap<T, K>(\n  items: ReadonlyArray<T>,\n  fn: (item: T, index: number) => K[]\n): K[]\n\n/**\n * Maps each element using a mapping function, then flattens the result into\n * a new array.\n *\n * @param fn - A function that produces an array of new values.\n * @signature\n *    R.flatMap(fn)(items)\n * @example\n *    R.pipe(\n *      [1, 2, 3],\n *      R.flatMap(x => [x, x * 10])\n *    ) // => [1, 10, 2, 20, 3, 30]\n *    R.pipe(\n *      [1, 2, 3],\n *      R.flatMap(x => x % 2 === 0 ? [x] : [])\n *    ) // => [2]\n * @data_last\n * @category Collection\n */\nexport function flatMap<T, K>(\n  fn: (item: T, index: number) => K[]\n): (items: ReadonlyArray<T>) => K[]\n\nexport function flatMap(...args: any[]) {\n  return purry(flatMapImplementation, args)\n}\n\nfunction flatMapImplementation<T, K>(\n  items: ReadonlyArray<T>,\n  fn: (item: T, index: number) => K[]\n): K[] {\n  return items.flatMap(fn)\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing entries() function in TypeScript for Remeda library\nDESCRIPTION: This snippet defines and implements the 'entries' function, which takes an object and returns an array of its key-value pairs. It includes type definitions for better type inference and safety.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/mapping/lodash/toPairs.md#2025-04-07_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { purry } from '../purry'\n\ntype Entry<T> = { [K in keyof T]: [K, T[K]] }[keyof T]\n\nexport function entries<T extends object>(obj: T): Entry<T>[]\n\nexport function entries<T extends object>(\n  obj: T\n): Entry<T>[] {\n  return Object.entries(obj) as Entry<T>[]\n}\n\nexport namespace entries {\n  export function indexed<T extends object>(\n    obj: T\n  ): { [K in keyof T]: [K, T[K], number] }[keyof T][] {\n    return Object.entries(obj).map(\n      ([k, v], i) => [k, v, i] as [keyof T, T[keyof T], number]\n    ) as { [K in keyof T]: [K, T[K], number] }[keyof T][]\n  }\n}\n\nexport default entries\n```\n\n----------------------------------------\n\nTITLE: Dynamic Function Invocation\nDESCRIPTION: Illustrates how to handle dynamic function calls using Remeda's map with type checking and error handling, replacing Lodash's invokeMap with dynamic function names.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/mapping/lodash/invokeMap.md#2025-04-07_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst DATA = [\n  { foo: (x: number) => x + 1, bar: (x: number) => x - 1 },\n  { foo: (x: number) => x * 2, bar: (x: number) => x / 2 },\n] as const;\n\n// Lodash\ninvokeMap(DATA, funcName, 3);\n\n// Remeda\nif (funcName === \"foo\" || funcName === \"bar\") {\n  map(DATA, ({ [funcName]: func }) => func(3));\n} else {\n  // Error!\n}\n\n// Or\nmap(DATA, (obj) => {\n  if (funcName === \"foo\" || funcName === \"bar\") {\n    return obj[funcName](3);\n  } else {\n    // Error\n  }\n});\n```\n\n----------------------------------------\n\nTITLE: Iterating Over Arrays with forEach in Lodash vs Remeda\nDESCRIPTION: Demonstrates the basic usage of forEach to iterate over arrays in both Lodash and Remeda. While the syntax is similar, Remeda requires explicit curly braces for the callback function.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/mapping/lodash/forEach.md#2025-04-07_snippet_0\n\nLANGUAGE: ts\nCODE:\n```\n// Lodash\nforEach([1, 2, 3], (item) => console.log(item));\n\n// Remeda\nforEach([1, 2, 3], (item) => {\n  console.log(item);\n});\n```\n\n----------------------------------------\n\nTITLE: Defining take Function for Arrays in TypeScript\nDESCRIPTION: This snippet defines the 'take' function that returns a new array with the first N elements of the input array. It handles both curried and non-curried usage, and includes type safety checks.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/mapping/lodash/take.md#2025-04-07_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { purry } from '../purry'\n\n/**\n * Creates a new array with `n` elements taken from the beginning of the given array.\n *\n * @param data the array\n * @param n the number of elements to take\n * @signature\n *    R.take(data, n)\n * @example\n *    R.take([1, 2, 3, 4, 3, 2, 1], 3) // => [1, 2, 3]\n *    R.take([1, 2, 3], 5) // => [1, 2, 3]\n *    R.take([1, 2, 3], 0) // => []\n * @data_first\n * @category Array\n */\nexport function take<T>(data: readonly T[], n: number): T[]\n\n/**\n * Creates a new array with `n` elements taken from the beginning of the given array.\n *\n * @param n the number of elements to take\n * @signature\n *    R.take(n)(data)\n * @example\n *    R.pipe([1, 2, 3, 4, 3, 2, 1], R.take(3)) // => [1, 2, 3]\n *    R.take(5)([1, 2, 3]) // => [1, 2, 3]\n *    R.take(0)([1, 2, 3]) // => []\n * @data_last\n * @category Array\n */\nexport function take<T>(n: number): (data: readonly T[]) => T[]\n\nexport function take(...args: any[]) {\n  return purry(_take, args)\n}\n\nfunction _take<T>(data: readonly T[], n: number): T[] {\n  if (n <= 0) {\n    return []\n  }\n\n  if (n >= data.length) {\n    return data.slice()\n  }\n\n  return data.slice(0, n)\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Well-Typed Object Functions in TypeScript\nDESCRIPTION: Example showing how to write type-safe object functions using a generic object type instead of Record for better type inference.\nSOURCE: https://github.com/remeda/remeda/blob/main/CONTRIBUTING.md#2025-04-07_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nconst data = { a: \"a\", b: 1 };\n\n// ❌ `T` can be too wide:\nfunction functionName<T>(data: Readonly<Record<PropertyKey, T>>) {}\n\nfunctionName(data); // inside functionName, data.a has type string | number\n\n// ✅ `T` is more specific:\nfunction functionName<T extends object>(data: T) {}\n\nfunctionName(data); // inside functionName, data.a has type string\n```\n\n----------------------------------------\n\nTITLE: Comparing Ramda maxBy with Remeda firstBy in TypeScript\nDESCRIPTION: This snippet demonstrates the usage of Ramda's maxBy function and how it can be recreated using Remeda's firstBy function. The firstBy function takes an array and a sorting criteria to return the first item without sorting the entire array.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/mapping/ramda/maxBy.md#2025-04-07_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// Ramda\nmaxBy(mapperFunc, a, b);\n\n// Remeda\nfirstBy([a, b], [mapperFunc, \"desc\"]);\n```\n\n----------------------------------------\n\nTITLE: Basic Debounce Implementation with Remeda Funnel\nDESCRIPTION: Basic implementation of a debounce function using Remeda's funnel utility. Supports leading/trailing edge execution and maximum wait time configuration.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/mapping/lodash/debounce.md#2025-04-07_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nfunction debounce<F extends (...args: any) => void>(\n  func: F,\n  wait = 0,\n  {\n    leading = false,\n    trailing = true,\n    maxWait,\n  }: {\n    readonly leading?: boolean;\n    readonly trailing?: boolean;\n    readonly maxWait?: number;\n  } = {},\n) {\n  const {\n    call,\n    isIdle: _isIdle,\n    ...rest\n  } = funnel(\n    () => {\n      if (leading || trailing) {\n        func();\n      }\n    },\n    {\n      minQuietPeriodMs: wait,\n      ...(maxWait !== undefined && { maxBurstDurationMs: maxWait }),\n      triggerAt: trailing ? (leading ? \"both\" : \"end\") : \"start\",\n    },\n  );\n  return Object.assign(call, rest);\n}\n```\n\n----------------------------------------\n\nTITLE: Iterating Over Objects with forEach in Lodash vs forEachObj in Remeda\nDESCRIPTION: Shows how to iterate over object properties. Lodash uses the same forEach function for both arrays and objects, while Remeda requires a separate forEachObj function for objects.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/mapping/lodash/forEach.md#2025-04-07_snippet_1\n\nLANGUAGE: ts\nCODE:\n```\n// Lodash\nforEach({ a: 1, b: 2, c: 3 }, (value) => console.log(value));\n\n// Remeda\nforEachObj({ a: 1, b: 2, c: 3 }, (value) => {\n  console.log(value);\n});\n```\n\n----------------------------------------\n\nTITLE: Defining and Using Zip Function in TypeScript for Remeda Library\nDESCRIPTION: This snippet defines the 'zip' function that combines multiple arrays into a single array of tuples. It includes type definitions and usage examples showing how to combine arrays of different types.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/mapping/ramda/zip.md#2025-04-07_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { _ } from \"remeda\";\n\nconst zipped = _.zip([1, 2], [\"a\", \"b\"], [true, false]);\n// => [[1, \"a\", true], [2, \"b\", false]]\n\ntype Zip = {\n  <T extends unknown[][]>(...arrays: T): {\n    [I in keyof T]: T[I] extends (infer U)[] ? U : never;\n  }[];\n};\n```\n\n----------------------------------------\n\nTITLE: Object.entries TypeScript Type Definition\nDESCRIPTION: Type definition that takes an object type and returns an array of key-value tuples. The type preserves the specific types of the input object's properties.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/mapping/ramda/toPairs.md#2025-04-07_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ntype Entries<T> = { [K in keyof T]: [K, T[K]] }[keyof T][]\n```\n\n----------------------------------------\n\nTITLE: Flattening Arrays with Remeda and Lodash in TypeScript\nDESCRIPTION: Demonstrates how to use Remeda's 'flat' function to flatten an array, with an optional depth parameter. It also shows the equivalent operation using Lodash's 'flatten' function for comparison. The 'flat' function can be used without parameters or with a depth of 1.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/mapping/lodash/flatten.md#2025-04-07_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// Lodash\nflatten(DATA);\n\n// Remeda\nflat(DATA);\nflat(DATA, 1 /* depth */);\n```\n\n----------------------------------------\n\nTITLE: Implementing forEachObj Function in TypeScript\nDESCRIPTION: This code snippet defines the 'forEachObj' function, which iterates over object properties. It takes an object and a callback function as parameters, applying the callback to each key-value pair of the object.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/mapping/lodash/forOwn.md#2025-04-07_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { _ } from './common';\n\n/**\n * Iterates over own enumerable string keyed properties of an object and invokes `iteratee` for each property.\n * The iteratee is invoked with three arguments: (value, key, object).\n * Iteratee functions may exit iteration early by explicitly returning `false`.\n *\n * @param obj - The object to iterate over.\n * @param iteratee - The function invoked per iteration.\n * @signature\n *    R.forEachObj(obj, iteratee)\n * @example\n *    R.forEachObj({ a: 1, b: 2 }, (value, key) => console.log(key, value))\n *    // => 'a', 1\n *    // => 'b', 2\n * @returns The input object.\n * @data_first\n * @category Object\n */\nexport function forEachObj<T extends object>(\n  obj: T,\n  iteratee: <K extends keyof T>(value: T[K], key: K, obj: T) => void | false\n): T;\n\n/**\n * Iterates over own enumerable string keyed properties of an object and invokes `iteratee` for each property.\n * The iteratee is invoked with three arguments: (value, key, object).\n * Iteratee functions may exit iteration early by explicitly returning `false`.\n *\n * @param iteratee - The function invoked per iteration.\n * @signature\n *    R.forEachObj(iteratee)(obj)\n * @example\n *    R.pipe(\n *      { a: 1, b: 2 },\n *      R.forEachObj((value, key) => console.log(key, value))\n *    )\n *    // => 'a', 1\n *    // => 'b', 2\n * @returns A function that accepts the object to iterate over and returns it.\n * @data_last\n * @category Object\n */\nexport function forEachObj<T extends object>(\n  iteratee: <K extends keyof T>(value: T[K], key: K, obj: T) => void | false\n): (obj: T) => T;\n\nexport function forEachObj(...args: any[]) {\n  return _((obj, iteratee) => {\n    for (const key in obj) {\n      if (Object.prototype.hasOwnProperty.call(obj, key)) {\n        if (iteratee(obj[key], key, obj) === false) {\n          break;\n        }\n      }\n    }\n    return obj;\n  }, args);\n}\n```\n\n----------------------------------------\n\nTITLE: Transforming key-value pairs into an object with fromEntries in TypeScript\nDESCRIPTION: The `fromEntries` function converts an array of key-value pair tuples into an object where each key points to its corresponding value. It provides standalone and pipeline usage patterns.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/mapping/lodash/fromPairs.md#2025-04-07_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { fromEntries } from 'remeda';\n\n// Standalone usage\nfromEntries([['a', 1], ['b', 2], ['c', 3]]); // => { a: 1, b: 2, c: 3 }\n\n// Pipeline usage\n[[\"a\", 1], [\"b\", 2], [\"c\", 3]] |> fromEntries; // => { a: 1, b: 2, c: 3 }\n```\n\n----------------------------------------\n\nTITLE: Using flatMap in Remeda for Array Transformation\nDESCRIPTION: Shows how to use the flatMap function to transform array elements and flatten the results. The example demonstrates mapping an array of people to an array of their pets, flattening the nested arrays.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/mapping/ramda/chain.md#2025-04-07_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { flatMap } from 'remeda';\n\nconst people = [\n  { name: 'Jill', pets: ['dog', 'cat'] },\n  { name: 'Rick', pets: ['fish'] },\n];\n\nconst result = flatMap(people, (person) => person.pets);\n// => ['dog', 'cat', 'fish']\n\n// Or using pipe:\nimport { pipe } from 'remeda';\n\nconst result2 = pipe(\n  people,\n  flatMap((person) => person.pets),\n);\n// => ['dog', 'cat', 'fish']\n```\n\n----------------------------------------\n\nTITLE: Flattening Arrays Using Remeda and Lodash in TypeScript\nDESCRIPTION: Demonstrates the correct usage of Remeda's flat function compared to Lodash's flattenDeep. It emphasizes using a constant depth value instead of Infinity for efficient typing.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/mapping/lodash/flattenDeep.md#2025-04-07_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// Lodash\nflattenDeep(DATA);\n\n// Remeda\nflat(DATA, 100); // ✅\nflat(DATA, Infinity); // ❌\n```\n\n----------------------------------------\n\nTITLE: Grouping Array Elements with Remeda's groupBy Function\nDESCRIPTION: Demonstrates the usage of the 'groupBy' function to group an array of objects based on a specified property. The function takes an array and a key selector function as arguments, returning an object with grouped elements.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/mapping/lodash/groupBy.md#2025-04-07_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport { groupBy } from 'remeda';\n\nconst users = [\n  { id: 1, name: 'John', age: 30 },\n  { id: 2, name: 'Jane', age: 25 },\n  { id: 3, name: 'Bob', age: 30 },\n];\n\nconst result = groupBy(users, (user) => user.age);\nconsole.log(result);\n// {\n//   '25': [{ id: 2, name: 'Jane', age: 25 }],\n//   '30': [\n//     { id: 1, name: 'John', age: 30 },\n//     { id: 3, name: 'Bob', age: 30 },\n//   ],\n// }\n```\n\n----------------------------------------\n\nTITLE: Implementing forEachRight for Arrays in TypeScript\nDESCRIPTION: This snippet demonstrates how to iterate through an array in reverse order using both Lodash's forEachRight and native JavaScript. It shows how to break the iteration when a condition is met, equivalent to returning false in Lodash's implementation.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/mapping/lodash/forEachRight.md#2025-04-07_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst DATA = [1, 2, 3];\n\n// Lodash\nforEachRight(DATA, (item) => (item === 2 ? false : console.log(item)));\n\n// Native\nfor (const index = DATA.length - 1; index >= 0; index--) {\n  const item = DATA[item]!;\n  if (item === 2) {\n    break;\n  }\n\n  console.log(item);\n}\n```\n\n----------------------------------------\n\nTITLE: Comparing Remeda's mapWithFeedback with Ramda's mapAccum in TypeScript\nDESCRIPTION: This code snippet demonstrates the usage of Ramda's mapAccum and Remeda's mapWithFeedback functions. It shows how to achieve similar results using both approaches, with the Remeda version requiring an additional step to match Ramda's output format.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/mapping/ramda/mapAccum.md#2025-04-07_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// Ramda\nconst result = mapAccum((a, b) => [a + b, a + b], 0, [\"1\", \"2\", \"3\", \"4\"]);\n\n// Remeda\nconst temp = mapWithFeedback([\"1\", \"2\", \"3\", \"4\"], (a, b) => a + b, 0);\nconst result = [last(temp), temp];\n```\n\n----------------------------------------\n\nTITLE: Setting Object Properties with Remeda and Lodash Comparison\nDESCRIPTION: Demonstrates different ways to set object properties using both Remeda and Lodash. Shows path-based property setting, type-safe updates, and handling nested objects. Highlights key differences: Remeda uses immutable updates and array-based paths, while Lodash supports string paths and mutates objects directly.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/mapping/lodash/set.md#2025-04-07_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nlet data = { a: \"hello\", deep: [{ z: true }] };\n\n// Lodash\nset(data, \"a\", \"world\");\nset(data, [\"a\"], \"foo\");\n\nset(data, \"a\", 123);\nset(data, [\"a\"], 456);\nset(data, \"b\", 123);\nset(data, [\"b\"], 456);\n\nset(data, \"deep[0].z\", false);\nset(data, [\"deep\", 0, \"z\"], false);\n\n// ❌ Not supported:\nset(data, \"deep[0].newProp\", 123);\nset(data, [\"deep\", 0, \"newProp\"], 123);\n\n// Remeda\ndata = set(data, \"a\", \"world\");\ndata = set(data, \"a\", \"foo\");\n\ndata = addProp(data, \"a\", 123);\ndata = addProp(data, \"a\", 456);\ndata = addProp(data, \"b\", 123);\ndata = addProp(data, \"b\", 456);\n\ndata = setPath(data, stringToPath(\"deep[0].z\"), false);\ndata = setPath(data, [\"deep\", 0, \"z\"], false);\n```\n\n----------------------------------------\n\nTITLE: Checking Array Inclusion with Remeda and Lodash\nDESCRIPTION: Demonstrates how to check if an item is included in an array using Remeda's isIncludedIn function and Lodash's includes method.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/mapping/lodash/includes.md#2025-04-07_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// Lodash\nincludes([1, 2, 3], 1);\n\n// Remeda\nisIncludedIn(1, [1, 2, 3]);\n```\n\n----------------------------------------\n\nTITLE: Cloning Objects and Arrays in Remeda Library\nDESCRIPTION: Implementation of a deep clone function that recursively copies objects and arrays while preserving their structure and values. The function handles nested objects, arrays, and primitive types.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/mapping/lodash/cloneDeep.md#2025-04-07_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { isObject } from \"./isObject\";\nimport { isArray } from \"./isArray\";\n\nfunction innerClone(source) {\n  // Fast path for primitives\n  if (!isObject(source)) {\n    return source;\n  }\n\n  // Clone array recursively\n  if (isArray(source)) {\n    return source.map(item => innerClone(item));\n  }\n\n  // Clone object recursively\n  const newObject = {};\n  for (const key in source) {\n    if (Object.prototype.hasOwnProperty.call(source, key)) {\n      newObject[key] = innerClone(source[key]);\n    }\n  }\n  return newObject;\n}\n\nexport const clone = innerClone;\n\n```\n\n----------------------------------------\n\nTITLE: Handling Nullish Values with Remeda's 'when' Function in TypeScript\nDESCRIPTION: This snippet demonstrates how to use Remeda's 'when' function with 'isNullish' predicate and 'constant' wrapper to handle nullish values, as an alternative to Ramda's 'defaultTo'.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/mapping/ramda/defaultTo.md#2025-04-07_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// Ramda\ndefaultTo(DATA, 10);\n\n// Remeda\nwhen(DATA, isNullish, constant(10));\n```\n\n----------------------------------------\n\nTITLE: Handling Nullish Values with Remeda when()\nDESCRIPTION: Shows how to use Remeda's when() function with isNullish predicate to provide default values for null or undefined inputs. Compares implementation with Lodash's defaultTo().\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/mapping/lodash/defaultTo.md#2025-04-07_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// Lodash\ndefaultTo(DATA, 10);\n\n// Remeda\nwhen(DATA, isNullish, constant(10));\n```\n\n----------------------------------------\n\nTITLE: Sorting Objects Using Remeda and Lodash Comparison\nDESCRIPTION: Illustrates sorting an array of user objects by multiple criteria using both Remeda and Lodash. Shows how Remeda uses callback functions with order modifiers as variadic arguments, while Lodash accepts separate arrays for properties and orders.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/mapping/lodash/orderBy.md#2025-04-07_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst DATA = [\n  { user: \"fred\", age: 48 },\n  { user: \"barney\", age: 34 },\n  { user: \"fred\", age: 40 },\n  { user: \"barney\", age: 36 },\n];\n\n// Lodash\norderBy(DATA, [\"user\", \"age\"], [\"asc\", \"desc\"]);\n\n// Remeda\nsortBy(DATA, prop(\"user\"), [prop(\"age\"), \"desc\"]);\n```\n\n----------------------------------------\n\nTITLE: Checking String Inclusion with Lodash and Native JavaScript\nDESCRIPTION: Illustrates how to check if a substring is included in a string using Lodash's includes method and native JavaScript's String.prototype.includes method.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/mapping/lodash/includes.md#2025-04-07_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst DATA = \"Hello, World!\";\n\n// Lodash\nincludes(DATA, \"lo\");\n\n// Native\nDATA.includes(\"lo\");\n```\n\n----------------------------------------\n\nTITLE: Implementing Omit Function in JavaScript\nDESCRIPTION: Implements the 'omit' function using Remeda's internal utilities. It handles different parameter combinations and creates a new object without the specified properties.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/mapping/ramda/omit.md#2025-04-07_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { purry } from '../purry'\nimport { _curry2 } from '../_internal/_curry2'\n\n/**\n * Creates an object composed of the properties not omitted.\n *\n * @param obj the target object\n * @param props the properties to omit\n * @signature\n *    R.omit(obj, props)\n * @example\n *    R.omit({ a: 1, b: 2, c: 3 }, ['a', 'b']) // => { c: 3 }\n *    R.omit({ a: 1, b: 2, c: 3 }, 'a', 'b') // => { c: 3 }\n * @data_first\n * @category Object\n */\nexport function omit<T extends object, K extends keyof T>(\n  obj: T,\n  ...props: K[] | [K[]] | [K]\n): OmitProps<T, K>\n\n/**\n * Creates an object composed of the properties not omitted.\n *\n * @param props the properties to omit\n * @signature\n *    R.omit(props)(obj)\n * @example\n *    R.pipe({ a: 1, b: 2, c: 3 }, R.omit(['a', 'b'])) // => { c: 3 }\n *    R.pipe({ a: 1, b: 2, c: 3 }, R.omit('a', 'b')) // => { c: 3 }\n * @data_last\n * @category Object\n */\nexport function omit<T extends object, K extends keyof T>(\n  ...props: K[] | [K[]] | [K]\n): (obj: T) => OmitProps<T, K>\n\nexport function omit(...args: any[]) {\n  return purry(_omit, args)\n}\n\nfunction _omit(obj: any, props: string | string[]) {\n  props = Array.isArray(props) ? props : [props]\n  const out: any = {}\n  for (const key in obj) {\n    if (!props.includes(key)) {\n      out[key] = obj[key]\n    }\n  }\n  return out\n}\n\nomit.lazy = _curry2(_omit)\n```\n\n----------------------------------------\n\nTITLE: Handling Both Nullish and NaN Values with Remeda when()\nDESCRIPTION: Shows how to combine checks for both nullish values and NaN using a custom type guard predicate with when(). Provides a complete solution for handling all invalid value cases.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/mapping/lodash/defaultTo.md#2025-04-07_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\n// Lodash\ndefaultTo(DATA, 10);\n\n// Remeda\nwhen(\n  DATA,\n  (x) => x === undefined || x === null || Number.isNaN(x),\n  constant(10),\n);\n```\n\n----------------------------------------\n\nTITLE: Implementing If-Else Logic in Remeda vs Ramda\nDESCRIPTION: Shows how to implement if-else conditional logic using Remeda's when function compared to Ramda's ifElse. Demonstrates both direct usage and pipe implementation.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/mapping/ramda/ifElse.md#2025-04-07_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// Ramda\nifElse(predicate, onTrue, onFalse)(data);\n\n// Remeda\nwhen(data, predicate, { onTrue, onFalse });\n\n// Or in a pipe\npipe(data, when(predicate, { onTrue, onFalse }));\n```\n\n----------------------------------------\n\nTITLE: Array Number Inclusion Check - Typescript\nDESCRIPTION: Demonstrates checking for number inclusion in an array using both Ramda and Remeda approaches.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/mapping/ramda/includes.md#2025-04-07_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// Ramda\nincludes(1, [1, 2, 3]);\n\n// Remeda\nisIncludedIn(1, [1, 2, 3]);\n```\n\n----------------------------------------\n\nTITLE: Defining map Function in TypeScript for Remeda Library\nDESCRIPTION: This snippet defines the 'map' function in Remeda, which takes an array and a mapping function to transform each element. It supports both curried and non-curried usage.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/mapping/lodash/map.md#2025-04-07_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { purry } from '../purry'\n\n/**\n * Applies the provided projection function to each element of the array\n * and returns a new array with the results.\n *\n * @param data - The array to map over.\n * @param fn - The projection function to apply to each element.\n * @signature\n *    R.map(data, fn)\n * @example\n *    R.map([1, 2, 3], x => x * 2) // => [2, 4, 6]\n *    R.map(['a', 'b', 'c'], x => x.toUpperCase()) // => ['A', 'B', 'C']\n * @data_first\n * @category Array\n */\nexport function map<T, K>(data: readonly T[], fn: (value: T, index: number) => K): K[]\n\n/**\n * Applies the provided projection function to each element of the array\n * and returns a new array with the results.\n *\n * @param fn - The projection function to apply to each element.\n * @signature\n *    R.map(fn)(data)\n * @example\n *    R.pipe([1, 2, 3], R.map(x => x * 2)) // => [2, 4, 6]\n *    R.map(x => x.toUpperCase())(['a', 'b', 'c']) // => ['A', 'B', 'C']\n * @data_last\n * @category Array\n */\nexport function map<T, K>(fn: (value: T, index: number) => K): (data: readonly T[]) => K[]\n\nexport function map<T, K>(\n  ...args: [readonly T[], (value: T, index: number) => K] | [(value: T, index: number) => K]\n) {\n  return purry(_map, args)\n}\n\nfunction _map<T, K>(data: readonly T[], fn: (value: T, index: number) => K): K[] {\n  return data.map(fn)\n}\n```\n\n----------------------------------------\n\nTITLE: Replicating Lodash includes with fromIndex (Non-positive) in Remeda\nDESCRIPTION: Demonstrates how to replicate Lodash's includes method with a non-positive fromIndex using Remeda's isIncludedIn function combined with takeLast.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/mapping/lodash/includes.md#2025-04-07_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\n// Lodash\nincludes([1, 2, 3], 1, -2);\n\n// Remeda\nisIncludedIn(1, takeLast([1, 2, 3], 2));\n```\n\n----------------------------------------\n\nTITLE: Demonstrating pick Function Usage in JavaScript\nDESCRIPTION: Examples showing how to use the 'pick' function to create new objects with selected properties from input objects.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/mapping/ramda/pick.md#2025-04-07_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { pick } from 'remeda'\n\npick({ a: 1, b: 2, c: 3 }, ['a', 'c']) // => { a: 1, c: 3 }\npick(['a', 'c'])({ a: 1, b: 2, c: 3 }) // => { a: 1, c: 3 }\n```\n\n----------------------------------------\n\nTITLE: Array First Element Extraction - TypeScript\nDESCRIPTION: Shows how to extract the first element from an array using both Ramda's head() and Remeda's first() functions. Both methods achieve the same result but use different function names.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/mapping/ramda/head.md#2025-04-07_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// Ramda\nhead([1, 2, 3]);\n\n// Remeda\nfirst([1, 2, 3]);\n```\n\n----------------------------------------\n\nTITLE: Retrieving the Last Character from Strings using Ramda and Remeda\nDESCRIPTION: Demonstrates how to get the last character of a string using both libraries. While Ramda uses the 'last' function directly, Remeda recommends using 'sliceString' with -1 as the parameter.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/mapping/ramda/last.md#2025-04-07_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n// Ramda\nlast(\"abc\");\n\n// Remeda\nsliceString(\"abc\", -1);\n```\n\n----------------------------------------\n\nTITLE: Implementing findLast Function in TypeScript with Remeda\nDESCRIPTION: This code snippet defines the findLast function in TypeScript using the Remeda library. It finds the last element in an array that satisfies a given predicate function.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/mapping/lodash/findLast.md#2025-04-07_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { _ } from '../core';\n\n/**\n * Finds the last element of the `collection` satisfying the `predicate`\n * function.\n */\nexport function findLast<T>(\n  collection: ReadonlyArray<T>,\n  predicate: (item: T) => boolean,\n): T | undefined;\n\nexport function findLast<T>(\n  predicate: (item: T) => boolean,\n): (collection: ReadonlyArray<T>) => T | undefined;\n\nexport function findLast() {\n  return _((collection: ReadonlyArray<unknown>, predicate: Function) => {\n    for (let i = collection.length - 1; i >= 0; i--) {\n      if (predicate(collection[i])) {\n        return collection[i];\n      }\n    }\n    return undefined;\n  }, arguments);\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Object Keys Function in TypeScript\nDESCRIPTION: A utility function that extracts all enumerable string-keyed property names from an object. Part of the Remeda library, this implementation follows functional programming principles.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/mapping/lodash/keys.md#2025-04-07_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ntype Obj = Record<PropertyKey, unknown>;\n\ndeclare function keys<T extends Obj>(obj: T): Array<keyof T & string>;\n\ndeclare function keys(obj: unknown): string[];\n```\n\n----------------------------------------\n\nTITLE: Debounce Implementation with Cached Return Values\nDESCRIPTION: Complete debounce implementation that caches and returns function results. Includes flush and cancel capabilities, along with support for leading/trailing edge execution and maximum wait time.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/mapping/lodash/debounce.md#2025-04-07_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nfunction debounce<F extends (...args: any) => any>(\n  func: F,\n  wait = 0,\n  {\n    leading = false,\n    trailing = true,\n    maxWait,\n  }: {\n    readonly leading?: boolean;\n    readonly trailing?: boolean;\n    readonly maxWait?: number;\n  } = {},\n) {\n  let cachedValue: ReturnType<F> | undefined;\n\n  const { call, flush, cancel } = funnel(\n    (args: Parameters<F>) => {\n      if (leading || trailing) {\n        cachedValue = func(...args) as ReturnType<F>;\n      }\n    },\n    {\n      reducer: (_, ...args: Parameters<F>) => args,\n      minQuietPeriodMs: wait,\n      ...(maxWait !== undefined && { maxBurstDurationMs: maxWait }),\n      triggerAt: trailing ? (leading ? \"both\" : \"end\") : \"start\",\n    },\n  );\n  return Object.assign(\n    (...args: Parameters<F>) => {\n      call(...args);\n      return cachedValue;\n    },\n    {\n      flush: () => {\n        flush();\n        return cachedValue;\n      },\n\n      cancel,\n    },\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Constant False Function in Remeda and Ramda\nDESCRIPTION: Shows the difference between Ramda's F constant and Remeda's constant factory function approach. While Ramda provides F directly as a function, Remeda requires calling constant(false) to create the constant function.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/mapping/ramda/F.md#2025-04-07_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// Ramda\nF;\n\n// Remeda\nconstant(false);\n```\n\n----------------------------------------\n\nTITLE: Comparing Ramda T and Remeda constant Functions in TypeScript\nDESCRIPTION: This snippet demonstrates the difference between Ramda's T function and Remeda's constant function. In Ramda, T is directly used as a function that returns true, while in Remeda, constant is a factory function that creates a function returning the provided value (true in this example).\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/mapping/ramda/T.md#2025-04-07_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// Ramda\nT;\n\n// Remeda\nconstant(true);\n```\n\n----------------------------------------\n\nTITLE: Example Usage of sortedLastIndex Function in TypeScript\nDESCRIPTION: This code snippet demonstrates how to use the sortedLastIndex function with different types of sorted arrays, including numbers and strings in both ascending and descending order.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/mapping/lodash/sortedLastIndex.md#2025-04-07_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nsortedLastIndex([1, 2, 3, 4, 4, 5], 4); // => 5\nsortedLastIndex([5, 4, 4, 3, 2, 1], 4); // => 3\nsortedLastIndex(['a', 'b', 'c', 'd'], 'b'); // => 2\nsortedLastIndex(['d', 'c', 'b', 'a'], 'b'); // => 3\n```\n\n----------------------------------------\n\nTITLE: Implementing Well-Typed Array Functions in TypeScript\nDESCRIPTION: Example showing how to write type-safe array functions using IterableContainer type instead of generic ReadonlyArray for better type inference.\nSOURCE: https://github.com/remeda/remeda/blob/main/CONTRIBUTING.md#2025-04-07_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nconst data = [\"a\", 1] as [string, number];\n\n// ❌ `T` can be too wide:\nfunction functionName<T>(data: ReadonlyArray<T>): ReadonlyArray<T> {}\n\nfunctionName(data); // inside functionName, data[0] has type string | number\n// output has type ReadonlyArray<string | number>\n\n// ✅ `T` is more specific:\nfunction functionName<T extends IterableContainer>(data: T): T {}\n\nfunctionName(data); // inside functionName, data[0] has type string\n// output has type [string, number]\n```\n\n----------------------------------------\n\nTITLE: Retrieving the Last Element from Arrays using Ramda and Remeda\nDESCRIPTION: Shows how to get the last element of an array using both Ramda and Remeda libraries. Both libraries use a 'last' function that returns the final element of the array.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/mapping/ramda/last.md#2025-04-07_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// Ramda\nlast([1, 2, 3]);\n\n// Remeda\nlast([1, 2, 3]);\n```\n\n----------------------------------------\n\nTITLE: Debounce Implementation with Call Arguments\nDESCRIPTION: Enhanced debounce implementation that preserves and passes through function arguments. Supports leading/trailing edge execution and maximum wait time configuration.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/mapping/lodash/debounce.md#2025-04-07_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nfunction debounce<F extends (...args: any) => void>(\n  func: F,\n  wait = 0,\n  {\n    leading = false,\n    trailing = true,\n    maxWait,\n  }: {\n    readonly leading?: boolean;\n    readonly trailing?: boolean;\n    readonly maxWait?: number;\n  } = {},\n) {\n  const {\n    call,\n    isIdle: _isIdle,\n    ...rest\n  } = funnel(\n    (args: Parameters<F>) => {\n      if (leading || trailing) {\n        func(...args);\n      }\n    },\n    {\n      reducer: (_, ...args: Parameters<F>) => args,\n      minQuietPeriodMs: wait,\n      ...(maxWait !== undefined && { maxBurstDurationMs: maxWait }),\n      triggerAt: trailing ? (leading ? \"both\" : \"end\") : \"start\",\n    },\n  );\n  return Object.assign(call, rest);\n}\n```\n\n----------------------------------------\n\nTITLE: Comparing Remeda and Lodash Intersection (With Duplicates)\nDESCRIPTION: Shows how Remeda's intersection function handles arrays with duplicate values differently from Lodash. To achieve the same output as Lodash, the result from Remeda needs to be passed through the 'unique' function.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/mapping/lodash/intersection.md#2025-04-07_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n// Lodash\nintersection([1, 1], [1, 1]);\n\n// Remeda\nunique(intersection([1, 1], [1, 1]));\n```\n\n----------------------------------------\n\nTITLE: Generating Random Integers with Two Parameters in Remeda vs. Lodash\nDESCRIPTION: Demonstrates how to generate a random integer between two specified values (1 and 10) in both Lodash and Remeda.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/mapping/lodash/random.md#2025-04-07_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// Lodash\nrandom(1, 10);\n\n// Remeda\nrandomInteger(1, 10);\n```\n\n----------------------------------------\n\nTITLE: Comparing Object Merging in Lodash and Remeda (TypeScript)\nDESCRIPTION: This snippet demonstrates the differences in object merging between Lodash and Remeda. Lodash mutates the first argument in-place, while Remeda creates a new object. For merging multiple objects, Remeda uses a separate 'mergeAll' function that takes an array of objects.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/mapping/lodash/assign.md#2025-04-07_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// Lodash\nconst DATA = { a: 1, b: 2 };\nassign(DATA, b);\nassign(DATA, b, c, d, e);\n\n// Remeda\nlet DATA = { a: 1, b: 2 };\nDATA = merge(DATA, b);\nDATA = mergeAll([DATA, b, c, d, e]);\n```\n\n----------------------------------------\n\nTITLE: Implementing Object Merging Function in TypeScript\nDESCRIPTION: This code snippet defines the 'merge' function that combines multiple objects into a single object. It uses TypeScript's type system to ensure type safety and proper inference of the resulting object type.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/mapping/ramda/mergeRight.md#2025-04-07_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { purry } from './purry'\n\n/**\n * Merges a list of objects into a single object.\n *\n * @param objects - The list of objects to merge.\n * @signature\n *    R.merge(obj1, obj2, ...objects)\n * @example\n *    R.merge({ a: 1 }, { b: 2 }, { c: 3 }) // => { a: 1, b: 2, c: 3 }\n *    R.merge({ a: 1 }, { a: 2 }, { a: 3 }) // => { a: 3 }\n * @category Object\n */\nexport function merge<A extends object>(\n  a: A\n): A\nexport function merge<A extends object, B extends object>(\n  a: A,\n  b: B\n): A & B\nexport function merge<A extends object, B extends object, C extends object>(\n  a: A,\n  b: B,\n  c: C\n): A & B & C\nexport function merge<\n  A extends object,\n  B extends object,\n  C extends object,\n  D extends object\n>(a: A, b: B, c: C, d: D): A & B & C & D\nexport function merge<T extends object[]>(...objects: T): UnionToIntersection<T[number]>\nexport function merge() {\n  return purry(merge_, arguments)\n}\n\nfunction merge_(first: object, ...rest: object[]) {\n  return Object.assign({}, first, ...rest)\n}\n\ntype UnionToIntersection<U> = (U extends any ? (k: U) => void : never) extends (\n  k: infer I\n) => void\n  ? I\n  : never\n```\n\n----------------------------------------\n\nTITLE: Using Tap Function in TypeScript with Remeda\nDESCRIPTION: This example demonstrates how to use the 'tap' function from the Remeda library. It shows logging a value to the console while passing it through a pipeline of operations.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/mapping/ramda/tap.md#2025-04-07_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { pipe, map, tap } from 'remeda';\n\nconst result = pipe(\n  [1, 2, 3],\n  tap(console.log), // [1, 2, 3]\n  map((x) => x * 2),\n  tap(console.log), // [2, 4, 6]\n);\nconsole.log(result); // [2, 4, 6]\n```\n\n----------------------------------------\n\nTITLE: Generating Random Integers with No Parameters in Remeda vs. Lodash\nDESCRIPTION: Illustrates how Lodash can generate a random integer with no parameters, while Remeda requires explicit min and max values (0 and 1 in this case).\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/mapping/lodash/random.md#2025-04-07_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\n// Lodash\nrandom();\n\n// Remeda\nrandomInteger(0, 1);\n```\n\n----------------------------------------\n\nTITLE: Importing mapKeys from Remeda\nDESCRIPTION: Shows how to import the mapKeys function from the Remeda library.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/mapping/lodash/mapKeys.md#2025-04-07_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { mapKeys } from 'remeda';\n```\n\n----------------------------------------\n\nTITLE: Creating New Object with Merge in TypeScript\nDESCRIPTION: Demonstrates how to create a new object by merging two objects using Just's extend and Remeda's merge functions. Remeda's approach avoids mutating the original objects.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/mapping/just/extend.md#2025-04-07_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// Just\nconst result = extend({}, a, b);\n\n// Remeda\nconst result = merge(a, b);\n```\n\n----------------------------------------\n\nTITLE: FlatMap with Custom Depth in Remeda\nDESCRIPTION: Implementation of flatMapDepth with both mapping function and custom depth parameter, showing both direct and pipe approaches.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/mapping/lodash/flatMapDepth.md#2025-04-07_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\n// Lodash\nflatMapDepth(DATA, mappingFunction, depth);\n\n// Remeda\nflat(map(DATA, mappingFunction), depth);\n\n// Or as a pipe\npipe(DATA, map(mappingFunction), flat(depth));\n```\n\n----------------------------------------\n\nTITLE: Implementing Min Function with Ramda and Native JavaScript in TypeScript\nDESCRIPTION: This snippet demonstrates how to implement a min function using both Ramda library and native JavaScript operators in TypeScript. It includes non-curried and curried versions of the function.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/mapping/ramda/min.md#2025-04-07_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// Ramda\nmin(a, b);\n\n// Curried\nconst minA = min(a);\n\n// Native\na < b ? a : b;\n\nconst minA = (b: number) => (a < b ? a : b);\n```\n\n----------------------------------------\n\nTITLE: Creating a Function with Fixed Return Value Using constant() in Remeda\nDESCRIPTION: The constant() function creates a new function that always returns the same value, regardless of what arguments are passed to it. This is useful for providing default values or creating predicates with fixed responses.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/mapping/lodash/constant.md#2025-04-07_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { constant } from 'remeda';\n\nconst getFive = constant(5);\nconst result = getFive(); // => 5\n\nconst users = [{ name: 'john' }, { name: 'john' }, { name: 'jane' }];\nconst isNameJohn = (user: { name: string }) => user.name === 'john';\nconst alwaysTrue = constant(true);\nusers.filter(isNameJohn); // => [{ name: 'john' }, { name: 'john' }]\nusers.filter(alwaysTrue); // => [{ name: 'john' }, { name: 'john' }, { name: 'jane' }]\n```\n\n----------------------------------------\n\nTITLE: Splitting Strings into Words with Native JavaScript Instead of Lodash\nDESCRIPTION: Demonstrates how to split a string into words using native JavaScript's String.prototype.split method with a regular expression instead of using Lodash's words() function. The regex pattern /\\s+/u matches one or more whitespace characters with Unicode support.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/mapping/lodash/words.md#2025-04-07_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// Lodash\nwords(str);\n\n// Native\nstr.split(/\\s+/u);\n```\n\n----------------------------------------\n\nTITLE: Using Remeda's firstBy with Descending Order Compared to Lodash's maxBy\nDESCRIPTION: This snippet compares Lodash's maxBy function with Remeda's firstBy function using a descending sort direction. The Remeda implementation accepts a tuple parameter with the criteria and the 'desc' direction string to sort in descending order.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/mapping/lodash/maxBy.md#2025-04-07_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// Lodash\nmaxBy(DATA, criteria);\n\n// Remeda\nfirstBy(DATA, [criteria, \"desc\"]);\n```\n\n----------------------------------------\n\nTITLE: Filtering Falsy Values from Arrays using Remeda and Lodash\nDESCRIPTION: Demonstrates two approaches to filter out falsy values from arrays: Lodash's compact function and Remeda's filter function with the isTruthy predicate. The isTruthy predicate can be imported from the Remeda library.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/mapping/lodash/compact.md#2025-04-07_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// Lodash\ncompact(DATA);\n\n// Remeda\nfilter(DATA, isTruthy);\n```\n\n----------------------------------------\n\nTITLE: Accessing Array Elements - TypeScript Comparison\nDESCRIPTION: Demonstrates various ways to access array elements using Remeda, Ramda, and native JavaScript methods. Shows equivalent operations for accessing first, last, and arbitrary index elements, including negative indices. Includes the use of first(), last(), nth(), array indexing, and Array.prototype.at().\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/mapping/ramda/nth.md#2025-04-07_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// Ramda\nnth(0, DATA);\n\n// Remeda\nfirst(DATA);\n\n// Ramda\nnth(1, DATA);\n\n// Native\nDATA[1];\nDATA.at(1);\n\n// Ramda\nnth(-1, DATA);\n\n// Remeda\nlast(DATA);\n\n// Ramda\nnth(-2, DATA);\n\n// Native\nDATA.at(-2);\n```\n\n----------------------------------------\n\nTITLE: Implementing isBoolean Function in TypeScript for Remeda Library\nDESCRIPTION: This code snippet defines the isBoolean function, which checks if the input value is of type boolean. It uses the typeof operator to perform the type check.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/mapping/lodash/isBoolean.md#2025-04-07_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\n/**\n * Checks if the given value is a boolean.\n *\n * @param value - the value to check\n * @returns true if value is a boolean, false otherwise\n * @example\n *    R.isBoolean(true) // => true\n *    R.isBoolean(false) // => true\n *    R.isBoolean(1) // => false\n */\nexport const isBoolean = (value: unknown): value is boolean => {\n  return typeof value === 'boolean';\n};\n```\n\n----------------------------------------\n\nTITLE: Function Categories List in Markdown\nDESCRIPTION: A structured markdown list of function categories and their associated methods that need to be implemented in the Remeda project. Each category contains specific utility functions commonly found in libraries like Lodash.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/mapping/lodash/__MISSING.md#2025-04-07_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n# Array\n\n- differenceBy\n- fill\n- flattenDepth\n- indexOf\n- initial\n- intersectionBy\n- lastIndexOf\n- pull\n- pullAll\n- pullAllBy\n- pullAllWith\n- pullAt\n- remove\n- slice\n- sortedIndexOf\n- sortedLastIndexOf\n- sortedUniqBy\n- tail\n- union\n- unionBy\n- unionWith\n- unzip\n- unzipWith\n- without\n- xor\n- xorBy\n- xorWith\n- zipObjectDeep\n```\n\n----------------------------------------\n\nTITLE: Incrementing Values with add Function in TypeScript (Remeda vs Ramda)\nDESCRIPTION: Demonstrates how to increment a value by 1 using remeda's 'add' function compared to Ramda's 'inc' function. The remeda approach explicitly passes both the value and the increment amount as parameters.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/mapping/ramda/inc.md#2025-04-07_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// Ramda\ninc(value);\n\n// Remeda\nadd(value, 1);\n```\n\n----------------------------------------\n\nTITLE: Writing Runtime Tests for Remeda Functions\nDESCRIPTION: Example structure for writing runtime tests for both data-first and data-last forms of a function in Remeda.\nSOURCE: https://github.com/remeda/remeda/blob/main/CONTRIBUTING.md#2025-04-07_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\n// <functionName>.test.ts\n\ndescribe(\"data-first\", () => {\n  test(\"test description\", () => {\n    expect(/* ... */).toBe(/* ... */);\n  });\n});\n\ndescribe(\"data-last\", () => {\n  test(\"test description\", () => {\n    expect(/* ... */).toBe(/* ... */);\n  });\n});\n```\n\n----------------------------------------\n\nTITLE: Using objOf to Create Objects with Key-Value Pairs in TypeScript\nDESCRIPTION: The objOf function creates a new object with a single key-value pair. It takes two parameters: a key (string) and a value of any type, and returns an object where the key maps to the specified value.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/mapping/ramda/objOf.md#2025-04-07_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { objOf } from 'remeda';\n\nobjOf('a', 1); // => { a: 1 }\nobjOf('user', { name: 'Alice' }); // => { user: { name: 'Alice' } }\n```\n\n----------------------------------------\n\nTITLE: Calculating Array Length with Remeda in JavaScript\nDESCRIPTION: The 'length' function from Remeda returns the number of elements in an array or array-like object. It can be used both as a standalone function and in a pipe operation.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/mapping/ramda/length.md#2025-04-07_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { length, pipe } from 'remeda';\n\nlength([1, 2, 3]); // => 3\nlength([]); // => 0\nlength('abc'); // => 3\n\npipe(\n  [1, 2, 3],\n  length\n); // => 3\n```\n\n----------------------------------------\n\nTITLE: Writing Type Tests for Remeda Functions\nDESCRIPTION: Example structure for writing type tests using expectTypeOf for both data-first and data-last forms of a function in Remeda.\nSOURCE: https://github.com/remeda/remeda/blob/main/CONTRIBUTING.md#2025-04-07_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\n// <functionName>.test-d.ts\n\ndescribe(\"data-first\", () => {\n  test(\"test description\", () => {\n    expectTypeOf(/* ... */).toEqualTypeOf</* ... */>();\n  });\n});\n\ndescribe(\"data-last\", () => {\n  test(\"test description\", () => {\n    expectTypeOf(/* ... */).toEqualTypeOf</* ... */>();\n  });\n});\n```\n\n----------------------------------------\n\nTITLE: Legacy Data-First Intersection Behavior in TypeScript\nDESCRIPTION: Demonstrates how to achieve the legacy behavior of the intersection function for data-first operations using filter and isIncludedIn functions.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/v1-migration/intersection.md#2025-04-07_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\n// Was\nintersection([1, 1, 2, 2], [1]); // => [1, 1]\n\n// Now\nfilter([1, 1, 2, 2], isIncludedIn([1])); // => [1, 1]\n```\n\n----------------------------------------\n\nTITLE: Comparing Partial Function Binding in Remeda and Ramda (TypeScript)\nDESCRIPTION: This snippet defines a greet function and demonstrates how to partially apply arguments using Remeda's partialBind and Ramda's partial. The key difference is that Remeda's partialBind takes a variadic list of arguments, while Ramda's partial expects an array of arguments.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/mapping/ramda/partial.md#2025-04-07_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nfunction greet(greeting, firstName, lastName) {\n  return greeting + \" \" + firstName + \" \" + lastName;\n}\n\n// Ramda\npartial(greet, [\"hi\", \"john\"]);\n\n// Remeda\npartialBind(greet, \"hi\", \"john\");\n```\n\n----------------------------------------\n\nTITLE: Implementing Length Function in TypeScript for Remeda Library\nDESCRIPTION: This code snippet defines the length function for the Remeda library. It determines the length of arrays, strings, objects, and other data types. The function is overloaded to handle different input types and return the appropriate length value.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/mapping/lodash/size.md#2025-04-07_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { purry } from '../purry'\n\n/**\n * Returns the length of an array, string, object or any other data type.\n *\n * @param data - The array, string, object or any other data type to get the length of.\n * @signature\n *    R.length(data)\n * @example\n *    R.length([1, 2, 3]) // => 3\n *    R.length('123') // => 3\n *    R.length({a: 1, b: 2}) // => 2\n *    R.length(new Set([1, 2, 3])) // => 3\n *    R.length(new Map([[1, 2], [3, 4]])) // => 2\n *    R.length(123) // => undefined\n * @data_first\n * @category Collection\n */\nexport function length<T extends ArrayLike<unknown>>(data: T): number\nexport function length(data: Record<string, unknown>): number\nexport function length(data: unknown): number | undefined\nexport function length(data: unknown): number | undefined {\n  if (typeof data === 'string' || Array.isArray(data)) {\n    return data.length\n  }\n\n  if (data instanceof Set || data instanceof Map) {\n    return data.size\n  }\n\n  if (typeof data === 'object' && data !== null) {\n    return Object.keys(data).length\n  }\n\n  return undefined\n}\n\nexport const lengthPurry = purry(length)\n```\n\n----------------------------------------\n\nTITLE: Legacy Data-Last Intersection Behavior in TypeScript\nDESCRIPTION: Shows how to replicate the legacy behavior of the intersection function for data-last operations using pipe, filter, and isIncludedIn functions.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/v1-migration/intersection.md#2025-04-07_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\n// Was\npipe([1, 1, 2, 2], intersection([1]));\n\n// Now\npipe([1, 1, 2, 2], filter(isIncludedIn([1])));\n```\n\n----------------------------------------\n\nTITLE: Comparing Intersection Results Without Duplicates in TypeScript\nDESCRIPTION: Demonstrates that the intersection function behaves the same for inputs without duplicate values in both the old and new implementations.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/v1-migration/intersection.md#2025-04-07_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n// Was\nintersection([1, 2, 3], [2]); // => [2]\n\n// Now\nintersection([1, 2, 3], [2]); // => [2]\n```\n\n----------------------------------------\n\nTITLE: Comparing Deep Equality in Objects with isDeepEqual in TypeScript\nDESCRIPTION: This snippet demonstrates the change from using 'equals' to 'isDeepEqual' for comparing deeply nested objects in Remeda. The functionality remains the same, but the function name has changed.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/v1-migration/equals.md#2025-04-07_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// Was\nR.equals({ a: { b: 123 } }, { a: { b: 456 } });\n\n// Now\nR.isDeepEqual({ a: { b: 123 } }, { a: { b: 456 } });\n```\n\n----------------------------------------\n\nTITLE: Converting Arrays to Object using Remeda zip and fromEntries\nDESCRIPTION: Shows equivalent implementations between Lodash's zipObject and Remeda's combination of zip and fromEntries functions. Takes two arrays (keys and values) and creates an object where keys are paired with their corresponding values.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/mapping/lodash/zipObject.md#2025-04-07_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// Lodash\nzipObject(keys, values);\n\n// Remeda\nfromEntries(zip(keys, values));\n```\n\n----------------------------------------\n\nTITLE: Plucking Values from Objects using Ramda and Remeda in TypeScript\nDESCRIPTION: This snippet shows how to extract values associated with a specific key from an object of objects. It compares Ramda's 'pluck' function with Remeda's 'mapValues' and 'prop' functions, demonstrating the equivalent operations in both libraries.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/mapping/ramda/pluck.md#2025-04-07_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst DATA = { a: { val: \"hello\" }, b: { val: \"world\" } };\n\n// Ramda\nR.pluck(\"val\", DATA); //=> { a: \"hello\", b: \"world\" };\n\n// Remeda\nmapValues(DATA, prop(\"val\"));\n```\n\n----------------------------------------\n\nTITLE: Implementing Floor Function in TypeScript for Remeda Library\nDESCRIPTION: This code snippet defines the floor function that rounds down a number to the nearest integer. It uses Math.floor() internally and handles both number and bigint types.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/mapping/lodash/floor.md#2025-04-07_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { purry } from \"../purry\";\n\n/**\n * Rounds down a number to the nearest integer.\n *\n * @param value - The number to round down.\n * @signature\n *    R.floor(value)\n * @example\n *    R.floor(3.78) // => 3\n *    R.floor(-2.1) // => -3\n * @dataFirst\n * @category Math\n */\nexport function floor(value: number): number;\nexport function floor(value: bigint): bigint;\n\n/**\n * Rounds down a number to the nearest integer.\n *\n * @param value - The number to round down.\n * @signature\n *    R.floor(value)\n * @example\n *    R.floor(3.78) // => 3\n *    R.floor(-2.1) // => -3\n * @dataFirst\n * @category Math\n */\nexport function floor(...args: [number] | [bigint]): number | bigint {\n  return purry(floor_, args);\n}\n\nfunction floor_(value: number): number;\nfunction floor_(value: bigint): bigint;\nfunction floor_(value: number | bigint): number | bigint {\n  if (typeof value === \"bigint\") {\n    return value;\n  }\n  return Math.floor(value);\n}\n```\n\n----------------------------------------\n\nTITLE: Using isDeepEqual as a Type Predicate in TypeScript Array Filtering\nDESCRIPTION: This example shows how the change from 'equals' to 'isDeepEqual' affects type inference when used in array filtering. The new 'isDeepEqual' function allows for more precise type narrowing in the result.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/v1-migration/equals.md#2025-04-07_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n// Was\nconst result = R.filter([] as (\"cat\" | \"dog\")[], R.equals(\"cat\"));\n//    ^? (\"cat\" | \"dog\")[]\n\n// Now\nconst result = R.filter([] as (\"cat\" | \"dog\")[], R.isDeepEqual(\"cat\"));\n//    ^? \"dog\"[]\n```\n\n----------------------------------------\n\nTITLE: Migrating from Indexed Variant in Remeda Find Function\nDESCRIPTION: Example showing how to migrate from the deprecated indexed variant to the standard find function, which now accepts index as a parameter by default.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/v1-migration/find.md#2025-04-07_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// Was\nfind.indexed([1, 2, 3], (item, index) => item + (index % 2) === 0);\n\n// Now\nfind([1, 2, 3], (item, index) => item + (index % 2) === 0);\n```\n\n----------------------------------------\n\nTITLE: Sampling Data with Remeda, Lodash, and Native JavaScript in TypeScript\nDESCRIPTION: This snippet demonstrates different ways to sample a single item from a data set using Remeda, Lodash, and native JavaScript methods. It includes examples of using Remeda's sample function with various extraction techniques, as well as pipe composition.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/mapping/lodash/sample.md#2025-04-07_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// Lodash\nsample(DATA);\n\n// Remeda\nonly(sample(DATA, 1 /* size */));\n\n// or with a pipe\npipe(DATA, sample(1 /* size */), only());\n\n// Or with native accessors\nsample(DATA, 1 /* size */)[0];\nsample(DATA, 1 /* size */).at(0)!;\nconst [result] = sample(DATA, 1 /* size */);\n```\n\n----------------------------------------\n\nTITLE: Calculating Product of Numbers in TypeScript using Remeda\nDESCRIPTION: Implements a function to calculate the product of all numbers in an array. It uses reduce to multiply all elements together, with an initial value of 1. The function handles empty arrays by returning 1.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/mapping/ramda/product.md#2025-04-07_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { reduce } from \"./reduce\";\n\n/**\n * Calculates the product of an array of numbers.\n *\n * @param numbers - The array of numbers to calculate the product of.\n * @returns The product of all numbers in the array.\n * @example\n *    product([1, 2, 3, 4]) // => 24\n *    product([]) // => 1\n */\nexport const product = (numbers: number[]): number =>\n  reduce(numbers, (a, b) => a * b, 1);\n```\n\n----------------------------------------\n\nTITLE: Implementing Round Function in TypeScript for Remeda Library\nDESCRIPTION: This code snippet defines a round function that takes a number and an optional precision parameter. It rounds the given number to the specified number of decimal places. The function uses Math.round and multiplication/division to achieve precise rounding.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/mapping/lodash/round.md#2025-04-07_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { _ } from './_';\n\n/**\n * Rounds a number to a specified number of decimal places.\n *\n * @param n - The number to round.\n * @param precision - The number of decimal places to round to. Defaults to 0.\n * @returns The rounded number.\n * @example\n *    R.round(3.14159, 2) // => 3.14\n *    R.round(3.14159) // => 3\n *    R.round(3.14159, -1) // => 0\n */\nexport function round(n: number, precision = 0): number;\nexport function round(_: Placeholder, precision?: number): (n: number) => number;\nexport function round(n: number | Placeholder, precision = 0) {\n  return _.isPlaceholder(n)\n    ? (m: number) => round(m, precision)\n    : Math.round(n * 10 ** precision) / 10 ** precision;\n}\n```\n\n----------------------------------------\n\nTITLE: Avoiding Callback Reference Bugs in Remeda Find\nDESCRIPTION: Example showing a potential bug when using function references with the updated find function, which now passes additional parameters (index and array). Includes the recommended fix.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/v1-migration/find.md#2025-04-07_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nfunction callback(value: number, index = 0): boolean {\n  return (value + index) % 2 === 0;\n}\n\n// Bug\nfind([1, 2, 3], callback); // => undefined, Was: 2\n\n// Fix\nfind([1, 2, 3], (item) => callback(item)); // => 2\n```\n\n----------------------------------------\n\nTITLE: Migrating from Indexed Variant in Remeda's Filter Method\nDESCRIPTION: Example showing how to migrate from the removed indexed variant to the standard filter implementation. The predicate function can still access the index parameter without requiring the indexed variant.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/v1-migration/filter.md#2025-04-07_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// Was\nfilter.indexed([1, 2, 3], (item, index) => item + (index % 2) === 0);\n\n// Now\nfilter([1, 2, 3], (item, index) => item + (index % 2) === 0);\n```\n\n----------------------------------------\n\nTITLE: Replacing noop with doNothing for Void Returns in Remeda\nDESCRIPTION: Demonstrates how to replace the deprecated 'noop' function with 'doNothing()' when the function should return void, as shown in a forEach example.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/v1-migration/noop.md#2025-04-07_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// Was\nforEach(DATA, noop);\n\n// Now\nforEach(DATA, doNothing());\n```\n\n----------------------------------------\n\nTITLE: Defining and Implementing Number Clamping Function in TypeScript\nDESCRIPTION: This snippet defines a 'clamp' function that takes a number and constrains it within a specified range. It includes type definitions for the function parameters and return value, as well as the implementation logic.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/mapping/lodash/clamp.md#2025-04-07_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ntype Clamp = {\n  (min: number, max: number): (value: number) => number\n  (min: number, max: number, value: number): number\n}\n\nexport const clamp: Clamp = (min: number, max: number, value?: number) => {\n  if (value === undefined) {\n    return (value: number) => Math.min(Math.max(value, min), max)\n  }\n  return Math.min(Math.max(value, min), max)\n}\n```\n\n----------------------------------------\n\nTITLE: Converting Ramda's tail to Remeda's drop for Arrays in TypeScript\nDESCRIPTION: Demonstrates how to replace Ramda's tail function with Remeda's drop function for arrays. The drop function requires an explicit argument of 1 to achieve the same functionality as tail.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/mapping/ramda/tail.md#2025-04-07_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// Ramda\ntail([1, 2, 3]);\n\n// Remeda\ndrop([1, 2, 3], 1);\n```\n\n----------------------------------------\n\nTITLE: Using Clamp Function in Remeda\nDESCRIPTION: Example demonstrating how to use the clamp function to constrain a number within a specified range. The function ensures that a value is not less than a specified minimum or greater than a specified maximum.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/mapping/ramda/clamp.md#2025-04-07_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { clamp } from 'remeda';\n\nclamp(10, 1, 5); // => 5\nclamp(1, 5, 10); // => 5\nclamp(5, 1, 10); // => 5\n```\n\n----------------------------------------\n\nTITLE: Using Extended Parameters in Remeda's fromKeys Function\nDESCRIPTION: Example demonstrating how to use the new index parameter that was previously unavailable in Remeda's predicate functions.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/v1-migration/fromKeys.md#2025-04-07_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// This was previously unavailable\nfromKeys([\"a\", \"b\", \"c\"], (item, index) => `${item}${index}`);\n```\n\n----------------------------------------\n\nTITLE: Migrating from indexed variant in Remeda's sortedIndexWith function\nDESCRIPTION: Example showing how to migrate from the removed 'indexed' variant to the base implementation in Remeda library. The base implementation now takes the same parameters as the previously separate indexed variant.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/v1-migration/sortedIndexWith.md#2025-04-07_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// Was\nsortedIndexWith.indexed(array, predicate);\n\n// Now\nsortedIndexWith(array, predicate);\n```\n\n----------------------------------------\n\nTITLE: Implementing findLastIndex function in TypeScript\nDESCRIPTION: This code snippet defines the findLastIndex function, which searches an array from right to left and returns the index of the last element that satisfies the given predicate. If no element is found, it returns -1.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/mapping/lodash/findLastIndex.md#2025-04-07_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { purry } from '../purry';\n\n/**\n * Returns the index of the last element in the array where predicate is true, and -1 otherwise.\n * @param array The array to search.\n * @param predicate The predicate function.\n * @signature\n *    R.findLastIndex(array, predicate)\n * @example\n *    R.findLastIndex([1, 2, 3, 4], x => x % 2 === 1) // => 2\n *    R.findLastIndex([1, 2, 3, 4], x => x > 4) // => -1\n * @data_first\n * @category Array\n */\nexport function findLastIndex<T>(\n  array: readonly T[],\n  predicate: (item: T) => boolean\n): number;\n\n/**\n * Returns the index of the last element in the array where predicate is true, and -1 otherwise.\n * @param predicate The predicate function.\n * @signature\n *    R.findLastIndex(predicate)(array)\n * @example\n *    R.pipe([1, 2, 3, 4], R.findLastIndex(x => x % 2 === 1)) // => 2\n *    R.pipe([1, 2, 3, 4], R.findLastIndex(x => x > 4)) // => -1\n * @data_last\n * @category Array\n */\nexport function findLastIndex<T>(\n  predicate: (item: T) => boolean\n): (array: readonly T[]) => number;\n\nexport function findLastIndex() {\n  return purry(_findLastIndex, arguments);\n}\n\nfunction _findLastIndex<T>(\n  array: readonly T[],\n  predicate: (item: T) => boolean\n): number {\n  for (let i = array.length - 1; i >= 0; i--) {\n    if (predicate(array[i])) {\n      return i;\n    }\n  }\n  return -1;\n}\n```\n\n----------------------------------------\n\nTITLE: Converting Ramda's tail to Remeda's sliceString for Strings in TypeScript\nDESCRIPTION: Shows how to replace Ramda's tail function with Remeda's sliceString function for string operations. For string operations, Remeda recommends using sliceString instead of drop.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/mapping/ramda/tail.md#2025-04-07_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n// Ramda\ntail(\"abc\");\n\n// Remeda\nsliceString(\"abc\", 1);\n```\n\n----------------------------------------\n\nTITLE: Comparing Ramda max Function with Native JavaScript Alternatives in TypeScript\nDESCRIPTION: Demonstrates how to use Ramda's max function in both standard and curried form, compared with native JavaScript alternatives. The Ramda function takes exactly 2 arguments to find the maximum value, while the native approach uses the ternary operator.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/mapping/ramda/max.md#2025-04-07_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// Ramda\nmax(a, b);\n\n// Curried\nconst maxA = max(a);\n\n// Native\na > b ? a : b;\n\nconst maxA = (b: number) => (a > b ? a : b);\n```\n\n----------------------------------------\n\nTITLE: Migrating from Indexed Variant in TypeScript\nDESCRIPTION: Demonstrates the removal of the .indexed variant from the API, showing how to update existing code to use the base implementation which now accepts the same parameters.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/v1-migration/sortedLastIndexBy.md#2025-04-07_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// Was\nsortedLastIndexBy.indexed(array, mapper);\n\n// Now\nsortedLastIndexBy(array, mapper);\n```\n\n----------------------------------------\n\nTITLE: Improved Type Inference in TypeScript\nDESCRIPTION: Demonstrates improved type inference with tuple types, showing how the function now preserves the shape of the input array in the return type.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/v1-migration/map.md#2025-04-07_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst DATA = [\"hello\"] as [string, ...string[]];\n\nconst mapped = map(DATA, (item) => item.length);\n//    ^? [number, ...number[]], Was: number[]\n```\n\n----------------------------------------\n\nTITLE: Handling parseInt Bug in TypeScript\nDESCRIPTION: Illustrates a potential bug when using parseInt directly as a mapper function and shows the correct way to implement the parseInt mapping.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/v1-migration/map.md#2025-04-07_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nconst DATA = [\"1\", \"2\", \"3\"];\n\n// Bug\nmap(DATA, parseInt); // => [1, NaN, NaN], Was: [1, 2, 3]\n\n// Fix\nmap(DATA, (raw) => parseInt(raw)); // => [1, 2, 3]\n```\n\n----------------------------------------\n\nTITLE: Comparing Remeda and Lodash Intersection (No Duplicates)\nDESCRIPTION: Demonstrates the usage of the intersection function in both Remeda and Lodash for arrays without duplicate values. In this case, both libraries produce the same result.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/mapping/lodash/intersection.md#2025-04-07_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// Lodash\nintersection([2, 1], [2, 3]);\n\n// Remeda\nintersection([2, 1], [2, 3]);\n```\n\n----------------------------------------\n\nTITLE: Implementing takeLastWhile Function in TypeScript for Remeda\nDESCRIPTION: This code snippet defines the takeLastWhile function, which takes an array and a predicate function as arguments. It returns a new array containing elements from the end of the input array that satisfy the predicate condition.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/mapping/ramda/takeLastWhile.md#2025-04-07_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { _ } from './';\n\nexport function takeLastWhile<T>(\n  array: ReadonlyArray<T>,\n  predicate: (item: T) => boolean\n): T[];\n\nexport function takeLastWhile<T>(\n  predicate: (item: T) => boolean\n): (array: ReadonlyArray<T>) => T[];\n\nexport function takeLastWhile() {\n  return _((array, predicate) => {\n    if (array.length === 0) {\n      return [];\n    }\n    const result: T[] = [];\n    for (let i = array.length - 1; i >= 0; i--) {\n      if (predicate(array[i])) {\n        result.unshift(array[i]);\n      } else {\n        break;\n      }\n    }\n    return result;\n  });\n}\n```\n\n----------------------------------------\n\nTITLE: Finding Minimum Value with Lodash vs Remeda in TypeScript\nDESCRIPTION: Demonstrates how to find the minimum value in a collection using Lodash's 'min' function compared to Remeda's 'firstBy' function with identity. The identity function is used as the criteria to evaluate each element directly.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/mapping/lodash/min.md#2025-04-07_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// Lodash\nmin(DATA);\n\n// Remeda\nfirstBy(DATA, identity());\n```\n\n----------------------------------------\n\nTITLE: Migrating from Strict Variant to Default in Remeda's entries Function\nDESCRIPTION: Shows how to migrate from the previously required strict variant to the new default implementation that provides the same strict typing.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/v1-migration/entries.md#2025-04-07_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// Was\nentries.strict(obj);\n\n// Now\nentries(obj);\n```\n\n----------------------------------------\n\nTITLE: Handling Symbol Keys in Object Entries\nDESCRIPTION: Illustrates how the entries function now filters out symbol keys from the return type, only including string keys in the resulting array.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/v1-migration/entries.md#2025-04-07_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst mySymbol = Symbol(\"a\");\n\n// Was\nconst result = entries.strict({ [mySymbol]: 123, a: 456 } as const);\n//    ^? ([typeof mySymbol, 123] | [a, 456])[]\n\n// Now\nconst result = entries({ [mySymbol]: 123, a: 456 } as const);\n//    ^? ['a', 456][]\n```\n\n----------------------------------------\n\nTITLE: Using dropWhile Function in Remeda for Array Manipulation\nDESCRIPTION: The dropWhile function removes elements from the beginning of an array as long as the predicate function returns true. It stops and returns the remaining elements once the predicate returns false for an element.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/mapping/lodash/dropWhile.md#2025-04-07_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { dropWhile } from 'remeda';\n\ndropWhile([1, 2, 3, 4, 3, 2, 1], x => x < 3);\n// => [3, 4, 3, 2, 1]\n\ndropWhile([1, 2, 3, 4, 3, 2, 1], x => x < 10);\n// => []\n```\n\n----------------------------------------\n\nTITLE: Implementing Ceil Function in TypeScript for Remeda\nDESCRIPTION: This code snippet defines the 'ceil' function in Remeda, which rounds a number up to the nearest integer. It includes type declarations for both curried and non-curried versions of the function.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/mapping/lodash/ceil.md#2025-04-07_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { purry } from \"../purry\";\n\n/**\n * Rounds up a number to the nearest integer.\n *\n * @param value - The number to round up.\n * @signature\n *    R.ceil(value)\n * @example\n *    R.ceil(4.2) // => 5\n *    R.ceil(4.7) // => 5\n *    R.ceil(-4.2) // => -4\n * @data_first\n * @category Math\n */\nexport function ceil(value: number): number;\n\n/**\n * Rounds up a number to the nearest integer.\n *\n * @param value - The number to round up.\n * @signature\n *    R.ceil(value)\n * @example\n *    R.ceil(4.2) // => 5\n *    R.ceil(4.7) // => 5\n *    R.ceil(-4.2) // => -4\n * @data_last\n * @category Math\n */\nexport function ceil(): (value: number) => number;\n\nexport function ceil(...args: Array<any>): unknown {\n  return purry(Math.ceil, args);\n}\n```\n\n----------------------------------------\n\nTITLE: Comparing Remeda firstBy with Ramda minBy in TypeScript\nDESCRIPTION: This code snippet demonstrates the difference between Ramda's minBy function and Remeda's firstBy function. The firstBy function returns what would be the first item if the array was sorted by the given criteria without performing a full sort operation.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/mapping/ramda/minBy.md#2025-04-07_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// Ramda\nminBy(mapperFunc, a, b);\n\n// Remeda\nfirstBy([a, b], mapperFunc);\n```\n\n----------------------------------------\n\nTITLE: TypeScript fromEntries with Number Keys Migration\nDESCRIPTION: Shows how to maintain type safety when using number keys with the new fromEntries implementation by explicitly typing the input array.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/v1-migration/fromEntries.md#2025-04-07_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst DATA = [\n  [123, \"a\"],\n  [456, \"b\"],\n] as const;\n\n// Was\nfromEntries(DATA);\n\n// Now\nfromEntries(DATA as [number, \"a\" | \"b\"][]);\n```\n\n----------------------------------------\n\nTITLE: Type Narrowing with FindLast Function\nDESCRIPTION: Demonstrates how the findLast function now properly narrows the return type when using type predicates, improving type safety in TypeScript.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/v1-migration/findLast.md#2025-04-07_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst result = findLast([1, \"a\"] as (string | number)[], isString);\n//    ^? string | undefined, Was: string | number | undefined\n```\n\n----------------------------------------\n\nTITLE: Handling Symbol Keys in Remeda's omitBy Function (TypeScript)\nDESCRIPTION: This snippet illustrates how omitBy now preserves properties with symbol keys in the output object. Previously, these properties were implicitly omitted, but now they are retained if they don't match the predicate.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/v1-migration/omitBy.md#2025-04-07_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst mySymbol = Symbol(\"a\");\nomitBy({ [mySymbol]: 123, a: \"hello\" }, isString); // => { [mySymbol]: 123 }, Was: {};\n```\n\n----------------------------------------\n\nTITLE: Implementing reduceRight functionality in Remeda using reduce and reverse\nDESCRIPTION: This snippet shows three different ways to achieve right-to-left reduction: first using Lodash's native reduceRight, then using Remeda's reverse and reduce functions together, and finally using Remeda's pipe function for a more functional approach. All approaches accomplish the same reduction from right to left on a data collection.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/mapping/lodash/reduceRight.md#2025-04-07_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// Lodash\nreduceRight(DATA, reducer, accumulator);\n\n// Remeda\nreduce(reverse(DATA), reducer, accumulator);\n\n// Or with a pipe\npipe(DATA, reverse(), reduce(reducer, accumulator));\n```\n\n----------------------------------------\n\nTITLE: Implementing Conditional Function Execution in TypeScript\nDESCRIPTION: The conditional function takes a predicate and two functions, executing one based on the predicate's result. It supports both curried and non-curried forms, allowing for flexible usage in functional programming patterns.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/mapping/lodash/cond.md#2025-04-07_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { purry } from \"./purry\";\n\n/**\n * Returns the result of `onTrue` if `pred` is true, otherwise `onFalse`.\n *\n * @param data - The input data.\n * @param pred - The predicate.\n * @param onTrue - The function to execute if predicate is true.\n * @param onFalse - The function to execute if predicate is false.\n * @signature\n *    R.conditional(pred, onTrue, onFalse)(data)\n *    R.conditional(data, pred, onTrue, onFalse)\n * @example\n *    R.conditional(true, () => 'True', () => 'False') // => 'True'\n *    R.conditional(false, () => 'True', () => 'False') // => 'False'\n *\n *    const pred = (x: number) => x > 0\n *    const onTrue = (x: number) => x + 1\n *    const onFalse = (x: number) => x - 1\n *    R.conditional(pred, onTrue, onFalse)(1) // => 2\n *    R.conditional(1, pred, onTrue, onFalse) // => 2\n *    R.conditional(-1, pred, onTrue, onFalse) // => -2\n * @category Util\n */\nexport function conditional<T, R>(\n  data: T,\n  pred: (data: T) => boolean,\n  onTrue: (data: T) => R,\n  onFalse: (data: T) => R\n): R;\nexport function conditional<T, R>(\n  pred: (data: T) => boolean,\n  onTrue: (data: T) => R,\n  onFalse: (data: T) => R\n): (data: T) => R;\nexport function conditional() {\n  return purry(_conditional, arguments);\n}\n\nfunction _conditional<T, R>(\n  data: T,\n  pred: (data: T) => boolean,\n  onTrue: (data: T) => R,\n  onFalse: (data: T) => R\n): R {\n  if (pred(data)) {\n    return onTrue(data);\n  } else {\n    return onFalse(data);\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Generating Random Integers with Single Parameter in Remeda vs. Lodash\nDESCRIPTION: Shows how Lodash can generate a random integer from 0 to a specified maximum with one parameter, while Remeda requires both min and max parameters.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/mapping/lodash/random.md#2025-04-07_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n// Lodash\nrandom(10);\n\n// Remeda\nrandomInteger(0, 10);\n```\n\n----------------------------------------\n\nTITLE: Symbol Key Removal in `mapValues` Function\nDESCRIPTION: Shows how symbol keys are now filtered out from the input object when using `mapValues`, resulting in a cleaner output type that only includes string keys.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/v1-migration/mapValues.md#2025-04-07_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst mySymbol = Symbol(\"a\");\n\nconst DATA = { [mySymbol]: \"hello\", a: 123 } as {\n  [mySymbol]: string;\n  a: number;\n};\n\nconst result = mapValues(DATA, constant(456));\n//    ^? { a: number }, Was: Record<symbol | \"a\", number>\n```\n\n----------------------------------------\n\nTITLE: Strict Keys Function Usage in TypeScript\nDESCRIPTION: Shows the transition from using strict variant to the new implementation where strict is the default behavior.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/v1-migration/keys.md#2025-04-07_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// Was\nkeys.strict(obj);\n\n// Now\nkeys(obj);\n```\n\n----------------------------------------\n\nTITLE: Filtering Collection Elements Using Remeda vs Lodash\nDESCRIPTION: Shows equivalent collection filtering between Lodash's reject() and Remeda's filter() with isNot() wrapper. The isNot wrapper inverts the predicate logic to match Lodash's reject functionality.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/mapping/lodash/reject.md#2025-04-07_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// Lodash\nreject(DATA, predicate);\n\n// Remeda\nfilter(DATA, isNot(predicate));\n```\n\n----------------------------------------\n\nTITLE: Using countBy Function in Remeda to Count Elements in a Collection\nDESCRIPTION: The countBy function takes a collection and a mapping function, then counts occurrences of items based on the key returned by the mapping function. It returns an object with keys as the mapped values and counts as the values.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/mapping/lodash/countBy.md#2025-04-07_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { countBy } from \"remeda\";\n\ncountBy([\"one\", \"two\", \"three\"], (x) => x.length); // → { \"3\": 2, \"5\": 1 }\ncountBy([{ n: 1 }, { n: 1 }, { n: 2 }], (x) => x.n); // → { \"1\": 2, \"2\": 1 }\n\n// Using pipe:\nimport { pipe } from \"remeda\";\n\npipe(\n  [\"one\", \"two\", \"three\"],\n  countBy((x) => x.length)\n); // → { \"3\": 2, \"5\": 1 }\n```\n\n----------------------------------------\n\nTITLE: Using join Function in Remeda for Array to String Conversion\nDESCRIPTION: This code snippet demonstrates how to use the join function in the Remeda library to convert an array of elements into a string with a specified separator. The function supports both pipe-style (data-first) and regular function call (data-last) approaches.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/mapping/lodash/join.md#2025-04-07_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { join, pipe } from 'remeda';\n\n// Data-first approach\njoin(['a', 'b', 'c'], '-'); // => 'a-b-c'\n\n// Data-last approach\npipe(['a', 'b', 'c'], join('-')); // => 'a-b-c'\n```\n\n----------------------------------------\n\nTITLE: Improved Type Inference for Object Keys\nDESCRIPTION: Demonstrates enhanced type inference where the returned type is more precise, showing exact key names instead of generic string array.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/v1-migration/keys.md#2025-04-07_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst result = keys({ a: 123 } as const);\n//    ^? \"a\"[], Was: string[]\n```\n\n----------------------------------------\n\nTITLE: Number Type Checking in TypeScript\nDESCRIPTION: Shows methods to verify if a value is a number using typeof operator or isNumber type guard.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/v1-migration/type.md#2025-04-07_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst DATA = 123;\n\n// Was\ntype(DATA) === \"Number\";\n\n// Now\ntypeof DATA === \"number\";\n\n// Or\nisNumber(DATA);\n```\n\n----------------------------------------\n\nTITLE: Headless Cloning Operations in TypeScript\nDESCRIPTION: Shows the updated syntax for cloning operations in map functions, where empty argument lists are now required instead of headless invocations.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/v1-migration/clone.md#2025-04-07_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n// Was\nconst cloned = map(DATA, clone);\n\n// Now\nconst cloned = map(DATA, clone());\n```\n\n----------------------------------------\n\nTITLE: Using mapKeys to Transform Object Keys with Remeda\nDESCRIPTION: Demonstrates using the mapKeys function to transform object keys by applying a mapping function to each key while preserving the values.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/mapping/lodash/mapKeys.md#2025-04-07_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { mapKeys } from 'remeda';\n\nconst user = { firstName: 'John', lastName: 'Doe' };\nconst result = mapKeys(user, key => key.toUpperCase());\n// => { FIRSTNAME: 'John', LASTNAME: 'Doe' }\n```\n\n----------------------------------------\n\nTITLE: Comparing Basic Array Difference Operations\nDESCRIPTION: Demonstrates the basic usage of difference operation without duplicates in both Lodash and Remeda libraries. Both implementations produce the same result in this case.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/mapping/lodash/difference.md#2025-04-07_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// Lodash\ndifference([2, 1], [2, 3]);\n\n// Remeda\ndifference([2, 1], [2, 3]);\n```\n\n----------------------------------------\n\nTITLE: Using Remeda split Function to Split Strings\nDESCRIPTION: The `split` function splits a string based on a separator and returns an array of substrings. It works similarly to the native String.prototype.split but is designed to work with Remeda's functional programming paradigm.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/mapping/ramda/split.md#2025-04-07_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n---\ncategory: String\nremeda: split\n---\n```\n\n----------------------------------------\n\nTITLE: Fixing parseInt Reference Bug in Array Mapping\nDESCRIPTION: Demonstrates a potential bug when using parseInt as a direct function reference and shows the correct way to implement it using an arrow function wrapper.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/v1-migration/meanBy.md#2025-04-07_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n// Bug\nmeanBy([\"1\", \"2\", \"3\"], parseInt); // => Nan, Was: 2\n\n// Fix\nmeanBy([\"1\", \"2\", \"3\"], (item) => parseInt(item)); // => 2\n```\n\n----------------------------------------\n\nTITLE: Replacing dataLast indexed flatMapToObj with pipe, flatMap, and fromEntries (TypeScript)\nDESCRIPTION: This example demonstrates how to replace the dataLast indexed version of flatMapToObj using pipe, flatMap, and fromEntries. It creates an object with array elements as keys and their indices as values, along with duplicated keys and summed indices.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/v1-migration/flatMapToObj.md#2025-04-07_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\n// Was\nR.pipe(\n  [\"a\", \"b\"],\n  R.flatMapToObj.indexed((x, i) => [\n    [x, i],\n    [x + x, i + i],\n  ]),\n);\n\n// Now\npipe(\n  [1, 2, 3],\n  flatMap((x, i) => [\n    [x, i],\n    [x + x, i + i],\n  ]),\n  fromEntries(),\n);\n```\n\n----------------------------------------\n\nTITLE: Implementing dropLastWhile Function in JavaScript\nDESCRIPTION: The dropLastWhile function removes elements from the end of an array as long as they satisfy a given predicate. It returns a new array with the remaining elements. The function supports both curried and non-curried usage.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/mapping/lodash/dropRightWhile.md#2025-04-07_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { purry } from '../purry';\n\n/**\n * Creates a slice of `array` excluding elements dropped from the end.\n * Elements are dropped until `predicate` returns falsey.\n *\n * @param array - The array to query.\n * @param predicate - The function invoked per iteration.\n * @signature\n *    R.dropLastWhile(array, predicate)\n * @example\n *    R.dropLastWhile([1, 2, 3, 4, 5], (n) => n < 3) // => [1, 2, 3]\n * @dataFirst\n * @category Array\n */\nexport function dropLastWhile<T>(\n  array: T[],\n  predicate: (value: T) => boolean\n): T[];\n\n/**\n * Creates a slice of `array` excluding elements dropped from the end.\n * Elements are dropped until `predicate` returns falsey.\n *\n * @param predicate - The function invoked per iteration.\n * @signature\n *    R.dropLastWhile(predicate)(array)\n * @example\n *    R.dropLastWhile((n) => n < 3)([1, 2, 3, 4, 5]) // => [1, 2, 3]\n * @dataLast\n * @category Array\n */\nexport function dropLastWhile<T>(\n  predicate: (value: T) => boolean\n): (array: T[]) => T[];\n\nexport function dropLastWhile(...args: any[]) {\n  return purry(_dropLastWhile, args);\n}\n\nfunction _dropLastWhile<T>(array: T[], predicate: (value: T) => boolean) {\n  for (let i = array.length - 1; i >= 0; i--) {\n    if (!predicate(array[i])) {\n      return array.slice(0, i + 1);\n    }\n  }\n  return [];\n}\n```\n\n----------------------------------------\n\nTITLE: Handling Array Differences with Duplicates\nDESCRIPTION: Shows how to handle array differences when dealing with duplicate values. Demonstrates Lodash's approach and Remeda's alternative using filter, isNot, and isIncludedIn functions.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/mapping/lodash/difference.md#2025-04-07_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n// Lodash\ndifference([1, 1, 2, 2], [1]);\n\n// Remeda\nfilter([1, 1, 2, 2], isNot(isIncludedIn([1])));\n```\n\n----------------------------------------\n\nTITLE: Comparing toCamelCase in Remeda vs camelCase in Lodash\nDESCRIPTION: This example demonstrates the difference between Remeda's toCamelCase and Lodash's camelCase functions. It shows how Remeda preserves consecutive uppercase letters by default, while Lodash converts them to lowercase. Remeda provides an optional configuration parameter to match Lodash's behavior if needed.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/mapping/lodash/camelCase.md#2025-04-07_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// Lodash\ncamelCase(\"HasHTML\"); // \"hasHtml\"\n\n// Remeda\ntoCamelCase(\"HasHTML\"); // \"hasHTML\";\n\ntoCamelCase(\"HasHTML\", { preserveConsecutiveUppercase: true }); // \"hasHTML\";\ntoCamelCase(\"HasHTML\", { preserveConsecutiveUppercase: false }); // \"hasHtml\";\n```\n\n----------------------------------------\n\nTITLE: Handling Potential Bugs with Function References in Remeda\nDESCRIPTION: Illustrates a potential bug when using function references with default parameters as predicates in Remeda functions. Shows both the problematic approach and the recommended fix using an inline arrow function wrapper.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/v1-migration/takeWhile.md#2025-04-07_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nfunction callback(item: number, index = 0): string {\n  return item > index;\n}\n\n// Bug\ntakeWhile([1, 1, 1], callback); // => [1, 1, 1], Was: [1]\n\n// Fix\ntakeWhile([1, 1, 1], (item) => callback(item)); // => [1]\n```\n\n----------------------------------------\n\nTITLE: MapKeys with Symbol and Number Keys Typing in TypeScript\nDESCRIPTION: Demonstrates the improved typing of mapKeys where symbol keys are no longer accepted and number keys are cast as strings, aligning with Object.entries behavior.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/v1-migration/mapKeys.md#2025-04-07_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst mySymbol = Symbol(\"a\");\nmapKeys({ [mySymbol]: \"hello\", a: 123, 456: true }, (key, value) => {\n  // key: \"a\" | \"456\", Was symbol | \"a\" | 456;\n  // value: number | boolean, Was string | number | boolean;\n});\n```\n\n----------------------------------------\n\nTITLE: Migrating from uniq to unique Function in TypeScript\nDESCRIPTION: Shows the before and after usage of the renamed function, demonstrating how to update code from using uniq to unique function\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/v1-migration/uniq.md#2025-04-07_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// Was\nuniq(data);\n\n// Now\nunique(data);\n```\n\n----------------------------------------\n\nTITLE: Advanced Sample Operation with Shuffle - Remeda vs Lodash\nDESCRIPTION: Shows how to handle multiple item sampling in both libraries, highlighting that Remeda maintains original order and requires explicit shuffle for randomization. Includes pipe operation example.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/mapping/lodash/sampleSize.md#2025-04-07_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n// Lodash\nsampleSize(DATA, 2);\n\n// Remeda\n// ❌ The result isn't shuffled!\nsample(DATA, 2);\n\n// ✅ Add `shuffle` after `sample` (if order is important).\nshuffle(sample(DATA, 2));\n\n// Or with a pipe\npipe(DATA, sample(2), shuffle());\n```\n\n----------------------------------------\n\nTITLE: Implementing flatMapDeep Using Remeda map and flat Functions\nDESCRIPTION: Demonstrates three different ways to achieve deep flat mapping: using Lodash's native flatMapDeep, using Remeda's composed functions, and using Remeda's pipe syntax. The implementation uses a fixed depth parameter for flattening.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/mapping/lodash/flatMapDeep.md#2025-04-07_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// Lodash\nflatMapDeep(DATA, mappingFunction);\n\n// Remeda\nflat(map(DATA, mappingFunction), 10 /* depth */);\n\n// Or as a pipe\npipe(DATA, map(mappingFunction), flat(10 /* depth */));\n```\n\n----------------------------------------\n\nTITLE: String Inclusion Check - Typescript\nDESCRIPTION: Shows string inclusion checking using Remeda's includes and native JavaScript string includes method.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/mapping/ramda/includes.md#2025-04-07_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst DATA = \"Hello, World!\";\n\n// Remeda\nincludes(\"lo\", DATA);\n\n// Native\nDATA.includes(\"lo\");\n```\n\n----------------------------------------\n\nTITLE: Using Index Parameter with uniqueBy in TypeScript\nDESCRIPTION: Example demonstrating how to use the new index parameter in mapper functions, which was previously unavailable. This allows operations that depend on both the item value and its position in the array.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/v1-migration/uniqueBy.md#2025-04-07_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// This was previously unavailable\nuniqueBy([1, 2, 3], (item, index) => item - index);\n```\n\n----------------------------------------\n\nTITLE: Handling Symbol Keys in TypeScript Values Function\nDESCRIPTION: Demonstrates the updated typing behavior for symbol keys in objects, where symbol values are correctly excluded from the return type inference.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/v1-migration/values.md#2025-04-07_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst mySymbol = Symbol(\"a\");\nconst result = values({ [mySymbol]: 123, a: \"hello\" });\n//    ^? string[], Was: (string | number)[]\n```\n\n----------------------------------------\n\nTITLE: Implementing zipWith Function in JavaScript\nDESCRIPTION: The zipWith function takes a combining function and multiple arrays as arguments. It applies the function to corresponding elements from each array, creating a new array of results. The function stops when the shortest input array is exhausted.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/mapping/lodash/zipWith.md#2025-04-07_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport { zipWith } from 'remeda';\n\nconst addMul = (a, b, c) => a + b * c;\nconst result = zipWith([1, 2, 3], [4, 5, 6], [7, 8], addMul);\nconsole.log(result); // [29, 42]\n```\n\n----------------------------------------\n\nTITLE: Example Usage of 'invert' Function in TypeScript\nDESCRIPTION: This snippet demonstrates how to use the 'invert' function with and without a callback. It shows inverting an object with duplicate values and using a custom callback to transform the keys.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/mapping/lodash/invert.md#2025-04-07_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nR.invert({ 'a': 1, 'b': 2, 'c': 1 }) // => { '1': 'c', '2': 'b' }\nR.invert({ 'a': 1, 'b': 2, 'c': 1 }, (num) => `${num}`) // => { '1': 'c', '2': 'b' }\n```\n\n----------------------------------------\n\nTITLE: Object Inclusion Check - Typescript\nDESCRIPTION: Demonstrates checking for object inclusion in an array using Ramda's includes and Remeda's isDeepEqual with Array.some().\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/mapping/ramda/includes.md#2025-04-07_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst DATA = [{ name: \"Fred\" }];\n\n// Ramda\nincludes({ name: \"Fred\" }, DATA);\n\n// Remeda\nDATA.some(isDeepEqual({ name: \"Fred\" }));\n```\n\n----------------------------------------\n\nTITLE: Converting Object to Entries using DataLast Approach in TypeScript\nDESCRIPTION: Shows how to use the entries function in a pipe operation with the dataLast approach, replacing the previous toPairs implementation.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/v1-migration/toPairs.md#2025-04-07_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst DATA = { a: \"b\", c: \"d\" } as const;\n\n// Was\nconst result = pipe(DATA, toPairs);\n//    ^? [string, \"b\" | \"d\"][]\n\n// Now\nconst result = pipe(DATA, entries());\n//    ^? ([\"a\", \"b\"] | [\"c\", \"d\"])[]\n```\n\n----------------------------------------\n\nTITLE: Using Strict Variant of Entries Function in TypeScript\nDESCRIPTION: Illustrates the migration from the strict variant of toPairs to the standard entries function, showing that the strict variant is no longer needed.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/v1-migration/toPairs.md#2025-04-07_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst DATA = { a: \"b\", c: \"d\" } as const;\n\n// Was\ntoPairs.strict(DATA);\n\n// Now\nentries(DATA);\n```\n\n----------------------------------------\n\nTITLE: Using New Index Parameter in Remeda Mapper Functions\nDESCRIPTION: Example showing how to use the newly available index parameter in Remeda's pullObject function, which was previously unavailable in earlier versions.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/v1-migration/pullObject.md#2025-04-07_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\npullObject(\n  [1, 2, 3],\n  // This was previously unavailable\n  (item, index) => item + index,\n  (item, index) => index + item,\n);\n```\n\n----------------------------------------\n\nTITLE: Unsupported Floating-Point Number Cases in Lodash\nDESCRIPTION: Shows Lodash examples using floating-point numbers or the 'floating' parameter that are not supported in Remeda's randomInteger function.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/mapping/lodash/random.md#2025-04-07_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nrandom(1.5, 3.5);\nrandom(1.5);\nrandom(10, true);\nrandom(5, 10, true);\nrandom(true);\n```\n\n----------------------------------------\n\nTITLE: Basic Array Sorting with Map\nDESCRIPTION: Demonstrates how to use Remeda's map function to sort nested arrays, replacing Lodash's invokeMap with no arguments.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/mapping/lodash/invokeMap.md#2025-04-07_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// Lodash\ninvokeMap(\n  [\n    [5, 1, 7],\n    [3, 2, 1],\n  ],\n  \"sort\",\n);\n\n// Remeda\nmap(\n  [\n    [5, 1, 7],\n    [3, 2, 1],\n  ],\n  (array) => array.sort(),\n);\n```\n\n----------------------------------------\n\nTITLE: Checking Object Value Inclusion with Remeda and Lodash\nDESCRIPTION: Shows how to check if a value is included in an object using Remeda's isIncludedIn function with values, compared to Lodash's includes method.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/mapping/lodash/includes.md#2025-04-07_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n// Lodash\nincludes({ a: 1, b: 2 }, 1);\n\n// Remeda\nisIncludedIn(1, values({ a: 1, b: 2 }));\n```\n\n----------------------------------------\n\nTITLE: Refactoring Purry Function Calls with Namespace Pattern in TypeScript\nDESCRIPTION: Demonstrates how to change from using TypeScript namespaces to attach lazy implementations to explicitly passing the lazy implementation as a parameter to purry calls.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/v1-migration/purry.md#2025-04-07_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nfunction myFunc(...args: readonly unknown[]): unknown {\n  // Was:\n  return purry(dataFirstImpl, args);\n\n  // Now:\n  return purry(dataFirstImpl, args, lazyImpl);\n}\n\nfunction dataFirstImpl(...) {\n  // ...\n}\n\n// This can be removed now:\nnamespace dataFirstImpl {\n  export const lazy = lazyImpl;\n}\n\nfunction lazyImpl(...): LazyEvaluator {\n  // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Replacing flatten() and flattenDeep() with flat()\nDESCRIPTION: Demonstrates the replacement of flatten() and flattenDeep() functions with the more versatile flat() function, which accepts an optional depth parameter.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/docs-articles/v1/migration-removed.md#2025-04-07_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n// Was\nflatten(DATA);\nflattenDeep(DATA);\n\n// Now\nflat(DATA);\nflat(DATA, 10);\n```\n\n----------------------------------------\n\nTITLE: Accessing Array Elements in TypeScript (Remeda vs Lodash vs Native)\nDESCRIPTION: Demonstrates various methods to access array elements, including first, last, and arbitrary indices. It compares Remeda functions with Lodash and native JavaScript methods.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/mapping/lodash/nth.md#2025-04-07_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// Lodash\nnth(DATA);\nnth(DATA, 0);\n\n// Remeda\nfirst(DATA);\n\n// Lodash\nnth(DATA, 1);\n\n// Native\nDATA[1];\nDATA.at(1);\n\n// Lodash\nnth(DATA, -1);\n\n// Remeda\nlast(DATA);\n\n// Lodash\nnth(DATA, -2);\n\n// Native\nDATA.at(-2);\n```\n\n----------------------------------------\n\nTITLE: Checking for Error Objects with Remeda isError Function in TypeScript\nDESCRIPTION: The isError function from Remeda checks if the provided value is an instance of the Error object. It returns true for Error objects and false for other types.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/mapping/lodash/isError.md#2025-04-07_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { isError } from 'remeda';\n\nisError(new Error()); // => true\nisError(new TypeError()); // => true\nisError('foo'); // => false\n```\n\n----------------------------------------\n\nTITLE: Replicating Lodash includes with fromIndex (Non-negative) in Remeda\nDESCRIPTION: Shows how to replicate Lodash's includes method with a non-negative fromIndex using Remeda's isIncludedIn function combined with drop.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/mapping/lodash/includes.md#2025-04-07_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\n// Lodash\nincludes([1, 2, 3], 1, 2);\n\n// Remeda\nisIncludedIn(1, drop([1, 2, 3], 2));\n```\n\n----------------------------------------\n\nTITLE: Accessing Object Properties in JavaScript\nDESCRIPTION: Demonstrates that number keys are cast as strings in JavaScript object property access. This behavior remains unchanged in Remeda v2, but typing has been updated to reflect it.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/docs-articles/v1/migration-keys.md#2025-04-07_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nmyObj[0] === myObj[\"0\"]\n```\n\n----------------------------------------\n\nTITLE: Retrieving and Updating data.json in Remeda Project\nDESCRIPTION: This snippet outlines the command-line steps to checkout the latest v1 tag or branch, generate the typedoc documentation, and manually copy the data.json file to the correct location in the project.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/functions/v1/README.md#2025-04-07_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit checkout <the latest v1 tag or branch>\ncd docs\nnpm run typedoc\n```\n\n----------------------------------------\n\nTITLE: Type Inference Comparison\nDESCRIPTION: Shows how Remeda provides better type inference compared to built-in array methods by preserving tuple types.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/pages/index.mdx#2025-04-07_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst DATA = [1, 2, 3] as const;\n\nconst builtin = DATA.map((x) => x.toString());\n//    ^? string[]\n\nconst withRemeda = R.map(DATA, (x) => x.toString());\n//    ^? [string, string, string]\n```\n\n----------------------------------------\n\nTITLE: Implementing No-Op Functions in TypeScript with Lodash and Remeda\nDESCRIPTION: This snippet demonstrates how to create no-op functions in TypeScript using both Lodash and Remeda libraries. It shows Lodash's 'noop' function and Remeda's 'constant(undefined)' and 'doNothing()' functions. The 'constant(undefined)' is used when a return value is needed, while 'doNothing()' is used when no return value is required.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/mapping/lodash/noop.md#2025-04-07_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// Lodash\nnoop;\n\n// Remeda\nconstant(undefined);\ndoNothing();\n```\n\n----------------------------------------\n\nTITLE: Comparing Lodash max() and Remeda firstBy() Usage\nDESCRIPTION: Demonstrates how to find the maximum value in a dataset using both Lodash and Remeda approaches. The Remeda implementation uses the identity function as criteria and 'desc' as sort direction to achieve the same result as Lodash's max function.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/mapping/lodash/max.md#2025-04-07_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// Lodash\nmax(DATA);\n\n// Remeda\nfirstBy(DATA, [identity(), \"desc\"]);\n```\n\n----------------------------------------\n\nTITLE: String First Character Extraction - TypeScript\nDESCRIPTION: Demonstrates different approaches to extracting the first character from a string. Ramda uses head() while Remeda recommends using sliceString() with explicit start and end indices.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/mapping/ramda/head.md#2025-04-07_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n// Ramda\nhead(\"abc\");\n\n// Remeda\nsliceString(\"abc\", 0, 1);\n```\n\n----------------------------------------\n\nTITLE: Data Transformation Pipeline Comparison\nDESCRIPTION: Compares data transformation pipelines between Remeda, Ramda, Lodash, and lodash/fp, highlighting type inference advantages.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/pages/index.mdx#2025-04-07_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nconst DATA = [\n  { name: \"john\", age: 20, gender: \"m\" },\n  { name: \"marry\", age: 22, gender: \"f\" },\n  { name: \"samara\", age: 24, gender: \"f\" },\n  { name: \"paula\", age: 24, gender: \"f\" },\n  { name: \"bill\", age: 33, gender: \"m\" },\n];\n\n// Remeda\nR.pipe(\n  DATA,\n  R.filter((x) => x.gender === \"f\"),\n  R.groupBy((x) => x.age),\n);\n\n// Ramda\nR.pipe(\n  R.filter((x) => x.gender === \"f\"),\n  //              ^? 😔 'x' is of type 'unknown'\n  R.groupBy((x) => x.age),\n  //                 ^? 😔 Property 'age' does not exist on type 'P'\n)(DATA);\n\n// Lodash\n_(DATA)\n  .filter((x) => x.gender === \"f\")\n  .groupBy((x) => x.age)\n  .value();\n\n// lodash/fp\n_.flow(\n  _.filter((x) => x.gender === \"f\"),\n  //              ^? 😔 'x' is of type 'unknown'\n  _.groupBy((x) => x.age),\n  //               ^? 😔 'x' is of type 'unknown'\n)(DATA);\n```\n\n----------------------------------------\n\nTITLE: Starting Development Server with Astro\nDESCRIPTION: Launches the development server with hot-module reloading for both documentation site changes and library source code updates.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/README.md#2025-04-07_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm run dev\n```\n\n----------------------------------------\n\nTITLE: Implementing firstBy Function in JavaScript\nDESCRIPTION: This function finds the first element in an array that satisfies a given predicate. It iterates through the array and returns the first element for which the predicate returns true. If no element satisfies the predicate, it returns undefined.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/mapping/lodash/minBy.md#2025-04-07_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { purry } from '../purry';\n\n/**\n * Finds the first element of `array` satisfying `predicate`.\n * @param array The array to search\n * @param predicate The predicate to apply to each element\n * @signature\n *   R.firstBy(array, predicate)\n * @example\n *   R.firstBy([1, 2, 3], x => x > 1) // => 2\n *   R.firstBy([1, 2, 3], x => x > 5) // => undefined\n * @data_first\n * @category Array\n */\nexport function firstBy<T>(array: T[], predicate: (item: T) => boolean): T | undefined;\n\n/**\n * Finds the first element of `array` satisfying `predicate`.\n * @param predicate The predicate to apply to each element\n * @signature\n *   R.firstBy(predicate)(array)\n * @example\n *   R.pipe([1, 2, 3], R.firstBy(x => x > 1)) // => 2\n *   R.pipe([1, 2, 3], R.firstBy(x => x > 5)) // => undefined\n * @data_last\n * @category Array\n */\nexport function firstBy<T>(predicate: (item: T) => boolean): (array: T[]) => T | undefined;\n\nexport function firstBy(...args: any[]) {\n  return purry(firstBy_, args);\n}\n\nfunction firstBy_<T>(array: T[], predicate: (item: T) => boolean): T | undefined {\n  for (let i = 0; i < array.length; i++) {\n    if (predicate(array[i])) {\n      return array[i];\n    }\n  }\n  return undefined;\n}\n```\n\n----------------------------------------\n\nTITLE: Comparing Partial Function Binding in Lodash, Remeda, and Native JavaScript\nDESCRIPTION: This snippet demonstrates how to partially bind function arguments using Lodash, Remeda, and native JavaScript. It highlights that Remeda does not support placeholder arguments, and suggests alternatives using partialLastBind or arrow functions.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/mapping/lodash/partial.md#2025-04-07_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nfunction greet(greeting, firstName, lastName) {\n  return greeting + \" \" + firstName + \" \" + lastName;\n}\n\n// Lodash\n_.partial(greet, _, \"john\", \"doe\");\n_.partial(greet, \"hi\", _, \"doe\");\n\n// Remeda\npartialLastBind(greet, \"john\", \"doe\");\n// (not supported)\n\n// Native\n(greeting) => greet(greeting, \"john\", \"doe\");\n(firstName) => greet(\"hi\", firstName, \"doe\");\n```\n\n----------------------------------------\n\nTITLE: Dropping Last Element from Arrays using Remeda\nDESCRIPTION: Shows how to remove the last element from an array using Remeda's dropLast function, which is equivalent to Ramda's init function. The function takes an array and the number of elements to drop (1 in this case).\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/mapping/ramda/init.md#2025-04-07_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// Ramda\ninit([1, 2, 3]);\n\n// Remeda\ndropLast([1, 2, 3], 1);\n```\n\n----------------------------------------\n\nTITLE: Type Operations Documentation in Markdown\nDESCRIPTION: Type checking and verification functions.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/mapping/ramda/__MISSING.md#2025-04-07_snippet_7\n\nLANGUAGE: markdown\nCODE:\n```\n# Type\n\n- type\n- is\n- propIs\n```\n\n----------------------------------------\n\nTITLE: List Operations Documentation in Markdown\nDESCRIPTION: Collection of list manipulation functions including array transformations, searches, and modifications.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/mapping/ramda/__MISSING.md#2025-04-07_snippet_1\n\nLANGUAGE: markdown\nCODE:\n```\n# List\n\n- adjust\n- all\n- any\n- aperture\n- collectBy\n- count\n- dropRepeats\n- dropRepeatsBy\n- dropRepeatsWith\n- endsWith\n- groupWith\n- indexOf\n- insert\n- insertAll\n- intersperse\n- into\n- lastIndexOf\n- mapAccumRight\n- move\n- none\n- pair\n- prepend\n- reduceBy\n- reduced\n- reduceRight\n- reduceWhile\n- remove\n- repeat\n- scan\n- sequence\n- splitEvery\n- splitWhenever\n- startsWith\n- transduce\n- transpose\n- traverse\n- unfold\n- unnest\n- update\n- without\n- xprod\n```\n\n----------------------------------------\n\nTITLE: Comparing Identity Function Usage in Lodash and Remeda\nDESCRIPTION: This snippet demonstrates the difference in using the identity function between Lodash and Remeda. In Remeda, the identity function is a factory that needs to be called to create an identity function, whereas in Lodash it can be used directly.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/mapping/lodash/identity.md#2025-04-07_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// Lodash\nmap(identity);\n\n// Remeda\nmap(identity());\n```\n\n----------------------------------------\n\nTITLE: Basic Sample Operation Comparison - Remeda vs Lodash\nDESCRIPTION: Demonstrates the basic usage difference between Lodash's sampleSize and Remeda's sample function. In Remeda, the size parameter is required, while in Lodash it defaults to 1.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/mapping/lodash/sampleSize.md#2025-04-07_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// Lodash\nsampleSize(DATA);\n\n// Remeda\nsample(DATA, 1);\n```\n\n----------------------------------------\n\nTITLE: Defining findLast Function in TypeScript with Remeda\nDESCRIPTION: This snippet defines the type signature for the 'findLast' function in Remeda. It takes a predicate function and returns a curried function that can be applied to an array, returning the last element that satisfies the predicate or undefined if no element is found.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/mapping/ramda/findLast.md#2025-04-07_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport function findLast<T, S extends T>(predicate: (v: T) => v is S): (list: readonly T[]) => S | undefined\nexport function findLast<T>(predicate: (v: T) => boolean): (list: readonly T[]) => T | undefined\nexport function findLast<T>(predicate: (v: T) => boolean): (list: readonly T[]) => T | undefined\n```\n\n----------------------------------------\n\nTITLE: Native JavaScript Implementation for Sampling Data\nDESCRIPTION: This snippet shows a native JavaScript approach to sampling a single item from a data set, comparing it with the Lodash implementation. It uses Math.random() and array indexing or the at() method to achieve the same result without external libraries.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/mapping/lodash/sample.md#2025-04-07_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n// Lodash\nsample(DATA);\n\n// Native\nDATA[Math.floor(Math.random() * DATA.length)]!;\nDATA.at(Math.floor(Math.random() * DATA.length))!;\n```\n\n----------------------------------------\n\nTITLE: Implementing sortedLastIndex Function in TypeScript\nDESCRIPTION: This function finds the highest index at which a value should be inserted into a sorted array to maintain its sort order. It uses binary search for efficiency and handles both ascending and descending sorted arrays.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/mapping/lodash/sortedLastIndex.md#2025-04-07_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst sortedLastIndex = <T>(array: readonly T[], value: T): number => {\n  if (array.length === 0) {\n    return 0;\n  }\n  const isDescending = array[0] > array[array.length - 1];\n  let low = 0;\n  let high = array.length;\n  while (low < high) {\n    const mid = Math.floor((low + high) / 2);\n    if (isDescending ? array[mid] > value : array[mid] < value) {\n      low = mid + 1;\n    } else {\n      high = mid;\n    }\n  }\n  return low;\n};\n```\n\n----------------------------------------\n\nTITLE: Implementing findLastIndex Function in TypeScript with Remeda\nDESCRIPTION: This code snippet defines the findLastIndex function in TypeScript using Remeda. It takes an array and a predicate function as arguments, and returns the index of the last element that satisfies the predicate, or -1 if no element is found.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/mapping/ramda/findLastIndex.md#2025-04-07_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { purry } from '../purry';\n\n/**\n * Returns the index of the last element in the array where predicate is true, and -1 otherwise.\n * @param array - The array to search\n * @param fn - The predicate function\n * @signature\n *    R.findLastIndex(array, fn)\n * @example\n *    R.findLastIndex([1, 2, 3, 4], x => x % 2 === 1) // => 2\n *    R.findLastIndex([1, 2, 3, 4], x => x > 4) // => -1\n * @dataFirst\n * @category List\n */\nexport function findLastIndex<T>(\n  array: ReadonlyArray<T>,\n  fn: (item: T, index: number) => boolean\n): number;\n\n/**\n * Returns the index of the last element in the array where predicate is true, and -1 otherwise.\n * @param fn - The predicate function\n * @signature\n *    R.findLastIndex(fn)(array)\n * @example\n *    R.pipe([1, 2, 3, 4], R.findLastIndex(x => x % 2 === 1)) // => 2\n *    R.pipe([1, 2, 3, 4], R.findLastIndex(x => x > 4)) // => -1\n * @dataLast\n * @category List\n */\nexport function findLastIndex<T>(\n  fn: (item: T, index: number) => boolean\n): (array: ReadonlyArray<T>) => number;\n\nexport function findLastIndex() {\n  return purry(_findLastIndex, arguments);\n}\n\nfunction _findLastIndex<T>(\n  array: ReadonlyArray<T>,\n  fn: (item: T, index: number) => boolean\n) {\n  for (let i = array.length - 1; i >= 0; i--) {\n    if (fn(array[i], i)) {\n      return i;\n    }\n  }\n  return -1;\n}\n```\n\n----------------------------------------\n\nTITLE: Comparing Array Reverse Implementation between Lodash and Remeda in TypeScript\nDESCRIPTION: This code demonstrates the difference in usage between Lodash and Remeda for reversing an array. Lodash's reverse function mutates the original array in-place, while Remeda's reverse function returns a new array without modifying the original, requiring reassignment to update a variable.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/mapping/lodash/reverse.md#2025-04-07_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// Lodash\nconst DATA = [1, 2, 3];\nreverse(DATA);\n\n// Remeda\nlet DATA = [1, 2, 3];\nDATA = reverse(DATA);\n```\n\n----------------------------------------\n\nTITLE: Implementing sortedLastIndexBy Function in TypeScript for Remeda\nDESCRIPTION: This snippet defines the sortedLastIndexBy function, which finds the highest index at which a value should be inserted into a sorted array to maintain its order. It uses a binary search algorithm and supports custom iteratee functions for comparison.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/mapping/lodash/sortedLastIndexBy.md#2025-04-07_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { purry } from '../purry';\nimport { Pred, PredIndexed } from '../types/common';\n\ntype SortedLastIndexBy = {\n  <T>(array: readonly T[], value: T, iteratee: Pred<T, number>): number;\n  <T>(array: readonly T[], iteratee: Pred<T, number>): (value: T) => number;\n  (array: readonly unknown[]): {\n    (value: unknown, iteratee: Pred<unknown, number>): number;\n    (iteratee: Pred<unknown, number>): (value: unknown) => number;\n  };\n};\n\nexport function sortedLastIndexBy<T>(\n  array: readonly T[],\n  value: T,\n  iteratee: PredIndexed<T, number>,\n): number;\n\nexport function sortedLastIndexBy<T>(\n  array: readonly T[],\n  iteratee: PredIndexed<T, number>,\n): (value: T) => number;\n\nexport function sortedLastIndexBy(array: readonly unknown[]) {\n  return (param1: unknown, param2?: unknown) => {\n    if (typeof param1 === 'function') {\n      return (value: unknown) => implementSortedLastIndexBy(array, value, param1);\n    }\n    return implementSortedLastIndexBy(array, param1, param2 as Pred<unknown, number>);\n  };\n}\n\nfunction implementSortedLastIndexBy<T>(\n  array: readonly T[],\n  value: T,\n  iteratee: Pred<T, number>,\n): number {\n  const length = array.length;\n  let low = 0;\n  let high = length;\n\n  while (low < high) {\n    const mid = (low + high) >>> 1;\n    if (iteratee(array[mid]) <= iteratee(value)) {\n      low = mid + 1;\n    } else {\n      high = mid;\n    }\n  }\n  return low;\n}\n\nexport const sortedLastIndexByc = sortedLastIndexBy as SortedLastIndexBy;\n\nexport default purry(sortedLastIndexBy);\n```\n\n----------------------------------------\n\nTITLE: Using findIndex in Remeda for JavaScript/TypeScript Arrays\nDESCRIPTION: The findIndex function takes a predicate function and returns the index of the first element in the array that satisfies the predicate. If no element satisfies the predicate, it returns -1. This function is similar to the native Array.prototype.findIndex but with a more functional approach.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/mapping/lodash/findIndex.md#2025-04-07_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { findIndex } from 'remeda';\n\nconst numbers = [1, 2, 3, 4, 5];\nconst result = findIndex(numbers, (x) => x > 3);\n// result === 3\n```\n\n----------------------------------------\n\nTITLE: Implementing takeWhile Function in TypeScript\nDESCRIPTION: This code snippet defines a takeWhile function that takes an array and a predicate function. It returns a new array containing elements from the beginning of the input array as long as the predicate function returns true for each element.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/mapping/ramda/takeWhile.md#2025-04-07_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { _ } from './_';\n\n/**\n * Takes elements from `array` until `predicate` returns falsy.\n *\n * @param predicate The predicate function to apply to each element.\n * @param array The input array.\n * @returns A new array containing elements taken from the beginning of `array`.\n * @signature\n *    R.takeWhile(predicate, array)\n * @example\n *    R.takeWhile(x => x < 3, [1, 2, 3, 4, 5]) // => [1, 2]\n *    R.takeWhile(x => x < 3, [5, 6, 7, 8, 9]) // => []\n * @data_first\n *    R.takeWhile(predicate)(array)\n * @category List\n */\nexport function takeWhile<T>(\n  predicate: (x: T) => boolean,\n  array: T[]\n): T[];\n\nexport function takeWhile<T>(\n  predicate: (x: T) => boolean\n): (array: T[]) => T[];\n\nexport function takeWhile() {\n  return _((predicate, array: unknown[]) => {\n    const result = [];\n    for (const item of array) {\n      if (!predicate(item)) break;\n      result.push(item);\n    }\n    return result;\n  });\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing sumBy Function in TypeScript for Remeda\nDESCRIPTION: This code defines a sumBy function that takes an array and a transformation function. It calculates the sum of the array elements after applying the transformation. The function supports both curried and non-curried usage.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/mapping/lodash/sumBy.md#2025-04-07_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { purry } from '../purry'\n\n/**\n * Calculates the sum of the elements of an array transformed by a function.\n * @param array The array\n * @param fn The transformation function\n * @signature\n *    R.sumBy(array, fn)\n * @example\n *    R.sumBy([1, 2, 3], x => x * 2) // => 12\n *    R.sumBy([{ a: 1 }, { a: 2 }, { a: 3 }], x => x.a) // => 6\n * @data_first\n * @category Math\n */\nexport function sumBy<T>(array: readonly T[], fn: (item: T) => number): number\n\n/**\n * Calculates the sum of the elements of an array transformed by a function.\n * @param fn The transformation function\n * @signature\n *    R.sumBy(fn)(array)\n * @example\n *    R.pipe([1, 2, 3], R.sumBy(x => x * 2)) // => 12\n *    R.pipe([{ a: 1 }, { a: 2 }, { a: 3 }], R.sumBy(x => x.a)) // => 6\n * @data_last\n * @category Math\n */\nexport function sumBy<T>(fn: (item: T) => number): (array: readonly T[]) => number\n\nexport function sumBy(...args: any[]) {\n  return purry(_sumBy, args)\n}\n\nfunction _sumBy<T>(array: readonly T[], fn: (item: T) => number) {\n  let sum = 0\n  for (let i = 0; i < array.length; i++) {\n    sum += fn(array[i])\n  }\n  return sum\n}\n```\n\n----------------------------------------\n\nTITLE: Comparing Lodash and Native JavaScript Array.every Method in TypeScript\nDESCRIPTION: Demonstrates how to use the native JavaScript Array.prototype.every method as an alternative to Lodash's every function. The native method performs the same operation but with better performance and reduced dependency.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/mapping/lodash/every.md#2025-04-07_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// Lodash\nevery(DATA, predicate);\n\n// Native\nDATA.every(predicate);\n```\n\n----------------------------------------\n\nTITLE: Filtering Lists with Remeda and Ramda in TypeScript\nDESCRIPTION: This snippet compares the usage of Ramda's reject function with Remeda's filter function combined with isNot. It demonstrates how to filter out elements from a list that match a given predicate, both as a standalone function and within a pipe.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/mapping/ramda/reject.md#2025-04-07_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// Ramda\nreject(predicate, DATA);\n\n// Remeda\nfilter(DATA, isNot(predicate));\n\n// Or in a pipe\npipe(DATA, filter(isNot(predicate)));\n```\n\n----------------------------------------\n\nTITLE: Basic Throttle Implementation using Funnel\nDESCRIPTION: Basic implementation of throttle function using funnel utility. Supports leading and trailing edge execution control with configurable wait times.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/mapping/lodash/throttle.md#2025-04-07_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nfunction throttle<F extends (...args: any) => void>(\n  func: F,\n  wait = 0,\n  {\n    leading = true,\n    trailing = true,\n  }: { readonly leading?: boolean; readonly trailing?: boolean } = {},\n) {\n  const {\n    call,\n    isIdle: _isIdle,\n    ...rest\n  } = funnel(\n    () => {\n      if (leading || trailing) {\n        func();\n      }\n    },\n    {\n      burstCoolDownMs: wait,\n      maxBurstDurationMs: wait,\n      invokedAt: trailing ? (leading ? \"both\" : \"end\") : \"start\",\n    },\n  );\n  return Object.assign(call, rest);\n}\n```\n\n----------------------------------------\n\nTITLE: Comparing Lodash some() with Native JavaScript Array.some() in TypeScript\nDESCRIPTION: This code snippet demonstrates how to replace Lodash's some function with JavaScript's native Array.prototype.some method. Both achieve the same functionality of testing whether at least one element in the array passes the test implemented by the provided function.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/mapping/lodash/some.md#2025-04-07_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// Lodash\nsome(DATA, predicate);\n\n// Native\nDATA.some(predicate);\n```\n\n----------------------------------------\n\nTITLE: Defining pick Function in TypeScript\nDESCRIPTION: TypeScript type definition for the 'pick' function, which takes an object and an array of keys, and returns a new object with only the specified properties.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/mapping/ramda/pick.md#2025-04-07_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nfunction pick<T extends object, K extends keyof T>(\n  obj: T,\n  keys: ReadonlyArray<K>\n): Pick<T, K>\n\nfunction pick<T extends object, K extends keyof T>(\n  keys: ReadonlyArray<K>\n): (obj: T) => Pick<T, K>\n```\n\n----------------------------------------\n\nTITLE: Setting Object Path Values with Remeda's setPath Function\nDESCRIPTION: The setPath function allows setting a value at a specified path within an object. It takes an object, a path (as an array or dot-separated string), and a value to set. The function returns a new object with the updated value, preserving immutability.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/mapping/ramda/assocPath.md#2025-04-07_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { setPath } from 'remeda'\n\nconst obj = { a: { b: { c: 1 } } }\nconst result = setPath(obj, 'a.b.c', 2)\nconsole.log(result) // => { a: { b: { c: 2 } } }\nconsole.log(obj) // => { a: { b: { c: 1 } } } (original object is not modified)\n\n// Path can also be an array\nconst result2 = setPath(obj, ['a', 'b', 'c'], 3)\nconsole.log(result2) // => { a: { b: { c: 3 } } }\n```\n\n----------------------------------------\n\nTITLE: Curried Usage of Remeda's groupBy Function\nDESCRIPTION: Shows how to use the 'groupBy' function in a curried manner, where the key selector function is provided first, followed by the array to be grouped. This allows for more flexible composition of functions.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/mapping/lodash/groupBy.md#2025-04-07_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { groupBy } from 'remeda';\n\nconst users = [\n  { id: 1, name: 'John', age: 30 },\n  { id: 2, name: 'Jane', age: 25 },\n  { id: 3, name: 'Bob', age: 30 },\n];\n\nconst groupByAge = groupBy((user) => user.age);\nconst result = groupByAge(users);\nconsole.log(result);\n// {\n//   '25': [{ id: 2, name: 'Jane', age: 25 }],\n//   '30': [\n//     { id: 1, name: 'John', age: 30 },\n//     { id: 3, name: 'Bob', age: 30 },\n//   ],\n// }\n```\n\n----------------------------------------\n\nTITLE: Comparing partialLastBind in Remeda with partialRight in Ramda\nDESCRIPTION: This snippet defines a greet function and demonstrates how to partially apply arguments using Ramda's partialRight and Remeda's partialLastBind. The key difference is that partialLastBind accepts individual arguments rather than an array.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/mapping/ramda/partialRight.md#2025-04-07_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nfunction greet(greeting, firstName, lastName) {\n  return greeting + \" \" + firstName + \" \" + lastName;\n}\n\n// Ramda\npartialRight(greet, [\"john\", \"doe\"]);\n\n// Remeda\npartialLastBind(greet, \"john\", \"doe\");\n```\n\n----------------------------------------\n\nTITLE: Implementing Subtraction in Remeda vs Ramda\nDESCRIPTION: Shows two different approaches to decrement a value by 1. Ramda uses the dec function while Remeda uses the more explicit subtract function with two parameters.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/mapping/ramda/dec.md#2025-04-07_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// Ramda\ndec(value);\n\n// Remeda\nsubtract(value, 1);\n```\n\n----------------------------------------\n\nTITLE: Implementing sortedUniq using Remeda's filter function in TypeScript\nDESCRIPTION: This code snippet demonstrates how to achieve the functionality of Lodash's sortedUniq using Remeda's filter function. It filters the array to keep only unique elements by comparing each item with the previous one.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/mapping/lodash/sortedUniq.md#2025-04-07_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// Lodash\nsortedUniq(DATA);\n\n// Remeda\nunique(DATA);\nfilter(DATA, (item, index, array) => index === 0 || item !== array[index - 1]);\n```\n\n----------------------------------------\n\nTITLE: Using takeLastWhile Function in TypeScript with Remeda\nDESCRIPTION: This code snippet demonstrates how to use the takeLastWhile function from Remeda. It shows examples of taking elements from the end of an array based on different conditions.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/mapping/ramda/takeLastWhile.md#2025-04-07_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { takeLastWhile } from 'remeda';\n\ntakeLastWhile([1, 2, 3, 4, 5], (x) => x > 3); // => [4, 5]\ntakeLastWhile([1, 2, 3, 4, 5], (x) => x > 5); // => []\ntakeLastWhile([1, 2, 3, 4, 5], (x) => x > 0); // => [1, 2, 3, 4, 5]\n\n// It can be used as data-last function\nconst takePositive = takeLastWhile((x: number) => x > 0);\ntakePositive([-1, -2, 3, 4, 5]); // => [3, 4, 5]\n```\n\n----------------------------------------\n\nTITLE: Implementing dropLastWhile Function in TypeScript for Remeda Library\nDESCRIPTION: This code snippet defines the dropLastWhile function, which removes elements from the end of an array as long as they satisfy a given predicate. It includes type definitions for both curried and non-curried versions of the function.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/mapping/ramda/dropLastWhile.md#2025-04-07_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { purry } from '../purry'\n\n/**\n * Removes elements from the end of the array until the predicate returns false.\n *\n * @param data - The array to remove elements from.\n * @param predicate - The predicate function.\n * @signature\n *    R.dropLastWhile(data, predicate)\n * @example\n *    R.dropLastWhile([1, 2, 3, 4, 3, 2, 1], x => x < 3) // => [1, 2, 3, 4]\n *    R.dropLastWhile([1, 2, 3, 4, 3, 2, 1], x => x < 5) // => []\n * @data_first\n * @category Array\n */\nexport function dropLastWhile<T>(\n  data: ReadonlyArray<T>,\n  predicate: (item: T) => boolean\n): Array<T>\n\n/**\n * Removes elements from the end of the array until the predicate returns false.\n *\n * @param predicate - The predicate function.\n * @signature\n *    R.dropLastWhile(predicate)(data)\n * @example\n *    R.pipe(\n *      [1, 2, 3, 4, 3, 2, 1],\n *      R.dropLastWhile(x => x < 3)\n *    ) // => [1, 2, 3, 4]\n * @data_last\n * @category Array\n */\nexport function dropLastWhile<T>(\n  predicate: (item: T) => boolean\n): (data: ReadonlyArray<T>) => Array<T>\n\nexport function dropLastWhile(...args: any[]) {\n  return purry(dropLastWhileImplementation, args)\n}\n\nfunction dropLastWhileImplementation<T>(\n  array: ReadonlyArray<T>,\n  predicate: (item: T) => boolean\n): Array<T> {\n  const result = [...array]\n  let pos = result.length - 1\n  while (pos >= 0 && predicate(result[pos])) {\n    pos--\n  }\n  result.splice(pos + 1)\n  return result\n}\n```\n\n----------------------------------------\n\nTITLE: Comparing Function Partial Application in Lodash, Remeda and Native JavaScript\nDESCRIPTION: Demonstrates how to partially apply arguments to functions using Lodash's partialRight, Remeda's partialBind, and native JavaScript arrow functions. Shows the limitations of Remeda's implementation which doesn't support placeholders.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/mapping/lodash/partialRight.md#2025-04-07_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nfunction greet(greeting, firstName, lastName) {\n  return greeting + \" \" + firstName + \" \" + lastName;\n}\n\n// Lodash\n_.partialRight(greet, \"hi\", \"john\", _);\n_.partialRight(greet, \"hi\", _, \"doe\");\n\n// Remeda\npartialBind(greet, [\"hi\", \"john\"]);\n// (not supported)\n\n// Native\n(lastName) => greet(\"hi\", \"john\", lastName);\n(firstName) => greet(\"hi\", firstName, \"doe\");\n```\n\n----------------------------------------\n\nTITLE: Removing Last Character from Strings using Remeda\nDESCRIPTION: Demonstrates how to remove the last character from a string using Remeda's sliceString function with start index 0 and end index -1, providing equivalent functionality to Ramda's init function for strings.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/mapping/ramda/init.md#2025-04-07_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n// Ramda\ninit(\"abc\");\n\n// Remeda\nsliceString(\"abc\", 0, -1);\n```\n\n----------------------------------------\n\nTITLE: Using findLast Function with Remeda in TypeScript\nDESCRIPTION: This example demonstrates how to use the 'findLast' function from Remeda to find the last even number in an array. It shows both the curried and non-curried usage of the function.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/mapping/ramda/findLast.md#2025-04-07_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { findLast } from 'remeda'\n\nfindLast(n => n % 2 === 0)([1, 2, 3, 4, 5]) // => 4\nfindLast((n: number) => n % 2 === 0)([1, 3, 5, 7]) // => undefined\n```\n\n----------------------------------------\n\nTITLE: String Splitting with Arguments\nDESCRIPTION: Shows how to use Remeda's map function to split numbers into arrays of characters, replacing Lodash's invokeMap with arguments.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/mapping/lodash/invokeMap.md#2025-04-07_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n// Lodash\ninvokeMap([123, 456], String.prototype.split, \"\");\n\n// Remeda\nmap([123, 456], (num) => num.toString().split(\"\"));\n```\n\n----------------------------------------\n\nTITLE: Generating Numeric Sequences with Remeda's range Function in TypeScript\nDESCRIPTION: The range function creates an array of numbers from start (inclusive) to end (exclusive). It can be called with one, two, or three arguments to specify the range and step. The function handles both ascending and descending ranges.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/mapping/ramda/range.md#2025-04-07_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { range } from 'remeda';\n\nrange(4); // => [0, 1, 2, 3]\nrange(1, 5); // => [1, 2, 3, 4]\nrange(0, 20, 5); // => [0, 5, 10, 15]\nrange(1, 4, 0); // => [1, 1, 1]\nrange(0); // => []\nrange(0, -4, -1); // => [0, -1, -2, -3]\nrange(0, 4, -1); // => [0, 1, 2, 3]\nrange(1, 4, 5); // => [1]\n\n// Floating point arguments are also allowed:\nrange(0, 1, 0.2); // => [0, 0.2, 0.4, 0.6, 0.8]\n```\n\n----------------------------------------\n\nTITLE: Comparing Identity Function Usage in Ramda vs Remeda\nDESCRIPTION: This snippet demonstrates the difference in usage pattern for the identity function between Ramda and Remeda libraries. In Ramda, identity is used directly, while in Remeda it needs to be called first as it's a factory function.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/mapping/ramda/identity.md#2025-04-07_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// Ramda\nmap(identity);\n\n// Remeda\nmap(identity());\n```\n\n----------------------------------------\n\nTITLE: Implementing If Logic in Remeda vs Ramda\nDESCRIPTION: Demonstrates simple if conditional logic implementation using Remeda's when function compared to Ramda's ifElse with identity function.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/mapping/ramda/ifElse.md#2025-04-07_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nifElse(predicate, onTrue, identity)(data);\n\n// Remeda\nwhen(data, predicate, onTrue);\n\n// Or in a pipe\npipe(data, when(predicate, onTrue));\n```\n\n----------------------------------------\n\nTITLE: Comparing Boolean Negation in Ramda and Remeda\nDESCRIPTION: Shows how to negate boolean values using Ramda's not function versus Remeda's isNot function. The isNot function only accepts boolean values directly.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/mapping/ramda/not.md#2025-04-07_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// Ramda\nnot(val);\n\n// Remeda\nisNot(val);\n```\n\n----------------------------------------\n\nTITLE: Handling Extra Arguments in Remeda vs Ramda\nDESCRIPTION: Shows how to work with additional arguments in conditional logic, comparing Remeda's simpler approach with Ramda's explicit typing requirements.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/mapping/ramda/ifElse.md#2025-04-07_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\n// Ramda\nconst mapper = ifElse(\n  (x: string | undefined, index: number) => x === undefined,\n  (_, index) => `item_${index}`,\n  identity,\n);\nmap(data, mapper);\n\n// Remeda\nmap(\n  data,\n  when(\n    (x) => x === undefined,\n    (_, index) => `item_${index}`,\n  ),\n);\n```\n\n----------------------------------------\n\nTITLE: Comparing addIndex Usage in Ramda and Remeda (TypeScript)\nDESCRIPTION: This snippet demonstrates the difference between using addIndex in Ramda and achieving the same result in Remeda. In Remeda, the index is provided by default in iteration functions, eliminating the need for addIndex.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/mapping/ramda/addIndex.md#2025-04-07_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// Ramda\naddIndex(map)((val, idx) => idx + \"-\" + val, DATA);\n\n// Remeda\nmap(DATA, (val, idx) => idx + \"-\" + val);\n```\n\n----------------------------------------\n\nTITLE: Object.entries Implementation\nDESCRIPTION: Implementation of the entries function that returns an array of key-value pairs from an object, with type safety preserved from the input object type.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/mapping/ramda/toPairs.md#2025-04-07_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst entries = <T extends object>(obj: T): Entries<T> => {\n  return Object.entries(obj) as Entries<T>\n}\n```\n\n----------------------------------------\n\nTITLE: Negating Values with Remeda's multiply Function in TypeScript\nDESCRIPTION: This snippet demonstrates how to negate a value using Remeda's multiply function compared to Ramda's dedicated negate function. In Remeda, you multiply the value by -1 to achieve the same result as Ramda's negate.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/mapping/ramda/negate.md#2025-04-07_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// Ramda\nnegate(value);\n\n// Remeda\nmultiply(value, -1);\n```\n\n----------------------------------------\n\nTITLE: Handling NaN Values with Remeda when()\nDESCRIPTION: Demonstrates using when() function with Number.isNaN() to provide default values for NaN inputs. Shows comparison with Lodash's defaultTo() implementation.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/mapping/lodash/defaultTo.md#2025-04-07_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n// Lodash\ndefaultTo(DATA, 10);\n\n// Remeda\nwhen(DATA, Number.isNaN, constant(10));\n```\n\n----------------------------------------\n\nTITLE: Negating Arbitrary Values in Ramda and Remeda\nDESCRIPTION: Demonstrates how to negate arbitrary (non-boolean) values in both libraries. For Remeda, this requires composing isNot with isTruthy to handle non-boolean values.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/mapping/ramda/not.md#2025-04-07_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n// Ramda\nnot(val);\n\n// Remeda\nisNot(isTruthy(val));\n```\n\n----------------------------------------\n\nTITLE: Implementing zipObj using Remeda's zip and fromEntries in TypeScript\nDESCRIPTION: This code snippet demonstrates how to achieve the functionality of Ramda's zipObj function using Remeda's zip and fromEntries functions. It takes two arrays, keys and values, zips them together, and then creates an object from the resulting entries.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/mapping/ramda/zipObj.md#2025-04-07_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// Ramda\nzipObj(keys, values);\n\n// Remeda\nfromEntries(zip(keys, values));\n```\n\n----------------------------------------\n\nTITLE: Handling NaN Values with Remeda's 'when' Function in TypeScript\nDESCRIPTION: This snippet shows how to use Remeda's 'when' function with 'Number.isNaN' to handle NaN values, as an alternative to Ramda's 'defaultTo'.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/mapping/ramda/defaultTo.md#2025-04-07_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n// Ramda\ndefaultTo(DATA, 10);\n\n// Remeda\nwhen(DATA, Number.isNaN, constant(10));\n```\n\n----------------------------------------\n\nTITLE: Function Category Documentation in Markdown\nDESCRIPTION: List of function-related utility methods including composition, currying, and function manipulation operations.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/mapping/ramda/__MISSING.md#2025-04-07_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n# Function\n\n- addIndexRight\n- andThen\n- ap\n- apply\n- applySpec\n- applyTo\n- ascend\n- ascendNatural\n- binary\n- bind\n- call\n- comparator\n- compose\n- composeWith\n- construct\n- constructN\n- converge\n- curry\n- curryN\n- descend\n- descendNatural\n- empty\n- flow\n- invoker\n- juxt\n- lift\n- liftN\n- memoizeWith\n- nAry\n- nthArg\n- o\n- of\n- on\n- otherwise\n- partialObject\n- pipeWith\n- promap\n- thunkify\n- tryCatch\n- unapply\n- unary\n- uncurryN\n- useWith\n```\n\n----------------------------------------\n\nTITLE: Merging Arrays in TypeScript\nDESCRIPTION: Demonstrates merging arrays using Just's extend and Remeda's splice function. Remeda's approach uses splice to achieve similar functionality for regular arrays.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/mapping/just/extend.md#2025-04-07_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\n// Just\nconst DATA = [...];\nextend(DATA, b);\n\n// Remeda\nlet DATA = [...];\nDATA = splice(DATA, 0 /* start */, b.length /* deleteCount */, b /* replacement */);\n```\n\n----------------------------------------\n\nTITLE: Handling Both Nullish and NaN Values with Remeda's 'when' Function in TypeScript\nDESCRIPTION: This snippet demonstrates how to use Remeda's 'when' function with a custom type-guard to handle both nullish and NaN values simultaneously, as an alternative to Ramda's 'defaultTo'.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/mapping/ramda/defaultTo.md#2025-04-07_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\n// Ramda\ndefaultTo(DATA, 10);\n\n// Remeda\nwhen(\n  DATA,\n  (x) => x === undefined || x === null || Number.isNaN(x),\n  constant(10),\n);\n```\n\n----------------------------------------\n\nTITLE: Object Type Checking in TypeScript\nDESCRIPTION: Demonstrates how to check if a value is an object using typeof operator or isPlainObject type guard.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/v1-migration/type.md#2025-04-07_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst DATA = {};\n\n// Was\ntype(DATA) === \"Object\";\n\n// Now\ntypeof DATA === \"object\";\n\n// Or\nisPlainObject(DATA);\n```\n\n----------------------------------------\n\nTITLE: Merging Multiple Objects in TypeScript\nDESCRIPTION: Shows how to merge multiple objects using Just's extend and Remeda's mergeDeep with an array of objects. Remeda requires wrapping objects in an array for multiple merges.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/mapping/just/extend.md#2025-04-07_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\n// Just\nconst DATA = { ... };\nextend(DATA, b, c, d);\n\n// Remeda\nlet DATA = { ... };\nDATA = mergeDeep([DATA, b, c, d]);\n```\n\n----------------------------------------\n\nTITLE: Replacing Object Data with Merge in TypeScript\nDESCRIPTION: Shows how to replace data in an existing object using Just's extend and Remeda's merge. Remeda's approach requires reassignment to avoid mutation.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/mapping/just/extend.md#2025-04-07_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n// Just\nconst DATA = { ... };\nextend(DATA, b);\n\n// Remeda\nlet DATA = { ... };\nDATA = merge(DATA, b);\n```\n\n----------------------------------------\n\nTITLE: Handling Callback Parameters in Partition Function\nDESCRIPTION: Demonstrates a potential bug when using function references with default parameters and shows the correct way to handle callbacks. The example illustrates how additional parameters can affect the function's behavior.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/v1-migration/partition.md#2025-04-07_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nfunction callback(value: number, index = 0): boolean {\n  return (value + index) % 2 === 0;\n}\n\n// Bug\npartition([1, 2, 3], callback); // => [[], [1, 2, 3]], Was: [[2], [1, 3]]\n\n// Fix\npartition([1, 2, 3], (item) => callback(item)); // => [[2], [1, 3]]\n```\n\n----------------------------------------\n\nTITLE: Data-Last Filter Migration Example in TypeScript\nDESCRIPTION: Shows how to replace compact() with filter(isTruthy) in data-last style within a pipe operation.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/v1-migration/compact.md#2025-04-07_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n// Was\npipe([1, null, 3], compact);\n\n// Now\npipe([1, null, 3], filter(isTruthy));\n```\n\n----------------------------------------\n\nTITLE: Deep Merging Objects in TypeScript\nDESCRIPTION: Illustrates deep merging of objects using Just's extend with the deep flag and Remeda's mergeDeep function. Remeda provides a separate function for deep merging.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/mapping/just/extend.md#2025-04-07_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\n// Just\nextend(true /* deep */, a, b);\n\n// Remeda\nmergeDeep(a, b);\n```\n\n----------------------------------------\n\nTITLE: Migrating Indexed Variant Usage in TypeScript\nDESCRIPTION: Demonstrates the migration path for code using the indexed variant. The indexed suffix can be removed as the functionality is now part of the base implementation.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/v1-migration/map.md#2025-04-07_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n// Was\nmap.indexed(array, mapper);\n\n// Now\nmap(array, mapper);\n```\n\n----------------------------------------\n\nTITLE: Replacing countBy with filter and length in TypeScript (dataFirst)\nDESCRIPTION: This snippet demonstrates how to replace the countBy function with filter and length in a dataFirst scenario. It shows counting even numbers in an array.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/v1-migration/countBy.md#2025-04-07_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// Was\ncountBy([1, 2, 3, 4], (item) => item % 2 === 0);\n\n// Now\nfilter([1, 2, 3, 4], (item) => item % 2 === 0).length;\n\n// or\nlength(filter([1, 2, 3, 4], (item) => item % 2 === 0));\n```\n\n----------------------------------------\n\nTITLE: Migrating Flatten to Flat - DataLast Style in TypeScript\nDESCRIPTION: Examples showing how to migrate from the deprecated 'flatten' function to the new 'flat' function in dataLast style using pipe. The new function supports an optional depth parameter.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/v1-migration/flatten.md#2025-04-07_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n// Was\npipe([[1, 2], [3], [4, 5]], flatten());\n\n// Now\npipe([[1, 2], [3], [4, 5]], flat());\n\n// Or\npipe([[1, 2], [3], [4, 5]], flat(1 /* depth */));\n```\n\n----------------------------------------\n\nTITLE: Potential Bug with Function Reference in findLastIndex (TypeScript)\nDESCRIPTION: Illustrates a potential bug when using a function reference as a predicate in findLastIndex. The function now receives additional parameters, which can cause unexpected behavior if not handled properly.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/v1-migration/findLastIndex.md#2025-04-07_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nfunction callback(value: number, index = 0): boolean {\n  return (value + index) % 2 === 0;\n}\n\n// Bug\nfindLastIndex([1, 2, 3], callback); // => -1, Was: 1\n\n// Fix\nfindLastIndex([1, 2, 3], (item) => callback(item)); // => 1\n```\n\n----------------------------------------\n\nTITLE: Illustrating Potential Bug and Fix in Predicate Function for TypeScript\nDESCRIPTION: This example demonstrates a potential bug when using a function reference as a predicate, and shows how to fix it. The bug occurs due to the additional parameters being passed to the callback function.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/v1-migration/dropWhile.md#2025-04-07_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nfunction callback(value: number, index = 0): boolean {\n  return (value + index) % 2 === 1;\n}\n\n// Bug\ndropWhile([1, 2, 3], callback); // => [1, 2, 3], Was: [2, 3]\n\n// Fix\ndropWhile([1, 2, 3], (item) => callback(item)); // => [2, 3]\n```\n\n----------------------------------------\n\nTITLE: Basic Flattening Array in Remeda\nDESCRIPTION: Simple array flattening without mapping function, equivalent to Lodash's flatMapDepth with no mapping function.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/mapping/lodash/flatMapDepth.md#2025-04-07_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// Lodash\nflatMapDepth(DATA);\n\n// Remeda\nflat(DATA);\n```\n\n----------------------------------------\n\nTITLE: Avoiding Bugs with Function References in Remeda's Filter Method\nDESCRIPTION: Example demonstrating a potential bug when using function references with default parameters as predicates, and how to fix it using an arrow function wrapper to control the parameters passed to the callback.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/v1-migration/filter.md#2025-04-07_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nfunction callback(value: number, index = 0): boolean {\n  return (value + index) % 2 === 0;\n}\n\n// Bug\nfilter([1, 2, 3], callback); // => [], Was: [2]\n\n// Fix\nfilter([1, 2, 3], (item) => callback(item)); // => [2]\n```\n\n----------------------------------------\n\nTITLE: Removing Indexed Variant in findLastIndex Function (TypeScript)\nDESCRIPTION: Demonstrates the removal of the indexed variant of the findLastIndex function. The base implementation now takes the same parameters as the previous indexed version.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/v1-migration/findLastIndex.md#2025-04-07_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// Was\nfindLastIndex.indexed([1, 2, 3], (item, index) => item + (index % 2) === 0);\n\n// Now\nfindLastIndex([1, 2, 3], (item, index) => item + (index % 2) === 0);\n```\n\n----------------------------------------\n\nTITLE: FlatMap with Mapping Function in Remeda\nDESCRIPTION: Implementation of flatMapDepth with a mapping function, using Remeda's flatMap function.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/mapping/lodash/flatMapDepth.md#2025-04-07_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n// Lodash\nflatMapDepth(DATA, mappingFunction);\n\n// Remeda\nflatMap(DATA, mappingFunction);\n```\n\n----------------------------------------\n\nTITLE: Migrating from Indexed FindIndex in TypeScript\nDESCRIPTION: Shows how to migrate from the removed indexed variant to the new base implementation. The functionality remains the same but the syntax is simplified.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/v1-migration/findIndex.md#2025-04-07_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// Was\nfindIndex.indexed([1, 2, 3], (item, index) => item + (index % 2) === 0);\n\n// Now\nfindIndex([1, 2, 3], (item, index) => item + (index % 2) === 0);\n```\n\n----------------------------------------\n\nTITLE: Using FlatMap with Index Parameter in TypeScript\nDESCRIPTION: Demonstrates the new capability of using the index parameter in the flatMap function's mapper callback. Shows how to access the current element's index during mapping.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/v1-migration/flatMap.md#2025-04-07_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// This was previously unavailable\nflatMap([1, 2, 3], (item, index) => [item + index]);\n```\n\n----------------------------------------\n\nTITLE: FlatMap Function Reference Bug Example\nDESCRIPTION: Illustrates a potential bug when using function references with default parameters in flatMap, and shows the correct way to handle such cases by wrapping the callback in an arrow function.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/v1-migration/flatMap.md#2025-04-07_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nfunction callback(value: number, index = 0): boolean {\n  return [value + index];\n}\n\n// Bug\nflatMap([1, 2, 3], callback); // => [1, 3, 5], Was: [1, 2, 3]\n\n// Fix\nflatMap([1, 2, 3], (item) => callback(item)); // => [1, 2, 3]\n```\n\n----------------------------------------\n\nTITLE: Illustrating Potential Bug with Function Reference as Predicate (TypeScript)\nDESCRIPTION: This example demonstrates a potential bug when using a function reference as a predicate. The function 'callback' is defined with a default value for the 'index' parameter, which can lead to unexpected behavior when used with dropLastWhile.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/v1-migration/dropLastWhile.md#2025-04-07_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nfunction callback(value: number, index = 0): boolean {\n  return (value + index) % 2 === 0;\n}\n\ndropLastWhile([1, 2], callback); // => [1, 2], Was: [1]\n```\n\n----------------------------------------\n\nTITLE: Replacing indexed flatMapToObj with fromEntries and flatMap (TypeScript)\nDESCRIPTION: This example shows how to replace the indexed version of flatMapToObj with fromEntries and flatMap. It creates an object with array elements as keys and their indices as values, along with duplicated keys and summed indices.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/v1-migration/flatMapToObj.md#2025-04-07_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n// Was\nflatMapToObj.indexed([\"a\", \"b\"], (x, index) => [\n  [x, index],\n  [x + x, index + index],\n]);\n\n// Now\nfromEntries(\n  flatMap([\"a\", \"b\"], (x, index) => [\n    [x, index],\n    [x + x, index + index],\n  ]),\n);\n```\n\n----------------------------------------\n\nTITLE: Utilizing New Parameters in Remeda's zipWith Function (TypeScript)\nDESCRIPTION: This example demonstrates the use of the new 'index' parameter in the zipping function of zipWith. The zipping function now has access to the current index of the element being processed.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/v1-migration/zipWith.md#2025-04-07_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n// This was previously unavailable\nzipWith([1, 2, 3], [4, 5, 6], (itemA, itemB, index) => itemA + itemB - index);\n```\n\n----------------------------------------\n\nTITLE: Removing Indexed Variant in FindLast Function\nDESCRIPTION: Shows the transition from using the indexed variant to the new simplified findLast implementation. The functionality remains the same but with a more streamlined API.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/v1-migration/findLast.md#2025-04-07_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// Was\nfindLast.indexed([1, 2, 3], (item, index) => item + (index % 2) === 0);\n\n// Now\nfindLast([1, 2, 3], (item, index) => item + (index % 2) === 0);\n```\n\n----------------------------------------\n\nTITLE: Replacing dataLast flatMapToObj with pipe, flatMap, and fromEntries (TypeScript)\nDESCRIPTION: This snippet shows how to replace the dataLast version of flatMapToObj using pipe, flatMap, and fromEntries. It filters odd numbers from an array and creates an object with the numbers as keys and values.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/v1-migration/flatMapToObj.md#2025-04-07_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\n// Was\npipe(\n  [1, 2, 3],\n  flatMapToObj((x) => (x % 2 === 1 ? [[String(x), x]] : [])),\n);\n\n// Now\npipe(\n  [1, 2, 3],\n  flatMap((x) => (x % 2 === 1 ? [[String(x), x]] : [])),\n  fromEntries(),\n);\n```\n\n----------------------------------------\n\nTITLE: Demonstrating New Parameters in Predicate Function for TypeScript\nDESCRIPTION: This snippet shows how to use the new index parameter in a predicate function for the dropWhile method. It demonstrates the ability to use both the item and its index in the condition.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/v1-migration/dropWhile.md#2025-04-07_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndropWhile([1, 2, 3], (item, index) => item + (index % 2) === 0);\n```\n\n----------------------------------------\n\nTITLE: Avoiding Callback Reference Issues in FindLast\nDESCRIPTION: Illustrates a potential bug when using function references with default parameters and shows the correct way to handle callback functions.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/v1-migration/findLast.md#2025-04-07_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nfunction callback(value: number, index = 0): boolean {\n  return (value + index) % 2 === 0;\n}\n\n// Bug\nfindLast([1, 2, 3], callback); // => undefined, Was: 2\n\n// Fix\nfindLast([1, 2, 3], (item) => callback(item)); // => 2\n```\n\n----------------------------------------\n\nTITLE: Migrating from flattenDeep to flat in TypeScript (dataLast approach)\nDESCRIPTION: This example shows how to migrate from 'flattenDeep' to 'flat' using the dataLast approach with the pipe function. It illustrates the syntax change and the addition of the depth parameter in the new 'flat' function.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/v1-migration/flattenDeep.md#2025-04-07_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n// Was\npipe(\n  [\n    [1, 2],\n    [[3], [4, 5]],\n  ],\n  flattenDeep(),\n);\n\n// Now\npipe(\n  [\n    [1, 2],\n    [[3], [4, 5]],\n  ],\n  flat(4 /* depth */),\n);\n```\n\n----------------------------------------\n\nTITLE: Callback Reference Bug Example - TypeScript\nDESCRIPTION: Illustrates a potential bug when using function references with additional parameters, showing both the problematic implementation and the correct fix using arrow functions.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/v1-migration/splitWhen.md#2025-04-07_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nfunction callback(item: number, index = 0): boolean {\n  return item > index;\n}\n\n// Bug\nsplitWhen([1, 1, 1], callback); // => [[1], [1, 1]], Was: [[1, 1, 1], []]\n\n// Fix\nsplitWhen([1, 1, 1], (item) => callback(item)); // => [[1, 1, 1], []]\n```\n\n----------------------------------------\n\nTITLE: Migrating from flattenDeep to flat in TypeScript (dataFirst approach)\nDESCRIPTION: This snippet demonstrates how to replace the deprecated 'flattenDeep' function with the new 'flat' function using the dataFirst approach. It shows the old and new syntax, emphasizing the addition of a depth parameter.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/v1-migration/flattenDeep.md#2025-04-07_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// Was\nflattenDeep([\n  [1, 2],\n  [[3], [4, 5]],\n]);\n\n// Now\nflat([[1, 2], [3], [4, 5]], 4 /* depth */);\n```\n\n----------------------------------------\n\nTITLE: Avoiding Callback Reference Bugs in ForEachObj\nDESCRIPTION: Illustrates potential issues when using function references as predicates and how to fix them by wrapping the callback in an arrow function.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/v1-migration/forEachObj.md#2025-04-07_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nfunction callback(value: number, key = \"X\"): boolean {\n  console.log(`${key} => ${value}`);\n}\n\n// Bug\nforEachObj({ a: 1, b: 2 }, callback); // \"a => 1, b => 2\", Was: \"a => X, b => X\"\n\n// Fix\nforEach({ a: 1, b: 2 }, (value) => callback(value)); // => \"a => X, b => X\"\n```\n\n----------------------------------------\n\nTITLE: Array Type Checking in TypeScript\nDESCRIPTION: Shows methods to check if a value is an array using Array.isArray() or isArray type guard.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/v1-migration/type.md#2025-04-07_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nconst DATA = [];\n\n// Was\ntype(DATA) === \"Array\";\n\n// Now\nArray.isArray(DATA);\n\n// Or\nisArray(DATA);\n```\n\n----------------------------------------\n\nTITLE: Migrating from isNil to isNullish in remeda\nDESCRIPTION: Example showing how to update code that previously used the 'isNil' function to now use the renamed 'isNullish' function with the filter function in remeda.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/v1-migration/isNil.md#2025-04-07_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// Was\nfilter(DATA, isNil);\n\n// Now\nfilter(DATA, isNullish);\n```\n\n----------------------------------------\n\nTITLE: TypeScript fromEntries with String Keys Migration\nDESCRIPTION: Demonstrates how to maintain type safety when using string keys with the new fromEntries implementation by explicitly typing the input array.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/v1-migration/fromEntries.md#2025-04-07_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst DATA = [\n  [\"a\", 123],\n  [\"b\", 456],\n] as const;\n\n// Was\nfromEntries(DATA);\n\n// Now\nfromEntries(DATA as [string, 123 | 456][]);\n```\n\n----------------------------------------\n\nTITLE: Filtering Object Types with isObjectType in TypeScript\nDESCRIPTION: Example showing how to filter an array to extract all object types (including arrays) using the new isObjectType function. This approach checks only the runtime type as defined by the typeof operator.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/v1-migration/isObject.md#2025-04-07_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst DATA = [] as ({ a: number } | number[])[];\n\n// Was\nconst filtered = filter(DATA, isObject);\n//    ^? { a: number }[]\n\n// Now\nconst filtered = filter(DATA, isObjectType);\n//    ^? ({ a: number } | number[])[]\n```\n\n----------------------------------------\n\nTITLE: Migrating from fromPairs to fromEntries in dataLast style (TypeScript)\nDESCRIPTION: Demonstrates how to update pipe-based dataLast usage from fromPairs to fromEntries. In the new version, fromEntries must be called as a function that returns another function.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/v1-migration/fromPairs.md#2025-04-07_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst DATA = [\n  [\"a\", \"b\"],\n  [\"c\", \"d\"],\n] as const;\n\n// Was\nconst result = pipe(DATA, fromPairs);\n//    ^? Record<string, string>\n\n// Now\nconst result = pipe(DATA, fromEntries());\n//    ^? { a: 'b', c: 'd' }\n```\n\n----------------------------------------\n\nTITLE: Updating identity function usage in TypeScript\nDESCRIPTION: This snippet demonstrates how to update the usage of the 'identity' function in Remeda. The function now requires parentheses to create an identity function, as it acts as a factory.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/v1-migration/identity.md#2025-04-07_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// Was\nmap(DATA, identity);\n\n// Now\nmap(DATA, identity());\n```\n\n----------------------------------------\n\nTITLE: Using Object's Clone Method in TypeScript\nDESCRIPTION: Demonstrates the change in cloning behavior where custom clone methods must be called directly instead of relying on the generic clone function.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/v1-migration/clone.md#2025-04-07_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ntype MyType = {\n  readonly clone: () => MyType;\n};\n\ndeclare const DATA: MyType;\n\n// Was\nconst cloned = clone(DATA);\n\n// Now\nconst cloned = DATA.clone();\n```\n\n----------------------------------------\n\nTITLE: Migrating from fromPairs.strict to fromEntries (TypeScript)\nDESCRIPTION: Shows the migration from the strict variant of fromPairs to the standard fromEntries function. The strict variant is no longer needed as fromEntries provides the same type safety by default.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/v1-migration/fromPairs.md#2025-04-07_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst DATA = [\n  [\"a\", \"b\"],\n  [\"c\", \"d\"],\n] as const;\n\n// Was\nfromPairs.strict(DATA);\n\n// Now\nfromEntries(DATA);\n```\n\n----------------------------------------\n\nTITLE: Comparing Intersection Results With Duplicates in TypeScript\nDESCRIPTION: Shows how the new implementation of the intersection function handles inputs with duplicate values differently, taking into account the duplication factor.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/v1-migration/intersection.md#2025-04-07_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\n// Was\nintersection([1, 1, 2, 2], [1]); // => [1, 1]\n\n// Now\nintersection([1, 1, 2, 2], [1]); // => [1]\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Symbol Key Retention in JavaScript Object Manipulation\nDESCRIPTION: This code snippet shows that symbol keys are no longer implicitly omitted when using the 'omit' function. It creates an object with both a symbol key and a string key, then omits the string key property.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/v1-migration/omit.md#2025-04-07_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst mySymbol = Symbol(\"a\");\nconst DATA = { [mySymbol]: \"hello\", a: 123 };\nconst result = omit(DATA, [\"a\"]); // => { [mySymbol]: \"hello\" }, Was: {}\n```\n\n----------------------------------------\n\nTITLE: Migrating fromEntries.strict to fromEntries in TypeScript\nDESCRIPTION: Shows how to update code from the old fromEntries.strict syntax to the new fromEntries implementation while maintaining const assertions.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/v1-migration/fromEntries.md#2025-04-07_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// Was\nfromEntries.strict([\"a\", 1] as const);\n\n// Now\nfromEntries([\"a\", 1] as const);\n```\n\n----------------------------------------\n\nTITLE: Filtering Plain Objects with isPlainObject in TypeScript\nDESCRIPTION: Example showing how to filter an array of mixed types to extract only plain objects using the new isPlainObject function. This approach provides better type inference than the deprecated isObject function.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/v1-migration/isObject.md#2025-04-07_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst DATA = [] as (Date | { a: number })[];\n\n// Was\nconst filtered = filter(DATA, isObject);\n//    ^? (Date | { a: number })[]\n\n// Now\nconst filtered = filter(DATA, isPlainObject);\n//    ^? { a: number }[]\n```\n\n----------------------------------------\n\nTITLE: Using Symbol Keys in Remeda Evolve Operation\nDESCRIPTION: Demonstrates how Symbol keys are no longer silently accepted in evolve operations. The code shows an example that worked in v1 but now raises a TypeScript error to prevent defining transformers for Symbol keys.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/v1-migration/evolve.md#2025-04-07_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst mySymbol = Symbol(\"a\");\n\n// This was fine in v1, will now raise a Typescript error.\nevolve({ [mySymbol]: 123 }, { [mySymbol]: add(1) });\n```\n\n----------------------------------------\n\nTITLE: Avoiding Bugs with Function References in Remeda\nDESCRIPTION: Example showing a potential bug that can occur when passing a function reference as a predicate with the new parameter behavior, and how to fix it by wrapping the function in an arrow function.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/v1-migration/fromKeys.md#2025-04-07_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nfunction callback(item: string, index?: number): boolean {\n  return `${item}${index ?? \"\"}`;\n}\n\n// Bug\nfromKeys([\"a\", \"b\", \"c\"], callback); // => { a: \"a0\", b: \"b1\", c: \"c2\" }, Was { a: \"a\", b: \"b\", c: \"c\" }\n\n// Fix\nfromKeys([\"a\", \"b\", \"c\"], (item) => callback(item)); // => { a: \"a\", b: \"b\", c: \"c\" }\n```\n\n----------------------------------------\n\nTITLE: Replicating Legacy isObject Behavior with Multiple Checks (dataLast)\nDESCRIPTION: Example showing how to replicate the exact behavior of the deprecated isObject function using a combination of isObjectType, isNonNull, and isNot(isArray) in a pipe-based dataLast context.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/v1-migration/isObject.md#2025-04-07_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\n// Was\nfilter(DATA, isObject);\n\n// Now\npipe(DATA, filter(isObjectType), filter(isNonNull), filter(isNot(isArray)));\n```\n\n----------------------------------------\n\nTITLE: Improved Type Inference for Object Entries in TypeScript\nDESCRIPTION: Demonstrates how the return type now preserves the specific key-value types from the input object rather than using generic string and number types.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/v1-migration/entries.md#2025-04-07_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst result = entries({ a: 123 } as const);\n//    ^? ['a', 123][], Was: [string, number][]\n```\n\n----------------------------------------\n\nTITLE: Migrating Flatten to Flat - DataFirst Style in TypeScript\nDESCRIPTION: Examples showing how to migrate from the deprecated 'flatten' function to the new 'flat' function in dataFirst style. The new function supports an optional depth parameter.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/v1-migration/flatten.md#2025-04-07_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// Was\nflatten([[1, 2], [3], [4, 5]]);\n\n// Now\nflat([[1, 2], [3], [4, 5]]);\n\n// Or\nflat([[1, 2], [3], [4, 5]], 1 /* depth */);\n```\n\n----------------------------------------\n\nTITLE: Legacy Type Behavior with Record Type\nDESCRIPTION: Shows how to achieve the legacy string[] typing behavior by using Record<string, unknown> type assertion.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/v1-migration/keys.md#2025-04-07_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nconst result = keys({ 123: \"hello\" } as Record<string, unknown>);\n//    ^? string[]\n```\n\n----------------------------------------\n\nTITLE: Converting Object to Entries using DataFirst Approach in TypeScript\nDESCRIPTION: Demonstrates the migration from toPairs to entries function using the dataFirst approach. Shows improved type inference with more specific tuple types in the result.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/v1-migration/toPairs.md#2025-04-07_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst DATA = { a: \"b\", c: \"d\" } as const;\n\n// Was\nconst result = toPairs(DATA);\n//    ^? [string, \"b\" | \"d\"][]\n\n// Now\nconst result = entries(DATA);\n//    ^? ([\"a\", \"b\"] | [\"c\", \"d\"])[]\n```\n\n----------------------------------------\n\nTITLE: Handling unlimited depth flattening with flat in TypeScript\nDESCRIPTION: This snippet demonstrates the recommended approach for handling unlimited depth flattening using the 'flat' function. It advises against using Number.POSITIVE_INFINITY and suggests using a large constant number like 50 for better typing and performance.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/v1-migration/flattenDeep.md#2025-04-07_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\npipe(\n  [\n    [1, 2],\n    [[3], [4, 5]],\n  ],\n\n  // Don't use:\n  flat(Number.POSITIVE_INFINITY),\n\n  // Use:\n  flat(50 /* depth */),\n);\n```\n\n----------------------------------------\n\nTITLE: MapKeys Third Parameter Bug and Fix Example in TypeScript\nDESCRIPTION: Illustrates a potential bug with the newly added third parameter in mapKeys when using function references as predicates, and demonstrates how to fix it by wrapping in an arrow function.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/v1-migration/mapKeys.md#2025-04-07_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nfunction callback(\n  key: string,\n  value: string,\n  obj: Record<string, string> = {},\n): boolean {\n  return `${key}${value}${Object.keys(obj).length}`;\n}\n\n// Bug\nmapKeys({ a: \"hello\" }, callback); // => { ahello1: \"hello\" }, Was: { ahello: \"hello\" }\n\n// Fix\nmapKeys({ a: \"hello\" }, (key, value) => callback(key, value)); // => { ahello: \"hello\" }\n```\n\n----------------------------------------\n\nTITLE: Migrating from fromPairs to fromEntries in dataFirst style (TypeScript)\nDESCRIPTION: Shows how to convert a dataFirst-style fromPairs call to fromEntries. The function converts an array of key-value pairs into an object. The type inference has improved in the new version.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/v1-migration/fromPairs.md#2025-04-07_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst DATA = [\n  [\"a\", \"b\"],\n  [\"c\", \"d\"],\n] as const;\n\n// Was\nconst result = fromPairs(DATA);\n//    ^? Record<string, string>\n\n// Now\nconst result = fromEntries(DATA);\n//    ^? { a: 'b', c: 'd' }\n```\n\n----------------------------------------\n\nTITLE: Type Narrowing with Predicate Functions in Remeda Find\nDESCRIPTION: Example demonstrating improved type narrowing when using type-predicate functions with find. The result is now correctly narrowed to the type of the predicate.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/v1-migration/find.md#2025-04-07_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst result = find([1, \"a\"] as (string | number)[], isString);\n//    ^? string | undefined, Was: string | number | undefined\n```\n\n----------------------------------------\n\nTITLE: Migrating from Indexed Variant in TypeScript\nDESCRIPTION: Shows how to migrate from the old indexed variant to the new base implementation. The change requires removing the 'indexed' property while maintaining the same parameters.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/v1-migration/mapToObj.md#2025-04-07_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// Was\nmapToObj.indexed(array, mapper);\n\n// Now\nmapToObj(array, mapper);\n```\n\n----------------------------------------\n\nTITLE: Handling Callback Function References in PickBy\nDESCRIPTION: Illustrates potential bugs when using function references as predicates and demonstrates the correct approach to avoid runtime issues with parameter handling.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/v1-migration/pickBy.md#2025-04-07_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst DATA = { hello: \"world\", helloworld: 123 };\n\nfunction callback(\n  value: string,\n  key: string,\n  obj: Record<string, string> = {},\n): boolean {\n  return `${key}${value}` in obj;\n}\n\n// Bug\npickBy(DATA, callback); // => { hello: \"world\" }, Was: DATA\n\n// Fix\npickBy(DATA, (value, key) => callback(key, value)); // => DATA\n```\n\n----------------------------------------\n\nTITLE: Fixing Callback Reference Bug in TypeScript\nDESCRIPTION: Demonstrates a potential bug when using function references with default parameters and shows how to fix it by wrapping the callback in an arrow function.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/v1-migration/findIndex.md#2025-04-07_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nfunction callback(value: number, index = 0): boolean {\n  return (value + index) % 2 === 0;\n}\n\n// Bug\nfindIndex([1, 2, 3], callback); // => [], Was: [2]\n\n// Fix\nfindIndex([1, 2, 3], (item) => callback(item)); // => [2]\n```\n\n----------------------------------------\n\nTITLE: Input Shape Preservation in `mapValues` Function\nDESCRIPTION: Demonstrates how the `mapValues` function better preserves the shape of the input object, including the optionality of properties. This prevents potential runtime errors when accessing properties that might not exist.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/v1-migration/mapValues.md#2025-04-07_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst DATA = { a: 123 } as { a: number; b?: boolean };\n\nconst result = mapValues(DATA, constant(\"hello\"));\n//    ^? { a: string, b?: string }, Was: Record<\"a\" | \"b\", string>\n\n// We don't know in compile time if the object contains the \"b\" prop or not, and\n// thus might not exist on the output object either, therefore it's a mistake to\n// assume that the type of the prop would be `string`.\nconsole.log(result.b);\n//                 ^? string | undefined, Was: string\n```\n\n----------------------------------------\n\nTITLE: Improved Mapper Typing for `mapValues` Function in TypeScript\nDESCRIPTION: Shows how `mapValues` no longer accepts symbol keys and casts number keys as strings. The typing is improved to accurately represent the parameter types passed to the mapper function.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/v1-migration/mapValues.md#2025-04-07_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst mySymbol = Symbol(\"a\");\nmapValues({ [mySymbol]: \"hello\", a: 123, 456: true }, (key, value) => {\n  // key: \"a\" | \"456\", Was symbol | \"a\" | 456;\n  // value: number | boolean, Was string | number | boolean;\n});\n```\n\n----------------------------------------\n\nTITLE: Implementing ForEachObj Without Indexed Variant in TypeScript\nDESCRIPTION: Demonstrates the removal of the indexed variant of forEachObj, showing how the base implementation now handles the same functionality. The callback function receives both value and key parameters.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/v1-migration/forEachObj.md#2025-04-07_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// Was\nforEachObj.indexed({ a: 1, b: 2 }, (value, key) => {\n  console.log(`${key} => ${value}`);\n});\n\n// Now\nforEachObj({ a: 1, b: 2 }, (value, key) => {\n  console.log(`${key} => ${value}`);\n});\n```\n\n----------------------------------------\n\nTITLE: Potential Bug and Fix with Third Parameter in `mapValues`\nDESCRIPTION: Illustrates a potential bug when using function references with the updated `mapValues` that now passes a third parameter (the input object). Shows how to fix this issue by wrapping the function in an arrow function.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/v1-migration/mapValues.md#2025-04-07_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nfunction callback(\n  value: string,\n  key: string,\n  obj: Record<string, string> = {},\n): boolean {\n  return `${key}${value}${Object.keys(obj).length}`;\n}\n\n// Bug\nmapValues({ a: \"hello\" }, callback); // => { a: \"ahello1\" }, Was: { a: \"ahello\" }\n\n// Fix\nmapValues({ a: \"hello\" }, (value, key) => callback(value, key)); // => { a: \"ahello\" }\n```\n\n----------------------------------------\n\nTITLE: Demonstrating tuple shape preservation in TypeScript\nDESCRIPTION: Example showing how Remeda now preserves the shape of tuple inputs in the return type. Instead of converting tuples to generic arrays, the output type reflects the input tuple structure, providing more precise typing.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/v1-migration/sortBy.md#2025-04-07_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst DATA = [1, true, \"hello\"] as [number, boolean, ...string[]];\n\nconst result = sortBy(DATA, identity());\n//    ^? [number | boolean | string, number | boolean | string, ...(number | boolean | string)[]]\n//  Was: (number | boolean | string)[]\n```\n\n----------------------------------------\n\nTITLE: Handling Symbol Keys in ForEachObj\nDESCRIPTION: Shows how symbol keys are handled in the updated implementation. Symbol keys are no longer passed to the callback function, and their values are excluded from typing.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/v1-migration/forEachObj.md#2025-04-07_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst mySymbol = Symbol(\"a\");\nforEachObj({ [mySymbol]: \"hello\", a: 123 }, (value, key) => {\n  // value: 123, Was: 123 | \"hello\".\n  // key: \"a\", Was: \"a\" | symbol.\n});\n```\n\n----------------------------------------\n\nTITLE: Fixing Potential Bugs with Remeda Map Function Parameters\nDESCRIPTION: Example showing a potential bug that can occur with the updated map function that now passes additional parameters (index and array) to the mapper function. If using function references instead of arrow functions, unexpected behavior may occur.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/v1-migration/mapWithFeedback.md#2025-04-07_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nfunction sum(a: number, b = 0, c = 0) {\n  return a + b + c;\n}\n\n// Bug\nmapWithFeedback([1, 2, 3], sum, 0); // => [1, 4, 9], Was: [1, 3, 6]\n\n// Fix\nmapWithFeedback([1, 2, 3], (prev, current) => sum(prev, current), 0); // => [1, 3, 6]\n```\n\n----------------------------------------\n\nTITLE: Migrating from zipObj to zip and fromEntries in TypeScript\nDESCRIPTION: This snippet demonstrates how to replace the deprecated zipObj function with a combination of zip and fromEntries functions in Remeda. It shows the old usage of zipObj and the new equivalent using zip and fromEntries.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/v1-migration/zipObj.md#2025-04-07_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// Was\nzipObj(a, b);\n\n// Now\nfromEntries(zip(a, b));\n```\n\n----------------------------------------\n\nTITLE: Number Key Handling in ForEachObj\nDESCRIPTION: Demonstrates how number keys are now cast to strings when passed to the predicate function in the callback.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/v1-migration/forEachObj.md#2025-04-07_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nforEachObj({ 123: \"hello\" }, (value, key) => {\n  // key: \"123\", Was: 123.\n});\n```\n\n----------------------------------------\n\nTITLE: Potential Bug and Fix with Function References in Remeda's omitBy (TypeScript)\nDESCRIPTION: This example showcases a potential bug when using function references with omitBy due to the addition of a third parameter. It also provides a fix by using an inline arrow function to correctly pass arguments to the callback.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/v1-migration/omitBy.md#2025-04-07_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nconst DATA = { hello: \"world\", helloworld: 123 };\n\nfunction callback(\n  value: string,\n  key: string,\n  obj: Record<string, string> = {},\n): boolean {\n  return `${key}${value}` in obj;\n}\n\n// Bug\nomitBy(DATA, callback); // => { helloworld: 123 }, Was: DATA\n\n// Fix\nomitBy(DATA, (value, key) => callback(key, value)); // => DATA\n```\n\n----------------------------------------\n\nTITLE: Replacing flatMapToObj with fromEntries and flatMap (TypeScript)\nDESCRIPTION: This snippet demonstrates how to replace the dataFirst version of flatMapToObj with a composition of fromEntries and flatMap. It filters odd numbers from an array and creates an object with the numbers as keys and values.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/v1-migration/flatMapToObj.md#2025-04-07_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// Was\nflatMapToObj([1, 2, 3], (x) => (x % 2 === 1 ? [[String(x), x]] : []));\n\n// Now\nfromEntries(flatMap([1, 2, 3], (x) => (x % 2 === 1 ? [[String(x), x]] : [])));\n```\n\n----------------------------------------\n\nTITLE: Converting Number Keys to Strings in Object Entries\nDESCRIPTION: Shows how number keys in objects are now correctly typed as strings in the return type, matching JavaScript's runtime behavior where object keys are always strings.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/v1-migration/entries.md#2025-04-07_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\n// Was\nconst result = entries.strict({ 123: \"hello\" } as const);\n//    ^? [123, \"hello\"][]\n\n// Now\nconst result = entries({ 123: \"hello\" } as const);\n//    ^? ['123', \"hello\"][]\n```\n\n----------------------------------------\n\nTITLE: Migrating Indexed Partition Usage in TypeScript\nDESCRIPTION: Shows how to migrate from the old indexed variant to the new base implementation of the partition function. The new implementation maintains the same parameters without requiring the indexed prefix.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/v1-migration/partition.md#2025-04-07_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// Was\npartition.indexed(array, predicate);\n\n// Now\npartition(array, predicate);\n```\n\n----------------------------------------\n\nTITLE: Replacing countBy with filter and length in TypeScript (dataLast)\nDESCRIPTION: This snippet shows how to replace the countBy function with filter and length in a dataLast scenario using pipe. It demonstrates counting even numbers in an array using a functional approach.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/v1-migration/countBy.md#2025-04-07_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n// Was\npipe(\n  [1, 2, 3, 4],\n  countBy((item) => item % 2 === 0),\n);\n\n// Now\npipe(\n  [1, 2, 3, 4],\n  filter((item) => item % 2 === 0),\n  length(),\n);\n```\n\n----------------------------------------\n\nTITLE: Comparing 'createPipe' and 'piped' Function Usage in TypeScript\nDESCRIPTION: This example demonstrates the change from the old 'createPipe' function to the renamed 'piped' function in Remeda. Both perform the same operation, creating a pipeline of functions (map and filter in this case).\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/v1-migration/createPipe.md#2025-04-07_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// Was\ncreatePipe(map(mapper), filter(predicate));\n\n// Now\npiped(map(mapper), filter(predicate));\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Mapper Typing in TypeScript PickBy Function\nDESCRIPTION: Shows how the pickBy function handles symbol keys and number keys, with key types being narrowed to string representations and value types being appropriately constrained.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/v1-migration/pickBy.md#2025-04-07_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst mySymbol = Symbol(\"a\");\npickBy({ [mySymbol]: \"hello\", a: 123, 456: true }, (key, value) => {\n  // key: \"a\" | \"456\", Was symbol | \"a\" | 456;\n  // value: number | boolean, Was string | number | boolean;\n});\n```\n\n----------------------------------------\n\nTITLE: Migrating Indexed Variant Usage in TypeScript\nDESCRIPTION: Shows how to migrate from the deprecated indexed variant to the new base implementation that now includes the same parameters.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/v1-migration/meanBy.md#2025-04-07_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// Was\nmeanBy.indexed(array, mapper);\n\n// Now\nmeanBy(array, mapper);\n```\n\n----------------------------------------\n\nTITLE: Data-First Filter Migration Example in TypeScript\nDESCRIPTION: Shows how to replace compact() with filter(isTruthy) in data-first style where data is passed as the first argument.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/v1-migration/compact.md#2025-04-07_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// Was\ncompact([1, null, 3]);\n\n// Now\nfilter([1, null, 3], isTruthy);\n```\n\n----------------------------------------\n\nTITLE: Migrating from Headless to Explicit Function Invocation in TypeScript\nDESCRIPTION: This example demonstrates how to update code following the removal of the 'headless' mode in Remeda. Instead of passing the function reference directly, you now need to explicitly invoke the function with parentheses.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/v1-migration/randomString.md#2025-04-07_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// Was:\nmap([1, 2, 3], randomString);\n\n// Now:\nmap([1, 2, 3], randomString());\n```\n\n----------------------------------------\n\nTITLE: Fixing parseInt Bug with Arrow Functions\nDESCRIPTION: Shows how to properly handle parseInt with string arrays by using an arrow function wrapper to avoid issues with additional parameters being passed to the function reference.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/v1-migration/sumBy.md#2025-04-07_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n// Bug\nsumBy([\"1\", \"2\", \"3\"], parseInt); // => NaN, Was: 6\n\n// Fix\nsumBy([\"1\", \"2\", \"3\"], (item) => parseInt(item)); // => 6\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Improved TypeScript Array Concatenation Types\nDESCRIPTION: Shows how the concat function maintains more precise type information when combining a tuple with specific number literals and a string array. The resulting type preserves the literal types from the tuple while properly handling the rest of the array.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/v1-migration/concat.md#2025-04-07_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst a = [1, 2, 3] as const;\nconst b = [\"hello\", \"world\"] as string[];\n\nconst concatenated = concat(a, b);\n//    ^? [1, 2, 3, ...string[]], was: (string | 1 | 2 | 3)[]\n```\n\n----------------------------------------\n\nTITLE: Using Remeda Sample Function with Invalid Inputs in TypeScript\nDESCRIPTION: Demonstrates how the updated sample function handles negative and non-integer sample sizes by returning an empty array rather than throwing an error. This change brings the function's behavior in line with other library functions and built-in JavaScript methods.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/v1-migration/sample.md#2025-04-07_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// No longer throws:\nsample([1, 2, 3], -1); // => []\n\n// No longer throws:\nsample([1, 2, 3], 2.5); // => []\n```\n\n----------------------------------------\n\nTITLE: Potential Bug with Function References in TypeScript\nDESCRIPTION: Example showing a potential bug when using function references with default parameters. The solution is to use an arrow function wrapper to ensure only the necessary parameters are passed to the callback function.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/v1-migration/uniqueBy.md#2025-04-07_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nfunction callback(item: number, index = 0): boolean {\n  return item - index;\n}\n\n// Bug\nuniqueBy([1, 2, 3], callback); // => [1], Was: [1, 2, 3]\n\n// Fix\nuniqueBy([1, 2, 3], (item) => callback(item)); // => [1, 2, 3]\n```\n\n----------------------------------------\n\nTITLE: Demonstrating New Parameters in dropLastWhile Function (TypeScript)\nDESCRIPTION: This example shows how to use the new 'index' parameter in the predicate function of dropLastWhile. The predicate now has access to both the current item and its index in the array.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/v1-migration/dropLastWhile.md#2025-04-07_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// This was previously unavailable\ndropLastWhile([1, 2, 3], (item, index) => item + (index % 2) === 0);\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Typo Protection in Remeda's setPath Function (TypeScript)\nDESCRIPTION: This snippet shows how the new implementation of setPath in Remeda provides better typo protection by surfacing TypeScript errors on the path itself when an incorrect property is specified.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/v1-migration/setPath.md#2025-04-07_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n// Would surface a typescript error on the path itself.\npipe({ a: { b: 456 } }, setPath([\"a\", \"c\"], 123));\n```\n\n----------------------------------------\n\nTITLE: Migrating from uniqBy to uniqueBy in TypeScript\nDESCRIPTION: Example showing the function name change from uniqBy to uniqueBy. The functionality remains the same, only the function name has been updated for consistency.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/v1-migration/uniqBy.md#2025-04-07_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// Was\nuniqBy(data, mapper);\n\n// Now\nuniqueBy(data, mapper);\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Removal of Indexed Variant in Remeda forEach Function (TypeScript)\nDESCRIPTION: This snippet shows how the 'indexed' variant of the forEach function has been removed, and how the base implementation now takes the same parameters. Users can simply remove the 'indexed' call without any other changes.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/v1-migration/forEach.md#2025-04-07_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// Was\nforEach.indexed([1, 2, 3], (item, index) => {\n  console.log(item + index);\n});\n\n// Now\nforEach([1, 2, 3], (item, index) => {\n  console.log(item + index);\n});\n```\n\n----------------------------------------\n\nTITLE: TypeScript Sort with Preserved Tuple Shape\nDESCRIPTION: Illustrates how the sort function preserves the input tuple shape in the return type, showing improved type inference for mixed-type arrays. The example demonstrates sorting a tuple with number, boolean, and string types.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/v1-migration/sort.md#2025-04-07_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst DATA = [1, true, \"hello\"] as [number, boolean, ...string[]];\n\nconst result = sort(DATA, (a, b) => a - b);\n//    ^? [number | boolean | string, number | boolean | string, ...(number | boolean | string)[]]\n```\n\n----------------------------------------\n\nTITLE: Migrating from Indexed Reduce Implementation in TypeScript\nDESCRIPTION: Shows how to migrate from the old indexed variant to the new base implementation of reduce. The functionality remains the same but the 'indexed' prefix is removed.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/v1-migration/reduce.md#2025-04-07_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// Was\nreduce.indexed([1, 2, 3], (acc, item, index) => acc + item + index, 0);\n\n// Now\nreduce([1, 2, 3], (acc, item, index) => acc + item + index, 0);\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Narrowed Result Type in TypeScript\nDESCRIPTION: Shows how the typing for the 'other' operand was widened to accept any value, allowing for narrowed return types in the intersection of two types.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/v1-migration/intersection.md#2025-04-07_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst DATA1 = [] as (string | number)[];\nconst DATA2 = [] as (number | boolean)[];\n\n// Was a type error, now okay:\nconst intersected = intersection(DATA1, DATA2);\n//    ^? number[];\n```\n\n----------------------------------------\n\nTITLE: Migrating from Indexed Variant in TypeScript\nDESCRIPTION: Shows how to migrate from the deprecated indexed variant to the new implementation of sortedIndexBy function. The base implementation now handles the same parameters directly.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/v1-migration/sortedIndexBy.md#2025-04-07_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// Was\nsortedIndexBy.indexed(array, mapper);\n\n// Now\nsortedIndexBy(array, mapper);\n```\n\n----------------------------------------\n\nTITLE: Handling Potential Bugs with Function References in TypeScript Reduce\nDESCRIPTION: Demonstrates a potential bug when using function references with default parameters and shows the correct way to implement the callback to avoid unexpected behavior.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/v1-migration/reduce.md#2025-04-07_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nfunction callback(acc: number, item: number, index = 0): number {\n  return acc + item + index;\n}\n\n// Bug\nreduce([1, 2, 3], callback, 0); // => 9, Was: 6\n\n// Fix\nreduce([1, 2, 3], (acc, item) => callback(acc, item), 0); // => 6\n```\n\n----------------------------------------\n\nTITLE: Replicating Legacy isObject Behavior with Multiple Checks (dataFirst)\nDESCRIPTION: Example showing how to replicate the exact behavior of the deprecated isObject function using a combination of isObjectType, isNonNull, and isArray checks in a dataFirst context.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/v1-migration/isObject.md#2025-04-07_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\n// Was\nif (isObject(DATA)) {\n  //\n}\n\n// Now\nif (isObjectType(DATA) && isNonNull(DATA) && !isArray(DATA)) {\n  //\n}\n```\n\n----------------------------------------\n\nTITLE: Fixing parseInt Bug in sortedLastIndexBy Function\nDESCRIPTION: Shows a potential bug when using parseInt as a direct function reference and demonstrates the correct way to implement the parsing using an arrow function wrapper.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/v1-migration/sortedLastIndexBy.md#2025-04-07_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n// Bug\nsortedLastIndexBy([\"1\", \"10\"], \"2\", parseInt); // => 2, Was: 1\n\n// Fix\nsortedLastIndexBy([\"1\", \"10\"], \"2\", (item) => parseInt(item)); // => 1\n```\n\n----------------------------------------\n\nTITLE: Updating Indexed Map Variant in Remeda\nDESCRIPTION: Example showing how to update code after the removal of the indexed variant in Remeda's map function. The base implementation now takes the same parameters, so you can simply remove the '.indexed' part from function calls.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/v1-migration/mapWithFeedback.md#2025-04-07_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// Was\nmapWithFeedback.indexed(array, mapper);\n\n// Now\nmapWithFeedback(array, mapper);\n```\n\n----------------------------------------\n\nTITLE: Symbol Key Handling in TypeScript\nDESCRIPTION: Shows how symbol keys are handled by the keys function, resulting in an empty array as symbols are filtered out.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/v1-migration/keys.md#2025-04-07_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst mySymbol = Symbol(\"a\");\nkeys({ [mySymbol]: 123 }); // => [];\n```\n\n----------------------------------------\n\nTITLE: Removing Indexed Variant in TypeScript\nDESCRIPTION: Demonstrates the migration from using the indexed variant to the base implementation, which now accepts the same parameters.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/v1-migration/sumBy.md#2025-04-07_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// Was\nsumBy.indexed(array, mapper);\n\n// Now\nsumBy(array, mapper);\n```\n\n----------------------------------------\n\nTITLE: Illustrating Potential Bug and Fix in Remeda forEach Function (TypeScript)\nDESCRIPTION: This example demonstrates a potential bug that can occur when using a function reference with default parameters as the callback in the forEach function. It also shows how to fix this issue by wrapping the callback in an arrow function.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/v1-migration/forEach.md#2025-04-07_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nfunction callback(value: number, index = 0): boolean {\n  console.log(item + index);\n}\n\n// Bug\nforEach([1, 2, 3], callback); // \"1, 3, 5\", Was: \"1, 2, 3\"\n\n// Fix\nforEach([1, 2, 3], (item) => callback(item)); // => \"1, 2, 3\"\n```\n\n----------------------------------------\n\nTITLE: Number Key Conversion in TypeScript\nDESCRIPTION: Illustrates how numeric keys are converted to strings in the resulting array.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/v1-migration/keys.md#2025-04-07_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nkeys({ 123: \"hello\" }); // [\"123\"];\n```\n\n----------------------------------------\n\nTITLE: Potential Bug and Fix When Using Function References in Remeda\nDESCRIPTION: Illustrates a common bug when using function references with default parameters as predicates. Shows both the problematic code that causes unexpected results and the proper fix using an arrow function wrapper.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/v1-migration/takeLastWhile.md#2025-04-07_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nfunction callback(item: number, index = 0): string {\n  return item > index;\n}\n\n// Bug\ntakeLastWhile([1, 1, 1], callback); // => [1, 1, 1], Was: [1]\n\n// Fix\ntakeLastWhile([1, 1, 1], (item) => callback(item)); // => [1]\n```\n\n----------------------------------------\n\nTITLE: Implementing Early Exit Logic in Lodash and Remeda\nDESCRIPTION: Illustrates how to implement early exit patterns. Lodash allows returning false from the callback to exit early, while Remeda requires using pipe with takeWhile for similar functionality since its forEach callback must return void.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/mapping/lodash/forEach.md#2025-04-07_snippet_2\n\nLANGUAGE: ts\nCODE:\n```\n// Lodash\nforEach([1, 2, 3], (item) => (item === 2 ? false : console.log(item)));\n\n// Remeda\n// ❌ You can't return a value in a forEach callback in Remeda:\nforEach([1, 2, 3], (item) => (item === 2 ? false : console.log(item)));\n\n// ✅ Instead you can rely on lazy evaluation of pipes:\npipe(\n  [1, 2, 3],\n  takeWhile((item) => item !== 2),\n  forEach((item) => {\n    console.log(item);\n  }),\n);\n```\n\n----------------------------------------\n\nTITLE: Updated Pipe Usage with Keys Function\nDESCRIPTION: Demonstrates the change in pipe usage where headless version is replaced with functional style.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/v1-migration/keys.md#2025-04-07_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\n// Was\npipe(DATA, keys);\n\n// Now\npipe(DATA, keys());\n```\n\n----------------------------------------\n\nTITLE: Using Additional Predicate Parameters in Remeda's takeWhile Function\nDESCRIPTION: Demonstrates how to utilize the additional index parameter in a takeWhile predicate function. The predicate compares each item to its index position, taking elements while the item value exceeds the index.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/v1-migration/takeWhile.md#2025-04-07_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ntakeWhile([1, 2, 3], (item, index) => item > index);\n```\n\n----------------------------------------\n\nTITLE: Implementing forEachRight for Objects in TypeScript\nDESCRIPTION: This snippet shows how to iterate through object properties in reverse order using both Lodash's forEachRight and native JavaScript. It demonstrates how to break the iteration when a specific value is encountered, similar to returning false in Lodash.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/mapping/lodash/forEachRight.md#2025-04-07_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst DATA = { a: 1, b: 2, c: 3 };\n\n// Lodash\nforEachRight(DATA, (value) => (value === 2 ? false : console.log(value)));\n\n// Native\nconst keys = Object.keys(DATA);\nfor (const index = keys.length - 1; index >= 0; index--) {\n  const value = DATA[key]!;\n  if (value === 2) {\n    break;\n  }\n\n  console.log(value);\n}\n```\n\n----------------------------------------\n\nTITLE: Migrating Strict Variant Usage in TypeScript\nDESCRIPTION: Shows how to update code that previously used the strict variant of the map function. The strict suffix is no longer needed as it's now the default behavior.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/v1-migration/map.md#2025-04-07_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// Was\nmap.strict(array, mapper);\n\n// Now\nmap(array, mapper);\n```\n\n----------------------------------------\n\nTITLE: RegExp Type Checking in TypeScript\nDESCRIPTION: Demonstrates how to check if a value is a regular expression using instanceof operator.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/v1-migration/type.md#2025-04-07_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nconst DATA = /abc/;\n\n// Was\ntype(DATA) === \"RegExp\";\n\n// Now\nDATA instanceof RegExp;\n```\n\n----------------------------------------\n\nTITLE: Demonstrating No Forward Typing in Remeda's setPath Function (TypeScript)\nDESCRIPTION: This snippet illustrates the change in Remeda's setPath function, moving from a forward-typing approach to a pipe-based implementation that validates the path exists in the piped object and is of the correct type.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/v1-migration/setPath.md#2025-04-07_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// Was: **The operand** for `setter` would be checked that the path [\"a\", \"b\"]\n// exists on it and is of the right type.\nconst setter = setPath([\"a\", \"b\"], 123);\nsetter({ a: { b: 456 } }); // => { a: { b: 123 }}\n\n// Now: We now validate that **the path** exists in the piped object and is of\n// the correct type.\npipe({ a: { b: 456 } }, setPath([\"a\", \"b\"], 123));\n```\n\n----------------------------------------\n\nTITLE: Legacy Type Casting in TypeScript\nDESCRIPTION: Shows how to achieve the previous typing behavior by explicitly casting the input tuple to an array type.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/v1-migration/map.md#2025-04-07_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nconst DATA = [\"hello\"] as [string, ...string[]];\n\nconst mapped = map(DATA as string[], (item) => item.length);\n//    ^? number[]\n```\n\n----------------------------------------\n\nTITLE: Migration Example: uniqWith to uniqueWith in TypeScript\nDESCRIPTION: Shows before and after code examples of the function rename from uniqWith to uniqueWith. The function maintains the same parameters and behavior, only the name has changed.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/v1-migration/uniqWith.md#2025-04-07_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// Was\nuniqWith(data, isEquals);\n\n// Now\nuniqueWith(data, isEquals);\n```\n\n----------------------------------------\n\nTITLE: Migration from Headless to Functional Style\nDESCRIPTION: Shows the migration from the deprecated headless dataLast form to the new required functional style when using pipe with values.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/v1-migration/values.md#2025-04-07_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n// Was\npipe(DATA, values);\n\n// Now\npipe(DATA, values());\n```\n\n----------------------------------------\n\nTITLE: MapKeys with Partial Result Return Type in TypeScript\nDESCRIPTION: Shows how mapKeys now correctly returns a Partial type when using literal union key mapping, fixing potential type safety issues when accessing mapped properties.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/v1-migration/mapKeys.md#2025-04-07_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst result = mapKeys(\n  //  ^? Partial<Record<\"yes\" | \"no\", string>>, Was: Record<\"yes\" | \"no\", string>\n  { a: \"hello\" } as Record<string, string>,\n  (key) => (key.length > 3 ? \"yes\" : \"no\"),\n);\n\n// It's possible none of the keys mapped to \"yes\", so the type here is\n// `string | undefined`:\nconsole.log(result.yes);\n//                 ^? string | undefined, Was: string\n```\n\n----------------------------------------\n\nTITLE: Improved Tuple Type Preservation in zip Function\nDESCRIPTION: Demonstrates how the zip function now correctly preserves positional types in tuples, allowing types to be zipped together. The example shows zipping two constant arrays and how the result type has improved.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/v1-migration/zip.md#2025-04-07_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst A = [1, 2, 3] as const;\nconst B = [\"a\", \"b\", \"c\"] as const;\n\n// Was\nconst result = zip(A, B);\n//    ^? [1 | 2 | 3, \"a\" | \"b\" | \"c\"][]\n\n// Now\nconst result = zip(A, B);\n//    ^? [[1, \"a\"], [2, \"b\"], [3, \"c\"]]\n```\n\n----------------------------------------\n\nTITLE: Replacing noop with constant(undefined) for Required Return Values in Remeda\nDESCRIPTION: Shows how to replace the deprecated 'noop' function with 'constant(undefined)' when a return value is required, as demonstrated in a map example.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/v1-migration/noop.md#2025-04-07_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n// Was\nmap(DATA, noop);\n\n// Now\nmap(DATA, constant(undefined));\n```\n\n----------------------------------------\n\nTITLE: Handling Additional Parameters in Mapper Callback\nDESCRIPTION: Demonstrates a potential bug when using function references with default parameters and shows how to fix it by wrapping the callback in an arrow function. The example illustrates how the new implementation affects parameter handling.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/v1-migration/mapToObj.md#2025-04-07_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nfunction callback(key: string, index = 0) {\n  return [key, index];\n}\n\n// Bug\nmapToObj([\"a\", \"b\", \"c\"], callback); // => { a: 0, b: 1, c: 2 }, Was: { a: 0, b: 0, c: 0 }\n\n// Fix\nmapToObj([\"a\", \"b\", \"c\"], (item) => callback(item)); // => { a: 0, b: 0, c: 0 }\n```\n\n----------------------------------------\n\nTITLE: Illustrating Potential Bug and Fix in Remeda's zipWith Function (TypeScript)\nDESCRIPTION: This snippet shows a potential bug that can occur when using a function reference with the updated zipWith, and provides a fix. It demonstrates how the additional parameters can affect the result if not handled properly.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/v1-migration/zipWith.md#2025-04-07_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst DATA_A = [1, 2, 3] as const;\nconst DATA_B = [4, 5, 6] as const;\n\nfunction callback(itemA: number, itemB: number, index = 0): boolean {\n  return itemA + itemB - index;\n}\n\n// Bug\nzipWith(A, B, callback); // => [5, 6, 7], Was: [5, 7, 9]\n\n// Fix\nzipWith(A, B, (itemA, itemB) => callback(itemA, itemB)); // => [5, 6, 7]\n```\n\n----------------------------------------\n\nTITLE: Type Differences Between Remeda v1 and v2\nDESCRIPTION: Comparison of type inference between Remeda v1 and v2. The strict variant's improved typing is now the default in v2, resulting in more precise types like tuple types instead of generic arrays.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/docs-articles/v1/migration-variants.md#2025-04-07_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst DATA = [\"1\", \"2\", \"3\"] as const;\n\nconst was = map(DATA, (item) => Number.parseInt(item));\n//    ^? number[];\n\nconst now = map(DATA, (item) => Number.parseInt(item));\n//    ^? [number, number, number]\n```\n\n----------------------------------------\n\nTITLE: Explicitly Omitting Symbol Keys in JavaScript Object Manipulation\nDESCRIPTION: This code snippet demonstrates how symbol keys can be explicitly targeted for omission. It creates an object with two symbol keys and omits one of them using the 'omit' function.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/v1-migration/omit.md#2025-04-07_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst symbolA = Symbol(\"a\");\nconst symbolB = Symbol(\"b\");\nconst DATA = { [symbolA]: \"hello\", [symbolB]: 123 };\nconst result = omit(DATA, [symbolA]); // => { [symbolB]: 123 }, Was: {}\n```\n\n----------------------------------------\n\nTITLE: Handling Callback Reference Issue with Indexed Parameters\nDESCRIPTION: Example of a potential bug when passing callbacks by reference in Remeda v2. Functions like parseInt that take an optional second parameter can cause unexpected behavior when passed directly to map. The solution is to wrap the callback in an inline function.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/docs-articles/v1/migration-variants.md#2025-04-07_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst DATA = [\"1\", \"2\", \"3\"] as const;\n\n// BUG! `parseInt` takes an optional 2nd `number` param for the radix!\nmap(DATA, Number.parseInt); //=> [1, NaN, NaN]\n\n// Fix:\nmap(DATA, (item) => Number.parseInt(item)); //=> [1, 2, 3]\n```\n\n----------------------------------------\n\nTITLE: Replacing toPairs/fromPairs with entries/fromEntries\nDESCRIPTION: Shows the migration from Lodash-style pair conversion functions to ECMAScript standard entry conversion functions.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/docs-articles/v1/migration-removed.md#2025-04-07_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\n// Was\npipe(DATA, toPairs(), ..., fromPairs());\n\n// Now\npipe(DATA, entries(), ..., fromEntries())\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Mapper Typing in Remeda's omitBy Function (TypeScript)\nDESCRIPTION: This snippet shows how the omitBy function now handles symbol keys and number keys in its predicate function. It demonstrates the new typing behavior where symbol keys are excluded and number keys are cast to strings.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/v1-migration/omitBy.md#2025-04-07_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst mySymbol = Symbol(\"a\");\nomitBy({ [mySymbol]: \"hello\", a: 123, 456: true }, (key, value) => {\n  // key: \"a\" | \"456\", Was symbol | \"a\" | 456;\n  // value: number | boolean, Was string | number | boolean;\n});\n```\n\n----------------------------------------\n\nTITLE: Working Around Stricter Types in Remeda v2\nDESCRIPTION: Examples of different approaches to work around the stricter typing in Remeda v2. Shows how to use type assertions, the satisfies keyword, explicit generics, or type casting to get back to less specific types when needed.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/docs-articles/v1/migration-variants.md#2025-04-07_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\n// Downstream bugs revealed:\n\n// @ts-expect-error [ts(2493)]Tuple type '[number]' of length '1' has no element at index '1'.\nconst [, buggy] = map([\"1\"] as const, (x) => Number.parseInt(x));\n\n// Get the legacy behavior:\n\nconst strict = map([\"1\", \"2\", \"3\"] as const, (x) => Number.parseInt(x));\n//    ^? [number, number, number]\n\nconst satisfied = map([\"1\", \"2\", \"3\"] satisfies `${number}`[], (x) =>\n//  ^? number[];\n  Number.parseInt(x),\n);\n\nconst generalized = map<`${number}`[], number[]>(\n  [\"1\", \"2\", \"3\"] as const,\n  (x) =>\n    //  ^? number[]\n    Number.parseInt(x),\n);\n\nconst casted = map([\"1\", \"2\", \"3\"] as `${number}`[], (x) =>\n//  ^? number[];\n  Number.parseInt(x),\n);\n\nconst castedOutput = map([\"1\", \"2\", \"3\"] as const, (x) =>\n  Number.parseInt(x),\n) as number[];\n```\n\n----------------------------------------\n\nTITLE: Replacing compact() with filter()\nDESCRIPTION: Shows how to replace the removed compact() function with a combination of filter() and isTruthy predicates to achieve the same functionality.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/docs-articles/v1/migration-removed.md#2025-04-07_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// Was\ncompact(DATA);\n\n// Now\nfilter(DATA, isTruthy);\n```\n\n----------------------------------------\n\nTITLE: Narrowed Return Type Example in Remeda's omitBy Function (TypeScript)\nDESCRIPTION: This example demonstrates how using a type-guard predicate with omitBy now narrows the resulting type. It shows how the function can infer and exclude string properties from the result type.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/v1-migration/omitBy.md#2025-04-07_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst DATA = { a: 123, b: 456 } as {\n  a: number;\n  b: number | string;\n  c?: number;\n  d: string;\n};\nconst result = omitBy(DATA, isString);\n//    ^? { a: number, b?: number, c?: number }, Was: typeof DATA\n```\n\n----------------------------------------\n\nTITLE: Math Operations Documentation in Markdown\nDESCRIPTION: Mathematical operation functions.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/mapping/ramda/__MISSING.md#2025-04-07_snippet_3\n\nLANGUAGE: markdown\nCODE:\n```\n# Math\n\n- mathMod\n- modulo\n```\n\n----------------------------------------\n\nTITLE: Logic Operations Documentation in Markdown\nDESCRIPTION: Boolean logic and conditional operation functions.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/mapping/ramda/__MISSING.md#2025-04-07_snippet_2\n\nLANGUAGE: markdown\nCODE:\n```\n# Logic\n\n- and\n- both\n- complement\n- either\n- isNotEmpty\n- or\n- pathSatisfies\n- propSatisfies\n- unless\n- until\n- xor\n```\n\n----------------------------------------\n\nTITLE: Type Narrowing with PickBy Function\nDESCRIPTION: Demonstrates how the pickBy function narrows return types when used with type guards, showing type inference improvements for object properties.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/v1-migration/pickBy.md#2025-04-07_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst DATA = { a: 123, b: 456 } as {\n  a: number;\n  b: number | string;\n  c?: number;\n  d: string;\n};\nconst result = pickBy(DATA, isNumber);\n//    ^? { a: number, b?: number, c?: number }, Was: typeof DATA\n```\n\n----------------------------------------\n\nTITLE: String Operations Documentation in Markdown\nDESCRIPTION: String manipulation and pattern matching functions.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/mapping/ramda/__MISSING.md#2025-04-07_snippet_6\n\nLANGUAGE: markdown\nCODE:\n```\n# String\n\n- match\n- replace\n- test\n- toString\n- trim\n```\n\n----------------------------------------\n\nTITLE: Object Operations Documentation in Markdown\nDESCRIPTION: Object manipulation and lens operations for working with object properties and paths.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/mapping/ramda/__MISSING.md#2025-04-07_snippet_4\n\nLANGUAGE: markdown\nCODE:\n```\n# Object\n\n- dissoc\n- dissocPath\n- eqProps\n- has\n- hasIn\n- hasPath\n- invert\n- keysIn\n- lens\n- lensIndex\n- lensPath\n- lensProp\n- mergeDeepLeft\n- mergeDeepWith\n- mergeDeepWithKey\n- mergeLeft\n- mergeWith\n- mergeWithKey\n- modify\n- modifyPath\n- over\n- path\n- paths\n- pickAll\n- project\n- propOr\n- props\n- toPairsIn\n- unwind\n- valuesIn\n- view\n- whereAny\n- whereEq\n```\n\n----------------------------------------\n\nTITLE: Potential Bug with Function References in Remeda\nDESCRIPTION: Example demonstrating a potential bug when using function references with Remeda's pullObject function. It shows how the additional parameters can cause unexpected behavior with functions like parseInt, and provides a fix using inline arrow functions.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/v1-migration/pullObject.md#2025-04-07_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nfunction callback(item: string, index?: number): string {\n  return `${item}${index ?? \"\"}`;\n}\n\n// Bug\npullObject([\"1\", \"2\", \"3\"], callback, parseInt); // => { 10: 1, 21: NaN, 32: NaN }, Was: { 1: 1, 2: 2, 3: 3 }\n\n// Fix\npullObject(\n  [\"1\", \"2\", \"3\"],\n  (item) => callback(item),\n  (item) => parseInt(item),\n); // => { 1: 1, 2: 2, 3: 3 }\n```\n\n----------------------------------------\n\nTITLE: Including Pre-Built Scripts Inline in HTML\nDESCRIPTION: Example showing how to include a pre-processed script as an inline script in an HTML file. The script is referenced from the public/dist/scripts folder and will run before the page is loaded.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/scripts/README.md#2025-04-07_snippet_0\n\nLANGUAGE: html\nCODE:\n```\n<script is:inline src=\"/dist/scripts/<__SCRIPT_NAME__>.js\"></script>\n```\n\n----------------------------------------\n\nTITLE: Relation Operations Documentation in Markdown\nDESCRIPTION: Comparison and relation functions for working with values and collections.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/mapping/ramda/__MISSING.md#2025-04-07_snippet_5\n\nLANGUAGE: markdown\nCODE:\n```\n# Relation\n\n- eqBy\n- gt\n- gte\n- identical\n- lt\n- lte\n- pathEq\n- propEq\n- symmetricDifference\n- symmetricDifferenceWith\n- union\n- unionWith\n```\n\n----------------------------------------\n\nTITLE: Refactoring Purry Function Calls with Object.assign Pattern in TypeScript\nDESCRIPTION: Shows how to transition from using Object.assign to attach lazy implementations to dataFirst functions to passing the lazy implementation directly as the third parameter in purry calls.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/v1-migration/purry.md#2025-04-07_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nfunction myFunc(...args: readonly unknown[]): unknown {\n  // Was:\n  return purry(withLazy, args);\n\n  // Now:\n  return purry(dataFirstImpl, args, lazyImpl);\n}\n\n// This can be removed now:\nfunction withLazy = Object.assign(dataFirstImpl, { lazy: lazyImpl });\n\nfunction dataFirstImpl(...) {\n  // ...\n}\n\nfunction lazyImpl(...): LazyEvaluator {\n  // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Syncing Content Loader Types\nDESCRIPTION: Command to regenerate types when making changes to content loaders or their schemas.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/README.md#2025-04-07_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nnpm run sync\n```\n\n----------------------------------------\n\nTITLE: Defining Logic Category Documentation\nDESCRIPTION: YAML frontmatter defining the category and remeda function type for documentation purposes.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/mapping/ramda/cond.md#2025-04-07_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\n---\ncategory: Logic\nremeda: conditional\n---\n```\n\n----------------------------------------\n\nTITLE: Removing Strict Variant in TypeScript Sort Operations\nDESCRIPTION: Demonstrates the transition from using the strict variant of sort to the simplified version while maintaining the same functionality. The example shows sorting an array of numbers in ascending order.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/v1-migration/sort.md#2025-04-07_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// Was\nsort.strict([1, 2, 3], (a, b) => a - b);\n\n// Now\nsort([1, 2, 3], (a, b) => a - b);\n```\n\n----------------------------------------\n\nTITLE: Installing Remeda Project Dependencies\nDESCRIPTION: Commands to clone the Remeda repository and install dependencies. Uses git for cloning and npm for dependency installation.\nSOURCE: https://github.com/remeda/remeda/blob/main/CONTRIBUTING.md#2025-04-07_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit clone git@github.com:remeda/remeda.git\ncd remeda\nnpm install\n```\n\n----------------------------------------\n\nTITLE: Testing for Type Errors in TypeScript\nDESCRIPTION: Example of testing for meaningful type errors in TypeScript using ts-expect-error with error codes and descriptions.\nSOURCE: https://github.com/remeda/remeda/blob/main/CONTRIBUTING.md#2025-04-07_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\ntest(\"doesn't accept non-literal depths\", () => {\n  // @ts-expect-error [ts2345] - non-literal numbers can't be used as depth.\n  flat([], 1 as number);\n});\n```\n\n----------------------------------------\n\nTITLE: Using sortBy without strict variant in TypeScript\nDESCRIPTION: Example showing how to use the sortBy function without the previously required strict variant. The strict variant has been removed, and the base function now provides the same functionality.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/v1-migration/sortBy.md#2025-04-07_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// Was\nsortBy.strict([1, 2, 3], identity());\n\n// Now\nsortBy([1, 2, 3], identity());\n```\n\n----------------------------------------\n\nTITLE: Running Tests in Remeda\nDESCRIPTION: Commands for running tests in the Remeda project, showing how to run all tests or target specific test files.\nSOURCE: https://github.com/remeda/remeda/blob/main/CONTRIBUTING.md#2025-04-07_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nnpm test # every test\nnpm test -i src/file.test.ts # specific test\n```\n\n----------------------------------------\n\nTITLE: Opening Project in VSCode\nDESCRIPTION: Command to open the docs directory as a top-level project in VSCode for proper tooling integration.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/README.md#2025-04-07_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\ncode docs\n```\n\n----------------------------------------\n\nTITLE: Fixing parseInt Bug in sortedIndexBy Function\nDESCRIPTION: Demonstrates a potential bug when using parseInt as a direct function reference and shows the correct implementation using an arrow function wrapper. This fixes issues with additional parameters being passed to the mapper function.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/v1-migration/sortedIndexBy.md#2025-04-07_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n// Bug\nsortedIndexBy([\"1\", \"10\"], \"2\", parseInt); // => 2, Was: 1\n\n// Fix\nsortedIndexBy([\"1\", \"10\"], \"2\", (item) => parseInt(item)); // => 1\n```\n\n----------------------------------------\n\nTITLE: Running Code Quality Tools in Remeda\nDESCRIPTION: Commands for manually running Prettier for code formatting and linting in the Remeda project.\nSOURCE: https://github.com/remeda/remeda/blob/main/CONTRIBUTING.md#2025-04-07_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nnpm run prettier # format\nnpm run lint # lint\n```\n\n----------------------------------------\n\nTITLE: Running Code Quality Checks\nDESCRIPTION: Commands to check and lint the project, including .astro, .ts and .tsx files. These checks run automatically on each commit via git hooks.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/README.md#2025-04-07_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nnpm run check\nnpm run lint\n```\n\n----------------------------------------\n\nTITLE: Using Index Parameter in Array Predicate - TypeScript\nDESCRIPTION: Demonstrates the new capability to access index parameter in array predicate functions, allowing comparison between item and index values.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/v1-migration/splitWhen.md#2025-04-07_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// This was previously unavailable\nsplitWhen([1, 2, 3], (item, index) => item > index);\n```\n\n----------------------------------------\n\nTITLE: Building and Previewing Production Site\nDESCRIPTION: Commands to build the site for production and preview it locally, simulating the CI/CD build flow.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/README.md#2025-04-07_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nnpm run build\nnpm run preview\n```\n\n----------------------------------------\n\nTITLE: Using Index Parameter with Predicate Function in Remeda's takeLastWhile\nDESCRIPTION: Demonstrates how to use the additional index parameter provided by Remeda's functions when calling takeLastWhile. The predicate checks if the item value is greater than its index position.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/v1-migration/takeLastWhile.md#2025-04-07_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ntakeLastWhile([1, 2, 3], (item, index) => item > index);\n```\n\n----------------------------------------\n\nTITLE: Boolean Type Checking in TypeScript\nDESCRIPTION: Illustrates boolean type checking using typeof operator or isBoolean type guard.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/v1-migration/type.md#2025-04-07_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst DATA = true;\n\n// Was\ntype(DATA) === \"Boolean\";\n\n// Now\ntypeof DATA === \"boolean\";\n\n// Or\nisBoolean(DATA);\n```\n\n----------------------------------------\n\nTITLE: String Type Checking in TypeScript\nDESCRIPTION: Shows how to verify if a value is a string using typeof operator or isString type guard.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/v1-migration/type.md#2025-04-07_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nconst DATA = \"abc\";\n\n// Was\ntype(DATA) === \"String\";\n\n// Now\ntypeof DATA === \"string\";\n\n// Or\nisString(DATA);\n```\n\n----------------------------------------\n\nTITLE: Null Type Checking in TypeScript\nDESCRIPTION: Demonstrates how to check for null values using direct comparison.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/v1-migration/type.md#2025-04-07_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nconst DATA = null;\n\n// Was\ntype(DATA) === \"Null\";\n\n// Now\nDATA === null;\n```\n\n----------------------------------------\n\nTITLE: Function Type Checking in TypeScript\nDESCRIPTION: Shows how to verify if a value is a function using typeof operator or isFunction type guard.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/v1-migration/type.md#2025-04-07_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nconst DATA = () => {};\n\n// Was\ntype(DATA) === \"Function\";\n\n// Now\ntypeof DATA === \"function\";\n\n// Or\nisFunction(DATA);\n```\n\n----------------------------------------\n\nTITLE: Undefined Type Checking in TypeScript\nDESCRIPTION: Demonstrates how to check for undefined values using direct comparison.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/v1-migration/type.md#2025-04-07_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nconst DATA = undefined;\n\n// Was\ntype(DATA) === \"Undefined\";\n\n// Now\nDATA === undefined;\n```\n\n----------------------------------------\n\nTITLE: Migrating from zip.strict to zip in TypeScript\nDESCRIPTION: Shows how to migrate from using the zip.strict variant to the now improved zip function. The strict behavior is now the default, so the .strict suffix should be removed.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/v1-migration/zip.md#2025-04-07_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// Was\nzip.strict(a, b);\n\n// Now\nzip(a, b);\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Parameter Reordering in Remeda's zipWith Function (TypeScript)\nDESCRIPTION: This snippet shows how the order of parameters in the zipWith function has changed. The second array to zip with is now the first parameter, and the zipping function is the second parameter.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/v1-migration/zipWith.md#2025-04-07_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// Was\npipe(\n  [1, 2, 3],\n  zipWith((a, b) => a + b, [4, 5, 6]),\n);\n\n// Now\npipe(\n  [1, 2, 3],\n  zipWith([4, 5, 6], (a, b) => a + b),\n);\n```\n\n----------------------------------------\n\nTITLE: Migrating from Indexed Variant in Remeda v2\nDESCRIPTION: Example of how to update code that previously used the indexed variant in Remeda. The indexed functionality is now available in the base implementation, allowing callbacks to receive index and data parameters without a separate variant.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/docs-articles/v1/migration-variants.md#2025-04-07_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst DATA = [1, 2, 3] as const;\n\n// Was\nmap.indexed(DATA, (item, index) => item + index);\n\n// Now\nmap(DATA, (item, index) => item + index);\n```\n\n----------------------------------------\n\nTITLE: Comparing Headless Invocation in Remeda v1 and v2\nDESCRIPTION: This code snippet demonstrates the differences in function calls between Remeda v1 and v2. In v2, single-parameter functions require empty parentheses for their dataLast implementation, except for type-guards like isString.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/docs-articles/v1/migration-headless.md#2025-04-07_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// Was\npipe(DATA, keys);\nmap(DATA, identity);\nfilter(DATA, isString);\n\n// Now\npipe(DATA, keys());\nmap(DATA, identity());\nfilter(DATA, isString); // Not changed!\n```\n\n----------------------------------------\n\nTITLE: Replacing uniq with unique\nDESCRIPTION: Demonstrates the renaming of the uniq function to the more complete spelling unique, following the principle of avoiding abbreviations.\nSOURCE: https://github.com/remeda/remeda/blob/main/packages/docs/src/content/docs-articles/v1/migration-removed.md#2025-04-07_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\n// Was\nuniq(DATA);\n\n// Now\nunique(DATA);\n```"
  }
]