[
  {
    "owner": "vuejs",
    "repo": "vuex",
    "content": "TITLE: Accessing Vuex Store in Composition API\nDESCRIPTION: Demonstrates how to access the Vuex store within the setup hook using the useStore function, which is equivalent to this.$store in the Options API.\nSOURCE: https://github.com/vuejs/vuex/blob/main/docs/guide/composition-api.md#2025-04-22_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport { useStore } from 'vuex'\n\nexport default {\n  setup () {\n    const store = useStore()\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Vuex Modules Structure Definition\nDESCRIPTION: Illustrates the structure for defining Vuex modules. Modules allow for organizing store functionality into separate units with their own state, mutations, actions, and getters.\nSOURCE: https://github.com/vuejs/vuex/blob/main/docs/api/index.md#2025-04-22_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\n{\n  key: {\n    state,\n    namespaced?,\n    mutations?,\n    actions?,\n    getters?,\n    modules?\n  },\n  ...\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Basic Vuex Store with Mutation in JavaScript\nDESCRIPTION: Demonstrates how to create a Vuex store with a state object and a mutation handler that increments a count value.\nSOURCE: https://github.com/vuejs/vuex/blob/main/docs/guide/mutations.md#2025-04-22_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nconst store = createStore({\n  state: {\n    count: 1\n  },\n  mutations: {\n    increment (state) {\n      // mutate state\n      state.count++\n    }\n  }\n})\n```\n\n----------------------------------------\n\nTITLE: Creating a Basic Vuex Store in JavaScript\nDESCRIPTION: This snippet demonstrates how to create a new Vuex store instance with initial state and a mutation, then install it in a Vue application. It sets up a simple counter state with an increment mutation.\nSOURCE: https://github.com/vuejs/vuex/blob/main/docs/guide/index.md#2025-04-22_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport { createApp } from 'vue'\nimport { createStore } from 'vuex'\n\n// Create a new store instance.\nconst store = createStore({\n  state () {\n    return {\n      count: 0\n    }\n  },\n  mutations: {\n    increment (state) {\n      state.count++\n    }\n  }\n})\n\nconst app = createApp({ /* your root component */ })\n\n// Install the store instance as a plugin\napp.use(store)\n```\n\n----------------------------------------\n\nTITLE: Composing Vuex Actions with Async/Await\nDESCRIPTION: Demonstrates using async/await syntax to compose actions, making asynchronous code look more like synchronous code and improving readability.\nSOURCE: https://github.com/vuejs/vuex/blob/main/docs/guide/actions.md#2025-04-22_snippet_10\n\nLANGUAGE: javascript\nCODE:\n```\n// assuming `getData()` and `getOtherData()` return Promises\n\nactions: {\n  async actionA ({ commit }) {\n    commit('gotData', await getData())\n  },\n  async actionB ({ dispatch, commit }) {\n    await dispatch('actionA') // wait for `actionA` to finish\n    commit('gotOtherData', await getOtherData())\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: File Structure for Complex Vuex Applications\nDESCRIPTION: A recommended directory structure for organizing Vuex applications with modules. The structure divides the store into separate files for actions, mutations, and modules (like cart and products), with API abstractions in a separate directory.\nSOURCE: https://github.com/vuejs/vuex/blob/main/docs/ptbr/guide/structure.md#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n├── index.html\n├── main.js\n├── api\n│   └── ... # abstrações para fazer requisições a API\n├── components\n│   ├── App.vue\n│   └── ...\n└── store\n    ├── index.js          # onde montamos os módulos e exportamos o store\n    ├── actions.js        # ações raiz\n    ├── mutations.js      # mutações raiz\n    └── modules\n        ├── cart.js       # módulo cart\n        └── products.js   # módulo products\n```\n\n----------------------------------------\n\nTITLE: Committing Mutations from a Vue Component\nDESCRIPTION: This snippet demonstrates how to access the Vuex store within a Vue component using this.$store. It shows a component method that commits a mutation and then logs the updated state.\nSOURCE: https://github.com/vuejs/vuex/blob/main/docs/guide/index.md#2025-04-22_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nmethods: {\n  increment() {\n    this.$store.commit('increment')\n    console.log(this.$store.state.count)\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Accessing Vuex State in a Vue Component with $store Property\nDESCRIPTION: Shows how to access Vuex state in a Vue component using the $store property that Vuex injects into all child components from the root component.\nSOURCE: https://github.com/vuejs/vuex/blob/main/docs/guide/state.md#2025-04-22_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nconst Counter = {\n  template: `<div>{{ count }}</div>`,\n  computed: {\n    count () {\n      return this.$store.state.count\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Accessing Vuex State and Getters with Composition API\nDESCRIPTION: Shows how to access Vuex state and getters while maintaining reactivity using computed references. This creates computed properties similar to Options API approach.\nSOURCE: https://github.com/vuejs/vuex/blob/main/docs/ja/guide/composition-api.md#2025-04-22_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { computed } from 'vue'\nimport { useStore } from 'vuex'\n\nexport default {\n  setup () {\n    const store = useStore()\n\n    return {\n      // computed 関数のステートにアクセスします\n      count: computed(() => store.state.count),\n\n      // computed 関数のゲッターにアクセスします\n      double: computed(() => store.getters.double)\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Committing a Mutation in Vuex\nDESCRIPTION: Shows how to trigger a mutation using the store.commit method.\nSOURCE: https://github.com/vuejs/vuex/blob/main/docs/guide/mutations.md#2025-04-22_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nstore.commit('increment')\n```\n\n----------------------------------------\n\nTITLE: Using useStore with Composition API in JavaScript\nDESCRIPTION: Demonstrates how to retrieve the Vuex store inside a component's setup function using the useStore composable function. This is the recommended approach for accessing the store when using Vue 3 Composition API.\nSOURCE: https://github.com/vuejs/vuex/blob/main/docs/api/index.md#2025-04-22_snippet_9\n\nLANGUAGE: javascript\nCODE:\n```\nimport { useStore } from 'vuex'\n\nexport default {\n  setup () {\n    const store = useStore()\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Binding Namespaced Modules to Components (With Namespace Prefix)\nDESCRIPTION: Demonstrates a simpler way to bind namespaced module state, getters, and actions to Vue components by providing the namespace as the first argument to the mapping helpers.\nSOURCE: https://github.com/vuejs/vuex/blob/main/docs/guide/modules.md#2025-04-22_snippet_8\n\nLANGUAGE: javascript\nCODE:\n```\ncomputed: {\n  ...mapState('some/nested/module', {\n    a: state => state.a,\n    b: state => state.b\n  }),\n  ...mapGetters('some/nested/module', [\n    'someGetter', // -> this.someGetter\n    'someOtherGetter', // -> this.someOtherGetter\n  ])\n},\nmethods: {\n  ...mapActions('some/nested/module', [\n    'foo', // -> this.foo()\n    'bar' // -> this.bar()\n  ])\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Vuex Store in JavaScript\nDESCRIPTION: Demonstrates how to create a new Vuex store using the createStore function. This is the entry point for setting up state management in a Vue.js application.\nSOURCE: https://github.com/vuejs/vuex/blob/main/docs/api/index.md#2025-04-22_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport { createStore } from 'vuex'\n\nconst store = createStore({ ...options })\n```\n\n----------------------------------------\n\nTITLE: Installing Typed Vuex Store with InjectionKey in Vue App\nDESCRIPTION: Demonstrates how to pass the defined injection key when installing the Vuex store to a Vue application. This ensures the store maintains its type information.\nSOURCE: https://github.com/vuejs/vuex/blob/main/docs/guide/typescript-support.md#2025-04-22_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\n// main.ts\nimport { createApp } from 'vue'\nimport { store, key } from './store'\n\nconst app = createApp({ ... })\n\n// pass the injection key\napp.use(store, key)\n\napp.mount('#app')\n```\n\n----------------------------------------\n\nTITLE: Creating Vuex Store with Multiple Modules\nDESCRIPTION: Demonstrates how to create a Vuex store with multiple modules. Each module can contain its own state, mutations, actions, and getters, allowing for better organization of complex state management.\nSOURCE: https://github.com/vuejs/vuex/blob/main/docs/guide/modules.md#2025-04-22_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nconst moduleA = {\n  state: () => ({ ... }),\n  mutations: { ... },\n  actions: { ... },\n  getters: { ... }\n}\n\nconst moduleB = {\n  state: () => ({ ... }),\n  mutations: { ... },\n  actions: { ... }\n}\n\nconst store = createStore({\n  modules: {\n    a: moduleA,\n    b: moduleB\n  }\n})\n\nstore.state.a // -> `moduleA`'s state\nstore.state.b // -> `moduleB`'s state\n```\n\n----------------------------------------\n\nTITLE: Defining TypeScript Store and Injection Key\nDESCRIPTION: Sets up a typed Vuex store with TypeScript by creating an InjectionKey and store instance. This establishes type safety for the store state by defining a State interface and creating a symbol key for dependency injection.\nSOURCE: https://github.com/vuejs/vuex/blob/main/docs/api/index.md#2025-04-22_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\n// store.ts\nimport { InjectionKey } from 'vue'\nimport { createStore, Store } from 'vuex'\n\nexport interface State {\n  count: number\n}\n\nexport const key: InjectionKey<Store<State>> = Symbol()\n\nexport const store = createStore<State>({\n  state: {\n    count: 0\n  }\n})\n```\n\n----------------------------------------\n\nTITLE: Accessing Vuex State and Getters with Composition API\nDESCRIPTION: Shows how to access Vuex state and getters within the setup hook using computed references to maintain reactivity, equivalent to creating computed properties in the Options API.\nSOURCE: https://github.com/vuejs/vuex/blob/main/docs/guide/composition-api.md#2025-04-22_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { computed } from 'vue'\nimport { useStore } from 'vuex'\n\nexport default {\n  setup () {\n    const store = useStore()\n\n    return {\n      // access a state in computed function\n      count: computed(() => store.state.count),\n\n      // access a getter in computed function\n      double: computed(() => store.getters.double)\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Custom Typed useStore Composable\nDESCRIPTION: Demonstrates how to create a custom useStore composable function that simplifies store usage while maintaining proper typing.\nSOURCE: https://github.com/vuejs/vuex/blob/main/docs/ptbr/guide/typescript-support.md#2025-04-22_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\n// store.ts\nimport { InjectionKey } from 'vue'\nimport { createStore, useStore as baseUseStore, Store } from 'vuex'\n\nexport interface State {\n  count: number\n}\n\nexport const key: InjectionKey<Store<State>> = Symbol()\n\nexport const store = createStore<State>({\n  state: {\n    count: 0\n  }\n})\n\n// defina sua própria função de composição `useStore`\nexport function useStore () {\n  return baseUseStore(key)\n}\n```\n\n----------------------------------------\n\nTITLE: Accessing Vuex State and Getters with Composition API in JavaScript\nDESCRIPTION: This snippet shows how to access Vuex state and getters in the setup function using computed references to maintain reactivity. This is equivalent to creating computed properties using the Options API.\nSOURCE: https://github.com/vuejs/vuex/blob/main/docs/ptbr/guide/composition-api.md#2025-04-22_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { computed } from 'vue'\nimport { useStore } from 'vuex'\n\nexport default {\n  setup () {\n    const store = useStore()\n\n    return {\n      // acessar um estado em uma função de dados computados\n      count: computed(() => store.state.count),\n\n      // acessar um getter em uma função de dados computados\n      double: computed(() => store.getters.double)\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Accessing Vuex Store in Vue 3 Composition API\nDESCRIPTION: Demonstrates how to access the Vuex store within the setup function using the useStore hook. This is equivalent to accessing this.$store in the Options API.\nSOURCE: https://github.com/vuejs/vuex/blob/main/docs/zh/guide/composition-api.md#2025-04-22_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport { useStore } from 'vuex'\n\nexport default {\n  setup () {\n    const store = useStore()\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Accessing State and Committing Mutations in Vuex\nDESCRIPTION: This snippet shows how to commit a mutation to the Vuex store and then access the updated state. It demonstrates the basic pattern for state management in Vuex.\nSOURCE: https://github.com/vuejs/vuex/blob/main/docs/guide/index.md#2025-04-22_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nstore.commit('increment')\n\nconsole.log(store.state.count) // -> 1\n```\n\n----------------------------------------\n\nTITLE: Registering a Basic Vuex Action\nDESCRIPTION: Demonstrates how to register a simple action in a Vuex store that commits a mutation. The action receives a context object that provides access to the store's methods and properties.\nSOURCE: https://github.com/vuejs/vuex/blob/main/docs/guide/actions.md#2025-04-22_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nconst store = createStore({\n  state: {\n    count: 0\n  },\n  mutations: {\n    increment (state) {\n      state.count++\n    }\n  },\n  actions: {\n    increment (context) {\n      context.commit('increment')\n    }\n  }\n})\n```\n\n----------------------------------------\n\nTITLE: Dynamic Module Registration in Vuex\nDESCRIPTION: Shows how to dynamically register Vuex modules after the store has been created using store.registerModule. This enables adding and removing modules at runtime, useful for code-splitting and plugin integration.\nSOURCE: https://github.com/vuejs/vuex/blob/main/docs/guide/modules.md#2025-04-22_snippet_11\n\nLANGUAGE: javascript\nCODE:\n```\nimport { createStore } from 'vuex'\n\nconst store = createStore({ /* options */ })\n\n// register a module `myModule`\nstore.registerModule('myModule', {\n  // ...\n})\n\n// register a nested module `nested/myModule`\nstore.registerModule(['nested', 'myModule'], {\n  // ...\n})\n```\n\n----------------------------------------\n\nTITLE: Creating Store with createStore Function in Vuex 4\nDESCRIPTION: Demonstrates the new store creation process in Vuex 4 using the createStore function, which aligns with Vue 3's initialization patterns. This approach replaces the previous 'new Store()' syntax.\nSOURCE: https://github.com/vuejs/vuex/blob/main/docs/guide/migrating-to-4-0-from-3-x.md#2025-04-22_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport { createStore } from 'vuex'\n\nexport const store = createStore({\n  state () {\n    return {\n      count: 1\n    }\n  }\n})\n```\n\n----------------------------------------\n\nTITLE: Complex Vuex Action Example for Checkout Process\nDESCRIPTION: A real-world example of a checkout action that calls an async API and commits multiple mutations. This demonstrates handling optimistic updates and error cases in an e-commerce scenario.\nSOURCE: https://github.com/vuejs/vuex/blob/main/docs/guide/actions.md#2025-04-22_snippet_5\n\nLANGUAGE: javascript\nCODE:\n```\nactions: {\n  checkout ({ commit, state }, products) {\n    // save the items currently in the cart\n    const savedCartItems = [...state.cart.added]\n    // send out checkout request, and optimistically\n    // clear the cart\n    commit(types.CHECKOUT_REQUEST)\n    // the shop API accepts a success callback and a failure callback\n    shop.buyProducts(\n      products,\n      // handle success\n      () => commit(types.CHECKOUT_SUCCESS),\n      // handle failure\n      () => commit(types.CHECKOUT_FAILURE, savedCartItems)\n    )\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Vuex Action Context Object Structure\nDESCRIPTION: Shows the structure of the context object passed to action handlers in Vuex. This object provides access to state, getters, and methods for committing mutations and dispatching other actions.\nSOURCE: https://github.com/vuejs/vuex/blob/main/docs/api/index.md#2025-04-22_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\n{\n  state,      // same as `store.state`, or local state if in modules\n  rootState,  // same as `store.state`, only in modules\n  commit,     // same as `store.commit`\n  dispatch,   // same as `store.dispatch`\n  getters,    // same as `store.getters`, or local getters if in modules\n  rootGetters // same as `store.getters`, only in modules\n}\n```\n\n----------------------------------------\n\nTITLE: Accessing Vuex State and Getters in Vue 3 Composition API\nDESCRIPTION: Shows how to access Vuex state and getters using computed properties to maintain reactivity. This is similar to creating computed properties in the Options API.\nSOURCE: https://github.com/vuejs/vuex/blob/main/docs/zh/guide/composition-api.md#2025-04-22_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { computed } from 'vue'\nimport { useStore } from 'vuex'\n\nexport default {\n  setup () {\n    const store = useStore()\n\n    return {\n      // 在 computed 函数中访问 state\n      count: computed(() => store.state.count),\n\n      // 在 computed 函数中访问 getter\n      double: computed(() => store.getters.double)\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Using mapState Helper with Various Mapping Patterns in Vue\nDESCRIPTION: Demonstrates how to use the mapState helper to generate computed getter functions for Vuex state with different syntax patterns including arrow functions, string shortcuts, and local state integration.\nSOURCE: https://github.com/vuejs/vuex/blob/main/docs/guide/state.md#2025-04-22_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\n// in full builds helpers are exposed as Vuex.mapState\nimport { mapState } from 'vuex'\n\nexport default {\n  // ...\n  computed: mapState({\n    // arrow functions can make the code very succinct!\n    count: state => state.count,\n\n    // passing the string value 'count' is same as `state => state.count`\n    countAlias: 'count',\n\n    // to access local state with `this`, a normal function must be used\n    countPlusLocalState (state) {\n      return state.count + this.localCount\n    }\n  })\n}\n```\n\n----------------------------------------\n\nTITLE: Using Vuex Mutations and Actions in Composition API\nDESCRIPTION: Illustrates how to access and use Vuex mutations and actions inside the setup hook by returning functions that call store.commit and store.dispatch methods.\nSOURCE: https://github.com/vuejs/vuex/blob/main/docs/guide/composition-api.md#2025-04-22_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nimport { useStore } from 'vuex'\n\nexport default {\n  setup () {\n    const store = useStore()\n\n    return {\n      // access a mutation\n      increment: () => store.commit('increment'),\n\n      // access an action\n      asyncIncrement: () => store.dispatch('asyncIncrement')\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: MapGetters Helper Usage\nDESCRIPTION: Example of using the mapGetters helper to map store getters to computed properties\nSOURCE: https://github.com/vuejs/vuex/blob/main/docs/guide/getters.md#2025-04-22_snippet_5\n\nLANGUAGE: javascript\nCODE:\n```\nimport { mapGetters } from 'vuex'\n\nexport default {\n  // ...\n  computed: {\n    // mix the getters into computed with object spread operator\n    ...mapGetters([\n      'doneTodosCount',\n      'anotherGetter',\n      // ...\n    ])\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Typing $store Property in Vue Components with TypeScript\nDESCRIPTION: Declares custom typings for Vue's ComponentCustomProperties to provide proper typing for this.$store. This creates a module augmentation to define state structure and make the $store property correctly typed.\nSOURCE: https://github.com/vuejs/vuex/blob/main/docs/guide/typescript-support.md#2025-04-22_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// vuex.d.ts\nimport { Store } from 'vuex'\n\ndeclare module 'vue' {\n  // declare your own store states\n  interface State {\n    count: number\n  }\n\n  // provide typings for `this.$store`\n  interface ComponentCustomProperties {\n    $store: Store<State>\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Typed Store with InjectionKey in Vuex\nDESCRIPTION: Creates a typed Vuex store using TypeScript by defining a State interface and an InjectionKey. This allows for type-safe store access throughout the application.\nSOURCE: https://github.com/vuejs/vuex/blob/main/docs/guide/typescript-support.md#2025-04-22_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n// store.ts\nimport { InjectionKey } from 'vue'\nimport { createStore, Store } from 'vuex'\n\n// define your typings for the store state\nexport interface State {\n  count: number\n}\n\n// define injection key\nexport const key: InjectionKey<Store<State>> = Symbol()\n\nexport const store = createStore<State>({\n  state: {\n    count: 0\n  }\n})\n```\n\n----------------------------------------\n\nTITLE: Accessing Vuex Mutations and Actions with Composition API in JavaScript\nDESCRIPTION: This snippet demonstrates how to access Vuex mutations and actions in the setup function. It shows how to use store.commit for mutations and store.dispatch for actions within the composition API context.\nSOURCE: https://github.com/vuejs/vuex/blob/main/docs/ptbr/guide/composition-api.md#2025-04-22_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nimport { useStore } from 'vuex'\n\nexport default {\n  setup () {\n    const store = useStore()\n\n    return {\n      // acessa uma mutação\n      increment: () => store.commit('increment'),\n\n      // acessa uma ação\n      asyncIncrement: () => store.dispatch('asyncIncrement')\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Synchronous Mutations Example in Vuex\nDESCRIPTION: Demonstrates the concept that mutations in Vuex are synchronous transactions, where state changes happen immediately after commit.\nSOURCE: https://github.com/vuejs/vuex/blob/main/docs/guide/mutations.md#2025-04-22_snippet_12\n\nLANGUAGE: javascript\nCODE:\n```\nstore.commit('increment')\n// any state change that the \"increment\" mutation may cause\n// should be done at this moment.\n```\n\n----------------------------------------\n\nTITLE: Creating a WebSocket Sync Plugin for Vuex\nDESCRIPTION: Example of a plugin that synchronizes a WebSocket data source with the Vuex store. It listens for socket events and commits mutations, and also reacts to specific mutations to emit socket events.\nSOURCE: https://github.com/vuejs/vuex/blob/main/docs/guide/plugins.md#2025-04-22_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nexport default function createWebSocketPlugin (socket) {\n  return (store) => {\n    socket.on('data', data => {\n      store.commit('receiveData', data)\n    })\n    store.subscribe(mutation => {\n      if (mutation.type === 'UPDATE_DATA') {\n        socket.emit('update', mutation.payload)\n      }\n    })\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Custom useStore Composable for TypeScript Support\nDESCRIPTION: Demonstrates how to create a custom useStore composable function that automatically includes the InjectionKey. This simplifies usage by eliminating the need to import and provide the key in each component.\nSOURCE: https://github.com/vuejs/vuex/blob/main/docs/guide/typescript-support.md#2025-04-22_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\n// store.ts\nimport { InjectionKey } from 'vue'\nimport { createStore, useStore as baseUseStore, Store } from 'vuex'\n\nexport interface State {\n  count: number\n}\n\nexport const key: InjectionKey<Store<State>> = Symbol()\n\nexport const store = createStore<State>({\n  state: {\n    count: 0\n  }\n})\n\n// define your own `useStore` composition function\nexport function useStore () {\n  return baseUseStore(key)\n}\n```\n\n----------------------------------------\n\nTITLE: Using TypeScript-typed Store in Vue Component with useStore\nDESCRIPTION: Shows how to use the useStore composition function with the InjectionKey to retrieve a properly typed Vuex store in a Vue component. This provides type safety when accessing store state.\nSOURCE: https://github.com/vuejs/vuex/blob/main/docs/guide/typescript-support.md#2025-04-22_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\n// in a vue component\nimport { useStore } from 'vuex'\nimport { key } from './store'\n\nexport default {\n  setup () {\n    const store = useStore(key)\n\n    store.state.count // typed as number\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Returning Promises from Vuex Actions\nDESCRIPTION: Shows how to make actions return Promises for handling async completion. This allows for chaining or awaiting action completion in the calling code.\nSOURCE: https://github.com/vuejs/vuex/blob/main/docs/guide/actions.md#2025-04-22_snippet_7\n\nLANGUAGE: javascript\nCODE:\n```\nactions: {\n  actionA ({ commit }) {\n    return new Promise((resolve, reject) => {\n      setTimeout(() => {\n        commit('someMutation')\n        resolve()\n      }, 1000)\n    })\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Chaining Vuex Actions with Promises\nDESCRIPTION: Shows how to compose multiple actions together by dispatching one action from another and using the returned Promise to sequence operations.\nSOURCE: https://github.com/vuejs/vuex/blob/main/docs/guide/actions.md#2025-04-22_snippet_9\n\nLANGUAGE: javascript\nCODE:\n```\nactions: {\n  // ...\n  actionB ({ dispatch, commit }) {\n    return dispatch('actionA').then(() => {\n      commit('someOtherMutation')\n    })\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Async Vuex Actions\nDESCRIPTION: Defines an asynchronous action that fetches products from an API. It commits a request mutation before the API call and a receive mutation after receiving data.\nSOURCE: https://github.com/vuejs/vuex/blob/main/docs/guide/testing.md#2025-04-22_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\n// actions.js\nimport shop from '../api/shop'\n\nexport const getAllProducts = ({ commit }) => {\n  commit('REQUEST_PRODUCTS')\n  shop.getProducts(products => {\n    commit('RECEIVE_PRODUCTS', products)\n  })\n}\n```\n\n----------------------------------------\n\nTITLE: Accessing Vuex State in Vue Component (JavaScript)\nDESCRIPTION: Demonstrates how to access Vuex state within a Vue component using a computed property. This method directly references the global store instance.\nSOURCE: https://github.com/vuejs/vuex/blob/main/docs/ptbr/guide/state.md#2025-04-22_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nconst Counter = {\n  template: `<div>{{ count }}</div>`,\n  computed: {\n    count () {\n      return store.state.count\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Committing a Mutation with Payload\nDESCRIPTION: Demonstrates how to pass a payload value when committing a mutation.\nSOURCE: https://github.com/vuejs/vuex/blob/main/docs/guide/mutations.md#2025-04-22_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nstore.commit('increment', 10)\n```\n\n----------------------------------------\n\nTITLE: Implementing Asynchronous Operations in Vuex Actions\nDESCRIPTION: Demonstrates how actions can contain asynchronous operations, unlike mutations which must be synchronous. This example uses setTimeout to delay a mutation.\nSOURCE: https://github.com/vuejs/vuex/blob/main/docs/guide/actions.md#2025-04-22_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nactions: {\n  incrementAsync ({ commit }) {\n    setTimeout(() => {\n      commit('increment')\n    }, 1000)\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Reusable Vuex Module with Function-Based State\nDESCRIPTION: Demonstrates how to create a reusable Vuex module by declaring state as a function to avoid state pollution across multiple instances. This approach prevents shared references between module instances, similar to how Vue component data works.\nSOURCE: https://github.com/vuejs/vuex/blob/main/docs/guide/modules.md#2025-04-22_snippet_12\n\nLANGUAGE: javascript\nCODE:\n```\nconst MyReusableModule = {\n  state: () => ({\n    foo: 'bar'\n  }),\n  // mutations, actions, getters...\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Vuex Store with TypeScript Injection Key\nDESCRIPTION: Shows how to install a typed Vuex store in a Vue application by passing the injection key to app.use(). This connects the typed store to the Vue application with proper type inference.\nSOURCE: https://github.com/vuejs/vuex/blob/main/docs/api/index.md#2025-04-22_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\n// main.ts\nimport { createApp } from 'vue'\nimport { store, key } from './store'\n\nconst app = createApp({ ... })\n\napp.use(store, key)\n\napp.mount('#app')\n```\n\n----------------------------------------\n\nTITLE: Implementing Vuex Store with Mutation Type Constants\nDESCRIPTION: Demonstrates how to import and use mutation type constants in a Vuex store definition, utilizing ES2015 computed property name feature.\nSOURCE: https://github.com/vuejs/vuex/blob/main/docs/guide/mutations.md#2025-04-22_snippet_9\n\nLANGUAGE: javascript\nCODE:\n```\n// store.js\nimport { createStore } from 'vuex'\nimport { SOME_MUTATION } from './mutation-types'\n\nconst store = createStore({\n  state: { ... },\n  mutations: {\n    // we can use the ES2015 computed property name feature\n    // to use a constant as the function name\n    [SOME_MUTATION] (state) {\n      // mutate state\n    }\n  }\n})\n```\n\n----------------------------------------\n\nTITLE: Committing a Mutation with Object Payload\nDESCRIPTION: Demonstrates committing a mutation with an object payload that contains multiple fields.\nSOURCE: https://github.com/vuejs/vuex/blob/main/docs/guide/mutations.md#2025-04-22_snippet_5\n\nLANGUAGE: javascript\nCODE:\n```\nstore.commit('increment', {\n  amount: 10\n})\n```\n\n----------------------------------------\n\nTITLE: Dispatching Vuex Actions with Payloads\nDESCRIPTION: Shows two ways to dispatch actions with additional data: using a payload parameter and using an object-style dispatch with a type property.\nSOURCE: https://github.com/vuejs/vuex/blob/main/docs/guide/actions.md#2025-04-22_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\n// dispatch with a payload\nstore.dispatch('incrementAsync', {\n  amount: 10\n})\n\n// dispatch with an object\nstore.dispatch({\n  type: 'incrementAsync',\n  amount: 10\n})\n```\n\n----------------------------------------\n\nTITLE: Combining Local Computed Properties with mapState Using Object Spread\nDESCRIPTION: Demonstrates how to combine local computed properties with Vuex state mapping using the object spread operator for cleaner syntax.\nSOURCE: https://github.com/vuejs/vuex/blob/main/docs/guide/state.md#2025-04-22_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\ncomputed: {\n  localComputed () { /* ... */ },\n  // mix this into the outer object with the object spread operator\n  ...mapState({\n    // ...\n  })\n}\n```\n\n----------------------------------------\n\nTITLE: Mapping Mutations in Vue Component using JavaScript\nDESCRIPTION: This snippet shows how to use the mapMutations helper to map component methods to store.commit calls. It demonstrates both array and object mapping syntaxes.\nSOURCE: https://github.com/vuejs/vuex/blob/main/docs/ptbr/guide/mutations.md#2025-04-22_snippet_9\n\nLANGUAGE: javascript\nCODE:\n```\nimport { mapMutations } from 'vuex'\n\nexport default {\n  // ...\n  methods: {\n    ...mapMutations([\n      'increment', // mapeia `this.increment()` para `this.$store.commit('increment')`\n\n      // `mapMutations` also supports payloads:\n      'incrementBy' // mapeia `this.incrementBy(amount)` para`this.$store.commit('incrementBy', amount)`\n    ]),\n    ...mapMutations({\n      add: 'increment' // mapeia `this.add()` para`this.$store.commit('increment')`\n    })\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Object-Style Commit in Vuex\nDESCRIPTION: Shows the alternative object-style syntax for committing mutations, where the type is specified as a property of the commit object.\nSOURCE: https://github.com/vuejs/vuex/blob/main/docs/guide/mutations.md#2025-04-22_snippet_6\n\nLANGUAGE: javascript\nCODE:\n```\nstore.commit({\n  type: 'increment',\n  amount: 10\n})\n```\n\n----------------------------------------\n\nTITLE: Using Typed Vuex Store with Composition API\nDESCRIPTION: Demonstrates how to use a typed Vuex store in a component with the Composition API. The key is passed to useStore to retrieve a properly typed store instance, enabling TypeScript to infer types for state properties.\nSOURCE: https://github.com/vuejs/vuex/blob/main/docs/api/index.md#2025-04-22_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\n// in a vue component\nimport { useStore } from 'vuex'\nimport { key } from './store'\n\nexport default {\n  setup () {\n    const store = useStore(key)\n\n    store.state.count // typed as number\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Accessing Vuex Mutations and Actions with Composition API\nDESCRIPTION: Demonstrates how to access Vuex mutations and actions within the setup hook using commit and dispatch functions.\nSOURCE: https://github.com/vuejs/vuex/blob/main/docs/ja/guide/composition-api.md#2025-04-22_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nimport { useStore } from 'vuex'\n\nexport default {\n  setup () {\n    const store = useStore()\n\n    return {\n      // ミューテーションにアクセスする\n      increment: () => store.commit('increment'),\n\n      // アクションにアクセスする\n      asyncIncrement: () => store.dispatch('asyncIncrement')\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Vuex Store Getter Definition\nDESCRIPTION: Example of defining getters in a Vuex store with state management for todos\nSOURCE: https://github.com/vuejs/vuex/blob/main/docs/guide/getters.md#2025-04-22_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nconst store = createStore({\n  state: {\n    todos: [\n      { id: 1, text: '...', done: true },\n      { id: 2, text: '...', done: false }\n    ]\n  },\n  getters: {\n    doneTodos (state) {\n      return state.todos.filter(todo => todo.done)\n    }\n  }\n})\n```\n\n----------------------------------------\n\nTITLE: Advanced Action Subscription with Before and After Hooks\nDESCRIPTION: Shows how to subscribe to actions with separate handlers for before and after the action execution. This allows for setup and cleanup operations around action dispatches.\nSOURCE: https://github.com/vuejs/vuex/blob/main/docs/api/index.md#2025-04-22_snippet_7\n\nLANGUAGE: javascript\nCODE:\n```\nstore.subscribeAction({\n  before: (action, state) => {\n    console.log(`before action ${action.type}`)\n  },\n  after: (action, state) => {\n    console.log(`after action ${action.type}`)\n  }\n})\n```\n\n----------------------------------------\n\nTITLE: Committing a Mutation with Payload in Vuex using JavaScript\nDESCRIPTION: This snippet demonstrates how to commit a mutation while passing a payload. The payload is a simple value that will be used by the mutation.\nSOURCE: https://github.com/vuejs/vuex/blob/main/docs/ptbr/guide/mutations.md#2025-04-22_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nstore.commit('increment', 10)\n```\n\n----------------------------------------\n\nTITLE: Implementing Namespaced Modules in Vuex\nDESCRIPTION: Shows how to create namespaced modules with nested modules. Namespaced modules automatically prefix their getters, actions, and mutations with the module path, making them more self-contained and reusable.\nSOURCE: https://github.com/vuejs/vuex/blob/main/docs/guide/modules.md#2025-04-22_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\nconst store = createStore({\n  modules: {\n    account: {\n      namespaced: true,\n\n      // module assets\n      state: () => ({ ... }), // module state is already nested and not affected by namespace option\n      getters: {\n        isAdmin () { ... } // -> getters['account/isAdmin']\n      },\n      actions: {\n        login () { ... } // -> dispatch('account/login')\n      },\n      mutations: {\n        login () { ... } // -> commit('account/login')\n      },\n\n      // nested modules\n      modules: {\n        // inherits the namespace from parent module\n        myPage: {\n          state: () => ({ ... }),\n          getters: {\n            profile () { ... } // -> getters['account/profile']\n          }\n        },\n\n        // further nest the namespace\n        posts: {\n          namespaced: true,\n\n          state: () => ({ ... }),\n          getters: {\n            popular () { ... } // -> getters['account/posts/popular']\n          }\n        }\n      }\n    }\n  }\n})\n```\n\n----------------------------------------\n\nTITLE: Declaring TypeScript Types for Vue Component $store Property\nDESCRIPTION: Demonstrates how to declare custom module augmentation to provide typing for the this.$store property in Vue components using TypeScript.\nSOURCE: https://github.com/vuejs/vuex/blob/main/docs/ptbr/guide/typescript-support.md#2025-04-22_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// vuex.d.ts\nimport { ComponentCustomProperties } from 'vue'\nimport { Store } from 'vuex'\n\ndeclare module 'vue' {\n  // declare seus próprios estados do store\n  interface State {\n    count: number\n  }\n\n  // fornece tipagem para `this.$store`\n  interface ComponentCustomProperties {\n    $store: Store<State>\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Using Vuex Mutations and Actions in Vue 3 Composition API\nDESCRIPTION: Illustrates how to use Vuex mutations and actions within the setup function by calling commit and dispatch methods on the store instance.\nSOURCE: https://github.com/vuejs/vuex/blob/main/docs/zh/guide/composition-api.md#2025-04-22_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nimport { useStore } from 'vuex'\n\nexport default {\n  setup () {\n    const store = useStore()\n\n    return {\n      // 使用 mutation\n      increment: () => store.commit('increment'),\n\n      // 使用 action\n      asyncIncrement: () => store.dispatch('asyncIncrement')\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Using Typed Store with useStore in Vue Components\nDESCRIPTION: This snippet shows how to use the useStore composition function with the injection key to get a properly typed store instance in a Vue component.\nSOURCE: https://github.com/vuejs/vuex/blob/main/docs/zh/guide/typescript-support.md#2025-04-22_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\n// vue 组件\nimport { useStore } from 'vuex'\nimport { key } from './store'\n\nexport default {\n  setup () {\n    const store = useStore(key)\n\n    store.state.count // 类型为 number\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Using Custom useStore Composable in Vue Components\nDESCRIPTION: Shows how to use the custom useStore composable function in a Vue component. This approach simplifies accessing a typed Vuex store without having to provide the injection key in each component.\nSOURCE: https://github.com/vuejs/vuex/blob/main/docs/guide/typescript-support.md#2025-04-22_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\n// in a vue component\nimport { useStore } from './store'\n\nexport default {\n  setup () {\n    const store = useStore()\n\n    store.state.count // typed as number\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Sample Directory Structure for Modular Vuex Application\nDESCRIPTION: This snippet illustrates a recommended project structure for a non-trivial Vuex application using modules. It shows how to organize files for a modular store with separate directories for API abstractions, Vue components, and store-related files.\nSOURCE: https://github.com/vuejs/vuex/blob/main/docs/guide/structure.md#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n├── index.html\n├── main.js\n├── api\n│   └── ... # abstractions for making API requests\n├── components\n│   ├── App.vue\n│   └── ...\n└── store\n    ├── index.js          # where we assemble modules and export the store\n    ├── actions.js        # root actions\n    ├── mutations.js      # root mutations\n    └── modules\n        ├── cart.js       # cart module\n        └── products.js   # products module\n```\n\n----------------------------------------\n\nTITLE: Declaring $store Property Types in Vue Components with TypeScript\nDESCRIPTION: This snippet demonstrates how to create a declaration file (vuex.d.ts) to provide type declarations for the $store property in Vue components using module augmentation.\nSOURCE: https://github.com/vuejs/vuex/blob/main/docs/zh/guide/typescript-support.md#2025-04-22_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// vuex.d.ts\nimport { Store } from 'vuex'\n\ndeclare module 'vue' {\n  // 声明自己的 store state\n  interface State {\n    count: number\n  }\n\n  // 为 `this.$store` 提供类型声明\n  interface ComponentCustomProperties {\n    $store: Store<State>\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Basic Vuex Plugin\nDESCRIPTION: Demonstrates how to create a simple Vuex plugin that subscribes to store mutations. The plugin function receives the store as its only argument and can react to mutations as they occur.\nSOURCE: https://github.com/vuejs/vuex/blob/main/docs/guide/plugins.md#2025-04-22_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nconst myPlugin = (store) => {\n  // called when the store is initialized\n  store.subscribe((mutation, state) => {\n    // called after every mutation.\n    // The mutation comes in the format of `{ type, payload }`.\n  })\n}\n```\n\n----------------------------------------\n\nTITLE: Creating State Snapshot Plugin\nDESCRIPTION: Implements a plugin that takes snapshots of the state before and after mutations for comparison. This uses deep cloning to preserve the state at different points in time.\nSOURCE: https://github.com/vuejs/vuex/blob/main/docs/ja/guide/plugins.md#2025-04-22_snippet_4\n\nLANGUAGE: js\nCODE:\n```\nconst myPluginWithSnapshot = (store) => {\n  let prevState = _.cloneDeep(store.state)\n  store.subscribe((mutation, state) => {\n    let nextState = _.cloneDeep(state)\n\n    // `prevState` と `nextState` を比較...\n\n    // 次のミューテーションのために状態を保存\n    prevState = nextState\n  })\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Mutation with Object Payload in Vuex using JavaScript\nDESCRIPTION: This example shows how to define a mutation that expects an object as its payload. This allows for more complex data to be passed to the mutation.\nSOURCE: https://github.com/vuejs/vuex/blob/main/docs/ptbr/guide/mutations.md#2025-04-22_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\nmutations: {\n  increment (state, payload) {\n    state.count += payload.amount\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Vuex Store with Mutations in JavaScript\nDESCRIPTION: This snippet demonstrates how to create a Vuex store with a simple mutation to increment a counter. It shows the basic structure of defining a state and a mutation within the store.\nSOURCE: https://github.com/vuejs/vuex/blob/main/docs/ptbr/guide/mutations.md#2025-04-22_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nconst store = createStore({\n  state: {\n    count: 1\n  },\n  mutations: {\n    increment (state) {\n      // muda o estado\n      state.count++\n    }\n  }\n})\n```\n\n----------------------------------------\n\nTITLE: Defining a Mutation with Payload Parameter\nDESCRIPTION: Shows how to define a mutation handler that accepts a payload parameter to modify the state with external data.\nSOURCE: https://github.com/vuejs/vuex/blob/main/docs/guide/mutations.md#2025-04-22_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\n// ...\nmutations: {\n  increment (state, n) {\n    state.count += n\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Using the useStore Composition Function in Vuex 4\nDESCRIPTION: Demonstrates how to access the Vuex store within the Composition API using the new useStore function, which allows store interaction within the setup hook of Vue components.\nSOURCE: https://github.com/vuejs/vuex/blob/main/docs/guide/migrating-to-4-0-from-3-x.md#2025-04-22_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\nimport { useStore } from 'vuex'\n\nexport default {\n  setup () {\n    const store = useStore()\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Object-Style Commit in Vuex using JavaScript\nDESCRIPTION: This example demonstrates an alternative way to commit a mutation using an object with a type property. This style allows for a more descriptive commit.\nSOURCE: https://github.com/vuejs/vuex/blob/main/docs/ptbr/guide/mutations.md#2025-04-22_snippet_6\n\nLANGUAGE: javascript\nCODE:\n```\nstore.commit({\n  type: 'increment',\n  amount: 10\n})\n```\n\n----------------------------------------\n\nTITLE: Implementing a WebSocket Plugin with Vuex Store\nDESCRIPTION: Shows how to instantiate and use the WebSocket plugin with a Vuex store. The plugin is created with a socket instance and then passed to the store configuration.\nSOURCE: https://github.com/vuejs/vuex/blob/main/docs/guide/plugins.md#2025-04-22_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nconst plugin = createWebSocketPlugin(socket)\n\nconst store = createStore({\n  state,\n  mutations,\n  plugins: [plugin]\n})\n```\n\n----------------------------------------\n\nTITLE: Testing Vuex Mutations with Mocha and Chai\nDESCRIPTION: Example test for an increment mutation using Mocha as the test runner and Chai for assertions. It demonstrates mocking state and verifying mutation effects.\nSOURCE: https://github.com/vuejs/vuex/blob/main/docs/guide/testing.md#2025-04-22_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\n// mutations.spec.js\nimport { expect } from 'chai'\nimport { mutations } from './store'\n\n// destructure assign `mutations`\nconst { increment } = mutations\n\ndescribe('mutations', () => {\n  it('INCREMENT', () => {\n    // mock state\n    const state = { count: 0 }\n    // apply mutation\n    increment(state)\n    // assert result\n    expect(state.count).to.equal(1)\n  })\n})\n```\n\n----------------------------------------\n\nTITLE: Using Promise Results from Dispatched Actions\nDESCRIPTION: Demonstrates how to use the Promise returned by store.dispatch to execute code after an action completes.\nSOURCE: https://github.com/vuejs/vuex/blob/main/docs/guide/actions.md#2025-04-22_snippet_8\n\nLANGUAGE: javascript\nCODE:\n```\nstore.dispatch('actionA').then(() => {\n  // ...\n})\n```\n\n----------------------------------------\n\nTITLE: Committing a Mutation with Object Payload in Vuex using JavaScript\nDESCRIPTION: This snippet illustrates how to commit a mutation with an object payload. The object contains properties that will be used by the mutation.\nSOURCE: https://github.com/vuejs/vuex/blob/main/docs/ptbr/guide/mutations.md#2025-04-22_snippet_5\n\nLANGUAGE: javascript\nCODE:\n```\nstore.commit('increment', {\n  amount: 10\n})\n```\n\n----------------------------------------\n\nTITLE: Accessing Global Assets in Namespaced Modules\nDESCRIPTION: Demonstrates how to access global state and dispatch global actions from within namespaced modules. Uses rootState, rootGetters, and the root option for dispatch and commit to interact with global store assets.\nSOURCE: https://github.com/vuejs/vuex/blob/main/docs/guide/modules.md#2025-04-22_snippet_5\n\nLANGUAGE: javascript\nCODE:\n```\nmodules: {\n  foo: {\n    namespaced: true,\n\n    getters: {\n      // `getters` is localized to this module's getters\n      // you can use rootGetters via 4th argument of getters\n      someGetter (state, getters, rootState, rootGetters) {\n        getters.someOtherGetter // -> 'foo/someOtherGetter'\n        rootGetters.someOtherGetter // -> 'someOtherGetter'\n        rootGetters['bar/someOtherGetter'] // -> 'bar/someOtherGetter'\n      },\n      someOtherGetter: state => { ... }\n    },\n\n    actions: {\n      // dispatch and commit are also localized for this module\n      // they will accept `root` option for the root dispatch/commit\n      someAction ({ dispatch, commit, getters, rootGetters }) {\n        getters.someGetter // -> 'foo/someGetter'\n        rootGetters.someGetter // -> 'someGetter'\n        rootGetters['bar/someGetter'] // -> 'bar/someGetter'\n\n        dispatch('someOtherAction') // -> 'foo/someOtherAction'\n        dispatch('someOtherAction', null, { root: true }) // -> 'someOtherAction'\n\n        commit('someMutation') // -> 'foo/someMutation'\n        commit('someMutation', null, { root: true }) // -> 'someMutation'\n      },\n      someOtherAction (ctx, payload) { ... }\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Using mapState Helper with String Array Syntax in Vue\nDESCRIPTION: Shows how to use the mapState helper with a string array when the mapped computed property names match the state property names.\nSOURCE: https://github.com/vuejs/vuex/blob/main/docs/guide/state.md#2025-04-22_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\ncomputed: mapState([\n  // map this.count to store.state.count\n  'count'\n])\n```\n\n----------------------------------------\n\nTITLE: Two-way computed property approach for form handling\nDESCRIPTION: This alternative approach uses a two-way computed property with a getter and setter. The getter retrieves the state from Vuex, while the setter commits a mutation to update the state.\nSOURCE: https://github.com/vuejs/vuex/blob/main/docs/guide/forms.md#2025-04-22_snippet_3\n\nLANGUAGE: html\nCODE:\n```\n<input v-model=\"message\">\n```\n\nLANGUAGE: javascript\nCODE:\n```\n// ...\ncomputed: {\n  message: {\n    get () {\n      return this.$store.state.obj.message\n    },\n    set (value) {\n      this.$store.commit('updateMessage', value)\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Method-Style Getter with Parameters\nDESCRIPTION: Implementation of a getter that accepts parameters by returning a function\nSOURCE: https://github.com/vuejs/vuex/blob/main/docs/guide/getters.md#2025-04-22_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\ngetters: {\n  // ...\n  getTodoById: (state) => (id) => {\n    return state.todos.find(todo => todo.id === id)\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Testing Async Actions with Dependency Injection\nDESCRIPTION: Demonstrates testing an asynchronous action with mock dependencies using inject-loader and a custom testAction helper function to verify commit calls.\nSOURCE: https://github.com/vuejs/vuex/blob/main/docs/guide/testing.md#2025-04-22_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\n// actions.spec.js\n\n// use require syntax for inline loaders.\n// with inject-loader, this returns a module factory\n// that allows us to inject mocked dependencies.\nimport { expect } from 'chai'\nconst actionsInjector = require('inject-loader!./actions')\n\n// create the module with our mocks\nconst actions = actionsInjector({\n  '../api/shop': {\n    getProducts (cb) {\n      setTimeout(() => {\n        cb([ /* mocked response */ ])\n      }, 100)\n    }\n  }\n})\n\n// helper for testing action with expected mutations\nconst testAction = (action, payload, state, expectedMutations, done) => {\n  let count = 0\n\n  // mock commit\n  const commit = (type, payload) => {\n    const mutation = expectedMutations[count]\n\n    try {\n      expect(type).to.equal(mutation.type)\n      expect(payload).to.deep.equal(mutation.payload)\n    } catch (error) {\n      done(error)\n    }\n\n    count++\n    if (count >= expectedMutations.length) {\n      done()\n    }\n  }\n\n  // call the action with mocked store and arguments\n  action({ commit, state }, payload)\n\n  // check if no mutations should have been dispatched\n  if (expectedMutations.length === 0) {\n    expect(count).to.equal(0)\n    done()\n  }\n}\n\ndescribe('actions', () => {\n  it('getAllProducts', done => {\n    testAction(actions.getAllProducts, null, {}, [\n      { type: 'REQUEST_PRODUCTS' },\n      { type: 'RECEIVE_PRODUCTS', payload: { /* mocked response */ } }\n    ], done)\n  })\n})\n```\n\n----------------------------------------\n\nTITLE: Registering Global Actions in Namespaced Modules\nDESCRIPTION: Shows how to register global actions from within namespaced modules using the root option and handler function. This allows a namespaced module to expose actions that can be called without the namespace prefix.\nSOURCE: https://github.com/vuejs/vuex/blob/main/docs/guide/modules.md#2025-04-22_snippet_6\n\nLANGUAGE: javascript\nCODE:\n```\n{\n  actions: {\n    someOtherAction ({dispatch}) {\n      dispatch('someAction')\n    }\n  },\n  modules: {\n    foo: {\n      namespaced: true,\n\n      actions: {\n        someAction: {\n          root: true,\n          handler (namespacedContext, payload) { ... } // -> 'someAction'\n        }\n      }\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Subscribing to Vuex Mutations\nDESCRIPTION: Shows how to subscribe to store mutations for tracking state changes, which is useful for debugging, logging, or persistence. Returns an unsubscribe function to stop listening.\nSOURCE: https://github.com/vuejs/vuex/blob/main/docs/api/index.md#2025-04-22_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nconst unsubscribe = store.subscribe((mutation, state) => {\n  console.log(mutation.type)\n  console.log(mutation.payload)\n})\n\n// you may call unsubscribe to stop the subscription\nunsubscribe()\n```\n\n----------------------------------------\n\nTITLE: Dispatching a Vuex Action\nDESCRIPTION: Shows how to trigger an action using the store.dispatch method.\nSOURCE: https://github.com/vuejs/vuex/blob/main/docs/guide/actions.md#2025-04-22_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nstore.dispatch('increment')\n```\n\n----------------------------------------\n\nTITLE: Creating a Type-Safe Store with InjectionKey in Vuex\nDESCRIPTION: This snippet shows how to define a typed store and InjectionKey to ensure type safety when using Vuex with TypeScript. It demonstrates defining state interface and creating a typed store instance.\nSOURCE: https://github.com/vuejs/vuex/blob/main/docs/zh/guide/typescript-support.md#2025-04-22_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n// store.ts\nimport { InjectionKey } from 'vue'\nimport { createStore, Store } from 'vuex'\n\n// 为 store state 声明类型\nexport interface State {\n  count: number\n}\n\n// 定义 injection key\nexport const key: InjectionKey<Store<State>> = Symbol()\n\nexport const store = createStore<State>({\n  state: {\n    count: 0\n  }\n})\n```\n\n----------------------------------------\n\nTITLE: Vuex mutation handler for updating message\nDESCRIPTION: This snippet shows the Vuex mutation handler that updates the state based on the input value. It's called by the updateMessage method in the component.\nSOURCE: https://github.com/vuejs/vuex/blob/main/docs/guide/forms.md#2025-04-22_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\n// ...\nmutations: {\n  updateMessage (state, message) {\n    state.obj.message = message\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Component Getter Usage\nDESCRIPTION: Example of using a Vuex getter within a component's computed property\nSOURCE: https://github.com/vuejs/vuex/blob/main/docs/guide/getters.md#2025-04-22_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\ncomputed: {\n  doneTodosCount () {\n    return this.$store.getters.doneTodosCount\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Mutation with Payload in Vuex using JavaScript\nDESCRIPTION: This example illustrates how to define a mutation that accepts a payload. The mutation uses the payload to determine how much to increment the counter by.\nSOURCE: https://github.com/vuejs/vuex/blob/main/docs/ptbr/guide/mutations.md#2025-04-22_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nmutations: {\n  increment (state, n) {\n    state.count += n\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Testing Actions with Sinon Spies\nDESCRIPTION: Shows an alternative approach to testing actions using Sinon.JS spies to monitor and verify commit calls.\nSOURCE: https://github.com/vuejs/vuex/blob/main/docs/guide/testing.md#2025-04-22_snippet_5\n\nLANGUAGE: javascript\nCODE:\n```\ndescribe('actions', () => {\n  it('getAllProducts', () => {\n    const commit = sinon.spy()\n    const state = {}\n\n    actions.getAllProducts({ commit, state })\n\n    expect(commit.args).to.deep.equal([\n      ['REQUEST_PRODUCTS'],\n      ['RECEIVE_PRODUCTS', { /* mocked response */ }]\n    ])\n  })\n})\n```\n\n----------------------------------------\n\nTITLE: Using mapMutations Helper in Vue Components\nDESCRIPTION: Shows how to use the mapMutations helper to map component methods to store mutation commits, supporting both array syntax and object syntax for renaming.\nSOURCE: https://github.com/vuejs/vuex/blob/main/docs/guide/mutations.md#2025-04-22_snippet_11\n\nLANGUAGE: javascript\nCODE:\n```\nimport { mapMutations } from 'vuex'\n\nexport default {\n  // ...\n  methods: {\n    ...mapMutations([\n      'increment', // map `this.increment()` to `this.$store.commit('increment')`\n\n      // `mapMutations` also supports payloads:\n      'incrementBy' // map `this.incrementBy(amount)` to `this.$store.commit('incrementBy', amount)`\n    ]),\n    ...mapMutations({\n      add: 'increment' // map `this.add()` to `this.$store.commit('increment')`\n    })\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Adding a Prepended Action Subscriber\nDESCRIPTION: Demonstrates how to add an action subscriber to the beginning of the subscription chain using the prepend option, ensuring it executes before other handlers.\nSOURCE: https://github.com/vuejs/vuex/blob/main/docs/api/index.md#2025-04-22_snippet_6\n\nLANGUAGE: javascript\nCODE:\n```\nstore.subscribeAction(handler, { prepend: true })\n```\n\n----------------------------------------\n\nTITLE: Using createNamespacedHelpers for Component Binding\nDESCRIPTION: Shows how to use the createNamespacedHelpers utility to create pre-namespaced component binding helpers. This provides a cleaner way to bind namespaced module assets to components.\nSOURCE: https://github.com/vuejs/vuex/blob/main/docs/guide/modules.md#2025-04-22_snippet_9\n\nLANGUAGE: javascript\nCODE:\n```\nimport { createNamespacedHelpers } from 'vuex'\n\nconst { mapState, mapActions } = createNamespacedHelpers('some/nested/module')\n\nexport default {\n  computed: {\n    // look up in `some/nested/module`\n    ...mapState({\n      a: state => state.a,\n      b: state => state.b\n    })\n  },\n  methods: {\n    // look up in `some/nested/module`\n    ...mapActions([\n      'foo',\n      'bar'\n    ])\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Basic Hot Reloading in Vuex Store with webpack's HMR\nDESCRIPTION: This snippet demonstrates how to set up hot reloading for Vuex mutations and modules using webpack's Hot Module Replacement API. It creates a store with state, mutations, and modules, then configures hot module acceptance to update these components without refreshing the page.\nSOURCE: https://github.com/vuejs/vuex/blob/main/docs/guide/hot-reload.md#2025-04-22_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// store.js\nimport { createStore } from 'vuex'\nimport mutations from './mutations'\nimport moduleA from './modules/a'\n\nconst state = { ... }\n\nconst store = createStore({\n  state,\n  mutations,\n  modules: {\n    a: moduleA\n  }\n})\n\nif (module.hot) {\n  // accept actions and mutations as hot modules\n  module.hot.accept(['./mutations', './modules/a'], () => {\n    // require the updated modules\n    // have to add .default here due to babel 6 module output\n    const newMutations = require('./mutations').default\n    const newModuleA = require('./modules/a').default\n    // swap in the new modules and mutations\n    store.hotUpdate({\n      mutations: newMutations,\n      modules: {\n        a: newModuleA\n      }\n    })\n  })\n}\n```\n\n----------------------------------------\n\nTITLE: Adding a Prepended Mutation Subscriber\nDESCRIPTION: Demonstrates how to add a mutation subscriber to the beginning of the subscription chain using the prepend option, ensuring it executes before other handlers.\nSOURCE: https://github.com/vuejs/vuex/blob/main/docs/api/index.md#2025-04-22_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\nstore.subscribe(handler, { prepend: true })\n```\n\n----------------------------------------\n\nTITLE: Getter with Other Getters Access\nDESCRIPTION: Demonstration of a getter that uses other getters as its second argument\nSOURCE: https://github.com/vuejs/vuex/blob/main/docs/guide/getters.md#2025-04-22_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\ngetters: {\n  // ...\n  doneTodosCount (state, getters) {\n    return getters.doneTodos.length\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Basic Vuex Plugin\nDESCRIPTION: Creates a basic Vuex plugin that subscribes to store mutations. This example shows the fundamental structure of a Vuex plugin which receives the store as an argument and can listen to mutations.\nSOURCE: https://github.com/vuejs/vuex/blob/main/docs/ja/guide/plugins.md#2025-04-22_snippet_0\n\nLANGUAGE: js\nCODE:\n```\nconst myPlugin = (store) => {\n  // ストアが初期化されたときに呼ばれます\n  store.subscribe((mutation, state) => {\n    // それぞれのミューテーションの後に呼ばれます\n    // ミューテーションは `{ type, payload }` の形式で提供されます\n  })\n}\n```\n\n----------------------------------------\n\nTITLE: Abordagem Vuex para manipulação de input\nDESCRIPTION: Demonstra como vincular o valor do input e chamar uma ação no evento input, seguindo o 'modo Vuex' de lidar com formulários.\nSOURCE: https://github.com/vuejs/vuex/blob/main/docs/ptbr/guide/forms.md#2025-04-22_snippet_1\n\nLANGUAGE: html\nCODE:\n```\n<input :value=\"message\" @input=\"updateMessage\">\n```\n\nLANGUAGE: javascript\nCODE:\n```\n// ...\ncomputed: {\n  ...mapState({\n    message: state => state.obj.message\n  })\n},\nmethods: {\n  updateMessage (e) {\n    this.$store.commit('updateMessage', e.target.value)\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Taking State Snapshots in Vuex Plugins\nDESCRIPTION: Demonstrates how to create a plugin that takes snapshots of the Vuex state before and after mutations for comparison. It uses deep-cloning to create independent copies of the state.\nSOURCE: https://github.com/vuejs/vuex/blob/main/docs/guide/plugins.md#2025-04-22_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\nconst myPluginWithSnapshot = (store) => {\n  let prevState = _.cloneDeep(store.state)\n  store.subscribe((mutation, state) => {\n    let nextState = _.cloneDeep(state)\n\n    // compare `prevState` and `nextState`...\n\n    // save state for next mutation\n    prevState = nextState\n  })\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Vuex with NPM\nDESCRIPTION: This command installs the next version of Vuex using NPM package manager and saves it as a dependency in package.json.\nSOURCE: https://github.com/vuejs/vuex/blob/main/docs/ja/installation.md#2025-04-22_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nnpm install vuex@next --save\n```\n\n----------------------------------------\n\nTITLE: Creating a Reusable Vuex Module with Function-based State\nDESCRIPTION: Demonstrates how to define a reusable Vuex module using a function for state declaration to avoid state pollution between store instances. This pattern is essential when registering the same module multiple times or creating multiple stores with the same module.\nSOURCE: https://github.com/vuejs/vuex/blob/main/docs/ptbr/guide/modules.md#2025-04-22_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nconst MyReusableModule = {\n  state: () => ({\n    foo: 'bar'\n  }),\n  // mutations, actions, getters...\n}\n```\n\n----------------------------------------\n\nTITLE: Committing a Mutation in Vuex using JavaScript\nDESCRIPTION: This snippet shows how to commit a mutation in Vuex using the store.commit method. It demonstrates the simplest way to trigger a mutation without any payload.\nSOURCE: https://github.com/vuejs/vuex/blob/main/docs/ptbr/guide/mutations.md#2025-04-22_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nstore.commit('increment')\n```\n\n----------------------------------------\n\nTITLE: Dynamic Module Hot Reloading in Vuex using require.context\nDESCRIPTION: This snippet shows an advanced technique for hot reloading Vuex modules dynamically using require.context. It automatically loads all module files from a directory and configures them for hot reloading, making it easier to manage applications with multiple modules.\nSOURCE: https://github.com/vuejs/vuex/blob/main/docs/guide/hot-reload.md#2025-04-22_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\n// store.js\nimport { createStore } from 'vuex'\n\n// Load all modules.\nfunction loadModules() {\n  const context = require.context(\"./modules\", false, /([a-z_]+)\\.js$/i)\n\n  const modules = context\n    .keys()\n    .map((key) => ({ key, name: key.match(/([a-z_]+)\\.js$/i)[1] }))\n    .reduce(\n      (modules, { key, name }) => ({\n        ...modules,\n        [name]: context(key).default\n      }),\n      {}\n    )\n\n  return { context, modules }\n}\n\nconst { context, modules } = loadModules()\n\nconst store = createStore({\n  modules\n})\n\nif (module.hot) {\n  // Hot reload whenever any module changes.\n  module.hot.accept(context.id, () => {\n    const { modules } = loadModules()\n\n    store.hotUpdate({\n      modules\n    })\n  })\n}\n```\n\n----------------------------------------\n\nTITLE: Accessing Vuex State in a Vue Component with Global Store Pattern\nDESCRIPTION: Demonstrates how to retrieve Vuex state in a Vue component by returning store state from a computed property using the global store instance directly.\nSOURCE: https://github.com/vuejs/vuex/blob/main/docs/guide/state.md#2025-04-22_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// let's create a Counter component\nconst Counter = {\n  template: `<div>{{ count }}</div>`,\n  computed: {\n    count () {\n      return store.state.count\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Using mapActions Helper in Vue Components\nDESCRIPTION: Demonstrates how to use the mapActions helper to map component methods to store.dispatch calls, including support for actions with and without payloads.\nSOURCE: https://github.com/vuejs/vuex/blob/main/docs/guide/actions.md#2025-04-22_snippet_6\n\nLANGUAGE: javascript\nCODE:\n```\nimport { mapActions } from 'vuex'\n\nexport default {\n  // ...\n  methods: {\n    ...mapActions([\n      'increment', // map `this.increment()` to `this.$store.dispatch('increment')`\n\n      // `mapActions` also supports payloads:\n      'incrementBy' // map `this.incrementBy(amount)` to `this.$store.dispatch('incrementBy', amount)`\n    ]),\n    ...mapActions({\n      add: 'increment' // map `this.add()` to `this.$store.dispatch('increment')`\n    })\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Typed Store in Vue Application\nDESCRIPTION: This snippet demonstrates how to install a typed Vuex store in a Vue application by passing the injection key to the app.use() method.\nSOURCE: https://github.com/vuejs/vuex/blob/main/docs/zh/guide/typescript-support.md#2025-04-22_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\n// main.ts\nimport { createApp } from 'vue'\nimport { store, key } from './store'\n\nconst app = createApp({ ... })\n\n// 传入 injection key\napp.use(store, key)\n\napp.mount('#app')\n```\n\n----------------------------------------\n\nTITLE: Using Typed Store in Vue Component\nDESCRIPTION: Shows how to use the typed store in a Vue component using the useStore composition function with proper typing.\nSOURCE: https://github.com/vuejs/vuex/blob/main/docs/ptbr/guide/typescript-support.md#2025-04-22_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\n// in a vue component\nimport { useStore } from 'vuex'\nimport { key } from './store'\n\nexport default {\n  setup () {\n    const store = useStore(key)\n\n    store.state.count // tipado como number\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Example of Incorrect Asynchronous Mutation\nDESCRIPTION: Illustrates an anti-pattern where a mutation contains asynchronous code, which would make state changes difficult to track for debugging tools.\nSOURCE: https://github.com/vuejs/vuex/blob/main/docs/guide/mutations.md#2025-04-22_snippet_10\n\nLANGUAGE: javascript\nCODE:\n```\nmutations: {\n  someMutation (state) {\n    api.callAsyncMethod(() => {\n      state.count++\n    })\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Basic Vuex Mutations\nDESCRIPTION: Example of defining a simple increment mutation in a mutations.js file that increments a counter in the state.\nSOURCE: https://github.com/vuejs/vuex/blob/main/docs/guide/testing.md#2025-04-22_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\n// mutations.js\nexport const mutations = {\n  increment: state => state.count++\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Vue App with Typed Store\nDESCRIPTION: Demonstrates how to install a typed Vuex store in a Vue application using the injection key.\nSOURCE: https://github.com/vuejs/vuex/blob/main/docs/ptbr/guide/typescript-support.md#2025-04-22_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\n// main.ts\nimport { createApp } from 'vue'\nimport { store, key } from './store'\n\nconst app = createApp({ ... })\n\n// passe o injection key\napp.use(store, key)\n\napp.mount('#app')\n```\n\n----------------------------------------\n\nTITLE: Vuex-compliant form input handling\nDESCRIPTION: This approach binds the input value to a computed property and uses an event handler to commit mutations. It's more verbose but complies with Vuex's strict mode requirements.\nSOURCE: https://github.com/vuejs/vuex/blob/main/docs/guide/forms.md#2025-04-22_snippet_1\n\nLANGUAGE: html\nCODE:\n```\n<input :value=\"message\" @input=\"updateMessage\">\n```\n\nLANGUAGE: javascript\nCODE:\n```\n// ...\ncomputed: {\n  ...mapState({\n    message: state => state.obj.message\n  })\n},\nmethods: {\n  updateMessage (e) {\n    this.$store.commit('updateMessage', e.target.value)\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Conditionally Using Plugins in Development Mode\nDESCRIPTION: Shows how to configure plugins to only be used in development mode by leveraging environment variables and build tools.\nSOURCE: https://github.com/vuejs/vuex/blob/main/docs/ja/guide/plugins.md#2025-04-22_snippet_5\n\nLANGUAGE: js\nCODE:\n```\nconst store = createStore({\n  // ...\n  plugins: process.env.NODE_ENV !== 'production'\n    ? [myPluginWithSnapshot]\n    : []\n})\n```\n\n----------------------------------------\n\nTITLE: Using Custom Typed useStore in Component\nDESCRIPTION: Shows how to use the custom typed useStore function in a Vue component for simplified store access with typing.\nSOURCE: https://github.com/vuejs/vuex/blob/main/docs/ptbr/guide/typescript-support.md#2025-04-22_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\n// em um componente vue\nimport { useStore } from './store'\n\nexport default {\n  setup () {\n    const store = useStore()\n\n    store.state.count // tipado como number\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Using ES2015 Argument Destructuring with Vuex Actions\nDESCRIPTION: Shows how to simplify action code using ES2015 argument destructuring to directly access the commit method from the context object.\nSOURCE: https://github.com/vuejs/vuex/blob/main/docs/guide/actions.md#2025-04-22_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nactions: {\n  increment ({ commit }) {\n    commit('increment')\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Mutation that Accepts an Object Payload\nDESCRIPTION: Shows how to create a mutation handler that works with an object payload containing multiple properties.\nSOURCE: https://github.com/vuejs/vuex/blob/main/docs/guide/mutations.md#2025-04-22_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\n// ...\nmutations: {\n  increment (state, payload) {\n    state.count += payload.amount\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Vuex 4 in a Vue 3 Application\nDESCRIPTION: Shows how to install a Vuex 4 store in a Vue 3 application using the app.use() method, passing the store instance directly rather than passing Vuex itself.\nSOURCE: https://github.com/vuejs/vuex/blob/main/docs/guide/migrating-to-4-0-from-3-x.md#2025-04-22_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { createApp } from 'vue'\nimport { store } from './store'\nimport App from './App.vue'\n\nconst app = createApp(App)\n\napp.use(store)\n\napp.mount('#app')\n```\n\n----------------------------------------\n\nTITLE: Incorrect Asynchronous Mutation in Vuex using JavaScript\nDESCRIPTION: This example demonstrates an incorrect way to implement an asynchronous mutation. Mutations should be synchronous to ensure proper state tracking and debugging.\nSOURCE: https://github.com/vuejs/vuex/blob/main/docs/ptbr/guide/mutations.md#2025-04-22_snippet_8\n\nLANGUAGE: javascript\nCODE:\n```\nmutations: {\n  someMutation (state) {\n    api.callAsyncMethod(() => {\n      state.count++\n    })\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Working with Module Local State\nDESCRIPTION: Shows how to define and access local state within a Vuex module. Module mutations and getters receive the module's local state as their first argument, allowing for encapsulated state management.\nSOURCE: https://github.com/vuejs/vuex/blob/main/docs/guide/modules.md#2025-04-22_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nconst moduleA = {\n  state: () => ({\n    count: 0\n  }),\n  mutations: {\n    increment (state) {\n      // `state` is the local module state\n      state.count++\n    }\n  },\n  getters: {\n    doubleCount (state) {\n      return state.count * 2\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Custom useStore Composition Function\nDESCRIPTION: This snippet demonstrates how to create a custom useStore composition function that automatically provides the injection key and correct typing, simplifying the store usage across components.\nSOURCE: https://github.com/vuejs/vuex/blob/main/docs/zh/guide/typescript-support.md#2025-04-22_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\n// store.ts\nimport { InjectionKey } from 'vue'\nimport { createStore, useStore as baseUseStore, Store } from 'vuex'\n\nexport interface State {\n  count: number\n}\n\nexport const key: InjectionKey<Store<State>> = Symbol()\n\nexport const store = createStore<State>({\n  state: {\n    count: 0\n  }\n})\n\n// 定义自己的 `useStore` 组合式函数\nexport function useStore () {\n  return baseUseStore(key)\n}\n```\n\n----------------------------------------\n\nTITLE: Accessing Root State in Module Actions\nDESCRIPTION: Shows how to access both local and root state in a module's actions. The action context provides access to local state via state and root state via rootState.\nSOURCE: https://github.com/vuejs/vuex/blob/main/docs/guide/modules.md#2025-04-22_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nconst moduleA = {\n  // ...\n  actions: {\n    incrementIfOddOnRootSum ({ state, commit, rootState }) {\n      if ((state.count + rootState.count) % 2 === 1) {\n        commit('increment')\n      }\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Subscribing to Vuex Actions\nDESCRIPTION: Shows how to subscribe to store actions to track dispatched actions. This is useful for logging, analytics, or debugging asynchronous operations in a Vuex store.\nSOURCE: https://github.com/vuejs/vuex/blob/main/docs/api/index.md#2025-04-22_snippet_5\n\nLANGUAGE: javascript\nCODE:\n```\nconst unsubscribe = store.subscribeAction((action, state) => {\n  console.log(action.type)\n  console.log(action.payload)\n})\n\n// you may call unsubscribe to stop the subscription\nunsubscribe()\n```\n\n----------------------------------------\n\nTITLE: Accessing Root State in Module Getters\nDESCRIPTION: Demonstrates how module getters can access root state through the third argument. This allows modules to compute derived state that depends on both local and root state values.\nSOURCE: https://github.com/vuejs/vuex/blob/main/docs/guide/modules.md#2025-04-22_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nconst moduleA = {\n  // ...\n  getters: {\n    sumWithRootCount (state, getters, rootState) {\n      return state.count + rootState.count\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Accessing Vuex State Using this.$store in Vue Component (JavaScript)\nDESCRIPTION: Shows how to access Vuex state in a Vue component using this.$store, which is available after Vuex injects the store into all child components of the root component.\nSOURCE: https://github.com/vuejs/vuex/blob/main/docs/ptbr/guide/state.md#2025-04-22_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nconst Counter = {\n  template: `<div>{{ count }}</div>`,\n  computed: {\n    count () {\n      return this.$store.state.count\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Adding a Plugin to Vuex Store\nDESCRIPTION: Shows how to add a plugin to a Vuex store instance using the plugins option in the store configuration.\nSOURCE: https://github.com/vuejs/vuex/blob/main/docs/guide/plugins.md#2025-04-22_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nconst store = createStore({\n  // ...\n  plugins: [myPlugin]\n})\n```\n\n----------------------------------------\n\nTITLE: Binding Namespaced Modules to Components (Verbose Form)\nDESCRIPTION: Shows the verbose way of binding namespaced module state, getters, and actions to Vue components using the mapState, mapGetters, and mapActions helpers with fully qualified paths.\nSOURCE: https://github.com/vuejs/vuex/blob/main/docs/guide/modules.md#2025-04-22_snippet_7\n\nLANGUAGE: javascript\nCODE:\n```\ncomputed: {\n  ...mapState({\n    a: state => state.some.nested.module.a,\n    b: state => state.some.nested.module.b\n  }),\n  ...mapGetters([\n    'some/nested/module/someGetter', // -> this['some/nested/module/someGetter']\n    'some/nested/module/someOtherGetter', // -> this['some/nested/module/someOtherGetter']\n  ])\n},\nmethods: {\n  ...mapActions([\n    'some/nested/module/foo', // -> this['some/nested/module/foo']()\n    'some/nested/module/bar' // -> this['some/nested/module/bar']()\n  ])\n}\n```\n\n----------------------------------------\n\nTITLE: Using Vuex's Built-in Logger Plugin\nDESCRIPTION: Demonstrates how to use Vuex's built-in logger plugin for debugging. This plugin logs mutations to the console to help track state changes during development.\nSOURCE: https://github.com/vuejs/vuex/blob/main/docs/guide/plugins.md#2025-04-22_snippet_6\n\nLANGUAGE: javascript\nCODE:\n```\nimport { createLogger } from 'vuex'\n\nconst store = createStore({\n  plugins: [createLogger()]\n})\n```\n\n----------------------------------------\n\nTITLE: Configuring Basic Hot Reloading for Vuex Store in JavaScript\nDESCRIPTION: This snippet demonstrates how to set up basic hot reloading for a Vuex store, including mutations and modules. It uses the store.hotUpdate() method to apply changes when modules are updated.\nSOURCE: https://github.com/vuejs/vuex/blob/main/docs/zh/guide/hot-reload.md#2025-04-22_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// store.js\nimport { createStore } from 'vuex'\nimport mutations from './mutations'\nimport moduleA from './modules/a'\n\nconst state = { ... }\n\nconst store = createStore({\n  state,\n  mutations,\n  modules: {\n    a: moduleA\n  }\n})\n\nif (module.hot) {\n  // 使 action 和 mutation 成为可热重载模块\n  module.hot.accept(['./mutations', './modules/a'], () => {\n    // 获取更新后的模块\n    // 因为 babel 6 的模块编译格式问题，这里需要加上 `.default`\n    const newMutations = require('./mutations').default\n    const newModuleA = require('./modules/a').default\n    // 加载新模块\n    store.hotUpdate({\n      mutations: newMutations,\n      modules: {\n        a: newModuleA\n      }\n    })\n  })\n}\n```\n\n----------------------------------------\n\nTITLE: Conditionally Using Plugins in Development Mode\nDESCRIPTION: Shows how to apply certain plugins only in development environments using environment variables. This is useful for performance-intensive plugins like state snapshot plugins.\nSOURCE: https://github.com/vuejs/vuex/blob/main/docs/guide/plugins.md#2025-04-22_snippet_5\n\nLANGUAGE: javascript\nCODE:\n```\nconst store = createStore({\n  // ...\n  plugins: process.env.NODE_ENV !== 'production'\n    ? [myPluginWithSnapshot]\n    : []\n})\n```\n\n----------------------------------------\n\nTITLE: Basic Computed Property Example\nDESCRIPTION: Simple example showing how to compute derived state using a component's computed property\nSOURCE: https://github.com/vuejs/vuex/blob/main/docs/guide/getters.md#2025-04-22_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\ncomputed: {\n  doneTodosCount () {\n    return this.$store.state.todos.filter(todo => todo.done).length\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Enabling Strict Mode in Vuex Store Creation (JavaScript)\nDESCRIPTION: This snippet demonstrates how to enable strict mode when creating a Vuex store. Strict mode throws an error if state is mutated outside of mutation handlers, aiding in debugging.\nSOURCE: https://github.com/vuejs/vuex/blob/main/docs/guide/strict.md#2025-04-22_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nconst store = createStore({\n  // ...\n  strict: true\n})\n```\n\n----------------------------------------\n\nTITLE: Using Custom useStore Function in Vue Components\nDESCRIPTION: This snippet shows how to use the custom useStore function in Vue components, which automatically provides the correct typing without needing to pass the injection key explicitly.\nSOURCE: https://github.com/vuejs/vuex/blob/main/docs/zh/guide/typescript-support.md#2025-04-22_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\n// vue 组件\nimport { useStore } from './store'\n\nexport default {\n  setup () {\n    const store = useStore()\n\n    store.state.count // 类型为 number\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Strict Mode for Development in Vuex Store (JavaScript)\nDESCRIPTION: This code shows how to conditionally enable strict mode only in development environments. It uses the NODE_ENV environment variable to determine whether to enable strict mode, avoiding performance costs in production.\nSOURCE: https://github.com/vuejs/vuex/blob/main/docs/guide/strict.md#2025-04-22_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nconst store = createStore({\n  // ...\n  strict: process.env.NODE_ENV !== 'production'\n})\n```\n\n----------------------------------------\n\nTITLE: Action Subscription with Error Handling\nDESCRIPTION: Demonstrates how to add an error handler to action subscriptions for catching and handling exceptions that occur during action execution.\nSOURCE: https://github.com/vuejs/vuex/blob/main/docs/api/index.md#2025-04-22_snippet_8\n\nLANGUAGE: javascript\nCODE:\n```\nstore.subscribeAction({\n  error: (action, state, error) => {\n    console.log(`error action ${action.type}`)\n    console.error(error)\n  }\n})\n```\n\n----------------------------------------\n\nTITLE: Using Constants for Mutation Types\nDESCRIPTION: Shows how to define mutation type constants in a separate file for better tooling support and collaboration.\nSOURCE: https://github.com/vuejs/vuex/blob/main/docs/guide/mutations.md#2025-04-22_snippet_8\n\nLANGUAGE: javascript\nCODE:\n```\n// mutation-types.js\nexport const SOME_MUTATION = 'SOME_MUTATION'\n```\n\n----------------------------------------\n\nTITLE: Configuring Vuex Logger Plugin Options\nDESCRIPTION: Shows the available configuration options for the Vuex logger plugin. These options can customize the logging behavior, including filtering mutations/actions, transforming state output, and formatting logged data.\nSOURCE: https://github.com/vuejs/vuex/blob/main/docs/guide/plugins.md#2025-04-22_snippet_7\n\nLANGUAGE: javascript\nCODE:\n```\nconst logger = createLogger({\n  collapsed: false, // auto-expand logged mutations\n  filter (mutation, stateBefore, stateAfter) {\n    // returns `true` if a mutation should be logged\n    // `mutation` is a `{ type, payload }`\n    return mutation.type !== \"aBlocklistedMutation\"\n  },\n  actionFilter (action, state) {\n    // same as `filter` but for actions\n    // `action` is a `{ type, payload }`\n    return action.type !== \"aBlocklistedAction\"\n  },\n  transformer (state) {\n    // transform the state before logging it.\n    // for example return only a specific sub-tree\n    return state.subTree\n  },\n  mutationTransformer (mutation) {\n    // mutations are logged in the format of `{ type, payload }`\n    // we can format it any way we want.\n    return mutation.type\n  },\n  actionTransformer (action) {\n    // Same as mutationTransformer but for actions\n    return action.type\n  },\n  logActions: true, // Log Actions\n  logMutations: true, // Log mutations\n  logger: console, // implementation of the `console` API, default `console`\n})\n```\n\n----------------------------------------\n\nTITLE: Using WebSocket Plugin with Vuex Store\nDESCRIPTION: Demonstrates how to instantiate and use the WebSocket plugin with a Vuex store.\nSOURCE: https://github.com/vuejs/vuex/blob/main/docs/ja/guide/plugins.md#2025-04-22_snippet_3\n\nLANGUAGE: js\nCODE:\n```\nconst plugin = createWebSocketPlugin(socket)\n\nconst store = createStore({\n  state,\n  mutations,\n  plugins: [plugin]\n})\n```\n\n----------------------------------------\n\nTITLE: Creating Typed Vuex Store with InjectionKey\nDESCRIPTION: Shows how to create a typed Vuex store using InjectionKey for proper typing in the composition API context.\nSOURCE: https://github.com/vuejs/vuex/blob/main/docs/ptbr/guide/typescript-support.md#2025-04-22_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n// store.ts\nimport { InjectionKey } from 'vue'\nimport { createStore, Store } from 'vuex'\n\n// defina suas tipagens para o estado do store\nexport interface State {\n  count: number\n}\n\n// defina o injection key\nexport const key: InjectionKey<Store<State>> = Symbol()\n\nexport const store = createStore<State>({\n  state: {\n    count: 0\n  }\n})\n```\n\n----------------------------------------\n\nTITLE: Creating WebSocket Synchronization Plugin\nDESCRIPTION: Implements a WebSocket plugin that synchronizes data between a WebSocket connection and Vuex store. The plugin listens for socket events and commits mutations, and also sends updates to the socket when specific mutations occur.\nSOURCE: https://github.com/vuejs/vuex/blob/main/docs/ja/guide/plugins.md#2025-04-22_snippet_2\n\nLANGUAGE: js\nCODE:\n```\nexport default function createWebSocketPlugin (socket) {\n  return (store) => {\n    socket.on('data', data => {\n      store.commit('receiveData', data)\n    })\n    store.subscribe(mutation => {\n      if (mutation.type === 'UPDATE_DATA') {\n        socket.emit('update', mutation.payload)\n      }\n    })\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing a Simple Vue Counter Component\nDESCRIPTION: A basic example of a self-contained Vue counter component that demonstrates the core concepts of state, view, and actions in a simple application. This example shows the foundation of the state management pattern before introducing Vuex.\nSOURCE: https://github.com/vuejs/vuex/blob/main/docs/index.md#2025-04-22_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nconst Counter = {\n  // state\n  data () {\n    return {\n      count: 0\n    }\n  },\n  // view\n  template: `\n    <div>{{ count }}</div>\n  `,\n  // actions\n  methods: {\n    increment () {\n      this.count++\n    }\n  }\n}\n\ncreateApp(Counter).mount('#app')\n```\n\n----------------------------------------\n\nTITLE: Exporting Vuex Mutations for Testing\nDESCRIPTION: Shows how to structure a store.js file to export mutations as a named export, making them easier to test independently.\nSOURCE: https://github.com/vuejs/vuex/blob/main/docs/guide/testing.md#2025-04-22_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nconst state = { ... }\n\n// export `mutations` as a named export\nexport const mutations = { ... }\n\nexport default createStore({\n  state,\n  mutations\n})\n```\n\n----------------------------------------\n\nTITLE: Using mapState with Array Syntax in Vue Component (JavaScript)\nDESCRIPTION: Demonstrates the use of mapState with an array of strings when the names of computed properties match the names of state subtrees.\nSOURCE: https://github.com/vuejs/vuex/blob/main/docs/ptbr/guide/state.md#2025-04-22_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\ncomputed: mapState([\n  // mapeia this.count para store.state.count\n  'count'\n])\n```\n\n----------------------------------------\n\nTITLE: Implementing Vuex Getters\nDESCRIPTION: Defines a getter that filters products based on a category. The getter function accesses state and other getters to produce filtered results.\nSOURCE: https://github.com/vuejs/vuex/blob/main/docs/guide/testing.md#2025-04-22_snippet_6\n\nLANGUAGE: javascript\nCODE:\n```\n// getters.js\nexport const getters = {\n  filteredProducts (state, { filterCategory }) {\n    return state.products.filter(product => {\n      return product.category === filterCategory\n    })\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Registering Plugins with Vuex Store\nDESCRIPTION: Shows how to register a plugin with the Vuex store using the plugins option when creating a new store.\nSOURCE: https://github.com/vuejs/vuex/blob/main/docs/ja/guide/plugins.md#2025-04-22_snippet_1\n\nLANGUAGE: js\nCODE:\n```\nconst store = createStore({\n  // ...\n  plugins: [myPlugin]\n})\n```\n\n----------------------------------------\n\nTITLE: Testing Vuex Getters with Mocha and Chai\nDESCRIPTION: Example test for a filteredProducts getter that verifies the getter correctly filters products by category using mock state and parameters.\nSOURCE: https://github.com/vuejs/vuex/blob/main/docs/guide/testing.md#2025-04-22_snippet_7\n\nLANGUAGE: javascript\nCODE:\n```\n// getters.spec.js\nimport { expect } from 'chai'\nimport { getters } from './getters'\n\ndescribe('getters', () => {\n  it('filteredProducts', () => {\n    // mock state\n    const state = {\n      products: [\n        { id: 1, title: 'Apple', category: 'fruit' },\n        { id: 2, title: 'Orange', category: 'fruit' },\n        { id: 3, title: 'Carrot', category: 'vegetable' }\n      ]\n    }\n    // mock getter\n    const filterCategory = 'fruit'\n\n    // get the result from the getter\n    const result = getters.filteredProducts(state, { filterCategory })\n\n    // assert the result\n    expect(result).to.deep.equal([\n      { id: 1, title: 'Apple', category: 'fruit' },\n      { id: 2, title: 'Orange', category: 'fruit' }\n    ])\n  })\n})\n```\n\n----------------------------------------\n\nTITLE: Combining Local Computed Properties with mapState Using Object Spread (JavaScript)\nDESCRIPTION: Shows how to combine local computed properties with mapState using the object spread operator, allowing for a mix of local and Vuex state in the computed properties.\nSOURCE: https://github.com/vuejs/vuex/blob/main/docs/ptbr/guide/state.md#2025-04-22_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\ncomputed: {\n  localComputed () { /* ... */ },\n  // mistura isso no objeto externo com o objeto spread operator\n  ...mapState({\n    // ...\n  })\n}\n```\n\n----------------------------------------\n\nTITLE: Using mapState Helper in Vue Component (JavaScript)\nDESCRIPTION: Illustrates the use of the mapState helper to generate computed getter functions for Vuex state properties. This approach reduces code repetition when accessing multiple state properties.\nSOURCE: https://github.com/vuejs/vuex/blob/main/docs/ptbr/guide/state.md#2025-04-22_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nimport { mapState } from 'vuex'\n\nexport default {\n  // ...\n  computed: mapState({\n    // As arrow functions (ou funções de seta) podem tornar o código muito sucinto!\n    count: state => state.count,\n\n    // passar o valor da String 'count' é o mesmo que `state => state.count`\n    countAlias: 'count',\n\n    // para acessar o estado local com `this`, uma função normal deve ser usada\n    countPlusLocalState (state) {\n      return state.count + this.localCount\n    }\n  })\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Logger Plugin Options\nDESCRIPTION: Shows the available configuration options for the built-in logger plugin, including filtering mutations and actions, transforming state and payloads, and customizing the logging behavior.\nSOURCE: https://github.com/vuejs/vuex/blob/main/docs/ja/guide/plugins.md#2025-04-22_snippet_7\n\nLANGUAGE: js\nCODE:\n```\nconst logger = createLogger({\n  collapsed: false, // ログ出力されたミューテーションを自動で展開します\n  filter (mutation, stateBefore, stateAfter) {\n    // ミューテーションを記録する必要がある場合は、`true` を返します\n    // `mutation` は `{ type, payload }` です\n    return mutation.type !== \"aBlocklistedMutation\"\n  },\n  actionFilter (action, state) {\n    // `filter` と同等ですが、アクション用です\n    // `action` は `{ type, payloed }` です\n    return action.type !== \"aBlocklistedAction\"\n  },\n  transformer (state) {\n    // ロギングの前に、状態を変換します\n    // 例えば、特定のサブツリーのみを返します\n    return state.subTree\n  },\n  mutationTransformer (mutation) {\n    // ミューテーションは、`{ type, payload }` の形式でログ出力されます\n    // 任意の方法でそれをフォーマットできます\n    return mutation.type\n  },\n  actionTransformer (action) {\n    // `mutationTransformer` と同等ですが、アクション用です\n    return action.type\n  },\n  logActions: true, // アクションログを出力します。\n  logMutations: true, // ミューテーションログを出力します。\n  logger: console, // `console` API の実装, デフォルトは `console`\n})\n```\n\n----------------------------------------\n\nTITLE: Mutation Handler for Object-Style Commits\nDESCRIPTION: Demonstrates that the mutation handler remains the same for both regular and object-style commits.\nSOURCE: https://github.com/vuejs/vuex/blob/main/docs/guide/mutations.md#2025-04-22_snippet_7\n\nLANGUAGE: javascript\nCODE:\n```\nmutations: {\n  increment (state, payload) {\n    state.count += payload.amount\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Using Constants for Mutation Types in Vuex with JavaScript\nDESCRIPTION: This snippet shows how to use constants to declare mutation types. This pattern is often used in Flux implementations and can be helpful in large projects.\nSOURCE: https://github.com/vuejs/vuex/blob/main/docs/ptbr/guide/mutations.md#2025-04-22_snippet_7\n\nLANGUAGE: javascript\nCODE:\n```\n// mutation-types.js\nexport const SOME_MUTATION = 'SOME_MUTATION'\n```\n\nLANGUAGE: javascript\nCODE:\n```\n// store.js\nimport { createStore } from 'vuex'\nimport { SOME_MUTATION } from './mutation-types'\n\nconst store = createStore({\n  state: { ... },\n  mutations: {\n    // podemos usar o recurso de nome do dado computado do ES2015\n    // para usar uma constante como o nome da função\n    [SOME_MUTATION] (state) {\n      // muda o estado\n    }\n  }\n})\n```\n\n----------------------------------------\n\nTITLE: MapGetters with Name Mapping\nDESCRIPTION: Example of mapping getters to different names using an object syntax\nSOURCE: https://github.com/vuejs/vuex/blob/main/docs/guide/getters.md#2025-04-22_snippet_6\n\nLANGUAGE: javascript\nCODE:\n```\n...mapGetters({\n  // map `this.doneCount` to `this.$store.getters.doneTodosCount`\n  doneCount: 'doneTodosCount'\n})\n```\n\n----------------------------------------\n\nTITLE: Using Built-in Logger Plugin\nDESCRIPTION: Demonstrates how to use Vuex's built-in logger plugin for debugging purposes.\nSOURCE: https://github.com/vuejs/vuex/blob/main/docs/ja/guide/plugins.md#2025-04-22_snippet_6\n\nLANGUAGE: js\nCODE:\n```\nimport { createLogger } from 'vuex'\n\nconst store = createStore({\n  plugins: [createLogger()]\n})\n```\n\n----------------------------------------\n\nTITLE: Implementing Dynamic Module Hot Reloading in Vuex with JavaScript\nDESCRIPTION: This code snippet shows how to implement dynamic module hot reloading in Vuex using require.context. It automatically loads all modules from a directory and sets up hot reloading for them.\nSOURCE: https://github.com/vuejs/vuex/blob/main/docs/zh/guide/hot-reload.md#2025-04-22_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\n// store.js\nimport { createStore } from 'vuex'\n\n// 加载所有模块。\nfunction loadModules() {\n  const context = require.context(\"./modules\", false, /([a-z_]+)\\.js$/i)\n\n  const modules = context\n    .keys()\n    .map((key) => ({ key, name: key.match(/([a-z_]+)\\.js$/i)[1] }))\n    .reduce(\n      (modules, { key, name }) => ({\n        ...modules,\n        [name]: context(key).default\n      }),\n      {}\n    )\n\n  return { context, modules }\n}\n\nconst { context, modules } = loadModules()\n\nconst store = new createStore({\n  modules\n})\n\nif (module.hot) {\n  // 在任何模块发生改变时进行热重载。\n  module.hot.accept(context.id, () => {\n    const { modules } = loadModules()\n\n    store.hotUpdate({\n      modules\n    })\n  })\n}\n```\n\n----------------------------------------\n\nTITLE: Using v-model with Vuex state (problematic in strict mode)\nDESCRIPTION: This snippet demonstrates the use of v-model with a computed property returning a Vuex state object. This approach is problematic in Vuex strict mode as it attempts to directly mutate the state.\nSOURCE: https://github.com/vuejs/vuex/blob/main/docs/guide/forms.md#2025-04-22_snippet_0\n\nLANGUAGE: html\nCODE:\n```\n<input v-model=\"obj.message\">\n```\n\n----------------------------------------\n\nTITLE: Creating Namespaced Plugins for Vuex\nDESCRIPTION: Demonstrates how to create a Vuex plugin that works with namespaced modules. The plugin accepts a namespace option that can be used to prefix actions and mutations when the plugin is used in a namespaced context.\nSOURCE: https://github.com/vuejs/vuex/blob/main/docs/guide/modules.md#2025-04-22_snippet_10\n\nLANGUAGE: javascript\nCODE:\n```\n// get namespace value via plugin option\n// and returns Vuex plugin function\nexport function createPlugin (options = {}) {\n  return function (store) {\n    // add namespace to plugin module's types\n    const namespace = options.namespace || ''\n    store.dispatch(namespace + 'pluginAction')\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Função manipuladora de mutação Vuex\nDESCRIPTION: Define a função manipuladora de mutação no Vuex para atualizar a mensagem no estado.\nSOURCE: https://github.com/vuejs/vuex/blob/main/docs/ptbr/guide/forms.md#2025-04-22_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\n// ...\nmutations: {\n  updateMessage (state, message) {\n    state.obj.message = message\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Importing createLogger from Vuex 4 Core Module\nDESCRIPTION: Shows how to import the createLogger function directly from the core Vuex package in version 4, which was previously imported from 'vuex/dist/logger' in version 3.\nSOURCE: https://github.com/vuejs/vuex/blob/main/docs/guide/migrating-to-4-0-from-3-x.md#2025-04-22_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nimport { createLogger } from 'vuex'\n```\n\n----------------------------------------\n\nTITLE: Uso problemático de v-model com Vuex\nDESCRIPTION: Exemplo de código que demonstra o uso problemático de v-model com um objeto do store Vuex, que pode resultar em erro no modo estrito.\nSOURCE: https://github.com/vuejs/vuex/blob/main/docs/ptbr/guide/forms.md#2025-04-22_snippet_0\n\nLANGUAGE: html\nCODE:\n```\n<input v-model=\"obj.message\">\n```\n\n----------------------------------------\n\nTITLE: TypeScript Module Augmentation for Vuex 4\nDESCRIPTION: Provides type declarations for Vuex 4 to properly type the $store property in Vue components. This addresses a previous typing issue (#994) by requiring manual module augmentation.\nSOURCE: https://github.com/vuejs/vuex/blob/main/docs/guide/migrating-to-4-0-from-3-x.md#2025-04-22_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\n// vuex-shim.d.ts\n\nimport { ComponentCustomProperties } from 'vue'\nimport { Store } from 'vuex'\n\ndeclare module 'vue' {\n  // Declare your own store states.\n  interface State {\n    count: number\n  }\n\n  interface ComponentCustomProperties {\n    $store: Store<State>\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Including Vuex via script tags in HTML\nDESCRIPTION: Demonstrates how to install Vuex by including it via script tags after Vue.js. Vuex will automatically install itself when loaded after Vue.\nSOURCE: https://github.com/vuejs/vuex/blob/main/docs/installation.md#2025-04-22_snippet_0\n\nLANGUAGE: html\nCODE:\n```\n<script src=\"/path/to/vue.js\"></script>\n<script src=\"/path/to/vuex.js\"></script>\n```\n\n----------------------------------------\n\nTITLE: Uso de v-model com dado computado bidirecional\nDESCRIPTION: Demonstra uma abordagem alternativa usando um dado computado bidirecional com um setter para manter a sintaxe v-model.\nSOURCE: https://github.com/vuejs/vuex/blob/main/docs/ptbr/guide/forms.md#2025-04-22_snippet_3\n\nLANGUAGE: html\nCODE:\n```\n<input v-model=\"message\">\n```\n\nLANGUAGE: javascript\nCODE:\n```\n// ...\ncomputed: {\n  message: {\n    get () {\n      return this.$store.state.obj.message\n    },\n    set (value) {\n      this.$store.commit('updateMessage', value)\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Including Vuex via Script Tags in HTML\nDESCRIPTION: This snippet demonstrates how to include Vuex in a project using script tags after loading Vue.js. When loaded this way, Vuex is automatically installed.\nSOURCE: https://github.com/vuejs/vuex/blob/main/docs/ja/installation.md#2025-04-22_snippet_0\n\nLANGUAGE: html\nCODE:\n```\n<script src=\"/path/to/vue.js\"></script>\n<script src=\"/path/to/vuex.js\"></script>\n```\n\n----------------------------------------\n\nTITLE: Webpack Configuration for Node.js Testing\nDESCRIPTION: Webpack configuration for running tests in Node.js environment. It specifies entry point, output, and babel-loader for transpiling JS files.\nSOURCE: https://github.com/vuejs/vuex/blob/main/docs/guide/testing.md#2025-04-22_snippet_8\n\nLANGUAGE: javascript\nCODE:\n```\n// webpack.config.js\nmodule.exports = {\n  entry: './test.js',\n  output: {\n    path: __dirname,\n    filename: 'test-bundle.js'\n  },\n  module: {\n    loaders: [\n      {\n        test: /\\.js$/,\n        loader: 'babel-loader',\n        exclude: /node_modules/\n      }\n    ]\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Running Vuex Examples Using npm\nDESCRIPTION: Instructions for installing dependencies and serving example applications built with Vuex. This snippet demonstrates how to set up and run the examples provided in the Vuex repository.\nSOURCE: https://github.com/vuejs/vuex/blob/main/README.md#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n$ npm install\n$ npm run dev # serve examples at localhost:8080\n```\n\n----------------------------------------\n\nTITLE: Running Tests in Node.js\nDESCRIPTION: Commands for bundling tests with webpack and running them with Mocha in a Node.js environment.\nSOURCE: https://github.com/vuejs/vuex/blob/main/docs/guide/testing.md#2025-04-22_snippet_9\n\nLANGUAGE: bash\nCODE:\n```\nwebpack\nmocha test-bundle.js\n```\n\n----------------------------------------\n\nTITLE: Testing TypeScript Declarations with TSC\nDESCRIPTION: Command to compile and validate TypeScript declarations using the TypeScript compiler with a specific test configuration file.\nSOURCE: https://github.com/vuejs/vuex/blob/main/types/README.md#2025-04-22_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\n$ tsc -p test/tsconfig.json\n```\n\n----------------------------------------\n\nTITLE: Installing Vuex with NPM\nDESCRIPTION: Shows how to install Vuex using NPM package manager. This command installs the next version of Vuex and saves it as a dependency in package.json.\nSOURCE: https://github.com/vuejs/vuex/blob/main/docs/installation.md#2025-04-22_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nnpm install vuex@next --save\n```\n\n----------------------------------------\n\nTITLE: Installing Vuex with Yarn\nDESCRIPTION: Shows how to install Vuex using Yarn package manager. This command installs the next version of Vuex and saves it as a dependency in package.json.\nSOURCE: https://github.com/vuejs/vuex/blob/main/docs/installation.md#2025-04-22_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nyarn add vuex@next --save\n```\n\n----------------------------------------\n\nTITLE: Installing Vuex with Yarn\nDESCRIPTION: This command installs the next version of Vuex using Yarn package manager and saves it as a dependency.\nSOURCE: https://github.com/vuejs/vuex/blob/main/docs/ja/installation.md#2025-04-22_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nyarn add vuex@next --save\n```\n\n----------------------------------------\n\nTITLE: Building Vuex from source (dev build)\nDESCRIPTION: Instructions for building Vuex from the GitHub repository source code. This process involves cloning the repository, installing dependencies, and building the library for those who need the latest development version.\nSOURCE: https://github.com/vuejs/vuex/blob/main/docs/installation.md#2025-04-22_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/vuejs/vuex.git node_modules/vuex\ncd node_modules/vuex\nyarn\nyarn build\n```\n\n----------------------------------------\n\nTITLE: Building Vuex from Source for Development\nDESCRIPTION: These commands clone the Vuex repository from GitHub, navigate to the directory, install dependencies, and build the development version from source code.\nSOURCE: https://github.com/vuejs/vuex/blob/main/docs/ja/installation.md#2025-04-22_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/vuejs/vuex.git node_modules/vuex\ncd node_modules/vuex\nyarn\nyarn build\n```\n\n----------------------------------------\n\nTITLE: Configuring TypeScript Store State Declaration\nDESCRIPTION: TypeScript declaration file for augmenting Vue's runtime core to add store state typing support. Enables proper typing for this.$store in Vue components.\nSOURCE: https://github.com/vuejs/vuex/blob/main/CHANGELOG.md#2025-04-22_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\n// vuex-shim.d.ts\n\ndeclare module \"@vue/runtime-core\" {\n  // Declare your own store states.\n  interface State {\n    count: number\n  }\n\n  interface ComponentCustomProperties {\n    $store: Store<State>;\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Accessing Vuex Store with useStore in JavaScript\nDESCRIPTION: This snippet demonstrates how to access the Vuex store within the setup hook using the useStore function. This is equivalent to accessing this.$store in components using the Options API.\nSOURCE: https://github.com/vuejs/vuex/blob/main/docs/ptbr/guide/composition-api.md#2025-04-22_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport { useStore } from 'vuex'\n\nexport default {\n  setup () {\n    const store = useStore()\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Accessing Vuex Store in Composition API\nDESCRIPTION: Demonstrates how to access the Vuex store within the setup hook using useStore function. This is equivalent to accessing this.$store in Options API.\nSOURCE: https://github.com/vuejs/vuex/blob/main/docs/ja/guide/composition-api.md#2025-04-22_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport { useStore } from 'vuex'\n\nexport default {\n  setup () {\n    const store = useStore()\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Vuex Store Instance with Vue 3\nDESCRIPTION: Example of creating a new Vuex store instance using the createStore function introduced in Vuex 4. Demonstrates the new initialization pattern aligned with Vue 3.\nSOURCE: https://github.com/vuejs/vuex/blob/main/CHANGELOG.md#2025-04-22_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\nimport { createStore } from 'vuex'\n\nconst store = createStore({\n  state () {\n    return {\n      count: 1\n    }\n  }\n})\n```\n\n----------------------------------------\n\nTITLE: TypeScript Component Store Declaration\nDESCRIPTION: TypeScript module augmentation for adding store typing to Vue components, enabling proper typing for this.$store.\nSOURCE: https://github.com/vuejs/vuex/blob/main/CHANGELOG.md#2025-04-22_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { ComponentCustomProperties } from 'vue'\nimport { Store } from 'vuex'\n\ndeclare module '@vue/runtime-core' {\n  // Declare your own store states.\n  interface State {\n    count: number\n  }\n\n  interface ComponentCustomProperties {\n    $store: Store<State>\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Vuex Store in Vue 3 Application\nDESCRIPTION: Example showing how to install and initialize a Vuex store in a Vue 3 application using the new app.use() pattern.\nSOURCE: https://github.com/vuejs/vuex/blob/main/CHANGELOG.md#2025-04-22_snippet_5\n\nLANGUAGE: javascript\nCODE:\n```\nimport { createApp } from 'vue'\nimport store from './store'\nimport App from './APP.vue'\n\nconst app = createApp(Counter)\n\napp.use(store)\n\napp.mount('#app')\n```\n\n----------------------------------------\n\nTITLE: Creating Vuex Store with Vue 3\nDESCRIPTION: Demonstrates the new way to create and initialize a Vuex store using the createStore function introduced in Vuex 4.\nSOURCE: https://github.com/vuejs/vuex/blob/main/CHANGELOG.md#2025-04-22_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport { createStore } from 'vuex'\n\nexport const store = createStore({\n  state() {\n    return {\n      count: 1\n    }\n  }\n})\n```\n\n----------------------------------------\n\nTITLE: Installing Vuex Store in Vue 3 Application\nDESCRIPTION: Shows how to install and initialize a Vuex store in a Vue 3 application using the new installation process.\nSOURCE: https://github.com/vuejs/vuex/blob/main/CHANGELOG.md#2025-04-22_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { createApp } from 'vue'\nimport { store } from './store'\nimport App from './App.vue'\n\nconst app = createApp(App)\n\napp.use(store)\n\napp.mount('#app')\n```"
  }
]