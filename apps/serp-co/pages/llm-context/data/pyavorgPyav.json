[
  {
    "owner": "pyav-org",
    "repo": "pyav",
    "content": "TITLE: Extracting Video Frames with PyAV\nDESCRIPTION: This snippet demonstrates how to open a video file using PyAV, set verbose logging, decode video frames from the first video stream, and save each frame as a JPEG image. It showcases the basic video frame extraction workflow in PyAV.\nSOURCE: https://github.com/pyav-org/pyav/blob/main/docs/index.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport av\n\nav.logging.set_level(av.logging.VERBOSE)\ncontainer = av.open(path_to_video)\n\nfor index, frame in enumerate(container.decode(video=0)):\n    frame.to_image().save(f\"frame-{index:04d}.jpg\")\n```\n\n----------------------------------------\n\nTITLE: Generating Video from Numpy Arrays using PyAV in Python\nDESCRIPTION: This script shows how to generate a video from Numpy arrays using PyAV. It creates a series of frames with changing colors, encodes them into a video file, and adds them to a container for output.\nSOURCE: https://github.com/pyav-org/pyav/blob/main/docs/cookbook/numpy.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport av\nimport numpy as np\n\ncontainer = av.open('output.mp4', mode='w')\n\nstream = container.add_stream('mpeg4', rate=24)\nstream.width = 320\nstream.height = 240\nstream.pix_fmt = 'yuv420p'\n\nfor i in range(100):\n    img = np.empty((240, 320, 3))\n    img[:, :, 0] = 0.5 + 0.5 * np.sin(2 * np.pi * (0 / 3 + i / 100))\n    img[:, :, 1] = 0.5 + 0.5 * np.sin(2 * np.pi * (1 / 3 + i / 100))\n    img[:, :, 2] = 0.5 + 0.5 * np.sin(2 * np.pi * (2 / 3 + i / 100))\n\n    img = np.round(255 * img).astype(np.uint8)\n    frame = av.VideoFrame.from_ndarray(img, format='rgb24')\n    packet = stream.encode(frame)\n    container.mux(packet)\n\n# Flush stream\npacket = stream.encode()\nwhile packet:\n    container.mux(packet)\n    packet = stream.encode()\n\ncontainer.close()\n```\n\n----------------------------------------\n\nTITLE: Creating Video Barcode using PyAV and Numpy in Python\nDESCRIPTION: This script demonstrates how to create a video barcode using PyAV and Numpy. It processes a video file, extracts frames, compresses them vertically, and combines them into a single image representing the color changes over time.\nSOURCE: https://github.com/pyav-org/pyav/blob/main/docs/cookbook/numpy.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport av\nimport numpy as np\nfrom PIL import Image\n\ncontainer = av.open('sunset.mp4')\nvideo = next(s for s in container.streams if s.type == 'video')\n\nframes = []\nfor packet in container.demux(video):\n    for frame in packet.decode():\n        \n        img = frame.to_ndarray(format='rgb24')\n        \n        # Compress down to a 1px width strip\n        img = img.mean(axis=1, dtype=np.uint8)\n        \n        frames.append(img)\n\nframes = np.stack(frames, axis=1)\n\nImage.fromarray(frames).save('barcode.png')\n```\n\n----------------------------------------\n\nTITLE: Applying atempo Filter to Increase Audio Speed in PyAV\nDESCRIPTION: This code demonstrates how to use PyAV's audio filtering capabilities to increase audio playback speed. The example specifically applies the atempo filter to double the speed of an audio track and saves the result to a new file.\nSOURCE: https://github.com/pyav-org/pyav/blob/main/docs/cookbook/audio.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport av\n\n# Open the input file\ninput_file = av.open(\"input.mp3\")\n\n# Create an output file with the same settings\noutput_file = av.open(\"output.mp3\", \"w\")\n\n# Set up the audio filtering\ninput_stream = input_file.streams.audio[0]\noutput_stream = output_file.add_stream(template=input_stream)\n\n# Create the filter graph\ngraph = av.filter.Graph()\n\n# Add the buffer and format filter, which is implicitly connected to the\n# first filter we add next.\nbuffer_filter = graph.add_buffer(template=input_stream)\n\n# Add the atempo filter\natempo_filter = graph.add(\"atempo\", \"2\")\nbuffer_filter.link_to(atempo_filter)\n\n# Add the sink buffer\nbuffer_sink = graph.add(\"abuffersink\")\natempo_filter.link_to(buffer_sink)\n\n# Transcode frames from input to output\nfor frame in input_file.decode(input_stream):\n    graph.push(frame)\n    while True:\n        try:\n            # filtered_frames = graph.pull()\n            for filtered_frame in graph.pull():\n                for packet in output_stream.encode(filtered_frame):\n                    output_file.mux(packet)\n        except av.error.EOFError:\n            break\n\n# Flush the encoder\nfor packet in output_stream.encode(None):\n    output_file.mux(packet)\n\n# Close files\ninput_file.close()\noutput_file.close()\n```\n\n----------------------------------------\n\nTITLE: Creating a VideoFrame in PyAV\nDESCRIPTION: Demonstrates how to instantiate a VideoFrame object with specific dimensions and format. This creates a 1920x1080 RGB24 video frame that can be used for video processing or encoding.\nSOURCE: https://github.com/pyav-org/pyav/blob/main/docs/api/video.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nframe = VideoFrame(1920, 1080, 'rgb24')\n```\n\n----------------------------------------\n\nTITLE: Remuxing Subtitles with PyAV\nDESCRIPTION: Example demonstrating how to copy subtitle streams from one container to another without transcoding, preserving the original quality. The code uses PyAV's remuxing capabilities to transfer subtitle data between containers.\nSOURCE: https://github.com/pyav-org/pyav/blob/main/docs/cookbook/subtitles.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n.. literalinclude:: ../../examples/subtitles/remux.py\n```\n\n----------------------------------------\n\nTITLE: Transcoding Operations in PyAV\nDESCRIPTION: Demonstrates the basic flow of transcoding operations using CodecContext. This includes parsing, encoding, decoding, and flushing buffers.\nSOURCE: https://github.com/pyav-org/pyav/blob/main/docs/api/codec.rst#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nparsed_packets = context.parse(raw_data)\nencoded_packets = context.encode(frames)\ndecoded_frames = context.decode(packets)\ncontext.flush_buffers()\n```\n\n----------------------------------------\n\nTITLE: Creating and Opening a CodecContext in PyAV\nDESCRIPTION: Illustrates the process of creating and opening a CodecContext. This is typically done to prepare for encoding or decoding operations.\nSOURCE: https://github.com/pyav-org/pyav/blob/main/docs/api/codec.rst#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ncontext = CodecContext.create('h264')\ncontext.open()\n```\n\n----------------------------------------\n\nTITLE: Accessing Packet and Frame Timestamps in PyAV\nDESCRIPTION: Illustrates how to retrieve a packet and frame from a video file, and access their timestamps and time bases. Both packet and frame use the stream's time base by default.\nSOURCE: https://github.com/pyav-org/pyav/blob/main/docs/api/time.rst#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n>>> p, f = get_nth_packet_and_frame(fh, skip=1)\n\n>>> p.time_base\nFraction(1, 25)\n>>> p.dts\n1\n\n>>> f.time_base\nFraction(1, 25)\n>>> f.pts\n1\n```\n\n----------------------------------------\n\nTITLE: Using Container as Context Manager in PyAV\nDESCRIPTION: Demonstrates the recommended approach for handling PyAV containers to avoid garbage collection issues. Using the context manager pattern ensures proper closure of the container, which helps prevent memory leaks that can occur due to reference cycles in PyAV.\nSOURCE: https://github.com/pyav-org/pyav/blob/main/docs/overview/caveats.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nwith av.open(path) as container:\n    # Do stuff with it.\n```\n\n----------------------------------------\n\nTITLE: Container Class Definition in Python\nDESCRIPTION: Base container class with attributes for metadata handling and timeout configuration.\nSOURCE: https://github.com/pyav-org/pyav/blob/main/docs/api/container.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nclass Container:\n    options\n    container_options\n    stream_options\n    metadata_encoding\n    metadata_errors\n    open_timeout\n    read_timeout\n```\n\n----------------------------------------\n\nTITLE: Container Format Definition in Python\nDESCRIPTION: Class that defines the format capabilities and properties of media containers.\nSOURCE: https://github.com/pyav-org/pyav/blob/main/docs/api/container.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nclass ContainerFormat:\n    name\n    long_name\n    options\n    input\n    output\n    is_input\n    is_output\n    extensions\n    flags\n```\n\n----------------------------------------\n\nTITLE: Creating a Codec Instance in PyAV\nDESCRIPTION: Demonstrates how to create a Codec instance using the create method. This is typically used to initialize a specific codec for encoding or decoding.\nSOURCE: https://github.com/pyav-org/pyav/blob/main/docs/api/codec.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ncodec = Codec.create(name='h264')\n```\n\n----------------------------------------\n\nTITLE: Accessing Stream Time Base in PyAV\nDESCRIPTION: Demonstrates how to open a video file, access the video stream, and retrieve its time base. The time base is represented as a Fraction object.\nSOURCE: https://github.com/pyav-org/pyav/blob/main/docs/api/time.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n>>> fh = av.open(path)\n>>> video = fh.streams.video[0]\n\n>>> video.time_base\nFraction(1, 25)\n```\n\n----------------------------------------\n\nTITLE: Calculating Duration in Seconds using Time Base\nDESCRIPTION: Shows how to calculate the duration of a video in seconds by multiplying the duration attribute with the time base.\nSOURCE: https://github.com/pyav-org/pyav/blob/main/docs/api/time.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n>>> video.duration\n168\n>>> float(video.duration * video.time_base)\n6.72\n```\n\n----------------------------------------\n\nTITLE: Accessing Frame Time in Seconds\nDESCRIPTION: Demonstrates how to access the frame's time attribute, which provides the timestamp in seconds as a float value for convenience.\nSOURCE: https://github.com/pyav-org/pyav/blob/main/docs/api/time.rst#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n>>> f.time\n0.04\n```\n\n----------------------------------------\n\nTITLE: Error Handling Example in PyAV\nDESCRIPTION: Example showing how to catch a specific FFmpeg-related error in PyAV using try-except block. The code demonstrates catching a FilterNotFoundError exception that could occur during FFmpeg operations.\nSOURCE: https://github.com/pyav-org/pyav/blob/main/docs/api/error.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ntry:\n    do_something()\nexcept av.FilterNotFoundError:\n    handle_error()\n```\n\n----------------------------------------\n\nTITLE: Importing CodecContext in PyAV\nDESCRIPTION: Shows how to import the CodecContext class from the av.codec.context module. CodecContext is used for configuring and managing codec operations.\nSOURCE: https://github.com/pyav-org/pyav/blob/main/docs/api/codec.rst#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom av.codec.context import CodecContext\n```\n\n----------------------------------------\n\nTITLE: Importing Codec Module in PyAV\nDESCRIPTION: Shows how to import the codec module in PyAV. This module provides access to codec-related functionality.\nSOURCE: https://github.com/pyav-org/pyav/blob/main/docs/api/codec.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom av.codec import Codec\n```\n\n----------------------------------------\n\nTITLE: Installing PyAV via pip\nDESCRIPTION: Installing PyAV binary wheels from PyPI using pip. This method works for Linux, MacOS and Windows and links against the latest stable version of ffmpeg.\nSOURCE: https://github.com/pyav-org/pyav/blob/main/README.md#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\npip install av\n```\n\n----------------------------------------\n\nTITLE: Installing PyAV using pip with binary wheels\nDESCRIPTION: The simplest way to install PyAV using pip, which will download pre-compiled binary wheels linked against FFmpeg for Linux, MacOS, and Windows.\nSOURCE: https://github.com/pyav-org/pyav/blob/main/docs/overview/installation.rst#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\npip install av\n```\n\n----------------------------------------\n\nTITLE: Installing PyAV via conda-forge\nDESCRIPTION: Alternative installation method using conda package manager from the conda-forge channel.\nSOURCE: https://github.com/pyav-org/pyav/blob/main/README.md#2025-04-22_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nconda install av -c conda-forge\n```\n\n----------------------------------------\n\nTITLE: Installing PyAV from source via pip\nDESCRIPTION: Installing PyAV from source using pip, requires existing ffmpeg installation of correct major version. Must be run in a POSIX environment.\nSOURCE: https://github.com/pyav-org/pyav/blob/main/README.md#2025-04-22_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\npip install av --no-binary av\n```\n\n----------------------------------------\n\nTITLE: Building PyAV from source\nDESCRIPTION: Complete process for building PyAV from source code, including cloning repository, building dependencies, testing and installation. Requires MSYS2 on Windows.\nSOURCE: https://github.com/pyav-org/pyav/blob/main/README.md#2025-04-22_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/PyAV-Org/PyAV.git\ncd PyAV\nsource scripts/activate.sh\n\n# Build ffmpeg from source. You can skip this step\n# if ffmpeg is already installed.\n./scripts/build-deps\n\n# Build PyAV\nmake\n\n# Testing\nmake test\n\n# Install globally\ndeactivate\npip install .\n```\n\n----------------------------------------\n\nTITLE: Installing PyAV from source with your own FFmpeg\nDESCRIPTION: Command to force installing PyAV from source instead of using binary wheels. This is useful when you want to use your own build of FFmpeg (version 7.0 or higher).\nSOURCE: https://github.com/pyav-org/pyav/blob/main/docs/overview/installation.rst#2025-04-22_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\npip install av --no-binary av\n```\n\n----------------------------------------\n\nTITLE: Building PyAV from the latest source on GitHub\nDESCRIPTION: A sequence of commands to clone the PyAV repository, set up a virtual environment, optionally build FFmpeg dependencies, and build PyAV from source.\nSOURCE: https://github.com/pyav-org/pyav/blob/main/docs/overview/installation.rst#2025-04-22_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n# Get PyAV from GitHub.\ngit clone https://github.com/PyAV-Org/PyAV.git\ncd PyAV\n\n# Prep a virtualenv.\nsource scripts/activate.sh\n\n# Optionally build FFmpeg.\n./scripts/build-deps\n\n# Build PyAV.\nmake\n```\n\n----------------------------------------\n\nTITLE: Documenting av.open Function in PyAV\nDESCRIPTION: This snippet uses the autofunction directive to generate documentation for the av.open function from the PyAV library. The av.open function is likely used to open media files or streams for processing with PyAV.\nSOURCE: https://github.com/pyav-org/pyav/blob/main/docs/api/_globals.rst#2025-04-22_snippet_0\n\nLANGUAGE: restructuredtext\nCODE:\n```\n.. autofunction:: av.open\n```\n\n----------------------------------------\n\nTITLE: Documenting PyAV Frame Class with reStructuredText\nDESCRIPTION: This snippet defines the documentation structure for the Frame class in the av.frame module. It uses Sphinx automodule and autoclass directives to automatically generate API documentation from the source code.\nSOURCE: https://github.com/pyav-org/pyav/blob/main/docs/api/frame.rst#2025-04-22_snippet_0\n\nLANGUAGE: reStructuredText\nCODE:\n```\nFrames\n======\n\n.. automodule:: av.frame\n\n    .. autoclass:: Frame\n        :members:\n```\n\n----------------------------------------\n\nTITLE: ReStructuredText Documentation for PyAV Subtitles Module\nDESCRIPTION: Sphinx documentation structure for PyAV's subtitle-related classes and modules, including SubtitleStream, SubtitleSet, and various subtitle type implementations.\nSOURCE: https://github.com/pyav-org/pyav/blob/main/docs/api/subtitles.rst#2025-04-22_snippet_0\n\nLANGUAGE: restructuredtext\nCODE:\n```\nSubtitles\n===========\n\n.. automodule:: av.subtitles.stream\n\n    .. autoclass:: SubtitleStream\n        :members:\n\n.. automodule:: av.subtitles.subtitle\n\n    .. autoclass:: SubtitleSet\n        :members:\n\n    .. autoclass:: Subtitle\n        :members:\n\n    .. autoclass:: AssSubtitle\n        :members:\n\n    .. autoclass:: BitmapSubtitle\n        :members:\n\n    .. autoclass:: BitmapSubtitlePlane\n        :members:\n```\n\n----------------------------------------\n\nTITLE: PyAV Filter Module Documentation Structure in RST\nDESCRIPTION: RST documentation structure defining the auto-documentation configuration for PyAV's filter system components including Filter, Graph, FilterContext, FilterLink, FilterPad and FilterContextPad classes.\nSOURCE: https://github.com/pyav-org/pyav/blob/main/docs/api/filter.rst#2025-04-22_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n.. automodule:: av.filter.filter\n\n    .. autoclass:: Filter\n        :members:\n\n\n.. automodule:: av.filter.graph\n\n    .. autoclass:: Graph\n        :members:\n\n\n.. automodule:: av.filter.context\n\n    .. autoclass:: FilterContext\n        :members:\n\n\n.. automodule:: av.filter.link\n\n    .. autoclass:: FilterLink\n        :members:\n\n\n.. automodule:: av.filter.pad\n\n    .. autoclass:: FilterPad\n        :members:\n\n    .. autoclass:: FilterContextPad\n        :members:\n```\n\n----------------------------------------\n\nTITLE: Documenting Buffer Class in PyAV using reStructuredText\nDESCRIPTION: This snippet uses reStructuredText directives to automatically generate documentation for the Buffer class in the av.buffer module of PyAV. It includes all members of the class in the documentation.\nSOURCE: https://github.com/pyav-org/pyav/blob/main/docs/api/buffer.rst#2025-04-22_snippet_0\n\nLANGUAGE: reStructuredText\nCODE:\n```\nBuffers\n=======\n\n.. automodule:: av.buffer\n\n    .. autoclass:: Buffer\n        :members:\n```\n\n----------------------------------------\n\nTITLE: Structuring Sphinx Documentation for PyAV Planes Module\nDESCRIPTION: RST markup for generating documentation for the av.plane module and Plane class in PyAV using Sphinx's automodule and autoclass directives. This setup automatically pulls docstrings from the codebase to create API documentation.\nSOURCE: https://github.com/pyav-org/pyav/blob/main/docs/api/plane.rst#2025-04-22_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\nPlanes\n======\n\n.. automodule:: av.plane\n\n    .. autoclass:: Plane\n        :members:\n```\n\n----------------------------------------\n\nTITLE: Defining Sphinx Documentation for PyAV Packet Module in RST\nDESCRIPTION: This RST snippet defines the documentation structure for the av.packet module in PyAV. It uses Sphinx automodule and autoclass directives to automatically generate documentation for the Packet class and its members.\nSOURCE: https://github.com/pyav-org/pyav/blob/main/docs/api/packet.rst#2025-04-22_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\nPackets\n=======\n\n.. automodule:: av.packet\n\n    .. autoclass:: Packet\n        :members:\n```\n\n----------------------------------------\n\nTITLE: Configuring Sphinx AutoDoc for PyAV AttachmentStream Class in RST\nDESCRIPTION: This RST code snippet configures Sphinx autodoc to generate documentation for the AttachmentStream class from the av.attachments.stream module. It includes directives to document the module and the class with all its members.\nSOURCE: https://github.com/pyav-org/pyav/blob/main/docs/api/attachments.rst#2025-04-22_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n.. automodule:: av.attachments.stream\n\n    .. autoclass:: AttachmentStream\n        :members:\n```\n\n----------------------------------------\n\nTITLE: Defining reStructuredText Documentation for PyAV Bitstream Module\nDESCRIPTION: A reStructuredText documentation template that defines how the bitstream module and BitStreamFilterContext class should be documented in the generated documentation. This uses the Sphinx autodoc extension to automatically extract documentation from the Python module.\nSOURCE: https://github.com/pyav-org/pyav/blob/main/docs/api/bitstream.rst#2025-04-22_snippet_0\n\nLANGUAGE: restructuredtext\nCODE:\n```\nBitstream Filters\n=================\n\n.. automodule:: av.bitstream\n\n    .. autoclass:: BitStreamFilterContext\n        :members:\n```\n\n----------------------------------------\n\nTITLE: RST Documentation for Side Data Module\nDESCRIPTION: ReStructuredText documentation for PyAV's side data module, including SideData class and Type enum documentation.\nSOURCE: https://github.com/pyav-org/pyav/blob/main/docs/api/sidedata.rst#2025-04-22_snippet_0\n\nLANGUAGE: restructuredtext\nCODE:\n```\nSide Data\n=========\n\n.. automodule:: av.sidedata.sidedata\n\n    .. autoclass:: SideData\n        :members:\n\n.. autoclass:: av.sidedata.sidedata.Type\n.. enumtable:: av.sidedata.sidedata.Type\n```\n\n----------------------------------------\n\nTITLE: RST Documentation for Motion Vectors Module\nDESCRIPTION: ReStructuredText documentation for PyAV's motion vectors module, including the MotionVectors class documentation.\nSOURCE: https://github.com/pyav-org/pyav/blob/main/docs/api/sidedata.rst#2025-04-22_snippet_1\n\nLANGUAGE: restructuredtext\nCODE:\n```\nMotion Vectors\n--------------\n\n.. automodule:: av.sidedata.motionvectors\n\n    .. autoclass:: MotionVectors\n        :members:\n```\n\n----------------------------------------\n\nTITLE: Documenting PyAV Logging Module with Sphinx\nDESCRIPTION: Uses Sphinx's automodule directive to automatically generate documentation for the av.logging module, including all members (functions, classes, and variables).\nSOURCE: https://github.com/pyav-org/pyav/blob/main/docs/api/utils.rst#2025-04-22_snippet_0\n\nLANGUAGE: restructuredtext\nCODE:\n```\n.. automodule:: av.logging\n    :members:\n```\n\n----------------------------------------\n\nTITLE: Documenting PyAV Utilities Module with Sphinx\nDESCRIPTION: Uses Sphinx's automodule directive to automatically generate documentation for the av.utils module, including all members (functions, classes, and variables).\nSOURCE: https://github.com/pyav-org/pyav/blob/main/docs/api/utils.rst#2025-04-22_snippet_1\n\nLANGUAGE: restructuredtext\nCODE:\n```\n.. automodule:: av.utils\n    :members:\n```\n\n----------------------------------------\n\nTITLE: Including AUTHORS.rst File in reStructuredText\nDESCRIPTION: This snippet uses the reStructuredText 'include' directive to incorporate the content of the AUTHORS.rst file from two directory levels up. This is commonly used to maintain a single source of contributor information that can be included in multiple documentation files.\nSOURCE: https://github.com/pyav-org/pyav/blob/main/docs/development/contributors.rst#2025-04-22_snippet_0\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. include:: ../../AUTHORS.rst\n```\n\n----------------------------------------\n\nTITLE: Including CHANGELOG.rst in PyAV Documentation\nDESCRIPTION: This snippet uses the reStructuredText 'include' directive to insert the contents of the CHANGELOG.rst file from the root of the repository into the current document. It also defines a reference label for the changelog section.\nSOURCE: https://github.com/pyav-org/pyav/blob/main/docs/development/changelog.rst#2025-04-22_snippet_0\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. _changelog:\n\n.. include:: ../../CHANGELOG.rst\n```\n\n----------------------------------------\n\nTITLE: Including LICENSE.txt in Sphinx Documentation using literalinclude\nDESCRIPTION: Uses Sphinx's literalinclude directive to embed the contents of the project's LICENSE.txt file into the documentation. The directive specifies that the included content should be treated as plain text.\nSOURCE: https://github.com/pyav-org/pyav/blob/main/docs/development/license.rst#2025-04-22_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n.. literalinclude:: ../../LICENSE.txt\n    :language: text\n```"
  }
]